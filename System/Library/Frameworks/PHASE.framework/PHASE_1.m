void sub_221EE4A80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::recursive_mutex *a12)
{
  std::recursive_mutex::unlock(a12);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::SubmixSystem::SetAudioSessionLevel(uint64_t a1, int a2, uint64_t a3, char a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if ((a4 & 1) == 0) {
    std::terminate();
  }
  v7 = (std::recursive_mutex *)(a1 + 80);
  std::recursive_mutex::lock((std::recursive_mutex *)(a1 + 80));
  v8 = *(void **)(a1 + 56);
  if (v8)
  {
    uint64_t v9 = 0;
    do
    {
      v10 = (Phase::Logger *)v8[4];
      if (!v10)
      {
        v16 = **(id **)(Phase::Logger::GetInstance(0) + 384);
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          int v18 = 136315394;
          v19 = "CvmSubmixSystem.mm";
          __int16 v20 = 1024;
          int v21 = 613;
          _os_log_impl(&dword_221E5E000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pSubmix != nullptr is false.", (uint8_t *)&v18, 0x12u);
        }
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "PRECONDITION: pSubmix != nullptr is false.");
      }
      if (*((_DWORD *)v10 + 12) == a2)
      {
        v10 = (Phase::Logger *)(*(uint64_t (**)(Phase::Logger *, uint64_t, uint64_t))(*(void *)v10 + 232))(v10, a3, 1);
        ++v9;
      }
      v8 = (void *)*v8;
    }
    while (v8);
    if (v9)
    {
      v11 = **(id **)(Phase::Logger::GetInstance(v10) + 384);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        double v12 = *(float *)a3;
        BOOL v13 = *(unsigned char *)(a3 + 4) == 0;
        int v18 = 136316674;
        v19 = "CvmSubmixSystem.mm";
        if (v13) {
          v14 = "NO";
        }
        else {
          v14 = "YES";
        }
        __int16 v20 = 1024;
        int v21 = 625;
        __int16 v22 = 2048;
        uint64_t v23 = a1;
        __int16 v24 = 2048;
        uint64_t v25 = v9;
        __int16 v26 = 1024;
        int v27 = a2;
        __int16 v28 = 2048;
        double v29 = v12;
        __int16 v30 = 2080;
        v31 = v14;
        _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: Setting %zu submixes belonging to session 0x%x to %f - muted: %s", (uint8_t *)&v18, 0x40u);
      }
    }
  }
  else
  {
    uint64_t v9 = 0;
  }
  std::recursive_mutex::unlock(v7);
  return v9;
}

void sub_221EE4D1C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  std::recursive_mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::SubmixSystem::SetAudioSessionLevelInVolumeCategoryAndMode(Phase::Controller::SubmixSystem *this, NSString *a2, NSString *a3, char a4)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  v7 = a2;
  v8 = a3;
  if ((a4 & 1) == 0) {
    std::terminate();
  }
  uint64_t v9 = v8;
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 80));
  memset(v30, 0, sizeof(v30));
  int v31 = 1065353216;
  memset(v28, 0, sizeof(v28));
  int v29 = 1065353216;
  v11 = (void *)*((void *)this + 7);
  if (!v11)
  {
    uint64_t v12 = 0;
    goto LABEL_24;
  }
  uint64_t v12 = 0;
  do
  {
    BOOL v13 = (unsigned int *)v11[4];
    if (!v13)
    {
      __int16 v24 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v10) + 384);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&buf[4] = "CvmSubmixSystem.mm";
        __int16 v33 = 1024;
        int v34 = 656;
        _os_log_impl(&dword_221E5E000, v24, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pSubmix != nullptr is false.", buf, 0x12u);
      }
      exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::logic_error::logic_error(exception, "PRECONDITION: pSubmix != nullptr is false.");
    }
    uint64_t v14 = v13[12];
    v15 = std::__hash_table<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>>>::find<unsigned int>(*(uint64_t *)&v30[0], *((unint64_t *)&v30[0] + 1), v13[12]);
    v10 = std::__hash_table<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>>>::find<unsigned int>(*(uint64_t *)&v28[0], *((unint64_t *)&v28[0] + 1), v14);
    if (v15) {
      goto LABEL_6;
    }
    if (v10) {
      goto LABEL_9;
    }
    unint64_t AudioSessionVolumeIfInVolumeCategoryAndMode = Phase::Controller::SessionManager::GetAudioSessionVolumeIfInVolumeCategoryAndMode(*((Phase::Controller::SessionManager **)this + 35), v14, v7, v9, 1);
    unint64_t v26 = AudioSessionVolumeIfInVolumeCategoryAndMode;
    int v27 = v17;
    if (!(_BYTE)v17)
    {
      v10 = std::__hash_table<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>>>::__emplace_unique_key_args<unsigned int,unsigned int const&,std::optional<Phase::Controller::SessionManager::SessionVolume>&>((float *)v28, v14, v14, (uint64_t)&v26);
      goto LABEL_9;
    }
    v15 = std::__hash_table<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>>>::__emplace_unique_key_args<unsigned int,unsigned int const&,std::optional<Phase::Controller::SessionManager::SessionVolume>&>((float *)v30, v14, v14, (uint64_t)&v26);
    int v18 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)v15)
                                                                                        + 384)));
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136316418;
      *(void *)&buf[4] = "CvmSubmixSystem.mm";
      v19 = "YES";
      if ((AudioSessionVolumeIfInVolumeCategoryAndMode & 0xFF00000000) == 0) {
        v19 = "NO";
      }
      __int16 v33 = 1024;
      int v34 = 689;
      __int16 v35 = 2048;
      v36 = this;
      __int16 v37 = 1024;
      *(_DWORD *)v38 = v14;
      *(_WORD *)&v38[4] = 2048;
      *(double *)&v38[6] = *(float *)&AudioSessionVolumeIfInVolumeCategoryAndMode;
      *(_WORD *)&v38[14] = 2080;
      *(void *)&v38[16] = v19;
      _os_log_impl(&dword_221E5E000, v18, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: session 0x%x volume: queried %f, muted %s", buf, 0x36u);
    }

    if (v15)
    {
LABEL_6:
      if (!*((unsigned char *)v15 + 28)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      *(void *)buf = *(uint64_t *)((char *)v15 + 20);
      v10 = (uint64_t *)(*(uint64_t (**)(unsigned int *, unsigned char *, uint64_t))(*(void *)v13 + 232))(v13, buf, 1);
      ++v12;
    }
LABEL_9:
    v11 = (void *)*v11;
  }
  while (v11);
  if (v12)
  {
    __int16 v20 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)v10)
                                                                                        + 384)));
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v21 = [(NSString *)v7 UTF8String];
      uint64_t v22 = [(NSString *)v9 UTF8String];
      *(_DWORD *)buf = 136316418;
      *(void *)&buf[4] = "CvmSubmixSystem.mm";
      __int16 v33 = 1024;
      int v34 = 710;
      __int16 v35 = 2048;
      v36 = this;
      __int16 v37 = 2048;
      *(void *)v38 = v12;
      *(_WORD *)&v38[8] = 2080;
      *(void *)&v38[10] = v21;
      *(_WORD *)&v38[18] = 2080;
      *(void *)&v38[20] = v22;
      _os_log_impl(&dword_221E5E000, v20, OS_LOG_TYPE_DEBUG, "%25s:%-5d impl@%p: Set volume on %zu submixes belonging to category/mode [%s, %s]", buf, 0x3Au);
    }
  }
LABEL_24:
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v28);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v30);
  std::recursive_mutex::unlock((std::recursive_mutex *)((char *)this + 80));

  return v12;
}

void sub_221EE515C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::recursive_mutex *a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&a15);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&a21);
  std::recursive_mutex::unlock(a12);

  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::SubmixSystem::SetAudioSessionLevelOnAllSessions(Phase::Controller::SubmixSystem *this, char a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  if ((a2 & 1) == 0) {
    std::terminate();
  }
  v3 = (std::recursive_mutex *)((char *)this + 80);
  std::recursive_mutex::lock((std::recursive_mutex *)((char *)this + 80));
  long long v22 = 0u;
  long long v23 = 0u;
  int v24 = 1065353216;
  v5 = (void *)*((void *)this + 7);
  if (v5)
  {
    uint64_t v6 = 0;
    do
    {
      v7 = (unsigned int *)v5[4];
      if (!v7)
      {
        int v18 = **(id **)(Phase::Logger::GetInstance(v4) + 384);
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&buf[4] = "CvmSubmixSystem.mm";
          __int16 v26 = 1024;
          int v27 = 731;
          _os_log_impl(&dword_221E5E000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pSubmix != nullptr is false.", buf, 0x12u);
        }
        exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "PRECONDITION: pSubmix != nullptr is false.");
      }
      uint64_t v8 = v7[12];
      uint64_t v9 = std::__hash_table<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>>>::find<unsigned int>(v22, *((unint64_t *)&v22 + 1), v7[12]);
      if (v9) {
        goto LABEL_15;
      }
      AudioSessionVolume = (Phase::Logger *)Phase::Controller::SessionManager::GetAudioSessionVolume(*((Phase::Controller::SessionManager **)this + 35), v8, 1);
      v11 = AudioSessionVolume;
      __int16 v20 = AudioSessionVolume;
      int v21 = v12;
      if ((_BYTE)v12)
      {
        uint64_t v9 = std::__hash_table<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>>>::__emplace_unique_key_args<unsigned int,unsigned int const&,std::optional<Phase::Controller::SessionManager::SessionVolume>&>((float *)&v22, v8, v8, (uint64_t)&v20);
        BOOL v13 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)v9)
                                                                                            + 384)));
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136316418;
          *(void *)&buf[4] = "CvmSubmixSystem.mm";
          uint64_t v14 = "YES";
          if (((unint64_t)v11 & 0xFF00000000) == 0) {
            uint64_t v14 = "NO";
          }
          __int16 v26 = 1024;
          int v27 = 759;
          __int16 v28 = 2048;
          int v29 = this;
          __int16 v30 = 1024;
          *(_DWORD *)int v31 = v8;
          *(_WORD *)&v31[4] = 2048;
          *(double *)&v31[6] = *(float *)&v11;
          *(_WORD *)&v31[14] = 2080;
          *(void *)&v31[16] = v14;
          _os_log_impl(&dword_221E5E000, v13, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: session 0x%x volume: queried %f muted: %s", buf, 0x36u);
        }
      }
      else
      {
        v15 = **(id **)(Phase::Logger::GetInstance(AudioSessionVolume) + 384);
        v4 = (Phase::Logger *)os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
        if (v4)
        {
          *(_DWORD *)buf = 136315906;
          *(void *)&buf[4] = "CvmSubmixSystem.mm";
          __int16 v26 = 1024;
          int v27 = 764;
          __int16 v28 = 2048;
          int v29 = this;
          __int16 v30 = 1024;
          *(_DWORD *)int v31 = v8;
          _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d impl@%p: error: could not get volume for session 0x%x", buf, 0x22u);
        }
      }
      if (v9)
      {
LABEL_15:
        if (!*((unsigned char *)v9 + 28)) {
          std::__throw_bad_optional_access[abi:ne180100]();
        }
        *(void *)buf = *(uint64_t *)((char *)v9 + 20);
        v4 = (Phase::Logger *)(*(uint64_t (**)(unsigned int *, unsigned char *, uint64_t))(*(void *)v7 + 232))(v7, buf, 1);
        ++v6;
      }
      v5 = (void *)*v5;
    }
    while (v5);
    if (v6)
    {
      v16 = **(id **)(Phase::Logger::GetInstance(v4) + 384);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136316162;
        *(void *)&buf[4] = "CvmSubmixSystem.mm";
        __int16 v26 = 1024;
        int v27 = 780;
        __int16 v28 = 2048;
        int v29 = this;
        __int16 v30 = 2048;
        *(void *)int v31 = v6;
        *(_WORD *)&v31[8] = 2048;
        *(void *)&v31[10] = *((void *)&v23 + 1);
        _os_log_impl(&dword_221E5E000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d impl@%p: Set volume on %zu submixes, %zu sessions", buf, 0x30u);
      }
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&v22);
  std::recursive_mutex::unlock(v3);
  return v6;
}

void sub_221EE55D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::recursive_mutex *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t *Phase::Controller::SubmixSystem::GetSubmixesForSource(uint64_t *result, uint64_t *a2, uint64_t **a3)
{
  for (uint64_t i = result[7]; i; uint64_t i = *(void *)i)
  {
    result = (uint64_t *)(*(uint64_t (**)(void))(**(void **)(i + 32) + 192))(*(void *)(i + 32));
    if (result == a2) {
      result = std::__tree<Phase::UniqueObjectId>::__emplace_unique_key_args<Phase::UniqueObjectId,Phase::UniqueObjectId const&>(a3, (unint64_t *)(i + 16), (_OWORD *)(i + 16));
    }
  }
  return result;
}

double Phase::Controller::SubmixSystem::GetStats@<D0>(Phase::Controller::RendererSystem **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = 0;
  v16[1] = *MEMORY[0x263EF8340];
  v16[0] = 0x706050403020100;
  do
  {
    int v5 = *((char *)v16 + v4);
    *(_DWORD *)(a2 + 4 * v5) = Phase::Controller::SubmixSystem::GetSubmixCount((Phase::Logger *)this, 1, *((unsigned char *)v16 + v4));
    *(_DWORD *)(a2 + 32 + 4 * v5) = Phase::Controller::SubmixSystem::GetSubmixCount((Phase::Logger *)this, 2, v5);
    *(_DWORD *)(a2 + 64 + 4 * v5) = Phase::Controller::SubmixSystem::GetSubmixCount((Phase::Logger *)this, 3, v5);
    ++v4;
  }
  while (v4 != 8);
  uint64_t v6 = 0;
  v7 = this[7];
  do
  {
    uint64_t v8 = __const__ZNK5Phase10Controller12SubmixSystem8GetStatsEv_generatorStates[v6];
    int v9 = 0;
    if (v7)
    {
      v10 = v7;
      do
      {
        v11 = *(void **)(*((void *)v10 + 4) + 264);
        if (v11)
        {
          int v12 = 0;
          do
          {
            if (*(_DWORD *)(v11[4] + 376) == v8) {
              ++v12;
            }
            v11 = (void *)*v11;
          }
          while (v11);
        }
        else
        {
          int v12 = 0;
        }
        v9 += v12;
        v10 = *(Phase::Controller::RendererSystem **)v10;
      }
      while (v10);
    }
    *(_DWORD *)(a2 + 96 + 4 * v8) = v9;
    ++v6;
  }
  while (v6 != 8);
  Phase::Controller::RendererSystem::GetStats(this[34], (uint64_t)v15);
  double result = *(double *)v15;
  long long v14 = v15[1];
  *(_OWORD *)(a2 + 116) = v15[0];
  *(_OWORD *)(a2 + 132) = v14;
  return result;
}

uint64_t Phase::Controller::SubmixSystem::GetSubmixCount(Phase::Logger *a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    uint64_t v8 = **(id **)(Phase::Logger::GetInstance(a1) + 384);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v10 = 136315650;
      v11 = "CvmSubmixSystem.mm";
      __int16 v12 = 1024;
      int v13 = 868;
      __int16 v14 = 2048;
      v15 = a1;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d impl@%p: error: requesting submix count for mixer type 'unknown'. Returning 0", (uint8_t *)&v10, 0x1Cu);
    }
    return 0;
  }
  uint64_t v4 = (void *)*((void *)a1 + 7);
  if (!v4) {
    return 0;
  }
  uint64_t v6 = 0;
  int v7 = a3;
  do
  {
    if ((*(uint64_t (**)(void))(*(void *)v4[4] + 336))(v4[4]) == a2)
    {
      if (*(unsigned __int8 *)(v4[4] + 72) == v7) {
        uint64_t v6 = (v6 + 1);
      }
      else {
        uint64_t v6 = v6;
      }
    }
    uint64_t v4 = (void *)*v4;
  }
  while (v4);
  return v6;
}

void Phase::LambdaFunction<Phase::Controller::SubmixSystem::ActivateAudioSession(unsigned int,BOOL,BOOL)::$_0::operator() const(void)::{lambda(void)#1},void>::~LambdaFunction()
{
}

void *Phase::LambdaFunction<Phase::Controller::SubmixSystem::ActivateAudioSession(unsigned int,BOOL,BOOL)::$_0::operator() const(void)::{lambda(void)#1},void>::operator()(uint64_t a1)
{
  v2 = *(Phase::Logger **)(a1 + 8);
  long long v7 = *(_OWORD *)(a1 + 24);
  double result = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)v2 + 5, &v7);
  if (result)
  {
    Submix = (void *)Phase::Controller::SubmixSystem::GetSubmix(v2, *(void *)(a1 + 24), *(void *)(a1 + 32));
    int v5 = Submix;
    uint64_t v6 = *Submix;
    if (*(unsigned char *)(a1 + 40))
    {
      (*(void (**)(void *))(v6 + 56))(Submix);
      return (void *)(*(uint64_t (**)(void *, float, float))(*v5 + 224))(v5, *(float *)(a1 + 16), *(float *)(a1 + 20));
    }
    else
    {
      return (void *)(*(uint64_t (**)(void *))(v6 + 48))(Submix);
    }
  }
  return result;
}

void Phase::LambdaFunction<Phase::Controller::SubmixSystem::FadeAudioSession(unsigned int,float,float,BOOL)::$_0::operator() const(void)::{lambda(void)#1},void>::~LambdaFunction()
{
}

void *Phase::LambdaFunction<Phase::Controller::SubmixSystem::FadeAudioSession(unsigned int,float,float,BOOL)::$_0::operator() const(void)::{lambda(void)#1},void>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  long long v5 = *(_OWORD *)(a1 + 16);
  double result = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(v2 + 40), &v5);
  if (result)
  {
    uint64_t Submix = Phase::Controller::SubmixSystem::GetSubmix(*(Phase::Logger **)(a1 + 8), *(void *)(a1 + 16), *(void *)(a1 + 24));
    return (void *)(*(uint64_t (**)(uint64_t, float, float))(*(void *)Submix + 224))(Submix, *(float *)(a1 + 32), *(float *)(a1 + 36));
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      v3 = (void *)*v2;
      uint64_t v4 = v2[4];
      v2[4] = 0;
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::Submix>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = __p[4];
    __p[4] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

Phase::Controller::SpatialSubmix *std::unique_ptr<Phase::Controller::SpatialSubmix>::reset[abi:ne180100](Phase::Controller::SpatialSubmix **a1)
{
  double result = *a1;
  *a1 = 0;
  if (result)
  {
    Phase::Controller::SpatialSubmix::~SpatialSubmix(result);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

Phase::Controller::ChannelSubmix *std::unique_ptr<Phase::Controller::ChannelSubmix>::reset[abi:ne180100](Phase::Controller::ChannelSubmix **a1)
{
  double result = *a1;
  *a1 = 0;
  if (result)
  {
    Phase::Controller::ChannelSubmix::~ChannelSubmix(result);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

Phase::Controller::AmbientSubmix *std::unique_ptr<Phase::Controller::AmbientSubmix>::reset[abi:ne180100](Phase::Controller::AmbientSubmix **a1)
{
  double result = *a1;
  *a1 = 0;
  if (result)
  {
    Phase::Controller::AmbientSubmix::~AmbientSubmix(result);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>>>::__emplace_unique_key_args<Phase::UniqueObjectId,std::pair<Phase::UniqueObjectId,Phase::UniqueObjectId>>(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v6 = 0;
  unint64_t v7 = 0xCBF29CE484222325;
  do
    unint64_t v7 = 0x100000001B3 * (v7 ^ *((char *)a2 + v6++));
  while (v6 != 16);
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
    int v10 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == *a2 && v11[3] == a2[1]) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v3) {
              break;
            }
          }
          v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x30uLL);
  void *v11 = 0;
  v11[1] = v7;
  long long v14 = a3[1];
  *((_OWORD *)v11 + 1) = *a3;
  *((_OWORD *)v11 + 2) = v14;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
      else {
        unint64_t v3 = v7;
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
    }
  }
  uint64_t v21 = *(void *)a1;
  long long v22 = *(void **)(*(void *)a1 + 8 * v3);
  if (v22)
  {
    void *v11 = *v22;
LABEL_44:
    *long long v22 = v11;
    goto LABEL_45;
  }
  void *v11 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v11;
  *(void *)(v21 + 8 * v3) = a1 + 16;
  if (*v11)
  {
    unint64_t v23 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v23 >= v8) {
        v23 %= v8;
      }
    }
    else
    {
      v23 &= v8 - 1;
    }
    long long v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return v11;
}

void sub_221EE5F7C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>>>::__emplace_unique_key_args<Phase::UniqueObjectId,std::piecewise_construct_t const&,std::tuple<Phase::UniqueObjectId const&>,std::tuple<>>(uint64_t a1, void *a2, uint64_t a3, _OWORD **a4)
{
  uint64_t v7 = 0;
  unint64_t v8 = 0xCBF29CE484222325;
  do
    unint64_t v8 = 0x100000001B3 * (v8 ^ *((char *)a2 + v7++));
  while (v7 != 16);
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = v8;
      if (v8 >= v9) {
        unint64_t v4 = v8 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
    v11 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (uint64_t i = *v11; i; uint64_t i = (void *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == v8)
        {
          if (i[2] == *a2 && i[3] == a2[1]) {
            return i;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x30uLL);
  *uint64_t i = 0;
  i[1] = v8;
  *((_OWORD *)i + 1) = **a4;
  i[4] = 0;
  i[5] = 0;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v17 = 1;
    if (v9 >= 3) {
      BOOL v17 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v9);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v20);
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v4 = v8 % v9;
      }
      else {
        unint64_t v4 = v8;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
  }
  uint64_t v21 = *(void *)a1;
  long long v22 = *(void **)(*(void *)a1 + 8 * v4);
  if (v22)
  {
    *uint64_t i = *v22;
LABEL_44:
    *long long v22 = i;
    goto LABEL_45;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = i;
  *(void *)(v21 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v23 = *(void *)(*i + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v23 >= v9) {
        v23 %= v9;
      }
    }
    else
    {
      v23 &= v9 - 1;
    }
    long long v22 = (void *)(*(void *)a1 + 8 * v23);
    goto LABEL_44;
  }
LABEL_45:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_221EE61D8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>>>::__erase_unique<Phase::UniqueObjectId>(void *a1, void *a2)
{
  double result = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(a1, a2);
  if (result)
  {
    std::__hash_table<Phase::Controller::Renderer *,std::hash<Phase::Controller::Renderer *>,std::equal_to<Phase::Controller::Renderer *>,std::allocator<Phase::Controller::Renderer *>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>>>::find<unsigned int>(uint64_t a1, unint64_t a2, unsigned int a3)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = a3;
    if (a3 >= a2) {
      unint64_t v4 = a3 % a2;
    }
  }
  else
  {
    unint64_t v4 = (a2 - 1) & a3;
  }
  long long v5 = *(uint64_t ***)(a1 + 8 * v4);
  if (!v5) {
    return 0;
  }
  for (double result = *v5; result; double result = (uint64_t *)*result)
  {
    unint64_t v7 = result[1];
    if (v7 == a3)
    {
      if (*((_DWORD *)result + 4) == a3) {
        return result;
      }
    }
    else
    {
      if (v3.u32[0] > 1uLL)
      {
        if (v7 >= a2) {
          v7 %= a2;
        }
      }
      else
      {
        v7 &= a2 - 1;
      }
      if (v7 != v4) {
        return 0;
      }
    }
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::optional<Phase::Controller::SessionManager::SessionVolume>>>>::__emplace_unique_key_args<unsigned int,unsigned int const&,std::optional<Phase::Controller::SessionManager::SessionVolume>&>(float *a1, unsigned int a2, int a3, uint64_t a4)
{
  unint64_t v8 = a2;
  unint64_t v9 = *((void *)a1 + 1);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    v11 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      unint64_t v12 = *v11;
      if (*v11)
      {
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == a2)
          {
            if (*((_DWORD *)v12 + 4) == a2) {
              return v12;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9) {
                v13 %= v9;
              }
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v4) {
              break;
            }
          }
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
  unint64_t v12 = operator new(0x20uLL);
  *unint64_t v12 = 0;
  v12[1] = v8;
  *((_DWORD *)v12 + 4) = a3;
  *(void *)((char *)v12 + 20) = *(void *)a4;
  *((_DWORD *)v12 + 7) = *(_DWORD *)(a4 + 8);
  float v14 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v15 = a1[8];
  if (v9 && (float)(v15 * (float)v9) >= v14)
  {
    unint64_t v8 = v4;
    goto LABEL_64;
  }
  BOOL v16 = 1;
  if (v9 >= 3) {
    BOOL v16 = (v9 & (v9 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v9);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    int8x8_t prime = (int8x8_t)v18;
  }
  else {
    int8x8_t prime = (int8x8_t)v17;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v9 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v9)
  {
    if (*(void *)&prime >= v9) {
      goto LABEL_60;
    }
    unint64_t v26 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v9 < 3 || (uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v27.i16[0] = vaddlv_u8(v27), v27.u32[0] > 1uLL))
    {
      unint64_t v26 = std::__next_prime(v26);
    }
    else
    {
      uint64_t v28 = 1 << -(char)__clz(v26 - 1);
      if (v26 >= 2) {
        unint64_t v26 = v28;
      }
    }
    if (*(void *)&prime <= v26) {
      int8x8_t prime = (int8x8_t)v26;
    }
    if (*(void *)&prime >= v9)
    {
      unint64_t v9 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      __int16 v35 = *(void **)a1;
      *(void *)a1 = 0;
      if (v35) {
        operator delete(v35);
      }
      unint64_t v9 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  size_t v20 = operator new(8 * *(void *)&prime);
  uint64_t v21 = *(void **)a1;
  *(void *)a1 = v20;
  if (v21) {
    operator delete(v21);
  }
  uint64_t v22 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v22++) = 0;
  while (*(void *)&prime != v22);
  unint64_t v23 = (void *)*((void *)a1 + 2);
  if (v23)
  {
    unint64_t v24 = v23[1];
    uint8x8_t v25 = (uint8x8_t)vcnt_s8(prime);
    v25.i16[0] = vaddlv_u8(v25);
    if (v25.u32[0] > 1uLL)
    {
      if (v24 >= *(void *)&prime) {
        v24 %= *(void *)&prime;
      }
    }
    else
    {
      v24 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v24) = a1 + 4;
    int v29 = (void *)*v23;
    if (*v23)
    {
      do
      {
        unint64_t v30 = v29[1];
        if (v25.u32[0] > 1uLL)
        {
          if (v30 >= *(void *)&prime) {
            v30 %= *(void *)&prime;
          }
        }
        else
        {
          v30 &= *(void *)&prime - 1;
        }
        if (v30 != v24)
        {
          if (!*(void *)(*(void *)a1 + 8 * v30))
          {
            *(void *)(*(void *)a1 + 8 * v30) = v23;
            goto LABEL_56;
          }
          *unint64_t v23 = *v29;
          *int v29 = **(void **)(*(void *)a1 + 8 * v30);
          **(void **)(*(void *)a1 + 8 * v30) = v29;
          int v29 = v23;
        }
        unint64_t v30 = v24;
LABEL_56:
        unint64_t v23 = v29;
        int v29 = (void *)*v29;
        unint64_t v24 = v30;
      }
      while (v29);
    }
  }
  unint64_t v9 = (unint64_t)prime;
LABEL_60:
  if ((v9 & (v9 - 1)) != 0)
  {
    if (v9 <= v8) {
      v8 %= v9;
    }
  }
  else
  {
    unint64_t v8 = (v9 - 1) & v8;
  }
LABEL_64:
  int v31 = *(void **)a1;
  uint64_t v32 = *(void **)(*(void *)a1 + 8 * v8);
  if (v32)
  {
    *unint64_t v12 = *v32;
LABEL_72:
    *uint64_t v32 = v12;
    goto LABEL_73;
  }
  *unint64_t v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v31[v8] = a1 + 4;
  if (*v12)
  {
    unint64_t v33 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v33 >= v9) {
        v33 %= v9;
      }
    }
    else
    {
      v33 &= v9 - 1;
    }
    uint64_t v32 = (void *)(*(void *)a1 + 8 * v33);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return v12;
}

void sub_221EE66C4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<Phase::UniqueObjectId>::__emplace_unique_key_args<Phase::UniqueObjectId,Phase::UniqueObjectId const&>(uint64_t **a1, unint64_t *a2, _OWORD *a3)
{
  long long v5 = (void **)std::__tree<Phase::UniqueObjectId>::__find_equal<Phase::UniqueObjectId>((uint64_t)a1, &v9, a2);
  uint64_t v6 = (uint64_t *)*v5;
  if (!*v5)
  {
    unint64_t v7 = (uint64_t **)v5;
    uint64_t v6 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v6 + 2) = *a3;
    std::__tree<Phase::SpatialCategory>::__insert_node_at(a1, v9, v7, v6);
  }
  return v6;
}

void *std::__tree<Phase::UniqueObjectId>::__find_equal<Phase::UniqueObjectId>(uint64_t a1, void *a2, unint64_t *a3)
{
  long long v5 = *(void **)(a1 + 8);
  double result = (void *)(a1 + 8);
  unint64_t v4 = v5;
  if (v5)
  {
    unint64_t v7 = *a3;
    unint64_t v6 = a3[1];
    do
    {
      while (1)
      {
        unint64_t v8 = v4;
        unint64_t v9 = v4[5];
        unint64_t v10 = v8[4];
        BOOL v11 = v7 < v10;
        if (v6 != v9) {
          BOOL v11 = v6 < v9;
        }
        if (!v11) {
          break;
        }
        unint64_t v4 = (void *)*v8;
        double result = v8;
        if (!*v8) {
          goto LABEL_15;
        }
      }
      BOOL v12 = v10 < v7;
      if (v6 == v9) {
        BOOL v13 = v12;
      }
      else {
        BOOL v13 = v9 < v6;
      }
      if (!v13) {
        break;
      }
      double result = v8 + 1;
      unint64_t v4 = (void *)v8[1];
    }
    while (v4);
  }
  else
  {
    unint64_t v8 = result;
  }
LABEL_15:
  *a2 = v8;
  return result;
}

Phase::Controller::VoiceData *Phase::Controller::VoiceData::VoiceData(Phase::Controller::VoiceData *this, const Phase::Controller::VoicePoolEntry *a2, uint64_t a3)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  *((_OWORD *)this + 1) = 0u;
  long long v5 = (float *)((char *)this + 16);
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  unint64_t v6 = (uint64_t *)((char *)this + 56);
  *((_DWORD *)this + 12) = 1065353216;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  *(void *)this = *((void *)a2 + 3);
  *((void *)this + 1) = a3;
  Phase::Controller::VoicePoolEntry::GetIdsOfParameterOfClass((uint64_t)a2, 5, (char **)&v50);
  unint64_t v7 = v50;
  if (v51 != v50)
  {
    unint64_t v8 = 0;
    do
    {
      int v9 = v7[v8];
      Phase::Controller::sCreateDefaultParameter((Phase::Controller *)__p, a2, v9);
      *(_DWORD *)buf = v9;
      *(_OWORD *)&buf[8] = *(_OWORD *)__p;
      long long v53 = v48;
      uint64_t v54 = v49;
      uint64_t v10 = std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::__emplace_unique_key_args<int,std::pair<int,Phase::Controller::Parameter<double>>>(v5, v9, (uint64_t)buf);
      if ((v10 & 1) == 0)
      {
        uint64_t v39 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v10) + 720);
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&buf[4] = "CvmVoiceData.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 50;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v9;
          _os_log_impl(&dword_221E5E000, v39, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!inserted.second is true]: \"Failed to insert %d parameter\"", buf, 0x18u);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Failed to insert %d parameter");
      }
      ++v8;
      unint64_t v7 = v50;
    }
    while (v8 < (v51 - (unsigned char *)v50) >> 2);
  }
  Phase::Controller::VoicePoolEntry::GetIdsOfParameterOfClass((uint64_t)a2, 4, (char **)&v45);
  BOOL v11 = v45;
  if (v46 != v45)
  {
    unint64_t v12 = 0;
    do
    {
      int v13 = v11[v12];
      Phase::Controller::sCreateDefaultParameter((Phase::Controller *)__p, a2, v13);
      *(_DWORD *)buf = v13;
      *(_OWORD *)&buf[8] = *(_OWORD *)__p;
      long long v53 = v48;
      uint64_t v54 = v49;
      uint64_t v14 = std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::__emplace_unique_key_args<int,std::pair<int,Phase::Controller::Parameter<double>>>(v5, v13, (uint64_t)buf);
      if ((v14 & 1) == 0)
      {
        v41 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v14) + 720);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&buf[4] = "CvmVoiceData.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 61;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v13;
          _os_log_impl(&dword_221E5E000, v41, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!inserted.second is true]: \"Failed to insert %d parameter\"", buf, 0x18u);
        }
        v42 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(v42, "Failed to insert %d parameter");
      }
      ++v12;
      BOOL v11 = v45;
    }
    while (v12 < (v46 - (unsigned char *)v45) >> 2);
  }
  Phase::Controller::VoicePoolEntry::GetInputBufferIds(a2, (char **)__p);
  float v15 = __p[0];
  BOOL v16 = __p[1];
  if (__p[0] != __p[1])
  {
    unint64_t v17 = (unint64_t *)((char *)this + 72);
    unint64_t v18 = *((void *)this + 8);
    do
    {
      if (v18 >= *v17)
      {
        uint64_t v19 = (uint64_t)(v18 - *v6) >> 5;
        if ((unint64_t)(v19 + 1) >> 59) {
          std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v20 = *v17 - *v6;
        uint64_t v21 = v20 >> 4;
        if (v20 >> 4 <= (unint64_t)(v19 + 1)) {
          uint64_t v21 = v19 + 1;
        }
        if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v22 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v22 = v21;
        }
        *((void *)&v53 + 1) = (char *)this + 72;
        if (v22) {
          unint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)this + 72, v22);
        }
        else {
          unint64_t v23 = 0;
        }
        unint64_t v24 = &v23[32 * v19];
        *(void *)buf = v23;
        *(void *)&buf[8] = v24;
        *(void *)&long long v53 = &v23[32 * v22];
        *(_DWORD *)unint64_t v24 = *v15;
        *((void *)v24 + 1) = 0;
        *((void *)v24 + 2) = 0;
        v24[24] = 0;
        *(void *)&buf[16] = v24 + 32;
        std::vector<Phase::Controller::VoiceBufferParameter>::__swap_out_circular_buffer(v6, buf);
        unint64_t v18 = *((void *)this + 8);
        std::__split_buffer<Phase::Controller::VoiceBufferParameter>::~__split_buffer((void **)buf);
      }
      else
      {
        *(_DWORD *)unint64_t v18 = *v15;
        *(void *)(v18 + 8) = 0;
        *(void *)(v18 + 16) = 0;
        *(unsigned char *)(v18 + 24) = 0;
        v18 += 32;
        *((void *)this + 8) = v18;
      }
      *((void *)this + 8) = v18;
      ++v15;
    }
    while (v15 != v16);
  }
  Phase::Controller::VoicePoolEntry::GetOutputBufferIds(a2, &v43);
  uint8x8_t v25 = v43;
  unint64_t v26 = v44;
  if (v43 != v44)
  {
    uint8x8_t v27 = (unint64_t *)((char *)this + 72);
    unint64_t v28 = *((void *)this + 8);
    do
    {
      if (v28 >= *v27)
      {
        uint64_t v29 = (uint64_t)(v28 - *v6) >> 5;
        if ((unint64_t)(v29 + 1) >> 59) {
          std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v30 = *v27 - *v6;
        uint64_t v31 = v30 >> 4;
        if (v30 >> 4 <= (unint64_t)(v29 + 1)) {
          uint64_t v31 = v29 + 1;
        }
        if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v32 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v32 = v31;
        }
        *((void *)&v53 + 1) = (char *)this + 72;
        if (v32) {
          unint64_t v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)this + 72, v32);
        }
        else {
          unint64_t v33 = 0;
        }
        int v34 = &v33[32 * v29];
        *(void *)buf = v33;
        *(void *)&buf[8] = v34;
        *(void *)&long long v53 = &v33[32 * v32];
        *(_DWORD *)int v34 = *(_DWORD *)v25;
        *((void *)v34 + 1) = 0;
        *((void *)v34 + 2) = 0;
        v34[24] = 0;
        *(void *)&buf[16] = v34 + 32;
        std::vector<Phase::Controller::VoiceBufferParameter>::__swap_out_circular_buffer(v6, buf);
        unint64_t v28 = *((void *)this + 8);
        std::__split_buffer<Phase::Controller::VoiceBufferParameter>::~__split_buffer((void **)buf);
      }
      else
      {
        *(_DWORD *)unint64_t v28 = *(_DWORD *)v25;
        *(void *)(v28 + 8) = 0;
        *(void *)(v28 + 16) = 0;
        *(unsigned char *)(v28 + 24) = 0;
        v28 += 32;
        *((void *)this + 8) = v28;
      }
      *((void *)this + 8) = v28;
      v25 += 4;
    }
    while (v25 != v26);
    uint8x8_t v25 = v43;
  }
  v36.i64[0] = *((void *)a2 + 4);
  v35.i64[0] = *((void *)a2 + 5);
  v35.i64[1] = *((void *)a2 + 8);
  v36.i64[1] = *((void *)a2 + 7);
  int64x2_t v37 = (int64x2_t)vshrq_n_u64((uint64x2_t)vsubq_s64(v35, v36), 3uLL);
  v37.i64[0] *= 0xAAAAAAAAAAAAAAABLL;
  v37.i64[1] *= 0xAAAAAAAAAAAAAAABLL;
  *((int64x2_t *)this + 5) = vshrq_n_s64(vshlq_n_s64(v37, 0x20uLL), 0x20uLL);
  if (v25)
  {
    v44 = v25;
    operator delete(v25);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  if (v45)
  {
    v46 = v45;
    operator delete(v45);
  }
  if (v50)
  {
    v51 = v50;
    operator delete(v50);
  }
  return this;
}

void sub_221EE6D4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,char a23)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  if (a20)
  {
    a21 = (uint64_t)a20;
    operator delete(a20);
  }
  std::vector<Phase::Controller::VoiceBufferParameter>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v23);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::sCreateDefaultParameter(Phase::Controller *this, const Phase::Controller::VoicePoolEntry *a2, int a3)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  Parameter = (double *)Phase::Controller::VoicePoolEntry::GetParameter(a2, a3);
  if (!Parameter)
  {
    int v9 = **(id **)(Phase::Logger::GetInstance(0) + 400);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v11 = 136315394;
      unint64_t v12 = "VoicePoolEntry.hpp";
      __int16 v13 = 1024;
      int v14 = 155;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d POSTCONDITION: false is false.", (uint8_t *)&v11, 0x12u);
    }
    exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "POSTCONDITION: false is false.");
  }
  double v5 = Parameter[4];
  double v6 = Parameter[5];
  double v7 = Parameter[6];
  *((unsigned char *)this + 32) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;

  return Phase::Controller::Parameter<double>::Initialize((uint64_t)this, v5, v6, v7);
}

void sub_221EE6F6C(_Unwind_Exception *exception_object)
{
}

Phase::Controller::VoiceData *Phase::Controller::VoiceData::VoiceData(Phase::Controller::VoiceData *this, const Phase::Controller::ProcedureInfo *a2, uint64_t a3)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  *((_OWORD *)this + 1) = 0u;
  double v5 = (float *)((char *)this + 16);
  *((_OWORD *)this + 2) = 0u;
  *((_DWORD *)this + 12) = 1065353216;
  *(_OWORD *)((char *)this + 56) = 0u;
  double v6 = (uint64_t *)((char *)this + 56);
  *(_OWORD *)((char *)this + 72) = 0u;
  *((void *)this + 11) = 0;
  *(void *)this = *((void *)a2 + 3);
  *((void *)this + 1) = a3;
  uint64_t v7 = *((void *)a2 + 4);
  if (*((void *)a2 + 5) != v7)
  {
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    do
    {
      uint64_t v10 = v7 + v8;
      int v11 = *(_DWORD *)(v10 + 32);
      double v12 = *(double *)(v10 + 40);
      double v13 = *(double *)(v10 + 48);
      double v14 = *(double *)(v10 + 56);
      LOBYTE(v41) = 0;
      long long v39 = 0u;
      long long v40 = 0u;
      Phase::Controller::Parameter<double>::Initialize((uint64_t)&v39, v12, v13, v14);
      *(_DWORD *)buf = v11;
      *(_OWORD *)&buf[8] = v39;
      long long v43 = v40;
      uint64_t v44 = v41;
      uint64_t v15 = std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::__emplace_unique_key_args<int,std::pair<int,Phase::Controller::Parameter<double>>>(v5, v11, (uint64_t)buf);
      if ((v15 & 1) == 0)
      {
        int64x2_t v37 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v15) + 720);
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&buf[4] = "CvmVoiceData.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 105;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v11;
          _os_log_impl(&dword_221E5E000, v37, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [!inserted.second is true]: \"Failed to insert %d parameter\"", buf, 0x18u);
        }
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "Failed to insert %d parameter");
      }
      ++v9;
      uint64_t v7 = *((void *)a2 + 4);
      v8 += 64;
    }
    while (v9 < (*((void *)a2 + 5) - v7) >> 6);
  }
  BOOL v16 = (_DWORD *)*((void *)a2 + 7);
  unint64_t v17 = (_DWORD *)*((void *)a2 + 8);
  if (v16 != v17)
  {
    unint64_t v18 = (unint64_t *)((char *)this + 72);
    unint64_t v19 = *((void *)this + 8);
    do
    {
      if (v19 >= *v18)
      {
        uint64_t v20 = (uint64_t)(v19 - *v6) >> 5;
        if ((unint64_t)(v20 + 1) >> 59) {
          std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v21 = *v18 - *v6;
        uint64_t v22 = v21 >> 4;
        if (v21 >> 4 <= (unint64_t)(v20 + 1)) {
          uint64_t v22 = v20 + 1;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v23 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v23 = v22;
        }
        *((void *)&v43 + 1) = (char *)this + 72;
        if (v23) {
          unint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)this + 72, v23);
        }
        else {
          unint64_t v24 = 0;
        }
        uint8x8_t v25 = &v24[32 * v20];
        *(void *)buf = v24;
        *(void *)&buf[8] = v25;
        *(void *)&long long v43 = &v24[32 * v23];
        *(_DWORD *)uint8x8_t v25 = *v16;
        *((void *)v25 + 1) = 0;
        *((void *)v25 + 2) = 0;
        v25[24] = 0;
        *(void *)&buf[16] = v25 + 32;
        std::vector<Phase::Controller::VoiceBufferParameter>::__swap_out_circular_buffer(v6, buf);
        unint64_t v19 = *((void *)this + 8);
        std::__split_buffer<Phase::Controller::VoiceBufferParameter>::~__split_buffer((void **)buf);
      }
      else
      {
        *(_DWORD *)unint64_t v19 = *v16;
        *(void *)(v19 + 8) = 0;
        *(void *)(v19 + 16) = 0;
        *(unsigned char *)(v19 + 24) = 0;
        v19 += 32;
        *((void *)this + 8) = v19;
      }
      *((void *)this + 8) = v19;
      ++v16;
    }
    while (v16 != v17);
  }
  unint64_t v26 = (_DWORD *)*((void *)a2 + 10);
  uint8x8_t v27 = (_DWORD *)*((void *)a2 + 11);
  if (v26 != v27)
  {
    unint64_t v28 = (unint64_t *)((char *)this + 72);
    unint64_t v29 = *((void *)this + 8);
    do
    {
      if (v29 >= *v28)
      {
        uint64_t v30 = (uint64_t)(v29 - *v6) >> 5;
        if ((unint64_t)(v30 + 1) >> 59) {
          std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v31 = *v28 - *v6;
        uint64_t v32 = v31 >> 4;
        if (v31 >> 4 <= (unint64_t)(v30 + 1)) {
          uint64_t v32 = v30 + 1;
        }
        if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v33 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v33 = v32;
        }
        *((void *)&v43 + 1) = (char *)this + 72;
        if (v33) {
          int v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)this + 72, v33);
        }
        else {
          int v34 = 0;
        }
        int64x2_t v35 = &v34[32 * v30];
        *(void *)buf = v34;
        *(void *)&buf[8] = v35;
        *(void *)&long long v43 = &v34[32 * v33];
        *(_DWORD *)int64x2_t v35 = *v26;
        *((void *)v35 + 1) = 0;
        *((void *)v35 + 2) = 0;
        v35[24] = 0;
        *(void *)&buf[16] = v35 + 32;
        std::vector<Phase::Controller::VoiceBufferParameter>::__swap_out_circular_buffer(v6, buf);
        unint64_t v29 = *((void *)this + 8);
        std::__split_buffer<Phase::Controller::VoiceBufferParameter>::~__split_buffer((void **)buf);
      }
      else
      {
        *(_DWORD *)unint64_t v29 = *v26;
        *(void *)(v29 + 8) = 0;
        *(void *)(v29 + 16) = 0;
        *(unsigned char *)(v29 + 24) = 0;
        v29 += 32;
        *((void *)this + 8) = v29;
      }
      *((void *)this + 8) = v29;
      ++v26;
    }
    while (v26 != v27);
  }
  *((_OWORD *)this + 5) = *(_OWORD *)((char *)a2 + 104);
  return this;
}

void sub_221EE733C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<Phase::Controller::VoiceBufferParameter>::__destroy_vector::operator()[abi:ne180100](&a9);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v9);
  _Unwind_Resume(a1);
}

void Phase::Controller::VoiceData::SetParameter(Phase::Controller::VoiceData *this, int a2, double a3, int a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  unint64_t v5 = *((void *)this + 3);
  if (v5)
  {
    uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
    v7.i16[0] = vaddlv_u8(v7);
    if (v7.u32[0] > 1uLL)
    {
      unint64_t v8 = a2;
      if (v5 <= a2) {
        unint64_t v8 = a2 % v5;
      }
    }
    else
    {
      unint64_t v8 = (v5 - 1) & a2;
    }
    uint64_t v9 = *(double ***)(*((void *)this + 2) + 8 * v8);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = *(double **)i)
      {
        unint64_t v11 = *((void *)i + 1);
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2)
          {
            double v13 = Phase::Controller::sClamp<double>(this, a3, i[3], i[4]);
            if (v13 != i[6])
            {
              i[6] = v13;
              *((unsigned char *)i + 56) = 1;
            }
            if (a4) {
              *((unsigned char *)i + 56) = 1;
            }
            return;
          }
        }
        else
        {
          if (v7.u32[0] > 1uLL)
          {
            if (v11 >= v5) {
              v11 %= v5;
            }
          }
          else
          {
            v11 &= v5 - 1;
          }
          if (v11 != v8) {
            break;
          }
        }
      }
    }
  }
  double v12 = **(id **)(Phase::Logger::GetInstance(this) + 384);
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    int v14 = 136315650;
    uint64_t v15 = "CvmVoiceData.mm";
    __int16 v16 = 1024;
    int v17 = 149;
    __int16 v18 = 1024;
    int v19 = a2;
    _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d CvmVoiceData::SetParameter: was called with an invalid inParameterId %d!\n", (uint8_t *)&v14, 0x18u);
  }
}

void Phase::Controller::VoiceData::SetBuffer(Phase::Logger *a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v4 = *((void *)a1 + 7);
  if (a2 >= (*((void *)a1 + 8) - v4) >> 5)
  {
    uint64_t v9 = **(id **)(Phase::Logger::GetInstance(a1) + 384);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v10 = 136315650;
      unint64_t v11 = "CvmVoiceData.mm";
      __int16 v12 = 1024;
      int v13 = 162;
      __int16 v14 = 2048;
      unint64_t v15 = a2;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d CvmVoiceData::SetBuffer: was called with an invalid inIndex %lu!\n", (uint8_t *)&v10, 0x1Cu);
    }
  }
  else
  {
    uint64_t v5 = v4 + 32 * a2;
    uint64_t v7 = *a3;
    uint64_t v6 = a3[1];
    if (v6) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(v5 + 8) = v7;
    unint64_t v8 = *(std::__shared_weak_count **)(v5 + 16);
    *(void *)(v5 + 16) = v6;
    if (v8)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v8);
    }
  }
}

void Phase::Controller::VoiceData::PackDirtyDspParameters(Phase::Controller::VoiceData *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = (uint64_t *)*((void *)this + 4);
  if (v2)
  {
    uint64_t v4 = 0;
    uint64_t v5 = a2 + 2;
    do
    {
      if (*((unsigned char *)v2 + 56))
      {
        uint64_t v6 = v2[6];
        if ((unint64_t)v4 >= *v5)
        {
          uint64_t v7 = (uint64_t)&v4[-*a2] >> 4;
          if ((unint64_t)(v7 + 1) >> 60) {
            std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v8 = *v5 - *a2;
          uint64_t v9 = v8 >> 3;
          if (v8 >> 3 <= (unint64_t)(v7 + 1)) {
            uint64_t v9 = v7 + 1;
          }
          if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v10 = v9;
          }
          unint64_t v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>((uint64_t)v5, v10);
          int v13 = &v11[16 * v7];
          *(_DWORD *)int v13 = *((_DWORD *)v2 + 4);
          *((void *)v13 + 1) = v6;
          unint64_t v15 = (char *)*a2;
          __int16 v14 = (char *)a2[1];
          uint64_t v16 = v13;
          if (v14 != (char *)*a2)
          {
            do
            {
              *((_OWORD *)v16 - 1) = *((_OWORD *)v14 - 1);
              v16 -= 16;
              v14 -= 16;
            }
            while (v14 != v15);
            __int16 v14 = (char *)*a2;
          }
          uint64_t v4 = v13 + 16;
          *a2 = v16;
          a2[1] = v13 + 16;
          a2[2] = &v11[16 * v12];
          if (v14) {
            operator delete(v14);
          }
        }
        else
        {
          *(_DWORD *)uint64_t v4 = *((_DWORD *)v2 + 4);
          *((void *)v4 + 1) = v6;
          v4 += 16;
        }
        a2[1] = v4;
      }
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
}

void sub_221EE77B8(_Unwind_Exception *exception_object)
{
  uint8x8_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double Phase::Controller::VoiceData::CreateDspNodeVoice@<D0>(Phase::Controller::VoiceData *this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 8) = 0u;
  uint64_t v4 = (uint64_t *)(a2 + 8);
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(void *)a2 = *((void *)this + 1);
  uint64_t v5 = *((void *)this + 7);
  uint64_t v6 = *((void *)this + 8);
  if (v5 != v6)
  {
    unint64_t v7 = 0;
    uint64_t v8 = (unint64_t *)(a2 + 24);
    do
    {
      if (v7 >= *v8)
      {
        uint64_t v10 = (uint64_t)(v7 - *v4) >> 5;
        if ((unint64_t)(v10 + 1) >> 59) {
          std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v11 = *v8 - *v4;
        uint64_t v12 = v11 >> 4;
        if (v11 >> 4 <= (unint64_t)(v10 + 1)) {
          uint64_t v12 = v10 + 1;
        }
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v12;
        }
        uint64_t v50 = a2 + 24;
        if (v13) {
          __int16 v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>(a2 + 24, v13);
        }
        else {
          __int16 v14 = 0;
        }
        unint64_t v15 = &v14[32 * v10];
        *(void *)&long long v47 = v14;
        *((void *)&v47 + 1) = v15;
        uint64_t v49 = &v14[32 * v13];
        *(_DWORD *)unint64_t v15 = *(_DWORD *)v5;
        *((void *)v15 + 1) = *(void *)(v5 + 8);
        uint64_t v16 = *(void *)(v5 + 16);
        *((void *)v15 + 2) = v16;
        if (v16) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
        }
        v15[24] = *(unsigned char *)(v5 + 24);
        long long v48 = v15 + 32;
        std::vector<Phase::Controller::VoiceBufferParameter>::__swap_out_circular_buffer(v4, &v47);
        unint64_t v7 = *(void *)(a2 + 16);
        std::__split_buffer<Phase::Controller::VoiceBufferParameter>::~__split_buffer((void **)&v47);
      }
      else
      {
        *(_DWORD *)unint64_t v7 = *(_DWORD *)v5;
        *(void *)(v7 + 8) = *(void *)(v5 + 8);
        uint64_t v9 = *(void *)(v5 + 16);
        *(void *)(v7 + 16) = v9;
        if (v9) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
        }
        *(unsigned char *)(v7 + 24) = *(unsigned char *)(v5 + 24);
        v7 += 32;
      }
      *(void *)(a2 + 16) = v7;
      v5 += 32;
    }
    while (v5 != v6);
  }
  if (*((void *)this + 10))
  {
    unint64_t v17 = 0;
    __int16 v18 = (void *)(a2 + 32);
    int v19 = (void *)(a2 + 48);
    uint64_t v20 = *(char **)(a2 + 40);
    do
    {
      if ((unint64_t)v20 >= *v19)
      {
        uint64_t v21 = (uint64_t)&v20[-*v18] >> 4;
        if ((unint64_t)(v21 + 1) >> 60) {
          std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v22 = *v19 - *v18;
        uint64_t v23 = v22 >> 3;
        if (v22 >> 3 <= (unint64_t)(v21 + 1)) {
          uint64_t v23 = v21 + 1;
        }
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v24 = v23;
        }
        uint8x8_t v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>(a2 + 48, v24);
        uint8x8_t v27 = &v25[16 * v21];
        *(_DWORD *)uint8x8_t v27 = v17;
        *((void *)v27 + 1) = 0x3FF0000000000000;
        unint64_t v29 = *(char **)(a2 + 32);
        unint64_t v28 = *(char **)(a2 + 40);
        uint64_t v30 = v27;
        if (v28 != v29)
        {
          do
          {
            *((_OWORD *)v30 - 1) = *((_OWORD *)v28 - 1);
            v30 -= 16;
            v28 -= 16;
          }
          while (v28 != v29);
          unint64_t v28 = (char *)*v18;
        }
        uint64_t v20 = v27 + 16;
        *(void *)(a2 + 32) = v30;
        *(void *)(a2 + 40) = v27 + 16;
        *(void *)(a2 + 48) = &v25[16 * v26];
        if (v28) {
          operator delete(v28);
        }
      }
      else
      {
        *(_DWORD *)uint64_t v20 = v17;
        *((void *)v20 + 1) = 0x3FF0000000000000;
        v20 += 16;
      }
      *(void *)(a2 + 40) = v20;
      ++v17;
    }
    while (*((void *)this + 10) > v17);
  }
  if (*((void *)this + 11))
  {
    unint64_t v31 = 0;
    uint64_t v32 = (void *)(a2 + 56);
    unint64_t v33 = (void *)(a2 + 72);
    int v34 = *(char **)(a2 + 64);
    do
    {
      if ((unint64_t)v34 >= *v33)
      {
        uint64_t v35 = (uint64_t)&v34[-*v32] >> 4;
        if ((unint64_t)(v35 + 1) >> 60) {
          std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v36 = *v33 - *v32;
        uint64_t v37 = v36 >> 3;
        if (v36 >> 3 <= (unint64_t)(v35 + 1)) {
          uint64_t v37 = v35 + 1;
        }
        if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v38 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v38 = v37;
        }
        long long v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>(a2 + 72, v38);
        uint64_t v41 = &v39[16 * v35];
        *(_DWORD *)uint64_t v41 = v31;
        *((void *)v41 + 1) = 0x3FF0000000000000;
        long long v43 = *(char **)(a2 + 56);
        v42 = *(char **)(a2 + 64);
        uint64_t v44 = v41;
        if (v42 != v43)
        {
          do
          {
            *((_OWORD *)v44 - 1) = *((_OWORD *)v42 - 1);
            v44 -= 16;
            v42 -= 16;
          }
          while (v42 != v43);
          v42 = (char *)*v32;
        }
        int v34 = v41 + 16;
        *(void *)(a2 + 56) = v44;
        *(void *)(a2 + 64) = v41 + 16;
        *(void *)(a2 + 72) = &v39[16 * v40];
        if (v42) {
          operator delete(v42);
        }
      }
      else
      {
        *(_DWORD *)int v34 = v31;
        *((void *)v34 + 1) = 0x3FF0000000000000;
        v34 += 16;
      }
      *(void *)(a2 + 64) = v34;
      ++v31;
    }
    while (*((void *)this + 11) > v31);
  }
  Phase::Controller::VoiceData::PackDirtyDspParameters(this, &v47);
  uint64_t v45 = *(void **)(a2 + 80);
  if (v45)
  {
    *(void *)(a2 + 88) = v45;
    operator delete(v45);
    *(void *)(a2 + 80) = 0;
    *(void *)(a2 + 88) = 0;
    *(void *)(a2 + 96) = 0;
  }
  double result = *(double *)&v47;
  *(_OWORD *)(a2 + 80) = v47;
  *(void *)(a2 + 96) = v48;
  return result;
}

void sub_221EE7B84(_Unwind_Exception *a1)
{
  Phase::Controller::DspNodeVoice::~DspNodeVoice(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::__emplace_unique_key_args<int,std::pair<int,Phase::Controller::Parameter<double>>>(float *a1, int a2, uint64_t a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (uint64_t *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return 0;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t v12 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v12 = 0;
  *((void *)v12 + 1) = v6;
  *((_DWORD *)v12 + 4) = *(_DWORD *)a3;
  *(_OWORD *)(v12 + 24) = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(v12 + 40) = *(_OWORD *)(a3 + 24);
  *((void *)v12 + 7) = *(void *)(a3 + 40);
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      int8x8_t prime = (int8x8_t)v17;
    }
    else {
      int8x8_t prime = (int8x8_t)v16;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (*(void *)&prime > v7) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v7)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (*(void *)&prime <= v25) {
        int8x8_t prime = (int8x8_t)v25;
      }
      if (*(void *)&prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          int v19 = operator new(8 * *(void *)&prime);
          uint64_t v20 = *(void **)a1;
          *(void *)a1 = v19;
          if (v20) {
            operator delete(v20);
          }
          uint64_t v21 = 0;
          *((int8x8_t *)a1 + 1) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v21++) = 0;
          while (*(void *)&prime != v21);
          uint64_t v22 = (void *)*((void *)a1 + 2);
          if (v22)
          {
            unint64_t v23 = v22[1];
            uint8x8_t v24 = (uint8x8_t)vcnt_s8(prime);
            v24.i16[0] = vaddlv_u8(v24);
            if (v24.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&prime) {
                v23 %= *(void *)&prime;
              }
            }
            else
            {
              v23 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v23) = a1 + 4;
            unint64_t v28 = (void *)*v22;
            if (*v22)
            {
              do
              {
                unint64_t v29 = v28[1];
                if (v24.u32[0] > 1uLL)
                {
                  if (v29 >= *(void *)&prime) {
                    v29 %= *(void *)&prime;
                  }
                }
                else
                {
                  v29 &= *(void *)&prime - 1;
                }
                if (v29 != v23)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v29))
                  {
                    *(void *)(*(void *)a1 + 8 * v29) = v22;
                    goto LABEL_55;
                  }
                  *uint64_t v22 = *v28;
                  *unint64_t v28 = **(void **)(*(void *)a1 + 8 * v29);
                  **(void **)(*(void *)a1 + 8 * v29) = v28;
                  unint64_t v28 = v22;
                }
                unint64_t v29 = v23;
LABEL_55:
                uint64_t v22 = v28;
                unint64_t v28 = (void *)*v28;
                unint64_t v23 = v29;
              }
              while (v28);
            }
          }
          unint64_t v7 = (unint64_t)prime;
          goto LABEL_59;
        }
        int v34 = *(void **)a1;
        *(void *)a1 = 0;
        if (v34) {
          operator delete(v34);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
      }
    }
LABEL_59:
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v30 = *(void **)a1;
  unint64_t v31 = *(void **)(*(void *)a1 + 8 * v3);
  if (v31)
  {
    *(void *)uint64_t v12 = *v31;
LABEL_72:
    void *v31 = v12;
    goto LABEL_73;
  }
  *(void *)uint64_t v12 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v12;
  v30[v3] = a1 + 4;
  if (*(void *)v12)
  {
    unint64_t v32 = *(void *)(*(void *)v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7) {
        v32 %= v7;
      }
    }
    else
    {
      v32 &= v7 - 1;
    }
    unint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return 1;
}

void sub_221EE7FB8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<Phase::Controller::VoiceBufferParameter>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Controller::VoiceBufferParameter>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Controller::VoiceBufferParameter>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = a3 + v7;
      *(_DWORD *)(a7 + v7 - 32) = *(_DWORD *)(a3 + v7 - 32);
      uint64_t v9 = a7 + v7 - 32;
      *(_OWORD *)(v9 + 8) = *(_OWORD *)(a3 + v7 - 24);
      *(void *)(v8 - 24) = 0;
      *(void *)(v8 - 16) = 0;
      *(unsigned char *)(v9 + 24) = *(unsigned char *)(a3 + v7 - 8);
      *((void *)&v15 + 1) = v9;
      v7 -= 32;
    }
    while (a3 + v7 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Controller::VoiceBufferParameter>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Controller::VoiceBufferParameter>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Controller::VoiceBufferParameter>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Controller::VoiceBufferParameter>,std::reverse_iterator<Phase::Controller::VoiceBufferParameter*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    unint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 32;
  }
}

void **std::__split_buffer<Phase::Controller::VoiceBufferParameter>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<Phase::Controller::VoiceBufferParameter>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 16) = v1 - 32;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 16);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 32;
    }
  }
}

void Phase::Controller::sCatchAll(Phase::Controller *this, const char *a2)
{
}

uint64_t sub_221EE822C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, uint64_t a10, __int16 a11, int a12, __int16 a13, uint64_t a14, __int16 a15, int a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  if (!a2) {
    _Unwind_Resume(exception_object);
  }
  switch(a2)
  {
    case 7:
      unint64_t v25 = (Phase::Logger *)__cxa_begin_catch(exception_object);
      uint8x8_t v26 = **(id **)(Phase::Logger::GetInstance(v25) + 384);
      uint64_t v27 = 3;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        int v35 = 136315906;
        uint64_t v36 = "CvmVoiceManager.mm";
        __int16 v37 = 1024;
        int v38 = 52;
        __int16 v39 = 2080;
        uint64_t v40 = v23;
        __int16 v41 = 1024;
        int v42 = 3;
        unint64_t v28 = "%25s:%-5d %s failed with ErrorCode: %hhd (InvalidId)";
LABEL_22:
        _os_log_impl(&dword_221E5E000, v26, OS_LOG_TYPE_ERROR, v28, (uint8_t *)&v35, 0x22u);
      }
      break;
    case 6:
      unint64_t v29 = (Phase::Logger *)__cxa_begin_catch(exception_object);
      uint8x8_t v26 = **(id **)(Phase::Logger::GetInstance(v29) + 384);
      uint64_t v27 = 4;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        int v35 = 136315906;
        uint64_t v36 = "CvmVoiceManager.mm";
        __int16 v37 = 1024;
        int v38 = 58;
        __int16 v39 = 2080;
        uint64_t v40 = v23;
        __int16 v41 = 1024;
        int v42 = 4;
        unint64_t v28 = "%25s:%-5d %s failed with ErrorCode: %hhd (IdAlreadyExists)";
        goto LABEL_22;
      }
      break;
    case 5:
      uint64_t v30 = (Phase::Logger *)__cxa_begin_catch(exception_object);
      uint8x8_t v26 = **(id **)(Phase::Logger::GetInstance(v30) + 384);
      uint64_t v27 = 6;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        int v35 = 136315906;
        uint64_t v36 = "CvmVoiceManager.mm";
        __int16 v37 = 1024;
        int v38 = 64;
        __int16 v39 = 2080;
        uint64_t v40 = v23;
        __int16 v41 = 1024;
        int v42 = 6;
        unint64_t v28 = "%25s:%-5d %s failed with ErrorCode: %hhd (OutOfMemory)";
        goto LABEL_22;
      }
      break;
    case 4:
      unint64_t v31 = (Phase::Logger *)__cxa_begin_catch(exception_object);
      uint8x8_t v26 = **(id **)(Phase::Logger::GetInstance(v31) + 384);
      uint64_t v27 = 1;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        int v35 = 136315906;
        uint64_t v36 = "CvmVoiceManager.mm";
        __int16 v37 = 1024;
        int v38 = 70;
        __int16 v39 = 2080;
        uint64_t v40 = v23;
        __int16 v41 = 1024;
        int v42 = 1;
        unint64_t v28 = "%25s:%-5d %s failed with ErrorCode: %hhd (InvalidArgument)";
        goto LABEL_22;
      }
      break;
    case 3:
      unint64_t v32 = (Phase::Logger *)__cxa_begin_catch(exception_object);
      uint8x8_t v26 = **(id **)(Phase::Logger::GetInstance(v32) + 384);
      uint64_t v27 = 8;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        int v35 = 136315906;
        uint64_t v36 = "CvmVoiceManager.mm";
        __int16 v37 = 1024;
        int v38 = 76;
        __int16 v39 = 2080;
        uint64_t v40 = v23;
        __int16 v41 = 1024;
        int v42 = 8;
        unint64_t v28 = "%25s:%-5d %s failed with ErrorCode: %hhd (Failed)";
        goto LABEL_22;
      }
      break;
    default:
      unint64_t v33 = (Phase::Logger *)__cxa_begin_catch(exception_object);
      if (a2 == 2)
      {
        uint8x8_t v26 = **(id **)(Phase::Logger::GetInstance(v33) + 384);
        uint64_t v27 = 8;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          int v35 = 136315906;
          uint64_t v36 = "CvmVoiceManager.mm";
          __int16 v37 = 1024;
          int v38 = 82;
          __int16 v39 = 2080;
          uint64_t v40 = v23;
          __int16 v41 = 1024;
          int v42 = 8;
          unint64_t v28 = "%25s:%-5d %s failed with runtime ErrorCode: %hhd (Failed)";
          goto LABEL_22;
        }
      }
      else
      {
        uint8x8_t v26 = **(id **)(Phase::Logger::GetInstance(v33) + 384);
        uint64_t v27 = 8;
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          int v35 = 136315906;
          uint64_t v36 = "CvmVoiceManager.mm";
          __int16 v37 = 1024;
          int v38 = 88;
          __int16 v39 = 2080;
          uint64_t v40 = v23;
          __int16 v41 = 1024;
          int v42 = 8;
          unint64_t v28 = "%25s:%-5d %s failed with logic ErrorCode: %hhd (Failed)";
          goto LABEL_22;
        }
      }
      break;
  }
  __cxa_end_catch();
  return v27;
}

void Phase::Controller::VoiceManager::VoiceManager(Phase::Controller::VoiceManager *this)
{
}

void sub_221EE86B0(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10E0C404FAEF3E0);
  _Unwind_Resume(a1);
}

void Phase::Controller::VoiceManager::Implementation::Initialize(Phase::Controller::VoiceManager::Implementation *this, const Phase::Controller::VoiceManagerInitializeParameters *a2, Phase::Controller::VoiceManager *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  *((void *)this + 85) = *((void *)a2 + 6);
  uint64_t v5 = **(id **)(Phase::Logger::GetInstance(this) + 384);
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    *(_DWORD *)buf = 136315650;
    *(void *)&buf[4] = "CvmVoiceManager.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 139;
    __int16 v12 = 2048;
    char v13 = this;
    _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: initializing", buf, 0x1Cu);
  }
  Instance = (Phase::Logger *)Phase::Logger::GetInstance((Phase::Logger *)v6);
  *((unsigned char *)this + 1001) = *((unsigned char *)Instance + 1553);
  uint64_t v8 = **(id **)(Phase::Logger::GetInstance(Instance) + 384);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *((unsigned __int8 *)this + 1001);
    *(void *)&buf[4] = "CvmVoiceManager.mm";
    *(_DWORD *)buf = 136315906;
    *(_WORD *)&unsigned char buf[12] = 1024;
    if (v9) {
      uint64_t v10 = "enabled";
    }
    else {
      uint64_t v10 = "disabled";
    }
    *(_DWORD *)&buf[14] = 143;
    __int16 v12 = 2048;
    char v13 = this;
    __int16 v14 = 2080;
    long long v15 = v10;
    _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: stats logging is %s", buf, 0x26u);
  }
  if (*((void *)a2 + 8)) {
    operator new();
  }
  operator new();
}

void sub_221EE9034(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26)
{
  if (a2)
  {
    __cxa_free_exception(v26);
    Phase::Controller::AudioRouteDescription::~AudioRouteDescription((Phase::Controller::AudioRouteDescription *)&a16);
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"Initialize", v28);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::Destroy(Phase::Controller::VoiceManager::Implementation *this)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  unint64_t v11 = (char *)this + 8;
  BOOL v12 = std::__shared_mutex_base::try_lock((std::__shared_mutex_base *)((char *)this + 8));
  uint64_t v2 = (Phase::Logger *)Phase::Controller::VoiceManager::Implementation::AcquireStateLock((uint64_t)this, (uint64_t)&v11, 0, 0.0);
  if (atomic_load((unsigned __int8 *)this)) {
    __assert_rtn("Destroy", "CvmVoiceManager.mm", 259, "mState == State::Stopped");
  }
  int v4 = (int)v2;
  if (v2)
  {
    uint64_t v5 = **(id **)(Phase::Logger::GetInstance(v2) + 384);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      __int16 v14 = "CvmVoiceManager.mm";
      __int16 v15 = 1024;
      int v16 = 262;
      __int16 v17 = 1024;
      int v18 = v4;
      _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d AcquireStateLock() failed with error %i", buf, 0x18u);
    }
  }
  uint64_t v6 = *((void *)this + 89);
  *((void *)this + 89) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 24))(v6);
  }
  Phase::Controller::SpatialModelerSystem::Destroy((Phase::Controller::VoiceManager::Implementation *)((char *)this + 560));
  Phase::Controller::SubmixSystem::Destroy((Phase::Controller::VoiceManager::Implementation *)((char *)this + 224));
  std::unique_ptr<Phase::Controller::DSPVoiceManager>::reset[abi:ne180100]((Phase::Controller::DSPVoiceManager::Implementation ***)this + 87, 0);
  uint64_t v7 = *((void *)this + 86);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
    uint64_t v8 = *((void *)this + 86);
    *((void *)this + 86) = 0;
    if (v8) {
      (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    }
  }
  uint64_t v9 = *((void *)this + 88);
  *((void *)this + 88) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v11);
  return 0;
}

void sub_221EE93DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::Start(Phase::Controller::VoiceManager::Implementation *this, double a2)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  Instance = (Phase::Logger *)Phase::Logger::GetInstance(this);
  if (*((unsigned char *)Instance + 392))
  {
    uint64_t v5 = (Phase::Logger *)objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(Instance)
                                                                                            + 384)));
    uint64_t v6 = Phase::Logger::GetInstance(v5);
    os_signpost_id_t v7 = os_signpost_id_generate(**(os_log_t **)(v6 + 384));
    if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v8 = v7;
      if (os_signpost_enabled((os_log_t)v5))
      {
        uint64_t v9 = (const char *)*((void *)this + 22);
        *(_DWORD *)buf = 134217984;
        uint8x8_t v24 = v9;
        _os_signpost_emit_with_name_impl(&dword_221E5E000, (os_log_t)v5, OS_SIGNPOST_EVENT, v8, "Phase_CVM_Start", "sr = %.f Hz", buf, 0xCu);
      }
    }
  }
  uint64_t v10 = **(id **)(Phase::Logger::GetInstance(Instance) + 384);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    uint8x8_t v24 = "CvmVoiceManager.mm";
    __int16 v25 = 1024;
    int v26 = 297;
    __int16 v27 = 2048;
    unint64_t v28 = this;
    _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: start", buf, 0x1Cu);
  }
  uint64_t v21 = (char *)this + 8;
  BOOL v22 = std::__shared_mutex_base::try_lock((std::__shared_mutex_base *)((char *)this + 8));
  uint64_t v11 = Phase::Controller::VoiceManager::Implementation::AcquireStateLock((uint64_t)this, (uint64_t)&v21, 1, a2);
  if (!v11)
  {
    int v12 = atomic_load((unsigned __int8 *)this);
    if (v12 == 1)
    {
LABEL_10:
      uint64_t v11 = 0;
      goto LABEL_11;
    }
    __int16 v14 = (Phase::Logger *)(*(uint64_t (**)(void))(**((void **)this + 86) + 40))(*((void *)this + 86));
    uint64_t v11 = (uint64_t)v14;
    if (!v14)
    {
      if (!atomic_load((unsigned __int8 *)this))
      {
        Phase::Controller::DVM::VoiceGraph::AddMaster(*(Phase::Controller::DVM::VoiceGraph **)(**((void **)this + 87) + 72), 0xFFFFFFFFFFFFFFFELL);
        __int16 v17 = (void *)*((void *)this + 89);
        if (v17) {
          Phase::Controller::TapManager::EngineStartNotify(v17);
        }
      }
      atomic_store(1u, (unsigned __int8 *)this);
      for (uint64_t i = (void *)*((void *)this + 72); i; uint64_t i = (void *)*i)
      {
        uint64_t v19 = (unsigned __int8 *)(*(void *)(i[3] + 80) + 5641);
        unsigned __int8 v20 = atomic_load(v19);
        if ((v20 & 1) == 0) {
          atomic_store(1u, v19);
        }
      }
      goto LABEL_10;
    }
    __int16 v15 = **(id **)(Phase::Logger::GetInstance(v14) + 384);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      uint8x8_t v24 = "CvmVoiceManager.mm";
      __int16 v25 = 1024;
      int v26 = 330;
      __int16 v27 = 2048;
      unint64_t v28 = this;
      __int16 v29 = 1024;
      int v30 = v11;
      _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d impl@%p: could not start audio IO unit, error %d", buf, 0x22u);
    }
  }
LABEL_11:
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v21);
  return v11;
}

void sub_221EE96D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::Pause(Phase::Controller::VoiceManager::Implementation *this)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v2 = **(id **)(Phase::Logger::GetInstance(this) + 384);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    uint64_t v11 = "CvmVoiceManager.mm";
    __int16 v12 = 1024;
    int v13 = 339;
    __int16 v14 = 2048;
    __int16 v15 = this;
    _os_log_impl(&dword_221E5E000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message Pause()", buf, 0x1Cu);
  }
  os_signpost_id_t v8 = (char *)this + 8;
  BOOL v9 = std::__shared_mutex_base::try_lock((std::__shared_mutex_base *)((char *)this + 8));
  unint64_t v3 = (Phase::Logger *)Phase::Controller::VoiceManager::Implementation::AcquireStateLock((uint64_t)this, (uint64_t)&v8, 0, 0.0);
  int v4 = (int)v3;
  if (v3)
  {
    uint64_t v5 = **(id **)(Phase::Logger::GetInstance(v3) + 384);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v11 = "CvmVoiceManager.mm";
      __int16 v12 = 1024;
      int v13 = 346;
      __int16 v14 = 1024;
      LODWORD(v15) = v4;
      _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d AcquireStateLock() failed with error %i", buf, 0x18u);
    }
  }
  int v6 = atomic_load((unsigned __int8 *)this);
  if (v6 == 1)
  {
    (*(void (**)(void))(**((void **)this + 86) + 48))(*((void *)this + 86));
    atomic_store(2u, (unsigned __int8 *)this);
  }
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v8);
  return 0;
}

void sub_221EE98BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::Stop(Phase::Controller::VoiceManager::Implementation *this)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v2 = **(id **)(Phase::Logger::GetInstance(this) + 384);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    __int16 v15 = "CvmVoiceManager.mm";
    __int16 v16 = 1024;
    int v17 = 364;
    __int16 v18 = 2048;
    uint64_t v19 = this;
    _os_log_impl(&dword_221E5E000, v2, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message Stop()", buf, 0x1Cu);
  }
  __int16 v12 = (char *)this + 8;
  BOOL v13 = std::__shared_mutex_base::try_lock((std::__shared_mutex_base *)((char *)this + 8));
  unint64_t v3 = (Phase::Logger *)Phase::Controller::VoiceManager::Implementation::AcquireStateLock((uint64_t)this, (uint64_t)&v12, 0, 0.0);
  int v4 = (int)v3;
  if (v3)
  {
    uint64_t v5 = **(id **)(Phase::Logger::GetInstance(v3) + 384);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      __int16 v15 = "CvmVoiceManager.mm";
      __int16 v16 = 1024;
      int v17 = 371;
      __int16 v18 = 1024;
      LODWORD(v19) = v4;
      _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d AcquireStateLock() failed with error %i", buf, 0x18u);
    }
  }
  if (atomic_load((unsigned __int8 *)this))
  {
    (*(void (**)(void))(**((void **)this + 86) + 56))(*((void *)this + 86));
    Phase::Controller::SpatialModelerSystem::Stop((Phase::Controller::VoiceManager::Implementation *)((char *)this + 560));
    Phase::Controller::SubmixSystem::Stop((Phase::Controller::VoiceManager::Implementation *)((char *)this + 224));
    Phase::Controller::DVM::VoiceGraph::RemoveMaster(*(Phase::Controller::DVM::VoiceGraph **)(**((void **)this + 87) + 72), 0xFFFFFFFFFFFFFFFELL);
    atomic_store(0, (unsigned __int8 *)this);
    uint64_t v7 = *((void *)this + 89);
    if (v7)
    {
      for (uint64_t i = *(uint64_t ***)(v7 + 56); i; uint64_t i = (uint64_t **)*i)
        (*(void (**)(uint64_t *))(*i[4] + 16))(i[4]);
    }
    if (!atomic_load((unsigned __int8 *)this))
    {
      for (j = (uint64_t **)*((void *)this + 72); j; j = (uint64_t **)*j)
        Phase::Controller::SpatialModelerCategory::Reset((Phase::Controller::SpatialModelerCategory *)j[3]);
      Phase::Controller::SubmixSystem::Reset((Phase::Controller::VoiceManager::Implementation *)((char *)this + 224));
      Phase::Controller::DSPVoiceManager::Implementation::Reset(**((Phase::Controller::DSPVoiceManager::Implementation ***)this
                                                                 + 87));
    }
    __assert_rtn("Reset", "CvmVoiceManager.mm", 241, "mState == State::Stopped");
  }
  std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v12);
  return 0;
}

void sub_221EE9B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::Update(Phase::Controller::VoiceManager::Implementation *this, double a2)
{
  uint64_t v55 = *MEMORY[0x263EF8340];
  if (a2 <= 0.0) {
    return 1;
  }
  uint64_t Instance = Phase::Logger::GetInstance(this);
  uint64_t v5 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 896));
  int v6 = (Phase::Logger *)Phase::Logger::GetInstance(v5);
  if (*((unsigned char *)v6 + 904))
  {
    uint64_t v7 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v6)
                                                                                       + 896)));
    os_signpost_id_t v8 = v7;
    if ((unint64_t)v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v8, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v5, "Phase_CVM_Update", "CVM Update", buf, 2u);
    }
  }
  uint64_t v40 = (char *)this + 8;
  char v41 = 1;
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)((char *)this + 8));
  Phase::Controller::SubmixSystem::Update((Phase::Controller::VoiceManager::Implementation *)((char *)this + 224), a2);
  for (uint64_t i = (uint64_t **)*((void *)this + 72); i; uint64_t i = (uint64_t **)*i)
    Phase::Controller::SpatialModelerCategory::Update((Phase::Controller::SpatialModelerInstance **)i[3], a2);
  Phase::Controller::DSPVoiceManager::Update(*((Phase::Controller::DSPVoiceManager **)this + 87));
  uint64_t v10 = (Phase::Logger *)Phase::Controller::TapManager::Update(*((Phase::Controller::TapManager **)this + 89));
  if (*((unsigned char *)this + 1001))
  {
    double v11 = *((double *)this + 126) + a2;
    *((double *)this + 126) = v11;
    if (v11 >= *((double *)this + 127))
    {
      Phase::Controller::SubmixSystem::GetStats((Phase::Controller::RendererSystem **)this + 28, (uint64_t)v48);
      std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)buf);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"\n=== CVM Statistics @ Time ", 27);
      __int16 v12 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" ===\n", 5);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"Submix States (stopped/sleeping/preparing/ready/playing/paused/beginsleeping/sleeping)\n", 87);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"Generator States (new/preparing/active/stopping/finished)\n", 58);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"Renderer States (stopped/playing/paused/resumed)\n", 49);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"* Num. Spatial Submixes (s/s/p/r/p/p/b/s): (", 44);
      for (uint64_t j = 0; j != 28; j += 4)
      {
        __int16 v14 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)"/", 1);
      }
      __int16 v15 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)")\n", 2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"* Num. Ambient Submixes (s/s/p/r/p/p/b/s): (", 44);
      for (uint64_t k = 32; k != 60; k += 4)
      {
        int v17 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"/", 1);
      }
      __int16 v18 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)")\n", 2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"* Num. Channel Submixes (s/s/p/r/p/p/b/s): (", 44);
      for (uint64_t m = 64; m != 92; m += 4)
      {
        uint64_t v20 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"/", 1);
      }
      uint64_t v21 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)")\n", 2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"* Num. Generators (n/p/a/s/f): (", 32);
      for (uint64_t n = 96; n != 112; n += 4)
      {
        uint64_t v23 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"/", 1);
      }
      uint8x8_t v24 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)")\n", 2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"* Num. Convolution Renderers (s/p/p/r): (", 41);
      for (iuint64_t i = 116; ii != 128; ii += 4)
      {
        int v26 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"/", 1);
      }
      __int16 v27 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)")\n", 2);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)"* Num. Matrix Renderers (s/p/p/r): (", 36);
      for (juint64_t j = 132; jj != 144; jj += 4)
      {
        __int16 v29 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)"/", 1);
      }
      int v30 = (void *)std::ostream::operator<<();
      uint64_t v31 = (Phase::Logger *)std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)")\n", 2);
      unint64_t v32 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v31)
                                                                                          + 384)));
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        std::stringbuf::str();
        unint64_t v33 = v43 >= 0 ? &__p : (void **)__p;
        *(_DWORD *)uint64_t v49 = 136315650;
        uint64_t v50 = "CvmVoiceManager.mm";
        __int16 v51 = 1024;
        int v52 = 1410;
        __int16 v53 = 2080;
        uint64_t v54 = v33;
        _os_log_impl(&dword_221E5E000, v32, OS_LOG_TYPE_DEFAULT, "%25s:%-5d %s", v49, 0x1Cu);
        if (v43 < 0) {
          operator delete(__p);
        }
      }

      int v34 = (void *)MEMORY[0x263F8C2B8];
      *((void *)this + 126) = 0;
      *(void *)buf = *v34;
      uint64_t v35 = v34[9];
      *(void *)&buf[*(void *)(*(void *)buf - 24)] = v34[8];
      v45[0] = v35;
      v45[1] = MEMORY[0x263F8C318] + 16;
      if (v46 < 0) {
        operator delete((void *)v45[9]);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      uint64_t v10 = (Phase::Logger *)MEMORY[0x223C937D0](&v47);
    }
    *((double *)this + 128) = *((double *)this + 128) + a2;
  }
  uint64_t v36 = (Phase::Logger *)Phase::Logger::GetInstance(v10);
  if (*((unsigned char *)v36 + 904))
  {
    __int16 v37 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v36)
                                                                                        + 896)));
    int v38 = v37;
    if ((unint64_t)v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v37))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v38, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v5, "Phase_CVM_Update", (const char *)&unk_222112ABB, buf, 2u);
    }
  }
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v40);
  return 0;
}

void sub_221EEA238(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  unint64_t v3 = v2;

  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va1);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_221EEA31C(void *a1, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(a1);
    Phase::Controller::sCatchAll((Phase::Controller *)"Update", v2);
  }
  JUMPOUT(0x221EEA314);
}

void sub_221EEA338()
{
}

void sub_221EEA340()
{
}

void sub_221EEA34C(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x221EEA314);
}

uint64_t Phase::Controller::VoiceManager::Implementation::CreateSpatialSubmix(Phase::Controller::VoiceManager::Implementation *this, const Phase::Controller::CreateSpatialSubmixParameters *a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (*((void *)a2 + 10))
  {
    if (*(void *)a2)
    {
      if (*((void *)a2 + 3)) {
        Phase::Controller::SubmixSystem::CreateSpatialSubmix((Phase::Controller::VoiceManager::Implementation *)((char *)this + 224), a2);
      }
      uint64_t v8 = **(id **)(Phase::Logger::GetInstance(this) + 384);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = *((void *)a2 + 3);
        int v12 = 136315906;
        BOOL v13 = "CvmVoiceManager.mm";
        __int16 v14 = 1024;
        int v15 = 526;
        __int16 v16 = 2048;
        int v17 = this;
        __int16 v18 = 2048;
        uint64_t v19 = v10;
        uint64_t v5 = "%25s:%-5d impl@%p: invalid source handle 0x%llx";
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t v8 = **(id **)(Phase::Logger::GetInstance(this) + 384);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = *(void *)a2;
        int v12 = 136315906;
        BOOL v13 = "CvmVoiceManager.mm";
        __int16 v14 = 1024;
        int v15 = 519;
        __int16 v16 = 2048;
        int v17 = this;
        __int16 v18 = 2048;
        uint64_t v19 = v9;
        uint64_t v5 = "%25s:%-5d impl@%p: invalid listener handle 0x%llx";
LABEL_11:
        int v6 = v8;
        uint32_t v7 = 38;
        goto LABEL_12;
      }
    }
  }
  else
  {
    int v4 = **(id **)(Phase::Logger::GetInstance(this) + 384);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v12 = 136315650;
      BOOL v13 = "CvmVoiceManager.mm";
      __int16 v14 = 1024;
      int v15 = 512;
      __int16 v16 = 2048;
      int v17 = this;
      uint64_t v5 = "%25s:%-5d impl@%p: spatial category parameters argument is empty";
      int v6 = v4;
      uint32_t v7 = 28;
LABEL_12:
      _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_ERROR, v5, (uint8_t *)&v12, v7);
    }
  }
  return 1;
}

void sub_221EEA564(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"CreateSpatialSubmix", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::CreateChannelSubmix(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  BOOL IsLayoutSupported = Phase::ChannelLayout::IsLayoutSupported((unsigned int **)(a2 + 16));
  if (IsLayoutSupported) {
    Phase::Controller::SubmixSystem::CreateChannelSubmix(a1 + 224);
  }
  int v4 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)IsLayoutSupported) + 384);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    int v6 = 136315650;
    uint32_t v7 = "CvmVoiceManager.mm";
    __int16 v8 = 1024;
    int v9 = 538;
    __int16 v10 = 2048;
    uint64_t v11 = a1;
    _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d impl@%p: invalid input channel layout for channel submix", (uint8_t *)&v6, 0x1Cu);
  }
  return 1;
}

void sub_221EEA6A8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"CreateChannelSubmix", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::CreateAmbientSubmix(Phase::Logger *a1, unsigned int **a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (*a2)
  {
    BOOL IsLayoutSupported = Phase::ChannelLayout::IsLayoutSupported(a2 + 5);
    if (IsLayoutSupported) {
      Phase::Controller::SubmixSystem::CreateAmbientSubmix((uint64_t)a1 + 224);
    }
    __int16 v10 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)IsLayoutSupported)
                                                     + 384));
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v12 = 136315650;
      BOOL v13 = "CvmVoiceManager.mm";
      __int16 v14 = 1024;
      int v15 = 556;
      __int16 v16 = 2048;
      int v17 = a1;
      uint32_t v7 = "%25s:%-5d impl@%p: invalid input channel layout to create ambient submix";
      __int16 v8 = v10;
      uint32_t v9 = 28;
      goto LABEL_8;
    }
  }
  else
  {
    uint64_t v5 = **(id **)(Phase::Logger::GetInstance(a1) + 384);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = *a2;
      int v12 = 136315906;
      BOOL v13 = "CvmVoiceManager.mm";
      __int16 v14 = 1024;
      int v15 = 550;
      __int16 v16 = 2048;
      int v17 = a1;
      __int16 v18 = 2048;
      uint64_t v19 = v6;
      uint32_t v7 = "%25s:%-5d impl@%p: invalid listener handle 0x%llx";
      __int16 v8 = v5;
      uint32_t v9 = 38;
LABEL_8:
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v12, v9);
    }
  }
  return 1;
}

void sub_221EEA880(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"CreateAmbientSubmix", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::DestroySubmix(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  int v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136315906;
    uint64_t v11 = "CvmVoiceManager.mm";
    __int16 v12 = 1024;
    int v13 = 568;
    __int16 v14 = 2048;
    int v15 = a1;
    __int16 v16 = 2048;
    uint64_t v17 = a2;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message DestroySubmix(%llu)", (uint8_t *)&v10, 0x26u);
  }
  Phase::Controller::SubmixSystem::Destroy((Phase::Logger *)(a1 + 28), a2, a3);
  uint64_t v7 = a1[89];
  if (v7)
  {
    for (uint64_t i = *(uint64_t ***)(v7 + 56); i; uint64_t i = (uint64_t **)*i)
      (*(void (**)(uint64_t *, uint64_t, uint64_t))(*i[4] + 56))(i[4], a2, a3);
  }
  return 0;
}

void sub_221EEAA10(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"DestroySubmix", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::SetSubmixParameter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t Submix = Phase::Controller::SubmixSystem::GetSubmix((Phase::Logger *)(a1 + 224), a2, a3);
  (*(void (**)(uint64_t, uint64_t, double))(*(void *)Submix + 144))(Submix, a4, a5);
  return 0;
}

void sub_221EEAAD4(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SetSubmixParameter", v1);
}

void sub_221EEAAE4()
{
}

void sub_221EEAAF4(_Unwind_Exception *a1)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::SetSubmixParameterData(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t Submix = Phase::Controller::SubmixSystem::GetSubmix((Phase::Logger *)(a1 + 224), a2, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)Submix + 152))(Submix, a4, a5, a6);
  return 0;
}

void sub_221EEAB74(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SetSubmixParameterData", v1);
}

void sub_221EEAB84()
{
}

void sub_221EEAB94(_Unwind_Exception *a1)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::SetSpatialCategorySendLevel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t Submix = Phase::Controller::SubmixSystem::GetSubmix((Phase::Logger *)(a1 + 224), a2, a3);
  (*(void (**)(uint64_t, uint64_t, double))(*(void *)Submix + 248))(Submix, a4, a5);
  return 0;
}

void sub_221EEAC0C(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SetSpatialCategorySendLevel", v1);
}

void sub_221EEAC1C()
{
}

void sub_221EEAC2C(_Unwind_Exception *a1)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::SetSpatialCategoryParameter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t Submix = Phase::Controller::SubmixSystem::GetSubmix((Phase::Logger *)(a1 + 224), a2, a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t, double))(*(void *)Submix + 256))(Submix, a4, a5, a6);
  return 0;
}

void sub_221EEACB4(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SetSpatialCategoryParameter", v1);
}

void sub_221EEACC4()
{
}

void sub_221EEACD4(_Unwind_Exception *a1)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::SetSpatialCategoryUpdateRate(unsigned __int8 *a1, int a2, double a3)
{
  uint64_t v86 = *MEMORY[0x263EF8340];
  int v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__p = 136316162;
    *(void *)&__p[4] = "CvmVoiceManager.mm";
    *(_WORD *)&__p[12] = 1024;
    *(_DWORD *)&__p[14] = 726;
    *(_WORD *)&__p[18] = 2048;
    *(void *)&__p[20] = a1;
    __int16 v82 = 1024;
    int v83 = a2;
    __int16 v84 = 2048;
    double v85 = a3;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message SetSpatialCategoryUpdateRate(spatial category: %d, value: %f)", __p, 0x2Cu);
  }
  uint64_t v7 = (char *)operator new(0x18uLL);
  *(_DWORD *)uint64_t v7 = a2;
  *(void *)(v7 + 4) = 0x100000001;
  *((_DWORD *)v7 + 3) = 1;
  *((double *)v7 + 2) = a3;
  *(void *)&__p[8] = v7 + 24;
  *(void *)&__p[16] = v7 + 24;
  *(void *)__p = v7;
  uint32_t v9 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], 2uLL);
  int v10 = *(char **)__p;
  uint64_t v11 = *(char **)&__p[8];
  *((_DWORD *)v9 + 6) = a2;
  __int16 v12 = v9 + 24;
  int v13 = &v9[24 * v8];
  *(void *)(v9 + 28) = 0x200000001;
  *((_DWORD *)v9 + 9) = 1;
  *((double *)v9 + 5) = a3;
  __int16 v14 = v9 + 48;
  if (v11 != v10)
  {
    do
    {
      long long v15 = *(_OWORD *)(v11 - 24);
      *((void *)v12 - 1) = *((void *)v11 - 1);
      *(_OWORD *)(v12 - 24) = v15;
      v12 -= 24;
      v11 -= 24;
    }
    while (v11 != v10);
    int v10 = *(char **)__p;
  }
  *(void *)__p = v12;
  *(void *)&__p[8] = v9 + 48;
  *(void *)&__p[16] = &v9[24 * v8];
  if (v10)
  {
    operator delete(v10);
    int v13 = *(char **)&__p[16];
  }
  *(void *)&__p[8] = v9 + 48;
  if (v14 >= v13)
  {
    uint64_t v17 = *(char **)__p;
    unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    unint64_t v19 = v18 + 1;
    if (v18 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v20 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*(void *)__p] >> 3);
    if (2 * v20 > v19) {
      unint64_t v19 = 2 * v20;
    }
    if (v20 >= 0x555555555555555) {
      unint64_t v21 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v21 = v19;
    }
    if (v21)
    {
      BOOL v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v21);
      uint64_t v17 = *(char **)__p;
      __int16 v14 = *(char **)&__p[8];
    }
    else
    {
      BOOL v22 = 0;
    }
    uint64_t v23 = &v22[24 * v18];
    int v13 = &v22[24 * v21];
    *(_DWORD *)uint64_t v23 = a2;
    *(void *)(v23 + 4) = 0x300000001;
    *((_DWORD *)v23 + 3) = 1;
    *((double *)v23 + 2) = a3;
    __int16 v16 = v23 + 24;
    if (v14 != v17)
    {
      do
      {
        long long v24 = *(_OWORD *)(v14 - 24);
        *((void *)v23 - 1) = *((void *)v14 - 1);
        *(_OWORD *)(v23 - 24) = v24;
        v23 -= 24;
        v14 -= 24;
      }
      while (v14 != v17);
      uint64_t v17 = *(char **)__p;
    }
    *(void *)__p = v23;
    *(void *)&__p[8] = v16;
    *(void *)&__p[16] = v13;
    if (v17)
    {
      operator delete(v17);
      int v13 = *(char **)&__p[16];
    }
  }
  else
  {
    *((_DWORD *)v9 + 12) = a2;
    *(void *)(v9 + 52) = 0x300000001;
    *((_DWORD *)v9 + 15) = 1;
    *((double *)v9 + 8) = a3;
    __int16 v16 = v9 + 72;
  }
  *(void *)&__p[8] = v16;
  if (v16 >= v13)
  {
    int v26 = *(char **)__p;
    unint64_t v27 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v16[-*(void *)__p] >> 3);
    unint64_t v28 = v27 + 1;
    if (v27 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*(void *)__p] >> 3);
    if (2 * v29 > v28) {
      unint64_t v28 = 2 * v29;
    }
    if (v29 >= 0x555555555555555) {
      unint64_t v30 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v30 = v28;
    }
    if (v30)
    {
      uint64_t v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v30);
      int v26 = *(char **)__p;
      __int16 v16 = *(char **)&__p[8];
    }
    else
    {
      uint64_t v31 = 0;
    }
    unint64_t v32 = &v31[24 * v27];
    int v13 = &v31[24 * v30];
    *(_DWORD *)unint64_t v32 = a2;
    *(void *)(v32 + 4) = 0x100000002;
    *((_DWORD *)v32 + 3) = 1;
    *((double *)v32 + 2) = a3;
    __int16 v25 = v32 + 24;
    if (v16 != v26)
    {
      do
      {
        long long v33 = *(_OWORD *)(v16 - 24);
        *((void *)v32 - 1) = *((void *)v16 - 1);
        *(_OWORD *)(v32 - 24) = v33;
        v32 -= 24;
        v16 -= 24;
      }
      while (v16 != v26);
      int v26 = *(char **)__p;
    }
    *(void *)__p = v32;
    *(void *)&__p[8] = v25;
    *(void *)&__p[16] = v13;
    if (v26)
    {
      operator delete(v26);
      int v13 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)__int16 v16 = a2;
    *(void *)(v16 + 4) = 0x100000002;
    *((_DWORD *)v16 + 3) = 1;
    *((double *)v16 + 2) = a3;
    __int16 v25 = v16 + 24;
  }
  *(void *)&__p[8] = v25;
  if (v25 >= v13)
  {
    uint64_t v35 = *(char **)__p;
    unint64_t v36 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v25[-*(void *)__p] >> 3);
    unint64_t v37 = v36 + 1;
    if (v36 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*(void *)__p] >> 3);
    if (2 * v38 > v37) {
      unint64_t v37 = 2 * v38;
    }
    if (v38 >= 0x555555555555555) {
      unint64_t v39 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v39 = v37;
    }
    if (v39)
    {
      uint64_t v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v39);
      uint64_t v35 = *(char **)__p;
      __int16 v25 = *(char **)&__p[8];
    }
    else
    {
      uint64_t v40 = 0;
    }
    char v41 = &v40[24 * v36];
    int v13 = &v40[24 * v39];
    *(_DWORD *)char v41 = a2;
    *(void *)(v41 + 4) = 0x200000002;
    *((_DWORD *)v41 + 3) = 1;
    *((double *)v41 + 2) = a3;
    int v34 = v41 + 24;
    if (v25 != v35)
    {
      do
      {
        long long v42 = *(_OWORD *)(v25 - 24);
        *((void *)v41 - 1) = *((void *)v25 - 1);
        *(_OWORD *)(v41 - 24) = v42;
        v41 -= 24;
        v25 -= 24;
      }
      while (v25 != v35);
      uint64_t v35 = *(char **)__p;
    }
    *(void *)__p = v41;
    *(void *)&__p[8] = v34;
    *(void *)&__p[16] = v13;
    if (v35)
    {
      operator delete(v35);
      int v13 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)__int16 v25 = a2;
    *(void *)(v25 + 4) = 0x200000002;
    *((_DWORD *)v25 + 3) = 1;
    *((double *)v25 + 2) = a3;
    int v34 = v25 + 24;
  }
  *(void *)&__p[8] = v34;
  if (v34 >= v13)
  {
    uint64_t v44 = *(char **)__p;
    unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v34[-*(void *)__p] >> 3);
    unint64_t v46 = v45 + 1;
    if (v45 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v47 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*(void *)__p] >> 3);
    if (2 * v47 > v46) {
      unint64_t v46 = 2 * v47;
    }
    if (v47 >= 0x555555555555555) {
      unint64_t v48 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v48 = v46;
    }
    if (v48)
    {
      uint64_t v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v48);
      uint64_t v44 = *(char **)__p;
      int v34 = *(char **)&__p[8];
    }
    else
    {
      uint64_t v49 = 0;
    }
    uint64_t v50 = &v49[24 * v45];
    int v13 = &v49[24 * v48];
    *(_DWORD *)uint64_t v50 = a2;
    *(void *)(v50 + 4) = 0x300000002;
    *((_DWORD *)v50 + 3) = 1;
    *((double *)v50 + 2) = a3;
    char v43 = v50 + 24;
    if (v34 != v44)
    {
      do
      {
        long long v51 = *(_OWORD *)(v34 - 24);
        *((void *)v50 - 1) = *((void *)v34 - 1);
        *(_OWORD *)(v50 - 24) = v51;
        v50 -= 24;
        v34 -= 24;
      }
      while (v34 != v44);
      uint64_t v44 = *(char **)__p;
    }
    *(void *)__p = v50;
    *(void *)&__p[8] = v43;
    *(void *)&__p[16] = v13;
    if (v44)
    {
      operator delete(v44);
      int v13 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)int v34 = a2;
    *(void *)(v34 + 4) = 0x300000002;
    *((_DWORD *)v34 + 3) = 1;
    *((double *)v34 + 2) = a3;
    char v43 = v34 + 24;
  }
  *(void *)&__p[8] = v43;
  if (v43 >= v13)
  {
    __int16 v53 = *(char **)__p;
    unint64_t v54 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v43[-*(void *)__p] >> 3);
    unint64_t v55 = v54 + 1;
    if (v54 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v56 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*(void *)__p] >> 3);
    if (2 * v56 > v55) {
      unint64_t v55 = 2 * v56;
    }
    if (v56 >= 0x555555555555555) {
      unint64_t v57 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v57 = v55;
    }
    if (v57)
    {
      v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v57);
      __int16 v53 = *(char **)__p;
      char v43 = *(char **)&__p[8];
    }
    else
    {
      v58 = 0;
    }
    v59 = &v58[24 * v54];
    int v13 = &v58[24 * v57];
    *(_DWORD *)v59 = a2;
    *(void *)(v59 + 4) = 0x100000003;
    *((_DWORD *)v59 + 3) = 1;
    *((double *)v59 + 2) = a3;
    int v52 = v59 + 24;
    if (v43 != v53)
    {
      do
      {
        long long v60 = *(_OWORD *)(v43 - 24);
        *((void *)v59 - 1) = *((void *)v43 - 1);
        *(_OWORD *)(v59 - 24) = v60;
        v59 -= 24;
        v43 -= 24;
      }
      while (v43 != v53);
      __int16 v53 = *(char **)__p;
    }
    *(void *)__p = v59;
    *(void *)&__p[8] = v52;
    *(void *)&__p[16] = v13;
    if (v53)
    {
      operator delete(v53);
      int v13 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)char v43 = a2;
    *(void *)(v43 + 4) = 0x100000003;
    *((_DWORD *)v43 + 3) = 1;
    *((double *)v43 + 2) = a3;
    int v52 = v43 + 24;
  }
  *(void *)&__p[8] = v52;
  if (v52 >= v13)
  {
    v62 = *(char **)__p;
    unint64_t v63 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v52[-*(void *)__p] >> 3);
    unint64_t v64 = v63 + 1;
    if (v63 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v65 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*(void *)__p] >> 3);
    if (2 * v65 > v64) {
      unint64_t v64 = 2 * v65;
    }
    if (v65 >= 0x555555555555555) {
      unint64_t v66 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v66 = v64;
    }
    if (v66)
    {
      v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v66);
      v62 = *(char **)__p;
      int v52 = *(char **)&__p[8];
    }
    else
    {
      v67 = 0;
    }
    v68 = &v67[24 * v63];
    int v13 = &v67[24 * v66];
    *(_DWORD *)v68 = a2;
    *(void *)(v68 + 4) = 0x200000003;
    *((_DWORD *)v68 + 3) = 1;
    *((double *)v68 + 2) = a3;
    v61 = v68 + 24;
    if (v52 != v62)
    {
      do
      {
        long long v69 = *(_OWORD *)(v52 - 24);
        *((void *)v68 - 1) = *((void *)v52 - 1);
        *(_OWORD *)(v68 - 24) = v69;
        v68 -= 24;
        v52 -= 24;
      }
      while (v52 != v62);
      v62 = *(char **)__p;
    }
    *(void *)__p = v68;
    *(void *)&__p[8] = v61;
    *(void *)&__p[16] = v13;
    if (v62)
    {
      operator delete(v62);
      int v13 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)int v52 = a2;
    *(void *)(v52 + 4) = 0x200000003;
    *((_DWORD *)v52 + 3) = 1;
    *((double *)v52 + 2) = a3;
    v61 = v52 + 24;
  }
  *(void *)&__p[8] = v61;
  if (v61 >= v13)
  {
    v71 = *(char **)__p;
    unint64_t v72 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v61[-*(void *)__p] >> 3);
    unint64_t v73 = v72 + 1;
    if (v72 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v74 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*(void *)__p] >> 3);
    if (2 * v74 > v73) {
      unint64_t v73 = 2 * v74;
    }
    if (v74 >= 0x555555555555555) {
      unint64_t v75 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v75 = v73;
    }
    if (v75)
    {
      v76 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v75);
      v71 = *(char **)__p;
      v61 = *(char **)&__p[8];
    }
    else
    {
      v76 = 0;
    }
    v77 = &v76[24 * v72];
    v78 = &v76[24 * v75];
    *(_DWORD *)v77 = a2;
    *(void *)(v77 + 4) = 0x300000003;
    *((_DWORD *)v77 + 3) = 1;
    *((double *)v77 + 2) = a3;
    v70 = v77 + 24;
    if (v61 != v71)
    {
      do
      {
        long long v79 = *(_OWORD *)(v61 - 24);
        *((void *)v77 - 1) = *((void *)v61 - 1);
        *(_OWORD *)(v77 - 24) = v79;
        v77 -= 24;
        v61 -= 24;
      }
      while (v61 != v71);
      v71 = *(char **)__p;
    }
    *(void *)__p = v77;
    *(void *)&__p[8] = v70;
    *(void *)&__p[16] = v78;
    if (v71) {
      operator delete(v71);
    }
  }
  else
  {
    *(_DWORD *)v61 = a2;
    *(void *)(v61 + 4) = 0x300000003;
    *((_DWORD *)v61 + 3) = 1;
    *((double *)v61 + 2) = a3;
    v70 = v61 + 24;
  }
  *(void *)&__p[8] = v70;
  Phase::Controller::SpatialModelerSystem::SetParameters(a1 + 560, (uint64_t *)__p);
  if (*(void *)__p)
  {
    *(void *)&__p[8] = *(void *)__p;
    operator delete(*(void **)__p);
  }
  return 0;
}

void sub_221EEB614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (a2)
  {
    if (__p) {
      operator delete(__p);
    }
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"SetSpatialCategoryUpdateRate", v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::SetSpatialCategoryBandCount(unsigned __int8 *a1, int a2, unint64_t a3)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  int v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__p = 136316162;
    *(void *)&__p[4] = "CvmVoiceManager.mm";
    *(_WORD *)&__p[12] = 1024;
    *(_DWORD *)&__p[14] = 774;
    *(_WORD *)&__p[18] = 2048;
    *(void *)&__p[20] = a1;
    __int16 v83 = 1024;
    int v84 = a2;
    __int16 v85 = 2048;
    unint64_t v86 = a3;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message SetSpatialCategoryBandCount(spatial category: %d, band count: %zu)", __p, 0x2Cu);
  }
  memset(__p, 0, 24);
  uint64_t v7 = (char *)operator new(0x18uLL);
  double v8 = (double)a3;
  *(_DWORD *)uint64_t v7 = a2;
  *(void *)(v7 + 4) = 0x100000001;
  *((_DWORD *)v7 + 3) = 2;
  *((double *)v7 + 2) = (double)a3;
  *(void *)&__p[8] = v7 + 24;
  *(void *)&__p[16] = v7 + 24;
  *(void *)__p = v7;
  int v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], 2uLL);
  uint64_t v11 = *(char **)__p;
  __int16 v12 = *(char **)&__p[8];
  *((_DWORD *)v10 + 6) = a2;
  int v13 = v10 + 24;
  __int16 v14 = &v10[24 * v9];
  *(void *)(v10 + 28) = 0x200000001;
  *((_DWORD *)v10 + 9) = 2;
  *((double *)v10 + 5) = (double)a3;
  long long v15 = v10 + 48;
  if (v12 != v11)
  {
    do
    {
      long long v16 = *(_OWORD *)(v12 - 24);
      *((void *)v13 - 1) = *((void *)v12 - 1);
      *(_OWORD *)(v13 - 24) = v16;
      v13 -= 24;
      v12 -= 24;
    }
    while (v12 != v11);
    uint64_t v11 = *(char **)__p;
  }
  *(void *)__p = v13;
  *(void *)&__p[8] = v10 + 48;
  *(void *)&__p[16] = &v10[24 * v9];
  if (v11)
  {
    operator delete(v11);
    __int16 v14 = *(char **)&__p[16];
  }
  *(void *)&__p[8] = v10 + 48;
  if (v15 >= v14)
  {
    unint64_t v18 = *(char **)__p;
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v15[-*(void *)__p] >> 3);
    unint64_t v20 = v19 + 1;
    if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v21 > v20) {
      unint64_t v20 = 2 * v21;
    }
    if (v21 >= 0x555555555555555) {
      unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v22 = v20;
    }
    if (v22)
    {
      uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v22);
      unint64_t v18 = *(char **)__p;
      long long v15 = *(char **)&__p[8];
    }
    else
    {
      uint64_t v23 = 0;
    }
    long long v24 = &v23[24 * v19];
    __int16 v14 = &v23[24 * v22];
    *(_DWORD *)long long v24 = a2;
    *(void *)(v24 + 4) = 0x300000001;
    *((_DWORD *)v24 + 3) = 2;
    *((double *)v24 + 2) = v8;
    uint64_t v17 = v24 + 24;
    if (v15 != v18)
    {
      do
      {
        long long v25 = *(_OWORD *)(v15 - 24);
        *((void *)v24 - 1) = *((void *)v15 - 1);
        *(_OWORD *)(v24 - 24) = v25;
        v24 -= 24;
        v15 -= 24;
      }
      while (v15 != v18);
      unint64_t v18 = *(char **)__p;
    }
    *(void *)__p = v24;
    *(void *)&__p[8] = v17;
    *(void *)&__p[16] = v14;
    if (v18)
    {
      operator delete(v18);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *((_DWORD *)v10 + 12) = a2;
    *(void *)(v10 + 52) = 0x300000001;
    *((_DWORD *)v10 + 15) = 2;
    *((double *)v10 + 8) = v8;
    uint64_t v17 = v10 + 72;
  }
  *(void *)&__p[8] = v17;
  if (v17 >= v14)
  {
    unint64_t v27 = *(char **)__p;
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v17[-*(void *)__p] >> 3);
    unint64_t v29 = v28 + 1;
    if (v28 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v30 > v29) {
      unint64_t v29 = 2 * v30;
    }
    if (v30 >= 0x555555555555555) {
      unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v31 = v29;
    }
    if (v31)
    {
      unint64_t v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v31);
      unint64_t v27 = *(char **)__p;
      uint64_t v17 = *(char **)&__p[8];
    }
    else
    {
      unint64_t v32 = 0;
    }
    long long v33 = &v32[24 * v28];
    __int16 v14 = &v32[24 * v31];
    *(_DWORD *)long long v33 = a2;
    *(void *)(v33 + 4) = 0x100000002;
    *((_DWORD *)v33 + 3) = 2;
    *((double *)v33 + 2) = v8;
    int v26 = v33 + 24;
    if (v17 != v27)
    {
      do
      {
        long long v34 = *(_OWORD *)(v17 - 24);
        *((void *)v33 - 1) = *((void *)v17 - 1);
        *(_OWORD *)(v33 - 24) = v34;
        v33 -= 24;
        v17 -= 24;
      }
      while (v17 != v27);
      unint64_t v27 = *(char **)__p;
    }
    *(void *)__p = v33;
    *(void *)&__p[8] = v26;
    *(void *)&__p[16] = v14;
    if (v27)
    {
      operator delete(v27);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)uint64_t v17 = a2;
    *(void *)(v17 + 4) = 0x100000002;
    *((_DWORD *)v17 + 3) = 2;
    *((double *)v17 + 2) = v8;
    int v26 = v17 + 24;
  }
  *(void *)&__p[8] = v26;
  if (v26 >= v14)
  {
    unint64_t v36 = *(char **)__p;
    unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v26[-*(void *)__p] >> 3);
    unint64_t v38 = v37 + 1;
    if (v37 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v39 > v38) {
      unint64_t v38 = 2 * v39;
    }
    if (v39 >= 0x555555555555555) {
      unint64_t v40 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v40 = v38;
    }
    if (v40)
    {
      char v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v40);
      unint64_t v36 = *(char **)__p;
      int v26 = *(char **)&__p[8];
    }
    else
    {
      char v41 = 0;
    }
    long long v42 = &v41[24 * v37];
    __int16 v14 = &v41[24 * v40];
    *(_DWORD *)long long v42 = a2;
    *(void *)(v42 + 4) = 0x200000002;
    *((_DWORD *)v42 + 3) = 2;
    *((double *)v42 + 2) = v8;
    uint64_t v35 = v42 + 24;
    if (v26 != v36)
    {
      do
      {
        long long v43 = *(_OWORD *)(v26 - 24);
        *((void *)v42 - 1) = *((void *)v26 - 1);
        *(_OWORD *)(v42 - 24) = v43;
        v42 -= 24;
        v26 -= 24;
      }
      while (v26 != v36);
      unint64_t v36 = *(char **)__p;
    }
    *(void *)__p = v42;
    *(void *)&__p[8] = v35;
    *(void *)&__p[16] = v14;
    if (v36)
    {
      operator delete(v36);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)int v26 = a2;
    *(void *)(v26 + 4) = 0x200000002;
    *((_DWORD *)v26 + 3) = 2;
    *((double *)v26 + 2) = v8;
    uint64_t v35 = v26 + 24;
  }
  *(void *)&__p[8] = v35;
  if (v35 >= v14)
  {
    unint64_t v45 = *(char **)__p;
    unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v35[-*(void *)__p] >> 3);
    unint64_t v47 = v46 + 1;
    if (v46 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v48 > v47) {
      unint64_t v47 = 2 * v48;
    }
    if (v48 >= 0x555555555555555) {
      unint64_t v49 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v49 = v47;
    }
    if (v49)
    {
      uint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v49);
      unint64_t v45 = *(char **)__p;
      uint64_t v35 = *(char **)&__p[8];
    }
    else
    {
      uint64_t v50 = 0;
    }
    long long v51 = &v50[24 * v46];
    __int16 v14 = &v50[24 * v49];
    *(_DWORD *)long long v51 = a2;
    *(void *)(v51 + 4) = 0x300000002;
    *((_DWORD *)v51 + 3) = 2;
    *((double *)v51 + 2) = v8;
    uint64_t v44 = v51 + 24;
    if (v35 != v45)
    {
      do
      {
        long long v52 = *(_OWORD *)(v35 - 24);
        *((void *)v51 - 1) = *((void *)v35 - 1);
        *(_OWORD *)(v51 - 24) = v52;
        v51 -= 24;
        v35 -= 24;
      }
      while (v35 != v45);
      unint64_t v45 = *(char **)__p;
    }
    *(void *)__p = v51;
    *(void *)&__p[8] = v44;
    *(void *)&__p[16] = v14;
    if (v45)
    {
      operator delete(v45);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)uint64_t v35 = a2;
    *(void *)(v35 + 4) = 0x300000002;
    *((_DWORD *)v35 + 3) = 2;
    *((double *)v35 + 2) = v8;
    uint64_t v44 = v35 + 24;
  }
  *(void *)&__p[8] = v44;
  if (v44 >= v14)
  {
    unint64_t v54 = *(char **)__p;
    unint64_t v55 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v44[-*(void *)__p] >> 3);
    unint64_t v56 = v55 + 1;
    if (v55 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v57 > v56) {
      unint64_t v56 = 2 * v57;
    }
    if (v57 >= 0x555555555555555) {
      unint64_t v58 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v58 = v56;
    }
    if (v58)
    {
      v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v58);
      unint64_t v54 = *(char **)__p;
      uint64_t v44 = *(char **)&__p[8];
    }
    else
    {
      v59 = 0;
    }
    long long v60 = &v59[24 * v55];
    __int16 v14 = &v59[24 * v58];
    *(_DWORD *)long long v60 = a2;
    *(void *)(v60 + 4) = 0x100000003;
    *((_DWORD *)v60 + 3) = 2;
    *((double *)v60 + 2) = v8;
    __int16 v53 = v60 + 24;
    if (v44 != v54)
    {
      do
      {
        long long v61 = *(_OWORD *)(v44 - 24);
        *((void *)v60 - 1) = *((void *)v44 - 1);
        *(_OWORD *)(v60 - 24) = v61;
        v60 -= 24;
        v44 -= 24;
      }
      while (v44 != v54);
      unint64_t v54 = *(char **)__p;
    }
    *(void *)__p = v60;
    *(void *)&__p[8] = v53;
    *(void *)&__p[16] = v14;
    if (v54)
    {
      operator delete(v54);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)uint64_t v44 = a2;
    *(void *)(v44 + 4) = 0x100000003;
    *((_DWORD *)v44 + 3) = 2;
    *((double *)v44 + 2) = v8;
    __int16 v53 = v44 + 24;
  }
  *(void *)&__p[8] = v53;
  if (v53 >= v14)
  {
    unint64_t v63 = *(char **)__p;
    unint64_t v64 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v53[-*(void *)__p] >> 3);
    unint64_t v65 = v64 + 1;
    if (v64 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v66 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v66 > v65) {
      unint64_t v65 = 2 * v66;
    }
    if (v66 >= 0x555555555555555) {
      unint64_t v67 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v67 = v65;
    }
    if (v67)
    {
      v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v67);
      unint64_t v63 = *(char **)__p;
      __int16 v53 = *(char **)&__p[8];
    }
    else
    {
      v68 = 0;
    }
    long long v69 = &v68[24 * v64];
    __int16 v14 = &v68[24 * v67];
    *(_DWORD *)long long v69 = a2;
    *(void *)(v69 + 4) = 0x200000003;
    *((_DWORD *)v69 + 3) = 2;
    *((double *)v69 + 2) = v8;
    v62 = v69 + 24;
    if (v53 != v63)
    {
      do
      {
        long long v70 = *(_OWORD *)(v53 - 24);
        *((void *)v69 - 1) = *((void *)v53 - 1);
        *(_OWORD *)(v69 - 24) = v70;
        v69 -= 24;
        v53 -= 24;
      }
      while (v53 != v63);
      unint64_t v63 = *(char **)__p;
    }
    *(void *)__p = v69;
    *(void *)&__p[8] = v62;
    *(void *)&__p[16] = v14;
    if (v63)
    {
      operator delete(v63);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)__int16 v53 = a2;
    *(void *)(v53 + 4) = 0x200000003;
    *((_DWORD *)v53 + 3) = 2;
    *((double *)v53 + 2) = v8;
    v62 = v53 + 24;
  }
  *(void *)&__p[8] = v62;
  if (v62 >= v14)
  {
    unint64_t v72 = *(char **)__p;
    unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v62[-*(void *)__p] >> 3);
    unint64_t v74 = v73 + 1;
    if (v73 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v75 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v75 > v74) {
      unint64_t v74 = 2 * v75;
    }
    if (v75 >= 0x555555555555555) {
      unint64_t v76 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v76 = v74;
    }
    if (v76)
    {
      v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v76);
      unint64_t v72 = *(char **)__p;
      v62 = *(char **)&__p[8];
    }
    else
    {
      v77 = 0;
    }
    v78 = &v77[24 * v73];
    long long v79 = &v77[24 * v76];
    *(_DWORD *)v78 = a2;
    *(void *)(v78 + 4) = 0x300000003;
    *((_DWORD *)v78 + 3) = 2;
    *((double *)v78 + 2) = v8;
    v71 = v78 + 24;
    if (v62 != v72)
    {
      do
      {
        long long v80 = *(_OWORD *)(v62 - 24);
        *((void *)v78 - 1) = *((void *)v62 - 1);
        *(_OWORD *)(v78 - 24) = v80;
        v78 -= 24;
        v62 -= 24;
      }
      while (v62 != v72);
      unint64_t v72 = *(char **)__p;
    }
    *(void *)__p = v78;
    *(void *)&__p[8] = v71;
    *(void *)&__p[16] = v79;
    if (v72) {
      operator delete(v72);
    }
  }
  else
  {
    *(_DWORD *)v62 = a2;
    *(void *)(v62 + 4) = 0x300000003;
    *((_DWORD *)v62 + 3) = 2;
    *((double *)v62 + 2) = v8;
    v71 = v62 + 24;
  }
  *(void *)&__p[8] = v71;
  Phase::Controller::SpatialModelerSystem::SetParameters(a1 + 560, (uint64_t *)__p);
  if (*(void *)__p)
  {
    *(void *)&__p[8] = *(void *)__p;
    operator delete(*(void **)__p);
  }
  return 0;
}

void sub_221EEBFE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (a2)
  {
    if (__p) {
      operator delete(__p);
    }
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"SetSpatialCategoryBandCount", v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::SetSpatialCategoryMaxClusterCount(unsigned __int8 *a1, int a2, unint64_t a3)
{
  uint64_t v87 = *MEMORY[0x263EF8340];
  int v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__p = 136316162;
    *(void *)&__p[4] = "CvmVoiceManager.mm";
    *(_WORD *)&__p[12] = 1024;
    *(_DWORD *)&__p[14] = 821;
    *(_WORD *)&__p[18] = 2048;
    *(void *)&__p[20] = a1;
    __int16 v83 = 1024;
    int v84 = a2;
    __int16 v85 = 2048;
    unint64_t v86 = a3;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message SetSpatialCategoryMaxClusterCount(spatial category: %d, max cluster count: %zu)", __p, 0x2Cu);
  }
  memset(__p, 0, 24);
  uint64_t v7 = (char *)operator new(0x18uLL);
  double v8 = (double)a3;
  *(_DWORD *)uint64_t v7 = a2;
  *(void *)(v7 + 4) = 0x100000001;
  *((_DWORD *)v7 + 3) = 5;
  *((double *)v7 + 2) = (double)a3;
  *(void *)&__p[8] = v7 + 24;
  *(void *)&__p[16] = v7 + 24;
  *(void *)__p = v7;
  int v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], 2uLL);
  uint64_t v11 = *(char **)__p;
  __int16 v12 = *(char **)&__p[8];
  *((_DWORD *)v10 + 6) = a2;
  int v13 = v10 + 24;
  __int16 v14 = &v10[24 * v9];
  *(void *)(v10 + 28) = 0x200000001;
  *((_DWORD *)v10 + 9) = 5;
  *((double *)v10 + 5) = (double)a3;
  long long v15 = v10 + 48;
  if (v12 != v11)
  {
    do
    {
      long long v16 = *(_OWORD *)(v12 - 24);
      *((void *)v13 - 1) = *((void *)v12 - 1);
      *(_OWORD *)(v13 - 24) = v16;
      v13 -= 24;
      v12 -= 24;
    }
    while (v12 != v11);
    uint64_t v11 = *(char **)__p;
  }
  *(void *)__p = v13;
  *(void *)&__p[8] = v10 + 48;
  *(void *)&__p[16] = &v10[24 * v9];
  if (v11)
  {
    operator delete(v11);
    __int16 v14 = *(char **)&__p[16];
  }
  *(void *)&__p[8] = v10 + 48;
  if (v15 >= v14)
  {
    unint64_t v18 = *(char **)__p;
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v15[-*(void *)__p] >> 3);
    unint64_t v20 = v19 + 1;
    if (v19 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v21 > v20) {
      unint64_t v20 = 2 * v21;
    }
    if (v21 >= 0x555555555555555) {
      unint64_t v22 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v22 = v20;
    }
    if (v22)
    {
      uint64_t v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v22);
      unint64_t v18 = *(char **)__p;
      long long v15 = *(char **)&__p[8];
    }
    else
    {
      uint64_t v23 = 0;
    }
    long long v24 = &v23[24 * v19];
    __int16 v14 = &v23[24 * v22];
    *(_DWORD *)long long v24 = a2;
    *(void *)(v24 + 4) = 0x300000001;
    *((_DWORD *)v24 + 3) = 5;
    *((double *)v24 + 2) = v8;
    uint64_t v17 = v24 + 24;
    if (v15 != v18)
    {
      do
      {
        long long v25 = *(_OWORD *)(v15 - 24);
        *((void *)v24 - 1) = *((void *)v15 - 1);
        *(_OWORD *)(v24 - 24) = v25;
        v24 -= 24;
        v15 -= 24;
      }
      while (v15 != v18);
      unint64_t v18 = *(char **)__p;
    }
    *(void *)__p = v24;
    *(void *)&__p[8] = v17;
    *(void *)&__p[16] = v14;
    if (v18)
    {
      operator delete(v18);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *((_DWORD *)v10 + 12) = a2;
    *(void *)(v10 + 52) = 0x300000001;
    *((_DWORD *)v10 + 15) = 5;
    *((double *)v10 + 8) = v8;
    uint64_t v17 = v10 + 72;
  }
  *(void *)&__p[8] = v17;
  if (v17 >= v14)
  {
    unint64_t v27 = *(char **)__p;
    unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v17[-*(void *)__p] >> 3);
    unint64_t v29 = v28 + 1;
    if (v28 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v30 > v29) {
      unint64_t v29 = 2 * v30;
    }
    if (v30 >= 0x555555555555555) {
      unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v31 = v29;
    }
    if (v31)
    {
      unint64_t v32 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v31);
      unint64_t v27 = *(char **)__p;
      uint64_t v17 = *(char **)&__p[8];
    }
    else
    {
      unint64_t v32 = 0;
    }
    long long v33 = &v32[24 * v28];
    __int16 v14 = &v32[24 * v31];
    *(_DWORD *)long long v33 = a2;
    *(void *)(v33 + 4) = 0x100000002;
    *((_DWORD *)v33 + 3) = 5;
    *((double *)v33 + 2) = v8;
    int v26 = v33 + 24;
    if (v17 != v27)
    {
      do
      {
        long long v34 = *(_OWORD *)(v17 - 24);
        *((void *)v33 - 1) = *((void *)v17 - 1);
        *(_OWORD *)(v33 - 24) = v34;
        v33 -= 24;
        v17 -= 24;
      }
      while (v17 != v27);
      unint64_t v27 = *(char **)__p;
    }
    *(void *)__p = v33;
    *(void *)&__p[8] = v26;
    *(void *)&__p[16] = v14;
    if (v27)
    {
      operator delete(v27);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)uint64_t v17 = a2;
    *(void *)(v17 + 4) = 0x100000002;
    *((_DWORD *)v17 + 3) = 5;
    *((double *)v17 + 2) = v8;
    int v26 = v17 + 24;
  }
  *(void *)&__p[8] = v26;
  if (v26 >= v14)
  {
    unint64_t v36 = *(char **)__p;
    unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v26[-*(void *)__p] >> 3);
    unint64_t v38 = v37 + 1;
    if (v37 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v39 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v39 > v38) {
      unint64_t v38 = 2 * v39;
    }
    if (v39 >= 0x555555555555555) {
      unint64_t v40 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v40 = v38;
    }
    if (v40)
    {
      char v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v40);
      unint64_t v36 = *(char **)__p;
      int v26 = *(char **)&__p[8];
    }
    else
    {
      char v41 = 0;
    }
    long long v42 = &v41[24 * v37];
    __int16 v14 = &v41[24 * v40];
    *(_DWORD *)long long v42 = a2;
    *(void *)(v42 + 4) = 0x200000002;
    *((_DWORD *)v42 + 3) = 5;
    *((double *)v42 + 2) = v8;
    uint64_t v35 = v42 + 24;
    if (v26 != v36)
    {
      do
      {
        long long v43 = *(_OWORD *)(v26 - 24);
        *((void *)v42 - 1) = *((void *)v26 - 1);
        *(_OWORD *)(v42 - 24) = v43;
        v42 -= 24;
        v26 -= 24;
      }
      while (v26 != v36);
      unint64_t v36 = *(char **)__p;
    }
    *(void *)__p = v42;
    *(void *)&__p[8] = v35;
    *(void *)&__p[16] = v14;
    if (v36)
    {
      operator delete(v36);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)int v26 = a2;
    *(void *)(v26 + 4) = 0x200000002;
    *((_DWORD *)v26 + 3) = 5;
    *((double *)v26 + 2) = v8;
    uint64_t v35 = v26 + 24;
  }
  *(void *)&__p[8] = v35;
  if (v35 >= v14)
  {
    unint64_t v45 = *(char **)__p;
    unint64_t v46 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v35[-*(void *)__p] >> 3);
    unint64_t v47 = v46 + 1;
    if (v46 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v48 > v47) {
      unint64_t v47 = 2 * v48;
    }
    if (v48 >= 0x555555555555555) {
      unint64_t v49 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v49 = v47;
    }
    if (v49)
    {
      uint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v49);
      unint64_t v45 = *(char **)__p;
      uint64_t v35 = *(char **)&__p[8];
    }
    else
    {
      uint64_t v50 = 0;
    }
    long long v51 = &v50[24 * v46];
    __int16 v14 = &v50[24 * v49];
    *(_DWORD *)long long v51 = a2;
    *(void *)(v51 + 4) = 0x300000002;
    *((_DWORD *)v51 + 3) = 5;
    *((double *)v51 + 2) = v8;
    uint64_t v44 = v51 + 24;
    if (v35 != v45)
    {
      do
      {
        long long v52 = *(_OWORD *)(v35 - 24);
        *((void *)v51 - 1) = *((void *)v35 - 1);
        *(_OWORD *)(v51 - 24) = v52;
        v51 -= 24;
        v35 -= 24;
      }
      while (v35 != v45);
      unint64_t v45 = *(char **)__p;
    }
    *(void *)__p = v51;
    *(void *)&__p[8] = v44;
    *(void *)&__p[16] = v14;
    if (v45)
    {
      operator delete(v45);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)uint64_t v35 = a2;
    *(void *)(v35 + 4) = 0x300000002;
    *((_DWORD *)v35 + 3) = 5;
    *((double *)v35 + 2) = v8;
    uint64_t v44 = v35 + 24;
  }
  *(void *)&__p[8] = v44;
  if (v44 >= v14)
  {
    unint64_t v54 = *(char **)__p;
    unint64_t v55 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v44[-*(void *)__p] >> 3);
    unint64_t v56 = v55 + 1;
    if (v55 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v57 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v57 > v56) {
      unint64_t v56 = 2 * v57;
    }
    if (v57 >= 0x555555555555555) {
      unint64_t v58 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v58 = v56;
    }
    if (v58)
    {
      v59 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v58);
      unint64_t v54 = *(char **)__p;
      uint64_t v44 = *(char **)&__p[8];
    }
    else
    {
      v59 = 0;
    }
    long long v60 = &v59[24 * v55];
    __int16 v14 = &v59[24 * v58];
    *(_DWORD *)long long v60 = a2;
    *(void *)(v60 + 4) = 0x100000003;
    *((_DWORD *)v60 + 3) = 5;
    *((double *)v60 + 2) = v8;
    __int16 v53 = v60 + 24;
    if (v44 != v54)
    {
      do
      {
        long long v61 = *(_OWORD *)(v44 - 24);
        *((void *)v60 - 1) = *((void *)v44 - 1);
        *(_OWORD *)(v60 - 24) = v61;
        v60 -= 24;
        v44 -= 24;
      }
      while (v44 != v54);
      unint64_t v54 = *(char **)__p;
    }
    *(void *)__p = v60;
    *(void *)&__p[8] = v53;
    *(void *)&__p[16] = v14;
    if (v54)
    {
      operator delete(v54);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)uint64_t v44 = a2;
    *(void *)(v44 + 4) = 0x100000003;
    *((_DWORD *)v44 + 3) = 5;
    *((double *)v44 + 2) = v8;
    __int16 v53 = v44 + 24;
  }
  *(void *)&__p[8] = v53;
  if (v53 >= v14)
  {
    unint64_t v63 = *(char **)__p;
    unint64_t v64 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v53[-*(void *)__p] >> 3);
    unint64_t v65 = v64 + 1;
    if (v64 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v66 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v66 > v65) {
      unint64_t v65 = 2 * v66;
    }
    if (v66 >= 0x555555555555555) {
      unint64_t v67 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v67 = v65;
    }
    if (v67)
    {
      v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v67);
      unint64_t v63 = *(char **)__p;
      __int16 v53 = *(char **)&__p[8];
    }
    else
    {
      v68 = 0;
    }
    long long v69 = &v68[24 * v64];
    __int16 v14 = &v68[24 * v67];
    *(_DWORD *)long long v69 = a2;
    *(void *)(v69 + 4) = 0x200000003;
    *((_DWORD *)v69 + 3) = 5;
    *((double *)v69 + 2) = v8;
    v62 = v69 + 24;
    if (v53 != v63)
    {
      do
      {
        long long v70 = *(_OWORD *)(v53 - 24);
        *((void *)v69 - 1) = *((void *)v53 - 1);
        *(_OWORD *)(v69 - 24) = v70;
        v69 -= 24;
        v53 -= 24;
      }
      while (v53 != v63);
      unint64_t v63 = *(char **)__p;
    }
    *(void *)__p = v69;
    *(void *)&__p[8] = v62;
    *(void *)&__p[16] = v14;
    if (v63)
    {
      operator delete(v63);
      __int16 v14 = *(char **)&__p[16];
    }
  }
  else
  {
    *(_DWORD *)__int16 v53 = a2;
    *(void *)(v53 + 4) = 0x200000003;
    *((_DWORD *)v53 + 3) = 5;
    *((double *)v53 + 2) = v8;
    v62 = v53 + 24;
  }
  *(void *)&__p[8] = v62;
  if (v62 >= v14)
  {
    unint64_t v72 = *(char **)__p;
    unint64_t v73 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v62[-*(void *)__p] >> 3);
    unint64_t v74 = v73 + 1;
    if (v73 + 1 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v75 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v14[-*(void *)__p] >> 3);
    if (2 * v75 > v74) {
      unint64_t v74 = 2 * v75;
    }
    if (v75 >= 0x555555555555555) {
      unint64_t v76 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v76 = v74;
    }
    if (v76)
    {
      v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)&__p[16], v76);
      unint64_t v72 = *(char **)__p;
      v62 = *(char **)&__p[8];
    }
    else
    {
      v77 = 0;
    }
    v78 = &v77[24 * v73];
    long long v79 = &v77[24 * v76];
    *(_DWORD *)v78 = a2;
    *(void *)(v78 + 4) = 0x300000003;
    *((_DWORD *)v78 + 3) = 5;
    *((double *)v78 + 2) = v8;
    v71 = v78 + 24;
    if (v62 != v72)
    {
      do
      {
        long long v80 = *(_OWORD *)(v62 - 24);
        *((void *)v78 - 1) = *((void *)v62 - 1);
        *(_OWORD *)(v78 - 24) = v80;
        v78 -= 24;
        v62 -= 24;
      }
      while (v62 != v72);
      unint64_t v72 = *(char **)__p;
    }
    *(void *)__p = v78;
    *(void *)&__p[8] = v71;
    *(void *)&__p[16] = v79;
    if (v72) {
      operator delete(v72);
    }
  }
  else
  {
    *(_DWORD *)v62 = a2;
    *(void *)(v62 + 4) = 0x300000003;
    *((_DWORD *)v62 + 3) = 5;
    *((double *)v62 + 2) = v8;
    v71 = v62 + 24;
  }
  *(void *)&__p[8] = v71;
  Phase::Controller::SpatialModelerSystem::SetParameters(a1 + 560, (uint64_t *)__p);
  if (*(void *)__p)
  {
    *(void *)&__p[8] = *(void *)__p;
    operator delete(*(void **)__p);
  }
  return 0;
}

void sub_221EEC9B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (a2)
  {
    if (__p) {
      operator delete(__p);
    }
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"SetSpatialCategoryMaxClusterCount", v11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::PrepareGenerator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  __int16 v12 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
  if (v13)
  {
    int v17 = 136316162;
    unint64_t v18 = "CvmVoiceManager.mm";
    __int16 v19 = 1024;
    int v20 = 867;
    __int16 v21 = 2048;
    uint64_t v22 = a1;
    __int16 v23 = 2048;
    uint64_t v24 = a2;
    __int16 v25 = 2048;
    uint64_t v26 = a4;
    _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message PrepareGenerator(generator: %llu, submix: %llu, ...)", (uint8_t *)&v17, 0x30u);
  }
  int v14 = atomic_load((unsigned __int8 *)a1);
  if (v14 != 2) {
    Phase::Controller::SubmixSystem::PrepareGenerator((Phase::Logger *)(a1 + 224), a2, a3, a4, a5, a6);
  }
  long long v15 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v13) + 384);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    int v17 = 136315906;
    unint64_t v18 = "CvmVoiceManager.mm";
    __int16 v19 = 1024;
    int v20 = 875;
    __int16 v21 = 2048;
    uint64_t v22 = a1;
    __int16 v23 = 2048;
    uint64_t v24 = a2;
    _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d impl@%p: system is paused, so we're ignoring the request to prepare generatorId %llu", (uint8_t *)&v17, 0x26u);
  }
  return 5;
}

void sub_221EECC18(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"PrepareGenerator", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::PlayGenerator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315906;
    uint64_t v9 = "CvmVoiceManager.mm";
    __int16 v10 = 1024;
    int v11 = 895;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    __int16 v14 = 2048;
    uint64_t v15 = a2;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message PlayGenerator(generator: %llu)", (uint8_t *)&v8, 0x26u);
  }
  Phase::Controller::SubmixSystem::PlayGenerator((Phase::Logger *)(a1 + 224), a2, a3);
  return 0;
}

void sub_221EECD60(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"PlayGenerator", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::PauseGenerator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315906;
    uint64_t v9 = "CvmVoiceManager.mm";
    __int16 v10 = 1024;
    int v11 = 903;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    __int16 v14 = 2048;
    uint64_t v15 = a2;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message PauseGenerator(generator: %llu)", (uint8_t *)&v8, 0x26u);
  }
  Phase::Controller::SubmixSystem::PauseGenerator((Phase::Logger *)(a1 + 224), a2, a3);
  return 0;
}

void sub_221EECEB0(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"PauseGenerator", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::ResumeGenerator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315906;
    uint64_t v9 = "CvmVoiceManager.mm";
    __int16 v10 = 1024;
    int v11 = 911;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    __int16 v14 = 2048;
    uint64_t v15 = a2;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received messageResumeGenerator(generator: %llu)", (uint8_t *)&v8, 0x26u);
  }
  Phase::Controller::SubmixSystem::ResumeGenerator((Phase::Logger *)(a1 + 224), a2, a3);
  return 0;
}

void sub_221EED000(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"ResumeGenerator", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::HasExternalStream(Phase::Controller::VoiceManager *this, UniqueObjectId a2)
{
  uint64_t v2 = *(void *)this;
  UniqueObjectId v6 = a2;
  unint64_t v3 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(v2 + 408), &v6);
  if (v3) {
    UniqueObjectId v4 = (UniqueObjectId)*((_OWORD *)v3 + 2);
  }
  else {
    UniqueObjectId v4 = (UniqueObjectId)0;
  }
  UniqueObjectId v6 = v4;
  if (std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(v2 + 368), &v6))
  {
    return 0;
  }
  else
  {
    return 3;
  }
}

uint64_t Phase::Controller::VoiceManager::Implementation::PauseExternalStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v7 = a2;
  uint64_t v8 = a3;
  UniqueObjectId v4 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1)
                                                                                     + 384)));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (void *)[objc_alloc(MEMORY[0x263F08C38]) initWithUUIDBytes:&v7];
    *(_DWORD *)buf = 136315906;
    __int16 v10 = "CvmVoiceManager.mm";
    __int16 v11 = 1024;
    int v12 = 925;
    __int16 v13 = 2048;
    uint64_t v14 = a1;
    __int16 v15 = 2112;
    uint64_t v16 = v5;
    _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message PauseExternalStream(external stream: %@)", buf, 0x26u);
  }
  Phase::Controller::SubmixSystem::PauseExternalStream((Phase::Logger *)(a1 + 224), v7, v8);
  return 0;
}

void sub_221EED1D8(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"PauseExternalStream", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::ResumeExternalStream(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v7 = a2;
  uint64_t v8 = a3;
  UniqueObjectId v4 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1)
                                                                                     + 384)));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (void *)[objc_alloc(MEMORY[0x263F08C38]) initWithUUIDBytes:&v7];
    *(_DWORD *)buf = 136315906;
    __int16 v10 = "CvmVoiceManager.mm";
    __int16 v11 = 1024;
    int v12 = 933;
    __int16 v13 = 2048;
    uint64_t v14 = a1;
    __int16 v15 = 2112;
    uint64_t v16 = v5;
    _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message ResumeExternalStream(external stream: %@)", buf, 0x26u);
  }
  Phase::Controller::SubmixSystem::ResumeExternalStream((Phase::Logger *)(a1 + 224), v7, v8);
  return 0;
}

void sub_221EED354(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"ResumeExternalStream", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::StopGenerator(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  uint64_t v8 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136316162;
    __int16 v11 = "CvmVoiceManager.mm";
    __int16 v12 = 1024;
    int v13 = 942;
    __int16 v14 = 2048;
    uint64_t v15 = a1;
    __int16 v16 = 2048;
    uint64_t v17 = a2;
    __int16 v18 = 2048;
    double v19 = a4;
    _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message StopGenerator(generator: %llu, fade out duration: %f)", (uint8_t *)&v10, 0x30u);
  }
  Phase::Controller::SubmixSystem::StopGenerator((Phase::Logger *)(a1 + 224), a2, a3);
  return 0;
}

void sub_221EED4C4(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"StopGenerator", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::SleepGenerator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  UniqueObjectId v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315906;
    uint64_t v9 = "CvmVoiceManager.mm";
    __int16 v10 = 1024;
    int v11 = 950;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    __int16 v14 = 2048;
    uint64_t v15 = a2;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message SleepGenerator(generator: %llu)", (uint8_t *)&v8, 0x26u);
  }
  Phase::Controller::SubmixSystem::SleepGenerator((Phase::Logger *)(a1 + 224), a2, a3);
  return 0;
}

void sub_221EED614(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"SleepGenerator", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::WakeGenerator(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  UniqueObjectId v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 384);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315906;
    uint64_t v9 = "CvmVoiceManager.mm";
    __int16 v10 = 1024;
    int v11 = 958;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    __int16 v14 = 2048;
    uint64_t v15 = a2;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: received message WakeGenerator(generator: %llu)", (uint8_t *)&v8, 0x26u);
  }
  Phase::Controller::SubmixSystem::WakeGenerator((Phase::Logger *)(a1 + 224), a2, a3);
  return 0;
}

void sub_221EED764(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_begin_catch(exception_object);
    Phase::Controller::sCatchAll((Phase::Controller *)"WakeGenerator", v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::SetGeneratorParameter(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, double a5)
{
  return 0;
}

void sub_221EED7E4(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SetGeneratorParameter", v1);
}

void sub_221EED7F4()
{
}

void sub_221EED804(_Unwind_Exception *a1)
{
}

BOOL Phase::Controller::VoiceManager::Implementation::AudioIOConfigChanged(Phase::Controller::VoiceManager::Implementation *this)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  uint64_t v2 = Phase::Controller::TaskManager::GetService<Phase::Controller::DeviceManager>(*(Phase::Logger **)(*((void *)this + 85) + 48), *(void *)(*((void *)this + 85) + 56));
  if (v2)
  {
    uint64_t v3 = v2;
    __int16 v18 = (char *)this + 8;
    BOOL v4 = std::__shared_mutex_base::try_lock_shared((std::__shared_mutex_base *)((char *)this + 8));
    BOOL v5 = v4;
    BOOL v19 = v4;
    if (v4)
    {
      uint64_t v15 = v18;
      BOOL v16 = v4;
      *((void *)&v17 + 1) = v3;
      __int16 v18 = 0;
      BOOL v19 = 0;
      *(void *)&long long v17 = this;
      uint64_t v6 = *(void *)(*(void *)(v3 + 8) + 8);
      unint64_t v21 = 0;
      BOOL v20 = 1;
      uint64_t v7 = Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v6, 40, &v21, &v20);
      if (!v7)
      {
        uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
        Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
        uint64_t v13 = **(id **)(v6 + 48);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          __int16 v23 = "CommandQueue.hpp";
          __int16 v24 = 1024;
          int v25 = 100;
          _os_log_impl(&dword_221E5E000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buf"
            "fer is full, unable to grow.\"",
            buf,
            0x12u);
        }
        exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
      }
      if (v20)
      {
        int v8 = **(id **)(v6 + 48);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136315906;
          __int16 v23 = "CommandQueue.hpp";
          __int16 v24 = 1024;
          int v25 = 89;
          __int16 v26 = 2048;
          unint64_t v27 = v21;
          __int16 v28 = 2048;
          uint64_t v29 = 40;
          _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
        }
      }
      *(void *)uint64_t v7 = &unk_26D473E30;
      *(void *)(v7 + 8) = v15;
      *(unsigned char *)(v7 + 16) = v16;
      uint64_t v15 = 0;
      BOOL v16 = 0;
      *(_OWORD *)(v7 + 24) = v17;
      Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v6, 40);
      atomic_store(0, (unsigned __int8 *)(v6 + 40));
      std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v15);
    }
    else
    {
      __int16 v10 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v4) + 384);
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        __int16 v23 = "CvmVoiceManager.mm";
        __int16 v24 = 1024;
        int v25 = 1054;
        _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Ignoring route change notification, received while updating engine state.", buf, 0x12u);
      }
    }
    std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v18);
  }
  else
  {
    uint64_t v9 = **(id **)(Phase::Logger::GetInstance(0) + 384);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      __int16 v23 = "CvmVoiceManager.mm";
      __int16 v24 = 1024;
      int v25 = 1061;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d DeviceManager service not available to propagate route change notification.", buf, 0x12u);
    }
    return 0;
  }
  return v5;
}

void sub_221EEDB78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
  if (a2)
  {
    __cxa_free_exception(v14);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v13);
    __cxa_end_catch();
    JUMPOUT(0x221EED99CLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::VoiceManager::Implementation::SeekGeneratorTime(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  return 0;
}

void sub_221EEDC20(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SeekGeneratorTime", v1);
}

void sub_221EEDC30()
{
}

void sub_221EEDC40(_Unwind_Exception *a1)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::ActivateAudioSession(Phase::Controller::VoiceManager::Implementation *this, int a2, int a3, int a4)
{
  return 0;
}

void sub_221EEDC7C(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"ActivateAudioSession", v1);
}

void sub_221EEDC8C()
{
}

void sub_221EEDC9C(_Unwind_Exception *a1)
{
}

uint64_t Phase::Controller::VoiceManager::IOExecuteRealtimeActions(Phase::Controller::VoiceManager *this, const AudioTimeStamp *a2)
{
  uint64_t v3 = *(void *)this;
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)(*(void *)this + 840));
  if (v4)
  {
    uint64_t v19 = v3 + 844;
    int v5 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(v3 + 844));
    char v20 = v5;
    if (v5)
    {
      uint64_t v6 = *(void *)(v3 + 800);
      uint64_t v7 = *(void *)(v3 + 760);
      *(void *)(v3 + 800) = v7;
      *(void *)(v3 + 760) = v6;
      unint64_t v8 = *(void *)(v3 + 808);
      unint64_t v9 = *(void *)(v3 + 768);
      *(void *)(v3 + 808) = v9;
      *(void *)(v3 + 768) = v8;
      uint64_t v10 = *(void *)(v3 + 816);
      uint64_t v11 = *(void *)(v3 + 776);
      *(void *)(v3 + 816) = v11;
      *(void *)(v3 + 776) = v10;
      uint64_t v12 = *(void *)(v3 + 824);
      uint64_t v13 = *(void *)(v3 + 784);
      *(void *)(v3 + 824) = v13;
      *(void *)(v3 + 784) = v12;
      int v14 = *(_DWORD *)(v3 + 832);
      *(_DWORD *)(v3 + 832) = *(_DWORD *)(v3 + 792);
      *(_DWORD *)(v3 + 792) = v14;
      if (v13)
      {
        unint64_t v15 = *(void *)(v11 + 8);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v15 >= v9) {
            v15 %= v9;
          }
        }
        else
        {
          v15 &= v9 - 1;
        }
        *(void *)(v7 + 8 * v15) = v3 + 816;
      }
      if (v12)
      {
        unint64_t v16 = *(void *)(*(void *)(v3 + 776) + 8);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v16 >= v8) {
            v16 %= v8;
          }
        }
        else
        {
          v16 &= v8 - 1;
        }
        *(void *)(*(void *)(v3 + 760) + 8 * v16) = v3 + 776;
      }
      atomic_store(0, (unsigned __int8 *)(v3 + 840));
    }
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v19);
  }
  for (uint64_t i = *(void **)(v3 + 816); i; uint64_t i = (void *)*i)
    (*(void (**)(void, const AudioTimeStamp *))(i[3] + 16))(i[3], a2);
  return 0;
}

uint64_t Phase::Controller::VoiceManager::IOExecuteRealtimeInputActions(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  unsigned __int8 v4 = atomic_load((unsigned __int8 *)(*a1 + 976));
  if (v4)
  {
    uint64_t v19 = v3 + 980;
    int v5 = caulk::pooled_semaphore_mutex::try_lock((caulk::pooled_semaphore_mutex *)(v3 + 980));
    char v20 = v5;
    if (v5)
    {
      uint64_t v6 = *(void *)(v3 + 936);
      uint64_t v7 = *(void *)(v3 + 896);
      *(void *)(v3 + 936) = v7;
      *(void *)(v3 + 896) = v6;
      unint64_t v8 = *(void *)(v3 + 944);
      unint64_t v9 = *(void *)(v3 + 904);
      *(void *)(v3 + 944) = v9;
      *(void *)(v3 + 904) = v8;
      uint64_t v10 = *(void *)(v3 + 952);
      uint64_t v11 = *(void *)(v3 + 912);
      *(void *)(v3 + 952) = v11;
      *(void *)(v3 + 912) = v10;
      uint64_t v12 = *(void *)(v3 + 960);
      uint64_t v13 = *(void *)(v3 + 920);
      *(void *)(v3 + 960) = v13;
      *(void *)(v3 + 920) = v12;
      int v14 = *(_DWORD *)(v3 + 968);
      *(_DWORD *)(v3 + 968) = *(_DWORD *)(v3 + 928);
      *(_DWORD *)(v3 + 928) = v14;
      if (v13)
      {
        unint64_t v15 = *(void *)(v11 + 8);
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v15 >= v9) {
            v15 %= v9;
          }
        }
        else
        {
          v15 &= v9 - 1;
        }
        *(void *)(v7 + 8 * v15) = v3 + 952;
      }
      if (v12)
      {
        unint64_t v16 = *(void *)(*(void *)(v3 + 912) + 8);
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v16 >= v8) {
            v16 %= v8;
          }
        }
        else
        {
          v16 &= v8 - 1;
        }
        *(void *)(*(void *)(v3 + 896) + 8 * v16) = v3 + 912;
      }
      atomic_store(0, (unsigned __int8 *)(v3 + 976));
    }
    std::unique_lock<caulk::pooled_semaphore_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v19);
  }
  for (uint64_t i = *(void **)(v3 + 952); i; uint64_t i = (void *)*i)
    (*(void (**)(void, uint64_t))(i[3] + 16))(i[3], a2);
  return 0;
}

uint64_t Phase::Controller::TaskManager::GetService<Phase::Controller::DeviceManager>(Phase::Logger *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  if ((unint64_t)(a2 - (void)a1) <= 0x320)
  {
    int v5 = **(id **)(Phase::Logger::GetInstance(a1) + 448);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v12 = "TaskManager.hpp";
      __int16 v13 = 1024;
      int v14 = 112;
      _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pId < mServiceRegistry.size() is false.", buf, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: pId < mServiceRegistry.size() is false.");
  }
  uint64_t v2 = (uint64_t (*)(uint64_t, char *, void, void, void *))*((void *)a1 + 100);
  if (!v2)
  {
    uint64_t v7 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(a1)
                                                                                       + 448)));
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      Phase::GetBacktraceFrame<1ul>(&__p);
      unint64_t v8 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
         ? &__p
         : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315906;
      uint64_t v12 = "TaskManager.hpp";
      __int16 v13 = 1024;
      int v14 = 121;
      __int16 v15 = 1024;
      int v16 = 25;
      __int16 v17 = 2080;
      __int16 v18 = v8;
      _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::domain_error) [not lService.has_value() is true]: \"No service registered for Id %i, in call \\n%s\"", buf, 0x22u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    unint64_t v9 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](v9, "No service registered for Id %i, in call \n%s");
  }
  uint64_t v3 = v2(3, (char *)a1 + 800, 0, 0, &std::__any_imp::__unique_typeinfo<Phase::Controller::DeviceManager *>::__id);
  if (!v3) {
    std::__throw_bad_any_cast[abi:ne180100]();
  }
  return *(void *)v3;
}

void sub_221EEE1A0(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_221EEE2B0(_Unwind_Exception *a1)
{
}

void sub_221EEE2D0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void Phase::Controller::SpatialModelerSystem::InitializeParameters::~InitializeParameters(Phase::Controller::SpatialModelerSystem::InitializeParameters *this)
{
  uint64_t v2 = (void *)*((void *)this + 10);
  if (v2)
  {
    *((void *)this + 11) = v2;
    operator delete(v2);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 40);
}

void Phase::Controller::AudioRouteDescription::~AudioRouteDescription(Phase::Controller::AudioRouteDescription *this)
{
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }

  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,unsigned int,objc_object * {__strong}>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)this);
}

Phase::Controller::DSPVoiceManager::Implementation ***std::unique_ptr<Phase::Controller::DSPVoiceManager>::reset[abi:ne180100](Phase::Controller::DSPVoiceManager::Implementation ***result, Phase::Controller::DSPVoiceManager::Implementation **a2)
{
  uint64_t v2 = *result;
  *uint64_t result = a2;
  if (v2)
  {
    std::unique_ptr<Phase::Controller::DSPVoiceManager::Implementation>::reset[abi:ne180100](v2, 0);
    std::unique_ptr<Phase::Controller::DSPVoiceManager::Implementation>::reset[abi:ne180100](v2, 0);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void *std::vector<std::any>::resize(void *result, unint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = (uint64_t (**)(void, void, void, void, void))result[1];
  unint64_t v4 = ((uint64_t)v3 - *result) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v6 = *result + 32 * a2;
      while (v3 != (uint64_t (**)(void, void, void, void, void))v6)
      {
        v3 -= 4;
        uint64_t result = std::any::reset[abi:ne180100](v3);
      }
      v2[1] = v6;
    }
  }
  else
  {
    unint64_t v5 = a2 - v4;
    return (void *)std::vector<std::any>::__append((uint64_t)result, v5);
  }
  return result;
}

void std::vector<Phase::ICommandable *>::resize(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v3 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v3)
  {
    if (a2 < v3) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<Phase::ICommandable *>::__append((void **)a1, a2 - v3, a3);
  }
}

uint64_t std::vector<std::any>::__append(uint64_t a1, unint64_t a2)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t result = a1 + 16;
  uint64_t v5 = v6;
  uint64_t v7 = *(void **)(result - 8);
  if (a2 <= (v6 - (uint64_t)v7) >> 5)
  {
    if (a2)
    {
      uint64_t v14 = 32 * a2;
      __int16 v15 = &v7[4 * a2];
      do
      {
        void *v7 = 0;
        v7[1] = 0;
        v7 += 4;
        v14 -= 32;
      }
      while (v14);
      uint64_t v7 = v15;
    }
    *(void *)(a1 + 8) = v7;
  }
  else
  {
    uint64_t v8 = (uint64_t)v7 - *(void *)a1;
    unint64_t v9 = a2 + (v8 >> 5);
    if (v9 >> 59) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 5;
    uint64_t v11 = v5 - *(void *)a1;
    if (v11 >> 4 > v9) {
      unint64_t v9 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    v19[4] = result;
    if (v12) {
      __int16 v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>(result, v12);
    }
    else {
      __int16 v13 = 0;
    }
    int v16 = &v13[32 * v10];
    v19[0] = v13;
    v19[1] = v16;
    v19[3] = &v13[32 * v12];
    uint64_t v17 = 32 * a2;
    __int16 v18 = &v16[32 * a2];
    do
    {
      *(void *)int v16 = 0;
      *((void *)v16 + 1) = 0;
      v16 += 32;
      v17 -= 32;
    }
    while (v17);
    v19[2] = v18;
    std::vector<std::any>::__swap_out_circular_buffer((void (***)(uint64_t))a1, v19);
    return std::__split_buffer<std::any>::~__split_buffer((uint64_t)v19);
  }
  return result;
}

void sub_221EEE598(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::any>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void (**std::vector<std::any>::__swap_out_circular_buffer(void (***a1)(uint64_t), void *a2))(uint64_t)
{
  uint64_t v5 = *a1;
  unint64_t v4 = a1[1];
  uint64_t result = (void (**)(uint64_t))a2[1];
  while (v4 != v5)
  {
    v4 -= 4;
    uint64_t result = (void (**)(uint64_t))std::any::any[abi:ne180100](result - 4, v4);
  }
  a2[1] = result;
  uint64_t v7 = *a1;
  *a1 = result;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = (void (**)(uint64_t))a2[2];
  a2[2] = v8;
  unint64_t v9 = a1[2];
  a1[2] = (void (**)(uint64_t))a2[3];
  a2[3] = v9;
  *a2 = a2[1];
  return result;
}

void *std::any::any[abi:ne180100](void *a1, void (**a2)(uint64_t))
{
  *a1 = 0;
  a1[1] = 0;
  if (*a2) {
    (*a2)(2);
  }
  return a1;
}

uint64_t (**std::any::reset[abi:ne180100](uint64_t (**result)(void, void, void, void, void)))(void, void, void, void, void)
{
  if (*result) {
    return (uint64_t (**)(void, void, void, void, void))(*result)(0, result, 0, 0, 0);
  }
  return result;
}

uint64_t std::__split_buffer<std::any>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    std::any::reset[abi:ne180100]((uint64_t (**)(void, void, void, void, void))(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::__any_imp::_SmallHandler<Phase::Controller::TapManager *>::__handle[abi:ne180100](unsigned int a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v5 = a1;
  uint64_t result = 0;
  switch(v5)
  {
    case 1:
      uint64_t result = 0;
      uint64_t v7 = a2[1];
      *a3 = std::__any_imp::_SmallHandler<Phase::Controller::TapManager *>::__handle[abi:ne180100];
      a3[1] = v7;
      break;
    case 2:
      uint64_t result = 0;
      uint64_t v8 = a2[1];
      *a3 = std::__any_imp::_SmallHandler<Phase::Controller::TapManager *>::__handle[abi:ne180100];
      a3[1] = v8;
      goto LABEL_5;
    case 3:
      if (a5 == &std::__any_imp::__unique_typeinfo<Phase::Controller::TapManager *>::__id && a4 == 0) {
        uint64_t result = a2 + 1;
      }
      else {
        uint64_t result = 0;
      }
      break;
    case 4:
      return result;
    default:
      uint64_t result = 0;
LABEL_5:
      *a2 = 0;
      break;
  }
  return result;
}

void std::vector<Phase::ICommandable *>::__append(void **a1, unint64_t a2, void *a3)
{
  uint64_t v8 = a1[2];
  uint64_t v6 = (uint64_t)(a1 + 2);
  uint64_t v7 = v8;
  unint64_t v9 = *(void **)(v6 - 8);
  if (a2 <= (v8 - (unsigned char *)v9) >> 3)
  {
    if (a2)
    {
      uint64_t v16 = 8 * a2;
      uint64_t v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 8;
      }
      while (v16);
      unint64_t v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    uint64_t v10 = (char *)v9 - (unsigned char *)*a1;
    unint64_t v11 = a2 + (v10 >> 3);
    if (v11 >> 61) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v12 = v10 >> 3;
    uint64_t v13 = v7 - (unsigned char *)*a1;
    if (v13 >> 2 > v11) {
      unint64_t v11 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v14 = v11;
    }
    if (v14) {
      __int16 v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v6, v14);
    }
    else {
      __int16 v15 = 0;
    }
    __int16 v18 = &v15[8 * v12];
    uint64_t v19 = &v18[8 * a2];
    uint64_t v20 = 8 * a2;
    unint64_t v21 = v18;
    do
    {
      *(void *)unint64_t v21 = *a3;
      v21 += 8;
      v20 -= 8;
    }
    while (v20);
    uint64_t v22 = &v15[8 * v14];
    __int16 v24 = (char *)*a1;
    __int16 v23 = (char *)a1[1];
    if (v23 != *a1)
    {
      do
      {
        uint64_t v25 = *((void *)v23 - 1);
        v23 -= 8;
        *((void *)v18 - 1) = v25;
        v18 -= 8;
      }
      while (v23 != v24);
      __int16 v23 = (char *)*a1;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
    {
      operator delete(v23);
    }
  }
}

uint64_t Phase::Controller::VoiceManager::Implementation::AcquireStateLock(uint64_t a1, uint64_t a2, int a3, double a4)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  v8.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  uint64_t rep = Phase::Controller::TaskManager::GetService<Phase::Controller::DeviceManager>(*(Phase::Logger **)(*(void *)(a1 + 680) + 48), *(void *)(*(void *)(a1 + 680) + 56));
  uint64_t v10 = rep;
  if (*(unsigned char *)(a2 + 8)) {
    return 0;
  }
  while (1)
  {
    if (a4 > 0.0)
    {
      uint64_t rep = std::chrono::steady_clock::now().__d_.__rep_;
      if (a4 * 1000.0 < (double)((rep - v8.__d_.__rep_) / 1000000)) {
        break;
      }
    }
    if (v10)
    {
      if (a3 == 1)
      {
        Phase::Commandable<128,Phase::LockFreeQueueMPSC>::ExecuteCommands(v10);
      }
      else
      {
        if (a3) {
          goto LABEL_21;
        }
        if (*(int *)(v10 + 16) >= 1)
        {
          uint64_t v11 = 0;
          do
            Phase::CommandQueue<Phase::LockFreeQueueMPSC>::Reset(*(void *)(*(void *)(v10 + 8) + 8 * v11++));
          while (v11 < *(int *)(v10 + 16));
        }
      }
    }
    uint64_t v12 = *(void *)(a1 + 688);
    *(_DWORD *)(v12 + 328) = 0;
    atomic_store(0, (unsigned int *)(v12 + 144));
    if (!*(void *)a2) {
      goto LABEL_20;
    }
    if (*(unsigned char *)(a2 + 8))
    {
      std::__throw_system_error(11, "unique_lock::try_lock: already locked");
LABEL_20:
      std::__throw_system_error(1, "unique_lock::try_lock: references null mutex");
LABEL_21:
      __int16 v15 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)rep) + 384);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        int v17 = 136315650;
        __int16 v18 = "CvmVoiceManager.mm";
        __int16 v19 = 1024;
        int v20 = 1509;
        __int16 v21 = 1024;
        LODWORD(v22) = a3;
        _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"[CVMVoiceManager::AcquireStateLock] Invalid action value %i for pending commands\"", (uint8_t *)&v17, 0x18u);
      }
      exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](exception, "[CVMVoiceManager::AcquireStateLock] Invalid action value %i for pending commands");
    }
    uint64_t rep = std::__shared_mutex_base::try_lock(*(std::__shared_mutex_base **)a2);
    *(unsigned char *)(a2 + 8) = rep;
    if (rep) {
      return 0;
    }
  }
  unint64_t v14 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)rep)
                                                                                      + 384)));
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    int v17 = 136315906;
    __int16 v18 = "CvmVoiceManager.mm";
    __int16 v19 = 1024;
    int v20 = 1484;
    __int16 v21 = 2048;
    uint64_t v22 = a1;
    __int16 v23 = 2048;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v24 = (std::chrono::steady_clock::now().__d_.__rep_ - v8.__d_.__rep_) / 1000000;
    _os_log_impl(&dword_221E5E000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d impl@%p: acquiring voicemanager state lock timed out after %lli ms", (uint8_t *)&v17, 0x26u);
  }

  return 4294900542;
}

void *Phase::LambdaFunction<Phase::Controller::VoiceManager::Implementation::AudioIOConfigChanged(void)::{lambda(void)#1},void>::~LambdaFunction(void *a1)
{
  *a1 = &unk_26D473E30;
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

void Phase::LambdaFunction<Phase::Controller::VoiceManager::Implementation::AudioIOConfigChanged(void)::{lambda(void)#1},void>::~LambdaFunction(void *a1)
{
  *a1 = &unk_26D473E30;
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)(a1 + 1));

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::LambdaFunction<Phase::Controller::VoiceManager::Implementation::AudioIOConfigChanged(void)::{lambda(void)#1},void>::operator()(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 24);
  Phase::Controller::SystemAudioIO::AudioIOBase::BeginRouteChange(*(Phase::Controller::SystemAudioIO::AudioIOBase **)(v2 + 688));
  uint64_t v3 = *(Phase::Logger ***)(a1 + 32);
  (*(void (**)(uint8_t *__return_ptr))(**(void **)(v2 + 688) + 96))(buf);
  Phase::Controller::DeviceManager::OnAudioOutputRouteChanged(v3, (id *)buf);
  if (*(void *)&v20[2])
  {
    *(void *)&v20[10] = *(void *)&v20[2];
    operator delete(*(void **)&v20[2]);
  }
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,unsigned int,objc_object * {__strong}>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 8);
  char v13 = *(unsigned char *)(a1 + 16);
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  uint64_t v14 = v2;
  uint64_t v5 = **(void **)(v4 + 8);
  unint64_t v16 = 0;
  BOOL v15 = 1;
  uint64_t v6 = Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v5, 32, &v16, &v15);
  if (!v6)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    uint64_t v10 = **(id **)(v5 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      __int16 v18 = "CommandQueue.hpp";
      __int16 v19 = 1024;
      *(_DWORD *)int v20 = 100;
      _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v15)
  {
    uint64_t v7 = **(id **)(v5 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      __int16 v18 = "CommandQueue.hpp";
      __int16 v19 = 1024;
      *(_DWORD *)int v20 = 89;
      *(_WORD *)&v20[4] = 2048;
      *(void *)&v20[6] = v16;
      *(_WORD *)&v20[14] = 2048;
      *(void *)&v20[16] = 32;
      _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(void *)uint64_t v6 = &unk_26D473E58;
  *(void *)(v6 + 8) = v12;
  *(unsigned char *)(v6 + 16) = v13;
  uint64_t v12 = 0;
  char v13 = 0;
  *(void *)(v6 + 24) = v14;
  Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v5, 32);
  atomic_store(0, (unsigned __int8 *)(v5 + 40));
  return std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)&v12);
}

void sub_221EEEF18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (a2)
  {
    __cxa_free_exception(v19);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v18);
    __cxa_end_catch();
    JUMPOUT(0x221EEEE2CLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_221EEEF78(uint64_t a1, ...)
{
  va_start(va, a1);
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)va);
  JUMPOUT(0x221EEEF50);
}

void sub_221EEEF94(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x221EEEF50);
}

void *Phase::LambdaFunction<Phase::Controller::VoiceManager::Implementation::AudioIOConfigChanged(void)::{lambda(void)#1}::operator()(void)::{lambda(void)#1},void>::~LambdaFunction(void *a1)
{
  *a1 = &unk_26D473E58;
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)(a1 + 1));
  return a1;
}

void Phase::LambdaFunction<Phase::Controller::VoiceManager::Implementation::AudioIOConfigChanged(void)::{lambda(void)#1}::operator()(void)::{lambda(void)#1},void>::~LambdaFunction(void *a1)
{
  *a1 = &unk_26D473E58;
  std::shared_lock<std::shared_mutex>::~shared_lock[abi:ne180100]((uint64_t)(a1 + 1));

  JUMPOUT(0x223C938A0);
}

void Phase::LambdaFunction<Phase::Controller::VoiceManager::Implementation::AudioIOConfigChanged(void)::{lambda(void)#1}::operator()(void)::{lambda(void)#1},void>::operator()(uint64_t a1)
{
}

void Phase::Controller::VoiceManager::Implementation::Implementation(Phase::Controller::VoiceManager::Implementation *this)
{
  *(unsigned char *)this = 0;
  uint64_t v2 = (Phase::Logger *)std::__shared_mutex_base::__shared_mutex_base((std::__shared_mutex_base *)((char *)this + 8));
  *((void *)this + 26) = 0;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_DWORD *)this + 54) = 1065353216;
  Phase::Logger::GetInstance(v2);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::Commandable((void *)this + 28);
}

void sub_221EEF270(_Unwind_Exception *a1)
{
  Phase::ThreadsafeContainer<std::unordered_map<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int,AudioBufferList *,Phase::Controller::SpeechDetectorInfo const*),std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<std::pair<unsigned long long const,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int,AudioBufferList *,Phase::Controller::SpeechDetectorInfo const*)>>>>::~ThreadsafeContainer(v6);
  Phase::ThreadsafeContainer<std::unordered_map<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int,AudioBufferList *,Phase::Controller::SpeechDetectorInfo const*),std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<std::pair<unsigned long long const,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int,AudioBufferList *,Phase::Controller::SpeechDetectorInfo const*)>>>>::~ThreadsafeContainer(v5);
  uint64_t v8 = *(void *)(v1 + 712);
  *(void *)(v1 + 712) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 24))(v8);
  }
  uint64_t v9 = *(void *)(v1 + 704);
  *(void *)(v1 + 704) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  std::unique_ptr<Phase::Controller::DSPVoiceManager>::reset[abi:ne180100]((Phase::Controller::DSPVoiceManager::Implementation ***)(v1 + 696), 0);
  uint64_t v10 = *(void *)(v1 + 688);
  *(void *)(v1 + 688) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  Phase::Controller::SpatialModelerSystem::~SpatialModelerSystem(v4);
  Phase::Controller::SubmixSystem::~SubmixSystem(v3);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v1 + 184);
  std::shared_mutex::~shared_mutex[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

uint64_t Phase::ThreadsafeContainer<std::unordered_map<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int,AudioBufferList *,Phase::Controller::SpeechDetectorInfo const*),std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<std::pair<unsigned long long const,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int,AudioBufferList *,Phase::Controller::SpeechDetectorInfo const*)>>>>::~ThreadsafeContainer(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table(a1 + 80);
  std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table(a1 + 40);

  return std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table(a1);
}

void std::shared_mutex::~shared_mutex[abi:ne180100](uint64_t a1)
{
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 112));
  std::condition_variable::~condition_variable((std::condition_variable *)(a1 + 64));

  std::mutex::~mutex((std::mutex *)a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void Phase::Controller::VoiceManager::Implementation::DvmCallbackInterface::~DvmCallbackInterface(Phase::Controller::VoiceManager::Implementation::DvmCallbackInterface *this)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::DvmCallbackInterface::SubmitGeneratorStoppedResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Phase::Controller::SubmixSystem::SubmitGeneratorStoppedResult((Phase::Logger *)(*(void *)(a1 + 8) + 224), a2, a3);
}

void sub_221EEF4D8(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SubmitGeneratorStoppedResult", v1);
}

void sub_221EEF4E8()
{
  __cxa_end_catch();
}

void sub_221EEF504(_Unwind_Exception *a1)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::DvmCallbackInterface::SubmitSubmixStoppedResult(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t Submix = Phase::Controller::SubmixSystem::GetSubmix((Phase::Logger *)(*(void *)(a1 + 8) + 224), a2, a3);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)Submix + 216))(Submix, a4, a5);
}

void sub_221EEF574(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SubmitSubmixStoppedResult", v1);
}

void sub_221EEF584()
{
  __cxa_end_catch();
}

void sub_221EEF5A0(_Unwind_Exception *a1)
{
}

uint64_t Phase::Controller::VoiceManager::Implementation::DvmCallbackInterface::SubmitRendererStoppedResult(Phase::Controller::VoiceManager::Implementation::DvmCallbackInterface *this, uint64_t a2, std::error_code a3)
{
  return Phase::Controller::RendererSystem::SubmitRendererStoppedResult(*(Phase::Controller::RendererSystem **)(*((void *)this + 1) + 496), a2, a3);
}

void sub_221EEF5DC(void *a1)
{
  __cxa_begin_catch(a1);
  Phase::Controller::sCatchAll((Phase::Controller *)"SubmitRendererStoppedResult", v1);
}

void sub_221EEF5EC()
{
  __cxa_end_catch();
}

void sub_221EEF608(_Unwind_Exception *a1)
{
}

Phase::Controller::VoiceManager::Implementation *std::unique_ptr<Phase::Controller::VoiceManager::Implementation>::reset[abi:ne180100](Phase::Controller::VoiceManager::Implementation **a1, Phase::Controller::VoiceManager::Implementation *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    Phase::Controller::VoiceManager::Implementation::~Implementation(result);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void Phase::Controller::VoiceManager::Implementation::~Implementation(Phase::Controller::VoiceManager::Implementation *this)
{
  Phase::Controller::VoiceManager::Implementation::Destroy(this);
  std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table((uint64_t)this + 936);
  std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table((uint64_t)this + 896);
  std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table((uint64_t)this + 856);
  std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table((uint64_t)this + 800);
  std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table((uint64_t)this + 760);
  std::__hash_table<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,void({block_pointer} {__strong})(AudioTimeStamp const*,unsigned int)>>>::~__hash_table((uint64_t)this + 720);
  uint64_t v2 = *((void *)this + 89);
  *((void *)this + 89) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 24))(v2);
  }
  uint64_t v3 = *((void *)this + 88);
  *((void *)this + 88) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  std::unique_ptr<Phase::Controller::DSPVoiceManager>::reset[abi:ne180100]((Phase::Controller::DSPVoiceManager::Implementation ***)this + 87, 0);
  uint64_t v4 = *((void *)this + 86);
  *((void *)this + 86) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  Phase::Controller::SpatialModelerSystem::~SpatialModelerSystem((Phase::Controller::VoiceManager::Implementation *)((char *)this + 560));
  Phase::Controller::SubmixSystem::~SubmixSystem((Phase::Controller::VoiceManager::Implementation *)((char *)this + 224));
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 184);
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 120));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 72));
  std::mutex::~mutex((std::mutex *)((char *)this + 8));
}

void Phase::Controller::WaterProcedure::WaterProcedure(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  Phase::Controller::ProcedureBase::ProcedureBase(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
}

void sub_221EEFDBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  __cxa_free_exception(v23);
  if (a21 < 0) {
    operator delete(__p);
  }
  Phase::Controller::Generator::~Generator(v22);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::TaskManager::GetService<Phase::Controller::ProcedureRegistry>(Phase::Logger *a1, int a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)a1 + 6);
  if (a2 >= (unint64_t)((*((void *)a1 + 7) - v3) >> 5))
  {
    uint64_t v7 = **(id **)(Phase::Logger::GetInstance(a1) + 448);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v14 = "TaskManager.hpp";
      __int16 v15 = 1024;
      int v16 = 112;
      _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pId < mServiceRegistry.size() is false.", buf, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: pId < mServiceRegistry.size() is false.");
  }
  uint64_t v4 = (Phase::Logger *)(v3 + 32 * a2);
  if (!*(void *)v4)
  {
    uint64_t v9 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v4)
                                                                                       + 448)));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      Phase::GetBacktraceFrame<1ul>(&__p);
      uint64_t v10 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315906;
      uint64_t v14 = "TaskManager.hpp";
      __int16 v15 = 1024;
      int v16 = 121;
      __int16 v17 = 1024;
      int v18 = a2;
      __int16 v19 = 2080;
      int v20 = v10;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::domain_error) [not lService.has_value() is true]: \"No service registered for Id %i, in call \\n%s\"", buf, 0x22u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    uint64_t v11 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](v11, "No service registered for Id %i, in call \n%s");
  }
  uint64_t v5 = std::any_cast[abi:ne180100]<Phase::Controller::ProcedureRegistry * const>((uint64_t (**)(uint64_t, void, void, void, void *))v4);
  if (!v5) {
    std::__throw_bad_any_cast[abi:ne180100]();
  }
  return (uint64_t)*v5;
}

void sub_221EF007C(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_221EF018C(_Unwind_Exception *a1)
{
}

void sub_221EF01AC(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void Phase::Controller::WaterProcedure::~WaterProcedure(Phase::Controller::WaterProcedure *this)
{
  Phase::Controller::Generator::~Generator(this);

  JUMPOUT(0x223C938A0);
}

double Phase::Controller::WaterProcedure::GetAnchorTimeForWakeFromSleepInSeconds(Phase::Controller::WaterProcedure *this, PHASECullOption a2, double a3)
{
  if (a2 != PHASECullOptionSleepWakeAtRandomOffset) {
    return 0.0;
  }
  double v3 = *((double *)this + 69);
  uint64_t v4 = *((void *)this + 70);
  unint64_t v5 = *((void *)this + 71);
  *((void *)this + 70) = v5;
  unint64_t v6 = (v5 >> 26) ^ ((v4 ^ (unint64_t)(v4 << 23)) >> 17) ^ v5 ^ v4 ^ (v4 << 23);
  *((void *)this + 71) = v6;
  return v3 * ((double)(v6 + v5) * 5.42101086e-20) + 0.0;
}

uint64_t (**std::any_cast[abi:ne180100]<Phase::Controller::ProcedureRegistry * const>(uint64_t (**result)(uint64_t, void, void, void, void *)))(uint64_t, void, void, void, void *)
{
  if (result)
  {
    if (*result) {
      return (uint64_t (**)(uint64_t, void, void, void, void *))(*result)(3, result, 0, 0, &std::__any_imp::__unique_typeinfo<Phase::Controller::ProcedureRegistry *>::__id);
    }
    else {
      return 0;
    }
  }
  return result;
}

void Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(Phase::DspLayer::DelayHermite3rdOrder4Point *this)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  uint64_t v1 = malloc_type_malloc(0x38uLL, 0x1050040B063AAFAuLL);
  void *v1 = "Delay In Seconds";
  v1[1] = 0x500000000;
  *(void *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2220A4F90;
  v1[6] = 0;
  operator new();
}

void sub_221EF040C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::DelayHermite3rdOrder4Point::~DelayHermite3rdOrder4Point(Phase::DspLayer::DelayHermite3rdOrder4Point *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);

  JUMPOUT(0x223C938A0);
}

void anonymous namespace'::DelayHermite3rdOrder4PointSlice::~DelayHermite3rdOrder4PointSlice(void **this)
{
  *this = &unk_26D473F68;
  free(this[1046]);
  this[1046] = 0;
}

{
  uint64_t vars8;

  *this = &unk_26D473F68;
  free(this[1046]);
  this[1046] = 0;

  JUMPOUT(0x223C938A0);
}

double anonymous namespace'::DelayHermite3rdOrder4PointSlice::Reset(uint64_t a1)
{
  *(_OWORD *)(a1 + 4144) = 0u;
  *(_DWORD *)(a1 + 8376) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  **(void **)(a1 + 8368) = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  double result = 0.0;
  *(_OWORD *)(a1 + 8400) = 0u;
  *(_OWORD *)(a1 + 8384) = 0u;
  return result;
}

uint64_t anonymous namespace'::DelayHermite3rdOrder4PointSlice::Reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (_DWORD *)(a1 + 4 * (int)a3);
  v8[4] = 0;
  v8[8] = 0;
  v8[1036] = 0;
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE5ResetEi(a1 + 8368, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2, a3);
  *(void *)(a1 + 8 * (int)a3 + 8384) = a4;
  return result;
}

double anonymous namespace'::DelayHermite3rdOrder4PointSlice::GetParameter(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2, int a3)
{
  if (!a2) {
    return *((float *)this + a3 + 4);
  }
  return result;
}

float anonymous namespace'::DelayHermite3rdOrder4PointSlice::SetParameter(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2, int a3, double a4)
{
  if (!a2)
  {
    *(float *)&a4 = a4;
    *((_DWORD *)this + a3 + 4) = LODWORD(a4);
  }
  return *(float *)&a4;
}

__n128 anonymous namespace'::DelayHermite3rdOrder4PointSlice::UpdateParameters(uint64_t a1, double *a2)
{
  float v3 = *a2;
  float32x4_t v4 = vmulq_n_f32(*(float32x4_t *)(a1 + 16), v3);
  float32x4_t v5 = vrndq_f32(v4);
  int32x4_t v6 = vcvtq_s32_f32(v5);
  v7.i64[0] = 0x200000002;
  v7.i64[1] = 0x200000002;
  int32x4_t v8 = vaddq_s32(v6, v7);
  v9.i64[0] = 0x100000001;
  v9.i64[1] = 0x100000001;
  int32x4_t v10 = vcgtq_s32(v9, v8);
  int32x4_t v11 = vdupq_n_s32(0xBB80u);
  int32x4_t v23 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v8, (int8x16_t)v10), v10), v11);
  long long v24 = *(_OWORD *)(a1 + 4144);
  v8.i64[0] = -1;
  v8.i64[1] = -1;
  int32x4_t v12 = vaddq_s32(v6, v8);
  int32x4_t v13 = vcgtq_s32(v9, v12);
  int32x4_t v14 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v12, (int8x16_t)v13), v13), v11);
  int32x4_t v15 = vcgtq_s32(v9, v6);
  int32x4_t v21 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v6, (int8x16_t)v15), v15), v11);
  int32x4_t v22 = v14;
  int8x16_t v16 = (int8x16_t)vaddq_s32(v6, v9);
  int32x4_t v17 = (int32x4_t)vcgtq_u32((uint32x4_t)v6, (uint32x4_t)vdupq_n_s32(0x7FFFFFFEu));
  float32x4_t v19 = vsubq_f32(v4, v5);
  int32x4_t v20 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8(v16, (int8x16_t)v17), v17), v11);
  memcpy((void *)(a1 + 4160), (const void *)(a1 + 32), 0x1010uLL);
  *(_OWORD *)(a1 + 8272) = v24;
  *(int32x4_t *)(a1 + 8288) = v23;
  *(int32x4_t *)(a1 + 8304) = v22;
  *(int32x4_t *)(a1 + 8320) = v21;
  *(int32x4_t *)(a1 + 8336) = v20;
  __n128 result = (__n128)v19;
  *(float32x4_t *)(a1 + 8352) = v19;
  return result;
}

float anonymous namespace'::DelayHermite3rdOrder4PointSlice::UpdateParameters(uint64_t a1, double *a2, int a3)
{
  uint64_t v3 = a1 + 4 * a3;
  int v4 = *(_DWORD *)(v3 + 4144);
  float v5 = *(float *)(v3 + 16);
  double v6 = *a2;
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  *(_DWORD *)(v3 + 4160) = v7;
  if ((int)v7 >= 1)
  {
    int32x4_t v8 = (_DWORD *)(a1 + 4 * a3);
    do
    {
      v8[1044] = v8[12];
      v8[1048] = v8[16];
      v8 += 8;
      --v7;
    }
    while (v7);
  }
  float v9 = v6 * v5;
  float v10 = truncf(v9);
  int v11 = (int)v9;
  unsigned int v12 = v11 & ~(v11 >> 31);
  if (v12 >= 0xBB7F) {
    unsigned int v12 = 47999;
  }
  if (v11 <= 1) {
    unsigned int v13 = 1;
  }
  else {
    unsigned int v13 = (int)v9;
  }
  if (v13 >= 0xBB80) {
    unsigned int v13 = 48000;
  }
  if (v11 <= 2) {
    int v14 = 2;
  }
  else {
    int v14 = (int)v9;
  }
  if (v14 >= 48001) {
    int v14 = 48001;
  }
  if (v11 < 0) {
    int v11 = -1;
  }
  if (v11 >= 47998) {
    int v11 = 47998;
  }
  uint64_t v15 = a1 + 4 * a3;
  *(_DWORD *)(v15 + 8272) = v4;
  *(_DWORD *)(v15 + 8288) = v11 + 2;
  float result = v9 - v10;
  *(_DWORD *)(v15 + 8304) = v14 - 1;
  *(_DWORD *)(v15 + 8320) = v13;
  *(_DWORD *)(v15 + 8336) = v12 + 1;
  *(float *)(v15 + 8352) = result;
  return result;
}

__n128 anonymous namespace'::DelayHermite3rdOrder4PointSlice::Run(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v35 = *(int32x4_t *)(a1 + 8304);
  int32x4_t v37 = *(int32x4_t *)(a1 + 8320);
  int32x4_t v39 = *(int32x4_t *)(a1 + 8336);
  int32x4_t v7 = (int32x4_t)vandq_s8(*(int8x16_t *)(a1 + 4160), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2220A5190));
  int64x2_t v8 = (int64x2_t)vcgtzq_s32(v7);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0])
  {
    uint64_t v9 = *(void *)(a2 + 56);
    float v10 = (float32x4_t *)(a1 + 4192);
    float32x4_t v11 = 0uLL;
    int32x4_t v12 = 0uLL;
    v13.i64[0] = 0x100000001;
    v13.i64[1] = 0x100000001;
    do
    {
      v14.i32[0] = *(_DWORD *)(v9 + 4 * v10[-1].i32[0]);
      v14.i32[1] = *(_DWORD *)(v9 + 4 * v10[-1].i32[1]);
      v14.i32[2] = *(_DWORD *)(v9 + 4 * v10[-1].i32[2]);
      v14.i32[3] = *(_DWORD *)(v9 + 4 * v10[-1].i32[3]);
      float32x4_t v11 = vmlaq_f32(v11, (float32x4_t)vandq_s8((int8x16_t)v8, v14), *v10);
      int32x4_t v12 = vaddq_s32(v12, v13);
      int64x2_t v8 = (int64x2_t)vcgtq_s32(v7, v12);
      v10 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0]);
  }
  else
  {
    float32x4_t v11 = 0uLL;
  }
  __n128 v40 = (__n128)v11;
  float32x4_t v34 = *(float32x4_t *)(a1 + 8352);
  *(__n64 *)v15.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8368), a4, *(int32x4_t *)(a1 + 8288));
  float32x4_t v33 = v15;
  *(__n64 *)v16.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8368), a4, v35);
  float32x4_t v36 = v16;
  *(__n64 *)v17.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8368), a4, v37);
  float32x4_t v38 = v17;
  *(__n64 *)v18.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8368), a4, v39);
  HIDWORD(v19) = a4 - 1;
  LODWORD(v19) = a4 - 1;
  __asm { FMOV            V3.4S, #1.5 }
  float32x4_t v25 = vmulq_f32(vsubq_f32(v38, v18), _Q3);
  _Q3.i64[0] = 0x3F0000003F000000;
  _Q3.i64[1] = 0x3F0000003F000000;
  __asm { FMOV            V1.4S, #-2.5 }
  float32x4_t v27 = vmlaq_f32(v36, _Q1, v38);
  _Q1.i64[0] = 0x4000000040000000;
  _Q1.i64[1] = 0x4000000040000000;
  float32x4_t v28 = vmlaq_f32(v27, _Q1, v18);
  _Q1.i64[0] = 0xBF000000BF000000;
  _Q1.i64[1] = 0xBF000000BF000000;
  float32x4_t v29 = vmlaq_f32(v38, v34, vmlaq_f32(vmulq_f32(vsubq_f32(v18, v36), _Q3), v34, vmlaq_f32(vmlaq_f32(v28, _Q1, v33), v34, vmlaq_f32(v25, _Q3, vsubq_f32(v33, v36)))));
  int8x16_t v30 = vandq_s8((int8x16_t)v29, vorrq_s8((int8x16_t)vcltzq_f32(v29), (int8x16_t)vcgezq_f32(v29)));
  switch((v19 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8284)) = v30.i32[3];
LABEL_8:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8280)) = v30.i32[2];
LABEL_9:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8276)) = v30.i32[1];
LABEL_10:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8272)) = v30.i32[0];
      break;
    default:
      break;
  }
  int v31 = (*(_DWORD *)(a1 + 8376) + 1) % *(_DWORD *)(a1 + 8380);
  *(_DWORD *)(a1 + 8376) = v31;
  __n128 result = v40;
  *(__n128 *)(*(void *)(a1 + 8368) + 16 * v31) = v40;
  return result;
}

void anonymous namespace'::DelayHermite3rdOrder4PointSlice::CopyVoiceState(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, Phase::DspLayer::VoicePoolSlice *a2, signed int a3, signed int a4)
{
  uint64_t v6 = a3;
  int32x4_t v7 = (char *)a2 + 4 * a3;
  uint64_t v8 = a4;
  uint64_t v9 = (char *)this + 4 * a4;
  *((_DWORD *)v9 + 4) = *((_DWORD *)v7 + 4);
  uint64_t v10 = *((unsigned int *)v7 + 8);
  *((_DWORD *)v9 + 8) = v10;
  if ((int)v10 >= 1)
  {
    float32x4_t v11 = (_DWORD *)((char *)this + 4 * a4 + 64);
    int32x4_t v12 = (int *)((char *)a2 + 4 * a3 + 64);
    do
    {
      *(v11 - 4) = *(v12 - 4);
      int v13 = *v12;
      v12 += 8;
      _DWORD *v11 = v13;
      v11 += 8;
      --v10;
    }
    while (v10);
  }
  int8x16_t v14 = (_DWORD *)((char *)this + 4 * a4);
  float32x4_t v15 = (_DWORD *)((char *)a2 + 4 * a3);
  uint64_t v16 = v15[1040];
  v14[1040] = v16;
  if ((int)v16 >= 1)
  {
    float32x4_t v17 = v14 + 1048;
    float32x4_t v18 = v15 + 1048;
    do
    {
      *(v17 - 4) = *(v18 - 4);
      int v19 = *v18;
      v18 += 8;
      *float32x4_t v17 = v19;
      v17 += 8;
      --v16;
    }
    while (v16);
  }
  v14[1036] = v15[1036];
  v14[2068] = v15[2068];
  v14[2072] = v15[2072];
  v14[2076] = v15[2076];
  v14[2080] = v15[2080];
  v14[2084] = v15[2084];
  v14[2088] = v15[2088];
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE4CopyEPS3_ii((uint64_t)this + 8368, (uint64_t)a2 + 8368, a3, a4);
  *((void *)this + v8 + 1048) = *((void *)a2 + v6 + 1048);
}

uint64_t anonymous namespace'::DelayHermite3rdOrder4PointSlice::AddInput(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  int32x4_t v7 = (char *)this + 32;
  uint64_t v8 = *((int *)this + a3 + 8);
  if ((int)v8 > 127) {
    return 6;
  }
  uint64_t result = 0;
  uint64_t v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 12) = a4;
  *((float *)v9 + 16) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t anonymous namespace'::DelayHermite3rdOrder4PointSlice::RemoveInput(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  else {
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 32, a3, a4);
  }
}

uint64_t anonymous namespace'::DelayHermite3rdOrder4PointSlice::SetInputGain(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  uint64_t v6 = *((unsigned int *)this + a3 + 8);
  if ((int)v6 < 1) {
    return 7;
  }
  uint64_t v7 = 0;
  for (uint64_t i = (float *)((char *)this + 4 * a3 + 64); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7) {
      return 7;
    }
  }
  if ((v7 & 0x80000000) != 0) {
    return 7;
  }
  uint64_t result = 0;
  *uint64_t i = a5;
  return result;
}

void anonymous namespace'::DelayHermite3rdOrder4PointSlice::GetInputs(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 32, a3, (char **)a4);
  }
}

uint64_t anonymous namespace'::DelayHermite3rdOrder4PointSlice::ClearInputs(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 8) = 0;
  return 0;
}

uint64_t anonymous namespace'::DelayHermite3rdOrder4PointSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t anonymous namespace'::DelayHermite3rdOrder4PointSlice::GetOutput(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2, int a3)
{
  if (a2) {
    return 0xFFFFFFFF00000008;
  }
  else {
    return (unint64_t)*((unsigned int *)this + a3 + 1036) << 32;
  }
}

uint64_t anonymous namespace'::DelayHermite3rdOrder4PointSlice::SetOutput(_anonymous_namespace_::DelayHermite3rdOrder4PointSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  uint64_t result = 0;
  *((_DWORD *)this + a3 + 1036) = a4;
  return result;
}

uint64_t _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE5ResetEi(uint64_t result, unsigned int a2)
{
  if (a2 > 3) {
    __assert_rtn("Reset", "DelaylineCircular.hpp", 69, "lane >= 0 && lane < PHASE_SIMD_WIDTH");
  }
  int v2 = *(_DWORD *)(result + 12);
  if (v2 >= 1)
  {
    uint64_t v3 = (_DWORD *)(*(void *)result + 4 * a2);
    do
    {
      _DWORD *v3 = 0;
      v3 += 4;
      --v2;
    }
    while (v2);
  }
  return result;
}

__n64 _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i(void *a1, int a2, int32x4_t a3)
{
  result.n64_u64[0] = 0;
  HIDWORD(v5) = a2 - 1;
  LODWORD(v5) = a2 - 1;
  uint64_t v6 = (const float *)(a1 + 1);
  int32x4_t v7 = (int32x4_t)vld1q_dup_f32(v6);
  int32x4_t v8 = vsubq_s32(v7, a3);
  v7.i64[0] = 0x100000001;
  v7.i64[1] = 0x100000001;
  int32x4_t v9 = vaddq_s32(v8, v7);
  uint64_t v10 = (const float *)a1 + 3;
  int32x4_t v11 = (int32x4_t)vld1q_dup_f32(v10);
  int8x16_t v12 = vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vorrq_s8(vandq_s8((int8x16_t)vcltzq_s32(v9), (int8x16_t)vaddq_s32(v9, v11)), (int8x16_t)vmaxq_s32(v9, (int32x4_t)0)), 2uLL), (int8x16_t)xmmword_2220A4FB0);
  switch((v5 >> 1))
  {
    case 0u:
      result.n64_u32[0] = *(_DWORD *)(*a1 + 4 * v12.i32[0]);
      break;
    case 1u:
      result.n64_u32[0] = *(_DWORD *)(*a1 + 4 * v12.i32[0]);
      result.n64_u32[1] = *(_DWORD *)(*a1 + 4 * v12.i32[1]);
      break;
    case 3u:
      result.n64_u32[0] = *(_DWORD *)(*a1 + 4 * v12.i32[0]);
      result.n64_u32[1] = *(_DWORD *)(*a1 + 4 * vextq_s8(v12, v12, 4uLL).i32[0]);
      break;
    case 7u:
      result.n64_u32[0] = *(_DWORD *)(*a1 + 4 * v12.i32[0]);
      result.n64_u32[1] = *(_DWORD *)(*a1 + 4 * v12.i32[1]);
      break;
    default:
      return result;
  }
  return result;
}

float _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE4CopyEPS3_ii(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3 >= 4) {
    __assert_rtn("Copy", "DelaylineCircular.hpp", 538, "fromLane >= 0 && fromLane < PHASE_SIMD_WIDTH");
  }
  if (a4 >= 4) {
    __assert_rtn("Copy", "DelaylineCircular.hpp", 539, "toLane >= 0 && toLane < PHASE_SIMD_WIDTH");
  }
  int v4 = *(_DWORD *)(a1 + 12);
  if (v4 != *(_DWORD *)(a2 + 12)) {
    __assert_rtn("Copy", "DelaylineCircular.hpp", 540, "mLength == dl->mLength");
  }
  if (v4 >= 1)
  {
    unint64_t v5 = (float *)(*(void *)a2 + 4 * a3);
    uint64_t v6 = (float *)(*(void *)a1 + 4 * a4);
    do
    {
      float v7 = *v5;
      v5 += 4;
      float result = v7;
      *uint64_t v6 = v7;
      v6 += 4;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(unsigned int *)(a1 + 4 * a2);
  if ((int)v3 < 1) {
    return 7;
  }
  uint64_t v4 = 0;
  for (uint64_t i = (_DWORD *)(a1 + 4 * a2 + 16); *i != a3; i += 8)
  {
    if (v3 == ++v4) {
      return 7;
    }
  }
  if ((v4 & 0x80000000) != 0) {
    return 7;
  }
  uint64_t v6 = (v3 - 1);
  if ((int)v6 > (int)v4)
  {
    uint64_t v7 = a1 + 32 * v6 + 4 * a2;
    *uint64_t i = *(_DWORD *)(v7 + 16);
    i[4] = *(_DWORD *)(v7 + 32);
  }
  uint64_t v8 = 0;
  *(_DWORD *)(a1 + 4 * a2) = v6;
  return v8;
}

void Phase::DspLayer::VoiceConnectionList<128>::GetConnections(uint64_t a1@<X0>, int a2@<W1>, char **a3@<X8>)
{
  uint64_t v6 = (int *)(a1 + 4 * a2);
  unint64_t v7 = *v6;
  a3[1] = 0;
  a3[2] = 0;
  *a3 = 0;
  std::vector<std::pair<int,float>>::reserve((void **)a3, v7);
  if ((int)v7 >= 1)
  {
    uint64_t v8 = 0;
    uint64_t v9 = a2;
    uint64_t v10 = a3 + 2;
    int32x4_t v11 = (int *)a3[1];
    do
    {
      int8x16_t v12 = &v6[8 * v8 + 4];
      int v13 = (int *)(a1 + 32 * v8 + 4 * v9 + 32);
      if ((unint64_t)v11 >= *v10)
      {
        uint64_t v14 = ((char *)v11 - *a3) >> 3;
        if ((unint64_t)(v14 + 1) >> 61) {
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v15 = *v10 - (void)*a3;
        uint64_t v16 = v15 >> 2;
        if (v15 >> 2 <= (unint64_t)(v14 + 1)) {
          uint64_t v16 = v14 + 1;
        }
        if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = v16;
        }
        float32x4_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)(a3 + 2), v17);
        int32x4_t v20 = (int *)&v18[8 * v14];
        *int32x4_t v20 = *v12;
        v20[1] = *v13;
        int32x4_t v22 = *a3;
        int32x4_t v21 = a3[1];
        int32x4_t v23 = v20;
        if (v21 != *a3)
        {
          do
          {
            uint64_t v24 = *((void *)v21 - 1);
            v21 -= 8;
            *((void *)v23 - 1) = v24;
            v23 -= 2;
          }
          while (v21 != v22);
          int32x4_t v21 = *a3;
        }
        int32x4_t v11 = v20 + 2;
        *a3 = (char *)v23;
        a3[1] = (char *)(v20 + 2);
        a3[2] = &v18[8 * v19];
        if (v21) {
          operator delete(v21);
        }
      }
      else
      {
        int *v11 = *v12;
        v11[1] = *v13;
        v11 += 2;
      }
      a3[1] = (char *)v11;
      ++v8;
    }
    while (v8 != v7);
  }
}

void sub_221EF116C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<int,float>>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 3)
  {
    if (a2 >> 61) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v3, a2);
    unint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    uint64_t v9 = &v6[8 * v8];
    int32x4_t v11 = (char *)*a1;
    uint64_t v10 = (char *)a1[1];
    int8x16_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        uint64_t v13 = *((void *)v10 - 1);
        v10 -= 8;
        *((void *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      uint64_t v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

void std::__function::__func<Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
}

void *std::__function::__func<Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  float result = operator new(0x10uLL);
  *float result = &unk_26D474040;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D474040;
}

void std::__function::__func<Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayHermite3rdOrder4Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()()
{
}

void sub_221EF1408(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

void Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(Phase::DspLayer::DelayHermite3rdOrder6Point *this)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  uint64_t v1 = malloc_type_malloc(0x38uLL, 0x1050040B063AAFAuLL);
  void *v1 = "Delay In Seconds";
  v1[1] = 0x500000000;
  *(void *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2220A4F90;
  v1[6] = 0;
  operator new();
}

void sub_221EF15AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::DelayHermite3rdOrder6Point::~DelayHermite3rdOrder6Point(Phase::DspLayer::DelayHermite3rdOrder6Point *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);

  JUMPOUT(0x223C938A0);
}

void anonymous namespace'::DelayHermite3rdOrder6PointSlice::~DelayHermite3rdOrder6PointSlice(void **this)
{
  *this = &unk_26D4740A8;
  free(this[1050]);
  this[1050] = 0;
}

{
  uint64_t vars8;

  *this = &unk_26D4740A8;
  free(this[1050]);
  this[1050] = 0;

  JUMPOUT(0x223C938A0);
}

double anonymous namespace'::DelayHermite3rdOrder6PointSlice::Reset(uint64_t a1)
{
  *(_OWORD *)(a1 + 4144) = 0u;
  *(_DWORD *)(a1 + 8408) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  **(void **)(a1 + 8400) = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  double result = 0.0;
  *(_OWORD *)(a1 + 8432) = 0u;
  *(_OWORD *)(a1 + 8416) = 0u;
  return result;
}

uint64_t anonymous namespace'::DelayHermite3rdOrder6PointSlice::Reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (_DWORD *)(a1 + 4 * (int)a3);
  v8[4] = 0;
  v8[8] = 0;
  v8[1036] = 0;
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE5ResetEi(a1 + 8400, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2, a3);
  *(void *)(a1 + 8 * (int)a3 + 8416) = a4;
  return result;
}

double anonymous namespace'::DelayHermite3rdOrder6PointSlice::GetParameter(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2, int a3)
{
  if (!a2) {
    return *((float *)this + a3 + 4);
  }
  return result;
}

float anonymous namespace'::DelayHermite3rdOrder6PointSlice::SetParameter(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2, int a3, double a4)
{
  if (!a2)
  {
    *(float *)&a4 = a4;
    *((_DWORD *)this + a3 + 4) = LODWORD(a4);
  }
  return *(float *)&a4;
}

__n128 anonymous namespace'::DelayHermite3rdOrder6PointSlice::UpdateParameters(uint64_t a1, double *a2)
{
  float v3 = *a2;
  float32x4_t v4 = vmulq_n_f32(*(float32x4_t *)(a1 + 16), v3);
  float32x4_t v5 = vrndq_f32(v4);
  int32x4_t v6 = vcvtq_s32_f32(v5);
  v7.i64[0] = 0x100000001;
  v7.i64[1] = 0x100000001;
  int32x4_t v8 = vaddq_s32(v6, v7);
  v9.i64[0] = 0x100000001;
  v9.i64[1] = 0x100000001;
  int32x4_t v10 = vcgtq_s32(v9, v8);
  int32x4_t v11 = vdupq_n_s32(0xBB80u);
  int32x4_t v30 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v8, (int8x16_t)v10), v10), v11);
  long long v31 = *(_OWORD *)(a1 + 4144);
  v8.i64[0] = 0x300000003;
  v8.i64[1] = 0x300000003;
  int32x4_t v12 = vaddq_s32(v6, v8);
  int32x4_t v13 = vcgtq_s32(v9, v12);
  int32x4_t v29 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v12, (int8x16_t)v13), v13), v11);
  v12.i64[0] = 0x200000002;
  v12.i64[1] = 0x200000002;
  int32x4_t v14 = vaddq_s32(v6, v12);
  int32x4_t v15 = vcgtq_s32(v9, v14);
  int32x4_t v16 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v14, (int8x16_t)v15), v15), v11);
  v14.i64[0] = -1;
  v14.i64[1] = -1;
  int32x4_t v17 = vaddq_s32(v6, v14);
  int32x4_t v18 = vcgtq_s32(v9, v17);
  int32x4_t v27 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v17, (int8x16_t)v18), v18), v11);
  int32x4_t v28 = v16;
  int32x4_t v19 = vcgtq_s32(v9, v6);
  int32x4_t v20 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v6, (int8x16_t)v19), v19), v11);
  int8x16_t v21 = (int8x16_t)vaddq_s32(v6, v9);
  int32x4_t v22 = (int32x4_t)vcgtq_u32((uint32x4_t)v6, (uint32x4_t)vdupq_n_s32(0x7FFFFFFEu));
  int32x4_t v25 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8(v21, (int8x16_t)v22), v22), v11);
  int32x4_t v26 = v20;
  float32x4_t v24 = vsubq_f32(v4, v5);
  memcpy((void *)(a1 + 4160), (const void *)(a1 + 32), 0x1010uLL);
  *(_OWORD *)(a1 + 8272) = v31;
  *(int32x4_t *)(a1 + 8288) = v30;
  *(int32x4_t *)(a1 + 8304) = v29;
  *(int32x4_t *)(a1 + 8320) = v28;
  *(int32x4_t *)(a1 + 8336) = v27;
  *(int32x4_t *)(a1 + 8352) = v26;
  *(int32x4_t *)(a1 + 8368) = v25;
  __n128 result = (__n128)v24;
  *(float32x4_t *)(a1 + 8384) = v24;
  return result;
}

float anonymous namespace'::DelayHermite3rdOrder6PointSlice::UpdateParameters(uint64_t a1, double *a2, int a3)
{
  uint64_t v3 = a1 + 4 * a3;
  int v4 = *(_DWORD *)(v3 + 4144);
  float v5 = *(float *)(v3 + 16);
  double v6 = *a2;
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  *(_DWORD *)(v3 + 4160) = v7;
  if ((int)v7 >= 1)
  {
    int32x4_t v8 = (_DWORD *)(a1 + 4 * a3);
    do
    {
      v8[1044] = v8[12];
      v8[1048] = v8[16];
      v8 += 8;
      --v7;
    }
    while (v7);
  }
  float v9 = v6 * v5;
  int v10 = (int)v9;
  float v11 = truncf(v9);
  unsigned int v12 = v10 & ~(v10 >> 31);
  if (v12 >= 0xBB7F) {
    unsigned int v12 = 47999;
  }
  if (v10 <= 1) {
    unsigned int v13 = 1;
  }
  else {
    unsigned int v13 = (int)v9;
  }
  if (v13 >= 0xBB80) {
    unsigned int v13 = 48000;
  }
  if (v10 <= 2) {
    int v14 = 2;
  }
  else {
    int v14 = (int)v9;
  }
  if (v14 >= 48001) {
    int v14 = 48001;
  }
  if (v10 < 0) {
    int v15 = -1;
  }
  else {
    int v15 = (int)v9;
  }
  if (v15 >= 47998) {
    int v15 = 47998;
  }
  int v16 = v15 + 2;
  if (v10 <= -2) {
    int v17 = -2;
  }
  else {
    int v17 = (int)v9;
  }
  if (v17 >= 47997) {
    int v17 = 47997;
  }
  int v18 = v17 + 3;
  if (v10 <= 3) {
    int v10 = 3;
  }
  if (v10 >= 48002) {
    int v10 = 48002;
  }
  uint64_t v19 = a1 + 4 * a3;
  *(_DWORD *)(v19 + 8272) = v4;
  *(_DWORD *)(v19 + 8288) = v10 - 2;
  *(_DWORD *)(v19 + 8304) = v18;
  *(_DWORD *)(v19 + 8320) = v16;
  float result = v9 - v11;
  *(_DWORD *)(v19 + 8336) = v14 - 1;
  *(_DWORD *)(v19 + 8352) = v13;
  *(_DWORD *)(v19 + 8368) = v12 + 1;
  *(float *)(v19 + 8384) = result;
  return result;
}

__n128 anonymous namespace'::DelayHermite3rdOrder6PointSlice::Run(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v35 = *(int32x4_t *)(a1 + 8304);
  int32x4_t v37 = *(int32x4_t *)(a1 + 8320);
  int32x4_t v39 = *(int32x4_t *)(a1 + 8336);
  int32x4_t v41 = *(int32x4_t *)(a1 + 8352);
  int32x4_t v43 = *(int32x4_t *)(a1 + 8368);
  int32x4_t v7 = (int32x4_t)vandq_s8(*(int8x16_t *)(a1 + 4160), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2220A5190));
  int64x2_t v8 = (int64x2_t)vcgtzq_s32(v7);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0])
  {
    uint64_t v9 = *(void *)(a2 + 56);
    int v10 = (float32x4_t *)(a1 + 4192);
    float32x4_t v11 = 0uLL;
    int32x4_t v12 = 0uLL;
    v13.i64[0] = 0x100000001;
    v13.i64[1] = 0x100000001;
    do
    {
      v14.i32[0] = *(_DWORD *)(v9 + 4 * v10[-1].i32[0]);
      v14.i32[1] = *(_DWORD *)(v9 + 4 * v10[-1].i32[1]);
      v14.i32[2] = *(_DWORD *)(v9 + 4 * v10[-1].i32[2]);
      v14.i32[3] = *(_DWORD *)(v9 + 4 * v10[-1].i32[3]);
      float32x4_t v11 = vmlaq_f32(v11, (float32x4_t)vandq_s8((int8x16_t)v8, v14), *v10);
      int32x4_t v12 = vaddq_s32(v12, v13);
      int64x2_t v8 = (int64x2_t)vcgtq_s32(v7, v12);
      v10 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0]);
  }
  else
  {
    float32x4_t v11 = 0uLL;
  }
  __n128 v44 = (__n128)v11;
  float32x4_t v34 = *(float32x4_t *)(a1 + 8384);
  *(__n64 *)v15.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, *(int32x4_t *)(a1 + 8288));
  float32x4_t v33 = v15;
  *(__n64 *)v16.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v35);
  float32x4_t v36 = v16;
  *(__n64 *)v17.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v37);
  float32x4_t v38 = v17;
  *(__n64 *)v18.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v39);
  float32x4_t v40 = v18;
  *(__n64 *)v19.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v41);
  float32x4_t v42 = v19;
  *(__n64 *)v20.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v43);
  HIDWORD(v21) = a4 - 1;
  LODWORD(v21) = a4 - 1;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3DAAAAABu);
  __asm { FMOV            V4.4S, #1.25 }
  float32x4_t v28 = vmlaq_f32(vmlaq_f32(vmulq_f32(v42, (float32x4_t)vdupq_n_s32(0xC0155555)), _Q4, v40), (float32x4_t)vdupq_n_s32(0x3FD55555u), v20);
  _Q4.i64[0] = 0xBF000000BF000000;
  _Q4.i64[1] = 0xBF000000BF000000;
  float32x4_t v29 = vmlaq_f32(v42, v34, vmlaq_f32(vmlaq_f32(vmulq_f32(vsubq_f32(v20, v40), (float32x4_t)vdupq_n_s32(0x3F2AAAABu)), v22, vsubq_f32(v33, v38)), v34, vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(v28, _Q4, v38), v22, v36), (float32x4_t)vdupq_n_s32(0xBE2AAAAB), v33), v34, vmlaq_f32(vmlaq_f32(vmulq_f32(vsubq_f32(v38, v40), (float32x4_t)vdupq_n_s32(0x3F155555u)), v22, vsubq_f32(v33, v36)), (float32x4_t)vdupq_n_s32(0x3FAAAAABu), vsubq_f32(v42, v20)))));
  int8x16_t v30 = vandq_s8((int8x16_t)v29, vorrq_s8((int8x16_t)vcltzq_f32(v29), (int8x16_t)vcgezq_f32(v29)));
  switch((v21 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8284)) = v30.i32[3];
LABEL_8:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8280)) = v30.i32[2];
LABEL_9:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8276)) = v30.i32[1];
LABEL_10:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8272)) = v30.i32[0];
      break;
    default:
      break;
  }
  int v31 = (*(_DWORD *)(a1 + 8408) + 1) % *(_DWORD *)(a1 + 8412);
  *(_DWORD *)(a1 + 8408) = v31;
  __n128 result = v44;
  *(__n128 *)(*(void *)(a1 + 8400) + 16 * v31) = v44;
  return result;
}

void anonymous namespace'::DelayHermite3rdOrder6PointSlice::CopyVoiceState(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, Phase::DspLayer::VoicePoolSlice *a2, signed int a3, signed int a4)
{
  uint64_t v6 = a3;
  int32x4_t v7 = (char *)a2 + 4 * a3;
  uint64_t v8 = a4;
  uint64_t v9 = (char *)this + 4 * a4;
  *((_DWORD *)v9 + 4) = *((_DWORD *)v7 + 4);
  uint64_t v10 = *((unsigned int *)v7 + 8);
  *((_DWORD *)v9 + 8) = v10;
  if ((int)v10 >= 1)
  {
    float32x4_t v11 = (_DWORD *)((char *)this + 4 * a4 + 64);
    int32x4_t v12 = (int *)((char *)a2 + 4 * a3 + 64);
    do
    {
      *(v11 - 4) = *(v12 - 4);
      int v13 = *v12;
      v12 += 8;
      _DWORD *v11 = v13;
      v11 += 8;
      --v10;
    }
    while (v10);
  }
  int8x16_t v14 = (_DWORD *)((char *)this + 4 * a4);
  float32x4_t v15 = (_DWORD *)((char *)a2 + 4 * a3);
  uint64_t v16 = v15[1040];
  v14[1040] = v16;
  if ((int)v16 >= 1)
  {
    float32x4_t v17 = v14 + 1048;
    float32x4_t v18 = v15 + 1048;
    do
    {
      *(v17 - 4) = *(v18 - 4);
      int v19 = *v18;
      v18 += 8;
      *float32x4_t v17 = v19;
      v17 += 8;
      --v16;
    }
    while (v16);
  }
  v14[1036] = v15[1036];
  v14[2068] = v15[2068];
  v14[2072] = v15[2072];
  v14[2076] = v15[2076];
  v14[2080] = v15[2080];
  v14[2084] = v15[2084];
  v14[2088] = v15[2088];
  v14[2092] = v15[2092];
  v14[2096] = v15[2096];
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE4CopyEPS3_ii((uint64_t)this + 8400, (uint64_t)a2 + 8400, a3, a4);
  *((void *)this + v8 + 1052) = *((void *)a2 + v6 + 1052);
}

uint64_t anonymous namespace'::DelayHermite3rdOrder6PointSlice::AddInput(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  int32x4_t v7 = (char *)this + 32;
  uint64_t v8 = *((int *)this + a3 + 8);
  if ((int)v8 > 127) {
    return 6;
  }
  uint64_t result = 0;
  uint64_t v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 12) = a4;
  *((float *)v9 + 16) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t anonymous namespace'::DelayHermite3rdOrder6PointSlice::RemoveInput(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  else {
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 32, a3, a4);
  }
}

uint64_t anonymous namespace'::DelayHermite3rdOrder6PointSlice::SetInputGain(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  uint64_t v6 = *((unsigned int *)this + a3 + 8);
  if ((int)v6 < 1) {
    return 7;
  }
  uint64_t v7 = 0;
  for (uint64_t i = (float *)((char *)this + 4 * a3 + 64); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7) {
      return 7;
    }
  }
  if ((v7 & 0x80000000) != 0) {
    return 7;
  }
  uint64_t result = 0;
  *uint64_t i = a5;
  return result;
}

void anonymous namespace'::DelayHermite3rdOrder6PointSlice::GetInputs(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 32, a3, (char **)a4);
  }
}

uint64_t anonymous namespace'::DelayHermite3rdOrder6PointSlice::ClearInputs(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 8) = 0;
  return 0;
}

uint64_t anonymous namespace'::DelayHermite3rdOrder6PointSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t anonymous namespace'::DelayHermite3rdOrder6PointSlice::GetOutput(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2, int a3)
{
  if (a2) {
    return 0xFFFFFFFF00000008;
  }
  else {
    return (unint64_t)*((unsigned int *)this + a3 + 1036) << 32;
  }
}

uint64_t anonymous namespace'::DelayHermite3rdOrder6PointSlice::SetOutput(_anonymous_namespace_::DelayHermite3rdOrder6PointSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  uint64_t result = 0;
  *((_DWORD *)this + a3 + 1036) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
}

void *std::__function::__func<Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D474180;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D474180;
}

void std::__function::__func<Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayHermite3rdOrder6Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()()
{
}

void sub_221EF21D4(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

void Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(Phase::DspLayer::DelayLagrange3rdOrder3Point *this)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  uint64_t v1 = malloc_type_malloc(0x38uLL, 0x1050040B063AAFAuLL);
  void *v1 = "Delay In Seconds";
  v1[1] = 0x500000000;
  *(void *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2220A4F90;
  v1[6] = 0;
  operator new();
}

void sub_221EF2378(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::DelayLagrange3rdOrder3Point::~DelayLagrange3rdOrder3Point(Phase::DspLayer::DelayLagrange3rdOrder3Point *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);

  JUMPOUT(0x223C938A0);
}

void anonymous namespace'::DelayLagrange3rdOrder3PointSlice::~DelayLagrange3rdOrder3PointSlice(void **this)
{
  *this = &unk_26D4741E8;
  free(this[1044]);
  this[1044] = 0;
}

{
  uint64_t vars8;

  *this = &unk_26D4741E8;
  free(this[1044]);
  this[1044] = 0;

  JUMPOUT(0x223C938A0);
}

double anonymous namespace'::DelayLagrange3rdOrder3PointSlice::Reset(uint64_t a1)
{
  *(_OWORD *)(a1 + 4144) = 0u;
  *(_DWORD *)(a1 + 8360) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  **(void **)(a1 + 8352) = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  double result = 0.0;
  *(_OWORD *)(a1 + 8384) = 0u;
  *(_OWORD *)(a1 + 8368) = 0u;
  return result;
}

uint64_t anonymous namespace'::DelayLagrange3rdOrder3PointSlice::Reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (_DWORD *)(a1 + 4 * (int)a3);
  v8[4] = 0;
  v8[8] = 0;
  v8[1036] = 0;
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE5ResetEi(a1 + 8352, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2, a3);
  *(void *)(a1 + 8 * (int)a3 + 8368) = a4;
  return result;
}

double anonymous namespace'::DelayLagrange3rdOrder3PointSlice::GetParameter(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2, int a3)
{
  if (!a2) {
    return *((float *)this + a3 + 4);
  }
  return result;
}

float anonymous namespace'::DelayLagrange3rdOrder3PointSlice::SetParameter(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2, int a3, double a4)
{
  if (!a2)
  {
    *(float *)&a4 = a4;
    *((_DWORD *)this + a3 + 4) = LODWORD(a4);
  }
  return *(float *)&a4;
}

__n128 anonymous namespace'::DelayLagrange3rdOrder3PointSlice::UpdateParameters(uint64_t a1, double *a2)
{
  long long v20 = *(_OWORD *)(a1 + 4144);
  float v3 = *a2;
  float32x4_t v4 = vmulq_n_f32(*(float32x4_t *)(a1 + 16), v3);
  float32x4_t v5 = vrndq_f32(v4);
  int32x4_t v6 = vcvtq_s32_f32(v5);
  v7.i64[0] = 0x100000001;
  v7.i64[1] = 0x100000001;
  int32x4_t v8 = (int32x4_t)vcgtq_u32((uint32x4_t)v6, (uint32x4_t)vdupq_n_s32(0x7FFFFFFEu));
  int32x4_t v9 = vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)vaddq_s32(v6, v7), (int8x16_t)v8), v8);
  int32x4_t v10 = vdupq_n_s32(0xBB80u);
  int32x4_t v11 = vminq_s32(v9, v10);
  v9.i64[0] = -1;
  v9.i64[1] = -1;
  int32x4_t v12 = vaddq_s32(v6, v9);
  int32x4_t v13 = vcgtq_s32(v7, v12);
  int32x4_t v18 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v12, (int8x16_t)v13), v13), v10);
  int32x4_t v19 = v11;
  int32x4_t v14 = vcgtq_s32(v7, v6);
  float32x4_t v16 = vsubq_f32(v4, v5);
  int32x4_t v17 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v6, (int8x16_t)v14), v14), v10);
  memcpy((void *)(a1 + 4160), (const void *)(a1 + 32), 0x1010uLL);
  *(_OWORD *)(a1 + 8272) = v20;
  *(int32x4_t *)(a1 + 8288) = v19;
  *(int32x4_t *)(a1 + 8304) = v18;
  *(int32x4_t *)(a1 + 8320) = v17;
  __n128 result = (__n128)v16;
  *(float32x4_t *)(a1 + 8336) = v16;
  return result;
}

float anonymous namespace'::DelayLagrange3rdOrder3PointSlice::UpdateParameters(uint64_t a1, double *a2, int a3)
{
  uint64_t v3 = a1 + 4 * a3;
  int v4 = *(_DWORD *)(v3 + 4144);
  float v5 = *(float *)(v3 + 16);
  double v6 = *a2;
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  *(_DWORD *)(v3 + 4160) = v7;
  if ((int)v7 >= 1)
  {
    int32x4_t v8 = (_DWORD *)(a1 + 4 * a3);
    do
    {
      v8[1044] = v8[12];
      v8[1048] = v8[16];
      v8 += 8;
      --v7;
    }
    while (v7);
  }
  float v9 = v6 * v5;
  float v10 = truncf(v9);
  int v11 = (int)v9;
  if ((int)v9 <= 1) {
    unsigned int v12 = 1;
  }
  else {
    unsigned int v12 = (int)v9;
  }
  if (v12 >= 0xBB80) {
    unsigned int v12 = 48000;
  }
  if (v11 <= 2) {
    int v13 = 2;
  }
  else {
    int v13 = (int)v9;
  }
  if (v13 >= 48001) {
    int v13 = 48001;
  }
  int v14 = v13 - 1;
  unsigned int v15 = v11 & ~(v11 >> 31);
  if (v15 >= 0xBB7F) {
    unsigned int v15 = 47999;
  }
  uint64_t v16 = a1 + 4 * a3;
  *(_DWORD *)(v16 + 8272) = v4;
  *(_DWORD *)(v16 + 8288) = v15 + 1;
  *(_DWORD *)(v16 + 8304) = v14;
  float result = v9 - v10;
  *(_DWORD *)(v16 + 8320) = v12;
  *(float *)(v16 + 8336) = result;
  return result;
}

__n128 anonymous namespace'::DelayLagrange3rdOrder3PointSlice::Run(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v27 = *(int32x4_t *)(a1 + 8304);
  int32x4_t v29 = *(int32x4_t *)(a1 + 8320);
  int32x4_t v7 = (int32x4_t)vandq_s8(*(int8x16_t *)(a1 + 4160), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2220A5190));
  int64x2_t v8 = (int64x2_t)vcgtzq_s32(v7);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0])
  {
    uint64_t v9 = *(void *)(a2 + 56);
    float v10 = (float32x4_t *)(a1 + 4192);
    float32x4_t v11 = 0uLL;
    int32x4_t v12 = 0uLL;
    v13.i64[0] = 0x100000001;
    v13.i64[1] = 0x100000001;
    do
    {
      v14.i32[0] = *(_DWORD *)(v9 + 4 * v10[-1].i32[0]);
      v14.i32[1] = *(_DWORD *)(v9 + 4 * v10[-1].i32[1]);
      v14.i32[2] = *(_DWORD *)(v9 + 4 * v10[-1].i32[2]);
      v14.i32[3] = *(_DWORD *)(v9 + 4 * v10[-1].i32[3]);
      float32x4_t v11 = vmlaq_f32(v11, (float32x4_t)vandq_s8((int8x16_t)v8, v14), *v10);
      int32x4_t v12 = vaddq_s32(v12, v13);
      int64x2_t v8 = (int64x2_t)vcgtq_s32(v7, v12);
      v10 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0]);
  }
  else
  {
    float32x4_t v11 = 0uLL;
  }
  __n128 v30 = (__n128)v11;
  float32x4_t v26 = *(float32x4_t *)(a1 + 8336);
  *(__n64 *)v15.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8352), a4, *(int32x4_t *)(a1 + 8288));
  float32x4_t v25 = v15;
  *(__n64 *)v16.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8352), a4, v27);
  float32x4_t v28 = v16;
  *(__n64 *)v17.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8352), a4, v29);
  HIDWORD(v18) = a4 - 1;
  LODWORD(v18) = a4 - 1;
  v19.i64[0] = 0x3F0000003F000000;
  v19.i64[1] = 0x3F0000003F000000;
  v20.i64[0] = 0xBF000000BF000000;
  v20.i64[1] = 0xBF000000BF000000;
  float32x4_t v21 = vmlaq_f32(v17, v26, vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(v25, (float32x4_t)vdupq_n_s32(0xBEAAAAAB), v28), v20, v17), (float32x4_t)vdupq_n_s32(0xBE2AAAAB), v25), v26, vmlaq_f32(vmlaq_f32(vnegq_f32(v17), v19, vaddq_f32(v25, v28)), v26, vmlaq_f32(vmulq_f32(vsubq_f32(v17, v25), v19), (float32x4_t)vdupq_n_s32(0x3E2AAAABu), vsubq_f32(v25, v28)))));
  int8x16_t v22 = vandq_s8((int8x16_t)v21, vorrq_s8((int8x16_t)vcltzq_f32(v21), (int8x16_t)vcgezq_f32(v21)));
  switch((v18 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8284)) = v22.i32[3];
LABEL_8:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8280)) = v22.i32[2];
LABEL_9:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8276)) = v22.i32[1];
LABEL_10:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8272)) = v22.i32[0];
      break;
    default:
      break;
  }
  int v23 = (*(_DWORD *)(a1 + 8360) + 1) % *(_DWORD *)(a1 + 8364);
  *(_DWORD *)(a1 + 8360) = v23;
  __n128 result = v30;
  *(__n128 *)(*(void *)(a1 + 8352) + 16 * v23) = v30;
  return result;
}

void anonymous namespace'::DelayLagrange3rdOrder3PointSlice::CopyVoiceState(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, Phase::DspLayer::VoicePoolSlice *a2, signed int a3, signed int a4)
{
  uint64_t v6 = a3;
  int32x4_t v7 = (char *)a2 + 4 * a3;
  uint64_t v8 = a4;
  uint64_t v9 = (char *)this + 4 * a4;
  *((_DWORD *)v9 + 4) = *((_DWORD *)v7 + 4);
  uint64_t v10 = *((unsigned int *)v7 + 8);
  *((_DWORD *)v9 + 8) = v10;
  if ((int)v10 >= 1)
  {
    float32x4_t v11 = (_DWORD *)((char *)this + 4 * a4 + 64);
    int32x4_t v12 = (int *)((char *)a2 + 4 * a3 + 64);
    do
    {
      *(v11 - 4) = *(v12 - 4);
      int v13 = *v12;
      v12 += 8;
      _DWORD *v11 = v13;
      v11 += 8;
      --v10;
    }
    while (v10);
  }
  int8x16_t v14 = (_DWORD *)((char *)this + 4 * a4);
  float32x4_t v15 = (_DWORD *)((char *)a2 + 4 * a3);
  uint64_t v16 = v15[1040];
  v14[1040] = v16;
  if ((int)v16 >= 1)
  {
    float32x4_t v17 = v14 + 1048;
    unint64_t v18 = v15 + 1048;
    do
    {
      *(v17 - 4) = *(v18 - 4);
      int v19 = *v18;
      v18 += 8;
      *float32x4_t v17 = v19;
      v17 += 8;
      --v16;
    }
    while (v16);
  }
  v14[1036] = v15[1036];
  v14[2068] = v15[2068];
  v14[2072] = v15[2072];
  v14[2076] = v15[2076];
  v14[2080] = v15[2080];
  v14[2084] = v15[2084];
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE4CopyEPS3_ii((uint64_t)this + 8352, (uint64_t)a2 + 8352, a3, a4);
  *((void *)this + v8 + 1046) = *((void *)a2 + v6 + 1046);
}

uint64_t anonymous namespace'::DelayLagrange3rdOrder3PointSlice::AddInput(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  int32x4_t v7 = (char *)this + 32;
  uint64_t v8 = *((int *)this + a3 + 8);
  if ((int)v8 > 127) {
    return 6;
  }
  uint64_t result = 0;
  uint64_t v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 12) = a4;
  *((float *)v9 + 16) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t anonymous namespace'::DelayLagrange3rdOrder3PointSlice::RemoveInput(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  else {
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 32, a3, a4);
  }
}

uint64_t anonymous namespace'::DelayLagrange3rdOrder3PointSlice::SetInputGain(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  uint64_t v6 = *((unsigned int *)this + a3 + 8);
  if ((int)v6 < 1) {
    return 7;
  }
  uint64_t v7 = 0;
  for (uint64_t i = (float *)((char *)this + 4 * a3 + 64); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7) {
      return 7;
    }
  }
  if ((v7 & 0x80000000) != 0) {
    return 7;
  }
  uint64_t result = 0;
  *uint64_t i = a5;
  return result;
}

void anonymous namespace'::DelayLagrange3rdOrder3PointSlice::GetInputs(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 32, a3, (char **)a4);
  }
}

uint64_t anonymous namespace'::DelayLagrange3rdOrder3PointSlice::ClearInputs(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 8) = 0;
  return 0;
}

uint64_t anonymous namespace'::DelayLagrange3rdOrder3PointSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t anonymous namespace'::DelayLagrange3rdOrder3PointSlice::GetOutput(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2, int a3)
{
  if (a2) {
    return 0xFFFFFFFF00000008;
  }
  else {
    return (unint64_t)*((unsigned int *)this + a3 + 1036) << 32;
  }
}

uint64_t anonymous namespace'::DelayLagrange3rdOrder3PointSlice::SetOutput(_anonymous_namespace_::DelayLagrange3rdOrder3PointSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  uint64_t result = 0;
  *((_DWORD *)this + a3 + 1036) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
}

void *std::__function::__func<Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D4742C0;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D4742C0;
}

void std::__function::__func<Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLagrange3rdOrder3Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()()
{
}

void sub_221EF2E2C(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

void Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(Phase::DspLayer::DelayLagrange5thOrder6Point *this)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  uint64_t v1 = malloc_type_malloc(0x38uLL, 0x1050040B063AAFAuLL);
  void *v1 = "Delay In Seconds";
  v1[1] = 0x500000000;
  *(void *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2220A4F90;
  v1[6] = 0;
  operator new();
}

void sub_221EF2FD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::DelayLagrange5thOrder6Point::~DelayLagrange5thOrder6Point(Phase::DspLayer::DelayLagrange5thOrder6Point *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);

  JUMPOUT(0x223C938A0);
}

void anonymous namespace'::DelayLagrange5thOrder6PointSlice::~DelayLagrange5thOrder6PointSlice(void **this)
{
  *this = &unk_26D474328;
  free(this[1050]);
  this[1050] = 0;
}

{
  uint64_t vars8;

  *this = &unk_26D474328;
  free(this[1050]);
  this[1050] = 0;

  JUMPOUT(0x223C938A0);
}

double anonymous namespace'::DelayLagrange5thOrder6PointSlice::Reset(uint64_t a1)
{
  *(_OWORD *)(a1 + 4144) = 0u;
  *(_DWORD *)(a1 + 8408) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  **(void **)(a1 + 8400) = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  double result = 0.0;
  *(_OWORD *)(a1 + 8432) = 0u;
  *(_OWORD *)(a1 + 8416) = 0u;
  return result;
}

uint64_t anonymous namespace'::DelayLagrange5thOrder6PointSlice::Reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (_DWORD *)(a1 + 4 * (int)a3);
  v8[4] = 0;
  v8[8] = 0;
  v8[1036] = 0;
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE5ResetEi(a1 + 8400, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2, a3);
  *(void *)(a1 + 8 * (int)a3 + 8416) = a4;
  return result;
}

double anonymous namespace'::DelayLagrange5thOrder6PointSlice::GetParameter(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2, int a3)
{
  if (!a2) {
    return *((float *)this + a3 + 4);
  }
  return result;
}

float anonymous namespace'::DelayLagrange5thOrder6PointSlice::SetParameter(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2, int a3, double a4)
{
  if (!a2)
  {
    *(float *)&a4 = a4;
    *((_DWORD *)this + a3 + 4) = LODWORD(a4);
  }
  return *(float *)&a4;
}

__n128 anonymous namespace'::DelayLagrange5thOrder6PointSlice::UpdateParameters(uint64_t a1, double *a2)
{
  float v3 = *a2;
  float32x4_t v4 = vmulq_n_f32(*(float32x4_t *)(a1 + 16), v3);
  float32x4_t v5 = vrndq_f32(v4);
  int32x4_t v6 = vcvtq_s32_f32(v5);
  v7.i64[0] = 0x300000003;
  v7.i64[1] = 0x300000003;
  int32x4_t v8 = vaddq_s32(v6, v7);
  v9.i64[0] = 0x100000001;
  v9.i64[1] = 0x100000001;
  int32x4_t v10 = vcgtq_s32(v9, v8);
  int32x4_t v11 = vdupq_n_s32(0xBB80u);
  int32x4_t v28 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v8, (int8x16_t)v10), v10), v11);
  long long v29 = *(_OWORD *)(a1 + 4144);
  v8.i64[0] = 0x100000001;
  v8.i64[1] = 0x100000001;
  int32x4_t v12 = vaddq_s32(v6, v8);
  int32x4_t v13 = vcgtq_s32(v9, v12);
  int32x4_t v27 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v12, (int8x16_t)v13), v13), v11);
  v12.i64[0] = -1;
  v12.i64[1] = -1;
  int32x4_t v14 = vaddq_s32(v6, v12);
  int32x4_t v15 = vcgtq_s32(v9, v14);
  int32x4_t v16 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v14, (int8x16_t)v15), v15), v11);
  v14.i64[0] = 0x200000002;
  v14.i64[1] = 0x200000002;
  int32x4_t v17 = vaddq_s32(v6, v14);
  int32x4_t v18 = vcgtq_s32(v9, v17);
  int32x4_t v25 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v17, (int8x16_t)v18), v18), v11);
  int32x4_t v26 = v16;
  int32x4_t v19 = (int32x4_t)vcgtq_u32((uint32x4_t)v6, (uint32x4_t)vdupq_n_s32(0x7FFFFFFEu));
  int32x4_t v20 = vcgtq_s32(v9, v6);
  int32x4_t v23 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v6, (int8x16_t)v20), v20), v11);
  int32x4_t v24 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)vaddq_s32(v6, v9), (int8x16_t)v19), v19), v11);
  float32x4_t v22 = vsubq_f32(v4, v5);
  memcpy((void *)(a1 + 4160), (const void *)(a1 + 32), 0x1010uLL);
  *(_OWORD *)(a1 + 8272) = v29;
  *(int32x4_t *)(a1 + 8288) = v28;
  *(int32x4_t *)(a1 + 8304) = v27;
  *(int32x4_t *)(a1 + 8320) = v26;
  *(int32x4_t *)(a1 + 8336) = v25;
  *(int32x4_t *)(a1 + 8352) = v24;
  *(int32x4_t *)(a1 + 8368) = v23;
  __n128 result = (__n128)v22;
  *(float32x4_t *)(a1 + 8384) = v22;
  return result;
}

float anonymous namespace'::DelayLagrange5thOrder6PointSlice::UpdateParameters(uint64_t a1, double *a2, int a3)
{
  uint64_t v3 = a1 + 4 * a3;
  int v4 = *(_DWORD *)(v3 + 4144);
  float v5 = *(float *)(v3 + 16);
  double v6 = *a2;
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  *(_DWORD *)(v3 + 4160) = v7;
  if ((int)v7 >= 1)
  {
    int32x4_t v8 = (_DWORD *)(a1 + 4 * a3);
    do
    {
      v8[1044] = v8[12];
      v8[1048] = v8[16];
      v8 += 8;
      --v7;
    }
    while (v7);
  }
  float v9 = v6 * v5;
  int v10 = (int)v9;
  float v11 = truncf(v9);
  if ((int)v9 <= 1) {
    unsigned int v12 = 1;
  }
  else {
    unsigned int v12 = (int)v9;
  }
  if (v12 >= 0xBB80) {
    unsigned int v12 = 48000;
  }
  unsigned int v13 = v10 & ~(v10 >> 31);
  if (v13 >= 0xBB7F) {
    unsigned int v13 = 47999;
  }
  unsigned int v14 = v13 + 1;
  if (v10 < 0) {
    int v15 = -1;
  }
  else {
    int v15 = (int)v9;
  }
  if (v15 >= 47998) {
    int v15 = 47998;
  }
  int v16 = v15 + 2;
  if (v10 <= 2) {
    int v17 = 2;
  }
  else {
    int v17 = (int)v9;
  }
  if (v17 >= 48001) {
    int v17 = 48001;
  }
  int v18 = v17 - 1;
  if (v10 <= 3) {
    int v19 = 3;
  }
  else {
    int v19 = (int)v9;
  }
  if (v19 >= 48002) {
    int v19 = 48002;
  }
  int v20 = v19 - 2;
  if (v10 <= -2) {
    int v10 = -2;
  }
  if (v10 >= 47997) {
    int v10 = 47997;
  }
  uint64_t v21 = a1 + 4 * a3;
  *(_DWORD *)(v21 + 8272) = v4;
  *(_DWORD *)(v21 + 8288) = v10 + 3;
  *(_DWORD *)(v21 + 8304) = v20;
  *(_DWORD *)(v21 + 8320) = v18;
  *(_DWORD *)(v21 + 8336) = v16;
  *(_DWORD *)(v21 + 8352) = v14;
  float result = v9 - v11;
  *(_DWORD *)(v21 + 8368) = v12;
  *(float *)(v21 + 8384) = result;
  return result;
}

__n128 anonymous namespace'::DelayLagrange5thOrder6PointSlice::Run(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v41 = *(int32x4_t *)(a1 + 8304);
  int32x4_t v43 = *(int32x4_t *)(a1 + 8320);
  int32x4_t v45 = *(int32x4_t *)(a1 + 8336);
  int32x4_t v47 = *(int32x4_t *)(a1 + 8352);
  int32x4_t v49 = *(int32x4_t *)(a1 + 8368);
  int32x4_t v7 = (int32x4_t)vandq_s8(*(int8x16_t *)(a1 + 4160), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2220A5190));
  int64x2_t v8 = (int64x2_t)vcgtzq_s32(v7);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0])
  {
    uint64_t v9 = *(void *)(a2 + 56);
    int v10 = (float32x4_t *)(a1 + 4192);
    float32x4_t v11 = 0uLL;
    int32x4_t v12 = 0uLL;
    v13.i64[0] = 0x100000001;
    v13.i64[1] = 0x100000001;
    do
    {
      v14.i32[0] = *(_DWORD *)(v9 + 4 * v10[-1].i32[0]);
      v14.i32[1] = *(_DWORD *)(v9 + 4 * v10[-1].i32[1]);
      v14.i32[2] = *(_DWORD *)(v9 + 4 * v10[-1].i32[2]);
      v14.i32[3] = *(_DWORD *)(v9 + 4 * v10[-1].i32[3]);
      float32x4_t v11 = vmlaq_f32(v11, (float32x4_t)vandq_s8((int8x16_t)v8, v14), *v10);
      int32x4_t v12 = vaddq_s32(v12, v13);
      int64x2_t v8 = (int64x2_t)vcgtq_s32(v7, v12);
      v10 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0]);
  }
  else
  {
    float32x4_t v11 = 0uLL;
  }
  __n128 v50 = (__n128)v11;
  float32x4_t v40 = *(float32x4_t *)(a1 + 8384);
  *(__n64 *)v15.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, *(int32x4_t *)(a1 + 8288));
  float32x4_t v39 = v15;
  *(__n64 *)v16.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v41);
  float32x4_t v42 = v16;
  *(__n64 *)v17.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v43);
  float32x4_t v44 = v17;
  *(__n64 *)v18.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v45);
  float32x4_t v46 = v18;
  *(__n64 *)v19.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v47);
  float32x4_t v48 = v19;
  *(__n64 *)v20.f32 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8400), a4, v49);
  HIDWORD(v21) = a4 - 1;
  LODWORD(v21) = a4 - 1;
  float32x4_t v22 = (float32x4_t)vdupq_n_s32(0x3D2AAAABu);
  float32x4_t v23 = vmlaq_f32(vmlaq_f32(vmulq_f32(vsubq_f32(v44, v46), v22), (float32x4_t)vdupq_n_s32(0x3C088889u), vsubq_f32(v39, v42)), (float32x4_t)vdupq_n_s32(0x3DAAAAABu), vsubq_f32(v48, v20));
  float32x4_t v24 = vaddq_f32(v44, v48);
  float32x4_t v25 = vmulq_f32(vaddq_f32(v42, v46), v22);
  __asm { FMOV            V5.4S, #0.25 }
  float32x4_t v31 = vaddq_f32(v25, vmlaq_f32(vmulq_f32(v24, (float32x4_t)vdupq_n_s32(0xBE2AAAAB)), _Q5, v20));
  __asm { FMOV            V6.4S, #-1.25 }
  float32x4_t v33 = vsubq_f32(vmlaq_f32(vmulq_f32(v20, _Q6), (float32x4_t)vdupq_n_s32(0x3EAAAAABu), v24), v25);
  v25.i64[0] = 0xBF000000BF000000;
  v25.i64[1] = 0xBF000000BF000000;
  __asm { FMOV            V6.4S, #-0.25 }
  float32x4_t v35 = vmlaq_f32(v20, v40, vmlaq_f32(vmlaq_f32(vmlaq_f32(vaddq_f32(v48, vmlaq_f32(vmlaq_f32(vmulq_f32(v44, v25), (float32x4_t)vdupq_n_s32(0x3D4CCCCDu), v42), (float32x4_t)vdupq_n_s32(0xBEAAAAAB), v20)), _Q6, v46), (float32x4_t)vdupq_n_s32(0x3D088889u), v39), v40, vmlaq_f32(v33, v40,
              vmlaq_f32(vmlaq_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v48, (float32x4_t)vdupq_n_s32(0xBF155555)), (float32x4_t)vdupq_n_s32(0x3ED55555u), v20), (float32x4_t)vdupq_n_s32(0x3E955555u), v46), (float32x4_t)vdupq_n_s32(0xBD2AAAAB), vaddq_f32(v39, vaddq_f32(v42, v44))), v40, vmlaq_f32(v31, v40, v23)))));
  int8x16_t v36 = vandq_s8((int8x16_t)v35, vorrq_s8((int8x16_t)vcltzq_f32(v35), (int8x16_t)vcgezq_f32(v35)));
  switch((v21 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8284)) = v36.i32[3];
LABEL_8:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8280)) = v36.i32[2];
LABEL_9:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8276)) = v36.i32[1];
LABEL_10:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8272)) = v36.i32[0];
      break;
    default:
      break;
  }
  int v37 = (*(_DWORD *)(a1 + 8408) + 1) % *(_DWORD *)(a1 + 8412);
  *(_DWORD *)(a1 + 8408) = v37;
  __n128 result = v50;
  *(__n128 *)(*(void *)(a1 + 8400) + 16 * v37) = v50;
  return result;
}

void anonymous namespace'::DelayLagrange5thOrder6PointSlice::CopyVoiceState(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, Phase::DspLayer::VoicePoolSlice *a2, signed int a3, signed int a4)
{
  uint64_t v6 = a3;
  int32x4_t v7 = (char *)a2 + 4 * a3;
  uint64_t v8 = a4;
  uint64_t v9 = (char *)this + 4 * a4;
  *((_DWORD *)v9 + 4) = *((_DWORD *)v7 + 4);
  uint64_t v10 = *((unsigned int *)v7 + 8);
  *((_DWORD *)v9 + 8) = v10;
  if ((int)v10 >= 1)
  {
    float32x4_t v11 = (_DWORD *)((char *)this + 4 * a4 + 64);
    int32x4_t v12 = (int *)((char *)a2 + 4 * a3 + 64);
    do
    {
      *(v11 - 4) = *(v12 - 4);
      int v13 = *v12;
      v12 += 8;
      _DWORD *v11 = v13;
      v11 += 8;
      --v10;
    }
    while (v10);
  }
  int8x16_t v14 = (_DWORD *)((char *)this + 4 * a4);
  float32x4_t v15 = (_DWORD *)((char *)a2 + 4 * a3);
  uint64_t v16 = v15[1040];
  v14[1040] = v16;
  if ((int)v16 >= 1)
  {
    float32x4_t v17 = v14 + 1048;
    float32x4_t v18 = v15 + 1048;
    do
    {
      *(v17 - 4) = *(v18 - 4);
      int v19 = *v18;
      v18 += 8;
      *float32x4_t v17 = v19;
      v17 += 8;
      --v16;
    }
    while (v16);
  }
  v14[1036] = v15[1036];
  v14[2068] = v15[2068];
  v14[2072] = v15[2072];
  v14[2076] = v15[2076];
  v14[2080] = v15[2080];
  v14[2084] = v15[2084];
  v14[2088] = v15[2088];
  v14[2092] = v15[2092];
  v14[2096] = v15[2096];
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE4CopyEPS3_ii((uint64_t)this + 8400, (uint64_t)a2 + 8400, a3, a4);
  *((void *)this + v8 + 1052) = *((void *)a2 + v6 + 1052);
}

uint64_t anonymous namespace'::DelayLagrange5thOrder6PointSlice::AddInput(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  int32x4_t v7 = (char *)this + 32;
  uint64_t v8 = *((int *)this + a3 + 8);
  if ((int)v8 > 127) {
    return 6;
  }
  uint64_t result = 0;
  uint64_t v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 12) = a4;
  *((float *)v9 + 16) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t anonymous namespace'::DelayLagrange5thOrder6PointSlice::RemoveInput(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  else {
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 32, a3, a4);
  }
}

uint64_t anonymous namespace'::DelayLagrange5thOrder6PointSlice::SetInputGain(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  uint64_t v6 = *((unsigned int *)this + a3 + 8);
  if ((int)v6 < 1) {
    return 7;
  }
  uint64_t v7 = 0;
  for (uint64_t i = (float *)((char *)this + 4 * a3 + 64); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7) {
      return 7;
    }
  }
  if ((v7 & 0x80000000) != 0) {
    return 7;
  }
  uint64_t result = 0;
  *uint64_t i = a5;
  return result;
}

void anonymous namespace'::DelayLagrange5thOrder6PointSlice::GetInputs(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 32, a3, (char **)a4);
  }
}

uint64_t anonymous namespace'::DelayLagrange5thOrder6PointSlice::ClearInputs(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 8) = 0;
  return 0;
}

uint64_t anonymous namespace'::DelayLagrange5thOrder6PointSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t anonymous namespace'::DelayLagrange5thOrder6PointSlice::GetOutput(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2, int a3)
{
  if (a2) {
    return 0xFFFFFFFF00000008;
  }
  else {
    return (unint64_t)*((unsigned int *)this + a3 + 1036) << 32;
  }
}

uint64_t anonymous namespace'::DelayLagrange5thOrder6PointSlice::SetOutput(_anonymous_namespace_::DelayLagrange5thOrder6PointSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  uint64_t result = 0;
  *((_DWORD *)this + a3 + 1036) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
}

void *std::__function::__func<Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D474400;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D474400;
}

void std::__function::__func<Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLagrange5thOrder6Point::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()()
{
}

void sub_221EF3C70(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

void Phase::DspLayer::DelayLinear::GetNewRegistryEntry(Phase::DspLayer::DelayLinear *this)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  uint64_t v1 = malloc_type_malloc(0x38uLL, 0x1050040B063AAFAuLL);
  void *v1 = "Delay In Seconds";
  v1[1] = 0x500000000;
  *(void *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2220A4F90;
  v1[6] = 0;
  operator new();
}

void sub_221EF3E14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::DelayLinear::~DelayLinear(Phase::DspLayer::DelayLinear *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);

  JUMPOUT(0x223C938A0);
}

void anonymous namespace'::DelayLinearSlice::~DelayLinearSlice(void **this)
{
  *this = &unk_26D474468;
  free(this[1044]);
  this[1044] = 0;
}

{
  uint64_t vars8;

  *this = &unk_26D474468;
  free(this[1044]);
  this[1044] = 0;

  JUMPOUT(0x223C938A0);
}

double anonymous namespace'::DelayLinearSlice::Reset(uint64_t a1)
{
  *(_OWORD *)(a1 + 4144) = 0u;
  *(_DWORD *)(a1 + 8360) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  **(void **)(a1 + 8352) = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  double result = 0.0;
  *(_OWORD *)(a1 + 8384) = 0u;
  *(_OWORD *)(a1 + 8368) = 0u;
  return result;
}

uint64_t anonymous namespace'::DelayLinearSlice::Reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (_DWORD *)(a1 + 4 * (int)a3);
  v8[4] = 0;
  v8[8] = 0;
  v8[1036] = 0;
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE5ResetEi(a1 + 8352, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2, a3);
  *(void *)(a1 + 8 * (int)a3 + 8368) = a4;
  return result;
}

double anonymous namespace'::DelayLinearSlice::GetParameter(_anonymous_namespace_::DelayLinearSlice *this, int a2, int a3)
{
  if (!a2) {
    return *((float *)this + a3 + 4);
  }
  return result;
}

float anonymous namespace'::DelayLinearSlice::SetParameter(_anonymous_namespace_::DelayLinearSlice *this, int a2, int a3, double a4)
{
  if (!a2)
  {
    *(float *)&a4 = a4;
    *((_DWORD *)this + a3 + 4) = LODWORD(a4);
  }
  return *(float *)&a4;
}

__n128 anonymous namespace'::DelayLinearSlice::UpdateParameters(uint64_t a1, double *a2)
{
  long long v15 = *(_OWORD *)(a1 + 4144);
  float v3 = *a2;
  float32x4_t v4 = vmulq_n_f32(*(float32x4_t *)(a1 + 16), v3);
  float32x4_t v5 = vrndq_f32(v4);
  int32x4_t v6 = vcvtq_s32_f32(v5);
  v7.i64[0] = 0x100000001;
  v7.i64[1] = 0x100000001;
  int32x4_t v14 = vcgtq_s32(v7, v6);
  int32x4_t v8 = vdupq_n_s32(0xBB80u);
  float32x4_t v12 = vsubq_f32(v4, v5);
  int32x4_t v13 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v6, (int8x16_t)v14), v14), v8);
  int32x4_t v9 = (int32x4_t)vcgtq_u32((uint32x4_t)v6, (uint32x4_t)vdupq_n_s32(0x7FFFFFFEu));
  int32x4_t v11 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)vaddq_s32(v6, v7), (int8x16_t)v9), v9), v8);
  memcpy((void *)(a1 + 4160), (const void *)(a1 + 32), 0x1010uLL);
  *(_OWORD *)(a1 + 8272) = v15;
  *(int32x4_t *)(a1 + 8288) = v14;
  *(int32x4_t *)(a1 + 8304) = v13;
  *(float32x4_t *)(a1 + 8320) = v12;
  __n128 result = (__n128)v11;
  *(int32x4_t *)(a1 + 8336) = v11;
  return result;
}

float anonymous namespace'::DelayLinearSlice::UpdateParameters(uint64_t a1, double *a2, int a3)
{
  uint64_t v3 = a1 + 4 * a3;
  int v4 = *(_DWORD *)(v3 + 4144);
  float v5 = *(float *)(v3 + 16);
  double v6 = *a2;
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  *(_DWORD *)(v3 + 4160) = v7;
  if ((int)v7 >= 1)
  {
    int32x4_t v8 = (_DWORD *)(a1 + 4 * a3);
    do
    {
      v8[1044] = v8[12];
      v8[1048] = v8[16];
      v8 += 8;
      --v7;
    }
    while (v7);
  }
  float v9 = v6 * v5;
  float v10 = truncf(v9);
  int v11 = (int)v9;
  unsigned int v12 = v11 & ~(v11 >> 31);
  if (v12 >= 0xBB7F) {
    unsigned int v12 = 47999;
  }
  unsigned int v13 = v12 + 1;
  BOOL v14 = v11 < 1;
  if (v11 <= 1) {
    int v11 = 1;
  }
  int v15 = v14;
  if (v11 >= 0xBB80) {
    int v11 = 48000;
  }
  uint64_t v16 = a1 + 4 * a3;
  *(_DWORD *)(v16 + 8272) = v4;
  *(_DWORD *)(v16 + 8288) = v15;
  *(_DWORD *)(v16 + 8304) = v11;
  float result = v9 - v10;
  *(float *)(v16 + 8320) = result;
  *(_DWORD *)(v16 + 8336) = v13;
  return result;
}

void anonymous namespace'::DelayLinearSlice::Run(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v28 = *(int32x4_t *)(a1 + 8336);
  int32x4_t v7 = (int32x4_t)vandq_s8(*(int8x16_t *)(a1 + 4160), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2220A5190));
  int64x2_t v8 = (int64x2_t)vcgtzq_s32(v7);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0])
  {
    uint64_t v9 = *(void *)(a2 + 56);
    float v10 = (float32x4_t *)(a1 + 4192);
    float32x4_t v11 = 0uLL;
    int32x4_t v12 = 0uLL;
    v13.i64[0] = 0x100000001;
    v13.i64[1] = 0x100000001;
    do
    {
      v14.i32[0] = *(_DWORD *)(v9 + 4 * v10[-1].i32[0]);
      v14.i32[1] = *(_DWORD *)(v9 + 4 * v10[-1].i32[1]);
      v14.i32[2] = *(_DWORD *)(v9 + 4 * v10[-1].i32[2]);
      v14.i32[3] = *(_DWORD *)(v9 + 4 * v10[-1].i32[3]);
      float32x4_t v11 = vmlaq_f32(v11, (float32x4_t)vandq_s8((int8x16_t)v8, v14), *v10);
      int32x4_t v12 = vaddq_s32(v12, v13);
      int64x2_t v8 = (int64x2_t)vcgtq_s32(v7, v12);
      v10 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0]);
  }
  else
  {
    float32x4_t v11 = 0uLL;
  }
  int8x16_t v29 = (int8x16_t)v11;
  int8x16_t v26 = *(int8x16_t *)(a1 + 8288);
  float32x4_t v27 = *(float32x4_t *)(a1 + 8320);
  *(__n64 *)v15.i8 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8352), a4, *(int32x4_t *)(a1 + 8304));
  int8x16_t v25 = v15;
  *(__n64 *)v16.i8 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8352), a4, v28);
  int v17 = *(_DWORD *)(a1 + 8360);
  int v18 = v17;
  if (v17 < 0) {
    int v18 = *(_DWORD *)(a1 + 8364) + v17;
  }
  uint64_t v19 = *(void *)(a1 + 8352);
  HIDWORD(v20) = a4 - 1;
  LODWORD(v20) = a4 - 1;
  float32x4_t v21 = (float32x4_t)vbslq_s8(v26, v29, v25);
  float32x4_t v22 = vmlaq_f32(v21, vsubq_f32((float32x4_t)vorrq_s8(vandq_s8(*(int8x16_t *)(v19 + 16 * v18), v26), vandq_s8(v16, vmvnq_s8(v26))), v21), v27);
  int8x16_t v23 = vandq_s8((int8x16_t)v22, vorrq_s8((int8x16_t)vcltzq_f32(v22), (int8x16_t)vcgezq_f32(v22)));
  switch((v20 >> 1))
  {
    case 0u:
      goto LABEL_12;
    case 1u:
      goto LABEL_11;
    case 3u:
      goto LABEL_10;
    case 7u:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8284)) = v23.i32[3];
LABEL_10:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8280)) = v23.i32[2];
LABEL_11:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8276)) = v23.i32[1];
LABEL_12:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8272)) = v23.i32[0];
      int v17 = *(_DWORD *)(a1 + 8360);
      uint64_t v19 = *(void *)(a1 + 8352);
      break;
    default:
      break;
  }
  int v24 = (v17 + 1) % *(_DWORD *)(a1 + 8364);
  *(_DWORD *)(a1 + 8360) = v24;
  *(int8x16_t *)(v19 + 16 * v24) = v29;
}

void anonymous namespace'::DelayLinearSlice::CopyVoiceState(_anonymous_namespace_::DelayLinearSlice *this, Phase::DspLayer::VoicePoolSlice *a2, signed int a3, signed int a4)
{
  uint64_t v6 = a3;
  int32x4_t v7 = (char *)a2 + 4 * a3;
  uint64_t v8 = a4;
  uint64_t v9 = (char *)this + 4 * a4;
  *((_DWORD *)v9 + 4) = *((_DWORD *)v7 + 4);
  uint64_t v10 = *((unsigned int *)v7 + 8);
  *((_DWORD *)v9 + 8) = v10;
  if ((int)v10 >= 1)
  {
    float32x4_t v11 = (_DWORD *)((char *)this + 4 * a4 + 64);
    int32x4_t v12 = (int *)((char *)a2 + 4 * a3 + 64);
    do
    {
      *(v11 - 4) = *(v12 - 4);
      int v13 = *v12;
      v12 += 8;
      _DWORD *v11 = v13;
      v11 += 8;
      --v10;
    }
    while (v10);
  }
  int8x16_t v14 = (_DWORD *)((char *)this + 4 * a4);
  int8x16_t v15 = (_DWORD *)((char *)a2 + 4 * a3);
  uint64_t v16 = v15[1040];
  v14[1040] = v16;
  if ((int)v16 >= 1)
  {
    int v17 = v14 + 1048;
    int v18 = v15 + 1048;
    do
    {
      *(v17 - 4) = *(v18 - 4);
      int v19 = *v18;
      v18 += 8;
      *int v17 = v19;
      v17 += 8;
      --v16;
    }
    while (v16);
  }
  v14[1036] = v15[1036];
  v14[2068] = v15[2068];
  v14[2072] = v15[2072];
  v14[2076] = v15[2076];
  v14[2080] = v15[2080];
  v14[2084] = v15[2084];
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE4CopyEPS3_ii((uint64_t)this + 8352, (uint64_t)a2 + 8352, a3, a4);
  *((void *)this + v8 + 1046) = *((void *)a2 + v6 + 1046);
}

uint64_t anonymous namespace'::DelayLinearSlice::AddInput(_anonymous_namespace_::DelayLinearSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  int32x4_t v7 = (char *)this + 32;
  uint64_t v8 = *((int *)this + a3 + 8);
  if ((int)v8 > 127) {
    return 6;
  }
  uint64_t result = 0;
  uint64_t v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 12) = a4;
  *((float *)v9 + 16) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t anonymous namespace'::DelayLinearSlice::RemoveInput(_anonymous_namespace_::DelayLinearSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  else {
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 32, a3, a4);
  }
}

uint64_t anonymous namespace'::DelayLinearSlice::SetInputGain(_anonymous_namespace_::DelayLinearSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  uint64_t v6 = *((unsigned int *)this + a3 + 8);
  if ((int)v6 < 1) {
    return 7;
  }
  uint64_t v7 = 0;
  for (uint64_t i = (float *)((char *)this + 4 * a3 + 64); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7) {
      return 7;
    }
  }
  if ((v7 & 0x80000000) != 0) {
    return 7;
  }
  uint64_t result = 0;
  *uint64_t i = a5;
  return result;
}

void anonymous namespace'::DelayLinearSlice::GetInputs(_anonymous_namespace_::DelayLinearSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 32, a3, (char **)a4);
  }
}

uint64_t anonymous namespace'::DelayLinearSlice::ClearInputs(_anonymous_namespace_::DelayLinearSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 8) = 0;
  return 0;
}

uint64_t anonymous namespace'::DelayLinearSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::DelayLinearSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t anonymous namespace'::DelayLinearSlice::GetOutput(_anonymous_namespace_::DelayLinearSlice *this, int a2, int a3)
{
  if (a2) {
    return 0xFFFFFFFF00000008;
  }
  else {
    return (unint64_t)*((unsigned int *)this + a3 + 1036) << 32;
  }
}

uint64_t anonymous namespace'::DelayLinearSlice::SetOutput(_anonymous_namespace_::DelayLinearSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  uint64_t result = 0;
  *((_DWORD *)this + a3 + 1036) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayLinear::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLinear::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
}

void *std::__function::__func<Phase::DspLayer::DelayLinear::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLinear::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D474540;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayLinear::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLinear::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D474540;
}

void std::__function::__func<Phase::DspLayer::DelayLinear::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayLinear::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()()
{
}

void sub_221EF4860(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

void Phase::DspLayer::DelayStep::GetNewRegistryEntry(Phase::DspLayer::DelayStep *this)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  uint64_t v1 = malloc_type_malloc(0x38uLL, 0x1050040B063AAFAuLL);
  void *v1 = "Delay In Seconds";
  v1[1] = 0x500000000;
  *(void *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2220A4F90;
  v1[6] = 0;
  operator new();
}

void sub_221EF4A04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::DelayStep::~DelayStep(Phase::DspLayer::DelayStep *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);

  JUMPOUT(0x223C938A0);
}

void anonymous namespace'::DelayStepSlice::~DelayStepSlice(void **this)
{
  *this = &unk_26D4745A8;
  free(this[1038]);
  this[1038] = 0;
}

{
  uint64_t vars8;

  *this = &unk_26D4745A8;
  free(this[1038]);
  this[1038] = 0;

  JUMPOUT(0x223C938A0);
}

double anonymous namespace'::DelayStepSlice::Reset(uint64_t a1)
{
  *(_OWORD *)(a1 + 4144) = 0u;
  *(_DWORD *)(a1 + 8312) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  **(void **)(a1 + 8304) = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 48))(a1);
  double result = 0.0;
  *(_OWORD *)(a1 + 8336) = 0u;
  *(_OWORD *)(a1 + 8320) = 0u;
  return result;
}

uint64_t anonymous namespace'::DelayStepSlice::Reset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (_DWORD *)(a1 + 4 * (int)a3);
  v8[4] = 0;
  v8[8] = 0;
  v8[1036] = 0;
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE5ResetEi(a1 + 8304, a3);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 56))(a1, a2, a3);
  *(void *)(a1 + 8 * (int)a3 + 8320) = a4;
  return result;
}

double anonymous namespace'::DelayStepSlice::GetParameter(_anonymous_namespace_::DelayStepSlice *this, int a2, int a3)
{
  if (!a2) {
    return *((float *)this + a3 + 4);
  }
  return result;
}

float anonymous namespace'::DelayStepSlice::SetParameter(_anonymous_namespace_::DelayStepSlice *this, int a2, int a3, double a4)
{
  if (!a2)
  {
    *(float *)&a4 = a4;
    *((_DWORD *)this + a3 + 4) = LODWORD(a4);
  }
  return *(float *)&a4;
}

__n128 anonymous namespace'::DelayStepSlice::UpdateParameters(uint64_t a1, double *a2)
{
  float v3 = *a2;
  int32x4_t v4 = vcvtq_s32_f32(vmulq_n_f32(*(float32x4_t *)(a1 + 16), v3));
  v5.i64[0] = 0x100000001;
  v5.i64[1] = 0x100000001;
  int32x4_t v6 = vcgtq_s32(v5, v4);
  int32x4_t v8 = vminq_s32(vsubq_s32((int32x4_t)vbicq_s8((int8x16_t)v4, (int8x16_t)v6), v6), vdupq_n_s32(0xBB80u));
  long long v9 = *(_OWORD *)(a1 + 4144);
  memcpy((void *)(a1 + 4160), (const void *)(a1 + 32), 0x1010uLL);
  *(_OWORD *)(a1 + 8272) = v9;
  __n128 result = (__n128)v8;
  *(int32x4_t *)(a1 + 8288) = v8;
  return result;
}

uint64_t anonymous namespace'::DelayStepSlice::UpdateParameters(uint64_t result, double *a2, int a3)
{
  uint64_t v3 = result + 4 * a3;
  int v4 = *(_DWORD *)(v3 + 4144);
  float v5 = *(float *)(v3 + 16);
  double v6 = *a2;
  uint64_t v7 = *(unsigned int *)(v3 + 32);
  *(_DWORD *)(v3 + 4160) = v7;
  if ((int)v7 >= 1)
  {
    int32x4_t v8 = (_DWORD *)(result + 4 * a3);
    do
    {
      v8[1044] = v8[12];
      v8[1048] = v8[16];
      v8 += 8;
      --v7;
    }
    while (v7);
  }
  int v9 = (int)(v6 * v5);
  if (v9 <= 1) {
    int v9 = 1;
  }
  if (v9 >= 0xBB80) {
    int v9 = 48000;
  }
  uint64_t v10 = result + 4 * a3;
  *(_DWORD *)(v10 + 8272) = v4;
  *(_DWORD *)(v10 + 8288) = v9;
  return result;
}

__n128 anonymous namespace'::DelayStepSlice::Run(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v7 = (int32x4_t)vandq_s8(*(int8x16_t *)(a1 + 4160), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2220A5190));
  int64x2_t v8 = (int64x2_t)vcgtzq_s32(v7);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0])
  {
    uint64_t v9 = *(void *)(a2 + 56);
    uint64_t v10 = (float32x4_t *)(a1 + 4192);
    float32x4_t v11 = 0uLL;
    int32x4_t v12 = 0uLL;
    v13.i64[0] = 0x100000001;
    v13.i64[1] = 0x100000001;
    do
    {
      v14.i32[0] = *(_DWORD *)(v9 + 4 * v10[-1].i32[0]);
      v14.i32[1] = *(_DWORD *)(v9 + 4 * v10[-1].i32[1]);
      v14.i32[2] = *(_DWORD *)(v9 + 4 * v10[-1].i32[2]);
      v14.i32[3] = *(_DWORD *)(v9 + 4 * v10[-1].i32[3]);
      float32x4_t v11 = vmlaq_f32(v11, (float32x4_t)vandq_s8((int8x16_t)v8, v14), *v10);
      int32x4_t v12 = vaddq_s32(v12, v13);
      int64x2_t v8 = (int64x2_t)vcgtq_s32(v7, v12);
      v10 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0]);
  }
  else
  {
    float32x4_t v11 = 0uLL;
  }
  __n128 v20 = (__n128)v11;
  *(__n64 *)v15.i8 = _ZNK5Phase8DspLayer17DelaylineCircularIfDv4_fE15GetValueAtDelayEiDv4_i((void *)(a1 + 8304), a4, *(int32x4_t *)(a1 + 8288));
  HIDWORD(v16) = a4 - 1;
  LODWORD(v16) = a4 - 1;
  int8x16_t v17 = vandq_s8(v15, vorrq_s8((int8x16_t)vcltzq_f32((float32x4_t)v15), (int8x16_t)vcgezq_f32((float32x4_t)v15)));
  switch((v16 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8284)) = v17.i32[3];
LABEL_8:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8280)) = v17.i32[2];
LABEL_9:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8276)) = v17.i32[1];
LABEL_10:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(a1 + 8272)) = v17.i32[0];
      break;
    default:
      break;
  }
  int v18 = (*(_DWORD *)(a1 + 8312) + 1) % *(_DWORD *)(a1 + 8316);
  *(_DWORD *)(a1 + 8312) = v18;
  __n128 result = v20;
  *(__n128 *)(*(void *)(a1 + 8304) + 16 * v18) = v20;
  return result;
}

void anonymous namespace'::DelayStepSlice::CopyVoiceState(_anonymous_namespace_::DelayStepSlice *this, Phase::DspLayer::VoicePoolSlice *a2, signed int a3, signed int a4)
{
  uint64_t v6 = a3;
  int32x4_t v7 = (char *)a2 + 4 * a3;
  uint64_t v8 = a4;
  uint64_t v9 = (char *)this + 4 * a4;
  *((_DWORD *)v9 + 4) = *((_DWORD *)v7 + 4);
  uint64_t v10 = *((unsigned int *)v7 + 8);
  *((_DWORD *)v9 + 8) = v10;
  if ((int)v10 >= 1)
  {
    float32x4_t v11 = (_DWORD *)((char *)this + 4 * a4 + 64);
    int32x4_t v12 = (int *)((char *)a2 + 4 * a3 + 64);
    do
    {
      *(v11 - 4) = *(v12 - 4);
      int v13 = *v12;
      v12 += 8;
      _DWORD *v11 = v13;
      v11 += 8;
      --v10;
    }
    while (v10);
  }
  int8x16_t v14 = (_DWORD *)((char *)this + 4 * a4);
  int8x16_t v15 = (_DWORD *)((char *)a2 + 4 * a3);
  uint64_t v16 = v15[1040];
  v14[1040] = v16;
  if ((int)v16 >= 1)
  {
    int8x16_t v17 = v14 + 1048;
    int v18 = v15 + 1048;
    do
    {
      *(v17 - 4) = *(v18 - 4);
      int v19 = *v18;
      v18 += 8;
      *int8x16_t v17 = v19;
      v17 += 8;
      --v16;
    }
    while (v16);
  }
  v14[1036] = v15[1036];
  v14[2068] = v15[2068];
  v14[2072] = v15[2072];
  _ZN5Phase8DspLayer17DelaylineCircularIfDv4_fE4CopyEPS3_ii((uint64_t)this + 8304, (uint64_t)a2 + 8304, a3, a4);
  *((void *)this + v8 + 1040) = *((void *)a2 + v6 + 1040);
}

uint64_t anonymous namespace'::DelayStepSlice::AddInput(_anonymous_namespace_::DelayStepSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  int32x4_t v7 = (char *)this + 32;
  uint64_t v8 = *((int *)this + a3 + 8);
  if ((int)v8 > 127) {
    return 6;
  }
  uint64_t result = 0;
  uint64_t v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + 12) = a4;
  *((float *)v9 + 16) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t anonymous namespace'::DelayStepSlice::RemoveInput(_anonymous_namespace_::DelayStepSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  else {
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 32, a3, a4);
  }
}

uint64_t anonymous namespace'::DelayStepSlice::SetInputGain(_anonymous_namespace_::DelayStepSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  uint64_t v6 = *((unsigned int *)this + a3 + 8);
  if ((int)v6 < 1) {
    return 7;
  }
  uint64_t v7 = 0;
  for (uint64_t i = (float *)((char *)this + 4 * a3 + 64); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7) {
      return 7;
    }
  }
  if ((v7 & 0x80000000) != 0) {
    return 7;
  }
  uint64_t result = 0;
  *uint64_t i = a5;
  return result;
}

void anonymous namespace'::DelayStepSlice::GetInputs(_anonymous_namespace_::DelayStepSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 32, a3, (char **)a4);
  }
}

uint64_t anonymous namespace'::DelayStepSlice::ClearInputs(_anonymous_namespace_::DelayStepSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 8) = 0;
  return 0;
}

uint64_t anonymous namespace'::DelayStepSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::DelayStepSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t anonymous namespace'::DelayStepSlice::GetOutput(_anonymous_namespace_::DelayStepSlice *this, int a2, int a3)
{
  if (a2) {
    return 0xFFFFFFFF00000008;
  }
  else {
    return (unint64_t)*((unsigned int *)this + a3 + 1036) << 32;
  }
}

uint64_t anonymous namespace'::DelayStepSlice::SetOutput(_anonymous_namespace_::DelayStepSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  uint64_t result = 0;
  *((_DWORD *)this + a3 + 1036) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayStep::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayStep::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
}

void *std::__function::__func<Phase::DspLayer::DelayStep::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayStep::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D474680;
  return result;
}

void std::__function::__func<Phase::DspLayer::DelayStep::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayStep::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D474680;
}

void std::__function::__func<Phase::DspLayer::DelayStep::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::DelayStep::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()()
{
}

void sub_221EF534C(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DeviceInfo::GetAcousticID(Phase::Controller::DeviceInfo *this)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v1 = (Phase::Logger *)MGIsQuestionValid();
  if (v1)
  {
    uint64_t v2 = MGGetSInt32Answer();
    if (v2 != 0x80000000)
    {
      int v10 = v2 & 0xFFFFFF00;
      unsigned int v8 = v2;
      uint64_t v9 = 0x100000000;
      return v9 | v10 | v8;
    }
    uint64_t v3 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)v2) + 1152);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v12 = 136315394;
      int v13 = "DeviceInfo.cpp";
      __int16 v14 = 1024;
      int v15 = 91;
      int v4 = "%25s:%-5d An Acoustic ID was not found on this device.";
      float v5 = v3;
      os_log_type_t v6 = OS_LOG_TYPE_ERROR;
LABEL_7:
      _os_log_impl(&dword_221E5E000, v5, v6, v4, (uint8_t *)&v12, 0x12u);
    }
  }
  else
  {
    uint64_t v7 = **(NSObject ***)(Phase::Logger::GetInstance(v1) + 1152);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136315394;
      int v13 = "DeviceInfo.cpp";
      __int16 v14 = 1024;
      int v15 = 97;
      int v4 = "%25s:%-5d This device does not recognize the request for an Acoustic ID.";
      float v5 = v7;
      os_log_type_t v6 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_7;
    }
  }
  unsigned int v8 = 0;
  uint64_t v9 = 0;
  int v10 = 0;
  return v9 | v10 | v8;
}

uint64_t Phase::Controller::DeviceInfo::IsInternalBuild(Phase::Controller::DeviceInfo *this)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v1 = (Phase::Logger *)MGIsQuestionValid();
  if (v1)
  {
    int v2 = MGGetBoolAnswer();
    int v3 = 1;
  }
  else
  {
    int v4 = **(NSObject ***)(Phase::Logger::GetInstance(v1) + 1152);
    BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
    int v2 = 0;
    int v3 = 0;
    if (v5)
    {
      int v7 = 136315394;
      unsigned int v8 = "DeviceInfo.cpp";
      __int16 v9 = 1024;
      int v10 = 175;
      _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d This device does not recognize the request for whether or not an internal build is installed.", (uint8_t *)&v7, 0x12u);
      int v2 = 0;
      int v3 = 0;
    }
  }
  return v2 | (v3 << 8);
}

void Phase::Controller::DeviceManager::Initialize(Phase::Controller::DeviceManager *this)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  aBlock[0] = MEMORY[0x263EF8330];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZN5Phase10Controller13DeviceManager10InitializeEv_block_invoke;
  aBlock[3] = &__block_descriptor_40_e8_v12__0i8l;
  aBlock[4] = this;
  uint64_t v1 = _Block_copy(aBlock);
  CFStringRef v2 = CFStringCreateWithBytes(0, (const UInt8 *)"PHASE-DeviceManager-device-orientation", 38, 0x8000100u, 0);
  *(void *)buf = v2;
  if (!v2)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  int v3 = CARegisterDeviceOrientation();
  CFRelease(v2);
  if (v3)
  {
    BOOL v5 = **(id **)(Phase::Logger::GetInstance(v4) + 592);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "DeviceManager_iOS.mm";
      __int16 v9 = 1024;
      int v10 = 30;
      __int16 v11 = 1024;
      int v12 = v3;
      _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d Device Manager: failed to register device orientation callback. Error code %i", buf, 0x18u);
    }
  }
}

void sub_221EF5794(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZN5Phase10Controller13DeviceManager10InitializeEv_block_invoke(uint64_t a1, int a2)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(int *)(v2 + 16) <= 0)
  {
    unsigned int v8 = **(id **)(v2 + 24);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v16 = "Commandable.hpp";
      __int16 v17 = 1024;
      int v18 = 132;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pQueueId >= 0 && pQueueId < mQueueCount is false.", buf, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: pQueueId >= 0 && pQueueId < mQueueCount is false.");
  }
  uint64_t v4 = **(void **)(v2 + 8);
  unint64_t v14 = 0;
  BOOL v13 = 1;
  uint64_t v5 = Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v4, 40, &v14, &v13);
  if (!v5)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    __int16 v11 = **(id **)(v4 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v16 = "CommandQueue.hpp";
      __int16 v17 = 1024;
      int v18 = 100;
      _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    int v12 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v12, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v13)
  {
    os_log_type_t v6 = **(id **)(v4 + 48);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v16 = "CommandQueue.hpp";
      __int16 v17 = 1024;
      int v18 = 89;
      __int16 v19 = 2048;
      unint64_t v20 = v14;
      __int16 v21 = 2048;
      uint64_t v22 = 40;
      _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(void *)uint64_t v5 = &unk_26D4746F8;
  *(void *)(v5 + 8) = v2;
  *(void *)(v5 + 16) = Phase::Controller::DeviceManager::OnDeviceOrientationChanged;
  *(void *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 32) = a2;
  uint64_t result = Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v4, 40);
  atomic_store(0, (unsigned __int8 *)(v4 + 40));
  return result;
}

void sub_221EF5AB4(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x221EF5928);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Controller::DeviceManager::OnDeviceOrientationChanged(uint64_t a1, uint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  int v3 = (Phase::Controller::SpatializerManager *)Phase::Controller::TaskManager::GetService<Phase::Controller::SpatializerManager>(*(Phase::Logger **)(a1 + 40), 9);
  Phase::Device::GetOrientationString((uint64_t)__p);
  uint64_t v5 = **(id **)(Phase::Logger::GetInstance(v4) + 592);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    os_log_type_t v6 = __p;
    if (v8 < 0) {
      os_log_type_t v6 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315650;
    int v10 = "DeviceManager_iOS.mm";
    __int16 v11 = 1024;
    int v12 = 49;
    __int16 v13 = 2080;
    unint64_t v14 = v6;
    _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Device orientation changed: %s", buf, 0x1Cu);
  }
  Phase::Controller::SpatializerManager::SetDeviceOrientation(v3, a2);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
}

void sub_221EF5C40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Device::GetOrientationString(uint64_t a1@<X8>)
{
  uint64_t v2 = (const void *)CFStringCreateWithCAOrientation();
  applesauce::CF::StringRef::StringRef((applesauce::CF::StringRef *)&cf, v2);
  if (!cf)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  applesauce::CF::convert_to<std::string,0>((const __CFString *)cf, a1);
  if (cf) {
    CFRelease(cf);
  }
}

void sub_221EF5CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, const void *a10)
{
  __cxa_free_exception(v10);
  applesauce::CF::StringRef::~StringRef(&a10);
  _Unwind_Resume(a1);
}

void Phase::Controller::DeviceManager::OnAudioOutputRouteChanged(Phase::Logger **this, id *a2)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  int v3 = (Phase::Logger *)Phase::Controller::TaskManager::GetService<Phase::Controller::SpatializerManager>(this[5], 9);
  if (*((_DWORD *)a2 + 2) == 2)
  {
    uint64_t v4 = (uint64_t)v3;
    id v5 = *a2;
    if ([v5 isMemberOfClass:objc_opt_class()])
    {
      id v6 = v5;
      int v7 = [v6 portType];
      if ([v7 isEqualToString:*MEMORY[0x263EF9208]])
      {
      }
      else
      {
        __int16 v21 = [v6 portType];
        char v22 = [v21 isEqualToString:*MEMORY[0x263EF91C0]];

        if ((v22 & 1) == 0)
        {
          int8x16_t v25 = [v6 portType];
          int v26 = [v25 isEqualToString:*MEMORY[0x263EF91F0]];

          if (v26) {
            int v19 = 1;
          }
          else {
            int v19 = 2;
          }
          goto LABEL_29;
        }
      }
      int v19 = 0;
LABEL_29:

LABEL_30:
      Phase::Controller::SpatializerManager::SetSpatializerOutput(v4, v19, (uint64_t)(a2 + 2));
LABEL_31:
      id v9 = v5;
      goto LABEL_32;
    }
    int v10 = (Phase::Logger *)[v5 conformsToProtocol:&unk_26D498060];
    if (!v10)
    {
      unint64_t v20 = **(id **)(Phase::Logger::GetInstance(v10) + 528);
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        int v28 = 136315394;
        int8x16_t v29 = "DeviceManager_iOS.mm";
        __int16 v30 = 1024;
        int v31 = 132;
        _os_log_impl(&dword_221E5E000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d Invalid route change notification: description doesn't conform to any of the expected protocols.", (uint8_t *)&v28, 0x12u);
      }
      goto LABEL_31;
    }
    id v9 = v5;
    __int16 v11 = [v9 streamDescription];
    if (v11)
    {
      int v12 = [v9 streamDescription];
      __int16 v13 = [v12 objectForKeyedSubscript:@"port type"];

      unint64_t v14 = [v9 streamDescription];
      uint64_t v15 = [v14 objectForKeyedSubscript:@"port subtype"];

      if (v13
        && (uint64_t v16 = (Phase::Logger *)[v13 count], v16 == (Phase::Logger *)1)
        && v15
        && (uint64_t v16 = (Phase::Logger *)[v15 count], v16 == (Phase::Logger *)1))
      {
        __int16 v17 = [v13 firstObject];
        int v18 = [v17 unsignedIntValue];

        if ((v18 - 1885892674) <= 0x35
          && ((1 << (v18 - 66)) & 0x20000100000001) != 0)
        {
          int v19 = 0;
        }
        else
        {
          if (v18 == 1886613611)
          {
            char v24 = 1;
            int v19 = 1;
            goto LABEL_24;
          }
          int v19 = 2;
        }
        char v24 = 1;
      }
      else
      {
        uint64_t v23 = **(id **)(Phase::Logger::GetInstance(v16) + 528);
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          int v28 = 136315394;
          int8x16_t v29 = "DeviceManager_iOS.mm";
          __int16 v30 = 1024;
          int v31 = 97;
          _os_log_impl(&dword_221E5E000, v23, OS_LOG_TYPE_ERROR, "%25s:%-5d Invalid route change notification.", (uint8_t *)&v28, 0x12u);
        }
        char v24 = 0;
        int v19 = 0;
      }
LABEL_24:

      if ((v24 & 1) == 0) {
        goto LABEL_32;
      }
      goto LABEL_30;
    }
    float32x4_t v27 = **(id **)(Phase::Logger::GetInstance(0) + 528);
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      int v28 = 136315394;
      int8x16_t v29 = "DeviceManager_iOS.mm";
      __int16 v30 = 1024;
      int v31 = 125;
      _os_log_impl(&dword_221E5E000, v27, OS_LOG_TYPE_ERROR, "%25s:%-5d Invalid route change notification: missing stream description.", (uint8_t *)&v28, 0x12u);
    }
  }
  else
  {
    char v8 = **(id **)(Phase::Logger::GetInstance(v3) + 528);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v28 = 136315394;
      int8x16_t v29 = "DeviceManager_iOS.mm";
      __int16 v30 = 1024;
      int v31 = 138;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d Invalid route change notification: description is not of the expected type.", (uint8_t *)&v28, 0x12u);
    }
    id v9 = 0;
  }
LABEL_32:
}

void sub_221EF6190(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Phase::Controller::DeviceManager::DeviceManager(Phase::Controller::DeviceManager *this, const Phase::Controller::TaskManager *a2)
{
}

void sub_221EF6280(_Unwind_Exception *a1)
{
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(v1);
  _Unwind_Resume(a1);
}

void Phase::Controller::DeviceManager::~DeviceManager(Phase::Controller::DeviceManager *this)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26D4746C8;
  CFStringRef v2 = CFStringCreateWithBytes(0, (const UInt8 *)"PHASE-DeviceManager-device-orientation", 38, 0x8000100u, 0);
  *(void *)int v7 = v2;
  if (!v2)
  {
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Could not construct");
  }
  int v3 = CAUnregisterDeviceOrientation();
  CFRelease(v2);
  if (v3)
  {
    id v5 = **(id **)(Phase::Logger::GetInstance(v4) + 592);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v7 = 136315394;
      *(void *)&v7[4] = "DeviceManager_iOS.mm";
      __int16 v8 = 1024;
      int v9 = 39;
      _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d Device Manager: failed to unregister device orientation callback.", v7, 0x12u);
    }
  }

  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this);
}

{
  uint64_t vars8;

  Phase::Controller::DeviceManager::~DeviceManager(this);

  JUMPOUT(0x223C938A0);
}

void sub_221EF640C(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_free_exception(v2);
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

applesauce::CF::StringRef *applesauce::CF::StringRef::StringRef(applesauce::CF::StringRef *this, CFTypeRef cf)
{
  *(void *)this = cf;
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 != CFStringGetTypeID())
    {
      exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Could not construct");
    }
  }
  return this;
}

void sub_221EF6514(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  if (*v1) {
    CFRelease(*v1);
  }
  _Unwind_Resume(a1);
}

void Phase::LambdaFunction<BOOL Phase::Commandable<128,Phase::LockFreeQueueMPSC>::CallAsync<Phase::Controller::DeviceManager,void,CAOrientation>(int,void (Phase::Controller::DeviceManager::*)(CAOrientation),CAOrientation)::{lambda(void)#1},void>::~LambdaFunction()
{
}

uint64_t Phase::LambdaFunction<BOOL Phase::Commandable<128,Phase::LockFreeQueueMPSC>::CallAsync<Phase::Controller::DeviceManager,void,CAOrientation>(int,void (Phase::Controller::DeviceManager::*)(CAOrientation),CAOrientation)::{lambda(void)#1},void>::operator()(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void *, void))(a1 + 16);
  uint64_t v2 = *(void *)(a1 + 24);
  CFTypeID v3 = (void *)(*(void *)(a1 + 8) + (v2 >> 1));
  if (v2) {
    uint64_t v1 = *(uint64_t (**)(void *, void))(*v3 + v1);
  }
  return v1(v3, *(unsigned int *)(a1 + 32));
}

void Phase::DFTUtils::SetFftSize(Phase::DFTUtils *this, int a2)
{
  uint64_t v4 = (vDSP_DFT_SetupStruct *)*((void *)this + 1);
  if (*(_DWORD *)this != a2 || !v4 || !*((void *)this + 2))
  {
    id v5 = (vDSP_DFT_SetupStruct *)*((void *)this + 2);
    *((void *)this + 1) = vDSP_DFT_zrop_CreateSetup(*((vDSP_DFT_Setup *)this + 1), a2, vDSP_DFT_FORWARD);
    *((void *)this + 2) = vDSP_DFT_zrop_CreateSetup(v5, a2, vDSP_DFT_INVERSE);
    vDSP_DFT_DestroySetup(v4);
    vDSP_DFT_DestroySetup(v5);
    if (a2 >= 0) {
      int v6 = a2;
    }
    else {
      int v6 = a2 + 1;
    }
    *(_DWORD *)this = a2;
    *((_DWORD *)this + 1) = v6 >> 1;
  }
}

void Phase::DFTUtils::~DFTUtils(vDSP_DFT_Setup *this)
{
  uint64_t v2 = this + 1;
  vDSP_DFT_DestroySetup(this[1]);
  vDSP_DFT_DestroySetup(this[2]);
  void *v2 = 0;
  v2[1] = 0;
}

void Phase::DFTUtils::ProcessDFT(const vDSP_DFT_SetupStruct **this, DSPComplex *__C, DSPSplitComplex *a3, float a4)
{
  float __B = a4;
  vDSP_ctoz(__C, 2, a3, 1, *((int *)this + 1));
  vDSP_DFT_Execute(this[1], a3->realp, a3->imagp, a3->realp, a3->imagp);
  vDSP_vsmul(a3->realp, 1, &__B, a3->realp, 1, (uint64_t)(*(_DWORD *)this + (*(int *)this < 0)) >> 1);
  vDSP_vsmul(a3->imagp, 1, &__B, a3->imagp, 1, (uint64_t)(*(_DWORD *)this + (*(int *)this < 0)) >> 1);
}

void Phase::DFTUtils::ProcessIDFT(const vDSP_DFT_SetupStruct **this, const DSPSplitComplex *a2, DSPComplex *a3)
{
  vDSP_DFT_Execute(this[2], a2->realp, a2->imagp, a2->realp, a2->imagp);
  vDSP_ztoc(a2, 1, a3, 2, *((int *)this + 1));
  vDSP_Length v6 = *(int *)this;
  float __B = 1.0 / (float)(int)v6;
  vDSP_vsmul((const float *)a3, 1, &__B, (float *)a3, 1, v6);
}

float Phase::DFTUtils::MultiplyAddComplexPackedSpectrums(Phase::DFTUtils *this, const DSPSplitComplex *__A, const DSPSplitComplex *a3, const DSPSplitComplex *__C, DSPSplitComplex *__D, int a6)
{
  float v7 = *__A->realp;
  float v8 = *__A->imagp;
  float v9 = *a3->realp;
  float v10 = *a3->imagp;
  float v11 = *__C->realp;
  float v12 = *__C->imagp;
  vDSP_zvma(__A, 1, a3, 1, __C, 1, __D, 1, a6);
  imagp = __D->imagp;
  *__D->realp = v11 + (float)(v7 * v9);
  float result = v12 + (float)(v8 * v10);
  float *imagp = result;
  return result;
}

float Phase::DFTUtils::MultiplyComplexPackedSpectrums(Phase::DFTUtils *this, const DSPSplitComplex *__A, const DSPSplitComplex *a3, DSPSplitComplex *__C, int a5)
{
  float v6 = *__A->realp;
  float v7 = *__A->imagp;
  float v8 = *a3->realp;
  float v9 = *a3->imagp;
  vDSP_zvmul(__A, 1, a3, 1, __C, 1, a5, 1);
  imagp = __C->imagp;
  *__C->realp = v6 * v8;
  float result = v7 * v9;
  float *imagp = v7 * v9;
  return result;
}

void **Phase::SpatialModeler::DirectionalHistogramData::operator=(void **this, uint64_t a2)
{
  int v4 = *(_DWORD *)this;
  int v5 = *(_DWORD *)a2;
  if (*(_DWORD *)this != v5)
  {
    Phase::SpatialModeler::DirectionalHistogramData::allocateHistogramUniform((Phase::SpatialModeler::DirectionalHistogramData *)this, v5);
    int v4 = *(_DWORD *)this;
  }
  memcpy(this + 2, (const void *)(a2 + 16), 0x124uLL);
  memcpy(this[1], *(const void **)(a2 + 8), 4 * (73 * v4));
  return this;
}

uint64_t Phase::SpatialModeler::DirectionalHistogramData::computePDF(Phase::SpatialModeler::DirectionalHistogramData *this, int a2)
{
  uint64_t v2 = 0;
  *(void *)&v22[5] = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)this + 1) + 4 * (73 * a2);
  do
  {
    if (*(float *)(v3 + 4 * v2) < 0.0)
    {
      float v10 = **(NSObject ***)(Phase::Logger::GetInstance(this) + 1184);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        return 1;
      }
      double v11 = *(float *)(v3 + 4 * v2);
      int v17 = 136315906;
      int v18 = "DirectionalHistogramData.cpp";
      __int16 v19 = 1024;
      int v20 = 217;
      __int16 v21 = 1024;
      v22[0] = v2;
      LOWORD(v22[1]) = 2048;
      *(double *)((char *)&v22[1] + 2) = v11;
      float v12 = "%25s:%-5d computePDF fails with pTS[%u] < 0.f: %e";
      __int16 v13 = v10;
      uint32_t v14 = 34;
      goto LABEL_17;
    }
    ++v2;
  }
  while (v2 != 72);
  uint64_t v4 = 0;
  float32x4_t v5 = (float32x4_t)xmmword_2220A5530;
  do
  {
    float32x4_t v5 = vaddq_f32(v5, *(float32x4_t *)(v3 + v4));
    v4 += 16;
  }
  while (v4 != 288);
  float v6 = (float)(vaddv_f32(*(float32x2_t *)v5.f32) + v5.f32[2]) + v5.f32[3];
  if (COERCE_INT(fabs(1.0 / v6)) >= 2139095040)
  {
    uint64_t v15 = **(NSObject ***)(Phase::Logger::GetInstance(this) + 1184);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return 1;
    }
    int v17 = 136315650;
    int v18 = "DirectionalHistogramData.cpp";
    __int16 v19 = 1024;
    int v20 = 231;
    __int16 v21 = 2048;
    *(double *)char v22 = v6;
    float v12 = "%25s:%-5d computePDF inverseSum inf, sum %e";
    __int16 v13 = v15;
    uint32_t v14 = 28;
    goto LABEL_17;
  }
  uint64_t v7 = 0;
  *((_DWORD *)this + 4) = 0;
  float v8 = 0.0;
  do
  {
    float v8 = v8 + (float)(*(float *)(v3 + v7) * (float)(1.0 / v6));
    *(float *)((char *)this + v7 + 20) = v8;
    v7 += 4;
  }
  while (v7 != 288);
  if (*((float *)this + 76) > 0.9) {
    return 0;
  }
  uint64_t v16 = **(NSObject ***)(Phase::Logger::GetInstance(this) + 1184);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    int v17 = 136315394;
    int v18 = "DirectionalHistogramData.cpp";
    __int16 v19 = 1024;
    int v20 = 247;
    float v12 = "%25s:%-5d m_pdfSum[kNumGroups] <= 0.9f";
    __int16 v13 = v16;
    uint32_t v14 = 18;
LABEL_17:
    _os_log_impl(&dword_221E5E000, v13, OS_LOG_TYPE_ERROR, v12, (uint8_t *)&v17, v14);
  }
  return 1;
}

uint64_t Phase::SpatialModeler::DirectionalHistogramData::getRandomSample(Phase::SpatialModeler::DirectionalHistogramData *this, float a2, float a3, float *a4, float *a5)
{
  if (a3 == 1.0) {
    a3 = 0.0;
  }
  if (a2 == 1.0) {
    a2 = 0.0;
  }
  float v5 = *((float *)this + 4);
  if (a2 < v5) {
    return 1;
  }
  float v6 = *((float *)this + 76);
  if (a2 >= v6) {
    return 1;
  }
  unsigned int v7 = (float)((float)((float)(a2 - v5) / (float)(v6 - v5)) * 72.0);
  float v8 = *((float *)this + v7 + 4);
  if (a2 < v8 || (float v9 = *((float *)this + v7 + 5), a2 >= v9))
  {
    unsigned int v7 = 0;
    unsigned int v10 = 72;
    do
    {
      if (a2 < *((float *)this + ((v7 + v10) >> 1) + 4)) {
        unsigned int v10 = (v7 + v10) >> 1;
      }
      else {
        unsigned int v7 = (v7 + v10) >> 1;
      }
    }
    while (v10 - v7 > 1);
    float v8 = *((float *)this + v7 + 4);
    float v9 = *((float *)this + v7 + 5);
  }
  *a4 = Phase::SpatialModeler::kRangeEle[v7 / 0xCuLL]
      + (float)((float)((float)(a2 - v8) / (float)(v9 - v8))
              * (float)(Phase::SpatialModeler::kRangeEle[v7 / 0xC + 1] - Phase::SpatialModeler::kRangeEle[v7 / 0xCuLL]));
  *a5 = Phase::SpatialModeler::kRangeAzi[v7 % 0xC]
      + (float)(a3 * (float)(Phase::SpatialModeler::kRangeAzi[v7 % 0xC + 1] - Phase::SpatialModeler::kRangeAzi[v7 % 0xC]));
  return 0;
}

uint64_t Phase::SpatialModeler::DirectionalHistogramData::allocateHistogramUniform(Phase::SpatialModeler::DirectionalHistogramData *this, int a2)
{
  int v4 = *(_DWORD *)this;
  float v5 = (void *)*((void *)this + 1);
  if (v4 == a2)
  {
    if (v5)
    {
      size_t v6 = 4 * (73 * a2);
LABEL_6:
      bzero(v5, v6);
      goto LABEL_7;
    }
  }
  else
  {
    free(v5);
    *((void *)this + 1) = 0;
  }
  size_t v6 = 4 * (73 * a2);
  float v5 = malloc_type_malloc(v6, 0x100004052888210uLL);
  *((void *)this + 1) = v5;
  *(_DWORD *)this = a2;
  if (v5) {
    goto LABEL_6;
  }
LABEL_7:
  *((_DWORD *)this + 76) = 0;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  return 0;
}

void Phase::SpatialModeler::DirectionalHistogramData::getNormalizedDirectionalDistribution(Phase::SpatialModeler::DirectionalHistogramData *this, float *a2, unsigned int a3)
{
  uint64_t v3 = a2;
  if (a3 >= 0x48) {
    uint64_t v5 = 72;
  }
  else {
    uint64_t v5 = a3;
  }
  bzero(a2, (4 * v5));
  uint64_t v6 = *(unsigned int *)this;
  if (v6)
  {
    unsigned int v7 = 0;
    uint64_t v8 = 0;
    uint64_t v9 = *((void *)this + 1);
    do
    {
      if (v5)
      {
        unsigned int v10 = (float *)(v9 + 4 * v7);
        double v11 = v3;
        uint64_t v12 = v5;
        do
        {
          float v13 = *v10++;
          float *v11 = v13 + *v11;
          ++v11;
          --v12;
        }
        while (v12);
      }
      ++v8;
      v7 += 73;
    }
    while (v8 != v6);
  }
  if (v5)
  {
    float v14 = 0.0;
    uint64_t v15 = v3;
    uint64_t v16 = v5;
    do
    {
      float v17 = *v15++;
      float v14 = v14 + v17;
      --v16;
    }
    while (v16);
    if (v14 > 0.0)
    {
      do
      {
        float *v3 = *v3 / v14;
        ++v3;
        --v5;
      }
      while (v5);
    }
  }
}

void Phase::SpatialModeler::DirectivityHistogram::~DirectivityHistogram(void **this)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  *this = &unk_26D474720;
  if (!atomic_load((unsigned int *)&Phase::SpatialModeler::HistogramPtrStack::sIsClearingPoolFlag))
  {
    uint64_t v3 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)this) + 1184);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136315394;
      uint64_t v6 = "DirectivityHistogram.cpp";
      __int16 v7 = 1024;
      int v8 = 32;
      _os_log_impl(&dword_221E5E000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d DirectivityHistogram must only be destructed when free pool is cleared.\n", (uint8_t *)&v5, 0x12u);
    }
  }
  free(this[15]);
  int v4 = this[11];
  if (v4)
  {
    this[12] = v4;
    operator delete(v4);
  }
  *this = &unk_26D476708;
  free(this[1]);
}

{
  uint64_t vars8;

  Phase::SpatialModeler::DirectivityHistogram::~DirectivityHistogram(this);

  JUMPOUT(0x223C938A0);
}

void sub_221EF701C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t Phase::SpatialModeler::DirectivityHistogram::initDirectivityHistogram(Phase::SpatialModeler::DirectivityHistogram *this, float a2, int a3, float a4, float a5, float a6)
{
  uint64_t v29 = *MEMORY[0x263EF8340];
  int v8 = (Phase::Logger *)Phase::SpatialModeler::EnergyHistogram::resizeEnergyHistogram(this, a2, a3, a4, a5);
  if (v8 == 1)
  {
    uint64_t v9 = **(NSObject ***)(Phase::Logger::GetInstance(v8) + 1184);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v25 = 136315394;
      int v26 = "DirectivityHistogram.cpp";
      __int16 v27 = 1024;
      int v28 = 48;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d Could not resize histogram.\n", (uint8_t *)&v25, 0x12u);
    }
    return 1;
  }
  else
  {
    double v11 = (void *)*((void *)this + 1);
    if (v11) {
      bzero(v11, 4 * (*((_DWORD *)this + 7) * *((_DWORD *)this + 6)));
    }
    *((unsigned char *)this + 36) = 1;
    *((_DWORD *)this + 11) = 0;
    uint64_t v12 = (char *)*((void *)this + 11);
    *((void *)this + 12) = v12;
    unint64_t v13 = *((unsigned int *)this + 6);
    if (v13)
    {
      uint64_t v14 = *((void *)this + 13) - (void)v12;
      if (v13 <= v14 >> 2)
      {
        bzero(v12, 4 * v13);
        *((void *)this + 12) = &v12[4 * v13];
      }
      else
      {
        uint64_t v15 = v14 >> 1;
        if (v14 >> 1 <= v13) {
          uint64_t v15 = *((unsigned int *)this + 6);
        }
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v16 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v16 = v15;
        }
        float v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)this + 104, v16);
        uint64_t v19 = v18;
        bzero(v17, 4 * v13);
        int v20 = &v17[4 * v13];
        __int16 v21 = &v17[4 * v19];
        char v22 = (char *)*((void *)this + 11);
        for (uint64_t i = (char *)*((void *)this + 12); i != v22; i -= 4)
        {
          int v24 = *((_DWORD *)i - 1);
          *((_DWORD *)v17 - 1) = v24;
          v17 -= 4;
        }
        *((void *)this + 11) = v17;
        *((void *)this + 12) = v20;
        *((void *)this + 13) = v21;
        if (v22) {
          operator delete(v22);
        }
      }
    }
    uint64_t result = Phase::SpatialModeler::DirectionalHistogramData::allocateHistogramUniform((Phase::SpatialModeler::DirectivityHistogram *)((char *)this + 112), *((_DWORD *)this + 6));
    *((_DWORD *)this + 20) = -1;
    *((float *)this + 8) = a6;
  }
  return result;
}

uint64_t Phase::SpatialModeler::DirectivityHistogram::resetDirectivityHistogram(Phase::SpatialModeler::DirectivityHistogram *this, int a2)
{
  int v4 = (void *)*((void *)this + 15);
  if (v4) {
    bzero(v4, 4 * (73 * *((_DWORD *)this + 28)));
  }
  int v5 = (void *)*((void *)this + 11);
  uint64_t v6 = *((void *)this + 12) - (void)v5;
  if (v6 >= 1) {
    bzero(v5, 4 * (((unint64_t)v6 >> 2) - ((unint64_t)v6 > 3)) + 4);
  }
  *((_DWORD *)this + 20) = -1;
  if (a2)
  {
    __int16 v7 = (void *)*((void *)this + 1);
    if (v7) {
      bzero(v7, 4 * (*((_DWORD *)this + 7) * *((_DWORD *)this + 6)));
    }
    *((unsigned char *)this + 36) = 1;
    *((_DWORD *)this + 11) = 0;
  }
  return 0;
}

uint64_t Phase::SpatialModeler::DirectivityHistogram::addEnergySphere(uint64_t a1, uint64_t a2, float a3, float a4, float a5)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  unsigned int v8 = (float)(a3 / *(float *)(a1 + 16));
  float v10 = Phase::SpatialModeler::EnergyHistogram::addEnergy_TS(a1, v8, a2);
  if (v10 <= 1.1755e-38) {
    return 1;
  }
  int v11 = (int)(float)((float)(a5 + 90.0) / 30.0) & ~((int)(float)((float)(a5 + 90.0) / 30.0) >> 31);
  unsigned int v12 = ((5 - v11) & ((5 - v11) >> 31)) + v11;
  if (v12 > 5 || *(_DWORD *)(a1 + 112) <= v8 || (LODWORD(v10) & 0x7FFFFFFFu) >= 0x7F800000)
  {
    uint64_t v15 = **(NSObject ***)(Phase::Logger::GetInstance(v9) + 1184);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      int v18 = 136315394;
      uint64_t v19 = "DirectivityHistogram.cpp";
      __int16 v20 = 1024;
      int v21 = 186;
      _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d Could not add to histogram.", (uint8_t *)&v18, 0x12u);
    }
    return 1;
  }
  uint64_t result = 0;
  unsigned int v17 = (float)(a4 / 30.0) % 0xC + 12 * v12 + 73 * v8;
  *(float *)(*(void *)(a1 + 120) + 4 * v17) = v10 + *(float *)(*(void *)(a1 + 120) + 4 * v17);
  *(_DWORD *)(*(void *)(a1 + 88) + 4 * v8) = 1;
  *(unsigned char *)(a1 + 36) = 0;
  return result;
}

uint64_t Phase::SpatialModeler::DirectivityHistogram::findImpactAngle_TS(Phase::SpatialModeler::DirectivityHistogram *this, unsigned int a2, float *a3, float *a4, float a5, float a6)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v8 = *((void *)this + 11);
  if (a2 >= (unint64_t)((*((void *)this + 12) - v8) >> 2))
  {
    *a3 = 90.0;
    *a4 = 90.0;
    unint64_t v16 = **(NSObject ***)(Phase::Logger::GetInstance(this) + 1184);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 136315394;
      uint64_t v22 = "DirectivityHistogram.cpp";
      __int16 v23 = 1024;
      int v24 = 309;
      uint64_t v15 = "%25s:%-5d Step out of range.\n";
      unsigned int v17 = v16;
      os_log_type_t v18 = OS_LOG_TYPE_DEFAULT;
LABEL_15:
      _os_log_impl(&dword_221E5E000, v17, v18, v15, (uint8_t *)&v21, 0x12u);
      return 1;
    }
    return 1;
  }
  if (!*(_DWORD *)(v8 + 4 * a2))
  {
    *a3 = 90.0;
    *a4 = 90.0;
    return 1;
  }
  if (*((_DWORD *)this + 20) != a2)
  {
    uint64_t v19 = (Phase::SpatialModeler::DirectivityHistogram *)((char *)this + 112);
    if (*((_DWORD *)this + 28) <= a2
      || (uint64_t v19 = (Phase::Logger *)Phase::SpatialModeler::DirectionalHistogramData::computePDF(v19, a2), v19))
    {
      *a3 = 90.0;
      *a4 = 90.0;
      uint64_t v14 = **(NSObject ***)(Phase::Logger::GetInstance(v19) + 1184);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v21 = 136315394;
        uint64_t v22 = "DirectivityHistogram.cpp";
        __int16 v23 = 1024;
        int v24 = 327;
        uint64_t v15 = "%25s:%-5d Error while preparing PDF.\n";
        goto LABEL_14;
      }
      return 1;
    }
    *((_DWORD *)this + 20) = a2;
  }
  RandomSample = (Phase::Logger *)Phase::SpatialModeler::DirectionalHistogramData::getRandomSample((Phase::SpatialModeler::DirectivityHistogram *)((char *)this + 112), a5, a6, a4, a3);
  if (RandomSample == 1)
  {
    *a3 = 90.0;
    *a4 = 90.0;
    uint64_t v14 = **(NSObject ***)(Phase::Logger::GetInstance(RandomSample) + 1184);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v21 = 136315394;
      uint64_t v22 = "DirectivityHistogram.cpp";
      __int16 v23 = 1024;
      int v24 = 338;
      uint64_t v15 = "%25s:%-5d Unknown error while resampling PDF.\n";
LABEL_14:
      unsigned int v17 = v14;
      os_log_type_t v18 = OS_LOG_TYPE_ERROR;
      goto LABEL_15;
    }
    return 1;
  }
  return 0;
}

void Phase::SpatialModeler::DirectivityHistogram::getNormalizedDirectionalDistribution(Phase::SpatialModeler::DirectivityHistogram *this, float *a2, unsigned int a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (a3 != 72)
  {
    uint64_t v6 = **(NSObject ***)(Phase::Logger::GetInstance(this) + 1184);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      int v7 = 136315394;
      uint64_t v8 = "DirectivityHistogram.cpp";
      __int16 v9 = 1024;
      int v10 = 353;
      _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d getNormalizedDirectionalDistribution: Mismatch of number of direction groups.\n", (uint8_t *)&v7, 0x12u);
    }
  }
  Phase::SpatialModeler::DirectionalHistogramData::getNormalizedDirectionalDistribution((Phase::SpatialModeler::DirectivityHistogram *)((char *)this + 112), a2, a3);
}

void Phase::SpatialModeler::DirectivityHistogram::updateWasHitVector(Phase::SpatialModeler::DirectivityHistogram *this)
{
  if (*((_DWORD *)this + 6))
  {
    unint64_t v2 = 0;
    do
    {
      vDSP_Length v3 = *((unsigned int *)this + 7);
      int v4 = (const float *)(*((void *)this + 1) + 4 * v2 * v3);
      float __C = -3.4028e38;
      vDSP_maxv(v4, 1, &__C, v3);
      *(_DWORD *)(*((void *)this + 11) + 4 * v2++) = __C > 1.0e-22;
    }
    while (v2 < *((unsigned int *)this + 6));
  }
}

Phase::SpatialModeler::EnergyHistogram *Phase::SpatialModeler::DirectivityHistogram::operator=(Phase::SpatialModeler::EnergyHistogram *this, uint64_t a2)
{
  if ((Phase::SpatialModeler::EnergyHistogram *)a2 != this)
  {
    Phase::SpatialModeler::EnergyHistogram::operator=((void **)this, a2);
    *((_DWORD *)this + 20) = *(_DWORD *)(a2 + 80);
    std::vector<unsigned int>::__assign_with_size[abi:ne180100]<unsigned int *,unsigned int *>((char *)this + 88, *(char **)(a2 + 88), *(void *)(a2 + 96), (uint64_t)(*(void *)(a2 + 96) - *(void *)(a2 + 88)) >> 2);
    Phase::SpatialModeler::DirectionalHistogramData::operator=((void **)this + 14, a2 + 112);
  }
  return this;
}

uint64_t Phase::SpatialModeler::DirectivityHistogram::operator+=(uint64_t a1, uint64_t a2)
{
  Phase::SpatialModeler::EnergyHistogram::operator+=(a1, a2);
  int v4 = *(_DWORD **)(a1 + 88);
  uint64_t v5 = *(void *)(a1 + 96) - (void)v4;
  if (v5)
  {
    unint64_t v6 = v5 >> 2;
    int v7 = *(_DWORD **)(a2 + 88);
    uint64_t v8 = (uint64_t)(*(void *)(a2 + 96) - (void)v7) >> 2;
    if (v6 <= 1) {
      unint64_t v6 = 1;
    }
    do
    {
      if (!v8) {
        break;
      }
      if (*v7 == 1) {
        _DWORD *v4 = 1;
      }
      ++v7;
      ++v4;
      --v8;
      --v6;
    }
    while (v6);
  }
  unsigned int v9 = *(_DWORD *)(a2 + 112);
  if (v9 >= *(_DWORD *)(a1 + 112)) {
    unsigned int v9 = *(_DWORD *)(a1 + 112);
  }
  if (v9)
  {
    LODWORD(v10) = 73 * v9;
    uint64_t v11 = *(float **)(a2 + 120);
    unsigned int v12 = *(float **)(a1 + 120);
    if (v10 <= 1) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = v10;
    }
    do
    {
      float v13 = *v11++;
      *unsigned int v12 = v13 + *v12;
      ++v12;
      --v10;
    }
    while (v10);
  }
  *(_DWORD *)(a1 + 80) = -1;
  return a1;
}

void sub_221EF798C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
  if (a2 == 1)
  {
    unsigned int v9 = (Phase::Logger *)__cxa_begin_catch(exception_object);
    uint64_t v10 = **(NSObject ***)(Phase::Logger::GetInstance(v9) + 1184);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(a9) = 136315394;
      *(void *)((char *)&a9 + 4) = "DirectivityHistogram.cpp";
      WORD6(a9) = 1024;
      *(_DWORD *)((char *)&a9 + 14) = 443;
      _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d Cannot add other histogram because of a size mismatch.\n", (uint8_t *)&a9, 0x12u);
    }
    __cxa_end_catch();
    JUMPOUT(0x221EF795CLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::SpatialModeler::DirectivityHistogram::MultiplyAdd(Phase::SpatialModeler::DirectivityHistogram *this, float **a2, float a3)
{
  uint64_t result = Phase::SpatialModeler::EnergyHistogram::MultiplyAdd((uint64_t)this, (const Phase::SpatialModeler::EnergyHistogram *)a2, a3);
  int v7 = (_DWORD *)*((void *)this + 11);
  uint64_t v8 = *((void *)this + 12) - (void)v7;
  if (v8)
  {
    unint64_t v9 = v8 >> 2;
    uint64_t v10 = (char *)a2[11];
    uint64_t v11 = ((char *)a2[12] - v10) >> 2;
    if (v9 <= 1) {
      unint64_t v9 = 1;
    }
    do
    {
      if (!v11) {
        break;
      }
      int v12 = *(_DWORD *)v10;
      v10 += 4;
      *v7++ |= v12;
      --v11;
      --v9;
    }
    while (v9);
  }
  unsigned int v13 = *((_DWORD *)a2 + 28);
  if (v13 >= *((_DWORD *)this + 28)) {
    unsigned int v13 = *((_DWORD *)this + 28);
  }
  if (v13)
  {
    LODWORD(v14) = 73 * v13;
    uint64_t v15 = a2[15];
    unint64_t v16 = (float *)*((void *)this + 15);
    if (v14 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = v14;
    }
    do
    {
      float v17 = *v15++;
      float *v16 = *v16 + (float)(v17 * a3);
      ++v16;
      --v14;
    }
    while (v14);
  }
  *((_DWORD *)this + 20) = -1;
  return result;
}

void sub_221EF7B38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
  if (a2 == 1)
  {
    unint64_t v9 = (Phase::Logger *)__cxa_begin_catch(exception_object);
    uint64_t v10 = **(NSObject ***)(Phase::Logger::GetInstance(v9) + 1184);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(a9) = 136315394;
      *(void *)((char *)&a9 + 4) = "DirectivityHistogram.cpp";
      WORD6(a9) = 1024;
      *(_DWORD *)((char *)&a9 + 14) = 474;
      _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d Cannot add other histogram because of a size mismatch.\n", (uint8_t *)&a9, 0x12u);
    }
    __cxa_end_catch();
    JUMPOUT(0x221EF7B08);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::SpatialModeler::DirectivityHistogram::operator*=(void *a1, float a2)
{
  int v4 = *(_DWORD *)(Phase::SpatialModeler::EnergyHistogram::operator*=((uint64_t)a1, a2) + 112);
  if (v4)
  {
    unsigned int v5 = 73 * v4;
    if (v5 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = (v6 + 3) & 0x1FFFFFFFCLL;
    uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(v6 - 1);
    int64x2_t v9 = (int64x2_t)xmmword_2220A5510;
    int64x2_t v10 = (int64x2_t)xmmword_2220A5520;
    uint64_t v11 = (float *)(a1[15] + 8);
    int64x2_t v12 = vdupq_n_s64(4uLL);
    do
    {
      int32x4_t v13 = (int32x4_t)vcgeq_u64(v8, (uint64x2_t)v10);
      *(int32x2_t *)v13.i8 = vmovn_s64((int64x2_t)v13);
      int32x2_t v14 = (int32x2_t)vmovn_s32(v13);
      if (v14.i8[0])
      {
        *(float *)v14.i32 = *(v11 - 2) * a2;
        *(v11 - 2) = *(float *)v14.i32;
      }
      if (vmovn_s32(v13).i8[2]) {
        *(v11 - 1) = *(v11 - 1) * a2;
      }
      int64x2_t v15 = (int64x2_t)vcgeq_u64(v8, (uint64x2_t)v9);
      if (vmovn_s32(vmovn_hight_s64(v14, v15)).i32[1]) {
        float *v11 = *v11 * a2;
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v15, v15)).i8[6]) {
        v11[1] = v11[1] * a2;
      }
      int64x2_t v9 = vaddq_s64(v9, v12);
      int64x2_t v10 = vaddq_s64(v10, v12);
      v11 += 4;
      v7 -= 4;
    }
    while (v7);
  }
  if (a2 == 0.0)
  {
    unint64_t v16 = (void *)a1[11];
    uint64_t v17 = a1[12] - (void)v16;
    if (v17 >= 1) {
      bzero(v16, 4 * (((unint64_t)v17 >> 2) - ((unint64_t)v17 > 3)) + 4);
    }
  }
  return a1;
}

uint64_t Phase::SpatialModeler::DirectivityHistogram::operator/=(uint64_t a1, float a2)
{
  float v2 = 1.0 / a2;
  uint64_t result = Phase::SpatialModeler::EnergyHistogram::operator*=(a1, 1.0 / a2);
  int v4 = *(_DWORD *)(result + 112);
  if (v4)
  {
    unsigned int v5 = 73 * v4;
    if (v5 <= 1) {
      uint64_t v6 = 1;
    }
    else {
      uint64_t v6 = v5;
    }
    uint64_t v7 = (v6 + 3) & 0x1FFFFFFFCLL;
    uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(v6 - 1);
    int64x2_t v9 = (int64x2_t)xmmword_2220A5510;
    int64x2_t v10 = (int64x2_t)xmmword_2220A5520;
    uint64_t v11 = (float *)(*(void *)(result + 120) + 8);
    int64x2_t v12 = vdupq_n_s64(4uLL);
    do
    {
      int32x4_t v13 = (int32x4_t)vcgeq_u64(v8, (uint64x2_t)v10);
      *(int32x2_t *)v13.i8 = vmovn_s64((int64x2_t)v13);
      int32x2_t v14 = (int32x2_t)vmovn_s32(v13);
      if (v14.i8[0])
      {
        *(float *)v14.i32 = v2 * *(v11 - 2);
        *(v11 - 2) = *(float *)v14.i32;
      }
      if (vmovn_s32(v13).i8[2]) {
        *(v11 - 1) = v2 * *(v11 - 1);
      }
      int64x2_t v15 = (int64x2_t)vcgeq_u64(v8, (uint64x2_t)v9);
      if (vmovn_s32(vmovn_hight_s64(v14, v15)).i32[1]) {
        float *v11 = v2 * *v11;
      }
      if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v15, v15)).i8[6]) {
        v11[1] = v2 * v11[1];
      }
      int64x2_t v9 = vaddq_s64(v9, v12);
      int64x2_t v10 = vaddq_s64(v10, v12);
      v11 += 4;
      v7 -= 4;
    }
    while (v7);
  }
  return result;
}

void *Phase::SpatialModeler::DirectPathTransmissionDebugger::BeginTrackingSource(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = a2;
  uint64_t v7 = &v6;
  int v4 = std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>>>::__emplace_unique_key_args<Phase::Handle64,std::piecewise_construct_t const&,std::tuple<Phase::Handle64 const&>,std::tuple<>>((uint64_t **)(a1 + 8), &v6, (uint64_t)&std::piecewise_construct, &v7);
  return std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::operator=(v4 + 7, a3);
}

void *std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void *Phase::SpatialModeler::DirectPathTransmissionDebugger::EndTrackingSource(Phase::SpatialModeler::DirectPathTransmissionDebugger *this, Handle64 a2)
{
  int v4 = (void *)*((void *)this + 2);
  uint64_t result = (void *)((char *)this + 16);
  vDSP_Length v3 = v4;
  if (v4)
  {
    uint64_t v5 = (uint64_t)result;
    do
    {
      unint64_t v6 = v3[4];
      BOOL v7 = v6 >= a2.mData;
      if (v6 >= a2.mData) {
        uint64x2_t v8 = v3;
      }
      else {
        uint64x2_t v8 = v3 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v3;
      }
      vDSP_Length v3 = (void *)*v8;
    }
    while (*v8);
    if ((void *)v5 != result && *(void *)(v5 + 32) <= a2.mData) {
      return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::operator=[abi:ne180100]((void *)(v5 + 56));
    }
  }
  return result;
}

void *Phase::SpatialModeler::DirectPathTransmissionDebugger::BeginTrackingAudibleGeometry(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v6 = a2;
  BOOL v7 = &v6;
  int v4 = std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>>>::__emplace_unique_key_args<Phase::Handle64,std::piecewise_construct_t const&,std::tuple<Phase::Handle64 const&>,std::tuple<>>((uint64_t **)(a1 + 8), &v6, (uint64_t)&std::piecewise_construct, &v7);
  return std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::operator=(v4 + 11, a3);
}

void *std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void *Phase::SpatialModeler::DirectPathTransmissionDebugger::EndTrackingAudibleGeometry(Phase::SpatialModeler::DirectPathTransmissionDebugger *this, Handle64 a2)
{
  int v4 = (void *)*((void *)this + 2);
  uint64_t result = (void *)((char *)this + 16);
  vDSP_Length v3 = v4;
  if (v4)
  {
    uint64_t v5 = (uint64_t)result;
    do
    {
      unint64_t v6 = v3[4];
      BOOL v7 = v6 >= a2.mData;
      if (v6 >= a2.mData) {
        uint64x2_t v8 = v3;
      }
      else {
        uint64x2_t v8 = v3 + 1;
      }
      if (v7) {
        uint64_t v5 = (uint64_t)v3;
      }
      vDSP_Length v3 = (void *)*v8;
    }
    while (*v8);
    if ((void *)v5 != result && *(void *)(v5 + 32) <= a2.mData) {
      return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::operator=[abi:ne180100]((void *)(v5 + 88));
    }
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::__map_value_compare<Phase::Handle64,std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>,std::less<Phase::Handle64>,true>,std::allocator<std::__value_type<Phase::Handle64,Phase::SpatialModeler::DirectPathTransmissionDebugger::SourceDebugInfo>>>::__emplace_unique_key_args<Phase::Handle64,std::piecewise_construct_t const&,std::tuple<Phase::Handle64 const&>,std::tuple<>>(uint64_t **a1, unint64_t *a2, uint64_t a3, void **a4)
{
  BOOL v7 = a1 + 1;
  unint64_t v6 = a1[1];
  if (v6)
  {
    unint64_t v8 = *a2;
    while (1)
    {
      while (1)
      {
        int64x2_t v9 = (uint64_t **)v6;
        unint64_t v10 = v6[4];
        if (v8 >= v10) {
          break;
        }
        unint64_t v6 = *v9;
        BOOL v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      unint64_t v6 = v9[1];
      if (!v6)
      {
        BOOL v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int64x2_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x78uLL);
    v11[4] = **a4;
    *((_OWORD *)v11 + 5) = 0u;
    *((_OWORD *)v11 + 6) = 0u;
    *((_OWORD *)v11 + 3) = 0u;
    *((_OWORD *)v11 + 4) = 0u;
    v11[5] = -1;
    *((_DWORD *)v11 + 12) = -1;
    *((unsigned char *)v11 + 52) = 1;
    v11[14] = 0;
    std::__tree<Phase::SpatialCategory>::__insert_node_at(a1, (uint64_t)v9, v7, v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void *std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100](void *a1)
{
  float v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    int v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221EF8540(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::operator=[abi:ne180100](void *a1)
{
  float v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    int v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221EF88CC(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::operator=[abi:ne180100](void *a1)
{
  float v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

const char *Phase::SpatialModeler::DirectPathTransmissionErrorCategory::name(Phase::SpatialModeler::DirectPathTransmissionErrorCategory *this)
{
  return "Direct Path Transmission";
}

void Phase::SpatialModeler::DirectPathTransmissionErrorCategory::message(int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 7)
  {
    if (a1 == 129)
    {
      uint64_t v5 = "Scene queries submitted to the Geometry Layer failed";
    }
    else if (a1 == 128)
    {
      uint64_t v5 = "Cannot generate source points from the SourceEntity";
    }
    else
    {
      uint64_t v5 = "(unrecognized error)";
    }
    std::string::basic_string[abi:ne180100]<0>(a2, v5);
  }
  else
  {
    std::string::basic_string[abi:ne180100]<0>(__p, "Direct path transmission ");
    Phase::SpatialModeler::ModelerErrorMessage(a1, (const void **)__p, (uint64_t)a2);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_221EF8A24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::SpatialModeler::DirectPathTransmissionErrorCategory::~DirectPathTransmissionErrorCategory(std::error_category *this)
{
  std::error_category::~error_category(this);

  JUMPOUT(0x223C938A0);
}

uint64_t (***Phase::SpatialModeler::DirectPathTransmissionImpl::RunCullQuery@<X0>(uint64_t (***result)(void)@<X0>, void *a2@<X1>, uint64_t a3@<X8>))(void)
{
  uint64_t v4 = a2[11];
  if (!v4 || *(_DWORD *)v4 != 1)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    uint64_t v14 = 3;
LABEL_16:
    *(void *)a3 = v14;
    *(void *)(a3 + 8) = result;
    int v13 = 2;
    goto LABEL_17;
  }
  uint64_t v5 = a2[8];
  if (!v5)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    uint64_t v14 = 5;
    goto LABEL_16;
  }
  uint64_t v6 = *(void *)(v4 + 480);
  unsigned int v7 = *(_DWORD *)(v5 + 136);
  if (v7 <= v6
    || (uint64_t v8 = *(void *)(v5 + 120), *(_DWORD *)(v8 + 24 * v6 + 20) != HIDWORD(v6))
    || (int64x2_t v9 = *(_DWORD **)(v8 + 24 * *(void *)(v4 + 480))) == 0
    || *v9 != 2)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    uint64_t v14 = 7;
    goto LABEL_16;
  }
  uint64_t v10 = *(void *)(v4 + 336);
  if (v7 <= v10
    || (unsigned int v11 = *(void *)(v4 + 336), *(_DWORD *)(v8 + 24 * v10 + 20) != HIDWORD(v10))
    || (int64x2_t v12 = *(_DWORD **)(v8 + 24 * v11)) == 0
    || *v12 != 3)
  {
    uint64_t result = (uint64_t (***)(void))(**result)(result);
    uint64_t v14 = 6;
    goto LABEL_16;
  }
  *(_DWORD *)(a2[12] + 8) = 0;
  int v13 = 1;
LABEL_17:
  *(_DWORD *)(a3 + 24) = v13;
  return result;
}

uint64_t Phase::SpatialModeler::DirectPathTransmissionImpl::RunClusterQuery@<X0>(uint64_t (***a1)(void)@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  v54[4] = *MEMORY[0x263EF8340];
  uint64_t v5 = a2[11];
  if (v5 && *(_DWORD *)v5 == 3 && (uint64_t v6 = a2[12]) != 0 && *(_DWORD *)v6 == 2)
  {
    uint64_t v7 = a2[8];
    if (v7)
    {
      uint64_t v8 = *(void *)(v5 + 152);
      if (*(_DWORD *)(v7 + 136) > v8
        && (uint64_t v9 = *(void *)(v7 + 120), *(_DWORD *)(v9 + 24 * v8 + 20) == HIDWORD(v8))
        && (uint64_t v10 = *(_DWORD **)(v9 + 24 * *(void *)(v5 + 152))) != 0
        && *v10 == 2)
      {
        unsigned int v11 = *(Phase::Logger **)(v5 + 144);
        uint64_t v47 = 16;
        float32x4_t v48 = v11;
        int32x4_t v49 = a1 + 5;
        __n128 v50 = &v48;
        long long v51 = &v47;
        float32x4_t v46 = a1 + 5;
        Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::RenderGroup*)#1} const&>(v11, (uint64_t)&v49, (uint64_t *)&v46, (size_t *)&v53);
        uint64_t v12 = v53;
        uint64_t v53 = 0;
        int32x4_t v49 = (uint64_t (***)(void))v12;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v50, (uint64_t)v54);
        long long v52 = v11;
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100](&v53);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v54);
        int v13 = (void *)(v6 + 8);
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(v6 + 8), (uint64_t *)&v49);
        *(void *)(v6 + 48) = v52;
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v49);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&v50);
        uint64_t v14 = *(Phase::Logger **)(v5 + 144);
        uint64_t v47 = 1;
        float32x4_t v48 = v14;
        int32x4_t v49 = a1 + 5;
        __n128 v50 = &v48;
        long long v51 = &v47;
        float32x4_t v46 = a1 + 5;
        Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(v14, (uint64_t)&v49, (uint64_t *)&v46, &v53);
        uint64_t v15 = v53;
        uint64_t v53 = 0;
        int32x4_t v49 = (uint64_t (***)(void))v15;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v50, (uint64_t)v54);
        long long v52 = v14;
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100](&v53);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v54);
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(v6 + 56), (uint64_t *)&v49);
        *(void *)(v6 + 96) = v52;
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v49);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&v50);
        unint64_t v16 = *(Phase::Logger **)(v5 + 144);
        uint64_t v47 = 8;
        float32x4_t v48 = v16;
        int32x4_t v49 = a1 + 5;
        __n128 v50 = &v48;
        long long v51 = &v47;
        float32x4_t v46 = a1 + 5;
        Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::SubmixRoutingOutput*)#1} const&>(v16, (uint64_t)&v49, (uint64_t *)&v46, &v53);
        uint64_t v17 = v53;
        uint64_t v53 = 0;
        int32x4_t v49 = (uint64_t (***)(void))v17;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v50, (uint64_t)v54);
        long long v52 = v16;
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::reset[abi:ne180100](&v53);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v54);
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(v6 + 104), (uint64_t *)&v49);
        *(void *)(v6 + 144) = v52;
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v49);
        uint64_t result = (uint64_t)std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&v50);
        if (!*(void *)(v6 + 144))
        {
          int v44 = 1;
          goto LABEL_20;
        }
        uint64_t v19 = 0;
        uint64_t v20 = 0;
        uint64_t v21 = 0;
        unint64_t v22 = 0;
        uint64_t v23 = *(void *)(v5 + 104);
        while (1)
        {
          int v24 = (unint64_t *)(*(void *)(v6 + 104) + v19);
          *int v24 = v22;
          v24[1] = 0;
          *(_OWORD *)(*v13 + v20) = *(_OWORD *)(v23 + v21);
          uint64_t v25 = *(void *)(v5 + 104) + v21;
          uint64_t v26 = *v13 + v20;
          *(void *)(v26 + 16) = *(void *)(v25 + 144);
          long long v27 = *(_OWORD *)(v25 + 16);
          long long v28 = *(_OWORD *)(v25 + 32);
          long long v29 = *(_OWORD *)(v25 + 64);
          *(_OWORD *)(v26 + 224) = *(_OWORD *)(v25 + 48);
          *(_OWORD *)(v26 + 240) = v29;
          *(_OWORD *)(v26 + 192) = v27;
          *(_OWORD *)(v26 + 208) = v28;
          long long v30 = *(_OWORD *)(v25 + 80);
          long long v31 = *(_OWORD *)(v25 + 96);
          long long v32 = *(_OWORD *)(v25 + 128);
          *(_OWORD *)(v26 + 288) = *(_OWORD *)(v25 + 112);
          *(_OWORD *)(v26 + 304) = v32;
          *(_OWORD *)(v26 + 256) = v30;
          *(_OWORD *)(v26 + 272) = v31;
          float32x4_t v33 = (_OWORD *)(*(void *)(v5 + 104) + v21);
          uint64_t v34 = *v13 + v20;
          long long v35 = v33[16];
          long long v36 = v33[17];
          long long v37 = v33[15];
          *(_OWORD *)(v34 + 120) = v33[14];
          *(_OWORD *)(v34 + 168) = v36;
          *(_OWORD *)(v34 + 152) = v35;
          *(_OWORD *)(v34 + 136) = v37;
          long long v38 = v33[10];
          long long v39 = v33[11];
          long long v40 = v33[12];
          *(_OWORD *)(v34 + 104) = v33[13];
          *(_OWORD *)(v34 + 88) = v40;
          *(_OWORD *)(v34 + 72) = v39;
          *(_OWORD *)(v34 + 56) = v38;
          *(unsigned char *)(*(void *)(v6 + 56) + v22) = 1;
          uint64_t v23 = *(void *)(v5 + 104);
          uint64_t v41 = *(void *)(v23 + v21 + 144);
          if (*(_DWORD *)(v7 + 136) <= v41) {
            break;
          }
          uint64_t v42 = *(void *)(v7 + 120);
          uint64_t result = *(unsigned int *)(v42 + 24 * v41 + 20);
          if (result != HIDWORD(v41)) {
            break;
          }
          int32x4_t v43 = *(_DWORD **)(v42 + 24 * *(void *)(v23 + v21 + 144));
          if (!v43 || *v43 != 3) {
            break;
          }
          ++v22;
          v20 += 336;
          v19 += 16;
          v21 += 304;
          int v44 = 1;
          if (v22 >= *(void *)(v6 + 144)) {
            goto LABEL_20;
          }
        }
        uint64_t result = (**a1)(a1);
        uint64_t v45 = 6;
      }
      else
      {
        uint64_t result = (**a1)(a1);
        uint64_t v45 = 7;
      }
    }
    else
    {
      uint64_t result = (**a1)(a1);
      uint64_t v45 = 5;
    }
  }
  else
  {
    uint64_t result = (**a1)(a1);
    uint64_t v45 = 3;
  }
  *(void *)a3 = v45;
  *(void *)(a3 + 8) = result;
  int v44 = 2;
LABEL_20:
  *(_DWORD *)(a3 + 24) = v44;
  return result;
}

void *Phase::SpatialModeler::DirectPathTransmissionImpl::AllocSpatialQueryState@<X0>(Phase::SpatialModeler::DirectPathTransmissionImpl *this@<X0>, Phase::SpatialModeler::DirectPathTransmission *a2@<X1>, Phase::SpatialModeler::Query *a3@<X2>, void *a4@<X8>)
{
  v25[4] = *MEMORY[0x263EF8340];
  uint64_t v5 = (char *)this + 40;
  uint64_t v6 = (char *)Phase::SystemAllocator::Alloc((Phase::SpatialModeler::DirectPathTransmissionImpl *)((char *)this + 40), (Phase::Logger *)0x1E0, (std::align_val_t)8uLL);
  uint64_t v7 = 0;
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  *(_OWORD *)uint64_t v6 = 0u;
  *((_OWORD *)v6 + 1) = 0u;
  *((_OWORD *)v6 + 2) = 0u;
  *((_OWORD *)v6 + 3) = 0u;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 10) = 0u;
  *((_OWORD *)v6 + 11) = 0u;
  *((_OWORD *)v6 + 12) = 0u;
  *((_OWORD *)v6 + 13) = 0u;
  *((_OWORD *)v6 + 14) = 0u;
  *((_OWORD *)v6 + 15) = 0u;
  *((_OWORD *)v6 + 18) = 0u;
  *((_OWORD *)v6 + 19) = 0u;
  *((_OWORD *)v6 + 20) = 0u;
  *((_OWORD *)v6 + 21) = 0u;
  *((_OWORD *)v6 + 22) = 0u;
  *((_OWORD *)v6 + 23) = 0u;
  *((_OWORD *)v6 + 24) = 0u;
  *((_OWORD *)v6 + 25) = 0u;
  *((_OWORD *)v6 + 26) = 0u;
  *((_OWORD *)v6 + 27) = 0u;
  *((_OWORD *)v6 + 28) = 0u;
  *((_OWORD *)v6 + 29) = 0u;
  *((void *)v6 + 9) = 0xFFFFFFFFLL;
  v6[80] = 0x80;
  *(void *)(v6 + 84) = 0;
  *(void *)(v6 + 100) = 0;
  *(void *)(v6 + 92) = 0;
  *((_DWORD *)v6 + 27) = 0;
  *(_OWORD *)(v6 + 136) = 0u;
  *(_OWORD *)(v6 + 152) = 0u;
  *(_OWORD *)(v6 + 168) = 0u;
  *(_OWORD *)(v6 + 184) = 0u;
  *(_OWORD *)(v6 + 200) = 0u;
  *(_OWORD *)(v6 + 216) = 0u;
  __asm { FMOV            V1.2S, #1.0 }
  *((void *)v6 + 29) = _D1;
  *((void *)v6 + 45) = 0;
  *((void *)v6 + 46) = 0;
  *((_OWORD *)v6 + 15) = 0u;
  *((_OWORD *)v6 + 16) = 0u;
  *((_OWORD *)v6 + 16) = 0u;
  *((_OWORD *)v6 + 17) = 0u;
  *((_DWORD *)v6 + 68) = 0;
  *((void *)v6 + 39) = 0;
  *((void *)v6 + 40) = 0;
  *((void *)v6 + 41) = 0;
  *((_DWORD *)v6 + 94) = -1;
  v6[380] = 1;
  *((_OWORD *)v6 + 24) = 0u;
  *((_OWORD *)v6 + 25) = 0u;
  *((_DWORD *)v6 + 104) = 2139095039;
  uint64_t v15 = v6 + 420;
  uint64_t v23 = 0;
  LODWORD(v24[0]) = 0;
  *(void *)(v6 + 420) = 0;
  *((_DWORD *)v6 + 107) = 0;
  do
  {
    if (v9 <= 2)
    {
      unint64_t v8 = v9 + 1;
      *(_DWORD *)&v15[4 * v9++] = *(_DWORD *)((char *)&v24[-1] + v7);
    }
    v7 += 4;
  }
  while (v7 != 12);
  if (v8 <= 2) {
    bzero(&v15[4 * v8], 12 - 4 * v8);
  }
  uint64_t v16 = 0;
  unint64_t v17 = 0;
  unint64_t v18 = 0;
  *(void *)(v6 + 436) = 0;
  uint64_t v19 = v6 + 436;
  *((_DWORD *)v6 + 108) = 0;
  uint64_t v23 = 0;
  LODWORD(v24[0]) = 0;
  *((_DWORD *)v6 + 111) = 0;
  do
  {
    if (v18 <= 2)
    {
      unint64_t v17 = v18 + 1;
      *(_DWORD *)&v19[4 * v18++] = *(_DWORD *)((char *)&v24[-1] + v16);
    }
    v16 += 4;
  }
  while (v16 != 12);
  if (v17 <= 2) {
    bzero(&v19[4 * v17], 12 - 4 * v17);
  }
  *((void *)v6 + 56) = 0;
  *((void *)v6 + 57) = 0;
  *((_DWORD *)v6 + 118) = 0;
  *((void *)v6 + 58) = 0;
  v25[0] = &unk_26D474818;
  v25[1] = v5;
  v25[3] = v25;
  uint64_t v23 = v6;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v24, (uint64_t)v25);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v25);
  uint64_t v20 = v23;
  v23[23] = Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBegin;
  uint64_t v23 = 0;
  *a4 = v20;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a4 + 1), (uint64_t)v24);
  uint64_t v21 = (uint64_t)v23;
  uint64_t v23 = 0;
  if (v21) {
    std::function<void ()(void *)>::operator()((uint64_t)v24, v21);
  }
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v24);
}

void sub_221EF936C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBegin(Phase::Logger *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, Phase::Logger *a4@<X8>)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  uint64_t Instance = Phase::Logger::GetInstance(a1);
  unint64_t v9 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 208));
  unint64_t v67 = v9;
  uint64_t v10 = (Phase::Logger *)Phase::Logger::GetInstance(v9);
  if (*((unsigned char *)v10 + 216))
  {
    unsigned int v11 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v10)
                                                                                        + 208)));
    uint64_t v12 = v11;
    if ((unint64_t)v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v12, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v9, "Phase_DirectPath_Spatial_Query_Begin", "DirectPathTransmission: Spatial Query Begin", buf, 2u);
    }
  }
  unint64_t v66 = (os_signpost_id_t *)&v67;
  uint64_t v13 = *(void *)(a2 + 88);
  if (!v13 || *(_DWORD *)v13 != 2)
  {
    uint64_t v41 = (**(uint64_t (***)(Phase::Logger *))a1)(a1);
    v64[0] = 3;
    v64[1] = v41;
    int v65 = 2;
    Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBegin(Phase::SpatialModeler::DirectPathTransmission &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState &)::$_1::operator()(a4, &v66, (uint64_t)v64);
    uint64_t v42 = v64;
LABEL_51:
    std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v42);
    return;
  }
  uint64_t v14 = *(void *)(a2 + 64);
  if (!v14)
  {
    uint64_t v44 = (**(uint64_t (***)(Phase::Logger *))a1)(a1);
    v62[0] = 5;
    v62[1] = v44;
    int v63 = 2;
    Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBegin(Phase::SpatialModeler::DirectPathTransmission &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState &)::$_1::operator()(a4, &v66, (uint64_t)v62);
    uint64_t v42 = v62;
    goto LABEL_51;
  }
  uint64_t v15 = *(void *)(v13 + 552);
  unsigned int v16 = *(_DWORD *)(v14 + 136);
  if (v16 <= v15
    || (uint64_t v17 = *(void *)(v14 + 120), *(_DWORD *)(v17 + 24 * v15 + 20) != HIDWORD(v15))
    || (unint64_t v18 = *(_DWORD **)(v17 + 24 * *(void *)(v13 + 552))) == 0
    || *v18 != 2)
  {
    uint64_t v43 = (**(uint64_t (***)(Phase::Logger *))a1)(a1);
    v60[0] = 7;
    v60[1] = v43;
    int v61 = 2;
    Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBegin(Phase::SpatialModeler::DirectPathTransmission &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState &)::$_1::operator()(a4, &v66, (uint64_t)v60);
    uint64_t v42 = v60;
    goto LABEL_51;
  }
  uint64_t v19 = *(void *)(v13 + 208);
  if (v16 <= v19
    || *(_DWORD *)(v17 + 24 * v19 + 20) != HIDWORD(v19)
    || (uint64_t v20 = *(void *)(v17 + 24 * *(void *)(v13 + 208))) == 0
    || *(_DWORD *)v20 != 3)
  {
    uint64_t v45 = (**(uint64_t (***)(Phase::Logger *))a1)(a1);
    v58[0] = 6;
    v58[1] = v45;
    int v59 = 2;
    Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBegin(Phase::SpatialModeler::DirectPathTransmission &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState &)::$_1::operator()(a4, &v66, (uint64_t)v58);
    uint64_t v42 = v58;
    goto LABEL_51;
  }
  unint64_t v22 = *(void **)(v20 + 120);
  uint64_t v21 = *(void **)(v20 + 128);
  if (v22 != v21)
  {
    if (*(_DWORD *)(v14 + 112) <= *v22
      || (uint64_t v23 = *(void *)(v14 + 96), *(_DWORD *)(v23 + 24 * *v22 + 20) != HIDWORD(*v22))
      || !*(void *)(v23 + 24 * *v22))
    {
      uint64_t v46 = (**(uint64_t (***)(Phase::Logger *))a1)(a1);
      v56[0] = 6;
      v56[1] = v46;
      int v57 = 2;
      Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBegin(Phase::SpatialModeler::DirectPathTransmission &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState &)::$_1::operator()(a4, &v66, (uint64_t)v56);
      uint64_t v42 = v56;
      goto LABEL_51;
    }
  }
  uint64_t v24 = 0;
  unint64_t v25 = 0;
  unint64_t v26 = 0;
  *(void *)(a3 + 192) = v19;
  uint64_t v52 = *(void *)(v13 + 552);
  *(void *)(a3 + 200) = v52;
  uint64_t v68 = *(void *)(v13 + 64);
  int v69 = *(_DWORD *)(v13 + 72);
  *(void *)buf = 0;
  LODWORD(v55) = 0;
  do
  {
    if (v26 <= 2)
    {
      unint64_t v25 = v26 + 1;
      *(_DWORD *)&buf[4 * v26++] = *(_DWORD *)((char *)&v68 + v24);
    }
    v24 += 4;
  }
  while (v24 != 12);
  uint64_t v53 = v21;
  if (v25 <= 2)
  {
    bzero(&buf[4 * v25], 12 - 4 * v25);
    uint64_t v21 = v53;
  }
  uint64_t v27 = 0;
  unint64_t v28 = 0;
  unint64_t v29 = 0;
  int v30 = (int)v55;
  *(void *)(a3 + 240) = *(void *)buf;
  *(_DWORD *)(a3 + 248) = v30;
  uint64_t v68 = *(void *)(v13 + 384);
  int v69 = *(_DWORD *)(v13 + 392);
  *(void *)buf = 0;
  LODWORD(v55) = 0;
  do
  {
    if (v29 <= 2)
    {
      unint64_t v28 = v29 + 1;
      *(_DWORD *)&buf[4 * v29++] = *(_DWORD *)((char *)&v68 + v27);
    }
    v27 += 4;
  }
  while (v27 != 12);
  if (v28 <= 2)
  {
    bzero(&buf[4 * v28], 12 - 4 * v28);
    uint64_t v21 = v53;
  }
  uint64_t v31 = 0;
  int v32 = (int)v55;
  *(void *)(a3 + 252) = *(void *)buf;
  *(_DWORD *)(a3 + 260) = v32;
  long long v33 = *(_OWORD *)(v13 + 528);
  *(void *)(a3 + 472) = *(void *)(v13 + 544);
  *(_OWORD *)(a3 + 456) = v33;
  if (v22 == v21) {
    int v34 = 1;
  }
  else {
    int v34 = 10;
  }
  *(_DWORD *)(a3 + 376) = v34;
  do
  {
    switch(*(_DWORD *)(v13 + v31 + 248))
    {
      case 1:
        *(void *)(a3 + 208) = *(void *)(v13 + v31 + 256);
        break;
      case 2:
        *(void *)(a3 + 216) = *(void *)(v13 + v31 + 256);
        break;
      case 3:
        *(void *)(a3 + 224) = *(void *)(v13 + v31 + 256);
        break;
      case 4:
        float v36 = *(double *)(v13 + v31 + 256);
        *(float *)(a3 + 232) = v36;
        break;
      case 5:
        float v35 = *(double *)(v13 + v31 + 256);
        *(float *)(a3 + 236) = v35;
        break;
      default:
        break;
    }
    v31 += 16;
  }
  while (v31 != 128);
  *((_DWORD *)a4 + 6) = 0;
  if (v22 == v21)
  {
    Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBeginPointSource((uint64_t)buf, (uint64_t)a1, a2, v14, (uint64_t)v18, (float *)v20, a3);
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>((uint64_t)a4, (uint64_t)buf);
    long long v40 = (Phase::Logger *)std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
  }
  else
  {
    Phase::SpatialModeler::DirectPathTransmission::GetHistory((uint64_t)a1, v19, v52, *(void *)(a3 + 208), buf);
    uint64_t v38 = *(void *)buf;
    long long v37 = v55;
    if (!*(void *)buf) {
      __assert_rtn("RunSpatialQueryBegin", "DirectPathTransmissionImpl.mm", 381, "nullptr != historyPtr");
    }
    double v39 = COERCE_DOUBLE(atomic_load((unint64_t *)(*(void *)buf + 176)));
    if ((double)std::chrono::steady_clock::now().__d_.__rep_ / 1000000000.0 - v39 >= 0.04)
    {
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v47 = *(std::__shared_weak_count **)(a3 + 176);
      *(void *)(a3 + 168) = v38;
      *(void *)(a3 + 176) = v37;
      if (v47) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v47);
      }
      *(void *)(a3 + 184) = Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryWaitForToken;
      *(void *)buf = v38;
      long long v40 = (Phase::Logger *)std::variant<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>::operator=[abi:ne180100]<Phase::SpatialModeler::ClaimOrWaitOnToken,0,Phase::SpatialModeler::ClaimOrWaitOnToken,4ul,0>((uint64_t)a4, buf);
    }
    else
    {
      Phase::SpatialModeler::DirectPathTransmissionImpl::BuildOutput((uint64_t)buf, (uint64_t (***)(void, __n128))a1, a2, a3, v38);
      std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>((uint64_t)a4, (uint64_t)buf);
      long long v40 = (Phase::Logger *)std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
    }
    if (v37) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v37);
    }
  }
  float32x4_t v48 = (Phase::Logger *)Phase::Logger::GetInstance(v40);
  if (*((unsigned char *)v48 + 216))
  {
    int32x4_t v49 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v48)
                                                                                        + 208)));
    __n128 v50 = v49;
    os_signpost_id_t v51 = (os_signpost_id_t)v67;
    if ((unint64_t)v67 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v49))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v50, OS_SIGNPOST_INTERVAL_END, v51, "Phase_DirectPath_Spatial_Query_Begin", (const char *)&unk_222112ABB, buf, 2u);
    }
  }
}

void sub_221EF9AA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQuery@<X0>(uint64_t (***a1)(void)@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  if (a2)
  {
    uint64_t v4 = *(uint64_t (**)(void))(a2 + 184);
    return v4();
  }
  else
  {
    uint64_t result = (**a1)(a1);
    *(void *)a3 = 1;
    *(void *)(a3 + 8) = result;
    *(_DWORD *)(a3 + 24) = 2;
  }
  return result;
}

uint64_t Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBegin(Phase::SpatialModeler::DirectPathTransmission &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState &)::$_1::operator()(Phase::Logger *a1, os_signpost_id_t **a2, uint64_t a3)
{
  uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(a1);
  if (*((unsigned char *)Instance + 216))
  {
    uint64_t v7 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(Instance)
                                                                                       + 208)));
    unint64_t v8 = v7;
    os_signpost_id_t v9 = **a2;
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
    {
      *(_WORD *)unsigned int v11 = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v8, OS_SIGNPOST_INTERVAL_END, v9, "Phase_DirectPath_Spatial_Query_Begin", (const char *)&unk_222112ABB, v11, 2u);
    }
  }
  return std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)a1, a3);
}

void Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryBeginPointSource(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, float *a6, uint64_t a7)
{
  uint64_t v76 = *MEMORY[0x263EF8340];
  double v14 = (double)std::chrono::steady_clock::now().__d_.__rep_ / 1000000000.0;
  if (v14 - *(double *)(a7 + 456) < 0.04)
  {
    float v15 = *(float *)(a7 + 464);
    float v16 = *(float *)(a7 + 468);
    float v17 = *(float *)(a7 + 472);
    Phase::SpatialModeler::DirectPathTransmissionImpl::BuildOutputPointSource(a1, (uint64_t (***)(void))a2, a3, a7, v15, v16, v17);
    return;
  }
  uint64_t v18 = *(void *)(a3 + 96);
  if (!v18 || *(_DWORD *)v18 != 3)
  {
    uint64_t v42 = (**(uint64_t (***)(uint64_t))a2)(a2);
    *(void *)a1 = 4;
    *(void *)(a1 + 8) = v42;
    *(_DWORD *)(a1 + 24) = 2;
    return;
  }
  *(double *)(v18 + 192) = v14;
  float v19 = *(float *)(a5 + 64);
  float v20 = *(float *)(a5 + 68);
  float v21 = *(float *)(a5 + 72);
  uint64_t v22 = *(void *)(a7 + 208);
  float v23 = Phase::Geometry::CalculateDirectivitySubbandGains<3ul>((Phase::Geometry::SystemState *)a4, a5, (uint64_t)a6, *(void *)(a7 + 216), *(void *)(a7 + 224));
  float v25 = v24;
  float v27 = v26;
  if (v23 <= 0.0) {
    float v23 = COERCE_FLOAT(1);
  }
  v74.f32[0] = (float)((float)(logf(v23) * 8.6859) / 10.0) * 10.0;
  if (v25 <= 0.0) {
    float v28 = COERCE_FLOAT(1);
  }
  else {
    float v28 = v25;
  }
  v74.f32[1] = (float)((float)(logf(v28) * 8.6859) / 10.0) * 10.0;
  if (v27 <= 0.0) {
    float v29 = COERCE_FLOAT(1);
  }
  else {
    float v29 = v27;
  }
  float v30 = logf(v29);
  uint64_t v31 = 0;
  unint64_t v32 = 0;
  unint64_t v33 = 0;
  float v75 = (float)((float)(v30 * 8.6859) / 10.0) * 10.0;
  *(void *)&long long v72 = 0;
  DWORD2(v72) = 0;
  do
  {
    if (v33 <= 2)
    {
      unint64_t v32 = v33 + 1;
      *((_DWORD *)&v72 + v33++) = v74.i32[v31];
    }
    ++v31;
  }
  while (v31 != 3);
  if (v32 <= 2) {
    bzero((char *)&v72 + 4 * v32, 12 - 4 * v32);
  }
  float32x2_t v34 = (float32x2_t)v72;
  float v35 = *((float *)&v72 + 2);
  *(void *)(a7 + 264) = v72;
  *(float *)(a7 + 272) = v35;
  int32x2_t v36 = 0;
  if (*(_DWORD *)(a4 + 40) > v22)
  {
    uint64_t v37 = *(void *)(a4 + 24);
    if (*(_DWORD *)(v37 + 24 * v22 + 20) == HIDWORD(v22))
    {
      uint64_t v38 = *(void *)(v37 + 24 * v22);
      if (v38)
      {
        float v39 = *(double *)(a5 + 152);
        float v40 = fmaxf(v39, sqrtf((float)((float)((float)(v19 - a6[16]) * (float)(v19 - a6[16]))+ (float)((float)(v20 - a6[17]) * (float)(v20 - a6[17])))+ (float)((float)(v21 - a6[18]) * (float)(v21 - a6[18]))));
        if (*(_DWORD *)v38 == 2)
        {
          uint64_t v43 = **(void **)(v38 + 40);
          if (v43)
          {
            float v44 = Phase::Envelope<float>::operator()((float **)(v43 + 16), v40);
            if (v44 <= 0.0) {
              float v44 = COERCE_FLOAT(1);
            }
            *(float *)v36.i32 = (float)((float)(logf(v44) * 8.6859) / 10.0) * 10.0;
            float32x2_t v34 = *(float32x2_t *)(a7 + 264);
            float v35 = *(float *)(a7 + 272);
            goto LABEL_33;
          }
        }
        else
        {
          if (*(_DWORD *)v38 != 1) {
            goto LABEL_33;
          }
          uint64_t v41 = **(void **)(v38 + 40);
          if (v41)
          {
            *(float *)v36.i32 = (float)(log2f(v40) * -6.0206) * *(float *)(v41 + 16);
            goto LABEL_33;
          }
        }
        std::terminate();
      }
    }
  }
LABEL_33:
  uint64_t v45 = 0;
  unint64_t v46 = 0;
  unint64_t v47 = 0;
  *(_DWORD *)(a7 + 384) = v36.i32[0];
  float32x2_t v48 = *(float32x2_t *)(a7 + 240);
  float v49 = *(float *)(a7 + 248);
  float v50 = *(float *)(a7 + 260);
  float32x2_t v74 = vadd_f32(v34, *(float32x2_t *)(a7 + 252));
  float v75 = v35 + v50;
  *(void *)&long long v72 = 0;
  DWORD2(v72) = 0;
  do
  {
    if (v47 <= 2)
    {
      unint64_t v46 = v47 + 1;
      *((_DWORD *)&v72 + v47++) = v74.i32[v45];
    }
    ++v45;
  }
  while (v45 != 3);
  if (v46 <= 2)
  {
    int32x2_t v71 = v36;
    bzero((char *)&v72 + 4 * v46, 12 - 4 * v46);
    int32x2_t v36 = v71;
  }
  uint64_t v51 = 0;
  unint64_t v52 = 0;
  unint64_t v53 = 0;
  float v54 = *((float *)&v72 + 2);
  float32x2_t v55 = (float32x2_t)v72;
  float v56 = a6[16];
  float v57 = a6[17];
  float v58 = a6[18];
  *(float *)(a7 + 388) = v56;
  *(float *)(a7 + 392) = v57;
  *(float *)(a7 + 396) = v58;
  float v59 = v19 - v56;
  float v60 = v20 - v57;
  float v61 = v21 - v58;
  float v62 = sqrtf((float)((float)(v59 * v59) + (float)(v60 * v60)) + (float)(v61 * v61));
  *(float *)(a7 + 404) = v59 / v62;
  *(float *)(a7 + 408) = v60 / v62;
  *(float *)(a7 + 412) = v61 / v62;
  *(_DWORD *)(a7 + 400) = 0;
  *(float *)(a7 + 416) = v62;
  float32x2_t v74 = vadd_f32((float32x2_t)vdup_lane_s32(v36, 0), v55);
  float v75 = *(float *)v36.i32 + v54;
  *(void *)&long long v72 = 0;
  DWORD2(v72) = 0;
  do
  {
    if (v53 <= 2)
    {
      unint64_t v52 = v53 + 1;
      *((_DWORD *)&v72 + v53++) = v74.i32[v51];
    }
    ++v51;
  }
  while (v51 != 3);
  if (v52 <= 2) {
    bzero((char *)&v72 + 4 * v52, 12 - 4 * v52);
  }
  uint64_t v63 = 0;
  unint64_t v64 = 0;
  unint64_t v65 = 0;
  float32x2_t v74 = vsub_f32(*(float32x2_t *)&v72, v48);
  float v75 = *((float *)&v72 + 2) - v49;
  *(void *)&long long v72 = 0;
  DWORD2(v72) = 0;
  do
  {
    if (v65 <= 2)
    {
      unint64_t v64 = v65 + 1;
      *((_DWORD *)&v72 + v65++) = v74.i32[v63];
    }
    ++v63;
  }
  while (v63 != 3);
  if (v64 <= 2) {
    bzero((char *)&v72 + 4 * v64, 12 - 4 * v64);
  }
  uint64_t v66 = 0;
  unint64_t v67 = 0;
  unint64_t v68 = 0;
  float32x2_t v74 = vmaxnm_f32(*(float32x2_t *)&v72, 0);
  float v75 = fmaxf(*((float *)&v72 + 2), 0.0);
  *(void *)&long long v72 = 0;
  DWORD2(v72) = 0;
  do
  {
    if (v68 <= 2)
    {
      unint64_t v67 = v68 + 1;
      *((_DWORD *)&v72 + v68++) = v74.i32[v66];
    }
    ++v66;
  }
  while (v66 != 3);
  if (v67 <= 2) {
    bzero((char *)&v72 + 4 * v67, 12 - 4 * v67);
  }
  int v69 = DWORD2(v72);
  *(void *)(a7 + 420) = v72;
  *(_DWORD *)(a7 + 428) = v69;
  *(_DWORD *)(a7 + 432) = 1;
  *(_DWORD *)(a7 + 64) = *(_DWORD *)(a2 + 44);
  *(void *)(a7 + 88) = a7 + 388;
  *(void *)(a7 + 96) = 0x4400000001;
  *(void *)(a7 + 184) = Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryHandleResultsPointSource;
  *(void *)(a7 + 72) = *(void *)(a2 + 24);
  uint64_t v70 = operator new(8uLL);
  void *v70 = a7;
  uint64_t v73 = 0;
  long long v72 = 0uLL;
  std::vector<Phase::Geometry::SceneQueryBatch *>::__init_with_size[abi:ne180100]<Phase::Geometry::SceneQueryBatch **,Phase::Geometry::SceneQueryBatch **>(&v72, v70, (uint64_t)(v70 + 1), 1uLL);
  *(_OWORD *)a1 = v72;
  *(void *)(a1 + 16) = v73;
  uint64_t v73 = 0;
  long long v72 = 0uLL;
  *(_DWORD *)(a1 + 24) = 3;
  operator delete(v70);
}

void sub_221EFA300(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryWaitForToken(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v156 = *MEMORY[0x263EF8340];
  uint64_t Instance = Phase::Logger::GetInstance((Phase::Logger *)a1);
  os_signpost_id_t v9 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 208));
  uint64_t v10 = (Phase::Logger *)Phase::Logger::GetInstance(v9);
  if (*((unsigned char *)v10 + 216))
  {
    unsigned int v11 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v10)
                                                                                        + 208)));
    uint64_t v12 = v11;
    if ((unint64_t)v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v12, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v9, "Phase_DirectPath_Spatial_Query_Token_Wait", "DirectPathTransmission: Spatial Query Wait For Token", buf, 2u);
    }
  }
  *(_DWORD *)(a4 + 24) = 0;
  uint64_t v13 = *(void *)(a3 + 168);
  unsigned int v14 = atomic_load((unsigned int *)(a2 + 104));
  if (v14 != *(_DWORD *)(v13 + 64))
  {
    Phase::SpatialModeler::DirectPathTransmissionImpl::BuildOutput((uint64_t)buf, (uint64_t (***)(void, __n128))a1, a2, a3, *(void *)(a3 + 168));
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>(a4, (uint64_t)buf);
    float v28 = buf;
    goto LABEL_131;
  }
  HIDWORD(v133) = 0;
  int v134 = 0;
  *(void *)&long long v133 = 0;
  __int16 v135 = 257;
  uint64_t v136 = 0;
  v150[3] = 0;
  v150[4] = 0;
  uint64_t v148 = 0;
  uint64_t v149 = 0;
  uint64_t v146 = 0;
  *(void *)buf = 0;
  *(_DWORD *)(a3 + 376) = 10;
  WORD4(v133) = 257;
  uint64_t v15 = *(void *)(a1 + 16);
  if (!*(void *)(v15 + 2760)) {
    goto LABEL_20;
  }
  uint64_t v16 = Phase::Geometry::SystemDebugger::GetFromSystem(v15);
  if (!v16) {
    goto LABEL_20;
  }
  float v19 = *(void **)(v16 + 24);
  uint64_t v17 = v16 + 24;
  uint64_t v18 = v19;
  if (!v19) {
    goto LABEL_20;
  }
  unint64_t v20 = *(void *)(a3 + 192);
  float v21 = (void *)v17;
  do
  {
    unint64_t v22 = v18[4];
    BOOL v23 = v22 >= v20;
    if (v22 >= v20) {
      float v24 = v18;
    }
    else {
      float v24 = v18 + 1;
    }
    if (v23) {
      float v21 = v18;
    }
    uint64_t v18 = (void *)*v24;
  }
  while (*v24);
  if (v21 != (void *)v17 && v21[4] <= v20)
  {
    int v42 = *((_DWORD *)v21 + 11);
    LODWORD(v133) = *((_DWORD *)v21 + 10);
    BYTE8(v133) = *((unsigned char *)v21 + 52);
    LODWORD(v26) = *((_DWORD *)v21 + 12);
    if (v42 >= 1) {
      *(_DWORD *)(a3 + 376) = v42;
    }
    if (v21[14])
    {
      std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::operator=(v145, (uint64_t)(v21 + 11));
      float v25 = &v149;
    }
    else
    {
      float v25 = 0;
    }
  }
  else
  {
LABEL_20:
    float v25 = 0;
    LODWORD(v26) = -1;
  }
  uint64_t v136 = v13 + 184;
  if (BYTE8(v133)) {
    BOOL v27 = BYTE9(v133) == 0;
  }
  else {
    BOOL v27 = 1;
  }
  if (v27)
  {
    *(unsigned char *)(a3 + 380) = 0;
  }
  else
  {
    unint64_t v29 = *(unsigned int *)(a3 + 376);
    if ((int)v29 < 2)
    {
      BYTE9(v133) = 0;
    }
    else
    {
      HIDWORD(v133) = *(_DWORD *)(a3 + 376);
      if ((v26 & 0x80000000) != 0)
      {
        unint64_t v30 = *(void *)(v13 + 160);
        if (v30 != v29)
        {
          uint64_t v31 = (float **)(v13 + 112);
          float v32 = (float)v29;
          if (v30 >= v29) {
            unint64_t v33 = v29;
          }
          else {
            unint64_t v33 = *(void *)(v13 + 160);
          }
          v129 = (uint64_t *)(v13 + 112);
          if (!v33) {
            goto LABEL_47;
          }
          float32x2_t v34 = *v31;
          float v35 = 0.0;
          int32x2_t v36 = *v31;
          unint64_t v37 = v33;
          do
          {
            float v38 = *v36++;
            float v35 = v35 + v38;
            --v37;
          }
          while (v37);
          if (v35 > 0.0)
          {
            float v39 = (float)((float)v30 / v32) / v35;
            unint64_t v40 = v33;
            do
            {
              *float32x2_t v34 = v39 * *v34;
              ++v34;
              --v40;
            }
            while (v40);
            unint64_t v41 = v33;
          }
          else
          {
LABEL_47:
            unint64_t v41 = 0;
          }
          if (*(void *)(v13 + 152) < v29)
          {
            unint64_t v128 = v41;
            float32x2_t v151 = (float32x2_t)v29;
            v138[0] = 4;
            *(void *)&long long v153 = &v151;
            *((void *)&v153 + 1) = v138;
            Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>(v29, (uint64_t)&v153, &v141);
            uint64_t v43 = v141;
            uint64_t v141 = 0;
            *(void *)&long long v153 = v43;
            std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v153 + 8, (uint64_t)v142);
            uint64_t v155 = v29;
            std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v141);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v142);
            uint64_t v44 = *v129;
            if (v33)
            {
              uint64_t v45 = (_DWORD *)v153;
              unint64_t v46 = (int *)*v129;
              do
              {
                int v47 = *v46++;
                *v45++ = v47;
                --v33;
              }
              while (v33);
            }
            *(void *)(v13 + 112) = 0;
            uint64_t v141 = v44;
            std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v142, v13 + 120);
            uint64_t v143 = *(void *)(v13 + 152);
            std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](v129, (uint64_t *)&v153);
            *(void *)(v13 + 152) = v155;
            std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v153, &v141);
            uint64_t v155 = v143;
            std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v141);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v142);
            std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v153);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)&v153 + 1);
            unint64_t v41 = v128;
          }
          unint64_t v48 = v29 - v41;
          if (v29 > v41)
          {
            float v49 = (float *)(*v129 + 4 * v41);
            do
            {
              *v49++ = 1.0 / v32;
              --v48;
            }
            while (v48);
          }
          *(void *)(v13 + 160) = v29;
        }
        uint64_t v26 = 0;
        unint64_t v50 = *(void *)(v13 + 192);
        unint64_t v51 = *(void *)(v13 + 184) ^ (*(void *)(v13 + 184) << 23);
        unint64_t v52 = (v50 >> 26) ^ (v51 >> 17) ^ v50 ^ v51;
        float v53 = *(float *)(v13 + 208);
        float v54 = *(float *)(v13 + 212) - v53;
        *(void *)(v13 + 184) = v50;
        *(void *)(v13 + 192) = v52;
        float v55 = v53 + (float)(v54 * (float)((float)(v52 + v50) * 5.421e-20));
        float v56 = *(float **)(v13 + 112);
        float v57 = 0.0;
        while (1)
        {
          float v57 = v57 + v56[v26];
          if (v55 < v57) {
            break;
          }
          if (v29 == ++v26)
          {
            unint64_t v58 = v29 - 1;
            LODWORD(v26) = v29 - 1;
            goto LABEL_62;
          }
        }
        unint64_t v58 = v29 - 1;
LABEL_62:
        *(void *)(v13 + 168) = (int)v26;
        float v59 = 9.0 / (float)v58;
        uint64_t v60 = (int)v26;
        float v61 = v56;
        do
        {
          if (v60) {
            float v62 = v59 + *v61;
          }
          else {
            float v62 = v56[(int)v26];
          }
          *v61++ = v62 * 0.1;
          --v60;
          --v29;
        }
        while (v29);
        int v134 = v26;
        LODWORD(v29) = HIDWORD(v133);
      }
      else
      {
        int v134 = v26;
        *(unsigned char *)(a3 + 380) = 0;
      }
      if ((int)v26 >= (int)v29) {
        int v134 = v29 - 1;
      }
    }
  }
  uint64_t v63 = *(void *)(a2 + 64);
  if (v63)
  {
    uint64_t v64 = *(void *)(a3 + 200);
    unsigned int v65 = *(_DWORD *)(v63 + 136);
    if (v65 > v64
      && (uint64_t v66 = *(void *)(v63 + 120), *(_DWORD *)(v66 + 24 * v64 + 20) == HIDWORD(v64))
      && (unint64_t v67 = *(float32x2_t **)(v66 + 24 * *(void *)(a3 + 200))) != 0
      && v67->i32[0] == 2)
    {
      uint64_t v68 = *(void *)(a3 + 192);
      if (v65 > v68 && *(_DWORD *)(v66 + 24 * v68 + 20) == HIDWORD(v68))
      {
        int v69 = *(float32x2_t **)(v66 + 24 * *(void *)(a3 + 192));
        if (v69)
        {
          if (v69->i32[0] == 3)
          {
            Phase::Geometry::GenerateSourcePoints(v63, (uint64_t)v69, v67, &v133, v25, (uint64_t)&v141);
            unint64_t v70 = v143;
            if (v143)
            {
              if (!v144) {
                *(_DWORD *)(a3 + 376) = 1;
              }
              float32x2_t v71 = v67[8];
              float v72 = v67[9].f32[0];
              uint64_t v73 = *(void *)(a3 + 208);
              float v74 = Phase::Geometry::CalculateDirectivitySubbandGains<3ul>((Phase::Geometry::SystemState *)v63, (uint64_t)v67, (uint64_t)v69, *(void *)(a3 + 216), *(void *)(a3 + 224));
              float v76 = v75;
              float v78 = v77;
              if (v74 <= 0.0) {
                float v74 = COERCE_FLOAT(1);
              }
              v151.f32[0] = (float)((float)(logf(v74) * 8.6859) / 10.0) * 10.0;
              if (v76 <= 0.0) {
                float v79 = COERCE_FLOAT(1);
              }
              else {
                float v79 = v76;
              }
              v151.f32[1] = (float)((float)(logf(v79) * 8.6859) / 10.0) * 10.0;
              if (v78 <= 0.0) {
                float v80 = COERCE_FLOAT(1);
              }
              else {
                float v80 = v78;
              }
              float v81 = logf(v80);
              uint64_t v82 = 0;
              unint64_t v83 = 0;
              unint64_t v84 = 0;
              *(float *)v152 = (float)((float)(v81 * 8.6859) / 10.0) * 10.0;
              *(void *)&long long v153 = 0;
              DWORD2(v153) = 0;
              do
              {
                if (v84 <= 2)
                {
                  unint64_t v83 = v84 + 1;
                  *((_DWORD *)&v153 + v84++) = v151.i32[v82];
                }
                ++v82;
              }
              while (v82 != 3);
              if (v83 <= 2) {
                bzero((char *)&v153 + 4 * v83, 12 - 4 * v83);
              }
              int v85 = DWORD2(v153);
              *(void *)(a3 + 264) = v153;
              *(_DWORD *)(a3 + 272) = v85;
              Phase::Geometry::CalculateDistanceGainsInDecibels<Phase::SystemAllocator>((uint64_t)&v153, a1 + 40, v63, (uint64_t)v67, (uint64_t)v69, &v141, v73);
              std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a3 + 328), (uint64_t *)&v153);
              *(void *)(a3 + 368) = v155;
              std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v153);
              std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)&v153 + 1);
              uint64_t v86 = 0;
              unint64_t v87 = 0;
              unint64_t v88 = 0;
              float32x2_t v89 = *(float32x2_t *)(a3 + 240);
              float v90 = *(float *)(a3 + 248);
              float v91 = *(float *)(a3 + 260);
              float32x2_t v151 = vadd_f32(*(float32x2_t *)(a3 + 252), *(float32x2_t *)(a3 + 264));
              *(float *)v152 = v91 + *(float *)(a3 + 272);
              *(void *)&long long v153 = 0;
              DWORD2(v153) = 0;
              do
              {
                if (v88 <= 2)
                {
                  unint64_t v87 = v88 + 1;
                  *((_DWORD *)&v153 + v88++) = v151.i32[v86];
                }
                ++v86;
              }
              while (v86 != 3);
              if (v87 <= 2) {
                bzero((char *)&v153 + 4 * v87, 12 - 4 * v87);
              }
              float32x2_t v92 = (float32x2_t)v153;
              float v93 = *((float *)&v153 + 2);
              uint64_t v94 = v143;
              uint64_t v139 = 4;
              uint64_t v140 = v143;
              v138[0] = a1 + 40;
              v138[1] = &v140;
              v138[2] = &v139;
              uint64_t v137 = a1 + 40;
              Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>((Phase::Logger *)&v151, v143, (uint64_t)v138, &v137);
              float32x2_t v95 = v151;
              float32x2_t v151 = 0;
              *(float32x2_t *)&long long v153 = v95;
              std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v153 + 8, (uint64_t)v152);
              uint64_t v155 = v94;
              std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v151);
              std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v152);
              std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a3 + 104), (uint64_t *)&v153);
              *(void *)(a3 + 144) = v155;
              std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v153);
              std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)&v153 + 1);
              uint64_t v96 = 0;
              uint64_t v97 = v70;
              if (v70 <= 1) {
                uint64_t v97 = 1;
              }
              uint64_t v127 = v97;
              do
              {
                Phase::operator*<float>((float *)&v69[6], (float *)(v141 + 12 * v96), (float *)&v153);
                uint64_t v98 = 0;
                unint64_t v99 = 0;
                unint64_t v100 = 0;
                float v101 = v69[9].f32[1];
                float v102 = (float)(v101 * *((float *)&v153 + 2)) + v69[9].f32[0];
                float32x2_t v103 = vadd_f32(vmul_n_f32(*(float32x2_t *)&v153, v101), v69[8]);
                uint64_t v104 = *(void *)(a3 + 104) + 68 * v96;
                *(float32x2_t *)uint64_t v104 = v103;
                float v105 = v72 - v102;
                float32x2_t v106 = vsub_f32(v71, v103);
                *(float *)v107.i32 = sqrtf(vaddv_f32(vmul_f32(v106, v106)) + (float)(v105 * v105));
                *(float *)(v104 + 8) = v102;
                int32x2_t v108 = (int32x2_t)vdiv_f32(v106, (float32x2_t)vdup_lane_s32(v107, 0));
                *(int32x2_t *)(v104 + 16) = v108;
                *(_DWORD *)(v104 + 12) = 0;
                *(float *)(v104 + 24) = v105 / *(float *)v107.i32;
                *(_DWORD *)(v104 + 28) = v107.i32[0];
                v108.i32[0] = *(_DWORD *)(*(void *)(a3 + 328) + 4 * v96);
                float32x2_t v151 = vadd_f32(v92, (float32x2_t)vdup_lane_s32(v108, 0));
                *(float *)v152 = v93 + *(float *)v108.i32;
                *(void *)&long long v153 = 0;
                DWORD2(v153) = 0;
                do
                {
                  if (v100 <= 2)
                  {
                    unint64_t v99 = v100 + 1;
                    *((_DWORD *)&v153 + v100++) = v151.i32[v98];
                  }
                  ++v98;
                }
                while (v98 != 3);
                if (v99 <= 2) {
                  bzero((char *)&v153 + 4 * v99, 12 - 4 * v99);
                }
                uint64_t v109 = 0;
                unint64_t v110 = 0;
                unint64_t v111 = 0;
                float32x2_t v151 = vsub_f32(*(float32x2_t *)&v153, v89);
                *(float *)v152 = *((float *)&v153 + 2) - v90;
                *(void *)&long long v153 = 0;
                DWORD2(v153) = 0;
                do
                {
                  if (v111 <= 2)
                  {
                    unint64_t v110 = v111 + 1;
                    *((_DWORD *)&v153 + v111++) = v151.i32[v109];
                  }
                  ++v109;
                }
                while (v109 != 3);
                if (v110 <= 2) {
                  bzero((char *)&v153 + 4 * v110, 12 - 4 * v110);
                }
                uint64_t v112 = 0;
                unint64_t v113 = 0;
                unint64_t v114 = 0;
                float32x2_t v151 = vmaxnm_f32(*(float32x2_t *)&v153, 0);
                LODWORD(v152[0]) = fmaxf(*((float *)&v153 + 2), 0.0);
                *(void *)&long long v153 = 0;
                DWORD2(v153) = 0;
                do
                {
                  if (v114 <= 2)
                  {
                    unint64_t v113 = v114 + 1;
                    *((_DWORD *)&v153 + v114++) = v151.i32[v112];
                  }
                  ++v112;
                }
                while (v112 != 3);
                if (v113 <= 2) {
                  bzero((char *)&v153 + 4 * v113, 12 - 4 * v113);
                }
                int v115 = DWORD2(v153);
                *(void *)(v104 + 32) = v153;
                *(_DWORD *)(v104 + 40) = v115;
                *(_DWORD *)(v104 + 44) = 1;
                ++v96;
              }
              while (v96 != v127);
              uint64_t v116 = *(void *)(a3 + 104);
              int v117 = v143;
              *(_DWORD *)(a3 + 64) = *(_DWORD *)(a1 + 44);
              *(void *)(a3 + 88) = v116;
              *(_DWORD *)(a3 + 96) = v117;
              *(_DWORD *)(a3 + 100) = 68;
              *(void *)(a3 + 184) = Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryHandleResults;
              uint64_t v118 = *(void *)(a3 + 280);
              *(void *)(a3 + 280) = 0;
              *(void *)&long long v153 = v118;
              std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v153 + 8, a3 + 288);
              uint64_t v155 = *(void *)(a3 + 320);
              std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a3 + 280), &v141);
              *(void *)(a3 + 320) = v143;
              std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](&v141, (uint64_t *)&v153);
              uint64_t v143 = v155;
              std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v153);
              std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)&v153 + 1);
              if (v146)
              {
                *(void *)buf = *(void *)(a3 + 192);
                uint64_t v148 = 0;
                *(void *)&long long v153 = buf;
                (*(void (**)(uint64_t, long long *))(*(void *)v146 + 48))(v146, &v153);
              }
              *(void *)(a3 + 72) = *(void *)(a1 + 24);
              v119 = operator new(8uLL);
              void *v119 = a3;
              uint64_t v154 = 0;
              long long v153 = 0uLL;
              std::vector<Phase::Geometry::SceneQueryBatch *>::__init_with_size[abi:ne180100]<Phase::Geometry::SceneQueryBatch **,Phase::Geometry::SceneQueryBatch **>(&v153, v119, (uint64_t)(v119 + 1), 1uLL);
              long long v130 = v153;
              uint64_t v131 = v154;
              uint64_t v154 = 0;
              long long v153 = 0uLL;
              int v132 = 3;
              operator delete(v119);
            }
            else
            {
              uint64_t v126 = (**(uint64_t (***)(uint64_t))a1)(a1);
              *(void *)&long long v130 = 128;
              *((void *)&v130 + 1) = v126;
              int v132 = 2;
            }
            std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v141);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v142);
            goto LABEL_130;
          }
        }
      }
      uint64_t v120 = (**(uint64_t (***)(uint64_t))a1)(a1);
      uint64_t v121 = 6;
    }
    else
    {
      uint64_t v120 = (**(uint64_t (***)(uint64_t))a1)(a1);
      uint64_t v121 = 7;
    }
  }
  else
  {
    uint64_t v120 = (**(uint64_t (***)(uint64_t))a1)(a1);
    uint64_t v121 = 5;
  }
  *(void *)&long long v130 = v121;
  *((void *)&v130 + 1) = v120;
  int v132 = 2;
LABEL_130:
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](v145);
  std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v149);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v150);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>(a4, (uint64_t)&v130);
  float v28 = (uint8_t *)&v130;
LABEL_131:
  v122 = (Phase::Logger *)std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v28);
  *(void *)(a3 + 72) = *(void *)(a1 + 24);
  v123 = (Phase::Logger *)Phase::Logger::GetInstance(v122);
  if (*((unsigned char *)v123 + 216))
  {
    v124 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v123)
                                                                                         + 208)));
    v125 = v124;
    if ((unint64_t)v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v124))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v125, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v9, "Phase_DirectPath_Spatial_Query_Token_Wait", (const char *)&unk_222112ABB, buf, 2u);
    }
  }
}

void sub_221EFB050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&a28);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&a29);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](&a35);
  std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>>::reset[abi:ne180100](&a41);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&a42);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor(v42);
  _Unwind_Resume(a1);
}

uint64_t std::variant<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>::operator=[abi:ne180100]<Phase::SpatialModeler::ClaimOrWaitOnToken,0,Phase::SpatialModeler::ClaimOrWaitOnToken,4ul,0>(uint64_t a1, void *a2)
{
  if (*(_DWORD *)(a1 + 24) == 4) {
    *(void *)a1 = *a2;
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<4ul,Phase::SpatialModeler::ClaimOrWaitOnToken>(a1, a2);
  }
  return a1;
}

void Phase::SpatialModeler::DirectPathTransmissionImpl::BuildOutput(uint64_t a1, uint64_t (***a2)(void, __n128), uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v138 = *MEMORY[0x263EF8340];
  std::atomic_load[abi:ne180100]<Phase::SpatialModeler::DirectPathTransmission::SourceData>(&v101, (void *)(a5 + 96));
  os_signpost_id_t v9 = v101;
  uint64_t v10 = v101[5];
  if (v10)
  {
    unsigned int v11 = 0;
    uint64_t v12 = (uint64_t *)(*v101 + 40);
    do
    {
      uint64_t v13 = *v12;
      v12 += 19;
      unsigned int v11 = (Phase::Logger *)((char *)v11 + v13);
      --v10;
    }
    while (v10);
    if (v11)
    {
      uint64_t v14 = *(void *)(a3 + 64);
      if (v14)
      {
        uint64_t v15 = *(void *)(a4 + 192);
        unsigned int v16 = *(_DWORD *)(v14 + 136);
        if (v16 > v15
          && (uint64_t v17 = *(void *)(v14 + 120), *(_DWORD *)(v17 + 24 * v15 + 20) == HIDWORD(v15))
          && (uint64_t v18 = *(void *)(v17 + 24 * *(void *)(a4 + 192))) != 0
          && *(_DWORD *)v18 == 3)
        {
          uint64_t v19 = *(void *)(a4 + 200);
          if (v16 > v19
            && *(_DWORD *)(v17 + 24 * v19 + 20) == HIDWORD(v19)
            && (uint64_t v20 = *(void *)(v17 + 24 * *(void *)(a4 + 200))) != 0
            && *(_DWORD *)v20 == 2)
          {
            long long v21 = *(_OWORD *)(v18 + 64);
            long long v99 = *(_OWORD *)(v18 + 48);
            long long v100 = v21;
            long long v23 = *(_OWORD *)(v20 + 48);
            long long v24 = *(_OWORD *)(v20 + 64);
            unint64_t v22 = (float *)(v20 + 48);
            long long v97 = v23;
            long long v98 = v24;
            Phase::Inverse<float>((float32x2_t *)&v97, (uint64_t)buf);
            v25.n128_f32[0] = Phase::operator*<float>((float32x2_t *)buf, (float *)&v99, (uint64_t)v92);
            uint64_t v26 = *(uint64_t **)(a3 + 96);
            if (v26 && *(_DWORD *)v26 == 3)
            {
              Phase::SpatialModeler::AllocMetadata<float,Phase::SystemAllocator>(v26, (uint64_t)(a2 + 5), v11, 3);
              uint64_t v81 = a4;
              uint64_t v82 = a1;
              int v85 = v26;
              float v80 = v22;
              float v27 = 1.0 / (float)(unint64_t)v11;
              if (v27 <= 0.0) {
                float v27 = COERCE_FLOAT(1);
              }
              *(float *)v29.i32 = logf(v27);
              unint64_t v30 = v9[5];
              if (v30)
              {
                unint64_t v31 = 0;
                unint64_t v32 = 0;
                *(float *)v29.i32 = (float)((float)(*(float *)v29.i32 * 8.6859) / 10.0) * 10.0;
                float v84 = *(float *)v29.i32;
                float32x2_t v33 = (float32x2_t)vdup_lane_s32(v29, 0);
                float32x2_t v34 = (float32x2_t)vdup_n_s32(0x3DEBC8E3u);
                __asm { FMOV            V11.2S, #10.0 }
                do
                {
                  float v91 = (void *)(*v9 + 152 * v31);
                  if (v91[5])
                  {
                    unint64_t v40 = 0;
                    unint64_t v83 = v31;
                    unint64_t v41 = (char *)v11 - v32;
                    if ((unint64_t)v11 < v32) {
                      unint64_t v41 = 0;
                    }
                    uint64_t v86 = (void *)(*v9 + 152 * v31 + 48);
                    unint64_t v87 = v41;
                    do
                    {
                      if (v40 == v87) {
                        __assert_rtn("BuildOutput", "DirectPathTransmissionImpl.mm", 728, "outputIndex < totalPointCount");
                      }
                      uint64_t v42 = v85[1];
                      uint64_t v43 = v85[7];
                      uint64_t v44 = v85[13];
                      uint64_t v45 = *(void *)(v44 + 8);
                      uint64_t v90 = v85[18];
                      Phase::operator*<float>(v92, (float *)(*v91 + 12 * (void)v40), (float *)buf);
                      float v46 = (float)(v96 * *(float *)buf) + v93;
                      float v47 = (float)(v96 * *(float *)&buf[4]) + v94;
                      float v48 = (float)(v96 * *(float *)&buf[8]) + v95;
                      float v49 = -v46;
                      if (v46 >= 0.0) {
                        float v49 = (float)(v96 * *(float *)buf) + v93;
                      }
                      if (v49 > 0.00000011921) {
                        goto LABEL_35;
                      }
                      float v50 = -v47;
                      if (v47 >= 0.0) {
                        float v50 = (float)(v96 * *(float *)&buf[4]) + v94;
                      }
                      if (v50 > 0.00000011921) {
                        goto LABEL_35;
                      }
                      float v51 = -v48;
                      if (v48 >= 0.0) {
                        float v51 = (float)(v96 * *(float *)&buf[8]) + v95;
                      }
                      float v52 = 0.0;
                      BOOL v53 = v51 > 0.00000011921;
                      float v54 = 0.0;
                      if (v53)
                      {
LABEL_35:
                        float v52 = acosf(v47 / sqrtf((float)((float)(v46 * v46) + (float)(v47 * v47)) + (float)(v48 * v48)));
                        float v54 = atan2f(v46, v48);
                      }
                      unint64_t v55 = v42 + 12 * v32;
                      *(_DWORD *)unint64_t v55 = 1065353216;
                      *(float *)(v55 + 4) = v52 * 57.296;
                      float v56 = (float)((float)(180.0 - (float)(v54 * 57.296))
                                  - (float)(floorf((float)(180.0 - (float)(v54 * 57.296)) / 360.0) * 360.0))
                          + 0.0;
                      if (v56 >= 360.0) {
                        float v56 = nextafterf(360.0, 0.0);
                      }
                      uint64_t v57 = 0;
                      unint64_t v58 = 0;
                      unint64_t v59 = 0;
                      *(float *)(v55 + 8) = v56;
                      *(_DWORD *)(v43 + 4 * v32) = 0;
                      uint64_t v60 = (float32x2_t *)(*v86 + 12 * (void)v40);
                      float32x2_t v136 = vadd_f32(v33, *v60);
                      float v61 = (Phase::Logger *)(v32 + 1);
                      float v137 = v84 + v60[1].f32[0];
                      memset(buf, 0, sizeof(buf));
                      do
                      {
                        if (v59 <= 2)
                        {
                          unint64_t v58 = v59 + 1;
                          *(_DWORD *)&buf[4 * v59++] = v136.i32[v57];
                        }
                        ++v57;
                      }
                      while (v57 != 3);
                      if (v58 <= 2) {
                        bzero(&buf[4 * v58], 12 - 4 * v58);
                      }
                      float v62 = *(float *)&buf[8];
                      float32x2_t v63 = vmul_f32(vdiv_f32(vmul_f32(*(float32x2_t *)buf, _D11), _D11), v34);
                      float v88 = v63.f32[0];
                      float v89 = expf(v63.f32[1]);
                      v64.f32[0] = expf(v88);
                      v64.f32[1] = v89;
                      float32x2_t v136 = v64;
                      float v65 = expf((float)((float)(v62 * 10.0) / 10.0) * 0.11513);
                      uint64_t v66 = 0;
                      unint64_t v67 = 0;
                      unint64_t v68 = 0;
                      float v137 = v65;
                      memset(buf, 0, sizeof(buf));
                      do
                      {
                        if (v68 <= 2)
                        {
                          unint64_t v67 = v68 + 1;
                          *(_DWORD *)&buf[4 * v68++] = v136.i32[v66];
                        }
                        ++v66;
                      }
                      while (v66 != 3);
                      if (v67 <= 2) {
                        bzero(&buf[4 * v67], 12 - 4 * v67);
                      }
                      int v69 = *(_DWORD *)&buf[8];
                      *(void *)(v44 + 4 * v45 * v32 + 16) = *(void *)buf;
                      *(_DWORD *)(v44 + 4 * v45 * v32 + 24) = v69;
                      *(unsigned char *)(v90 + v32) = 0;
                      ++v40;
                      ++v32;
                    }
                    while (v91[5] > (unint64_t)v40);
                    unint64_t v30 = v9[5];
                    unint64_t v32 = (unint64_t)v61;
                    unint64_t v31 = v83;
                  }
                  else
                  {
                    float v61 = (Phase::Logger *)v32;
                  }
                  ++v31;
                }
                while (v30 > v31);
              }
              else
              {
                float v61 = 0;
              }
              uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(v28);
              a1 = v82;
              if (*((unsigned char *)Instance + 216))
              {
                float v74 = (Phase::Logger *)**(id **)(Phase::Logger::GetInstance(Instance) + 208);
                uint64_t v75 = Phase::Logger::GetInstance(v74);
                os_signpost_id_t v76 = os_signpost_id_generate(**(os_log_t **)(v75 + 208));
                if (v76 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
                {
                  os_signpost_id_t v77 = v76;
                  if (os_signpost_enabled((os_log_t)v74))
                  {
                    uint64_t v79 = *(void *)(v81 + 192);
                    uint64_t v78 = *(void *)(v81 + 200);
                    *(_DWORD *)buf = 134222080;
                    *(void *)&uint8_t buf[4] = v85;
                    __int16 v104 = 2048;
                    uint64_t v105 = v78;
                    __int16 v106 = 2048;
                    double v107 = *(float *)&v97;
                    __int16 v108 = 2048;
                    double v109 = *((float *)&v97 + 1);
                    __int16 v110 = 2048;
                    double v111 = *((float *)&v97 + 2);
                    __int16 v112 = 2048;
                    double v113 = *((float *)&v97 + 3);
                    __int16 v114 = 2048;
                    double v115 = *(float *)&v98;
                    __int16 v116 = 2048;
                    double v117 = *((float *)&v98 + 1);
                    __int16 v118 = 2048;
                    double v119 = *((float *)&v98 + 2);
                    __int16 v120 = 2048;
                    uint64_t v121 = v79;
                    __int16 v122 = 2048;
                    double v123 = *(float *)&v99;
                    __int16 v124 = 2048;
                    double v125 = *((float *)&v99 + 1);
                    __int16 v126 = 2048;
                    double v127 = *((float *)&v99 + 2);
                    __int16 v128 = 2048;
                    double v129 = *((float *)&v99 + 3);
                    __int16 v130 = 2048;
                    double v131 = *(float *)&v100;
                    __int16 v132 = 2048;
                    double v133 = *((float *)&v100 + 1);
                    __int16 v134 = 2048;
                    double v135 = *((float *)&v100 + 2);
                    _os_signpost_emit_with_name_impl(&dword_221E5E000, (os_log_t)v74, OS_SIGNPOST_EVENT, v77, "Phase_Spatial_Modeler_Output", "Metadata %p built for: Listener %llu: Rotation [%f, %f, %f, %f], Position [%f, %f, %f] \n Source %llu: Rotation [%f, %f, %f, %f], Position [%f, %f, %f] \n ", buf, 0xACu);
                  }
                }
              }
              Phase::Trace::PostDirectPathSpatialModelerOutput(*(Phase::Logger **)(v81 + 200), *(void *)(v81 + 192), v80);
              if (v61 != v11) {
                __assert_rtn("BuildOutput", "DirectPathTransmissionImpl.mm", 781, "outputIndex == totalPointCount");
              }
              goto LABEL_67;
            }
            uint64_t v70 = (**a2)(a2, v25);
            uint64_t v71 = 4;
          }
          else
          {
            uint64_t v70 = ((uint64_t (*)(uint64_t (***)(void, __n128)))**a2)(a2);
            uint64_t v71 = 7;
          }
        }
        else
        {
          uint64_t v70 = ((uint64_t (*)(uint64_t (***)(void, __n128)))**a2)(a2);
          uint64_t v71 = 6;
        }
      }
      else
      {
        uint64_t v70 = ((uint64_t (*)(uint64_t (***)(void, __n128)))**a2)(a2);
        uint64_t v71 = 5;
      }
      *(void *)a1 = v71;
      *(void *)(a1 + 8) = v70;
      int v72 = 2;
      goto LABEL_68;
    }
  }
LABEL_67:
  int v72 = 1;
LABEL_68:
  *(_DWORD *)(a1 + 24) = v72;
  if (v102) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v102);
  }
}

void sub_221EFB960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,std::__shared_weak_count *a38)
{
  if (a38) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a38);
  }
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryHandleResults(Phase::Logger *a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v132 = *MEMORY[0x263EF8340];
  uint64_t Instance = Phase::Logger::GetInstance(a1);
  uint64_t v7 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 208));
  unint64_t v8 = (Phase::Logger *)Phase::Logger::GetInstance(v7);
  if (*((unsigned char *)v8 + 216))
  {
    os_signpost_id_t v9 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v8)
                                                                                       + 208)));
    uint64_t v10 = v9;
    if ((unint64_t)v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v10, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v7, "Phase_DirectPath_Spatial_Query_Handle_Results", "DirectPathTransmission: Handle Query Results", buf, 2u);
    }
  }
  unsigned int v11 = atomic_load((unsigned int *)a2);
  if (v11 != 3)
  {
    uint64_t v25 = (**(uint64_t (***)(Phase::Logger *))a1)(a1);
    *(void *)a3 = 129;
    *(void *)(a3 + 8) = v25;
    *(_DWORD *)(a3 + 24) = 2;
    return;
  }
  uint64_t v12 = *((void *)a1 + 2);
  if (!*(void *)(v12 + 2760)) {
    goto LABEL_23;
  }
  uint64_t v13 = Phase::Geometry::SystemDebugger::GetFromSystem(v12);
  if (!v13) {
    goto LABEL_23;
  }
  unsigned int v16 = *(void **)(v13 + 24);
  uint64_t v14 = v13 + 24;
  uint64_t v15 = v16;
  if (!v16) {
    goto LABEL_23;
  }
  unint64_t v17 = *(void *)(a2 + 192);
  uint64_t v18 = (void *)v14;
  do
  {
    unint64_t v19 = v15[4];
    BOOL v20 = v19 >= v17;
    if (v19 >= v17) {
      long long v21 = v15;
    }
    else {
      long long v21 = v15 + 1;
    }
    if (v20) {
      uint64_t v18 = v15;
    }
    uint64_t v15 = (void *)*v21;
  }
  while (*v21);
  if (v18 != (void *)v14)
  {
    unint64_t v22 = v18[4];
    long long v23 = v18 + 5;
    if (v22 <= v17) {
      long long v24 = v23;
    }
    else {
      long long v24 = 0;
    }
  }
  else
  {
LABEL_23:
    long long v24 = 0;
  }
  uint64_t v26 = *(void **)(a2 + 168);
  unint64_t v27 = *(int *)(a2 + 376);
  std::atomic_load[abi:ne180100]<Phase::SpatialModeler::DirectPathTransmission::SourceData>(&v113, v26 + 12);
  os_signpost_id_t v104 = (os_signpost_id_t)v7;
  uint64_t v105 = a3;
  float v28 = v113;
  int32x2_t v29 = (char *)operator new(0x48uLL);
  unint64_t v30 = (std::__shared_weak_count *)v29;
  *((void *)v29 + 1) = 0;
  unint64_t v31 = (atomic_ullong *)(v29 + 8);
  *((void *)v29 + 2) = 0;
  *(void *)int32x2_t v29 = &unk_26D474860;
  *(_OWORD *)(v29 + 24) = 0u;
  unint64_t v32 = (uint64_t *)(v29 + 24);
  *(_OWORD *)(v29 + 40) = 0u;
  *(_OWORD *)(v29 + 56) = 0u;
  if (!v27)
  {
    float v102 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v29) + 112);
    if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int16 v124 = 136315394;
      *(void *)&v124[4] = "ManagedPtr.hpp";
      *(_WORD *)&v124[12] = 1024;
      *(_DWORD *)&v124[14] = 229;
      _os_log_impl(&dword_221E5E000, v102, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v124, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  float32x2_t v33 = operator new(152 * (int)v27, (std::align_val_t)8uLL);
  double v111 = v31;
  __int16 v106 = v24;
  float32x2_t v34 = v33;
  do
  {
    *float32x2_t v34 = 0;
    v34[5] = 0;
    v34[6] = 0;
    v34[4] = 0;
    v34[11] = 0;
    v34[12] = 0;
    v34[10] = 0;
    v34[17] = 0;
    v34[18] = 0;
    v34[16] = 0;
    v34 += 19;
  }
  while (v34 != &v33[19 * (int)v27]);
  double v129 = (char *)&unk_26D474898;
  unint64_t v130 = v27;
  double v131 = (void **)&v129;
  *(void *)__int16 v124 = v33;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v124[8], (uint64_t)&v129);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&v129);
  uint64_t v35 = *(void *)v124;
  *(void *)__int16 v124 = 0;
  *(void *)buf = v35;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v118, (uint64_t)&v124[8]);
  uint64_t v119 = v27;
  std::unique_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceFrame [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)v124);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&v124[8]);
  uint64_t v36 = *(void *)buf;
  *(void *)buf = 0;
  uint64_t v37 = *v32;
  *unint64_t v32 = v36;
  if (v37) {
    std::function<void ()(void *)>::operator()((uint64_t)&v30[1].__shared_owners_, v37);
  }
  std::__function::__value_func<void ()(void *)>::operator=[abi:ne180100](&v30[1].__shared_owners_, (uint64_t)v118);
  v30[2].__shared_weak_owners_ = v119;
  std::unique_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceFrame [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v118);
  if (v28)
  {
    if (v28[5] < v27) {
      unint64_t v27 = v28[5];
    }
    if (v27)
    {
      uint64_t v38 = 0;
      do
      {
        Phase::SpatialModeler::DirectPathTransmission::SourceFrame::operator=((uint64_t *)(*v32 + v38), (void *)(*v28 + v38));
        v38 += 152;
        --v27;
      }
      while (v27);
    }
  }
  double v39 = (double)std::chrono::steady_clock::now().__d_.__rep_ / 1000000000.0;
  unint64_t shared_weak_owners = v30[2].__shared_weak_owners_;
  if (!shared_weak_owners)
  {
    unint64_t v43 = 0;
LABEL_45:
    if (*(unsigned char *)(a2 + 380))
    {
      if (v26[21] >= shared_weak_owners) {
        unint64_t v43 = 0;
      }
      else {
        unint64_t v43 = v26[21];
      }
    }
    float v48 = (uint64_t *)(*v32 + 152 * v43);
    v48[18] = 0;
    std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](v48 + 12);
    v48[17] = 0;
    std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](v48 + 6);
    v48[11] = 0;
    std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](v48);
    v48[5] = 0;
    uint64_t v44 = 1;
    goto LABEL_50;
  }
  uint64_t v41 = 0;
  unint64_t v42 = 0;
  unint64_t v43 = 0;
  uint64_t v44 = 0;
  double v45 = 1.79769313e308;
  do
  {
    uint64_t v46 = *v32 + v41;
    double v47 = *(double *)(v46 + 144);
    if (v47 >= v39 + -10.0)
    {
      if (v47 < v45)
      {
        unint64_t v43 = v42;
        double v45 = *(double *)(v46 + 144);
      }
    }
    else
    {
      *(void *)(v46 + 144) = 0;
      std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(v46 + 96));
      *(void *)(v46 + 136) = 0;
      std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(v46 + 48));
      *(void *)(v46 + 88) = 0;
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)v46);
      *(void *)(v46 + 40) = 0;
      ++v44;
      unint64_t shared_weak_owners = v30[2].__shared_weak_owners_;
    }
    ++v42;
    v41 += 152;
  }
  while (shared_weak_owners > v42);
  if (!v44) {
    goto LABEL_45;
  }
LABEL_50:
  uint64_t v49 = *(void *)(a2 + 320);
  if (v49 != *(void *)(a2 + 144)) {
    __assert_rtn("RunSpatialQueryHandleResults", "DirectPathTransmissionImpl.mm", 548, "sourcePointCount == inQueryState.mTraceQueries.Size()");
  }
  double v107 = v26;
  Phase::SpatialModeler::DirectPathTransmission::SourceFrame::SourceFrame((Phase::SpatialModeler::DirectPathTransmission::SourceFrame *)buf, v49, v39);
  if (v49)
  {
    for (uint64_t i = 0; i != v49; ++i)
    {
      uint64_t v51 = 0;
      unint64_t v52 = 0;
      unint64_t v53 = 0;
      float v54 = (_DWORD *)(*(void *)(a2 + 280) + 12 * i);
      unint64_t v55 = (_DWORD *)(*(void *)buf + 12 * i);
      uint64_t v56 = *(void *)(a2 + 104);
      *unint64_t v55 = *v54;
      v55[1] = v54[1];
      v55[2] = v54[2];
      uint64_t v57 = (float32x2_t *)(v56 + 68 * i);
      double v129 = (char *)vneg_f32(v57[6]);
      *(float *)&unint64_t v130 = -v57[7].f32[0];
      *(void *)__int16 v124 = 0;
      *(_DWORD *)&v124[8] = 0;
      do
      {
        if (v53 <= 2)
        {
          unint64_t v52 = v53 + 1;
          *(_DWORD *)&v124[4 * v53++] = *(_DWORD *)((char *)&v129 + v51);
        }
        v51 += 4;
      }
      while (v51 != 12);
      if (v52 <= 2) {
        bzero(&v124[4 * v52], 12 - 4 * v52);
      }
      uint64_t v58 = 0;
      unint64_t v59 = 0;
      unint64_t v60 = 0;
      float32x2_t v61 = *(float32x2_t *)(a2 + 264);
      double v129 = (char *)vadd_f32(*(float32x2_t *)v124, v61);
      *(float *)&unint64_t v130 = *(float *)&v124[8] + *(float *)(a2 + 272);
      *(void *)__int16 v124 = 0;
      *(_DWORD *)&v124[8] = 0;
      do
      {
        if (v60 <= 2)
        {
          unint64_t v59 = v60 + 1;
          *(_DWORD *)&v124[4 * v60++] = *(_DWORD *)((char *)&v129 + v58);
        }
        v58 += 4;
      }
      while (v58 != 12);
      if (v59 <= 2) {
        bzero(&v124[4 * v59], 12 - 4 * v59);
      }
      uint64_t v62 = 0;
      unint64_t v63 = 0;
      unint64_t v64 = 0;
      v61.i32[0] = *(_DWORD *)(*(void *)(a2 + 328) + 4 * i);
      double v129 = (char *)vadd_f32(*(float32x2_t *)v124, (float32x2_t)vdup_lane_s32((int32x2_t)v61, 0));
      *(float *)&unint64_t v130 = *(float *)&v124[8] + v61.f32[0];
      *(void *)__int16 v124 = 0;
      *(_DWORD *)&v124[8] = 0;
      do
      {
        if (v64 <= 2)
        {
          unint64_t v63 = v64 + 1;
          *(_DWORD *)&v124[4 * v64++] = *(_DWORD *)((char *)&v129 + v62);
        }
        v62 += 4;
      }
      while (v62 != 12);
      if (v63 <= 2) {
        bzero(&v124[4 * v63], 12 - 4 * v63);
      }
      int v65 = *(_DWORD *)&v124[8];
      uint64_t v66 = v120 + 12 * i;
      *(void *)uint64_t v66 = *(void *)v124;
      *(_DWORD *)(v66 + 8) = v65;
      *(_DWORD *)(v122 + 4 * i) = *(_DWORD *)(v56 + 68 * i + 64);
    }
  }
  unint64_t v67 = v30[2].__shared_weak_owners_;
  if (!v67) {
    goto LABEL_89;
  }
  unint64_t v68 = 0;
  uint64_t v69 = 144;
  uint64_t v70 = v26;
  do
  {
    uint64_t v71 = (double *)(*v32 + v69);
    double v73 = *v71;
    int v72 = (uint64_t *)(v71 - 18);
    if (v73 == 0.0)
    {
      if (v44 == 1)
      {
        Phase::SpatialModeler::DirectPathTransmission::SourceFrame::operator=(v72, (uint64_t *)buf);
      }
      else
      {
        if (!v44) {
          __assert_rtn("RunSpatialQueryHandleResults", "DirectPathTransmissionImpl.mm", 571, "emptyCount != 0");
        }
        Phase::SpatialModeler::DirectPathTransmission::SourceFrame::operator=(v72, buf);
      }
      unint64_t v67 = v30[2].__shared_weak_owners_;
      --v44;
    }
    ++v68;
    v69 += 152;
  }
  while (v67 > v68);
  if (v44) {
LABEL_89:
  }
    __assert_rtn("RunSpatialQueryHandleResults", "DirectPathTransmissionImpl.mm", 584, "0 == emptyCount");
  atomic_fetch_add_explicit(v111, 1uLL, memory_order_relaxed);
  sp_mut = std::__get_sp_mut(v26 + 12);
  std::__sp_mut::lock(sp_mut);
  uint64_t v75 = (std::__shared_weak_count *)v107[13];
  v107[12] = v32;
  v107[13] = v30;
  std::__sp_mut::unlock(sp_mut);
  if (v75) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v75);
  }
  atomic_store(*(unint64_t *)&v39, v107 + 22);
  uint64_t v77 = v30[2].__shared_weak_owners_;
  if (v77)
  {
    unint64_t v78 = 0;
    uint64_t v79 = (uint64_t *)(*v32 + 40);
    float v80 = v106;
    do
    {
      uint64_t v81 = *v79;
      v79 += 19;
      v78 += v81;
      --v77;
    }
    while (v77);
    if (!v106) {
      goto LABEL_116;
    }
LABEL_91:
    if (v80[5])
    {
      *(void *)__int16 v124 = *(void *)(a2 + 192);
      *(void *)&v124[8] = 0;
      __int16 v126 = 0;
      *(void *)&v124[16] = v78;
      std::vector<Phase::Vector<float,3ul>>::vector(&v129, v78);
      uint64_t v82 = v129;
      double v125 = v129;
      if (v78)
      {
        if (v78 >> 57) {
          std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v83 = (char *)operator new(v78 << 7);
        bzero(v83, v78 << 7);
      }
      else
      {
        unint64_t v83 = 0;
      }
      __int16 v126 = v83;
      uint64_t v110 = v30[2].__shared_weak_owners_;
      if (v110)
      {
        uint64_t v84 = 0;
        LODWORD(v85) = 0;
        uint64_t v86 = *v32;
        long long v87 = 0uLL;
        uint64_t v108 = *v32;
        uint64_t v109 = a2;
        do
        {
          float v88 = (void *)(v86 + 152 * v84);
          if (v88[5])
          {
            unint64_t v89 = 0;
            uint64_t v112 = v84;
            uint64_t v90 = (void *)(v86 + 152 * v84 + 48);
            uint64_t v85 = (int)v85;
            do
            {
              uint64_t v91 = 0;
              unint64_t v92 = 0;
              unint64_t v93 = 0;
              float v94 = (_DWORD *)(*v88 + 12 * v89);
              float v95 = &v82[12 * v85];
              *(_DWORD *)float v95 = *v94;
              *((_DWORD *)v95 + 1) = v94[1];
              *((_DWORD *)v95 + 2) = v94[2];
              float v96 = (float32x2_t *)(*v90 + 12 * v89);
              float32x2_t v127 = vneg_f32(*v96);
              float v128 = -v96[1].f32[0];
              uint64_t v115 = 0;
              int v116 = 0;
              do
              {
                if (v93 <= 2)
                {
                  unint64_t v92 = v93 + 1;
                  *((_DWORD *)&v115 + v93++) = v127.i32[v91];
                }
                ++v91;
              }
              while (v91 != 3);
              if (v92 <= 2)
              {
                bzero((char *)&v115 + 4 * v92, 12 - 4 * v92);
                long long v87 = 0uLL;
              }
              int v97 = v116;
              long long v98 = &v83[128 * v85];
              *(void *)long long v98 = v115;
              *((_DWORD *)v98 + 2) = v97;
              *(_OWORD *)(v98 + 12) = v87;
              *(_OWORD *)(v98 + 28) = v87;
              *(_OWORD *)(v98 + 44) = v87;
              *(_OWORD *)(v98 + 60) = v87;
              *(_OWORD *)(v98 + 76) = v87;
              *(_OWORD *)(v98 + 92) = v87;
              *(_OWORD *)(v98 + 108) = v87;
              *((_DWORD *)v98 + 31) = 3;
              ++v85;
              ++v89;
            }
            while (v88[5] > v89);
            uint64_t v86 = v108;
            a2 = v109;
            uint64_t v84 = v112;
          }
          ++v84;
        }
        while (v84 != v110);
      }
      else
      {
        LODWORD(v85) = 0;
      }
      uint64_t v70 = v107;
      if (v78 != (int)v85) {
        __assert_rtn("RunSpatialQueryHandleResults", "DirectPathTransmissionImpl.mm", 627, "totalPointCount == debugIndex");
      }
      std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::operator()(v106[5], (uint64_t)v124);
      if (v83) {
        operator delete(v83);
      }
      os_signpost_id_t v76 = (Phase::Logger *)v129;
      if (v129)
      {
        unint64_t v130 = (unint64_t)v129;
        operator delete(v129);
      }
    }
    goto LABEL_116;
  }
  unint64_t v78 = 0;
  float v80 = v106;
  if (v106) {
    goto LABEL_91;
  }
LABEL_116:
  *(void *)(a2 + 184) = Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryReturnOutput;
  long long v99 = (Phase::Logger *)Phase::Logger::GetInstance(v76);
  if (*((unsigned char *)v99 + 216))
  {
    long long v100 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v99)
                                                                                         + 208)));
    float v101 = v100;
    if (v104 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v100))
    {
      *(_WORD *)__int16 v124 = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v101, OS_SIGNPOST_INTERVAL_END, v104, "Phase_DirectPath_Spatial_Query_Handle_Results", (const char *)&unk_222112ABB, v124, 2u);
    }
  }
  *(void *)uint64_t v105 = v70;
  *(_DWORD *)(v105 + 24) = 5;
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v122);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v123);
  std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v120);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v121);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v118);
  std::__shared_weak_count::__release_shared[abi:ne180100](v30);
  if (v114) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v114);
  }
}

void sub_221EFC528(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, std::__shared_weak_count *a20,uint64_t a21,uint64_t a22,char a23)
{
  __cxa_free_exception(v23);
  std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  if (a20) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a20);
  }
  _Unwind_Resume(a1);
}

void std::atomic_load[abi:ne180100]<Phase::SpatialModeler::DirectPathTransmission::SourceData>(void *a1, void *a2)
{
  sp_mut = std::__get_sp_mut(a2);
  std::__sp_mut::lock(sp_mut);
  uint64_t v5 = a2[1];
  *a1 = *a2;
  a1[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }

  std::__sp_mut::unlock(sp_mut);
}

uint64_t std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v3);
}

void Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryReturnOutput(Phase::Logger *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t Instance = Phase::Logger::GetInstance(a1);
  os_signpost_id_t v9 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 208));
  uint64_t v10 = (Phase::Logger *)Phase::Logger::GetInstance(v9);
  if (*((unsigned char *)v10 + 216))
  {
    unsigned int v11 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v10)
                                                                                        + 208)));
    uint64_t v12 = v11;
    if ((unint64_t)v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v12, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v9, "Phase_DirectPath_Spatial_Query_Return_Output", "DirectPathTransmission: Return Output", buf, 2u);
    }
  }
  Phase::SpatialModeler::DirectPathTransmissionImpl::BuildOutput(a4, (uint64_t (***)(void, __n128))a1, a2, a3, *(void *)(a3 + 168));
  uint64_t v14 = (Phase::Logger *)Phase::Logger::GetInstance(v13);
  if (*((unsigned char *)v14 + 216))
  {
    uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v14)
                                                                                        + 208)));
    unsigned int v16 = v15;
    if ((unint64_t)v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v15))
    {
      *(_WORD *)unint64_t v17 = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v16, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v9, "Phase_DirectPath_Spatial_Query_Return_Output", (const char *)&unk_222112ABB, v17, 2u);
    }
  }
}

void sub_221EFC810(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::DirectPathTransmission::SourceFrame::~SourceFrame(Phase::SpatialModeler::DirectPathTransmission::SourceFrame *this)
{
}

float Phase::operator*<float>@<S0>(float32x2_t *a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  Phase::operator*<float>((float *)a1, a2, (float *)&v10);
  Phase::operator*<float>((float *)a1, a2 + 4, (float *)&v11);
  float v6 = a1[3].f32[1];
  float result = (float)(v6 * v12) + a1[3].f32[0];
  float32x2_t v8 = vadd_f32(vmul_n_f32(v11, v6), a1[2]);
  float v9 = v6 * a2[7];
  *(_OWORD *)a3 = v10;
  *(float32x2_t *)(a3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v8;
  *(float *)(a3 + 24) = result;
  *(float *)(a3 + 28) = v9;
  return result;
}

float32x2_t Phase::Inverse<float>@<D0>(float32x2_t *a1@<X0>, uint64_t a2@<X8>)
{
  __int32 v3 = a1[1].i32[1];
  *(float *)&unsigned int v4 = -a1[1].f32[0];
  *(float32x2_t *)&long long v10 = vneg_f32(*a1);
  *((void *)&v10 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = __PAIR64__(v3, v4);
  float v5 = 1.0 / a1[3].f32[1];
  Phase::operator*<float>((float *)&v10, (float *)&a1[2], (float *)&v8);
  float v6 = -(float)(v5 * v9);
  *(_OWORD *)a2 = v10;
  float32x2_t result = vmul_n_f32(v8, -v5);
  *(float32x2_t *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
  *(float *)(a2 + 24) = v6;
  *(float *)(a2 + 28) = v5;
  return result;
}

float Phase::Geometry::CalculateDirectivitySubbandGains<3ul>(Phase::Geometry::SystemState *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  BOOL v5 = *(_DWORD *)a3 == 3 && *(_DWORD *)a2 == 2;
  float v6 = 1.0;
  if (v5)
  {
    Phase::Geometry::SystemState::SystemState((Phase::Geometry::SystemState *)&v44, a1);
    long long v12 = *(_OWORD *)(a2 + 64);
    v43[0] = *(_OWORD *)(a2 + 48);
    v43[1] = v12;
    long long v13 = *(_OWORD *)(a3 + 64);
    v42[0] = *(_OWORD *)(a3 + 48);
    v42[1] = v13;
    _ZZN5Phase8Geometry32CalculateDirectivitySubbandGainsILm3EEENS_14PackedSubbandsIfXT_EEERNS0_11SystemStateERKNS0_6EntityES8_NS_8Handle64ES9_ENKUlT_bT0_T1_T2_E_clIS4_S9_NS_6AffineIfEESH_EEDaSA_bSB_SC_SD_(v44, v46, 1, a4, (float32x2_t *)v43, (float32x2_t *)v42);
    float v6 = v14;
    float v16 = v15;
    float v18 = v17;
    unint64_t v53 = (void **)&v52;
    std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__destroy_vector::operator()[abi:ne180100](&v53);
    if (v51) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v51);
    }
    if (v50) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v50);
    }
    if (v49) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v49);
    }
    if (v48) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v48);
    }
    if (v47) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v47);
    }
    if (v45) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v45);
    }
    if (*(void *)(a3 + 120) == *(void *)(a3 + 128))
    {
      Phase::Geometry::SystemState::SystemState((Phase::Geometry::SystemState *)&v33, a1);
      long long v19 = *(_OWORD *)(a2 + 64);
      v32[0] = *(_OWORD *)(a2 + 48);
      v32[1] = v19;
      long long v20 = *(_OWORD *)(a3 + 64);
      v31[0] = *(_OWORD *)(a3 + 48);
      v31[1] = v20;
      _ZZN5Phase8Geometry32CalculateDirectivitySubbandGainsILm3EEENS_14PackedSubbandsIfXT_EEERNS0_11SystemStateERKNS0_6EntityES8_NS_8Handle64ES9_ENKUlT_bT0_T1_T2_E_clIS4_S9_NS_6AffineIfEESH_EEDaSA_bSB_SC_SD_(v33, v35, 0, a5, (float32x2_t *)v32, (float32x2_t *)v31);
      float v22 = v21;
      float v24 = v23;
      float v26 = v25;
      unint64_t v53 = (void **)&v41;
      std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__destroy_vector::operator()[abi:ne180100](&v53);
      if (v40) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v40);
      }
      if (v39) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v39);
      }
      if (v38) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v38);
      }
      if (v37) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v37);
      }
      if (v36) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v36);
      }
      if (v34) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v34);
      }
      uint64_t v27 = 0;
      unint64_t v28 = 0;
      unint64_t v29 = 0;
      v55[0] = v6 * v22;
      v55[1] = v16 * v24;
      v55[2] = v18 * v26;
      unint64_t v53 = 0;
      int v54 = 0;
      do
      {
        if (v29 <= 2)
        {
          unint64_t v28 = v29 + 1;
          *((float *)&v53 + v29++) = v55[v27];
        }
        ++v27;
      }
      while (v27 != 3);
      if (v28 <= 2) {
        bzero((char *)&v53 + 4 * v28, 12 - 4 * v28);
      }
      return *(float *)&v53;
    }
  }
  return v6;
}

void sub_221EFCC2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  Phase::Geometry::SystemState::~SystemState((Phase::Geometry::SystemState *)va);
  _Unwind_Resume(a1);
}

void Phase::Geometry::CalculateDistanceGainsInDecibels<Phase::SystemAllocator>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7)
{
  v42[4] = *MEMORY[0x263EF8340];
  long long v13 = (Phase::Logger *)a6[5];
  uint64_t v39 = 4;
  unint64_t v40 = v13;
  v38[0] = a2;
  v38[1] = &v40;
  v38[2] = &v39;
  uint64_t v37 = a2;
  Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(float*)#1} const&>(v13, (uint64_t)v38, &v37, &v41);
  uint64_t v14 = v41;
  uint64_t v41 = 0;
  *(void *)a1 = v14;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100](a1 + 8, (uint64_t)v42);
  *(void *)(a1 + 40) = v13;
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v41);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v42);
  uint64_t v15 = *(void *)(a1 + 40);
  if (v15) {
    bzero(*(void **)a1, 4 * v15);
  }
  if (*(_DWORD *)(a3 + 40) > a7)
  {
    uint64_t v16 = *(void *)(a3 + 24);
    if (*(_DWORD *)(v16 + 24 * a7 + 20) == HIDWORD(a7))
    {
      uint64_t v17 = *(void *)(v16 + 24 * a7);
      if (v17)
      {
        uint64_t v18 = *(_DWORD *)a4 == 2 ? a4 : 0;
        if (*(_DWORD *)a5 == 3 && *(_DWORD *)a4 == 2)
        {
          long long v19 = *(uint64_t **)(a5 + 120);
          float v20 = 0.0;
          if (v19 != *(uint64_t **)(a5 + 128))
          {
            uint64_t v21 = *v19;
            if (*(_DWORD *)(a3 + 112) > *v19)
            {
              uint64_t v22 = *(void *)(a3 + 96);
              if (*(_DWORD *)(v22 + 24 * v21 + 20) == HIDWORD(v21))
              {
                float v23 = *(float **)(v22 + 24 * v21);
                if (v23) {
                  float v20 = (float)(*(float *)(a5 + 76) * fmaxf(fmaxf(v23[9] - v23[6], v23[10] - v23[7]), v23[11] - v23[8]))
                }
                      * 0.5;
              }
            }
          }
          uint64_t v24 = a6[5];
          if (v24)
          {
            uint64_t v25 = 0;
            uint64_t v26 = 0;
            float v27 = *(float *)(a4 + 64);
            float v28 = *(float *)(a4 + 68);
            float v29 = *(float *)(a4 + 72);
            float v30 = *(double *)(v18 + 152);
            do
            {
              Phase::operator*<float>((float *)(a5 + 48), (float *)(*a6 + v25), (float *)&v41);
              float v31 = *(float *)(a5 + 76);
              float v32 = fmaxf(v30, v20+ sqrtf((float)((float)((float)(v27 - (float)((float)(v31 * *(float *)&v41) + *(float *)(a5 + 64)))* (float)(v27 - (float)((float)(v31 * *(float *)&v41) + *(float *)(a5 + 64))))+ (float)((float)(v28 - (float)((float)(v31 * *((float *)&v41 + 1)) + *(float *)(a5 + 68)))* (float)(v28 - (float)((float)(v31 * *((float *)&v41 + 1)) + *(float *)(a5 + 68)))))+ (float)((float)(v29 - (float)((float)(v31 * *(float *)v42) + *(float *)(a5 + 72)))* (float)(v29 - (float)((float)(v31 * *(float *)v42) + *(float *)(a5 + 72))))));
              if (*(_DWORD *)v17 == 2)
              {
                uint64_t v35 = **(void **)(v17 + 40);
                if (!v35) {
LABEL_28:
                }
                  std::terminate();
                float v36 = Phase::Envelope<float>::operator()((float **)(v35 + 16), v32);
                if (v36 <= 0.0) {
                  float v36 = COERCE_FLOAT(1);
                }
                float v33 = (float)((float)(logf(v36) * 8.6859) / 10.0) * 10.0;
              }
              else
              {
                float v33 = 0.0;
                if (*(_DWORD *)v17 == 1)
                {
                  uint64_t v34 = **(void **)(v17 + 40);
                  if (!v34) {
                    goto LABEL_28;
                  }
                  float v33 = (float)(log2f(v32 / (float)(v20 + 1.0)) * -6.0206) * *(float *)(v34 + 16);
                }
              }
              *(float *)(*(void *)a1 + 4 * v26++) = v33;
              v25 += 12;
            }
            while (v24 != v26);
          }
        }
      }
    }
  }
}

void sub_221EFCF98(_Unwind_Exception *a1)
{
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](v1);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::DirectPathTransmissionImpl::BuildOutputPointSource(uint64_t a1, uint64_t (***a2)(void), uint64_t a3, uint64_t a4, float a5, float a6, float a7)
{
  uint64_t v99 = *MEMORY[0x263EF8340];
  uint64_t v9 = *(void *)(a3 + 64);
  if (!v9)
  {
    uint64_t result = (**a2)(a2);
    uint64_t v56 = 5;
    goto LABEL_38;
  }
  uint64_t v11 = *(void *)(a4 + 192);
  unsigned int v12 = *(_DWORD *)(v9 + 136);
  if (v12 <= v11
    || (uint64_t v13 = *(void *)(v9 + 120), *(_DWORD *)(v13 + 24 * v11 + 20) != HIDWORD(v11))
    || (uint64_t v14 = *(void *)(v13 + 24 * *(void *)(a4 + 192))) == 0
    || *(_DWORD *)v14 != 3)
  {
    uint64_t result = (**a2)(a2);
    uint64_t v56 = 6;
LABEL_38:
    *(void *)a1 = v56;
    *(void *)(a1 + 8) = result;
    int v55 = 2;
    goto LABEL_39;
  }
  uint64_t v15 = *(void *)(a4 + 200);
  if (v12 <= v15
    || *(_DWORD *)(v13 + 24 * v15 + 20) != HIDWORD(v15)
    || (uint64_t v16 = *(void *)(v13 + 24 * *(void *)(a4 + 200))) == 0
    || *(_DWORD *)v16 != 2)
  {
    uint64_t result = (**a2)(a2);
    uint64_t v56 = 7;
    goto LABEL_38;
  }
  long long v21 = *(_OWORD *)(v14 + 64);
  long long v63 = *(_OWORD *)(v14 + 48);
  long long v64 = v21;
  long long v23 = *(_OWORD *)(v16 + 48);
  long long v24 = *(_OWORD *)(v16 + 64);
  uint64_t v22 = (float *)(v16 + 48);
  long long v61 = v23;
  long long v62 = v24;
  Phase::Inverse<float>((float32x2_t *)&v61, (uint64_t)buf);
  v25.n128_f32[0] = Phase::operator*<float>((float32x2_t *)buf, (float *)&v63, (uint64_t)&v57);
  uint64_t v26 = *(void *)(a3 + 96);
  if (!v26 || *(_DWORD *)v26 != 3)
  {
    uint64_t result = ((uint64_t (*)(uint64_t (***)(void), __n128))**a2)(a2, v25);
    uint64_t v56 = 4;
    goto LABEL_38;
  }
  *(unsigned char *)(v26 + 200) = 1;
  Phase::SpatialModeler::AllocMetadata<float,Phase::SystemAllocator>((uint64_t *)v26, (uint64_t)(a2 + 5), (Phase::Logger *)1, 3);
  uint64_t v27 = *(void *)(v26 + 8);
  float v28 = *(_DWORD **)(v26 + 56);
  uint64_t v29 = *(void *)(v26 + 104);
  float v30 = *(unsigned char **)(v26 + 144);
  float v31 = v58;
  float v32 = v60;
  float v33 = -v58;
  if (v58 >= 0.0) {
    float v33 = v58;
  }
  if (v33 > 0.00000011921) {
    goto LABEL_21;
  }
  float v34 = -v59;
  if (v59 >= 0.0) {
    float v34 = v59;
  }
  if (v34 > 0.00000011921) {
    goto LABEL_21;
  }
  float v35 = -v60;
  if (v60 >= 0.0) {
    float v35 = v60;
  }
  if (v35 <= 0.00000011921)
  {
    float v38 = 0.0;
    float v39 = 180.0;
  }
  else
  {
LABEL_21:
    float v36 = acosf(v59 / sqrtf((float)((float)(v58 * v58) + (float)(v59 * v59)) + (float)(v60 * v60)));
    float v37 = atan2f(v31, v32);
    float v38 = v36 * 57.296;
    float v39 = 180.0 - (float)(v37 * 57.296);
  }
  *(_DWORD *)uint64_t v27 = 1065353216;
  *(float *)(v27 + 4) = v38;
  float v40 = (float)(v39 - (float)(floorf(v39 / 360.0) * 360.0)) + 0.0;
  if (v40 >= 360.0) {
    float v40 = nextafterf(360.0, 0.0);
  }
  *(float *)(v27 + 8) = v40;
  *float v28 = 0;
  v98[0] = expf((float)((float)(a5 * 10.0) / 10.0) * 0.11513);
  v98[1] = expf((float)((float)(a6 * 10.0) / 10.0) * 0.11513);
  float v42 = expf((float)((float)(a7 * 10.0) / 10.0) * 0.11513);
  uint64_t v43 = 0;
  unint64_t v44 = 0;
  unint64_t v45 = 0;
  *(float *)&v98[2] = v42;
  memset(buf, 0, sizeof(buf));
  do
  {
    if (v45 <= 2)
    {
      unint64_t v44 = v45 + 1;
      *(_DWORD *)&buf[4 * v45++] = v98[v43];
    }
    ++v43;
  }
  while (v43 != 3);
  if (v44 <= 2) {
    bzero(&buf[4 * v44], 12 - 4 * v44);
  }
  int v46 = *(_DWORD *)&buf[8];
  *(void *)(v29 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)buf;
  *(_DWORD *)(v29 + 24) = v46;
  *float v30 = 0;
  uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(v41);
  if (*((unsigned char *)Instance + 216))
  {
    float v48 = (Phase::Logger *)objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(Instance)
                                                                                             + 208)));
    uint64_t v49 = Phase::Logger::GetInstance(v48);
    os_signpost_id_t v50 = os_signpost_id_generate(**(os_log_t **)(v49 + 208));
    if (v50 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
    {
      os_signpost_id_t v51 = v50;
      if (os_signpost_enabled((os_log_t)v48))
      {
        uint64_t v53 = *(void *)(a4 + 192);
        uint64_t v52 = *(void *)(a4 + 200);
        *(_DWORD *)buf = 134222080;
        *(void *)&uint8_t buf[4] = v26;
        __int16 v66 = 2048;
        uint64_t v67 = v52;
        __int16 v68 = 2048;
        double v69 = *(float *)&v61;
        __int16 v70 = 2048;
        double v71 = *((float *)&v61 + 1);
        __int16 v72 = 2048;
        double v73 = *((float *)&v61 + 2);
        __int16 v74 = 2048;
        double v75 = *((float *)&v61 + 3);
        __int16 v76 = 2048;
        double v77 = *(float *)&v62;
        __int16 v78 = 2048;
        double v79 = *((float *)&v62 + 1);
        __int16 v80 = 2048;
        double v81 = *((float *)&v62 + 2);
        __int16 v82 = 2048;
        uint64_t v83 = v53;
        __int16 v84 = 2048;
        double v85 = *(float *)&v63;
        __int16 v86 = 2048;
        double v87 = *((float *)&v63 + 1);
        __int16 v88 = 2048;
        double v89 = *((float *)&v63 + 2);
        __int16 v90 = 2048;
        double v91 = *((float *)&v63 + 3);
        __int16 v92 = 2048;
        double v93 = *(float *)&v64;
        __int16 v94 = 2048;
        double v95 = *((float *)&v64 + 1);
        __int16 v96 = 2048;
        double v97 = *((float *)&v64 + 2);
        _os_signpost_emit_with_name_impl(&dword_221E5E000, (os_log_t)v48, OS_SIGNPOST_EVENT, v51, "Phase_Spatial_Modeler_Output", "Metadata %p built for: Listener %llu: Rotation [%f, %f, %f, %f], Position [%f, %f, %f] \n Source %llu: Rotation [%f, %f, %f, %f], Position [%f, %f, %f] \n ", buf, 0xACu);
      }
    }
  }
  uint64_t result = Phase::Trace::PostDirectPathSpatialModelerOutput(*(Phase::Logger **)(a4 + 200), *(void *)(a4 + 192), v22);
  int v55 = 1;
LABEL_39:
  *(_DWORD *)(a1 + 24) = v55;
  return result;
}

void sub_221EFD564(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::DirectPathTransmissionImpl::RunSpatialQueryHandleResultsPointSource(Phase::Logger *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v64 = *MEMORY[0x263EF8340];
  uint64_t Instance = Phase::Logger::GetInstance(a1);
  uint64_t v9 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 208));
  long long v10 = (Phase::Logger *)Phase::Logger::GetInstance(v9);
  if (*((unsigned char *)v10 + 216))
  {
    uint64_t v11 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v10)
                                                                                        + 208)));
    unsigned int v12 = v11;
    if ((unint64_t)v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
    {
      v47.i16[0] = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v12, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v9, "Phase_DirectPath_Spatial_Query_Handle_Results", "DirectPathTransmission: Handle Query Results", (uint8_t *)&v47, 2u);
    }
  }
  unsigned int v13 = atomic_load((unsigned int *)a3);
  if (v13 == 3)
  {
    uint64_t v14 = *((void *)a1 + 2);
    if (!*(void *)(v14 + 2760)) {
      goto LABEL_23;
    }
    uint64_t v15 = Phase::Geometry::SystemDebugger::GetFromSystem(v14);
    if (!v15) {
      goto LABEL_23;
    }
    uint64_t v18 = *(void **)(v15 + 24);
    uint64_t v16 = v15 + 24;
    uint64_t v17 = v18;
    if (!v18) {
      goto LABEL_23;
    }
    unint64_t v19 = *(void *)(a3 + 192);
    float v20 = (void *)v16;
    do
    {
      unint64_t v21 = v17[4];
      BOOL v22 = v21 >= v19;
      if (v21 >= v19) {
        long long v23 = v17;
      }
      else {
        long long v23 = v17 + 1;
      }
      if (v22) {
        float v20 = v17;
      }
      uint64_t v17 = (void *)*v23;
    }
    while (*v23);
    if (v20 != (void *)v16)
    {
      unint64_t v24 = v20[4];
      __n128 v25 = v20 + 5;
      if (v24 <= v19) {
        uint64_t v26 = v25;
      }
      else {
        uint64_t v26 = 0;
      }
    }
    else
    {
LABEL_23:
      uint64_t v26 = 0;
    }
    uint64_t v28 = 0;
    unint64_t v29 = 0;
    unint64_t v30 = 0;
    float32x2_t v59 = vneg_f32(*(float32x2_t *)(a3 + 436));
    *(float *)&long long v60 = -*(float *)(a3 + 444);
    float32x2_t v47 = 0;
    float v48 = 0.0;
    do
    {
      if (v30 <= 2)
      {
        unint64_t v29 = v30 + 1;
        v47.i32[v30++] = v59.i32[v28];
      }
      ++v28;
    }
    while (v28 != 3);
    if (v29 <= 2) {
      bzero((char *)&v47 + 4 * v29, 12 - 4 * v29);
    }
    uint64_t v31 = 0;
    unint64_t v32 = 0;
    unint64_t v33 = 0;
    float32x2_t v34 = *(float32x2_t *)(a3 + 264);
    float32x2_t v59 = vadd_f32(v47, v34);
    *(float *)&long long v60 = v48 + *(float *)(a3 + 272);
    float32x2_t v47 = 0;
    float v48 = 0.0;
    do
    {
      if (v33 <= 2)
      {
        unint64_t v32 = v33 + 1;
        v47.i32[v33++] = v59.i32[v31];
      }
      ++v31;
    }
    while (v31 != 3);
    if (v32 <= 2) {
      bzero((char *)&v47 + 4 * v32, 12 - 4 * v32);
    }
    uint64_t v35 = 0;
    unint64_t v36 = 0;
    unint64_t v37 = 0;
    v34.i32[0] = *(_DWORD *)(a3 + 384);
    float32x2_t v59 = vadd_f32(v47, (float32x2_t)vdup_lane_s32((int32x2_t)v34, 0));
    *(float *)&long long v60 = v48 + v34.f32[0];
    float32x2_t v47 = 0;
    float v48 = 0.0;
    do
    {
      if (v37 <= 2)
      {
        unint64_t v36 = v37 + 1;
        v47.i32[v37++] = v59.i32[v35];
      }
      ++v35;
    }
    while (v35 != 3);
    if (v36 <= 2) {
      bzero((char *)&v47 + 4 * v36, 12 - 4 * v36);
    }
    float32x2_t v38 = v47;
    float v39 = v48;
    if (v26 && v26[5])
    {
      uint64_t v40 = 0;
      unint64_t v41 = 0;
      unint64_t v42 = 0;
      float32x2_t v59 = *(float32x2_t *)(a3 + 192);
      long long v60 = xmmword_2220A5520;
      uint64_t v57 = 0;
      int v58 = 0;
      long long v61 = &v57;
      long long v62 = 0;
      v63[0] = -v47.f32[0];
      v63[1] = -v47.f32[1];
      v63[2] = -v48;
      float32x2_t v47 = 0;
      float v48 = 0.0;
      do
      {
        if (v42 <= 2)
        {
          unint64_t v41 = v42 + 1;
          v47.f32[v42++] = v63[v40];
        }
        ++v40;
      }
      while (v40 != 3);
      if (v41 <= 2) {
        bzero((char *)&v47 + 4 * v41, 12 - 4 * v41);
      }
      int v56 = 3;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v62 = &v47;
      std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::operator()(v26[5], (uint64_t)&v59);
    }
    uint64_t v43 = (Phase::Logger *)Phase::SpatialModeler::DirectPathTransmissionImpl::BuildOutputPointSource(a4, (uint64_t (***)(void))a1, a2, a3, v38.f32[0], v38.f32[1], v39);
    unint64_t v44 = (Phase::Logger *)Phase::Logger::GetInstance(v43);
    if (*((unsigned char *)v44 + 216))
    {
      unint64_t v45 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v44)
                                                                                          + 208)));
      int v46 = v45;
      if ((unint64_t)v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v45))
      {
        v47.i16[0] = 0;
        _os_signpost_emit_with_name_impl(&dword_221E5E000, v46, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v9, "Phase_DirectPath_Spatial_Query_Handle_Results", (const char *)&unk_222112ABB, (uint8_t *)&v47, 2u);
      }
    }
  }
  else
  {
    uint64_t v27 = (**(uint64_t (***)(Phase::Logger *))a1)(a1);
    *(void *)a4 = 129;
    *(void *)(a4 + 8) = v27;
    *(_DWORD *)(a4 + 24) = 2;
  }
}

void sub_221EFDA34(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_26D474778[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3EEE10__dispatchB8ne180100IOZNS0_6__dtorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEELNS0_6_TraitE1EE9__destroyB8ne180100EvEUlRT_E_JRNS0_6__baseILSH_1EJS8_SB_SC_SD_SE_SF_EEEEEEDcSJ_DpT0_(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

uint64_t std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_construct[abi:ne180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>(a1, a2);
  return a1;
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_construct[abi:ne180100]<std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 24);
  if (v4 != -1) {
    uint64_t result = ((uint64_t (*)(char *, uint64_t))off_26D474778[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 24) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 24);
  if (v5 != -1)
  {
    uint64_t result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_26D4747A8[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 24) = v5;
  }
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSN_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSV_EEEDcSN_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSN_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSV_EEEDcSN_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  __n128 result = *a3;
  *a2 = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSN_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSV_EEEDcSN_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE19__generic_constructB8ne180100INS0_18__move_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSN_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSV_EEEDcSN_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(unsigned int *)(result + 24);
  uint64_t v4 = *(unsigned int *)(a2 + 24);
  if (v3 == -1)
  {
    if (v4 == -1) {
      return result;
    }
  }
  else if (v4 == -1)
  {
    __n128 result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_26D474778[v3])(&v6, result, a2);
    *(_DWORD *)(v2 + 24) = -1;
    return result;
  }
  uint64_t v5 = result;
  return ((uint64_t (*)(uint64_t *, uint64_t, uint64_t))off_26D4747D8[v4])(&v5, result, a2);
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t *a1)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 24)) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<0ul,std::monostate>(result);
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t *a1)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 24) != 1) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<1ul,Phase::SpatialModeler::ReturnSuccess>(result);
  }
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t *a1, _OWORD *a2, _OWORD *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 24) != 2) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<2ul,Phase::SpatialModeler::ReturnError>(result, a3);
  }
  *a2 = *a3;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t *a1, uint64_t a2, __n128 *a3)
{
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 24) != 4) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<4ul,Phase::SpatialModeler::ClaimOrWaitOnToken>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_12__assignmentINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE16__generic_assignB8ne180100INS0_17__move_assignmentISG_LNS0_6_TraitE1EEEEEvOT_EUlRSM_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEEOSU_EEEDcSM_DpT0_(uint64_t *a1, void *a2, void *a3)
{
  uint64_t result = *a1;
  if (*(_DWORD *)(result + 24) != 5) {
    return std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<5ul,Phase::SpatialModeler::ReleaseToken>(result, a3);
  }
  *a2 = *a3;
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<0ul,std::monostate>(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_26D474778[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 24) = 0;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<1ul,Phase::SpatialModeler::ReturnSuccess>(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 24);
  if (v2 != -1) {
    ((void (*)(char *, uint64_t))off_26D474778[v2])(&v4, a1);
  }
  *(_DWORD *)(a1 + 24) = 1;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<2ul,Phase::SpatialModeler::ReturnError>(uint64_t a1, _OWORD *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_26D474778[v4])(&v6, a1);
  }
  *(_DWORD *)(a1 + 24) = -1;
  *(_OWORD *)a1 = *a2;
  *(_DWORD *)(a1 + 24) = 2;
  return a1;
}

void std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__assign_alt[abi:ne180100]<3ul,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::WaitOnSceneQueries>(uint64_t a1, uint64_t a2, __n128 *a3)
{
  if (*(_DWORD *)(a1 + 24) == 3) {
    std::vector<Phase::Geometry::SceneQueryBatch *>::__move_assign(a2, a3);
  }
  else {
    std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<3ul,Phase::SpatialModeler::WaitOnSceneQueries>(a1, (uint64_t)a3);
  }
}

__n128 std::vector<Phase::Geometry::SceneQueryBatch *>::__move_assign(uint64_t a1, __n128 *a2)
{
  uint64_t v4 = *(void **)a1;
  if (v4)
  {
    *(void *)(a1 + 8) = v4;
    operator delete(v4);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  }
  __n128 result = *a2;
  *(__n128 *)a1 = *a2;
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<3ul,Phase::SpatialModeler::WaitOnSceneQueries>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_26D474778[v4])(&v6, a1);
  }
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a2 + 16);
  *(void *)a2 = 0;
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(_DWORD *)(a1 + 24) = 3;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<4ul,Phase::SpatialModeler::ClaimOrWaitOnToken>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_26D474778[v4])(&v6, a1);
  }
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 24) = 4;
  return a1;
}

uint64_t std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__emplace[abi:ne180100]<5ul,Phase::SpatialModeler::ReleaseToken>(uint64_t a1, void *a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  if (v4 != -1) {
    ((void (*)(char *, uint64_t))off_26D474778[v4])(&v6, a1);
  }
  *(void *)a1 = *a2;
  *(_DWORD *)(a1 + 24) = 5;
  return a1;
}

uint64_t *std::unique_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceFrame [],std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v1);
  }
  return result;
}

uint64_t *std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v1);
  }
  return result;
}

uint64_t *std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v1);
  }
  return result;
}

void *std::vector<Phase::Geometry::SceneQueryBatch *>::__init_with_size[abi:ne180100]<Phase::Geometry::SceneQueryBatch **,Phase::Geometry::SceneQueryBatch **>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    char v6 = result;
    __n128 result = std::vector<Phase::FrequencyBand<float>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      __n128 result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_221EFE0F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::unique_ptr<Phase::ManagedArray<Phase::Triangle<float>> [],std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v1);
  }
  return result;
}

float Phase::Envelope<float>::operator()(float **a1, float a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  float v5 = *v3;
  float v6 = *(v4 - 10);
  BOOL v7 = v6 >= a2 && v5 <= a2;
  float v8 = fminf(fmaxf(a2, v5), v6);
  if (!v7) {
    a2 = v8;
  }
  if (v4 != v3)
  {
    while (a2 < *v3 || a2 >= v3[2])
    {
      v3 += 12;
      if (v3 == v4) {
        goto LABEL_14;
      }
    }
  }
  if (v3 == v4)
  {
LABEL_14:
    if (a2 != *(v4 - 10)) {
      std::terminate();
    }
    uint64_t v3 = v4 - 12;
  }

  return Phase::Envelope<float>::SegmentInternal::operator()(v3, a2);
}

float Phase::Envelope<float>::SegmentInternal::operator()(float *a1, float a2)
{
  float v3 = *a1;
  float v4 = a1[2];
  float v5 = *a1 - v4;
  if (v5 < 0.0) {
    float v5 = -v5;
  }
  if (v5 <= 0.001)
  {
    float v6 = 0.0;
    if (v3 <= a2)
    {
      float v6 = 1.0;
      if (v3 >= a2) {
        float v6 = 0.5;
      }
    }
  }
  else
  {
    float v6 = fminf(fmaxf((float)(a2 - v3) / (float)(v4 - v3), 0.0), 1.0);
  }
  std::function<float ()(float)>::operator()((uint64_t)(a1 + 4), v6);
  return a1[1] + (float)(fminf(fmaxf(v7, 0.0), 1.0) * (float)(a1[3] - a1[1]));
}

uint64_t std::function<float ()(float)>::operator()(uint64_t a1, float a2)
{
  float v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, float *))(*(void *)v2 + 48))(v2, &v4);
}

void *std::__function::__value_func<void ()(Phase::Geometry::SceneQueryBatch *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&>(Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&>(Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&>(Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&>(Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D474818;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&>(Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&>(Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D474818;
  a2[1] = v2;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&>(Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&>(Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::DirectPathTransmissionImpl::SpatialQueryState*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t **a2)
{
  uint64_t v2 = *a2;
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](*a2 + 41);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v2 + 42);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](v2 + 35);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v2 + 36);
  uint64_t v3 = (std::__shared_weak_count *)v2[22];
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  float v4 = (std::__shared_weak_count *)v2[20];
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>>::reset[abi:ne180100](v2 + 13);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v2 + 14);
  std::__function::__value_func<void ()(Phase::Geometry::SceneQueryBatch *)>::~__value_func[abi:ne180100](v2 + 3);
  float v5 = (std::__shared_weak_count *)v2[2];
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }

  operator delete(v2);
}

void *Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    float v6 = **(id **)(Phase::Logger::GetInstance(0) + 112);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float v8 = 136315394;
      *(void *)&v8[4] = "ManagedPtr.hpp";
      __int16 v9 = 1024;
      int v10 = 229;
      _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v8, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  float v4 = operator new(4 * **(void **)a2, **(std::align_val_t **)(a2 + 8));
  *(void *)float v8 = &unk_26D474928;
  v8[8] = 0;
  uint64_t v11 = v8;
  *a3 = v4;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v8);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v8);
}

void sub_221EFE628(_Unwind_Exception *exception_object)
{
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayIfRKZNS3_10AllocArrayIfEENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS5_IfEESD_mmEUlPS7_E_EESD_mOT0_OT1_EUlSA_E_NS_9allocatorISP_EESB_ED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayIfRKZNS3_10AllocArrayIfEENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS5_IfEESD_mmEUlPS7_E_EESD_mOT0_OT1_EUlSA_E_NS_9allocatorISP_EESB_E7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_26D474928;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayIfRKZNS3_10AllocArrayIfEENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS5_IfEESD_mmEUlPS7_E_EESD_mOT0_OT1_EUlSA_E_NS_9allocatorISP_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D474928;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayIfRKZNS3_10AllocArrayIfEENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS5_IfEESD_mmEUlPS7_E_EESD_mOT0_OT1_EUlSA_E_NS_9allocatorISP_EESB_EclEOSA_(uint64_t a1, void **a2)
{
}

void std::__shared_ptr_emplace<Phase::SpatialModeler::DirectPathTransmission::SourceData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D474860;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::SpatialModeler::DirectPathTransmission::SourceData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D474860;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

void *std::__shared_ptr_emplace<Phase::SpatialModeler::DirectPathTransmission::SourceData>::__on_zero_shared(uint64_t a1)
{
  std::unique_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceFrame [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(a1 + 24));

  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler22DirectPathTransmission11SourceFrameERKZNS3_10AllocArrayIS7_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS8_IS7_EESG_mmEUlPSA_E_EESG_mOT0_OT1_EUlSD_E_NS_9allocatorISS_EESE_ED0Ev()
{
}

__n128 _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler22DirectPathTransmission11SourceFrameERKZNS3_10AllocArrayIS7_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS8_IS7_EESG_mmEUlPSA_E_EESG_mOT0_OT1_EUlSD_E_NS_9allocatorISS_EESE_E7__cloneEv(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26D474898;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler22DirectPathTransmission11SourceFrameERKZNS3_10AllocArrayIS7_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS8_IS7_EESG_mmEUlPSA_E_EESG_mOT0_OT1_EUlSD_E_NS_9allocatorISS_EESE_E7__cloneEPNS0_6__baseISE_EE(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D474898;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler22DirectPathTransmission11SourceFrameERKZNS3_10AllocArrayIS7_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS8_IS7_EESG_mmEUlPSA_E_EESG_mOT0_OT1_EUlSD_E_NS_9allocatorISS_EESE_EclEOSD_(uint64_t a1, void **a2)
{
  uint64_t v2 = *a2;
  if (*(void *)(a1 + 8))
  {
    unint64_t v4 = 0;
    float v5 = (uint64_t *)*a2;
    do
    {
      std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](v5 + 12);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v5 + 13);
      std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](v5 + 6);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v5 + 7);
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](v5);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v5 + 1);
      ++v4;
      v5 += 19;
    }
    while (v4 < *(void *)(a1 + 8));
  }

  operator delete(v2);
}

void *std::vector<Phase::Vector<float,3ul>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<Phase::Vector<float,3ul>>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v4 = (char *)a1[1];
    size_t v5 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_221EFE948(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Phase::Vector<float,3ul>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556) {
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Vector<float,3ul>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[12 * v4];
  return result;
}

void _ZZN5Phase8Geometry32CalculateDirectivitySubbandGainsILm3EEENS_14PackedSubbandsIfXT_EEERNS0_11SystemStateERKNS0_6EntityES8_NS_8Handle64ES9_ENKUlT_bT0_T1_T2_E_clIS4_S9_NS_6AffineIfEESH_EEDaSA_bSB_SC_SD_(uint64_t a1, unsigned int a2, int a3, uint64_t a4, float32x2_t *a5, float32x2_t *a6)
{
  if (a4 >= a2) {
    return;
  }
  if (*(_DWORD *)(a1 + 24 * a4 + 20) != HIDWORD(a4)) {
    return;
  }
  float v6 = *(int **)(a1 + 24 * a4);
  if (!v6) {
    return;
  }
  int v7 = *v6;
  if (*v6 == 3)
  {
    uint64_t v16 = **((void **)v6 + 5);
    if (!v16) {
      goto LABEL_36;
    }
    if (a3) {
      uint64_t v17 = a6;
    }
    else {
      uint64_t v17 = a5;
    }
    if (a3) {
      uint64_t v18 = a5;
    }
    else {
      uint64_t v18 = a6;
    }
    Phase::TransformPositionByInverse<float>(v18, v17 + 2, &v28);
    float v19 = v28;
    float v20 = v30;
    float v21 = acosf(v29 / sqrtf((float)((float)(v19 * v19) + (float)(v29 * v29)) + (float)(v20 * v20)));
    float v22 = atan2f(v19, v20) + 3.1416;
    float v23 = (float)(v22 - (float)(floorf(v22 / 6.2832) * 6.2832)) + 0.0;
    if (v23 >= 6.2832) {
      float v23 = nextafterf(6.2832, 0.0);
    }
    Phase::Geometry::SphericalCapDirectivity::GetSubbandGainsFromDatabase<3ul>(v16, v21, v23);
  }
  else
  {
    if (v7 != 2)
    {
      if (v7 != 1) {
        return;
      }
      uint64_t v8 = *(void *)(*((void *)v6 + 5) + 40);
      if (v8)
      {
        if (a3) {
          __int16 v9 = a6;
        }
        else {
          __int16 v9 = a5;
        }
        if (a3) {
          int v10 = a5;
        }
        else {
          int v10 = a6;
        }
        Phase::TransformPositionByInverse<float>(v10, v9 + 2, &v28);
        float v11 = v28;
        float v12 = v30;
        float v13 = acosf(v29 / sqrtf((float)((float)(v11 * v11) + (float)(v29 * v29)) + (float)(v12 * v12)));
        float v14 = atan2f(v11, v12) + 3.1416;
        float v15 = (float)(v14 - (float)(floorf(v14 / 6.2832) * 6.2832)) + 0.0;
        if (v15 >= 6.2832) {
          float v15 = nextafterf(6.2832, 0.0);
        }
        Phase::Geometry::CardioidDirectivity::CalculateSubbandGains<3ul>(v8, v13, v15);
        return;
      }
LABEL_36:
      std::terminate();
    }
    uint64_t v24 = *(void *)(*((void *)v6 + 5) + 40);
    if (!v24) {
      goto LABEL_36;
    }
    if (a3) {
      __n128 v25 = a6;
    }
    else {
      __n128 v25 = a5;
    }
    if (a3) {
      uint64_t v26 = a5;
    }
    else {
      uint64_t v26 = a6;
    }
    Phase::TransformPositionByInverse<float>(v26, v25 + 2, &v28);
    float v27 = acosf((float)-v30 / sqrtf((float)((float)(v28 * v28) + (float)(v29 * v29)) + (float)(v30 * v30)));
    Phase::Geometry::ConeDirectivity::CalculateSubbandGains<3ul>(v24, v27 + v27);
  }
}

void Phase::Geometry::SystemState::~SystemState(Phase::Geometry::SystemState *this)
{
  uint64_t v8 = (void **)((char *)this + 984);
  std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__destroy_vector::operator()[abi:ne180100](&v8);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 10);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  size_t v5 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  float v6 = (std::__shared_weak_count *)*((void *)this + 4);
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  int v7 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v7) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v7);
  }
}

float Phase::TransformPositionByInverse<float>@<S0>(float32x2_t *a1@<X0>, float32x2_t *a2@<X1>, float *a3@<X8>)
{
  __int32 v3 = a1[1].i32[1];
  *(float *)&unsigned int v4 = -a1[1].f32[0];
  int32x2_t v5 = (int32x2_t)vneg_f32(*a1);
  v10[0] = v5;
  v10[1] = __PAIR64__(v3, v4);
  v5.i32[0] = a1[3].i32[1];
  float v6 = (float)(a2[1].f32[0] - a1[3].f32[0]) / *(float *)v5.i32;
  float32x2_t v8 = vdiv_f32(vsub_f32(*a2, a1[2]), (float32x2_t)vdup_lane_s32(v5, 0));
  float v9 = v6;
  return Phase::operator*<float>((float *)v10, (float *)&v8, a3);
}

void Phase::Geometry::CardioidDirectivity::CalculateSubbandGains<3ul>(uint64_t a1, float a2, float a3)
{
  __asm { FMOV            V1.2S, #1.0 }
  uint64_t v16 = _D1;
  int v17 = 1065353216;
  if (*(_DWORD *)(a1 + 140) >= 3u) {
    unsigned int v9 = 3;
  }
  else {
    unsigned int v9 = *(_DWORD *)(a1 + 140);
  }
  if (v9)
  {
    float v11 = sinf(a2);
    uint64_t v12 = 0;
    float v13 = v11 * cosf(a3);
    uint64_t v14 = 4 * v9;
    do
    {
      float v15 = (float)(1.0 - *(float *)(a1 + v12 + 144)) + (float)(v13 * *(float *)(a1 + v12 + 144));
      if (v15 < 0.0) {
        float v15 = -v15;
      }
      *(float *)((char *)&v16 + vstd::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = powf(v15, *(float *)(a1 + v12 + 272));
      v12 += 4;
    }
    while (v14 != v12);
  }
}

float Phase::Geometry::ConeDirectivity::CalculateSubbandGains<3ul>(uint64_t a1, float a2)
{
  __asm { FMOV            V1.2S, #1.0 }
  int v16 = 1065353216;
  if (*(_DWORD *)(a1 + 140) >= 3u) {
    unsigned int v7 = 3;
  }
  else {
    unsigned int v7 = *(_DWORD *)(a1 + 140);
  }
  if (!v7) {
    return 1.0;
  }
  uint64_t v8 = 0;
  uint64_t v9 = 4 * v7;
  do
  {
    float v10 = *(float *)(a1 + v8 + 144);
    float v11 = *(float *)(a1 + v8 + 272);
    float v12 = v10 - v11;
    if ((float)(v10 - v11) < 0.0) {
      float v12 = -(float)(v10 - v11);
    }
    if (v12 <= 0.001745)
    {
      float v13 = 0.0;
      if (v10 <= a2)
      {
        if (v10 >= a2) {
          float v13 = 0.5;
        }
        else {
          float v13 = 1.0;
        }
      }
    }
    else
    {
      float v13 = fminf(fmaxf((float)(a2 - v10) / (float)(v11 - v10), 0.0), 1.0);
    }
    *(float *)((char *)&v15 + v8) = (float)(1.0 - v13) + (float)(*(float *)(a1 + v8 + 400) * v13);
    v8 += 4;
  }
  while (v9 != v8);
  return *(float *)&v15;
}

float Phase::Geometry::SphericalCapDirectivity::GetSubbandGainsFromDatabase<3ul>(uint64_t a1, float a2, float a3)
{
  float v3 = a2 + -1.5708;
  unsigned int v4 = *(uint64_t **)(a1 + 48);
  float v5 = cosf(a3);
  float v6 = cosf(v3);
  float v7 = acosf(v5 * v6);
  uint64_t ValuesForAllDimensionsAt = Phase::Zeppelin::SphereSampling::NDimEquiangularHalfCircleData<float,double>::GetValuesForAllDimensionsAt(*v4, 0, v7);
  for (uint64_t i = 0; i != 3; ++i)
  {
    float v10 = *(double *)(ValuesForAllDimensionsAt + 8 * i);
    *(&v12 + i) = v10;
  }
  return v12;
}

Phase::Geometry::SystemState *Phase::Geometry::SystemState::SystemState(Phase::Geometry::SystemState *this, Phase::Geometry::SystemState *a2)
{
  *(void *)this = 0;
  *((void *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::operator=((uint64_t)this, (uint64_t *)a2);
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((_DWORD *)this + 10) = 0;
  Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::operator=((uint64_t)this + 24, (uint64_t *)a2 + 3);
  *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((void *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
  *((_DWORD *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::operator=((uint64_t)this + 48, (uint64_t *)a2 + 6);
  *((void *)this + 9) = 0;
  *((void *)this + 10) = 0;
  *((_DWORD *)this + 22) = 0;
  Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::operator=((uint64_t)this + 72, (uint64_t *)a2 + 9);
  *((void *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
  *((void *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0;
  *((_DWORD *)this + 28) = 0;
  Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::operator=((uint64_t)this + 96, (uint64_t *)a2 + 12);
  *((void *)this + 15) = 0;
  *((void *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((_DWORD *)this + 34) = 0;
  Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::operator=((uint64_t)this + 120, (uint64_t *)a2 + 15);
  memcpy((char *)this + 144, (char *)a2 + 144, 0x310uLL);
  long long v5 = *((_OWORD *)a2 + 58);
  long long v4 = *((_OWORD *)a2 + 59);
  *((void *)this + 120) = *((void *)a2 + 120);
  *((_OWORD *)this + 58) = v5;
  *((_OWORD *)this + 59) = v4;
  *(_OWORD *)((char *)this + 968) = *(_OWORD *)((char *)a2 + 968);
  *((void *)this + 123) = 0;
  *((void *)this + 125) = 0;
  *((void *)this + 124) = 0;
  float v6 = (char *)*((void *)a2 + 123);
  float v7 = (char *)*((void *)a2 + 124);
  if (v7 != v6)
  {
    std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__vallocate[abi:ne180100]((void *)this + 123, (v7 - v6) >> 4);
    *((void *)this + 124) = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::shared_ptr<Phase::Geometry::MpsCpuScene>>,std::shared_ptr<Phase::Geometry::MpsCpuScene>*,std::shared_ptr<Phase::Geometry::MpsCpuScene>*,std::shared_ptr<Phase::Geometry::MpsCpuScene>*>((uint64_t)this + 1000, v6, v7, *((void **)this + 124));
  }
  long long v8 = *((_OWORD *)a2 + 63);
  *((void *)this + 128) = *((void *)a2 + 128);
  *((_OWORD *)this + 63) = v8;
  return this;
}

void sub_221EFF080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  v9[124] = v10;
  std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__destroy_vector::operator()[abi:ne180100](&a9);
  float v12 = (std::__shared_weak_count *)v9[16];
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v12);
  }
  float v13 = (std::__shared_weak_count *)v9[13];
  if (v13) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  uint64_t v14 = (std::__shared_weak_count *)v9[10];
  if (v14) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v14);
  }
  uint64_t v15 = (std::__shared_weak_count *)v9[7];
  if (v15) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v15);
  }
  int v16 = (std::__shared_weak_count *)v9[4];
  if (v16) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v16);
  }
  int v17 = (std::__shared_weak_count *)v9[1];
  if (v17) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v17);
  }
  _Unwind_Resume(a1);
}

uint64_t Phase::SharedSlotMapState<Phase::Geometry::Directivity,Phase::Handle64>::operator=(uint64_t a1, uint64_t *a2)
{
  uint64_t v5 = *a2;
  uint64_t v4 = a2[1];
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  float v6 = *(std::__shared_weak_count **)(a1 + 8);
  *(void *)a1 = v5;
  *(void *)(a1 + 8) = v4;
  if (v6) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
  *(_DWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)a2 + 4);
  return a1;
}

char *std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  __n128 result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::shared_ptr<Phase::Geometry::MpsCpuScene>>,std::shared_ptr<Phase::Geometry::MpsCpuScene>*,std::shared_ptr<Phase::Geometry::MpsCpuScene>*,std::shared_ptr<Phase::Geometry::MpsCpuScene>*>(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v9 = a4;
  v7[0] = a1;
  v7[1] = &v9;
  v7[2] = &v10;
  if (a2 != a3)
  {
    do
    {
      void *v4 = *a2;
      uint64_t v5 = a2[1];
      v4[1] = v5;
      if (v5) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      }
      v4 += 2;
      a2 += 2;
    }
    while (a2 != a3);
    uint64_t v10 = v4;
  }
  char v8 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<Phase::Geometry::MpsCpuScene>>,std::shared_ptr<Phase::Geometry::MpsCpuScene>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v7);
  return v4;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<Phase::Geometry::MpsCpuScene>>,std::shared_ptr<Phase::Geometry::MpsCpuScene>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<Phase::Geometry::MpsCpuScene>>,std::shared_ptr<Phase::Geometry::MpsCpuScene>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<Phase::Geometry::MpsCpuScene>>,std::shared_ptr<Phase::Geometry::MpsCpuScene>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    float v3 = *(std::__shared_weak_count **)(v1 - 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 -= 16;
  }
}

void std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__clear[abi:ne180100]((uint64_t *)v2);
    float v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 16)
  {
    uint64_t v4 = *(std::__shared_weak_count **)(i - 8);
    if (v4) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
    }
  }
  a1[1] = v2;
}

void *Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(Phase::Logger *a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    float v20 = **(id **)(Phase::Logger::GetInstance(a1) + 112);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float v22 = 136315394;
      *(void *)&v22[4] = "ManagedPtr.hpp";
      *(_WORD *)&v22[12] = 1024;
      *(_DWORD *)&v22[14] = 229;
      _os_log_impl(&dword_221E5E000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v22, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  float v7 = (char *)Phase::SystemAllocator::Alloc(*(Phase::SystemAllocator **)a3, (Phase::Logger *)(68 * **(void **)(a3 + 8)), **(std::align_val_t **)(a3 + 16));
  char v8 = &v7[68 * a2];
  uint64_t v9 = v7;
  do
  {
    uint64_t v10 = 0;
    unint64_t v11 = 0;
    unint64_t v12 = 0;
    *(void *)uint64_t v9 = 0;
    *((void *)v9 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = 0;
    *((void *)v9 + 2) = 0;
    *((void *)v9 + 3) = 0x7F7FFFFF00000000;
    *((void *)v9 + 4) = 0;
    float v13 = v9 + 32;
    *(void *)float v22 = 0;
    *(_DWORD *)&v22[8] = 0;
    *((_DWORD *)v9 + 10) = 0;
    do
    {
      if (v12 <= 2)
      {
        unint64_t v11 = v12 + 1;
        *(_DWORD *)&v13[4 * v12++] = *(_DWORD *)&v22[v10];
      }
      v10 += 4;
    }
    while (v10 != 12);
    if (v11 <= 2) {
      bzero(&v13[4 * v11], 12 - 4 * v11);
    }
    uint64_t v14 = 0;
    unint64_t v15 = 0;
    unint64_t v16 = 0;
    *((_DWORD *)v9 + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = 0;
    *((void *)v9 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    int v17 = v9 + 48;
    *(void *)float v22 = 0;
    *(_DWORD *)&v22[8] = 0;
    *((_DWORD *)v9 + 14) = 0;
    do
    {
      if (v16 <= 2)
      {
        unint64_t v15 = v16 + 1;
        *(_DWORD *)&v17[4 * v16++] = *(_DWORD *)&v22[v14];
      }
      v14 += 4;
    }
    while (v14 != 12);
    if (v15 <= 2) {
      bzero(&v17[4 * v15], 12 - 4 * v15);
    }
    *((_DWORD *)v9 + 15) = 0;
    *((_DWORD *)v9 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    v9 += 68;
  }
  while (v9 != v8);
  uint64_t v18 = *a4;
  *(void *)float v22 = &unk_26D4748E0;
  *(void *)&v22[8] = v18;
  float v23 = v22;
  *(void *)a1 = v7;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)a1 + 8, (uint64_t)v22);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v22);
}

void sub_221EFF5C4(_Unwind_Exception *exception_object)
{
}

void std::__function::__func<std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D4748E0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4748E0;
  a2[1] = v2;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&>(unsigned long,Phase::SystemAllocator&&,std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::TraceWithEnergyQuery,Phase::SystemAllocator>(Phase::SystemAllocator &,unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::TraceWithEnergyQuery*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, void **a2)
{
}

uint64_t *std::unique_ptr<Phase::SpatialModeler::TraceWithEnergyQuery [],std::function<void ()(void *)>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  uint64_t v5 = *a1;
  *a1 = v4;
  if (v5) {
    std::function<void ()(void *)>::operator()((uint64_t)(a1 + 1), v5);
  }
  std::__function::__value_func<void ()(void *)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

Phase::SpatialModeler::DirectPathTransmission::SourceFrame *Phase::SpatialModeler::DirectPathTransmission::SourceFrame::SourceFrame(Phase::SpatialModeler::DirectPathTransmission::SourceFrame *this, uint64_t a2, double a3)
{
  v20[4] = *MEMORY[0x263EF8340];
  *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  float v6 = (uint64_t *)((char *)this + 48);
  *(void *)this = 0;
  *((void *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
  float v7 = (uint64_t *)((char *)this + 96);
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = 0;
  *((void *)this + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  uint64_t v14 = 4;
  uint64_t v15 = a2;
  unint64_t v12 = &v15;
  float v13 = &v14;
  Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>(a2, (uint64_t)&v12, &v19);
  uint64_t v8 = v19;
  uint64_t v19 = 0;
  uint64_t v16 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v17, (uint64_t)v20);
  uint64_t v18 = a2;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v19);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v20);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)this, &v16);
  *((void *)this + 5) = v18;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v16);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v17);
  unint64_t v12 = (uint64_t *)a2;
  uint64_t v15 = 4;
  Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>,std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbands<float,3ul>*)#1} const&>((Phase::Logger *)&v19, a2, &v12, (std::align_val_t *)&v15);
  uint64_t v9 = v19;
  uint64_t v19 = 0;
  uint64_t v16 = v9;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v17, (uint64_t)v20);
  uint64_t v18 = a2;
  std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v19);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v20);
  std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](v6, &v16);
  *((void *)this + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = v18;
  std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v16);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v17);
  uint64_t v14 = 4;
  uint64_t v15 = a2;
  unint64_t v12 = &v15;
  float v13 = &v14;
  Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>(a2, (uint64_t)&v12, &v19);
  uint64_t v10 = v19;
  uint64_t v19 = 0;
  uint64_t v16 = v10;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v17, (uint64_t)v20);
  uint64_t v18 = a2;
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v19);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v20);
  std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](v7, &v16);
  *((void *)this + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v18;
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v16);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v17);
  *((double *)this + 18) = a3;
  return this;
}

void sub_221EFF914(_Unwind_Exception *a1)
{
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](v2);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v1 + 13);
  std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](v3);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v1 + 7);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](v1);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v1 + 1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::SpatialModeler::DirectPathTransmission::SourceFrame::operator=(uint64_t *a1, void *a2)
{
  v27[4] = *MEMORY[0x263EF8340];
  uint64_t v4 = a2[5];
  if (v4)
  {
    uint64_t v21 = 4;
    uint64_t v22 = v4;
    float v23 = &v22;
    v24[0] = &v21;
    Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>(v4, (uint64_t)&v23, &v26);
    uint64_t v5 = v26;
    uint64_t v26 = 0;
    float v23 = (uint64_t *)v5;
    std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v24, (uint64_t)v27);
    uint64_t v25 = v4;
    std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v26);
    std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v27);
    std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1, (uint64_t *)&v23);
    a1[5] = v25;
    std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v23);
    std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v24);
    float v6 = (_DWORD *)(*a1 + 8);
    float v7 = (int *)(*a2 + 8);
    do
    {
      *(v6 - 2) = *(v7 - 2);
      *(v6 - std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = *(v7 - 1);
      int v8 = *v7;
      v7 += 3;
      *float v6 = v8;
      v6 += 3;
      --v4;
    }
    while (v4);
    uint64_t v9 = a2[5];
    if (v9)
    {
      uint64_t v22 = 4;
      float v23 = (uint64_t *)v9;
      Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>,std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbands<float,3ul>*)#1} const&>((Phase::Logger *)&v26, v9, &v23, (std::align_val_t *)&v22);
      uint64_t v10 = v26;
      uint64_t v26 = 0;
      float v23 = (uint64_t *)v10;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v24, (uint64_t)v27);
      uint64_t v25 = v9;
      std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v26);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v27);
      std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 6, (uint64_t *)&v23);
      a1[11] = v25;
      std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v23);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v24);
      uint64_t v11 = 0;
      do
      {
        unint64_t v12 = (uint64_t *)(a2[6] + v11);
        uint64_t v13 = a1[6] + v11;
        uint64_t v14 = *v12;
        *(_DWORD *)(v13 + 8) = *((_DWORD *)v12 + 2);
        *(void *)uint64_t v13 = v14;
        v11 += 12;
        --v9;
      }
      while (v9);
      uint64_t v15 = a2[5];
      if (v15)
      {
        uint64_t v21 = 4;
        uint64_t v22 = v15;
        float v23 = &v22;
        v24[0] = &v21;
        Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>(v15, (uint64_t)&v23, &v26);
        uint64_t v16 = v26;
        uint64_t v26 = 0;
        float v23 = (uint64_t *)v16;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v24, (uint64_t)v27);
        uint64_t v25 = v15;
        std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v26);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v27);
        std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 12, (uint64_t *)&v23);
        a1[17] = v25;
        std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v23);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v24);
        int v17 = (int *)a2[12];
        uint64_t v18 = (_DWORD *)a1[12];
        do
        {
          int v19 = *v17++;
          *v18++ = v19;
          --v15;
        }
        while (v15);
      }
    }
  }
  a1[18] = a2[18];
  return a1;
}

uint64_t *Phase::SpatialModeler::DirectPathTransmission::SourceFrame::operator=(uint64_t *a1, uint64_t *a2)
{
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1, a2);
  a1[5] = a2[5];
  std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 6, a2 + 6);
  a1[11] = a2[11];
  std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 12, a2 + 12);
  a1[17] = a2[17];
  a1[18] = a2[18];
  return a1;
}

void Phase::SpatialModeler::DirectPathTransmission::GetSupportedQueryDescs(std::string **a1@<X8>)
{
  *(void *)&long long v29 = *MEMORY[0x263EF8340];
  char v14 = 4;
  strcpy((char *)&v13, "CULL");
  uint64_t v15 = 0;
  uint64_t v16 = 0x100000001;
  int v17 = 1;
  memset(v18, 0, sizeof(v18));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v18, 5uLL);
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)v18;
  do
  {
    *(_DWORD *)(v4 + v3) = *(_DWORD *)((char *)&constinit + v3);
    v3 += 4;
  }
  while (v3 != 20);
  v19[23] = 7;
  strcpy(v19, "CLUSTER");
  uint64_t v20 = 1;
  uint64_t v21 = 0x200000003;
  int v22 = 1;
  memset(v23, 0, sizeof(v23));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v23, 5uLL);
  uint64_t v5 = 0;
  uint64_t v6 = *(void *)v23;
  do
  {
    *(_DWORD *)(v6 + v5 * 4) = Phase::SpatialModeler::DirectPathTransmissionPrivate::sClusterQueryPropertyUIDs[v5];
    ++v5;
  }
  while (v5 != 5);
  v24[23] = 7;
  strcpy(v24, "SPATIAL");
  uint64_t v25 = 2;
  uint64_t v26 = 0x300000002;
  int v27 = 2;
  memset(v28, 0, sizeof(v28));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v28, 5uLL);
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)v28;
  do
  {
    *(_DWORD *)(v8 + v7 * 4) = Phase::SpatialModeler::DirectPathTransmissionPrivate::sSpatialQueryPropertyUIDs[v7];
    ++v7;
  }
  while (v7 != 5);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v9 = (std::string *)operator new(0xF0uLL);
  *a1 = v9;
  a1[1] = v9;
  a1[2] = v9 + 10;
  uint64_t v10 = 0;
  a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc*>((uint64_t)(a1 + 2), &v13, &v29, v9);
  do
  {
    uint64_t v11 = (char *)&v13 + v10;
    unint64_t v12 = *(void **)&v28[v10];
    if (v12)
    {
      *((void *)v11 + 2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v12;
      operator delete(v12);
    }
    if (v11[183] < 0) {
      operator delete(*((void **)v11 + 20));
    }
    v10 -= 80;
  }
  while (v10 != -240);
}

void sub_221EFFEB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  *(void *)(v12 + 8) = v13;
  std::vector<Phase::SpatialModeler::QueryDesc>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (uint64_t i = 160; i != -80; i -= 80)
    Phase::SpatialModeler::QueryDesc::~QueryDesc((Phase::SpatialModeler::QueryDesc *)(&a12 + i));
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::DirectPathTransmission::GetEntityShapeTemplates@<X0>(uint64_t *a1@<X8>)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  memset(v13, 0, sizeof(v13));
  int v14 = 1065353216;
  int v15 = 3;
  int v12 = 1;
  int v16 = 1;
  int v18 = 1;
  Phase::UnorderedStringMap<Phase::OptionsValue>::Set((uint64_t)v13, (uint64_t)&Phase::Geometry::MeshOptions::SortPrimitives, (uint64_t)&v16);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<BOOL,int,unsigned int,float,double,Phase::Vector<float,2ul>,Phase::Vector<float,3ul>,Phase::Vector<float,4ul>,std::string,std::vector<unsigned int>,std::vector<unsigned long long>,Phase::UnorderedStringMap<Phase::OptionsValue>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)&v16);
  memset(v17, 0, sizeof(v17));
  int v18 = 1065353216;
  int v19 = 4;
  int v16 = 2;
  memset(v9, 0, sizeof(v9));
  int v10 = 1065353216;
  int v11 = 5;
  int v8 = 1;
  uint64_t v3 = (int *)a1[1];
  if ((unint64_t)v3 >= a1[2])
  {
    uint64_t v4 = (_DWORD *)std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__push_back_slow_path<Phase::SpatialModeler::EntityShapeTemplate const&>(a1, &v12);
  }
  else
  {
    int *v3 = v12;
    std::unordered_map<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,std::allocator<std::pair<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey const,Phase::OptionsValue>>>::unordered_map((uint64_t)(v3 + 2), (uint64_t)v13);
    v3[12] = v15;
    uint64_t v4 = v3 + 14;
    a1[1] = (uint64_t)(v3 + 14);
  }
  a1[1] = (uint64_t)v4;
  if ((unint64_t)v4 >= a1[2])
  {
    uint64_t v5 = (_DWORD *)std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__push_back_slow_path<Phase::SpatialModeler::EntityShapeTemplate const&>(a1, &v16);
  }
  else
  {
    _DWORD *v4 = v16;
    std::unordered_map<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,std::allocator<std::pair<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey const,Phase::OptionsValue>>>::unordered_map((uint64_t)(v4 + 2), (uint64_t)v17);
    v4[12] = v19;
    uint64_t v5 = v4 + 14;
    a1[1] = (uint64_t)v5;
  }
  a1[1] = (uint64_t)v5;
  if ((unint64_t)v5 >= a1[2])
  {
    uint64_t v6 = std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__push_back_slow_path<Phase::SpatialModeler::EntityShapeTemplate const&>(a1, &v8);
  }
  else
  {
    _DWORD *v5 = v8;
    std::unordered_map<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,std::allocator<std::pair<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey const,Phase::OptionsValue>>>::unordered_map((uint64_t)(v5 + 2), (uint64_t)v9);
    v5[12] = v11;
    uint64_t v6 = (uint64_t)(v5 + 14);
    a1[1] = (uint64_t)(v5 + 14);
  }
  a1[1] = v6;
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v9);
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v17);
  return std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v13);
}

void sub_221F0011C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void **a16)
{
  uint64_t v21 = v20;
  *(void *)(v16 + 8) = v21;
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table(v19);
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table(v18);
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table(v17);
  a16 = (void **)v16;
  std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__destroy_vector::operator()[abi:ne180100](&a16);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::DirectPathTransmission::Init(uint64_t a1, Phase::Geometry::System *a2)
{
  uint64_t result = Phase::SpatialModeler::TraceWithEnergyQuery::RegisterQuery(*(Phase::SpatialModeler::TraceWithEnergyQuery **)(a1 + 16), a2);
  *(_DWORD *)(a1 + 44) = result;
  return result;
}

uint64_t Phase::SpatialModeler::DirectPathTransmission::RunQuery@<X0>(uint64_t (***a1)(void)@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v4 = a2[10];
  if (v4 > 2)
  {
    if (a1)
    {
      uint64_t result = (**a1)(a1);
      *(void *)a3 = 2;
      *(void *)(a3 + 8) = result;
      *(_DWORD *)(a3 + 24) = 2;
      return result;
    }
    goto LABEL_16;
  }
  uint64_t v5 = (_DWORD *)a2[11];
  if (!v5 || (uint64_t v6 = Phase::SpatialModeler::DirectPathTransmissionPrivate::QueryTable[v4], *((_DWORD *)v6 + 4) != *v5))
  {
    if (a1)
    {
      uint64_t result = (**a1)(a1);
      uint64_t v10 = 3;
LABEL_15:
      *(void *)a3 = v10;
      *(void *)(a3 + 8) = result;
      *(_DWORD *)(a3 + 24) = 2;
      return result;
    }
LABEL_16:
    std::terminate();
  }
  uint64_t v7 = (_DWORD *)a2[12];
  if (!v7 || *((_DWORD *)v6 + 5) != *v7)
  {
    if (a1)
    {
      uint64_t result = (**a1)(a1);
      uint64_t v10 = 4;
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  int v8 = (uint64_t (*)(void))v6[8];

  return v8();
}

uint64_t Phase::SpatialModeler::DirectPathTransmission::AllocateQueryState@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  unint64_t v2 = *(void *)(a1 + 80);
  if (v2 <= 2)
  {
    uint64_t v3 = (uint64_t (*)(void))Phase::SpatialModeler::DirectPathTransmissionPrivate::QueryTable[v2][7];
    if (v3) {
      return v3();
    }
  }
  *a2 = 0;
  a2[4] = 0;
  return result;
}

uint64_t Phase::SpatialModeler::DirectPathTransmission::GetGraphDescription@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  switch(a1)
  {
    case 2:
      *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x223C933A0](a2, "DirectPathTransmissionSpatialQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 3uLL);
      uint64_t v6 = *(void *)(a2 + 24);
      MEMORY[0x223C933A0](v6, "BeginSpatialQueries");
      *(void *)(v6 + 24) |= 1uLL;
      uint64_t v7 = *(void *)(a2 + 24);
      MEMORY[0x223C933A0](v7 + 32, "RunSpatialSceneQueries");
      *(void *)(v7 + 56) |= 2uLL;
      uint64_t v8 = *(void *)(a2 + 24);
      uint64_t result = MEMORY[0x223C933A0](v8 + 64, "FinishSpatialQueries");
      *(void *)(v8 + 88) |= 0xCuLL;
      return result;
    case 1:
      *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x223C933A0](a2, "DirectPathTransmissionClusterQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t result = MEMORY[0x223C933A0](v4, "FullClusterQueries");
      goto LABEL_7;
    case 0:
      *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x223C933A0](a2, "DirectPathTransmissionCullQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t result = MEMORY[0x223C933A0](v4, "FullCullQueries");
LABEL_7:
      *(void *)(v4 + 24) = 0xFFFFFFFFLL;
      return result;
  }
  *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
  *(_OWORD *)(a2 + 32) = 0uLL;
  *(_OWORD *)a2 = 0uLL;
  return result;
}

void sub_221F00468(_Unwind_Exception *a1)
{
  Phase::SpatialModeler::GraphDescription::~GraphDescription(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::DirectPathTransmission::GetErrorCategory(Phase::SpatialModeler::DirectPathTransmission *this)
{
  return (uint64_t)this + 48;
}

BOOL Phase::SpatialModeler::DirectPathTransmission::IsQueryIndexValid(Phase::SpatialModeler::DirectPathTransmission *this, unint64_t a2)
{
  return a2 < 3;
}

unint64_t Phase::SpatialModeler::DirectPathTransmission::GetHistory@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v105 = *MEMORY[0x263EF8340];
  unint64_t v9 = 0xC6A4A7935BD1E995
     * ((0xC6A4A7935BD1E995
       * ((0x35A98F4D286A90B9 * ((0xC6A4A7935BD1E995 * a2) ^ ((0xC6A4A7935BD1E995 * a2) >> 47)) + 3864292196u) ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * a3) ^ ((0xC6A4A7935BD1E995 * a3) >> 47))))
       + 3864292196u) ^ (0xC6A4A7935BD1E995 * ((0xC6A4A7935BD1E995 * a4) ^ ((0xC6A4A7935BD1E995 * a4) >> 47))))
     + 3864292196u;
  unint64_t v10 = a1 + 64;
  double v93 = (std::__shared_weak_count *)(a1 + 320);
  caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal();
  *(void *)buf = v9;
  unint64_t v11 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le>(v10, buf, 0);
  __int16 v90 = (void *)a1;
  double v89 = (Phase::Logger *)(a1 + 264);
  if (*(void *)(v11 + 16) == v9) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = a1 + 264;
  }
  if (*(unsigned char *)(v12 + 26) != 2)
  {
    char v13 = atomic_load((unint64_t *)(v12 + 40));
    if ((v13 & 1) == 0) {
      goto LABEL_6;
    }
  }
  uint64_t v83 = a2;
  uint64_t v84 = a3;
  uint64_t v85 = a4;
  int v92 = 0;
  int v15 = v90;
  unint64_t v95 = v9;
  while (2)
  {
    uint64_t v16 = (char *)operator new(0xF0uLL);
    *((void *)v16 + 2) = 0;
    *((void *)v16 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = 0;
    *(void *)uint64_t v16 = &unk_26D474B88;
    *((void *)v16 + 3) = 850045863;
    double v91 = v16 + 24;
    *((_OWORD *)v16 + 2) = 0u;
    *((_OWORD *)v16 + 3) = 0u;
    *((_OWORD *)v16 + 4) = 0u;
    *(_OWORD *)(v16 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
    *((void *)v16 + 28) = 0;
    *((_OWORD *)v16 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
    *((_OWORD *)v16 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
    *((_OWORD *)v16 + 8) = 0u;
    *(_OWORD *)(v16 + 168) = 0u;
    *(_OWORD *)(v16 + 184) = 0u;
    *((void *)v16 + 25) = 0;
    *((_OWORD *)v16 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = xmmword_2220A4EB0;
    *((void *)v16 + 29) = 0x3F80000000000000;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v16 + 1, 1uLL, memory_order_relaxed);
    if (v15[10] >= v9 || v15[35] <= v9)
    {
      __break(1u);
      goto LABEL_117;
    }
    __int16 v94 = (std::__shared_weak_count *)v16;
    caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal();
    *(void *)buf = v9;
    unint64_t v17 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le>(v10, buf, 0);
    unint64_t v19 = *(void *)(v17 + 16);
    if (v19 == v9)
    {
      char v20 = 0;
      uint64_t v21 = v94;
      goto LABEL_72;
    }
    unint64_t v22 = v17;
    unint64_t v23 = v18;
    int v24 = 0;
    std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v25 = 0;
    for (uint64_t i = 1; i != 9; ++i)
    {
      if (i == 1)
      {
        int v27 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::random_engine();
        float v28 = v27;
        uint64_t v29 = 0;
        while (1)
        {
          float v30 = (atomic_uchar *)&v27[628 * v29 + 626];
          if ((atomic_exchange(v30, 1u) & 1) == 0) {
            break;
          }
          if (v29 == 3) {
            uint64_t v29 = 0;
          }
          else {
            ++v29;
          }
        }
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v25 = v27[2513];
        std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v31 = v25 - v28[2512];
        if (v31)
        {
          unint64_t v32 = (std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *)&v28[628 * v29];
          unsigned int v33 = v31 + 1;
          if (v31 == -1)
          {
            std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v25 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()((std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *)&v28[628 * v29]);
          }
          else
          {
            uint64_t v34 = __clz(v33);
            uint64_t v35 = 31;
            if (((v33 << v34) & 0x7FFFFFFF) != 0) {
              uint64_t v35 = 32;
            }
            unint64_t v36 = v35 - v34;
            unint64_t v37 = v36 >> 5;
            if ((v36 & 0x1F) != 0) {
              ++v37;
            }
            if (v37 <= v36) {
              unsigned int v38 = 0xFFFFFFFF >> -(v36 / v37);
            }
            else {
              unsigned int v38 = 0;
            }
            do
              std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v39 = std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(v32) & v38;
            while (v39 >= v33);
            std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v25 = v28[2512] + v39;
            int v15 = v90;
          }
          unint64_t v9 = v95;
        }
        atomic_store(0, (unsigned __int8 *)v30);
        int v24 = 3;
      }
      if ((v24 & ~v25) != 0) {
        break;
      }
      v24 *= 4;
    }
    uint64_t v40 = 0;
    uint64_t v41 = v15[42] + 64;
    while (1)
    {
      unint64_t v42 = caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::Sizes[v40];
      if (v42 >= caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::node_sizes[i - 1]) {
        break;
      }
      v41 += 32;
      if (++v40 == 10)
      {
        uint64_t v43 = 0;
        goto LABEL_42;
      }
    }
    uint64_t v88 = v15[42];
    unint64_t v44 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop();
    if (!v44)
    {
      atomic_fetch_add((atomic_uint *volatile)(v88 + 40), 0x801u);
      long long v62 = *(unint64_t **)(v88 + 24);
      if (!v62) {
        long long v62 = *(unint64_t **)(v88 + 16);
      }
      *(_DWORD *)buf = 0;
      long long v63 = (os_unfair_lock_s *)(v88 + 32);
      BOOL v64 = v42 > 0x3FF0;
      unint64_t v65 = (v42 + 7) & 0xFFFFFFFFFFFFFFF8;
      if (v65) {
        char v66 = v64;
      }
      else {
        char v66 = 1;
      }
      while (!v62)
      {
LABEL_102:
        locuint64_t k = v63;
        if (os_unfair_lock_trylock(v63))
        {
          double v75 = (unint64_t *)caulk::alloc::details::caching_page_allocator_base::allocate(*(caulk::alloc::details::caching_page_allocator_base **)(v88 + 8));
          long long v62 = v75;
          v75[1] = v76;
          v75[2] = 0;
          __dmb(0xBu);
          double v77 = (atomic_ullong *)(v88 + 16);
          unint64_t v78 = *(void *)(v88 + 16);
          atomic_store(v78, v75);
          unint64_t v79 = v78;
          atomic_compare_exchange_strong(v77, &v79, (unint64_t)v75);
          if (v79 != v78)
          {
            unint64_t v80 = v79;
            do
            {
              atomic_store(v79, v75);
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v88 + 16), &v80, (unint64_t)v75);
              BOOL v74 = v80 == v79;
              unint64_t v79 = v80;
            }
            while (!v74);
          }
          os_unfair_lock_unlock(lock);
          long long v63 = lock;
        }
        else
        {
          caulk::concurrent::details::spinloop::spin((uint64_t)buf);
          long long v63 = lock;
        }
      }
      unint64_t v67 = (unint64_t)v62;
      while (1)
      {
        if ((v66 & 1) == 0)
        {
          uint64_t v68 = *(void *)(v67 + 16);
          uint64_t v69 = ~((_BYTE)v68 + (_BYTE)v67 + 39) & 7;
          unint64_t v70 = v68 + v65 + v69;
          if (v70 <= 0x3FE0)
          {
            uint64_t v71 = *(void *)(v67 + 16);
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v67 + 16), (unint64_t *)&v71, v70);
            if (v71 == v68)
            {
LABEL_109:
              uint64_t v43 = v67 + 32 + v68 + v69;
              if ((v43 & 7) == 0)
              {
                *(void *)(v88 + 24) = v67;
                atomic_fetch_add((atomic_uint *volatile)(v88 + 40), 0xFFFFFFFF);
                goto LABEL_42;
              }
LABEL_117:
              _os_assert_log();
              _os_crash();
              __break(1u);
            }
            while (1)
            {
              uint64_t v69 = ~((_BYTE)v71 + (_BYTE)v67 + 39) & 7;
              unint64_t v72 = v71 + v65 + v69;
              if (v72 > 0x3FE0) {
                break;
              }
              uint64_t v68 = v71;
              uint64_t v73 = v71;
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v67 + 16), (unint64_t *)&v73, v72);
              BOOL v74 = v73 == v71;
              uint64_t v71 = v73;
              if (v74) {
                goto LABEL_109;
              }
            }
          }
        }
        unint64_t v67 = atomic_load((unint64_t *)v67);
        if (!v67) {
          unint64_t v67 = *(void *)(v88 + 16);
        }
        if (v62 == (unint64_t *)v67) {
          goto LABEL_102;
        }
      }
    }
    uint64_t v43 = (uint64_t)v44;
    atomic_fetch_add((atomic_ullong *volatile)(v41 + 16), 0xFFFFFFFFFFFFFFFFLL);
LABEL_42:
    *(unsigned char *)(v43 + 24) = i;
    *(_WORD *)(v43 + 25) = 1;
    *(unsigned char *)(v43 + 2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = i;
    *(void *)uint64_t v43 = v91;
    *(void *)(v43 + 8) = v94;
    *(void *)(v43 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v9;
    *(void *)(v43 + 40) = 0;
    *(void *)(v43 + 48) = 0;
    *(void *)(v43 + 32) = 0;
    if ((_BYTE)i)
    {
      unint64_t v45 = (unint64_t *)(v43 + 48);
      uint64_t v46 = i;
      do
      {
        atomic_store(0, v45 - 1);
        atomic_store(0, v45);
        v45 += 2;
        --v46;
      }
      while (v46);
    }
    unint64_t v47 = 0;
    __dmb(0xBu);
    while (2)
    {
      if (*(void *)(v22 + 16) == *(void *)(v43 + 16))
      {
        uint64_t v48 = 0;
        goto LABEL_66;
      }
      while (1)
      {
        long long v49 = (unint64_t *)(v22 + 16 * v47 + 40);
        unint64_t v50 = atomic_load(v49);
        if ((v50 & 2) == 0) {
          break;
        }
        caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(v10, v47, v22, v50 & 0xFFFFFFFFFFFFFFFCLL);
LABEL_56:
        unint64_t v54 = *(void *)(v43 + 16);
        while (1)
        {
          unint64_t v55 = atomic_load((unint64_t *)(v22 + 16 * v47 + 40));
          unint64_t v23 = v55 & 0xFFFFFFFFFFFFFFFCLL;
          if (v54 < *(void *)((v55 & 0xFFFFFFFFFFFFFFFCLL) + 16)) {
            break;
          }
          char v56 = atomic_load((unint64_t *)(v23 + 40));
          if (v56)
          {
            unint64_t v22 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(v10, v47, v22, v23);
            if (!v57) {
              caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(v10, v47, v22, v23);
            }
          }
          else
          {
            unint64_t v22 = v23;
          }
        }
        if (*(void *)(v22 + 16) == *(void *)(v43 + 16))
        {
          uint64_t v48 = 0;
          goto LABEL_65;
        }
      }
      atomic_store(v23, (unint64_t *)(v43 + 16 * v47 + 40));
      unint64_t v51 = v23;
      atomic_compare_exchange_strong((atomic_ullong *volatile)v49, &v51, v43);
      if (v51 != v23)
      {
        if ((v51 & 2) != 0) {
          caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(v10, v47, v22, v51 & 0xFFFFFFFFFFFFFFFCLL);
        }
        char v52 = atomic_load(v49);
        if (v52)
        {
          do
          {
            unint64_t v22 = atomic_load((unint64_t *)(v22 + 16 * v47 + 48));
            char v53 = atomic_load((unint64_t *)(v22 + 16 * v47 + 40));
          }
          while ((v53 & 1) != 0);
        }
        goto LABEL_56;
      }
      uint64_t v48 = v43;
LABEL_65:
      unint64_t v9 = v95;
LABEL_66:
      if (v48 | v47)
      {
        unint64_t v19 = atomic_load((unint64_t *)(v43 + 40));
        if ((v19 & 1) == 0 && ++v47 != i)
        {
          *(void *)buf = v9;
          unint64_t v22 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le>(v10, buf, v47);
          unint64_t v23 = v58;
          continue;
        }
        uint64_t v21 = 0;
        char v20 = 1;
      }
      else
      {
        caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::free_node(v93, v43);
        uint64_t v21 = 0;
        char v20 = 0;
      }
      break;
    }
LABEL_72:
    caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal((unint64_t)v93, v19);
    if (v21) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v21);
    }
    if (v20)
    {
      unint64_t add_explicit = (unint64_t)a5;
      *a5 = v91;
      a5[1] = v94;
      return caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal((unint64_t)v93, add_explicit);
    }
    *(void *)buf = v9;
    float32x2_t v59 = (Phase::Logger *)caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le>(v10, buf, 0);
    unint64_t v12 = 0;
    long long v60 = v89;
    if (*((void *)v59 + 2) == v9) {
      long long v60 = v59;
    }
    if (*((unsigned char *)v60 + 26) != 2)
    {
      char v61 = atomic_load((unint64_t *)v60 + 5);
      if (v61) {
        unint64_t v12 = 0;
      }
      else {
        unint64_t v12 = (unint64_t)v60;
      }
    }
    if (v92 != 1000)
    {
      ++v92;
      std::__shared_weak_count::__release_shared[abi:ne180100](v94);
      if (v12)
      {
LABEL_6:
        *a5 = *(void *)v12;
        unint64_t add_explicit = *(void *)(v12 + 8);
        a5[1] = add_explicit;
        if (add_explicit) {
          unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(add_explicit + 8), 1uLL, memory_order_relaxed);
        }
        return caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal((unint64_t)v93, add_explicit);
      }
      continue;
    }
    break;
  }
  double v81 = **(NSObject ***)(Phase::Logger::GetInstance(v59) + 208);
  if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136316162;
    *(void *)&uint8_t buf[4] = "DirectPathTransmissionModeler.cpp";
    __int16 v97 = 1024;
    int v98 = 565;
    __int16 v99 = 2048;
    uint64_t v100 = v83;
    __int16 v101 = 2048;
    uint64_t v102 = v84;
    __int16 v103 = 2048;
    uint64_t v104 = v85;
    _os_log_impl(&dword_221E5E000, v81, OS_LOG_TYPE_ERROR, "%25s:%-5d Failed to add or find a history entry for Source: %llu, Listener: %llu, DistanceModel: %llu.\n", buf, 0x30u);
  }
  *a5 = 0;
  a5[1] = 0;
  std::__shared_weak_count::__release_shared[abi:ne180100](v94);
  return caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal((unint64_t)v93, add_explicit);
}

void sub_221F00D38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_unfair_lock_t lock, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  if (a2)
  {
    os_unfair_lock_unlock(lock);
    atomic_fetch_add((atomic_uint *volatile)(a15 + 40), 0xFFFFFFFF);
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void Phase::SpatialModeler::DirectPathTransmission::~DirectPathTransmission(std::error_category *this)
{
  this->__vftable = (std::error_category_vtbl *)&unk_26D474970;
  unint64_t v2 = this + 6;
  caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::~skiplist((unint64_t)&this[8]);
  std::error_category::~error_category(v2);
  this->__vftable = (std::error_category_vtbl *)&unk_26D471808;
  std::error_category::~error_category(this + 1);
}

{
  std::error_category *v2;
  uint64_t vars8;

  this->__vftable = (std::error_category_vtbl *)&unk_26D474970;
  unint64_t v2 = this + 6;
  caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::~skiplist((unint64_t)&this[8]);
  std::error_category::~error_category(v2);
  this->__vftable = (std::error_category_vtbl *)&unk_26D471808;
  std::error_category::~error_category(this + 1);

  JUMPOUT(0x223C938A0);
}

unint64_t caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal@<X0>(unint64_t result@<X0>, unint64_t a2@<X8>)
{
  _X2 = 0;
  _X3 = 0;
  __asm { CASPAL          X2, X3, X2, X3, [X0] }
  unint64_t v9 = 0;
  for (uint64_t i = _X2; ; uint64_t i = _X2)
  {
    uint64_t v11 = (_X3 - 1);
    a2 = a2 & 0xFFFFFFFF00000000 | v11;
    _X6 = (int)_X3 <= 1 ? 0 : i;
    _X3 = _X3 | (v9 << 32);
    __asm { CASPAL          X2, X3, X6, X7, [X0] }
    if (_X2 == i) {
      break;
    }
    unint64_t v9 = HIDWORD(_X3);
  }
  if (!v11)
  {
    if (i) {
      return caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::free_node_chain_now(result, i);
    }
  }
  return result;
}

unint64_t caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::free_node_chain_now(unint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (std::__shared_weak_count *)result;
    unint64_t v4 = result + 40;
    do
    {
      unint64_t v5 = atomic_load((unint64_t *)(v2 + 32));
      uint64_t shared_owners = v3[1].__shared_owners_;
      if (*(unsigned char *)(shared_owners + 32))
      {
        if (!*(unsigned char *)(v2 + 26)) {
          (*(void (**)(unint64_t, uint64_t))shared_owners)(v4, v2);
        }
      }
      uint64_t result = caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::free_node(v3, v2);
      uint64_t v2 = v5;
    }
    while (v5);
  }
  return result;
}

unint64_t caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::free_node(std::__shared_weak_count *a1, uint64_t a2)
{
  _X20 = (unint64_t *)a2;
  uint64_t v3 = a1;
  uint64_t v4 = *(unsigned __int8 *)(a2 + 24);
  if (*(unsigned char *)(a2 + 25))
  {
    a1 = *(std::__shared_weak_count **)(a2 + 8);
    if (a1) {
      std::__shared_weak_count::__release_shared[abi:ne180100](a1);
    }
  }
  uint64_t v5 = 0;
  uint64_t v6 = v3->__shared_weak_owners_ + 64;
  while ((unint64_t)caulk::alloc::multi_free_list<caulk::alloc::cascading_allocator<caulk::alloc::chunk_allocator<caulk::alloc::global_page_cache,caulk::alloc::serial_allocator,caulk::alloc::embed_block_memory,16384ul>>,caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::size_generator,8ul,1ul,-1l>::Sizes[v5] < caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::node_sizes[v4 - 1])
  {
    v6 += 32;
    if (++v5 == 10) {
      caulk::alloc::base_allocator::bad_dealloc((caulk::alloc::base_allocator *)a1);
    }
  }
  _X2 = 0;
  _X3 = 0;
  __asm { CASPAL          X2, X3, X2, X3, [X8] }
  atomic_store(_X2, _X20);
  _X1 = 0;
  __asm { CASPAL          X0, X1, X20, X21, [X8] }
  if (result != _X2)
  {
    do
    {
      atomic_store(result, _X20);
      _X3 = 0;
      __asm { CASPAL          X2, X3, X20, X21, [X8] }
      unint64_t v18 = _X2 ^ result;
      unint64_t result = _X2;
    }
    while (v18);
  }
  atomic_fetch_add((atomic_ullong *volatile)(v6 + 16), 1uLL);
  return result;
}

void caulk::alloc::base_allocator::bad_dealloc(caulk::alloc::base_allocator *this)
{
  exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
  caulk::alloc::alloc_error::alloc_error(exception, "deallocate() called for unowned block");
}

void sub_221F010EC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::runtime_error *caulk::alloc::alloc_error::alloc_error(std::runtime_error *this, const char *a2)
{
  unint64_t result = std::runtime_error::runtime_error(this, a2);
  result->__vftable = (std::runtime_error_vtbl *)&unk_26D474AD0;
  return result;
}

void caulk::alloc::alloc_error::~alloc_error(std::runtime_error *this)
{
  std::runtime_error::~runtime_error(this);

  JUMPOUT(0x223C938A0);
}

unint64_t caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::~skiplist(unint64_t a1)
{
  unint64_t v2 = a1 + 256;
  caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal();
  for (unint64_t i = atomic_load((unint64_t *)(a1 + 40)); ; unint64_t i = atomic_load((unint64_t *)(v4 + 40)))
  {
    unint64_t v4 = i & 0xFFFFFFFFFFFFFFFCLL;
    if (a1 + 200 == (i & 0xFFFFFFFFFFFFFFFCLL)) {
      break;
    }
    if (*(unsigned char *)(v4 + 26) != 2)
    {
      char v5 = atomic_load((unint64_t *)(v4 + 40));
      if ((v5 & 1) == 0)
      {
        uint64_t v6 = *(void *)(v4 + 16);
        caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal();
        uint64_t v29 = v6;
        uint64_t v7 = -1;
        uint64_t v8 = 56;
        do
        {
          unint64_t v9 = atomic_load((unint64_t *)(a1 + v8));
          ++v7;
          v8 += 16;
        }
        while (*(unsigned char *)((v9 & 0xFFFFFFFFFFFFFFFCLL) + 26) != 2);
        unint64_t v10 = a1;
        if (v7)
        {
          unint64_t v10 = a1;
          do
            unint64_t v10 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_lt &>(a1, v7--, v10, &v29);
          while (v7);
        }
        unint64_t v11 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_lt &>(a1, 0, v10, &v29);
        unint64_t v13 = *(void *)(v12 + 16);
        if (v13 == v6)
        {
          uint64_t v14 = v12;
          unint64_t v15 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(a1, 0, v11, v12);
          uint64_t v17 = v16;
          if (!v16) {
            caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(a1, 0, v15, v14);
          }
          if (v14)
          {
            unint64_t v13 = v17 & 0xFF00000000;
            if ((v17 & 0xFF00000000) != 0)
            {
              uint64_t v29 = v6;
              caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le>(a1, &v29, 0);
            }
          }
        }
        caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v2, v13);
      }
    }
  }
  caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::end_traversal(v2, i);
  if (*(unsigned char *)(a1 + 25))
  {
    unint64_t v18 = *(std::__shared_weak_count **)(a1 + 8);
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
  }
  if (*(unsigned char *)(a1 + 225))
  {
    unint64_t v19 = *(std::__shared_weak_count **)(a1 + 208);
    if (v19) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v19);
    }
  }
  _X2 = 0;
  _X3 = 0;
  __asm { CASPAL          X2, X3, X2, X3, [X20] }
  if (_X2) {
    caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::free_node_chain_now(v2, _X2);
  }
  (*(void (**)(unint64_t))(*(void *)(a1 + 288) + 24))(a1 + 296);
  int v27 = *(std::__shared_weak_count **)(a1 + 280);
  if (v27) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v27);
  }
  return a1;
}

unint64_t caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_to_level<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le>(unint64_t a1, void *a2, unint64_t a3)
{
  unint64_t v6 = -1;
  uint64_t v7 = 56;
  do
  {
    do
    {
      ++v6;
      unint64_t v8 = atomic_load((unint64_t *)(a1 + v7));
      v7 += 16;
    }
    while (v6 < a3);
  }
  while (*(unsigned char *)((v8 & 0xFFFFFFFFFFFFFFFCLL) + 26) != 2);
  unint64_t v9 = a1;
  if (v6 > a3)
  {
    unint64_t v9 = a1;
    do
      unint64_t v9 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le &>(a1, v6--, v9, a2);
    while (v6 > a3);
  }

  return caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le &>(a1, a3, v9, a2);
}

void caulk::concurrent::details::node_allocator<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10ul,(caulk::concurrent::skiplist_options)0>::begin_traversal()
{
  _X4 = 0;
  _X5 = 0;
  __asm { CASPAL          X4, X5, X4, X5, [X0] }
  _X6 = _X4;
  _X3 = 0;
  __asm { CASPAL          X2, X3, X6, X7, [X0] }
  if (_X2 != _X4)
  {
    do
    {
      _X4 = _X2;
      _X7 = 0;
      __asm { CASPAL          X6, X7, X4, X5, [X0] }
      uint64_t v13 = _X6 ^ _X2;
      _X2 = _X6;
    }
    while (v13);
  }
}

unint64_t caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_lt &>(unint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  unint64_t v4 = a3;
  unint64_t v5 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
  unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (*a4 > *(void *)((v5 & 0xFFFFFFFFFFFFFFFCLL) + 16))
  {
    do
    {
      char v10 = atomic_load((unint64_t *)(v6 + 40));
      if (v10)
      {
        unint64_t v4 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(a1, a2, v4, v6);
        if (!v11) {
          caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(a1, a2, v4, v6);
        }
      }
      else
      {
        unint64_t v4 = v6;
      }
      unint64_t v12 = atomic_load((unint64_t *)(v4 + 16 * a2 + 40));
      unint64_t v6 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (*a4 > *(void *)((v12 & 0xFFFFFFFFFFFFFFFCLL) + 16));
  }
  return v4;
}

unint64_t caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v8 = a4 | 2;
  do
  {
    unint64_t v9 = (unint64_t *)(a3 + 16 * a2 + 40);
    unint64_t v10 = atomic_load(v9);
    if (v10 == v8) {
      break;
    }
    uint64_t v11 = a4;
    atomic_compare_exchange_strong((atomic_ullong *volatile)v9, (unint64_t *)&v11, v8);
    if (v11 == a4 || v11 == v8) {
      break;
    }
    char v12 = atomic_load(v9);
    if (v12)
    {
      do
      {
        a3 = atomic_load((unint64_t *)(a3 + 16 * a2 + 48));
        char v13 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
      }
      while ((v13 & 1) != 0);
    }
    unint64_t v14 = *(void *)(a4 + 16);
    while (1)
    {
      unint64_t v15 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
      unint64_t v16 = v15 & 0xFFFFFFFFFFFFFFFCLL;
      if (v14 <= *(void *)((v15 & 0xFFFFFFFFFFFFFFFCLL) + 16)) {
        break;
      }
      char v17 = atomic_load((unint64_t *)(v16 + 40));
      if (v17)
      {
        a3 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(a1, a2, a3, v16);
        if (!v18) {
          caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(a1, a2, a3, v16);
        }
      }
      else
      {
        a3 = v16;
      }
    }
  }
  while (v16 == a4);
  return a3;
}

unint64_t caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(unint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  _X20 = a4;
  unint64_t v7 = result;
  uint64_t v8 = a4 + 16 * a2;
  unint64_t v9 = (unint64_t *)(v8 + 40);
  atomic_store(a3, (unint64_t *)(v8 + 48));
  while (1)
  {
    char v10 = atomic_load(v9);
    if (v10) {
      break;
    }
    unint64_t v11 = atomic_load(v9);
    unint64_t v12 = v11 & 0xFFFFFFFFFFFFFFFCLL;
    atomic_compare_exchange_strong((atomic_ullong *volatile)v9, &v12, v12 | 1);
    if ((v12 & 2) != 0) {
      unint64_t result = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(v7, a2, _X20, v12 & 0xFFFFFFFFFFFFFFFCLL);
    }
  }
  unint64_t v13 = atomic_load(v9);
  uint64_t v14 = _X20 | 2;
  atomic_compare_exchange_strong((atomic_ullong *volatile)(a3 + 16 * a2 + 40), (unint64_t *)&v14, v13 & 0xFFFFFFFFFFFFFFFCLL);
  if (v14 == (_X20 | 2) && atomic_fetch_add((atomic_uchar *volatile)(_X20 + 27), 0xFFu) == 1)
  {
    _X2 = 0;
    _X3 = 0;
    __asm { CASPAL          X2, X3, X2, X3, [X8] }
    atomic_store(_X2, (unint64_t *)(_X20 + 32));
    _X1 = 0;
    __asm { CASPAL          X0, X1, X20, X21, [X8] }
    if (result != _X2)
    {
      do
      {
        atomic_store(result, (unint64_t *)(_X20 + 32));
        _X3 = 0;
        __asm { CASPAL          X2, X3, X20, X21, [X8] }
        unint64_t v25 = _X2 ^ result;
        unint64_t result = _X2;
      }
      while (v25);
    }
  }
  return result;
}

unint64_t caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::search_right<caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::key_le &>(unint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  unint64_t v4 = a3;
  unint64_t v5 = atomic_load((unint64_t *)(a3 + 16 * a2 + 40));
  unint64_t v6 = v5 & 0xFFFFFFFFFFFFFFFCLL;
  if (*a4 >= *(void *)((v5 & 0xFFFFFFFFFFFFFFFCLL) + 16))
  {
    do
    {
      char v10 = atomic_load((unint64_t *)(v6 + 40));
      if (v10)
      {
        unint64_t v4 = caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::try_flag_node(a1, a2, v4, v6);
        if (!v11) {
          caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::help_flagged(a1, a2, v4, v6);
        }
      }
      else
      {
        unint64_t v4 = v6;
      }
      unint64_t v12 = atomic_load((unint64_t *)(v4 + 16 * a2 + 40));
      unint64_t v6 = v12 & 0xFFFFFFFFFFFFFFFCLL;
    }
    while (*a4 >= *(void *)((v12 & 0xFFFFFFFFFFFFFFFCLL) + 16));
  }
  return v4;
}

void *Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    unint64_t v7 = **(NSObject ***)(Phase::Logger::GetInstance(0) + 112);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t v9 = 136315394;
      *(void *)&v9[4] = "ManagedPtr.hpp";
      __int16 v10 = 1024;
      int v11 = 229;
      _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v9, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  unint64_t v5 = operator new(12 * **(void **)a2, **(std::align_val_t **)(a2 + 8));
  bzero(v5, 12 * ((12 * a1 - 12) / 0xCuLL) + 12);
  *(void *)unint64_t v9 = &unk_26D474AF8;
  v9[8] = 0;
  unint64_t v12 = v9;
  *a3 = v5;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v9);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v9);
}

void sub_221F019D0(_Unwind_Exception *exception_object)
{
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_6VectorIfLm3EEERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_ED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_6VectorIfLm3EEERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEv(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  *(void *)unint64_t result = &unk_26D474AF8;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_6VectorIfLm3EEERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEPNS0_6__baseISD_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D474AF8;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_6VectorIfLm3EEERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_EclEOSC_(uint64_t a1, void **a2)
{
}

void *Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>,std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::PackedSubbands<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbands<float,3ul>*)#1} const&>(Phase::Logger *a1, uint64_t a2, void *a3, std::align_val_t *a4)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    uint64_t v8 = **(NSObject ***)(Phase::Logger::GetInstance(a1) + 112);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)__int16 v10 = 136315394;
      *(void *)&v10[4] = "ManagedPtr.hpp";
      __int16 v11 = 1024;
      int v12 = 229;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v10, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  unint64_t v6 = operator new(12 * *a3, *a4);
  bzero(v6, 12 * ((12 * a2 - 12) / 0xCuLL) + 12);
  *(void *)__int16 v10 = &unk_26D474B40;
  v10[8] = 0;
  uint64_t v13 = v10;
  *(void *)a1 = v6;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)a1 + 8, (uint64_t)v10);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v10);
}

void sub_221F01C10(_Unwind_Exception *exception_object)
{
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14PackedSubbandsIfLm3EEERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_ED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14PackedSubbandsIfLm3EEERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEv(uint64_t a1)
{
  unint64_t result = operator new(0x10uLL);
  *(void *)unint64_t result = &unk_26D474B40;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14PackedSubbandsIfLm3EEERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEPNS0_6__baseISD_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D474B40;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14PackedSubbandsIfLm3EEERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_EclEOSC_(uint64_t a1, void **a2)
{
}

uint64_t *std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]<Phase::PackedSubbands<float,3ul>*,0>(a1, v4);
  std::__function::__value_func<void ()(void *)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

uint64_t *std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]<Phase::PackedSubbands<float,3ul>*,0>(uint64_t *result, uint64_t a2)
{
  uint64_t v3 = *result;
  *unint64_t result = a2;
  if (v3) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v3);
  }
  return result;
}

void std::vector<unsigned int>::resize(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __sz)
{
  std::vector<unsigned int>::size_type v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2) {
      this->__end_ = &this->__begin_[__sz];
    }
  }
  else
  {
    std::vector<unsigned int>::__append(this, __sz - v2);
  }
}

void std::vector<unsigned int>::__append(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  unint64_t v5 = value;
  end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    begiuint64_t n = this->__begin_;
    uint64_t v9 = (char *)end - (char *)this->__begin_;
    unint64_t v10 = __n + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v13);
      begiuint64_t n = this->__begin_;
      end = this->__end_;
    }
    else
    {
      uint64_t v14 = 0;
    }
    unint64_t v15 = &v14[4 * v11];
    unint64_t v16 = (unsigned int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    char v17 = (unsigned int *)&v15[4 * __n];
    while (end != begin)
    {
      int v18 = *--end;
      *((_DWORD *)v15 - std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<unsigned int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

std::string *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc*>(uint64_t a1, long long *a2, long long *a3, std::string *this)
{
  uint64_t v4 = this;
  uint64_t v11 = this;
  uint64_t v12 = this;
  v9[0] = a1;
  v9[1] = &v11;
  _OWORD v9[2] = &v12;
  char v10 = 0;
  if (a2 != a3)
  {
    unint64_t v6 = a2;
    int v7 = a1;
    do
    {
      std::allocator<Phase::SpatialModeler::QueryDesc>::construct[abi:ne180100]<Phase::SpatialModeler::QueryDesc,Phase::SpatialModeler::QueryDesc const&>(v7, v4, v6);
      v6 += 5;
      uint64_t v4 = (std::string *)((char *)v12 + 80);
      uint64_t v12 = (std::string *)((char *)v12 + 80);
    }
    while (v6 != a3);
  }
  char v10 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v9);
  return v4;
}

void sub_221F01F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc*>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc*>::operator()[abi:ne180100](uint64_t *a1)
{
  std::vector<unsigned int>::size_type v2 = (uint64_t *)a1[1];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v4 = *v2;
  if (*v1 != *v2)
  {
    uint64_t v5 = *a1;
    do
    {
      v3 -= 80;
      std::allocator<Phase::SpatialModeler::QueryDesc>::destroy[abi:ne180100](v5, v3);
    }
    while (v3 != v4);
  }
}

uint64_t std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__push_back_slow_path<Phase::SpatialModeler::EntityShapeTemplate const&>(uint64_t *a1, _DWORD *a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x492492492492492) {
    std::vector<Phase::SpatialModeler::OptionalPropertyDescription>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x249249249249249) {
    unint64_t v9 = 0x492492492492492;
  }
  else {
    unint64_t v9 = v5;
  }
  char v17 = a1 + 2;
  if (v9) {
    char v10 = std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::EntityShapeTemplate>>(v7, v9);
  }
  else {
    char v10 = 0;
  }
  uint64_t v11 = &v10[14 * v4];
  v14[0] = v10;
  v14[1] = v11;
  unint64_t v15 = v11;
  unint64_t v16 = (char *)&v10[14 * v9];
  _DWORD *v11 = *a2;
  std::unordered_map<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,std::allocator<std::pair<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey const,Phase::OptionsValue>>>::unordered_map((uint64_t)(v11 + 2), (uint64_t)(a2 + 2));
  v10[14 * v4 + 12] = a2[12];
  v15 += 14;
  std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__swap_out_circular_buffer(a1, v14);
  uint64_t v12 = a1[1];
  std::__split_buffer<Phase::SpatialModeler::EntityShapeTemplate>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_221F020E4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Phase::SpatialModeler::EntityShapeTemplate>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = *result;
  uint64_t v4 = result[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    int v7 = *(_DWORD *)(v4 - 56);
    v4 -= 56;
    *(_DWORD *)(v6 - 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v7;
    v6 -= 56;
    unint64_t result = (uint64_t *)std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::__hash_table(v6 + 8, (uint64_t *)(v4 + 8));
    *(_DWORD *)(v6 + 48) = *(_DWORD *)(v4 + 48);
  }
  a2[1] = v6;
  uint64_t v8 = *v3;
  uint64_t *v3 = v6;
  a2[1] = v8;
  uint64_t v9 = v3[1];
  v3[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = v3[2];
  v3[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

void std::__shared_ptr_emplace<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D474B88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D474B88;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

void std::__shared_ptr_emplace<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>::__on_zero_shared(uint64_t a1)
{
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(a1 + 136));
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)(a1 + 144));
  std::vector<unsigned int>::size_type v2 = *(std::__shared_weak_count **)(a1 + 128);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *(void **)(a1 + 96);
  if (v3)
  {
    *(void *)(a1 + 104) = v3;
    operator delete(v3);
  }

  std::mutex::~mutex((std::mutex *)(a1 + 24));
}

void *caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::random_engine()
{
  {
    caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::multi_simple_random((uint64_t)&caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::random_engine(void)::engine, 0, -1);
  }
  return &caulk::concurrent::skiplist<unsigned long,std::shared_ptr<Phase::SpatialModeler::DirectPathTransmission::SourceHistory>,10,(caulk::concurrent::skiplist_options)0>::random_engine(void)::engine;
}

void sub_221F022D8(_Unwind_Exception *a1)
{
}

uint64_t caulk::multi_simple_random<unsigned int,4ul,std::uniform_int_distribution<unsigned int>,std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>::multi_simple_random(uint64_t a1, int a2, int a3)
{
  uint64_t v4 = 0;
  uint64_t v5 = a1;
  do
  {
    uint64_t v6 = a1 + 2512 * v4;
    unsigned int v7 = 5489;
    *(_DWORD *)uint64_t v6 = 5489;
    for (uint64_t i = 1; i != 624; ++i)
    {
      unsigned int v7 = i + 1812433253 * (v7 ^ (v7 >> 30));
      *(_DWORD *)(v5 + 4 * i) = v7;
    }
    *(void *)(v6 + 249std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    *(unsigned char *)(a1 + 2512 * v4++ + 2504) = 0;
    v5 += 2512;
  }
  while (v4 != 4);
  uint64_t v9 = 0;
  *(_DWORD *)(a1 + 10048) = a2;
  *(_DWORD *)(a1 + 10052) = a3;
  uint64_t v10 = a1;
  do
  {
    unsigned int v11 = mach_absolute_time();
    *(_DWORD *)uint64_t v10 = v11;
    for (uint64_t j = 1; j != 624; ++j)
    {
      unsigned int v11 = j + 1812433253 * (v11 ^ (v11 >> 30));
      *(_DWORD *)(v10 + 4 * j) = v11;
    }
    *(void *)(v10 + 249std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    ++v9;
    v10 += 2512;
  }
  while (v9 != 4);
  return a1;
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  size_t i = this->__i_;
  size_t v2 = (i + 1) % 0x270;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3 = this->__x_[(i + 397) % 0x270] ^ ((this->__x_[v2] & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1) ^ ((int)(this->__x_[v2] << 31) >> 31) & 0x9908B0DF;
  this->__x_[i] = v3;
  this->__i_ = v2;
  LODWORD(i) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return (i << 15) & 0xEFC60000 ^ i ^ (((i << 15) & 0xEFC60000 ^ i) >> 18);
}

unint64_t *caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop()
{
  _X0 = 0;
  _X1 = 0;
  __asm { CASPAL          X0, X1, X0, X1, [X8] }
  if (result)
  {
    unsigned int v7 = result;
    do
    {
      _X6 = atomic_load(result);
      _X5 = 0;
      __asm { CASPAL          X4, X5, X6, X7, [X8] }
      if (_X4 == v7) {
        break;
      }
      unint64_t result = _X4;
      unsigned int v7 = _X4;
    }
    while (_X4);
  }
  return result;
}

uint64_t caulk::concurrent::details::spinloop::spin(uint64_t this)
{
  int v1 = *(_DWORD *)this + 1;
  *(_DWORD *)this = v1;
  if (v1 == 100)
  {
    size_t v2 = (_DWORD *)this;
    this = sched_yield();
    _DWORD *v2 = 0;
  }
  return this;
}

uint64_t Phase::Dispatch::ClientTransactionManager::ClientTransactionManager(uint64_t a1, uint64_t a2, uint64_t a3, Phase::Dispatch::ExternalStreamClientInterface *a4, uint64_t a5, Phase::Dispatch::TapsClientInterface *a6, uint64_t a7, Phase::Controller::TaskManager *a8)
{
  uint64_t v14 = Phase::Dispatch::GeometryClientCommandProcessor::GeometryClientCommandProcessor(a1, a3);
  Phase::ActionTreeClientCommandProcessor::ActionTreeClientCommandProcessor(v14 + 88, a2);
  Phase::Dispatch::TransactionExecutor<Phase::Dispatch::MiscServerMessageType>::TransactionExecutor(a1 + 176);
  *(void *)(a1 + 17std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = &unk_26D475BE0;
  *(void *)(a1 + 25std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a5;
  Phase::Dispatch::ExternalStreamClientCommandProcessor::ExternalStreamClientCommandProcessor((Phase::Dispatch::ExternalStreamClientCommandProcessor *)(a1 + 264), a4);
  Phase::Dispatch::TapsClientCommandProcessor::TapsClientCommandProcessor((Phase::Dispatch::TapsClientCommandProcessor *)(a1 + 352), a6, a8);
  Phase::Dispatch::TransactionWriter<Phase::ActionTreeServerCommand>::TransactionWriter((std::vector<char> *)(a1 + 448), 0x20000uLL);
  return a1;
}

void sub_221F025B0(_Unwind_Exception *a1)
{
  Phase::Dispatch::TapsClientCommandProcessor::~TapsClientCommandProcessor(v5);
  Phase::Dispatch::ExternalStreamClientCommandProcessor::~ExternalStreamClientCommandProcessor(v4);
  Phase::Dispatch::MiscClientCommandProcessor::~MiscClientCommandProcessor(v3);
  Phase::ActionTreeClientCommandProcessor::~ActionTreeClientCommandProcessor(v2);
  Phase::Dispatch::GeometryClientCommandProcessor::~GeometryClientCommandProcessor(v1);
  _Unwind_Resume(a1);
}

void Phase::Dispatch::TapsClientCommandProcessor::~TapsClientCommandProcessor(id *this)
{
  *this = &unk_26D474C38;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table((uint64_t)(this + 1));
}

{
  uint64_t vars8;

  *this = &unk_26D474C38;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table((uint64_t)(this + 1));

  JUMPOUT(0x223C938A0);
}

void Phase::Dispatch::ExternalStreamClientCommandProcessor::~ExternalStreamClientCommandProcessor(id *this)
{
  *this = &unk_26D474BC0;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table((uint64_t)(this + 1));
}

{
  uint64_t vars8;

  *this = &unk_26D474BC0;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table((uint64_t)(this + 1));

  JUMPOUT(0x223C938A0);
}

void Phase::Dispatch::MiscClientCommandProcessor::~MiscClientCommandProcessor(id *this)
{
  *this = &unk_26D474C10;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table((uint64_t)(this + 1));
}

{
  uint64_t vars8;

  *this = &unk_26D474C10;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table((uint64_t)(this + 1));

  JUMPOUT(0x223C938A0);
}

void Phase::Dispatch::GeometryClientCommandProcessor::~GeometryClientCommandProcessor(id *this)
{
  *this = &unk_26D474BE8;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table((uint64_t)(this + 1));
}

{
  uint64_t vars8;

  *this = &unk_26D474BE8;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table((uint64_t)(this + 1));

  JUMPOUT(0x223C938A0);
}

void Phase::Dispatch::ClientTransactionManager::AddTransaction(id *a1, uint64_t a2, void *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v5 = a3;
  uint64_t v6 = v5;
  if (v5 && (uint64_t v5 = (Phase::Logger *)[(Phase::Logger *)v5 length]) != 0)
  {
    switch(a2)
    {
      case 0:
        id v7 = a1[20];
        uint64_t v8 = v6;
        objc_sync_enter(v7);
        [a1[20] addObject:v8];
        goto LABEL_11;
      case 1:
        id v7 = a1[9];
        uint64_t v8 = v6;
        objc_sync_enter(v7);
        [a1[9] addObject:v8];
        goto LABEL_11;
      case 2:
        id v7 = a1[31];
        uint64_t v8 = v6;
        objc_sync_enter(v7);
        [a1[31] addObject:v8];
        goto LABEL_11;
      case 3:
        id v7 = a1[42];
        uint64_t v8 = v6;
        objc_sync_enter(v7);
        [a1[42] addObject:v8];
        goto LABEL_11;
      case 4:
        id v7 = a1[53];
        uint64_t v8 = v6;
        objc_sync_enter(v7);
        [a1[53] addObject:v8];
LABEL_11:

        objc_sync_exit(v7);
        break;
      default:
        break;
    }
  }
  else
  {
    uint64_t v9 = **(id **)(Phase::Logger::GetInstance(v5) + 832);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      int v10 = 136315650;
      unsigned int v11 = "DispatcherClientTransactionManager.mm";
      __int16 v12 = 1024;
      int v13 = 129;
      __int16 v14 = 2048;
      unint64_t v15 = a1;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d ctm@%p: Error: trying to add empty transaction to manager!", (uint8_t *)&v10, 0x1Cu);
    }
  }
}

void sub_221F02950(_Unwind_Exception *a1)
{
  objc_sync_exit(v2);
  _Unwind_Resume(a1);
}

void Phase::Dispatch::TransactionExecutor<Phase::Dispatch::GeometryServerMessageType>::ExecuteTransactions(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v2 = *(id *)(a1 + 72);
  objc_sync_enter(v2);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = *(id *)(a1 + 72);
  uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v11;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v3);
        }
        id v7 = *(id *)(*((void *)&v10 + 1) + 8 * v6);
        uint64_t v8 = objc_msgSend(v7, "bytes", (void)v10);
        uint64_t v9 = [v7 length];
        *(void *)(a1 + 48) = v8;
        *(void *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v9;
        *(void *)(a1 + 64) = 0;
        Phase::MessagePipeReader<Phase::Dispatch::GeometryServerMessageType>::Execute((uint64_t *)(a1 + 48), (void *)(a1 + 8));

        ++v6;
      }
      while (v4 != v6);
      uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v4);
  }

  [*(id *)(a1 + 72) removeAllObjects];
  objc_sync_exit(v2);
}

void sub_221F02B04(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void Phase::Dispatch::TransactionExecutor<Phase::Dispatch::MiscServerMessageType>::ExecuteTransactions(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v2 = *(id *)(a1 + 72);
  objc_sync_enter(v2);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = *(id *)(a1 + 72);
  uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v11;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v3);
        }
        id v7 = *(id *)(*((void *)&v10 + 1) + 8 * v6);
        uint64_t v8 = objc_msgSend(v7, "bytes", (void)v10);
        uint64_t v9 = [v7 length];
        *(void *)(a1 + 48) = v8;
        *(void *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v9;
        *(void *)(a1 + 64) = 0;
        Phase::MessagePipeReader<Phase::ActionTreeServerCommand>::Execute((uint64_t *)(a1 + 48), (void *)(a1 + 8));

        ++v6;
      }
      while (v4 != v6);
      uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v4);
  }

  [*(id *)(a1 + 72) removeAllObjects];
  objc_sync_exit(v2);
}

void sub_221F02CA0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void Phase::Dispatch::TransactionExecutor<Phase::Dispatch::ExternalStreamServerMessageType>::ExecuteTransactions(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v2 = *(id *)(a1 + 72);
  objc_sync_enter(v2);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = *(id *)(a1 + 72);
  uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v11;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v3);
        }
        id v7 = *(id *)(*((void *)&v10 + 1) + 8 * v6);
        uint64_t v8 = objc_msgSend(v7, "bytes", (void)v10);
        uint64_t v9 = [v7 length];
        *(void *)(a1 + 48) = v8;
        *(void *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v9;
        *(void *)(a1 + 64) = 0;
        Phase::MessagePipeReader<Phase::ActionTreeServerCommand>::Execute((uint64_t *)(a1 + 48), (void *)(a1 + 8));

        ++v6;
      }
      while (v4 != v6);
      uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v4);
  }

  [*(id *)(a1 + 72) removeAllObjects];
  objc_sync_exit(v2);
}

void sub_221F02E3C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

void Phase::Dispatch::TransactionExecutor<Phase::Dispatch::TapsServerMessageType>::ExecuteTransactions(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  id v2 = *(id *)(a1 + 72);
  objc_sync_enter(v2);
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  id v3 = *(id *)(a1 + 72);
  uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    uint64_t v5 = *(void *)v11;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v11 != v5) {
          objc_enumerationMutation(v3);
        }
        id v7 = *(id *)(*((void *)&v10 + 1) + 8 * v6);
        uint64_t v8 = objc_msgSend(v7, "bytes", (void)v10);
        uint64_t v9 = [v7 length];
        *(void *)(a1 + 48) = v8;
        *(void *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v9;
        *(void *)(a1 + 64) = 0;
        Phase::MessagePipeReader<Phase::ActionTreeServerCommand>::Execute((uint64_t *)(a1 + 48), (void *)(a1 + 8));

        ++v6;
      }
      while (v4 != v6);
      uint64_t v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v4);
  }

  [*(id *)(a1 + 72) removeAllObjects];
  objc_sync_exit(v2);
}

void sub_221F02FD8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);

  _Unwind_Resume(a1);
}

uint64_t Phase::Dispatch::TransactionExecutor<Phase::Dispatch::TapsServerMessageType>::~TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474C38;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);
  return a1;
}

{
  *(void *)a1 = &unk_26D474C38;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);
  return a1;
}

void Phase::Dispatch::TransactionExecutor<Phase::Dispatch::TapsServerMessageType>::~TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474C38;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Dispatch::TransactionExecutor<Phase::Dispatch::ExternalStreamServerMessageType>::~TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474BC0;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);
  return a1;
}

{
  *(void *)a1 = &unk_26D474BC0;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);
  return a1;
}

void Phase::Dispatch::TransactionExecutor<Phase::Dispatch::ExternalStreamServerMessageType>::~TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474BC0;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Dispatch::TransactionExecutor<Phase::Dispatch::MiscServerMessageType>::~TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474C10;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);
  return a1;
}

void Phase::Dispatch::TransactionExecutor<Phase::Dispatch::MiscServerMessageType>::~TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474C10;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Dispatch::TransactionExecutor<Phase::Dispatch::GeometryServerMessageType>::~TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474BE8;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);
  return a1;
}

{
  *(void *)a1 = &unk_26D474BE8;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);
  return a1;
}

void Phase::Dispatch::TransactionExecutor<Phase::Dispatch::GeometryServerMessageType>::~TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474BE8;

  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(a1 + 8);

  JUMPOUT(0x223C938A0);
}

std::vector<char> *Phase::Dispatch::TransactionWriter<Phase::ActionTreeServerCommand>::TransactionWriter(std::vector<char> *this, std::vector<char>::size_type a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  this[3].__end_ = 0;
  *(_OWORD *)&this->__begin_ = 0u;
  *(_OWORD *)&this->__end_cap_.__value_ = 0u;
  *(_OWORD *)&this[1].__end_ = 0u;
  this[2].__begin_ = 0;
  if (a2)
  {
    std::vector<char>::__append(this, a2);
    begiuint64_t n = this->__begin_;
    value = this->__end_cap_.__value_;
  }
  else
  {
    value = 0;
    begiuint64_t n = 0;
  }
  this[1].__begin_ = begin;
  this[1].__end_ = 0;
  this[1].__end_cap_.__value_ = (char *)(value - begin);
  this[2].__begin_ = (std::vector<char>::pointer)this;
  v6[0] = &unk_26D471118;
  v6[1] = Phase::Dispatch::sMessageWriterCallback;
  v6[3] = v6;
  std::function<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::operator=(&this[2].__end_, (uint64_t)v6);
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::~__value_func[abi:ne180100](v6);
  return this;
}

void sub_221F033F8(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(Phase::MessageWriteBuffer &,Phase::MessageWriteBuffer &,unsigned long)>::~__value_func[abi:ne180100]((void *)(v1 + 56));
  id v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(a1);
}

void Phase::MessagePipeReader<Phase::Dispatch::GeometryServerMessageType>::Execute(uint64_t *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  unint64_t v3 = a1[1];
  uint64_t v2 = a1[2];
  uint64_t v4 = v2 + 8;
  if (v2 + 8 <= v3)
  {
    uint64_t v6 = *a1;
    id v7 = (unsigned int *)(*a1 + v2);
    unint64_t v8 = v4 + v7[1];
    if (v8 <= v3)
    {
      a1[2] = v8;
      unsigned int v18 = *v7;
      if (v18)
      {
        uint64_t v10 = v6 + v4;
        do
        {
          long long v11 = std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::find<Phase::Dispatch::GeometryServerMessageType>(a2, &v18);
          if (v11)
          {
            if (!v10 || !v11[6]) {
              std::terminate();
            }
            std::function<void ()(void const*)>::operator()((uint64_t)(v11 + 3), v10);
          }
          else
          {
            long long v12 = **(id **)(Phase::Logger::GetInstance(0) + 848);
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              char v20 = "MessagePipe.hpp";
              __int16 v21 = 1024;
              int v22 = 102;
              __int16 v23 = 1024;
              unsigned int v24 = v18;
              _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d skipping unrecognized transaction message %d", buf, 0x18u);
            }
          }
          unint64_t v14 = a1[1];
          uint64_t v13 = a1[2];
          uint64_t v15 = v13 + 8;
          if (v13 + 8 > v14) {
            break;
          }
          uint64_t v16 = (unsigned int *)(*a1 + v13);
          unint64_t v17 = v15 + v16[1];
          if (v17 > v14) {
            break;
          }
          uint64_t v10 = *a1 + v15;
          a1[2] = v17;
          unsigned int v18 = *v16;
        }
        while (v18);
      }
    }
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::find<Phase::Dispatch::GeometryServerMessageType>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  uint64_t v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (unint64_t result = *v6; result; unint64_t result = (uint64_t *)*result)
  {
    unint64_t v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

Phase::Dispatch::ExternalStreamClientCommandProcessor *Phase::Dispatch::ExternalStreamClientCommandProcessor::ExternalStreamClientCommandProcessor(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, Phase::Dispatch::ExternalStreamClientInterface *a2)
{
  *(void *)this = &unk_26D474BC0;
  *(_OWORD *)((char *)this + 8) = 0u;
  uint8x8_t v4 = (char *)this + 8;
  *(_OWORD *)((char *)this + 24) = 0u;
  *((_DWORD *)this + 10) = 1065353216;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  id v5 = objc_alloc_init(MEMORY[0x263EFF980]);
  uint64_t v6 = (void *)*((void *)this + 9);
  *((void *)this + 9) = v5;

  *(void *)this = &unk_26D474C60;
  *((void *)this + 10) = a2;
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleAddStreamResponse;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 1, 1, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleAddInputStreamResponse;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 2, 2, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleRemoveStreamResponse;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 3, 3, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleClaimStreamResponse;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 4, 4, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleAbandonStreamResponse;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 5, 5, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::HandlePauseStreamResponse;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 14, 14, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::UpdateStreamStateForController;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 11, 11, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::UpdateControllerPauseState;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 6, 6, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::UpdateStreamPauseState;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 7, 7, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::PrepareRendering;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 8, 8, (uint64_t)&v8);
  unint64_t v8 = Phase::Dispatch::ExternalStreamClientCommandProcessor::StartRendering;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 9, 9, (uint64_t)&v8);
  unint64_t v8 = Phase::Dispatch::ExternalStreamClientCommandProcessor::StopRendering;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 10, 10, (uint64_t)&v8);
  unint64_t v8 = (uint64_t (*)(Phase::Dispatch::ExternalStreamClientCommandProcessor *, const void *))Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleInputMutedSpeechActivityResponse;
  uint64_t v9 = 0;
  uint64_t v10 = this;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>((uint64_t)v4, 13, 13, (uint64_t)&v8);
  return this;
}

void sub_221F03A1C(_Unwind_Exception *a1)
{
  Phase::Dispatch::TransactionExecutor<Phase::Dispatch::ExternalStreamServerMessageType>::~TransactionExecutor(v1);
  _Unwind_Resume(a1);
}

void sub_221F03A60()
{
  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(v1);
  JUMPOUT(0x221F03A58);
}

void Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleAddStreamResponse(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, void *a2)
{
  Phase::Dispatch::ExternalStreamResponseCodeToError(a2[8], a2[4], a2[5]);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(void, void, void, void, void, void, void, void, void, id))(**((void **)this + 10) + 128))(*((void *)this + 10), *a2, a2[1], a2[2], a2[3], a2[4], a2[5], a2[6], a2[7], v4);
}

void sub_221F03B10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleAddInputStreamResponse(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, double *a2)
{
  Phase::Dispatch::ExternalStreamResponseCodeToError(*((void *)a2 + 8), *((void *)a2 + 4), *((void *)a2 + 5));
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(void, void, void, void, void, void, void, void, double, void, _DWORD, id))(**((void **)this + 10) + 136))(*((void *)this + 10), *(void *)a2, *((void *)a2 + 1), *((void *)a2 + 2), *((void *)a2 + 3), *((void *)a2 + 4), *((void *)a2 + 5), *((void *)a2 + 6), a2[9], *((void *)a2 + 7), *((_DWORD *)a2 + 20), v4);
}

void sub_221F03BC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  _Unwind_Resume(a1);
}

void Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleRemoveStreamResponse(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, void *a2)
{
  Phase::Dispatch::ExternalStreamResponseCodeToError(a2[6], a2[4], a2[5]);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(void, void, void, void, void, void, void))(**((void **)this + 10) + 144))(*((void *)this + 10), *a2, a2[1], a2[2], a2[3], a2[4], a2[5]);
}

void sub_221F03C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleClaimStreamResponse(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, void *a2)
{
  Phase::Dispatch::ExternalStreamResponseCodeToError(a2[4], a2[2], a2[3]);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(void, void, void, void, void))(**((void **)this + 10) + 152))(*((void *)this + 10), *a2, a2[1], a2[2], a2[3]);
}

void sub_221F03D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleAbandonStreamResponse(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, void *a2)
{
  Phase::Dispatch::ExternalStreamResponseCodeToError(a2[4], a2[2], a2[3]);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(void, void, void, void, void, void, void))(**((void **)this + 10) + 160))(*((void *)this + 10), *a2, a2[1], a2[5], a2[6], a2[2], a2[3]);
}

void sub_221F03DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void Phase::Dispatch::ExternalStreamClientCommandProcessor::HandlePauseStreamResponse(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, void *a2)
{
  Phase::Dispatch::ExternalStreamResponseCodeToError(a2[6], a2[2], a2[3]);
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(void, void, void, void, void, void, void))(**((void **)this + 10) + 168))(*((void *)this + 10), *a2, a2[1], a2[2], a2[3], a2[4], a2[5]);
}

void sub_221F03E54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::Dispatch::ExternalStreamClientCommandProcessor::UpdateStreamStateForController(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void, void, void, void))(**((void **)this + 10) + 184))(*((void *)this + 10), a2[2], a2[3], a2[4], a2[5], a2[6]);
}

uint64_t Phase::Dispatch::ExternalStreamClientCommandProcessor::UpdateControllerPauseState(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void, void, void, void))(**((void **)this + 10) + 192))(*((void *)this + 10), a2[2], a2[3], a2[4], a2[5], *((unsigned __int8 *)a2 + 48));
}

uint64_t Phase::Dispatch::ExternalStreamClientCommandProcessor::UpdateStreamPauseState(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void, void, void, void))(**((void **)this + 10) + 200))(*((void *)this + 10), a2[2], a2[3], a2[4], a2[5], *((unsigned __int8 *)a2 + 48));
}

uint64_t Phase::Dispatch::ExternalStreamClientCommandProcessor::PrepareRendering(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, double *a2)
{
  return (*(uint64_t (**)(void, void, double))(**((void **)this + 10) + 208))(*((void *)this + 10), *((unsigned int *)a2 + 6), a2[2]);
}

uint64_t Phase::Dispatch::ExternalStreamClientCommandProcessor::StartRendering(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, const void *a2)
{
  return (*(uint64_t (**)(void))(**((void **)this + 10) + 216))();
}

uint64_t Phase::Dispatch::ExternalStreamClientCommandProcessor::StopRendering(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, const void *a2)
{
  return (*(uint64_t (**)(void))(**((void **)this + 10) + 224))();
}

uint64_t Phase::Dispatch::ExternalStreamClientCommandProcessor::HandleInputMutedSpeechActivityResponse(Phase::Dispatch::ExternalStreamClientCommandProcessor *this, char *a2)
{
  return (*(uint64_t (**)(void, void, void, char *))(**((void **)this + 10) + 176))(*((void *)this + 10), *(void *)a2, *((void *)a2 + 1), a2 + 16);
}

void std::__hash_table<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::ExternalStreamServerMessageType,std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::ExternalStreamServerMessageType>,std::hash<Phase::Dispatch::ExternalStreamServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::ExternalStreamServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::ExternalStreamServerMessageType,Phase::Dispatch::ExternalStreamServerMessageType,std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>(uint64_t a1, int a2, int a3, uint64_t a4)
{
  unint64_t v8 = a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    long long v11 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (size_t i = *v11; i; size_t i = (uint64_t *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }
  unint64_t v14 = (void *)(a1 + 16);
  uint64_t v15 = operator new(0x38uLL);
  v38[0] = v15;
  v38[1] = a1 + 16;
  char v39 = 0;
  void *v15 = 0;
  v15[1] = v8;
  *((_DWORD *)v15 + 4) = a3;
  v15[6] = 0;
  uint64_t v16 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v16 = &unk_26D474C88;
  *(_OWORD *)(v16 + 8) = *(_OWORD *)a4;
  *((void *)v16 + 3) = *(void *)(a4 + 16);
  v15[6] = v16;
  char v39 = 1;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      int8x8_t prime = (int8x8_t)v21;
    }
    else {
      int8x8_t prime = (int8x8_t)v20;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v9 = *(void *)(a1 + 8);
    }
    if (*(void *)&prime > v9) {
      goto LABEL_30;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v29 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v9 < 3 || (uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v30.i16[0] = vaddlv_u8(v30), v30.u32[0] > 1uLL))
      {
        unint64_t v29 = std::__next_prime(v29);
      }
      else
      {
        uint64_t v31 = 1 << -(char)__clz(v29 - 1);
        if (v29 >= 2) {
          unint64_t v29 = v31;
        }
      }
      if (*(void *)&prime <= v29) {
        int8x8_t prime = (int8x8_t)v29;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *(void *)(a1 + 8);
      }
      else
      {
        if (prime)
        {
LABEL_30:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          __int16 v23 = operator new(8 * *(void *)&prime);
          unsigned int v24 = *(void **)a1;
          *(void *)a1 = v23;
          if (v24) {
            operator delete(v24);
          }
          uint64_t v25 = 0;
          *(int8x8_t *)(a1 + 8) = prime;
          do
            *(void *)(*(void *)a1 + 8 * v25++) = 0;
          while (*(void *)&prime != v25);
          uint64_t v26 = (void *)*v14;
          if (*v14)
          {
            unint64_t v27 = v26[1];
            uint8x8_t v28 = (uint8x8_t)vcnt_s8(prime);
            v28.i16[0] = vaddlv_u8(v28);
            if (v28.u32[0] > 1uLL)
            {
              if (v27 >= *(void *)&prime) {
                v27 %= *(void *)&prime;
              }
            }
            else
            {
              v27 &= *(void *)&prime - 1;
            }
            *(void *)(*(void *)a1 + 8 * v2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v14;
            unint64_t v32 = (void *)*v26;
            if (*v26)
            {
              do
              {
                unint64_t v33 = v32[1];
                if (v28.u32[0] > 1uLL)
                {
                  if (v33 >= *(void *)&prime) {
                    v33 %= *(void *)&prime;
                  }
                }
                else
                {
                  v33 &= *(void *)&prime - 1;
                }
                if (v33 != v27)
                {
                  if (!*(void *)(*(void *)a1 + 8 * v33))
                  {
                    *(void *)(*(void *)a1 + 8 * v33) = v26;
                    goto LABEL_55;
                  }
                  *uint64_t v26 = *v32;
                  *unint64_t v32 = **(void **)(*(void *)a1 + 8 * v33);
                  **(void **)(*(void *)a1 + 8 * v33) = v32;
                  unint64_t v32 = v26;
                }
                unint64_t v33 = v27;
LABEL_55:
                uint64_t v26 = v32;
                unint64_t v32 = (void *)*v32;
                unint64_t v27 = v33;
              }
              while (v32);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_59;
        }
        unint64_t v37 = *(void **)a1;
        *(void *)a1 = 0;
        if (v37) {
          operator delete(v37);
        }
        unint64_t v9 = 0;
        *(void *)(a1 + 8) = 0;
      }
    }
LABEL_59:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v8) {
        unint64_t v4 = v8 % v9;
      }
      else {
        unint64_t v4 = v8;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & v8;
    }
  }
  uint64_t v34 = *(void **)(*(void *)a1 + 8 * v4);
  uint64_t v35 = v38[0];
  if (v34)
  {
    *(void *)v38[0] = *v34;
LABEL_72:
    *uint64_t v34 = v35;
    goto LABEL_73;
  }
  *(void *)v38[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v35;
  *(void *)(*(void *)a1 + 8 * v4) = v14;
  if (*(void *)v35)
  {
    unint64_t v36 = *(void *)(*(void *)v35 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v36 >= v9) {
        v36 %= v9;
      }
    }
    else
    {
      v36 &= v9 - 1;
    }
    uint64_t v34 = (void *)(*(void *)a1 + 8 * v36);
    goto LABEL_72;
  }
LABEL_73:
  v38[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,void *>>>>::reset[abi:ne180100]((uint64_t)v38);
}

void sub_221F044C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>,void ()(void const*)>::~__func()
{
}

__n128 std::__function::__func<std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>,void ()(void const*)>::__clone(uint64_t a1)
{
  int8x8_t v2 = (char *)operator new(0x20uLL);
  *(void *)int8x8_t v2 = &unk_26D474C88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>,void ()(void const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D474C88;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (Phase::Dispatch::ExternalStreamClientCommandProcessor::*)(void const*),Phase::Dispatch::ExternalStreamClientCommandProcessor*,std::placeholders::__ph<1> const&>>,void ()(void const*)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  unint64_t v3 = (uint64_t (*)(void *, void))a1[1];
  unint64_t v4 = (void *)(a1[3] + (v2 >> 1));
  if (v2) {
    unint64_t v3 = *(uint64_t (**)(void *, void))(*v4 + v3);
  }
  return v3(v4, *a2);
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::ExternalStreamClientDirectDispatcher(Phase::Dispatch::ExternalStreamClientDirectDispatcher *this, const Phase::Controller::TaskManager *a2)
{
  unint64_t v3 = [MEMORY[0x263F08C38] UUID];
  *(void *)this = &unk_26D474DF8;
  Phase::Logger::GetInstance(v3);
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::Commandable((void *)this + 1);
}

void sub_221F046C0(_Unwind_Exception *a1)
{
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(v3);
  _Unwind_Resume(a1);
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(id *this)
{
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this + 1);
}

{
  uint64_t vars8;

  Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this);

  JUMPOUT(0x223C938A0);
}

void non-virtual thunk to'Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(id *this)
{
}

{
  uint64_t vars8;

  Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1);

  JUMPOUT(0x223C938A0);
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::AddExternalOutputStream(uint64_t a1, void *a2, void *a3, void *a4, char a5, void *a6, void *a7)
{
  uint64_t v44 = *MEMORY[0x263EF8340];
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  id v16 = a6;
  id v17 = a7;
  id v18 = *(id *)(a1 + 48);
  id v19 = *(id *)(a1 + 56);
  id v33 = v13;
  id v20 = v14;
  id v21 = v15;
  uint64_t v31 = v16;
  int v22 = _Block_copy(v16);
  unint64_t v32 = v17;
  __int16 v23 = _Block_copy(v17);
  uint64_t v24 = **(void **)(a1 + 16);
  unint64_t v35 = 0;
  BOOL v34 = 1;
  uint64_t v25 = Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v24, 72, &v35, &v34);
  if (!v25)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    unint64_t v29 = **(id **)(v24 + 48);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      unint64_t v37 = "CommandQueue.hpp";
      __int16 v38 = 1024;
      int v39 = 100;
      _os_log_impl(&dword_221E5E000, v29, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v34)
  {
    uint64_t v26 = **(id **)(v24 + 48);
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      unint64_t v37 = "CommandQueue.hpp";
      __int16 v38 = 1024;
      int v39 = 89;
      __int16 v40 = 2048;
      unint64_t v41 = v35;
      __int16 v42 = 2048;
      uint64_t v43 = 72;
      _os_log_impl(&dword_221E5E000, v26, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(void *)uint64_t v25 = &unk_26D474EF0;
  *(void *)(v25 + 8) = v18;
  *(void *)(v25 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v19;
  unint64_t v27 = v33;
  *(void *)(v25 + 24) = v33;
  *(void *)(v25 + 32) = v20;
  *(void *)(v25 + 40) = v21;
  *(unsigned char *)(v25 + 48) = a5;
  *(void *)(v25 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v22;
  *(void *)(v25 + 64) = v23;
  Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v24, 72);
  atomic_store(0, (unsigned __int8 *)(v24 + 40));
}

void sub_221F04AEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (a2)
  {
    __cxa_free_exception(v20);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v21 + 8);
    __cxa_end_catch();
    JUMPOUT(0x221F049C4);
  }
  _Unwind_Resume(exception_object);
}

id *Phase::Dispatch::ExternalStreamClientDirectDispatcher::AddExternalOutputStream(NSUUID *,NSUUID *,PHASEExternalOutputStreamDefinition *,BOOL,int({block_pointer})(BOOL *,AudioTimeStamp const*,unsigned int,AudioBufferList *),void({block_pointer})(NSError *))::$_0::~$_0(id *a1)
{
  return a1;
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::AddExternalInputStream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  v18[1] = *MEMORY[0x263EF8340];
  id v7 = a7;
  uint64_t v17 = *MEMORY[0x263F08320];
  v18[0] = @"Error: input streams not supported for in-process clients";
  unint64_t v8 = [NSDictionary dictionaryWithObjects:v18 forKeys:&v17 count:1];
  unint64_t v9 = [MEMORY[0x263F087E8] errorWithDomain:@"com.apple.coreaudio.phase" code:1346924129 userInfo:v8];
  uint8x8_t v10 = **(id **)(Phase::Logger::GetInstance(v9) + 912);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = 136315650;
    long long v12 = "DispatcherExternalStreamClientDirect.mm";
    __int16 v13 = 1024;
    int v14 = 78;
    __int16 v15 = 2112;
    id v16 = v9;
    _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d %@", (uint8_t *)&v11, 0x1Cu);
  }
  v7[2](v7, v9);
}

void sub_221F04D40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::RemoveExternalStream(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = *(id *)(a1 + 48);
  id v11 = v7;
  id v12 = v8;
  __int16 v13 = _Block_copy(v9);
  uint64_t v14 = **(void **)(a1 + 16);
  unint64_t v21 = 0;
  BOOL v20 = 1;
  __int16 v15 = (void *)Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v14, 40, &v21, &v20);
  if (!v15)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    id v18 = **(id **)(v14 + 48);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      __int16 v23 = "CommandQueue.hpp";
      __int16 v24 = 1024;
      int v25 = 100;
      _os_log_impl(&dword_221E5E000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v20)
  {
    id v16 = **(id **)(v14 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      __int16 v23 = "CommandQueue.hpp";
      __int16 v24 = 1024;
      int v25 = 89;
      __int16 v26 = 2048;
      unint64_t v27 = v21;
      __int16 v28 = 2048;
      uint64_t v29 = 40;
      _os_log_impl(&dword_221E5E000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  void *v15 = &unk_26D474F18;
  v15[1] = v10;
  _OWORD v15[2] = v11;
  v15[3] = v12;
  v15[4] = v13;
  Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v14, 40);
  atomic_store(0, (unsigned __int8 *)(v14 + 40));
}

void sub_221F05014(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a2)
  {
    __cxa_free_exception(v13);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v12 + 8);
    __cxa_end_catch();
    JUMPOUT(0x221F04F0CLL);
  }
  _Unwind_Resume(exception_object);
}

id *Phase::Dispatch::ExternalStreamClientDirectDispatcher::RemoveExternalStream(NSUUID *,NSUUID *,void({block_pointer})(NSError *))::$_0::~$_0(id *a1)
{
  return a1;
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::ClaimControlOfExternalStreamUUID(uint64_t a1, void *a2, void *a3, void *a4)
{
  uint64_t v30 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = *(id *)(a1 + 48);
  id v11 = v7;
  uint64_t v12 = _Block_copy(v8);
  __int16 v13 = _Block_copy(v9);
  uint64_t v14 = **(void **)(a1 + 16);
  unint64_t v21 = 0;
  BOOL v20 = 1;
  __int16 v15 = (void *)Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v14, 48, &v21, &v20);
  if (!v15)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    id v18 = **(id **)(v14 + 48);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      __int16 v23 = "CommandQueue.hpp";
      __int16 v24 = 1024;
      int v25 = 100;
      _os_log_impl(&dword_221E5E000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v20)
  {
    id v16 = **(id **)(v14 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      __int16 v23 = "CommandQueue.hpp";
      __int16 v24 = 1024;
      int v25 = 89;
      __int16 v26 = 2048;
      unint64_t v27 = v21;
      __int16 v28 = 2048;
      uint64_t v29 = 48;
      _os_log_impl(&dword_221E5E000, v16, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  void *v15 = &unk_26D474F40;
  v15[1] = v10;
  _OWORD v15[2] = v11;
  v15[3] = a1;
  v15[4] = v12;
  v15[5] = v13;
  Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v14, 48);
  atomic_store(0, (unsigned __int8 *)(v14 + 40));
}

void sub_221F0538C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a2)
  {
    __cxa_free_exception(v14);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v13 + 8);
    __cxa_end_catch();
    JUMPOUT(0x221F05280);
  }
  _Unwind_Resume(exception_object);
}

id *Phase::Dispatch::ExternalStreamClientDirectDispatcher::ClaimControlOfExternalStreamUUID(NSUUID *,void({block_pointer})(NSUUID *,NSUUID *,PHASEExternalStreamState),void({block_pointer})(Phase::UniqueObjectId,NSError *))::$_0::~$_0(id *a1)
{
  return a1;
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::AbandonControlOfExternalStreamUUID(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  id v7 = a2;
  id v8 = a5;
  id v9 = *(id *)(a1 + 48);
  id v10 = v7;
  id v11 = _Block_copy(v8);
  uint64_t v12 = **(void **)(a1 + 16);
  unint64_t v19 = 0;
  BOOL v18 = 1;
  uint64_t v13 = (void *)Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v12, 32, &v19, &v18);
  if (!v13)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    id v16 = **(id **)(v12 + 48);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      unint64_t v21 = "CommandQueue.hpp";
      __int16 v22 = 1024;
      int v23 = 100;
      _os_log_impl(&dword_221E5E000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v18)
  {
    uint64_t v14 = **(id **)(v12 + 48);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      unint64_t v21 = "CommandQueue.hpp";
      __int16 v22 = 1024;
      int v23 = 89;
      __int16 v24 = 2048;
      unint64_t v25 = v19;
      __int16 v26 = 2048;
      uint64_t v27 = 32;
      _os_log_impl(&dword_221E5E000, v14, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *uint64_t v13 = &unk_26D474F68;
  v13[1] = v9;
  _OWORD v13[2] = v10;
  v13[3] = v11;
  Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v12, 32);
  atomic_store(0, (unsigned __int8 *)(v12 + 40));
}

void sub_221F056CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  if (a2)
  {
    __cxa_free_exception(v12);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v11 + 8);
    __cxa_end_catch();
    JUMPOUT(0x221F055CCLL);
  }
  _Unwind_Resume(exception_object);
}

id *Phase::Dispatch::ExternalStreamClientDirectDispatcher::AbandonControlOfExternalStreamUUID(NSUUID *,Phase::UniqueObjectId,void({block_pointer})(NSError *))::$_0::~$_0(id *a1)
{
  return a1;
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::PauseExternalStream(uint64_t a1, void *a2, void *a3, char a4, void *a5)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  id v12 = *(id *)(a1 + 48);
  id v13 = v9;
  id v14 = v10;
  __int16 v15 = _Block_copy(v11);
  uint64_t v16 = **(void **)(a1 + 16);
  unint64_t v23 = 0;
  BOOL v22 = 1;
  uint64_t v17 = Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v16, 48, &v23, &v22);
  if (!v17)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    BOOL v20 = **(id **)(v16 + 48);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      unint64_t v25 = "CommandQueue.hpp";
      __int16 v26 = 1024;
      int v27 = 100;
      _os_log_impl(&dword_221E5E000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v22)
  {
    BOOL v18 = **(id **)(v16 + 48);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      unint64_t v25 = "CommandQueue.hpp";
      __int16 v26 = 1024;
      int v27 = 89;
      __int16 v28 = 2048;
      unint64_t v29 = v23;
      __int16 v30 = 2048;
      uint64_t v31 = 48;
      _os_log_impl(&dword_221E5E000, v18, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(void *)uint64_t v17 = &unk_26D474F90;
  *(void *)(v17 + 8) = v12;
  *(void *)(v17 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v13;
  *(void *)(v17 + 24) = v14;
  *(unsigned char *)(v17 + 32) = a4;
  *(void *)(v17 + 40) = v15;
  Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v16, 48);
  atomic_store(0, (unsigned __int8 *)(v16 + 40));
}

void sub_221F05A40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a2)
  {
    __cxa_free_exception(v14);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v13 + 8);
    __cxa_end_catch();
    JUMPOUT(0x221F05934);
  }
  _Unwind_Resume(exception_object);
}

id *Phase::Dispatch::ExternalStreamClientDirectDispatcher::PauseExternalStream(NSUUID *,NSUUID *,BOOL,void({block_pointer})(NSError *))::$_0::~$_0(id *a1)
{
  return a1;
}

void Phase::Dispatch::ExternalStreamClientDirectDispatcher::GatherDebugInformation(uint64_t a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  id v3 = a2;
  id v4 = *(id *)(a1 + 48);
  id v5 = _Block_copy(v3);
  uint64_t v6 = **(void **)(a1 + 16);
  unint64_t v13 = 0;
  BOOL v12 = 1;
  id v7 = (void *)Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v6, 24, &v13, &v12);
  if (!v7)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    id v10 = **(id **)(v6 + 48);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      __int16 v15 = "CommandQueue.hpp";
      __int16 v16 = 1024;
      int v17 = 100;
      _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v12)
  {
    id v8 = **(id **)(v6 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      __int16 v15 = "CommandQueue.hpp";
      __int16 v16 = 1024;
      int v17 = 89;
      __int16 v18 = 2048;
      unint64_t v19 = v13;
      __int16 v20 = 2048;
      uint64_t v21 = 24;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  void *v7 = &unk_26D474FB8;
  v7[1] = v4;
  v7[2] = v5;
  Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v6, 24);
  atomic_store(0, (unsigned __int8 *)(v6 + 40));
}

void sub_221F05D54(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2 + 8);
    __cxa_end_catch();
    JUMPOUT(0x221F05C60);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Dispatch::ExternalStreamClientDirectDispatcher::Update(Phase::Dispatch::ExternalStreamClientDirectDispatcher *this)
{
  return Phase::Commandable<128,Phase::LockFreeQueueMPSC>::ExecuteCommands((uint64_t)this + 8);
}

uint64_t Phase::Dispatch::ExternalStreamClientDirectDispatcher::GetTransactionBuffer(Phase::Dispatch::ExternalStreamClientDirectDispatcher *this)
{
  return 0;
}

id *Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::AddExternalOutputStream(NSUUID *,NSUUID *,PHASEExternalOutputStreamDefinition *,BOOL,int({block_pointer})(BOOL *,AudioTimeStamp const*,unsigned int,AudioBufferList *),void({block_pointer})(NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  return a1;
}

void Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::AddExternalOutputStream(NSUUID *,NSUUID *,PHASEExternalOutputStreamDefinition *,BOOL,int({block_pointer})(BOOL *,AudioTimeStamp const*,unsigned int,AudioBufferList *),void({block_pointer})(NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  JUMPOUT(0x223C938A0);
}

uint64_t Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::AddExternalOutputStream(NSUUID *,NSUUID *,PHASEExternalOutputStreamDefinition *,BOOL,int({block_pointer})(BOOL *,AudioTimeStamp const*,unsigned int,AudioBufferList *),void({block_pointer})(NSError *))::$_0,void>::operator()(uint64_t a1)
{
  return [*(id *)(a1 + 8) addExternalOutputStreamGroupID:*(void *)(a1 + 24) streamID:*(void *)(a1 + 32) attributedTo:*(void *)(a1 + 16) definition:*(void *)(a1 + 40) startsPaused:*(unsigned __int8 *)(a1 + 48) renderBlock:*(void *)(a1 + 56) withCallback:*(void *)(a1 + 64)];
}

id *Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::RemoveExternalStream(NSUUID *,NSUUID *,void({block_pointer})(NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  return a1;
}

void Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::RemoveExternalStream(NSUUID *,NSUUID *,void({block_pointer})(NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  JUMPOUT(0x223C938A0);
}

uint64_t Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::RemoveExternalStream(NSUUID *,NSUUID *,void({block_pointer})(NSError *))::$_0,void>::operator()(uint64_t a1)
{
  return [*(id *)(a1 + 8) removeExternalOutputStreamGroupID:*(void *)(a1 + 16) streamID:*(void *)(a1 + 24) withCallback:*(void *)(a1 + 32)];
}

id *Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::ClaimControlOfExternalStreamUUID(NSUUID *,void({block_pointer})(NSUUID *,NSUUID *,PHASEExternalStreamState),void({block_pointer})(Phase::UniqueObjectId,NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  return a1;
}

void Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::ClaimControlOfExternalStreamUUID(NSUUID *,void({block_pointer})(NSUUID *,NSUUID *,PHASEExternalStreamState),void({block_pointer})(Phase::UniqueObjectId,NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  JUMPOUT(0x223C938A0);
}

void Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::ClaimControlOfExternalStreamUUID(NSUUID *,void({block_pointer})(NSUUID *,NSUUID *,PHASEExternalStreamState),void({block_pointer})(Phase::UniqueObjectId,NSError *))::$_0,void>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(*(void *)(a1 + 24) + 56);
  v5[0] = MEMORY[0x263EF8330];
  v5[1] = 3221225472;
  v5[2] = ___ZZN5Phase8Dispatch36ExternalStreamClientDirectDispatcher32ClaimControlOfExternalStreamUUIDEP6NSUUIDU13block_pointerFvS3_S3_24PHASEExternalStreamStateEU13block_pointerFvNS_14UniqueObjectIdEP7NSErrorEENK3__0clEv_block_invoke;
  v5[3] = &unk_2645F7330;
  id v6 = *(id *)(a1 + 40);
  [v1 claimControlOfExternalStreamGroupID:v2 attributedTo:v4 stateChangeBlock:v3 withCallback:v5];
}

void sub_221F06138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZZN5Phase8Dispatch36ExternalStreamClientDirectDispatcher32ClaimControlOfExternalStreamUUIDEP6NSUUIDU13block_pointerFvS3_S3_24PHASEExternalStreamStateEU13block_pointerFvNS_14UniqueObjectIdEP7NSErrorEENK3__0clEv_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = *(void *)(a1 + 32);
  MEMORY[0x223C944F0](v5);
  (*(void (**)(uint64_t, void, void, id))(v4 + 16))(v4, v5[0], v5[1], v3);
}

void sub_221F061A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::AbandonControlOfExternalStreamUUID(NSUUID *,Phase::UniqueObjectId,void({block_pointer})(NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  return a1;
}

void Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::AbandonControlOfExternalStreamUUID(NSUUID *,Phase::UniqueObjectId,void({block_pointer})(NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  JUMPOUT(0x223C938A0);
}

uint64_t Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::AbandonControlOfExternalStreamUUID(NSUUID *,Phase::UniqueObjectId,void({block_pointer})(NSError *))::$_0,void>::operator()(uint64_t a1)
{
  return [*(id *)(a1 + 8) abandonControlOfExternalStreamGroupID:*(void *)(a1 + 16) withCallback:*(void *)(a1 + 24)];
}

id *Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::PauseExternalStream(NSUUID *,NSUUID *,BOOL,void({block_pointer})(NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  return a1;
}

void Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::PauseExternalStream(NSUUID *,NSUUID *,BOOL,void({block_pointer})(NSError *))::$_0,void>::~LambdaFunction(id *a1)
{
  JUMPOUT(0x223C938A0);
}

void Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::PauseExternalStream(NSUUID *,NSUUID *,BOOL,void({block_pointer})(NSError *))::$_0,void>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(void *)(a1 + 24);
  uint64_t v5 = *(unsigned __int8 *)(a1 + 32);
  id v7 = 0;
  [v2 setPauseExternalOutputStreamGroupID:v3 streamID:v4 isPaused:v5 error:&v7];
  id v6 = v7;
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_221F0636C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::GatherDebugInformation(void({block_pointer})(NSDictionary *,NSError *))::$_0,void>::~LambdaFunction(uint64_t a1)
{
  return a1;
}

void Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::GatherDebugInformation(void({block_pointer})(NSDictionary *,NSError *))::$_0,void>::~LambdaFunction(uint64_t a1)
{
  JUMPOUT(0x223C938A0);
}

uint64_t Phase::LambdaFunction<Phase::Dispatch::ExternalStreamClientDirectDispatcher::GatherDebugInformation(void({block_pointer})(NSDictionary *,NSError *))::$_0,void>::operator()(uint64_t a1)
{
  return [*(id *)(a1 + 8) gatherDebugInformation:*(void *)(a1 + 16)];
}

id Phase::Dispatch::ExternalStreamResponseCodeToError(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  v36[1] = *MEMORY[0x263EF8340];
  uint64_t v23 = a2;
  uint64_t v24 = a3;
  if (a1 > 1346924645)
  {
    if (a1 == 1346924646)
    {
      uint64_t v25 = *MEMORY[0x263F08320];
      __int16 v16 = NSString;
      int v17 = (void *)[objc_alloc(MEMORY[0x263F08C38]) initWithUUIDBytes:&v23];
      __int16 v18 = [v16 stringWithFormat:@"failed to pause/resume stream %@", v17, v23, v24, v25];
      __int16 v26 = v18;
      uint64_t v8 = [NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];

      uint64_t v9 = [MEMORY[0x263F087E8] errorWithDomain:@"com.apple.coreaudio.phase" code:1346924646 userInfo:v8];
    }
    else if (a1 == 1346925413)
    {
      uint64_t v33 = *MEMORY[0x263F08320];
      unint64_t v19 = NSString;
      __int16 v20 = (void *)[objc_alloc(MEMORY[0x263F08C38]) initWithUUIDBytes:&v23];
      uint64_t v21 = [v19 stringWithFormat:@"stream %@ already exists", v20, v23, v24];
      BOOL v34 = v21;
      uint64_t v8 = [NSDictionary dictionaryWithObjects:&v34 forKeys:&v33 count:1];

      uint64_t v9 = [MEMORY[0x263F087E8] errorWithDomain:@"com.apple.coreaudio.phase" code:1346925413 userInfo:v8];
    }
    else
    {
      uint64_t v4 = 0;
      if (a1 != 1346925939) {
        goto LABEL_15;
      }
      uint64_t v27 = *MEMORY[0x263F08320];
      id v10 = NSString;
      id v11 = (void *)[objc_alloc(MEMORY[0x263F08C38]) initWithUUIDBytes:&v23];
      BOOL v12 = [v10 stringWithFormat:@"stream %@ not claimed", v11, v23, v24];
      __int16 v28 = v12;
      uint64_t v8 = [NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];

      uint64_t v9 = [MEMORY[0x263F087E8] errorWithDomain:@"com.apple.coreaudio.phase" code:1346925939 userInfo:v8];
    }
  }
  else if (a1 == 1346921331)
  {
    uint64_t v29 = *MEMORY[0x263F08320];
    unint64_t v13 = NSString;
    id v14 = (void *)[objc_alloc(MEMORY[0x263F08C38]) initWithUUIDBytes:&v23];
    __int16 v15 = [v13 stringWithFormat:@"stream %@ already claimed", v14, v23, v24];
    __int16 v30 = v15;
    uint64_t v8 = [NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];

    uint64_t v9 = [MEMORY[0x263F087E8] errorWithDomain:@"com.apple.coreaudio.phase" code:1346921331 userInfo:v8];
  }
  else
  {
    if (a1 == 1346922849)
    {
      uint64_t v35 = *MEMORY[0x263F08320];
      v36[0] = @"invalid arguments";
      uint64_t v3 = [NSDictionary dictionaryWithObjects:v36 forKeys:&v35 count:1];
      uint64_t v4 = [MEMORY[0x263F087E8] errorWithDomain:@"com.apple.coreaudio.phase" code:1346922849 userInfo:v3];
      goto LABEL_15;
    }
    uint64_t v4 = 0;
    if (a1 != 1346924147) {
      goto LABEL_15;
    }
    uint64_t v31 = *MEMORY[0x263F08320];
    uint64_t v5 = NSString;
    id v6 = (void *)[objc_alloc(MEMORY[0x263F08C38]) initWithUUIDBytes:&v23];
    id v7 = [v5 stringWithFormat:@"stream %@ does not exist", v6, v23, v24];
    uint64_t v32 = v7;
    uint64_t v8 = [NSDictionary dictionaryWithObjects:&v32 forKeys:&v31 count:1];

    uint64_t v9 = [MEMORY[0x263F087E8] errorWithDomain:@"com.apple.coreaudio.phase" code:1346924147 userInfo:v8];
  }
  uint64_t v4 = (void *)v9;
  uint64_t v3 = (void *)v8;
LABEL_15:

  return v4;
}

void sub_221F068B8(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::GeometryClientCommandProcessor(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = &unk_26D474BE8;
  *(_OWORD *)(a1 + 8) = 0u;
  uint64_t v4 = a1 + 8;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  id v5 = objc_alloc_init(MEMORY[0x263EFF980]);
  id v6 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = v5;

  *(void *)a1 = &unk_26D474FE0;
  *(void *)(a1 + 80) = a2;
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingSourceCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 1u, 1, (uint64_t)&v8);
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingAudibleGeometryCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 2u, 2, (uint64_t)&v8);
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::GetShapeInfoCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 3u, 3, (uint64_t)&v8);
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::GetVoxelsCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 4u, 4, (uint64_t)&v8);
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingRayTraceIntersectionsCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 5u, 5, (uint64_t)&v8);
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingEnergyHistogramCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 6u, 6, (uint64_t)&v8);
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingImageSourceLocationsCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 7u, 7, (uint64_t)&v8);
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingListenerEarlyResponseMetadataCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 8u, 8, (uint64_t)&v8);
  uint64_t v8 = Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingListenerLateReverbMetadataCallback;
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(v4, 9u, 9, (uint64_t)&v8);
  return a1;
}

void sub_221F06B70(_Unwind_Exception *a1)
{
  Phase::Dispatch::TransactionExecutor<Phase::Dispatch::GeometryServerMessageType>::~TransactionExecutor(v1);
  _Unwind_Resume(a1);
}

void sub_221F06BA4()
{
  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(v1);
  JUMPOUT(0x221F06B9CLL);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingSourceCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 336))(*((void *)this + 10), *a2, a2[1]);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingAudibleGeometryCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 360))(*((void *)this + 10), *a2, a2[1]);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::GetShapeInfoCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 384))(*((void *)this + 10), *a2, a2[1]);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::GetVoxelsCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 400))(*((void *)this + 10), *a2, a2[1]);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingRayTraceIntersectionsCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 424))(*((void *)this + 10), *a2, a2[1]);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingEnergyHistogramCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 448))(*((void *)this + 10), *a2, a2[1]);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingImageSourceLocationsCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 472))(*((void *)this + 10), *a2, a2[1]);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingListenerEarlyResponseMetadataCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 496))(*((void *)this + 10), *a2, a2[1]);
}

uint64_t Phase::Dispatch::GeometryClientCommandProcessor::BeginTrackingListenerLateReverbMetadataCallback(Phase::Dispatch::GeometryClientCommandProcessor *this, void *a2)
{
  return (*(uint64_t (**)(void, void, void))(**((void **)this + 10) + 520))(*((void *)this + 10), *a2, a2[1]);
}

void std::__hash_table<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::hash<Phase::Dispatch::GeometryServerMessageType>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,true>,std::__unordered_map_equal<Phase::Dispatch::GeometryServerMessageType,std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>,std::equal_to<Phase::Dispatch::GeometryServerMessageType>,std::hash<Phase::Dispatch::GeometryServerMessageType>,true>,std::allocator<std::__hash_value_type<Phase::Dispatch::GeometryServerMessageType,std::function<void ()(void const*)>>>>::__emplace_unique_key_args<Phase::Dispatch::GeometryServerMessageType,Phase::Dispatch::GeometryServerMessageType,std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>(uint64_t a1, unsigned int a2, int a3, uint64_t a4)
{
  unint64_t v8 = a2;
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v4 = a2;
      if (v9 <= a2) {
        unint64_t v4 = a2 % v9;
      }
    }
    else
    {
      unint64_t v4 = (v9 - 1) & a2;
    }
    id v11 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v11)
    {
      for (size_t i = *v11; i; size_t i = (uint64_t *)*i)
      {
        unint64_t v13 = i[1];
        if (v13 == a2)
        {
          if (*((_DWORD *)i + 4) == a2) {
            return;
          }
        }
        else
        {
          if (v10.u32[0] > 1uLL)
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
          }
          else
          {
            v13 &= v9 - 1;
          }
          if (v13 != v4) {
            break;
          }
        }
      }
    }
  }
  id v14 = (void *)(a1 + 16);
  __int16 v15 = operator new(0x38uLL);
  v38[0] = v15;
  v38[1] = a1 + 16;
  char v39 = 0;
  void *v15 = 0;
  v15[1] = v8;
  *((_DWORD *)v15 + 4) = a3;
  v15[6] = 0;
  __int16 v16 = (char *)operator new(0x20uLL);
  *(void *)__int16 v16 = &unk_26D475008;
  *(_OWORD *)(v16 + 8) = *(_OWORD *)a4;
  *((void *)v16 + 3) = *(void *)(a4 + 16);
  v15[6] = v16;
  char v39 = 1;
  float v17 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v18 = *(float *)(a1 + 32);
  if (v9 && (float)(v18 * (float)v9) >= v17)
  {
    unint64_t v8 = v4;
    goto LABEL_64;
  }
  BOOL v19 = 1;
  if (v9 >= 3) {
    BOOL v19 = (v9 & (v9 - 1)) != 0;
  }
  unint64_t v20 = v19 | (2 * v9);
  unint64_t v21 = vcvtps_u32_f32(v17 / v18);
  if (v20 <= v21) {
    int8x8_t prime = (int8x8_t)v21;
  }
  else {
    int8x8_t prime = (int8x8_t)v20;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v9 = *(void *)(a1 + 8);
  }
  if (*(void *)&prime <= v9)
  {
    if (*(void *)&prime >= v9) {
      goto LABEL_60;
    }
    unint64_t v29 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v9 < 3 || (uint8x8_t v30 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v30.i16[0] = vaddlv_u8(v30), v30.u32[0] > 1uLL))
    {
      unint64_t v29 = std::__next_prime(v29);
    }
    else
    {
      uint64_t v31 = 1 << -(char)__clz(v29 - 1);
      if (v29 >= 2) {
        unint64_t v29 = v31;
      }
    }
    if (*(void *)&prime <= v29) {
      int8x8_t prime = (int8x8_t)v29;
    }
    if (*(void *)&prime >= v9)
    {
      unint64_t v9 = *(void *)(a1 + 8);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      unint64_t v37 = *(void **)a1;
      *(void *)a1 = 0;
      if (v37) {
        operator delete(v37);
      }
      unint64_t v9 = 0;
      *(void *)(a1 + 8) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v23 = operator new(8 * *(void *)&prime);
  uint64_t v24 = *(void **)a1;
  *(void *)a1 = v23;
  if (v24) {
    operator delete(v24);
  }
  uint64_t v25 = 0;
  *(int8x8_t *)(a1 + 8) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v25++) = 0;
  while (*(void *)&prime != v25);
  __int16 v26 = (void *)*v14;
  if (*v14)
  {
    unint64_t v27 = v26[1];
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(prime);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      if (v27 >= *(void *)&prime) {
        v27 %= *(void *)&prime;
      }
    }
    else
    {
      v27 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v14;
    uint64_t v32 = (void *)*v26;
    if (*v26)
    {
      do
      {
        unint64_t v33 = v32[1];
        if (v28.u32[0] > 1uLL)
        {
          if (v33 >= *(void *)&prime) {
            v33 %= *(void *)&prime;
          }
        }
        else
        {
          v33 &= *(void *)&prime - 1;
        }
        if (v33 != v27)
        {
          if (!*(void *)(*(void *)a1 + 8 * v33))
          {
            *(void *)(*(void *)a1 + 8 * v33) = v26;
            goto LABEL_56;
          }
          *__int16 v26 = *v32;
          *uint64_t v32 = **(void **)(*(void *)a1 + 8 * v33);
          **(void **)(*(void *)a1 + 8 * v33) = v32;
          uint64_t v32 = v26;
        }
        unint64_t v33 = v27;
LABEL_56:
        __int16 v26 = v32;
        uint64_t v32 = (void *)*v32;
        unint64_t v27 = v33;
      }
      while (v32);
    }
  }
  unint64_t v9 = (unint64_t)prime;
LABEL_60:
  if ((v9 & (v9 - 1)) != 0)
  {
    if (v9 <= v8) {
      v8 %= v9;
    }
  }
  else
  {
    unint64_t v8 = (v9 - 1) & v8;
  }
LABEL_64:
  BOOL v34 = *(void **)(*(void *)a1 + 8 * v8);
  uint64_t v35 = v38[0];
  if (v34)
  {
    *(void *)v38[0] = *v34;
LABEL_72:
    *BOOL v34 = v35;
    goto LABEL_73;
  }
  *(void *)v38[0] = *(void *)(a1 + 16);
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v35;
  *(void *)(*(void *)a1 + 8 * v8) = v14;
  if (*(void *)v35)
  {
    unint64_t v36 = *(void *)(*(void *)v35 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v36 >= v9) {
        v36 %= v9;
      }
    }
    else
    {
      v36 &= v9 - 1;
    }
    BOOL v34 = (void *)(*(void *)a1 + 8 * v36);
    goto LABEL_72;
  }
LABEL_73:
  v38[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,void *>>>>::reset[abi:ne180100]((uint64_t)v38);
}

void sub_221F072B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::ActionTreeServerCommand,std::function<void ()(void const*)>>,void *>>>>::reset[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>,void ()(void const*)>::~__func()
{
}

__n128 std::__function::__func<std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>,void ()(void const*)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_26D475008;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>,void ()(void const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D475008;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (Phase::Dispatch::GeometryClientCommandProcessor::*)(void const*),Phase::Dispatch::GeometryClientCommandProcessor*,std::placeholders::__ph<1> const&>>,void ()(void const*)>::operator()(void *a1, void *a2)
{
  uint64_t v2 = a1[2];
  uint64_t v3 = (uint64_t (*)(void *, void))a1[1];
  unint64_t v4 = (void *)(a1[3] + (v2 >> 1));
  if (v2) {
    uint64_t v3 = *(uint64_t (**)(void *, void))(*v4 + v3);
  }
  return v3(v4, *a2);
}

uint64_t Phase::Controller::TaskManager::GetService<Phase::Controller::ListenerManager>(Phase::Logger *a1, int a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)a1 + 6);
  if (a2 >= (unint64_t)((*((void *)a1 + 7) - v3) >> 5))
  {
    id v7 = **(id **)(Phase::Logger::GetInstance(a1) + 448);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      id v14 = "TaskManager.hpp";
      __int16 v15 = 1024;
      int v16 = 112;
      _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d PRECONDITION: pId < mServiceRegistry.size() is false.", buf, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](exception, "PRECONDITION: pId < mServiceRegistry.size() is false.");
  }
  unint64_t v4 = *(uint64_t (**)(uint64_t))(v3 + 32 * a2);
  if (!v4)
  {
    unint64_t v9 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(a1)
                                                                                       + 448)));
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      Phase::GetBacktraceFrame<1ul>(&__p);
      uint8x8_t v10 = (__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &__p
          : (std::string *)__p.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315906;
      id v14 = "TaskManager.hpp";
      __int16 v15 = 1024;
      int v16 = 121;
      __int16 v17 = 1024;
      int v18 = a2;
      __int16 v19 = 2080;
      unint64_t v20 = v10;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::domain_error) [not lService.has_value() is true]: \"No service registered for Id %i, in call \\n%s\"", buf, 0x22u);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }

    id v11 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::domain_error::domain_error[abi:ne180100](v11, "No service registered for Id %i, in call \n%s");
  }
  uint64_t v5 = v4(3);
  if (!v5) {
    std::__throw_bad_any_cast[abi:ne180100]();
  }
  return *(void *)v5;
}

void sub_221F07600(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void sub_221F07710(_Unwind_Exception *a1)
{
}

void sub_221F07730(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

unint64_t Phase::Dispatch::GeometryClientDirectDispatcher::CreateEntity(uint64_t a1, int a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  Phase::Geometry::EntityFactory::Create(a2, &v8);
  if (v8)
  {
    unint64_t v5 = Phase::Geometry::SystemScheduler::AddToDatabase(*(void *)(a1 + 8) + 2352, &v8);
    if (a2 == 2) {
      Phase::Controller::ListenerManager::AddListener(*(void *)(a1 + 16), v5);
    }
  }
  else
  {
    id v6 = **(id **)(Phase::Logger::GetInstance(v4) + 832);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      id v11 = "DispatcherGeometryClientDirect.mm";
      __int16 v12 = 1024;
      int v13 = 330;
      _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create geo entity.", buf, 0x12u);
    }
    unint64_t v5 = 0;
  }
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  return v5;
}

void sub_221F0787C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

unint64_t Phase::Dispatch::GeometryClientDirectDispatcher::CreateMedium(uint64_t a1, uint64_t a2)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  memset(v36, 0, sizeof(v36));
  int v37 = 1065353216;
  uint64_t v43 = "MediumDataMapSize";
  uint64_t v44 = 17;
  *(_DWORD *)buf = 4;
  int v42 = 1;
  Phase::UnorderedStringMap<Phase::OptionsValue>::Set((uint64_t)v36, (uint64_t)&v43, (uint64_t)buf);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<BOOL,int,unsigned int,float,double,Phase::Vector<float,2ul>,Phase::Vector<float,3ul>,Phase::Vector<float,4ul>,std::string,std::vector<unsigned int>,std::vector<unsigned long long>,Phase::UnorderedStringMap<Phase::OptionsValue>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
  unint64_t v4 = (Phase::Logger *)Phase::Geometry::MediumFactory::Create(*(void *)(a1 + 8) + 496, 1u, (uint64_t)v36, &v34);
  if (v34)
  {
    uint64_t v5 = **(void **)(v34 + 40);
    uint64_t v6 = [*(id *)a2 count];
    uint64_t v33 = a1;
    *(_OWORD *)(v5 + 124) = 0u;
    *(_OWORD *)(v5 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
    *(_OWORD *)(v5 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
    *(_OWORD *)(v5 + 64) = 0u;
    *(_OWORD *)(v5 + 80) = 0u;
    *(_OWORD *)(v5 + 32) = 0u;
    *(_OWORD *)(v5 + 48) = 0u;
    *(_OWORD *)(v5 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
    *(_DWORD *)(v5 + 140) = v6;
    *(_OWORD *)(v5 + 144) = 0u;
    *(_OWORD *)(v5 + 160) = 0u;
    *(_OWORD *)(v5 + 17std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
    *(_OWORD *)(v5 + 192) = 0u;
    *(_OWORD *)(v5 + 208) = 0u;
    *(_OWORD *)(v5 + 224) = 0u;
    *(_OWORD *)(v5 + 240) = 0u;
    *(_OWORD *)(v5 + 252) = 0u;
    *(_DWORD *)(v5 + 268) = v6;
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        uint64_t v8 = [*(id *)a2 objectAtIndexedSubscript:i];
        [v8 frequency];
        *(_DWORD *)(v5 + 4 * i + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v9;

        uint8x8_t v10 = [*(id *)a2 objectAtIndexedSubscript:i];
        [v10 value];
        float v12 = v11;

        float v13 = 0.0;
        if (v12 != 1.0)
        {
          int v14 = 1;
          if (v12 > 0.0) {
            *(float *)&int v14 = v12;
          }
          float v13 = (float)((float)(logf(*(float *)&v14) * 8.6859) / 10.0) * -10.0;
        }
        *(float *)(v5 + 4 * i + 144) = v13;
      }
    }
    *(_DWORD *)(v5 + 272) = *(_DWORD *)(a2 + 8);
    uint64_t v15 = 1;
    while (1)
    {
      uint64_t v16 = *(void *)(*(void *)(v34 + 40) + 40 * v15);
      unint64_t v17 = qword_2220A5778[v15 - 1];
      unint64_t v18 = objc_msgSend(*(id *)a2, "count", sGetFrequencies((uint64_t)buf, v17));
      std::vector<float>::vector(&v43, v18);
      std::vector<float>::vector(&v39, v18);
      if (v18)
      {
        for (uint64_t j = 0; j != v18; ++j)
        {
          unint64_t v20 = [*(id *)a2 objectAtIndexedSubscript:j];
          [v20 frequency];
          *((_DWORD *)v43 + j) = v21;

          uint64_t v22 = [*(id *)a2 objectAtIndexedSubscript:j];
          [v22 value];
          *((_DWORD *)v39 + j) = v23;
        }
      }
      std::vector<float>::vector(__p, v17);
      Phase::GetValuesFromFrequencyResponse<std::__wrap_iter<float *>,std::__wrap_iter<float *>,std::__wrap_iter<float const*>,std::__wrap_iter<float *>,&float Phase::Square<float>,&float Phase::SquareRoot<float>>((float *)v43, (float *)v44, (uint64_t)v39, (uint64_t)v40, *(float **)buf, *(float **)&buf[8], (uint64_t)__p[0]);
      *(_OWORD *)(v16 + 144) = 0u;
      uint64_t v24 = (float *)(v16 + 144);
      *(_OWORD *)(v16 + 124) = 0u;
      *(_OWORD *)(v16 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
      *(_OWORD *)(v16 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
      *(_OWORD *)(v16 + 64) = 0u;
      *(_OWORD *)(v16 + 80) = 0u;
      *(_OWORD *)(v16 + 32) = 0u;
      *(_OWORD *)(v16 + 48) = 0u;
      *(_OWORD *)(v16 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
      *(_DWORD *)(v16 + 140) = v17;
      *(_OWORD *)(v16 + 160) = 0u;
      *(_OWORD *)(v16 + 17std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
      *(_OWORD *)(v16 + 192) = 0u;
      *(_OWORD *)(v16 + 208) = 0u;
      *(_OWORD *)(v16 + 224) = 0u;
      *(_OWORD *)(v16 + 240) = 0u;
      *(_OWORD *)(v16 + 252) = 0u;
      *(_DWORD *)(v16 + 268) = v17;
      uint64_t v25 = __p[0];
      if (v17) {
        break;
      }
      *(_DWORD *)(v16 + 272) = *(_DWORD *)(a2 + 8);
      if (v25) {
        goto LABEL_22;
      }
LABEL_23:
      if (v39)
      {
        __int16 v40 = v39;
        operator delete(v39);
      }
      if (v43)
      {
        uint64_t v44 = (uint64_t)v43;
        operator delete(v43);
      }
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
      if (++v15 == 4)
      {
        unint64_t v30 = Phase::Geometry::SystemScheduler::AddToDatabase(*(void *)(v33 + 8) + 2352, &v34);
        goto LABEL_34;
      }
    }
    __int16 v26 = *(float **)buf;
    unint64_t v27 = (float *)__p[0];
    do
    {
      *(v24 - 32) = *v26;
      float v28 = 0.0;
      if (*v27 != 1.0)
      {
        LODWORD(v29) = 1;
        if (*v27 > 0.0) {
          float v29 = *v27;
        }
        float v28 = (float)((float)(logf(v29) * 8.6859) / 10.0) * -10.0;
      }
      *v24++ = v28;
      ++v27;
      ++v26;
      --v17;
    }
    while (v17);
    *(_DWORD *)(v16 + 272) = *(_DWORD *)(a2 + 8);
LABEL_22:
    __p[1] = v25;
    operator delete(v25);
    goto LABEL_23;
  }
  uint64_t v31 = **(id **)(Phase::Logger::GetInstance(v4) + 832);
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = "DispatcherGeometryClientDirect.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 356;
    _os_log_impl(&dword_221E5E000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create geo material.", buf, 0x12u);
  }
  unint64_t v30 = 0;
LABEL_34:
  if (v35) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v35);
  }
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v36);
  return v30;
}

void sub_221F07D08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint8_t buf,uint64_t a32)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)&a13);
  _Unwind_Resume(a1);
}

unint64_t Phase::Dispatch::GeometryClientDirectDispatcher::CreateMaterial(uint64_t a1, id *a2)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  memset(v13, 0, sizeof(v13));
  int v14 = 1065353216;
  float v11 = "MaterialDataMapSize";
  uint64_t v12 = 19;
  *(_DWORD *)buf = 4;
  int v19 = 1;
  Phase::UnorderedStringMap<Phase::OptionsValue>::Set((uint64_t)v13, (uint64_t)&v11, (uint64_t)buf);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<BOOL,int,unsigned int,float,double,Phase::Vector<float,2ul>,Phase::Vector<float,3ul>,Phase::Vector<float,4ul>,std::string,std::vector<unsigned int>,std::vector<unsigned long long>,Phase::UnorderedStringMap<Phase::OptionsValue>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
  unint64_t v4 = (Phase::Logger *)Phase::Geometry::MaterialFactory::Create(*(void *)(a1 + 8) + 952, 1u, (uint64_t)v13, &v11);
  if (v11)
  {
    Phase::Dispatch::sCopyMaterialData(a2, **((void **)v11 + 5));
    uint64_t v5 = (unint64_t *)qword_2220A5778;
    for (uint64_t i = 40; i != 160; i += 40)
    {
      unint64_t v7 = *v5++;
      Phase::Dispatch::sConvertMaterialData(a2, *(void *)(*((void *)v11 + 5) + i), v7);
    }
    unint64_t v8 = Phase::Geometry::SystemScheduler::AddToDatabase(*(void *)(a1 + 8) + 2352, (uint64_t *)&v11);
  }
  else
  {
    int v9 = **(id **)(Phase::Logger::GetInstance(v4) + 832);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v16 = "DispatcherGeometryClientDirect.mm";
      __int16 v17 = 1024;
      int v18 = 396;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create geo material.", buf, 0x12u);
    }
    unint64_t v8 = 0;
  }
  if (v12) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v12);
  }
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v13);
  return v8;
}

void sub_221F0804C(_Unwind_Exception *a1, uint64_t a2, std::__shared_weak_count *a3, ...)
{
  va_start(va, a3);
  if (a3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a3);
  }
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_221F0808C(void *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, long long buf)
{
  if (a2)
  {
    __int16 v17 = (Phase::Logger *)__cxa_begin_catch(a1);
    int v18 = **(id **)(Phase::Logger::GetInstance(v17) + 832);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 136315394;
      *(void *)((char *)&buf + 4) = "DispatcherGeometryClientDirect.mm";
      WORD6(buf) = 1024;
      *(_DWORD *)((char *)&buf + 14) = 415;
      _os_log_impl(&dword_221E5E000, v18, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create geo material.", (uint8_t *)&buf, 0x12u);
    }
    __cxa_end_catch();
    JUMPOUT(0x221F08000);
  }
  JUMPOUT(0x221F08084);
}

void sub_221F08114()
{
}

void sub_221F08120(void *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  JUMPOUT(0x221F08084);
}

void Phase::Dispatch::sCopyMaterialData(id *a1, uint64_t a2)
{
  uint64_t v4 = [*a1 count];
  *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
  *(_OWORD *)(a2 + 124) = 0u;
  *(_DWORD *)(a2 + 140) = v4;
  *(_OWORD *)(a2 + 144) = 0u;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 17std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 252) = 0u;
  *(_DWORD *)(a2 + 268) = v4;
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      uint64_t v6 = [*a1 objectAtIndexedSubscript:i];
      [v6 frequency];
      *(_DWORD *)(a2 + 4 * i + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v7;

      unint64_t v8 = [*a1 objectAtIndexedSubscript:i];
      [v8 value];
      float v10 = v9;

      float v11 = 0.0;
      if (v10 != 1.0)
      {
        int v12 = 1;
        if (v10 > 0.0) {
          *(float *)&int v12 = v10;
        }
        float v11 = (float)((float)(logf(*(float *)&v12) * 8.6859) / 10.0) * -10.0;
      }
      *(float *)(a2 + 4 * i + 144) = v11;
    }
  }
  [a1[1] measuredDepth];
  *(_DWORD *)(a2 + 272) = v13;
  int v14 = [a1[2] absorptionCoefficients];
  uint64_t v15 = [v14 count];

  *(_OWORD *)(a2 + 39std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 368) = 0u;
  *(_OWORD *)(a2 + 384) = 0u;
  *(_OWORD *)(a2 + 33std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_DWORD *)(a2 + 4std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v15;
  *(_OWORD *)(a2 + 41std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 432) = 0u;
  *(_OWORD *)(a2 + 448) = 0u;
  *(_OWORD *)(a2 + 464) = 0u;
  *(_OWORD *)(a2 + 480) = 0u;
  *(_OWORD *)(a2 + 49std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 5std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
  *(_OWORD *)(a2 + 524) = 0u;
  *(_DWORD *)(a2 + 540) = v15;
  if (v15)
  {
    for (uint64_t j = 0; j != v15; ++j)
    {
      __int16 v17 = [a1[2] absorptionCoefficients];
      int v18 = [v17 objectAtIndexedSubscript:j];
      [v18 frequency];
      *(_DWORD *)(a2 + 4 * j + 288) = v19;

      uint64_t v20 = [a1[2] absorptionCoefficients];
      int v21 = [v20 objectAtIndexedSubscript:j];
      [v21 value];
      *(_DWORD *)(a2 + 4 * j + 41std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v22;
    }
  }
  int v23 = [a1[3] scatteringCoefficients];
  uint64_t v24 = [v23 count];

  *(_OWORD *)(a2 + 652) = 0u;
  *(_OWORD *)(a2 + 624) = 0u;
  *(_OWORD *)(a2 + 640) = 0u;
  *(_OWORD *)(a2 + 592) = 0u;
  *(_OWORD *)(a2 + 608) = 0u;
  *(_OWORD *)(a2 + 560) = 0u;
  *(_OWORD *)(a2 + 57std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 544) = 0u;
  *(_DWORD *)(a2 + 668) = v24;
  *(_OWORD *)(a2 + 672) = 0u;
  *(_OWORD *)(a2 + 688) = 0u;
  *(_OWORD *)(a2 + 704) = 0u;
  *(_OWORD *)(a2 + 720) = 0u;
  *(_OWORD *)(a2 + 73std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 752) = 0u;
  *(_OWORD *)(a2 + 768) = 0u;
  *(_OWORD *)(a2 + 780) = 0u;
  *(_DWORD *)(a2 + 79std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v24;
  if (v24)
  {
    for (uint64_t k = 0; k != v24; ++k)
    {
      __int16 v26 = [a1[3] scatteringCoefficients];
      unint64_t v27 = [v26 objectAtIndexedSubscript:k];
      [v27 frequency];
      *(_DWORD *)(a2 + 4 * k + 544) = v28;

      float v29 = [a1[3] scatteringCoefficients];
      unint64_t v30 = [v29 objectAtIndexedSubscript:k];
      [v30 value];
      *(_DWORD *)(a2 + 4 * k + 672) = v31;
    }
  }
}

void sub_221F08408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void Phase::Dispatch::sConvertMaterialData(id *a1, uint64_t a2, unint64_t a3)
{
  if (a3 <= 2) {
    std::terminate();
  }
  unint64_t v6 = objc_msgSend(*a1, "count", sGetFrequencies((uint64_t)&v62, a3));
  std::vector<float>::vector(&v60, v6);
  std::vector<float>::vector(&v58, v6);
  if (v6)
  {
    for (uint64_t i = 0; i != v6; ++i)
    {
      unint64_t v8 = [*a1 objectAtIndexedSubscript:i];
      [v8 frequency];
      v60[i] = v9;

      float v10 = [*a1 objectAtIndexedSubscript:i];
      [v10 value];
      *((_DWORD *)v58 + i) = v11;
    }
  }
  std::vector<float>::vector(v57, a3);
  Phase::GetValuesFromFrequencyResponse<std::__wrap_iter<float *>,std::__wrap_iter<float *>,std::__wrap_iter<float const*>,std::__wrap_iter<float *>,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v60, v61, (uint64_t)v58, (uint64_t)v59, v62, v63, (uint64_t)v57[0]);
  *(_OWORD *)(a2 + 144) = 0u;
  int v12 = (float *)(a2 + 144);
  *(_OWORD *)(a2 + 124) = 0u;
  *(_OWORD *)(a2 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_DWORD *)(a2 + 140) = a3;
  *(_OWORD *)(a2 + 160) = 0u;
  *(_OWORD *)(a2 + 17std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 192) = 0u;
  *(_OWORD *)(a2 + 208) = 0u;
  *(_OWORD *)(a2 + 224) = 0u;
  *(_OWORD *)(a2 + 240) = 0u;
  *(_OWORD *)(a2 + 252) = 0u;
  *(_DWORD *)(a2 + 268) = a3;
  int v13 = v62;
  unint64_t v14 = a3;
  uint64_t v15 = (float *)v57[0];
  do
  {
    *(v12 - 32) = *v13;
    float v16 = 0.0;
    if (*v15 != 1.0)
    {
      LODWORD(v1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 1;
      if (*v15 > 0.0) {
        float v17 = *v15;
      }
      float v16 = (float)((float)(logf(v17) * 8.6859) / 10.0) * -10.0;
    }
    *v12++ = v16;
    ++v15;
    ++v13;
    --v14;
  }
  while (v14);
  [a1[1] measuredDepth];
  *(_DWORD *)(a2 + 272) = v18;
  int v19 = [a1[2] absorptionCoefficients];
  unint64_t v20 = [v19 count];

  std::vector<float>::vector(&v55, v20);
  std::vector<float>::vector(&v53, v20);
  if (v20)
  {
    for (uint64_t j = 0; j != v20; ++j)
    {
      int v22 = [a1[2] absorptionCoefficients];
      int v23 = [v22 objectAtIndexedSubscript:j];
      [v23 frequency];
      *((_DWORD *)v55 + j) = v24;

      uint64_t v25 = [a1[2] absorptionCoefficients];
      __int16 v26 = [v25 objectAtIndexedSubscript:j];
      [v26 value];
      *((_DWORD *)v53 + j) = v27;
    }
  }
  std::vector<float>::vector(v52, a3);
  Phase::GetValuesFromFrequencyResponse<std::__wrap_iter<float *>,std::__wrap_iter<float *>,std::__wrap_iter<float const*>,std::__wrap_iter<float *>,&float Phase::Identity<float>,&float Phase::Identity<float>>((float *)v55, v56, (uint64_t)v53, (uint64_t)v54, v62, v63, (uint64_t)v52[0]);
  *(_OWORD *)(a2 + 368) = 0u;
  *(_OWORD *)(a2 + 384) = 0u;
  *(_OWORD *)(a2 + 33std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 352) = 0u;
  *(_OWORD *)(a2 + 304) = 0u;
  *(_OWORD *)(a2 + 320) = 0u;
  *(_OWORD *)(a2 + 288) = 0u;
  *(_OWORD *)(a2 + 39std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_DWORD *)(a2 + 4std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = a3;
  int v28 = (_DWORD *)(a2 + 416);
  *(_OWORD *)(a2 + 41std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 432) = 0u;
  *(_OWORD *)(a2 + 448) = 0u;
  *(_OWORD *)(a2 + 464) = 0u;
  *(_OWORD *)(a2 + 480) = 0u;
  *(_OWORD *)(a2 + 49std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 5std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
  *(_OWORD *)(a2 + 524) = 0u;
  *(_DWORD *)(a2 + 540) = a3;
  float v29 = v62;
  unint64_t v30 = a3;
  int v31 = (int *)v52[0];
  do
  {
    int v32 = *(_DWORD *)v29++;
    *(v28 - 32) = v32;
    int v33 = *v31++;
    *v28++ = v33;
    --v30;
  }
  while (v30);
  uint64_t v34 = [a1[3] scatteringCoefficients];
  unint64_t v35 = [v34 count];

  std::vector<float>::vector(&v50, v35);
  std::vector<float>::vector(&v48, v35);
  if (v35)
  {
    for (uint64_t k = 0; k != v35; ++k)
    {
      int v37 = [a1[3] scatteringCoefficients];
      __int16 v38 = [v37 objectAtIndexedSubscript:k];
      [v38 frequency];
      *((_DWORD *)v50 + k) = v39;

      __int16 v40 = [a1[3] scatteringCoefficients];
      unint64_t v41 = [v40 objectAtIndexedSubscript:k];
      [v41 value];
      *((_DWORD *)v48 + k) = v42;
    }
  }
  std::vector<float>::vector(__p, a3);
  Phase::GetValuesFromFrequencyResponse<std::__wrap_iter<float *>,std::__wrap_iter<float *>,std::__wrap_iter<float const*>,std::__wrap_iter<float *>,&float Phase::Identity<float>,&float Phase::Identity<float>>((float *)v50, v51, (uint64_t)v48, (uint64_t)v49, v62, v63, (uint64_t)__p[0]);
  uint64_t v43 = 0;
  *(_OWORD *)(a2 + 624) = 0u;
  *(_OWORD *)(a2 + 640) = 0u;
  *(_OWORD *)(a2 + 592) = 0u;
  *(_OWORD *)(a2 + 608) = 0u;
  *(_OWORD *)(a2 + 560) = 0u;
  *(_OWORD *)(a2 + 57std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 544) = 0u;
  *(_OWORD *)(a2 + 652) = 0u;
  *(_DWORD *)(a2 + 668) = a3;
  *(_OWORD *)(a2 + 672) = 0u;
  *(_OWORD *)(a2 + 688) = 0u;
  *(_OWORD *)(a2 + 704) = 0u;
  *(_OWORD *)(a2 + 720) = 0u;
  *(_OWORD *)(a2 + 73std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a2 + 752) = 0u;
  *(_OWORD *)(a2 + 768) = 0u;
  *(_OWORD *)(a2 + 780) = 0u;
  *(_DWORD *)(a2 + 79std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
  uint64_t v44 = v62;
  uint64_t v45 = __p[0];
  do
  {
    uint64_t v46 = a2 + 4 * v43;
    *(float *)(v46 + 544) = v44[v43];
    *(_DWORD *)(v46 + 672) = v45[v43++];
  }
  while (a3 != v43);
  __p[1] = v45;
  operator delete(v45);
  if (v48)
  {
    long long v49 = v48;
    operator delete(v48);
  }
  if (v50)
  {
    unint64_t v51 = (float *)v50;
    operator delete(v50);
  }
  if (v52[0])
  {
    v52[1] = v52[0];
    operator delete(v52[0]);
  }
  if (v53)
  {
    unint64_t v54 = v53;
    operator delete(v53);
  }
  if (v55)
  {
    char v56 = (float *)v55;
    operator delete(v55);
  }
  if (v57[0])
  {
    v57[1] = v57[0];
    operator delete(v57[0]);
  }
  if (v58)
  {
    float32x2_t v59 = v58;
    operator delete(v58);
  }
  if (v60)
  {
    char v61 = v60;
    operator delete(v60);
  }
  if (v62)
  {
    long long v63 = v62;
    operator delete(v62);
  }
}

void sub_221F08918(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31)
{
  if (__p) {
    operator delete(__p);
  }
  if (a12) {
    operator delete(a12);
  }
  if (a15) {
    operator delete(a15);
  }
  if (a18) {
    operator delete(a18);
  }
  if (a21) {
    operator delete(a21);
  }
  if (a24) {
    operator delete(a24);
  }
  if (a27) {
    operator delete(a27);
  }
  if (a30) {
    operator delete(a30);
  }
  int v33 = *(void **)(v31 - 160);
  if (v33)
  {
    *(void *)(v31 - 152) = v33;
    operator delete(v33);
  }
  uint64_t v34 = *(void **)(v31 - 136);
  if (v34)
  {
    *(void *)(v31 - 128) = v34;
    operator delete(v34);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::CreateShape(uint64_t a1, unsigned int a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v5 = (Phase::Logger *)Phase::Geometry::ShapeFactory::Create((uint64_t *)(*(void *)(a1 + 8) + 1200), a2, a3, a4, &v9);
  if (v9)
  {
    uint64_t v6 = Phase::Geometry::SystemScheduler::AddToDatabase(*(void *)(a1 + 8) + 2352, &v9);
  }
  else
  {
    int v7 = **(id **)(Phase::Logger::GetInstance(v5) + 832);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      int v12 = "DispatcherGeometryClientDirect.mm";
      __int16 v13 = 1024;
      int v14 = 434;
      _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to create geo shape.", buf, 0x12u);
    }
    uint64_t v6 = 0;
  }
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  return v6;
}

void sub_221F08B98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

Phase::Logger *Phase::Dispatch::GeometryClientDirectDispatcher::CreateDirectivityModel(uint64_t a1, unsigned __int8 *a2, int a3)
{
  return Phase::Controller::CreateDirectivityModelHandle(a2, *(void *)(a1 + 8), a3);
}

unint64_t Phase::Dispatch::GeometryClientDirectDispatcher::CreateDistanceModel(uint64_t a1, double *a2)
{
  return Phase::Controller::CreateDistanceModelHandle(a2, *(void *)(a1 + 8));
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::Copy(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Phase::Geometry::SystemScheduler::Copy(*(void *)(a1 + 8) + 2352, a2, a3);
}

void Phase::Dispatch::GeometryClientDirectDispatcher::GetSceneRoot(Phase::Dispatch::GeometryClientDirectDispatcher *this)
{
  uint64_t v1 = *MEMORY[0x263EF8340];
  Phase::Geometry::CreateEntity<Phase::Geometry::Entity>();
}

void sub_221F08D08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::SetMaterial(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return Phase::Geometry::SystemScheduler::SetMaterial(*(void *)(a1 + 8) + 2352, a2, a3, a4);
}

void Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(uint64_t a1, uint64_t a2, id *a3)
{
  *(void *)&v22[5] = *MEMORY[0x263EF8340];
  id v6 = *a3;
  id v7 = a3[1];
  id v8 = a3[2];
  uint64_t v9 = (Phase::Logger *)a3[3];
  float v10 = **(id **)(Phase::Logger::GetInstance(v9) + 848);
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315650;
    int v18 = "DispatcherGeometryClientDirect.mm";
    __int16 v19 = 1024;
    int v20 = 544;
    __int16 v21 = 2048;
    *(void *)int v22 = a2;
    _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Updating Material 0x%llx", buf, 0x1Cu);
  }
  uint64_t v11 = *(void *)(a1 + 8);
  id v12 = v6;
  id v13 = v7;
  id v14 = v8;
  uint64_t v15 = v9;
  float v16 = operator new(0x30uLL);
  void *v16 = &unk_26D4752A8;
  v16[1] = v12;
  void v16[2] = v13;
  v16[3] = v14;
  v16[4] = v15;
  v16[5] = a2;
  *(void *)&v22[1] = v16;
  Phase::Geometry::SystemScheduler::RunFunction(v11 + 2352, (uint64_t)buf);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](buf);
}

void sub_221F08EE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  id v3 = va_arg(va1, id);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va1);
  Phase::Dispatch::ExternalStreamClientDirectDispatcher::RemoveExternalStream(NSUUID *,NSUUID *,void({block_pointer})(NSError *))::$_0::~$_0((id *)va);
  _Unwind_Resume(a1);
}

void Phase::Dispatch::GeometryClientDirectDispatcher::AddShapes(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(uint64_t a1, uint64_t a2, float a3)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 8) + 2352;
  v5[0] = &unk_26D4752F0;
  v5[1] = a2;
  void v5[2] = LODWORD(a3);
  v5[3] = v5;
  Phase::Geometry::SystemScheduler::RunFunction(v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v5);
}

void sub_221F08FC0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(uint64_t a1, uint64_t a2, float a3)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 8) + 2352;
  v5[0] = &unk_26D475338;
  v5[1] = a2;
  void v5[2] = LODWORD(a3);
  v5[3] = v5;
  Phase::Geometry::SystemScheduler::RunFunction(v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v5);
}

void sub_221F09064(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(uint64_t a1, const void *a2)
{
  v7[4] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 24);
  uint64_t v4 = *(void *)(a1 + 8) + 2352;
  uint64_t v5 = operator new(0x2D0uLL);
  void *v5 = &unk_26D4753C8;
  memcpy(v5 + 1, a2, 0x2C0uLL);
  v5[89] = v3;
  void v7[3] = v5;
  Phase::Geometry::SystemScheduler::RunFunction(v4, (uint64_t)v7);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v7);
}

void sub_221F09134(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetEnableRoomAcousticParametersTracking(Phase::Dispatch::GeometryClientDirectDispatcher *this, uint64_t a2)
{
  return Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode((uint64_t)this, a2 << 63 >> 63);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D475380;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F091DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(Phase::Dispatch::GeometryClientDirectDispatcher *this, float a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 1);
  uint64_t v4 = &unk_26D475410;
  float v5 = a2;
  uint64_t v6 = &v4;
  Phase::Geometry::SystemScheduler::RunFunction(v2 + 2352, (uint64_t)&v4);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](&v4);
}

void sub_221F09280(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(Phase::Dispatch::GeometryClientDirectDispatcher *this, char a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 1);
  uint64_t v4 = &unk_26D475458;
  char v5 = a2;
  uint64_t v6 = &v4;
  Phase::Geometry::SystemScheduler::RunFunction(v2 + 2352, (uint64_t)&v4);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](&v4);
}

void sub_221F09324(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(Phase::Dispatch::GeometryClientDirectDispatcher *this, float a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 1);
  uint64_t v4 = &unk_26D4754A0;
  float v5 = a2;
  uint64_t v6 = &v4;
  Phase::Geometry::SystemScheduler::RunFunction(v2 + 2352, (uint64_t)&v4);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](&v4);
}

void sub_221F093C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(Phase::Dispatch::GeometryClientDirectDispatcher *this, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 1) + 2352;
  v4[0] = &unk_26D4754E8;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F09468(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(uint64_t a1, _OWORD *a2)
{
  void v6[4] = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 8) + 2352;
  uint64_t v4 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v4 = &unk_26D475530;
  *(_OWORD *)(v4 + 8) = *a2;
  v6[3] = v4;
  Phase::Geometry::SystemScheduler::RunFunction(v3, (uint64_t)v6);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v6);
}

void sub_221F0951C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(Phase::Dispatch::GeometryClientDirectDispatcher *this, float a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v2 = *((void *)this + 1);
  uint64_t v4 = &unk_26D475578;
  float v5 = a2;
  uint64_t v6 = &v4;
  Phase::Geometry::SystemScheduler::RunFunction(v2 + 2352, (uint64_t)&v4);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](&v4);
}

void sub_221F095C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D4755C0;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F09660(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::SetDefaultSceneReverbPreset(Phase::Dispatch::GeometryClientDirectDispatcher *this, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v4 = **(id **)(Phase::Logger::GetInstance(this) + 848);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136315650;
    uint64_t v7 = "DispatcherGeometryClientDirect.mm";
    __int16 v8 = 1024;
    int v9 = 775;
    __int16 v10 = 2048;
    uint64_t v11 = a2;
    _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Setting scene reverb preset 0x%llx", (uint8_t *)&v6, 0x1Cu);
  }
  return Phase::Geometry::SystemScheduler::SetDefaultSceneReverbPreset((Phase::Geometry::SystemScheduler *)(*((void *)this + 1) + 2352), a2);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::SetDefaultSceneMedium(Phase::Logger *a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v4 = **(id **)(Phase::Logger::GetInstance(a1) + 848);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136315650;
    uint64_t v7 = "DispatcherGeometryClientDirect.mm";
    __int16 v8 = 1024;
    int v9 = 782;
    __int16 v10 = 2048;
    uint64_t v11 = a2;
    _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Setting scene medium 0x%llx", (uint8_t *)&v6, 0x1Cu);
  }
  return Phase::Geometry::SystemScheduler::SetDefaulSceneMedium(*((void *)a1 + 1) + 2352, a2);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Logger *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v6 = a3;
  uint64_t v7 = **(id **)(Phase::Logger::GetInstance(a1) + 848);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v8 = "false";
    *(void *)&v11[4] = "DispatcherGeometryClientDirect.mm";
    *(_WORD *)&v11[12] = 1024;
    *(_DWORD *)&v11[14] = 807;
    *(_DWORD *)uint64_t v11 = 136315906;
    if (a3) {
      __int16 v8 = "true";
    }
    *(_WORD *)&v11[18] = 2080;
    *(void *)&v11[20] = v8;
    *(_WORD *)&v11[28] = 2048;
    *(void *)&v11[30] = a2;
    _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Setting isStatic to %s on occluder 0x%llx", v11, 0x26u);
  }
  uint64_t v9 = *((void *)a1 + 1) + 2352;
  *(void *)uint64_t v11 = &unk_26D475608;
  *(void *)&v11[8] = a2;
  *(void *)&uint8_t v11[16] = v6;
  *(void *)&v11[24] = v11;
  Phase::Geometry::SystemScheduler::RunFunction(v9, (uint64_t)v11);
  return std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v11);
}

void sub_221F09990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerHeadTracking(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 832);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "false";
    __int16 v10 = "DispatcherGeometryClientDirect.mm";
    __int16 v11 = 1024;
    int v12 = 815;
    int v9 = 136315906;
    if (a3) {
      uint64_t v7 = "true";
    }
    __int16 v13 = 2080;
    id v14 = v7;
    __int16 v15 = 2048;
    uint64_t v16 = a2;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Setting tracking to %s on listener 0x%llx", (uint8_t *)&v9, 0x26u);
  }
  return Phase::Controller::ListenerManager::SetTracking(a1[2], a2, a3);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::AddChild(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Phase::Geometry::SystemScheduler::AddChild(*(void *)(a1 + 8) + 2352, a2, a3);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::RemoveChild(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Phase::Geometry::SystemScheduler::RemoveChild(*(void *)(a1 + 8) + 2352, a2, a3);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::UpdateTransform(uint64_t a1, uint64_t a2, long long *a3, int a4)
{
  if (a4) {
    return Phase::Controller::ListenerManager::UpdateTransform(*(void *)(a1 + 16), a2, a3);
  }
  else {
    return Phase::Geometry::SystemScheduler::UpdateTransform(*(void *)(a1 + 8) + 2352, a2, a3);
  }
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::ReleaseSceneRoot(uint64_t a1, uint64_t a2)
{
  return Phase::Geometry::SystemScheduler::ReleaseEntity(*(void *)(a1 + 8) + 2352, a2);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::ReleaseEntity(uint64_t a1, uint64_t a2)
{
  Phase::Controller::ListenerManager::RemoveListener(*(void *)(a1 + 16), a2);
  uint64_t v4 = *(void *)(a1 + 8) + 2352;

  return Phase::Geometry::SystemScheduler::ReleaseEntity(v4, a2);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::ReleaseMedium(uint64_t a1, uint64_t a2)
{
  return Phase::Geometry::SystemScheduler::ReleaseMedium(*(void *)(a1 + 8) + 2352, a2);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::ReleaseMaterial(uint64_t a1, uint64_t a2)
{
  return Phase::Geometry::SystemScheduler::ReleaseMaterial(*(void *)(a1 + 8) + 2352, a2);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::ReleaseShape(uint64_t a1, uint64_t a2)
{
  return Phase::Geometry::SystemScheduler::ReleaseShape(*(void *)(a1 + 8) + 2352, a2);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::ReleaseDirectivity(uint64_t a1, uint64_t a2)
{
  return Phase::Geometry::SystemScheduler::ReleaseDirectivity(*(void *)(a1 + 8) + 2352, a2);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::ReleaseDistanceModel(uint64_t a1, uint64_t a2)
{
  return Phase::Geometry::SystemScheduler::ReleaseDistanceModel(*(void *)(a1 + 8) + 2352, a2);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v16[4] = *MEMORY[0x263EF8340];
  uint64_t v15 = a2;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::__value_func[abi:ne180100]((uint64_t)v16, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v10 = v15;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::__value_func[abi:ne180100]((uint64_t)v11, (uint64_t)v16);
  id v14 = 0;
  float v5 = operator new(0x30uLL);
  uint64_t v6 = v5;
  uint64_t v7 = v12;
  void *v5 = &unk_26D475650;
  v5[1] = v10;
  if (v7)
  {
    if (v7 == v11)
    {
      void v5[5] = v5 + 2;
      (*(void (**)(void *))(v11[0] + 24))(v11);
      goto LABEL_7;
    }
    __int16 v8 = &v12;
    void v5[5] = v7;
  }
  else
  {
    __int16 v8 = v5 + 5;
  }
  void *v8 = 0;
LABEL_7:
  id v14 = v6;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v4 + 2352, (uint64_t)v13);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v13);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100](v11);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100](v16);
}

void sub_221F09CC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D475698;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F09DA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v16[4] = *MEMORY[0x263EF8340];
  uint64_t v15 = a2;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::__value_func[abi:ne180100]((uint64_t)v16, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v10 = v15;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::__value_func[abi:ne180100]((uint64_t)v11, (uint64_t)v16);
  id v14 = 0;
  float v5 = operator new(0x30uLL);
  uint64_t v6 = v5;
  uint64_t v7 = v12;
  void *v5 = &unk_26D4756E0;
  v5[1] = v10;
  if (v7)
  {
    if (v7 == v11)
    {
      void v5[5] = v5 + 2;
      (*(void (**)(void *))(v11[0] + 24))(v11);
      goto LABEL_7;
    }
    __int16 v8 = &v12;
    void v5[5] = v7;
  }
  else
  {
    __int16 v8 = v5 + 5;
  }
  void *v8 = 0;
LABEL_7:
  id v14 = v6;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v4 + 2352, (uint64_t)v13);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v13);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](v11);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](v16);
}

void sub_221F09EFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D475728;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F09FD8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v16[4] = *MEMORY[0x263EF8340];
  uint64_t v15 = a2;
  std::__function::__value_func<void ()(unsigned int,void const*)>::__value_func[abi:ne180100]((uint64_t)v16, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v10 = v15;
  std::__function::__value_func<void ()(unsigned int,void const*)>::__value_func[abi:ne180100]((uint64_t)v11, (uint64_t)v16);
  id v14 = 0;
  float v5 = operator new(0x30uLL);
  uint64_t v6 = v5;
  uint64_t v7 = v12;
  void *v5 = &unk_26D475770;
  v5[1] = v10;
  if (v7)
  {
    if (v7 == v11)
    {
      void v5[5] = v5 + 2;
      (*(void (**)(void *))(v11[0] + 24))(v11);
      goto LABEL_7;
    }
    __int16 v8 = &v12;
    void v5[5] = v7;
  }
  else
  {
    __int16 v8 = v5 + 5;
  }
  void *v8 = 0;
LABEL_7:
  id v14 = v6;
  Phase::Geometry::SystemScheduler::RunFunction(v4 + 2352, (uint64_t)v13);
  std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](v13);
  std::__function::__value_func<void ()(unsigned int,void const*)>::~__value_func[abi:ne180100](v11);
  return std::__function::__value_func<void ()(unsigned int,void const*)>::~__value_func[abi:ne180100](v16);
}

void sub_221F0A134(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v20[4] = *MEMORY[0x263EF8340];
  *(void *)&long long v18 = a2;
  *((void *)&v18 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a3;
  uint64_t v19 = a4;
  std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::__value_func[abi:ne180100]((uint64_t)v20, a5);
  uint64_t v6 = *(void *)(a1 + 8);
  long long v12 = v18;
  uint64_t v13 = v19;
  std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::__value_func[abi:ne180100]((uint64_t)v14, (uint64_t)v20);
  uint64_t v17 = 0;
  uint64_t v7 = (char *)operator new(0x40uLL);
  __int16 v8 = v7;
  *(void *)uint64_t v7 = &unk_26D4757B8;
  *(_OWORD *)(v7 + 8) = v12;
  int v9 = v15;
  *((void *)v7 + 3) = v13;
  if (v9)
  {
    if (v9 == v14)
    {
      *((void *)v7 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v7 + 32;
      (*(void (**)(void *))(v14[0] + 24))(v14);
      goto LABEL_7;
    }
    uint64_t v10 = &v15;
    *((void *)v7 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v9;
  }
  else
  {
    uint64_t v10 = v7 + 56;
  }
  void *v10 = 0;
LABEL_7:
  uint64_t v17 = v8;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v6 + 2352, (uint64_t)v16);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v16);
  std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::~__value_func[abi:ne180100](v14);
  return std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::~__value_func[abi:ne180100](v20);
}

void sub_221F0A2E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  if (a2) {
    __clang_call_terminate(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[4] = *MEMORY[0x263EF8340];
  uint64_t v11 = a2;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v12, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v7 = v11;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v8, (uint64_t)v12);
  uint64_t v10 = 0;
  float v5 = operator new(0x30uLL);
  void *v5 = &unk_26D475800;
  v5[1] = v7;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v5 + 2), (uint64_t)v8);
  uint64_t v10 = v5;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v4 + 2352, (uint64_t)v9);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v9);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v12);
}

void sub_221F0A42C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v7);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D475848;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F0A4F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[4] = *MEMORY[0x263EF8340];
  uint64_t v11 = a2;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v12, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v7 = v11;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v8, (uint64_t)v12);
  uint64_t v10 = 0;
  float v5 = operator new(0x30uLL);
  void *v5 = &unk_26D475890;
  v5[1] = v7;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v5 + 2), (uint64_t)v8);
  uint64_t v10 = v5;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v4 + 2352, (uint64_t)v9);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v9);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v12);
}

void sub_221F0A604(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v7);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D4758D8;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F0A6CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[4] = *MEMORY[0x263EF8340];
  uint64_t v11 = a2;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v12, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v7 = v11;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v8, (uint64_t)v12);
  uint64_t v10 = 0;
  float v5 = operator new(0x30uLL);
  void *v5 = &unk_26D475920;
  v5[1] = v7;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v5 + 2), (uint64_t)v8);
  uint64_t v10 = v5;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v4 + 2352, (uint64_t)v9);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v9);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v12);
}

void sub_221F0A7DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v7);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D475968;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F0A8A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[4] = *MEMORY[0x263EF8340];
  uint64_t v11 = a2;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v12, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v7 = v11;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v8, (uint64_t)v12);
  uint64_t v10 = 0;
  float v5 = operator new(0x30uLL);
  void *v5 = &unk_26D4759B0;
  v5[1] = v7;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v5 + 2), (uint64_t)v8);
  uint64_t v10 = v5;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v4 + 2352, (uint64_t)v9);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v9);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v12);
}

void sub_221F0A9B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v7);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D4759F8;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F0AA7C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[4] = *MEMORY[0x263EF8340];
  uint64_t v11 = a2;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v12, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v7 = v11;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v8, (uint64_t)v12);
  uint64_t v10 = 0;
  float v5 = operator new(0x30uLL);
  void *v5 = &unk_26D475A40;
  v5[1] = v7;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v5 + 2), (uint64_t)v8);
  uint64_t v10 = v5;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v4 + 2352, (uint64_t)v9);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v9);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v12);
}

void sub_221F0AB8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v7);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D475A88;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F0AC54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v12[4] = *MEMORY[0x263EF8340];
  uint64_t v11 = a2;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v12, a3);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v7 = v11;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v8, (uint64_t)v12);
  uint64_t v10 = 0;
  float v5 = operator new(0x30uLL);
  void *v5 = &unk_26D475AD0;
  v5[1] = v7;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v5 + 2), (uint64_t)v8);
  uint64_t v10 = v5;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v4 + 2352, (uint64_t)v9);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v9);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v12);
}

void sub_221F0AD60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v7);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(uint64_t a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 8) + 2352;
  v4[0] = &unk_26D475B18;
  v4[1] = a2;
  v4[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v2, (uint64_t)v4);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v4);
}

void sub_221F0AE28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::Dispatch::GeometryClientDirectDispatcher *this, RuntimeDebugParameters *a2)
{
  v7[4] = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)this + 1) + 2352;
  uint64_t v4 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v4 = &unk_26D475B60;
  long long v5 = *(_OWORD *)&a2->mLateReverbRayTraceComputeTimeLimit;
  *(_OWORD *)(v4 + 8) = *(_OWORD *)&a2->mTailcorrectionEnabled;
  *(_OWORD *)(v4 + 24) = v5;
  *(_OWORD *)(v4 + 40) = *(_OWORD *)&a2->mRayTraceIntersectionHandleCounter;
  *((void *)v4 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *(void *)&a2->mEarlyScatteringAggregationCoef;
  void v7[3] = v4;
  Phase::Geometry::SystemScheduler::RunDebugFunction(v3, (uint64_t)v7);
  return std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](v7);
}

void sub_221F0AEF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Dispatch::GeometryClientDirectDispatcher::GetTransactionBuffer(Phase::Dispatch::GeometryClientDirectDispatcher *this)
{
  return 0;
}

void Phase::Dispatch::GeometryClientDirectDispatcher::~GeometryClientDirectDispatcher(Phase::Dispatch::GeometryClientDirectDispatcher *this)
{
}

void sub_221F0AFF4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__value_func<void ()(unsigned int,void const*)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

id *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::~__func(id *a1)
{
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::~__func(id *a1)
{
  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = operator new(0x30uLL);
  void *v2 = &unk_26D4752A8;
  std::__compressed_pair_elem<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0 const&,0ul>(v2 + 1, v1);
  return v2;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D4752A8;
  return std::__compressed_pair_elem<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0 const&,0ul>(a2 + 1, a1 + 8);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::destroy(uint64_t a1)
{
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::destroy_deallocate(void **a1)
{
  std::__function::__alloc_func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::destroy[abi:ne180100](a1 + 1);

  operator delete(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v3 = *a2;
  UniqueSlot = (std::__shared_weak_count *)Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::GetUniqueSlot(*a2 + 744, *(void *)(a1 + 40));
  if (!UniqueSlot) {
    goto LABEL_16;
  }
  long long v5 = UniqueSlot;
  uint64_t shared_owners = UniqueSlot->__shared_owners_;
  if (shared_owners && *(uint64_t *)(shared_owners + 8) >= 1)
  {
    uint64_t v7 = *(void *)(v3 + 944);
    if (!v7) {
      std::terminate();
    }
    __int16 v8 = (unsigned int *)v5->__vftable;
    Phase::Geometry::MaterialFactory::Create(v7, (unsigned int *)v5->__vftable, 0, v20);
    int v9 = *(std::__shared_weak_count_vtbl **)v20;
    if (*(void *)v20) {
      *(void *)(*(void *)v20 + 8) = *((void *)v8 + 1);
    }
    uint64_t v10 = *(void *)&v20[8];
    *(void *)int v20 = 0;
    *(void *)&v20[8] = 0;
    UniqueSlot = (std::__shared_weak_count *)v5->__shared_owners_;
    v5->__vftable = v9;
    v5->__shared_owners_ = v10;
    if (UniqueSlot)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](UniqueSlot);
      UniqueSlot = *(std::__shared_weak_count **)&v20[8];
      if (*(void *)&v20[8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v20[8]);
      }
    }
  }
  uint64_t v11 = (unsigned int *)v5->__vftable;
  if (!v11)
  {
LABEL_16:
    long long v18 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)UniqueSlot) + 832);
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int v20 = 136315394;
    *(void *)&v20[4] = "DispatcherGeometryClientDirect.mm";
    *(_WORD *)&v20[12] = 1024;
    *(_DWORD *)&v20[14] = 509;
    uint64_t v19 = "%25s:%-5d Unable to find geo material to update.";
    goto LABEL_18;
  }
  uint64_t v12 = **((void **)v11 + 5);
  if (v12)
  {
    uint64_t v13 = (id *)(a1 + 8);
    Phase::Dispatch::sCopyMaterialData(v13, v12);
    uint64_t v15 = (unint64_t *)qword_2220A5778;
    uint64_t v16 = 40;
    while (1)
    {
      uint64_t v17 = *(void *)(*((void *)v11 + 5) + v16);
      if (!v17) {
        break;
      }
      Phase::Dispatch::sConvertMaterialData(v13, v17, *v15);
      v16 += 40;
      ++v15;
      if (v16 == 160) {
        return;
      }
    }
    long long v18 = **(id **)(Phase::Logger::GetInstance(v14) + 832);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v20 = 136315394;
      *(void *)&v20[4] = "DispatcherGeometryClientDirect.mm";
      *(_WORD *)&v20[12] = 1024;
      *(_DWORD *)&v20[14] = 529;
      uint64_t v19 = "%25s:%-5d Unable to find internal geo material map to update.";
      goto LABEL_18;
    }
  }
  else
  {
    long long v18 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)UniqueSlot) + 832);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v20 = 136315394;
      *(void *)&v20[4] = "DispatcherGeometryClientDirect.mm";
      *(_WORD *)&v20[12] = 1024;
      *(_DWORD *)&v20[14] = 517;
      uint64_t v19 = "%25s:%-5d Unable to find user geo material map to update.";
LABEL_18:
      _os_log_impl(&dword_221E5E000, v18, OS_LOG_TYPE_ERROR, v19, v20, 0x12u);
    }
  }
}

void sub_221F0B560(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
  if (a2)
  {
    int v9 = (Phase::Logger *)__cxa_begin_catch(exception_object);
    uint64_t v10 = **(id **)(Phase::Logger::GetInstance(v9) + 832);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(a9) = 136315394;
      *(void *)((char *)&a9 + 4) = "DispatcherGeometryClientDirect.mm";
      WORD6(a9) = 1024;
      *(_DWORD *)((char *)&a9 + 14) = 538;
      _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_ERROR, "%25s:%-5d Unable to update geo material.", (uint8_t *)&a9, 0x12u);
    }
    __cxa_end_catch();
    JUMPOUT(0x221F0B474);
  }
  _Unwind_Resume(exception_object);
}

void *std::__compressed_pair_elem<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,0,false>::__compressed_pair_elem[abi:ne180100]<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0 const&,0ul>(void *a1, uint64_t a2)
{
  *a1 = *(id *)a2;
  a1[1] = *(id *)(a2 + 8);
  a1[2] = *(id *)(a2 + 16);
  id v4 = *(id *)(a2 + 24);
  uint64_t v5 = *(void *)(a2 + 32);
  a1[3] = v4;
  a1[4] = v5;
  return a1;
}

void std::__function::__alloc_func<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::UpdateMaterial(Phase::Handle64,Phase::Dispatch::MaterialData const&)::$_0>,void ()(Phase::Geometry::System *)>::destroy[abi:ne180100](void **a1)
{
  uint64_t v2 = *a1;
}

uint64_t Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::GetUniqueSlot(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 16) <= a2) {
    return 0;
  }
  unsigned int v3 = a2;
  uint64_t result = *(void *)a1 + 24 * a2;
  if (*(_DWORD *)(result + 20) != HIDWORD(a2)) {
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (v5)
  {
    if (*(uint64_t *)(v5 + 8) >= 1)
    {
      Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::Realloc((uint64_t *)a1);
      return *(void *)a1 + 24 * v3;
    }
  }
  return result;
}

void Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::Realloc(uint64_t *a1)
{
  unint64_t v1 = *((unsigned int *)a1 + 4);
  if (v1)
  {
    Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::AllocSlots(v1, &v15);
    if (*((_DWORD *)a1 + 4))
    {
      uint64_t v3 = 0;
      unint64_t v4 = 0;
      do
      {
        uint64_t v5 = *a1;
        uint64_t v6 = (uint64_t *)(*a1 + v3);
        uint64_t v7 = v15;
        uint64_t v9 = *v6;
        uint64_t v8 = v6[1];
        if (v8) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v10 = (void *)(v7 + v3);
        uint64_t v11 = *(std::__shared_weak_count **)(v7 + v3 + 8);
        void *v10 = v9;
        v10[1] = v8;
        if (v11) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v11);
        }
        void v10[2] = *(void *)(v5 + v3 + 16);
        ++v4;
        v3 += 24;
      }
      while (v4 < *((unsigned int *)a1 + 4));
    }
    uint64_t v13 = a1 + 4;
    char v14 = 1;
    std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 4));
    long long v12 = *(_OWORD *)a1;
    *(_OWORD *)a1 = v15;
    long long v15 = v12;
    std::unique_lock<std::shared_mutex>::~unique_lock[abi:ne180100]((uint64_t)&v13);
    if (*((void *)&v15 + 1)) {
      std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v15 + 1));
    }
  }
}

void sub_221F0B814(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::__shared_weak_count *a12)
{
  if (a12) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a12);
  }
  _Unwind_Resume(exception_object);
}

void Phase::details::SharedSlotMap<Phase::Geometry::Material,Phase::Handle64>::AllocSlots(unint64_t a1@<X1>, void *a2@<X8>)
{
  if (a1)
  {
    is_mul_ok(a1, 0x18uLL);
    operator new[]();
  }
  *a2 = 0;
  a2[1] = 0;
}

void std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot []>::shared_ptr[abi:ne180100]<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot,void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_221F0B948(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  a10 = 0;
  if (v10) {
    std::default_delete<Phase::SharedSlotMapState<Phase::Geometry::Entity,Phase::Handle64>::Slot>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  }
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

void std::__shared_ptr_pointer<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot *,std::shared_ptr<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot[]>::__shared_ptr_default_delete<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot[],Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot>,std::allocator<Phase::SharedSlotMapState<Phase::Geometry::Material,Phase::Handle64>::Slot>>::__on_zero_shared(uint64_t a1)
{
}

void *std::__function::__value_func<void ()(Phase::Geometry::System *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(Phase::Handle64,float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(Phase::Handle64,float)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(Phase::Handle64,float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(Phase::Handle64,float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26D4752F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(Phase::Handle64,float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(Phase::Handle64,float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D4752F0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(Phase::Handle64,float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSourceGain(Phase::Handle64,float)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (*a2)
  {
    uint64_t v3 = (double *)Phase::Geometry::GetUniqueEntityChecked<Phase::Geometry::Source>(*a2 + 1240, *(void *)(a1 + 8));
    if (v3)
    {
      v3[21] = *(float *)(a1 + 16);
    }
    else
    {
      unint64_t v4 = **(id **)(Phase::Logger::GetInstance(0) + 832);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = 136315394;
        uint64_t v6 = "DispatcherGeometryClientDirect.mm";
        __int16 v7 = 1024;
        int v8 = 567;
        _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d Couldn't set gain on the source, geometry system doesn't have the source!", (uint8_t *)&v5, 0x12u);
      }
    }
  }
}

_DWORD *Phase::Geometry::GetUniqueEntityChecked<Phase::Geometry::Source>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA = (_DWORD **)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(a1, a2, (uint64_t)&v4);
  if (!UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA) {
    return 0;
  }
  __n128 result = *UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
  if (!result || *result != 3) {
    return 0;
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(Phase::Handle64,float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(Phase::Handle64,float)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(Phase::Handle64,float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(Phase::Handle64,float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26D475338;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(Phase::Handle64,float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(Phase::Handle64,float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D475338;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(Phase::Handle64,float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetListenerGain(Phase::Handle64,float)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  if (*a2)
  {
    uint64_t v3 = (double *)Phase::Geometry::GetUniqueEntityChecked<Phase::Geometry::Listener>(*a2 + 1240, *(void *)(a1 + 8));
    if (v3)
    {
      v3[22] = *(float *)(a1 + 16);
    }
    else
    {
      uint64_t v4 = **(id **)(Phase::Logger::GetInstance(0) + 832);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = 136315394;
        uint64_t v6 = "DispatcherGeometryClientDirect.mm";
        __int16 v7 = 1024;
        int v8 = 591;
        _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d Couldn't set gain on the listener, geometry system doesn't have the listener!", (uint8_t *)&v5, 0x12u);
      }
    }
  }
}

_DWORD *Phase::Geometry::GetUniqueEntityChecked<Phase::Geometry::Listener>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1;
  UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA = (_DWORD **)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(a1, a2, (uint64_t)&v4);
  if (!UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA) {
    return 0;
  }
  __n128 result = *UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA;
  if (!result || *result != 2) {
    return 0;
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(PHASERoomAcousticTrackingMode)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(PHASERoomAcousticTrackingMode)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(PHASERoomAcousticTrackingMode)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(PHASERoomAcousticTrackingMode)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D475380;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(PHASERoomAcousticTrackingMode)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(PHASERoomAcousticTrackingMode)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D475380;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(PHASERoomAcousticTrackingMode)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTrackingMode(PHASERoomAcousticTrackingMode)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t result, uint64_t a2)
{
  if (*(void *)a2) {
    *(_DWORD *)(*(void *)a2 + 1480) = *(void *)(result + 8);
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(Phase::Geometry::TargetRoomAcousticParametersMultiBand const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(Phase::Geometry::TargetRoomAcousticParametersMultiBand const&)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(Phase::Geometry::TargetRoomAcousticParametersMultiBand const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(Phase::Geometry::TargetRoomAcousticParametersMultiBand const&)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  unint64_t v1 = (const void *)(a1 + 8);
  uint64_t v2 = operator new(0x2D0uLL);
  void *v2 = &unk_26D4753C8;
  memcpy(v2 + 1, v1, 0x2C8uLL);
  return v2;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(Phase::Geometry::TargetRoomAcousticParametersMultiBand const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(Phase::Geometry::TargetRoomAcousticParametersMultiBand const&)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D4753C8;
  return memcpy(a2 + 1, (const void *)(a1 + 8), 0x2C8uLL);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(Phase::Geometry::TargetRoomAcousticParametersMultiBand const&)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticTarget(Phase::Geometry::TargetRoomAcousticParametersMultiBand const&)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, std::chrono::steady_clock::time_point **a2, double a3)
{
  uint64_t v4 = (const void *)(a1 + 8);
  int v5 = *a2;
  if (*a2)
  {
    memcpy((char *)&v5[185].__d_.__rep_ + 4, v4, 0x2C0uLL);
    v5[274].__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  }
  uint64_t v6 = *(void *)(a1 + 712);
  if (v6)
  {
    Phase::Controller::RoomCongruenceManager::SetTargetRoomAcousticParameters(v6, (uint64_t)v4, a3);
  }
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(float)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

_DWORD *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_26D475410;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D475410;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

float std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticMaximumReverbTime(float)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    float result = *(float *)(a1 + 8);
    *(float *)(*(void *)a2 + 2200) = result;
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(BOOL)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(BOOL)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

unsigned char *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(BOOL)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(BOOL)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  *(void *)float result = &unk_26D475458;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(BOOL)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(BOOL)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D475458;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(BOOL)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSoftLimiting(BOOL)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t result, uint64_t a2)
{
  if (*(void *)a2) {
    *(unsigned char *)(*(void *)a2 + 2204) = *(unsigned char *)(result + 8);
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(float)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

_DWORD *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  *(void *)float result = &unk_26D4754A0;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D4754A0;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

float std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomAcousticSmoothing(float)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    float result = *(float *)(a1 + 8);
    *(float *)(*(void *)a2 + 2208) = result;
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(unsigned long long)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(unsigned long long)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(unsigned long long)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(unsigned long long)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_26D4754E8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(unsigned long long)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(unsigned long long)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4754E8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(unsigned long long)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPreset(unsigned long long)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t result, uint64_t a2)
{
  if (*(void *)a2) {
    *(void *)(*(void *)a2 + 221std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(result + 8);
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(Phase::Quaternion<float>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(Phase::Quaternion<float>)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(Phase::Quaternion<float>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(Phase::Quaternion<float>)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26D475530;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

float std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(Phase::Quaternion<float>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(Phase::Quaternion<float>)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D475530;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a1 + 12);
  *(_DWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a1 + 16);
  float result = *(float *)(a1 + 20);
  *(float *)(a2 + 20) = result;
  return result;
}

float std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(Phase::Quaternion<float>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendTargetPresetOrientation(Phase::Quaternion<float>)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    *(_DWORD *)(v2 + 2224) = *(_DWORD *)(a1 + 8);
    *(_DWORD *)(v2 + 2228) = *(_DWORD *)(a1 + 12);
    *(_DWORD *)(v2 + 2232) = *(_DWORD *)(a1 + 16);
    float result = *(float *)(a1 + 20);
    *(float *)(v2 + 223std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(float)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

_DWORD *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  *(void *)float result = &unk_26D475578;
  result[2] = *(_DWORD *)(a1 + 8);
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(float)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D475578;
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(result + 8);
  return result;
}

float std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(float)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSpaceBlendLevel(float)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2)
  {
    float result = *(float *)(a1 + 8);
    *(float *)(*(void *)a2 + 2240) = result;
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(PHASESceneClassification)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(PHASESceneClassification)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(PHASESceneClassification)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(PHASESceneClassification)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_26D4755C0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(PHASESceneClassification)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(PHASESceneClassification)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4755C0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(PHASESceneClassification)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetSceneClassification(PHASESceneClassification)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t result, uint64_t a2)
{
  if (*(void *)a2)
  {
    uint64_t v2 = *(void *)(result + 8);
    if (v2 == 1935886702)
    {
      char v3 = 0;
    }
    else
    {
      if (v2 != 1935888245) {
        return result;
      }
      char v3 = 1;
    }
    *(unsigned char *)(*(void *)a2 + 2244) = v3;
  }
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Handle64,BOOL)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Handle64,BOOL)::$_0>,void ()(Phase::Geometry::System *)>::~__func()
{
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Handle64,BOOL)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Handle64,BOOL)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_26D475608;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Handle64,BOOL)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Handle64,BOOL)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D475608;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Handle64,BOOL)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetOccluderIsStatic(Phase::Handle64,BOOL)::$_0>,void ()(Phase::Geometry::System *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    *(void *)int v8 = v2 + 1240;
    UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA = (Phase::Logger *)_ZN5Phase7details13SharedSlotMapINS_8Geometry6EntityENS_8Handle64EE13GetSlotToEditIRZNS_13SharedSlotMapIS3_S4_NS2_13EntityFactoryEE9GetUniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA_(v2 + 1240, v4, (uint64_t)v8);
    if (UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA
      && (uint64_t v6 = *(void *)UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA) != 0
      && *(_DWORD *)v6 == 4)
    {
      *(unsigned char *)(v6 + 15std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(unsigned char *)(a1 + 16);
    }
    else
    {
      __int16 v7 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(UniqueES4_EUlRT_E_EEPNS_18SharedSlotMapStateIS3_S4_E4SlotES4_OSA)
                                                      + 832));
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v8 = 136315394;
        *(void *)&void v8[4] = "DispatcherGeometryClientDirect.mm";
        __int16 v9 = 1024;
        int v10 = 797;
        _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d Couldn't set isStatic on the occluder, geometry system doesn't have the occluder!", v8, 0x12u);
      }
    }
  }
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475650;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475650;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D475650;
  v2[1] = v3;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0C6EC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D475650;
  a2[1] = v2;
  return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingSource(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::__value_func[abi:ne180100]((uint64_t)v5, a1 + 16);
  Phase::SpatialModeler::DirectPathTransmissionDebugger::BeginTrackingSource(v2 + 8, v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100](v5);
}

void sub_221F0C7F0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::RenderSourceView const*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(Phase::Geometry::SystemDebugger *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D475698;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D475698;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingSource(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = (Phase::SpatialModeler::DirectPathTransmissionDebugger *)(*a2 + 8);
  v3.mData = *(void *)(a1 + 8);
  return Phase::SpatialModeler::DirectPathTransmissionDebugger::EndTrackingSource(v2, v3);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D4756E0;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D4756E0;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D4756E0;
  v2[1] = v3;
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0CA30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D4756E0;
  a2[1] = v2;
  return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingAudibleGeometry(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::__value_func[abi:ne180100]((uint64_t)v5, a1 + 16);
  Phase::SpatialModeler::DirectPathTransmissionDebugger::BeginTrackingAudibleGeometry(v2 + 8, v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100](v5);
}

void sub_221F0CB34(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::DirectPathTransmissionDebugger::AudibleTriangleView const*)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D475728;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D475728;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingAudibleGeometry(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = (Phase::SpatialModeler::DirectPathTransmissionDebugger *)(*a2 + 8);
  v3.mData = *(void *)(a1 + 8);
  return Phase::SpatialModeler::DirectPathTransmissionDebugger::EndTrackingAudibleGeometry(v2, v3);
}

uint64_t std::__function::__value_func<void ()(unsigned int,void const*)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0>,void ()(Phase::Geometry::System *)>::~__func(void *a1)
{
  *a1 = &unk_26D475770;
  std::__function::__value_func<void ()(unsigned int,void const*)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0>,void ()(Phase::Geometry::System *)>::~__func(void *a1)
{
  *a1 = &unk_26D475770;
  std::__function::__value_func<void ()(unsigned int,void const*)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D475770;
  v2[1] = v3;
  std::__function::__value_func<void ()(unsigned int,void const*)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0CD88(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0>,void ()(Phase::Geometry::System *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D475770;
  a2[1] = v2;
  return std::__function::__value_func<void ()(unsigned int,void const*)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0>,void ()(Phase::Geometry::System *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned int,void const*)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0>,void ()(Phase::Geometry::System *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned int,void const*)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetShapeInfo(Phase::Handle64,std::function<void ()(unsigned int,void const*)>)::$_0>,void ()(Phase::Geometry::System *)>::operator()(void *result, uint64_t *a2)
{
  v11[5] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = result;
    uint64_t v4 = result[1];
    if (*(_DWORD *)(v2 + 1008) > v4)
    {
      uint64_t v5 = *(void *)(v2 + 992);
      if (*(_DWORD *)(v5 + 24 * v4 + 20) == HIDWORD(v4))
      {
        uint64_t v6 = *(Phase::Logger **)(v5 + 24 * result[1]);
        if (v6)
        {
          if (*(_DWORD *)v6 == 2)
          {
            Phase::Geometry::GetVoxelTreeDebugInfo(v6, &v10);
            uint64_t v7 = v3[5];
            int v9 = *(_DWORD *)v6;
            int v8 = &v10;
            if (!v7) {
              std::__throw_bad_function_call[abi:ne180100]();
            }
            (*(void (**)(uint64_t, int *, uint64_t **))(*(void *)v7 + 48))(v7, &v9, &v8);
            std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo [],std::function<void ()(void *)>>::reset[abi:ne180100](&v10);
            return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v11);
          }
        }
      }
    }
  }
  return result;
}

void sub_221F0CF30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12)
{
}

uint64_t *std::unique_ptr<Phase::Geometry::VoxelTreeDebugInfo::VoxelSubtreeDebugInfo [],std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *__n128 result = 0;
  if (v1) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v1);
  }
  return result;
}

uint64_t std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D4757B8;
  std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::~__value_func[abi:ne180100](a1 + 4);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D4757B8;
  std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::~__value_func[abi:ne180100](a1 + 4);

  JUMPOUT(0x223C938A0);
}

char *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_26D4757B8;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 32), a1 + 32);
  return v2;
}

void sub_221F0D130(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D4757B8;
  long long v2 = *(_OWORD *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(_OWORD *)(a2 + 8) = v2;
  return std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::__value_func[abi:ne180100](a2 + 32, a1 + 32);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::~__value_func[abi:ne180100]((void *)(a1 + 32));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>::~__value_func[abi:ne180100](a1 + 4);

  operator delete(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::GetVoxels(Phase::Handle64,unsigned long,unsigned long,std::function<void ()(unsigned long,Phase::Vector<unsigned short,3ul> *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(void *a1, Phase::Geometry::System ***a2)
{
  Phase::Geometry::ShapeDebugger::GetVoxels(*a2, a1[1], a1[2], a1[3], (uint64_t)&v4);
  uint64_t v3 = a1[7];
  uint64_t v7 = __p;
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v6 - (unsigned char *)__p) >> 1);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  (*(void (**)(uint64_t, unint64_t *, void **))(*(void *)v3 + 48))(v3, &v8, &v7);
  if (__p)
  {
    uint64_t v6 = __p;
    operator delete(__p);
  }
}

void sub_221F0D268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

{
  void *v3;
  uint64_t v4;

  uint64_t v3 = (void *)(a2 + 24);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(*(void *)*v3 + 24))(*v3, a1);
      return a1;
    }
    *(void *)(a1 + 24) = v4;
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 24);
  }
  void *v3 = 0;
  return a1;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475800;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475800;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  long long v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D475800;
  v2[1] = v3;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0D41C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D475800;
  a2[1] = v2;
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRayTraceIntersections(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v5, a1 + 16);
  Phase::SpatialModeler::RoomSimulationDebugger::BeginTrackingIntersections(v2 + 40, v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v5);
}

void sub_221F0D520(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D475848;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D475848;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRayTraceIntersections(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = (Phase::SpatialModeler::RoomSimulationDebugger *)(*a2 + 40);
  v3.mData = *(void *)(a1 + 8);
  return Phase::SpatialModeler::RoomSimulationDebugger::EndTrackingIntersections(v2, v3);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475890;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475890;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D475890;
  v2[1] = v3;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0D75C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D475890;
  a2[1] = v2;
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingEnergyHistogram(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v5, a1 + 16);
  Phase::SpatialModeler::RoomSimulationDebugger::BeginTrackingEnergyHistogram(v2 + 40, v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v5);
}

void sub_221F0D860(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D4758D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4758D8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingEnergyHistogram(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = (Phase::SpatialModeler::RoomSimulationDebugger *)(*a2 + 40);
  v3.mData = *(void *)(a1 + 8);
  return Phase::SpatialModeler::RoomSimulationDebugger::EndTrackingEnergyHistogram(v2, v3);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475920;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475920;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D475920;
  v2[1] = v3;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0DA1C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D475920;
  a2[1] = v2;
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingImageSourceLocations(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v5, a1 + 16);
  Phase::SpatialModeler::RoomSimulationDebugger::BeginTrackingImageSourceLocations(v2 + 40, v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v5);
}

void sub_221F0DB20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D475968;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D475968;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingImageSourceLocations(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = (Phase::SpatialModeler::RoomSimulationDebugger *)(*a2 + 40);
  v3.mData = *(void *)(a1 + 8);
  return Phase::SpatialModeler::RoomSimulationDebugger::EndTrackingImageSourceLocations(v2, v3);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D4759B0;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D4759B0;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D4759B0;
  v2[1] = v3;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0DCDC(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D4759B0;
  a2[1] = v2;
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerEarlyResponseMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v5, a1 + 16);
  Phase::SpatialModeler::RoomSimulationDebugger::BeginTrackingListenerEarlyResponseMetadata(v2 + 40, v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v5);
}

void sub_221F0DDE0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D4759F8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4759F8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerEarlyResponseMetadata(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = (Phase::SpatialModeler::RoomSimulationDebugger *)(*a2 + 40);
  v3.mData = *(void *)(a1 + 8);
  return Phase::SpatialModeler::RoomSimulationDebugger::EndTrackingListenerEarlyResponseMetadata(v2, v3);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475A40;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475A40;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D475A40;
  v2[1] = v3;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0DF9C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D475A40;
  a2[1] = v2;
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingListenerLateReverbMetadata(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v5, a1 + 16);
  Phase::SpatialModeler::RoomSimulationDebugger::BeginTrackingListenerLateReverbMetadata(v2 + 40, v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v5);
}

void sub_221F0E0A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D475A88;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D475A88;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingListenerLateReverbMetadata(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = (Phase::SpatialModeler::RoomSimulationDebugger *)(*a2 + 40);
  v3.mData = *(void *)(a1 + 8);
  return Phase::SpatialModeler::RoomSimulationDebugger::EndTrackingListenerLateReverbMetadata(v2, v3);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475AD0;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);
  return a1;
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func(void *a1)
{
  *a1 = &unk_26D475AD0;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  JUMPOUT(0x223C938A0);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  void *v2 = &unk_26D475AD0;
  v2[1] = v3;
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(v2 + 2), a1 + 16);
  return v2;
}

void sub_221F0E25C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  *a2 = &unk_26D475AD0;
  a2[1] = v2;
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)(a2 + 2), a1 + 16);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy(uint64_t a1)
{
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((void *)(a1 + 16));
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::destroy_deallocate(void *a1)
{
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](a1 + 2);

  operator delete(a1);
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::BeginTrackingRoomData(Phase::Handle64,std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  void v5[4] = *MEMORY[0x263EF8340];
  uint64_t v2 = *a2;
  unint64_t v3 = *(void *)(a1 + 8);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::__value_func[abi:ne180100]((uint64_t)v5, a1 + 16);
  Phase::SpatialModeler::RoomSimulationDebugger::BeginTrackingRoomData(v2 + 40, v3, (uint64_t)v5);
  return std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100](v5);
}

void sub_221F0E360(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D475B18;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D475B18;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(Phase::Handle64)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::EndTrackingRoomData(Phase::Handle64)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, void *a2)
{
  uint64_t v2 = (Phase::SpatialModeler::RoomSimulationDebugger *)(*a2 + 40);
  v3.mData = *(void *)(a1 + 8);
  return Phase::SpatialModeler::RoomSimulationDebugger::EndTrackingRoomData(v2, v3);
}

void std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::SpatialModeler::RoomSimulationDebugger::RuntimeDebugParameters)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::SpatialModeler::RoomSimulationDebugger::RuntimeDebugParameters)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::~__func()
{
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::SpatialModeler::RoomSimulationDebugger::RuntimeDebugParameters)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::SpatialModeler::RoomSimulationDebugger::RuntimeDebugParameters)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v2 = &unk_26D475B60;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  *((void *)v2 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *(void *)(a1 + 56);
  return result;
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::SpatialModeler::RoomSimulationDebugger::RuntimeDebugParameters)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::SpatialModeler::RoomSimulationDebugger::RuntimeDebugParameters)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D475B60;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  long long v4 = *(_OWORD *)(a1 + 40);
  *(void *)(a2 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a1 + 56);
  *(_OWORD *)(a2 + 40) = v4;
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::SpatialModeler::RoomSimulationDebugger::RuntimeDebugParameters)::$_0,std::allocator<Phase::Dispatch::GeometryClientDirectDispatcher::SetRoomSimulationRuntimeDebugParameters(Phase::SpatialModeler::RoomSimulationDebugger::RuntimeDebugParameters)::$_0>,void ()(Phase::Geometry::SystemDebugger *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v4 = *(_OWORD *)(a1 + 24);
  long long v5 = *(_OWORD *)(a1 + 40);
  *(void *)(v2 + 88) = *(void *)(a1 + 56);
  *(_OWORD *)(v2 + 72) = v5;
  *(_OWORD *)(v2 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
  *(__n128 *)(v2 + 40) = result;
  return result;
}

uint64_t Phase::Dispatch::TransactionExecutor<Phase::Dispatch::MiscServerMessageType>::TransactionExecutor(uint64_t a1)
{
  *(void *)a1 = &unk_26D474C10;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_DWORD *)(a1 + 40) = 1065353216;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  id v2 = objc_alloc_init(MEMORY[0x263EFF980]);
  long long v3 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = v2;

  return a1;
}

void sub_221F0E584(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::__unordered_map_hasher<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::hash<Phase::ActionTreeClientCommand>,std::equal_to<Phase::ActionTreeClientCommand>,true>,std::__unordered_map_equal<Phase::ActionTreeClientCommand,std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>,std::equal_to<Phase::ActionTreeClientCommand>,std::hash<Phase::ActionTreeClientCommand>,true>,std::allocator<std::__hash_value_type<Phase::ActionTreeClientCommand,std::function<void ()(void const*)>>>>::~__hash_table(v2);
  _Unwind_Resume(a1);
}

Phase::Dispatch::MiscClientDirectDispatcher *Phase::Dispatch::MiscClientDirectDispatcher::MiscClientDirectDispatcher(Phase::Dispatch::MiscClientDirectDispatcher *this, Phase::Controller::TaskManager *a2, Phase::Controller::LoadBalancer *a3)
{
  *((void *)this + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_26D475C08;
  uint64_t v5 = Phase::Controller::TaskManager::GetService<Phase::Controller::VoiceManager>(a2, 8);
  *((void *)this + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v5;
  if (!v5 || (*((void *)this + 2) = a3) == 0) {
    std::terminate();
  }
  return this;
}

void *Phase::Dispatch::MiscClientDirectDispatcher::GetGeometryPermutations@<X0>(Phase::Dispatch::MiscClientDirectDispatcher *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = **((void **)this + 1);
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return std::vector<Phase::Controller::GeometryPermutation>::__init_with_size[abi:ne180100]<Phase::Controller::GeometryPermutation*,Phase::Controller::GeometryPermutation*>(a2, *(void *)(v2 + 624), *(void *)(v2 + 632), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(v2 + 632) - *(void *)(v2 + 624)) >> 4));
}

uint64_t Phase::Dispatch::MiscClientDirectDispatcher::SetSpatialCategoryUpdateRate(unsigned __int8 ***a1, int a2, float a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 848);
  double v7 = a3;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315906;
    uint64_t v10 = "DispatcherMiscClientDirect.mm";
    __int16 v11 = 1024;
    int v12 = 39;
    __int16 v13 = 1024;
    int v14 = a2;
    __int16 v15 = 2048;
    double v16 = v7;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Setting Spatial Category %d Update Rate: %f", (uint8_t *)&v9, 0x22u);
  }
  return Phase::Controller::VoiceManager::Implementation::SetSpatialCategoryUpdateRate(*a1[1], a2, v7);
}

uint64_t Phase::Dispatch::MiscClientDirectDispatcher::SetSpatialCategoryBandCount(unsigned __int8 ***a1, int a2, unint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 848);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315906;
    int v9 = "DispatcherMiscClientDirect.mm";
    __int16 v10 = 1024;
    int v11 = 47;
    __int16 v12 = 1024;
    int v13 = a2;
    __int16 v14 = 2048;
    unint64_t v15 = a3;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Setting Spatial Category %d Band Count: %zu", (uint8_t *)&v8, 0x22u);
  }
  return Phase::Controller::VoiceManager::Implementation::SetSpatialCategoryBandCount(*a1[1], a2, a3);
}

uint64_t Phase::Dispatch::MiscClientDirectDispatcher::SetSpatialCategoryMaxClusterCount(unsigned __int8 ***a1, int a2, unint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  uint64_t v6 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 848);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315906;
    int v9 = "DispatcherMiscClientDirect.mm";
    __int16 v10 = 1024;
    int v11 = 58;
    __int16 v12 = 1024;
    int v13 = a2;
    __int16 v14 = 2048;
    unint64_t v15 = a3;
    _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Setting Spatial Category %d Max Cluster Count: %zu", (uint8_t *)&v8, 0x22u);
  }
  return Phase::Controller::VoiceManager::Implementation::SetSpatialCategoryMaxClusterCount(*a1[1], a2, a3);
}

void Phase::Dispatch::MiscClientDirectDispatcher::SetUnitsPerMeter(Phase::Dispatch::MiscClientDirectDispatcher *this, double a2)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  long long v4 = **(id **)(Phase::Logger::GetInstance(this) + 848);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136315650;
    uint64_t v6 = "DispatcherMiscClientDirect.mm";
    __int16 v7 = 1024;
    int v8 = 66;
    __int16 v9 = 2048;
    double v10 = a2;
    _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Setting Units Per Meter: %f", (uint8_t *)&v5, 0x1Cu);
  }
  Phase::Controller::SubmixSystem::SetUnitsPerMeter((Phase::Controller::SubmixSystem *)(**((void **)this + 1) + 224), a2);
}

uint64_t Phase::Dispatch::MiscClientDirectDispatcher::SetProfileOverride(Phase::Dispatch::MiscClientDirectDispatcher *this, uint64_t a2, double a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v5 = *((void *)this + 2);
  uint64_t v6 = **(void **)(v5 + 8);
  unint64_t v14 = 0;
  BOOL v13 = 1;
  uint64_t v7 = Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v6, 32, &v14, &v13);
  if (!v7)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    uint64_t v11 = **(id **)(v6 + 48);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      uint64_t v16 = "CommandQueue.hpp";
      __int16 v17 = 1024;
      int v18 = 100;
      _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v13)
  {
    int v8 = **(id **)(v6 + 48);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v16 = "CommandQueue.hpp";
      __int16 v17 = 1024;
      int v18 = 89;
      __int16 v19 = 2048;
      unint64_t v20 = v14;
      __int16 v21 = 2048;
      uint64_t v22 = 32;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  *(void *)uint64_t v7 = &unk_26D475C78;
  *(void *)(v7 + 8) = v5;
  *(void *)(v7 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a2;
  *(double *)(v7 + 24) = a3;
  uint64_t result = Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v6, 32);
  atomic_store(0, (unsigned __int8 *)(v6 + 40));
  return result;
}

void sub_221F0ECBC(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x221F0EBD0);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Dispatch::MiscClientDirectDispatcher::ClearProfileOverride(Phase::Dispatch::MiscClientDirectDispatcher *this)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v1 = *((void *)this + 2);
  uint64_t v2 = **(void **)(v1 + 8);
  unint64_t v10 = 0;
  BOOL v9 = 1;
  long long v3 = (void *)Phase::LockFreeQueueMPSC::GetWriteBuffer((atomic_uchar *)v2, 16, &v10, &v9);
  if (!v3)
  {
    uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(0);
    Phase::Logger::DumpTailspinWithThrottleAsync(Instance, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
    uint64_t v7 = **(id **)(v2 + 48);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315394;
      __int16 v12 = "CommandQueue.hpp";
      __int16 v13 = 1024;
      int v14 = 100;
      _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [true is true]: \"CommandQueue unable to retrieve write buffer; buffer "
        "is full, unable to grow.\"",
        buf,
        0x12u);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "CommandQueue unable to retrieve write buffer; buffer is full, unable to grow.");
  }
  if (v9)
  {
    long long v4 = **(id **)(v2 + 48);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136315906;
      __int16 v12 = "CommandQueue.hpp";
      __int16 v13 = 1024;
      int v14 = 89;
      __int16 v15 = 2048;
      unint64_t v16 = v10;
      __int16 v17 = 2048;
      uint64_t v18 = 16;
      _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_DEBUG, "%25s:%-5d Warning: CommandQueue grew buffer to %zu bytes to accommodate extra %zu bytes - this usually means the system is under load or the command queue is too small.", buf, 0x26u);
    }
  }
  void *v3 = &unk_26D475CA0;
  v3[1] = v1;
  uint64_t result = Phase::LockFreeQueueSPSC::CommitBytes((atomic_uchar *)v2, 16);
  atomic_store(0, (unsigned __int8 *)(v2 + 40));
  return result;
}

void sub_221F0EF18(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2);
    __cxa_end_catch();
    JUMPOUT(0x221F0EE34);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Dispatch::MiscClientDirectDispatcher::GetTransactionBuffer(Phase::Dispatch::MiscClientDirectDispatcher *this)
{
  return 0;
}

void Phase::Dispatch::MiscClientDirectDispatcher::~MiscClientDirectDispatcher(Phase::Dispatch::MiscClientDirectDispatcher *this)
{
}

void Phase::LambdaFunction<Phase::Dispatch::MiscClientDirectDispatcher::SetProfileOverride(unsigned long long,double)::$_0,void>::~LambdaFunction()
{
}

void Phase::LambdaFunction<Phase::Dispatch::MiscClientDirectDispatcher::SetProfileOverride(unsigned long long,double)::$_0,void>::operator()(uint64_t a1)
{
}

void Phase::LambdaFunction<Phase::Dispatch::MiscClientDirectDispatcher::ClearProfileOverride(void)::$_0,void>::~LambdaFunction()
{
}

void Phase::LambdaFunction<Phase::Dispatch::MiscClientDirectDispatcher::ClearProfileOverride(void)::$_0,void>::operator()(uint64_t a1)
{
}

void Phase::Controller::DSPVoiceManager::DSPVoiceManager()
{
}

void sub_221F0F04C(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F2C4053184E0FLL);
  _Unwind_Resume(a1);
}

Phase::Controller::DSPVoiceManager::Implementation *std::unique_ptr<Phase::Controller::DSPVoiceManager::Implementation>::reset[abi:ne180100](Phase::Controller::DSPVoiceManager::Implementation **a1, Phase::Controller::DSPVoiceManager::Implementation *a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    Phase::Controller::DSPVoiceManager::Implementation::~Implementation(result);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

uint64_t Phase::Controller::DSPVoiceManager::ConfigureGeneratorWithRenderCallback(Phase::Logger *a1, unint64_t a2, unint64_t a3, int a4, char *a5, uint64_t *a6, void *a7)
{
  *(void *)&v36[5] = *MEMORY[0x263EF8340];
  if (!a7[1])
  {
    int v14 = **(id **)(Phase::Logger::GetInstance(a1) + 80);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v31 = "DSPVoiceManager.mm";
      __int16 v32 = 1024;
      int v33 = 105;
      __int16 v34 = 2048;
      *(void *)unint64_t v35 = a2;
      _os_log_impl(&dword_221E5E000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [renderCallbackInfo.mRenderProc == nullptr is true]: \"Member .mRenderProc is nullptr in RenderCallbackInfo for generatorId %llu \\n\"", buf, 0x1Cu);
    }
    exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(exception, "Member .mRenderProc is nullptr in RenderCallbackInfo for generatorId %llu \n");
  }
  uint64_t v8 = a7[3];
  if (!v8)
  {
    unint64_t v16 = **(id **)(Phase::Logger::GetInstance(a1) + 80);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      uint64_t v17 = a7[3];
      *(_DWORD *)buf = 136315906;
      uint64_t v31 = "DSPVoiceManager.mm";
      __int16 v32 = 1024;
      int v33 = 112;
      __int16 v34 = 2048;
      *(void *)unint64_t v35 = v17;
      *(_WORD *)&v35[8] = 2048;
      *(void *)unint64_t v36 = a2;
      _os_log_impl(&dword_221E5E000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [renderCallbackInfo.mMaximumFrameCount <= 0 is true]: \"Invalid .mMaximumFrameCount count (= %zu) in RenderCallbackInfo for generatorId %llu \\n\"", buf, 0x26u);
    }
    uint64_t v18 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v18, "Invalid .mMaximumFrameCount count (= %zu) in RenderCallbackInfo for generatorId %llu \n");
  }
  uint64_t v9 = a7[2];
  if (!v9)
  {
    unint64_t v20 = **(id **)(Phase::Logger::GetInstance(a1) + 80);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v31 = "DSPVoiceManager.mm";
      __int16 v32 = 1024;
      int v33 = 118;
      __int16 v34 = 2048;
      *(void *)unint64_t v35 = a2;
      _os_log_impl(&dword_221E5E000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [renderCallbackInfo.mBuffer == nullptr is true]: \"Member .mBuffer in RenderCallbackInfo is nullptr for generatorId %llu \\n\"", buf, 0x1Cu);
    }
    __int16 v21 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v21, "Member .mBuffer in RenderCallbackInfo is nullptr for generatorId %llu \n");
  }
  if (!*(void *)(v9 + 16))
  {
    uint64_t v23 = **(id **)(Phase::Logger::GetInstance(a1) + 80);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      uint64_t v31 = "DSPVoiceManager.mm";
      __int16 v32 = 1024;
      int v33 = 124;
      __int16 v34 = 2048;
      *(void *)unint64_t v35 = a2;
      _os_log_impl(&dword_221E5E000, v23, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [renderCallbackInfo.mBuffer->mBuffers[0].mData == nullptr is true]: \"Member .mBuffer->mBuffers[0].mData in RenderCallbackInfo is nullptr for generatorId %llu \\n\"", buf, 0x1Cu);
    }
    int v24 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v24, "Member .mBuffer->mBuffers[0].mData in RenderCallbackInfo is nullptr for generatorId %llu \n");
  }
  unsigned int v10 = *(_DWORD *)(v9 + 12);
  if (v10 < 4 * (int)v8)
  {
    unsigned int v27 = v10;
    uint64_t v25 = **(id **)(Phase::Logger::GetInstance(a1) + 80);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      uint64_t v31 = "DSPVoiceManager.mm";
      __int16 v32 = 1024;
      int v33 = 138;
      __int16 v34 = 1024;
      *(_DWORD *)unint64_t v35 = v27;
      *(_WORD *)&v35[4] = 1024;
      *(_DWORD *)&v35[6] = 4 * v8;
      v36[0] = 2048;
      *(void *)&v36[1] = a2;
      _os_log_impl(&dword_221E5E000, v25, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error) [kCallbackBufferSize < kRequiredCallbackBufferSizeBytes is true]: \"Render callback size in bytes %u is less than the %u bytes requiredfor generatorId %llu \\n\"", buf, 0x28u);
    }
    __int16 v26 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    std::runtime_error::runtime_error(v26, "Render callback size in bytes %u is less than the %u bytes requiredfor generatorId %llu \n");
  }
  uint64_t v11 = *(void *)(*(void *)a1 + 72);

  return Phase::Controller::DVM::VoiceGraph::ConfigureGeneratorWithRenderCallback(v11, a2, a3, a4, a5, a6, (uint64_t)a7);
}

void sub_221F0F524(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void Phase::Controller::DSPVoiceManager::Update(Phase::Controller::DSPVoiceManager *this)
{
  uint64_t Instance = Phase::Logger::GetInstance(this);
  long long v3 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 896));
  long long v4 = (Phase::Logger *)Phase::Logger::GetInstance(v3);
  if (*((unsigned char *)v4 + 904))
  {
    uint64_t v5 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v4)
                                                                                       + 896)));
    uint64_t v6 = v5;
    if ((unint64_t)v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v6, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v3, "Phase_DVM_Update", "DVM Update", buf, 2u);
    }
  }
  Phase::Controller::DSPVoiceManager::Implementation::ProcessMessagesFromDvmRt(*(Phase::Controller::DSPVoiceManager::Implementation **)this);
  Phase::Controller::DSPVoiceManager::Implementation::Update(*(Phase::Controller::DSPVoiceManager::Implementation **)this);
  uint64_t v8 = (Phase::Logger *)Phase::Logger::GetInstance(v7);
  if (*((unsigned char *)v8 + 904))
  {
    uint64_t v9 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v8)
                                                                                       + 896)));
    unsigned int v10 = v9;
    if ((unint64_t)v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v10, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v3, "Phase_DVM_Update", (const char *)&unk_222112ABB, v11, 2u);
    }
  }
}

uint64_t Phase::Controller::DSPVoiceManager::AddTap(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = *a1;
  std::__function::__value_func<void ()(float *,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v9, a3);
  uint64_t v7 = Phase::Controller::DSPVoiceManager::Implementation::AddTap(v6, a2, (uint64_t)v9, a4);
  std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100](v9);
  return v7;
}

void sub_221F0F728(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<void ()(float *,unsigned long)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t Phase::Controller::DVM_RT::DVM_RT(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = 0;
  uint64_t v6 = a1 + 2440320;
  uint64_t v7 = (void *)(a1 + 1520752);
  uint64_t v8 = (uint64_t *)(a1 + 601248);
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  uint64_t v9 = (void *)(a1 + 600960);
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a4;
  *(void *)(a1 + 40) = 0;
  uint64_t v10 = a1 + 376;
  do
  {
    uint64_t v11 = a1 + v5;
    __int16 v12 = (_OWORD *)(a1 + v5 + 408);
    *__int16 v12 = 0uLL;
    v12[1] = 0uLL;
    *(void *)(v11 + 384) = 0;
    *(void *)(v11 + 392) = 0;
    *(void *)(v11 + 37std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    *(_DWORD *)(v11 + 440) = 1;
    v5 += 72;
  }
  while (v5 != 18432);
  bzero((void *)(a1 + 120), 0x4904uLL);
  *(void *)(a1 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v10;
  __int16 v13 = (void *)(a1 + 448);
  uint64_t v14 = 255;
  do
  {
    *(v13 - 8) = v13;
    *__int16 v13 = v13 - 9;
    v13 += 9;
    --v14;
  }
  while (v14);
  *(void *)(a1 + 1873std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a1 + 18664;
  uint64_t v15 = -8192;
  do
  {
    uint64_t v16 = a1 + v15;
    *(_OWORD *)(v16 + 27272) = 0uLL;
    *(void *)(v16 + 27288) = 0;
    v15 += 32;
  }
  while (v15);
  bzero((void *)(a1 + 18824), 0x2104uLL);
  *(void *)(a1 + 1881std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a1 + 19080;
  uint64_t v17 = (void *)(a1 + 19112);
  uint64_t v18 = 255;
  do
  {
    *(v17 - 3) = v17;
    *uint64_t v17 = v17 - 4;
    v17 += 4;
    --v18;
  }
  while (v18);
  uint64_t v19 = 0;
  *(void *)(a1 + 27240) = a1 + 27208;
  uint64_t v20 = a1 + 27800;
  do
  {
    uint64_t v21 = a1 + v19;
    *(_OWORD *)(v21 + 27800) = 0uLL;
    *(void *)(v21 + 2781std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    v19 += 280;
  }
  while (v19 != 573440);
  bzero((void *)(a1 + 27288), 0x8C204uLL);
  *(void *)(a1 + 27280) = v20;
  uint64_t v22 = 2047;
  do
  {
    *(void *)(v20 + 8) = v20 + 280;
    *(void *)(v20 + 280) = v20;
    v20 += 280;
    --v22;
  }
  while (v22);
  *uint64_t v9 = a1 + 600680;
  uint64_t v23 = a1 + 603304;
  do
  {
    int v24 = (void *)(v23 + v22);
    *int v24 = 0;
    v24[1] = 0;
    v24[2] = 0;
    v22 += 56;
  }
  while (v22 != 917504);
  bzero((void *)(a1 + 601256), 0xE0804uLL);
  uint64_t *v8 = v23;
  uint64_t v25 = v8 + 264;
  uint64_t v26 = 0x3FFFLL;
  do
  {
    *(v25 - std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v25;
    *uint64_t v25 = v25 - 7;
    v25 += 7;
    --v26;
  }
  while (v26);
  uint64_t v27 = 0;
  void *v7 = a1 + 1520696;
  uint64_t v28 = a1 + 1522872;
  do
  {
    float v29 = (void *)(v28 + v27);
    *float v29 = 0;
    v29[1] = 0;
    v29[2] = 0;
    v27 += 56;
  }
  while (v27 != 917504);
  bzero((void *)(a1 + 1520824), 0xE0804uLL);
  v7[8] = v28;
  unint64_t v30 = v7 + 272;
  uint64_t v31 = 0x3FFFLL;
  do
  {
    *(v30 - std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v30;
    *unint64_t v30 = v30 - 7;
    v30 += 7;
    --v31;
  }
  while (v31);
  *(void *)uint64_t v6 = a1 + 2440264;
  *(_DWORD *)(v6 + 64) = 0;
  *(_OWORD *)(a1 + 2440392) = 0u;
  *(_OWORD *)(a1 + 2440408) = 0u;
  *(_DWORD *)(v6 + 104) = 1065353216;
  *(_OWORD *)(a1 + 2440432) = 0u;
  *(_OWORD *)(a1 + 2440448) = 0u;
  *(_DWORD *)(v6 + 144) = 1065353216;
  *(_OWORD *)(a1 + 2440472) = 0u;
  *(_OWORD *)(a1 + 2440488) = 0u;
  Phase::DspLayer::VoiceEngine::SetVoicePoolMessageCallback(*(void *)(a1 + 16), a1, (uint64_t (*)())Phase::Controller::VoiceEngineCallback);
  return a1;
}

void sub_221F0FB1C(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v2);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void Phase::Controller::DVM_RT::RtUpdate(Phase::Controller::DVM_RT *this)
{
  uint64_t v91 = *MEMORY[0x263EF8340];
  unint64_t v86 = 0;
  uint64_t v2 = Phase::LockFreeQueueSPSC::GetWriteBuffer(*((atomic_uchar **)this + 1), 0x10000, &v86);
  if (!v2)
  {
    bzero(*(void **)(*((void *)this + 2) + 64), 4 * *(int *)(*((void *)this + 2) + 112));
    __int16 v40 = **(NSObject ***)(Phase::Logger::GetInstance(v39) + 80);
    if (!os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
      return;
    }
    uint64_t v41 = *(void *)(*((void *)this + 2) + 16);
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "DVM_RT.cpp";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 240;
    *(_WORD *)&unsigned char buf[18] = 1024;
    int v88 = 0x10000;
    __int16 v89 = 2048;
    uint64_t v90 = v41;
    int v42 = "%25s:%-5d DVM_RT unable to reserve %iB in message pipe to DVM_NRT at Frame %llu, pipe is full! Did the main th"
          "read stop, pause, or stutter?";
    goto LABEL_69;
  }
  uint64_t v3 = (_DWORD *)((char *)this + 2440376);
  int v4 = v86;
  uint64_t v5 = *((void *)this + 2);
  uint64_t v6 = *(void *)(v5 + 16);
  *((void *)this + 3) = v2;
  *((_DWORD *)this + 8) = v4;
  *((_DWORD *)this + 9) = 20;
  *(void *)uint64_t v2 = 0x656C646E756223;
  *((void *)v2 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6;
  v2[4] = 20;
  unint64_t v7 = *(void *)(v5 + 16);
  if (!(v7 % (uint64_t)*(double *)v5))
  {
    uint64_t v9 = *(char **)(v5 + 32);
    uint64_t v8 = *(char **)(v5 + 40);
    if (v9 == v8)
    {
      int v10 = 0;
      int v11 = 0;
    }
    else
    {
      int v10 = 0;
      int v11 = 0;
      __int16 v12 = *(char **)(v5 + 32);
      do
      {
        __int16 v13 = *(_DWORD **)v12;
        v12 += 8;
        v11 += v13[3];
        int v10 = v10 + v13[2] - v13[11] + 4;
      }
      while (v12 != v8);
      if (v9 != v8)
      {
        int v14 = 0;
        int v15 = 0;
        uint64_t v84 = 0;
        int v16 = 0;
        int v17 = 0;
        int v18 = 0;
        int v19 = 0;
        int v20 = 0;
        int v21 = 0;
        int v22 = 0;
        int v23 = 0;
        int v24 = 0;
        int v25 = 0;
        int v85 = 0;
        int v26 = 0;
        int v27 = 0;
        int v28 = 0;
        float v29 = *(void **)(v5 + 32);
        while (1)
        {
          unint64_t v30 = (_DWORD *)*v29;
          uint64_t v31 = *(unsigned char **)(*v29 + 48);
          if (!v31) {
            goto LABEL_35;
          }
          unsigned int v32 = *v31;
          if (!*v31) {
            goto LABEL_35;
          }
          int v33 = v31 + 1;
          uint64_t v34 = 0xCBF29CE484222325;
          do
          {
            uint64_t v34 = 0x100000001B3 * (v34 ^ v32);
            unsigned int v35 = *v33++;
            unsigned int v32 = v35;
          }
          while (v35);
          if (v34 > (uint64_t)0xF57EBABD1FFDD055)
          {
            if (v34 <= 0x20999FECD11286CCLL)
            {
              if (v34 == 0xF57EBABD1FFDD056)
              {
                int v16 = v30[2];
                v18 += v30[3];
                int v17 = v17 + v16 - v30[11] + 4;
                goto LABEL_35;
              }
              if (v34 == 0x15687F45806132E7) {
                goto LABEL_30;
              }
              goto LABEL_35;
            }
            if (v34 == 0x20999FECD11286CDLL)
            {
              int v14 = v30[2];
              LODWORD(v84) = v30[3];
              int v15 = v14 - v30[11] + 4;
              goto LABEL_35;
            }
            if (v34 == 0x235B3F2D33EB877ALL)
            {
              int v19 = v30[2];
              v21 += v30[3];
              int v20 = v20 + v19 - v30[11] + 4;
              goto LABEL_35;
            }
            unint64_t v37 = 0x36265BBA99CF899FLL;
          }
          else
          {
            if (v34 > (uint64_t)0xC1F9D0B8A19AAC09)
            {
              if (v34 != 0xC1F9D0B8A19AAC0ALL)
              {
                if (v34 != 0xCFE1F9A8E823B67BLL && v34 != 0xE8CBC3A55AEFC3DALL) {
                  goto LABEL_35;
                }
LABEL_30:
                int v38 = v30[2];
                v28 += v30[3];
                int v27 = v27 + v38 - v30[11] + 4;
                v26 += v38;
                goto LABEL_35;
              }
LABEL_27:
              int v22 = v30[2];
              int v24 = v30[3];
              int v23 = v22 - v30[11] + 4;
              goto LABEL_35;
            }
            if (v34 == 0x90B234A352A80E9BLL)
            {
              int v85 = v30[3];
              int v25 = v30[2];
              HIDWORD(v84) = v25 - v30[11] + 4;
              goto LABEL_35;
            }
            unint64_t v37 = 0xC1F9CCB8A19AA53ELL;
          }
          if (v34 == v37) {
            goto LABEL_27;
          }
LABEL_35:
          if (++v29 == (void *)v8)
          {
            uint64_t v3 = (_DWORD *)((char *)this + 2440376);
            goto LABEL_41;
          }
        }
      }
    }
    int v28 = 0;
    int v27 = 0;
    int v26 = 0;
    int v85 = 0;
    uint64_t v84 = 0;
    int v25 = 0;
    int v24 = 0;
    int v23 = 0;
    int v22 = 0;
    int v21 = 0;
    int v20 = 0;
    int v19 = 0;
    int v18 = 0;
    int v17 = 0;
    int v16 = 0;
    int v15 = 0;
    int v14 = 0;
LABEL_41:
    uint64_t v43 = v3 + 26;
    uint64_t v44 = *((int *)this + 9);
    if (*((_DWORD *)this + 8) - (int)v44 - 4 >= 184)
    {
      int v45 = *((_DWORD *)this + 150310);
      int v46 = *((_DWORD *)this + 6818);
      int v47 = *v3;
      uint64_t v48 = (char *)v2 + v44;
      int v49 = *((_DWORD *)this + 380202);
      unint64_t v50 = v8 - v9;
      int v52 = v3[26];
      int v51 = v3[27];
      int v53 = *((_DWORD *)this + 610118);
      *(void *)(v48 + 4) = 11;
      long long v54 = *(_OWORD *)((char *)this + 2440488);
      *((_DWORD *)v48 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v53;
      *((_DWORD *)v48 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = v52;
      uint64_t v3 = (_DWORD *)((char *)this + 2440376);
      *((_DWORD *)v48 + 18) = v51;
      *((_DWORD *)v48 + 19) = v49;
      *((_DWORD *)v48 + 20) = 0x4000;
      *((_DWORD *)v48 + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v47;
      *((_DWORD *)v48 + 22) = 0x4000;
      *((_DWORD *)v48 + 23) = v28;
      *((_DWORD *)v48 + 24) = v27;
      *((_DWORD *)v48 + 25) = v26;
      *((_DWORD *)v48 + 2std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v21;
      *((_DWORD *)v48 + 2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v20;
      *((_DWORD *)v48 + 28) = v19;
      *((_DWORD *)v48 + 29) = v18;
      *((_DWORD *)v48 + 30) = v17;
      *((_DWORD *)v48 + 3Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v16;
      *((_DWORD *)v48 + 32) = v46;
      *((_DWORD *)v48 + 33) = 256;
      *((_DWORD *)v48 + 34) = v85;
      *((_DWORD *)v48 + 35) = HIDWORD(v84);
      *((_DWORD *)v48 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v25;
      *((_DWORD *)v48 + 3std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v24;
      *((_DWORD *)v48 + 38) = v23;
      *((_DWORD *)v48 + 39) = v22;
      *((_DWORD *)v48 + 40) = v84;
      *((_DWORD *)v48 + 4Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v15;
      *((_DWORD *)v48 + 42) = v14;
      *((_DWORD *)v48 + 43) = v50 >> 3;
      *((_DWORD *)v48 + 44) = v45;
      memset(v48 + 44, 105, 3);
      *(_OWORD *)(v48 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v54;
      *(void *)&long long v54 = 0x6969696969696969;
      *((void *)&v54 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0x6969696969696969;
      *(_OWORD *)(v48 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v54;
      *(_OWORD *)(v48 + 28) = v54;
      *((_DWORD *)v48 + 45) = v11;
      *((_DWORD *)v48 + 4std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v10;
      uint64_t v55 = *((void *)this + 3);
      *(_DWORD *)(v55 + *((int *)this + 9)) = 184;
      *(_DWORD *)(v55 + 16) += 188;
      *((_DWORD *)this + 9) += 188;
      uint64_t v5 = *((void *)this + 2);
    }
    v3[24] = 0;
    v43[1] = 0;
    _OWORD v43[2] = 0;
    void *v43 = 0;
    unint64_t v7 = *(void *)(v5 + 16);
  }
  for (uint64_t i = Phase::CalendarQueue<64,2048,Phase::Controller::DVM_RT::OSCData>::PopAtTime((uint64_t)this + 27280, v7);
        i;
        uint64_t v3 = (_DWORD *)((char *)this + 2440376))
  {
    memset(buf, 0, sizeof(buf));
    int v58 = *(_DWORD *)i;
    int v57 = *(_DWORD *)i;
    *(void *)buf = (char *)i + 4;
    *(_DWORD *)&uint8_t buf[8] = v58;
    *(_DWORD *)&unsigned char buf[12] = (strlen((const char *)i + 12) & 0xFFFFFFFC) + 12;
    int v59 = v3[31] + v57;
    ++v3[30];
    v3[31] = v59;
    Phase::Controller::DVM_RT::ProcessMessageFromNRT(this, (Phase::PhaseOSCMessage *)buf, v60, v61);
    uint64_t i = Phase::CalendarQueue<64,2048,Phase::Controller::DVM_RT::OSCData>::PopAtTime((uint64_t)this + 27280, *(void *)(*((void *)this + 2) + 16));
  }
  if (Phase::LockFreeQueueSPSC::HasData(*(Phase::LockFreeQueueSPSC **)this))
  {
    int v62 = 0;
    int v63 = 0;
    do
    {
      BOOL v64 = (int *)(*(void *)(*(void *)this + 16) + *(int *)(*(void *)this + 4));
      unsigned int v65 = *v64;
      if (*((void *)v64 + 2) == 0x656C646E756223)
      {
        int v66 = 0;
        memset(buf, 0, sizeof(buf));
        if (v64[8] >= 21)
        {
          int v66 = 0;
          int v67 = 20;
          do
          {
            int v68 = *(int *)((char *)v64 + v67 + 16);
            *(void *)buf = (char *)v64 + v67 + 20;
            *(_DWORD *)&uint8_t buf[8] = v68;
            *(_DWORD *)&unsigned char buf[12] = (strlen((const char *)(*(void *)buf + 8)) & 0xFFFFFFFC) + 12;
            *(_DWORD *)&uint8_t buf[16] = 0;
            Phase::Controller::DVM_RT::ProcessMessageFromNRT(this, (Phase::PhaseOSCMessage *)buf, v69, v70);
            v67 += v68 + 4;
            ++v66;
          }
          while (v67 < v64[8]);
        }
      }
      else
      {
        *(_DWORD *)&uint8_t buf[16] = 0;
        *(void *)buf = v64 + 4;
        *(void *)&uint8_t buf[8] = v65;
        *(_DWORD *)&unsigned char buf[12] = (strlen((const char *)v64 + 24) & 0xFFFFFFFC) + 12;
        *(_DWORD *)&uint8_t buf[16] = 0;
        Phase::Controller::DVM_RT::ProcessMessageFromNRT(this, (Phase::PhaseOSCMessage *)buf, v71, v72);
        int v66 = 1;
      }
      v63 += v65;
      uint64_t v73 = *(atomic_uchar **)this;
      *((_DWORD *)v73 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(*(void *)this + 4)
                           + ((*(_DWORD *)(*(void *)(*(void *)this + 16) + *(int *)(*(void *)this + 4)) + 15) & 0xFFFFFFF0)
                           + 16;
      v62 += v66;
    }
    while (Phase::LockFreeQueueSPSC::HasData((Phase::LockFreeQueueSPSC *)v73));
  }
  else
  {
    int v63 = 0;
    int v62 = 0;
  }
  *((_DWORD *)this + 610118) += v62;
  int v74 = *((_DWORD *)this + 610122);
  int v75 = *((_DWORD *)this + 610123);
  if (v74 <= v62) {
    int v74 = v62;
  }
  if (v75 <= v63) {
    int v75 = v63;
  }
  *((_DWORD *)this + 610122) = v74;
  *((_DWORD *)this + 610123) = v75;
  *((_DWORD *)this + 610120) += v63;
  uint64_t v76 = *((void *)this + 2);
  double v77 = (uint64_t **)*((void *)this + 305051);
  if (v77)
  {
    uint64_t v78 = *(void *)(v76 + 16);
    do
    {
      (*(void (**)(uint64_t *, uint64_t))(*v77[2] + 40))(v77[2], v78);
      double v77 = (uint64_t **)*v77;
    }
    while (v77);
    uint64_t v76 = *((void *)this + 2);
  }
  Phase::DspLayer::VoiceEngine::Run((uint64_t **)v76);
  uint64_t v79 = *((void *)this + 3);
  int v80 = *(_DWORD *)(v79 + 16);
  if (v80 != 20)
  {
    *((_DWORD *)this + 610121) += v80;
    uint64_t v81 = Phase::LockFreeQueueSPSC::CommitBytes(*((atomic_uchar **)this + 1), *(_DWORD *)(v79 + 16));
    if ((v81 & 1) == 0)
    {
      __int16 v40 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)v81) + 80);
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
      {
        int v82 = *(_DWORD *)(*((void *)this + 3) + 16);
        uint64_t v83 = *(void *)(*((void *)this + 2) + 16);
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "DVM_RT.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 534;
        *(_WORD *)&unsigned char buf[18] = 1024;
        int v88 = v82;
        __int16 v89 = 2048;
        uint64_t v90 = v83;
        int v42 = "%25s:%-5d DVM_RT unable to write %iB into message pipe to DVM_NRT at Frame %llu. Pipe is full!";
LABEL_69:
        _os_log_impl(&dword_221E5E000, v40, OS_LOG_TYPE_ERROR, v42, buf, 0x22u);
      }
    }
  }
}

uint64_t *Phase::CalendarQueue<64,2048,Phase::Controller::DVM_RT::OSCData>::PopAtTime(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8 * (a2 & 0x3F) + 8);
  if (!v2) {
    return 0;
  }
  while (1)
  {
    uint64_t v3 = v2[2];
    if (v3 >= a2) {
      break;
    }
    uint64_t v2 = (uint64_t *)v2[1];
    if (!v2) {
      return 0;
    }
  }
  if (v3 != a2) {
    return 0;
  }
  Phase::CalendarQueue<64,2048,Phase::Controller::DVM_RT::OSCData>::RemoveNode(a1, v2);
  return v2 + 3;
}

double Phase::Controller::DVM_RT::ProcessMessageFromNRT(Phase::Controller::DVM_RT *this, Phase::PhaseOSCMessage *a2, Phase::PhaseOSCMessage *a3, __n128 a4)
{
  v249[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = *(_DWORD **)a2;
  uint64_t v8 = *((int *)a2 + 3);
  uint64_t v7 = *((int *)a2 + 4);
  uint64_t v9 = *(unsigned int *)(*(void *)a2 + v8);
  uint64_t v10 = v8 + 4;
  *((_DWORD *)a2 + 3) = v8 + 4;
  *((_DWORD *)a2 + 4) = v7 + 1;
  if ((int)v9 >= 1)
  {
    uint64_t v11 = *(void *)(*((void *)this + 2) + 16) + v9;
    uint64_t v12 = *((void *)this + 3410);
    __int16 v13 = *(void **)(v12 + 8);
    *((void *)this + 3410) = v13;
    if (v13) {
      *__int16 v13 = 0;
    }
    *(void *)uint64_t v12 = 0;
    *(void *)(v12 + 8) = 0;
    *(void *)(v12 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v11;
    int v14 = (void **)((char *)this + 8 * (v11 & 0x3F) + 27288);
    int v15 = *v14;
    if (*v14)
    {
      if (v15[2] <= v11)
      {
        while (1)
        {
          int v19 = v15;
          int v15 = (void *)v15[1];
          if (!v15) {
            break;
          }
          if (v15[2] > v11)
          {
            void *v15 = v12;
            *(void *)uint64_t v12 = v19;
            *(void *)(v12 + 8) = v15;
            v19[1] = v12;
            goto LABEL_8;
          }
        }
        v19[1] = v12;
        *(void *)uint64_t v12 = v19;
        goto LABEL_8;
      }
      *(void *)(v12 + 8) = v15;
      void *v15 = v12;
    }
    NSObject *v14 = (void *)v12;
LABEL_8:
    ++*((_DWORD *)this + 150310);
    *(_DWORD *)(v12 + 24) = *((_DWORD *)a2 + 2);
    int v16 = *(char **)a2;
    int v17 = (strlen((const char *)(*(void *)a2 + 8)) & 0xFFFFFFFC) + 12;
    *((_DWORD *)a2 + 3) = v17;
    *((_DWORD *)a2 + 4) = 0;
    *(_DWORD *)&v16[v17] = 0;
    size_t v18 = *((int *)a2 + 2);
    memcpy((void *)(v12 + 28), v16, v18);
    return a4.n128_f64[0];
  }
  if (v9)
  {
    Phase::Controller::DVM_RT::DVMRTOSCCommand_ToString((Phase::Controller::DVM_RT *)&__p, a2);
    int v20 = (uint64_t *)((char *)this + 24);
    if (v244 >= 0) {
      p_p = (char *)&__p;
    }
    else {
      p_p = (char *)__p;
    }
    unsigned int v22 = 2;
LABEL_19:
    Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,char const*>(v20, v22, p_p);
    if (v244 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    switch(*v6)
    {
      case 0:
        *(void *)(*((void *)this + 2) + 40) = *(void *)(*((void *)this + 2) + 32);
        return a4.n128_f64[0];
      case 1:
        int v23 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        *((_DWORD *)a2 + 3) = v8 + 12;
        *((_DWORD *)a2 + 4) = v7 + 2;
        uint64_t v24 = *(unsigned int *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 16;
        *((_DWORD *)a2 + 4) = v7 + 3;
        int v25 = (Phase::DspLayer::VoiceEngine *)*((void *)this + 2);
        Phase::DspLayer::VoiceEngine::AddPool(v25, v23, v24);
        return a4.n128_f64[0];
      case 2:
        uint64_t v26 = *(void *)((char *)v6 + v10);
        *((_DWORD *)a2 + 3) = v8 + 12;
        *((_DWORD *)a2 + 4) = v7 + 2;
        uint64_t v27 = *((void *)this + 2);
        Phase::DspLayer::VoiceEngine::RemovePool(v27, v26);
        return a4.n128_f64[0];
      case 3:
        uint64_t v119 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        uint64_t v120 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        v240 = v119;
        uint64_t v241 = v120;
        v249[0] = &unk_26D475CC8;
        v249[3] = v249;
        Phase::CalendarQueue<64,2048,Phase::Controller::DVM_RT::OSCData>::CancelAllEvents((uint64_t)this + 27280, (uint64_t)v249, (uint64_t)&v240);
        std::__function::__value_func<BOOL ()(long long,Phase::Controller::DVM_RT::OSCData &,void *)>::~__value_func[abi:ne180100](v249);
        int v121 = Phase::DspLayer::VoicePool::Play(v119, v120);
        if (v121) {
          goto LABEL_107;
        }
        uint64_t v202 = 0;
        uint64_t v203 = 0xCBF29CE484222325;
        std::string __p = v119;
        uint64_t v243 = v120;
        do
          uint64_t v203 = 0x100000001B3 * (v203 ^ *((char *)&__p + v202++));
        while (v202 != 16);
        uint64_t v204 = *((void *)this + v203 + 75157);
        if (!v204) {
          goto LABEL_245;
        }
        while (1)
        {
          uint64_t v205 = *(void *)(v204 + 16);
          if (v205 >= v203) {
            break;
          }
          uint64_t v204 = *(void *)(v204 + 8);
          if (!v204) {
            goto LABEL_245;
          }
        }
        if (v205 == v203)
        {
          do
          {
            uint64_t v212 = *(void *)(v204 + 24);
            uint64_t v213 = *(void *)(v204 + 32);
            v214 = (void *)(*(void *)(v212 + 72) + 8 * (int)(*(_DWORD *)(v212 + 56) & v213));
            while (1)
            {
              v214 = (void *)*v214;
              if (!v214) {
                break;
              }
              if (v214[2] == v213)
              {
                int v215 = -1431655765 * (((unint64_t)v214 - *(void *)(v212 + 80)) >> 3);
                if ((v215 & 0x80000000) == 0 && *(_DWORD *)(v212 + 12) > v215)
                {
                  v122.n128_u32[0] = *(_DWORD *)(v204 + 52);
                  Phase::DspLayer::VoicePool::AddInput((Phase::DspLayer::VoicePool *)v212, v213, *(unsigned int *)(v204 + 40), v122);
                  Phase::DspLayer::VoicePool::UpdateParameters(*(Phase::DspLayer::VoicePool **)(v204 + 24), *(void *)(v204 + 32));
                }
                break;
              }
            }
            uint64_t v216 = *(void *)(v204 + 8);
            if (!v216) {
              break;
            }
            uint64_t v217 = *(void *)(v204 + 16);
            uint64_t v204 = *(void *)(v204 + 8);
          }
          while (*(void *)(v216 + 16) == v217);
        }
LABEL_245:
        uint64_t v218 = *((void *)this + v203 + 190103);
        if (v218)
        {
          while (1)
          {
            uint64_t v219 = *(void *)(v218 + 16);
            if (v219 >= v203) {
              break;
            }
            uint64_t v218 = *(void *)(v218 + 8);
            if (!v218) {
              goto LABEL_107;
            }
          }
          if (v219 == v203)
          {
            do
            {
              uint64_t v220 = *(void *)(v218 + 24);
              uint64_t v221 = *(void *)(v218 + 32);
              v222 = (void *)(*(void *)(v220 + 72) + 8 * (int)(*(_DWORD *)(v220 + 56) & v221));
              while (1)
              {
                v222 = (void *)*v222;
                if (!v222) {
                  break;
                }
                if (v222[2] == v221)
                {
                  int v223 = -1431655765 * (((unint64_t)v222 - *(void *)(v220 + 80)) >> 3);
                  if ((v223 & 0x80000000) == 0 && *(_DWORD *)(v220 + 12) > v223)
                  {
                    v122.n128_u32[0] = *(_DWORD *)(v218 + 52);
                    Phase::DspLayer::VoicePool::AddInput(v119, v120, *(unsigned int *)(v218 + 40), v122);
                    Phase::DspLayer::VoicePool::UpdateParameters(v119, v120);
                  }
                  break;
                }
              }
              uint64_t v224 = *(void *)(v218 + 8);
              if (!v224) {
                break;
              }
              uint64_t v225 = *(void *)(v218 + 16);
              uint64_t v218 = *(void *)(v218 + 8);
            }
            while (*(void *)(v224 + 16) == v225);
          }
        }
LABEL_107:
        uint64_t v44 = (uint64_t *)((char *)this + 24);
        unsigned int v45 = 2;
        uint64_t v46 = (uint64_t)v119;
        uint64_t v47 = v120;
        int v43 = v121;
        goto LABEL_108;
      case 4:
        double v123 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        uint64_t v124 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        Phase::DspLayer::VoicePool::ClearInputs(v123, v124);
        Phase::DspLayer::VoicePool::UpdateParameters(v123, v124);
        int v125 = Phase::DspLayer::VoicePool::Pause(v123, v124);
        if (v125) {
          goto LABEL_233;
        }
        uint64_t v126 = 0;
        uint64_t v127 = 0xCBF29CE484222325;
        std::string __p = v123;
        uint64_t v243 = v124;
        do
          uint64_t v127 = 0x100000001B3 * (v127 ^ *((char *)&__p + v126++));
        while (v126 != 16);
        uint64_t v128 = *((void *)this + v127 + 75157);
        if (!v128) {
          goto LABEL_232;
        }
        while (1)
        {
          uint64_t v129 = *(void *)(v128 + 16);
          if (v129 >= v127) {
            break;
          }
          uint64_t v128 = *(void *)(v128 + 8);
          if (!v128) {
            goto LABEL_232;
          }
        }
        if (v129 != v127)
        {
LABEL_232:
          int v125 = 0;
          goto LABEL_233;
        }
        int v125 = 0;
        do
        {
          uint64_t v206 = *(void *)(v128 + 24);
          uint64_t v207 = *(void *)(v128 + 32);
          v208 = (void *)(*(void *)(v206 + 72) + 8 * (int)(*(_DWORD *)(v206 + 56) & v207));
          while (1)
          {
            v208 = (void *)*v208;
            if (!v208) {
              break;
            }
            if (v208[2] == v207)
            {
              int v209 = -1431655765 * (((unint64_t)v208 - *(void *)(v206 + 80)) >> 3);
              if ((v209 & 0x80000000) == 0 && *(_DWORD *)(v206 + 12) > v209)
              {
                int v125 = Phase::DspLayer::VoicePool::RemoveInput((Phase::DspLayer::VoicePool *)v206, v207, *(unsigned int *)(v128 + 40));
                Phase::DspLayer::VoicePool::UpdateParameters(*(Phase::DspLayer::VoicePool **)(v128 + 24), *(void *)(v128 + 32));
              }
              break;
            }
          }
          uint64_t v210 = *(void *)(v128 + 8);
          if (!v210) {
            break;
          }
          uint64_t v211 = *(void *)(v128 + 16);
          uint64_t v128 = *(void *)(v128 + 8);
        }
        while (*(void *)(v210 + 16) == v211);
LABEL_233:
        a4.n128_f64[0] = Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePoolErr>((uint64_t *)this + 3, 6u, (uint64_t)v123, v124, v125);
        return a4.n128_f64[0];
      case 5:
        uint64_t v28 = 0;
        uint64_t v29 = *(void *)((char *)v6 + v10);
        uint64_t v30 = *(void *)((char *)v6 + v8 + 12);
        uint64_t v31 = 0xCBF29CE484222325;
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        std::string __p = (void *)v29;
        uint64_t v243 = v30;
        do
          uint64_t v31 = 0x100000001B3 * (v31 ^ *((char *)&__p + v28++));
        while (v28 != 16);
        unsigned int v32 = (void *)(*(void *)(v29 + 72) + 8 * (int)(*(_DWORD *)(v29 + 56) & v30));
        while (1)
        {
          unsigned int v32 = (void *)*v32;
          if (!v32) {
            break;
          }
          if (v32[2] == v30)
          {
            int v33 = -1431655765 * (((unint64_t)v32 - *(void *)(v29 + 80)) >> 3);
            if ((v33 & 0x80000000) == 0 && *(_DWORD *)(v29 + 12) > v33)
            {
              uint64_t v34 = (char *)this + 8 * v31 + 601248;
              uint64_t v37 = *((void *)v34 + 1);
              unint64_t v36 = (uint64_t *)(v34 + 8);
              uint64_t v35 = v37;
              if (v37)
              {
                do
                {
                  while (1)
                  {
                    uint64_t v38 = *(void *)(v35 + 16);
                    if (v38 >= v31) {
                      break;
                    }
                    uint64_t v35 = *(void *)(v35 + 8);
                    if (!v35) {
                      goto LABEL_50;
                    }
                  }
                  if (v38 != v31) {
                    break;
                  }
                  Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::RemoveNode((uint64_t)this + 601248, (uint64_t *)v35);
                  uint64_t v39 = *(void *)(v35 + 24);
                  uint64_t v40 = *(void *)(v35 + 32);
                  uint64_t v41 = (void *)(*(void *)(v39 + 72) + 8 * (int)(*(_DWORD *)(v39 + 56) & v40));
                  while (1)
                  {
                    uint64_t v41 = (void *)*v41;
                    if (!v41) {
                      break;
                    }
                    if (v41[2] == v40)
                    {
                      int v42 = -1431655765 * (((unint64_t)v41 - *(void *)(v39 + 80)) >> 3);
                      if ((v42 & 0x80000000) == 0 && *(_DWORD *)(v39 + 12) > v42)
                      {
                        Phase::DspLayer::VoicePool::RemoveInput((Phase::DspLayer::VoicePool *)v39, v40, *(unsigned int *)(v35 + 40));
                        Phase::DspLayer::VoicePool::UpdateParameters(*(Phase::DspLayer::VoicePool **)(v35 + 24), *(void *)(v35 + 32));
                      }
                      break;
                    }
                  }
                  uint64_t v35 = *v36;
                }
                while (*v36);
              }
            }
            break;
          }
        }
LABEL_50:
        std::string __p = (void *)v29;
        uint64_t v243 = v30;
        v248[0] = &unk_26D475D10;
        v248[3] = v248;
        Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelAllEvents((uint64_t)this + 601248, (uint64_t)v248, (uint64_t)&__p);
        std::__function::__value_func<BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::~__value_func[abi:ne180100](v248);
        Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelEvents((uint64_t)this + 1520816, v31);
        Phase::CalendarQueue<32,256,Phase::Controller::DVM_RT::SamplerState>::CancelEvents((uint64_t)this + 112, v31);
        Phase::CalendarQueue<32,256,std::function<void ()(float *,unsigned long)> *>::CancelEvents((uint64_t)this + 18816, v31);
        int v43 = Phase::DspLayer::VoicePool::Stop((Phase::DspLayer::VoicePool *)v29, v30);
        uint64_t v44 = (uint64_t *)((char *)this + 24);
        unsigned int v45 = 4;
        uint64_t v46 = v29;
        uint64_t v47 = v30;
LABEL_108:
        a4.n128_f64[0] = Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePoolErr>(v44, v45, v46, v47, v43);
        return a4.n128_f64[0];
      case 6:
        uint64_t v48 = *(void *)((char *)v6 + v10);
        uint64_t v49 = *(void *)((char *)v6 + v8 + 12);
        uint64_t v50 = *(void *)((char *)v6 + v8 + 20);
        uint64_t v51 = *(void *)((char *)v6 + v8 + 28);
        *((_DWORD *)a2 + 3) = v8 + 36;
        *((_DWORD *)a2 + 4) = v7 + 5;
        uint64_t v52 = *(unsigned int *)((char *)v6 + v8 + 36);
        uint64_t v53 = *(void *)((char *)v6 + v8 + 40);
        *((_DWORD *)a2 + 3) = v8 + 48;
        *((_DWORD *)a2 + 4) = v7 + 7;
        int v54 = *(_DWORD *)((char *)v6 + v8 + 48);
        unsigned __int32 v55 = *(_DWORD *)((char *)v6 + v8 + 52);
        *((_DWORD *)a2 + 3) = v8 + 56;
        *((_DWORD *)a2 + 4) = v7 + 9;
        int v56 = *((unsigned __int8 *)v6 + v7 + 17);
        *((_DWORD *)a2 + 4) = v7 + 10;
        if (v56 == 84) {
          goto LABEL_52;
        }
        uint64_t v191 = (int)(*(_DWORD *)(v48 + 56) & v49);
        uint64_t v190 = *(void *)(v48 + 72);
        v192 = (void *)(v190 + 8 * v191);
        do
        {
          v192 = (void *)*v192;
          if (!v192) {
            goto LABEL_191;
          }
        }
        while (v192[2] != v49);
        int v193 = -1431655765 * (((unint64_t)v192 - *(void *)(v48 + 80)) >> 3);
        if (v193 < 0 || *(_DWORD *)(v48 + 12) <= v193) {
          goto LABEL_191;
        }
LABEL_52:
        int v57 = (void *)(*(void *)(v50 + 72) + 8 * (int)(*(_DWORD *)(v50 + 56) & v51));
        while (1)
        {
          int v57 = (void *)*v57;
          if (!v57) {
            break;
          }
          if (v57[2] == v51)
          {
            int v58 = -1431655765 * (((unint64_t)v57 - *(void *)(v50 + 80)) >> 3);
            if ((v58 & 0x80000000) == 0 && *(_DWORD *)(v50 + 12) > v58)
            {
              a4.n128_u32[0] = v55;
              int v59 = Phase::DspLayer::VoicePool::AddInput((Phase::DspLayer::VoicePool *)v50, v51, v52, a4);
              if (v59)
              {
                Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int,Phase::DspLayer::VoicePoolErr>((uint64_t *)this + 3, 5u, v48, v49, v50, v51, v52, v53, v54, v59);
                return a4.n128_f64[0];
              }
            }
            break;
          }
        }
        if (v56 != 84)
        {
          uint64_t v190 = *(void *)(v48 + 72);
          uint64_t v191 = (int)(*(_DWORD *)(v48 + 56) & v49);
LABEL_191:
          v194 = (void *)(v190 + 8 * v191);
          while (1)
          {
            v194 = (void *)*v194;
            if (!v194) {
              return a4.n128_f64[0];
            }
            if (v194[2] == v49)
            {
              if (((-1431655765 * (((unint64_t)v194 - *(void *)(v48 + 80)) >> 3)) & 0x80000000) == 0)
              {
                v195 = (void *)(*(void *)(v50 + 72) + 8 * (int)(*(_DWORD *)(v50 + 56) & v51));
                while (1)
                {
                  v195 = (void *)*v195;
                  if (!v195) {
                    break;
                  }
                  if (v195[2] == v51)
                  {
                    if (((-1431655765 * (((unint64_t)v195 - *(void *)(v50 + 80)) >> 3)) & 0x80000000) != 0) {
                      return a4.n128_f64[0];
                    }
                    uint64_t v196 = 0;
                    uint64_t v197 = 0xCBF29CE484222325;
                    std::string __p = (void *)v48;
                    uint64_t v243 = v49;
                    uint64_t v198 = 0xCBF29CE484222325;
                    do
                      uint64_t v198 = 0x100000001B3 * (v198 ^ *((char *)&__p + v196++));
                    while (v196 != 16);
                    v199 = Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::ScheduleEvent((uint64_t)this + 601248, v198);
                    if (v199)
                    {
                      uint64_t v200 = 0;
                      void *v199 = v50;
                      v199[1] = v51;
                      *((_DWORD *)v199 + 4) = v52;
                      *((_DWORD *)v199 + 5) = v53;
                      *((_DWORD *)v199 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v54;
                      *((_DWORD *)v199 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v55;
                      std::string __p = (void *)v50;
                      uint64_t v243 = v51;
                      do
                        uint64_t v197 = 0x100000001B3 * (v197 ^ *((char *)&__p + v200++));
                      while (v200 != 16);
                      v201 = Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::ScheduleEvent((uint64_t)this + 1520816, v197);
                      if (v201)
                      {
                        void *v201 = v48;
                        v201[1] = v49;
                        *((_DWORD *)v201 + 4) = v52;
                        *((_DWORD *)v201 + 5) = v53;
                        *((_DWORD *)v201 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v54;
                        *((_DWORD *)v201 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v55;
                        return a4.n128_f64[0];
                      }
                      int v80 = (uint64_t *)((char *)this + 24);
                      int v233 = v54;
                      unsigned int v87 = 7;
                    }
                    else
                    {
                      int v80 = (uint64_t *)((char *)this + 24);
                      int v233 = v54;
                      unsigned int v87 = 6;
                    }
                    uint64_t v81 = v48;
                    uint64_t v82 = v49;
                    uint64_t v83 = v50;
                    uint64_t v84 = v51;
                    int v85 = v52;
                    int v86 = v53;
                    goto LABEL_79;
                  }
                }
              }
              return a4.n128_f64[0];
            }
          }
        }
        return a4.n128_f64[0];
      case 7:
        v240 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        uint64_t v60 = (uint64_t)v240;
        uint64_t v239 = *(void *)((char *)v6 + v8 + 12);
        uint64_t v61 = v239;
        int v62 = *(void **)((char *)v6 + v8 + 20);
        v238 = v62;
        uint64_t v63 = *(void *)((char *)v6 + v8 + 28);
        *((_DWORD *)a2 + 3) = v8 + 36;
        *((_DWORD *)a2 + 4) = v7 + 5;
        uint64_t v237 = v63;
        uint64_t v64 = *(unsigned int *)((char *)v6 + v8 + 36);
        *((_DWORD *)a2 + 3) = v8 + 40;
        *((_DWORD *)a2 + 4) = v7 + 6;
        int v236 = v64;
        int v65 = *(_DWORD *)((char *)v6 + v8 + 40);
        *((_DWORD *)a2 + 3) = v8 + 44;
        *((_DWORD *)a2 + 4) = v7 + 7;
        int v235 = v65;
        int v66 = *(_DWORD *)((char *)v6 + v8 + 44);
        *((_DWORD *)a2 + 3) = v8 + 48;
        *((_DWORD *)a2 + 4) = v7 + 8;
        int v234 = v66;
        int v67 = (void *)(*(void *)(v60 + 72) + 8 * (int)(*(_DWORD *)(v60 + 56) & v61));
        while (1)
        {
          int v67 = (void *)*v67;
          if (!v67) {
            break;
          }
          if (v67[2] == v61)
          {
            int v68 = -1431655765 * (((unint64_t)v67 - *(void *)(v60 + 80)) >> 3);
            if ((v68 & 0x80000000) == 0 && *(_DWORD *)(v60 + 12) > v68)
            {
              uint64_t v69 = (void *)(*((void *)v62 + 9) + 8 * (int)(*((_DWORD *)v62 + 14) & v63));
              while (1)
              {
                uint64_t v69 = (void *)*v69;
                if (!v69) {
                  break;
                }
                if (v69[2] == v63)
                {
                  int v70 = -1431655765 * (((unint64_t)v69 - *((void *)v62 + 10)) >> 3);
                  if ((v70 & 0x80000000) == 0 && *((_DWORD *)v62 + 3) > v70)
                  {
                    int v71 = Phase::DspLayer::VoicePool::RemoveInput((Phase::DspLayer::VoicePool *)v62, v63, v64);
                    if (v71) {
                      Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int,Phase::DspLayer::VoicePoolErr>((uint64_t *)this + 3, 0xAu, v60, v61, (uint64_t)v62, v63, v64, v65, v66, v71);
                    }
                  }
                  goto LABEL_71;
                }
              }
            }
            break;
          }
        }
LABEL_71:
        uint64_t v72 = 0;
        uint64_t v73 = 0xCBF29CE484222325;
        std::string __p = (void *)v60;
        uint64_t v243 = v61;
        uint64_t v74 = 0xCBF29CE484222325;
        do
          uint64_t v74 = 0x100000001B3 * (v74 ^ *((char *)&__p + v72++));
        while (v72 != 16);
        int v75 = operator new(0x30uLL);
        *int v75 = &unk_26D475D58;
        v75[1] = &v238;
        v75[2] = &v237;
        v75[3] = &v236;
        v75[4] = &v235;
        v75[5] = &v234;
        v247[3] = v75;
        char v76 = Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelEvent((uint64_t)this + 601248, v74, (uint64_t)v75);
        std::__function::__value_func<BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::~__value_func[abi:ne180100](v247);
        if ((v76 & 1) == 0) {
          Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int>((uint64_t *)this + 3, 8u, v60, v61, (uint64_t)v238, v237, v236, v235, v234);
        }
        uint64_t v77 = 0;
        std::string __p = v238;
        uint64_t v243 = v237;
        do
          uint64_t v73 = 0x100000001B3 * (v73 ^ *((char *)&__p + v77++));
        while (v77 != 16);
        uint64_t v78 = operator new(0x30uLL);
        void *v78 = &unk_26D475DA0;
        v78[1] = &v240;
        v78[2] = &v239;
        v78[3] = &v236;
        v78[4] = &v235;
        v78[5] = &v234;
        v246[3] = v78;
        char v79 = Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelEvent((uint64_t)this + 1520816, v73, (uint64_t)v78);
        std::__function::__value_func<BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::~__value_func[abi:ne180100](v246);
        if ((v79 & 1) == 0)
        {
          int v80 = (uint64_t *)((char *)this + 24);
          uint64_t v82 = v239;
          uint64_t v81 = (uint64_t)v240;
          uint64_t v84 = v237;
          uint64_t v83 = (uint64_t)v238;
          int v86 = v235;
          int v85 = v236;
          int v233 = v234;
          unsigned int v87 = 9;
LABEL_79:
          Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int>(v80, v87, v81, v82, v83, v84, v85, v86, v233);
        }
        return a4.n128_f64[0];
      case 8:
        uint64_t v130 = *(void *)((char *)v6 + v10);
        uint64_t v131 = *(void *)((char *)v6 + v8 + 12);
        uint64_t v132 = *(void *)((char *)v6 + v8 + 20);
        uint64_t v133 = *(void *)((char *)v6 + v8 + 28);
        *((_DWORD *)a2 + 3) = v8 + 36;
        *((_DWORD *)a2 + 4) = v7 + 5;
        uint64_t v134 = *(unsigned int *)((char *)v6 + v8 + 36);
        uint64_t v135 = *(void *)((char *)v6 + v8 + 40);
        *((_DWORD *)a2 + 3) = v8 + 48;
        *((_DWORD *)a2 + 4) = v7 + 7;
        int v136 = *(_DWORD *)((char *)v6 + v8 + 48);
        float v137 = *(float *)((char *)v6 + v8 + 52);
        *((_DWORD *)a2 + 3) = v8 + 56;
        *((_DWORD *)a2 + 4) = v7 + 9;
        uint64_t v138 = (void *)(*(void *)(v130 + 72) + 8 * (int)(*(_DWORD *)(v130 + 56) & v131));
        while (1)
        {
          uint64_t v138 = (void *)*v138;
          if (!v138) {
            break;
          }
          if (v138[2] == v131)
          {
            int v139 = -1431655765 * (((unint64_t)v138 - *(void *)(v130 + 80)) >> 3);
            if ((v139 & 0x80000000) == 0 && *(_DWORD *)(v130 + 12) > v139)
            {
              uint64_t v140 = (void *)(*(void *)(v132 + 72) + 8 * (int)(*(_DWORD *)(v132 + 56) & v133));
              while (1)
              {
                uint64_t v140 = (void *)*v140;
                if (!v140) {
                  break;
                }
                if (v140[2] == v133)
                {
                  int v141 = -1431655765 * (((unint64_t)v140 - *(void *)(v132 + 80)) >> 3);
                  if ((v141 & 0x80000000) == 0 && *(_DWORD *)(v132 + 12) > v141)
                  {
                    a4.n128_f32[0] = v137;
                    int v142 = Phase::DspLayer::VoicePool::SetInputGain((Phase::DspLayer::VoicePool *)v132, v133, v134, a4);
                    if (v142) {
                      Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int,float,Phase::DspLayer::VoicePoolErr>((uint64_t *)this + 3, v130, v131, v132, v133, v134, v135, v136, v137, v142);
                    }
                  }
                  goto LABEL_128;
                }
              }
            }
            break;
          }
        }
LABEL_128:
        uint64_t v143 = (void *)(*(void *)(v130 + 72) + 8 * (int)(*(_DWORD *)(v130 + 56) & v131));
        while (1)
        {
          uint64_t v143 = (void *)*v143;
          if (!v143) {
            break;
          }
          if (v143[2] == v131)
          {
            if (((-1431655765 * (((unint64_t)v143 - *(void *)(v130 + 80)) >> 3)) & 0x80000000) == 0)
            {
              char v144 = (void *)(*(void *)(v132 + 72) + 8 * (int)(*(_DWORD *)(v132 + 56) & v133));
              while (1)
              {
                char v144 = (void *)*v144;
                if (!v144) {
                  break;
                }
                if (v144[2] == v133)
                {
                  if (((-1431655765 * (((unint64_t)v144 - *(void *)(v132 + 80)) >> 3)) & 0x80000000) != 0) {
                    goto LABEL_175;
                  }
                  uint64_t v145 = 0;
                  uint64_t v146 = 0xCBF29CE484222325;
                  std::string __p = (void *)v130;
                  uint64_t v243 = v131;
                  uint64_t v147 = 0xCBF29CE484222325;
                  do
                    uint64_t v147 = 0x100000001B3 * (v147 ^ *((char *)&__p + v145++));
                  while (v145 != 16);
                  uint64_t v148 = *((void *)this + v147 + 75157);
                  if (v148)
                  {
                    while (1)
                    {
                      uint64_t v149 = *(void *)(v148 + 16);
                      if (v149 >= v147) {
                        break;
                      }
                      uint64_t v148 = *(void *)(v148 + 8);
                      if (!v148) {
                        goto LABEL_271;
                      }
                    }
                    if (v149 == v147)
                    {
                      while (*(void *)(v148 + 24) != v132 || *(void *)(v148 + 32) != v133)
                      {
                        uint64_t v148 = *(void *)(v148 + 8);
                        if (!v148 || *(void *)(v148 + 16) != v147) {
                          goto LABEL_271;
                        }
                      }
                      *(float *)(v148 + 52) = v137;
                    }
                  }
LABEL_271:
                  uint64_t v227 = 0;
                  std::string __p = (void *)v132;
                  uint64_t v243 = v133;
                  do
                    uint64_t v146 = 0x100000001B3 * (v146 ^ *((char *)&__p + v227++));
                  while (v227 != 16);
                  uint64_t v228 = *((void *)this + v146 + 190103);
                  if (v228)
                  {
                    while (1)
                    {
                      uint64_t v229 = *(void *)(v228 + 16);
                      BOOL v230 = v229 == v146;
                      if (v229 >= v146) {
                        break;
                      }
                      uint64_t v228 = *(void *)(v228 + 8);
                      if (!v228) {
                        return a4.n128_f64[0];
                      }
                    }
                    while (v230)
                    {
                      if (*(void *)(v228 + 24) == v130 && *(void *)(v228 + 32) == v131)
                      {
                        *(float *)(v228 + 52) = v137;
                        return a4.n128_f64[0];
                      }
                      uint64_t v228 = *(void *)(v228 + 8);
                      if (!v228) {
                        return a4.n128_f64[0];
                      }
                      BOOL v230 = *(void *)(v228 + 16) == v146;
                    }
                  }
                  return a4.n128_f64[0];
                }
              }
            }
            break;
          }
        }
LABEL_175:
        Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int,float,Phase::DspLayer::VoicePoolErr>((uint64_t *)this + 3, v130, v131, v132, v133, v134, v135, v136, v137, 2);
        return a4.n128_f64[0];
      case 9:
        v150 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        uint64_t v151 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        uint64_t v152 = *(unsigned int *)((char *)v6 + v8 + 20);
        *((_DWORD *)a2 + 3) = v8 + 32;
        *((_DWORD *)a2 + 4) = v7 + 5;
        *((_DWORD *)a2 + 3) = v8 + 36;
        *((_DWORD *)a2 + 4) = v7 + 6;
        Phase::DspLayer::VoicePool::SetOutput(v150, v151, v152);
        return a4.n128_f64[0];
      case 0xA:
        int v88 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        uint64_t v89 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        v240 = v88;
        uint64_t v241 = v89;
        v245[0] = &unk_26D475DE8;
        v245[3] = v245;
        Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelAllEvents((uint64_t)this + 601248, (uint64_t)v245, (uint64_t)&v240);
        uint64_t v90 = 0xCBF29CE484222325;
        std::__function::__value_func<BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::~__value_func[abi:ne180100](v245);
        uint64_t v91 = 0;
        std::string __p = v88;
        uint64_t v243 = v89;
        do
          uint64_t v90 = 0x100000001B3 * (v90 ^ *((char *)&__p + v91++));
        while (v91 != 16);
        Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelEvents((uint64_t)this + 1520816, v90);
        int v92 = Phase::DspLayer::VoicePool::ClearInputs(v88, v89);
        if (v92) {
          Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePoolErr>((uint64_t *)this + 3, (uint64_t)v88, v89, v92);
        }
        return a4.n128_f64[0];
      case 0xB:
        Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::Clear((uint64_t)this + 601248);
        Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::Clear((uint64_t)this + 1520816);
        uint64_t v93 = *((void *)this + 2);
        __int16 v94 = *(uint64_t **)(v93 + 32);
        unint64_t v95 = *(uint64_t **)(v93 + 40);
        while (v94 != v95)
        {
          uint64_t v96 = *v94++;
          Phase::DspLayer::VoicePool::ClearInputsFromAllVoices(v96);
        }
        return a4.n128_f64[0];
      case 0xC:
        __int16 v97 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        uint64_t v98 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        uint64_t v99 = *(unsigned int *)((char *)v6 + v8 + 20);
        double v100 = *(double *)((char *)v6 + v8 + 24);
        *((_DWORD *)a2 + 3) = v8 + 32;
        *((_DWORD *)a2 + 4) = v7 + 5;
        a4.n128_f64[0] = v100;
        int v101 = Phase::DspLayer::VoicePool::SetParameter(v97, v98, v99, a4);
        if (v101)
        {
          Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,int,double,Phase::DspLayer::VoicePoolErr>((uint64_t *)this + 3, (uint64_t)v97, v98, v99, v101, v100);
        }
        return a4.n128_f64[0];
      case 0xD:
        uint64_t v102 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        uint64_t v103 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        uint64_t v104 = *(unsigned int *)((char *)v6 + v8 + 20);
        uint64_t v105 = *(void **)((char *)v6 + v8 + 24);
        *((_DWORD *)a2 + 3) = v8 + 32;
        *((_DWORD *)a2 + 4) = v7 + 5;
        int v106 = *(_DWORD *)((char *)v6 + v8 + 32);
        *((_DWORD *)a2 + 3) = v8 + 36;
        *((_DWORD *)a2 + 4) = v7 + 6;
        int v107 = Phase::DspLayer::VoicePool::SetBuffer(v102, v103, v104, v105);
        if (v107)
        {
          Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long,void *,int,Phase::DspLayer::VoicePoolErr>((uint64_t *)this + 3, (uint64_t)v102, v103, (uint64_t)v105, v106, v107);
        }
        return a4.n128_f64[0];
      case 0xF:
        long long v153 = *(Phase::DspLayer::VoicePool **)((char *)v6 + v10);
        uint64_t v154 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        goto LABEL_209;
      case 0x10:
        uint64_t v155 = *(void *)((char *)v6 + v10);
        uint64_t v156 = (char *)v6 + v8;
        uint64_t v157 = *(void *)(v156 + 12);
        uint64_t v158 = *(void *)(v156 + 20);
        uint64_t v159 = *(void *)(v156 + 28);
        *((_DWORD *)a2 + 3) = v8 + 36;
        *((_DWORD *)a2 + 4) = v7 + 5;
        v160 = (uint64_t *)((char *)this + 24);
        a4.n128_f64[0] = Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,long long,long long,long long,long long>(v160, v155, v157, v158, v159);
        return a4.n128_f64[0];
      case 0x11:
        uint64_t v161 = 0;
        uint64_t v162 = 0xCBF29CE484222325;
        v163 = *(void **)((char *)v6 + v10);
        uint64_t v164 = *(void *)((char *)v6 + v8 + 12);
        v165 = *(unsigned int (**)(uint64_t, double *, void, uint64_t))((char *)v6 + v8 + 20);
        uint64_t v166 = *(void *)((char *)v6 + v8 + 28);
        uint64_t v167 = *(void *)((char *)v6 + v8 + 36);
        v168 = *(void **)((char *)v6 + v8 + 44);
        *((_DWORD *)a2 + 3) = v8 + 52;
        *((_DWORD *)a2 + 4) = v7 + 7;
        int v169 = *(_DWORD *)((char *)v6 + v8 + 52);
        *((_DWORD *)a2 + 3) = v8 + 56;
        *((_DWORD *)a2 + 4) = v7 + 8;
        uint64_t v170 = 0xCBF29CE484222325;
        std::string __p = v163;
        uint64_t v243 = v164;
        do
          uint64_t v170 = 0x100000001B3 * (v170 ^ *((char *)&__p + v161++));
        while (v161 != 16);
        v171 = (char *)this + 112;
        v172 = (char *)this + 8 * (v170 & 0x1F) + 112;
        while (1)
        {
          v172 = (char *)*((void *)v172 + 1);
          if (!v172) {
            break;
          }
          uint64_t v173 = *((void *)v172 + 2);
          if (v173 >= v170)
          {
            if (v173 == v170)
            {
              Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,BOOL (*)(void *,AudioTimeStamp const&,unsigned long,AudioBufferList *)>((uint64_t *)this + 3, (uint64_t)v163, v164, (uint64_t)v165);
              return a4.n128_f64[0];
            }
            break;
          }
        }
        uint64_t v182 = v166;
        v183 = Phase::CalendarQueue<32,256,Phase::Controller::DVM_RT::SamplerState>::ScheduleEvent((uint64_t)v171, v170);
        if (v183)
        {
          *((_DWORD *)v183 + 10) = v169;
          void *v183 = v165;
          v183[1] = v182;
          v183[2] = v167;
          v183[3] = v168;
          if (v169 < 0)
          {
            v186 = (unsigned char *)v163[6];
            if (!v186) {
              goto LABEL_183;
            }
            unsigned int v187 = *v186;
            if (!*v186) {
              goto LABEL_183;
            }
            v188 = v186 + 1;
            do
            {
              uint64_t v162 = 0x100000001B3 * (v162 ^ v187);
              unsigned int v189 = *v188++;
              unsigned int v187 = v189;
            }
            while (v189);
            if (v162 != 0xE8CBC3A55AEFC3DALL)
            {
LABEL_183:
              Phase::Controller::DVM_RT::RenderAndSetNextSamplerBuffer((uint64_t)this, (Phase::DspLayer::VoicePool *)v163, v164, v184, v185, v182, v165, v167, v168);
              goto LABEL_208;
            }
          }
        }
        else
        {
          a4.n128_f64[0] = Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long>((uint64_t *)this + 3, 0xFu, (uint64_t)v163, v164);
        }
        return a4.n128_f64[0];
      case 0x12:
        uint64_t v174 = 0;
        uint64_t v175 = 0xCBF29CE484222325;
        v163 = *(void **)((char *)v6 + v10);
        v176 = (char *)v6 + v8;
        uint64_t v164 = *(void *)(v176 + 12);
        uint64_t v177 = *(void *)(v176 + 20);
        *((_DWORD *)a2 + 3) = v8 + 28;
        *((_DWORD *)a2 + 4) = v7 + 4;
        std::string __p = v163;
        uint64_t v243 = v164;
        do
          uint64_t v175 = 0x100000001B3 * (v175 ^ *((char *)&__p + v174++));
        while (v174 != 16);
        v178 = (char *)this + 8 * (v175 & 0x1F) + 18816;
        break;
      case 0x13:
        uint64_t v108 = *(void *)((char *)v6 + v10);
        uint64_t v109 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        int v110 = Phase::Controller::ProcedureManager_RT::PlayProcedure((uint64_t)this + 2440384, v108, v109);
        double v111 = (uint64_t *)((char *)this + 24);
        unsigned int v112 = 3;
        goto LABEL_172;
      case 0x14:
        uint64_t v108 = *(void *)((char *)v6 + v10);
        uint64_t v109 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        int v110 = Phase::Controller::ProcedureManager_RT::StopProcedure((uint64_t)this + 2440384, v108);
        double v111 = (uint64_t *)((char *)this + 24);
        unsigned int v112 = 5;
        goto LABEL_172;
      case 0x15:
        uint64_t v108 = *(void *)((char *)v6 + v10);
        uint64_t v109 = *(void *)((char *)v6 + v8 + 12);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        int v110 = Phase::Controller::ProcedureManager_RT::PauseProcedure((uint64_t)this + 2440384, v108, v109);
        double v111 = (uint64_t *)((char *)this + 24);
        unsigned int v112 = 7;
LABEL_172:
        Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM::ProcedureBase *,long long,BOOL>(v111, v112, v108, v109, v110);
        return a4.n128_f64[0];
      case 0x16:
        uint64_t v113 = *(void *)((char *)v6 + v10);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        *((_DWORD *)a2 + 3) = v8 + 32;
        *((_DWORD *)a2 + 4) = v7 + 5;
        *((_DWORD *)a2 + 3) = v8 + 36;
        *((_DWORD *)a2 + 4) = v7 + 6;
        __int16 v114 = *(void (**)(void))(*(void *)v113 + 24);
        v114();
        return a4.n128_f64[0];
      case 0x17:
        uint64_t v115 = *(void *)((char *)v6 + v10);
        *((_DWORD *)a2 + 3) = v8 + 20;
        *((_DWORD *)a2 + 4) = v7 + 3;
        a4.n128_u64[0] = *(void *)((char *)v6 + v8 + 24);
        *((_DWORD *)a2 + 3) = v8 + 32;
        *((_DWORD *)a2 + 4) = v7 + 5;
        int v116 = *(void (**)(__n128))(*(void *)v115 + 16);
        a4.n128_f32[0] = a4.n128_f64[0];
        v116(a4);
        return a4.n128_f64[0];
      case 0x18:
        uint64_t v117 = *(void *)((char *)v6 + v10);
        *((_DWORD *)a2 + 3) = v8 + 12;
        *((_DWORD *)a2 + 4) = v7 + 2;
        __int16 v118 = *(void (**)(void))(*(void *)v117 + 32);
        v118();
        return a4.n128_f64[0];
      default:
        Phase::Controller::DVM_RT::DVMRTOSCCommand_ToString((Phase::Controller::DVM_RT *)&__p, a2);
        int v20 = (uint64_t *)((char *)this + 24);
        if (v244 >= 0) {
          p_p = (char *)&__p;
        }
        else {
          p_p = (char *)__p;
        }
        unsigned int v22 = 1;
        goto LABEL_19;
    }
    while (1)
    {
      v178 = (char *)*((void *)v178 + 1);
      if (!v178) {
        break;
      }
      uint64_t v179 = *((void *)v178 + 2);
      if (v179 >= v175)
      {
        if (v179 == v175)
        {
          Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,std::function<void ()(float *,unsigned long)> *>((uint64_t *)this + 3, (uint64_t)v163, v164, v177);
          Phase::CalendarQueue<32,256,std::function<void ()(float *,unsigned long)> *>::CancelEvents((uint64_t)this + 18816, v175);
        }
        break;
      }
    }
    v180 = Phase::CalendarQueue<32,256,std::function<void ()(float *,unsigned long)> *>::ScheduleEvent((uint64_t)this + 18816, v175);
    if (v180) {
      void *v180 = v177;
    }
    else {
      Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long>((uint64_t *)this + 3, 0x10u, (uint64_t)v163, v164);
    }
    v181.n128_f64[0] = (double)(unint64_t)(*(void *)(*((void *)this + 2) + 16) - *((void *)this + 5));
    Phase::DspLayer::VoicePool::SetParameter((Phase::DspLayer::VoicePool *)v163, v164, 1, v181);
LABEL_208:
    long long v153 = (Phase::DspLayer::VoicePool *)v163;
    uint64_t v154 = v164;
LABEL_209:
    Phase::DspLayer::VoicePool::UpdateParameters(v153, v154);
  }
  return a4.n128_f64[0];
}

void sub_221F12044(_Unwind_Exception *a1)
{
  std::__function::__value_func<BOOL ()(long long,Phase::Controller::DVM_RT::OSCData &,void *)>::~__value_func[abi:ne180100]((void *)(v1 - 144));
  _Unwind_Resume(a1);
}

uint64_t Phase::CalendarQueue<64,2048,Phase::Controller::DVM_RT::OSCData>::CancelAllEvents(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = 0;
  int v7 = 0;
  do
  {
    uint64_t v8 = *(uint64_t **)(v5 + 8 * v6 + 8);
    if (v8)
    {
      do
      {
        uint64_t v9 = v8[2];
        uint64_t v10 = *(void *)(a2 + 24);
        uint64_t v12 = a3;
        uint64_t v13 = v9;
        if (!v10) {
          std::__throw_bad_function_call[abi:ne180100]();
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(void *)v10 + 48))(v10, &v13, v8 + 3, &v12);
        uint64_t v11 = (uint64_t *)v8[1];
        if (result)
        {
          uint64_t result = Phase::CalendarQueue<64,2048,Phase::Controller::DVM_RT::OSCData>::RemoveNode(v5, v8);
          ++v7;
        }
        uint64_t v8 = v11;
      }
      while (v11);
    }
    ++v6;
  }
  while (v6 != 64);
  return result;
}

double Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePoolErr>(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = *((int *)a1 + 3);
  if (*((_DWORD *)a1 + 2) - (int)v5 >= 40)
  {
    uint64_t v6 = *a1 + v5;
    *(void *)(v6 + 4) = a2;
    *(void *)(v6 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    *(void *)(v6 + 24) = a4;
    *(void *)&double result = 6842480;
    *(_DWORD *)(v6 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 6842480;
    *(void *)(v6 + 32) = a5;
    uint64_t v8 = *a1;
    *(_DWORD *)(v8 + *((int *)a1 + 3)) = 36;
    *(_DWORD *)(v8 + 16) += 40;
    *((_DWORD *)a1 + 3) += 40;
  }
  return result;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM::ProcedureBase *,long long,BOOL>(uint64_t *result, unsigned int a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v5 >= 32)
  {
    uint64_t v6 = *result + v5;
    *(void *)(v6 + 4) = a2;
    *(unsigned char *)(v6 + 15) = 0;
    *(_WORD *)(v6 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 26736;
    *(void *)(v6 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    *(void *)(v6 + 24) = a4;
    if (a5) {
      char v7 = 84;
    }
    else {
      char v7 = 70;
    }
    *(unsigned char *)(v6 + 14) = v7;
    uint64_t v8 = *result;
    *(_DWORD *)(v8 + *((int *)result + 3)) = 28;
    *(_DWORD *)(v8 + 16) += 32;
    *((_DWORD *)result + 3) += 32;
  }
  return result;
}

uint64_t Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelAllEvents(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = result;
  uint64_t v6 = 0;
  int v7 = 0;
  do
  {
    uint64_t v8 = *(uint64_t **)(v5 + 8 * v6 + 8);
    if (v8)
    {
      do
      {
        uint64_t v9 = v8[2];
        uint64_t v10 = *(void *)(a2 + 24);
        uint64_t v12 = a3;
        uint64_t v13 = v9;
        if (!v10) {
          std::__throw_bad_function_call[abi:ne180100]();
        }
        double result = (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *, uint64_t *))(*(void *)v10 + 48))(v10, &v13, v8 + 3, &v12);
        uint64_t v11 = (uint64_t *)v8[1];
        if (result)
        {
          double result = Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::RemoveNode(v5, v8);
          ++v7;
        }
        uint64_t v8 = v11;
      }
      while (v11);
    }
    ++v6;
  }
  while (v6 != 256);
  return result;
}

uint64_t Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelEvents(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(uint64_t **)(result + 8 * a2 + 8);
  if (v3)
  {
    uint64_t v4 = result;
    while (v3[2] < a2)
    {
      uint64_t v3 = (uint64_t *)v3[1];
      if (!v3) {
        return result;
      }
    }
    do
    {
      if (v3[2] != a2) {
        break;
      }
      uint64_t v5 = (uint64_t *)v3[1];
      double result = Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::RemoveNode(v4, v3);
      uint64_t v3 = v5;
    }
    while (v5);
  }
  return result;
}

uint64_t Phase::CalendarQueue<32,256,Phase::Controller::DVM_RT::SamplerState>::CancelEvents(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result + 8 * (a2 & 0x1F);
  uint64_t v5 = *(void **)(v2 + 8);
  uint64_t v3 = (void *)(v2 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    while (v4[2] < a2)
    {
      uint64_t v4 = (void *)v4[1];
      if (!v4) {
        return result;
      }
    }
    do
    {
      if (v4[2] != a2) {
        break;
      }
      uint64_t v6 = (void *)v4[1];
      if (*v4) {
        int v7 = (void *)(*v4 + 8);
      }
      else {
        int v7 = v3;
      }
      void *v7 = v6;
      uint64_t v8 = (void *)v4[1];
      if (v8) {
        void *v8 = *v4;
      }
      uint64_t v9 = *(void **)result;
      void *v4 = 0;
      v4[1] = v9;
      if (v9) {
        *uint64_t v9 = v4;
      }
      *(void *)double result = v4;
      --*(_DWORD *)(result + 18696);
      uint64_t v4 = v6;
    }
    while (v6);
  }
  return result;
}

uint64_t Phase::CalendarQueue<32,256,std::function<void ()(float *,unsigned long)> *>::CancelEvents(uint64_t result, uint64_t a2)
{
  uint64_t v2 = result + 8 * (a2 & 0x1F);
  uint64_t v5 = *(void **)(v2 + 8);
  uint64_t v3 = (void *)(v2 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    while (v4[2] < a2)
    {
      uint64_t v4 = (void *)v4[1];
      if (!v4) {
        return result;
      }
    }
    do
    {
      if (v4[2] != a2) {
        break;
      }
      uint64_t v6 = (void *)v4[1];
      if (*v4) {
        int v7 = (void *)(*v4 + 8);
      }
      else {
        int v7 = v3;
      }
      void *v7 = v6;
      uint64_t v8 = (void *)v4[1];
      if (v8) {
        void *v8 = *v4;
      }
      uint64_t v9 = *(void **)result;
      void *v4 = 0;
      v4[1] = v9;
      if (v9) {
        *uint64_t v9 = v4;
      }
      *(void *)double result = v4;
      --*(_DWORD *)(result + 8456);
      uint64_t v4 = v6;
    }
    while (v6);
  }
  return result;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int,Phase::DspLayer::VoicePoolErr>(uint64_t *result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, int a9, int a10)
{
  uint64_t v10 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v10 >= 88)
  {
    uint64_t v11 = *result + v10;
    *(void *)(v11 + 4) = 9;
    *(void *)(v11 + 24) = a2;
    *(void *)(v11 + 32) = a3;
    *(void *)(v11 + 40) = a4;
    *(void *)(v11 + 48) = a5;
    *(void *)(v11 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a6;
    *(_DWORD *)(v11 + 64) = a7;
    *(void *)(v11 + 68) = a8;
    strcpy((char *)(v11 + 12), "hphphihih");
    *(_DWORD *)(v11 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a9;
    *(void *)(v11 + 80) = a10;
    uint64_t v12 = *result;
    *(_DWORD *)(v12 + *((int *)result + 3)) = 84;
    *(_DWORD *)(v12 + 16) += 88;
    *((_DWORD *)result + 3) += 88;
  }
  return result;
}

void *Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::ScheduleEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    uint64_t v3 = (void *)v2[1];
    *(void *)a1 = v3;
    if (v3) {
      void *v3 = 0;
    }
    void *v2 = 0;
    v2[1] = 0;
    v2[2] = a2;
    uint64_t v4 = a1 + 8 * a2;
    int v7 = *(void **)(v4 + 8);
    uint64_t v6 = (void *)(v4 + 8);
    uint64_t v5 = v7;
    if (v7)
    {
      if (v5[2] <= a2)
      {
        while (1)
        {
          uint64_t v9 = v5;
          uint64_t v5 = (void *)v5[1];
          if (!v5) {
            break;
          }
          if (v5[2] > a2)
          {
            void *v5 = v2;
            void *v2 = v9;
            v2[1] = v5;
            v9[1] = v2;
            goto LABEL_8;
          }
        }
        v9[1] = v2;
        void *v2 = v9;
        goto LABEL_8;
      }
      v2[1] = v5;
      void *v5 = v2;
    }
    *uint64_t v6 = v2;
LABEL_8:
    ++*(_DWORD *)(a1 + 919560);
    return v2 + 3;
  }
  return 0;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int>(uint64_t *result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, int a9)
{
  uint64_t v9 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v9 >= 80)
  {
    uint64_t v10 = *result + v9;
    *(void *)(v10 + 4) = 9;
    *(void *)(v10 + 24) = a2;
    *(void *)(v10 + 32) = a3;
    *(void *)(v10 + 40) = a4;
    *(void *)(v10 + 48) = a5;
    *(void *)(v10 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a6;
    *(_DWORD *)(v10 + 64) = a7;
    *(void *)(v10 + 68) = a8;
    strcpy((char *)(v10 + 12), "hphphihi");
    *(_DWORD *)(v10 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a9;
    uint64_t v11 = *result;
    *(_DWORD *)(v11 + *((int *)result + 3)) = 76;
    *(_DWORD *)(v11 + 16) += 80;
    *((_DWORD *)result + 3) += 80;
  }
  return result;
}

uint64_t Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::CancelEvent(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(uint64_t **)(a1 + 8 * a2 + 8);
  if (!v3) {
    return 0;
  }
  while (1)
  {
    uint64_t v5 = v3[2];
    if (v5 >= a2) {
      break;
    }
    uint64_t v3 = (uint64_t *)v3[1];
    if (!v3) {
      return 0;
    }
  }
  if (v5 != a2) {
    return 0;
  }
  if (!a3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a3 + 48))(a3, v3 + 3);
  if (result)
  {
    Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::RemoveNode(a1, v3);
    return 1;
  }
  return result;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePool *,long long,int,Phase::DspLayer::VoiceEngine::BusId,int,float,Phase::DspLayer::VoicePoolErr>(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, float a9, int a10)
{
  uint64_t v10 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v10 >= 92)
  {
    uint64_t v11 = *result + v10;
    *(void *)(v11 + 4) = 9;
    *(void *)(v11 + 24) = 12;
    *(void *)(v11 + 32) = a2;
    *(void *)(v11 + 40) = a3;
    *(void *)(v11 + 48) = a4;
    *(void *)(v11 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a5;
    *(_DWORD *)(v11 + 64) = a6;
    *(void *)(v11 + 68) = a7;
    strcpy((char *)(v11 + 12), "hphphihifh");
    *(_DWORD *)(v11 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a8;
    *(float *)(v11 + 80) = a9;
    *(void *)(v11 + 84) = a10;
    uint64_t v12 = *result;
    *(_DWORD *)(v12 + *((int *)result + 3)) = 88;
    *(_DWORD *)(v12 + 16) += 92;
    *((_DWORD *)result + 3) += 92;
  }
  return result;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,Phase::DspLayer::VoicePoolErr>(uint64_t *result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v4 >= 52)
  {
    uint64_t v5 = *result + v4;
    *(void *)(v5 + 4) = 9;
    *(void *)(v5 + 20) = 11;
    *(void *)(v5 + 28) = a2;
    *(void *)(v5 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    strcpy((char *)(v5 + 12), "hphh");
    *(void *)(v5 + 44) = a4;
    uint64_t v6 = *result;
    *(_DWORD *)(v6 + *((int *)result + 3)) = 48;
    *(_DWORD *)(v6 + 16) += 52;
    *((_DWORD *)result + 3) += 52;
  }
  return result;
}

uint64_t Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::Clear(uint64_t result)
{
  for (uint64_t i = 0; i != 256; ++i)
  {
    uint64_t v2 = result + 8 * i;
    uint64_t v5 = *(void *)(v2 + 8);
    uint64_t v3 = (void *)(v2 + 8);
    uint64_t v4 = v5;
    if (v5)
    {
      uint64_t v6 = v4;
      do
      {
        uint64_t v7 = v6;
        uint64_t v6 = *(void *)(v6 + 8);
      }
      while (v6);
      uint64_t v8 = *(void **)result;
      *(void *)(v7 + 8) = *(void *)result;
      if (v8) {
        void *v8 = v7;
      }
      *(void *)uint64_t result = v4;
    }
    void *v3 = 0;
  }
  *(_DWORD *)(result + 919560) = 0;
  return result;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,int,double,Phase::DspLayer::VoicePoolErr>(uint64_t *result, uint64_t a2, uint64_t a3, int a4, int a5, double a6)
{
  uint64_t v6 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v6 >= 64)
  {
    uint64_t v7 = *result + v6;
    *(void *)(v7 + 4) = 9;
    *(void *)(v7 + 20) = 4;
    *(void *)(v7 + 28) = a2;
    *(void *)(v7 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    strcpy((char *)(v7 + 12), "hphidh");
    *(_DWORD *)(v7 + 44) = a4;
    *(double *)(v7 + 48) = a6;
    *(void *)(v7 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a5;
    uint64_t v8 = *result;
    *(_DWORD *)(v8 + *((int *)result + 3)) = 60;
    *(_DWORD *)(v8 + 16) += 64;
    *((_DWORD *)result + 3) += 64;
  }
  return result;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long,void *,int,Phase::DspLayer::VoicePoolErr>(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v6 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v6 >= 56)
  {
    uint64_t v7 = *result + v6;
    *(void *)(v7 + 4) = 0;
    *(void *)(v7 + 20) = a2;
    *(void *)(v7 + 28) = a3;
    *(void *)(v7 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a4;
    strcpy((char *)(v7 + 12), "phpih");
    *(_DWORD *)(v7 + 44) = a5;
    *(void *)(v7 + 48) = a6;
    uint64_t v8 = *result;
    *(_DWORD *)(v8 + *((int *)result + 3)) = 52;
    *(_DWORD *)(v8 + 16) += 56;
    *((_DWORD *)result + 3) += 56;
  }
  return result;
}

double Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,long long,long long,long long,long long>(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *((int *)a1 + 3);
  if (*((_DWORD *)a1 + 2) - (int)v5 >= 52)
  {
    uint64_t v6 = *a1 + v5;
    *(void *)(v6 + 4) = 8;
    *(void *)(v6 + 20) = a2;
    *(void *)(v6 + 28) = a3;
    *(void *)(v6 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a4;
    double result = 8.90874679e194;
    strcpy((char *)(v6 + 12), "hhhh");
    *(void *)(v6 + 44) = a5;
    uint64_t v8 = *a1;
    *(_DWORD *)(v8 + *((int *)a1 + 3)) = 48;
    *(_DWORD *)(v8 + 16) += 52;
    *((_DWORD *)a1 + 3) += 52;
  }
  return result;
}

void *Phase::CalendarQueue<32,256,Phase::Controller::DVM_RT::SamplerState>::ScheduleEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    uint64_t v3 = (void *)v2[1];
    *(void *)a1 = v3;
    if (v3) {
      void *v3 = 0;
    }
    void *v2 = 0;
    v2[1] = 0;
    v2[2] = a2;
    uint64_t v4 = a1 + 8 * (a2 & 0x1F);
    uint64_t v7 = *(void **)(v4 + 8);
    uint64_t v6 = (void *)(v4 + 8);
    uint64_t v5 = v7;
    if (v7)
    {
      if (v5[2] <= a2)
      {
        while (1)
        {
          uint64_t v9 = v5;
          uint64_t v5 = (void *)v5[1];
          if (!v5) {
            break;
          }
          if (v5[2] > a2)
          {
            void *v5 = v2;
            void *v2 = v9;
            v2[1] = v5;
            v9[1] = v2;
            goto LABEL_8;
          }
        }
        v9[1] = v2;
        void *v2 = v9;
        goto LABEL_8;
      }
      v2[1] = v5;
      void *v5 = v2;
    }
    *uint64_t v6 = v2;
LABEL_8:
    ++*(_DWORD *)(a1 + 18696);
    return v2 + 3;
  }
  return 0;
}

void Phase::Controller::DVM_RT::RenderAndSetNextSamplerBuffer(uint64_t a1, Phase::DspLayer::VoicePool *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int (*a7)(uint64_t, double *, void, uint64_t), uint64_t a8, void *a9)
{
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v37 = 0u;
  uint64_t v15 = *(void *)(a1 + 16);
  double v16 = (double)(unint64_t)(*(void *)(v15 + 16) - *(void *)(a1 + 40));
  double v36 = *(double *)(a1 + 48) + v16;
  LODWORD(v40) = 1;
  int v17 = *(_DWORD *)(a1 + 104);
  if ((v17 & 2) != 0)
  {
    *(void *)&long long v37 = *(void *)(a1 + 56) + (uint64_t)(v16 / *(double *)v15 * 24000000.0);
    LODWORD(v40) = 3;
    int v18 = 7;
    if ((v17 & 4) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  int v18 = 5;
  if ((v17 & 4) != 0)
  {
LABEL_5:
    *((void *)&v37 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(void *)(a1 + 64);
    LODWORD(v40) = v18;
  }
LABEL_6:
  uint64_t v41 = a3;
  int v19 = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(a9, (unint64_t *)&v41);
  if (v19)
  {
    int v20 = (void *)v19[3];
    uint64_t v21 = *((unsigned __int8 *)v19 + 32);
    *((unsigned char *)v19 + 32) = 0;
  }
  else
  {
    int v20 = 0;
    uint64_t v21 = 0;
  }
  if (*(_DWORD *)(a8 + 12) >> 2 >= *(_DWORD *)(*(void *)(a1 + 16) + 24)) {
    int v22 = *(_DWORD *)(*(void *)(a1 + 16) + 24);
  }
  else {
    int v22 = *(_DWORD *)(a8 + 12) >> 2;
  }
  int v23 = (unsigned char *)*((void *)a2 + 6);
  if (!v23) {
    goto LABEL_30;
  }
  unsigned int v24 = *v23;
  if (!*v23) {
    goto LABEL_30;
  }
  int v25 = v23 + 1;
  uint64_t v26 = 0xCBF29CE484222325;
  do
  {
    uint64_t v26 = 0x100000001B3 * (v26 ^ v24);
    unsigned int v27 = *v25++;
    unsigned int v24 = v27;
  }
  while (v27);
  BOOL v28 = v26 == 0xCFE1F9A8E823B67BLL || v26 == 0xE8CBC3A55AEFC3DALL;
  if (!v28 && v26 != 0x15687F45806132E7)
  {
LABEL_30:
    Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long>((uint64_t *)(a1 + 24), 3u, (uint64_t)a2, a3);
    return;
  }
  if (v21) {
    goto LABEL_28;
  }
  if (a7(a6, &v36, v22, a8))
  {
    uint64_t v41 = a3;
    uint64_t v30 = std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(a9, (unint64_t *)&v41);
    if (!v30 || (int v20 = (void *)v30[3], v31 = *((unsigned __int8 *)v30 + 32), *((unsigned char *)v30 + 32) = 0, !v31)) {
      __assert_rtn("RenderAndSetNextSamplerBuffer", "DVM_RT.cpp", 1439, "bufferState.second == true");
    }
LABEL_28:
    if (!v20) {
      __assert_rtn("RenderAndSetNextSamplerBuffer", "DVM_RT.cpp", 1463, "false && \"DVM_RT::RenderAndSetNextSamplerBuffer failed to find a buffer to set on a sampler.\"");
    }
    Phase::DspLayer::VoicePool::SetBuffer(a2, a3, 0, v20);
    return;
  }
  if (v22 >= 48000) {
    int v32 = 48000;
  }
  else {
    int v32 = v22;
  }
  Phase::DspLayer::VoicePool::SetBuffer(a2, a3, 0, *(void **)(*(void *)(a1 + 16) + 74944));
  uint64_t v33 = *(int *)(a1 + 36);
  if (*(_DWORD *)(a1 + 32) - (int)v33 >= 48)
  {
    uint64_t v34 = *(void *)(a1 + 24) + v33;
    *(void *)(v34 + 4) = 9;
    *(void *)(v34 + 20) = 0;
    *(void *)(v34 + 28) = a2;
    *(void *)(v34 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    strcpy((char *)(v34 + 12), "hphi");
    *(_DWORD *)(v34 + 44) = v32;
    uint64_t v35 = *(void *)(a1 + 24);
    *(_DWORD *)(v35 + *(int *)(a1 + 36)) = 44;
    *(_DWORD *)(v35 + 16) += 48;
    *(_DWORD *)(a1 + 36) += 48;
  }
}

double Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long>(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *((int *)a1 + 3);
  if (*((_DWORD *)a1 + 2) - (int)v4 >= 40)
  {
    uint64_t v5 = *a1 + v4;
    *(void *)(v5 + 4) = 9;
    *(void *)(v5 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a2;
    *(void *)(v5 + 24) = a3;
    *(void *)&double result = 6844520;
    *(_DWORD *)(v5 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 6844520;
    *(void *)(v5 + 32) = a4;
    uint64_t v7 = *a1;
    *(_DWORD *)(v7 + *((int *)a1 + 3)) = 36;
    *(_DWORD *)(v7 + 16) += 40;
    *((_DWORD *)a1 + 3) += 40;
  }
  return result;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,BOOL (*)(void *,AudioTimeStamp const&,unsigned long,AudioBufferList *)>(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v4 >= 52)
  {
    uint64_t v5 = *result + v4;
    *(void *)(v5 + 4) = 9;
    *(void *)(v5 + 20) = 14;
    *(void *)(v5 + 28) = a2;
    *(void *)(v5 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    strcpy((char *)(v5 + 12), "hphp");
    *(void *)(v5 + 44) = a4;
    uint64_t v6 = *result;
    *(_DWORD *)(v6 + *((int *)result + 3)) = 48;
    *(_DWORD *)(v6 + 16) += 52;
    *((_DWORD *)result + 3) += 52;
  }
  return result;
}

uint64_t *Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,Phase::DspLayer::VoicePool *,long long,std::function<void ()(float *,unsigned long)> *>(uint64_t *result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *((int *)result + 3);
  if (*((_DWORD *)result + 2) - (int)v4 >= 52)
  {
    uint64_t v5 = *result + v4;
    *(void *)(v5 + 4) = 9;
    *(void *)(v5 + 20) = 13;
    *(void *)(v5 + 28) = a2;
    *(void *)(v5 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    strcpy((char *)(v5 + 12), "hphp");
    *(void *)(v5 + 44) = a4;
    uint64_t v6 = *result;
    *(_DWORD *)(v6 + *((int *)result + 3)) = 48;
    *(_DWORD *)(v6 + 16) += 52;
    *((_DWORD *)result + 3) += 52;
  }
  return result;
}

uint64_t Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::Controller::DVM_RT::DVMRTError,char const*>(uint64_t *a1, unsigned int a2, char *__s)
{
  uint64_t v6 = *((int *)a1 + 3);
  signed int v7 = *((_DWORD *)a1 + 2) - v6 - 4;
  uint64_t result = strlen(__s);
  if ((int)((result & 0xFFFFFFFC) + 24) <= v7)
  {
    uint64_t v9 = *a1 + v6;
    *(void *)(v9 + 4) = 9;
    strcpy((char *)(v9 + 12), "hs");
    *(void *)(v9 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a2;
    uint64_t v10 = (void *)(v9 + 24);
    size_t v11 = strlen(__s);
    int v12 = (v11 + 4) & 0xFFFFFFFC;
    uint64_t result = (uint64_t)memcpy(v10, __s, v11 + 1);
    if (v12 >= -20)
    {
      uint64_t v13 = *a1;
      *(_DWORD *)(v13 + *((int *)a1 + 3)) = v12 + 20;
      *(_DWORD *)(v13 + 16) += v12 + 24;
      *((_DWORD *)a1 + 3) += v12 + 24;
    }
  }
  return result;
}

void *Phase::Controller::DVM_RT::DVMRTOSCCommand_ToString(Phase::Controller::DVM_RT *this, Phase::PhaseOSCMessage *a2)
{
  uint64_t v97 = *MEMORY[0x263EF8340];
  uint64_t v4 = *(int **)a2;
  size_t v5 = strlen((const char *)(*(void *)a2 + 8)) & 0xFFFFFFFC;
  *((_DWORD *)a2 + 3) = v5 + 12;
  *((_DWORD *)a2 + 4) = 0;
  uint64_t v6 = *(unsigned int *)((char *)v4 + (int)v5 + 12);
  int v7 = *v4;
  int v8 = v5 + 16;
  *((_DWORD *)a2 + 3) = v5 + 16;
  *((_DWORD *)a2 + 4) = 1;
  switch(v7)
  {
    case 0:
      uint64_t v83 = v6;
      uint64_t v9 = "ClearPools<%i>";
      goto LABEL_38;
    case 1:
      uint64_t v10 = *(const char **)((char *)v4 + v8);
      *((_DWORD *)a2 + 3) = v5 + 24;
      *((_DWORD *)a2 + 4) = 2;
      uint64_t v11 = *((void *)v10 + 6);
      int v12 = (const char *)*(unsigned int *)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 28;
      *((_DWORD *)a2 + 4) = 3;
      int v85 = v10;
      int v86 = v12;
      uint64_t v83 = v6;
      uint64_t v84 = v11;
      uint64_t v9 = "AddPool<%i> %s(%08x) idx:%i";
      goto LABEL_38;
    case 3:
      int v14 = *(const char **)((char *)v4 + v8);
      uint64_t v15 = *((void *)v14 + 6);
      double v16 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      int v85 = v14;
      int v86 = v16;
      uint64_t v83 = v6;
      uint64_t v84 = v15;
      uint64_t v9 = "PlayVoice<%i> %s(%08x):%lli";
      goto LABEL_38;
    case 4:
      int v17 = *(const char **)((char *)v4 + v8);
      uint64_t v18 = *((void *)v17 + 6);
      int v19 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      int v85 = v17;
      int v86 = v19;
      uint64_t v83 = v6;
      uint64_t v84 = v18;
      uint64_t v9 = "PauseVoice<%i> %s(%08x):%lli";
      goto LABEL_38;
    case 5:
      int v20 = *(const char **)((char *)v4 + v8);
      uint64_t v21 = *((void *)v20 + 6);
      int v22 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      int v85 = v20;
      int v86 = v22;
      uint64_t v83 = v6;
      uint64_t v84 = v21;
      uint64_t v9 = "StopVoice<%i> %s(%08x):%lli";
      goto LABEL_38;
    case 6:
      int v23 = *(const char **)((char *)v4 + v8);
      unsigned int v24 = *(const char **)((char *)v4 + (int)v5 + 24);
      uint64_t v25 = *(void *)((char *)v4 + (int)v5 + 32);
      uint64_t v26 = *(void *)((char *)v4 + (int)v5 + 40);
      *((_DWORD *)a2 + 3) = v5 + 48;
      *((_DWORD *)a2 + 4) = 5;
      unsigned int v27 = (const char *)*(unsigned int *)((char *)v4 + (int)v5 + 48);
      uint64_t v28 = *(void *)((char *)v4 + (int)v5 + 52);
      *((_DWORD *)a2 + 3) = v5 + 60;
      *((_DWORD *)a2 + 4) = 7;
      uint64_t v29 = (const char *)*(unsigned int *)((char *)v4 + (int)v5 + 60);
      float v30 = *(float *)((char *)v4 + (int)v5 + 64);
      *((_DWORD *)a2 + 3) = v5 + 68;
      *((_DWORD *)a2 + 4) = 9;
      int v31 = *((unsigned __int8 *)v4 + 17);
      *((_DWORD *)a2 + 4) = 10;
      if (v31 == 84)
      {
        float v32 = log10f(v30);
        uint64_t v90 = (const char *)v25;
        uint64_t v91 = v26;
        int v88 = v27;
        double v89 = *(double *)(v25 + 48);
        double v87 = (float)(v32 * 10.0);
        uint64_t v9 = "AddVoiceInput<%i> Procedure(%08x):%lli ]- in:%i@%5.2fdB ->[%i %s(%08x):%lli";
        int v85 = v24;
        int v86 = v29;
        uint64_t v84 = (uint64_t)v23;
      }
      else
      {
        uint64_t v95 = *((void *)v23 + 6);
        if (v28 > 5) {
          *(double *)&char v79 = COERCE_DOUBLE("bus");
        }
        else {
          char v79 = off_2645F7350[(int)v28];
        }
        float v82 = log10f(v30);
        uint64_t v92 = v25;
        uint64_t v93 = v26;
        uint64_t v90 = v27;
        uint64_t v91 = *(void *)(v25 + 48);
        double v89 = (float)(v82 * 10.0);
        double v87 = *(double *)&v79;
        int v88 = v29;
        uint64_t v9 = "AddVoiceInput<%i> %s(%08x):%lli ]- %s:%i@%5.2fdB ->[%i %s(%08x):%lli";
        int v85 = v23;
        int v86 = v24;
        uint64_t v84 = v95;
      }
      goto LABEL_37;
    case 8:
      uint64_t v33 = *(const char **)((char *)v4 + v8);
      uint64_t v34 = *(const char **)((char *)v4 + (int)v5 + 24);
      uint64_t v35 = *(void *)((char *)v4 + (int)v5 + 32);
      uint64_t v36 = *(void *)((char *)v4 + (int)v5 + 40);
      *((_DWORD *)a2 + 3) = v5 + 48;
      *((_DWORD *)a2 + 4) = 5;
      long long v37 = (const char *)*(unsigned int *)((char *)v4 + (int)v5 + 48);
      uint64_t v38 = *(void *)((char *)v4 + (int)v5 + 52);
      *((_DWORD *)a2 + 3) = v5 + 60;
      *((_DWORD *)a2 + 4) = 7;
      long long v39 = (const char *)*(unsigned int *)((char *)v4 + (int)v5 + 60);
      float v40 = *(float *)((char *)v4 + (int)v5 + 64);
      *((_DWORD *)a2 + 3) = v5 + 68;
      *((_DWORD *)a2 + 4) = 9;
      uint64_t v41 = *((void *)v33 + 6);
      __int16 v94 = v33;
      uint64_t v42 = v36;
      if (v38 > 5) {
        *(double *)&int v43 = COERCE_DOUBLE("bus");
      }
      else {
        int v43 = off_2645F7350[(int)v38];
      }
      float v80 = log10f(v40);
      uint64_t v92 = v35;
      uint64_t v93 = v42;
      uint64_t v90 = v37;
      uint64_t v91 = *(void *)(v35 + 48);
      double v89 = (float)(v80 * 10.0);
      double v87 = *(double *)&v43;
      int v88 = v39;
      uint64_t v9 = "SetVoiceInputGain<%i> %s(%08x):%lli ]- %s:%i@%5.2fdB ->[%i %s(%08x):%lli";
      int v85 = v94;
      int v86 = v34;
      uint64_t v84 = v41;
      goto LABEL_37;
    case 9:
      uint64_t v44 = *(const char **)((char *)v4 + v8);
      uint64_t v45 = *((void *)v44 + 6);
      uint64_t v46 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      *(void *)&double v47 = *(unsigned int *)((char *)v4 + (int)v5 + 32);
      uint64_t v48 = *(void *)((char *)v4 + (int)v5 + 36);
      *((_DWORD *)a2 + 3) = v5 + 44;
      *((_DWORD *)a2 + 4) = 5;
      if (v48 > 5) {
        uint64_t v49 = "bus";
      }
      else {
        uint64_t v49 = off_2645F7350[(int)v48];
      }
      *(void *)&double v81 = *(unsigned int *)((char *)v4 + (int)v5 + 44);
      *((_DWORD *)a2 + 3) = v5 + 48;
      *((_DWORD *)a2 + 4) = 6;
      int v88 = v49;
      double v89 = v81;
      int v86 = v46;
      double v87 = v47;
      uint64_t v9 = "SetVoiceOutput<%i> %s(%08x):%lli %i]->%s:%i";
      uint64_t v84 = v45;
      int v85 = v44;
      goto LABEL_37;
    case 10:
      uint64_t v50 = *(const char **)((char *)v4 + v8);
      uint64_t v51 = *((void *)v50 + 6);
      uint64_t v52 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      int v85 = v50;
      int v86 = v52;
      uint64_t v83 = v6;
      uint64_t v84 = v51;
      uint64_t v9 = "RemoveAllVoiceInputs<%i> %s(%08x):%lli";
      goto LABEL_38;
    case 11:
      uint64_t v83 = v6;
      uint64_t v9 = "ClearAllVoiceInputs<%i>";
      goto LABEL_38;
    case 12:
      uint64_t v53 = *(const char **)((char *)v4 + v8);
      uint64_t v54 = *((void *)v53 + 6);
      unsigned __int32 v55 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      int v56 = *(const char **)((char *)v4 + (int)v5 + 36);
      *(void *)&double v57 = *(unsigned int *)((char *)v4 + (int)v5 + 32);
      *((_DWORD *)a2 + 3) = v5 + 44;
      *((_DWORD *)a2 + 4) = 5;
      int v88 = v56;
      int v86 = v55;
      double v87 = v57;
      uint64_t v84 = v54;
      int v85 = v53;
      uint64_t v83 = v6;
      uint64_t v9 = "SetParameter<%i> %s(%08x):%lli param:%i val:%g";
      goto LABEL_38;
    case 13:
      int v58 = *(const char **)((char *)v4 + v8);
      uint64_t v59 = *((void *)v58 + 6);
      uint64_t v60 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      uint64_t v61 = *(const char **)((char *)v4 + (int)v5 + 36);
      *(void *)&double v62 = *(unsigned int *)((char *)v4 + (int)v5 + 32);
      *((_DWORD *)a2 + 3) = v5 + 44;
      *((_DWORD *)a2 + 4) = 5;
      *(void *)&double v63 = *(unsigned int *)((char *)v4 + (int)v5 + 44);
      *((_DWORD *)a2 + 3) = v5 + 48;
      *((_DWORD *)a2 + 4) = 6;
      int v88 = v61;
      double v89 = v63;
      int v86 = v60;
      double v87 = v62;
      uint64_t v9 = "SetBuffer<%i> %s(%08x):%lli buff:%i %p len:%i";
      uint64_t v84 = v59;
      int v85 = v58;
LABEL_37:
      uint64_t v83 = v6;
      goto LABEL_38;
    case 15:
      uint64_t v64 = *(const char **)((char *)v4 + v8);
      uint64_t v65 = *((void *)v64 + 6);
      int v66 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      int v85 = v64;
      int v86 = v66;
      uint64_t v83 = v6;
      uint64_t v84 = v65;
      uint64_t v9 = "UpdateVoice<%i> %s(%08x):%lli";
      goto LABEL_38;
    case 16:
      uint64_t v67 = *(void *)((char *)v4 + v8);
      int v68 = *(const char **)((char *)v4 + (int)v5 + 24);
      uint64_t v69 = *(const char **)((char *)v4 + (int)v5 + 32);
      unint64_t v70 = *(void *)((char *)v4 + (int)v5 + 40);
      *((_DWORD *)a2 + 3) = v5 + 48;
      *((_DWORD *)a2 + 4) = 5;
      if (v70 > 3) {
        *(double *)&int v71 = COERCE_DOUBLE("???");
      }
      else {
        int v71 = off_2645F7380[v70];
      }
      int v86 = v69;
      double v87 = *(double *)&v71;
      uint64_t v84 = v67;
      int v85 = v68;
      uint64_t v83 = v6;
      uint64_t v9 = "NodePlayState<%i> nodeid:%lli 0x%lli%lli %s";
      goto LABEL_38;
    case 17:
      uint64_t v72 = *(const char **)((char *)v4 + v8);
      uint64_t v73 = *((void *)v72 + 6);
      uint64_t v74 = *(const char **)((char *)v4 + (int)v5 + 24);
      *((_DWORD *)a2 + 3) = v5 + 32;
      *((_DWORD *)a2 + 4) = 3;
      int v85 = v72;
      int v86 = v74;
      uint64_t v83 = v6;
      uint64_t v84 = v73;
      uint64_t v9 = "ConfigureSampler<%i> %s(%08x):%lli";
      goto LABEL_38;
    case 18:
      int v75 = *(const char **)((char *)v4 + v8);
      uint64_t v76 = *((void *)v75 + 6);
      uint64_t v77 = *(const char **)((char *)v4 + (int)v5 + 24);
      double v78 = *(double *)((char *)v4 + (int)v5 + 32);
      *((_DWORD *)a2 + 3) = v5 + 40;
      *((_DWORD *)a2 + 4) = 4;
      int v86 = v77;
      double v87 = v78;
      uint64_t v84 = v76;
      int v85 = v75;
      uint64_t v83 = v6;
      uint64_t v9 = "SetTapperCallback<%i> %s(%08x):%lli callback@%p";
LABEL_38:
      snprintf(__str, 0x400uLL, v9, v83, v84, v85, v86, *(void *)&v87, v88, *(void *)&v89, v90, v91, v92, v93);
      *(void *)((char *)a2 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = (strlen((const char *)(*(void *)a2 + 8)) & 0xFFFFFFFC) + 12;
      uint64_t result = std::string::basic_string[abi:ne180100]<0>(this, __str);
      break;
    default:
      uint64_t result = Phase::PhaseOSCMessage::ToString(a2, this);
      break;
  }
  return result;
}

uint64_t Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long>(uint64_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *((int *)a1 + 3);
  if (*((_DWORD *)a1 + 2) - (int)v4 < 32) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v6 = *a1 + v4;
  *(void *)(v6 + 4) = a2;
  strcpy((char *)(v6 + 12), "ph");
  *(void *)(v6 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
  *(void *)(v6 + 24) = a4;
  uint64_t v7 = *a1;
  uint64_t v5 = 28;
  *(_DWORD *)(v7 + *((int *)a1 + 3)) = 28;
  *(_DWORD *)(v7 + 16) += 32;
  *((_DWORD *)a1 + 3) += 32;
  return v5;
}

void *Phase::PhaseOSCMessage::ToString@<X0>(Phase::PhaseOSCMessage *this@<X0>, void *a2@<X8>)
{
  double v16 = a2;
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)this;
  *((_DWORD *)this + 3) = (strlen((const char *)(*(void *)this + 8)) & 0xFFFFFFFC) + 12;
  *((_DWORD *)this + 4) = 0;
  int v4 = snprintf(__str, 0x400uLL, "0x%08llX", *(void *)v3);
  char v5 = *(unsigned char *)(v3 + 8);
  if (v5)
  {
    int v6 = v4;
    uint64_t v7 = (unsigned __int8 *)(v3 + 9);
    do
    {
      if (v5 <= 99)
      {
        if (v5 != 70 && v5 != 84) {
          goto LABEL_18;
        }
        uint64_t v10 = &__str[v6];
        size_t v11 = 1024 - v6;
        if (v5 == 84) {
          int v12 = snprintf(v10, v11, " true", v15, v16);
        }
        else {
          int v12 = snprintf(v10, v11, " false");
        }
      }
      else
      {
        switch(v5)
        {
          case 'd':
            int v8 = &__str[v6];
            size_t v9 = 1024 - v6;
            *(int32x2_t *)((char *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = vadd_s32(*(int32x2_t *)((char *)this + 12), (int32x2_t)0x100000008);
            goto LABEL_14;
          case 'e':
          case 'g':
            goto LABEL_18;
          case 'f':
            int v8 = &__str[v6];
            size_t v9 = 1024 - v6;
            *(int32x2_t *)((char *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = vadd_s32(*(int32x2_t *)((char *)this + 12), (int32x2_t)0x100000004);
LABEL_14:
            int v12 = snprintf(v8, v9, " %g");
            break;
          case 'h':
            *(int32x2_t *)((char *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = vadd_s32(*(int32x2_t *)((char *)this + 12), (int32x2_t)0x100000008);
            int v12 = snprintf(&__str[v6], 1024 - v6, " %lli");
            break;
          case 'i':
            *(int32x2_t *)((char *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = vadd_s32(*(int32x2_t *)((char *)this + 12), (int32x2_t)0x100000004);
            int v12 = snprintf(&__str[v6], 1024 - v6, " %i");
            break;
          default:
            if (v5 != 112) {
              goto LABEL_18;
            }
            *(int32x2_t *)((char *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = vadd_s32(*(int32x2_t *)((char *)this + 12), (int32x2_t)0x100000008);
            int v12 = snprintf(&__str[v6], 1024 - v6, " %p");
            break;
        }
      }
      v6 += v12;
LABEL_18:
      int v13 = *v7++;
      char v5 = v13;
    }
    while (v13);
  }
  *(void *)((char *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = (strlen((const char *)(*(void *)this + 8)) & 0xFFFFFFFC) + 12;
  return std::string::basic_string[abi:ne180100]<0>(v16, __str);
}

double Phase::Controller::DVM_RT::Reset(Phase::Controller::DVM_RT *this)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v2 = (_DWORD *)((char *)this + 601240);
  uint64_t v3 = (_DWORD *)((char *)this + 18808);
  int v4 = **(NSObject ***)(Phase::Logger::GetInstance(this) + 80);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(*((void *)this + 2) + 16);
    int v27 = 136315650;
    uint64_t v28 = "DVM_RT.cpp";
    __int16 v29 = 1024;
    int v30 = 1671;
    __int16 v31 = 2048;
    uint64_t v32 = v5;
    _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_DEFAULT, "%25s:%-5d DVM-RT is reset @ Frame %llu", (uint8_t *)&v27, 0x1Cu);
  }
  Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::Clear((uint64_t)this + 601248);
  Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::Clear((uint64_t)this + 1520816);
  for (uint64_t i = 0; i != 64; ++i)
  {
    uint64_t v7 = (char *)this + 8 * i;
    uint64_t v8 = *((void *)v7 + 3411);
    if (v8)
    {
      uint64_t v9 = *((void *)v7 + 3411);
      do
      {
        uint64_t v10 = v9;
        uint64_t v9 = *(void *)(v9 + 8);
      }
      while (v9);
      size_t v11 = (void *)*((void *)this + 3410);
      *(void *)(v10 + 8) = v11;
      if (v11) {
        void *v11 = v10;
      }
      *((void *)this + 3410) = v8;
    }
    *((void *)v7 + 341Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  }
  uint64_t v12 = 0;
  _DWORD *v2 = 0;
  do
  {
    int v13 = (char *)this + 8 * v12;
    uint64_t v16 = *((void *)v13 + 15);
    int v14 = v13 + 120;
    uint64_t v15 = v16;
    if (v16)
    {
      uint64_t v17 = v15;
      do
      {
        uint64_t v18 = v17;
        uint64_t v17 = *(void *)(v17 + 8);
      }
      while (v17);
      int v19 = (void *)*((void *)this + 14);
      *(void *)(v18 + 8) = v19;
      if (v19) {
        void *v19 = v18;
      }
      *((void *)this + 14) = v15;
    }
    void *v14 = 0;
    ++v12;
  }
  while (v12 != 32);
  uint64_t v20 = 0;
  _DWORD *v3 = 0;
  do
  {
    uint64_t v21 = (char *)this + 8 * v20;
    uint64_t v22 = *((void *)v21 + 2353);
    if (v22)
    {
      uint64_t v23 = *((void *)v21 + 2353);
      do
      {
        uint64_t v24 = v23;
        uint64_t v23 = *(void *)(v23 + 8);
      }
      while (v23);
      uint64_t v25 = (void *)*((void *)this + 2352);
      *(void *)(v24 + 8) = v25;
      if (v25) {
        *uint64_t v25 = v24;
      }
      *((void *)this + 2352) = v22;
    }
    *((void *)v21 + 2353) = 0;
    ++v20;
  }
  while (v20 != 32);
  v3[2116] = 0;
  std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::clear((void *)this + 305049);
  std::__hash_table<std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,Phase::Controller::Parameter<double>>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,Phase::Controller::Parameter<double>>>>::clear((void *)this + 305054);
  double result = 0.0;
  *(_OWORD *)((char *)this + 2440472) = 0u;
  *(_OWORD *)((char *)this + 2440488) = 0u;
  return result;
}

uint64_t Phase::CalendarQueue<64,2048,Phase::Controller::DVM_RT::OSCData>::RemoveNode(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    uint64_t v2 = result + 8 * (a2[2] & 0x3F);
  }
  *(void *)(v2 + 8) = a2[1];
  uint64_t v3 = (uint64_t *)a2[1];
  if (v3) {
    uint64_t *v3 = *a2;
  }
  int v4 = *(uint64_t ***)result;
  *a2 = 0;
  a2[1] = (uint64_t)v4;
  if (v4) {
    NSObject *v4 = a2;
  }
  *(void *)double result = a2;
  --*(_DWORD *)(result + 573960);
  return result;
}

void std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_0,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_0>,BOOL ()(long long,Phase::Controller::DVM_RT::OSCData &,void *)>::~__func()
{
}

void *std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_0,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_0>,BOOL ()(long long,Phase::Controller::DVM_RT::OSCData &,void *)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_26D475CC8;
  return result;
}

void std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_0,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_0>,BOOL ()(long long,Phase::Controller::DVM_RT::OSCData &,void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D475CC8;
}

BOOL std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_0,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_0>,BOOL ()(long long,Phase::Controller::DVM_RT::OSCData &,void *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, void **a4)
{
  uint64_t v4 = a3 + 4;
  BOOL result = 0;
  if (*(_DWORD *)(a3 + 4) == 4)
  {
    uint64_t v5 = *a4;
    int v6 = strlen((const char *)(a3 + 12)) & 0xFFFFFFFC;
    if (*v5 == *(void *)(v4 + v6 + 16) && *(void *)(v4 + v6 + 24) == v5[1]) {
      return 1;
    }
  }
  return result;
}

void *std::__function::__value_func<BOOL ()(long long,Phase::Controller::DVM_RT::OSCData &,void *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t Phase::CalendarQueue<256,16384,Phase::Controller::DVM_RT::VoiceConnectionData>::RemoveNode(uint64_t result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (!*a2) {
    uint64_t v2 = result + 8 * *((unsigned __int8 *)a2 + 16);
  }
  *(void *)(v2 + 8) = a2[1];
  uint64_t v3 = (uint64_t *)a2[1];
  if (v3) {
    uint64_t *v3 = *a2;
  }
  uint64_t v4 = *(uint64_t ***)result;
  *a2 = 0;
  a2[1] = (uint64_t)v4;
  if (v4) {
    NSObject *v4 = a2;
  }
  *(void *)BOOL result = a2;
  --*(_DWORD *)(result + 919560);
  return result;
}

void std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_1,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_1>,BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::~__func()
{
}

void *std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_1,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_1>,BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_26D475D10;
  return result;
}

void std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_1,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_1>,BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D475D10;
}

BOOL std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_1,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_1>,BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::operator()(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  return *a3 == **(void **)a4 && a3[1] == *(void *)(*(void *)a4 + 8);
}

void *std::__function::__value_func<BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_2,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_2>,BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::~__func()
{
}

__n128 std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_2,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_2>,BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_26D475D58;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_2,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_2>,BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D475D58;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_2,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_2>,BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(void *)a2 == **(void **)(a1 + 8)
      && *(void *)(a2 + 8) == **(void **)(a1 + 16)
      && *(_DWORD *)(a2 + 16) == **(_DWORD **)(a1 + 24)
      && *(_DWORD *)(a2 + 20) == **(_DWORD **)(a1 + 32)
      && *(_DWORD *)(a2 + 24) == **(_DWORD **)(a1 + 40);
}

void *std::__function::__value_func<BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_3,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_3>,BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::~__func()
{
}

__n128 std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_3,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_3>,BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint64_t v2 = &unk_26D475DA0;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

__n128 std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_3,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_3>,BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_26D475DA0;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(void *)(a2 + 40) = *(void *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

BOOL std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_3,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_3>,BOOL ()(Phase::Controller::DVM_RT::VoiceConnectionData &)>::operator()(uint64_t a1, uint64_t a2)
{
  return *(void *)a2 == **(void **)(a1 + 8)
      && *(void *)(a2 + 8) == **(void **)(a1 + 16)
      && *(_DWORD *)(a2 + 16) == **(_DWORD **)(a1 + 24)
      && *(_DWORD *)(a2 + 20) == **(_DWORD **)(a1 + 32)
      && *(_DWORD *)(a2 + 24) == **(_DWORD **)(a1 + 40);
}

void std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_4,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_4>,BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::~__func()
{
}

void *std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_4,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_4>,BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_26D475DE8;
  return result;
}

void std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_4,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_4>,BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D475DE8;
}

BOOL std::__function::__func<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_4,std::allocator<Phase::Controller::DVM_RT::ProcessMessageFromNRT(unsigned long long,Phase::PhaseOSCMessage &,BOOL)::$_4>,BOOL ()(long long,Phase::Controller::DVM_RT::VoiceConnectionData &,void *)>::operator()(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  return *a3 == **(void **)a4 && a3[1] == *(void *)(*(void *)a4 + 8);
}

void *Phase::CalendarQueue<32,256,std::function<void ()(float *,unsigned long)> *>::ScheduleEvent(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)a1;
  if (*(void *)a1)
  {
    long long v3 = (void *)v2[1];
    *(void *)a1 = v3;
    if (v3) {
      void *v3 = 0;
    }
    void *v2 = 0;
    v2[1] = 0;
    v2[2] = a2;
    uint64_t v4 = a1 + 8 * (a2 & 0x1F);
    uint64_t v7 = *(void **)(v4 + 8);
    int v6 = (void *)(v4 + 8);
    uint64_t v5 = v7;
    if (v7)
    {
      if (v5[2] <= a2)
      {
        while (1)
        {
          uint64_t v9 = v5;
          uint64_t v5 = (void *)v5[1];
          if (!v5) {
            break;
          }
          if (v5[2] > a2)
          {
            void *v5 = v2;
            void *v2 = v9;
            v2[1] = v5;
            v9[1] = v2;
            goto LABEL_8;
          }
        }
        v9[1] = v2;
        void *v2 = v9;
        goto LABEL_8;
      }
      v2[1] = v5;
      void *v5 = v2;
    }
    *int v6 = v2;
LABEL_8:
    ++*(_DWORD *)(a1 + 8456);
    return v2 + 3;
  }
  return 0;
}

void Phase::Controller::VoiceEngineCallback(uint64_t *a1, uint64_t a2, Phase::DspLayer::VoicePool *this, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  int v6 = (unsigned char *)*((void *)this + 6);
  if (!v6) {
    return;
  }
  unsigned int v7 = *v6;
  if (!*v6) {
    return;
  }
  uint64_t v12 = 0xCBF29CE484222325;
  int v13 = v6 + 1;
  uint64_t v14 = 0xCBF29CE484222325;
  do
  {
    uint64_t v14 = 0x100000001B3 * (v14 ^ v7);
    unsigned int v15 = *v13++;
    unsigned int v7 = v15;
  }
  while (v15);
  if (v14 <= (uint64_t)0xD1A51C852B332C80)
  {
    if (v14 != 0x90B234A352A80E9BLL)
    {
      if (v14 != 0xCFE1F9A8E823B67BLL || a5 != 0) {
        return;
      }
      uint64_t v21 = 0;
      *(void *)buf = this;
      *(void *)&uint8_t buf[8] = a4;
      do
        uint64_t v12 = 0x100000001B3 * (v12 ^ (char)buf[v21++]);
      while (v21 != 16);
      uint64_t v18 = a1[(v12 & 0x1F) + 15];
      if (v18)
      {
        while (1)
        {
          uint64_t v22 = *(void *)(v18 + 16);
          if (v22 >= v12) {
            break;
          }
          uint64_t v18 = *(void *)(v18 + 8);
          if (!v18) {
            goto LABEL_63;
          }
        }
        if (v22 == v12)
        {
          int v34 = *(_DWORD *)(v18 + 64);
          if (v34 < 2)
          {
            if (v34 != 1) {
              return;
            }
LABEL_79:
            *(_DWORD *)(v18 + 64) = 0;
            Phase::DspLayer::VoicePool::SetBuffer(this, a4, 0, *(void **)(a1[2] + 74944));
            Phase::DspLayer::VoicePool::UpdateParameters(this, a4);
            Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long>(a1 + 3, 1, (uint64_t)this, a4);
            return;
          }
LABEL_62:
          *(_DWORD *)(v18 + 64) = v34 - 1;
          return;
        }
      }
LABEL_63:
      __int16 v31 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 80);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return;
      }
      uint64_t v36 = *(void *)(a2 + 16);
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVM_RT_VoiceEngineCallback.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 155;
      __int16 v40 = 2048;
      uint64_t v41 = this;
      __int16 v42 = 2048;
      uint64_t v43 = a4;
      __int16 v44 = 2048;
      uint64_t v45 = v36;
      uint64_t v33 = "%25s:%-5d VoiceEngineCallback: the ResidentSampler (%p):%llu does not exist in DVM_RT.mSamplerMap @ Frame %llu";
LABEL_76:
      _os_log_impl(&dword_221E5E000, v31, OS_LOG_TYPE_ERROR, v33, buf, 0x30u);
      return;
    }
    if (a5) {
      return;
    }
    if (*(int *)a6 <= 0) {
      __assert_rtn("GetPointer", "VoicePoolMessage.hpp", 68, "elemIndex >= 0 && elemIndex < mNumElements");
    }
    uint64_t v28 = *(void *)(a6 + 16);
    if (!v28)
    {
      __int16 v31 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 80);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return;
      }
      uint64_t v32 = *(void *)(a2 + 16);
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVM_RT_VoiceEngineCallback.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 294;
      __int16 v40 = 2048;
      uint64_t v41 = this;
      __int16 v42 = 2048;
      uint64_t v43 = a4;
      __int16 v44 = 2048;
      uint64_t v45 = v32;
      uint64_t v33 = "%25s:%-5d VoiceEngineCallback: the IConvolver (%p):%llu is NULL @ Frame %llu";
      goto LABEL_76;
    }
    int v29 = (*(uint64_t (**)(void))(*(void *)v28 + 40))(*(void *)(a6 + 16));
    int v30 = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 56))(v28) + v29;
    Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long,int>(a1 + 3, (uint64_t)this, a4, v30);
  }
  else
  {
    if (v14 != 0xD1A51C852B332C81)
    {
      if (v14 == 0xE8CBC3A55AEFC3DALL)
      {
        if (a5) {
          return;
        }
        uint64_t v26 = 0;
        *(void *)buf = this;
        *(void *)&uint8_t buf[8] = a4;
        do
          uint64_t v12 = 0x100000001B3 * (v12 ^ (char)buf[v26++]);
        while (v26 != 16);
        uint64_t v18 = a1[(v12 & 0x1F) + 15];
        if (v18)
        {
          while (1)
          {
            uint64_t v27 = *(void *)(v18 + 16);
            if (v27 >= v12) {
              break;
            }
            uint64_t v18 = *(void *)(v18 + 8);
            if (!v18) {
              goto LABEL_74;
            }
          }
          if (v27 == v12)
          {
LABEL_71:
            Phase::Controller::DVM_RT::RenderAndSetNextSamplerBuffer((uint64_t)a1, this, a4, 0, 0, *(void *)(v18 + 32), *(unsigned int (**)(uint64_t, double *, void, uint64_t))(v18 + 24), *(void *)(v18 + 40), *(void **)(v18 + 48));
            Phase::DspLayer::VoicePool::UpdateParameters(this, a4);
            return;
          }
        }
LABEL_74:
        __int16 v31 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 80);
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          return;
        }
        uint64_t v38 = *(void *)(a2 + 16);
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = "DVM_RT_VoiceEngineCallback.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 200;
        __int16 v40 = 2048;
        uint64_t v41 = this;
        __int16 v42 = 2048;
        uint64_t v43 = a4;
        __int16 v44 = 2048;
        uint64_t v45 = v38;
        uint64_t v33 = "%25s:%-5d VoiceEngineCallback: the PullStreamSampler (%p):%llu does not exist in DVM_RT.mSamplerMap @ Frame %llu";
      }
      else
      {
        if (v14 != 0x15687F45806132E7 || a5 != 0) {
          return;
        }
        uint64_t v17 = 0;
        *(void *)buf = this;
        *(void *)&uint8_t buf[8] = a4;
        do
          uint64_t v12 = 0x100000001B3 * (v12 ^ (char)buf[v17++]);
        while (v17 != 16);
        uint64_t v18 = a1[(v12 & 0x1F) + 15];
        if (v18)
        {
          while (1)
          {
            uint64_t v19 = *(void *)(v18 + 16);
            if (v19 >= v12) {
              break;
            }
            uint64_t v18 = *(void *)(v18 + 8);
            if (!v18) {
              goto LABEL_58;
            }
          }
          if (v19 == v12)
          {
            int v34 = *(_DWORD *)(v18 + 64);
            if (v34 < 2)
            {
              if (!v34) {
                return;
              }
              if (v34 != 1) {
                goto LABEL_71;
              }
              goto LABEL_79;
            }
            goto LABEL_62;
          }
        }
LABEL_58:
        __int16 v31 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 80);
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          return;
        }
        uint64_t v35 = *(void *)(a2 + 16);
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = "DVM_RT_VoiceEngineCallback.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 93;
        __int16 v40 = 2048;
        uint64_t v41 = this;
        __int16 v42 = 2048;
        uint64_t v43 = a4;
        __int16 v44 = 2048;
        uint64_t v45 = v35;
        uint64_t v33 = "%25s:%-5d VoiceEngineCallback: the PushStreamSampler (%p):%llu does not exist in DVM_RT.mSamplerMap @ Frame %llu";
      }
      goto LABEL_76;
    }
    if (a5) {
      return;
    }
    uint64_t v23 = 0;
    *(void *)buf = this;
    *(void *)&uint8_t buf[8] = a4;
    do
      uint64_t v12 = 0x100000001B3 * (v12 ^ (char)buf[v23++]);
    while (v23 != 16);
    uint64_t v24 = (void *)a1[(v12 & 0x1F) + 2353];
    if (!v24) {
      goto LABEL_68;
    }
    while (1)
    {
      uint64_t v25 = v24[2];
      if (v25 >= v12) {
        break;
      }
      uint64_t v24 = (void *)v24[1];
      if (!v24) {
        goto LABEL_68;
      }
    }
    if (v25 != v12)
    {
LABEL_68:
      __int16 v31 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 80);
      if (!os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
        return;
      }
      uint64_t v37 = *(void *)(a2 + 16);
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVM_RT_VoiceEngineCallback.cpp";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 245;
      __int16 v40 = 2048;
      uint64_t v41 = this;
      __int16 v42 = 2048;
      uint64_t v43 = a4;
      __int16 v44 = 2048;
      uint64_t v45 = v37;
      uint64_t v33 = "%25s:%-5d VoiceEngineCallback: the Tapper (%p):%llu does not exist in DVM_RT.mTapperMap @ Frame %llu";
      goto LABEL_76;
    }
    if (*(int *)a6 <= 0) {
      __assert_rtn("GetBufferId", "VoicePoolMessage.hpp", 62, "elemIndex >= 0 && elemIndex < mNumElements");
    }
    Phase::DspLayer::VoicePool::GetBuffer((uint64_t)this, a4, *(unsigned int *)(a6 + 16), (uint64_t)buf);
    std::function<void ()(float *,unsigned long)>::operator()(*(void *)(v24[3] + 24), *(uint64_t *)&buf[8], *(int *)(a1[2] + 24));
  }
}

uint64_t std::function<void ()(float *,unsigned long)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a3;
  uint64_t v5 = a2;
  if (!a1) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)a1 + 48))(a1, &v5, &v4);
}

double Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMNRTOSCCommand,Phase::DspLayer::VoicePool *,long long,int>(uint64_t *a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *((int *)a1 + 3);
  if (*((_DWORD *)a1 + 2) - (int)v4 >= 36)
  {
    uint64_t v5 = *a1 + v4;
    *(void *)(v5 + 4) = 10;
    *(void *)(v5 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a2;
    *(void *)(v5 + 24) = a3;
    *(void *)&double result = 6908016;
    *(_DWORD *)(v5 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 6908016;
    *(_DWORD *)(v5 + 32) = a4;
    uint64_t v7 = *a1;
    *(_DWORD *)(v7 + *((int *)a1 + 3)) = 32;
    *(_DWORD *)(v7 + 16) += 36;
    *((_DWORD *)a1 + 3) += 36;
  }
  return result;
}

void std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::resize(char **a1, unint64_t a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  unint64_t v6 = 0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 3);
  unint64_t v7 = a2 - v6;
  if (a2 > v6)
  {
    uint64_t v8 = (uint64_t)(a1 + 2);
    uint64_t v9 = a1[2];
    if (0xAAAAAAAAAAAAAAABLL * ((v9 - v4) >> 3) >= v7)
    {
      uint64_t v32 = &v4[24 * v7];
      uint64_t v33 = 24 * a2 - 24 * v6;
      int v34 = v4 + 8;
      do
      {
        *int v34 = 0;
        v34[1] = 0;
        *(v34 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v34;
        v34 += 3;
        v33 -= 24;
      }
      while (v33);
      a1[1] = v32;
      return;
    }
    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v9 - v5) >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a2) {
      uint64_t v11 = a2;
    }
    if (v10 >= 0x555555555555555) {
      unint64_t v12 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v12 = v11;
    }
    int v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>(v8, v12);
    unsigned int v15 = &v13[24 * v6];
    uint64_t v16 = &v13[24 * a2];
    uint64_t v17 = v15 + 8;
    uint64_t v18 = 24 * a2 - 24 * v6;
    do
    {
      *uint64_t v17 = 0;
      v17[1] = 0;
      *(v17 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v17;
      v17 += 3;
      v18 -= 24;
    }
    while (v18);
    uint64_t v19 = &v13[24 * v14];
    uint64_t v20 = *a1;
    uint64_t v21 = a1[1];
    if (v21 == *a1)
    {
      *a1 = v15;
      a1[1] = v16;
      a1[2] = v19;
      if (!v21) {
        return;
      }
    }
    else
    {
      uint64_t v22 = 0;
      do
      {
        uint64_t v23 = &v15[v22];
        *((void *)v23 - 3) = *(void *)&v21[v22 - 24];
        uint64_t v24 = &v21[v22 - 16];
        uint64_t v25 = *(void *)v24;
        *(void *)&v15[v22 - 16] = *(void *)v24;
        uint64_t v26 = (uint64_t)&v15[v22 - 16];
        uint64_t v27 = *(void *)&v21[v22 - 8];
        *((void *)v23 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v27;
        if (v27)
        {
          *(void *)(v25 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v26;
          *(void *)&v21[v22 - 24] = v24;
          *(void *)uint64_t v24 = 0;
          *(void *)&v21[v22 - 8] = 0;
        }
        else
        {
          *((void *)v23 - 3) = v26;
        }
        v22 -= 24;
      }
      while (&v21[v22] != v20);
      uint64_t v21 = *a1;
      uint64_t v28 = a1[1];
      *a1 = &v15[v22];
      a1[1] = v16;
      a1[2] = v19;
      if (v28 != v21)
      {
        do
        {
          int v29 = v28 - 24;
          std::__tree<Phase::SpatialCategory>::destroy((uint64_t)(v28 - 24), *((void **)v28 - 2));
          uint64_t v28 = v29;
        }
        while (v29 != v21);
      }
      if (!v21) {
        return;
      }
    }
    operator delete(v21);
    return;
  }
  if (a2 < v6)
  {
    int v30 = &v5[24 * a2];
    if (v4 != v30)
    {
      do
      {
        __int16 v31 = v4 - 24;
        std::__tree<Phase::SpatialCategory>::destroy((uint64_t)(v4 - 24), *((void **)v4 - 2));
        uint64_t v4 = v31;
      }
      while (v31 != v30);
    }
    a1[1] = v30;
  }
}

void std::vector<Phase::Controller::DVM::VoiceNode::BusChannelPair>::resize(char **a1, unint64_t a2)
{
  uint64_t v4 = *a1;
  long long v3 = a1[1];
  unint64_t v5 = (v3 - *a1) >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    uint64_t v16 = &v4[8 * a2];
    goto LABEL_20;
  }
  unint64_t v6 = a2 - v5;
  unint64_t v7 = a1[2];
  if (a2 - v5 <= (v7 - v3) >> 3)
  {
    memset_pattern16(a1[1], &unk_2220A5810, 8 * v6);
    uint64_t v16 = &v3[8 * v6];
LABEL_20:
    a1[1] = v16;
    return;
  }
  if (a2 >> 61) {
    std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v8 = v7 - v4;
  uint64_t v9 = v8 >> 2;
  if (v8 >> 2 <= a2) {
    uint64_t v9 = a2;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  uint64_t v11 = (char *)operator new(8 * v10);
  unint64_t v12 = &v11[8 * v5];
  int v13 = &v11[8 * v10];
  memset_pattern16(v12, &unk_2220A5810, 8 * v6);
  uint64_t v14 = &v12[8 * v6];
  if (v3 != v4)
  {
    do
    {
      uint64_t v15 = *((void *)v3 - 1);
      v3 -= 8;
      *((void *)v12 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v15;
      v12 -= 8;
    }
    while (v3 != v4);
    long long v3 = v4;
  }
  *a1 = v12;
  a1[1] = v14;
  a1[2] = v13;
  if (v3)
  {
    operator delete(v3);
  }
}

uint64_t Phase::Controller::DVM::VoicePoolNode::AddVoice(Phase::Controller::DVM::VoicePoolNode *this, unint64_t a2)
{
  unint64_t v6 = a2;
  long long v3 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 4, &v6);
  if (!v3 || (uint64_t result = v3[3]) == 0)
  {
    int v5 = *((_DWORD *)this + 6);
    if (v5)
    {
      if (v5 != 1)
      {
        (*(void (**)(Phase::Controller::DVM::VoicePoolNode *))(*(void *)this + 16))(this);
        operator new();
      }
      std::terminate();
    }
    (*(void (**)(Phase::Controller::DVM::VoicePoolNode *))(*(void *)this + 16))(this);
    operator new();
  }
  return result;
}

void sub_221F152E0(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void Phase::Controller::DVM::VoicePoolNode::RemoveVoice(Phase::Controller::DVM::VoicePoolNode *this, unint64_t a2)
{
}

void Phase::Controller::DVM::ProcedureVoicePoolNode::~ProcedureVoicePoolNode(Phase::Controller::DVM::ProcedureVoicePoolNode *this)
{
  *(void *)this = &unk_26D475ED0;
  uint64_t v2 = (void *)((char *)this + 80);
  if (*((void *)this + 13))
  {
    std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>>>::__deallocate_node(*((void **)this + 12));
    *((void *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
    uint64_t v3 = *((void *)this + 11);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*v2 + 8 * i) = 0;
    }
    *((void *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0;
  }
  std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>>>::~__hash_table((uint64_t)v2);
  *(void *)this = &unk_26D475E30;
  std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>>>::~__hash_table((uint64_t)this + 32);
}

{
  uint64_t vars8;

  Phase::Controller::DVM::ProcedureVoicePoolNode::~ProcedureVoicePoolNode(this);

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Controller::DVM::ProcedureVoicePoolNode::AddVoice(Phase::Controller::DVM::ProcedureVoicePoolNode *this, unint64_t a2)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  uint64_t v4 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                     + 80)));
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    Phase::Controller::DVM::VoicePoolNode::GetDescription((Phase::Controller::DVM::VoicePoolNode *)__p, (uint64_t)this);
    if (v8 >= 0) {
      int v5 = __p;
    }
    else {
      int v5 = (void **)__p[0];
    }
    *(_DWORD *)buf = 136315650;
    unint64_t v10 = "DVMGraph.mm";
    __int16 v11 = 1024;
    int v12 = 175;
    __int16 v13 = 2080;
    uint64_t v14 = v5;
    _os_log_impl(&dword_221E5E000, v4, OS_LOG_TYPE_ERROR, "%25s:%-5d Error: creating a procedure node %s, with default params (unexpected)!", buf, 0x1Cu);
    if (v8 < 0) {
      operator delete(__p[0]);
    }
  }

  return Phase::Controller::DVM::ProcedureVoicePoolNode::AddVoice((uint64_t)this, a2, 64, 0);
}

void sub_221F15564(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *Phase::Controller::DVM::VoicePoolNode::GetDescription(Phase::Controller::DVM::VoicePoolNode *this, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 24))(a2))
  {
    (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
    snprintf(__str, 0x200uLL, "<voice %s [%llu, %p, #%d]>");
  }
  else
  {
    snprintf(__str, 0x200uLL, "<voice %s [%llu, #%d]>");
  }
  return std::string::basic_string[abi:ne180100]<0>(this, __str);
}

uint64_t Phase::Controller::DVM::ProcedureVoicePoolNode::AddVoice(uint64_t a1, unint64_t a2, int a3, uint64_t a4)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  *(void *)buf = a2;
  uint64_t v9 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)(a1 + 32), (unint64_t *)buf);
  if (!v9 || (uint64_t v10 = v9[3]) == 0)
  {
    int8x8_t v11 = *(int8x8_t *)(a1 + 88);
    if (v11)
    {
      uint8x8_t v12 = (uint8x8_t)vcnt_s8(v11);
      v12.i16[0] = vaddlv_u8(v12);
      if (v12.u32[0] > 1uLL)
      {
        unint64_t v13 = a2;
        if (*(void *)&v11 <= a2) {
          unint64_t v13 = a2 % *(void *)&v11;
        }
      }
      else
      {
        unint64_t v13 = (*(void *)&v11 - 1) & a2;
      }
      uint64_t v14 = *(void **)(*(void *)(a1 + 80) + 8 * v13);
      if (v14)
      {
        for (uint64_t i = (void *)*v14; i; uint64_t i = (void *)*i)
        {
          unint64_t v16 = i[1];
          if (v16 == a2)
          {
            if (i[2] == a2)
            {
              if (i[3]) {
                std::terminate();
              }
              break;
            }
          }
          else
          {
            if (v12.u32[0] > 1uLL)
            {
              if (v16 >= *(void *)&v11) {
                v16 %= *(void *)&v11;
              }
            }
            else
            {
              v16 &= *(void *)&v11 - 1;
            }
            if (v16 != v13) {
              break;
            }
          }
        }
      }
    }
    if (a3 <= 1) {
      int v17 = 1;
    }
    else {
      int v17 = a3;
    }
    uint64_t v18 = (Phase::Logger *)Phase::Controller::ProcedureRegistry::CreateProcedureInstance(*(void **)(a1 + 72), *(void *)(a1 + 16), *(void *)(a1 + 8), v17, a4, &v53);
    uint64_t v19 = v53;
    if (v53)
    {
      uint64_t v53 = 0;
      unint64_t v20 = *(void *)(a1 + 88);
      if (v20)
      {
        uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v20);
        v21.i16[0] = vaddlv_u8(v21);
        if (v21.u32[0] > 1uLL)
        {
          unint64_t v4 = a2;
          if (v20 <= a2) {
            unint64_t v4 = a2 % v20;
          }
        }
        else
        {
          unint64_t v4 = (v20 - 1) & a2;
        }
        uint64_t v24 = *(void **)(*(void *)(a1 + 80) + 8 * v4);
        if (v24)
        {
          for (uint64_t j = (void *)*v24; j; uint64_t j = (void *)*j)
          {
            unint64_t v26 = j[1];
            if (v26 == a2)
            {
              if (j[2] == a2)
              {
                (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
                std::terminate();
              }
            }
            else
            {
              if (v21.u32[0] > 1uLL)
              {
                if (v26 >= v20) {
                  v26 %= v20;
                }
              }
              else
              {
                v26 &= v20 - 1;
              }
              if (v26 != v4) {
                break;
              }
            }
          }
        }
      }
      uint64_t v27 = operator new(0x20uLL);
      uint64_t v28 = (void *)(a1 + 96);
      *uint64_t v27 = 0;
      v27[1] = a2;
      v27[2] = a2;
      v27[3] = v19;
      float v29 = (float)(unint64_t)(*(void *)(a1 + 104) + 1);
      float v30 = *(float *)(a1 + 112);
      if (v20 && (float)(v30 * (float)v20) >= v29)
      {
LABEL_91:
        uint64_t v47 = *(void *)(a1 + 80);
        uint64_t v48 = *(void **)(v47 + 8 * v4);
        if (v48)
        {
          *uint64_t v27 = *v48;
        }
        else
        {
          *uint64_t v27 = *v28;
          *uint64_t v28 = v27;
          *(void *)(v47 + 8 * v4) = v28;
          if (!*v27) {
            goto LABEL_100;
          }
          unint64_t v49 = *(void *)(*v27 + 8);
          if ((v20 & (v20 - 1)) != 0)
          {
            if (v49 >= v20) {
              v49 %= v20;
            }
          }
          else
          {
            v49 &= v20 - 1;
          }
          uint64_t v48 = (void *)(*(void *)(a1 + 80) + 8 * v49);
        }
        *uint64_t v48 = v27;
LABEL_100:
        ++*(void *)(a1 + 104);
        operator new();
      }
      BOOL v31 = 1;
      if (v20 >= 3) {
        BOOL v31 = (v20 & (v20 - 1)) != 0;
      }
      unint64_t v32 = v31 | (2 * v20);
      unint64_t v33 = vcvtps_u32_f32(v29 / v30);
      if (v32 <= v33) {
        int8x8_t prime = (int8x8_t)v33;
      }
      else {
        int8x8_t prime = (int8x8_t)v32;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v20 = *(void *)(a1 + 88);
      }
      if (*(void *)&prime > v20) {
        goto LABEL_57;
      }
      if (*(void *)&prime < v20)
      {
        unint64_t v41 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 104) / *(float *)(a1 + 112));
        if (v20 < 3 || (uint8x8_t v42 = (uint8x8_t)vcnt_s8((int8x8_t)v20), v42.i16[0] = vaddlv_u8(v42), v42.u32[0] > 1uLL))
        {
          unint64_t v41 = std::__next_prime(v41);
        }
        else
        {
          uint64_t v43 = 1 << -(char)__clz(v41 - 1);
          if (v41 >= 2) {
            unint64_t v41 = v43;
          }
        }
        if (*(void *)&prime <= v41) {
          int8x8_t prime = (int8x8_t)v41;
        }
        if (*(void *)&prime >= v20)
        {
          unint64_t v20 = *(void *)(a1 + 88);
        }
        else
        {
          if (prime)
          {
LABEL_57:
            if (*(void *)&prime >> 61) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            uint64_t v35 = operator new(8 * *(void *)&prime);
            uint64_t v36 = *(void **)(a1 + 80);
            *(void *)(a1 + 80) = v35;
            if (v36) {
              operator delete(v36);
            }
            uint64_t v37 = 0;
            *(int8x8_t *)(a1 + 88) = prime;
            do
              *(void *)(*(void *)(a1 + 80) + 8 * v37++) = 0;
            while (*(void *)&prime != v37);
            uint64_t v38 = (void *)*v28;
            if (*v28)
            {
              unint64_t v39 = v38[1];
              uint8x8_t v40 = (uint8x8_t)vcnt_s8(prime);
              v40.i16[0] = vaddlv_u8(v40);
              if (v40.u32[0] > 1uLL)
              {
                if (v39 >= *(void *)&prime) {
                  v39 %= *(void *)&prime;
                }
              }
              else
              {
                v39 &= *(void *)&prime - 1;
              }
              *(void *)(*(void *)(a1 + 80) + 8 * v39) = v28;
              __int16 v44 = (void *)*v38;
              if (*v38)
              {
                do
                {
                  unint64_t v45 = v44[1];
                  if (v40.u32[0] > 1uLL)
                  {
                    if (v45 >= *(void *)&prime) {
                      v45 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v45 &= *(void *)&prime - 1;
                  }
                  if (v45 != v39)
                  {
                    uint64_t v46 = *(void *)(a1 + 80);
                    if (!*(void *)(v46 + 8 * v45))
                    {
                      *(void *)(v46 + 8 * v45) = v38;
                      goto LABEL_82;
                    }
                    *uint64_t v38 = *v44;
                    void *v44 = **(void **)(*(void *)(a1 + 80) + 8 * v45);
                    **(void **)(*(void *)(a1 + 80) + 8 * v45) = v44;
                    __int16 v44 = v38;
                  }
                  unint64_t v45 = v39;
LABEL_82:
                  uint64_t v38 = v44;
                  __int16 v44 = (void *)*v44;
                  unint64_t v39 = v45;
                }
                while (v44);
              }
            }
            unint64_t v20 = (unint64_t)prime;
            goto LABEL_86;
          }
          uint64_t v52 = *(void **)(a1 + 80);
          *(void *)(a1 + 80) = 0;
          if (v52) {
            operator delete(v52);
          }
          unint64_t v20 = 0;
          *(void *)(a1 + 88) = 0;
        }
      }
LABEL_86:
      if ((v20 & (v20 - 1)) != 0)
      {
        if (v20 <= a2) {
          unint64_t v4 = a2 % v20;
        }
        else {
          unint64_t v4 = a2;
        }
      }
      else
      {
        unint64_t v4 = (v20 - 1) & a2;
      }
      goto LABEL_91;
    }
    uint64_t v22 = **(id **)(Phase::Logger::GetInstance(v18) + 80);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = *(void *)(a1 + 16);
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      __int16 v55 = 1024;
      int v56 = 196;
      __int16 v57 = 2048;
      uint64_t v58 = v23;
      _os_log_impl(&dword_221E5E000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d Error: could not create a procedure instance for Id %llu", buf, 0x1Cu);
    }
    uint64_t v10 = 0;
    uint64_t v50 = v53;
    uint64_t v53 = 0;
    if (v50) {
      (*(void (**)(uint64_t))(*(void *)v50 + 8))(v50);
    }
  }
  return v10;
}

void sub_221F15EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,void *>>>::operator()[abi:ne180100](1, v10);
  if (a10) {
    (*(void (**)(uint64_t))(*(void *)a10 + 8))(a10);
  }
  _Unwind_Resume(a1);
}

void Phase::Controller::DVM::ProcedureVoicePoolNode::RemoveVoice(Phase::Controller::DVM::ProcedureVoicePoolNode *this, unint64_t a2)
{
}

uint64_t Phase::Controller::DVM::VoiceGraph::VoiceGraph(uint64_t a1, uint64_t a2, long long *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(void *)a1 = a2;
  long long v9 = *a3;
  long long v10 = a3[1];
  uint64_t v11 = *((void *)a3 + 4);
  *(_OWORD *)(a1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(void *)(a1 + 40) = v11;
  *(_OWORD *)(a1 + 8) = v9;
  *(_OWORD *)(a1 + 24) = v10;
  *(_DWORD *)(a1 + 48) = a4;
  *(void *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a5;
  *(void *)(a1 + 64) = a6;
  *(void *)(a1 + 72) = a7;
  *(void *)(a1 + 80) = a8;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 1065353216;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_DWORD *)(a1 + 168) = 1065353216;
  *(void *)(a1 + 17std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = &unk_26D4760A0;
  *(void *)(a1 + 200) = a1 + 176;
  *(_DWORD *)(a1 + 208) = 0;
  *(void *)(a1 + 21std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = 0;
  *(void *)(a1 + 25std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 850045863;
  *(void *)(a1 + 344) = 0;
  *(_OWORD *)(a1 + 3std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 29std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_DWORD *)(a1 + 352) = 1065353216;
  *(_OWORD *)(a1 + 360) = 0u;
  *(_OWORD *)(a1 + 37std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_DWORD *)(a1 + 392) = 1065353216;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 41std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_DWORD *)(a1 + 432) = 1065353216;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 45std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_DWORD *)(a1 + 472) = 1065353216;
  *(void *)(a1 + 480) = a1 + 480;
  *(void *)(a1 + 488) = a1 + 480;
  *(void *)(a1 + 5std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
  *(void *)(a1 + 520) = 0;
  *(void *)(a1 + 49std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(void *)(a1 + 504) = a1 + 512;
  *(void *)(a1 + 53std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(void *)(a1 + 544) = 0;
  *(void *)(a1 + 528) = a1 + 536;
  *(_OWORD *)(a1 + 552) = 0u;
  *(_OWORD *)(a1 + 568) = 0u;
  *(_DWORD *)(a1 + 584) = 1065353216;
  Phase::Controller::DVM::ChannelAllocator::ChannelAllocator((Phase::Controller::DVM::ChannelAllocator *)(a1 + 592), *(_DWORD *)(a2 + 124));
  Phase::Controller::DVM::ChannelAllocator::ChannelAllocator((Phase::Controller::DVM::ChannelAllocator *)(a1 + 624), *(_DWORD *)(*(void *)a1 + 116));
  *(void *)(a1 + 65std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a1 + 656;
  *(void *)(a1 + 664) = a1 + 656;
  *(void *)(a1 + 672) = 0;
  *(void *)(a1 + 680) = a1 + 680;
  *(void *)(a1 + 688) = a1 + 680;
  *(void *)(a1 + 768) = 0;
  *(void *)(a1 + 760) = 0;
  *(void *)(a1 + 744) = 0;
  *(_OWORD *)(a1 + 69std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a1 + 7std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
  *(_OWORD *)(a1 + 728) = 0u;
  *(void *)(a1 + 752) = a1 + 760;
  *(void *)(a1 + 784) = 0;
  *(void *)(a1 + 800) = 0;
  *(void *)(a1 + 792) = 0;
  *(void *)(a1 + 77std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a1 + 784;
  if (!*(void *)(a1 + 80)) {
    std::terminate();
  }
  return a1;
}

void sub_221F16170(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object)
{
  Phase::Controller::DVM::ChannelAllocator::~ChannelAllocator(v15);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>>>::~__hash_table(v11 + 416);
  std::__tree<Phase::SpatialCategory>::destroy(v11 + 392, *(void **)(v10 + 536));
  std::__tree<Phase::SpatialCategory>::destroy(v11 + 368, *(void **)(v10 + 512));
  std::__list_imp<std::unique_ptr<Phase::Controller::DVM::VoicePoolNode>>::clear(v14);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>>>::~__hash_table(v11 + 304);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>>>::~__hash_table(v13);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>>>::~__hash_table(v11 + 224);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>>>::~__hash_table(v10 + 320);
  caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::~guarded_lookup_hash_table(v12);
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>>>::~__hash_table(v11);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v10 + 96);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::AddSubmix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  *(void *)uint64_t v50 = a2;
  *(void *)&v50[8] = a3;
  uint64_t v10 = (void **)(a1 + 136);
  uint64_t v11 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(a1 + 136), v50);
  if (v11)
  {
    uint64_t v12 = **(id **)(Phase::Logger::GetInstance(v11) + 80);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v50 = 136315906;
      *(void *)&v50[4] = "DVMGraph.mm";
      *(_WORD *)&v50[12] = 1024;
      *(_DWORD *)&v50[14] = 257;
      __int16 v51 = 2048;
      uint64_t v52 = a1;
      __int16 v53 = 2048;
      uint64_t v54 = a2;
      _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: submixId %llu already exists!", v50, 0x26u);
    }
    return 4;
  }
  if (a4 != 1 || a5 == 1)
  {
    uint64_t v15 = operator new(0xA8uLL);
    void *v15 = 0;
    v15[1] = 0;
    _OWORD v15[2] = a2;
    v15[3] = a3;
    *((_DWORD *)v15 + 10) = 1;
    v15[6] = a2;
    v15[7] = a3;
    *((unsigned char *)v15 + 64) = 0;
    *((_DWORD *)v15 + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
    *((unsigned char *)v15 + 72) = 0;
    *((unsigned char *)v15 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    v15[10] = 0;
    v15[4] = &unk_26D476238;
    v15[11] = a4;
    v15[12] = 0;
    std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::vector(v15 + 13, a5);
    unint64_t v16 = 0xCBF29CE484222325;
    *((_OWORD *)v15 + 8) = 0u;
    *((_OWORD *)v15 + 9) = 0u;
    *((_DWORD *)v15 + 40) = 1065353216;
    uint64_t v17 = 16;
    uint64_t v18 = 0xCBF29CE484222325;
    do
      uint64_t v18 = 0x100000001B3 * (v18 ^ *((char *)v15 + v17++));
    while (v17 != 32);
    v15[1] = v18;
    for (uint64_t i = 16; i != 32; ++i)
      unint64_t v16 = 0x100000001B3 * (v16 ^ *((char *)v15 + i));
    v15[1] = v16;
    unint64_t v20 = *(void *)(a1 + 144);
    if (v20)
    {
      uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v20);
      v21.i16[0] = vaddlv_u8(v21);
      if (v21.u32[0] > 1uLL)
      {
        unint64_t v22 = v16;
        if (v20 <= v16) {
          unint64_t v22 = v16 % v20;
        }
      }
      else
      {
        unint64_t v22 = (v20 - 1) & v16;
      }
      uint64_t v23 = (void *)*((void *)*v10 + v22);
      if (v23)
      {
        for (uint64_t j = (void *)*v23; j; uint64_t j = (void *)*j)
        {
          unint64_t v25 = j[1];
          if (v25 == v16)
          {
            if (j[2] == v15[2] && j[3] == v15[3])
            {
              std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,void *>>>::operator()[abi:ne180100](1, (uint64_t)v15);
              return 0;
            }
          }
          else
          {
            if (v21.u32[0] > 1uLL)
            {
              if (v25 >= v20) {
                v25 %= v20;
              }
            }
            else
            {
              v25 &= v20 - 1;
            }
            if (v25 != v22) {
              break;
            }
          }
        }
      }
    }
    float v27 = (float)(unint64_t)(*(void *)(a1 + 160) + 1);
    float v28 = *(float *)(a1 + 168);
    if (!v20 || (float)(v28 * (float)v20) < v27)
    {
      BOOL v29 = 1;
      if (v20 >= 3) {
        BOOL v29 = (v20 & (v20 - 1)) != 0;
      }
      unint64_t v30 = v29 | (2 * v20);
      unint64_t v31 = vcvtps_u32_f32(v27 / v28);
      if (v30 <= v31) {
        int8x8_t prime = (int8x8_t)v31;
      }
      else {
        int8x8_t prime = (int8x8_t)v30;
      }
      if (*(void *)&prime == 1)
      {
        int8x8_t prime = (int8x8_t)2;
      }
      else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
      {
        int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
        unint64_t v20 = *(void *)(a1 + 144);
      }
      if (*(void *)&prime > v20) {
        goto LABEL_101;
      }
      if (*(void *)&prime >= v20) {
        goto LABEL_75;
      }
      unint64_t v39 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 160) / *(float *)(a1 + 168));
      if (v20 < 3 || (uint8x8_t v40 = (uint8x8_t)vcnt_s8((int8x8_t)v20), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
      {
        unint64_t v39 = std::__next_prime(v39);
      }
      else
      {
        uint64_t v41 = 1 << -(char)__clz(v39 - 1);
        if (v39 >= 2) {
          unint64_t v39 = v41;
        }
      }
      if (*(void *)&prime <= v39) {
        int8x8_t prime = (int8x8_t)v39;
      }
      if (*(void *)&prime >= v20)
      {
        unint64_t v20 = *(void *)(a1 + 144);
        goto LABEL_75;
      }
      if (prime)
      {
LABEL_101:
        if (*(void *)&prime >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        unint64_t v33 = operator new(8 * *(void *)&prime);
        int v34 = *v10;
        void *v10 = v33;
        if (v34) {
          operator delete(v34);
        }
        uint64_t v35 = 0;
        *(int8x8_t *)(a1 + 144) = prime;
        do
          *((void *)*v10 + v35++) = 0;
        while (*(void *)&prime != v35);
        uint64_t v36 = *(void **)(a1 + 152);
        if (v36)
        {
          unint64_t v37 = v36[1];
          uint8x8_t v38 = (uint8x8_t)vcnt_s8(prime);
          v38.i16[0] = vaddlv_u8(v38);
          if (v38.u32[0] > 1uLL)
          {
            if (v37 >= *(void *)&prime) {
              v37 %= *(void *)&prime;
            }
          }
          else
          {
            v37 &= *(void *)&prime - 1;
          }
          *((void *)*v10 + v3std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = a1 + 152;
          uint8x8_t v42 = (void *)*v36;
          if (*v36)
          {
            do
            {
              unint64_t v43 = v42[1];
              if (v38.u32[0] > 1uLL)
              {
                if (v43 >= *(void *)&prime) {
                  v43 %= *(void *)&prime;
                }
              }
              else
              {
                v43 &= *(void *)&prime - 1;
              }
              if (v43 != v37)
              {
                if (!*((void *)*v10 + v43))
                {
                  *((void *)*v10 + v43) = v36;
                  goto LABEL_71;
                }
                void *v36 = *v42;
                void *v42 = **((void **)*v10 + v43);
                **((void **)*v10 + v43) = v42;
                uint8x8_t v42 = v36;
              }
              unint64_t v43 = v37;
LABEL_71:
              uint64_t v36 = v42;
              uint8x8_t v42 = (void *)*v42;
              unint64_t v37 = v43;
            }
            while (v42);
          }
        }
        unint64_t v20 = (unint64_t)prime;
      }
      else
      {
        unint64_t v49 = *v10;
        void *v10 = 0;
        if (v49) {
          operator delete(v49);
        }
        unint64_t v20 = 0;
        *(void *)(a1 + 144) = 0;
      }
    }
LABEL_75:
    unint64_t v44 = v15[1];
    uint8x8_t v45 = (uint8x8_t)vcnt_s8((int8x8_t)v20);
    v45.i16[0] = vaddlv_u8(v45);
    if (v45.u32[0] > 1uLL)
    {
      if (v44 >= v20) {
        v44 %= v20;
      }
    }
    else
    {
      v44 &= v20 - 1;
    }
    uint64_t v46 = *v10;
    uint64_t v47 = (void *)*((void *)*v10 + v44);
    if (v47)
    {
      void *v15 = *v47;
    }
    else
    {
      void *v15 = *(void *)(a1 + 152);
      *(void *)(a1 + 152) = v15;
      v46[v44] = a1 + 152;
      if (!*v15)
      {
LABEL_88:
        uint64_t result = 0;
        ++*(void *)(a1 + 160);
        return result;
      }
      unint64_t v48 = *(void *)(*v15 + 8);
      if (v45.u32[0] > 1uLL)
      {
        if (v48 >= v20) {
          v48 %= v20;
        }
      }
      else
      {
        v48 &= v20 - 1;
      }
      uint64_t v47 = (char *)*v10 + 8 * v48;
    }
    *uint64_t v47 = v15;
    goto LABEL_88;
  }
  uint64_t v14 = **(id **)(Phase::Logger::GetInstance(0) + 80);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t v50 = 136316418;
    *(void *)&v50[4] = "DVMGraph.mm";
    *(_WORD *)&v50[12] = 1024;
    *(_DWORD *)&v50[14] = 263;
    __int16 v51 = 2048;
    uint64_t v52 = a1;
    __int16 v53 = 2048;
    uint64_t v54 = a2;
    __int16 v55 = 2080;
    int v56 = "PHASEMixerTypeSpatial";
    __int16 v57 = 1024;
    int v58 = a5;
    _os_log_impl(&dword_221E5E000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: Spatial submixId %llu, type %s has invalid channel count (%i)!", v50, 0x36u);
  }
  return 1;
}

void sub_221F16860(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void Phase::Controller::DVM::VoiceGraph::InternalRemoveNode(uint64_t a1, int a2, unint64_t a3, unint64_t a4, int a5)
{
  uint64_t v152 = *MEMORY[0x263EF8340];
  uint64_t v10 = (unsigned char *)(a1 + 656);
  *(void *)buf = buf;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0;
  uint64_t v11 = *(void *)(a1 + 664);
  if (v11 != a1 + 656)
  {
    uint64_t v12 = 0;
    do
    {
      if (*(_DWORD *)(v11 + 32) == a2 && *(void *)(v11 + 40) == a3 && *(void *)(v11 + 48) == a4)
      {
        for (uint64_t i = *(void *)(v11 + 8); ; uint64_t i = *(void *)(i + 8))
        {
          if ((unsigned char *)i == v10)
          {
            char v14 = 1;
            uint64_t i = a1 + 656;
            goto LABEL_18;
          }
          if (*(_DWORD *)(i + 32) != a2 || *(void *)(i + 40) != a3 || *(void *)(i + 48) != a4) {
            break;
          }
        }
        char v14 = 0;
LABEL_18:
        if (v11 != i)
        {
          uint64_t v15 = *(void *)i;
          if (buf != v10)
          {
            uint64_t v16 = 1;
            if (v15 != v11)
            {
              uint64_t v17 = v11;
              do
              {
                uint64_t v17 = *(void *)(v17 + 8);
                ++v16;
              }
              while (v17 != v15);
            }
            *(void *)(a1 + 672) -= v16;
            v12 += v16;
            *(void *)&uint8_t buf[16] = v12;
          }
          uint64_t v18 = *(void *)v11;
          *(void *)(v18 + 8) = *(void *)(v15 + 8);
          **(void **)(v15 + 8) = v18;
          uint64_t v19 = *(void *)buf;
          *(void *)(*(void *)buf + 8) = v11;
          *(void *)uint64_t v11 = v19;
          *(void *)buf = v15;
          *(void *)(v15 + 8) = buf;
        }
        if (v14) {
          goto LABEL_14;
        }
      }
      else
      {
        uint64_t i = v11;
      }
      uint64_t i = *(void *)(i + 8);
LABEL_14:
      uint64_t v11 = i;
    }
    while ((unsigned char *)i != v10);
  }
  std::__list_imp<Phase::Controller::DVM::DspNodePlayStateCommand>::clear((uint64_t *)buf);
  uint64_t v144 = 0;
  switch(a2)
  {
    case 0:
      uint64_t v144 = *(void *)(Phase::Controller::DVM::VoiceGraph::GetGenerator((Phase::Controller::DVM::VoiceGraph *)a1, a3, a4)+ 48);
      Phase::Controller::DVM::VoiceGraph::InternalRemoveGenerator(a1, a3, a4);
      goto LABEL_267;
    case 1:
      int v141 = a5;
      v153.mStorage[0] = a3;
      v153.mStorage[1] = a4;
      uint64_t v144 = Phase::Controller::DVM::VoiceGraph::GetSubmix((Phase::Controller::DVM::VoiceGraph *)a1, v153)[6];
      __ns.__rep_ = a3;
      uint64_t v146 = (void *)a4;
      *(void *)buf = a3;
      *(void *)&uint8_t buf[8] = a4;
      uint64_t v143 = (void *)(a1 + 136);
      if (std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(a1 + 136), buf))
      {
        uint64_t v47 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(v143, &__ns);
        Phase::Controller::DVM::Submix::GetGeneratorIds((Phase::Controller::DVM::Submix *)(v47 + 4), (char **)buf);
        uint64_t v50 = *(unint64_t **)buf;
        __int16 v51 = *(unint64_t **)&buf[8];
        BOOL v52 = *(void *)buf != *(void *)&buf[8];
        if (*(void *)buf != *(void *)&buf[8])
        {
          do
          {
            Phase::Controller::DVM::VoiceGraph::InternalRemoveGenerator(a1, *v50, v50[1]);
            v50 += 2;
          }
          while (v50 != v51);
          uint64_t v50 = *(unint64_t **)buf;
        }
        if (v50)
        {
          *(void *)&uint8_t buf[8] = v50;
          operator delete(v50);
        }
        __int16 v53 = (Phase::Controller::DVM::VoiceGraph ***)v47[13];
        uint64_t v54 = (Phase::Controller::DVM::VoiceGraph ***)v47[14];
        while (v53 != v54)
        {
          int v56 = *v53;
          __int16 v55 = v53[1];
          if (*v53 != v55)
          {
            do
              unint64_t v48 = (uint64_t *)Phase::Controller::DVM::VoiceGraph::ScheduleRemoveVoice(*v56++, v49);
            while (v56 != v55);
            BOOL v52 = 1;
          }
          v53 += 9;
        }
        if (v52) {
          *(void *)(a1 + 88) |= 8uLL;
        }
        for (uint64_t j = *(void **)(a1 + 336); j; uint64_t j = (void *)*j)
        {
          unint64_t v48 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(j + 11, &__ns);
          if (v48) {
            std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::erase(j + 11, v48);
          }
        }
        int v68 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v48) + 80);
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v69 = Phase::Controller::DVM::kSubmixTypeStrings[v47[11]];
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 446;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&uint8_t buf[20] = a1;
          __int16 v148 = 2048;
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = __ns.__rep_;
          __int16 v150 = 2080;
          uint64_t v151 = v69;
          _os_log_impl(&dword_221E5E000, v68, OS_LOG_TYPE_DEFAULT, "%25s:%-5d graph@%p: internal removed submixId %llu, type %s!", buf, 0x30u);
        }
        unint64_t v70 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(v143, &__ns);
        a5 = v141;
        if (v70)
        {
          int8x8_t v71 = *(int8x8_t *)(a1 + 144);
          uint64_t v72 = *v70;
          unint64_t v73 = v70[1];
          uint8x8_t v74 = (uint8x8_t)vcnt_s8(v71);
          v74.i16[0] = vaddlv_u8(v74);
          if (v74.u32[0] > 1uLL)
          {
            if (v73 >= *(void *)&v71) {
              v73 %= *(void *)&v71;
            }
          }
          else
          {
            v73 &= *(void *)&v71 - 1;
          }
          double v89 = *(uint64_t **)(*v143 + 8 * v73);
          do
          {
            uint64_t v90 = v89;
            double v89 = (uint64_t *)*v89;
          }
          while (v89 != v70);
          if (v90 == (uint64_t *)(a1 + 152)) {
            goto LABEL_174;
          }
          unint64_t v91 = v90[1];
          if (v74.u32[0] > 1uLL)
          {
            if (v91 >= *(void *)&v71) {
              v91 %= *(void *)&v71;
            }
          }
          else
          {
            v91 &= *(void *)&v71 - 1;
          }
          if (v91 != v73)
          {
LABEL_174:
            if (v72)
            {
              unint64_t v96 = *(void *)(v72 + 8);
              if (v74.u32[0] > 1uLL)
              {
                unint64_t v97 = *(void *)(v72 + 8);
                if (v96 >= *(void *)&v71) {
                  unint64_t v97 = v96 % *(void *)&v71;
                }
              }
              else
              {
                unint64_t v97 = v96 & (*(void *)&v71 - 1);
              }
              if (v97 == v73) {
                goto LABEL_178;
              }
            }
            *(void *)(*v143 + 8 * v73) = 0;
            uint64_t v72 = *v70;
          }
          if (!v72)
          {
LABEL_184:
            *uint64_t v90 = v72;
            uint64_t *v70 = 0;
            --*(void *)(a1 + 160);
            std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,void *>>>::operator()[abi:ne180100](1, (uint64_t)v70);
            goto LABEL_267;
          }
          unint64_t v96 = *(void *)(v72 + 8);
LABEL_178:
          if (v74.u32[0] > 1uLL)
          {
            if (v96 >= *(void *)&v71) {
              v96 %= *(void *)&v71;
            }
          }
          else
          {
            v96 &= *(void *)&v71 - 1;
          }
          if (v96 != v73)
          {
            *(void *)(*v143 + 8 * v9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v90;
            uint64_t v72 = *v70;
          }
          goto LABEL_184;
        }
      }
      else
      {
        uint64_t v77 = **(id **)(Phase::Logger::GetInstance(0) + 80);
        if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 407;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&uint8_t buf[20] = a1;
          __int16 v148 = 2048;
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = a3;
          _os_log_impl(&dword_221E5E000, v77, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: submixId %llu does not exist!", buf, 0x26u);
        }
      }
      goto LABEL_267;
    case 2:
      int v20 = a5;
      uint64_t v144 = Phase::Controller::DVM::VoiceGraph::GetTap((Phase::Controller::DVM::VoiceGraph *)a1, a3)[6];
      float v28 = (void *)(a1 + 320);
      BOOL v29 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 320), a3);
      if (v29)
      {
        unint64_t v30 = v29;
        uint64_t v31 = *((void *)v29 + 8);
        if ((v31 & 0xFF00000000) == 0 || *((void *)v29 + 8) != 0)
        {
          unint64_t v33 = **(id **)(Phase::Logger::GetInstance(v29) + 80);
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            if ((v31 & 0xFF00000000) != 0) {
              int v34 = Phase::Controller::DVM::kPlayStateStrings[(int)v31];
            }
            else {
              int v34 = "none";
            }
            *(_DWORD *)buf = 136316162;
            *(void *)&uint8_t buf[4] = "DVMGraph.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1557;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&uint8_t buf[20] = a1;
            __int16 v148 = 2048;
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = a3;
            __int16 v150 = 2080;
            uint64_t v151 = (void *)v34;
            _os_log_impl(&dword_221E5E000, v33, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: trying to remove tapId %llu that is not stopped (%s)!", buf, 0x30u);
          }
        }
        unint64_t v98 = *((void *)v30 + 10);
        if (v98)
        {
          *(void *)(a1 + 88) |= 8uLL;
          Phase::Controller::DVM::VoiceNode::Disconnect(v98, 1);
          Phase::Controller::DVM::VoiceNode::Disconnect(v98, 0);
        }
        *(void *)buf = a1 + 256;
        uint8_t buf[8] = 1;
        std::mutex::lock((std::mutex *)(a1 + 256));
        uint64_t v99 = atomic_load((unint64_t *)(a1 + 216));
        if (v99)
        {
          unint64_t SlotForKey = caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl::findSlotForKey(v99, a3);
          if (SlotForKey)
          {
            uint64_t v102 = v101;
            atomic_store(0xFFFFFFFFFFFFFFFFLL, (unint64_t *)(v99 + 8 * HIDWORD(SlotForKey) + 16));
            if (v101)
            {
              int v103 = atomic_load((unsigned int *)(a1 + 224));
              if (v103 >= 1)
              {
                do
                {
                  __ns.__rep_ = 50000;
                  std::this_thread::sleep_for (&__ns);
                  int v104 = atomic_load((unsigned int *)(a1 + 224));
                }
                while (v104 > 0);
              }
              if ((unsigned __int16)atomic_load(v102))
              {
                std::unique_lock<std::mutex>::unlock((std::unique_lock<std::mutex> *)buf);
                while ((unsigned __int16)atomic_load(v102))
                {
                  __ns.__rep_ = 500000;
                  std::this_thread::sleep_for (&__ns);
                }
                std::unique_lock<std::mutex>::lock((std::unique_lock<std::mutex> *)buf);
                uint64_t v99 = atomic_load((unint64_t *)(a1 + 216));
              }
              caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::element_t::release(v102);
              int v108 = *(_DWORD *)(a1 + 208) - 1;
              *(_DWORD *)(a1 + 208) = v108;
              if (v99)
              {
                unsigned int v109 = *(_DWORD *)(v99 + 8);
                if (v109 >= 9 && 16 * v108 / v109 <= 2) {
                  caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::rehash((unint64_t *)(a1 + 176), v109 >> 1);
                }
              }
            }
          }
        }
        caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::emptyReleasePool(a1 + 176);
        if (buf[8]) {
          std::mutex::unlock(*(std::mutex **)buf);
        }
        int v110 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 320), a3);
        a5 = v20;
        if (v110)
        {
          int8x8_t v111 = *(int8x8_t *)(a1 + 328);
          uint64_t v112 = *v110;
          unint64_t v113 = v110[1];
          uint8x8_t v114 = (uint8x8_t)vcnt_s8(v111);
          v114.i16[0] = vaddlv_u8(v114);
          if (v114.u32[0] > 1uLL)
          {
            if (v113 >= *(void *)&v111) {
              v113 %= *(void *)&v111;
            }
          }
          else
          {
            v113 &= *(void *)&v111 - 1;
          }
          uint64_t v115 = *(uint64_t **)(*v28 + 8 * v113);
          do
          {
            int v116 = v115;
            uint64_t v115 = (uint64_t *)*v115;
          }
          while (v115 != v110);
          if (v116 == (uint64_t *)(a1 + 336)) {
            goto LABEL_222;
          }
          unint64_t v117 = v116[1];
          if (v114.u32[0] > 1uLL)
          {
            if (v117 >= *(void *)&v111) {
              v117 %= *(void *)&v111;
            }
          }
          else
          {
            v117 &= *(void *)&v111 - 1;
          }
          if (v117 != v113)
          {
LABEL_222:
            if (v112)
            {
              unint64_t v118 = *(void *)(v112 + 8);
              if (v114.u32[0] > 1uLL)
              {
                unint64_t v119 = *(void *)(v112 + 8);
                if (v118 >= *(void *)&v111) {
                  unint64_t v119 = v118 % *(void *)&v111;
                }
              }
              else
              {
                unint64_t v119 = v118 & (*(void *)&v111 - 1);
              }
              if (v119 == v113) {
                goto LABEL_226;
              }
            }
            *(void *)(*v28 + 8 * v1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0;
            uint64_t v112 = *v110;
          }
          if (!v112)
          {
LABEL_232:
            *int v116 = v112;
            *int v110 = 0;
            --*(void *)(a1 + 344);
            std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,void *>>>::operator()[abi:ne180100](1, v110);
            goto LABEL_267;
          }
          unint64_t v118 = *(void *)(v112 + 8);
LABEL_226:
          if (v114.u32[0] > 1uLL)
          {
            if (v118 >= *(void *)&v111) {
              v118 %= *(void *)&v111;
            }
          }
          else
          {
            v118 &= *(void *)&v111 - 1;
          }
          if (v118 != v113)
          {
            *(void *)(*v28 + 8 * v118) = v116;
            uint64_t v112 = *v110;
          }
          goto LABEL_232;
        }
LABEL_267:
        char v76 = 0;
      }
      else
      {
        int v75 = **(id **)(Phase::Logger::GetInstance(0) + 80);
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315906;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1548;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&uint8_t buf[20] = a1;
          __int16 v148 = 2048;
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = a3;
          _os_log_impl(&dword_221E5E000, v75, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: TapId %llu does not exists!", buf, 0x26u);
        }
        char v76 = 3;
LABEL_94:
        a5 = v20;
      }
LABEL_268:
      if (a5) {
        char v76 = a5;
      }
      uint64_t v132 = *(void *)(a1 + 72);
      if (v132)
      {
        switch(a2)
        {
          case 3:
            unsigned int v137 = v76;
            uint64_t v138 = std::generic_category();
            (*(void (**)(uint64_t, unint64_t, void, const std::error_category *))(*(void *)v132 + 32))(v132, a3, v137, v138);
            break;
          case 1:
            unsigned int v135 = v76;
            int v136 = std::generic_category();
            (*(void (**)(uint64_t, unint64_t, unint64_t, void, const std::error_category *))(*(void *)v132 + 24))(v132, a3, a4, v135, v136);
            break;
          case 0:
            unsigned int v133 = v76;
            uint64_t v134 = std::generic_category();
            (*(void (**)(uint64_t, unint64_t, unint64_t, uint64_t *, void, const std::error_category *))(*(void *)v132 + 16))(v132, a3, a4, &v144, v133, v134);
            break;
        }
      }
      return;
    case 3:
      int v35 = a5;
      uint64_t v144 = Phase::Controller::DVM::VoiceGraph::GetRenderer((Phase::Controller::DVM::VoiceGraph *)a1, a3)[6];
      *(void *)buf = a3;
      uint64_t v36 = (void *)(a1 + 360);
      if (!std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)(a1 + 360), (unint64_t *)buf))
      {
        char v76 = 0;
        goto LABEL_268;
      }
      unint64_t v37 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 360), a3);
      (*(void (**)(unsigned char *__return_ptr))(v37[3] + 40))(buf);
      uint8x8_t v40 = *(Phase::Controller::DVM::VoiceGraph ***)buf;
      unint64_t v39 = *(Phase::Controller::DVM::VoiceGraph ***)&buf[8];
      if (*(void *)buf != *(void *)&buf[8])
      {
        do
        {
          *(void *)(a1 + 88) |= 8uLL;
          Phase::Controller::DVM::VoiceGraph::ScheduleRemoveVoice(*v40++, v38);
        }
        while (v40 != v39);
        uint8x8_t v40 = *(Phase::Controller::DVM::VoiceGraph ***)buf;
      }
      a5 = v35;
      if (v40)
      {
        *(void *)&uint8_t buf[8] = v40;
        operator delete(v40);
      }
      uint64_t v41 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 360), a3);
      if (!v41) {
        goto LABEL_267;
      }
      uint8x8_t v42 = v41;
      int8x8_t v43 = *(int8x8_t *)(a1 + 368);
      uint64_t v44 = *v41;
      unint64_t v45 = v41[1];
      uint8x8_t v46 = (uint8x8_t)vcnt_s8(v43);
      v46.i16[0] = vaddlv_u8(v46);
      if (v46.u32[0] > 1uLL)
      {
        if (v45 >= *(void *)&v43) {
          v45 %= *(void *)&v43;
        }
      }
      else
      {
        v45 &= *(void *)&v43 - 1;
      }
      uint64_t v83 = *(uint64_t **)(*v36 + 8 * v45);
      do
      {
        uint64_t v84 = v83;
        uint64_t v83 = (uint64_t *)*v83;
      }
      while (v83 != v41);
      if (v84 != (uint64_t *)(a1 + 376))
      {
        unint64_t v85 = v84[1];
        if (v46.u32[0] > 1uLL)
        {
          if (v85 >= *(void *)&v43) {
            v85 %= *(void *)&v43;
          }
        }
        else
        {
          v85 &= *(void *)&v43 - 1;
        }
        if (v85 == v45) {
          goto LABEL_147;
        }
      }
      if (v44)
      {
        unint64_t v92 = *(void *)(v44 + 8);
        if (v46.u32[0] > 1uLL)
        {
          unint64_t v93 = *(void *)(v44 + 8);
          if (v92 >= *(void *)&v43) {
            unint64_t v93 = v92 % *(void *)&v43;
          }
        }
        else
        {
          unint64_t v93 = v92 & (*(void *)&v43 - 1);
        }
        if (v93 == v45) {
          goto LABEL_149;
        }
      }
      *(void *)(*v36 + 8 * v45) = 0;
      uint64_t v44 = *v41;
LABEL_147:
      if (v44)
      {
        unint64_t v92 = *(void *)(v44 + 8);
LABEL_149:
        if (v46.u32[0] > 1uLL)
        {
          if (v92 >= *(void *)&v43) {
            v92 %= *(void *)&v43;
          }
        }
        else
        {
          v92 &= *(void *)&v43 - 1;
        }
        if (v92 != v45)
        {
          *(void *)(*v36 + 8 * v92) = v84;
          uint64_t v44 = *v41;
        }
      }
      *uint64_t v84 = v44;
      uint64_t *v41 = 0;
      --*(void *)(a1 + 384);
      v41[3] = (uint64_t)&unk_26D476128;
      *(void *)buf = v41 + 11;
      std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      operator delete(v42);
      goto LABEL_267;
    case 4:
      int v20 = a5;
      uint64_t v144 = Phase::Controller::DVM::VoiceGraph::GetMaster((Phase::Controller::DVM::VoiceGraph *)a1, a3)[6];
      *(void *)buf = a3;
      uint8x8_t v21 = (void *)(a1 + 400);
      if (!std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)(a1 + 400), (unint64_t *)buf))
      {
        char v76 = 0;
        goto LABEL_94;
      }
      unint64_t v22 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 400), a3);
      uint64_t v24 = v22;
      uint64_t v25 = *((void *)v22 + 8);
      if ((v25 & 0xFF00000000) == 0 || *((void *)v22 + 8))
      {
        unint64_t v26 = **(id **)(Phase::Logger::GetInstance(v22) + 80);
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          if ((v25 & 0xFF00000000) != 0) {
            float v27 = Phase::Controller::DVM::kPlayStateStrings[(int)v25];
          }
          else {
            float v27 = "none";
          }
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 2139;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&uint8_t buf[20] = a1;
          __int16 v148 = 2048;
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = a3;
          __int16 v150 = 2080;
          uint64_t v151 = (void *)v27;
          _os_log_impl(&dword_221E5E000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: trying to remove masterId %llu that is not stopped (%s)!", buf, 0x30u);
        }
      }
      uint64_t v120 = (Phase::Controller::DVM::VoiceGraph **)*((void *)v24 + 10);
      int v121 = (Phase::Controller::DVM::VoiceGraph **)*((void *)v24 + 11);
      while (v120 != v121)
      {
        *(void *)(a1 + 88) |= 8uLL;
        Phase::Controller::DVM::VoiceGraph::ScheduleRemoveVoice(*v120++, v23);
      }
      __n128 v122 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 400), a3);
      a5 = v20;
      if (!v122) {
        goto LABEL_267;
      }
      int8x8_t v123 = *(int8x8_t *)(a1 + 408);
      uint64_t v124 = *v122;
      unint64_t v125 = v122[1];
      uint8x8_t v126 = (uint8x8_t)vcnt_s8(v123);
      v126.i16[0] = vaddlv_u8(v126);
      if (v126.u32[0] > 1uLL)
      {
        if (v125 >= *(void *)&v123) {
          v125 %= *(void *)&v123;
        }
      }
      else
      {
        v125 &= *(void *)&v123 - 1;
      }
      uint64_t v127 = *(uint64_t **)(*v21 + 8 * v125);
      do
      {
        uint64_t v128 = v127;
        uint64_t v127 = (uint64_t *)*v127;
      }
      while (v127 != v122);
      if (v128 != (uint64_t *)(a1 + 416))
      {
        unint64_t v129 = v128[1];
        if (v126.u32[0] > 1uLL)
        {
          if (v129 >= *(void *)&v123) {
            v129 %= *(void *)&v123;
          }
        }
        else
        {
          v129 &= *(void *)&v123 - 1;
        }
        if (v129 == v125) {
          goto LABEL_258;
        }
      }
      if (v124)
      {
        unint64_t v130 = *(void *)(v124 + 8);
        if (v126.u32[0] > 1uLL)
        {
          unint64_t v131 = *(void *)(v124 + 8);
          if (v130 >= *(void *)&v123) {
            unint64_t v131 = v130 % *(void *)&v123;
          }
        }
        else
        {
          unint64_t v131 = v130 & (*(void *)&v123 - 1);
        }
        if (v131 == v125) {
          goto LABEL_260;
        }
      }
      *(void *)(*v21 + 8 * v125) = 0;
      uint64_t v124 = *v122;
LABEL_258:
      if (v124)
      {
        unint64_t v130 = *(void *)(v124 + 8);
LABEL_260:
        if (v126.u32[0] > 1uLL)
        {
          if (v130 >= *(void *)&v123) {
            v130 %= *(void *)&v123;
          }
        }
        else
        {
          v130 &= *(void *)&v123 - 1;
        }
        if (v130 != v125)
        {
          *(void *)(*v21 + 8 * v130) = v128;
          uint64_t v124 = *v122;
        }
      }
      *uint64_t v128 = v124;
      uint64_t *v122 = 0;
      --*(void *)(a1 + 424);
      std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,void *>>>::operator()[abi:ne180100](1, v122);
      goto LABEL_267;
    case 5:
      if (!std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 440), a3))goto LABEL_267; {
      int v142 = a5;
      }
      uint64_t v140 = (void *)(a1 + 440);
      __int16 v57 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 440), a3);
      if (!v57) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      (*(void (**)(std::chrono::nanoseconds *__return_ptr))(v57[3] + 40))(&__ns);
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v59 = __ns.__rep_;
      uint64_t v60 = v146;
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v139 = __ns.__rep_;
      if ((void *)__ns.__rep_ == v146)
      {
        int v66 = (void *)__ns.__rep_;
      }
      else
      {
        do
        {
          uint64_t v61 = *(Phase::Logger **)v59;
          if ((*(void *)(*(void *)v59 + 192) & 0xFF00000000) == 0
            || *(void *)(*(void *)v59 + 192) != 0)
          {
            double v63 = **(id **)(Phase::Logger::GetInstance(v61) + 80);
            if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
            {
              uint64_t v64 = *(void *)(*(void *)v59 + 192);
              if ((v64 & 0xFF00000000) != 0) {
                uint64_t v65 = Phase::Controller::DVM::kPlayStateStrings[(int)v64];
              }
              else {
                uint64_t v65 = "none";
              }
              *(_DWORD *)buf = 136316162;
              *(void *)&uint8_t buf[4] = "DVMGraph.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 384;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&uint8_t buf[20] = a1;
              __int16 v148 = 2048;
              std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = a3;
              __int16 v150 = 2080;
              uint64_t v151 = (void *)v65;
              _os_log_impl(&dword_221E5E000, v63, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: trying to remove sinkId %llu that is not stopped (%s)!", buf, 0x30u);
            }
            uint64_t v61 = *(Phase::Logger **)v59;
          }
          Phase::Controller::DVM::VoiceGraph::ScheduleRemoveVoice(v61, v58);
          v59 += 8;
        }
        while ((void *)v59 != v60);
        int v66 = (void *)__ns.__rep_;
      }
      if (v66)
      {
        uint64_t v146 = v66;
        operator delete(v66);
      }
      double v78 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v140, a3);
      if (!v78) {
        goto LABEL_169;
      }
      int8x8_t v79 = *(int8x8_t *)(a1 + 448);
      uint64_t v80 = *v78;
      unint64_t v81 = v78[1];
      uint8x8_t v82 = (uint8x8_t)vcnt_s8(v79);
      v82.i16[0] = vaddlv_u8(v82);
      if (v82.u32[0] > 1uLL)
      {
        if (v81 >= *(void *)&v79) {
          v81 %= *(void *)&v79;
        }
      }
      else
      {
        v81 &= *(void *)&v79 - 1;
      }
      int v86 = *(uint64_t **)(*v140 + 8 * v81);
      do
      {
        double v87 = v86;
        int v86 = (uint64_t *)*v86;
      }
      while (v86 != v78);
      if (v87 != (uint64_t *)(a1 + 456))
      {
        unint64_t v88 = v87[1];
        if (v82.u32[0] > 1uLL)
        {
          if (v88 >= *(void *)&v79) {
            v88 %= *(void *)&v79;
          }
        }
        else
        {
          v88 &= *(void *)&v79 - 1;
        }
        if (v88 == v81) {
          goto LABEL_160;
        }
      }
      if (v80)
      {
        unint64_t v94 = *(void *)(v80 + 8);
        if (v82.u32[0] > 1uLL)
        {
          unint64_t v95 = *(void *)(v80 + 8);
          if (v94 >= *(void *)&v79) {
            unint64_t v95 = v94 % *(void *)&v79;
          }
        }
        else
        {
          unint64_t v95 = v94 & (*(void *)&v79 - 1);
        }
        if (v95 == v81) {
          goto LABEL_162;
        }
      }
      *(void *)(*v140 + 8 * v8Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
      uint64_t v80 = *v78;
LABEL_160:
      if (v80)
      {
        unint64_t v94 = *(void *)(v80 + 8);
LABEL_162:
        if (v82.u32[0] > 1uLL)
        {
          if (v94 >= *(void *)&v79) {
            v94 %= *(void *)&v79;
          }
        }
        else
        {
          v94 &= *(void *)&v79 - 1;
        }
        if (v94 != v81)
        {
          *(void *)(*v140 + 8 * v94) = v87;
          uint64_t v80 = *v78;
        }
      }
      *double v87 = v80;
      uint64_t *v78 = 0;
      --*(void *)(a1 + 464);
      std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,void *>>>::operator()[abi:ne180100](1, v78);
LABEL_169:
      char v76 = 0;
      if ((void *)v139 != v60) {
        *(void *)(a1 + 88) |= 8uLL;
      }
      a5 = v142;
      goto LABEL_268;
    default:
      std::terminate();
      return;
  }
}

void sub_221F17AB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, std::mutex *a19, uint64_t a20)
{
  if ((_BYTE)a20) {
    std::mutex::unlock(a19);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::DVM::VoiceGraph::GetGenerator(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3)
{
  unint64_t v9 = a2;
  unint64_t v10 = a3;
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 12, &v9))std::terminate(); {
  v11.mStorage[0] = a2;
  }
  v11.mStorage[1] = a3;
  SubmixForGenerator = Phase::Controller::DVM::VoiceGraph::GetSubmixForGenerator(a1, v11);
  unint64_t v9 = a2;
  unint64_t v10 = a3;
  unint64_t v7 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(SubmixForGenerator + 12, &v9);
  if (!v7 || (uint64_t result = v7[4]) == 0) {
    __assert_rtn("GetGenerator", "DVMGraph.hpp", 329, "pGenerator != nullptr");
  }
  return result;
}

void Phase::Controller::DVM::VoiceGraph::InternalRemoveGenerator(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  unint64_t v4 = a2;
  uint64_t v40 = *MEMORY[0x263EF8340];
  unint64_t v33 = a2;
  unint64_t v34 = a3;
  *(void *)buf = a2;
  *(void *)&uint8_t buf[8] = a3;
  uint64_t v6 = (void *)(a1 + 96);
  if (std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(a1 + 96), buf))
  {
    uint64_t Generator = Phase::Controller::DVM::VoiceGraph::GetGenerator((Phase::Controller::DVM::VoiceGraph *)a1, v4, v3);
    (*(void (**)(unsigned char *__return_ptr))(*(void *)Generator + 40))(buf);
    if (*(void *)buf == *(void *)&buf[8])
    {
      unint64_t v26 = *(uint64_t **)(a1 + 752);
      if (v26 != (uint64_t *)(a1 + 760))
      {
        do
        {
          if (v26[6] == v33 && v26[7] == v34)
          {
            float v27 = std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>>>::__remove_node_pointer((uint64_t **)(a1 + 752), v26);
            operator delete(v26);
          }
          else
          {
            float v28 = (uint64_t *)v26[1];
            if (v28)
            {
              do
              {
                float v27 = v28;
                float v28 = (uint64_t *)*v28;
              }
              while (v28);
            }
            else
            {
              do
              {
                float v27 = (uint64_t *)v26[2];
                BOOL v24 = *v27 == (void)v26;
                unint64_t v26 = v27;
              }
              while (!v24);
            }
          }
          unint64_t v26 = v27;
        }
        while (v27 != (uint64_t *)(a1 + 760));
        unint64_t v4 = v33;
        unint64_t v3 = v34;
      }
    }
    else
    {
      (*(void (**)(unint64_t **__return_ptr, uint64_t))(*(void *)Generator + 40))(&v31, Generator);
      char v8 = v31;
      unint64_t v9 = v32;
      if (v31 != v32)
      {
        unint64_t v10 = (uint64_t **)(a1 + 784);
        while (1)
        {
          unint64_t v11 = *v8;
          if (*(_DWORD *)(*v8 + 188)) {
            std::terminate();
          }
          *(void *)(a1 + 88) |= 8uLL;
          Phase::Controller::DVM::VoiceNode::Disconnect(v11, 1);
          Phase::Controller::DVM::VoiceNode::Disconnect(v11, 0);
          if (*(_DWORD *)(*v8 + 24)) {
            goto LABEL_7;
          }
          if (!(*(unsigned int (**)(uint64_t))(*(void *)Generator + 56))(Generator)) {
            break;
          }
          uint64_t v12 = (*(uint64_t (**)(void))(*(void *)*v8 + 16))();
          unint64_t v13 = *(void *)(*v8 + 16);
          v30[0] = v12;
          v30[1] = v13;
          char v14 = std::__tree<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<std::pair<unsigned long long,long long>,std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::less<std::pair<unsigned long long,long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>>>::find<std::pair<unsigned long long,long long>>(a1 + 752, v30);
          if ((uint64_t *)(a1 + 760) != v14)
          {
            std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>>>::__remove_node_pointer((uint64_t **)(a1 + 752), v14);
LABEL_12:
            operator delete(v14);
          }
LABEL_7:
          if (++v8 == v9)
          {
            char v8 = v31;
            goto LABEL_38;
          }
        }
        if (!(*(unsigned int (**)(void))(*(void *)*v8 + 48))()) {
          goto LABEL_7;
        }
        unint64_t v15 = (*(uint64_t (**)(void))(*(void *)*v8 + 16))();
        uint64_t v16 = *v10;
        if (!*v10) {
          goto LABEL_7;
        }
        uint64_t v17 = *(void *)(*v8 + 16);
        char v14 = (uint64_t *)(a1 + 784);
        uint64_t v18 = *v10;
        do
        {
          unint64_t v19 = v18[4];
          if (v19 >= v15)
          {
            if (v19 <= v15)
            {
              if (v18[5] < v17) {
                ++v18;
              }
              else {
                char v14 = v18;
              }
            }
            else
            {
              char v14 = v18;
            }
          }
          else
          {
            ++v18;
          }
          uint64_t v18 = (uint64_t *)*v18;
        }
        while (v18);
        if (v14 == (uint64_t *)v10) {
          goto LABEL_7;
        }
        unint64_t v20 = v14[4];
        if (v20 > v15 || v20 >= v15 && v14[5] > v17) {
          goto LABEL_7;
        }
        uint8x8_t v21 = (uint64_t *)v14[1];
        unint64_t v22 = v14;
        if (v21)
        {
          do
          {
            uint64_t v23 = v21;
            uint8x8_t v21 = (uint64_t *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            uint64_t v23 = (uint64_t *)v22[2];
            BOOL v24 = *v23 == (void)v22;
            unint64_t v22 = v23;
          }
          while (!v24);
        }
        if (*(uint64_t **)(a1 + 776) == v14) {
          *(void *)(a1 + 77std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v23;
        }
        --*(void *)(a1 + 792);
        std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v16, v14);
        goto LABEL_12;
      }
LABEL_38:
      if (v8)
      {
        unint64_t v32 = v8;
        operator delete(v8);
      }
    }
    v41.mStorage[0] = v4;
    v41.mStorage[1] = v3;
    SubmixForuint64_t Generator = Phase::Controller::DVM::VoiceGraph::GetSubmixForGenerator((Phase::Controller::DVM::VoiceGraph *)a1, v41);
    uint64_t v31 = (unint64_t *)v4;
    unint64_t v32 = (unint64_t *)v3;
    std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::__erase_unique<Phase::UniqueObjectId>(SubmixForGenerator + 12, &v31);
    std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::UniqueObjectId>>>::__erase_unique<Phase::UniqueObjectId>(v6, &v33);
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
  }
  else
  {
    uint64_t v25 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 775;
      __int16 v36 = 2048;
      uint64_t v37 = a1;
      __int16 v38 = 2048;
      unint64_t v39 = v4;
      _os_log_impl(&dword_221E5E000, v25, OS_LOG_TYPE_DEFAULT, "%25s:%-5d graph@%p: generatorId %llu does not exist!", buf, 0x26u);
    }
  }
}

void sub_221F18068(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::Controller::DVM::VoiceGraph::GetSubmix(Phase::Controller::DVM::VoiceGraph *this, UniqueObjectId a2)
{
  UniqueObjectId v4 = a2;
  UniqueObjectId v5 = a2;
  uint64_t v2 = (void *)((char *)this + 136);
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)this + 17, &v5))std::terminate(); {
  return std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(v2, &v4)+ 4;
  }
}

void *Phase::Controller::DVM::VoiceGraph::GetRenderer(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2)
{
  unint64_t v5 = a2;
  unint64_t v3 = (void *)((char *)this + 360);
  if (!std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 45, &v5))__assert_rtn("GetRenderer", "DVMGraph.hpp", 349, "RendererIdExists(Id)"); {
  return std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v3, a2)+ 3;
  }
}

void *Phase::Controller::DVM::VoiceGraph::GetTap(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2)
{
  unint64_t v3 = (void *)((char *)this + 320);
  if (!std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)this + 40, a2))__assert_rtn("GetTap", "DVMGraph.hpp", 361, "TapIdExists(Id)"); {
  return std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v3, a2)+ 3;
  }
}

void *Phase::Controller::DVM::VoiceGraph::GetMaster(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2)
{
  unint64_t v5 = a2;
  unint64_t v3 = (void *)((char *)this + 400);
  if (!std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 50, &v5))__assert_rtn("GetMaster", "DVMGraph.hpp", 355, "MasterIdExists(Id)"); {
  return std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v3, a2)+ 3;
  }
}

uint64_t Phase::Controller::DVM::VoiceGraph::ScheduleRemoveVoice(Phase::Controller::DVM::VoiceGraph *this, Phase::Controller::DVM::VoiceNode *a2)
{
  if (!this) {
    std::terminate();
  }
  Phase::Controller::DVM::VoiceNode::Disconnect((unint64_t)this, 1);

  return Phase::Controller::DVM::VoiceNode::Disconnect((unint64_t)this, 0);
}

void *Phase::Controller::DVM::VoiceGraph::RemoveSubmix(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3)
{
  v7[0] = a2;
  v7[1] = a3;
  uint64_t result = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 17, v7);
  if (result) {
    return (void *)Phase::Controller::DVM::VoiceGraph::SetSubmixPlayState(a1, a2, a3, 0);
  }
  return result;
}

uint64_t Phase::Controller::DVM::VoiceGraph::SetSubmixPlayState(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  *(void *)unint64_t v15 = a2;
  *(void *)&v15[8] = a3;
  if (std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 17, v15))
  {
    v23.mStorage[0] = a2;
    v23.mStorage[1] = a3;
    uint64_t Submix = Phase::Controller::DVM::VoiceGraph::GetSubmix(a1, v23);
    int v9 = Phase::Controller::DVM::VoiceGraph::PreprocessPlayStateChange((uint64_t)a1, (uint64_t)Submix, a4);
    if (v9 != 8)
    {
      if (v9 == 4) {
        return 1;
      }
      *((void *)a1 + 11) |= 8uLL;
      if (v9 == 2) {
        float v13 = 0.001;
      }
      else {
        float v13 = 0.0;
      }
      for (uint64_t i = (void *)Submix[14]; i; uint64_t i = (void *)*i)
        Phase::Controller::DVM::VoiceGraph::SetGeneratorPlayState(a1, i[2], i[3], a4);
      Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(a1, (uint64_t)Submix, a4, v13);
    }
    return 0;
  }
  else
  {
    unint64_t v11 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      uint64_t v12 = Phase::Controller::DVM::kPlayStateStrings[a4];
      *(_DWORD *)unint64_t v15 = 136316162;
      *(void *)&v15[4] = "DVMGraph.mm";
      *(_WORD *)&v15[12] = 1024;
      *(_DWORD *)&v15[14] = 2495;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 2080;
      unint64_t v19 = v12;
      __int16 v20 = 2048;
      unint64_t v21 = a2;
      _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: state change request %s, submixId %llu does not exist!", v15, 0x30u);
    }
    return 3;
  }
}

uint64_t Phase::Controller::DVM::VoiceGraph::ConfigureSubmix(void *a1, unint64_t a2, unint64_t a3, int a4, void *a5)
{
  unint64_t v7 = a3;
  unint64_t v8 = a2;
  uint64_t v104 = *MEMORY[0x263EF8340];
  unint64_t v95 = a2;
  unint64_t v96 = a3;
  *(void *)buf = a2;
  *(void *)&uint8_t buf[8] = a3;
  unint64_t v10 = a1 + 17;
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>(a1 + 17, buf))
  {
    __int16 v16 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 469;
      __int16 v98 = 2048;
      uint64_t v99 = a1;
      __int16 v100 = 2048;
      unint64_t v101 = v8;
      _os_log_impl(&dword_221E5E000, v16, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: submixId %llu does not exist!", buf, 0x26u);
    }
    return 3;
  }
  unint64_t v11 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(v10, &v95);
  uint64_t v94 = v11[9];
  PlayStateTransitionStatus = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetPlayStateTransitionStatus((uint64_t)a1, (int *)&v94, a4);
  if (PlayStateTransitionStatus == 4 || a4 == 3 || !a4)
  {
    float v13 = **(id **)(Phase::Logger::GetInstance(PlayStateTransitionStatus) + 80);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      char v14 = Phase::Controller::DVM::kPlayStateStrings[a4];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 482;
      __int16 v98 = 2048;
      uint64_t v99 = a1;
      __int16 v100 = 2048;
      unint64_t v101 = v8;
      __int16 v102 = 2080;
      unint64_t v103 = (unint64_t)v14;
      _os_log_impl(&dword_221E5E000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: can't configure submixId %llu with invalid play state %s!", buf, 0x30u);
    }
    return 7;
  }
  uint64_t v17 = a5[1];
  if (*a5 != v17)
  {
    uint64_t v18 = *a5;
    while (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(v18 + 16) - *(void *)(v18 + 8)) >> 3) == 0x8E38E38E38E38E39 * ((uint64_t)(v11[14] - v11[13]) >> 3))
    {
      v18 += 32;
      if (v18 == v17) {
        goto LABEL_15;
      }
    }
    BOOL v29 = **(id **)(Phase::Logger::GetInstance(PlayStateTransitionStatus) + 80);
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      int v35 = Phase::Controller::DVM::kSubmixTypeStrings[v11[11]];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 491;
      __int16 v98 = 2048;
      uint64_t v99 = a1;
      __int16 v100 = 2048;
      unint64_t v101 = v8;
      __int16 v102 = 2080;
      unint64_t v103 = (unint64_t)v35;
      uint64_t v31 = "%25s:%-5d graph@%p: submixId %llu, type %s invalid effect voice count!";
      goto LABEL_35;
    }
    return 1;
  }
LABEL_15:
  unint64_t v19 = (void *)v11[18];
  if (v19)
  {
    __int16 v20 = (void *)v11[18];
    while (1)
    {
      uint64_t v21 = v20[4];
      uint64_t v22 = *(void **)(v21 + 72);
      UniqueObjectId v23 = *(void **)(v21 + 80);
      if (v22 == v23) {
        break;
      }
      do
      {
        uint64_t v24 = v22[2];
        if (v22[1] == v24) {
          uint64_t v25 = v22;
        }
        else {
          uint64_t v25 = (void *)(v24 - 8);
        }
        if (!*v25) {
          goto LABEL_30;
        }
        v22 += 4;
      }
      while (v22 != v23);
      __int16 v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_24;
      }
    }
LABEL_30:
    unint64_t v32 = **(id **)(Phase::Logger::GetInstance(PlayStateTransitionStatus) + 80);
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return 1;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 500;
    __int16 v98 = 2048;
    uint64_t v99 = a1;
    __int16 v100 = 2048;
    unint64_t v101 = v8;
    uint64_t v31 = "%25s:%-5d graph@%p: submixId %llu uninitialized sampler!";
LABEL_32:
    unint64_t v33 = v32;
    uint32_t v34 = 38;
LABEL_36:
    _os_log_impl(&dword_221E5E000, v33, OS_LOG_TYPE_ERROR, v31, buf, v34);
    return 1;
  }
LABEL_24:
  uint64_t v26 = v11[11];
  switch(v26)
  {
    case 3:
      if (v19)
      {
        float v27 = (char *)v11[13];
        float v28 = (char *)v11[14];
        while (0x8E38E38E38E38E39 * ((v28 - v27) >> 3) == (uint64_t)(*(void *)(v19[4] + 80)
                                                                     - *(void *)(v19[4] + 72)) >> 5)
        {
          unint64_t v19 = (void *)*v19;
          if (!v19) {
            goto LABEL_57;
          }
        }
        unint64_t v32 = **(id **)(Phase::Logger::GetInstance(PlayStateTransitionStatus) + 80);
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          return 1;
        }
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 547;
        __int16 v98 = 2048;
        uint64_t v99 = a1;
        __int16 v100 = 2048;
        unint64_t v101 = v8;
        uint64_t v31 = "%25s:%-5d graph@%p: submixId %llu, type PHASEMixerTypeChannel, invalid generator channel count!";
        goto LABEL_32;
      }
      float v27 = (char *)v11[13];
      float v28 = (char *)v11[14];
      break;
    case 2:
      if (v19)
      {
        float v27 = (char *)v11[13];
        float v28 = (char *)v11[14];
        while (0x8E38E38E38E38E39 * ((v28 - v27) >> 3) == (uint64_t)(*(void *)(v19[4] + 80)
                                                                     - *(void *)(v19[4] + 72)) >> 5)
        {
          unint64_t v19 = (void *)*v19;
          if (!v19) {
            goto LABEL_51;
          }
        }
        unint64_t v32 = **(id **)(Phase::Logger::GetInstance(PlayStateTransitionStatus) + 80);
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          return 1;
        }
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 526;
        __int16 v98 = 2048;
        uint64_t v99 = a1;
        __int16 v100 = 2048;
        unint64_t v101 = v8;
        uint64_t v31 = "%25s:%-5d graph@%p: submixId %llu, type PHASEMixerTypeAmbient, invalid generator channel count!";
        goto LABEL_32;
      }
      float v27 = (char *)v11[13];
      float v28 = (char *)v11[14];
LABEL_51:
      if (v27 == v28) {
        goto LABEL_140;
      }
      uint64_t v37 = v27;
      while (!*((void *)v37 + 8))
      {
        v37 += 72;
        if (v37 == v28) {
          goto LABEL_140;
        }
      }
      break;
    case 1:
      float v27 = (char *)v11[13];
      float v28 = (char *)v11[14];
      if (v28 - v27 != 72)
      {
        BOOL v29 = **(id **)(Phase::Logger::GetInstance(PlayStateTransitionStatus) + 80);
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
        {
          unint64_t v30 = 0x8E38E38E38E38E39 * ((uint64_t)(v11[14] - v11[13]) >> 3);
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 512;
          __int16 v98 = 2048;
          uint64_t v99 = a1;
          __int16 v100 = 2048;
          unint64_t v101 = v8;
          __int16 v102 = 2048;
          unint64_t v103 = v30;
          uint64_t v31 = "%25s:%-5d graph@%p: submixId %llu, type PHASEMixerTypeSpatial, invalid submix channel count (%lu)!";
LABEL_35:
          unint64_t v33 = v29;
          uint32_t v34 = 48;
          goto LABEL_36;
        }
        return 1;
      }
      break;
    default:
      BOOL v29 = **(id **)(Phase::Logger::GetInstance(PlayStateTransitionStatus) + 80);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
        return 1;
      }
      __int16 v36 = Phase::Controller::DVM::kSubmixTypeStrings[v11[11]];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 556;
      __int16 v98 = 2048;
      uint64_t v99 = a1;
      __int16 v100 = 2048;
      unint64_t v101 = v8;
      __int16 v102 = 2080;
      unint64_t v103 = (unint64_t)v36;
      uint64_t v31 = "%25s:%-5d graph@%p: submixId %llu invalid submix type %s!";
      goto LABEL_35;
  }
LABEL_57:
  if (v27 != v28)
  {
    __int16 v38 = v27;
    while (*(void *)v38 == *((void *)v38 + 1))
    {
      v38 += 72;
      if (v38 == v28) {
        goto LABEL_61;
      }
    }
    goto LABEL_62;
  }
LABEL_61:
  if (*a5 == v17)
  {
LABEL_140:
    Phase::Controller::DVM::VoiceGraph::SetSubmixPlayState((Phase::Controller::DVM::VoiceGraph *)a1, v8, v7, a4);
    return 0;
  }
LABEL_62:
  a1[11] |= 8uLL;
  if (v27 == v28) {
    goto LABEL_134;
  }
  unint64_t v39 = 0;
  double v89 = a5;
  do
  {
    uint64_t v40 = (uint64_t **)&v27[72 * v39];
    std::string __p = 0;
    unint64_t v92 = 0;
    uint64_t v93 = 0;
    std::vector<Phase::Controller::DVM::VoiceNode *>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode **,Phase::Controller::DVM::VoiceNode **>(&__p, *v40, (uint64_t)v40[1], v40[1] - *v40);
    v40[1] = *v40;
    uint64_t v42 = *a5;
    uint64_t v41 = a5[1];
    if (*a5 != v41)
    {
      uint64_t v43 = 0;
      int v44 = 0x200000;
      while (1)
      {
        unint64_t v45 = v43;
        VoiceNode = Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode((uint64_t)a1, *(void *)v42, *(void *)(*(void *)(v42 + 8) + 104 * v39), 6, v44, 0);
        uint64_t v43 = (uint64_t)VoiceNode;
        if (!VoiceNode) {
          break;
        }
        Phase::Controller::DVM::VoiceNode::Configure((uint64_t)VoiceNode, *(void *)(v42 + 8), *(void *)(v42 + 16), v39, v44, 0);
        if (v45 && !Phase::Controller::DVM::VoiceNode::ConnectToNode(v45, v43)) {
          goto LABEL_137;
        }
        unint64_t v48 = v40[1];
        unint64_t v47 = (unint64_t)v40[2];
        if ((unint64_t)v48 >= v47)
        {
          uint64_t v50 = v48 - *v40;
          if ((unint64_t)(v50 + 1) >> 61) {
            std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v51 = v47 - (void)*v40;
          uint64_t v52 = v51 >> 2;
          if (v51 >> 2 <= (unint64_t)(v50 + 1)) {
            uint64_t v52 = v50 + 1;
          }
          if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v53 = v52;
          }
          if (v53) {
            uint64_t v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)(v40 + 2), v53);
          }
          else {
            uint64_t v54 = 0;
          }
          __int16 v55 = (uint64_t *)&v54[8 * v50];
          *__int16 v55 = v43;
          unint64_t v49 = (char *)(v55 + 1);
          __int16 v57 = (char *)*v40;
          int v56 = (char *)v40[1];
          if (v56 != (char *)*v40)
          {
            do
            {
              uint64_t v58 = *((void *)v56 - 1);
              v56 -= 8;
              *--__int16 v55 = v58;
            }
            while (v56 != v57);
            int v56 = (char *)*v40;
          }
          *uint64_t v40 = v55;
          v40[1] = (uint64_t *)v49;
          v40[2] = (uint64_t *)&v54[8 * v53];
          if (v56) {
            operator delete(v56);
          }
        }
        else
        {
          *unint64_t v48 = v43;
          unint64_t v49 = (char *)(v48 + 1);
        }
        ++v44;
        v40[1] = (uint64_t *)v49;
        v42 += 32;
        if (v42 == v41) {
          goto LABEL_86;
        }
      }
      double v87 = **(id **)(Phase::Logger::GetInstance(0) + 80);
      if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
      {
        unint64_t v88 = Phase::Controller::DVM::kSubmixTypeStrings[v11[11]];
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 589;
        __int16 v98 = 2048;
        uint64_t v99 = a1;
        __int16 v100 = 2048;
        unint64_t v101 = v95;
        __int16 v102 = 2080;
        unint64_t v103 = (unint64_t)v88;
        _os_log_impl(&dword_221E5E000, v87, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: submixId %llu, type %s, failed creating or getting an effect voice node!", buf, 0x30u);
      }
LABEL_137:
      if (__p)
      {
        unint64_t v92 = (Phase::Controller::DVM::VoiceGraph **)__p;
        operator delete(__p);
      }
      return 8;
    }
LABEL_86:
    if (__p != v92)
    {
      std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v59 = (void *)v11[18];
      if (v59)
      {
        uint64_t v60 = *(void *)__p;
        while (1)
        {
          uint64_t v61 = v59[4];
          if (!v61) {
            break;
          }
          double v62 = *(unint64_t **)(v61 + 72);
          double v63 = *(unint64_t **)(v61 + 80);
          while (v62 != v63)
          {
            unint64_t v64 = v62[2];
            if (v62[1] == v64) {
              uint64_t v65 = v62;
            }
            else {
              uint64_t v65 = (unint64_t *)(v64 - 8);
            }
            Phase::Controller::DVM::VoiceNode::DisconnectFromNode(*v65, 0, v60);
            v62 += 4;
          }
          std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v59 = (void *)*v59;
          if (!v59) {
            goto LABEL_97;
          }
        }
LABEL_146:
        std::terminate();
      }
    }
LABEL_97:
    Phase::Controller::DVM::Submix::ChannelStrip::GetHeadNodes(v40, buf);
    if (*(void *)buf != *(void *)&buf[8])
    {
      uint64_t v67 = (void *)v11[18];
      for (i = v39; v67; unint64_t v39 = i)
      {
        uint64_t v68 = v67[4];
        if (!v68) {
          goto LABEL_146;
        }
        uint64_t v69 = v11[11];
        if ((unint64_t)(v69 - 2) >= 2)
        {
          if (v69 != 1) {
            __assert_rtn("ConfigureSubmix", "DVMGraph.mm", 659, "false");
          }
          int v75 = *(unint64_t **)(v68 + 72);
          char v76 = *(unint64_t **)(v68 + 80);
          while (v75 != v76)
          {
            unint64_t v77 = v75[2];
            if (v75[1] == v77) {
              double v78 = v75;
            }
            else {
              double v78 = (unint64_t *)(v77 - 8);
            }
            uint64_t v80 = *(uint64_t **)buf;
            int8x8_t v79 = *(uint64_t **)&buf[8];
            if (*(void *)buf != *(void *)&buf[8])
            {
              unint64_t v81 = *v78;
              do
                Phase::Controller::DVM::VoiceNode::ConnectToNode(v81, *v80++);
              while (v80 != v79);
            }
            v75 += 4;
          }
        }
        else
        {
          unint64_t v70 = (unint64_t *)(*(void *)(v68 + 72) + 32 * v39);
          unint64_t v71 = v70[2];
          if (v70[1] != v71) {
            unint64_t v70 = (unint64_t *)(v71 - 8);
          }
          uint64_t v72 = *(uint64_t **)buf;
          unint64_t v73 = *(uint64_t **)&buf[8];
          if (*(void *)buf != *(void *)&buf[8])
          {
            unint64_t v74 = *v70;
            do
              Phase::Controller::DVM::VoiceNode::ConnectToNode(v74, *v72++);
            while (v72 != v73);
          }
        }
        uint64_t v67 = (void *)*v67;
      }
    }
    uint8x8_t v82 = (Phase::Controller::DVM::VoiceGraph **)__p;
    uint64_t v83 = v92;
    while (v82 != v83)
    {
      uint64_t v84 = *v82;
      int v86 = (Phase::Controller::DVM::VoiceGraph **)*v40;
      unint64_t v85 = (Phase::Controller::DVM::VoiceGraph **)v40[1];
      while (v86 != v85)
      {
        if (*v86 == v84) {
          goto LABEL_125;
        }
        ++v86;
      }
      int v86 = (Phase::Controller::DVM::VoiceGraph **)v40[1];
LABEL_125:
      if (v85 == v86) {
        Phase::Controller::DVM::VoiceGraph::ScheduleRemoveVoice(v84, v66);
      }
      ++v82;
    }
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    a5 = v89;
    if (__p)
    {
      unint64_t v92 = (Phase::Controller::DVM::VoiceGraph **)__p;
      operator delete(__p);
    }
    ++v39;
    float v27 = (char *)v11[13];
  }
  while (0x8E38E38E38E38E39 * ((uint64_t)(v11[14] - (void)v27) >> 3) > v39);
  unint64_t v8 = v95;
  unint64_t v7 = v96;
LABEL_134:
  Phase::Controller::DVM::VoiceGraph::SetSubmixPlayState((Phase::Controller::DVM::VoiceGraph *)a1, v8, v7, a4);
  return 0;
}

void sub_221F19024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::DVM::VoiceGraph::GetPlayStateTransitionStatus(uint64_t result, int *a2, int a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  if (!*((unsigned char *)a2 + 4)) {
    return 0;
  }
  int v5 = *a2;
  if (*a2 == a3) {
    return 8;
  }
  uint64_t v6 = result;
  if (v5 == 3)
  {
    if (a3 == 1) {
      goto LABEL_13;
    }
    return 2;
  }
  if (v5 == 2)
  {
    uint64_t result = a3 == 3;
    if (a3 != 1) {
      return result;
    }
    goto LABEL_13;
  }
  if (v5 == 1 && a3 != 3) {
    return 2;
  }
LABEL_13:
  unint64_t v7 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)result) + 80);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)a2 + 4)) {
      unint64_t v8 = Phase::Controller::DVM::kPlayStateStrings[*a2];
    }
    else {
      unint64_t v8 = "none";
    }
    int v9 = Phase::Controller::DVM::kPlayStateStrings[a3];
    int v10 = 136316162;
    unint64_t v11 = "DVMGraph.mm";
    __int16 v12 = 1024;
    int v13 = 2382;
    __int16 v14 = 2048;
    uint64_t v15 = v6;
    __int16 v16 = 2080;
    uint64_t v17 = v8;
    __int16 v18 = 2080;
    unint64_t v19 = v9;
    _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_DEFAULT, "%25s:%-5d graph@%p: state change request %s to %s is invalid!", (uint8_t *)&v10, 0x30u);
  }
  return 4;
}

_DWORD *Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode(uint64_t a1, unint64_t a2, unint64_t a3, int a4, int a5, uint64_t a6)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  VoiceNode = Phase::Controller::DVM::VoiceGraph::GetVoiceNode((Phase::Controller::DVM::VoiceGraph *)a1, a2, a3);
  int64_t v58 = a3;
  if (VoiceNode)
  {
    __int16 v12 = VoiceNode;
    if ((VoiceNode[7] ^ a5) < 0x10000) {
      return v12;
    }
    int v13 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)VoiceNode)
                                                                                        + 80)));
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      Phase::Controller::DVM::VoiceNode::GetDescription((Phase::Controller::DVM::VoiceNode *)__p, v12);
      __int16 v14 = (SBYTE7(v60) & 0x80u) == 0 ? __p : (void **)__p[0];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2972;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&uint8_t buf[20] = a1;
      *(_WORD *)&unsigned char buf[28] = 2080;
      *(void *)&buf[30] = v14;
      *(_WORD *)&buf[38] = 1024;
      int v62 = a5;
      _os_log_impl(&dword_221E5E000, v13, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: Error: found an existing voicenode with a different base order %s (expected order = 0x%x)!", buf, 0x2Cu);
      if (SBYTE7(v60) < 0) {
        operator delete(__p[0]);
      }
    }
  }
  *(void *)buf = a2;
  *(void *)&uint8_t buf[8] = a3;
  int v56 = (void **)(a1 + 528);
  uint64_t v15 = std::__tree<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<std::pair<unsigned long long,long long>,std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::less<std::pair<unsigned long long,long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>>>::find<std::pair<unsigned long long,long long>>(a1 + 528, (unint64_t *)buf);
  __int16 v16 = (uint64_t **)(a1 + 536);
  if ((void *)(a1 + 536) == v15 || (uint64_t v17 = (void *)v15[6]) == 0)
  {
    uint64_t v55 = a6;
    memset(buf, 0, 24);
    uint64_t v18 = *(void *)(a1 + 488);
    if (v18 == a1 + 480)
    {
      uint64_t v17 = 0;
      a6 = v55;
    }
    else
    {
      unint64_t v19 = 0;
      do
      {
        uint64_t v20 = *(void *)(v18 + 16);
        if (*(void *)(v20 + 16) == a2)
        {
          if ((unint64_t)v19 >= *(void *)&buf[16])
          {
            uint64_t v21 = ((uint64_t)v19 - *(void *)buf) >> 3;
            if ((unint64_t)(v21 + 1) >> 61) {
              std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
            }
            unint64_t v22 = (uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 2;
            if (v22 <= v21 + 1) {
              unint64_t v22 = v21 + 1;
            }
            if (*(void *)&buf[16] - *(void *)buf >= 0x7FFFFFFFFFFFFFF8uLL) {
              unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v23 = v22;
            }
            if (v23) {
              uint64_t v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&buf[16], v23);
            }
            else {
              uint64_t v24 = 0;
            }
            uint64_t v25 = &v24[8 * v21];
            *(void *)uint64_t v25 = v20;
            unint64_t v19 = v25 + 8;
            float v27 = *(char **)buf;
            uint64_t v26 = *(char **)&buf[8];
            if (*(void *)&buf[8] != *(void *)buf)
            {
              do
              {
                uint64_t v28 = *((void *)v26 - 1);
                v26 -= 8;
                *((void *)v25 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v28;
                v25 -= 8;
              }
              while (v26 != v27);
              uint64_t v26 = *(char **)buf;
            }
            *(void *)buf = v25;
            *(void *)&uint8_t buf[8] = v19;
            *(void *)&uint8_t buf[16] = &v24[8 * v23];
            if (v26) {
              operator delete(v26);
            }
          }
          else
          {
            *v19++ = v20;
          }
          *(void *)&uint8_t buf[8] = v19;
        }
        uint64_t v18 = *(void *)(v18 + 8);
      }
      while (v18 != a1 + 480);
      if (*(void **)buf == v19)
      {
        uint64_t v17 = 0;
        a6 = v55;
      }
      else
      {
        BOOL v29 = *(void ***)buf;
        a6 = v55;
        do
        {
          uint64_t v17 = *v29;
          if (!*v29) {
            goto LABEL_95;
          }
          unint64_t v30 = (void *)v17[6];
          if (v30)
          {
            int v31 = -1;
            do
            {
              if (v31 <= *(_DWORD *)(v30[3] + 28)) {
                int v31 = *(_DWORD *)(v30[3] + 28);
              }
              unint64_t v30 = (void *)*v30;
            }
            while (v30);
          }
          else
          {
            int v31 = -1;
          }
          unint64_t v32 = v17[7];
          if (!v32) {
            goto LABEL_55;
          }
          BOOL v33 = v31 < a5;
          unsigned int v34 = (v31 ^ a5) >> 16;
          BOOL v35 = !v33 && v34 == 0;
          if (v35 && (a4 == 1 || v32 < *(int *)(a1 + 48))) {
            goto LABEL_55;
          }
          ++v29;
        }
        while (v29 != v19);
        uint64_t v17 = 0;
      }
LABEL_55:
      if (*(void *)buf)
      {
        *(void *)&uint8_t buf[8] = *(void *)buf;
        operator delete(*(void **)buf);
      }
    }
  }
  if (a4 == 1)
  {
    if (!v17) {
      operator new();
    }
    uint64_t v36 = (*(uint64_t (**)(void *))(*v17 + 40))(v17);
    uint64_t v37 = v36;
    if (!v36 || !a6 || (uint64_t v38 = (*(uint64_t (**)(uint64_t))(*(void *)a6 + 24))(a6)) == 0) {
LABEL_95:
    }
      std::terminate();
    uint64_t v39 = Phase::Controller::DVM::ProcedureVoicePoolNode::AddVoice(v37, a3, *(_DWORD *)(v38 + 60), *(void *)(v38 + 64));
  }
  else
  {
    if (!v17) {
      operator new();
    }
    uint64_t v39 = (*(uint64_t (**)(void *, unint64_t))(*v17 + 48))(v17, a3);
  }
  __int16 v12 = (_DWORD *)v39;
  if (!v39) {
    goto LABEL_95;
  }
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)v39 + 32))(__p, v39);
  *(_OWORD *)buf = *(_OWORD *)__p;
  *(_OWORD *)&uint8_t buf[16] = v60;
  *(void *)&buf[32] = v17;
  uint64_t v40 = (void *)(a1 + 512);
  uint64_t v41 = *(void **)(a1 + 512);
  if (v41)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v42 = v41;
        uint64_t v43 = (uint64_t)(v41 + 4);
        if (!std::operator<[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>((uint64_t)buf, (uint64_t)(v41 + 4)))break; {
        uint64_t v41 = (void *)*v42;
        }
        uint64_t v40 = v42;
        if (!*v42) {
          goto LABEL_77;
        }
      }
      if (!std::operator<[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>(v43, (uint64_t)buf))break; {
      uint64_t v40 = v42 + 1;
      }
      uint64_t v41 = (void *)v42[1];
      if (!v41) {
        goto LABEL_77;
      }
    }
    if (*v40) {
      goto LABEL_80;
    }
  }
  else
  {
    uint64_t v42 = (void *)(a1 + 512);
  }
LABEL_77:
  int v44 = operator new(0x48uLL);
  long long v45 = *(_OWORD *)&buf[16];
  v44[2] = *(_OWORD *)buf;
  v44[3] = v45;
  *((void *)v44 + 8) = *(void *)&buf[32];
  *(void *)int v44 = 0;
  *((void *)v44 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)v44 + 2) = v42;
  *uint64_t v40 = v44;
  uint64_t v46 = **(void **)(a1 + 504);
  if (v46)
  {
    *(void *)(a1 + 504) = v46;
    int v44 = (_OWORD *)*v40;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 512), (uint64_t *)v44);
  ++*(void *)(a1 + 520);
LABEL_80:
  unint64_t v47 = v17[2];
  unint64_t v48 = *v16;
  unint64_t v49 = (uint64_t **)(a1 + 536);
  if (!*v16) {
    goto LABEL_89;
  }
  do
  {
    while (1)
    {
      unint64_t v49 = (uint64_t **)v48;
      unint64_t v50 = v48[4];
      if (v50 <= v47) {
        break;
      }
LABEL_82:
      unint64_t v48 = *v49;
      __int16 v16 = v49;
      if (!*v49) {
        goto LABEL_89;
      }
    }
    if (v50 >= v47)
    {
      int64_t v51 = (int64_t)v49[5];
      if (v51 > v58) {
        goto LABEL_82;
      }
      if (v51 >= v58) {
        return v12;
      }
    }
    unint64_t v48 = v49[1];
  }
  while (v48);
  __int16 v16 = v49 + 1;
LABEL_89:
  uint64_t v52 = (uint64_t *)operator new(0x38uLL);
  v52[4] = v47;
  v52[5] = v58;
  v52[6] = (uint64_t)v17;
  *uint64_t v52 = 0;
  v52[1] = 0;
  v52[2] = (uint64_t)v49;
  NSObject *v16 = v52;
  unint64_t v53 = (void *)**v56;
  if (v53)
  {
    *int v56 = v53;
    uint64_t v52 = *v16;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 536), v52);
  ++*(void *)(a1 + 544);
  return v12;
}

void sub_221F19B7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceNode::Configure(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  if (0x4EC4EC4EC4EC4EC5 * ((a3 - a2) >> 3) <= (unint64_t)a4
    || *(void *)(a1 + 16) != *(void *)(a2 + 104 * a4))
  {
    goto LABEL_51;
  }
  int v10 = (void *)(a1 + 104);
  unint64_t v11 = *(char **)(a1 + 104);
  *(void *)(a1 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v11;
  __int16 v12 = (const void **)(a2 + 104 * a4 + 80);
  if ((const void **)(a1 + 104) != v12)
  {
    int v13 = *v12;
    __int16 v14 = *(unsigned char **)(a2 + 104 * a4 + 88);
    int64_t v15 = v14 - (unsigned char *)*v12;
    unint64_t v16 = v15 >> 4;
    uint64_t v17 = *(void *)(a1 + 120);
    if (v15 >> 4 > (unint64_t)((v17 - (uint64_t)v11) >> 4))
    {
      if (v11)
      {
        operator delete(v11);
        uint64_t v17 = 0;
        void *v10 = 0;
        *(void *)(a1 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
        *(void *)(a1 + 120) = 0;
      }
      if (v15 < 0) {
        std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v18 = v17 >> 3;
      if (v17 >> 3 <= v16) {
        uint64_t v18 = v15 >> 4;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v18;
      }
      std::vector<Phase::Controller::DspParameterPair>::__vallocate[abi:ne180100]((void *)(a1 + 104), v19);
      unint64_t v11 = *(char **)(a1 + 112);
    }
    if (v14 != v13) {
      memmove(v11, v13, v15);
    }
    *(void *)(a1 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = &v11[16 * v16];
  }
  std::vector<Phase::Controller::VoiceBufferParameter>::__clear[abi:ne180100]((uint64_t *)(a1 + 128));
  uint64_t v20 = (uint64_t *)(a2 + 104 * a4 + 8);
  if ((uint64_t *)(a1 + 128) == v20) {
    goto LABEL_34;
  }
  uint64_t v21 = *v20;
  uint64_t v22 = *(void *)(a2 + 104 * a4 + 16);
  uint64_t v23 = v22 - *v20;
  unint64_t v24 = v23 >> 5;
  uint64_t v25 = *(void *)(a1 + 128);
  if (v23 >> 5 > (unint64_t)((*(void *)(a1 + 144) - v25) >> 5))
  {
    std::vector<Phase::Controller::VoiceBufferParameter>::__vdeallocate((uint64_t *)(a1 + 128));
    if (v23 < 0) {
      std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v26 = *(void *)(a1 + 144) - *(void *)(a1 + 128);
    uint64_t v27 = v26 >> 4;
    if (v26 >> 4 <= v24) {
      uint64_t v27 = v23 >> 5;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v28 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v28 = v27;
    }
    std::vector<Phase::Controller::VoiceBufferParameter>::__vallocate[abi:ne180100]((void *)(a1 + 128), v28);
    uint64_t v29 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::Controller::VoiceBufferParameter>,Phase::Controller::VoiceBufferParameter*,Phase::Controller::VoiceBufferParameter*,Phase::Controller::VoiceBufferParameter*>(a1 + 144, v21, v22, *(void *)(a1 + 136));
    goto LABEL_28;
  }
  unint64_t v30 = (*(void *)(a1 + 136) - v25) >> 5;
  if (v30 < v24)
  {
    uint64_t v31 = v21 + 32 * v30;
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::Controller::VoiceBufferParameter *,Phase::Controller::VoiceBufferParameter *,Phase::Controller::VoiceBufferParameter *>(v21, v31, v25);
    uint64_t v29 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::Controller::VoiceBufferParameter>,Phase::Controller::VoiceBufferParameter*,Phase::Controller::VoiceBufferParameter*,Phase::Controller::VoiceBufferParameter*>(a1 + 144, v31, v22, *(void *)(a1 + 136));
LABEL_28:
    *(void *)(a1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v29;
    goto LABEL_34;
  }
  uint64_t v32 = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::Controller::VoiceBufferParameter *,Phase::Controller::VoiceBufferParameter *,Phase::Controller::VoiceBufferParameter *>(v21, *(void *)(a2 + 104 * a4 + 16), v25);
  for (uint64_t i = *(void *)(a1 + 136); i != v32; i -= 32)
  {
    unsigned int v34 = *(std::__shared_weak_count **)(i - 16);
    if (v34) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v34);
    }
  }
  *(void *)(a1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v32;
LABEL_34:
  BOOL v35 = (void *)(a2 + 104 * a4 + 32);
  uint64_t v36 = *(void *)(a1 + 40) - *(void *)(a1 + 32);
  if (v36)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v36 >> 3) != (uint64_t)(*(void *)(a2 + 104 * a4 + 40) - *v35) >> 4) {
      goto LABEL_51;
    }
  }
  else
  {
    std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::resize((char **)(a1 + 32), (uint64_t)(*(void *)(a2 + 104 * a4 + 40) - *v35) >> 4);
  }
  uint64_t v37 = (void *)(a2 + 104 * a4 + 56);
  uint64_t v38 = *(void *)(a1 + 64) - *(void *)(a1 + 56);
  if (v38)
  {
    if (0xAAAAAAAAAAAAAAABLL * (v38 >> 3) != (uint64_t)(*(void *)(a2 + 104 * a4 + 64) - *v37) >> 4) {
      goto LABEL_51;
    }
  }
  else
  {
    uint64_t v41 = a2 + 104 * a4;
    uint64_t v43 = *(void *)(v41 + 64);
    uint64_t v42 = (void *)(v41 + 64);
    uint64_t v44 = v43 - *v37;
    if (v43 != *v37)
    {
      std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::resize((char **)(a1 + 56), v44 >> 4);
      std::vector<Phase::Controller::DVM::VoiceNode::BusChannelPair>::resize((char **)(a1 + 80), (uint64_t)(*v42 - *v37) >> 4);
      if (*v42 != *v37)
      {
        unint64_t v45 = (uint64_t)(*v42 - *v37) >> 4;
        if (v45 <= 1) {
          unint64_t v45 = 1;
        }
        uint64_t v46 = (_DWORD *)(*(void *)(a1 + 80) + 4);
        unint64_t v47 = (double *)(*v37 + 8);
        do
        {
          int v48 = *((_DWORD *)v47 - 2);
          *(v46 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = (int)*v47;
          _DWORD *v46 = v48;
          v46 += 2;
          v47 += 2;
          --v45;
        }
        while (v45);
      }
    }
  }
  if (a5 < 0) {
LABEL_51:
  }
    std::terminate();
  *(_DWORD *)(a1 + 28) = a5;
  uint64_t v39 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 64);

  return v39(a1, a6);
}

void sub_221F1A0A0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v2;
  _Unwind_Resume(a1);
}

void sub_221F1A0A8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v2;
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceNode::ConnectToNode(unint64_t a1, uint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3) >= 0xAAAAAAAAAAAAAAABLL
                                                                                             * ((uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 3))
    unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 64) - *(void *)(a1 + 56)) >> 3);
  else {
    unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 3);
  }
  if (!v2) {
    return 1;
  }
  uint64_t v5 = 0;
  LODWORD(vstd::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  do
  {
    uint64_t v8 = a2;
    int v9 = v5;
    int v10 = 1065353216;
    char v11 = 1;
    uint64_t v6 = v6 & Phase::Controller::DVM::VoiceNode::Connect(a1, 0, v5++, (uint64_t)&v8);
  }
  while (v2 != v5);
  return v6;
}

void Phase::Controller::DVM::VoiceNode::DisconnectFromNode(unint64_t a1, int a2, uint64_t a3)
{
  if (a2) {
    uint64_t v3 = 32;
  }
  else {
    uint64_t v3 = 56;
  }
  if (a2) {
    unint64_t v4 = a1 + 32;
  }
  else {
    unint64_t v4 = a1 + 56;
  }
  uint64_t v5 = *(void *)(a1 + v3);
  if (*(void *)(v4 + 8) != v5)
  {
    unint64_t v9 = 0;
    int v10 = 1;
    do
    {
      std::set<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::set[abi:ne180100]((uint64_t)&v15, v5 + 24 * v9);
      char v11 = v15;
      if (v15 != v16)
      {
        do
        {
          if (v11[4] == a3) {
            v10 &= Phase::Controller::DVM::VoiceNode::Disconnect(a1, a2, v9, (uint64_t)(v11 + 4));
          }
          __int16 v12 = (void *)v11[1];
          if (v12)
          {
            do
            {
              int v13 = (void **)v12;
              __int16 v12 = (void *)*v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              int v13 = (void **)v11[2];
              BOOL v14 = *v13 == v11;
              char v11 = v13;
            }
            while (!v14);
          }
          char v11 = v13;
        }
        while (v13 != v16);
      }
      std::__tree<Phase::SpatialCategory>::destroy((uint64_t)&v15, v16[0]);
      ++v9;
      uint64_t v5 = *(void *)(a1 + v3);
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v4 + 8) - v5) >> 3) > v9);
  }
}

void sub_221F1A2AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

uint64_t Phase::Controller::DVM::VoiceGraph::ConfigureAmbientSubmix(void *a1, unint64_t a2, unint64_t a3, uint64_t *a4, void *a5)
{
  uint64_t v49 = *MEMORY[0x263EF8340];
  *(void *)uu = a2;
  unint64_t v38 = a3;
  *(void *)buf = a2;
  *(void *)&uint8_t buf[8] = a3;
  unint64_t v7 = a1 + 17;
  if (std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>(a1 + 17, buf))
  {
    v50.mStorage[0] = a2;
    v50.mStorage[1] = a3;
    uint64_t Submix = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetSubmix((Phase::Controller::DVM::VoiceGraph *)a1, v50);
    unint64_t v9 = Submix;
    uint64_t v10 = *((void *)Submix + 5);
    if ((v10 & 0xFF00000000) != 0)
    {
      uint64_t v12 = *a4;
      uint64_t v11 = a4[1];
      if (0x8E38E38E38E38E39 * ((uint64_t)(*((void *)Submix + 10) - *((void *)Submix + 9)) >> 3) != (v11 - *a4) >> 4)
      {
        uint64_t v23 = **(id **)(Phase::Logger::GetInstance(Submix) + 80);
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
          return 1;
        }
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 704;
        __int16 v40 = 2048;
        uint64_t v41 = a1;
        __int16 v42 = 2048;
        unint64_t v43 = a2;
        unint64_t v24 = "%25s:%-5d graph@%p: invalid channel count for ambient submixId %llu!";
        uint64_t v25 = v23;
        uint32_t v26 = 38;
LABEL_24:
        _os_log_impl(&dword_221E5E000, v25, OS_LOG_TYPE_ERROR, v24, buf, v26);
        return 1;
      }
      if (v11 != v12)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        unint64_t v15 = 0;
        while (1)
        {
          *(_OWORD *)buf = *(_OWORD *)(v12 + v13);
          if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>(v7, buf))
          {
            uint64_t v27 = **(id **)(Phase::Logger::GetInstance(0) + 80);
            if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
              return 1;
            }
            unint64_t v28 = *(void *)(v12 + v13);
            *(_DWORD *)buf = 136316162;
            *(void *)&uint8_t buf[4] = "DVMGraph.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 720;
            __int16 v40 = 2048;
            uint64_t v41 = a1;
            __int16 v42 = 2048;
            unint64_t v43 = v28;
            __int16 v44 = 2048;
            unint64_t v45 = a2;
            unint64_t v24 = "%25s:%-5d graph@%p: unregistered child submix %llu for ambient submixId %llu!";
            uint64_t v25 = v27;
            uint32_t v26 = 48;
            goto LABEL_24;
          }
          unint64_t v16 = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetSubmix((Phase::Controller::DVM::VoiceGraph *)a1, *(UniqueObjectId *)(v12 + v13));
          uint64_t v17 = v16;
          if (*((void *)v16 + 8)) {
            break;
          }
          *((void *)v16 + 8) = v9;
          uint64_t v18 = *((void *)v9 + 9) + v14;
          *(_OWORD *)(v18 + 48) = *(_OWORD *)(v12 + v13);
          *(void *)(v18 + 64) = v16;
          ++v15;
          uint64_t v12 = *a4;
          v14 += 72;
          v13 += 16;
          if (v15 >= (a4[1] - *a4) >> 4)
          {
            uint64_t v10 = *((void *)v9 + 5);
            goto LABEL_10;
          }
        }
        uint64_t v29 = **(id **)(Phase::Logger::GetInstance(v16) + 80);
        if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          return 1;
        }
        unint64_t v30 = *(void *)(v12 + v13);
        uint64_t v31 = *((void *)v17 + 8);
        *(_DWORD *)buf = 136316418;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 727;
        __int16 v40 = 2048;
        uint64_t v41 = a1;
        __int16 v42 = 2048;
        unint64_t v43 = v30;
        __int16 v44 = 2048;
        unint64_t v45 = a2;
        __int16 v46 = 2048;
        uint64_t v47 = v31;
        unint64_t v24 = "%25s:%-5d graph@%p: child submix %llu for ambient submixId %llu already has parent %p!";
        uint64_t v25 = v29;
        uint32_t v26 = 58;
        goto LABEL_24;
      }
LABEL_10:
      if ((v10 & 0xFF00000000) == 0) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      return Phase::Controller::DVM::VoiceGraph::ConfigureSubmix(a1, a2, a3, v10, a5);
    }
    else
    {
      uint64_t v21 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(Submix)
                                                                                          + 80)));
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        memset(out, 0, 37);
        uuid_unparse(uu, out);
        std::string::basic_string[abi:ne180100]<0>(__p, out);
        uint64_t v22 = v36 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 696;
        __int16 v40 = 2048;
        uint64_t v41 = a1;
        __int16 v42 = 2080;
        unint64_t v43 = (unint64_t)v22;
        _os_log_impl(&dword_221E5E000, v21, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: trying to configure an ambient submix with unconfigured parent submixId %s!", buf, 0x26u);
        if (v36 < 0) {
          operator delete(__p[0]);
        }
      }

      return 7;
    }
  }
  else
  {
    uint64_t v20 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 685;
      __int16 v40 = 2048;
      uint64_t v41 = a1;
      __int16 v42 = 2048;
      unint64_t v43 = a2;
      _os_log_impl(&dword_221E5E000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: ambient submix with submixId %llu was not registered!", buf, 0x26u);
    }
    return 4;
  }
}

void sub_221F1A788(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::AddGenerator(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  v23[2] = a3;
  v23[3] = a4;
  v23[0] = a5;
  v23[1] = a6;
  *(void *)buf = a3;
  *(void *)&uint8_t buf[8] = a4;
  uint64_t v12 = (void *)(a1 + 96);
  uint64_t v13 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(a1 + 96), buf);
  if (v13
    || (*(void *)buf = a5,
        *(void *)&uint8_t buf[8] = a6,
        (uint64_t v13 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(a1 + 136), buf)) == 0))
  {
    uint64_t v14 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v13)
                                                                                        + 80)));
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = a3;
      uint64_t v25 = a4;
      unint64_t v15 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>(v12, &v24);
      uint64_t v24 = a5;
      uint64_t v25 = a6;
      unint64_t v16 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(a1 + 136), &v24);
      uint64_t v17 = "generatorId already exists,";
      *(_DWORD *)buf = 136316930;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 748;
      if (!v15) {
        uint64_t v17 = "";
      }
      __int16 v27 = 2048;
      uint64_t v28 = a1;
      __int16 v29 = 1024;
      if (v16) {
        uint64_t v18 = "";
      }
      else {
        uint64_t v18 = "submixId does not exist";
      }
      *(_DWORD *)unint64_t v30 = a2;
      *(_WORD *)&v30[4] = 2048;
      *(void *)&v30[6] = a3;
      *(_WORD *)&v30[14] = 2048;
      *(void *)&v30[16] = a5;
      __int16 v31 = 2080;
      uint64_t v32 = v17;
      __int16 v33 = 2080;
      unsigned int v34 = v18;
      _os_log_impl(&dword_221E5E000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: generatorType %d, generatorId %llu, submixId %llu: %s%s!", buf, 0x4Au);
    }

    return 3;
  }
  else
  {
    uint64_t v20 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>((void *)(a1 + 136), v23);
    if ((*((void *)v20 + 9) & 0xFF00000000) == 0 || *((void *)v20 + 9) != 0) {
      Phase::Controller::DVM::Submix::AddGenerator((uint64_t)v20 + 32, a2);
    }
    uint64_t v22 = **(id **)(Phase::Logger::GetInstance(v20) + 80);
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 760;
      __int16 v27 = 2048;
      uint64_t v28 = a1;
      __int16 v29 = 2048;
      *(void *)unint64_t v30 = a3;
      *(_WORD *)&v30[8] = 2048;
      *(void *)&v30[10] = a5;
      _os_log_impl(&dword_221E5E000, v22, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: can't add a generatorId %llu, to a submixId %llu that is stopping!!", buf, 0x30u);
    }
    return 7;
  }
}

void sub_221F1AC38(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *Phase::Controller::DVM::VoiceGraph::GetSubmixForGenerator(Phase::Controller::DVM::VoiceGraph *this, UniqueObjectId a2)
{
  UniqueObjectId v7 = a2;
  UniqueObjectId v8 = a2;
  uint64_t v3 = (void *)((char *)this + 96);
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)this + 12, &v8))__assert_rtn("GetSubmixForGenerator", "DVMGraph.hpp", 335, "GeneratorIdExists(generatorId)"); {
  UniqueObjectId v6 = (UniqueObjectId)*((_OWORD *)std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(v3, &v7)+ 2);
  }
  UniqueObjectId v8 = v6;
  unint64_t v4 = (void *)((char *)this + 136);
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>(v4, &v8))std::terminate(); {
  return std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(v4, &v6)+ 4;
  }
}

void *Phase::Controller::DVM::VoiceGraph::RemoveGenerator(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3)
{
  v7[0] = a2;
  v7[1] = a3;
  uint64_t result = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 12, v7);
  if (result) {
    return (void *)Phase::Controller::DVM::VoiceGraph::SetGeneratorPlayState(a1, a2, a3, 0);
  }
  return result;
}

uint64_t Phase::Controller::DVM::VoiceGraph::SetGeneratorPlayState(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3, int a4)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  *(void *)buf = a2;
  *(void *)&uint8_t buf[8] = a3;
  if (std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 12, buf))
  {
    uint64_t Generator = Phase::Controller::DVM::VoiceGraph::GetGenerator(a1, a2, a3);
    int v6 = Phase::Controller::DVM::VoiceGraph::PreprocessPlayStateChange((uint64_t)a1, Generator, a4);
    if (v6 != 8)
    {
      if (v6 == 4) {
        return 1;
      }
      uint64_t v10 = (uint64_t)a1;
      *((void *)a1 + 11) |= 8uLL;
      float v11 = 0.0;
      if ((v6 - 1) <= 1u)
      {
        float v11 = v6 == 2 ? 0.001 : 0.0;
        uint64_t v12 = *(unint64_t **)(Generator + 72);
        uint64_t v63 = *(unint64_t **)(Generator + 80);
        if (v12 != v63)
        {
          if (v6 == 1) {
            double v13 = 1.0;
          }
          else {
            double v13 = 0.0;
          }
          if (v6 == 1) {
            double v14 = 0.0;
          }
          else {
            double v14 = 1.0;
          }
          do
          {
            unint64_t v15 = (char **)(v12 + 1);
            unint64_t v16 = v12[2];
            if (v12[1] == v16) {
              uint64_t v17 = v12;
            }
            else {
              uint64_t v17 = (unint64_t *)(v16 - 8);
            }
            unint64_t v18 = *v17;
            if (*(_DWORD *)(*v17 + 24) == 2)
            {
              unint64_t v19 = *v17;
            }
            else
            {
              int v20 = *(_DWORD *)(v18 + 28);
              VoiceNode = (char **)Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode(v10, 0xF57EBABD1FFDD056, atomic_fetch_add(*(atomic_ullong *volatile *)(v10 + 80), 1uLL), 2, v20 + 1, 0);
              unint64_t v19 = (unint64_t)VoiceNode;
              if (!VoiceNode
                || (std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::resize(VoiceNode + 4, 1uLL),
                    std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::resize((char **)(v19 + 56), 1uLL),
                    std::vector<Phase::Controller::DVM::VoiceNode::BusChannelPair>::resize((char **)(v19 + 80), 1uLL),
                    **(void **)(v19 + 80) = 1,
                    v20 <= -2))
              {
                std::terminate();
              }
              *(_DWORD *)(v19 + 28) = v20 + 1;
              memset(buf, 0, 24);
              std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode::IOChannel*,Phase::Controller::DVM::VoiceNode::IOChannel*>(buf, *(void *)(v18 + 56), *(void *)(v18 + 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v18 + 64) - *(void *)(v18 + 56)) >> 3));
              Phase::Controller::DVM::VoiceNode::Disconnect(v18, 0);
              uint64_t v10 = (uint64_t)a1;
              Phase::Controller::DVM::VoiceNode::ConnectToNode(v18, v19);
              uint64_t v23 = *(void *)buf;
              uint64_t v22 = *(void *)&buf[8];
              if (*(void *)&buf[8] != *(void *)buf)
              {
                unint64_t v24 = 0;
                do
                {
                  uint64_t v25 = (void *)(v23 + 24 * v24);
                  uint64_t v28 = (void *)*v25;
                  uint32_t v26 = v25 + 1;
                  __int16 v27 = v28;
                  if (v28 != v26)
                  {
                    do
                    {
                      Phase::Controller::DVM::VoiceNode::Connect(v19, 0, v24, (uint64_t)(v27 + 4));
                      __int16 v29 = (void *)v27[1];
                      if (v29)
                      {
                        do
                        {
                          unint64_t v30 = v29;
                          __int16 v29 = (void *)*v29;
                        }
                        while (v29);
                      }
                      else
                      {
                        do
                        {
                          unint64_t v30 = (void *)v27[2];
                          BOOL v31 = *v30 == (void)v27;
                          __int16 v27 = v30;
                        }
                        while (!v31);
                      }
                      __int16 v27 = v30;
                    }
                    while (v30 != v26);
                    uint64_t v23 = *(void *)buf;
                    uint64_t v22 = *(void *)&buf[8];
                  }
                  ++v24;
                }
                while (0xAAAAAAAAAAAAAAABLL * ((v22 - v23) >> 3) > v24);
              }
              unint64_t v32 = v12[3];
              __int16 v33 = (unint64_t *)v12[2];
              if ((unint64_t)v33 >= v32)
              {
                uint64_t v35 = ((char *)v33 - *v15) >> 3;
                if ((unint64_t)(v35 + 1) >> 61) {
                  std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v36 = v32 - (void)*v15;
                uint64_t v37 = v36 >> 2;
                if (v36 >> 2 <= (unint64_t)(v35 + 1)) {
                  uint64_t v37 = v35 + 1;
                }
                if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v38 = v37;
                }
                if (v38) {
                  uint64_t v39 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)(v12 + 3), v38);
                }
                else {
                  uint64_t v39 = 0;
                }
                __int16 v40 = (unint64_t *)&v39[8 * v35];
                *__int16 v40 = v19;
                unsigned int v34 = v40 + 1;
                __int16 v42 = (char *)v12[1];
                uint64_t v41 = (char *)v12[2];
                if (v41 != v42)
                {
                  do
                  {
                    unint64_t v43 = *((void *)v41 - 1);
                    v41 -= 8;
                    *--__int16 v40 = v43;
                  }
                  while (v41 != v42);
                  uint64_t v41 = *v15;
                }
                v12[1] = (unint64_t)v40;
                v12[2] = (unint64_t)v34;
                void v12[3] = (unint64_t)&v39[8 * v38];
                if (v41) {
                  operator delete(v41);
                }
              }
              else
              {
                *__int16 v33 = v19;
                unsigned int v34 = v33 + 1;
              }
              v12[2] = (unint64_t)v34;
              Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange((uint64_t)a1, (void *)v19, 1);
              if (a4 == 3) {
                Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange((uint64_t)a1, (void *)v19, 2);
              }
              int v66 = (void **)buf;
              std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100](&v66);
            }
            uint64_t v45 = *(void *)(v19 + 104);
            uint64_t v44 = *(void *)(v19 + 112);
            unint64_t v46 = v44 - v45;
            if ((unint64_t)(v44 - v45) > 0x2F)
            {
              if (v46 != 48) {
                *(void *)(v19 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v45 + 48;
              }
            }
            else
            {
              unint64_t v47 = 3 - (v46 >> 4);
              uint64_t v48 = *(void *)(v19 + 120);
              if (v47 <= (v48 - v44) >> 4)
              {
                uint64_t v60 = v44 + 16 * v47;
                do
                {
                  *(_DWORD *)uint64_t v44 = 0x7FFFFFFF;
                  *(void *)(v44 + 8) = 0x7FEFFFFFFFFFFFFFLL;
                  v44 += 16;
                }
                while (v44 != v60);
                *(void *)(v19 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v60;
              }
              else
              {
                unint64_t v49 = v48 - v45;
                unint64_t v50 = (v48 - v45) >> 3;
                if (v50 <= 3) {
                  unint64_t v50 = 3;
                }
                if (v49 >= 0x7FFFFFFFFFFFFFF0) {
                  unint64_t v51 = 0xFFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v51 = v50;
                }
                uint64_t v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>(v19 + 120, v51);
                uint64_t v54 = (v46 >> 4) - 3;
                uint64_t v55 = &v52[16 * (v46 >> 4) + 8];
                do
                {
                  *((_DWORD *)v55 - 2) = 0x7FFFFFFF;
                  *(void *)uint64_t v55 = 0x7FEFFFFFFFFFFFFFLL;
                  v55 += 16;
                }
                while (!__CFADD__(v54++, 1));
                __int16 v57 = &v52[16 * (v46 >> 4)];
                std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v59 = *(char **)(v19 + 104);
                int64_t v58 = *(char **)(v19 + 112);
                if (v58 != v59)
                {
                  do
                  {
                    *((_OWORD *)v57 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((_OWORD *)v58 - 1);
                    v57 -= 16;
                    v58 -= 16;
                  }
                  while (v58 != v59);
                  int64_t v58 = *(char **)(v19 + 104);
                }
                uint64_t v10 = (uint64_t)a1;
                *(void *)(v19 + 104) = v57;
                *(void *)(v19 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v52 + 48;
                *(void *)(v19 + 120) = &v52[16 * v53];
                if (v58) {
                  operator delete(v58);
                }
              }
            }
            uint64_t v61 = *(void *)(v19 + 104);
            *(_DWORD *)uint64_t v61 = 0;
            *(void *)(v61 + 8) = 0x3F50624DE0000000;
            *(_DWORD *)(v61 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
            *(double *)(v61 + 24) = v14;
            *(_DWORD *)(v61 + 32) = 2;
            *(double *)(v61 + 40) = v13;
            v12 += 4;
          }
          while (v12 != v63);
        }
      }
      Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange((void *)v10, Generator, a4, v11);
    }
    return 0;
  }
  else
  {
    UniqueObjectId v8 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      unint64_t v9 = Phase::Controller::DVM::kPlayStateStrings[a4];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2395;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&uint8_t buf[20] = a1;
      __int16 v68 = 2080;
      uint64_t v69 = v9;
      __int16 v70 = 2048;
      unint64_t v71 = a2;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: state change request %s, generatorId %llu does not exist!", buf, 0x30u);
    }
    return 3;
  }
}

void sub_221F1B330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14, char a15)
{
  a14 = (void **)&a15;
  std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100](&a14);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::ConfigureGeneratorWithRenderCallback(uint64_t a1, unint64_t a2, unint64_t a3, int a4, char *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v144 = *MEMORY[0x263EF8340];
  *(void *)buf = a2;
  *(void *)&uint8_t buf[8] = a3;
  UniqueObjectId v7 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)(a1 + 96), buf);
  if (v7)
  {
    if ((a4 - 3) <= 0xFFFFFFFD)
    {
      UniqueObjectId v8 = **(id **)(Phase::Logger::GetInstance(v7) + 80);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        int v9 = a5[40];
        uint64_t v10 = Phase::Controller::DVM::kPlayStateStrings[a4];
        *(_DWORD *)buf = 136316418;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 876;
        __int16 v138 = 2048;
        uint64_t v139 = a1;
        __int16 v140 = 1024;
        *(_DWORD *)int v141 = v9;
        *(_WORD *)&v141[4] = 2048;
        *(void *)&v141[6] = a2;
        __int16 v142 = 2080;
        *(void *)uint64_t v143 = v10;
        float v11 = "%25s:%-5d graph@%p: generatorType %d, generatorId %llu invalid play state %s!";
        uint64_t v12 = v8;
        uint32_t v13 = 54;
LABEL_37:
        _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, v11, buf, v13);
        return 1;
      }
      return 1;
    }
    if (a5[40] == 1)
    {
      UniqueObjectId v7 = (Phase::Logger *)(*(uint64_t (**)(char *))(*(void *)a5 + 24))(a5);
      if (v7 && *((unsigned char *)v7 + 56))
      {
        int v124 = 1;
LABEL_15:
        if (a7)
        {
          unint64_t v16 = (unsigned __int8 *)(*(uint64_t (**)(char *))(*(void *)a5 + 16))(a5);
          uint64_t v17 = v16;
          if (a5[40] || !v16 || v16[56] - 1 >= 4)
          {
            uint64_t v39 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v16) + 80);
            if (!os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
              return 1;
            }
            int v40 = a5[40];
            if (v17) {
              int v41 = (char)v17[56];
            }
            else {
              int v41 = -1;
            }
            uint64_t v44 = Phase::Controller::DVM::kPlayStateStrings[a4];
            *(_DWORD *)buf = 136316674;
            *(void *)&uint8_t buf[4] = "DVMGraph.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 924;
            __int16 v138 = 2048;
            uint64_t v139 = a1;
            __int16 v140 = 1024;
            *(_DWORD *)int v141 = v40;
            *(_WORD *)&v141[4] = 2048;
            *(void *)&v141[6] = a2;
            __int16 v142 = 1024;
            *(_DWORD *)uint64_t v143 = v41;
            *(_WORD *)&v143[4] = 2080;
            *(void *)&v143[6] = v44;
            float v11 = "%25s:%-5d graph@%p: generatorType %d, generatorId %llu, sampler type %d, play state %s - render callba"
                  "ck is only supported on streaming samplers!";
            uint64_t v12 = v39;
            uint32_t v13 = 60;
            goto LABEL_37;
          }
        }
        *(void *)(a1 + 88) |= 8uLL;
        v145.mStorage[0] = a2;
        v145.mStorage[1] = a3;
        SubmixForuint64_t Generator = Phase::Controller::DVM::VoiceGraph::GetSubmixForGenerator((Phase::Controller::DVM::VoiceGraph *)a1, v145);
        uint64_t Generator = Phase::Controller::DVM::VoiceGraph::GetGenerator((Phase::Controller::DVM::VoiceGraph *)a1, a2, a3);
        uint64_t v19 = Generator;
        unint64_t v20 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*((void *)a5 + 3) - *((void *)a5 + 2)) >> 3);
        uint64_t v21 = *(char **)(Generator + 72);
        uint64_t v22 = *(char **)(Generator + 80);
        unint64_t v23 = (v22 - v21) >> 5;
        if (v20 <= v23)
        {
          uint64_t i = (Phase::Controller::DVM::VoiceGraph *)a1;
          if (v20 < v23)
          {
            __int16 v42 = &v21[0xD89D89D89D89D8A0 * ((uint64_t)(*((void *)a5 + 3) - *((void *)a5 + 2)) >> 3)];
            while (v22 != v42)
            {
              unint64_t v43 = (void *)*((void *)v22 - 3);
              if (v43)
              {
                *((void *)v22 - 2) = v43;
                operator delete(v43);
              }
              v22 -= 32;
            }
            *(void *)(v19 + 80) = v42;
          }
        }
        else
        {
          unint64_t v24 = v20 - v23;
          uint64_t v25 = *(void *)(Generator + 88);
          uint64_t i = (Phase::Controller::DVM::VoiceGraph *)a1;
          if (v20 - v23 <= (v25 - (uint64_t)v22) >> 5)
          {
            bzero(*(void **)(Generator + 80), 32 * v24);
            *(void *)(v19 + 80) = &v22[32 * v24];
          }
          else
          {
            if (v20 >> 59) {
              std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v27 = v25 - (void)v21;
            if (v27 >> 4 > v20) {
              unint64_t v20 = v27 >> 4;
            }
            if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v28 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v28 = v20;
            }
            if (v28 >> 59) {
              std::__throw_bad_array_new_length[abi:ne180100]();
            }
            __int16 v29 = (char *)operator new(32 * v28);
            unint64_t v30 = &v29[32 * v23];
            BOOL v31 = &v29[32 * v28];
            bzero(v30, 32 * v24);
            unint64_t v32 = &v30[32 * v24];
            if (v22 == v21)
            {
              *(void *)(v19 + 72) = v30;
              *(void *)(v19 + 80) = v32;
              *(void *)(v19 + 88) = v31;
              uint64_t i = (Phase::Controller::DVM::VoiceGraph *)a1;
            }
            else
            {
              do
              {
                long long v33 = *((_OWORD *)v22 - 2);
                v22 -= 32;
                *((_OWORD *)v30 - 2) = v33;
                v30 -= 32;
                *((void *)v30 + 2) = *((void *)v22 + 2);
                *((void *)v30 + 3) = *((void *)v22 + 3);
                *((void *)v22 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
                *((void *)v22 + 2) = 0;
                *((void *)v22 + 3) = 0;
              }
              while (v22 != v21);
              uint64_t v22 = *(char **)(v19 + 72);
              unsigned int v34 = *(char **)(v19 + 80);
              *(void *)(v19 + 72) = v30;
              *(void *)(v19 + 80) = v32;
              *(void *)(v19 + 88) = v31;
              for (uint64_t i = (Phase::Controller::DVM::VoiceGraph *)a1; v34 != v22; v34 -= 32)
              {
                uint64_t v35 = (void *)*((void *)v34 - 3);
                if (v35)
                {
                  *((void *)v34 - 2) = v35;
                  operator delete(v35);
                }
              }
            }
            if (v22) {
              operator delete(v22);
            }
          }
        }
        uint64_t v45 = *(void *)(v19 + 72);
        if (*(void *)(v19 + 80) != v45)
        {
          unint64_t v46 = 0;
          int v47 = 0x100000;
          char v123 = 1;
          while (1)
          {
            VoiceNode = Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode((uint64_t)i, *((void *)a5 + 1), *(void *)(*((void *)a5 + 2) + 104 * v46), v124, 0x100000, (uint64_t)a5);
            Phase::Controller::DVM::VoiceNode::Configure((uint64_t)VoiceNode, *((void *)a5 + 2), *((void *)a5 + 3), v46, v47, a7);
            unint64_t v49 = (unint64_t *)(v45 + 32 * v46);
            unint64_t v50 = (const void **)(v49 + 1);
            uint64_t v52 = (uint64_t *)(v49 + 2);
            unint64_t v51 = v49[2];
            if (v49[1] == v51) {
              uint64_t v53 = (unint64_t *)(v45 + 32 * v46);
            }
            else {
              uint64_t v53 = (unint64_t *)(v51 - 8);
            }
            if (*v53) {
              Phase::Controller::DVM::VoiceNode::Disconnect(*v53, 0);
            }
            unint64_t v54 = *v49;
            if (*v49 && (_DWORD *)v54 != VoiceNode)
            {
              Phase::Controller::DVM::VoiceNode::Disconnect(*v49, 1);
              Phase::Controller::DVM::VoiceNode::Disconnect(v54, 0);
            }
            *unint64_t v49 = (unint64_t)VoiceNode;
            (*(void (**)(uint64_t, char *))(*(void *)v19 + 48))(v19, a5);
            std::string __p = 0;
            unsigned int v135 = 0;
            uint64_t v136 = 0;
            std::vector<Phase::Controller::DVM::VoiceNode *>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode **,Phase::Controller::DVM::VoiceNode **>(&__p, *v50, *v52, (*v52 - (uint64_t)*v50) >> 3);
            uint8x8_t v126 = (unint64_t *)(v45 + 32 * v46);
            int v56 = (char *)*v50;
            *uint64_t v52 = (uint64_t)*v50;
            uint64_t v57 = *a6;
            uint64_t v58 = a6[1];
            if (*a6 == v58) {
              break;
            }
            std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v59 = (void *)(v45 + 32 * v46 + 24);
            while (1)
            {
              uint64_t v60 = *(void *)(v57 + 8);
              if (0x4EC4EC4EC4EC4EC5 * ((*(void *)(v57 + 16) - v60) >> 3) != (uint64_t)(*(void *)(v19 + 80)
                                                                                          - *(void *)(v19 + 72)) >> 5)
                goto LABEL_163;
              unint64_t v61 = (unint64_t)VoiceNode;
              int v62 = Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode(a1, *(void *)v57, *(void *)(v60 + 104 * v46), 6, v47, 0);
              VoiceNode = v62;
              if (!v62) {
                goto LABEL_108;
              }
              Phase::Controller::DVM::VoiceNode::Configure((uint64_t)v62, *(void *)(v57 + 8), *(void *)(v57 + 16), v46, v47, 0);
              uint64_t v63 = (Phase::Logger *)Phase::Controller::DVM::VoiceNode::ConnectToNode(v61, (uint64_t)VoiceNode);
              ++v47;
              if (!v63) {
                break;
              }
              unint64_t v64 = (char *)*v52;
              if ((unint64_t)*v52 >= *v59)
              {
                uint64_t v65 = (v64 - (unsigned char *)*v50) >> 3;
                if ((unint64_t)(v65 + 1) >> 61) {
                  std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
                }
                uint64_t v66 = *v59 - (void)*v50;
                uint64_t v67 = v66 >> 2;
                if (v66 >> 2 <= (unint64_t)(v65 + 1)) {
                  uint64_t v67 = v65 + 1;
                }
                if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v55 = v67;
                }
                if (v55) {
                  __int16 v68 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)v59, v55);
                }
                else {
                  __int16 v68 = 0;
                }
                uint64_t v69 = &v68[8 * v65];
                *(void *)uint64_t v69 = VoiceNode;
                int v56 = v69 + 8;
                __int16 v70 = (char *)*v52;
                unint64_t v71 = (char *)*v50;
                if ((const void *)*v52 != *v50)
                {
                  do
                  {
                    uint64_t v72 = *((void *)v70 - 1);
                    v70 -= 8;
                    *((void *)v69 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v72;
                    v69 -= 8;
                  }
                  while (v70 != v71);
                  __int16 v70 = (char *)*v50;
                }
                unint64_t *v50 = v69;
                *uint64_t v52 = (uint64_t)v56;
                void *v59 = &v68[8 * v55];
                if (v70) {
                  operator delete(v70);
                }
              }
              else
              {
                *(void *)unint64_t v64 = VoiceNode;
                int v56 = v64 + 8;
              }
              *uint64_t v52 = (uint64_t)v56;
              v57 += 32;
              if (v57 == v58) {
                goto LABEL_88;
              }
            }
            uint8x8_t v82 = **(id **)(Phase::Logger::GetInstance(v63) + 80);
            if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
            {
              uint64_t v83 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(v61 + 24)];
              int v84 = a5[40];
              unint64_t v85 = Phase::Controller::DVM::kVoiceTypeStrings[VoiceNode[6]];
              *(_DWORD *)buf = 136316674;
              *(void *)&uint8_t buf[4] = "DVMGraph.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 1001;
              __int16 v138 = 2048;
              uint64_t i = (Phase::Controller::DVM::VoiceGraph *)a1;
              uint64_t v139 = a1;
              __int16 v140 = 1024;
              *(_DWORD *)int v141 = v84;
              *(_WORD *)&v141[4] = 2048;
              *(void *)&v141[6] = a2;
              __int16 v142 = 2080;
              *(void *)uint64_t v143 = v83;
              *(_WORD *)&v143[8] = 2080;
              *(void *)&v143[10] = v85;
              _os_log_impl(&dword_221E5E000, v82, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: generatorType %d, generatorId %llu: unable to connect %s -> %s!", buf, 0x40u);
              char v86 = 0;
              char v123 = 8;
            }
            else
            {
LABEL_108:
              char v86 = 0;
              char v123 = 8;
              uint64_t i = (Phase::Controller::DVM::VoiceGraph *)a1;
            }
LABEL_120:
            if (__p)
            {
              unsigned int v135 = (Phase::Controller::DVM::VoiceGraph **)__p;
              operator delete(__p);
            }
            if ((v86 & 1) == 0) {
              return v123;
            }
            ++v46;
            uint64_t v45 = *(void *)(v19 + 72);
            if (v46 >= (*(void *)(v19 + 80) - v45) >> 5) {
              goto LABEL_124;
            }
          }
LABEL_88:
          unint64_t v73 = (Phase::Controller::DVM::VoiceGraph **)__p;
          unint64_t v74 = v135;
          uint64_t i = (Phase::Controller::DVM::VoiceGraph *)a1;
          if (__p != v135)
          {
            do
            {
              int v75 = *v73;
              uint64_t v76 = *v52;
              for (uint64_t j = (Phase::Controller::DVM::VoiceGraph **)*v50; j != (Phase::Controller::DVM::VoiceGraph **)v76; ++j)
              {
                if (*j == v75) {
                  goto LABEL_94;
                }
              }
              uint64_t j = (Phase::Controller::DVM::VoiceGraph **)*v52;
LABEL_94:
              if ((Phase::Controller::DVM::VoiceGraph **)v76 == j) {
                Phase::Controller::DVM::VoiceGraph::ScheduleRemoveVoice(v75, (Phase::Controller::DVM::VoiceNode *)v55);
              }
              ++v73;
            }
            while (v73 != v74);
            int v56 = (char *)*v52;
          }
          double v78 = v126;
          if (*v50 != v56) {
            double v78 = (unint64_t *)(v56 - 8);
          }
          unint64_t v79 = *v78;
          if (!*v78) {
            __assert_rtn("ConfigureGeneratorWithRenderCallback", "DVMGraph.mm", 1022, "tailNode != nullptr");
          }
          unint64_t v80 = SubmixForGenerator[7];
          if (v80 == 3)
          {
            unint64_t v89 = SubmixForGenerator[9];
            if (0x8E38E38E38E38E39 * ((uint64_t)(SubmixForGenerator[10] - v89) >> 3) != (uint64_t)(*(void *)(v19 + 80)
                                                                                                  - *(void *)(v19 + 72)) >> 5)
              goto LABEL_163;
            Phase::Controller::DVM::Submix::ChannelStrip::GetHeadNodes((uint64_t **)(v89 + 72 * v46), buf);
          }
          else
          {
            if (v80 == 2)
            {
              unint64_t v87 = SubmixForGenerator[9];
              if (0x8E38E38E38E38E39 * ((uint64_t)(SubmixForGenerator[10] - v87) >> 3) != (uint64_t)(*(void *)(v19 + 80) - *(void *)(v19 + 72)) >> 5) {
                goto LABEL_163;
              }
              uint64_t v88 = *(void *)(v87 + 72 * v46 + 64);
              if (!v88) {
                goto LABEL_119;
              }
              unint64_t v81 = *(uint64_t ***)(v88 + 72);
              if (*(void *)(v88 + 80) - (void)v81 != 72) {
                goto LABEL_163;
              }
            }
            else
            {
              if (v80 != 1) {
                __assert_rtn("ConfigureGeneratorWithRenderCallback", "DVMGraph.mm", 1055, "false");
              }
              unint64_t v81 = (uint64_t **)SubmixForGenerator[9];
              if (SubmixForGenerator[10] - (void)v81 != 72) {
LABEL_163:
              }
                std::terminate();
            }
            Phase::Controller::DVM::Submix::ChannelStrip::GetHeadNodes(v81, buf);
          }
          unint64_t v91 = *(void **)buf;
          uint64_t v90 = *(uint64_t **)&buf[8];
          for (uint64_t k = *(uint64_t **)buf; k != v90; ++k)
            Phase::Controller::DVM::VoiceNode::ConnectToNode(v79, *k);
          if (v91) {
            operator delete(v91);
          }
LABEL_119:
          char v86 = 1;
          goto LABEL_120;
        }
LABEL_124:
        Phase::Controller::DVM::VoiceGraph::SetGeneratorPlayState(i, a2, a3, a4);
        if ((*(unsigned int (**)(uint64_t))(*(void *)v19 + 56))(v19))
        {
          uint64_t v93 = *(void *)(v19 + 72);
          uint64_t v94 = *(void *)(v19 + 80);
          if (v93 != v94)
          {
            unint64_t v95 = (void *)(a1 + 760);
            while (1)
            {
              unint64_t v96 = (*(uint64_t (**)(void))(**(void **)v93 + 16))();
              unint64_t v97 = v96;
              uint64_t v98 = *(void *)(*(void *)v93 + 16);
              uint64_t v99 = (void *)*v95;
              __int16 v100 = (void *)(a1 + 760);
              unint64_t v101 = (void *)(a1 + 760);
              if (*v95) {
                break;
              }
LABEL_136:
              uint64_t v104 = operator new(0x40uLL);
              v104[4] = v97;
              v104[5] = v98;
              *((_OWORD *)v104 + 3) = *(_OWORD *)(v19 + 16);
              *uint64_t v104 = 0;
              v104[1] = 0;
              v104[2] = v101;
              *__int16 v100 = v104;
              uint64_t v105 = **(void **)(a1 + 752);
              if (v105)
              {
                *(void *)(a1 + 752) = v105;
                uint64_t v104 = (void *)*v100;
              }
              std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 760), v104);
              ++*(void *)(a1 + 768);
LABEL_139:
              v93 += 32;
              if (v93 == v94) {
                goto LABEL_157;
              }
            }
            while (1)
            {
              while (1)
              {
                unint64_t v101 = v99;
                unint64_t v102 = v99[4];
                if (v102 <= v96) {
                  break;
                }
LABEL_129:
                uint64_t v99 = (void *)*v101;
                __int16 v100 = v101;
                if (!*v101) {
                  goto LABEL_136;
                }
              }
              if (v102 >= v96)
              {
                uint64_t v103 = v101[5];
                if (v103 > v98) {
                  goto LABEL_129;
                }
                if (v103 >= v98) {
                  goto LABEL_139;
                }
              }
              uint64_t v99 = (void *)v101[1];
              if (!v99)
              {
                __int16 v100 = v101 + 1;
                goto LABEL_136;
              }
            }
          }
          goto LABEL_157;
        }
        if (!a7 || (int v106 = *(uint64_t **)(v19 + 72), v107 = *(uint64_t **)(v19 + 80), v106 == v107))
        {
LABEL_157:
          (*(void (**)(unsigned char *__return_ptr))(*SubmixForGenerator + 40))(buf);
          uint64_t v120 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
          unint64_t v121 = 0x8E38E38E38E38E39 * ((uint64_t)(SubmixForGenerator[10] - SubmixForGenerator[9]) >> 3);
          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          __n128 v122 = (Phase::Logger *)a1;
          if (v120 == v121) {
            Phase::Controller::DVM::VoiceGraph::ConnectSubmixToTaps((Phase::Controller::DVM::VoiceGraph *)a1, SubmixForGenerator[2], SubmixForGenerator[3]);
          }
          Phase::Logger::GetInstance(v122);
          return 0;
        }
        int v108 = (uint64_t **)(a1 + 784);
        while (1)
        {
          unint64_t v109 = (*(uint64_t (**)(void))(*(void *)*v106 + 16))();
          unint64_t v110 = v109;
          uint64_t v111 = *v106;
          uint64_t v112 = *(void *)(*v106 + 16);
          unint64_t v113 = *v108;
          uint8x8_t v114 = (uint64_t **)(a1 + 784);
          uint64_t v115 = (uint64_t **)(a1 + 784);
          if (*v108) {
            break;
          }
LABEL_153:
          unint64_t v118 = (uint64_t *)operator new(0x38uLL);
          void v118[4] = v110;
          v118[5] = v112;
          v118[6] = v111;
          *unint64_t v118 = 0;
          v118[1] = 0;
          v118[2] = (uint64_t)v115;
          *uint8x8_t v114 = v118;
          uint64_t v119 = **(void **)(a1 + 776);
          if (v119)
          {
            *(void *)(a1 + 77std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v119;
            unint64_t v118 = *v114;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 784), v118);
          ++*(void *)(a1 + 792);
LABEL_156:
          v106 += 4;
          if (v106 == v107) {
            goto LABEL_157;
          }
        }
        while (1)
        {
          while (1)
          {
            uint64_t v115 = (uint64_t **)v113;
            unint64_t v116 = v113[4];
            if (v116 <= v109) {
              break;
            }
LABEL_146:
            unint64_t v113 = *v115;
            uint8x8_t v114 = v115;
            if (!*v115) {
              goto LABEL_153;
            }
          }
          if (v116 >= v109)
          {
            uint64_t v117 = (uint64_t)v115[5];
            if (v117 > v112) {
              goto LABEL_146;
            }
            if (v117 >= v112) {
              goto LABEL_156;
            }
          }
          unint64_t v113 = v115[1];
          if (!v113)
          {
            uint8x8_t v114 = v115 + 1;
            goto LABEL_153;
          }
        }
      }
    }
    else if (!a5[40])
    {
      UniqueObjectId v7 = (Phase::Logger *)(*(uint64_t (**)(char *))(*(void *)a5 + 16))(a5);
      if (v7)
      {
        int v124 = 0;
        goto LABEL_15;
      }
    }
    uint64_t v36 = **(id **)(Phase::Logger::GetInstance(v7) + 80);
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      int v37 = a5[40];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 910;
      __int16 v138 = 2048;
      uint64_t v139 = a1;
      __int16 v140 = 1024;
      *(_DWORD *)int v141 = v37;
      *(_WORD *)&v141[4] = 2048;
      *(void *)&v141[6] = a2;
      float v11 = "%25s:%-5d graph@%p: invalid generatorType %d, generatorId %llu!";
      uint64_t v12 = v36;
      uint32_t v13 = 44;
      goto LABEL_37;
    }
    return 1;
  }
  double v14 = **(id **)(Phase::Logger::GetInstance(0) + 80);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 869;
    __int16 v138 = 2048;
    uint64_t v139 = a1;
    __int16 v140 = 2048;
    *(void *)int v141 = a2;
    _os_log_impl(&dword_221E5E000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: generatorId %llu does not exist!", buf, 0x26u);
  }
  return 3;
}

void sub_221F1C180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::DVM::VoiceNode::Disconnect(unint64_t a1, int a2)
{
  if (a2) {
    uint64_t v2 = 32;
  }
  else {
    uint64_t v2 = 56;
  }
  if (a2) {
    unint64_t v3 = a1 + 32;
  }
  else {
    unint64_t v3 = a1 + 56;
  }
  uint64_t v4 = *(void *)(a1 + v2);
  if (*(void *)(v3 + 8) == v4)
  {
    char v8 = 1;
  }
  else
  {
    unint64_t v7 = 0;
    char v8 = 1;
    do
    {
      std::set<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::set[abi:ne180100]((uint64_t)&v15, v4 + 24 * v7);
      int v9 = v15;
      if (v15 != v16)
      {
        do
        {
          BOOL v10 = Phase::Controller::DVM::VoiceNode::Disconnect(a1, a2, v7, (uint64_t)(v9 + 4));
          float v11 = v9[1];
          if (v11)
          {
            do
            {
              uint64_t v12 = (void **)v11;
              float v11 = (void *)*v11;
            }
            while (v11);
          }
          else
          {
            do
            {
              uint64_t v12 = (void **)v9[2];
              BOOL v13 = *v12 == v9;
              int v9 = v12;
            }
            while (!v13);
          }
          v8 &= v10;
          int v9 = v12;
        }
        while (v12 != v16);
      }
      std::__tree<Phase::SpatialCategory>::destroy((uint64_t)&v15, v16[0]);
      ++v7;
      uint64_t v4 = *(void *)(a1 + v2);
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v3 + 8) - v4) >> 3) > v7);
  }
  return v8 & 1;
}

void sub_221F1C308(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, void *a11)
{
}

void Phase::Controller::DVM::VoiceGraph::ConnectSubmixToTaps(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3)
{
  uint64_t v40 = *MEMORY[0x263EF8340];
  *(void *)uu = a2;
  unint64_t v27 = a3;
  *(void *)buf = a2;
  *(void *)&uint8_t buf[8] = a3;
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 17, buf))
  {
    unint64_t v18 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(0)
                                                                                        + 80)));
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      memset(out, 0, 37);
      uuid_unparse(uu, out);
      std::string::basic_string[abi:ne180100]<0>(__p, out);
      if (v25 >= 0) {
        uint64_t v19 = __p;
      }
      else {
        uint64_t v19 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1331;
      __int16 v29 = 2048;
      unint64_t v30 = a1;
      __int16 v31 = 2080;
      unint64_t v32 = v19;
      unint64_t v20 = "%25s:%-5d graph@%p: submixId %s does not exist";
      uint64_t v21 = v18;
      os_log_type_t v22 = OS_LOG_TYPE_ERROR;
LABEL_27:
      _os_log_impl(&dword_221E5E000, v21, v22, v20, buf, 0x26u);
      if (v25 < 0) {
        operator delete(__p[0]);
      }
    }
LABEL_29:

    return;
  }
  v41.mStorage[0] = a2;
  v41.mStorage[1] = a3;
  uint64_t Submix = Phase::Controller::DVM::VoiceGraph::GetSubmix(a1, v41);
  unint64_t v7 = (Phase::Logger *)(*(void *(**)(unsigned char *__return_ptr))(*Submix + 40))(buf);
  uint64_t v8 = *(void *)buf;
  uint64_t v9 = *(void *)&buf[8];
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  if (v8 == v9)
  {
    unint64_t v18 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v7)
                                                                                        + 80)));
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      memset(out, 0, 37);
      uuid_unparse(uu, out);
      std::string::basic_string[abi:ne180100]<0>(__p, out);
      if (v25 >= 0) {
        unint64_t v23 = __p;
      }
      else {
        unint64_t v23 = (void **)__p[0];
      }
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1339;
      __int16 v29 = 2048;
      unint64_t v30 = a1;
      __int16 v31 = 2080;
      unint64_t v32 = v23;
      unint64_t v20 = "%25s:%-5d graph@%p: submixId %s exists, but has no valid voice nodes yet to connect to taps. No op.";
      uint64_t v21 = v18;
      os_log_type_t v22 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_27;
    }
    goto LABEL_29;
  }
  for (uint64_t i = (void *)*((void *)a1 + 42); i; uint64_t i = (void *)*i)
  {
    float v11 = (float *)std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(i + 11, uu);
    if (v11)
    {
      uint64_t v12 = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::InternalConnectTapToSubmix(a1, i + 3, Submix, (void *)v11 + 4, v11[14]);
      unsigned __int8 v13 = v12;
      if (v12)
      {
        double v14 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v12)
                                                                                            + 80)));
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          unint64_t v15 = (void **)i[5];
          GetTapTypeString(i[20]);
          id v16 = (id)objc_claimAutoreleasedReturnValue();
          memset(out, 0, 37);
          uuid_unparse(uu, out);
          std::string::basic_string[abi:ne180100]<0>(__p, out);
          uint64_t v17 = __p;
          if (v25 < 0) {
            uint64_t v17 = (void **)__p[0];
          }
          *(_DWORD *)buf = 136316674;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1359;
          __int16 v29 = 2048;
          unint64_t v30 = a1;
          __int16 v31 = 2048;
          unint64_t v32 = v15;
          __int16 v33 = 2112;
          id v34 = v16;
          __int16 v35 = 2080;
          uint64_t v36 = v17;
          __int16 v37 = 1024;
          int v38 = v13;
          _os_log_impl(&dword_221E5E000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: failed to connect TapId %llu, type %@ to SubmixId %s with error %hhd", buf, 0x40u);
          if (v25 < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
  }
}

void sub_221F1C718(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::AddTap(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  v65[3] = *MEMORY[0x263EF8340];
  uint64_t v8 = (void **)(a1 + 320);
  uint64_t v9 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 320), a2);
  if (v9)
  {
    BOOL v10 = **(id **)(Phase::Logger::GetInstance(v9) + 944);
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v58 = 136315906;
      *(void *)&v58[4] = "DVMGraph.mm";
      __int16 v59 = 1024;
      int v60 = 1125;
      __int16 v61 = 2048;
      *(void *)int v62 = a1;
      *(_WORD *)&v62[8] = 2048;
      *(void *)&v62[10] = a2;
      _os_log_impl(&dword_221E5E000, v10, OS_LOG_TYPE_DEFAULT, "%25s:%-5d pre-spatialTap@%p: TapId %llu already exist", v58, 0x26u);
    }
    return 4;
  }
  uint64_t v12 = operator new(0xA8uLL);
  *uint64_t v12 = 0;
  v12[1] = a2;
  *((_DWORD *)v12 + 8) = 2;
  void v12[5] = a2;
  v12[6] = 0;
  *((unsigned char *)v12 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((_DWORD *)v12 + 15) = 0;
  *((unsigned char *)v12 + 64) = 0;
  *((unsigned char *)v12 + 68) = 0;
  v12[9] = 0;
  v12[2] = a2;
  void v12[3] = &unk_26D4760E8;
  *((_OWORD *)v12 + 5) = 0u;
  *((_OWORD *)v12 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  v12[14] = 0;
  *((_DWORD *)v12 + 30) = 1065353216;
  v12[19] = 0;
  v12[20] = 0;
  unint64_t v13 = *(void *)(a1 + 328);
  if (v13)
  {
    uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
    v14.i16[0] = vaddlv_u8(v14);
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v15 = a2;
      if (v13 <= a2) {
        unint64_t v15 = a2 % v13;
      }
    }
    else
    {
      unint64_t v15 = (v13 - 1) & a2;
    }
    id v16 = (void *)*((void *)*v8 + v15);
    if (v16)
    {
      for (uint64_t i = (void *)*v16; i; uint64_t i = (void *)*i)
      {
        unint64_t v18 = i[1];
        if (v18 == a2)
        {
          if (i[2] == a2)
          {
            std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,void *>>>::operator()[abi:ne180100](1, v12);
            goto LABEL_76;
          }
        }
        else
        {
          if (v14.u32[0] > 1uLL)
          {
            if (v18 >= v13) {
              v18 %= v13;
            }
          }
          else
          {
            v18 &= v13 - 1;
          }
          if (v18 != v15) {
            break;
          }
        }
      }
    }
  }
  float v19 = (float)(unint64_t)(*(void *)(a1 + 344) + 1);
  float v20 = *(float *)(a1 + 352);
  if (!v13 || (float)(v20 * (float)v13) < v19)
  {
    BOOL v21 = 1;
    if (v13 >= 3) {
      BOOL v21 = (v13 & (v13 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v13);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      int8x8_t prime = (int8x8_t)v23;
    }
    else {
      int8x8_t prime = (int8x8_t)v22;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v13 = *(void *)(a1 + 328);
    }
    if (*(void *)&prime > v13) {
      goto LABEL_111;
    }
    if (*(void *)&prime >= v13) {
      goto LABEL_62;
    }
    unint64_t v31 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 344) / *(float *)(a1 + 352));
    if (v13 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v13), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
    {
      unint64_t v31 = std::__next_prime(v31);
    }
    else
    {
      uint64_t v33 = 1 << -(char)__clz(v31 - 1);
      if (v31 >= 2) {
        unint64_t v31 = v33;
      }
    }
    if (*(void *)&prime <= v31) {
      int8x8_t prime = (int8x8_t)v31;
    }
    if (*(void *)&prime >= v13)
    {
      unint64_t v13 = *(void *)(a1 + 328);
      goto LABEL_62;
    }
    if (prime)
    {
LABEL_111:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      char v25 = operator new(8 * *(void *)&prime);
      uint32_t v26 = *v8;
      NSObject *v8 = v25;
      if (v26) {
        operator delete(v26);
      }
      uint64_t v27 = 0;
      *(int8x8_t *)(a1 + 328) = prime;
      do
        *((void *)*v8 + v27++) = 0;
      while (*(void *)&prime != v27);
      unint64_t v28 = *(void **)(a1 + 336);
      if (v28)
      {
        unint64_t v29 = v28[1];
        uint8x8_t v30 = (uint8x8_t)vcnt_s8(prime);
        v30.i16[0] = vaddlv_u8(v30);
        if (v30.u32[0] > 1uLL)
        {
          if (v29 >= *(void *)&prime) {
            v29 %= *(void *)&prime;
          }
        }
        else
        {
          v29 &= *(void *)&prime - 1;
        }
        *((void *)*v8 + v29) = a1 + 336;
        id v34 = (void *)*v28;
        if (*v28)
        {
          do
          {
            unint64_t v35 = v34[1];
            if (v30.u32[0] > 1uLL)
            {
              if (v35 >= *(void *)&prime) {
                v35 %= *(void *)&prime;
              }
            }
            else
            {
              v35 &= *(void *)&prime - 1;
            }
            if (v35 != v29)
            {
              if (!*((void *)*v8 + v35))
              {
                *((void *)*v8 + v35) = v28;
                goto LABEL_58;
              }
              *unint64_t v28 = *v34;
              *id v34 = **((void **)*v8 + v35);
              **((void **)*v8 + v35) = v34;
              id v34 = v28;
            }
            unint64_t v35 = v29;
LABEL_58:
            unint64_t v28 = v34;
            id v34 = (void *)*v34;
            unint64_t v29 = v35;
          }
          while (v34);
        }
      }
      unint64_t v13 = (unint64_t)prime;
    }
    else
    {
      int v47 = *v8;
      NSObject *v8 = 0;
      if (v47) {
        operator delete(v47);
      }
      unint64_t v13 = 0;
      *(void *)(a1 + 328) = 0;
    }
  }
LABEL_62:
  unint64_t v36 = v12[1];
  uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v13);
  v37.i16[0] = vaddlv_u8(v37);
  if (v37.u32[0] > 1uLL)
  {
    if (v36 >= v13) {
      v36 %= v13;
    }
  }
  else
  {
    v36 &= v13 - 1;
  }
  int v38 = *v8;
  uint64_t v39 = (void *)*((void *)*v8 + v36);
  if (v39)
  {
    *uint64_t v12 = *v39;
LABEL_74:
    *uint64_t v39 = v12;
    goto LABEL_75;
  }
  *uint64_t v12 = *(void *)(a1 + 336);
  *(void *)(a1 + 33std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v12;
  v38[v36] = a1 + 336;
  if (*v12)
  {
    unint64_t v40 = *(void *)(*v12 + 8);
    if (v37.u32[0] > 1uLL)
    {
      if (v40 >= v13) {
        v40 %= v13;
      }
    }
    else
    {
      v40 &= v13 - 1;
    }
    uint64_t v39 = (char *)*v8 + 8 * v40;
    goto LABEL_74;
  }
LABEL_75:
  ++*(void *)(a1 + 344);
LABEL_76:
  UniqueObjectId v41 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v8, a2);
  if (v41)
  {
    __int16 v42 = v41;
    std::__function::__value_func<void ()(float *,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v58, a3);
    unint64_t v43 = v42 + 16;
    if (v58 != (unsigned char *)(v42 + 16))
    {
      uint64_t v44 = *(void *)&v62[4];
      uint64_t v45 = (void *)v42[19];
      if (*(unsigned char **)&v62[4] == v58)
      {
        if (v45 == v43)
        {
          (*(void (**)(unsigned char *, void *))(*(void *)v58 + 24))(v58, v65);
          (*(void (**)(void))(**(void **)&v62[4] + 32))(*(void *)&v62[4]);
          *(void *)&v62[4] = 0;
          (*(void (**)(void, unsigned char *))(*(void *)v42[19] + 24))(v42[19], v58);
          (*(void (**)(void))(*(void *)v42[19] + 32))(v42[19]);
          v42[19] = 0;
          *(void *)&v62[4] = v58;
          (*(void (**)(void *, void *))(v65[0] + 24))(v65, v42 + 16);
          (*(void (**)(void *))(v65[0] + 32))(v65);
        }
        else
        {
          (*(void (**)(unsigned char *, void *))(*(void *)v58 + 24))(v58, v42 + 16);
          (*(void (**)(void))(**(void **)&v62[4] + 32))(*(void *)&v62[4]);
          *(void *)&v62[4] = v42[19];
        }
        v42[19] = v43;
      }
      else if (v45 == v43)
      {
        (*(void (**)(void *, unsigned char *))(*v43 + 24))(v42 + 16, v58);
        (*(void (**)(void))(*(void *)v42[19] + 32))(v42[19]);
        v42[19] = *(void *)&v62[4];
        *(void *)&v62[4] = v58;
      }
      else
      {
        *(void *)&v62[4] = v42[19];
        v42[19] = v44;
      }
    }
    std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100](v58);
    v42[20] = a4;
    std::mutex::lock((std::mutex *)(a1 + 256));
    uint64_t v48 = (_DWORD *)atomic_load((unint64_t *)(a1 + 216));
    int v49 = *(_DWORD *)(a1 + 208) + 1;
    *(_DWORD *)(a1 + 208) = v49;
    if (v48)
    {
      unsigned int v50 = 16 * v49;
      unsigned int v51 = v48[2];
      if (v50 / v51 < 0xB)
      {
LABEL_103:
        unint64_t v54 = v42 + 3;
        if ((caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl::findSlotForKey((uint64_t)v48, a2) & 1) == 0)operator new(); {
        *(void *)(v53 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v54;
        }
        --*(_DWORD *)(a1 + 208);
        std::mutex::unlock((std::mutex *)(a1 + 256));
        int v56 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v55)
                                                                                            + 944)));
        if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v57 = GetTapTypeString(a4);
          *(_DWORD *)uint64_t v58 = 136316162;
          *(void *)&v58[4] = "DVMGraph.mm";
          __int16 v59 = 1024;
          int v60 = 1141;
          __int16 v61 = 2048;
          *(void *)int v62 = a1;
          *(_WORD *)&v62[8] = 2048;
          *(void *)&v62[10] = a2;
          __int16 v63 = 2112;
          unint64_t v64 = v57;
          _os_log_impl(&dword_221E5E000, v56, OS_LOG_TYPE_DEFAULT, "%25s:%-5d pre-spatialTap@%p: TapId %llu, type %@ added!", v58, 0x30u);
        }
        return 0;
      }
      unsigned int v52 = 2 * v51;
    }
    else
    {
      unsigned int v52 = 8;
    }
    uint64_t v48 = caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::rehash((unint64_t *)(a1 + 176), v52);
    goto LABEL_103;
  }
  unint64_t v46 = **(id **)(Phase::Logger::GetInstance(0) + 80);
  if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint64_t v58 = 136315906;
    *(void *)&v58[4] = "DVMGraph.mm";
    __int16 v59 = 1024;
    int v60 = 1134;
    __int16 v61 = 2048;
    *(void *)int v62 = a1;
    *(_WORD *)&v62[8] = 2048;
    *(void *)&v62[10] = a2;
    _os_log_impl(&dword_221E5E000, v46, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: Error adding TapId %llu!", v58, 0x26u);
  }
  return 3;
}

void sub_221F1D0A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::ConfigureTap(void *a1, unint64_t a2, int a3, uint64_t a4)
{
  uint64_t v35 = *MEMORY[0x263EF8340];
  uint64_t v8 = a1 + 40;
  uint64_t v9 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(a1 + 40, a2);
  if (v9)
  {
    if ((a3 - 3) <= 0xFFFFFFFD)
    {
      BOOL v10 = v9;
      float v11 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v9)
                                                                                          + 80)));
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        uint64_t v12 = GetTapTypeString(*((void *)v10 + 20));
        unint64_t v13 = Phase::Controller::DVM::kPlayStateStrings[a3];
        int v23 = 136316418;
        unint64_t v24 = "DVMGraph.mm";
        __int16 v25 = 1024;
        int v26 = 1157;
        __int16 v27 = 2048;
        unint64_t v28 = a1;
        __int16 v29 = 2048;
        unint64_t v30 = a2;
        __int16 v31 = 2112;
        uint8x8_t v32 = v12;
        __int16 v33 = 2080;
        id v34 = v13;
        _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: TapId %llu, type %@ invalid play state %s!", (uint8_t *)&v23, 0x3Au);
      }
      return 1;
    }
    id v16 = *(unint64_t **)(a4 + 8);
    if (*(void *)(a4 + 16) - (void)v16 != 104) {
      std::terminate();
    }
    VoiceNode = Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode((uint64_t)a1, *(void *)a4, *v16, 5, 3145728, 0);
    if (VoiceNode)
    {
      uint64_t v18 = (uint64_t)VoiceNode;
      a1[11] |= 8uLL;
      float v19 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v8, a2);
      uint64_t v20 = (uint64_t)(v19 + 3);
      Phase::Controller::DVM::VoiceNode::Configure(v18, *(void *)(a4 + 8), *(void *)(a4 + 16), 0, 3145728, 0);
      unint64_t v21 = v19[10];
      if (v21 && v21 != v18)
      {
        Phase::Controller::DVM::VoiceNode::Disconnect(v19[10], 1);
        Phase::Controller::DVM::VoiceNode::Disconnect(v21, 0);
      }
      v19[10] = v18;
      int v22 = Phase::Controller::DVM::VoiceGraph::PreprocessPlayStateChange((uint64_t)a1, v20, a3);
      if (v22 != 8)
      {
        if (v22 == 4) {
          return 1;
        }
        Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(a1, v20, a3, 0.0);
      }
      return 0;
    }
    else
    {
      return 8;
    }
  }
  else
  {
    unint64_t v15 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      int v23 = 136315906;
      unint64_t v24 = "DVMGraph.mm";
      __int16 v25 = 1024;
      int v26 = 1150;
      __int16 v27 = 2048;
      unint64_t v28 = a1;
      __int16 v29 = 2048;
      unint64_t v30 = a2;
      _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: TapId %llu does not exists!", (uint8_t *)&v23, 0x26u);
    }
    return 3;
  }
}

void sub_221F1D3B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::PreprocessPlayStateChange(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a2 + 40);
  uint64_t v15 = v6;
  uint64_t PlayStateTransitionStatus = Phase::Controller::DVM::VoiceGraph::GetPlayStateTransitionStatus(a1, (int *)&v15, a3);
  if (PlayStateTransitionStatus <= 2)
  {
    uint64_t v8 = (Phase::Logger *)(*(void *(**)(unsigned char *__return_ptr, uint64_t))(*(void *)a2 + 40))(buf, a2);
    uint64_t v9 = *(void *)buf;
    uint64_t v10 = *(void *)&buf[8];
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (v9 == v10)
    {
      float v11 = **(id **)(Phase::Logger::GetInstance(v8) + 80);
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        if ((v6 & 0xFF00000000) != 0) {
          uint64_t v12 = Phase::Controller::DVM::kPlayStateStrings[(int)v6];
        }
        else {
          uint64_t v12 = "none";
        }
        unint64_t v13 = Phase::Controller::DVM::kPlayStateStrings[a3];
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 2309;
        __int16 v17 = 2048;
        uint64_t v18 = a1;
        __int16 v19 = 2080;
        uint64_t v20 = v12;
        __int16 v21 = 2080;
        int v22 = v13;
        _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d graph@%p: Empty DSPNode, processing state transition from %s to %s immediately!", buf, 0x30u);
      }
      *(unsigned char *)(a2 + 44) = 1;
      *(unsigned char *)(a2 + 32) = 0;
      *(_DWORD *)(a2 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
      *(_DWORD *)(a2 + 40) = a3;
      if (!a3) {
        Phase::Controller::DVM::VoiceGraph::InternalRemoveNode(a1, *(_DWORD *)(a2 + 8), *(void *)(a2 + 16), *(void *)(a2 + 24), 0);
      }
      return 8;
    }
  }
  return PlayStateTransitionStatus;
}

void Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(void *a1, uint64_t a2, int a3, float a4)
{
  uint64_t v108 = *MEMORY[0x263EF8340];
  (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a2 + 32))(&__p, a2);
  uint64_t v8 = a1 + 82;
  uint64_t v9 = a1[83];
  if ((void *)v9 != a1 + 82)
  {
    do
    {
      int v10 = *(_DWORD *)(v9 + 32);
      if (v10 == *(_DWORD *)(a2 + 8)
        && *(void *)(v9 + 40) == *(void *)(a2 + 16)
        && *(void *)(v9 + 48) == *(void *)(a2 + 24))
      {
        if (a4 < *(float *)(v9 + 28)) {
          a4 = *(float *)(v9 + 28);
        }
      }
      else if (__p != v92)
      {
        float v11 = (uint64_t *)__p;
        do
        {
          uint64_t v12 = *v11;
          if (!*v11) {
            std::terminate();
          }
          if (v10 == *(_DWORD *)(v12 + 8)
            && *(void *)(v9 + 40) == *(void *)(v12 + 16)
            && *(void *)(v9 + 48) == *(void *)(v12 + 24)
            && a4 < *(float *)(v9 + 28))
          {
            a4 = *(float *)(v9 + 28);
          }
          ++v11;
        }
        while (v11 != v92);
      }
      uint64_t v9 = *(void *)(v9 + 8);
    }
    while ((void *)v9 != v8);
  }
  if (a3 == 2)
  {
    int v13 = *(_DWORD *)(a2 + 36);
    BOOL v83 = v13 == 0;
    if (!v13 && a4 == 0.0)
    {
      int v14 = *(_DWORD *)(a2 + 8);
      uint64_t v15 = *(void *)(a2 + 16);
      uint64_t v16 = *(void *)(a2 + 24);
      __int16 v17 = (float *)operator new(0x38uLL);
      BOOL v83 = 1;
      *((_DWORD *)v17 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
      v17[7] = a4;
      *((void *)v17 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v8;
      *((void *)v17 + 2) = &unk_26D4761E8;
      *((_DWORD *)v17 + 8) = v14;
      *((void *)v17 + 5) = v15;
      *((void *)v17 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v16;
      uint64_t v18 = a1[82];
      *(void *)__int16 v17 = v18;
      *(void *)(v18 + 8) = v17;
      a1[82] = v17;
      ++a1[84];
    }
  }
  else
  {
    BOOL v83 = 0;
  }
  int v19 = *(_DWORD *)(a2 + 8);
  uint64_t v20 = *(void *)(a2 + 16);
  uint64_t v21 = *(void *)(a2 + 24);
  int v22 = (float *)operator new(0x38uLL);
  *((_DWORD *)v22 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
  _DWORD v22[7] = a4;
  *((void *)v22 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v8;
  *((void *)v22 + 2) = &unk_26D4761E8;
  *((_DWORD *)v22 + 8) = v19;
  *((void *)v22 + 5) = v20;
  *((void *)v22 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v21;
  uint64_t v23 = a1[82];
  *(void *)int v22 = v23;
  *(void *)(v23 + 8) = v22;
  a1[82] = v22;
  ++a1[84];
  BOOL v25 = a4 > 0.0 && a3 == 0;
  *(_DWORD *)(a2 + 40) = a3;
  *(unsigned char *)(a2 + 44) = 1;
  BOOL v86 = v25;
  *(unsigned char *)(a2 + 32) = v25;
  int v26 = (uint64_t *)__p;
  __int16 v27 = v92;
  if (__p != v92)
  {
    BOOL v28 = v83;
    if (a4 != 0.0) {
      BOOL v28 = 0;
    }
    BOOL v84 = v28;
    while (1)
    {
      __int16 v29 = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::PreprocessPlayStateChange((uint64_t)a1, *v26, a3);
      if (v29 < 3) {
        break;
      }
      unint64_t v30 = **(id **)(Phase::Logger::GetInstance(v29) + 80);
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        __int16 v31 = Phase::Controller::DVM::kPlayStateStrings[a3];
        uint8x8_t v32 = Phase::Controller::DVM::kDspNodeTypeStrings[*(int *)(*v26 + 8)];
        __int16 v33 = *(char **)(*v26 + 16);
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        __int16 v94 = 1024;
        int v95 = 2241;
        __int16 v96 = 2080;
        unint64_t v97 = v31;
        __int16 v98 = 2080;
        uint64_t v99 = v32;
        __int16 v100 = 2048;
        unint64_t v101 = v33;
        id v34 = v30;
        os_log_type_t v35 = OS_LOG_TYPE_ERROR;
        unint64_t v36 = "%25s:%-5d NRT state transition to %s is invalid for DspNode type %s, id %llu \n";
        uint32_t v37 = 48;
LABEL_40:
        _os_log_impl(&dword_221E5E000, v34, v35, v36, buf, v37);
      }
LABEL_41:
      if (++v26 == v27) {
        goto LABEL_42;
      }
    }
    if (v84)
    {
      int v38 = *(_DWORD *)(*v26 + 8);
      uint64_t v39 = *(void *)(*v26 + 16);
      uint64_t v40 = *(void *)(*v26 + 24);
      UniqueObjectId v41 = (float *)operator new(0x38uLL);
      *((_DWORD *)v41 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
      v41[7] = a4;
      *((void *)v41 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v8;
      *((void *)v41 + 2) = &unk_26D4761E8;
      *((_DWORD *)v41 + 8) = v38;
      *((void *)v41 + 5) = v39;
      *((void *)v41 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v40;
      uint64_t v42 = a1[82];
      *(void *)UniqueObjectId v41 = v42;
      *(void *)(v42 + 8) = v41;
      a1[82] = v41;
      ++a1[84];
    }
    int v43 = *(_DWORD *)(*v26 + 8);
    uint64_t v44 = *(void *)(*v26 + 16);
    uint64_t v45 = *(void *)(*v26 + 24);
    unint64_t v46 = (float *)operator new(0x38uLL);
    *((_DWORD *)v46 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    v46[7] = a4;
    *((void *)v46 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v8;
    *((void *)v46 + 2) = &unk_26D4761E8;
    *((_DWORD *)v46 + 8) = v43;
    *((void *)v46 + 5) = v44;
    *((void *)v46 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v45;
    uint64_t v47 = a1[82];
    *(void *)unint64_t v46 = v47;
    *(void *)(v47 + 8) = v46;
    a1[82] = v46;
    ++a1[84];
    uint64_t v48 = *v26;
    *(_DWORD *)(v48 + 40) = a3;
    *(unsigned char *)(v48 + 44) = 1;
    *(unsigned char *)(v48 + 32) = v86;
    int v49 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v46) + 80);
    if (!os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_41;
    }
    unsigned int v50 = Phase::Controller::DVM::kPlayStateStrings[a3];
    unsigned int v51 = Phase::Controller::DVM::kDspNodeTypeStrings[*(int *)(*v26 + 8)];
    unsigned int v52 = *(char **)(*v26 + 16);
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    __int16 v94 = 1024;
    int v95 = 2255;
    __int16 v96 = 2080;
    unint64_t v97 = v50;
    __int16 v98 = 2080;
    uint64_t v99 = v51;
    __int16 v100 = 2048;
    unint64_t v101 = v52;
    __int16 v102 = 2048;
    double v103 = a4;
    id v34 = v49;
    os_log_type_t v35 = OS_LOG_TYPE_DEFAULT;
    unint64_t v36 = "%25s:%-5d NRT state set to %s, for DspNode type %s, id %llu with %.3f sec. delay.";
    uint32_t v37 = 58;
    goto LABEL_40;
  }
LABEL_42:
  (*(void (**)(char **__return_ptr, uint64_t))(*(void *)a2 + 40))(&v89, a2);
  uint64_t v53 = v89;
  unint64_t v54 = v90;
  if (v89 == v90) {
    goto LABEL_59;
  }
  unint64_t v55 = a1 + 85;
  BOOL v56 = v83;
  if (a4 != 0.0) {
    BOOL v56 = 0;
  }
  BOOL v85 = v56;
  do
  {
    uint64_t v57 = *(void **)v53;
    if (*(_DWORD *)(*(void *)v53 + 24) == 1)
    {
      uint64_t v58 = "Procedure";
    }
    else
    {
      uint64_t v58 = *(const char **)((*(uint64_t (**)(void *))(*v57 + 16))(v57) + 48);
      uint64_t v57 = *(void **)v53;
    }
    *(void *)buf = v57[24];
    uint64_t PlayStateTransitionStatus = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetPlayStateTransitionStatus((uint64_t)a1, (int *)buf, a3);
    if (PlayStateTransitionStatus >= 3)
    {
      int v60 = **(id **)(Phase::Logger::GetInstance(PlayStateTransitionStatus) + 80);
      if (!os_log_type_enabled(v60, OS_LOG_TYPE_ERROR)) {
        goto LABEL_57;
      }
      __int16 v61 = Phase::Controller::DVM::kDspNodeTypeStrings[*(int *)(a2 + 8)];
      int v62 = *(char **)(*(void *)v53 + 16);
      double v63 = *(double *)(a2 + 16);
      unint64_t v64 = Phase::Controller::DVM::kPlayStateStrings[a3];
      *(_DWORD *)buf = 136316674;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      __int16 v94 = 1024;
      int v95 = 2267;
      __int16 v96 = 2080;
      unint64_t v97 = (void *)v58;
      __int16 v98 = 2048;
      uint64_t v99 = v62;
      __int16 v100 = 2080;
      unint64_t v101 = v61;
      __int16 v102 = 2048;
      double v103 = v63;
      __int16 v104 = 2080;
      uint64_t v105 = v64;
      uint64_t v65 = v60;
      os_log_type_t v66 = OS_LOG_TYPE_ERROR;
      uint64_t v67 = "%25s:%-5d NRT transition stat for %s vid %llu (on %sId %llu) to %s is invalid! \n";
      uint32_t v68 = 68;
      goto LABEL_56;
    }
    (*(void (**)(long long *__return_ptr))(**(void **)v53 + 32))(&v87);
    if (v85)
    {
      int v69 = *(_DWORD *)(*(void *)v53 + 24);
      __int16 v70 = (float *)operator new(0x48uLL);
      *((_DWORD *)v70 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
      v70[7] = a4;
      *((void *)v70 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v55;
      *((void *)v70 + 2) = &unk_26D476210;
      long long v71 = v88;
      *((_OWORD *)v70 + 2) = v87;
      *((_OWORD *)v70 + 3) = v71;
      *((_DWORD *)v70 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v69;
      uint64_t v72 = a1[85];
      *(void *)__int16 v70 = v72;
      *(void *)(v72 + 8) = v70;
      a1[85] = v70;
      ++a1[87];
    }
    int v73 = *(_DWORD *)(*(void *)v53 + 24);
    unint64_t v74 = (float *)operator new(0x48uLL);
    *((_DWORD *)v74 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
    v74[7] = a4;
    *((void *)v74 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v55;
    *((void *)v74 + 2) = &unk_26D476210;
    long long v75 = v88;
    *((_OWORD *)v74 + 2) = v87;
    *((_OWORD *)v74 + 3) = v75;
    *((_DWORD *)v74 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v73;
    uint64_t v76 = a1[85];
    *(void *)unint64_t v74 = v76;
    *(void *)(v76 + 8) = v74;
    a1[85] = v74;
    ++a1[87];
    uint64_t v77 = *(void *)v53;
    *(unsigned char *)(v77 + 8) = v86;
    *(_DWORD *)(v77 + 192) = a3;
    *(unsigned char *)(v77 + 19std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
    double v78 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v74) + 80);
    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v79 = *(char **)(*(void *)v53 + 16);
      unint64_t v80 = Phase::Controller::DVM::kDspNodeTypeStrings[*(int *)(a2 + 8)];
      double v81 = *(double *)(a2 + 16);
      uint8x8_t v82 = Phase::Controller::DVM::kPlayStateStrings[a3];
      *(_DWORD *)buf = 136316930;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      __int16 v94 = 1024;
      int v95 = 2282;
      __int16 v96 = 2080;
      unint64_t v97 = (void *)v58;
      __int16 v98 = 2048;
      uint64_t v99 = v79;
      __int16 v100 = 2080;
      unint64_t v101 = v80;
      __int16 v102 = 2048;
      double v103 = v81;
      __int16 v104 = 2080;
      uint64_t v105 = v82;
      __int16 v106 = 2048;
      double v107 = a4;
      uint64_t v65 = v78;
      os_log_type_t v66 = OS_LOG_TYPE_DEFAULT;
      uint64_t v67 = "%25s:%-5d NRT set %s vid %llu (on %sId %llu) to %s with %.3f sec. delay.";
      uint32_t v68 = 78;
LABEL_56:
      _os_log_impl(&dword_221E5E000, v65, v66, v67, buf, v68);
    }
LABEL_57:
    v53 += 8;
  }
  while (v53 != v54);
  uint64_t v53 = v89;
LABEL_59:
  if (v53)
  {
    uint64_t v90 = v53;
    operator delete(v53);
  }
  if (__p)
  {
    unint64_t v92 = (uint64_t *)__p;
    operator delete(__p);
  }
}

void sub_221F1DE70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::DVM::VoiceGraph::InternalConnectTapToSubmix(Phase::Logger *a1, void *a2, void *a3, void *a4, float a5)
{
  uint64_t v86 = *MEMORY[0x263EF8340];
  uint64_t v8 = a3[9];
  uint64_t v7 = a3[10];
  unint64_t v9 = 0x8E38E38E38E38E39 * ((v7 - v8) >> 3);
  if (v9 != (uint64_t)(a4[1] - *a4) >> 2)
  {
    unint64_t v30 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(a1)
                                                                                        + 80)));
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v31 = a3[2];
      uint8x8_t v32 = Phase::Controller::DVM::kSubmixTypeStrings[a3[7]];
      uint64_t v33 = a2[2];
      id v34 = GetTapTypeString(a2[17]);
      *(_DWORD *)buf = 136316674;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1214;
      __int16 v78 = 2048;
      unint64_t v79 = a1;
      __int16 v80 = 2048;
      unint64_t v81 = v31;
      __int16 v82 = 2080;
      BOOL v83 = v32;
      __int16 v84 = 2048;
      *(void *)BOOL v85 = v33;
      *(_WORD *)&v85[8] = 2112;
      *(void *)&v85[10] = v34;
      _os_log_impl(&dword_221E5E000, v30, OS_LOG_TYPE_DEFAULT, "%25s:%-5d graph@%p: invalid channel and gain pairs for submixId %llu, type %s and tapId %llu, type %@. No op.", buf, 0x44u);
    }
    return 0;
  }
  unint64_t v74 = 0;
  long long v75 = 0;
  uint64_t v76 = 0;
  if (v7 == v8)
  {
    int v13 = 0;
  }
  else
  {
    std::vector<Phase::Controller::DVM::VoiceNode *>::__vallocate[abi:ne180100](&v74, 0x8E38E38E38E38E39 * ((v7 - v8) >> 3));
    uint64_t v12 = v75;
    bzero(v75, 8 * v9);
    int v13 = (Phase::Logger *)((char *)v12 + 8 * v9);
    long long v75 = v13;
    uint64_t v14 = a3[9];
    if (a3[10] != v14)
    {
      unint64_t v15 = 0;
      while (1)
      {
        uint64_t v16 = (uint64_t *)(v14 + 72 * v15);
        uint64_t v18 = *v16;
        uint64_t v17 = v16[1];
        if (v18 == v17)
        {
          if (a3[7] != 2)
          {
            unsigned int v50 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v13)
                                                                                                + 80)));
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            {
              unint64_t v55 = a3[2];
              BOOL v56 = Phase::Controller::DVM::kSubmixTypeStrings[a3[7]];
              uint64_t v57 = a2[2];
              uint64_t v58 = GetTapTypeString(a2[17]);
              *(_DWORD *)buf = 136316674;
              *(void *)&uint8_t buf[4] = "DVMGraph.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 1244;
              __int16 v78 = 2048;
              unint64_t v79 = a1;
              __int16 v80 = 2048;
              unint64_t v81 = v55;
              __int16 v82 = 2080;
              BOOL v83 = v56;
              __int16 v84 = 2048;
              *(void *)BOOL v85 = v57;
              *(_WORD *)&v85[8] = 2112;
              *(void *)&v85[10] = v58;
              _os_log_impl(&dword_221E5E000, v50, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: can't connect submixId %llu, type %s to tapId %llu, type %@. Submix has no effects!", buf, 0x44u);
            }
            goto LABEL_48;
          }
          int v19 = (UniqueObjectId *)(v14 + 72 * v15);
          UniqueObjectId v21 = v19[3];
          uint64_t v20 = v19 + 3;
          *(UniqueObjectId *)buf = v21;
          if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 17, buf))
          {
            unsigned int v50 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(0)
                                                                                                + 80)));
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            {
              unint64_t v59 = v20->mStorage[0];
              int v60 = (char *)a3[2];
              uint64_t v61 = a2[2];
              int v62 = GetTapTypeString(a2[17]);
              *(_DWORD *)buf = 136316674;
              *(void *)&uint8_t buf[4] = "DVMGraph.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 1255;
              __int16 v78 = 2048;
              unint64_t v79 = a1;
              __int16 v80 = 2048;
              unint64_t v81 = v59;
              __int16 v82 = 2048;
              BOOL v83 = v60;
              __int16 v84 = 2048;
              *(void *)BOOL v85 = v61;
              *(_WORD *)&v85[8] = 2112;
              *(void *)&v85[10] = v62;
              _os_log_impl(&dword_221E5E000, v50, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: can't connect unregistered child submixId %llu for ambient submixId %llu to tapId %llu, type %@!", buf, 0x44u);
            }
            goto LABEL_48;
          }
          uint64_t Submix = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetSubmix(a1, *v20);
          uint64_t v23 = (void *)*((void *)Submix + 9);
          uint64_t v17 = v23[1];
          if (*v23 == v17)
          {
            unsigned int v50 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(Submix)
                                                                                                + 80)));
            if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
            {
              unint64_t v63 = v20->mStorage[0];
              unint64_t v64 = (char *)a3[2];
              uint64_t v65 = a2[2];
              os_log_type_t v66 = GetTapTypeString(a2[17]);
              *(_DWORD *)buf = 136316674;
              *(void *)&uint8_t buf[4] = "DVMGraph.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 1267;
              __int16 v78 = 2048;
              unint64_t v79 = a1;
              __int16 v80 = 2048;
              unint64_t v81 = v63;
              __int16 v82 = 2048;
              BOOL v83 = v64;
              __int16 v84 = 2048;
              *(void *)BOOL v85 = v65;
              *(_WORD *)&v85[8] = 2112;
              *(void *)&v85[10] = v66;
              _os_log_impl(&dword_221E5E000, v50, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: can't connect child submix %llu for ambient submixId %llu to tapId %llu, type %@! Child submix has no effects!", buf, 0x44u);
            }
LABEL_48:
            uint64_t v35 = 1;
            goto LABEL_49;
          }
        }
        uint64_t v24 = *(void *)(v17 - 8);
        int v13 = (Phase::Logger *)(*(uint64_t (**)(uint64_t))(*(void *)v24 + 16))(v24);
        BOOL v25 = (unsigned char *)*((void *)v13 + 6);
        if (!v25) {
          goto LABEL_38;
        }
        unsigned int v26 = *v25;
        if (!*v25) {
          goto LABEL_38;
        }
        __int16 v27 = v25 + 1;
        uint64_t v28 = 0xCBF29CE484222325;
        do
        {
          uint64_t v28 = 0x100000001B3 * (v28 ^ v26);
          unsigned int v29 = *v27++;
          unsigned int v26 = v29;
        }
        while (v29);
        if (v28 != 0x235B3F2D33EB877ALL)
        {
LABEL_38:
          unsigned int v50 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v13)
                                                                                              + 80)));
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            unint64_t v51 = a3[2];
            unsigned int v52 = Phase::Controller::DVM::kSubmixTypeStrings[a3[7]];
            uint64_t v53 = a2[2];
            unint64_t v54 = GetTapTypeString(a2[17]);
            *(_DWORD *)buf = 136316930;
            *(void *)&uint8_t buf[4] = "DVMGraph.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1283;
            __int16 v78 = 2048;
            unint64_t v79 = a1;
            __int16 v80 = 2048;
            unint64_t v81 = v51;
            __int16 v82 = 2080;
            BOOL v83 = v52;
            __int16 v84 = 1024;
            *(_DWORD *)BOOL v85 = v15;
            *(_WORD *)&v85[4] = 2048;
            *(void *)&v85[6] = v53;
            *(_WORD *)&v85[14] = 2112;
            *(void *)&v85[16] = v54;
            _os_log_impl(&dword_221E5E000, v50, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: unsupported effect type in the tail of submixId %llu, type %s, channel %d trying to connect to tapId %llu, type %@.", buf, 0x4Au);
          }
          uint64_t v35 = 8;
LABEL_49:

LABEL_50:
          int v13 = (Phase::Logger *)v74;
          if (v74) {
            goto LABEL_51;
          }
          return v35;
        }
        *((void *)v74 + v15++) = v24;
        uint64_t v14 = a3[9];
        if (0x8E38E38E38E38E39 * ((a3[10] - v14) >> 3) <= v15)
        {
          int v13 = v75;
          break;
        }
      }
    }
  }
  *((void *)a1 + 11) |= 8uLL;
  unint64_t v36 = v74;
  if (v13 != v74)
  {
    unint64_t v37 = 0;
    while (1)
    {
      uint64_t v38 = v36[v37];
      float v39 = *(float *)(*a4 + 4 * v37);
      (*(void (**)(void **__return_ptr, void *))(*a2 + 40))(__p, a2);
      if (a2[17]) {
        int v40 = 2;
      }
      else {
        int v40 = 3;
      }
      uint64_t v69 = v38;
      int v70 = v40;
      float v71 = v39 * a5;
      char v72 = 1;
      BOOL v41 = Phase::Controller::DVM::VoiceNode::Connect(*(void *)__p[0], 1, 0, (uint64_t)&v69);
      BOOL v42 = v41;
      if (!v41)
      {
        int v43 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)v41)
                                                                                            + 80)));
        if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        {
          unint64_t v44 = a2[2];
          GetTapTypeString(a2[17]);
          uint64_t v45 = (char *)objc_claimAutoreleasedReturnValue();
          unint64_t v46 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(v38 + 24)];
          uint64_t v47 = *(void *)(*(void *)__p[0] + 16);
          uint64_t v48 = *(void *)(v38 + 16);
          *(_DWORD *)buf = 136316930;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1312;
          __int16 v78 = 2048;
          unint64_t v79 = a1;
          __int16 v80 = 2048;
          unint64_t v81 = v44;
          __int16 v82 = 2112;
          BOOL v83 = v45;
          __int16 v84 = 2048;
          *(void *)BOOL v85 = v47;
          *(_WORD *)&v85[8] = 2080;
          *(void *)&v85[10] = v46;
          *(_WORD *)&v85[18] = 2048;
          *(void *)&v85[20] = v48;
          _os_log_impl(&dword_221E5E000, v43, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: TapId %llu, type %@ failed to connect tapper vid %llu input to submix node %s, vid %llu output. Undoing all previously connected channels!", buf, 0x4Eu);
        }
        if (v37)
        {
          for (uint64_t i = 0; i != v37; ++i)
            Phase::Controller::DVM::VoiceNode::DisconnectFromNode(*(void *)__p[0], 1, *((void *)v74 + i));
        }
      }
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (!v42) {
        break;
      }
      ++v37;
      unint64_t v36 = v74;
      if (v37 >= (v75 - (Phase::Logger *)v74) >> 3)
      {
        uint64_t v35 = 0;
        goto LABEL_50;
      }
    }
    uint64_t v35 = 8;
    goto LABEL_50;
  }
  uint64_t v35 = 0;
  if (v13)
  {
LABEL_51:
    long long v75 = v13;
    operator delete(v13);
  }
  return v35;
}

void sub_221F1E784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL Phase::Controller::DVM::VoiceNode::Connect(unint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  unint64_t v4 = a1 + 56;
  if (a2) {
    uint64_t v5 = 32;
  }
  else {
    uint64_t v5 = 56;
  }
  if (a2) {
    unint64_t v4 = a1 + 32;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v4 + 8) - *(void *)(a1 + v5)) >> 3) <= a3) {
    return 0;
  }
  unsigned int v9 = *(_DWORD *)(a4 + 12);
  char v10 = *(unsigned char *)(a4 + 16);
  *(void *)&long long v31 = a1;
  *((void *)&v31 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = __PAIR64__(v9, a3);
  LOBYTE(v32) = v10;
  unint64_t v11 = *(void *)a4;
  uint64_t v12 = *(void *)a4 + 32;
  if (a2 == 1) {
    uint64_t v13 = 56;
  }
  else {
    uint64_t v13 = 32;
  }
  if (a2 == 1) {
    uint64_t v12 = *(void *)a4 + 56;
  }
  unint64_t v14 = *(int *)(a4 + 8);
  uint64_t v15 = *(void *)(v12 + 8);
  uint64_t v16 = *(void *)(v11 + v13);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v16) >> 3) < v14) {
    return 0;
  }
  if (!a1)
  {
    __int16 v27 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    BOOL result = os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "DVMVoiceNode.hpp";
    __int16 v34 = 1024;
    int v35 = 475;
    __int16 v36 = 2048;
    unint64_t v37 = 0;
    uint64_t v28 = "%25s:%-5d DvmVoiceNode@%p: trying to add a connection to a nullptr node (thisConn.mNode).";
    unsigned int v29 = v27;
LABEL_24:
    _os_log_impl(&dword_221E5E000, v29, OS_LOG_TYPE_ERROR, v28, buf, 0x1Cu);
    return 0;
  }
  std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__erase_unique<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>((uint64_t **)(v16 + 24 * (int)v14), a1, a3);
  uint64_t v17 = (uint64_t **)(*(void *)(v11 + v13) + 24 * *(int *)(a4 + 8));
  inserted = (Phase::Logger *)std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__find_equal<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>((uint64_t)v17, buf, (unint64_t *)&v31);
  int v19 = (uint64_t **)inserted;
  if (!*(void *)inserted)
  {
    uint64_t v20 = operator new(0x38uLL);
    v20[2] = v31;
    uint64_t v21 = *(void *)buf;
    *((void *)v20 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v32;
    inserted = (Phase::Logger *)std::__tree<Phase::SpatialCategory>::__insert_node_at(v17, v21, v19, (uint64_t *)v20);
  }
  if (!*(void *)a4)
  {
    unint64_t v30 = **(id **)(Phase::Logger::GetInstance(inserted) + 80);
    BOOL result = os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "DVMVoiceNode.hpp";
    __int16 v34 = 1024;
    int v35 = 486;
    __int16 v36 = 2048;
    unint64_t v37 = a1;
    uint64_t v28 = "%25s:%-5d DvmVoiceNode@%p: trying to add a connection to a nullptr node (conn.mNode).";
    unsigned int v29 = v30;
    goto LABEL_24;
  }
  uint64_t v22 = 3 * a3;
  std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__erase_unique<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>((uint64_t **)(*(void *)(a1 + v5) + 8 * v22), *(void *)a4, *(_DWORD *)(a4 + 8));
  uint64_t v23 = (uint64_t **)(*(void *)(a1 + v5) + 8 * v22);
  uint64_t v24 = std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__find_equal<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>((uint64_t)v23, buf, (unint64_t *)a4);
  if (!*v24)
  {
    BOOL v25 = operator new(0x38uLL);
    v25[2] = *(_OWORD *)a4;
    *((void *)v25 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a4 + 16);
    std::__tree<Phase::SpatialCategory>::__insert_node_at(v23, *(uint64_t *)buf, (uint64_t **)v24, (uint64_t *)v25);
  }
  return 1;
}

uint64_t Phase::Controller::DVM::VoiceGraph::ConnectTapToSubmixes(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2)
{
  uint64_t v70 = *MEMORY[0x263EF8340];
  unint64_t v4 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)this + 40, a2);
  if (v4)
  {
    uint64_t v5 = v4;
    if (*((void *)v4 + 10))
    {
      unint64_t v51 = *((void *)v4 + 10);
      long long v57 = 0u;
      long long v58 = 0u;
      float v59 = 1.0;
      uint64_t v6 = (uint64_t *)*((void *)v4 + 13);
      if (v6)
      {
        uint64_t v53 = v4;
        while (1)
        {
          *(_OWORD *)uu = *((_OWORD *)v6 + 1);
          v71.mStorage[0] = *(void *)uu;
          v71.mStorage[1] = v6[3];
          uint64_t Submix = Phase::Controller::DVM::VoiceGraph::GetSubmix(this, v71);
          *(_OWORD *)buf = *((_OWORD *)v6 + 1);
          uint64_t v8 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)this + 17, buf);
          if (!v8) {
            break;
          }
          if (!Submix[44])
          {
            unint64_t v30 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v8)
                                                                                                + 80)));
            if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
            {
              memset(out, 0, 37);
              unint64_t v2 = (unint64_t)buf;
              uuid_unparse(uu, out);
              std::string::basic_string[abi:ne180100]<0>(__p, out);
              int v36 = v55;
              unint64_t v37 = (void **)__p[0];
              uint64_t v38 = GetTapTypeString(*((void *)v5 + 20));
              __int16 v34 = (void *)v38;
              *(_DWORD *)buf = 136316418;
              float v39 = __p;
              if (v36 < 0) {
                float v39 = v37;
              }
              *(void *)&uint8_t buf[4] = "DVMGraph.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 1410;
              __int16 v61 = 2048;
              int v62 = this;
              __int16 v63 = 2080;
              unint64_t v64 = (unint64_t)v39;
              __int16 v65 = 2048;
              unint64_t v66 = a2;
              __int16 v67 = 2112;
              uint64_t v68 = v38;
              _os_log_impl(&dword_221E5E000, v30, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: submixId %s is not configured. Failed to connect to tapId %llu, type %@", buf, 0x3Au);
              if (v55 < 0) {
                operator delete(__p[0]);
              }
              goto LABEL_67;
            }
            goto LABEL_68;
          }
          (*(void (**)(unsigned char *__return_ptr, unsigned char *))(*(void *)Submix + 40))(buf, Submix);
          uint64_t v10 = *(void *)buf;
          uint64_t v9 = *(void *)&buf[8];
          if (*(void *)buf)
          {
            *(void *)&uint8_t buf[8] = *(void *)buf;
            operator delete(*(void **)buf);
          }
          unint64_t v11 = v6;
          if (v10 != v9)
          {
            do
            {
              unint64_t v12 = 0xCBF29CE484222325;
              for (uint64_t i = 16; i != 32; ++i)
                unint64_t v12 = 0x100000001B3 * (v12 ^ *((char *)v11 + i));
              unint64_t v14 = *((void *)&v57 + 1);
              if (*((void *)&v57 + 1))
              {
                uint8x8_t v15 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v57 + 8));
                v15.i16[0] = vaddlv_u8(v15);
                if (v15.u32[0] > 1uLL)
                {
                  unint64_t v2 = v12;
                  if (v12 >= *((void *)&v57 + 1)) {
                    unint64_t v2 = v12 % *((void *)&v57 + 1);
                  }
                }
                else
                {
                  unint64_t v2 = (*((void *)&v57 + 1) - 1) & v12;
                }
                uint64_t v16 = *(void **)(v57 + 8 * v2);
                if (v16)
                {
                  for (uint64_t j = (void *)*v16; j; uint64_t j = (void *)*j)
                  {
                    unint64_t v18 = j[1];
                    if (v18 == v12)
                    {
                      if (j[2] == v11[2] && j[3] == v11[3]) {
                        goto LABEL_54;
                      }
                    }
                    else
                    {
                      if (v15.u32[0] > 1uLL)
                      {
                        if (v18 >= *((void *)&v57 + 1)) {
                          v18 %= *((void *)&v57 + 1);
                        }
                      }
                      else
                      {
                        v18 &= *((void *)&v57 + 1) - 1;
                      }
                      if (v18 != v2) {
                        break;
                      }
                    }
                  }
                }
              }
              uint64_t v20 = operator new(0x40uLL);
              *uint64_t v20 = 0;
              v20[1] = v12;
              long long v21 = *((_OWORD *)v11 + 1);
              v20[4] = 0;
              *((_OWORD *)v20 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v21;
              void v20[5] = 0;
              v20[6] = 0;
              std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v20 + 4, (const void *)v11[4], v11[5], (v11[5] - v11[4]) >> 2);
              *((_DWORD *)v20 + 14) = *((_DWORD *)v11 + 14);
              float v22 = (float)(unint64_t)(*((void *)&v58 + 1) + 1);
              if (!v14 || (float)(v59 * (float)v14) < v22)
              {
                BOOL v23 = (v14 & (v14 - 1)) != 0;
                if (v14 < 3) {
                  BOOL v23 = 1;
                }
                unint64_t v24 = v23 | (2 * v14);
                unint64_t v25 = vcvtps_u32_f32(v22 / v59);
                if (v24 <= v25) {
                  size_t v26 = v25;
                }
                else {
                  size_t v26 = v24;
                }
                std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)&v57, v26);
                unint64_t v14 = *((void *)&v57 + 1);
                if ((*((void *)&v57 + 1) & (*((void *)&v57 + 1) - 1)) != 0)
                {
                  if (v12 >= *((void *)&v57 + 1)) {
                    unint64_t v2 = v12 % *((void *)&v57 + 1);
                  }
                  else {
                    unint64_t v2 = v12;
                  }
                }
                else
                {
                  unint64_t v2 = (*((void *)&v57 + 1) - 1) & v12;
                }
              }
              uint64_t v27 = v57;
              uint64_t v28 = *(void **)(v57 + 8 * v2);
              if (v28)
              {
                *uint64_t v20 = *v28;
              }
              else
              {
                *uint64_t v20 = v58;
                *(void *)&long long v58 = v20;
                *(void *)(v27 + 8 * v2) = &v58;
                if (!*v20) {
                  goto LABEL_53;
                }
                unint64_t v29 = *(void *)(*v20 + 8);
                if ((v14 & (v14 - 1)) != 0)
                {
                  if (v29 >= v14) {
                    v29 %= v14;
                  }
                }
                else
                {
                  v29 &= v14 - 1;
                }
                uint64_t v28 = (void *)(v57 + 8 * v29);
              }
              *uint64_t v28 = v20;
LABEL_53:
              ++*((void *)&v58 + 1);
LABEL_54:
              unint64_t v11 = (uint64_t *)*v11;
            }
            while (v11);
          }
LABEL_69:
          uint64_t v6 = (uint64_t *)*v6;
          uint64_t v5 = v53;
          if (!v6) {
            goto LABEL_70;
          }
        }
        unint64_t v30 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(0)
                                                                                            + 80)));
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          memset(out, 0, 37);
          unint64_t v2 = (unint64_t)buf;
          uuid_unparse(uu, out);
          std::string::basic_string[abi:ne180100]<0>(__p, out);
          int v31 = v55;
          uint64_t v32 = (void **)__p[0];
          uint64_t v33 = GetTapTypeString(*((void *)v5 + 20));
          __int16 v34 = (void *)v33;
          *(_DWORD *)buf = 136316418;
          int v35 = __p;
          if (v31 < 0) {
            int v35 = v32;
          }
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1401;
          __int16 v61 = 2048;
          int v62 = this;
          __int16 v63 = 2080;
          unint64_t v64 = (unint64_t)v35;
          __int16 v65 = 2048;
          unint64_t v66 = a2;
          __int16 v67 = 2112;
          uint64_t v68 = v33;
          _os_log_impl(&dword_221E5E000, v30, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: submixId %s does not exist. Impossible to connect to tapId %llu, type %@", buf, 0x3Au);
          if (v55 < 0) {
            operator delete(__p[0]);
          }
LABEL_67:
        }
LABEL_68:

        goto LABEL_69;
      }
LABEL_70:
      int v40 = Phase::Controller::DVM::VoiceNode::Disconnect(v51, 1);
      BOOL v41 = (Phase::Logger *)Phase::Controller::DVM::VoiceNode::Disconnect(v51, 0);
      if (v40 & v41)
      {
        *((void *)this + 11) |= 8uLL;
        BOOL v42 = (uint64_t *)v58;
        if ((void)v58)
        {
          char v43 = 0;
          do
          {
            unint64_t v44 = Phase::Controller::DVM::VoiceGraph::GetSubmix(this, *((UniqueObjectId *)v42 + 1));
            if (Phase::Controller::DVM::VoiceGraph::InternalConnectTapToSubmix(this, (void *)v5 + 3, v44, v42 + 4, *((float *)v42 + 14)))char v43 = 8; {
            BOOL v42 = (uint64_t *)*v42;
            }
          }
          while (v42);
        }
        else
        {
          char v43 = 0;
        }
      }
      else
      {
        uint64_t v48 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v41)
                                                                                            + 80)));
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          int v49 = GetTapTypeString(*((void *)v5 + 20));
          *(_DWORD *)buf = 136316162;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1428;
          __int16 v61 = 2048;
          int v62 = this;
          __int16 v63 = 2048;
          unint64_t v64 = a2;
          __int16 v65 = 2112;
          unint64_t v66 = (unint64_t)v49;
          _os_log_impl(&dword_221E5E000, v48, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: failed to disconnect parent nodes from input of TapId %llu, type %@", buf, 0x30u);
        }
        char v43 = 8;
      }
      std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::~__hash_table((uint64_t)&v57);
    }
    else
    {
      unint64_t v46 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v4)
                                                                                          + 80)));
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        uint64_t v47 = GetTapTypeString(*((void *)v5 + 20));
        *(_DWORD *)buf = 136316162;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1382;
        __int16 v61 = 2048;
        int v62 = this;
        __int16 v63 = 2048;
        unint64_t v64 = a2;
        __int16 v65 = 2112;
        unint64_t v66 = (unint64_t)v47;
        _os_log_impl(&dword_221E5E000, v46, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: failed to connect tap to submix. VoiceNode for TapId %llu, type %@ is a nullptr!", buf, 0x30u);
      }
      return 8;
    }
  }
  else
  {
    uint64_t v45 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1372;
      __int16 v61 = 2048;
      int v62 = this;
      __int16 v63 = 2048;
      unint64_t v64 = a2;
      _os_log_impl(&dword_221E5E000, v45, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: TapId %llu does not exists!", buf, 0x26u);
    }
    return 3;
  }
  return v43;
}

void sub_221F1F330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::~__hash_table((uint64_t)&a24);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::AddSubmixToTap(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x263EF8340];
  *(void *)&long long v40 = a3;
  *((void *)&v40 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a4;
  unint64_t v11 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)a1 + 40, a2);
  if (!v11)
  {
    uint8x8_t v15 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      return 3;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1460;
    __int16 v42 = 2048;
    char v43 = a1;
    __int16 v44 = 2048;
    unint64_t v45 = a2;
    uint64_t v16 = "%25s:%-5d graph@%p: TapId %llu does not exists!";
    uint64_t v17 = v15;
    os_log_type_t v18 = OS_LOG_TYPE_ERROR;
LABEL_6:
    _os_log_impl(&dword_221E5E000, v17, v18, v16, buf, 0x26u);
    return 3;
  }
  unint64_t v12 = (float *)v11;
  uint64_t v13 = v11 + 11;
  if (std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(v11 + 11, &v40))
  {
    return 4;
  }
  *(void *)buf = a3;
  *(void *)&uint8_t buf[8] = a4;
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 17, buf))
  {
    unint64_t v25 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      return 3;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1471;
    __int16 v42 = 2048;
    char v43 = a1;
    __int16 v44 = 2048;
    unint64_t v45 = a3;
    uint64_t v16 = "%25s:%-5d graph@%p: submixId %llu not added yet";
    uint64_t v17 = v25;
    os_log_type_t v18 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_6;
  }
  v47.mStorage[0] = a3;
  v47.mStorage[1] = a4;
  uint64_t Submix = Phase::Controller::DVM::VoiceGraph::GetSubmix(a1, v47);
  if (Submix[7] == 2)
  {
    uint64_t v20 = Submix[9];
    if (v20 == Submix[10] || !*(void *)(v20 + 64)) {
      return 3;
    }
  }
  uint64_t v21 = 0;
  unint64_t v22 = 0xCBF29CE484222325;
  do
    unint64_t v22 = 0x100000001B3 * (v22 ^ (char)buf[v21++ - 16]);
  while (v21 != 16);
  unint64_t v23 = *((void *)v12 + 12);
  if (v23)
  {
    uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v23);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      unint64_t v5 = v22;
      if (v22 >= v23) {
        unint64_t v5 = v22 % v23;
      }
    }
    else
    {
      unint64_t v5 = (v23 - 1) & v22;
    }
    size_t v26 = *(void **)(*v13 + 8 * v5);
    if (v26)
    {
      for (uint64_t i = (void *)*v26; i; uint64_t i = (void *)*i)
      {
        unint64_t v28 = i[1];
        if (v28 == v22)
        {
          if (i[2] == a3 && i[3] == a4) {
            return 0;
          }
        }
        else
        {
          if (v24.u32[0] > 1uLL)
          {
            if (v28 >= v23) {
              v28 %= v23;
            }
          }
          else
          {
            v28 &= v23 - 1;
          }
          if (v28 != v5) {
            break;
          }
        }
      }
    }
  }
  unint64_t v30 = operator new(0x40uLL);
  *unint64_t v30 = 0;
  v30[1] = v22;
  *((_OWORD *)v30 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v40;
  v30[5] = 0;
  v30[6] = 0;
  v30[4] = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v30 + 4, *(const void **)a5, *(void *)(a5 + 8), (uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 2);
  *((_DWORD *)v30 + 14) = *(_DWORD *)(a5 + 24);
  float v31 = (float)(unint64_t)(*((void *)v12 + 14) + 1);
  float v32 = v12[30];
  if (!v23 || (float)(v32 * (float)v23) < v31)
  {
    BOOL v33 = 1;
    if (v23 >= 3) {
      BOOL v33 = (v23 & (v23 - 1)) != 0;
    }
    unint64_t v34 = v33 | (2 * v23);
    unint64_t v35 = vcvtps_u32_f32(v31 / v32);
    if (v34 <= v35) {
      size_t v36 = v35;
    }
    else {
      size_t v36 = v34;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>((uint64_t)v13, v36);
    unint64_t v23 = *((void *)v12 + 12);
    if ((v23 & (v23 - 1)) != 0)
    {
      if (v22 >= v23) {
        unint64_t v5 = v22 % v23;
      }
      else {
        unint64_t v5 = v22;
      }
    }
    else
    {
      unint64_t v5 = (v23 - 1) & v22;
    }
  }
  uint64_t v37 = *v13;
  uint64_t v38 = *(void **)(*v13 + 8 * v5);
  if (v38)
  {
    *unint64_t v30 = *v38;
LABEL_57:
    *uint64_t v38 = v30;
    goto LABEL_58;
  }
  *unint64_t v30 = *((void *)v12 + 13);
  *((void *)v12 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = v30;
  *(void *)(v37 + 8 * v5) = v12 + 26;
  if (*v30)
  {
    unint64_t v39 = *(void *)(*v30 + 8);
    if ((v23 & (v23 - 1)) != 0)
    {
      if (v39 >= v23) {
        v39 %= v23;
      }
    }
    else
    {
      v39 &= v23 - 1;
    }
    uint64_t v38 = (void *)(*v13 + 8 * v39);
    goto LABEL_57;
  }
LABEL_58:
  uint64_t result = 0;
  ++*((void *)v12 + 14);
  return result;
}

void sub_221F1F80C(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::RemoveSubmixFromTap(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  v15[0] = a3;
  v15[1] = a4;
  uint64_t v7 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 320), a2);
  if (v7)
  {
    uint64_t v8 = v7 + 11;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(v7 + 11, v15);
    if (v9)
    {
      std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::erase(v8, v9);
      return 0;
    }
    unint64_t v14 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v17 = "DVMGraph.mm";
      __int16 v18 = 1024;
      int v19 = 1506;
      __int16 v20 = 2048;
      uint64_t v21 = a1;
      __int16 v22 = 2048;
      unint64_t v23 = a3;
      unint64_t v12 = "%25s:%-5d graph@%p: SubmixTapGains for submixId %llu not found!";
      uint64_t v13 = v14;
      goto LABEL_8;
    }
  }
  else
  {
    unint64_t v11 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      uint64_t v17 = "DVMGraph.mm";
      __int16 v18 = 1024;
      int v19 = 1499;
      __int16 v20 = 2048;
      uint64_t v21 = a1;
      __int16 v22 = 2048;
      unint64_t v23 = a2;
      unint64_t v12 = "%25s:%-5d graph@%p: TapId %llu does not exists!";
      uint64_t v13 = v11;
LABEL_8:
      _os_log_impl(&dword_221E5E000, v13, OS_LOG_TYPE_ERROR, v12, buf, 0x26u);
    }
  }
  return 3;
}

uint64_t Phase::Controller::DVM::VoiceGraph::RemoveTap(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  unint64_t v4 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)this + 40, a2);
  if (v4)
  {
    uint64_t v5 = (uint64_t)(v4 + 3);
    int v6 = Phase::Controller::DVM::VoiceGraph::PreprocessPlayStateChange((uint64_t)this, (uint64_t)(v4 + 3), 0);
    if (v6 != 8)
    {
      if (v6 == 4) {
        return 1;
      }
      *((void *)this + 11) |= 8uLL;
      Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(this, v5, 0, 0.0);
    }
    return 0;
  }
  else
  {
    uint64_t v8 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315906;
      uint64_t v10 = "DVMGraph.mm";
      __int16 v11 = 1024;
      int v12 = 1520;
      __int16 v13 = 2048;
      unint64_t v14 = this;
      __int16 v15 = 2048;
      unint64_t v16 = a2;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: TapId %llu does not exists!", (uint8_t *)&v9, 0x26u);
    }
    return 3;
  }
}

void *Phase::Controller::DVM::Tap::GetAllValidVoiceNodes@<X0>(void *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = this[7];
  if (v2)
  {
    unint64_t v4 = operator new(8uLL);
    *a2 = v4;
    void *v4 = v2;
    this = v4 + 1;
    a2[1] = this;
    a2[2] = this;
  }
  return this;
}

uint64_t Phase::Controller::DVM::VoiceGraph::AddRenderer(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2, unint64_t a3)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  *(void *)buf = a2;
  int v6 = (void **)((char *)this + 360);
  uint64_t v7 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 45, (unint64_t *)buf);
  if (!v7)
  {
    *(void *)buf = a3;
    uint64_t v7 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 50, (unint64_t *)buf);
    if (v7)
    {
      unint64_t v14 = operator new(0x78uLL);
      void *v14 = 0;
      v14[1] = a2;
      *((_DWORD *)v14 + 8) = 3;
      v14[5] = a2;
      v14[6] = 0;
      *((unsigned char *)v14 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *((_DWORD *)v14 + 15) = 0;
      *((unsigned char *)v14 + 64) = 0;
      *((unsigned char *)v14 + 68) = 0;
      v14[9] = 0;
      v14[10] = a3;
      void v14[2] = a2;
      void v14[3] = &unk_26D476128;
      v14[11] = 0;
      v14[12] = 0;
      v14[13] = 0;
      *((_DWORD *)v14 + 28) = 0;
      unint64_t v15 = *((void *)this + 46);
      if (v15)
      {
        uint8x8_t v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
        v16.i16[0] = vaddlv_u8(v16);
        if (v16.u32[0] > 1uLL)
        {
          unint64_t v17 = a2;
          if (v15 <= a2) {
            unint64_t v17 = a2 % v15;
          }
        }
        else
        {
          unint64_t v17 = (v15 - 1) & a2;
        }
        __int16 v18 = (void *)*((void *)*v6 + v17);
        if (v18)
        {
          for (uint64_t i = (void *)*v18; i; uint64_t i = (void *)*i)
          {
            unint64_t v20 = i[1];
            if (v20 == a2)
            {
              if (i[2] == a2)
              {
                std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,void *>>>::operator()[abi:ne180100](1, (char *)v14);
                return 0;
              }
            }
            else
            {
              if (v16.u32[0] > 1uLL)
              {
                if (v20 >= v15) {
                  v20 %= v15;
                }
              }
              else
              {
                v20 &= v15 - 1;
              }
              if (v20 != v17) {
                break;
              }
            }
          }
        }
      }
      float v21 = (float)(unint64_t)(*((void *)this + 48) + 1);
      float v22 = *((float *)this + 98);
      if (!v15 || (float)(v22 * (float)v15) < v21)
      {
        BOOL v23 = 1;
        if (v15 >= 3) {
          BOOL v23 = (v15 & (v15 - 1)) != 0;
        }
        unint64_t v24 = v23 | (2 * v15);
        unint64_t v25 = vcvtps_u32_f32(v21 / v22);
        if (v24 <= v25) {
          int8x8_t prime = (int8x8_t)v25;
        }
        else {
          int8x8_t prime = (int8x8_t)v24;
        }
        if (*(void *)&prime == 1)
        {
          int8x8_t prime = (int8x8_t)2;
        }
        else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
        {
          int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
          unint64_t v15 = *((void *)this + 46);
        }
        if (*(void *)&prime > v15) {
          goto LABEL_93;
        }
        if (*(void *)&prime >= v15) {
          goto LABEL_67;
        }
        unint64_t v33 = vcvtps_u32_f32((float)*((unint64_t *)this + 48) / *((float *)this + 98));
        if (v15 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v15), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
        {
          unint64_t v33 = std::__next_prime(v33);
        }
        else
        {
          uint64_t v35 = 1 << -(char)__clz(v33 - 1);
          if (v33 >= 2) {
            unint64_t v33 = v35;
          }
        }
        if (*(void *)&prime <= v33) {
          int8x8_t prime = (int8x8_t)v33;
        }
        if (*(void *)&prime >= v15)
        {
          unint64_t v15 = *((void *)this + 46);
          goto LABEL_67;
        }
        if (prime)
        {
LABEL_93:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v27 = operator new(8 * *(void *)&prime);
          unint64_t v28 = *v6;
          *int v6 = v27;
          if (v28) {
            operator delete(v28);
          }
          uint64_t v29 = 0;
          *((int8x8_t *)this + 4std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = prime;
          do
            *((void *)*v6 + v29++) = 0;
          while (*(void *)&prime != v29);
          unint64_t v30 = (void *)*((void *)this + 47);
          if (v30)
          {
            unint64_t v31 = v30[1];
            uint8x8_t v32 = (uint8x8_t)vcnt_s8(prime);
            v32.i16[0] = vaddlv_u8(v32);
            if (v32.u32[0] > 1uLL)
            {
              if (v31 >= *(void *)&prime) {
                v31 %= *(void *)&prime;
              }
            }
            else
            {
              v31 &= *(void *)&prime - 1;
            }
            *((void *)*v6 + v3Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = (char *)this + 376;
            size_t v36 = (void *)*v30;
            if (*v30)
            {
              do
              {
                unint64_t v37 = v36[1];
                if (v32.u32[0] > 1uLL)
                {
                  if (v37 >= *(void *)&prime) {
                    v37 %= *(void *)&prime;
                  }
                }
                else
                {
                  v37 &= *(void *)&prime - 1;
                }
                if (v37 != v31)
                {
                  if (!*((void *)*v6 + v37))
                  {
                    *((void *)*v6 + v3std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v30;
                    goto LABEL_63;
                  }
                  *unint64_t v30 = *v36;
                  void *v36 = **((void **)*v6 + v37);
                  **((void **)*v6 + v3std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v36;
                  size_t v36 = v30;
                }
                unint64_t v37 = v31;
LABEL_63:
                unint64_t v30 = v36;
                size_t v36 = (void *)*v36;
                unint64_t v31 = v37;
              }
              while (v36);
            }
          }
          unint64_t v15 = (unint64_t)prime;
        }
        else
        {
          char v43 = *v6;
          *int v6 = 0;
          if (v43) {
            operator delete(v43);
          }
          unint64_t v15 = 0;
          *((void *)this + 4std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
        }
      }
LABEL_67:
      unint64_t v38 = v14[1];
      uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
      v39.i16[0] = vaddlv_u8(v39);
      if (v39.u32[0] > 1uLL)
      {
        if (v38 >= v15) {
          v38 %= v15;
        }
      }
      else
      {
        v38 &= v15 - 1;
      }
      long long v40 = *v6;
      BOOL v41 = (void *)*((void *)*v6 + v38);
      if (v41)
      {
        void *v14 = *v41;
      }
      else
      {
        void *v14 = *((void *)this + 47);
        *((void *)this + 4std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v14;
        v40[v38] = (char *)this + 376;
        if (!*v14)
        {
LABEL_80:
          uint64_t result = 0;
          ++*((void *)this + 48);
          return result;
        }
        unint64_t v42 = *(void *)(*v14 + 8);
        if (v39.u32[0] > 1uLL)
        {
          if (v42 >= v15) {
            v42 %= v15;
          }
        }
        else
        {
          v42 &= v15 - 1;
        }
        BOOL v41 = (char *)*v6 + 8 * v42;
      }
      void *v41 = v14;
      goto LABEL_80;
    }
  }
  uint64_t v8 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v7)
                                                                                     + 80)));
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    unint64_t v44 = a2;
    int v9 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>(v6, &v44);
    unint64_t v44 = a3;
    uint64_t v10 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 50, &v44);
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    __int16 v11 = "rendererId already exists,";
    __int16 v46 = 1024;
    int v47 = 1587;
    int v12 = "";
    *(_DWORD *)buf = 136316674;
    int v49 = this;
    __int16 v48 = 2048;
    if (!v9) {
      __int16 v11 = "";
    }
    __int16 v50 = 2048;
    if (!v10) {
      int v12 = " masterId does not exist";
    }
    unint64_t v51 = a2;
    __int16 v52 = 2048;
    unint64_t v53 = a3;
    __int16 v54 = 2080;
    char v55 = v11;
    __int16 v56 = 2080;
    long long v57 = v12;
    _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: rendererId %llu, masterId %llu: %s%s!", buf, 0x44u);
  }

  return 3;
}

void sub_221F200F4(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void *Phase::Controller::DVM::VoiceGraph::RemoveRenderer(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2)
{
  unint64_t v5 = a2;
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 45, &v5);
  if (result) {
    return (void *)Phase::Controller::DVM::VoiceGraph::SetRendererPlayState((uint64_t)this, a2, 0, 0);
  }
  return result;
}

uint64_t Phase::Controller::DVM::VoiceGraph::SetRendererPlayState(uint64_t a1, unint64_t a2, int a3, char a4)
{
  uint64_t v22 = *MEMORY[0x263EF8340];
  *(void *)std::string __p = a2;
  if (std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)(a1 + 360), (unint64_t *)__p))
  {
    Renderer = Phase::Controller::DVM::VoiceGraph::GetRenderer((Phase::Controller::DVM::VoiceGraph *)a1, a2);
    int v9 = Phase::Controller::DVM::VoiceGraph::PreprocessPlayStateChange(a1, (uint64_t)Renderer, a3);
    if (v9 != 8)
    {
      if (v9 == 4) {
        return 1;
      }
      *(void *)(a1 + 88) |= 8uLL;
      float v13 = 0.0;
      if ((a3 & 0xFFFFFFFD) == 0 && (a4 & 1) == 0)
      {
        (*(void (**)(unsigned char *__return_ptr, void *, double))(*Renderer + 40))(__p, Renderer, 0.0);
        float v14 = (double)(*(int (**)(void))(***(void ***)__p + 40))() / *(double *)(a1 + 8);
        if (*(void *)__p)
        {
          *(void *)&__p[8] = *(void *)__p;
          operator delete(*(void **)__p);
        }
        float v13 = v14 + 0.001;
      }
      Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange((void *)a1, (uint64_t)Renderer, a3, v13);
    }
    return 0;
  }
  else
  {
    __int16 v11 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = Phase::Controller::DVM::kPlayStateStrings[a3];
      *(_DWORD *)std::string __p = 136316162;
      *(void *)&__p[4] = "DVMGraph.mm";
      *(_WORD *)&__p[12] = 1024;
      *(_DWORD *)&__p[14] = 2537;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 2080;
      int v19 = v12;
      __int16 v20 = 2048;
      unint64_t v21 = a2;
      _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: state change request %s, rendererId %llu does not exist!", __p, 0x30u);
    }
    return 3;
  }
}

void sub_221F20388(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::DVM::VoiceGraph::ConfigureRenderer(uint64_t a1, unint64_t a2, int a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v200 = *MEMORY[0x263EF8340];
  *(void *)buf = a2;
  v178 = (void *)(a1 + 360);
  unint64_t v5 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)(a1 + 360), (unint64_t *)buf);
  if (!v5)
  {
    uint64_t v17 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1639;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&uint8_t buf[20] = a1;
      *(_WORD *)&unsigned char buf[28] = 2048;
      *(void *)&buf[30] = a2;
      _os_log_impl(&dword_221E5E000, v17, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: rendererId %llu does not exist!", buf, 0x26u);
    }
    return 3;
  }
  if (!a3)
  {
    int v19 = **(id **)(Phase::Logger::GetInstance(v5) + 80);
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1646;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&uint8_t buf[20] = a1;
      *(_WORD *)&unsigned char buf[28] = 2048;
      *(void *)&buf[30] = a2;
      __int16 v194 = 2080;
      v195 = "Stopped";
      __int16 v20 = "%25s:%-5d graph@%p: rendererId %llu invalid play state %s!";
      unint64_t v21 = v19;
      uint32_t v22 = 48;
LABEL_24:
      _os_log_impl(&dword_221E5E000, v21, OS_LOG_TYPE_ERROR, v20, buf, v22);
    }
    return 1;
  }
  uint64_t v7 = *a5;
  uint64_t v6 = a5[1];
  uint64_t v8 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v178, a2);
  int v9 = v8;
  __int16 v11 = (char *)*((void *)v8 + 11);
  uint64_t v10 = (char *)*((void *)v8 + 12);
  if (v11 != v10)
  {
    uint64_t v12 = v10 - v11;
    float v13 = (unint64_t *)a4;
    uint64_t v14 = *(void *)(a4 + 8);
    uint64_t v15 = *(void *)(a4 + 16);
    if (0x4EC4EC4EC4EC4EC5 * ((v15 - v14) >> 3) == v12 >> 5)
    {
      uint64_t v16 = a1;
      goto LABEL_28;
    }
    unint64_t v31 = **(id **)(Phase::Logger::GetInstance(v8) + 80);
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      uint64_t v32 = (uint64_t)(*((void *)v9 + 12) - *((void *)v9 + 11)) >> 5;
      uint64_t v33 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(*(void *)(a4 + 16) - *(void *)(a4 + 8)) >> 3);
      *(_DWORD *)buf = 136316418;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1667;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&uint8_t buf[20] = a1;
      *(_WORD *)&unsigned char buf[28] = 2048;
      *(void *)&buf[30] = a2;
      __int16 v194 = 2048;
      v195 = (const char *)v32;
      __int16 v196 = 2048;
      *(void *)uint64_t v197 = v33;
      __int16 v20 = "%25s:%-5d graph@%p: rendererId %llu and DspNode voice count mismatch [%zu,%zu]!";
      unint64_t v21 = v31;
      uint32_t v22 = 58;
      goto LABEL_24;
    }
    return 1;
  }
  uint64_t v23 = *(void *)(a4 + 16) - *(void *)(a4 + 8);
  uint64_t v16 = a1;
  if (v23)
  {
    unint64_t v24 = 0x4EC4EC4EC4EC4EC5 * (v23 >> 3);
    uint64_t v25 = *((void *)v8 + 13) - (void)v11;
    if (v24 <= v25 >> 5)
    {
      bzero(*((void **)v8 + 11), 32 * v24);
      *((void *)v9 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = &v11[32 * v24];
    }
    else
    {
      if (v24 >> 59) {
        std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
      }
      size_t v26 = v8;
      uint64_t v27 = v25 >> 4;
      if (v25 >> 4 <= v24) {
        uint64_t v27 = v24;
      }
      if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v28 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v28 = v27;
      }
      if (v28 >> 59) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v29 = (char *)operator new(32 * v28);
      bzero(v29, 32 * v24);
      unint64_t v30 = &v29[32 * v28];
      int v9 = v26;
      *((void *)v26 + 1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v29;
      *((void *)v26 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = &v29[32 * v24];
      *((void *)v26 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = v30;
      uint64_t v16 = a1;
      if (v11) {
        operator delete(v11);
      }
    }
  }
  float v13 = (unint64_t *)a4;
  uint64_t v14 = *(void *)(a4 + 8);
  uint64_t v15 = *(void *)(a4 + 16);
LABEL_28:
  uint64_t v179 = v9;
  *((_DWORD *)v9 + 28) = (*(void *)(v14 + 64) - *(void *)(v14 + 56)) >> 4;
  *(void *)(v16 + 88) |= 8uLL;
  if (v15 != v14)
  {
    unint64_t v34 = 0;
    int v182 = ((unint64_t)(v6 - v7) >> 5) + 0x400000;
    while (1)
    {
      VoiceNode = Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode(a1, *v13, *(void *)(v14 + 104 * v34), 7, v182, 0);
      size_t v36 = VoiceNode;
      if (!VoiceNode) {
        break;
      }
      uint64_t v37 = *((void *)v179 + 11);
      Phase::Controller::DVM::VoiceNode::Configure((uint64_t)VoiceNode, *(void *)(a4 + 8), *(void *)(a4 + 16), v34, v182, 0);
      unint64_t v38 = (Phase::Controller::DVM::Renderer::ChannelStrip *)(v37 + 32 * v34);
      unint64_t v39 = *(void *)v38;
      if (*(void *)v38) {
        BOOL v40 = v39 == (void)v36;
      }
      else {
        BOOL v40 = 1;
      }
      if (!v40)
      {
        BOOL v41 = *(void **)(v39 + 32);
        unint64_t v44 = (void *)*v41;
        unint64_t v42 = v41 + 1;
        char v43 = v44;
        if (v44 != v42)
        {
          do
          {
            Phase::Controller::DVM::VoiceNode::Connect((unint64_t)v36, 1, 0, (uint64_t)(v43 + 4));
            unint64_t v45 = (void *)v43[1];
            if (v45)
            {
              do
              {
                __int16 v46 = v45;
                unint64_t v45 = (void *)*v45;
              }
              while (v45);
            }
            else
            {
              do
              {
                __int16 v46 = (void *)v43[2];
                BOOL v40 = *v46 == (void)v43;
                char v43 = v46;
              }
              while (!v40);
            }
            char v43 = v46;
          }
          while (v46 != v42);
          unint64_t v39 = *(void *)v38;
        }
        Phase::Controller::DVM::VoiceNode::Disconnect(v39, 1);
        Phase::Controller::DVM::VoiceNode::Disconnect(v39, 0);
        Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(a1, *(void **)v38, 0);
        Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(a1, v36, a3);
      }
      *(void *)unint64_t v38 = v36;
      uint64_t v47 = v37 + 32 * v34;
      std::string __p = 0;
      uint64_t v191 = 0;
      uint64_t v192 = 0;
      int v49 = *(const void **)(v47 + 8);
      __int16 v48 = (uint64_t **)(v47 + 8);
      __int16 v50 = v48 + 1;
      std::vector<Phase::Controller::DVM::VoiceNode *>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode **,Phase::Controller::DVM::VoiceNode **>(&__p, v49, (uint64_t)v48[1], ((char *)v48[1] - (unsigned char *)v49) >> 3);
      if (__p == (void *)v191)
      {
        uint64_t v187 = 0;
        uint64_t v188 = 0;
        uint64_t v189 = 0;
      }
      else
      {
        uint64_t v51 = *(void *)__p;
        uint64_t v187 = 0;
        uint64_t v188 = 0;
        uint64_t v189 = 0;
        std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode::IOChannel*,Phase::Controller::DVM::VoiceNode::IOChannel*>(&v187, *(void *)(v51 + 32), *(void *)(v51 + 40), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v51 + 40) - *(void *)(v51 + 32)) >> 3));
      }
      NSObject *v50 = *v48;
      uint64_t v52 = *a5;
      uint64_t v53 = a5[1];
      if (*a5 == v53)
      {
LABEL_71:
        unint64_t HeadNode = Phase::Controller::DVM::Renderer::ChannelStrip::GetHeadNode(v38);
        unint64_t v74 = HeadNode;
        if (!HeadNode) {
          goto LABEL_246;
        }
        if (__p != (void *)v191 && *(void *)__p != HeadNode)
        {
          if (v187 == v188) {
LABEL_246:
          }
            std::terminate();
          Phase::Controller::DVM::VoiceNode::Disconnect(HeadNode, 1);
          uint64_t v76 = v187;
          uint64_t v75 = v188;
          if (v188 != v187)
          {
            unint64_t v77 = 0;
            do
            {
              __int16 v78 = (void *)(v76 + 24 * v77);
              unint64_t v81 = (void *)*v78;
              unint64_t v79 = v78 + 1;
              __int16 v80 = v81;
              if (v81 != v79)
              {
                do
                {
                  BOOL v82 = Phase::Controller::DVM::VoiceNode::Connect(v74, 1, v77, (uint64_t)(v80 + 4));
                  if (!v82)
                  {
                    BOOL v83 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)v82)
                                                                     + 80));
                    if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
                    {
                      __int16 v84 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(v80[4] + 24)];
                      int v85 = *((_DWORD *)v80 + 10);
                      uint64_t v86 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(v74 + 24)];
                      *(_DWORD *)buf = 136316930;
                      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = 1796;
                      *(_WORD *)&unsigned char buf[18] = 2048;
                      *(void *)&uint8_t buf[20] = a1;
                      *(_WORD *)&unsigned char buf[28] = 2048;
                      *(void *)&buf[30] = a2;
                      __int16 v194 = 2080;
                      v195 = v84;
                      __int16 v196 = 1024;
                      *(_DWORD *)uint64_t v197 = v85;
                      *(_WORD *)&v197[4] = 2080;
                      *(void *)&v197[6] = v86;
                      __int16 v198 = 1024;
                      int v199 = v77;
                      _os_log_impl(&dword_221E5E000, v83, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: rendererId %llu: unable to bridge connection(s) %s[%d] -> %s[%d]!", buf, 0x46u);
                    }
                  }
                  long long v87 = (void *)v80[1];
                  if (v87)
                  {
                    do
                    {
                      long long v88 = v87;
                      long long v87 = (void *)*v87;
                    }
                    while (v87);
                  }
                  else
                  {
                    do
                    {
                      long long v88 = (void *)v80[2];
                      BOOL v40 = *v88 == (void)v80;
                      __int16 v80 = v88;
                    }
                    while (!v40);
                  }
                  __int16 v80 = v88;
                }
                while (v88 != v79);
                uint64_t v76 = v187;
                uint64_t v75 = v188;
              }
              ++v77;
            }
            while (0xAAAAAAAAAAAAAAABLL * ((v75 - v76) >> 3) > v77);
          }
        }
        unint64_t v89 = (unint64_t *)__p;
        uint64_t v90 = (unint64_t *)v191;
        while (v89 != v90)
        {
          unint64_t v91 = (void *)*v89;
          unint64_t v92 = *v50;
          for (uint64_t i = *v48; i != v92; ++i)
          {
            if ((void *)*i == v91) {
              goto LABEL_96;
            }
          }
          uint64_t i = *v50;
LABEL_96:
          if (v92 == i)
          {
            Phase::Controller::DVM::VoiceNode::Disconnect(*v89, 1);
            Phase::Controller::DVM::VoiceNode::Disconnect((unint64_t)v91, 0);
            Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(a1, v91, 0);
          }
          ++v89;
        }
        int v94 = 1;
      }
      else
      {
        uint64_t v177 = (uint64_t *)(v37 + 32 * v34);
        uint64_t v54 = 0;
        char v55 = v177 + 3;
        int v56 = 0x400000;
        do
        {
          uint64_t v57 = *(void *)(v52 + 8);
          if (*(void *)(v52 + 16) - v57 != *(void *)(a4 + 16) - *(void *)(a4 + 8)) {
            goto LABEL_246;
          }
          unint64_t v58 = v54;
          float v59 = Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode(a1, *(void *)v52, *(void *)(v57 + 104 * v34), 6, v56, 0);
          uint64_t v54 = (uint64_t)v59;
          if (!v59) {
            goto LABEL_105;
          }
          Phase::Controller::DVM::VoiceNode::Configure((uint64_t)v59, *(void *)(v52 + 8), *(void *)(v52 + 16), v34, v56, 0);
          if (v58)
          {
            uint64_t v60 = Phase::Controller::DVM::VoiceNode::ConnectToNode(v58, v54);
            if ((v60 & 1) == 0)
            {
              int v95 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v60) + 80);
              if (!os_log_type_enabled(v95, OS_LOG_TYPE_ERROR)) {
                goto LABEL_105;
              }
              __int16 v96 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(v58 + 24)];
              unint64_t v97 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(v54 + 24)];
              *(_DWORD *)buf = 136316418;
              *(void *)&uint8_t buf[4] = "DVMGraph.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 1758;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&uint8_t buf[20] = a1;
              *(_WORD *)&unsigned char buf[28] = 2048;
              *(void *)&buf[30] = a2;
              __int16 v194 = 2080;
              v195 = v96;
              __int16 v196 = 2080;
              *(void *)uint64_t v197 = v97;
              __int16 v98 = v95;
              goto LABEL_104;
            }
          }
          __int16 v61 = *v50;
          if ((unint64_t)*v50 >= *v55)
          {
            uint64_t v63 = v61 - *v48;
            if ((unint64_t)(v63 + 1) >> 61) {
              std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v64 = *v55 - (void)*v48;
            uint64_t v65 = v64 >> 2;
            if (v64 >> 2 <= (unint64_t)(v63 + 1)) {
              uint64_t v65 = v63 + 1;
            }
            if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v66 = v65;
            }
            if (v66) {
              __int16 v67 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)v55, v66);
            }
            else {
              __int16 v67 = 0;
            }
            uint64_t v68 = (uint64_t *)&v67[8 * v63];
            uint64_t *v68 = v54;
            int v62 = v68 + 1;
            uint64_t v69 = *v50;
            uint64_t v70 = *v48;
            if (*v50 != *v48)
            {
              do
              {
                uint64_t v71 = *--v69;
                *--uint64_t v68 = v71;
              }
              while (v69 != v70);
              uint64_t v69 = *v48;
            }
            *__int16 v48 = v68;
            NSObject *v50 = v62;
            *char v55 = &v67[8 * v66];
            if (v69) {
              operator delete(v69);
            }
          }
          else
          {
            uint64_t *v61 = v54;
            int v62 = v61 + 1;
          }
          ++v56;
          NSObject *v50 = v62;
          v52 += 32;
        }
        while (v52 != v53);
        unint64_t v38 = (Phase::Controller::DVM::Renderer::ChannelStrip *)v177;
        uint64_t v72 = Phase::Controller::DVM::VoiceNode::ConnectToNode(*(v62 - 1), *v177);
        if (v72) {
          goto LABEL_71;
        }
        uint64_t v99 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v72) + 80);
        if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
        {
          __int16 v100 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(*(v62 - 1) + 24)];
          unint64_t v101 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(*v177 + 24)];
          *(_DWORD *)buf = 136316418;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1772;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&uint8_t buf[20] = a1;
          *(_WORD *)&unsigned char buf[28] = 2048;
          *(void *)&buf[30] = a2;
          __int16 v194 = 2080;
          v195 = v100;
          __int16 v196 = 2080;
          *(void *)uint64_t v197 = v101;
          __int16 v98 = v99;
LABEL_104:
          _os_log_impl(&dword_221E5E000, v98, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: rendererId %llu: unable to connect %s -> %s!", buf, 0x3Au);
        }
LABEL_105:
        int v94 = 0;
      }
      *(void *)buf = &v187;
      std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      if (__p)
      {
        uint64_t v191 = (uint64_t)__p;
        operator delete(__p);
      }
      if (!v94) {
        return 8;
      }
      ++v34;
      float v13 = (unint64_t *)a4;
      uint64_t v14 = *(void *)(a4 + 8);
      if (0x4EC4EC4EC4EC4EC5 * ((*(void *)(a4 + 16) - v14) >> 3) <= v34) {
        goto LABEL_110;
      }
    }
    unint64_t v109 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1692;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&uint8_t buf[20] = a1;
      *(_WORD *)&unsigned char buf[28] = 2048;
      *(void *)&buf[30] = a2;
      __int16 v194 = 1024;
      LODWORD(v195) = v34;
      _os_log_impl(&dword_221E5E000, v109, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: rendererId %llu could not create a voice for input channel %d! ChannelStrips from this channel and above won't be configured!", buf, 0x2Cu);
    }
    return 8;
  }
LABEL_110:
  __int16 v102 = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::SetRendererPlayState(a1, a2, a3, 1);
  unsigned __int8 v103 = v102;
  if (v102)
  {
    __int16 v104 = **(id **)(Phase::Logger::GetInstance(v102) + 224);
    if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1819;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&uint8_t buf[20] = v103;
      _os_log_impl(&dword_221E5E000, v104, OS_LOG_TYPE_ERROR, "%25s:%-5d RenderGroupMgr:: VoiceGraph::SetRendererPlayState returned retval %d", buf, 0x18u);
    }
  }
  *(void *)buf = a2;
  if (std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>(v178, (unint64_t *)buf))
  {
    uint64_t v105 = a1;
    __int16 v106 = *(uint64_t **)(a1 + 376);
    if (v106)
    {
      unsigned int v107 = 0;
      do
      {
        if (*((_DWORD *)v106 + 28) > (signed int)v107) {
          unsigned int v107 = *((_DWORD *)v106 + 28);
        }
        __int16 v106 = (uint64_t *)*v106;
      }
      while (v106);
    }
    else
    {
      unsigned int v107 = 0;
    }
    if (*(void *)(a1 + 800) == v107) {
      goto LABEL_236;
    }
    unint64_t v110 = v107;
    uint64_t v111 = (void **)(a1 + 440);
    if (*(void *)(a1 + 464))
    {
      uint64_t v112 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 440), 0xCuLL);
      if (!v112) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      unint64_t v113 = v112;
      unint64_t v114 = 0;
      while (1)
      {
        uint64_t v115 = *(void **)(v113[10] + 8 * v114);
        uint64_t v116 = v115[24];
        uint64_t v117 = v116 & 0xFF00000000;
        if (v114 >= v110)
        {
          if (!v117) {
            std::__throw_bad_optional_access[abi:ne180100]();
          }
          if (v116 == 2) {
            goto LABEL_138;
          }
          int v118 = 2;
        }
        else
        {
          if (!v117) {
            std::__throw_bad_optional_access[abi:ne180100]();
          }
          if (v116 != 2) {
            goto LABEL_138;
          }
          int v118 = 3;
        }
        Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(v105, v115, v118);
        uint64_t v105 = a1;
LABEL_138:
        if (++v114 == 12) {
          goto LABEL_235;
        }
      }
    }
    uint64_t v119 = (char *)operator new(0x68uLL);
    *((void *)v119 + 2) = 12;
    *((_DWORD *)v119 + 8) = 5;
    *(_OWORD *)(v119 + 40) = xmmword_2220A57F0;
    v119[56] = 0;
    *((_DWORD *)v119 + 15) = 0;
    v119[64] = 0;
    v119[68] = 0;
    *((void *)v119 + 9) = 0;
    *((void *)v119 + 10) = 0;
    *((void *)v119 + 3) = &unk_26D4761A8;
    *((void *)v119 + 1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
    *((void *)v119 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
    *(_OWORD *)uint64_t v119 = xmmword_2220A5800;
    unint64_t v120 = *(void *)(a1 + 448);
    if (v120)
    {
      uint8x8_t v121 = (uint8x8_t)vcnt_s8((int8x8_t)v120);
      v121.i16[0] = vaddlv_u8(v121);
      unint64_t v122 = v121.u32[0];
      if (v121.u32[0] > 1uLL)
      {
        uint64_t v123 = 12;
        if (v120 <= 0xC) {
          uint64_t v123 = 0xCu % *(void *)(a1 + 448);
        }
      }
      else
      {
        uint64_t v123 = ((_BYTE)v120 - 1) & 0xC;
      }
      uint64_t v127 = (void *)*((void *)*v111 + v123);
      if (v127)
      {
        for (uint64_t j = (void *)*v127; j; uint64_t j = (void *)*j)
        {
          unint64_t v129 = j[1];
          if (v129 == 12)
          {
            if (j[2] == 12)
            {
              std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,void *>>>::operator()[abi:ne180100](1, v119);
LABEL_211:
              uint64_t v149 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v111, 0xCuLL);
              if (!v149) {
                std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
              }
              __int16 v150 = v149;
              memset(buf, 0, 32);
              std::vector<Phase::Controller::DspNodeVoice>::resize((uint64_t *)&buf[8], 0xCuLL);
              uint64_t v151 = 0;
              uint64_t v184 = (uint64_t)(v150 + 3);
              *(void *)buf = 0x20999FECD11286CDLL;
              uint64_t v152 = (char **)(v150 + 10);
              do
              {
                unint64_t add = atomic_fetch_add(*(atomic_ullong *volatile *)(a1 + 80), 1uLL);
                uint64_t v154 = *(void *)&buf[8] + 104 * v151;
                *(void *)uint64_t v154 = add;
                std::vector<Phase::Controller::DspChannelIdBusValuePair>::resize((void **)(v154 + 32));
                std::vector<Phase::Controller::DspChannelIdBusValuePair>::resize((void **)(*(void *)&buf[8]
                                                                                         + 104 * v151
                                                                                         + 56));
                uint64_t v155 = Phase::Controller::DVM::VoiceGraph::CreateOrGetVoiceNode(a1, 0x20999FECD11286CDuLL, *(void *)(*(void *)&buf[8] + 104 * v151), 8, 6291456, 0);
                uint64_t v156 = v155;
                if (!v155) {
                  goto LABEL_246;
                }
                Phase::Controller::DVM::VoiceNode::Configure((uint64_t)v155, *(uint64_t *)&buf[8], *(uint64_t *)&buf[16], v151, 6291456, 0);
                uint64_t v158 = (void *)v150[11];
                unint64_t v157 = v150[12];
                if ((unint64_t)v158 >= v157)
                {
                  uint64_t v160 = ((char *)v158 - *v152) >> 3;
                  if ((unint64_t)(v160 + 1) >> 61) {
                    std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
                  }
                  uint64_t v161 = v157 - (void)*v152;
                  uint64_t v162 = v161 >> 2;
                  if (v161 >> 2 <= (unint64_t)(v160 + 1)) {
                    uint64_t v162 = v160 + 1;
                  }
                  if ((unint64_t)v161 >= 0x7FFFFFFFFFFFFFF8) {
                    unint64_t v163 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v163 = v162;
                  }
                  if (v163) {
                    uint64_t v164 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)(v150 + 12), v163);
                  }
                  else {
                    uint64_t v164 = 0;
                  }
                  v165 = &v164[8 * v160];
                  *(void *)v165 = v156;
                  uint64_t v159 = v165 + 8;
                  uint64_t v167 = (char *)v150[10];
                  uint64_t v166 = (char *)v150[11];
                  if (v166 != v167)
                  {
                    do
                    {
                      uint64_t v168 = *((void *)v166 - 1);
                      v166 -= 8;
                      *((void *)v165 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v168;
                      v165 -= 8;
                    }
                    while (v166 != v167);
                    uint64_t v166 = *v152;
                  }
                  v150[10] = v165;
                  v150[11] = v159;
                  v150[12] = &v164[8 * v163];
                  if (v166) {
                    operator delete(v166);
                  }
                }
                else
                {
                  *uint64_t v158 = v156;
                  uint64_t v159 = v158 + 1;
                }
                v150[11] = v159;
                ++v151;
              }
              while (v151 != 12);
              uint64_t v105 = a1;
              Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange((void *)a1, v184, 1, 0.0);
              if ((int)v110 <= 11)
              {
                unint64_t v169 = v110;
                do
                  Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(a1, *(void **)&(*v152)[8 * v169++], 2);
                while (v169 != 12);
              }
              std::string __p = &buf[8];
              std::vector<Phase::Controller::DspNodeVoice>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
LABEL_235:
              *(void *)(v105 + 800) = v110;
LABEL_236:
              uint64_t v170 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(v105 + 440), 0xCuLL);
              if (!v170) {
                std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
              }
              (*(void (**)(unsigned char *__return_ptr))(v170[3] + 40))(buf);
              v171 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>(v178, a2);
              v172 = (unint64_t *)v171[11];
              for (uint64_t k = (unint64_t *)v171[12]; v172 != k; v172 += 4)
              {
                unint64_t v174 = *v172;
                if (*(void *)(*v172 + 64) != *(void *)(*v172 + 56))
                {
                  unint64_t v175 = 0;
                  do
                  {
                    std::string __p = *(void **)(*(void *)buf + 8 * v175);
                    uint64_t v191 = 0x3F80000000000000;
                    LOBYTE(v192) = 1;
                    Phase::Controller::DVM::VoiceNode::Connect(v174, 0, v175++, (uint64_t)&__p);
                  }
                  while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v174 + 64) - *(void *)(v174 + 56)) >> 3) > v175);
                }
              }
              if (*(void *)buf)
              {
                *(void *)&uint8_t buf[8] = *(void *)buf;
                operator delete(*(void **)buf);
              }
              return 0;
            }
          }
          else
          {
            if (v121.u32[0] > 1uLL)
            {
              if (v129 >= v120) {
                v129 %= v120;
              }
            }
            else
            {
              v129 &= v120 - 1;
            }
            if (v129 != v123) {
              break;
            }
          }
        }
      }
      float v125 = *(float *)(a1 + 472);
      if ((float)(v125 * (float)v120) >= 1.0) {
        goto LABEL_197;
      }
      uint64_t v124 = 2 * v120;
      BOOL v126 = v122 > 1;
      if (v120 < 3) {
        BOOL v126 = 1;
      }
    }
    else
    {
      uint64_t v124 = 0;
      float v125 = *(float *)(a1 + 472);
      BOOL v126 = 1;
    }
    unint64_t v130 = v126 | v124;
    unint64_t v131 = vcvtps_u32_f32(1.0 / v125);
    if (v130 <= v131) {
      int8x8_t prime = (int8x8_t)v131;
    }
    else {
      int8x8_t prime = (int8x8_t)v130;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v120 = *(void *)(a1 + 448);
    }
    if (*(void *)&prime > v120) {
      goto LABEL_268;
    }
    if (*(void *)&prime >= v120) {
      goto LABEL_197;
    }
    unint64_t v139 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 464) / *(float *)(a1 + 472));
    if (v120 < 3 || (uint8x8_t v140 = (uint8x8_t)vcnt_s8((int8x8_t)v120), v140.i16[0] = vaddlv_u8(v140), v140.u32[0] > 1uLL))
    {
      unint64_t v139 = std::__next_prime(v139);
    }
    else
    {
      uint64_t v141 = 1 << -(char)__clz(v139 - 1);
      if (v139 >= 2) {
        unint64_t v139 = v141;
      }
    }
    if (*(void *)&prime <= v139) {
      int8x8_t prime = (int8x8_t)v139;
    }
    if (*(void *)&prime >= v120)
    {
      unint64_t v120 = *(void *)(a1 + 448);
      goto LABEL_197;
    }
    if (prime)
    {
LABEL_268:
      if (*(void *)&prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      unsigned int v133 = operator new(8 * *(void *)&prime);
      uint64_t v134 = *v111;
      *uint64_t v111 = v133;
      if (v134) {
        operator delete(v134);
      }
      uint64_t v135 = 0;
      *(int8x8_t *)(a1 + 448) = prime;
      do
        *((void *)*v111 + v135++) = 0;
      while (*(void *)&prime != v135);
      uint64_t v136 = *(void **)(a1 + 456);
      if (v136)
      {
        unint64_t v137 = v136[1];
        uint8x8_t v138 = (uint8x8_t)vcnt_s8(prime);
        v138.i16[0] = vaddlv_u8(v138);
        if (v138.u32[0] > 1uLL)
        {
          if (v137 >= *(void *)&prime) {
            v137 %= *(void *)&prime;
          }
        }
        else
        {
          v137 &= *(void *)&prime - 1;
        }
        *((void *)*v111 + v13std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = a1 + 456;
        __int16 v142 = (void *)*v136;
        if (*v136)
        {
          do
          {
            unint64_t v143 = v142[1];
            if (v138.u32[0] > 1uLL)
            {
              if (v143 >= *(void *)&prime) {
                v143 %= *(void *)&prime;
              }
            }
            else
            {
              v143 &= *(void *)&prime - 1;
            }
            if (v143 != v137)
            {
              if (!*((void *)*v111 + v143))
              {
                *((void *)*v111 + v143) = v136;
                goto LABEL_193;
              }
              *uint64_t v136 = *v142;
              *__int16 v142 = **((void **)*v111 + v143);
              **((void **)*v111 + v143) = v142;
              __int16 v142 = v136;
            }
            unint64_t v143 = v137;
LABEL_193:
            uint64_t v136 = v142;
            __int16 v142 = (void *)*v142;
            unint64_t v137 = v143;
          }
          while (v142);
        }
      }
      unint64_t v120 = (unint64_t)prime;
    }
    else
    {
      v176 = *v111;
      *uint64_t v111 = 0;
      if (v176) {
        operator delete(v176);
      }
      unint64_t v120 = 0;
      *(void *)(a1 + 448) = 0;
    }
LABEL_197:
    unint64_t v144 = *((void *)v119 + 1);
    uint8x8_t v145 = (uint8x8_t)vcnt_s8((int8x8_t)v120);
    v145.i16[0] = vaddlv_u8(v145);
    if (v145.u32[0] > 1uLL)
    {
      if (v144 >= v120) {
        v144 %= v120;
      }
    }
    else
    {
      v144 &= v120 - 1;
    }
    uint64_t v146 = *v111;
    uint64_t v147 = (void *)*((void *)*v111 + v144);
    if (v147)
    {
      *(void *)uint64_t v119 = *v147;
    }
    else
    {
      *(void *)uint64_t v119 = *(void *)(a1 + 456);
      *(void *)(a1 + 45std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v119;
      v146[v144] = a1 + 456;
      if (!*(void *)v119)
      {
LABEL_210:
        ++*(void *)(a1 + 464);
        goto LABEL_211;
      }
      unint64_t v148 = *(void *)(*(void *)v119 + 8);
      if (v145.u32[0] > 1uLL)
      {
        if (v148 >= v120) {
          v148 %= v120;
        }
      }
      else
      {
        v148 &= v120 - 1;
      }
      uint64_t v147 = (char *)*v111 + 8 * v148;
    }
    *uint64_t v147 = v119;
    goto LABEL_210;
  }
  uint64_t v108 = **(id **)(Phase::Logger::GetInstance(0) + 80);
  uint64_t result = os_log_type_enabled(v108, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1831;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&uint8_t buf[20] = a1;
    *(_WORD *)&unsigned char buf[28] = 2048;
    *(void *)&buf[30] = a2;
    _os_log_impl(&dword_221E5E000, v108, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: rendererId %llu does not exist!", buf, 0x26u);
    return 0;
  }
  return result;
}

void sub_221F21830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,void *>>>::operator()[abi:ne180100](1, v30);
  _Unwind_Resume(a1);
}

void Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(uint64_t a1, void *a2, int a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  (*(void (**)(unsigned char *__return_ptr, void *))(*a2 + 32))(v14, a2);
  int v6 = *((_DWORD *)a2 + 6);
  uint64_t v7 = operator new(0x48uLL);
  *((_DWORD *)v7 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
  *((_DWORD *)v7 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
  *((void *)v7 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a1 + 680;
  *((void *)v7 + 2) = &unk_26D476210;
  long long v8 = *(_OWORD *)&v14[16];
  *((_OWORD *)v7 + 2) = *(_OWORD *)v14;
  *((_OWORD *)v7 + 3) = v8;
  *((_DWORD *)v7 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v6;
  uint64_t v9 = *(void *)(a1 + 680);
  *(void *)uint64_t v7 = v9;
  *(void *)(v9 + 8) = v7;
  *(void *)(a1 + 680) = v7;
  ++*(void *)(a1 + 696);
  *((unsigned char *)a2 + 8) = 0;
  *((_DWORD *)a2 + 48) = a3;
  *((unsigned char *)a2 + 19std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  if (v6 == 1)
  {
    uint64_t v10 = "Procedure";
  }
  else
  {
    uint64_t v7 = (void *)(*(uint64_t (**)(void *))(*a2 + 16))(a2);
    uint64_t v10 = (const char *)*((void *)v7 + 6);
  }
  __int16 v11 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v7) + 80);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = a2[2];
    float v13 = Phase::Controller::DVM::kPlayStateStrings[a3];
    *(_DWORD *)uint64_t v14 = 136316162;
    *(void *)&v14[4] = "DVMGraph.mm";
    *(_WORD *)&v14[12] = 1024;
    *(_DWORD *)&v14[14] = 2292;
    *(_WORD *)&v14[18] = 2080;
    *(void *)&v14[20] = v10;
    *(_WORD *)&v14[28] = 2048;
    *(void *)&v14[30] = v12;
    __int16 v15 = 2080;
    uint64_t v16 = v13;
    _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_DEFAULT, "%25s:%-5d NRT set %s vid %llu to %s. \n", v14, 0x30u);
  }
}

uint64_t Phase::Controller::DVM::Renderer::ChannelStrip::GetHeadNode(Phase::Controller::DVM::Renderer::ChannelStrip *this)
{
  uint64_t v1 = (uint64_t *)*((void *)this + 1);
  if (v1 == *((uint64_t **)this + 2)) {
    return *(void *)this;
  }
  uint64_t result = *v1;
  if (!*v1) {
    __assert_rtn("GetHeadNode", "DVMDspNode.hpp", 346, "mPreEffects.front() != nullptr");
  }
  return result;
}

void std::vector<Phase::Controller::DspNodeVoice>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0x4EC4EC4EC4EC4EC5 * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Controller::DspNodeVoice>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 104 * a2;
    while (v3 != v7)
    {
      v3 -= 104;
      std::allocator<Phase::Controller::DspNodeVoice>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void std::vector<Phase::Controller::DspChannelIdBusValuePair>::resize(void **a1)
{
  uint64_t v2 = (char *)a1[1];
  if (v2 != *a1)
  {
    if ((unint64_t)(v2 - (unsigned char *)*a1) < 0x11) {
      return;
    }
    uint64_t v3 = (uint64_t)*a1 + 16;
    goto LABEL_6;
  }
  uint64_t v4 = (uint64_t)(a1 + 2);
  if (a1[2] != v2)
  {
    *(_DWORD *)uint64_t v2 = 0x7FFFFFFF;
    *((void *)v2 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0x7FEFFFFFFFFFFFFFLL;
    uint64_t v3 = (uint64_t)(v2 + 16);
LABEL_6:
    a1[1] = (void *)v3;
    return;
  }
  BOOL v5 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>(v4, 1uLL);
  uint64_t v7 = (char *)*a1;
  unint64_t v6 = (char *)a1[1];
  *(_DWORD *)BOOL v5 = 0x7FFFFFFF;
  *((void *)v5 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0x7FEFFFFFFFFFFFFFLL;
  long long v8 = v5 + 16;
  uint64_t v10 = &v5[16 * v9];
  if (v6 != v7)
  {
    do
    {
      *((_OWORD *)v5 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((_OWORD *)v6 - 1);
      v5 -= 16;
      v6 -= 16;
    }
    while (v6 != v7);
    unint64_t v6 = (char *)*a1;
  }
  *a1 = v5;
  a1[1] = v8;
  a1[2] = v10;
  if (v6)
  {
    operator delete(v6);
  }
}

uint64_t Phase::Controller::DVM::VoiceGraph::ConnectSubmixToRenderer(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3, unint64_t a4, double a5)
{
  uint64_t v85 = *MEMORY[0x263EF8340];
  *(void *)buf = a2;
  *(void *)&uint8_t buf[8] = a3;
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 17, buf))
  {
    unint64_t v38 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      return 3;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1932;
    __int16 v73 = 2048;
    unint64_t v74 = a1;
    __int16 v75 = 2048;
    unint64_t v76 = a2;
    unint64_t v39 = "%25s:%-5d graph@%p: submixId %llu does not exist";
    BOOL v40 = v38;
LABEL_24:
    _os_log_impl(&dword_221E5E000, v40, OS_LOG_TYPE_ERROR, v39, buf, 0x26u);
    return 3;
  }
  v86.mStorage[0] = a2;
  v86.mStorage[1] = a3;
  uint64_t Submix = Phase::Controller::DVM::VoiceGraph::GetSubmix(a1, v86);
  __int16 v11 = Submix;
  uint64_t v12 = Submix[5];
  if ((v12 & 0xFF00000000) == 0)
  {
    BOOL v41 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)Submix) + 80);
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      unint64_t v42 = Phase::Controller::DVM::kSubmixTypeStrings[v11[7]];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1941;
      __int16 v73 = 2048;
      unint64_t v74 = a1;
      __int16 v75 = 2048;
      unint64_t v76 = a2;
      __int16 v77 = 2080;
      __int16 v78 = v42;
      char v43 = "%25s:%-5d graph@%p: submixId %llu, type %s is not configured";
      unint64_t v44 = v41;
      uint32_t v45 = 48;
LABEL_33:
      _os_log_impl(&dword_221E5E000, v44, OS_LOG_TYPE_ERROR, v43, buf, v45);
    }
    return 5;
  }
  if (!v12)
  {
    __int16 v46 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)Submix) + 80);
    BOOL v47 = os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v47)
    {
      __int16 v48 = Phase::Controller::DVM::kSubmixTypeStrings[v11[7]];
      *(_DWORD *)buf = 136316418;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1951;
      __int16 v73 = 2048;
      unint64_t v74 = a1;
      __int16 v75 = 2048;
      unint64_t v76 = a2;
      __int16 v77 = 2080;
      __int16 v78 = v48;
      __int16 v79 = 2048;
      *(void *)__int16 v80 = a4;
      _os_log_impl(&dword_221E5E000, v46, OS_LOG_TYPE_DEFAULT, "%25s:%-5d graph@%p: trying to connect submixId %llu, type %s in Stopped state to rendererId %llu. No-op.", buf, 0x3Au);
      return 0;
    }
    return result;
  }
  *(void *)buf = a4;
  if (!std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)a1 + 45, (unint64_t *)buf))
  {
    __int16 v50 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      return 3;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 1957;
    __int16 v73 = 2048;
    unint64_t v74 = a1;
    __int16 v75 = 2048;
    unint64_t v76 = a4;
    unint64_t v39 = "%25s:%-5d graph@%p: rendererId %llu does not exist";
    BOOL v40 = v50;
    goto LABEL_24;
  }
  Renderer = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetRenderer(a1, a4);
  uint64_t v14 = Renderer;
  uint64_t v15 = *((void *)Renderer + 8);
  uint64_t v16 = *((void *)Renderer + 9);
  if (v15 == v16 || !*((unsigned char *)Renderer + 44))
  {
    int v49 = **(id **)(Phase::Logger::GetInstance(Renderer) + 80);
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1965;
      __int16 v73 = 2048;
      unint64_t v74 = a1;
      __int16 v75 = 2048;
      unint64_t v76 = a4;
      char v43 = "%25s:%-5d graph@%p: rendererId %llu is not configured";
      unint64_t v44 = v49;
      uint32_t v45 = 38;
      goto LABEL_33;
    }
    return 5;
  }
  uint64_t v17 = v16 - v15;
  uint64_t v18 = v11[9];
  uint64_t v19 = v11[10];
  if (0x8E38E38E38E38E39 * ((v19 - v18) >> 3) == v17 >> 5)
  {
    if (v19 == v18)
    {
      uint64_t result = 0;
      *((void *)a1 + 11) |= 8uLL;
      return result;
    }
    unint64_t v20 = 0;
    do
    {
      unint64_t v21 = (uint64_t *)(v18 + 72 * v20);
      uint64_t v23 = *v21;
      uint64_t v22 = v21[1];
      if (v23 == v22)
      {
        float v59 = **(id **)(Phase::Logger::GetInstance(Renderer) + 80);
        if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
          return 8;
        }
        __int16 v61 = Phase::Controller::DVM::kSubmixTypeStrings[v11[7]];
        *(_DWORD *)buf = 136316674;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1986;
        __int16 v73 = 2048;
        unint64_t v74 = a1;
        __int16 v75 = 2048;
        unint64_t v76 = a2;
        __int16 v77 = 2080;
        __int16 v78 = v61;
        __int16 v79 = 1024;
        *(_DWORD *)__int16 v80 = v20;
        *(_WORD *)&v80[4] = 2048;
        *(void *)&v80[6] = a4;
        char v55 = "%25s:%-5d graph@%p: trying to connect an empty submixId %llu, type %s, channel %d to rendererId %llu.";
        goto LABEL_45;
      }
      Renderer = (Phase::Logger *)(*(uint64_t (**)(void))(**(void **)(v22 - 8) + 16))(*(void *)(v22 - 8));
      unint64_t v24 = (unsigned char *)*((void *)Renderer + 6);
      if (!v24) {
        goto LABEL_41;
      }
      unsigned int v25 = *v24;
      if (!*v24) {
        goto LABEL_41;
      }
      size_t v26 = v24 + 1;
      uint64_t v27 = 0xCBF29CE484222325;
      do
      {
        uint64_t v27 = 0x100000001B3 * (v27 ^ v25);
        unsigned int v28 = *v26++;
        unsigned int v25 = v28;
      }
      while (v28);
      if (v27 != 0x235B3F2D33EB877ALL)
      {
LABEL_41:
        float v59 = **(id **)(Phase::Logger::GetInstance(Renderer) + 80);
        if (!os_log_type_enabled(v59, OS_LOG_TYPE_ERROR)) {
          return 8;
        }
        uint64_t v60 = Phase::Controller::DVM::kSubmixTypeStrings[v11[7]];
        *(_DWORD *)buf = 136316674;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1997;
        __int16 v73 = 2048;
        unint64_t v74 = a1;
        __int16 v75 = 2048;
        unint64_t v76 = a2;
        __int16 v77 = 2080;
        __int16 v78 = v60;
        __int16 v79 = 1024;
        *(_DWORD *)__int16 v80 = v20;
        *(_WORD *)&v80[4] = 2048;
        *(void *)&v80[6] = a4;
        char v55 = "%25s:%-5d graph@%p: trying to connect submixId %llu, type %s, channel %d to rendererId %llu without a Subm"
              "ixGain voice as effect tail.";
LABEL_45:
        int v56 = v59;
        os_log_type_t v57 = OS_LOG_TYPE_ERROR;
        uint32_t v58 = 64;
        goto LABEL_46;
      }
      ++v20;
      uint64_t v18 = v11[9];
      uint64_t v29 = v11[10];
    }
    while (0x8E38E38E38E38E39 * ((v29 - v18) >> 3) > v20);
    *((void *)a1 + 11) |= 8uLL;
    if (v29 == v18) {
      return 0;
    }
    uint64_t v30 = 0;
    unint64_t v31 = 0;
    for (uint64_t i = 8; ; i += 72)
    {
      unint64_t HeadNode = Phase::Controller::DVM::Renderer::ChannelStrip::GetHeadNode((Phase::Controller::DVM::Renderer::ChannelStrip *)(*((void *)v14 + 8) + v30));
      uint64_t v35 = *(void *)(*(void *)(v11[9] + i) - 8);
      uint64_t v68 = v35;
      int v69 = 3;
      float v32 = a5;
      float v70 = v32;
      char v71 = 1;
      BOOL v36 = Phase::Controller::DVM::VoiceNode::Connect(HeadNode, 1, 0, (uint64_t)&v68);
      if (!v36) {
        break;
      }
      uint64_t result = 0;
      ++v31;
      v30 += 32;
      if (0x8E38E38E38E38E39 * ((uint64_t)(v11[10] - v11[9]) >> 3) <= v31) {
        return result;
      }
    }
    int v62 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v36) + 80);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      uint64_t v63 = Phase::Controller::DVM::kSubmixTypeStrings[v11[7]];
      uint64_t v64 = *(void *)(v35 + 16);
      unint64_t v65 = *(void *)(HeadNode + 16);
      *(_DWORD *)buf = 136317186;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2020;
      __int16 v73 = 2048;
      unint64_t v74 = a1;
      __int16 v75 = 2048;
      unint64_t v76 = a2;
      __int16 v77 = 2080;
      __int16 v78 = v63;
      __int16 v79 = 2048;
      *(void *)__int16 v80 = v64;
      *(_WORD *)&v80[8] = 2048;
      *(void *)&v80[10] = a4;
      __int16 v81 = 2048;
      unint64_t v82 = v65;
      __int16 v83 = 2048;
      double v84 = a5;
      _os_log_impl(&dword_221E5E000, v62, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: Failed to connect submixId %llu, type %s tail node (voiceId %llu) -> rendererId %llu head node (voiceId %llu) with gaiuint64_t n = %f. Undoing all previously connected channels!", buf, 0x58u);
    }
    if (v31)
    {
      uint64_t v66 = 0;
      do
      {
        unint64_t v67 = Phase::Controller::DVM::Renderer::ChannelStrip::GetHeadNode((Phase::Controller::DVM::Renderer::ChannelStrip *)(*((void *)v14 + 8) + v66));
        Phase::Controller::DVM::VoiceNode::DisconnectFromNode(v67, 1, *(void *)(*(void *)(v11[9] + i) - 8));
        v66 += 32;
        --v31;
      }
      while (v31);
    }
  }
  else
  {
    uint64_t v51 = **(id **)(Phase::Logger::GetInstance(Renderer) + 80);
    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v52 = Phase::Controller::DVM::kSubmixTypeStrings[v11[7]];
      uint64_t v53 = (uint64_t)(*((void *)v14 + 9) - *((void *)v14 + 8)) >> 5;
      unint64_t v54 = 0x8E38E38E38E38E39 * ((uint64_t)(v11[10] - v11[9]) >> 3);
      *(_DWORD *)buf = 136316930;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1974;
      __int16 v73 = 2048;
      unint64_t v74 = a1;
      __int16 v75 = 2048;
      unint64_t v76 = a2;
      __int16 v77 = 2080;
      __int16 v78 = v52;
      __int16 v79 = 2048;
      *(void *)__int16 v80 = a4;
      *(_WORD *)&v80[8] = 2048;
      *(void *)&v80[10] = v53;
      __int16 v81 = 2048;
      unint64_t v82 = v54;
      char v55 = "%25s:%-5d graph@%p: channel mistmatch trying to connect submixId %llu, type %s to rendererId %llu [%lu,%lu].";
      int v56 = v51;
      os_log_type_t v57 = OS_LOG_TYPE_DEFAULT;
      uint32_t v58 = 78;
LABEL_46:
      _os_log_impl(&dword_221E5E000, v56, v57, v55, buf, v58);
    }
  }
  return 8;
}

uint64_t Phase::Controller::DVM::VoiceGraph::UpdateSubmixToRendererConnectionGain(Phase::Controller::DVM::VoiceGraph *this, UniqueObjectId *a2, unint64_t *a3, double a4)
{
  uint64_t v54 = *MEMORY[0x263EF8340];
  *(UniqueObjectId *)buf = *a2;
  if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)this + 17, buf))
  {
    unsigned int v28 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      unint64_t v29 = a2->mStorage[0];
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2041;
      __int16 v46 = 2048;
      BOOL v47 = this;
      __int16 v48 = 2048;
      unint64_t v49 = v29;
      uint64_t v30 = "%25s:%-5d graph@%p: submixId %llu does not exist";
      unint64_t v31 = v28;
LABEL_38:
      _os_log_impl(&dword_221E5E000, v31, OS_LOG_TYPE_ERROR, v30, buf, 0x26u);
    }
    return 3;
  }
  uint64_t Submix = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetSubmix(this, *a2);
  uint64_t v9 = Submix;
  if (!*((unsigned char *)Submix + 44))
  {
    float v32 = **(id **)(Phase::Logger::GetInstance(Submix) + 80);
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      unint64_t v33 = a2->mStorage[0];
      unint64_t v34 = Phase::Controller::DVM::kSubmixTypeStrings[*((void *)v9 + 7)];
      *(_DWORD *)buf = 136316162;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2050;
      __int16 v46 = 2048;
      BOOL v47 = this;
      __int16 v48 = 2048;
      unint64_t v49 = v33;
      __int16 v50 = 2080;
      unint64_t v51 = (unint64_t)v34;
      uint64_t v35 = "%25s:%-5d graph@%p: submixId %llu, type %s is not configured";
      BOOL v36 = v32;
      uint32_t v37 = 48;
LABEL_34:
      _os_log_impl(&dword_221E5E000, v36, OS_LOG_TYPE_ERROR, v35, buf, v37);
    }
    return 5;
  }
  *(void *)buf = *a3;
  if (!std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 45, (unint64_t *)buf))
  {
    BOOL v40 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      unint64_t v41 = *a3;
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2056;
      __int16 v46 = 2048;
      BOOL v47 = this;
      __int16 v48 = 2048;
      unint64_t v49 = v41;
      uint64_t v30 = "%25s:%-5d graph@%p: rendererId %llu does not exist";
      unint64_t v31 = v40;
      goto LABEL_38;
    }
    return 3;
  }
  Renderer = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetRenderer(this, *a3);
  __int16 v11 = Renderer;
  if (*((void *)Renderer + 8) == *((void *)Renderer + 9) || !*((unsigned char *)Renderer + 44))
  {
    unint64_t v38 = **(id **)(Phase::Logger::GetInstance(Renderer) + 80);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      unint64_t v39 = *a3;
      *(_DWORD *)buf = 136315906;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 2064;
      __int16 v46 = 2048;
      BOOL v47 = this;
      __int16 v48 = 2048;
      unint64_t v49 = v39;
      uint64_t v35 = "%25s:%-5d graph@%p: rendererId %llu is not configured";
      BOOL v36 = v38;
      uint32_t v37 = 38;
      goto LABEL_34;
    }
    return 5;
  }
  if (!*((unsigned char *)v9 + 44)) {
    std::terminate();
  }
  uint64_t v13 = *((void *)v9 + 9);
  uint64_t v12 = *((void *)v9 + 10);
  if (v12 != v13)
  {
    unint64_t v14 = 0;
    do
    {
      uint64_t v15 = *(void *)(*(void *)(v13 + 72 * v14 + 8) - 8);
      uint64_t v16 = *(float ***)(v15 + 56);
      unint64_t v44 = *(float ***)(v15 + 64);
      if (v16 != v44)
      {
        unint64_t v43 = v14;
        do
        {
          uint64_t v17 = *v16;
          if (*v16 != (float *)(v16 + 1))
          {
            do
            {
              uint64_t v18 = (Phase::Controller::DVM::Renderer::ChannelStrip *)*((void *)v11 + 8);
              uint64_t v19 = (Phase::Controller::DVM::Renderer::ChannelStrip *)*((void *)v11 + 9);
              while (v18 != v19)
              {
                Renderer = (Phase::Logger *)Phase::Controller::DVM::Renderer::ChannelStrip::GetHeadNode(v18);
                if (Renderer == *((Phase::Logger **)v17 + 4))
                {
                  uint64_t result = 0;
                  if (v17[11] != a4)
                  {
                    float v42 = a4;
                    v17[11] = v42;
                    *((unsigned char *)v17 + 48) = 1;
                    *((void *)this + 11) |= 4uLL;
                  }
                  return result;
                }
                uint64_t v18 = (Phase::Controller::DVM::Renderer::ChannelStrip *)((char *)v18 + 32);
              }
              unint64_t v20 = (float *)*((void *)v17 + 1);
              if (v20)
              {
                do
                {
                  unint64_t v21 = (float **)v20;
                  unint64_t v20 = *(float **)v20;
                }
                while (v20);
              }
              else
              {
                do
                {
                  unint64_t v21 = (float **)*((void *)v17 + 2);
                  BOOL v22 = *v21 == v17;
                  uint64_t v17 = (float *)v21;
                }
                while (!v22);
              }
              uint64_t v17 = (float *)v21;
            }
            while (v21 != v16 + 1);
          }
          v16 += 3;
        }
        while (v16 != v44);
        uint64_t v13 = *((void *)v9 + 9);
        uint64_t v12 = *((void *)v9 + 10);
        unint64_t v14 = v43;
      }
      ++v14;
    }
    while (0x8E38E38E38E38E39 * ((v12 - v13) >> 3) > v14);
  }
  uint64_t v23 = **(id **)(Phase::Logger::GetInstance(Renderer) + 80);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    unint64_t v24 = (Phase::Controller::DVM::VoiceGraph *)a2->mStorage[0];
    unsigned int v25 = Phase::Controller::DVM::kSubmixTypeStrings[*((void *)v9 + 7)];
    unint64_t v26 = *a3;
    *(_DWORD *)buf = 136316418;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 2103;
    __int16 v46 = 2048;
    BOOL v47 = v24;
    __int16 v48 = 2080;
    unint64_t v49 = (unint64_t)v25;
    __int16 v50 = 2048;
    unint64_t v51 = v26;
    __int16 v52 = 2048;
    double v53 = a4;
    _os_log_impl(&dword_221E5E000, v23, OS_LOG_TYPE_ERROR, "%25s:%-5d No connection found from submixId %llu, type %s to rendererId %llu. Connection gain won't be updated to %f", buf, 0x3Au);
  }
  return 1;
}

uint64_t Phase::Controller::DVM::VoiceGraph::AddMaster(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2)
{
  unint64_t v3 = a2;
  uint64_t v44 = *MEMORY[0x263EF8340];
  *(void *)uint32_t v37 = a2;
  BOOL v5 = (void **)((char *)this + 400);
  unint64_t v6 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 50, (unint64_t *)v37);
  if (!v6)
  {
    unint64_t v9 = *((void *)this + 51);
    if (v9)
    {
      uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
      v10.i16[0] = vaddlv_u8(v10);
      if (v10.u32[0] > 1uLL)
      {
        unint64_t v2 = v3;
        if (v9 <= v3) {
          unint64_t v2 = v3 % v9;
        }
      }
      else
      {
        unint64_t v2 = (v9 - 1) & v3;
      }
      __int16 v11 = (void *)*((void *)*v5 + v2);
      if (v11)
      {
        for (uint64_t i = (void *)*v11; i; uint64_t i = (void *)*i)
        {
          unint64_t v13 = i[1];
          if (v13 == v3)
          {
            if (i[2] == v3) {
              return 0;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9) {
                v13 %= v9;
              }
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v2) {
              break;
            }
          }
        }
      }
    }
    unint64_t v14 = operator new(0x68uLL);
    uint64_t v15 = (void *)((char *)this + 416);
    void *v14 = 0;
    v14[1] = v3;
    *((_DWORD *)v14 + 8) = 4;
    v14[5] = v3;
    v14[6] = 0;
    *((unsigned char *)v14 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    *((_DWORD *)v14 + 15) = 0;
    *((unsigned char *)v14 + 64) = 0;
    *((unsigned char *)v14 + 68) = 0;
    v14[9] = 0;
    v14[10] = 0;
    void v14[2] = v3;
    void v14[3] = &unk_26D476168;
    float v16 = (float)(unint64_t)(*((void *)this + 53) + 1);
    v14[11] = 0;
    v14[12] = 0;
    float v17 = *((float *)this + 108);
    if ((((float)(v17 * (float)v9) >= v16) & ~(v9 == 0)) != 0)
    {
      unint64_t v3 = v2;
      goto LABEL_67;
    }
    BOOL v18 = 1;
    if (v9 >= 3) {
      BOOL v18 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v19 = v18 | (2 * v9);
    unint64_t v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20) {
      int8x8_t prime = (int8x8_t)v20;
    }
    else {
      int8x8_t prime = (int8x8_t)v19;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v9 = *((void *)this + 51);
    }
    if (*(void *)&prime > v9) {
      goto LABEL_34;
    }
    if (*(void *)&prime < v9)
    {
      unint64_t v28 = vcvtps_u32_f32((float)*((unint64_t *)this + 53) / *((float *)this + 108));
      if (v9 < 3 || (uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
      {
        unint64_t v28 = std::__next_prime(v28);
      }
      else
      {
        uint64_t v30 = 1 << -(char)__clz(v28 - 1);
        if (v28 >= 2) {
          unint64_t v28 = v30;
        }
      }
      if (*(void *)&prime <= v28) {
        int8x8_t prime = (int8x8_t)v28;
      }
      if (*(void *)&prime >= v9)
      {
        unint64_t v9 = *((void *)this + 51);
      }
      else
      {
        if (prime)
        {
LABEL_34:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          BOOL v22 = operator new(8 * *(void *)&prime);
          uint64_t v23 = *v5;
          char *v5 = v22;
          if (v23) {
            operator delete(v23);
          }
          uint64_t v24 = 0;
          *((int8x8_t *)this + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = prime;
          do
            *((void *)*v5 + v24++) = 0;
          while (*(void *)&prime != v24);
          unsigned int v25 = (void *)*v15;
          if (*v15)
          {
            unint64_t v26 = v25[1];
            uint8x8_t v27 = (uint8x8_t)vcnt_s8(prime);
            v27.i16[0] = vaddlv_u8(v27);
            if (v27.u32[0] > 1uLL)
            {
              if (v26 >= *(void *)&prime) {
                v26 %= *(void *)&prime;
              }
            }
            else
            {
              v26 &= *(void *)&prime - 1;
            }
            *((void *)*v5 + v2std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v15;
            unint64_t v31 = (void *)*v25;
            if (*v25)
            {
              do
              {
                unint64_t v32 = v31[1];
                if (v27.u32[0] > 1uLL)
                {
                  if (v32 >= *(void *)&prime) {
                    v32 %= *(void *)&prime;
                  }
                }
                else
                {
                  v32 &= *(void *)&prime - 1;
                }
                if (v32 != v26)
                {
                  if (!*((void *)*v5 + v32))
                  {
                    *((void *)*v5 + v32) = v25;
                    goto LABEL_59;
                  }
                  *unsigned int v25 = *v31;
                  void *v31 = **((void **)*v5 + v32);
                  **((void **)*v5 + v32) = v31;
                  unint64_t v31 = v25;
                }
                unint64_t v32 = v26;
LABEL_59:
                unsigned int v25 = v31;
                unint64_t v31 = (void *)*v31;
                unint64_t v26 = v32;
              }
              while (v31);
            }
          }
          unint64_t v9 = (unint64_t)prime;
          goto LABEL_63;
        }
        BOOL v36 = *v5;
        char *v5 = 0;
        if (v36) {
          operator delete(v36);
        }
        unint64_t v9 = 0;
        *((void *)this + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
      }
    }
LABEL_63:
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v9 <= v3) {
        v3 %= v9;
      }
    }
    else
    {
      v3 &= v9 - 1;
    }
LABEL_67:
    unint64_t v33 = *v5;
    unint64_t v34 = (void *)*((void *)*v5 + v3);
    if (v34)
    {
      void *v14 = *v34;
    }
    else
    {
      void *v14 = *v15;
      void *v15 = v14;
      v33[v3] = v15;
      if (!*v14)
      {
LABEL_76:
        uint64_t result = 0;
        ++*((void *)this + 53);
        return result;
      }
      unint64_t v35 = *(void *)(*v14 + 8);
      if ((v9 & (v9 - 1)) != 0)
      {
        if (v35 >= v9) {
          v35 %= v9;
        }
      }
      else
      {
        v35 &= v9 - 1;
      }
      unint64_t v34 = (char *)*v5 + 8 * v35;
    }
    *unint64_t v34 = v14;
    goto LABEL_76;
  }
  uint64_t v7 = **(id **)(Phase::Logger::GetInstance(v6) + 80);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)uint32_t v37 = 136315906;
    *(void *)&v37[4] = "DVMGraph.mm";
    __int16 v38 = 1024;
    int v39 = 2116;
    __int16 v40 = 2048;
    unint64_t v41 = this;
    __int16 v42 = 2048;
    unint64_t v43 = v3;
    _os_log_impl(&dword_221E5E000, v7, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: masterId %llu already exists!", v37, 0x26u);
  }
  return 4;
}

void sub_221F22F50(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,void *>>>::operator()[abi:ne180100](1, v1);
  _Unwind_Resume(a1);
}

void *Phase::Controller::DVM::VoiceGraph::RemoveMaster(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2)
{
  unint64_t v5 = a2;
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)this + 50, &v5);
  if (result) {
    return (void *)Phase::Controller::DVM::VoiceGraph::SetMasterPlayState(this, a2, 0);
  }
  return result;
}

uint64_t Phase::Controller::DVM::VoiceGraph::SetMasterPlayState(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, int a3)
{
  uint64_t v20 = *MEMORY[0x263EF8340];
  *(void *)__int16 v11 = a2;
  if (std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)a1 + 50, (unint64_t *)v11))
  {
    Master = Phase::Controller::DVM::VoiceGraph::GetMaster(a1, a2);
    int v7 = Phase::Controller::DVM::VoiceGraph::PreprocessPlayStateChange((uint64_t)a1, (uint64_t)Master, a3);
    if (v7 != 8)
    {
      if (v7 == 4) {
        return 1;
      }
      *((void *)a1 + 11) |= 8uLL;
      Phase::Controller::DVM::VoiceGraph::SchedulePlayStateChange(a1, (uint64_t)Master, a3, 0.0);
    }
    return 0;
  }
  else
  {
    unint64_t v9 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint8x8_t v10 = Phase::Controller::DVM::kPlayStateStrings[a3];
      *(_DWORD *)__int16 v11 = 136316162;
      *(void *)&v11[4] = "DVMGraph.mm";
      __int16 v12 = 1024;
      int v13 = 2583;
      __int16 v14 = 2048;
      uint64_t v15 = a1;
      __int16 v16 = 2080;
      float v17 = v10;
      __int16 v18 = 2048;
      unint64_t v19 = a2;
      _os_log_impl(&dword_221E5E000, v9, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: state change request %s, masterId %llu does not exist!", v11, 0x30u);
    }
    return 3;
  }
}

uint64_t Phase::Controller::DVM::VoiceGraph::SetParameters(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3, void *a4)
{
  if (*a4 == a4[1]) {
    return 0;
  }
  VoiceNode = Phase::Controller::DVM::VoiceGraph::GetVoiceNode(a1, a2, a3);
  if (!VoiceNode) {
    return 3;
  }
  Phase::Controller::DVM::VoiceNode::SetParameters(VoiceNode, (uint64_t)a4);
  uint64_t result = 0;
  *((void *)a1 + 11) |= 2uLL;
  return result;
}

void *Phase::Controller::DVM::VoiceGraph::GetVoiceNode(Phase::Controller::DVM::VoiceGraph *this, unint64_t a2, unint64_t a3)
{
  v8[0] = a2;
  v8[1] = a3;
  unint64_t v5 = std::__tree<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<std::pair<unsigned long long,long long>,std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::less<std::pair<unsigned long long,long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>>>::find<std::pair<unsigned long long,long long>>((uint64_t)this + 528, v8);
  if ((void *)((char *)this + 536) == v5) {
    return 0;
  }
  uint64_t v6 = v5[6];
  if (!v6) {
    return 0;
  }
  v8[0] = a3;
  uint64_t result = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)(v6 + 32), v8);
  if (result) {
    return (void *)result[3];
  }
  return result;
}

void Phase::Controller::DVM::VoiceNode::SetParameters(void *a1, uint64_t a2)
{
  unint64_t v2 = *(_DWORD **)a2;
  unint64_t v3 = *(_DWORD **)(a2 + 8);
  if (*(_DWORD **)a2 != v3)
  {
    unint64_t v5 = (void **)(a1 + 13);
    uint64_t v6 = a1 + 15;
    do
    {
      int v7 = (_OWORD *)a1[13];
      long long v8 = (_OWORD *)a1[14];
      if (v7 == v8)
      {
        unint64_t v9 = (_DWORD *)a1[13];
      }
      else
      {
        unint64_t v9 = (_DWORD *)a1[13];
        while (*v9 != *v2)
        {
          v9 += 4;
          if (v9 == (_DWORD *)v8) {
            goto LABEL_11;
          }
        }
      }
      if (v9 == (_DWORD *)v8)
      {
LABEL_11:
        if ((unint64_t)v8 >= *v6)
        {
          uint64_t v11 = v8 - v7;
          unint64_t v12 = v11 + 1;
          if ((unint64_t)(v11 + 1) >> 60) {
            std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v13 = *v6 - (void)v7;
          if (v13 >> 3 > v12) {
            unint64_t v12 = v13 >> 3;
          }
          if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v14 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v14 = v12;
          }
          if (v14) {
            uint64_t v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>((uint64_t)v6, v14);
          }
          else {
            uint64_t v15 = 0;
          }
          __int16 v16 = &v15[16 * v11];
          *(_OWORD *)__int16 v16 = *(_OWORD *)v2;
          __int16 v18 = (char *)a1[13];
          float v17 = (char *)a1[14];
          unint64_t v19 = v16;
          if (v17 != v18)
          {
            do
            {
              *((_OWORD *)v19 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((_OWORD *)v17 - 1);
              v19 -= 16;
              v17 -= 16;
            }
            while (v17 != v18);
            float v17 = (char *)*v5;
          }
          uint8x8_t v10 = v16 + 16;
          a1[13] = v19;
          a1[14] = v16 + 16;
          a1[15] = &v15[16 * v14];
          if (v17) {
            operator delete(v17);
          }
        }
        else
        {
          _OWORD *v8 = *(_OWORD *)v2;
          uint8x8_t v10 = v8 + 1;
        }
        a1[14] = v10;
      }
      else
      {
        *(_OWORD *)unint64_t v9 = *(_OWORD *)v2;
      }
      v2 += 4;
    }
    while (v2 != v3);
  }
}

uint64_t Phase::Controller::DVM::VoiceGraph::SetBufferParameters(Phase::Controller::DVM::VoiceGraph *a1, unint64_t a2, unint64_t a3, uint64_t *a4)
{
  if (*a4 == a4[1]) {
    return 0;
  }
  VoiceNode = Phase::Controller::DVM::VoiceGraph::GetVoiceNode(a1, a2, a3);
  if (!VoiceNode) {
    return 3;
  }
  Phase::Controller::DVM::VoiceNode::SetBufferParameters(VoiceNode, a4);
  uint64_t result = 0;
  *((void *)a1 + 11) |= 2uLL;
  return result;
}

void Phase::Controller::DVM::VoiceNode::SetBufferParameters(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2[1];
  if (*a2 != v3)
  {
    unint64_t v5 = a1 + 16;
    uint64_t v6 = (unint64_t *)(a1 + 18);
    do
    {
      uint64_t v8 = a1[16];
      unint64_t v7 = a1[17];
      if (v8 == v7)
      {
        uint64_t v9 = a1[16];
      }
      else
      {
        uint64_t v9 = a1[16];
        while (*(_DWORD *)v9 != *(_DWORD *)v2)
        {
          v9 += 32;
          if (v9 == v7) {
            goto LABEL_15;
          }
        }
      }
      if (v9 == v7)
      {
LABEL_15:
        if (v7 >= *v6)
        {
          uint64_t v15 = (uint64_t)(v7 - v8) >> 5;
          unint64_t v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 59) {
            std::vector<Phase::Controller::VoiceBufferParameter>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v17 = *v6 - v8;
          if (v17 >> 4 > v16) {
            unint64_t v16 = v17 >> 4;
          }
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFE0) {
            unint64_t v18 = 0x7FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v18 = v16;
          }
          v22[4] = v6;
          if (v18) {
            unint64_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)v6, v18);
          }
          else {
            unint64_t v19 = 0;
          }
          uint64_t v20 = &v19[32 * v15];
          v22[0] = v19;
          v22[1] = v20;
          v22[3] = &v19[32 * v18];
          *(_DWORD *)uint64_t v20 = *(_DWORD *)v2;
          *((void *)v20 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(void *)(v2 + 8);
          uint64_t v21 = *(void *)(v2 + 16);
          *((void *)v20 + 2) = v21;
          if (v21) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
          }
          unsigned char v20[24] = *(unsigned char *)(v2 + 24);
          v22[2] = v20 + 32;
          std::vector<Phase::Controller::VoiceBufferParameter>::__swap_out_circular_buffer(v5, v22);
          uint64_t v14 = a1[17];
          std::__split_buffer<Phase::Controller::VoiceBufferParameter>::~__split_buffer(v22);
        }
        else
        {
          *(_DWORD *)unint64_t v7 = *(_DWORD *)v2;
          *(void *)(v7 + 8) = *(void *)(v2 + 8);
          uint64_t v13 = *(void *)(v2 + 16);
          *(void *)(v7 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v13;
          if (v13) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
          }
          *(unsigned char *)(v7 + 24) = *(unsigned char *)(v2 + 24);
          uint64_t v14 = v7 + 32;
        }
        a1[17] = v14;
      }
      else
      {
        *(_DWORD *)uint64_t v9 = *(_DWORD *)v2;
        uint64_t v11 = *(void *)(v2 + 8);
        uint64_t v10 = *(void *)(v2 + 16);
        if (v10) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
        }
        unint64_t v12 = *(std::__shared_weak_count **)(v9 + 16);
        *(void *)(v9 + 8) = v11;
        *(void *)(v9 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v10;
        if (v12) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v12);
        }
        *(unsigned char *)(v9 + 24) = *(unsigned char *)(v2 + 24);
      }
      v2 += 32;
    }
    while (v2 != v3);
  }
}

void sub_221F235A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Phase::Controller::VoiceBufferParameter>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(Phase::Controller::DVM::VoiceGraph *a1, int a2, unint64_t a3, unint64_t a4, int a5, void *a6, int a7)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  switch(a2)
  {
    case 0:
      *(void *)uint64_t v20 = a3;
      *(void *)&v20[8] = a4;
      if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 12, v20))return; {
      uint64_t Generator = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetGenerator(a1, a3, a4);
      }
      break;
    case 1:
      *(void *)uint64_t v20 = a3;
      *(void *)&v20[8] = a4;
      if (!std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::ActionTreeIOManager::BufferInfo>>>>::find<Phase::UniqueObjectId>((void *)a1 + 17, v20))return; {
      v22.mStorage[0] = a3;
      }
      v22.mStorage[1] = a4;
      uint64_t Generator = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetSubmix(a1, v22);
      break;
    case 2:
      if (!std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)a1 + 40, a3))return; {
      uint64_t Generator = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetTap(a1, a3);
      }
      break;
    case 3:
      *(void *)uint64_t v20 = a3;
      if (!std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)a1 + 45, (unint64_t *)v20))return; {
      uint64_t Generator = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetRenderer(a1, a3);
      }
      break;
    case 4:
      *(void *)uint64_t v20 = a3;
      if (!std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)a1 + 50, (unint64_t *)v20))return; {
      uint64_t Generator = (Phase::Logger *)Phase::Controller::DVM::VoiceGraph::GetMaster(a1, a3);
      }
      break;
    case 5:
      uint64_t Generator = (Phase::Logger *)std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)a1 + 55, a3);
      if (!Generator) {
        std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
      }
      uint64_t v15 = (Phase::Logger *)((char *)Generator + 24);
      goto LABEL_15;
    default:
      std::terminate();
      return;
  }
  uint64_t v15 = Generator;
LABEL_15:
  if (a5 != 1 || *((_DWORD *)v15 + 9))
  {
    *((_DWORD *)v15 + 9) = a5;
    if (!a5)
    {
      (*(void (**)(Phase::Logger *))(*(void *)v15 + 24))(v15);
      Phase::Controller::DVM::VoiceGraph::InternalRemoveNode((uint64_t)a1, *((_DWORD *)v15 + 2), *((void *)v15 + 2), *((void *)v15 + 3), a7);
    }
  }
  else
  {
    *((void *)v15 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *a6;
    if (!a2)
    {
      uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(Generator);
      if (*((unsigned char *)Instance + 696))
      {
        uint64_t v17 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(Instance)
                                                                                            + 688)));
        unint64_t v18 = v17;
        if (a3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
        {
          uint64_t v19 = *a6;
          *(_DWORD *)uint64_t v20 = 134218240;
          *(void *)&v20[4] = a3;
          *(_WORD *)&v20[12] = 2048;
          *(void *)&v20[14] = v19;
          _os_signpost_emit_with_name_impl(&dword_221E5E000, v18, OS_SIGNPOST_INTERVAL_END, a3, "Phase_Generator_Start", "Generator ID %llu IO Start Time: %llu", v20, 0x16u);
        }
      }
    }
    *((_DWORD *)v15 + 9) = 1;
  }
}

void Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t v67 = *MEMORY[0x263EF8340];
  uint64_t v9 = (uint64_t **)(a1 + 504);
  uint64_t v10 = (Phase::Logger *)std::__tree<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<Phase::Controller::DVM::VoiceIOContext,std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::less<Phase::Controller::DVM::VoiceIOContext>,true>,std::allocator<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>>>::find<Phase::Controller::DVM::VoiceIOContext>(a1 + 504, a2);
  uint64_t v11 = (uint64_t *)(a1 + 512);
  if ((Phase::Logger *)(a1 + 512) != v10
    && (uint64_t v12 = *((void *)v10 + 8)) != 0
    && (*(void *)buf = *(void *)(a2 + 24),
        (v10 = (Phase::Logger *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)(v12 + 32), (unint64_t *)buf)) != 0)&& (uint64_t v13 = *((void *)v10 + 3)) != 0)
  {
    *(_DWORD *)(v13 + 188) = a3;
    if (!a3)
    {
      uint64_t v14 = std::__tree<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<Phase::Controller::DVM::VoiceIOContext,std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::less<Phase::Controller::DVM::VoiceIOContext>,true>,std::allocator<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>>>::find<Phase::Controller::DVM::VoiceIOContext>((uint64_t)v9, a2);
      VoiceNode = Phase::Controller::DVM::VoiceGraph::GetVoiceNode((Phase::Controller::DVM::VoiceGraph *)a1, *(void *)(v14[8] + 16), *(void *)(a2 + 24));
      if (VoiceNode)
      {
        unint64_t v16 = VoiceNode;
        Phase::Controller::DVM::VoiceNode::Disconnect((unint64_t)VoiceNode, 1);
        Phase::Controller::DVM::VoiceNode::Disconnect((unint64_t)v16, 0);
        uint64_t v17 = v16[2];
        (*(void (**)(unsigned char *__return_ptr, void *))(*v16 + 32))(buf, v16);
        unint64_t v18 = (Phase::Logger *)std::__tree<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<Phase::Controller::DVM::VoiceIOContext,std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::less<Phase::Controller::DVM::VoiceIOContext>,true>,std::allocator<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>>>::find<Phase::Controller::DVM::VoiceIOContext>((uint64_t)v9, (uint64_t)buf);
        if (v11 == (uint64_t *)v18 || (uint64_t v19 = (void *)*((void *)v18 + 8)) == 0)
        {
          uint64_t v30 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v18)
                                                                                              + 80)));
          if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
          {
            Phase::Controller::DVM::VoiceNode::GetDescription((Phase::Controller::DVM::VoiceNode *)__p, v16);
            unint64_t v31 = v55 >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "DVMGraph.mm";
            __int16 v57 = 1024;
            int v58 = 3090;
            __int16 v59 = 2048;
            uint64_t v60 = a1;
            __int16 v61 = 2080;
            int v62 = v31;
            _os_log_impl(&dword_221E5E000, v30, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: Trying to remove a voice node %s from a nullptr VoicePoolNode!", buf, 0x26u);
            if (SHIBYTE(v55) < 0) {
              operator delete(__p[0]);
            }
          }
        }
        else
        {
          (*(void (**)(unsigned char *__return_ptr, void *))(*v16 + 32))(buf, v16);
          uint64_t v20 = (void *)*v11;
          if (*v11)
          {
            uint64_t v21 = (uint64_t *)(a1 + 512);
            do
            {
              int v22 = std::operator<[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>((uint64_t)(v20 + 4), (uint64_t)buf);
              uint64_t v23 = v20 + 1;
              if (!v22)
              {
                uint64_t v23 = v20;
                uint64_t v21 = v20;
              }
              uint64_t v20 = (void *)*v23;
            }
            while (*v23);
            if (v21 != v11
              && (std::operator<[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>((uint64_t)buf, (uint64_t)(v21 + 4)) & 1) == 0)
            {
              uint64_t v24 = (uint64_t *)v21[1];
              if (v24)
              {
                do
                {
                  unsigned int v25 = v24;
                  uint64_t v24 = (uint64_t *)*v24;
                }
                while (v24);
              }
              else
              {
                unint64_t v33 = v21;
                do
                {
                  unsigned int v25 = (uint64_t *)v33[2];
                  BOOL v34 = *v25 == (void)v33;
                  unint64_t v33 = v25;
                }
                while (!v34);
              }
              if (*v9 == v21) {
                *uint64_t v9 = v25;
              }
              --*(void *)(a1 + 520);
              std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 512), v21);
              operator delete(v21);
            }
          }
          unint64_t v35 = *(uint64_t **)(a1 + 536);
          if (v35)
          {
            unint64_t v36 = v19[2];
            uint32_t v37 = (uint64_t *)(a1 + 536);
            __int16 v38 = *(uint64_t **)(a1 + 536);
            do
            {
              unint64_t v39 = v38[4];
              if (v39 >= v36)
              {
                if (v39 <= v36)
                {
                  if (v38[5] < v17) {
                    ++v38;
                  }
                  else {
                    uint32_t v37 = v38;
                  }
                }
                else
                {
                  uint32_t v37 = v38;
                }
              }
              else
              {
                ++v38;
              }
              __int16 v38 = (uint64_t *)*v38;
            }
            while (v38);
            if (v37 != (uint64_t *)(a1 + 536))
            {
              unint64_t v40 = v37[4];
              if (v40 <= v36 && (v40 < v36 || v37[5] <= v17))
              {
                unint64_t v41 = (uint64_t *)v37[1];
                if (v41)
                {
                  do
                  {
                    __int16 v42 = v41;
                    unint64_t v41 = (uint64_t *)*v41;
                  }
                  while (v41);
                }
                else
                {
                  unint64_t v43 = v37;
                  do
                  {
                    __int16 v42 = (uint64_t *)v43[2];
                    BOOL v34 = *v42 == (void)v43;
                    unint64_t v43 = v42;
                  }
                  while (!v34);
                }
                if (*(uint64_t **)(a1 + 528) == v37) {
                  *(void *)(a1 + 528) = v42;
                }
                --*(void *)(a1 + 544);
                std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v35, v37);
                operator delete(v37);
              }
            }
          }
          uint64_t v44 = (void **)(a1 + 680);
          __p[0] = __p;
          __p[1] = __p;
          uint64_t v55 = 0;
          uint32_t v45 = *(void **)(a1 + 688);
          if (v45 != (void *)(a1 + 680))
          {
            do
            {
              int v46 = std::operator==[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>((uint64_t)(v45 + 4), (uint64_t)buf);
              uint64_t v47 = v45[1];
              if (v46)
              {
                if ((void **)v47 == v44)
                {
                  LOBYTE(v48) = 1;
LABEL_70:
                  uint64_t v47 = a1 + 680;
                }
                else
                {
                  while (1)
                  {
                    int v48 = std::operator==[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>(v47 + 32, (uint64_t)buf);
                    if (!v48) {
                      break;
                    }
                    uint64_t v47 = *(void *)(v47 + 8);
                    if ((void **)v47 == v44) {
                      goto LABEL_70;
                    }
                  }
                }
                if (v45 != (void *)v47)
                {
                  unint64_t v49 = *(void **)v47;
                  if (__p != v44)
                  {
                    uint64_t v50 = 1;
                    if (v49 != v45)
                    {
                      unint64_t v51 = v45;
                      do
                      {
                        unint64_t v51 = (void *)v51[1];
                        ++v50;
                      }
                      while (v51 != v49);
                    }
                    *(void *)(a1 + 696) -= v50;
                    v55 += v50;
                  }
                  uint64_t v52 = *v45;
                  *(void *)(v52 + 8) = v49[1];
                  *(void *)v49[1] = v52;
                  double v53 = __p[0];
                  *((void *)__p[0] + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v45;
                  void *v45 = v53;
                  __p[0] = v49;
                  v49[1] = __p;
                }
                if ((v48 & 1) == 0) {
                  uint64_t v47 = *(void *)(v47 + 8);
                }
              }
              uint32_t v45 = (void *)v47;
            }
            while ((void **)v47 != v44);
          }
          std::__list_imp<Phase::Controller::DVM::DspNodePlayStateCommand>::clear((uint64_t *)__p);
          (*(void (**)(void *, uint64_t))(*v19 + 56))(v19, v17);
          *(void *)(a1 + 88) |= 8uLL;
        }
      }
      else
      {
        unint64_t v32 = **(id **)(Phase::Logger::GetInstance(0) + 80);
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          __int16 v57 = 1024;
          int v58 = 3078;
          __int16 v59 = 2048;
          uint64_t v60 = a1;
          _os_log_impl(&dword_221E5E000, v32, OS_LOG_TYPE_ERROR, "%25s:%-5d graph@%p: Trying to remove a nullptr VoiceNode!", buf, 0x1Cu);
        }
      }
    }
  }
  else if (a3)
  {
    unint64_t v26 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v10)
                                                                                        + 80)));
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      if (*(_DWORD *)(a2 + 16)) {
        std::terminate();
      }
      uint64_t v27 = *(void *)a2;
      unint64_t v28 = *(void ***)(a2 + 8);
      uint8x8_t v29 = Phase::Controller::DVM::kPlayStateStrings[a3];
      *(_DWORD *)buf = 136316418;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      __int16 v57 = 1024;
      int v58 = 2784;
      __int16 v59 = 2048;
      uint64_t v60 = v27;
      __int16 v61 = 2048;
      int v62 = v28;
      __int16 v63 = 2080;
      uint64_t v64 = v29;
      __int16 v65 = 1024;
      int v66 = a5;
      _os_log_impl(&dword_221E5E000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d VoiceGraph::CallbackPlayStateChanged vNode [VoicePool(%p):%llu] is null but PlayState is not stopped (%s). Operation result: %hhi", buf, 0x36u);
    }
  }
}

void sub_221F23E88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DVM::VoiceGraph::CallbackVoiceFinishedPlaying(Phase::Controller::DVM::VoiceGraph *this, Phase::DspLayer::VoicePool *a2, unint64_t a3)
{
  v6[0] = (unint64_t)a2;
  v6[1] = a3;
  uint64_t v4 = std::__tree<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<std::pair<unsigned long long,long long>,std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::less<std::pair<unsigned long long,long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>>>::find<std::pair<unsigned long long,long long>>((uint64_t)this + 752, v6);
  if ((unint64_t *)((char *)this + 760) == v4) {
    std::terminate();
  }
  return Phase::Controller::DVM::VoiceGraph::SetGeneratorPlayState(this, v4[6], v4[7], 0);
}

void Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(Phase::Controller::DVM::VoiceGraph *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v61[0] = this;
  v61[1] = a2;
  if (*((void *)this + 20))
  {
    uint64_t v2 = (void *)*((void *)this + 19);
    if (v2)
    {
      uint64_t v45 = *(void *)(MEMORY[0x263F8C2B8] + 72);
      uint64_t v47 = *(void **)(MEMORY[0x263F8C2B8] + 64);
      uint64_t v50 = (void *)*MEMORY[0x263F8C2B8];
      do
      {
        Phase::Controller::DVM::Submix::GetAllValidVoiceNodes((Phase::Controller::DVM::Submix *)(v2 + 4), &v59);
        Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)const::$_0::operator()(v61, (uint64_t)v59, (uint64_t)v60);
        if ((*(unsigned char *)(*(void *)(Phase::Logger::GetInstance(v3) + 80) + 8) & 2) != 0)
        {
          unint64_t v5 = v59;
          uint64_t v4 = v60;
          if (v59 == v60)
          {
            uint64_t v10 = 0;
            uint64_t v8 = 0;
          }
          else
          {
            uint64_t v6 = 0;
            unint64_t v7 = 0;
            uint64_t v8 = 0;
            do
            {
              uint64_t v9 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(*(void *)v5 + 24)];
              if (v6 >= v7)
              {
                uint64_t v11 = (v6 - v8) >> 3;
                unint64_t v12 = v11 + 1;
                if ((unint64_t)(v11 + 1) >> 61) {
                  std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
                }
                if ((v7 - v8) >> 2 > v12) {
                  unint64_t v12 = (v7 - v8) >> 2;
                }
                if ((unint64_t)(v7 - v8) >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v13 = v12;
                }
                if (v13)
                {
                  if (v13 >> 61) {
                    std::__throw_bad_array_new_length[abi:ne180100]();
                  }
                  uint64_t v14 = (char *)operator new(8 * v13);
                }
                else
                {
                  uint64_t v14 = 0;
                }
                uint64_t v15 = (char **)&v14[8 * v11];
                Phase::Logger *v15 = v9;
                uint64_t v10 = (char *)(v15 + 1);
                if (v6 != v8)
                {
                  do
                  {
                    unint64_t v16 = (char *)*((void *)v6 - 1);
                    v6 -= 8;
                    *--uint64_t v15 = v16;
                  }
                  while (v6 != v8);
                  uint64_t v6 = v8;
                }
                uint64_t v8 = (char *)v15;
                unint64_t v7 = &v14[8 * v13];
                if (v6) {
                  operator delete(v6);
                }
              }
              else
              {
                *(void *)uint64_t v6 = v9;
                uint64_t v10 = v6 + 8;
              }
              v5 += 8;
              uint64_t v6 = v10;
            }
            while (v5 != v4);
          }
          std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v52);
          if (v8 != v10)
          {
            uint64_t v17 = (const char **)v8;
            do
            {
              size_t v18 = strlen(*v17);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v54, (uint64_t)*v17, v18);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v54, (uint64_t)", ", 2);
              ++v17;
            }
            while (v17 != (const char **)v10);
          }
          uint64_t v52 = v50;
          *(void **)((char *)&v52 + *((void *)v50 - 3)) = v47;
          uint64_t v54 = v45;
          uint64_t v55 = MEMORY[0x263F8C318] + 16;
          if (v57 < 0) {
            operator delete(__p);
          }
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x223C937D0](v58);
          if (v8) {
            operator delete(v8);
          }
        }
        if (v59)
        {
          uint64_t v60 = v59;
          operator delete(v59);
        }
        uint64_t v2 = (void *)*v2;
      }
      while (v2);
    }
  }
  if (*((void *)this + 43))
  {
    for (uint64_t i = (void *)*((void *)this + 42); i; uint64_t i = (void *)*i)
    {
      uint64_t v20 = i[10];
      if (v20)
      {
        uint64_t v21 = operator new(8uLL);
        *uint64_t v21 = v20;
        uint64_t v22 = (uint64_t)(v21 + 1);
      }
      else
      {
        uint64_t v21 = 0;
        uint64_t v22 = 0;
      }
      Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)const::$_0::operator()(v61, (uint64_t)v21, v22);
      if (v21) {
        operator delete(v21);
      }
    }
  }
  if (*((void *)this + 48))
  {
    for (uint64_t j = (void *)*((void *)this + 47); j; uint64_t j = (void *)*j)
    {
      Phase::Controller::DVM::Renderer::GetAllValidVoiceNodes((Phase::Controller::DVM::Renderer *)(j + 3), &v52);
      Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)const::$_0::operator()(v61, (uint64_t)v52, (uint64_t)v53);
      if (v52)
      {
        double v53 = v52;
        operator delete(v52);
      }
    }
  }
  if (*((void *)this + 53))
  {
    for (uint64_t k = (uint64_t **)*((void *)this + 52); k; uint64_t k = (uint64_t **)*k)
    {
      uint64_t v52 = 0;
      double v53 = 0;
      uint64_t v54 = 0;
      std::vector<Phase::Controller::DVM::VoiceNode *>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode **,Phase::Controller::DVM::VoiceNode **>(&v52, k[10], (uint64_t)k[11], k[11] - k[10]);
      Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)const::$_0::operator()(v61, (uint64_t)v52, (uint64_t)v53);
      if (v52)
      {
        double v53 = v52;
        operator delete(v52);
      }
    }
  }
  if (*((void *)this + 58))
  {
    unsigned int v25 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)this + 55, 0xCuLL);
    if (!v25) {
      std::terminate();
    }
    (*(void (**)(void **__return_ptr))(v25[3] + 40))(&v52);
    Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)const::$_0::operator()(v61, (uint64_t)v52, (uint64_t)v53);
    if (v52)
    {
      double v53 = v52;
      operator delete(v52);
    }
  }
  unint64_t v26 = (uint64_t *)a2[1];
  unint64_t v27 = 126 - 2 * __clz(((uint64_t)v26 - *a2) >> 3);
  if (v26 == (uint64_t *)*a2) {
    uint64_t v28 = 0;
  }
  else {
    uint64_t v28 = v27;
  }
  uint8x8_t v29 = (Phase::Logger *)std::__introsort<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **,false>(*a2, v26, v28, 1);
  if (*(unsigned char *)(*(void *)(Phase::Logger::GetInstance(v29) + 80) + 8))
  {
    uint64_t v30 = *a2;
    uint64_t v51 = a2[1];
    if (v51 != *a2)
    {
      int v48 = *(void **)(MEMORY[0x263F8C2B8] + 64);
      uint64_t v46 = *(void *)(MEMORY[0x263F8C2B8] + 72);
      unint64_t v49 = (void *)*MEMORY[0x263F8C2B8];
      do
      {
        unint64_t v31 = *(void **)(*(void *)v30 + 48);
        if (v31)
        {
          unint64_t v32 = 0;
          unint64_t v33 = 0;
          BOOL v34 = 0;
          do
          {
            if (v33 >= v34)
            {
              uint64_t v36 = (v33 - v32) >> 3;
              unint64_t v37 = v36 + 1;
              if ((unint64_t)(v36 + 1) >> 61) {
                std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
              }
              if ((v34 - v32) >> 2 > v37) {
                unint64_t v37 = (v34 - v32) >> 2;
              }
              if ((unint64_t)(v34 - v32) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v38 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v38 = v37;
              }
              if (v38)
              {
                if (v38 >> 61) {
                  std::__throw_bad_array_new_length[abi:ne180100]();
                }
                unint64_t v39 = (char *)operator new(8 * v38);
              }
              else
              {
                unint64_t v39 = 0;
              }
              unint64_t v40 = &v39[8 * v36];
              *(void *)unint64_t v40 = v31[2];
              unint64_t v35 = v40 + 8;
              while (v33 != v32)
              {
                uint64_t v41 = *((void *)v33 - 1);
                v33 -= 8;
                *((void *)v40 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v41;
                v40 -= 8;
              }
              BOOL v34 = &v39[8 * v38];
              if (v32) {
                operator delete(v32);
              }
              unint64_t v32 = v40;
            }
            else
            {
              *(void *)unint64_t v33 = v31[2];
              unint64_t v35 = v33 + 8;
            }
            unint64_t v31 = (void *)*v31;
            unint64_t v33 = v35;
          }
          while (v31);
        }
        else
        {
          unint64_t v32 = 0;
          unint64_t v35 = 0;
        }
        std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)&v52);
        if (v32 != v35)
        {
          __int16 v42 = v32;
          do
          {
            std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v54, (uint64_t)" ", 1);
            v42 += 8;
          }
          while (v42 != v35);
        }
        uint64_t v52 = v49;
        *(void **)((char *)&v52 + *((void *)v49 - 3)) = v48;
        uint64_t v54 = v46;
        uint64_t v55 = MEMORY[0x263F8C318] + 16;
        if (v57 < 0) {
          operator delete(__p);
        }
        std::streambuf::~streambuf();
        std::iostream::~basic_iostream();
        MEMORY[0x223C937D0](v58);
        if (v32) {
          operator delete(v32);
        }
        v30 += 8;
      }
      while (v30 != v51);
    }
  }
}

void sub_221F24670(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v20 = *(void **)a9;
  if (*(void *)a9)
  {
    *(void *)(a9 + 8) = v20;
    operator delete(v20);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)const::$_0::operator()(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v6 = *a1 + 504;
    uint64_t v7 = *a1 + 512;
    do
    {
      (*(void (**)(void *__return_ptr))(**(void **)v4 + 32))(v26);
      uint64_t v8 = std::__tree<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<Phase::Controller::DVM::VoiceIOContext,std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::less<Phase::Controller::DVM::VoiceIOContext>,true>,std::allocator<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>>>::find<Phase::Controller::DVM::VoiceIOContext>(v6, (uint64_t)v26);
      if ((void *)v7 == v8 || (uint64_t v9 = v8[8]) == 0) {
        std::terminate();
      }
      uint64_t v10 = (char **)a1[1];
      uint64_t v11 = *v10;
      unint64_t v12 = v10[1];
      if (*v10 == v12)
      {
LABEL_9:
        unint64_t v13 = v10[1];
      }
      else
      {
        unint64_t v13 = *v10;
        uint64_t v14 = *v10;
        while (*(void *)v14 != v9)
        {
          v14 += 8;
          v13 += 8;
          if (v14 == v12) {
            goto LABEL_9;
          }
        }
      }
      if (v12 == v13)
      {
        unint64_t v15 = (unint64_t)v10[2];
        if ((unint64_t)v12 >= v15)
        {
          uint64_t v17 = (v12 - v11) >> 3;
          if ((unint64_t)(v17 + 1) >> 61) {
            std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v18 = v15 - (void)v11;
          uint64_t v19 = v18 >> 2;
          if (v18 >> 2 <= (unint64_t)(v17 + 1)) {
            uint64_t v19 = v17 + 1;
          }
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v19;
          }
          if (v20) {
            uint64_t v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)(v10 + 2), v20);
          }
          else {
            uint64_t v21 = 0;
          }
          uint64_t v22 = &v21[8 * v17];
          *(void *)uint64_t v22 = v9;
          unint64_t v16 = v22 + 8;
          uint64_t v24 = *v10;
          uint64_t v23 = v10[1];
          if (v23 != *v10)
          {
            do
            {
              uint64_t v25 = *((void *)v23 - 1);
              v23 -= 8;
              *((void *)v22 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v25;
              v22 -= 8;
            }
            while (v23 != v24);
            uint64_t v23 = *v10;
          }
          char *v10 = v22;
          v10[1] = v16;
          void v10[2] = &v21[8 * v20];
          if (v23) {
            operator delete(v23);
          }
        }
        else
        {
          *(void *)unint64_t v12 = v9;
          unint64_t v16 = v12 + 8;
        }
        v10[1] = v16;
      }
      v4 += 8;
    }
    while (v4 != a3);
  }
}

void Phase::Controller::DVM::Renderer::GetAllValidVoiceNodes(Phase::Controller::DVM::Renderer *this@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = (uint64_t *)*((void *)this + 8);
  uint64_t v3 = (uint64_t *)*((void *)this + 9);
  if (v2 != v3)
  {
    uint64_t v5 = (uint64_t)(a2 + 2);
    do
    {
      std::vector<Phase::Controller::DVM::VoiceNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Phase::Controller::DVM::VoiceNode * const*>,std::__wrap_iter<Phase::Controller::DVM::VoiceNode * const*>>((uint64_t)a2, (uint64_t)a2[1], (char *)v2[1], (char *)v2[2], (v2[2] - v2[1]) >> 3);
      uint64_t v6 = *v2;
      if (*v2)
      {
        uint64_t v8 = a2[1];
        unint64_t v7 = (unint64_t)a2[2];
        if ((unint64_t)v8 >= v7)
        {
          uint64_t v10 = ((char *)v8 - (unsigned char *)*a2) >> 3;
          if ((unint64_t)(v10 + 1) >> 61) {
            std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v11 = v7 - (void)*a2;
          uint64_t v12 = v11 >> 2;
          if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
            uint64_t v12 = v10 + 1;
          }
          if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v13 = v12;
          }
          if (v13)
          {
            uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v5, v13);
            uint64_t v6 = *v2;
          }
          else
          {
            uint64_t v14 = 0;
          }
          unint64_t v15 = &v14[8 * v10];
          *(void *)unint64_t v15 = v6;
          uint64_t v9 = v15 + 8;
          uint64_t v17 = (char *)*a2;
          unint64_t v16 = (char *)a2[1];
          if (v16 != *a2)
          {
            do
            {
              uint64_t v18 = *((void *)v16 - 1);
              v16 -= 8;
              *((void *)v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v18;
              v15 -= 8;
            }
            while (v16 != v17);
            unint64_t v16 = (char *)*a2;
          }
          *a2 = v15;
          a2[1] = v9;
          a2[2] = &v14[8 * v13];
          if (v16) {
            operator delete(v16);
          }
        }
        else
        {
          void *v8 = v6;
          uint64_t v9 = v8 + 1;
        }
        a2[1] = v9;
      }
      v2 += 4;
    }
    while (v2 != v3);
  }
}

void sub_221F24A24(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::Controller::DVM::Master::GetAllValidVoiceNodes@<X0>(Phase::Controller::DVM::Master *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<Phase::Controller::DVM::VoiceNode *>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode **,Phase::Controller::DVM::VoiceNode **>(a2, *((const void **)this + 7), *((void *)this + 8), (uint64_t)(*((void *)this + 8) - *((void *)this + 7)) >> 3);
}

void *Phase::Controller::DVM::VoiceNode::GetDescription(Phase::Controller::DVM::VoiceNode *this, _DWORD *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v4 = Phase::Controller::DVM::kVoiceTypeStrings[a2[6]];
  int v5 = a2[4];
  (*(void (**)(void **__return_ptr, _DWORD *))(*(void *)a2 + 32))(v8, a2);
  Phase::Controller::DVM::VoiceIOContext::GetDescription((Phase::Controller::DVM::VoiceIOContext *)__p, (uint64_t)v8);
  if (v10 >= 0) {
    uint64_t v6 = __p;
  }
  else {
    uint64_t v6 = (void **)__p[0];
  }
  snprintf(__str, 0x100uLL, "<voice %sId %d, %s, order 0x%x>", v4, v5, (const char *)v6, a2[7]);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  return std::string::basic_string[abi:ne180100]<0>(this, __str);
}

BOOL Phase::Controller::DVM::VoiceGraph::RouteConnections(uint64_t a1, uint64_t **a2)
{
  uint64_t v71 = *MEMORY[0x263EF8340];
  for (uint64_t i = *a2; i != a2[1]; ++i)
  {
    if (!*i)
    {
      uint64_t v47 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 80);
      BOOL result = os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 3122;
      int v48 = "%25s:%-5d VoicePoolNode is nullptr!";
LABEL_70:
      unint64_t v49 = v47;
      uint32_t v50 = 18;
      goto LABEL_77;
    }
    uint64_t v4 = 0;
    int v5 = 0;
    uint64_t v6 = (void *)(*i + 48);
    while (1)
    {
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        break;
      }
      uint64_t v7 = v4;
      uint64_t v4 = v6[3];
      if (!v4)
      {
        uint64_t v47 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 80);
        BOOL result = os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "DVMGraph.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 3131;
        int v48 = "%25s:%-5d Voice Node is nullptr!";
        goto LABEL_70;
      }
      BOOL v8 = *(_DWORD *)(v4 + 28) < v5;
      int v5 = *(_DWORD *)(v4 + 28);
      if (v8)
      {
        if (v7)
        {
          uint64_t v51 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(v7 + 24)];
          uint64_t v52 = *(void *)(v7 + 16);
        }
        else
        {
          uint64_t v52 = -1;
          uint64_t v51 = "nullptr";
        }
        double v53 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 80);
        BOOL result = os_log_type_enabled(v53, OS_LOG_TYPE_ERROR);
        if (result)
        {
          uint64_t v54 = *(void *)(v4 + 16);
          uint64_t v55 = Phase::Controller::DVM::kVoiceTypeStrings[*(int *)(v4 + 24)];
          *(_DWORD *)buf = 136316418;
          *(void *)&uint8_t buf[4] = "DVMGraph.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 3142;
          __int16 v63 = 2048;
          uint64_t v64 = v54;
          __int16 v65 = 2080;
          int v66 = v55;
          __int16 v67 = 2048;
          uint64_t v68 = v52;
          __int16 v69 = 2080;
          float v70 = v51;
          int v48 = "%25s:%-5d Voice node with vid %llu, type %s is in wrong order! Prev. node vid %llu and type %s";
          unint64_t v49 = v53;
          uint32_t v50 = 58;
          goto LABEL_77;
        }
        return result;
      }
    }
  }
  bzero(*(void **)(a1 + 592), 8 * (*(_DWORD *)(a1 + 612) / 64));
  bzero(*(void **)(a1 + 600), 4 * *(int *)(a1 + 612));
  *(void *)(a1 + 61std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  bzero(*(void **)(a1 + 624), 8 * (*(_DWORD *)(a1 + 644) / 64));
  bzero(*(void **)(a1 + 632), 4 * *(int *)(a1 + 644));
  *(void *)(a1 + 648) = 0;
  char v10 = *a2;
  uint64_t v11 = a2[1];
  if (*a2 != v11)
  {
    __int16 v61 = a2;
    uint64_t v12 = *a2;
    do
    {
      for (uint64_t j = *(void **)(*v12 + 48); j; uint64_t j = (void *)*j)
      {
        uint64_t v14 = (void *)j[3];
        uint64_t v15 = v14[8] - v14[7];
        if (v15)
        {
          unint64_t v16 = v15 / 24;
          uint64_t v17 = (void *)v14[10];
          if (v16 <= 1) {
            unint64_t v16 = 1;
          }
          do
          {
            *v17++ = 1;
            --v16;
          }
          while (v16);
        }
      }
      ++v12;
    }
    while (v12 != v11);
    do
    {
      if (*(_DWORD *)(*v10 + 24) == 1)
      {
        uint64_t v18 = *(void **)(*v10 + 48);
        if (v18)
        {
          while (1)
          {
            uint64_t v19 = v18[3];
            if (*(_DWORD *)(v19 + 24) != 1 || *(void *)(v19 + 32) != *(void *)(v19 + 40)) {
              goto LABEL_83;
            }
            if (*(void *)(v19 + 64) != *(void *)(v19 + 56)) {
              break;
            }
LABEL_34:
            uint64_t v18 = (void *)*v18;
            if (!v18) {
              goto LABEL_35;
            }
          }
          uint64_t v20 = 0;
          unint64_t v21 = 0;
          while (1)
          {
            if ((v21 & 0x80000000) != 0
              || (uint64_t v22 = *(void *)(v19 + 80),
                  v21 >= (unint64_t)((*(void *)(v19 + 88) - v22) >> 3)))
            {
              __assert_rtn("GetOutputChannel", "DVMVoiceNode.hpp", 618, "outputIndex >= 0 && outputIndex < mOutputChannels.size()");
            }
            uint64_t v23 = *(void *)(v22 + 8 * v21);
            if (v23 != 1 && v23 != 3) {
              break;
            }
            uint64_t v9 = Phase::Controller::DVM::ChannelAllocator::ReserveChannel((Phase::Controller::DVM::ChannelAllocator *)(a1 + 592), 1);
            uint64_t v25 = (_DWORD *)(*(void *)(v19 + 80) + v20);
            *uint64_t v25 = 3;
            v25[1] = v9;
            ++v21;
            v20 += 8;
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v19 + 64) - *(void *)(v19 + 56)) >> 3) <= v21) {
              goto LABEL_34;
            }
          }
LABEL_83:
          std::terminate();
        }
      }
LABEL_35:
      ++v10;
    }
    while (v10 != v11);
    unint64_t v26 = *v61;
    int v58 = v61[1];
    if (*v61 != v58)
    {
      while (1)
      {
        __int16 v59 = v26;
        uint64_t v27 = *v26;
        int v28 = *(_DWORD *)(*v26 + 24);
        if (v28 != 1 && v28 != 8)
        {
          uint64_t v30 = *(void **)(v27 + 48);
          if (v30) {
            break;
          }
        }
LABEL_50:
        unint64_t v26 = v59 + 1;
        if (v59 + 1 == v58) {
          goto LABEL_51;
        }
      }
      while (1)
      {
        uint64_t v31 = v30[3];
        if (*(_DWORD *)(v31 + 24) == 1) {
          goto LABEL_83;
        }
        if (*(void *)(v31 + 64) != *(void *)(v31 + 56))
        {
          uint64_t v32 = 0;
          unint64_t v33 = 0;
          do
          {
            uint64_t v9 = Phase::Controller::DVM::ChannelAllocator::ReserveChannel((Phase::Controller::DVM::ChannelAllocator *)(a1 + 624), 1);
            if ((v9 & 0x80000000) != 0)
            {
              BOOL v34 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v9) + 80);
              uint64_t v9 = os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
              if (v9)
              {
                *(_DWORD *)buf = 136315394;
                *(void *)&uint8_t buf[4] = "DVMGraph.mm";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = 3257;
                _os_log_impl(&dword_221E5E000, v34, OS_LOG_TYPE_ERROR, "%25s:%-5d No more channels are available on the mix bus. Reserved channels will be reused in order to prevent a crash. Audio output will have errors.", buf, 0x12u);
                uint64_t v9 = 0;
              }
            }
            unint64_t v35 = (_DWORD *)(*(void *)(v31 + 80) + v32);
            *unint64_t v35 = 1;
            v35[1] = v9;
            ++v33;
            v32 += 8;
          }
          while (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v31 + 64) - *(void *)(v31 + 56)) >> 3) > v33);
        }
        uint64_t v30 = (void *)*v30;
        if (!v30) {
          goto LABEL_50;
        }
      }
    }
  }
LABEL_51:
  if (!*(void *)(a1 + 464))
  {
LABEL_65:
    uint64_t v44 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)v9)
                                                                                        + 80)));
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      int v45 = *(_DWORD *)(a1 + 648);
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "DVMGraph.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 3387;
      __int16 v63 = 1024;
      LODWORD(v64) = v45;
      _os_log_impl(&dword_221E5E000, v44, OS_LOG_TYPE_DEFAULT, "%25s:%-5d Routed connections: %d mix busses used!", buf, 0x18u);
    }

    return 1;
  }
  if (std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 440), 0xCuLL))
  {
    uint64_t v36 = std::__hash_table<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::__unordered_map_hasher<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::hash<PHASETapType>,std::equal_to<PHASETapType>,true>,std::__unordered_map_equal<PHASETapType,std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>,std::equal_to<PHASETapType>,std::hash<PHASETapType>,true>,std::allocator<std::__hash_value_type<PHASETapType,std::unique_ptr<Phase::TapSourceRegistry::TapSourceInfo>>>>::find<PHASETapType>((void *)(a1 + 440), 0xCuLL);
    if (!v36) {
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
    }
    (*(void (**)(unsigned char *__return_ptr))(v36[3] + 40))(buf);
    uint64_t v9 = *(void *)buf;
    uint64_t v37 = *(void *)&buf[8];
    if (*(void *)buf != *(void *)&buf[8])
    {
      int v38 = 0;
      uint64_t v39 = *(void *)buf;
      do
      {
        uint64_t v40 = *(void *)(*(void *)v39 + 64) - *(void *)(*(void *)v39 + 56);
        if (v40)
        {
          unint64_t v41 = v40 / 24;
          if (v41 <= 1) {
            uint64_t v42 = 1;
          }
          else {
            uint64_t v42 = v41;
          }
          unint64_t v43 = (_DWORD *)(*(void *)(*(void *)v39 + 80) + 4);
          do
          {
            *(v43 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
            _DWORD *v43 = v38++;
            v43 += 2;
            --v42;
          }
          while (v42);
        }
        v39 += 8;
      }
      while (v39 != v37);
    }
    if (v9)
    {
      *(void *)&uint8_t buf[8] = v9;
      operator delete((void *)v9);
    }
    goto LABEL_65;
  }
  int v56 = **(id **)(Phase::Logger::GetInstance(0) + 80);
  BOOL result = os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  if (result)
  {
    uint64_t v57 = *(void *)(a1 + 800);
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "DVMGraph.mm";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 3372;
    __int16 v63 = 2048;
    uint64_t v64 = v57;
    int v48 = "%25s:%-5d Sink Id %llu doesn't exist!";
    unint64_t v49 = v56;
    uint32_t v50 = 28;
LABEL_77:
    _os_log_impl(&dword_221E5E000, v49, OS_LOG_TYPE_ERROR, v48, buf, v50);
    return 0;
  }
  return result;
}

uint64_t Phase::Controller::DVM::VoicePoolNode::HasVoicePool(Phase::Controller::DVM::VoicePoolNode *this)
{
  return 0;
}

uint64_t Phase::Controller::DVM::VoicePoolNode::AsGenericVoicePoolNode(Phase::Controller::DVM::VoicePoolNode *this)
{
  return 0;
}

uint64_t Phase::Controller::DVM::VoicePoolNode::AsProcedureVoicePoolNode(Phase::Controller::DVM::VoicePoolNode *this)
{
  return 0;
}

void Phase::Controller::DVM::ProcedureVoicePoolNode::GetVoicePool(Phase::Controller::DVM::ProcedureVoicePoolNode *this)
{
}

uint64_t Phase::Controller::DVM::ProcedureVoicePoolNode::HasVoicePool(Phase::Controller::DVM::ProcedureVoicePoolNode *this)
{
  return 0;
}

void Phase::Controller::DVM::GenericVoicePoolNode::~GenericVoicePoolNode(Phase::Controller::DVM::GenericVoicePoolNode *this)
{
  Phase::Controller::DVM::GenericVoicePoolNode::~GenericVoicePoolNode(this);

  JUMPOUT(0x223C938A0);
}

{
  uint64_t v2;

  *(void *)this = &unk_26D475E80;
  uint64_t v2 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  *(void *)this = &unk_26D475E30;
  std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>>>::~__hash_table((uint64_t)this + 32);
}

uint64_t Phase::Controller::DVM::GenericVoicePoolNode::GetVoicePool(Phase::Controller::DVM::GenericVoicePoolNode *this)
{
  return *((void *)this + 10);
}

BOOL Phase::Controller::DVM::GenericVoicePoolNode::HasVoicePool(Phase::Controller::DVM::GenericVoicePoolNode *this)
{
  return *((void *)this + 10) != 0;
}

void std::__list_imp<std::unique_ptr<Phase::Controller::DVM::VoicePoolNode>>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v3 = *a1;
    uint64_t v2 = (uint64_t *)a1[1];
    uint64_t v4 = *v2;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v3 + 8) = v4;
    a1[2] = 0;
    while (v2 != a1)
    {
      int v5 = (uint64_t *)v2[1];
      std::__list_imp<std::unique_ptr<Phase::Controller::DVM::VoicePoolNode>>::__delete_node[abi:ne180100]<>((int)a1, v2);
      uint64_t v2 = v5;
    }
  }
}

void std::__list_imp<std::unique_ptr<Phase::Controller::DVM::VoicePoolNode>>::__delete_node[abi:ne180100]<>(int a1, void *__p)
{
  uint64_t v3 = __p[2];
  __p[2] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }

  operator delete(__p);
}

void std::__list_imp<Phase::Controller::DVM::DspNodePlayStateCommand>::clear(uint64_t *a1)
{
  if (a1[2])
  {
    uint64_t v2 = *a1;
    uint64_t v3 = (uint64_t *)a1[1];
    uint64_t v4 = *v3;
    *(void *)(v4 + 8) = *(void *)(*a1 + 8);
    **(void **)(v2 + 8) = v4;
    a1[2] = 0;
    if (v3 != a1)
    {
      do
      {
        int v5 = (uint64_t *)v3[1];
        (*(void (**)(void))v3[2])();
        operator delete(v3);
        uint64_t v3 = v5;
      }
      while (v5 != a1);
    }
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::Controller::VoiceBufferParameter *,Phase::Controller::VoiceBufferParameter *,Phase::Controller::VoiceBufferParameter *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 != a2)
  {
    uint64_t v5 = a1;
    do
    {
      *(_DWORD *)a3 = *(_DWORD *)v5;
      uint64_t v7 = *(void *)(v5 + 8);
      uint64_t v6 = *(void *)(v5 + 16);
      if (v6) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
      }
      BOOL v8 = *(std::__shared_weak_count **)(a3 + 16);
      *(void *)(a3 + 8) = v7;
      *(void *)(a3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v6;
      if (v8) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v8);
      }
      *(unsigned char *)(a3 + 24) = *(unsigned char *)(v5 + 24);
      a3 += 32;
      v5 += 32;
    }
    while (v5 != a2);
  }
  return a3;
}

BOOL Phase::Controller::DVM::VoiceNode::Disconnect(unint64_t a1, int a2, int a3, uint64_t a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  if (a2) {
    uint64_t v4 = 32;
  }
  else {
    uint64_t v4 = 56;
  }
  if (a3 > 0x17) {
    return 0;
  }
  uint64_t v6 = *(void *)a4 + 32;
  uint64_t v7 = 32;
  if (a2 == 1)
  {
    uint64_t v7 = 56;
    uint64_t v6 = *(void *)a4 + 56;
  }
  unint64_t v8 = *(int *)(a4 + 8);
  uint64_t v9 = *(void *)(*(void *)a4 + v7);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v6 + 8) - v9) >> 3) < v8) {
    return 0;
  }
  if (!a1)
  {
    uint64_t v14 = **(id **)(Phase::Logger::GetInstance(0) + 80);
    BOOL result = os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v18 = 136315650;
    uint64_t v19 = "DVMVoiceNode.hpp";
    __int16 v20 = 1024;
    int v21 = 538;
    __int16 v22 = 2048;
    unint64_t v23 = 0;
    uint64_t v15 = "%25s:%-5d DvmVoiceNode@%p: trying to disconnect a nullptr node (thisConn.mNode).";
    unint64_t v16 = v14;
    goto LABEL_15;
  }
  std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__erase_unique<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>((uint64_t **)(v9 + 24 * (int)v8), a1, a3);
  if (*(void *)a4)
  {
    std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__erase_unique<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>((uint64_t **)(*(void *)(a1 + v4) + 24 * a3), *(void *)a4, *(_DWORD *)(a4 + 8));
    return 1;
  }
  uint64_t v17 = **(id **)(Phase::Logger::GetInstance(v12) + 80);
  BOOL result = os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v18 = 136315650;
    uint64_t v19 = "DVMVoiceNode.hpp";
    __int16 v20 = 1024;
    int v21 = 545;
    __int16 v22 = 2048;
    unint64_t v23 = a1;
    uint64_t v15 = "%25s:%-5d DvmVoiceNode@%p: trying to disconnect from a nullptr node (conn.mNode).";
    unint64_t v16 = v17;
LABEL_15:
    _os_log_impl(&dword_221E5E000, v16, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&v18, 0x1Cu);
    return 0;
  }
  return result;
}

uint64_t std::set<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::set[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)a1 = a1 + 8;
  std::set<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::insert[abi:ne180100]<std::__tree_const_iterator<Phase::Controller::DVM::VoiceNode::IOChannel::Connection,std::__tree_node<Phase::Controller::DVM::VoiceNode::IOChannel::Connection,void *> *,long>>((_OWORD *)a1, *(void **)a2, (void *)(a2 + 8));
  return a1;
}

void sub_221F25774(_Unwind_Exception *a1)
{
  std::__tree<Phase::SpatialCategory>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

_OWORD *std::set<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::insert[abi:ne180100]<std::__tree_const_iterator<Phase::Controller::DVM::VoiceNode::IOChannel::Connection,std::__tree_node<Phase::Controller::DVM::VoiceNode::IOChannel::Connection,void *> *,long>>(_OWORD *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    uint64_t v4 = a2;
    uint64_t v5 = (uint64_t **)result;
    uint64_t v6 = (uint64_t *)result + 1;
    do
    {
      BOOL result = std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__emplace_hint_unique_key_args<Phase::Controller::DVM::VoiceNode::IOChannel::Connection,Phase::Controller::DVM::VoiceNode::IOChannel::Connection const&>(v5, v6, (uint64_t)(v4 + 4), (uint64_t)(v4 + 4));
      uint64_t v7 = (void *)v4[1];
      if (v7)
      {
        do
        {
          unint64_t v8 = v7;
          uint64_t v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          unint64_t v8 = (void *)v4[2];
          BOOL v9 = *v8 == (void)v4;
          uint64_t v4 = v8;
        }
        while (!v9);
      }
      uint64_t v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

_OWORD *std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__emplace_hint_unique_key_args<Phase::Controller::DVM::VoiceNode::IOChannel::Connection,Phase::Controller::DVM::VoiceNode::IOChannel::Connection const&>(uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__find_equal<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (_OWORD *)*v6;
  if (!*v6)
  {
    unint64_t v8 = (uint64_t **)v6;
    uint64_t v7 = operator new(0x38uLL);
    void v7[2] = *(_OWORD *)a4;
    *((void *)v7 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a4 + 16);
    std::__tree<Phase::SpatialCategory>::__insert_node_at(a1, (uint64_t)v11, v8, (uint64_t *)v7);
  }
  return v7;
}

uint64_t *std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__find_equal<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>(uint64_t **a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, uint64_t a5)
{
  if (a1 + 1 == (uint64_t **)a2) {
    goto LABEL_3;
  }
  unint64_t v5 = *(void *)a5;
  unint64_t v6 = a2[4];
  if (*(void *)a5 < v6) {
    goto LABEL_3;
  }
  if (*(void *)a5 != v6)
  {
    if (v6 < v5)
    {
LABEL_10:
      uint64_t v10 = a2[1];
      if (v10)
      {
        uint64_t v11 = (uint64_t *)a2[1];
        do
        {
          a4 = (uint64_t **)v11;
          uint64_t v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
      else
      {
        uint64_t v17 = a2;
        do
        {
          a4 = (uint64_t **)v17[2];
          BOOL v13 = *a4 == v17;
          uint64_t v17 = (uint64_t *)a4;
        }
        while (!v13);
      }
      if (a4 != a1 + 1)
      {
        unint64_t v18 = (unint64_t)a4[4];
        if (v5 >= v18 && (v5 != v18 || *(_DWORD *)(a5 + 8) >= *((_DWORD *)a4 + 10))) {
          return std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__find_equal<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>((uint64_t)a1, a3, (unint64_t *)a5);
        }
      }
      if (v10)
      {
        *a3 = (uint64_t *)a4;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
      return (uint64_t *)a4;
    }
LABEL_26:
    *a3 = a2;
    *a4 = a2;
    return (uint64_t *)a4;
  }
  int v15 = *(_DWORD *)(a5 + 8);
  int v16 = *((_DWORD *)a2 + 10);
  if (v15 >= v16)
  {
    if (v16 < v15) {
      goto LABEL_10;
    }
    goto LABEL_26;
  }
LABEL_3:
  uint64_t v7 = (uint64_t *)*a2;
  if (*a1 == a2)
  {
    BOOL v9 = a2;
  }
  else
  {
    if (v7)
    {
      unint64_t v8 = (uint64_t *)*a2;
      do
      {
        BOOL v9 = v8;
        unint64_t v8 = (uint64_t *)v8[1];
      }
      while (v8);
    }
    else
    {
      uint64_t v12 = a2;
      do
      {
        BOOL v9 = (uint64_t *)v12[2];
        BOOL v13 = *v9 == (void)v12;
        uint64_t v12 = v9;
      }
      while (v13);
    }
    unint64_t v14 = v9[4];
    if (v14 >= *(void *)a5 && (v14 != *(void *)a5 || *((_DWORD *)v9 + 10) >= *(_DWORD *)(a5 + 8))) {
      return std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__find_equal<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>((uint64_t)a1, a3, (unint64_t *)a5);
    }
  }
  if (v7)
  {
    *a3 = v9;
    return v9 + 1;
  }
  else
  {
    *a3 = a2;
    return a2;
  }
}

uint64_t *std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__find_equal<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>(uint64_t a1, void *a2, unint64_t *a3)
{
  unint64_t v5 = *(uint64_t **)(a1 + 8);
  BOOL result = (uint64_t *)(a1 + 8);
  uint64_t v4 = v5;
  if (v5)
  {
    unint64_t v6 = *a3;
    int v7 = *((_DWORD *)a3 + 2);
    while (1)
    {
      while (1)
      {
        unint64_t v8 = v4;
        unint64_t v9 = v4[4];
        if (v6 >= v9) {
          break;
        }
LABEL_4:
        uint64_t v4 = (uint64_t *)*v8;
        BOOL result = v8;
        if (!*v8) {
          goto LABEL_14;
        }
      }
      if (v6 == v9)
      {
        int v10 = *((_DWORD *)v8 + 10);
        if (v7 < v10) {
          goto LABEL_4;
        }
        if (v10 >= v7) {
          goto LABEL_14;
        }
      }
      else if (v9 >= v6)
      {
        goto LABEL_14;
      }
      BOOL result = v8 + 1;
      uint64_t v4 = (uint64_t *)v8[1];
      if (!v4) {
        goto LABEL_14;
      }
    }
  }
  unint64_t v8 = result;
LABEL_14:
  *a2 = v8;
  return result;
}

void std::__tree<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::__erase_unique<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>(uint64_t **a1, unint64_t a2, int a3)
{
  unint64_t v5 = (uint64_t *)(a1 + 1);
  uint64_t v4 = a1[1];
  if (v4)
  {
    unint64_t v6 = v5;
    int v7 = v4;
    do
    {
      unint64_t v8 = v7[4];
      if (v8 >= a2)
      {
        if (v8 == a2)
        {
          if (*((_DWORD *)v7 + 10) < a3) {
            ++v7;
          }
          else {
            unint64_t v6 = v7;
          }
        }
        else
        {
          unint64_t v6 = v7;
        }
      }
      else
      {
        ++v7;
      }
      int v7 = (uint64_t *)*v7;
    }
    while (v7);
    if (v6 != v5)
    {
      unint64_t v9 = v6[4];
      if (v9 <= a2 && (v9 != a2 || *((_DWORD *)v6 + 10) <= a3))
      {
        int v10 = (uint64_t *)v6[1];
        if (v10)
        {
          do
          {
            uint64_t v11 = v10;
            int v10 = (uint64_t *)*v10;
          }
          while (v10);
        }
        else
        {
          uint64_t v12 = v6;
          do
          {
            uint64_t v11 = (uint64_t *)v12[2];
            BOOL v13 = *v11 == (void)v12;
            uint64_t v12 = v11;
          }
          while (!v13);
        }
        if (*a1 == v6) {
          *a1 = v11;
        }
        a1[2] = (uint64_t *)((char *)a1[2] - 1);
        std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v4, v6);
        operator delete(v6);
      }
    }
  }
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  uint64_t v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      uint64_t v3 = a2;
      goto LABEL_7;
    }
    do
    {
      uint64_t v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  unint64_t v6 = (uint64_t **)v3[2];
  int v7 = *v6;
  if (*v6 == v3)
  {
    *unint64_t v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      int v7 = 0;
      BOOL result = (uint64_t *)v2;
    }
    else
    {
      int v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v3;
    uint64_t *v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      BOOL result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 != v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      uint64_t v18 = v7[1];
      *(void *)uint64_t v12 = v18;
      if (v18) {
        *(void *)(v18 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v12;
      }
      void v7[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
      v7[1] = v12;
      *(void *)(v12 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v7;
      if (result == (uint64_t *)v12) {
        BOOL result = v7;
      }
      int v7 = *(uint64_t **)v12;
    }
    uint64_t v19 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v19 + 24)) {
      goto LABEL_68;
    }
    __int16 v20 = (uint64_t *)v7[1];
    if (v20 && !*((unsigned char *)v20 + 24))
    {
      if (v19 && !*((unsigned char *)v19 + 24))
      {
LABEL_68:
        __int16 v20 = v7;
      }
      else
      {
        *((unsigned char *)v20 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v26 = *v20;
        v7[1] = *v20;
        if (v26) {
          *(void *)(v26 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v7;
        }
        v20[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
        *__int16 v20 = (uint64_t)v7;
        void v7[2] = (uint64_t)v20;
        uint64_t v19 = v7;
      }
      uint64_t v23 = v20[2];
      *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v19 + 24) = 1;
      uint64_t v24 = *(uint64_t **)v23;
      uint64_t v27 = *(void *)(*(void *)v23 + 8);
      *(void *)uint64_t v23 = v27;
      if (v27) {
        *(void *)(v27 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v23;
      }
      v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      v24[1] = v23;
      goto LABEL_72;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
LABEL_49:
    int v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    BOOL v13 = *(uint64_t **)(v12 + 8);
    uint64_t v14 = *v13;
    *(void *)(v12 + 8) = *v13;
    if (v14) {
      *(void *)(v14 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v12;
    }
    _OWORD v13[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
    *BOOL v13 = v12;
    *(void *)(v12 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v13;
    if (result == (uint64_t *)*v7) {
      BOOL result = v7;
    }
    int v7 = *(uint64_t **)(*v7 + 8);
  }
  int v15 = (void *)*v7;
  if (!*v7 || *((unsigned char *)v15 + 24))
  {
    int v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_59;
    }
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      uint64_t v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  int v16 = (uint64_t *)v7[1];
  if (v16 && !*((unsigned char *)v16 + 24))
  {
LABEL_59:
    int v15 = v7;
  }
  else
  {
    *((unsigned char *)v15 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v22 = v15[1];
    uint64_t *v7 = v22;
    if (v22) {
      *(void *)(v22 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v7;
    }
    void v15[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
    v15[1] = v7;
    void v7[2] = (uint64_t)v15;
    int v16 = v7;
  }
  uint64_t v23 = v15[2];
  *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v16 + 24) = 1;
  uint64_t v24 = *(uint64_t **)(v23 + 8);
  uint64_t v25 = *v24;
  *(void *)(v23 + 8) = *v24;
  if (v25) {
    *(void *)(v25 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v23;
  }
  v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  *uint64_t v24 = v23;
LABEL_72:
  *(void *)(v23 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v24;
  return result;
}

void std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]()
{
}

void *std::__tree<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<Phase::Controller::DVM::VoiceIOContext,std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::less<Phase::Controller::DVM::VoiceIOContext>,true>,std::allocator<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>>>::find<Phase::Controller::DVM::VoiceIOContext>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  int v5 = (void *)(a1 + 8);
  do
  {
    int v6 = std::operator<[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>((uint64_t)(v3 + 4), a2);
    int v7 = v3 + 1;
    if (!v6)
    {
      int v7 = v3;
      int v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2
    || std::operator<[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>(a2, (uint64_t)(v5 + 4)))
  {
    return v2;
  }
  return v5;
}

uint64_t std::operator<[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a2 + 16);
  if (v2 == -1) {
    return 0;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  if (v3 == -1 || v3 < v2) {
    return 1;
  }
  if (v3 > v2) {
    return 0;
  }
  int v6 = &v5;
  return ((uint64_t (*)(char **, uint64_t, uint64_t))off_26D475F10[v3])(&v6, a1, a2);
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<0ul,0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::less<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::pair<Phase::DspLayer::VoicePool *,long long>,std::__variant_detail::_Trait<std::pair::Controller::DVM::ProcedureBase *,long long>> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::pair<Phase::DspLayer::VoicePool *,long long>,std::__variant_detail::_Trait<std::pair::Controller::DVM::ProcedureBase *,long long>> const>(uint64_t a1, void *a2, void *a3)
{
  if (*a2 < *a3) {
    return 1;
  }
  if (*a3 >= *a2) {
    return a2[1] < a3[1];
  }
  return 0;
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<1ul,1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::less<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::pair<Phase::DspLayer::VoicePool *,long long>,std::__variant_detail::_Trait<std::pair::Controller::DVM::ProcedureBase *,long long>> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::pair<Phase::DspLayer::VoicePool *,long long>,std::__variant_detail::_Trait<std::pair::Controller::DVM::ProcedureBase *,long long>> const>(uint64_t a1, void *a2, void *a3)
{
  if (*a2 < *a3) {
    return 1;
  }
  if (*a3 >= *a2) {
    return a2[1] < a3[1];
  }
  return 0;
}

char *std::vector<Phase::Controller::DVM::VoiceNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Phase::Controller::DVM::VoiceNode * const*>,std::__wrap_iter<Phase::Controller::DVM::VoiceNode * const*>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  int v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    BOOL v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 3;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v9, v17);
    }
    else {
      uint64_t v18 = 0;
    }
    int v28 = &v18[8 * v15];
    std::string __p = v18;
    BOOL v34 = v28;
    uint64_t v36 = &v18[8 * v17];
    uint64_t v29 = 8 * a5;
    uint64_t v30 = &v28[8 * a5];
    do
    {
      uint64_t v31 = *(void *)v7;
      v7 += 8;
      *(void *)int v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    unint64_t v35 = v30;
    char v5 = std::vector<Phase::Controller::DVM::VoiceNode *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    BOOL v21 = &__src[8 * a5];
    uint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    uint64_t v24 = &v5[8 * a5];
    uint64_t v25 = &v23[-8 * a5];
    uint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      uint64_t v26 = v23;
      do
      {
        uint64_t v27 = *(void *)v25;
        v25 += 8;
        *(void *)uint64_t v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  BOOL v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  }
  uint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_221F26268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Phase::Controller::DVM::VoiceNode *>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char v5 = *(char **)(a2 + 8);
  int v6 = (char *)*a1;
  int v7 = v5;
  if (*a1 != __src)
  {
    int v8 = __src;
    int v7 = *(char **)(a2 + 8);
    do
    {
      uint64_t v9 = *((void *)v8 - 1);
      v8 -= 8;
      *((void *)v7 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v10 = a1[1];
  uint64_t v11 = *(void *)(a2 + 16);
  int64_t v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    int v7 = *(char **)(a2 + 8);
  }
  *(void *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v11 + v12;
  BOOL v13 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v13;
  unint64_t v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v14;
  uint64_t v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v15;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void *Phase::Controller::DVM::VoiceIOContext::GetDescription(Phase::Controller::DVM::VoiceIOContext *this, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a2 + 16);
  if (v3)
  {
    if (v3 != 1) {
      std::terminate();
    }
    snprintf(__str, 0x100uLL, "<iocontext: procedure [%p, %d]>");
  }
  else
  {
    snprintf(__str, 0x100uLL, "<iocontext: voice [%p, %d]>");
  }
  return std::string::basic_string[abi:ne180100]<0>(this, __str);
}

void *std::__tree<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<std::pair<unsigned long long,long long>,std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::less<std::pair<unsigned long long,long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>>>::find<std::pair<unsigned long long,long long>>(uint64_t a1, unint64_t *a2)
{
  uint64_t v4 = *(void **)(a1 + 8);
  unsigned int v2 = (void *)(a1 + 8);
  int v3 = v4;
  if (!v4) {
    return v2;
  }
  unint64_t v6 = *a2;
  uint64_t v5 = a2[1];
  int v7 = v2;
  do
  {
    unint64_t v8 = v3[4];
    if (v8 >= v6)
    {
      if (v6 >= v8)
      {
        if (v3[5] < v5) {
          ++v3;
        }
        else {
          int v7 = v3;
        }
      }
      else
      {
        int v7 = v3;
      }
    }
    else
    {
      ++v3;
    }
    int v3 = (void *)*v3;
  }
  while (v3);
  if (v7 == v2) {
    return v2;
  }
  unint64_t v9 = v7[4];
  if (v6 < v9 || v9 >= v6 && v5 < v7[5]) {
    return v2;
  }
  return v7;
}

uint64_t std::operator==[abi:ne180100]<std::pair<Phase::DspLayer::VoicePool *,long long>,std::pair<Phase::Controller::DVM::ProcedureBase *,long long>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 16);
  int v5 = *(_DWORD *)(a2 + 16);
  BOOL v6 = v5 == v4;
  BOOL v9 = v5 == -1;
  BOOL v7 = v5 == -1;
  if (v9) {
    BOOL v6 = 0;
  }
  if (v4 == -1) {
    uint64_t result = v7;
  }
  else {
    uint64_t result = v6;
  }
  BOOL v9 = v4 == -1 || !v6;
  if (!v9)
  {
    uint64_t v11 = &v10;
    return ((uint64_t (*)(char **, uint64_t))off_26D475F20[v4])(&v11, a1);
  }
  return result;
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<0ul,0ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::pair<Phase::DspLayer::VoicePool *,long long>,std::__variant_detail::_Trait<std::pair::Controller::DVM::ProcedureBase *,long long>> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::pair<Phase::DspLayer::VoicePool *,long long>,std::__variant_detail::_Trait<std::pair::Controller::DVM::ProcedureBase *,long long>> const>(uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

BOOL std::__variant_detail::__visitation::__base::__dispatcher<1ul,1ul>::__dispatch[abi:ne180100]<std::__variant_detail::__visitation::__variant::__value_visitor<std::__convert_to_BOOL<std::equal_to<void>>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::pair<Phase::DspLayer::VoicePool *,long long>,std::__variant_detail::_Trait<std::pair::Controller::DVM::ProcedureBase *,long long>> const&,std::__variant_detail::__base<(std::__variant_detail::_Trait)0,std::pair<Phase::DspLayer::VoicePool *,long long>,std::__variant_detail::_Trait<std::pair::Controller::DVM::ProcedureBase *,long long>> const>(uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

uint64_t std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  unsigned int v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    unsigned int v2 = __p;
    do
    {
      int v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[4];
      if (v4)
      {
        v2[5] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      unsigned int v2 = v3;
    }
    while (v3);
  }
}

void *std::vector<Phase::Controller::DVM::VoiceNode *>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode **,Phase::Controller::DVM::VoiceNode **>(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    BOOL v6 = result;
    uint64_t result = std::vector<Phase::Controller::DVM::VoiceNode *>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_221F26614(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Phase::Controller::DVM::VoiceNode *>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  unsigned int v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    int v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        BOOL v6 = v4 - 24;
        std::__tree<Phase::SpatialCategory>::destroy((uint64_t)(v4 - 24), *((void **)v4 - 2));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      int v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>>>::~__hash_table(uint64_t a1)
{
  unsigned int v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      int v3 = (void *)*v2;
      uint64_t v4 = v2[3];
      v2[3] = 0;
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
      operator delete(v2);
      unsigned int v2 = v3;
    }
    while (v3);
  }
  int v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

uint64_t Phase::Controller::DVM::GenericVoiceNode::GenericVoiceNode(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  *(unsigned char *)(a1 + 19std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(a1 + 92) = 0u;
  *(_OWORD *)(a1 + 108) = 0u;
  *(_OWORD *)(a1 + 124) = 0u;
  *(_OWORD *)(a1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(void *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 192) = 0;
  memset_pattern16((void *)(a1 + 152), &unk_2220A5820, 0x20uLL);
  *(void *)a1 = &unk_26D475F98;
  *(void *)(a1 + 200) = a2;
  if (a4 == 1 || !a2) {
    std::terminate();
  }
  return a1;
}

void Phase::Controller::DVM::SamplerVoiceNode::~SamplerVoiceNode(Phase::Controller::DVM::SamplerVoiceNode *this)
{
  Phase::Controller::DVM::VoiceNode::~VoiceNode(this);

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Controller::DVM::GenericVoiceNode::GetVoicePool(Phase::Controller::DVM::GenericVoiceNode *this)
{
  return *((void *)this + 25);
}

void Phase::Controller::DVM::GenericVoiceNode::GetProcedure(Phase::Controller::DVM::GenericVoiceNode *this)
{
}

uint64_t Phase::Controller::DVM::GenericVoiceNode::GetVoiceIOContext@<X0>(Phase::Controller::DVM::GenericVoiceNode *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(Phase::Controller::DVM::GenericVoiceNode *))(*(void *)this + 16))(this);
  uint64_t v5 = *((void *)this + 2);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(void *)(a2 + 24) = v5;
  return result;
}

uint64_t Phase::Controller::DVM::VoiceNode::GetConnectedNodesTailInFrames(Phase::Controller::DVM::VoiceNode *this)
{
  unsigned int v2 = (void *)*((void *)this + 7);
  int v3 = (void *)*((void *)this + 8);
  if (v2 == v3)
  {
    int v4 = 0;
  }
  else
  {
    int v4 = 0;
    do
    {
      uint64_t v5 = (void *)*v2;
      if ((void *)*v2 != v2 + 1)
      {
        do
        {
          int v6 = (*(uint64_t (**)(void))(*(void *)v5[4] + 40))(v5[4]);
          if (v6 > v4) {
            int v4 = v6;
          }
          uint64_t v7 = (void *)v5[1];
          if (v7)
          {
            do
            {
              size_t v8 = v7;
              uint64_t v7 = (void *)*v7;
            }
            while (v7);
          }
          else
          {
            do
            {
              size_t v8 = (void *)v5[2];
              BOOL v9 = *v8 == (void)v5;
              uint64_t v5 = v8;
            }
            while (!v9);
          }
          uint64_t v5 = v8;
        }
        while (v8 != v2 + 1);
      }
      v2 += 3;
    }
    while (v2 != v3);
  }
  return (*((_DWORD *)this + 46) + v4);
}

uint64_t Phase::Controller::DVM::SamplerVoiceNode::HasRenderCallback(Phase::Controller::DVM::SamplerVoiceNode *this)
{
  return *((unsigned __int8 *)this + 208);
}

uint64_t Phase::Controller::DVM::SamplerVoiceNode::GetRenderCallbackInfo(Phase::Controller::DVM::SamplerVoiceNode *this)
{
  if (*((unsigned char *)this + 208)) {
    return (uint64_t)this + 216;
  }
  else {
    return 0;
  }
}

__n128 Phase::Controller::DVM::SamplerVoiceNode::SetRenderCallbackInfo(uint64_t a1, void *a2)
{
  if (!a2 || *(unsigned char *)(a1 + 208))
  {
    if (*(unsigned char *)(a1 + 208)
      && (!a2
       || *(void *)(a1 + 216) != *a2
       || *(void *)(a1 + 224) != a2[1]
       || *(void *)(a1 + 232) != a2[2]
       || *(void *)(a1 + 240) != a2[3]
       || *(void *)(a1 + 248) != a2[4]))
    {
      std::terminate();
    }
  }
  else
  {
    __n128 result = *(__n128 *)a2;
    long long v3 = *((_OWORD *)a2 + 1);
    *(void *)(a1 + 248) = a2[4];
    *(_OWORD *)(a1 + 232) = v3;
    *(__n128 *)(a1 + 21std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
    *(unsigned char *)(a1 + 208) = 1;
  }
  return result;
}

void Phase::Controller::DVM::GenericVoiceNode::~GenericVoiceNode(Phase::Controller::DVM::GenericVoiceNode *this)
{
  Phase::Controller::DVM::VoiceNode::~VoiceNode(this);

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Controller::DVM::VoiceNode::HasRenderCallback(Phase::Controller::DVM::VoiceNode *this)
{
  return 0;
}

uint64_t Phase::Controller::DVM::VoiceNode::GetRenderCallbackInfo(Phase::Controller::DVM::VoiceNode *this)
{
  return 0;
}

void Phase::Controller::DVM::VoiceNode::SetRenderCallbackInfo(uint64_t a1, uint64_t a2)
{
  if (a2) {
    std::terminate();
  }
}

void Phase::Controller::DVM::VoiceNode::~VoiceNode(Phase::Controller::DVM::VoiceNode *this)
{
  *(void *)this = &unk_26D475FF0;
  int v4 = (void **)((char *)this + 128);
  std::vector<Phase::Controller::VoiceBufferParameter>::__destroy_vector::operator()[abi:ne180100](&v4);
  unsigned int v2 = (void *)*((void *)this + 13);
  if (v2)
  {
    *((void *)this + 14) = v2;
    operator delete(v2);
  }
  long long v3 = (void *)*((void *)this + 10);
  if (v3)
  {
    *((void *)this + 1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v3;
    operator delete(v3);
  }
  int v4 = (void **)((char *)this + 56);
  std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100](&v4);
  int v4 = (void **)((char *)this + 32);
  std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100](&v4);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    uint64_t v3 = __p[3];
    __p[3] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>>>::__erase_unique<long long>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return;
  }
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = a2;
    if (*(void *)&v2 <= a2) {
      unint64_t v5 = a2 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (*(void *)&v2 - 1) & a2;
  }
  int v6 = *(void ***)(*a1 + 8 * v5);
  if (!v6) {
    return;
  }
  uint64_t v7 = *v6;
  if (!*v6) {
    return;
  }
  uint64_t v8 = *(void *)&v2 - 1;
  while (1)
  {
    unint64_t v9 = v7[1];
    if (v9 == a2) {
      break;
    }
    if (v4.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v2) {
        v9 %= *(void *)&v2;
      }
    }
    else
    {
      v9 &= v8;
    }
    if (v9 != v5) {
      return;
    }
LABEL_17:
    uint64_t v7 = (void *)*v7;
    if (!v7) {
      return;
    }
  }
  if (v7[2] != a2) {
    goto LABEL_17;
  }
  char v10 = (void *)*v7;
  if (v4.u32[0] > 1uLL)
  {
    if (v9 >= *(void *)&v2) {
      v9 %= *(void *)&v2;
    }
  }
  else
  {
    v9 &= v8;
  }
  uint64_t v11 = *(void **)(*a1 + 8 * v9);
  do
  {
    int64_t v12 = v11;
    uint64_t v11 = (void *)*v11;
  }
  while (v11 != v7);
  if (v12 == a1 + 2) {
    goto LABEL_36;
  }
  unint64_t v13 = v12[1];
  if (v4.u32[0] > 1uLL)
  {
    if (v13 >= *(void *)&v2) {
      v13 %= *(void *)&v2;
    }
  }
  else
  {
    v13 &= v8;
  }
  if (v13 == v9)
  {
LABEL_38:
    if (v10)
    {
      unint64_t v14 = v10[1];
      goto LABEL_40;
    }
  }
  else
  {
LABEL_36:
    if (!v10) {
      goto LABEL_37;
    }
    unint64_t v14 = v10[1];
    if (v4.u32[0] > 1uLL)
    {
      unint64_t v15 = v10[1];
      if (v14 >= *(void *)&v2) {
        unint64_t v15 = v14 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v15 = v14 & v8;
    }
    if (v15 != v9)
    {
LABEL_37:
      *(void *)(*a1 + 8 * v9) = 0;
      char v10 = (void *)*v7;
      goto LABEL_38;
    }
LABEL_40:
    if (v4.u32[0] > 1uLL)
    {
      if (v14 >= *(void *)&v2) {
        v14 %= *(void *)&v2;
      }
    }
    else
    {
      v14 &= v8;
    }
    if (v14 != v9)
    {
      *(void *)(*a1 + 8 * v14) = v12;
      char v10 = (void *)*v7;
    }
  }
  *int64_t v12 = v10;
  void *v7 = 0;
  --a1[3];
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::VoiceNode>>,void *>>>::operator()[abi:ne180100](1, v7);
}

uint64_t std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>>>::__deallocate_node(*(void **)(a1 + 16));
  int8x8_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::__unordered_map_hasher<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::hash<long long>,std::equal_to<long long>,true>,std::__unordered_map_equal<long long,std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,std::equal_to<long long>,std::hash<long long>,true>,std::allocator<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>>>::__deallocate_node(void *__p)
{
  if (__p)
  {
    uint64_t v1 = __p;
    do
    {
      int8x8_t v2 = (void *)*v1;
      uint64_t v3 = v1[3];
      v1[3] = 0;
      if (v3) {
        (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
      }
      operator delete(v1);
      uint64_t v1 = v2;
    }
    while (v2);
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<long long,std::unique_ptr<Phase::Controller::DVM::ProcedureBase>>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    uint64_t v3 = __p[3];
    __p[3] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void Phase::Controller::DVM::ProcedureVoiceNode::~ProcedureVoiceNode(Phase::Controller::DVM::ProcedureVoiceNode *this)
{
  Phase::Controller::DVM::VoiceNode::~VoiceNode(this);

  JUMPOUT(0x223C938A0);
}

void Phase::Controller::DVM::ProcedureVoiceNode::GetVoicePool(Phase::Controller::DVM::ProcedureVoiceNode *this)
{
}

uint64_t Phase::Controller::DVM::ProcedureVoiceNode::GetProcedure(Phase::Controller::DVM::ProcedureVoiceNode *this)
{
  return *((void *)this + 25);
}

uint64_t Phase::Controller::DVM::ProcedureVoiceNode::GetVoiceIOContext@<X0>(Phase::Controller::DVM::ProcedureVoiceNode *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t result = (*(uint64_t (**)(Phase::Controller::DVM::ProcedureVoiceNode *))(*(void *)this + 24))(this);
  uint64_t v5 = *((void *)this + 2);
  *(void *)a2 = result;
  *(void *)(a2 + 8) = v5;
  *(_DWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  *(void *)(a2 + 24) = v5;
  return result;
}

void std::__function::__func<std::hash<unsigned long long>,std::allocator<std::hash<unsigned long long>>,unsigned int ()(unsigned long long)>::~__func()
{
}

void *std::__function::__func<std::hash<unsigned long long>,std::allocator<std::hash<unsigned long long>>,unsigned int ()(unsigned long long)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D4760A0;
  return result;
}

void std::__function::__func<std::hash<unsigned long long>,std::allocator<std::hash<unsigned long long>>,unsigned int ()(unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D4760A0;
}

uint64_t std::__function::__func<std::hash<unsigned long long>,std::allocator<std::hash<unsigned long long>>,unsigned int ()(unsigned long long)>::operator()(uint64_t a1, unsigned int *a2)
{
  return *a2;
}

uint64_t std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>>>::__deallocate_node(a1, *(char **)(a1 + 16));
  int8x8_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>>>::__deallocate_node(uint64_t a1, char *a2)
{
  if (a2)
  {
    int8x8_t v2 = a2;
    do
    {
      uint64_t v3 = *(char **)v2;
      *((void *)v2 + 4) = &unk_26D476238;
      std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::~__hash_table((uint64_t)(v2 + 128));
      uint8x8_t v4 = (void **)(v2 + 104);
      std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__destroy_vector::operator()[abi:ne180100](&v4);
      operator delete(v2);
      int8x8_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  int8x8_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    int8x8_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = v2[4];
      v2[4] = 0;
      if (v4) {
        (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
      }
      operator delete(v2);
      int8x8_t v2 = v3;
    }
    while (v3);
  }
}

void std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  int8x8_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 72;
        std::allocator<Phase::Controller::DVM::Submix::ChannelStrip>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<Phase::Controller::DVM::Submix::ChannelStrip>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void **)(a2 + 24);
  if (v3)
  {
    *(void *)(a2 + 32) = v3;
    operator delete(v3);
  }
  uint64_t v4 = *(void **)a2;
  if (*(void *)a2)
  {
    *(void *)(a2 + 8) = v4;
    operator delete(v4);
  }
}

void *caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::~guarded_lookup_hash_table(uint64_t a1)
{
  if (atomic_load((unsigned int *)(a1 + 48)))
  {
    _os_assert_log();
    uint64_t result = (void *)_os_crash();
    __break(1u);
  }
  else
  {
    uint64_t v3 = atomic_load((unint64_t *)(a1 + 40));
    if (v3)
    {
      uint64_t v4 = caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl::~table_impl(v3);
      MEMORY[0x223C938A0](v4, 0x1060C402CF69088);
    }
    std::mutex::~mutex((std::mutex *)(a1 + 80));
    int v6 = (void **)(a1 + 56);
    std::vector<std::unique_ptr<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl,std::default_delete<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl>>>::__destroy_vector::operator()[abi:ne180100](&v6);
    return std::__function::__value_func<unsigned int ()(unsigned long long)>::~__value_func[abi:ne180100]((void *)a1);
  }
  return result;
}

uint64_t caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl::~table_impl(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = (unsigned int **)(a1 + 16);
    do
    {
      if ((unint64_t)*v3 + 1 >= 2) {
        caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::element_t::release(*v3);
      }
      ++v3;
      --v2;
    }
    while (v2);
  }
  return a1;
}

unsigned int *caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::element_t::release(unsigned int *result)
{
  if ((atomic_fetch_add((atomic_uint *volatile)result, 0xFFFF0000) & 0xFFFF0000) == 0x10000)
  {
    if (atomic_load(result))
    {
      _os_assert_log();
      _os_crash();
      __break(1u);
    }
    else if (((vars8 ^ (2 * vars8)) & 0x4000000000000000) != 0)
    {
      __break(0xC471u);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::vector<std::unique_ptr<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl,std::default_delete<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)**a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
        std::unique_ptr<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl,std::default_delete<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl>>::reset[abi:ne180100](--v4, 0);
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::unique_ptr<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl,std::default_delete<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl>>::reset[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result = *a1;
  *a1 = a2;
  if (result)
  {
    caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl::~table_impl(result);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void *std::__function::__value_func<unsigned int ()(unsigned long long)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      v2[3] = &unk_26D4760E8;
      std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100](v2 + 16);
      std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::~__hash_table((uint64_t)(v2 + 11));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void Phase::Controller::DVM::Tap::~Tap(Phase::Controller::DVM::Tap *this)
{
  *(void *)this = &unk_26D4760E8;
  std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100]((void *)this + 13);
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::~__hash_table((uint64_t)this + 64);
}

{
  uint64_t vars8;

  *(void *)this = &unk_26D4760E8;
  std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100]((void *)this + 13);
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::~__hash_table((uint64_t)this + 64);

  JUMPOUT(0x223C938A0);
}

void *Phase::Controller::DVM::DspNodeBase::GetDescription@<X0>(Phase::Controller::DVM::DspNodeBase *this@<X0>, void *a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v3 = *((void *)this + 5);
  if ((v3 & 0xFF00000000) != 0) {
    uint64_t v4 = Phase::Controller::DVM::kPlayStateStrings[(int)v3];
  }
  else {
    uint64_t v4 = "-";
  }
  snprintf(__str, 0x200uLL, "<node %sId %llu (%s, IO %s)>", Phase::Controller::DVM::kDspNodeTypeStrings[*((int *)this + 2)], *((void *)this + 2), v4, Phase::Controller::DVM::kPlayStateStrings[*((int *)this + 9)]);
  return std::string::basic_string[abi:ne180100]<0>(a2, __str);
}

uint64_t Phase::Controller::DVM::Tap::Reset(uint64_t this)
{
  *(void *)(this + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  return this;
}

void Phase::Controller::DVM::DspNodeBase::GetAllValidDspNodes(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>>>::__deallocate_node(a1, *(char **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>>>::__deallocate_node(uint64_t a1, char *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v3 = *(char **)v2;
      *((void *)v2 + 3) = &unk_26D476128;
      uint64_t v4 = (void **)(v2 + 88);
      std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v4);
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void Phase::Controller::DVM::Renderer::~Renderer(Phase::Controller::DVM::Renderer *this)
{
  *(void *)this = &unk_26D476128;
  uint64_t v1 = (void **)((char *)this + 64);
  std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v2;

  *(void *)this = &unk_26D476128;
  uint64_t v2 = (void **)((char *)this + 64);
  std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v2);
  MEMORY[0x223C938A0](this, 0x10A1C40B315E06FLL);
}

uint64_t Phase::Controller::DVM::Renderer::Reset(uint64_t this)
{
  *(_DWORD *)(this + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  if (*(unsigned char *)(this + 44)) {
    *(unsigned char *)(this + 44) = 0;
  }
  uint64_t v1 = *(void **)(this + 64);
  uint64_t v2 = *(void **)(this + 72);
  while (v1 != v2)
  {
    v1[2] = v1[1];
    void *v1 = 0;
    v1 += 4;
  }
  return this;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      v2[3] = &unk_26D476168;
      uint64_t v4 = (void *)v2[10];
      if (v4)
      {
        v2[11] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void Phase::Controller::DVM::Master::~Master(Phase::Controller::DVM::Master *this)
{
  *(void *)this = &unk_26D476168;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26D476168;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Controller::DVM::Master::Reset(uint64_t this)
{
  *(_DWORD *)(this + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  if (*(unsigned char *)(this + 44)) {
    *(unsigned char *)(this + 44) = 0;
  }
  *(void *)(this + 64) = *(void *)(this + 56);
  return this;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>>>::__deallocate_node(int a1, void *__p)
{
  if (__p)
  {
    uint64_t v2 = __p;
    do
    {
      uint64_t v3 = (void *)*v2;
      v2[3] = &unk_26D4761A8;
      uint64_t v4 = (void *)v2[10];
      if (v4)
      {
        v2[11] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
}

void Phase::Controller::DVM::Sink::~Sink(Phase::Controller::DVM::Sink *this)
{
  *(void *)this = &unk_26D4761A8;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_26D4761A8;
  uint64_t v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    *((void *)this + 8) = v2;
    operator delete(v2);
  }

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Controller::DVM::Sink::Reset(uint64_t this)
{
  *(_DWORD *)(this + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  if (*(unsigned char *)(this + 44)) {
    *(unsigned char *)(this + 44) = 0;
  }
  *(void *)(this + 64) = *(void *)(this + 56);
  return this;
}

void *Phase::Controller::DVM::Sink::GetAllValidVoiceNodes@<X0>(Phase::Controller::DVM::Sink *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<Phase::Controller::DVM::VoiceNode *>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode **,Phase::Controller::DVM::VoiceNode **>(a2, *((const void **)this + 7), *((void *)this + 8), (uint64_t)(*((void *)this + 8) - *((void *)this + 7)) >> 3);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,void *>>>::operator()[abi:ne180100](char a1, uint64_t a2)
{
  if (a1)
  {
    *(void *)(a2 + 32) = &unk_26D476238;
    std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::~__hash_table(a2 + 128);
    uint64_t v3 = (void **)(a2 + 104);
    std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  else if (!a2)
  {
    return;
  }
  operator delete((void *)a2);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    __p[3] = &unk_26D4761A8;
    uint64_t v3 = (void *)__p[10];
    if (v3)
    {
      __p[11] = v3;
      operator delete(v3);
    }
  }

  operator delete(__p);
}

void std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::erase(void *a1, uint64_t *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  uint64_t v3 = *a2;
  unint64_t v4 = a2[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v2);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v2) {
      v4 %= *(void *)&v2;
    }
  }
  else
  {
    v4 &= *(void *)&v2 - 1;
  }
  int v6 = *(uint64_t **)(*a1 + 8 * v4);
  do
  {
    uint64_t v7 = v6;
    int v6 = (uint64_t *)*v6;
  }
  while (v6 != a2);
  if (v7 != a1 + 2)
  {
    unint64_t v8 = v7[1];
    if (v5.u32[0] > 1uLL)
    {
      if (v8 >= *(void *)&v2) {
        v8 %= *(void *)&v2;
      }
    }
    else
    {
      v8 &= *(void *)&v2 - 1;
    }
    if (v8 == v4)
    {
LABEL_20:
      if (!v3) {
        goto LABEL_27;
      }
      goto LABEL_21;
    }
  }
  if (!v3) {
    goto LABEL_19;
  }
  unint64_t v9 = *(void *)(v3 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v9 >= *(void *)&v2) {
      v9 %= *(void *)&v2;
    }
  }
  else
  {
    v9 &= *(void *)&v2 - 1;
  }
  if (v9 != v4)
  {
LABEL_19:
    *(void *)(*a1 + 8 * v4) = 0;
    uint64_t v3 = *a2;
    goto LABEL_20;
  }
LABEL_21:
  unint64_t v10 = *(void *)(v3 + 8);
  if (v5.u32[0] > 1uLL)
  {
    if (v10 >= *(void *)&v2) {
      v10 %= *(void *)&v2;
    }
  }
  else
  {
    v10 &= *(void *)&v2 - 1;
  }
  if (v10 != v4)
  {
    *(void *)(*a1 + 8 * v10) = v7;
    uint64_t v3 = *a2;
  }
LABEL_27:
  uint64_t *v7 = v3;
  *a2 = 0;
  --a1[3];
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,void *>>>::operator()[abi:ne180100](1, a2);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    uint64_t v3 = (void *)__p[4];
    if (v3)
    {
      __p[5] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t *std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::UniqueObjectId>>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  int8x8_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      uint64_t v3 = v2;
      int8x8_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    unint64_t v4 = a2;
    do
    {
      uint64_t v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      unint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  int v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    __p[3] = &unk_26D4760E8;
    std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100](__p + 16);
    std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::SubmixTapGains>>>::~__hash_table((uint64_t)(__p + 11));
  }

  operator delete(__p);
}

_DWORD *caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::rehash(unint64_t *a1, unsigned int a2)
{
  unint64_t v4 = a1 + 5;
  unint64_t v5 = atomic_load(a1 + 5);
  int v6 = operator new(8 * (a2 - 1) + 24);
  *(void *)int v6 = a1;
  unint64_t v6[2] = a2;
  bzero(v6 + 4, 8 * a2);
  if (v5)
  {
    uint64_t v7 = *(unsigned int *)(v5 + 8);
    if (v7)
    {
      unint64_t v8 = (unint64_t *)(v5 + 16);
      do
      {
        unint64_t v9 = *v8;
        if (*v8 + 1 >= 2)
        {
          unint64_t SlotForKey = caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl::findSlotForKey((uint64_t)v6, *(void *)(v9 + 8));
          if ((SlotForKey & 1) == 0)
          {
            atomic_fetch_add((atomic_uint *volatile)v9, 0x10000u);
            atomic_store(v9, (unint64_t *)&v6[2 * HIDWORD(SlotForKey) + 4]);
          }
        }
        ++v8;
        --v7;
      }
      while (v7);
    }
    atomic_store((unint64_t)v6, a1 + 5);
    int64_t v12 = (uint64_t *)a1[8];
    unint64_t v11 = a1[9];
    if ((unint64_t)v12 >= v11)
    {
      unint64_t v14 = (void *)a1[7];
      uint64_t v15 = v12 - v14;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 61) {
        std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v17 = v11 - (void)v14;
      if (v17 >> 2 > v16) {
        unint64_t v16 = v17 >> 2;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18)
      {
        if (v18 >> 61) {
          std::__throw_bad_array_new_length[abi:ne180100]();
        }
        uint64_t v19 = (char *)operator new(8 * v18);
      }
      else
      {
        uint64_t v19 = 0;
      }
      uint64_t v20 = (unint64_t *)&v19[8 * v15];
      BOOL v21 = &v19[8 * v18];
      *uint64_t v20 = v5;
      unint64_t v13 = v20 + 1;
      if (v12 == v14)
      {
        a1[7] = (unint64_t)v20;
        a1[8] = (unint64_t)v13;
        a1[9] = (unint64_t)v21;
      }
      else
      {
        do
        {
          unint64_t v22 = *--v12;
          *int64_t v12 = 0;
          *--uint64_t v20 = v22;
        }
        while (v12 != v14);
        int64_t v12 = (uint64_t *)a1[7];
        uint64_t v23 = (uint64_t *)a1[8];
        a1[7] = (unint64_t)v20;
        a1[8] = (unint64_t)v13;
        a1[9] = (unint64_t)v21;
        while (v23 != v12)
          std::unique_ptr<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl,std::default_delete<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl>>::reset[abi:ne180100](--v23, 0);
      }
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      *int64_t v12 = v5;
      unint64_t v13 = v12 + 1;
    }
    a1[8] = (unint64_t)v13;
  }
  else
  {
    atomic_store((unint64_t)v6, v4);
  }
  return v6;
}

uint64_t caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::emptyReleasePool(uint64_t result)
{
  int v1 = atomic_load((unsigned int *)(result + 48));
  if (v1 <= 0)
  {
    uint64_t v2 = result;
    unint64_t v4 = *(uint64_t **)(result + 56);
    for (uint64_t i = *(uint64_t **)(result + 64);
          i != v4;
          uint64_t result = std::unique_ptr<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl,std::default_delete<caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl>>::reset[abi:ne180100](i, 0))
    {
      --i;
    }
    *(void *)(v2 + 64) = v4;
  }
  return result;
}

uint64_t caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl::findSlotForKey(uint64_t a1, uint64_t a2)
{
  int v4 = *(_DWORD *)(a1 + 8);
  uint64_t result = std::function<unsigned int ()(unsigned long long)>::operator()(*(void *)a1, a2);
  signed int v6 = result % *(_DWORD *)(a1 + 8);
  if (v6 >= 3) {
    int v7 = 0;
  }
  else {
    int v7 = v4;
  }
  uint64_t v8 = (v6 + v7 - 3);
  uint64_t v9 = 0xFFFFFFFFLL;
  uint64_t v10 = 1;
  uint64_t v11 = result % *(_DWORD *)(a1 + 8);
  do
  {
    uint64_t v12 = v8;
    unint64_t v13 = atomic_load((unint64_t *)(a1 + 8 * v11 + 16));
    if (v13 == -1)
    {
      if ((int)v9 >= 0) {
        uint64_t v9 = v9;
      }
      else {
        uint64_t v9 = v11;
      }
    }
    else
    {
      if (!v13)
      {
        uint64_t v10 = 0;
        if ((int)v9 >= 0) {
          uint64_t v11 = v9;
        }
        else {
          uint64_t v11 = v11;
        }
        return v10 | (v11 << 32);
      }
      if (*(void *)(v13 + 8) == a2) {
        return v10 | (v11 << 32);
      }
    }
    if ((int)v8 >= 3) {
      int v14 = 0;
    }
    else {
      int v14 = v4;
    }
    uint64_t v8 = (v8 + v14 - 3);
    uint64_t v11 = v12;
  }
  while (v12 != v6);
  if ((v9 & 0x80000000) == 0)
  {
    uint64_t v10 = 0;
    uint64_t v11 = v9;
    return v10 | (v11 << 32);
  }
  __break(1u);
  return result;
}

uint64_t std::function<unsigned int ()(unsigned long long)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,void *>>>::operator()[abi:ne180100](char a1, char *__p)
{
  if (a1)
  {
    *((void *)__p + 3) = &unk_26D476128;
    uint64_t v3 = (void **)(__p + 88);
    std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
  operator delete(__p);
}

void *std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode::IOChannel*,Phase::Controller::DVM::VoiceNode::IOChannel*>(void *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    signed int v6 = result;
    std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__vallocate[abi:ne180100](result, a4);
    uint64_t result = (void *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::Controller::DVM::VoiceNode::IOChannel>,Phase::Controller::DVM::VoiceNode::IOChannel*,Phase::Controller::DVM::VoiceNode::IOChannel*,Phase::Controller::DVM::VoiceNode::IOChannel*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_221F28374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  *(void *)(v9 + 8) = v10;
  std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::string>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::Controller::DVM::VoiceNode::IOChannel>,Phase::Controller::DVM::VoiceNode::IOChannel*,Phase::Controller::DVM::VoiceNode::IOChannel*,Phase::Controller::DVM::VoiceNode::IOChannel*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v10 = a4;
  uint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  unint64_t v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      std::set<Phase::Controller::DVM::VoiceNode::IOChannel::Connection>::set[abi:ne180100](v4, v6);
      v6 += 24;
      uint64_t v4 = v11 + 24;
      v11 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Controller::DVM::VoiceNode::IOChannel>,Phase::Controller::DVM::VoiceNode::IOChannel*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_221F28478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Controller::DVM::VoiceNode::IOChannel>,Phase::Controller::DVM::VoiceNode::IOChannel*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Controller::DVM::VoiceNode::IOChannel>,Phase::Controller::DVM::VoiceNode::IOChannel*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Phase::Controller::DVM::VoiceNode::IOChannel>,Phase::Controller::DVM::VoiceNode::IOChannel*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    do
    {
      uint64_t v3 = v1 - 24;
      std::__tree<Phase::SpatialCategory>::destroy(v1 - 24, *(void **)(v1 - 16));
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

void **std::vector<Phase::Controller::DspNodeVoice>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = (uint64_t)*(result - 1);
  if (0x4EC4EC4EC4EC4EC5 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = v7 + 104 * a2;
      do
      {
        *(void *)uint64_t v7 = 0x7FFFFFFFFFFFFFFFLL;
        *(_OWORD *)(v7 + 8) = 0uLL;
        *(_OWORD *)(v7 + 24) = 0uLL;
        *(_OWORD *)(v7 + 40) = 0uLL;
        *(_OWORD *)(v7 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
        *(_OWORD *)(v7 + 72) = 0uLL;
        *(_OWORD *)(v7 + 88) = 0uLL;
        v7 += 104;
      }
      while (v7 != v13);
      uint64_t v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = 0x4EC4EC4EC4EC4EC5 * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x276276276276276) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x4EC4EC4EC4EC4EC5 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x13B13B13B13B13BLL) {
      unint64_t v11 = 0x276276276276276;
    }
    else {
      unint64_t v11 = v9;
    }
    v16[4] = result;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::DspNodeVoice>>((uint64_t)result, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    int v14 = &v12[104 * v8];
    v16[0] = v12;
    v16[1] = v14;
    void v16[3] = &v12[104 * v11];
    uint64_t v15 = &v14[104 * a2];
    do
    {
      *(void *)int v14 = 0x7FFFFFFFFFFFFFFFLL;
      *(_OWORD *)(v14 + 8) = 0uLL;
      *(_OWORD *)(v14 + 24) = 0uLL;
      *(_OWORD *)(v14 + 40) = 0uLL;
      *(_OWORD *)(v14 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
      *(_OWORD *)(v14 + 72) = 0uLL;
      *(_OWORD *)(v14 + 88) = 0uLL;
      v14 += 104;
    }
    while (v14 != v15);
    void v16[2] = v15;
    std::vector<Phase::Controller::DspNodeVoice>::__swap_out_circular_buffer(a1, v16);
    return std::__split_buffer<Phase::Controller::DspNodeVoice>::~__split_buffer(v16);
  }
  return result;
}

void sub_221F28690(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Phase::Controller::DspNodeVoice>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,void *>>>::operator()[abi:ne180100](char a1, void *__p)
{
  if (a1)
  {
    __p[3] = &unk_26D476168;
    uint64_t v3 = (void *)__p[10];
    if (v3)
    {
      __p[11] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void Phase::Controller::DVM::DspNodePlayStateCommand::~DspNodePlayStateCommand(Phase::Controller::DVM::DspNodePlayStateCommand *this)
{
}

void *Phase::Controller::DVM::DspNodePlayStateCommand::GetDescription@<X0>(Phase::Controller::DVM::DspNodePlayStateCommand *this@<X0>, void *a2@<X8>)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v3 = Phase::Controller::DVM::kDspNodeTypeStrings[*((int *)this + 4)];
  uint64_t v4 = *((void *)this + 3);
  snprintf(__str, 0x100uLL, "%s, %f s", Phase::Controller::DVM::kPlayStateStrings[*((int *)this + 2)], *((float *)this + 3));
  std::string::basic_string[abi:ne180100]<0>(__p, __str);
  if (v8 >= 0) {
    uint64_t v5 = __p;
  }
  else {
    uint64_t v5 = (void **)__p[0];
  }
  snprintf(__str, 0x100uLL, "<cmd node %sId %llu, %s>", v3, v4, (const char *)v5);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, __str);
}

void Phase::Controller::DVM::VoicePlayStateCommand::~VoicePlayStateCommand(Phase::Controller::DVM::VoicePlayStateCommand *this)
{
}

void *Phase::Controller::DVM::VoicePlayStateCommand::GetDescription@<X0>(Phase::Controller::DVM::VoicePlayStateCommand *this@<X0>, void *a2@<X8>)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  Phase::Controller::DVM::VoiceIOContext::GetDescription((Phase::Controller::DVM::VoiceIOContext *)v11, (uint64_t)this + 16);
  int v4 = v12;
  uint64_t v5 = (void **)v11[0];
  snprintf(__str, 0x100uLL, "%s, %f s", Phase::Controller::DVM::kPlayStateStrings[*((int *)this + 2)], *((float *)this + 3));
  std::string::basic_string[abi:ne180100]<0>(__p, __str);
  uint64_t v6 = v11;
  if (v4 < 0) {
    uint64_t v6 = v5;
  }
  if (v10 >= 0) {
    uint64_t v7 = __p;
  }
  else {
    uint64_t v7 = (void **)__p[0];
  }
  snprintf(__s, 0x100uLL, "<cmd voice [%s], %s>", (const char *)v6, (const char *)v7);
  if (v10 < 0) {
    operator delete(__p[0]);
  }
  if (v12 < 0) {
    operator delete(v11[0]);
  }
  return std::string::basic_string[abi:ne180100]<0>(a2, __s);
}

void sub_221F2897C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::__hash_table<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>>>::__erase_unique<void *>(void *a1, void *a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>>>::find<void *>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>>>::find<void *>(void *a1, void *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  char v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    do
    {
      unint64_t v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2) {
          return result;
        }
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(void *)&v2) {
            v10 %= *(void *)&v2;
          }
        }
        else
        {
          v10 &= *(void *)&v2 - 1;
        }
        if (v10 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>>>::remove(a1, a2, (uint64_t)&__p);
  unint64_t v3 = __p;
  std::string __p = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    unint64_t v3 = (std::__shared_weak_count *)__p[4];
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (uint64_t *)result;
  while (2)
  {
    unint64_t v10 = a2 - 1;
    unint64_t v11 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v11;
          uint64_t v12 = (char *)a2 - (char *)v11;
          unint64_t v13 = a2 - v11;
          if (v5 || !v4)
          {
            switch(v13)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                uint64_t v92 = *(a2 - 1);
                uint64_t v93 = *v11;
                int v94 = *(void **)(v92 + 48);
                if (v94)
                {
                  int v95 = -1;
                  do
                  {
                    if (v95 <= *(_DWORD *)(v94[3] + 28)) {
                      int v95 = *(_DWORD *)(v94[3] + 28);
                    }
                    int v94 = (void *)*v94;
                  }
                  while (v94);
                }
                else
                {
                  int v95 = -1;
                }
                v176 = *(void **)(v93 + 48);
                if (v176)
                {
                  int v177 = -1;
                  do
                  {
                    if (v177 <= *(_DWORD *)(v176[3] + 28)) {
                      int v177 = *(_DWORD *)(v176[3] + 28);
                    }
                    v176 = (void *)*v176;
                  }
                  while (v176);
                }
                else
                {
                  int v177 = -1;
                }
                if (v95 < v177)
                {
                  uint64_t *v11 = v92;
                  *(a2 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v93;
                }
                break;
              case 3uLL:
                uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(v11, v11 + 1, a2 - 1);
                break;
              case 4uLL:
                uint64_t result = (uint64_t)std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(v11, v11 + 1, v11 + 2, a2 - 1);
                break;
              case 5uLL:
                uint64_t result = (uint64_t)std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **,0>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v12 <= 191)
          {
            __int16 v96 = v11 + 1;
            BOOL v98 = v11 == a2 || v96 == a2;
            if (a4)
            {
              if (!v98)
              {
                uint64_t v99 = v11;
                do
                {
                  __int16 v100 = v96;
                  uint64_t v101 = v99[1];
                  __int16 v102 = *(void **)(v101 + 48);
                  if (v102)
                  {
                    int v103 = -1;
                    do
                    {
                      if (v103 <= *(_DWORD *)(v102[3] + 28)) {
                        int v103 = *(_DWORD *)(v102[3] + 28);
                      }
                      __int16 v102 = (void *)*v102;
                    }
                    while (v102);
                  }
                  else
                  {
                    int v103 = -1;
                  }
                  uint64_t v104 = *v99;
                  uint64_t v105 = *(void **)(*v99 + 48);
                  if (v105)
                  {
                    int v106 = -1;
                    do
                    {
                      if (v106 <= *(_DWORD *)(v105[3] + 28)) {
                        int v106 = *(_DWORD *)(v105[3] + 28);
                      }
                      uint64_t v105 = (void *)*v105;
                    }
                    while (v105);
                  }
                  else
                  {
                    int v106 = -1;
                  }
                  if (v103 < v106)
                  {
                    unsigned int v107 = v100;
                    while (1)
                    {
                      *unsigned int v107 = v104;
                      if (v99 == v11) {
                        break;
                      }
                      unsigned int v107 = v99;
                      uint64_t v108 = *(void **)(v101 + 48);
                      if (v108)
                      {
                        int v109 = -1;
                        do
                        {
                          if (v109 <= *(_DWORD *)(v108[3] + 28)) {
                            int v109 = *(_DWORD *)(v108[3] + 28);
                          }
                          uint64_t v108 = (void *)*v108;
                        }
                        while (v108);
                      }
                      else
                      {
                        int v109 = -1;
                      }
                      uint64_t v99 = v107 - 1;
                      uint64_t v104 = *(v107 - 1);
                      unint64_t v110 = *(void **)(v104 + 48);
                      if (v110)
                      {
                        int v111 = -1;
                        do
                        {
                          if (v111 <= *(_DWORD *)(v110[3] + 28)) {
                            int v111 = *(_DWORD *)(v110[3] + 28);
                          }
                          unint64_t v110 = (void *)*v110;
                        }
                        while (v110);
                      }
                      else
                      {
                        int v111 = -1;
                      }
                      if (v109 >= v111) {
                        goto LABEL_256;
                      }
                    }
                    unsigned int v107 = v11;
LABEL_256:
                    *unsigned int v107 = v101;
                  }
                  __int16 v96 = v100 + 1;
                  uint64_t v99 = v100;
                }
                while (v100 + 1 != a2);
              }
            }
            else if (!v98)
            {
              do
              {
                uint64_t v164 = v96;
                uint64_t v165 = v9[1];
                uint64_t v166 = *(void **)(v165 + 48);
                if (v166)
                {
                  int v167 = -1;
                  do
                  {
                    if (v167 <= *(_DWORD *)(v166[3] + 28)) {
                      int v167 = *(_DWORD *)(v166[3] + 28);
                    }
                    uint64_t v166 = (void *)*v166;
                  }
                  while (v166);
                }
                else
                {
                  int v167 = -1;
                }
                uint64_t v168 = *v9;
                unint64_t v169 = *(void **)(*v9 + 48);
                if (v169)
                {
                  int v170 = -1;
                  do
                  {
                    if (v170 <= *(_DWORD *)(v169[3] + 28)) {
                      int v170 = *(_DWORD *)(v169[3] + 28);
                    }
                    unint64_t v169 = (void *)*v169;
                  }
                  while (v169);
                }
                else
                {
                  int v170 = -1;
                }
                if (v167 < v170)
                {
                  v171 = v164;
                  do
                  {
                    uint64_t *v171 = v168;
                    v171 = v9;
                    v172 = *(void **)(v165 + 48);
                    if (v172)
                    {
                      int v173 = -1;
                      do
                      {
                        if (v173 <= *(_DWORD *)(v172[3] + 28)) {
                          int v173 = *(_DWORD *)(v172[3] + 28);
                        }
                        v172 = (void *)*v172;
                      }
                      while (v172);
                    }
                    else
                    {
                      int v173 = -1;
                    }
                    --v9;
                    uint64_t v168 = *(v171 - 1);
                    unint64_t v174 = *(void **)(v168 + 48);
                    if (v174)
                    {
                      int v175 = -1;
                      do
                      {
                        if (v175 <= *(_DWORD *)(v174[3] + 28)) {
                          int v175 = *(_DWORD *)(v174[3] + 28);
                        }
                        unint64_t v174 = (void *)*v174;
                      }
                      while (v174);
                    }
                    else
                    {
                      int v175 = -1;
                    }
                  }
                  while (v173 < v175);
                  uint64_t *v171 = v165;
                }
                __int16 v96 = v164 + 1;
                unint64_t v9 = v164;
              }
              while (v164 + 1 != a2);
            }
            return result;
          }
          if (!a3)
          {
            if (v11 != a2)
            {
              int64_t v112 = (v13 - 2) >> 1;
              int64_t v113 = v112;
              do
              {
                int64_t v114 = v113;
                if (v112 >= v113)
                {
                  uint64_t v115 = (2 * v113) | 1;
                  uint64_t v116 = &v11[v115];
                  if (2 * v114 + 2 < (uint64_t)v13)
                  {
                    uint64_t v117 = *(void **)(*v116 + 48);
                    if (v117)
                    {
                      int v118 = -1;
                      do
                      {
                        if (v118 <= *(_DWORD *)(v117[3] + 28)) {
                          int v118 = *(_DWORD *)(v117[3] + 28);
                        }
                        uint64_t v117 = (void *)*v117;
                      }
                      while (v117);
                    }
                    else
                    {
                      int v118 = -1;
                    }
                    uint64_t v119 = v116[1];
                    ++v116;
                    unint64_t v120 = *(void **)(v119 + 48);
                    if (v120)
                    {
                      int v121 = -1;
                      do
                      {
                        if (v121 <= *(_DWORD *)(v120[3] + 28)) {
                          int v121 = *(_DWORD *)(v120[3] + 28);
                        }
                        unint64_t v120 = (void *)*v120;
                      }
                      while (v120);
                    }
                    else
                    {
                      int v121 = -1;
                    }
                    if (v118 < v121) {
                      uint64_t v115 = 2 * v114 + 2;
                    }
                    else {
                      uint64_t v116 = &v11[v115];
                    }
                  }
                  uint64_t v122 = *v116;
                  uint64_t v123 = *(void **)(*v116 + 48);
                  if (v123)
                  {
                    int v124 = -1;
                    do
                    {
                      if (v124 <= *(_DWORD *)(v123[3] + 28)) {
                        int v124 = *(_DWORD *)(v123[3] + 28);
                      }
                      uint64_t v123 = (void *)*v123;
                    }
                    while (v123);
                  }
                  else
                  {
                    int v124 = -1;
                  }
                  uint64_t result = (uint64_t)&v11[v114];
                  uint64_t v125 = *(void *)result;
                  BOOL v126 = *(void **)(*(void *)result + 48);
                  if (v126)
                  {
                    int v127 = -1;
                    do
                    {
                      if (v127 <= *(_DWORD *)(v126[3] + 28)) {
                        int v127 = *(_DWORD *)(v126[3] + 28);
                      }
                      BOOL v126 = (void *)*v126;
                    }
                    while (v126);
                  }
                  else
                  {
                    int v127 = -1;
                  }
                  if (v124 >= v127)
                  {
                    do
                    {
                      uint64_t v128 = v116;
                      *(void *)uint64_t result = v122;
                      if (v112 < v115) {
                        break;
                      }
                      uint64_t v129 = (2 * v115) | 1;
                      uint64_t v116 = &v11[v129];
                      if (2 * v115 + 2 < (uint64_t)v13)
                      {
                        unint64_t v130 = *(void **)(*v116 + 48);
                        if (v130)
                        {
                          int v131 = -1;
                          do
                          {
                            if (v131 <= *(_DWORD *)(v130[3] + 28)) {
                              int v131 = *(_DWORD *)(v130[3] + 28);
                            }
                            unint64_t v130 = (void *)*v130;
                          }
                          while (v130);
                        }
                        else
                        {
                          int v131 = -1;
                        }
                        uint64_t v132 = v116[1];
                        ++v116;
                        unsigned int v133 = *(void **)(v132 + 48);
                        if (v133)
                        {
                          int v134 = -1;
                          do
                          {
                            if (v134 <= *(_DWORD *)(v133[3] + 28)) {
                              int v134 = *(_DWORD *)(v133[3] + 28);
                            }
                            unsigned int v133 = (void *)*v133;
                          }
                          while (v133);
                        }
                        else
                        {
                          int v134 = -1;
                        }
                        if (v131 < v134)
                        {
                          uint64_t v115 = 2 * v115 + 2;
                        }
                        else
                        {
                          uint64_t v116 = &v11[v129];
                          uint64_t v115 = (2 * v115) | 1;
                        }
                      }
                      else
                      {
                        uint64_t v115 = (2 * v115) | 1;
                      }
                      uint64_t v122 = *v116;
                      uint64_t v135 = *(void **)(*v116 + 48);
                      if (v135)
                      {
                        int v136 = -1;
                        do
                        {
                          if (v136 <= *(_DWORD *)(v135[3] + 28)) {
                            int v136 = *(_DWORD *)(v135[3] + 28);
                          }
                          uint64_t v135 = (void *)*v135;
                        }
                        while (v135);
                      }
                      else
                      {
                        int v136 = -1;
                      }
                      unint64_t v137 = *(void **)(v125 + 48);
                      if (v137)
                      {
                        int v138 = -1;
                        do
                        {
                          if (v138 <= *(_DWORD *)(v137[3] + 28)) {
                            int v138 = *(_DWORD *)(v137[3] + 28);
                          }
                          unint64_t v137 = (void *)*v137;
                        }
                        while (v137);
                      }
                      else
                      {
                        int v138 = -1;
                      }
                      uint64_t result = (uint64_t)v128;
                    }
                    while (v136 >= v138);
                    *uint64_t v128 = v125;
                  }
                }
                int64_t v113 = v114 - 1;
              }
              while (v114);
              uint64_t v139 = (unint64_t)v12 >> 3;
              do
              {
                uint64_t v140 = 0;
                uint64_t v141 = *v11;
                __int16 v142 = v11;
                do
                {
                  unint64_t v143 = &v142[v140 + 1];
                  uint64_t v144 = (2 * v140) | 1;
                  uint64_t v145 = 2 * v140 + 2;
                  if (v145 < v139)
                  {
                    uint64_t v146 = *(void **)(*v143 + 48);
                    if (v146)
                    {
                      int v147 = -1;
                      do
                      {
                        if (v147 <= *(_DWORD *)(v146[3] + 28)) {
                          int v147 = *(_DWORD *)(v146[3] + 28);
                        }
                        uint64_t v146 = (void *)*v146;
                      }
                      while (v146);
                    }
                    else
                    {
                      int v147 = -1;
                    }
                    uint64_t result = *(void *)(v143[1] + 48);
                    if (result)
                    {
                      int v148 = -1;
                      do
                      {
                        if (v148 <= *(_DWORD *)(*(void *)(result + 24) + 28)) {
                          int v148 = *(_DWORD *)(*(void *)(result + 24) + 28);
                        }
                        uint64_t result = *(void *)result;
                      }
                      while (result);
                    }
                    else
                    {
                      int v148 = -1;
                    }
                    if (v147 < v148)
                    {
                      ++v143;
                      uint64_t v144 = v145;
                    }
                  }
                  *__int16 v142 = *v143;
                  __int16 v142 = v143;
                  uint64_t v140 = v144;
                }
                while (v144 <= (uint64_t)((unint64_t)(v139 - 2) >> 1));
                if (v143 == --a2)
                {
                  *unint64_t v143 = v141;
                }
                else
                {
                  *unint64_t v143 = *a2;
                  *a2 = v141;
                  uint64_t v149 = (char *)v143 - (char *)v11 + 8;
                  if (v149 >= 9)
                  {
                    unint64_t v150 = (((unint64_t)v149 >> 3) - 2) >> 1;
                    uint64_t v151 = &v11[v150];
                    uint64_t v152 = *v151;
                    UniqueObjectId v153 = *(void **)(*v151 + 48);
                    if (v153)
                    {
                      int v154 = -1;
                      do
                      {
                        if (v154 <= *(_DWORD *)(v153[3] + 28)) {
                          int v154 = *(_DWORD *)(v153[3] + 28);
                        }
                        UniqueObjectId v153 = (void *)*v153;
                      }
                      while (v153);
                    }
                    else
                    {
                      int v154 = -1;
                    }
                    uint64_t v155 = *v143;
                    uint64_t v156 = *(void **)(*v143 + 48);
                    if (v156)
                    {
                      int v157 = -1;
                      do
                      {
                        if (v157 <= *(_DWORD *)(v156[3] + 28)) {
                          int v157 = *(_DWORD *)(v156[3] + 28);
                        }
                        uint64_t v156 = (void *)*v156;
                      }
                      while (v156);
                    }
                    else
                    {
                      int v157 = -1;
                    }
                    if (v154 < v157)
                    {
                      do
                      {
                        uint64_t v158 = v151;
                        *unint64_t v143 = v152;
                        if (!v150) {
                          break;
                        }
                        unint64_t v150 = (v150 - 1) >> 1;
                        uint64_t v151 = &v11[v150];
                        uint64_t v152 = *v151;
                        uint64_t v159 = *(void **)(*v151 + 48);
                        if (v159)
                        {
                          int v160 = -1;
                          do
                          {
                            if (v160 <= *(_DWORD *)(v159[3] + 28)) {
                              int v160 = *(_DWORD *)(v159[3] + 28);
                            }
                            uint64_t v159 = (void *)*v159;
                          }
                          while (v159);
                        }
                        else
                        {
                          int v160 = -1;
                        }
                        uint64_t v161 = *(void **)(v155 + 48);
                        if (v161)
                        {
                          int v162 = -1;
                          do
                          {
                            if (v162 <= *(_DWORD *)(v161[3] + 28)) {
                              int v162 = *(_DWORD *)(v161[3] + 28);
                            }
                            uint64_t v161 = (void *)*v161;
                          }
                          while (v161);
                        }
                        else
                        {
                          int v162 = -1;
                        }
                        unint64_t v143 = v158;
                      }
                      while (v160 < v162);
                      *uint64_t v158 = v155;
                    }
                  }
                }
              }
              while (v139-- > 2);
            }
            return result;
          }
          unint64_t v14 = v13 >> 1;
          uint64_t v15 = &v11[v13 >> 1];
          if ((unint64_t)v12 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(v9, &v9[v13 >> 1], a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(v9 + 1, v15 - 1, a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(v9 + 2, &v9[v14 + 1], a2 - 3);
            uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(v15 - 1, v15, &v9[v14 + 1]);
            uint64_t v16 = *v9;
            *unint64_t v9 = *v15;
            uint64_t *v15 = v16;
          }
          else
          {
            uint64_t result = (uint64_t)std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(&v9[v13 >> 1], v9, a2 - 1);
          }
          --a3;
          uint64_t v17 = *v9;
          if (a4)
          {
            unint64_t v18 = *(void **)(v17 + 48);
            break;
          }
          uint64_t v19 = *(void **)(*(v9 - 1) + 48);
          if (v19)
          {
            int v20 = -1;
            do
            {
              if (v20 <= *(_DWORD *)(v19[3] + 28)) {
                int v20 = *(_DWORD *)(v19[3] + 28);
              }
              uint64_t v19 = (void *)*v19;
            }
            while (v19);
            BOOL v21 = (void *)(v17 + 48);
            unint64_t v18 = *(void **)(v17 + 48);
            if (!v18)
            {
LABEL_106:
              unint64_t v18 = 0;
              uint64_t v58 = *v10;
              int v59 = -1;
              LOBYTE(v60) = 1;
              goto LABEL_111;
            }
          }
          else
          {
            BOOL v21 = (void *)(v17 + 48);
            unint64_t v18 = *(void **)(v17 + 48);
            if (!v18) {
              goto LABEL_106;
            }
            int v20 = -1;
          }
          int v22 = -1;
          uint64_t v23 = v18;
          do
          {
            if (v22 <= *(_DWORD *)(v23[3] + 28)) {
              int v22 = *(_DWORD *)(v23[3] + 28);
            }
            uint64_t v23 = (void *)*v23;
          }
          while (v23);
          if (v20 < v22) {
            break;
          }
          uint64_t v58 = *v10;
          int v59 = -1;
          uint64_t v60 = v18;
          do
          {
            if (v59 <= *(_DWORD *)(v60[3] + 28)) {
              int v59 = *(_DWORD *)(v60[3] + 28);
            }
            uint64_t v60 = (void *)*v60;
          }
          while (v60);
LABEL_111:
          __int16 v61 = *(void **)(v58 + 48);
          if (v61)
          {
            int v62 = -1;
            do
            {
              if (v62 <= *(_DWORD *)(v61[3] + 28)) {
                int v62 = *(_DWORD *)(v61[3] + 28);
              }
              __int16 v61 = (void *)*v61;
            }
            while (v61);
          }
          else
          {
            int v62 = -1;
          }
          unint64_t v11 = v9;
          if (v59 >= v62)
          {
            do
            {
              if (++v11 >= a2) {
                break;
              }
              int v68 = -1;
              if ((v60 & 1) == 0)
              {
                __int16 v69 = v18;
                do
                {
                  if (v68 <= *(_DWORD *)(v69[3] + 28)) {
                    int v68 = *(_DWORD *)(v69[3] + 28);
                  }
                  __int16 v69 = (void *)*v69;
                }
                while (v69);
              }
              float v70 = *(void **)(*v11 + 48);
              if (v70)
              {
                int v71 = -1;
                do
                {
                  if (v71 <= *(_DWORD *)(v70[3] + 28)) {
                    int v71 = *(_DWORD *)(v70[3] + 28);
                  }
                  float v70 = (void *)*v70;
                }
                while (v70);
              }
              else
              {
                int v71 = -1;
              }
            }
            while (v68 >= v71);
          }
          else
          {
            unint64_t v11 = v9;
            do
            {
              int v63 = -1;
              if ((v60 & 1) == 0)
              {
                uint64_t v64 = v18;
                do
                {
                  if (v63 <= *(_DWORD *)(v64[3] + 28)) {
                    int v63 = *(_DWORD *)(v64[3] + 28);
                  }
                  uint64_t v64 = (void *)*v64;
                }
                while (v64);
              }
              uint64_t v65 = v11[1];
              ++v11;
              int v66 = *(void **)(v65 + 48);
              if (v66)
              {
                int v67 = -1;
                do
                {
                  if (v67 <= *(_DWORD *)(v66[3] + 28)) {
                    int v67 = *(_DWORD *)(v66[3] + 28);
                  }
                  int v66 = (void *)*v66;
                }
                while (v66);
              }
              else
              {
                int v67 = -1;
              }
            }
            while (v63 >= v67);
          }
          uint64_t v72 = a2;
          if (v11 < a2)
          {
            uint64_t v72 = a2;
            do
            {
              int v73 = -1;
              if ((v60 & 1) == 0)
              {
                unint64_t v74 = v18;
                do
                {
                  if (v73 <= *(_DWORD *)(v74[3] + 28)) {
                    int v73 = *(_DWORD *)(v74[3] + 28);
                  }
                  unint64_t v74 = (void *)*v74;
                }
                while (v74);
              }
              uint64_t v75 = *--v72;
              unint64_t v76 = *(void **)(v75 + 48);
              if (v76)
              {
                int v77 = -1;
                do
                {
                  if (v77 <= *(_DWORD *)(v76[3] + 28)) {
                    int v77 = *(_DWORD *)(v76[3] + 28);
                  }
                  unint64_t v76 = (void *)*v76;
                }
                while (v76);
              }
              else
              {
                int v77 = -1;
              }
            }
            while (v73 < v77);
          }
          if (v11 < v72)
          {
            uint64_t v78 = *v11;
            uint64_t v79 = *v72;
            do
            {
              uint64_t *v11 = v79;
              *uint64_t v72 = v78;
              __int16 v80 = (void *)*v21;
              do
              {
                uint64_t v81 = v11[1];
                ++v11;
                uint64_t v78 = v81;
                int v82 = -1;
                if (v80)
                {
                  __int16 v83 = (void *)*v21;
                  do
                  {
                    if (v82 <= *(_DWORD *)(v83[3] + 28)) {
                      int v82 = *(_DWORD *)(v83[3] + 28);
                    }
                    __int16 v83 = (void *)*v83;
                  }
                  while (v83);
                }
                double v84 = *(void **)(v78 + 48);
                if (v84)
                {
                  int v85 = -1;
                  do
                  {
                    if (v85 <= *(_DWORD *)(v84[3] + 28)) {
                      int v85 = *(_DWORD *)(v84[3] + 28);
                    }
                    double v84 = (void *)*v84;
                  }
                  while (v84);
                }
                else
                {
                  int v85 = -1;
                }
              }
              while (v82 >= v85);
              do
              {
                uint64_t v86 = *--v72;
                uint64_t v79 = v86;
                int v87 = -1;
                if (v80)
                {
                  long long v88 = (void *)*v21;
                  do
                  {
                    if (v87 <= *(_DWORD *)(v88[3] + 28)) {
                      int v87 = *(_DWORD *)(v88[3] + 28);
                    }
                    long long v88 = (void *)*v88;
                  }
                  while (v88);
                }
                unint64_t v89 = *(void **)(v79 + 48);
                if (v89)
                {
                  int v90 = -1;
                  do
                  {
                    if (v90 <= *(_DWORD *)(v89[3] + 28)) {
                      int v90 = *(_DWORD *)(v89[3] + 28);
                    }
                    unint64_t v89 = (void *)*v89;
                  }
                  while (v89);
                }
                else
                {
                  int v90 = -1;
                }
              }
              while (v87 < v90);
            }
            while (v11 < v72);
          }
          unint64_t v91 = v11 - 1;
          BOOL v4 = v11 - 1 >= v9;
          BOOL v5 = v11 - 1 == v9;
          if (v11 - 1 != v9) {
            *unint64_t v9 = *v91;
          }
          a4 = 0;
          *unint64_t v91 = v17;
        }
        uint64_t v24 = v9;
        do
        {
          uint64_t v25 = v24;
          uint64_t v27 = v24[1];
          ++v24;
          uint64_t v26 = v27;
          int v28 = *(void **)(v27 + 48);
          if (v28)
          {
            int v29 = -1;
            do
            {
              if (v29 <= *(_DWORD *)(v28[3] + 28)) {
                int v29 = *(_DWORD *)(v28[3] + 28);
              }
              int v28 = (void *)*v28;
            }
            while (v28);
          }
          else
          {
            int v29 = -1;
          }
          int v30 = -1;
          if (v18)
          {
            uint64_t v31 = v18;
            do
            {
              if (v30 <= *(_DWORD *)(v31[3] + 28)) {
                int v30 = *(_DWORD *)(v31[3] + 28);
              }
              uint64_t v31 = (void *)*v31;
            }
            while (v31);
          }
        }
        while (v29 < v30);
        uint64_t v32 = a2;
        if (v25 == v9)
        {
          uint64_t v32 = a2;
          do
          {
            if (v24 >= v32) {
              break;
            }
            uint64_t v38 = *--v32;
            uint64_t v39 = *(void **)(v38 + 48);
            if (v39)
            {
              int v40 = -1;
              do
              {
                if (v40 <= *(_DWORD *)(v39[3] + 28)) {
                  int v40 = *(_DWORD *)(v39[3] + 28);
                }
                uint64_t v39 = (void *)*v39;
              }
              while (v39);
            }
            else
            {
              int v40 = -1;
            }
            int v41 = -1;
            if (v18)
            {
              uint64_t v42 = v18;
              do
              {
                if (v41 <= *(_DWORD *)(v42[3] + 28)) {
                  int v41 = *(_DWORD *)(v42[3] + 28);
                }
                uint64_t v42 = (void *)*v42;
              }
              while (v42);
            }
          }
          while (v40 >= v41);
        }
        else
        {
          do
          {
            uint64_t v33 = *--v32;
            BOOL v34 = *(void **)(v33 + 48);
            if (v34)
            {
              int v35 = -1;
              do
              {
                if (v35 <= *(_DWORD *)(v34[3] + 28)) {
                  int v35 = *(_DWORD *)(v34[3] + 28);
                }
                BOOL v34 = (void *)*v34;
              }
              while (v34);
            }
            else
            {
              int v35 = -1;
            }
            int v36 = -1;
            if (v18)
            {
              uint64_t v37 = v18;
              do
              {
                if (v36 <= *(_DWORD *)(v37[3] + 28)) {
                  int v36 = *(_DWORD *)(v37[3] + 28);
                }
                uint64_t v37 = (void *)*v37;
              }
              while (v37);
            }
          }
          while (v35 >= v36);
        }
        if (v24 < v32)
        {
          uint64_t v43 = *v32;
          uint64_t v44 = v24;
          int v45 = v32;
          do
          {
            uint64_t *v44 = v43;
            uint64_t *v45 = v26;
            uint64_t v46 = *(void *)(v17 + 48);
            do
            {
              uint64_t v25 = v44;
              uint64_t v47 = v44[1];
              ++v44;
              uint64_t v26 = v47;
              int v48 = *(void **)(v47 + 48);
              if (v48)
              {
                int v49 = -1;
                do
                {
                  if (v49 <= *(_DWORD *)(v48[3] + 28)) {
                    int v49 = *(_DWORD *)(v48[3] + 28);
                  }
                  int v48 = (void *)*v48;
                }
                while (v48);
              }
              else
              {
                int v49 = -1;
              }
              int v50 = -1;
              if (v46)
              {
                uint64_t v51 = *(void **)(v17 + 48);
                do
                {
                  if (v50 <= *(_DWORD *)(v51[3] + 28)) {
                    int v50 = *(_DWORD *)(v51[3] + 28);
                  }
                  uint64_t v51 = (void *)*v51;
                }
                while (v51);
              }
            }
            while (v49 < v50);
            do
            {
              uint64_t v52 = *--v45;
              uint64_t v43 = v52;
              double v53 = *(void **)(v52 + 48);
              if (v53)
              {
                int v54 = -1;
                do
                {
                  if (v54 <= *(_DWORD *)(v53[3] + 28)) {
                    int v54 = *(_DWORD *)(v53[3] + 28);
                  }
                  double v53 = (void *)*v53;
                }
                while (v53);
              }
              else
              {
                int v54 = -1;
              }
              int v55 = -1;
              if (v46)
              {
                int v56 = *(void **)(v17 + 48);
                do
                {
                  if (v55 <= *(_DWORD *)(v56[3] + 28)) {
                    int v55 = *(_DWORD *)(v56[3] + 28);
                  }
                  int v56 = (void *)*v56;
                }
                while (v56);
              }
            }
            while (v54 >= v55);
          }
          while (v44 < v45);
        }
        if (v25 != v9) {
          *unint64_t v9 = *v25;
        }
        *uint64_t v25 = v17;
        if (v24 >= v32) {
          break;
        }
LABEL_105:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **,false>(v9, v25, a3, a4 & 1);
        a4 = 0;
        unint64_t v11 = v25 + 1;
      }
      BOOL v57 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(v9, v25);
      unint64_t v11 = v25 + 1;
      uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(v25 + 1, a2);
      if (result) {
        break;
      }
      if (!v57) {
        goto LABEL_105;
      }
    }
    a2 = v25;
    if (!v57) {
      continue;
    }
    return result;
  }
}

uint64_t *std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(a1, a2, a3, a4);
  uint64_t v11 = *a4;
  uint64_t v12 = *(void **)(*a5 + 48);
  if (v12)
  {
    int v13 = -1;
    do
    {
      if (v13 <= *(_DWORD *)(v12[3] + 28)) {
        int v13 = *(_DWORD *)(v12[3] + 28);
      }
      uint64_t v12 = (void *)*v12;
    }
    while (v12);
  }
  else
  {
    int v13 = -1;
  }
  unint64_t v14 = *(void **)(v11 + 48);
  if (v14)
  {
    int v15 = -1;
    do
    {
      if (v15 <= *(_DWORD *)(v14[3] + 28)) {
        int v15 = *(_DWORD *)(v14[3] + 28);
      }
      unint64_t v14 = (void *)*v14;
    }
    while (v14);
  }
  else
  {
    int v15 = -1;
  }
  if (v13 < v15)
  {
    *a4 = *a5;
    *a5 = v11;
    uint64_t v16 = *a3;
    uint64_t v17 = *(void **)(*a4 + 48);
    if (v17)
    {
      int v18 = -1;
      do
      {
        if (v18 <= *(_DWORD *)(v17[3] + 28)) {
          int v18 = *(_DWORD *)(v17[3] + 28);
        }
        uint64_t v17 = (void *)*v17;
      }
      while (v17);
    }
    else
    {
      int v18 = -1;
    }
    uint64_t v19 = *(void **)(v16 + 48);
    if (v19)
    {
      int v20 = -1;
      do
      {
        if (v20 <= *(_DWORD *)(v19[3] + 28)) {
          int v20 = *(_DWORD *)(v19[3] + 28);
        }
        uint64_t v19 = (void *)*v19;
      }
      while (v19);
    }
    else
    {
      int v20 = -1;
    }
    if (v18 < v20)
    {
      *a3 = *a4;
      *a4 = v16;
      uint64_t v21 = *a2;
      int v22 = *(void **)(*a3 + 48);
      if (v22)
      {
        int v23 = -1;
        do
        {
          if (v23 <= *(_DWORD *)(v22[3] + 28)) {
            int v23 = *(_DWORD *)(v22[3] + 28);
          }
          int v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        int v23 = -1;
      }
      uint64_t v24 = *(void **)(v21 + 48);
      if (v24)
      {
        int v25 = -1;
        do
        {
          if (v25 <= *(_DWORD *)(v24[3] + 28)) {
            int v25 = *(_DWORD *)(v24[3] + 28);
          }
          uint64_t v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        int v25 = -1;
      }
      if (v23 < v25)
      {
        *a2 = *a3;
        *a3 = v21;
        uint64_t v26 = *a1;
        uint64_t v27 = *(void **)(*a2 + 48);
        if (v27)
        {
          int v28 = -1;
          do
          {
            if (v28 <= *(_DWORD *)(v27[3] + 28)) {
              int v28 = *(_DWORD *)(v27[3] + 28);
            }
            uint64_t v27 = (void *)*v27;
          }
          while (v27);
        }
        else
        {
          int v28 = -1;
        }
        int v29 = *(void **)(v26 + 48);
        if (v29)
        {
          int v30 = -1;
          do
          {
            if (v30 <= *(_DWORD *)(v29[3] + 28)) {
              int v30 = *(_DWORD *)(v29[3] + 28);
            }
            int v29 = (void *)*v29;
          }
          while (v29);
        }
        else
        {
          int v30 = -1;
        }
        if (v28 < v30)
        {
          *a1 = *a2;
          *a2 = v26;
        }
      }
    }
  }
  return result;
}

uint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  BOOL v5 = *(void **)(*a2 + 48);
  if (v5)
  {
    int v6 = -1;
    unint64_t v7 = *(void **)(*a2 + 48);
    do
    {
      if (v6 <= *(_DWORD *)(v7[3] + 28)) {
        int v6 = *(_DWORD *)(v7[3] + 28);
      }
      unint64_t v7 = (void *)*v7;
    }
    while (v7);
  }
  else
  {
    int v6 = -1;
  }
  char v8 = *(void **)(v4 + 48);
  if (v8)
  {
    int v9 = -1;
    do
    {
      if (v9 <= *(_DWORD *)(v8[3] + 28)) {
        int v9 = *(_DWORD *)(v8[3] + 28);
      }
      char v8 = (void *)*v8;
    }
    while (v8);
  }
  else
  {
    int v9 = -1;
  }
  uint64_t v10 = *a3;
  uint64_t v11 = *(void **)(*a3 + 48);
  if (v6 >= v9)
  {
    for (int i = -1; v11; v11 = (void *)*v11)
    {
      if (i <= *(_DWORD *)(v11[3] + 28)) {
        int i = *(_DWORD *)(v11[3] + 28);
      }
    }
    for (j = -1; v5; BOOL v5 = (void *)*v5)
    {
      if (j <= *(_DWORD *)(v5[3] + 28)) {
        int j = *(_DWORD *)(v5[3] + 28);
      }
    }
    if (i < j)
    {
      *a2 = v10;
      *a3 = v3;
      uint64_t v16 = *result;
      uint64_t v17 = *(void **)(*a2 + 48);
      if (v17)
      {
        int v18 = -1;
        do
        {
          if (v18 <= *(_DWORD *)(v17[3] + 28)) {
            int v18 = *(_DWORD *)(v17[3] + 28);
          }
          uint64_t v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        int v18 = -1;
      }
      uint64_t v21 = *(void **)(v16 + 48);
      if (v21)
      {
        int v22 = -1;
        do
        {
          if (v22 <= *(_DWORD *)(v21[3] + 28)) {
            int v22 = *(_DWORD *)(v21[3] + 28);
          }
          uint64_t v21 = (void *)*v21;
        }
        while (v21);
      }
      else
      {
        int v22 = -1;
      }
      if (v18 < v22)
      {
        *uint64_t result = *a2;
        *a2 = v16;
      }
    }
  }
  else
  {
    for (k = -1; v11; uint64_t v11 = (void *)*v11)
    {
      if (k <= *(_DWORD *)(v11[3] + 28)) {
        int k = *(_DWORD *)(v11[3] + 28);
      }
    }
    for (m = -1; v5; BOOL v5 = (void *)*v5)
    {
      if (m <= *(_DWORD *)(v5[3] + 28)) {
        int m = *(_DWORD *)(v5[3] + 28);
      }
    }
    if (k < m)
    {
      *uint64_t result = v10;
LABEL_67:
      *a3 = v4;
      return result;
    }
    *uint64_t result = v3;
    *a2 = v4;
    uint64_t v19 = *(void **)(*a3 + 48);
    if (v19)
    {
      int v20 = -1;
      do
      {
        if (v20 <= *(_DWORD *)(v19[3] + 28)) {
          int v20 = *(_DWORD *)(v19[3] + 28);
        }
        uint64_t v19 = (void *)*v19;
      }
      while (v19);
    }
    else
    {
      int v20 = -1;
    }
    int v23 = *(void **)(v4 + 48);
    if (v23)
    {
      int v24 = -1;
      do
      {
        if (v24 <= *(_DWORD *)(v23[3] + 28)) {
          int v24 = *(_DWORD *)(v23[3] + 28);
        }
        int v23 = (void *)*v23;
      }
      while (v23);
    }
    else
    {
      int v24 = -1;
    }
    if (v20 < v24)
    {
      *a2 = *a3;
      goto LABEL_67;
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      char v8 = *(void **)(v6 + 48);
      if (v8)
      {
        int v9 = -1;
        do
        {
          if (v9 <= *(_DWORD *)(v8[3] + 28)) {
            int v9 = *(_DWORD *)(v8[3] + 28);
          }
          char v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        int v9 = -1;
      }
      int v24 = *(void **)(v7 + 48);
      if (v24)
      {
        int v25 = -1;
        do
        {
          if (v25 <= *(_DWORD *)(v24[3] + 28)) {
            int v25 = *(_DWORD *)(v24[3] + 28);
          }
          int v24 = (void *)*v24;
        }
        while (v24);
      }
      else
      {
        int v25 = -1;
      }
      if (v9 < v25)
      {
        *a1 = v6;
        *(a2 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v7;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(a1, a1 + 1, a1 + 2);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      break;
  }
  while (1)
  {
    uint64_t v13 = *v11;
    unint64_t v14 = *(void **)(*v11 + 48);
    if (v14)
    {
      int v15 = -1;
      do
      {
        if (v15 <= *(_DWORD *)(v14[3] + 28)) {
          int v15 = *(_DWORD *)(v14[3] + 28);
        }
        unint64_t v14 = (void *)*v14;
      }
      while (v14);
    }
    else
    {
      int v15 = -1;
    }
    uint64_t v16 = *v10;
    uint64_t v17 = *(void **)(*v10 + 48);
    if (v17)
    {
      int v18 = -1;
      do
      {
        if (v18 <= *(_DWORD *)(v17[3] + 28)) {
          int v18 = *(_DWORD *)(v17[3] + 28);
        }
        uint64_t v17 = (void *)*v17;
      }
      while (v17);
    }
    else
    {
      int v18 = -1;
    }
    if (v15 < v18)
    {
      uint64_t v19 = v11;
      while (1)
      {
        uint64_t *v19 = v16;
        if (v10 == a1) {
          break;
        }
        uint64_t v19 = v10;
        int v20 = *(void **)(v13 + 48);
        if (v20)
        {
          int v21 = -1;
          do
          {
            if (v21 <= *(_DWORD *)(v20[3] + 28)) {
              int v21 = *(_DWORD *)(v20[3] + 28);
            }
            int v20 = (void *)*v20;
          }
          while (v20);
        }
        else
        {
          int v21 = -1;
        }
        --v10;
        uint64_t v16 = *(v19 - 1);
        int v22 = *(void **)(v16 + 48);
        if (v22)
        {
          int v23 = -1;
          do
          {
            if (v23 <= *(_DWORD *)(v22[3] + 28)) {
              int v23 = *(_DWORD *)(v22[3] + 28);
            }
            int v22 = (void *)*v22;
          }
          while (v22);
        }
        else
        {
          int v23 = -1;
        }
        if (v21 >= v23) {
          goto LABEL_44;
        }
      }
      uint64_t v19 = a1;
LABEL_44:
      uint64_t *v19 = v13;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11++;
    if (v11 == a2) {
      return 1;
    }
  }
}

uint64_t *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes(void)::$_1 &,Phase::Controller::DVM::VoicePoolNode **>(a1, a2, a3);
  uint64_t v9 = *a3;
  uint64_t v10 = *(void **)(*a4 + 48);
  if (v10)
  {
    int v11 = -1;
    do
    {
      if (v11 <= *(_DWORD *)(v10[3] + 28)) {
        int v11 = *(_DWORD *)(v10[3] + 28);
      }
      uint64_t v10 = (void *)*v10;
    }
    while (v10);
  }
  else
  {
    int v11 = -1;
  }
  int v12 = *(void **)(v9 + 48);
  if (v12)
  {
    int v13 = -1;
    do
    {
      if (v13 <= *(_DWORD *)(v12[3] + 28)) {
        int v13 = *(_DWORD *)(v12[3] + 28);
      }
      int v12 = (void *)*v12;
    }
    while (v12);
  }
  else
  {
    int v13 = -1;
  }
  if (v11 < v13)
  {
    *a3 = *a4;
    *a4 = v9;
    uint64_t v14 = *a2;
    int v15 = *(void **)(*a3 + 48);
    if (v15)
    {
      int v16 = -1;
      do
      {
        if (v16 <= *(_DWORD *)(v15[3] + 28)) {
          int v16 = *(_DWORD *)(v15[3] + 28);
        }
        int v15 = (void *)*v15;
      }
      while (v15);
    }
    else
    {
      int v16 = -1;
    }
    uint64_t v17 = *(void **)(v14 + 48);
    if (v17)
    {
      int v18 = -1;
      do
      {
        if (v18 <= *(_DWORD *)(v17[3] + 28)) {
          int v18 = *(_DWORD *)(v17[3] + 28);
        }
        uint64_t v17 = (void *)*v17;
      }
      while (v17);
    }
    else
    {
      int v18 = -1;
    }
    if (v16 < v18)
    {
      *a2 = *a3;
      *a3 = v14;
      uint64_t v19 = *a1;
      int v20 = *(void **)(*a2 + 48);
      if (v20)
      {
        int v21 = -1;
        do
        {
          if (v21 <= *(_DWORD *)(v20[3] + 28)) {
            int v21 = *(_DWORD *)(v20[3] + 28);
          }
          int v20 = (void *)*v20;
        }
        while (v20);
      }
      else
      {
        int v21 = -1;
      }
      int v22 = *(void **)(v19 + 48);
      if (v22)
      {
        int v23 = -1;
        do
        {
          if (v23 <= *(_DWORD *)(v22[3] + 28)) {
            int v23 = *(_DWORD *)(v22[3] + 28);
          }
          int v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        int v23 = -1;
      }
      if (v21 < v23)
      {
        *a1 = *a2;
        *a2 = v19;
      }
    }
  }
  return result;
}

void Phase::Controller::DSPVoiceManager::Implementation::Implementation(std::string *this, long long *a2, long long *a3)
{
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v5 = *a2;
    this->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&this->__r_.__value_.__l.__data_ = v5;
  }
  long long v6 = *a3;
  long long v7 = a3[1];
  long long v8 = a3[2];
  this[3].__r_.__value_.__r.__words[0] = 0;
  *(_OWORD *)&this[1].__r_.__value_.__r.__words[2] = v7;
  *(_OWORD *)&this[2].__r_.__value_.__r.__words[1] = v8;
  *(_OWORD *)&this[1].__r_.__value_.__l.__data_ = v6;
  std::string::basic_string[abi:ne180100]<0>(__p, "VoiceEngine-DVM");
  Phase::DspLayer::VoiceEngine::VoiceEngine((uint64_t)&this[3].__r_.__value_.__l.__size_, (long long *)__p);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  this[3126].__r_.__value_.__l.__size_ = 0x40E7700000000000;
  *(_OWORD *)&this[3126].__r_.__value_.__r.__words[2] = xmmword_2220A5830;
  this[3127].__r_.__value_.__l.__size_ = 0;
  LODWORD(this[3127].__r_.__value_.__r.__words[2]) = 0;
  *(_OWORD *)&this[3128].__r_.__value_.__l.__data_ = xmmword_2220A5010;
  this[3129].__r_.__value_.__r.__words[0] = 0;
  LODWORD(this[3128].__r_.__value_.__r.__words[2]) = 0;
  *(_OWORD *)&this[3129].__r_.__value_.__r.__words[1] = xmmword_2220A5840;
  uint64_t v9 = malloc_type_malloc(0x100000uLL, 0xED83EC4BuLL);
  this[3130].__r_.__value_.__r.__words[0] = (std::string::size_type)v9;
  this[3130].__r_.__value_.__l.__size_ = (std::string::size_type)v9;
  this[3130].__r_.__value_.__s.__data_[16] = 0;
  bzero(v9, SLODWORD(this[3129].__r_.__value_.__r.__words[1]));
  *(_OWORD *)&this[3131].__r_.__value_.__l.__data_ = xmmword_2220A5840;
  uint64_t v10 = malloc_type_malloc(0x100000uLL, 0xED83EC4BuLL);
  this[3131].__r_.__value_.__r.__words[2] = (std::string::size_type)v10;
  this[3132].__r_.__value_.__r.__words[0] = (std::string::size_type)v10;
  this[3132].__r_.__value_.__s.__data_[8] = 0;
  bzero(v10, SLODWORD(this[3131].__r_.__value_.__l.__data_));
  this[3133].__r_.__value_.__l.__size_ = 0;
  this[3133].__r_.__value_.__r.__words[2] = 0;
  this[3134].__r_.__value_.__r.__words[0] = 0;
  Phase::Controller::DSPVoiceManager::Implementation::_Configure((Phase::Logger **)this);
}

void sub_221F2A510(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void **a10, uint64_t *a11, Phase::DspLayer::VoiceEngine *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  Phase::LockFreeQueueSPSC::~LockFreeQueueSPSC(a10);
  std::unique_ptr<Phase::Controller::DVM_RT>::reset[abi:ne180100](a11, 0);
  Phase::DspLayer::VoiceEngine::~VoiceEngine(a12);
  std::unique_ptr<Phase::Controller::DVM::VoiceGraph>::reset[abi:ne180100](v21, 0);
  if (*(char *)(a15 + 23) < 0) {
    operator delete(*(void **)a15);
  }
  _Unwind_Resume(a1);
}

void Phase::Controller::DSPVoiceManager::Implementation::_Configure(Phase::Logger **this)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v2 = this + 9379;
  uint64_t v3 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)this) + 80);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = this[3];
    int v5 = *((_DWORD *)this + 9);
    int v6 = *((_DWORD *)this + 10);
    int v7 = 136316418;
    long long v8 = "DVMImplementation.mm";
    __int16 v9 = 1024;
    int v10 = 70;
    __int16 v11 = 2048;
    char v12 = this;
    __int16 v13 = 2048;
    uint64_t v14 = v4;
    __int16 v15 = 1024;
    int v16 = v5;
    __int16 v17 = 1024;
    int v18 = v6;
    _os_log_impl(&dword_221E5E000, v3, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: configuring with sample rate %.f Hz, channels [out %d, in %d]", (uint8_t *)&v7, 0x32u);
  }
  *(void *)uint64_t v2 = this[3];
  v2[2] = *((_DWORD *)this + 8);
  v2[3] = 12;
  v2[4] = *((_DWORD *)this + 10) + 64;
  v2[5] = 4096;
  Phase::DspLayer::VoiceEngine::Configure((uint64_t)(this + 10), v2);
  Phase::Controller::TaskManager::GetService<Phase::Controller::VoicePoolRegistry>(this[7], 3);
  Phase::Controller::TaskManager::GetService<Phase::Controller::ProcedureRegistry>(this[7], 4);
  operator new();
}

void sub_221F2A7A8(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F0C4068E752D1);
  _Unwind_Resume(a1);
}

void Phase::Controller::DSPVoiceManager::Implementation::~Implementation(Phase::Controller::DSPVoiceManager::Implementation *this)
{
  uint64_t v2 = (char *)this + 75200;
  uint64_t v3 = (void *)*((void *)this + 9400);
  if (v3)
  {
    *((void *)v2 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v3;
    operator delete(v3);
  }
  Phase::LockFreeQueueSPSC::~LockFreeQueueSPSC((void **)this + 9393);
  Phase::LockFreeQueueSPSC::~LockFreeQueueSPSC((void **)this + 9388);
  std::unique_ptr<Phase::Controller::DVM_RT>::reset[abi:ne180100]((uint64_t *)this + 9387, 0);
  Phase::DspLayer::VoiceEngine::~VoiceEngine((Phase::Controller::DSPVoiceManager::Implementation *)((char *)this + 80));
  std::unique_ptr<Phase::Controller::DVM::VoiceGraph>::reset[abi:ne180100]((Phase::Controller::DVM::VoiceGraph **)this + 9, 0);
  if (*((char *)this + 23) < 0) {
    operator delete(*(void **)this);
  }
}

void Phase::Controller::DSPVoiceManager::Implementation::Reset(Phase::Controller::DSPVoiceManager::Implementation *this)
{
  *((void *)this + 15) = *((void *)this + 14);
  Phase::CalendarQueue<128,1024,Phase::DspLayer::VoiceEngine::Action>::Clear((uint64_t)this + 240);
  std::unique_ptr<Phase::Controller::DVM::VoiceGraph>::reset[abi:ne180100]((Phase::Controller::DVM::VoiceGraph **)this + 9, 0);
  Phase::Controller::TaskManager::GetService<Phase::Controller::VoicePoolRegistry>(*((Phase::Logger **)this + 7), 3);
  Phase::Controller::TaskManager::GetService<Phase::Controller::ProcedureRegistry>(*((Phase::Logger **)this + 7), 4);
  operator new();
}

void sub_221F2A974(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10B0C40DC91DD83);
  _Unwind_Resume(a1);
}

Phase::Controller::DVM::VoiceGraph *std::unique_ptr<Phase::Controller::DVM::VoiceGraph>::reset[abi:ne180100](Phase::Controller::DVM::VoiceGraph **a1, Phase::Controller::DVM::VoiceGraph *a2)
{
  BOOL result = *a1;
  *a1 = a2;
  if (result)
  {
    Phase::Controller::DVM::VoiceGraph::~VoiceGraph(result);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void Phase::Controller::DSPVoiceManager::Implementation::Update(Phase::Controller::DSPVoiceManager::Implementation *this)
{
  uint64_t v221 = *MEMORY[0x263EF8340];
  uint64_t v2 = (char *)this + 75104;
  uint64_t v3 = *((void *)this + 9400);
  *((void *)this + 9398) = v3;
  uint64_t v4 = (uint64_t *)((char *)this + 75184);
  *((_DWORD *)this + 18798) = *((_DWORD *)this + 18776) - 32;
  *((_DWORD *)this + 18799) = 20;
  *(_OWORD *)uint64_t v3 = xmmword_2220A5850;
  *(_DWORD *)(v3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 20;
  uint64_t v5 = *((void *)this + 9);
  uint64_t v205 = v4;
  if ((*(unsigned char *)(v5 + 88) & 8) == 0)
  {
    if (*(void *)(v5 + 496) < (unint64_t)((uint64_t)(*(void *)(v5 + 736) - *(void *)(v5 + 728)) >> 3)) {
      goto LABEL_301;
    }
    goto LABEL_48;
  }
  Phase::Controller::DVM::VoiceGraph::GetOrderedVoicePoolNodes((Phase::Controller::DVM::VoiceGraph *)v5, (uint64_t *)&__p);
  BOOL v6 = Phase::Controller::DVM::VoiceGraph::RouteConnections(*((void *)this + 9), (uint64_t **)&__p);
  BOOL v7 = v6;
  if (v6)
  {
    *(void *)(*((void *)this + 9) + 73std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(*((void *)this + 9) + 728);
    uint64_t v8 = *((void *)this + 9);
    BOOL v203 = v6;
    if ((void **)(v8 + 728) == &__p) {
      goto LABEL_27;
    }
    int v10 = (char *)__p;
    __int16 v9 = v208;
    size_t v11 = v208 - (unsigned char *)__p;
    unint64_t v12 = (v208 - (unsigned char *)__p) >> 3;
    uint64_t v13 = *(void *)(v8 + 744);
    uint64_t v14 = *(char **)(v8 + 728);
    if (v12 <= (v13 - (uint64_t)v14) >> 3)
    {
      __int16 v17 = (void **)(v8 + 736);
      uint64_t v19 = *(unsigned char **)(v8 + 736);
      unint64_t v20 = (v19 - v14) >> 3;
      if (v20 < v12)
      {
        int v21 = (char *)__p + 8 * v20;
        if (v19 != v14)
        {
          memmove(*(void **)(v8 + 728), __p, v19 - v14);
          uint64_t v14 = (char *)*v17;
        }
        size_t v11 = v9 - v21;
        if (v9 == v21) {
          goto LABEL_26;
        }
        int v22 = v14;
        int v23 = v21;
        goto LABEL_25;
      }
    }
    else
    {
      if (v14)
      {
        *(void *)(v8 + 73std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v14;
        operator delete(v14);
        uint64_t v13 = 0;
        *(void *)(v8 + 728) = 0;
        *(void *)(v8 + 73std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
        *(void *)(v8 + 744) = 0;
      }
      if ((v11 & 0x8000000000000000) != 0) {
        goto LABEL_304;
      }
      uint64_t v15 = v13 >> 2;
      if (v13 >> 2 <= v12) {
        uint64_t v15 = v12;
      }
      unint64_t v16 = (unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v15;
      if (v16 >> 61) {
LABEL_304:
      }
        std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v8 + 744, v16);
      *(void *)(v8 + 728) = v14;
      __int16 v17 = (void **)(v8 + 736);
      *(void *)(v8 + 73std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v14;
      *(void *)(v8 + 744) = &v14[8 * v18];
    }
    if (v9 == v10)
    {
LABEL_26:
      *__int16 v17 = &v14[v11];
      uint64_t v4 = v205;
LABEL_27:
      if (*(void *)(*v4 + 8) != 1) {
        goto LABEL_301;
      }
      int v24 = (Phase::Logger *)Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMRTOSCCommand,int>(v4, 0);
      if ((int)v24 <= 0) {
        goto LABEL_301;
      }
      int v25 = **(id **)(Phase::Logger::GetInstance(v24) + 80);
      uint64_t v26 = (Phase::Logger *)os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT);
      if (v26)
      {
        uint64_t v27 = (Phase::Controller::DSPVoiceManager::Implementation *)*((void *)this + 12);
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 136;
        __int16 v211 = 2048;
        uint64_t v212 = v27;
        _os_log_impl(&dword_221E5E000, v25, OS_LOG_TYPE_DEFAULT, "%25s:%-5d === Adding voice pools: frame %llu ===", buf, 0x1Cu);
      }
      uint64_t v28 = *((void *)this + 9);
      int v29 = *(void **)(v28 + 728);
      int v30 = *(void **)(v28 + 736);
      if (v29 != v30)
      {
        int v31 = 0;
        do
        {
          if (!*v29) {
            goto LABEL_301;
          }
          uint64_t v26 = (Phase::Logger *)(*(uint64_t (**)(void))(*(void *)*v29 + 24))(*v29);
          if (v26)
          {
            uint64_t v32 = (Phase::Logger *)(*(uint64_t (**)(void))(*(void *)*v29 + 16))();
            uint64_t v33 = v32;
            if (!v32) {
              goto LABEL_301;
            }
            if (*(void *)(*v205 + 8) != 1) {
              goto LABEL_301;
            }
            uint64_t v34 = *((int *)v2 + 23);
            if (*((_DWORD *)v2 + 22) - (int)v34 <= 31) {
              goto LABEL_301;
            }
            uint64_t v35 = *v205 + v34;
            *(void *)(v35 + 4) = 1;
            *(_DWORD *)(v35 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
            *(void *)(v35 + 20) = v32;
            *(_DWORD *)(v35 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 6910057;
            *(_DWORD *)(v35 + 28) = v31;
            uint64_t v36 = *((void *)v2 + 10);
            *(_DWORD *)(v36 + *((int *)v2 + 23)) = 28;
            *(_DWORD *)(v36 + 16) += 32;
            *((_DWORD *)v2 + 23) += 32;
            uint64_t v37 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v32)
                                                                                                + 80)));
            if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v38 = (Phase::Controller::DSPVoiceManager::Implementation *)*((void *)v33 + 6);
              *(_DWORD *)buf = 136315650;
              *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 146;
              __int16 v211 = 2080;
              uint64_t v212 = v38;
              _os_log_impl(&dword_221E5E000, v37, OS_LOG_TYPE_DEFAULT, "%25s:%-5d     %s \n", buf, 0x1Cu);
            }

            ++v31;
          }
          ++v29;
        }
        while (v29 != v30);
      }
      uint64_t v39 = **(id **)(Phase::Logger::GetInstance(v26) + 80);
      uint64_t v4 = v205;
      BOOL v7 = v203;
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 149;
        _os_log_impl(&dword_221E5E000, v39, OS_LOG_TYPE_DEFAULT, "%25s:%-5d === \n", buf, 0x12u);
      }
      goto LABEL_44;
    }
    int v22 = v14;
    int v23 = v10;
LABEL_25:
    memmove(v22, v23, v11);
    goto LABEL_26;
  }
  Phase::Controller::DSPVoiceManager::Implementation::EndMessageBundle(this);
LABEL_44:
  if (__p)
  {
    v208 = (char *)__p;
    operator delete(__p);
  }
  if (!v7) {
    return;
  }
  uint64_t v5 = *((void *)this + 9);
LABEL_48:
  uint64_t v40 = v5 + 680;
  uint64_t v41 = *(void *)(v5 + 688);
  if (v41 != v5 + 680)
  {
    while (2)
    {
      int v42 = *(_DWORD *)(v41 + 64);
      double v43 = *((double *)this + 3) * *(float *)(v41 + 28);
      int v44 = (int)v43;
      int v45 = *(_DWORD *)(v41 + 48);
      if (v42 == 1)
      {
        if (v45 == 1 && *(void *)(*v205 + 8) == 1)
        {
          uint64_t v46 = *(void *)(v41 + 32);
          if (v46)
          {
            switch(*(_DWORD *)(v41 + 24))
            {
              case 0:
                unsigned int v47 = 20;
                goto LABEL_63;
              case 1:
              case 3:
                unsigned int v47 = 19;
                goto LABEL_63;
              case 2:
                unsigned int v47 = 21;
LABEL_63:
                if (!Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMRTOSCCommand,int,Phase::DspLayer::VoicePool const*,long long>(v205, v47, (int)v43, v46, *(void *)(v41 + 40)))goto LABEL_301; {
                goto LABEL_73;
                }
              default:
                goto LABEL_301;
            }
          }
        }
        goto LABEL_301;
      }
      if (v45) {
        goto LABEL_301;
      }
      if (*(void *)(*v205 + 8) != 1) {
        goto LABEL_301;
      }
      int v48 = *(Phase::DspLayer::VoicePool **)(v41 + 32);
      if (!v48) {
        goto LABEL_301;
      }
      unint64_t v49 = *(void *)(v41 + 40);
      switch(*(_DWORD *)(v41 + 24))
      {
        case 0:
          int v50 = v205;
          unsigned int v51 = 5;
          goto LABEL_66;
        case 1:
        case 3:
          int v50 = v205;
          unsigned int v51 = 3;
          goto LABEL_66;
        case 2:
          int v50 = v205;
          unsigned int v51 = 4;
LABEL_66:
          if ((int)Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMRTOSCCommand,int,Phase::DspLayer::VoicePool const*,long long>(v50, v51, (int)v43, *(void *)(v41 + 32), *(void *)(v41 + 40)) <= 0)goto LABEL_301; {
          if (!v42 && *(_DWORD *)(v41 + 24) == 1)
          }
          {
            uint64_t v52 = *((void *)this + 9) + 752;
            *(void *)buf = v48;
            *(void *)&uint8_t buf[8] = v49;
            double v53 = std::__tree<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<std::pair<unsigned long long,long long>,std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>,std::less<std::pair<unsigned long long,long long>>,true>,std::allocator<std::__value_type<std::pair<unsigned long long,long long>,Phase::Controller::DVM::VoicePoolNode *>>>::find<std::pair<unsigned long long,long long>>(v52, (unint64_t *)buf);
            int v54 = (Phase::Controller::DVM::VoiceGraph *)*((void *)this + 9);
            if ((void *)((char *)v54 + 760) == v53)
            {
              VoiceNode = Phase::Controller::DVM::VoiceGraph::GetVoiceNode(v54, v48, v49);
              int v56 = (uint64_t *)(*(uint64_t (**)(void *))(*VoiceNode + 56))(VoiceNode);
              if (v56)
              {
                Phase::Controller::DSPVoiceManager::Implementation::SendConfigureSamplerMessage((uint64_t)this, (uint64_t)v48, v49, -1, v56[1], *v56, v56[2], v56[4], v44);
                BOOL v57 = Phase::Controller::DVM::VoiceGraph::GetVoiceNode(*((Phase::Controller::DVM::VoiceGraph **)this + 9), v48, v49);
                std::vector<Phase::Controller::VoiceBufferParameter>::__clear[abi:ne180100](v57 + 16);
              }
              else
              {
                Phase::Controller::DSPVoiceManager::Implementation::SendConfigureSamplerMessage((uint64_t)this, (uint64_t)v48, v49, 0, 0, 0, 0, 0, v44);
              }
            }
            else
            {
              Phase::Controller::DSPVoiceManager::Implementation::SendConfigureSamplerMessage((uint64_t)this, (uint64_t)v48, v49, 1, 0, 0, 0, 0, v44);
            }
          }
LABEL_73:
          uint64_t v41 = *(void *)(v41 + 8);
          if (v41 != v40) {
            continue;
          }
          uint64_t v5 = *((void *)this + 9);
          uint64_t v4 = v205;
          break;
        default:
          goto LABEL_301;
      }
      break;
    }
  }
  uint64_t v58 = *(void *)(v5 + 664);
  if (v58 != v5 + 656)
  {
    uint64_t v59 = *v4;
    do
    {
      if (*(void *)(v59 + 8) != 1) {
        goto LABEL_301;
      }
      uint64_t v60 = *((int *)v2 + 23);
      if (*((_DWORD *)v2 + 22) - (int)v60 <= 55) {
        goto LABEL_301;
      }
      int v61 = (int)(*((double *)this + 3) * *(float *)(v58 + 28));
      uint64_t v62 = *(int *)(v58 + 32);
      uint64_t v63 = *(int *)(v58 + 24);
      long long v64 = *(_OWORD *)(v58 + 40);
      uint64_t v65 = v59 + v60;
      *(void *)(v65 + 4) = 16;
      *(_DWORD *)(v65 + 20) = v61;
      *(void *)(v65 + 24) = v62;
      strcpy((char *)(v65 + 12), "ihhhh");
      *(_OWORD *)(v65 + 32) = v64;
      *(void *)(v65 + 48) = v63;
      uint64_t v59 = *((void *)v2 + 10);
      *(_DWORD *)(v59 + *((int *)v2 + 23)) = 52;
      *(_DWORD *)(v59 + 16) += 56;
      *((_DWORD *)v2 + 23) += 56;
      uint64_t v58 = *(void *)(v58 + 8);
    }
    while (v58 != v5 + 656);
    uint64_t v5 = *((void *)this + 9);
  }
  std::__list_imp<Phase::Controller::DVM::DspNodePlayStateCommand>::clear((uint64_t *)(v5 + 656));
  std::__list_imp<Phase::Controller::DVM::DspNodePlayStateCommand>::clear((uint64_t *)(*((void *)this + 9) + 680));
  *(void *)(*((void *)this + 9) + 7std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(void *)(*((void *)this + 9) + 704);
  uint64_t v66 = *((void *)this + 9);
  if ((*(unsigned char *)(v66 + 88) & 8) != 0)
  {
    if (*(void *)(*v4 + 8) != 1
      || (int)Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMRTOSCCommand,int>(v4, 0xBu) <= 0)
    {
      goto LABEL_301;
    }
    uint64_t v66 = *((void *)this + 9);
  }
  v195 = *(void **)(v66 + 736);
  if (*(void **)(v66 + 728) == v195) {
    goto LABEL_299;
  }
  int v67 = *(void **)(v66 + 728);
  unint64_t v68 = 8;
  do
  {
    if (!*v67) {
      goto LABEL_301;
    }
    __int16 v196 = v67;
    __int16 v69 = (Phase::Logger *)(*(uint64_t (**)(void))(*(void *)*v67 + 24))(*v67);
    float v70 = v196;
    if (v69)
    {
      __int16 v69 = (Phase::Logger *)(*(uint64_t (**)(void))(*(void *)*v196 + 16))();
      uint64_t j = (uint64_t)v69;
      float v70 = v196;
    }
    else
    {
      uint64_t j = 0;
    }
    uint64_t v72 = *(void **)(*v70 + 48);
    uint64_t v206 = j;
    if (v72)
    {
      do
      {
        uint64_t v197 = v72;
        uint64_t v73 = v72[3];
        if (!v73) {
          goto LABEL_301;
        }
        uint64_t v74 = *(void *)(v73 + 16);
        uint64_t v198 = *(int *)(v73 + 24);
        uint64_t v75 = *(void *)(v73 + 192);
        if ((v75 & 0xFF00000000) == 0 || !v75 && !*(unsigned char *)(v73 + 8))
        {
          uint64_t v92 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v69)
                                                                                              + 80)));
          if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v93 = "Procedure ";
            if (v198 != 1) {
              uint64_t v93 = *(const char **)(j + 48);
            }
            if ((v75 & 0xFF00000000) != 0) {
              int v94 = Phase::Controller::DVM::kPlayStateStrings[(int)v75];
            }
            else {
              int v94 = "none";
            }
            uint64_t v190 = Phase::Controller::DVM::kVoiceTypeStrings[v198];
            *(_DWORD *)buf = 136316674;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 257;
            __int16 v211 = 2048;
            uint64_t v212 = this;
            __int16 v213 = 2048;
            uint64_t v214 = v74;
            __int16 v215 = 2080;
            uint64_t v216 = v93;
            __int16 v217 = 2080;
            uint64_t v218 = v190;
            __int16 v219 = 2080;
            uint64_t v220 = v94;
            _os_log_impl(&dword_221E5E000, v92, OS_LOG_TYPE_DEFAULT, "%25s:%-5d impl@%p: DVM update won't config a voiceId %llu, in a %s voice pool (type %s) without valid play state (%s)", buf, 0x44u);
          }

          goto LABEL_290;
        }
        std::string __p = 0;
        v208 = 0;
        uint64_t v209 = 0;
        std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__init_with_size[abi:ne180100]<Phase::Controller::DVM::VoiceNode::IOChannel*,Phase::Controller::DVM::VoiceNode::IOChannel*>(&__p, *(void *)(v73 + 56), *(void *)(v73 + 64), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v73 + 64) - *(void *)(v73 + 56)) >> 3));
        if (v198 == 1)
        {
          uint64_t v76 = (*(uint64_t (**)(uint64_t))(*(void *)v73 + 24))(v73);
          if (!v76) {
            goto LABEL_301;
          }
          int v77 = __p;
          if (v208 != __p)
          {
            unint64_t v78 = 0;
            do
            {
              if ((*(unsigned char *)(*((void *)this + 9) + 88) & 8) != 0)
              {
                if (*(void *)(*v205 + 8) != 1) {
                  goto LABEL_301;
                }
                uint64_t v79 = *((int *)v2 + 23);
                if (*((_DWORD *)v2 + 22) - (int)v79 >= 56)
                {
                  __int16 v80 = (int *)(*(void *)(v73 + 80) + 8 * v78);
                  int v81 = *v80;
                  LODWORD(v80) = v80[1];
                  uint64_t v82 = *v205 + v79;
                  *(void *)(v82 + 4) = 22;
                  *(_DWORD *)(v82 + 20) = 0;
                  *(void *)(v82 + 24) = v76;
                  *(void *)(v82 + 32) = v74;
                  strcpy((char *)(v82 + 12), "iphihi");
                  *(_DWORD *)(v82 + 40) = v78;
                  *(void *)(v82 + 44) = v81;
                  *(_DWORD *)(v82 + 52) = v80;
                  uint64_t v83 = *((void *)v2 + 10);
                  *(_DWORD *)(v83 + *((int *)v2 + 23)) = 52;
                  *(_DWORD *)(v83 + 16) += 56;
                  *((_DWORD *)v2 + 23) += 56;
                  int v77 = __p;
                }
                double v84 = &v77[24 * v78];
                int v87 = (void *)*v84;
                int v85 = v84 + 1;
                uint64_t v86 = v87;
                if (v87 != v85)
                {
                  do
                  {
                    uint64_t v88 = (*(uint64_t (**)(void))(*(void *)v86[4] + 16))(v86[4]);
                    if (!v88) {
                      goto LABEL_301;
                    }
                    uint64_t v89 = *(void *)(v86[4] + 16);
                    if (v89 < 0) {
                      goto LABEL_301;
                    }
                    Phase::Controller::DSPVoiceManager::Implementation::SendAddVoiceInputMessage((uint64_t)this, v76, v74, v88, v89, *((_DWORD *)v86 + 10), *(_DWORD *)(*(void *)(v73 + 80) + 8 * v78), *(_DWORD *)(*(void *)(v73 + 80) + 8 * v78 + 4), *((float *)v86 + 11), 1);
                    int v90 = (void *)v86[1];
                    if (v90)
                    {
                      do
                      {
                        unint64_t v91 = v90;
                        int v90 = (void *)*v90;
                      }
                      while (v90);
                    }
                    else
                    {
                      do
                      {
                        unint64_t v91 = (void *)v86[2];
                        BOOL v173 = *v91 == (void)v86;
                        uint64_t v86 = v91;
                      }
                      while (!v173);
                    }
                    uint64_t v86 = v91;
                  }
                  while (v91 != v85);
                  int v77 = __p;
                }
              }
              ++v78;
              uint64_t j = v206;
            }
            while (0xAAAAAAAAAAAAAAABLL * ((v208 - v77) >> 3) > v78);
            goto LABEL_150;
          }
LABEL_152:
          uint64_t v119 = (*(uint64_t (**)(uint64_t))(*(void *)v73 + 24))(v73);
          if (!v119) {
            goto LABEL_301;
          }
          unint64_t v120 = *(int **)(v73 + 104);
          int v121 = *(int **)(v73 + 112);
          if (v120 != v121)
          {
            uint64_t v122 = *v205;
            while (*(void *)(v122 + 8) == 1)
            {
              uint64_t v123 = *((int *)v2 + 23);
              if (*((_DWORD *)v2 + 22) - (int)v123 >= 52)
              {
                int v124 = *v120;
                uint64_t v125 = *((void *)v120 + 1);
                uint64_t v126 = v122 + v123;
                *(void *)(v126 + 4) = 23;
                *(_DWORD *)(v126 + 20) = 0;
                *(void *)(v126 + 24) = v119;
                *(void *)(v126 + 32) = v74;
                strcpy((char *)(v126 + 12), "iphid");
                *(_DWORD *)(v126 + 40) = v124;
                *(void *)(v126 + 44) = v125;
                uint64_t v122 = *((void *)v2 + 10);
                *(_DWORD *)(v122 + *((int *)v2 + 23)) = 48;
                *(_DWORD *)(v122 + 16) += 52;
                *((_DWORD *)v2 + 23) += 52;
              }
              v120 += 4;
              if (v120 == v121) {
                goto LABEL_275;
              }
            }
LABEL_301:
            std::terminate();
          }
          goto LABEL_275;
        }
        if (!j || v74 < 0) {
          goto LABEL_301;
        }
        int v95 = __p;
        if (v208 == __p) {
          goto LABEL_150;
        }
        unint64_t v96 = 0;
        do
        {
          if ((*(unsigned char *)(*((void *)this + 9) + 88) & 8) != 0)
          {
            if (*(void *)(*v205 + 8) != 1) {
              goto LABEL_301;
            }
            uint64_t v97 = *((int *)v2 + 23);
            if (*((_DWORD *)v2 + 22) - (int)v97 <= 55) {
              goto LABEL_301;
            }
            BOOL v98 = (int *)(*(void *)(v73 + 80) + 8 * v96);
            int v99 = *v98;
            LODWORD(v98) = v98[1];
            uint64_t v100 = *v205 + v97;
            *(void *)(v100 + 4) = 9;
            *(_DWORD *)(v100 + 20) = 0;
            *(void *)(v100 + 24) = j;
            *(void *)(v100 + 32) = v74;
            strcpy((char *)(v100 + 12), "iphihi");
            *(_DWORD *)(v100 + 40) = v96;
            *(void *)(v100 + 44) = v99;
            *(_DWORD *)(v100 + 52) = v98;
            uint64_t v101 = *((void *)v2 + 10);
            *(_DWORD *)(v101 + *((int *)v2 + 23)) = 52;
            *(_DWORD *)(v101 + 16) += 56;
            *((_DWORD *)v2 + 23) += 56;
            int v95 = __p;
          }
          __int16 v102 = &v95[24 * v96];
          uint64_t v105 = (void *)*v102;
          int v103 = v102 + 1;
          uint64_t v104 = v105;
          if (v105 == v103) {
            goto LABEL_149;
          }
          do
          {
            uint64_t v106 = (*(uint64_t (**)(void))(*(void *)v104[4] + 16))(v104[4]);
            if (!v106) {
              goto LABEL_301;
            }
            uint64_t v107 = *(void *)(v104[4] + 16);
            if (v107 < 0) {
              goto LABEL_301;
            }
            int v108 = *((_DWORD *)v104 + 10);
            uint64_t v109 = *(void *)(*((void *)this + 9) + 88);
            if ((v109 & 8) != 0)
            {
              Phase::Controller::DSPVoiceManager::Implementation::SendAddVoiceInputMessage((uint64_t)this, v206, v74, v106, v107, v108, *(_DWORD *)(*(void *)(v73 + 80) + 8 * v96), *(_DWORD *)(*(void *)(v73 + 80) + 8 * v96 + 4), *((float *)v104 + 11), 0);
              unint64_t v110 = v104 + 6;
            }
            else
            {
              if ((v109 & 4) == 0) {
                goto LABEL_142;
              }
              unint64_t v110 = v104 + 6;
              if (!*((unsigned char *)v104 + 48)) {
                goto LABEL_142;
              }
              if (*(void *)(*v205 + 8) != 1) {
                goto LABEL_301;
              }
              if (v106 == v206) {
                goto LABEL_301;
              }
              uint64_t v111 = *((int *)v2 + 23);
              if (*((_DWORD *)v2 + 22) - (int)v111 <= 79) {
                goto LABEL_301;
              }
              int64_t v112 = (int *)(*(void *)(v73 + 80) + 8 * v96);
              int v113 = *v112;
              LODWORD(v1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v112[1];
              int v114 = *((_DWORD *)v104 + 11);
              uint64_t v115 = *v205 + v111;
              *(void *)(v115 + 4) = 8;
              *(_DWORD *)(v115 + 24) = 0;
              *(void *)(v115 + 28) = v206;
              *(void *)(v115 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v74;
              *(void *)(v115 + 44) = v106;
              *(void *)(v115 + 52) = v107;
              *(_DWORD *)(v115 + 60) = v108;
              *(void *)(v115 + 64) = v113;
              strcpy((char *)(v115 + 12), "iphphihif");
              *(_DWORD *)(v115 + 72) = v112;
              *(_DWORD *)(v115 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v114;
              uint64_t v116 = *((void *)v2 + 10);
              *(_DWORD *)(v116 + *((int *)v2 + 23)) = 76;
              *(_DWORD *)(v116 + 16) += 80;
              *((_DWORD *)v2 + 23) += 80;
            }
            *unint64_t v110 = 0;
LABEL_142:
            uint64_t v117 = (void *)v104[1];
            if (v117)
            {
              do
              {
                int v118 = v117;
                uint64_t v117 = (void *)*v117;
              }
              while (v117);
            }
            else
            {
              do
              {
                int v118 = (void *)v104[2];
                BOOL v173 = *v118 == (void)v104;
                uint64_t v104 = v118;
              }
              while (!v173);
            }
            uint64_t v104 = v118;
          }
          while (v118 != v103);
          int v95 = __p;
LABEL_149:
          ++v96;
          uint64_t j = v206;
        }
        while (0xAAAAAAAAAAAAAAABLL * ((v208 - v95) >> 3) > v96);
LABEL_150:
        if (v198)
        {
          if (v198 == 1) {
            goto LABEL_152;
          }
LABEL_165:
          uint64_t v129 = *(int **)(v73 + 128);
          uint64_t v128 = *(int **)(v73 + 136);
          int v199 = v128;
LABEL_166:
          if (v129 != v128)
          {
            if (!*((unsigned char *)v129 + 24)) {
              goto LABEL_242;
            }
            uint64_t v130 = *((void *)this + 9);
            int v131 = (std::__shared_weak_count *)*((void *)v129 + 2);
            v201 = (unint64_t *)*((void *)v129 + 1);
            unint64_t v132 = *v201;
            if (v131) {
              atomic_fetch_add_explicit(&v131->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            uint64_t v202 = v131;
            unint64_t v133 = 0x9DDFEA08EB382D69 * (((8 * v132) + 8) ^ HIDWORD(v132));
            unint64_t v134 = 0x9DDFEA08EB382D69 * (HIDWORD(v132) ^ (v133 >> 47) ^ v133);
            unint64_t v204 = 0x9DDFEA08EB382D69 * (v134 ^ (v134 >> 47));
            unint64_t v135 = *(void *)(v130 + 560);
            if (v135)
            {
              uint8x8_t v136 = (uint8x8_t)vcnt_s8((int8x8_t)v135);
              v136.i16[0] = vaddlv_u8(v136);
              if (v136.u32[0] > 1uLL)
              {
                unint64_t v68 = 0x9DDFEA08EB382D69 * (v134 ^ (v134 >> 47));
                if (v204 >= v135) {
                  unint64_t v68 = v204 % v135;
                }
              }
              else
              {
                unint64_t v68 = (v135 - 1) & v204;
              }
              unint64_t v137 = *(void **)(*(void *)(v130 + 552) + 8 * v68);
              if (v137)
              {
                for (int i = (void *)*v137; i; int i = (void *)*i)
                {
                  unint64_t v139 = i[1];
                  if (v139 == v204)
                  {
                    if (i[2] == v132)
                    {
                      unint64_t v68 = 8;
                      if (v131) {
                        std::__shared_weak_count::__release_shared[abi:ne180100](v131);
                      }
LABEL_242:
                      if (*(void *)(*v205 + 8) != 1) {
                        goto LABEL_301;
                      }
                      if (!v206) {
                        goto LABEL_301;
                      }
                      int v162 = (uint64_t *)*((void *)v129 + 1);
                      uint64_t v163 = *v162;
                      if (!*v162) {
                        goto LABEL_301;
                      }
                      uint64_t v164 = *((int *)v2 + 23);
                      if (*((_DWORD *)v2 + 22) - (int)v164 <= 55) {
                        goto LABEL_301;
                      }
                      int v165 = *v129;
                      v129 += 8;
                      int v166 = *((_DWORD *)v162 + 2);
                      uint64_t v167 = *v205 + v164;
                      *(void *)(v167 + 4) = 13;
                      *(_DWORD *)(v167 + 20) = 0;
                      *(void *)(v167 + 24) = v206;
                      *(void *)(v167 + 32) = v74;
                      strcpy((char *)(v167 + 12), "iphipi");
                      *(_DWORD *)(v167 + 40) = v165;
                      *(void *)(v167 + 44) = v163;
                      *(_DWORD *)(v167 + 52) = v166;
                      uint64_t v168 = *((void *)v2 + 10);
                      *(_DWORD *)(v168 + *((int *)v2 + 23)) = 52;
                      *(_DWORD *)(v168 + 16) += 56;
                      *((_DWORD *)v2 + 23) += 56;
                      uint64_t v128 = v199;
                      goto LABEL_166;
                    }
                  }
                  else
                  {
                    if (v136.u32[0] > 1uLL)
                    {
                      if (v139 >= v135) {
                        v139 %= v135;
                      }
                    }
                    else
                    {
                      v139 &= v135 - 1;
                    }
                    if (v139 != v68) {
                      break;
                    }
                  }
                }
              }
            }
            uint64_t v140 = operator new(0x28uLL);
            uint64_t v200 = (void *)(v130 + 568);
            *(void *)&uint8_t buf[8] = v130 + 568;
            *uint64_t v140 = 0;
            v140[1] = v204;
            v140[2] = v132;
            v140[3] = v201;
            v140[4] = v202;
            uint8_t buf[16] = 1;
            float v141 = (float)(unint64_t)(*(void *)(v130 + 576) + 1);
            float v142 = *(float *)(v130 + 584);
            if (!v135 || (float)(v142 * (float)v135) < v141)
            {
              BOOL v143 = (v135 & (v135 - 1)) != 0;
              if (v135 < 3) {
                BOOL v143 = 1;
              }
              unint64_t v144 = v143 | (2 * v135);
              unint64_t v145 = vcvtps_u32_f32(v141 / v142);
              if (v144 <= v145) {
                int8x8_t prime = (int8x8_t)v145;
              }
              else {
                int8x8_t prime = (int8x8_t)v144;
              }
              if (*(void *)&prime == 1)
              {
                int8x8_t prime = (int8x8_t)2;
              }
              else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
              {
                int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
              }
              unint64_t v135 = *(void *)(v130 + 560);
              if (*(void *)&prime <= v135)
              {
                if (*(void *)&prime >= v135) {
                  goto LABEL_227;
                }
                unint64_t v153 = vcvtps_u32_f32((float)*(unint64_t *)(v130 + 576) / *(float *)(v130 + 584));
                if (v135 < 3
                  || (uint8x8_t v154 = (uint8x8_t)vcnt_s8((int8x8_t)v135), v154.i16[0] = vaddlv_u8(v154), v154.u32[0] > 1uLL))
                {
                  unint64_t v153 = std::__next_prime(v153);
                }
                else
                {
                  uint64_t v155 = 1 << -(char)__clz(v153 - 1);
                  if (v153 >= 2) {
                    unint64_t v153 = v155;
                  }
                }
                if (*(void *)&prime <= v153) {
                  int8x8_t prime = (int8x8_t)v153;
                }
                if (*(void *)&prime >= v135)
                {
                  unint64_t v135 = *(void *)(v130 + 560);
                  goto LABEL_227;
                }
                if (prime) {
                  goto LABEL_198;
                }
                unint64_t v169 = *(void **)(v130 + 552);
                *(void *)(v130 + 552) = 0;
                unint64_t v68 = v204;
                if (v169) {
                  operator delete(v169);
                }
                unint64_t v135 = 0;
                *(void *)(v130 + 560) = 0;
              }
              else
              {
LABEL_198:
                if (*(void *)&prime >> 61) {
                  std::__throw_bad_array_new_length[abi:ne180100]();
                }
                int v147 = operator new(8 * *(void *)&prime);
                int v148 = *(void **)(v130 + 552);
                *(void *)(v130 + 552) = v147;
                if (v148) {
                  operator delete(v148);
                }
                uint64_t v149 = 0;
                *(int8x8_t *)(v130 + 560) = prime;
                do
                  *(void *)(*(void *)(v130 + 552) + 8 * v149++) = 0;
                while (*(void *)&prime != v149);
                unint64_t v150 = (void *)*v200;
                if (*v200)
                {
                  unint64_t v151 = v150[1];
                  uint8x8_t v152 = (uint8x8_t)vcnt_s8(prime);
                  v152.i16[0] = vaddlv_u8(v152);
                  if (v152.u32[0] > 1uLL)
                  {
                    if (v151 >= *(void *)&prime) {
                      v151 %= *(void *)&prime;
                    }
                  }
                  else
                  {
                    v151 &= *(void *)&prime - 1;
                  }
                  *(void *)(*(void *)(v130 + 552) + 8 * v15Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v200;
                  uint64_t v156 = (void *)*v150;
                  if (*v150)
                  {
                    do
                    {
                      unint64_t v157 = v156[1];
                      if (v152.u32[0] > 1uLL)
                      {
                        if (v157 >= *(void *)&prime) {
                          v157 %= *(void *)&prime;
                        }
                      }
                      else
                      {
                        v157 &= *(void *)&prime - 1;
                      }
                      if (v157 != v151)
                      {
                        uint64_t v158 = *(void *)(v130 + 552);
                        if (!*(void *)(v158 + 8 * v157))
                        {
                          *(void *)(v158 + 8 * v15std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v150;
                          goto LABEL_223;
                        }
                        void *v150 = *v156;
                        *uint64_t v156 = **(void **)(*(void *)(v130 + 552) + 8 * v157);
                        **(void **)(*(void *)(v130 + 552) + 8 * v15std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v156;
                        uint64_t v156 = v150;
                      }
                      unint64_t v157 = v151;
LABEL_223:
                      unint64_t v150 = v156;
                      uint64_t v156 = (void *)*v156;
                      unint64_t v151 = v157;
                    }
                    while (v156);
                  }
                }
                unint64_t v135 = (unint64_t)prime;
LABEL_227:
                unint64_t v68 = v204;
              }
              if ((v135 & (v135 - 1)) != 0)
              {
                if (v68 >= v135) {
                  v68 %= v135;
                }
              }
              else
              {
                v68 &= v135 - 1;
              }
            }
            uint64_t v159 = *(void *)(v130 + 552);
            int v160 = *(void **)(v159 + 8 * v68);
            if (v160)
            {
              *uint64_t v140 = *v160;
              unint64_t v68 = 8;
              goto LABEL_240;
            }
            *uint64_t v140 = *v200;
            *uint64_t v200 = v140;
            *(void *)(v159 + 8 * v68) = v200;
            unint64_t v68 = 8;
            if (*v140)
            {
              unint64_t v161 = *(void *)(*v140 + 8);
              if ((v135 & (v135 - 1)) != 0)
              {
                if (v161 >= v135) {
                  v161 %= v135;
                }
              }
              else
              {
                v161 &= v135 - 1;
              }
              int v160 = (void *)(*(void *)(v130 + 552) + 8 * v161);
LABEL_240:
              void *v160 = v140;
            }
            ++*(void *)(v130 + 576);
            goto LABEL_242;
          }
          int v170 = *(double **)(v73 + 104);
          v171 = *(int **)(v73 + 112);
          for (uint64_t j = v206; v170 != (double *)v171; v170 += 2)
          {
            int v172 = *(_DWORD *)v170;
            BOOL v173 = *(_DWORD *)(v73 + 24) == 5 && v172 == 0;
            if (v173)
            {
              uint64_t v176 = *((void *)this + 9);
              double v177 = v170[1];
              atomic_fetch_add((atomic_uint *volatile)(v176 + 224), 1u);
              uint64_t v178 = atomic_load((unint64_t *)(v176 + 216));
              if (!v178
                || (caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::table_impl::findSlotForKey(v178, (unint64_t)v177), !v179))
              {
                atomic_fetch_add((atomic_uint *volatile)(v176 + 224), 0xFFFFFFFF);
                __assert_rtn("IOGetTapCallback", "DVMGraph.hpp", 161, "false");
              }
              atomic_fetch_add((atomic_uint *volatile)v179, 1u);
              uint64_t v180 = *(void *)(v179 + 16);
              atomic_fetch_add((atomic_uint *volatile)(v176 + 224), 0xFFFFFFFF);
              atomic_fetch_add((atomic_uint *volatile)v179, 0xFFFFFFFF);
              if (*(void *)(*v205 + 8) != 1) {
                goto LABEL_301;
              }
              uint64_t j = v206;
              if (!v206) {
                goto LABEL_301;
              }
              uint64_t v181 = *((int *)v2 + 23);
              if (*((_DWORD *)v2 + 22) - (int)v181 <= 47) {
                goto LABEL_301;
              }
              uint64_t v182 = *v205 + v181;
              *(void *)(v182 + 4) = 18;
              *(_DWORD *)(v182 + 20) = 0;
              *(void *)(v182 + 24) = v206;
              *(void *)(v182 + 32) = v74;
              strcpy((char *)(v182 + 12), "iphp");
              *(void *)(v182 + 40) = v180 + 104;
              uint64_t v174 = *((void *)v2 + 10);
              *(_DWORD *)(v174 + *((int *)v2 + 23)) = 44;
              *(_DWORD *)(v174 + 16) += 48;
              int v175 = *((_DWORD *)v2 + 23) + 48;
              *((_DWORD *)v2 + 23) = v175;
              unint64_t v68 = 8;
              if (*(void *)(v174 + 8) != 1) {
                goto LABEL_301;
              }
              int v172 = *(_DWORD *)v170;
            }
            else
            {
              uint64_t v174 = *v205;
              if (*(void *)(*v205 + 8) != 1 || !j) {
                goto LABEL_301;
              }
              int v175 = *((_DWORD *)v2 + 23);
            }
            if (*((_DWORD *)v2 + 22) - v175 <= 51) {
              goto LABEL_301;
            }
            uint64_t v183 = *((void *)v170 + 1);
            uint64_t v184 = v174 + v175;
            *(void *)(v184 + 4) = 12;
            *(_DWORD *)(v184 + 20) = 0;
            *(void *)(v184 + 24) = j;
            *(void *)(v184 + 32) = v74;
            strcpy((char *)(v184 + 12), "iphid");
            *(_DWORD *)(v184 + 40) = v172;
            *(void *)(v184 + 44) = v183;
            uint64_t v185 = *((void *)v2 + 10);
            *(_DWORD *)(v185 + *((int *)v2 + 23)) = 48;
            *(_DWORD *)(v185 + 16) += 52;
            *((_DWORD *)v2 + 23) += 52;
          }
        }
        else
        {
          if (!(*(unsigned int (**)(uint64_t))(*(void *)v73 + 48))(v73)) {
            goto LABEL_165;
          }
          int v127 = *(unsigned int **)(v73 + 128);
          if (v127 == *(unsigned int **)(v73 + 136)) {
            goto LABEL_165;
          }
          if (!j) {
            goto LABEL_301;
          }
          Phase::DspLayer::VoicePool::GetBuffer(j, *(void *)(v73 + 16), *v127, (uint64_t)buf);
          if (*(_DWORD *)buf || *(void *)&buf[8]) {
            goto LABEL_165;
          }
        }
LABEL_275:
        if ((*(unsigned char *)(*((void *)this + 9) + 88) & 0xC) != 0
          || *(void *)(v73 + 136) != *(void *)(v73 + 128)
          || *(void *)(v73 + 112) != *(void *)(v73 + 104))
        {
          if (v198 == 1)
          {
            uint64_t v186 = (*(uint64_t (**)(uint64_t))(*(void *)v73 + 24))(v73);
            if (*(void *)(*v205 + 8) != 1) {
              goto LABEL_301;
            }
            if (!v186) {
              goto LABEL_301;
            }
            uint64_t v187 = *((int *)v2 + 23);
            if (*((_DWORD *)v2 + 22) - (int)v187 <= 27) {
              goto LABEL_301;
            }
            uint64_t v188 = *v205 + v187;
            *(void *)(v188 + 4) = 24;
            strcpy((char *)(v188 + 12), "ip");
            *(_DWORD *)(v188 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
            *(void *)(v188 + 20) = v186;
            uint64_t v189 = *((void *)v2 + 10);
            *(_DWORD *)(v189 + *((int *)v2 + 23)) = 24;
            *(_DWORD *)(v189 + 16) += 28;
            *((_DWORD *)v2 + 23) += 28;
          }
          else if (*(void *)(*v205 + 8) != 1 {
                 || !j
          }
                 || (int)Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMRTOSCCommand,int,Phase::DspLayer::VoicePool const*,long long>(v205, 0xFu, 0, j, v74) <= 0)
          {
            goto LABEL_301;
          }
        }
        *(void *)buf = &__p;
        std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
LABEL_290:
        uint64_t v72 = (void *)*v197;
      }
      while (*v197);
    }
    int v67 = v196 + 1;
  }
  while (v196 + 1 != v195);
  uint64_t v66 = *((void *)this + 9);
  uint64_t v191 = *(void *)(v66 + 728);
  uint64_t v192 = *(void *)(v66 + 736);
  if (v191 == v192) {
    goto LABEL_299;
  }
  do
  {
    if (!*(void *)v191) {
      goto LABEL_301;
    }
    for (int k = *(void **)(*(void *)v191 + 48); k; int k = (void *)*k)
    {
      __int16 v194 = (void *)k[3];
      if (!v194) {
        goto LABEL_301;
      }
      v194[14] = v194[13];
      std::vector<Phase::Controller::VoiceBufferParameter>::__clear[abi:ne180100](v194 + 16);
    }
    v191 += 8;
  }
  while (v191 != v192);
  uint64_t v66 = *((void *)this + 9);
LABEL_299:
  *(void *)(v66 + 88) = (unint64_t)*(unsigned int *)(v66 + 92) << 32;
  Phase::Controller::DSPVoiceManager::Implementation::EndMessageBundle(this);
}

void sub_221F2C22C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34)
{
  *(void *)(v34 - 200) = &__p;
  std::vector<Phase::Controller::DVM::VoiceNode::IOChannel>::__destroy_vector::operator()[abi:ne180100]((void ***)(v34 - 200));
  _Unwind_Resume(a1);
}

void Phase::Controller::DSPVoiceManager::Implementation::EndMessageBundle(Phase::Controller::DSPVoiceManager::Implementation *this)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  uint64_t v1 = (const void **)((char *)this + 75184);
  if (*(_DWORD *)(*((void *)this + 9398) + 16) != 20)
  {
    uint64_t v3 = mach_absolute_time();
    unint64_t v17 = 0;
    uint64_t v4 = (char *)this + 75104;
    while (1)
    {
      uint64_t v5 = Phase::LockFreeQueueSPSC::GetWriteBuffer(v4, *((_DWORD *)*v1 + 4), &v17);
      if (v5) {
        break;
      }
      sched_yield();
      uint64_t v6 = mach_absolute_time();
      uint64_t v7 = __udivti3();
      if (v6 >= v3) {
        uint64_t v8 = v7;
      }
      else {
        uint64_t v8 = -v7;
      }
      if (v8 >= 10000000)
      {
        __int16 v9 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v7) + 80);
        if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          return;
        }
        int v10 = *((_DWORD *)*v1 + 4);
        *(_DWORD *)buf = 136316162;
        uint64_t v19 = "DVMImplementation.mm";
        __int16 v20 = 1024;
        int v21 = 723;
        __int16 v22 = 1024;
        int v23 = v10;
        __int16 v24 = 2048;
        unint64_t v25 = v8 / 0xF4240uLL;
        __int16 v26 = 2048;
        unint64_t v27 = v17;
        size_t v11 = "%25s:%-5d DVM_NRT unable to reserve %iB in message pipe to DVM_RT after %llims. Pipe has only %zuB availab"
              "le, will stop trying.";
        unint64_t v12 = v9;
        uint32_t v13 = 44;
        goto LABEL_13;
      }
    }
    memcpy(v5, *v1, *((int *)*v1 + 4));
    uint64_t v14 = Phase::LockFreeQueueSPSC::CommitBytes(v4, *((_DWORD *)*v1 + 4));
    if ((v14 & 1) == 0)
    {
      uint64_t v15 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v14) + 80);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        int v16 = *((_DWORD *)*v1 + 4);
        *(_DWORD *)buf = 136315650;
        uint64_t v19 = "DVMImplementation.mm";
        __int16 v20 = 1024;
        int v21 = 738;
        __int16 v22 = 1024;
        int v23 = v16;
        size_t v11 = "%25s:%-5d DVM_NRT unable to write %iB into message pipe to DVM_RT. Pipe is full!";
        unint64_t v12 = v15;
        uint32_t v13 = 24;
LABEL_13:
        _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, v11, buf, v13);
      }
    }
  }
}

void sub_221F2C538(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t Phase::Controller::DSPVoiceManager::Implementation::SendConfigureSamplerMessage(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = *(void *)(result + 75184);
  if (*(void *)(v9 + 8) != 1
    || !a2
    || (uint64_t v10 = *(int *)(result + 75196), *(_DWORD *)(result + 75192) - (int)v10 <= 79))
  {
    std::terminate();
  }
  uint64_t v11 = v9 + v10;
  *(void *)(v11 + 4) = 17;
  *(_DWORD *)(v11 + 24) = a9;
  *(void *)(v11 + 28) = a2;
  *(void *)(v11 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
  *(void *)(v11 + 44) = a5;
  *(void *)(v11 + 52) = a6;
  *(void *)(v11 + 60) = a7;
  *(void *)(v11 + 68) = a8;
  strcpy((char *)(v11 + 12), "iphppppi");
  *(_DWORD *)(v11 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a4;
  uint64_t v12 = *(void *)(result + 75184);
  *(_DWORD *)(v12 + *(int *)(result + 75196)) = 76;
  *(_DWORD *)(v12 + 16) += 80;
  *(_DWORD *)(result + 75196) += 80;
  return result;
}

void *Phase::Controller::DVM::VoiceGraph::GetVoiceNode(Phase::Controller::DVM::VoiceGraph *this, Phase::DspLayer::VoicePool *a2, unint64_t a3)
{
  v8[0] = (unint64_t)a2;
  v8[1] = a3;
  int v9 = 0;
  unint64_t v10 = a3;
  uint64_t v5 = std::__tree<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::__map_value_compare<Phase::Controller::DVM::VoiceIOContext,std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>,std::less<Phase::Controller::DVM::VoiceIOContext>,true>,std::allocator<std::__value_type<Phase::Controller::DVM::VoiceIOContext,Phase::Controller::DVM::VoicePoolNode *>>>::find<Phase::Controller::DVM::VoiceIOContext>((uint64_t)this + 504, (uint64_t)v8);
  if ((void *)((char *)this + 512) == v5) {
    return 0;
  }
  uint64_t v6 = v5[8];
  if (!v6) {
    return 0;
  }
  v8[0] = a3;
  BOOL result = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::Parameter<double>>>>::find<unsigned long long>((void *)(v6 + 32), v8);
  if (result) {
    return (void *)result[3];
  }
  return result;
}

uint64_t Phase::Controller::DSPVoiceManager::Implementation::SendAddVoiceInputMessage(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, int a8, float a9, char a10)
{
  uint64_t v10 = *(void *)(result + 75184);
  if (*(void *)(v10 + 8) != 1
    || a4 == a2
    || (uint64_t v11 = *(int *)(result + 75196), *(_DWORD *)(result + 75192) - (int)v11 <= 79))
  {
    std::terminate();
  }
  uint64_t v12 = v10 + v11;
  *(void *)(v12 + 4) = 6;
  *(unsigned char *)(v12 + 22) = 0;
  *(_DWORD *)(v12 + 24) = 0;
  *(void *)(v12 + 28) = a2;
  *(void *)(v12 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
  *(void *)(v12 + 44) = a4;
  *(void *)(v12 + 52) = a5;
  *(_DWORD *)(v12 + 60) = a6;
  *(void *)(v12 + 64) = a7;
  *(void *)(v12 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0x6968696870687069;
  *(_DWORD *)(v12 + 72) = a8;
  *(unsigned char *)(v12 + 20) = 102;
  *(float *)(v12 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a9;
  if (a10) {
    char v13 = 84;
  }
  else {
    char v13 = 70;
  }
  *(unsigned char *)(v12 + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v13;
  uint64_t v14 = *(void *)(result + 75184);
  *(_DWORD *)(v14 + *(int *)(result + 75196)) = 76;
  *(_DWORD *)(v14 + 16) += 80;
  *(_DWORD *)(result + 75196) += 80;
  return result;
}

uint64_t Phase::Controller::DSPVoiceManager::Implementation::AddTap(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[4] = *MEMORY[0x263EF8340];
  uint64_t v6 = *(void *)(a1 + 72);
  std::__function::__value_func<void ()(float *,unsigned long)>::__value_func[abi:ne180100]((uint64_t)v9, a3);
  uint64_t v7 = Phase::Controller::DVM::VoiceGraph::AddTap(v6, a2, (uint64_t)v9, a4);
  std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100](v9);
  return v7;
}

void sub_221F2C7D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__function::__value_func<void ()(float *,unsigned long)>::~__value_func[abi:ne180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

BOOL Phase::Controller::DSPVoiceManager::Implementation::ProcessMessagesFromDvmRt(Phase::Controller::DSPVoiceManager::Implementation *this)
{
  uint64_t v2 = (Phase::Controller::DSPVoiceManager::Implementation *)((char *)this + 75144);
  BOOL result = Phase::LockFreeQueueSPSC::HasData((Phase::Controller::DSPVoiceManager::Implementation *)((char *)this + 75144));
  if (result)
  {
    uint64_t v4 = (int *)((char *)this + 75148);
    do
    {
      uint64_t v5 = (int *)(*((void *)this + 9395) + *v4);
      uint64_t v7 = v5 + 4;
      unsigned int v6 = *v5;
      if (!*v5) {
        std::terminate();
      }
      if (*v7 == 0x656C646E756223)
      {
        uint64_t v10 = 0;
        uint64_t v11 = 0;
        int v12 = 0;
        if (v5[8] >= 21)
        {
          int v8 = 20;
          do
          {
            int v9 = *(_DWORD *)((char *)v7 + v8);
            uint64_t v10 = (uint64_t)v5 + v8 + 20;
            LODWORD(v1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v9;
            HIDWORD(v1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = (strlen((const char *)(v10 + 8)) & 0xFFFFFFFC) + 12;
            int v12 = 0;
            v8 += v9 + 4;
            Phase::Controller::DSPVoiceManager::Implementation::ProcessMessageFromDvmRt(this, *((void *)v5 + 3), (Phase::PhaseOSCMessage *)&v10);
          }
          while (v8 < v5[8]);
        }
      }
      else
      {
        int v12 = 0;
        uint64_t v10 = (uint64_t)(v5 + 4);
        uint64_t v11 = v6;
        HIDWORD(v1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = (strlen((const char *)v5 + 24) & 0xFFFFFFFC) + 12;
        int v12 = 0;
        Phase::Controller::DSPVoiceManager::Implementation::ProcessMessageFromDvmRt(this, 1, (Phase::PhaseOSCMessage *)&v10);
      }
      *v4 += ((*(_DWORD *)(*((void *)this + 9395) + *v4) + 15) & 0xFFFFFFF0) + 16;
      BOOL result = Phase::LockFreeQueueSPSC::HasData(v2);
    }
    while (result);
  }
  return result;
}

void Phase::Controller::DSPVoiceManager::Implementation::ProcessMessageFromDvmRt(Phase::Controller::DSPVoiceManager::Implementation *this, uint64_t a2, Phase::PhaseOSCMessage *a3)
{
  uint64_t v274 = *MEMORY[0x263EF8340];
  uint64_t v5 = *(void *)a3;
  switch(**(_DWORD **)a3)
  {
    case 0:
      int v6 = *((_DWORD *)a3 + 4);
      uint64_t v7 = *((int *)a3 + 3);
      uint64_t v9 = *(void *)(v5 + v7);
      uint64_t v8 = *(void *)(v5 + v7 + 8);
      uint64_t v10 = *(void *)(v5 + v7 + 16);
      *((_DWORD *)a3 + 3) = v7 + 24;
      *((_DWORD *)a3 + 4) = v6 + 3;
      int v11 = *(_DWORD *)(v5 + v7 + 24);
      unsigned int v12 = *(_DWORD *)(v5 + v7 + 28);
      *((_DWORD *)a3 + 3) = v7 + 36;
      *((_DWORD *)a3 + 4) = v6 + 5;
      char v13 = (void *)(*((void *)this + 9) + 552);
      *(void *)buf = v10;
      uint64_t v14 = std::__hash_table<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,std::shared_ptr<Phase::DspLayer::VoiceBuffer>>>>::__erase_unique<void *>(v13, buf);
      if (v12)
      {
        uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)v14)
                                                                                            + 80)));
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          uint64_t v16 = *(void *)(v9 + 48);
          unint64_t v17 = Phase::DspLayer::VoicePoolErr_ToString(v12);
          *(_DWORD *)buf = 136317186;
          *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1244;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)v232 = v10;
          *(_WORD *)&v232[8] = 1024;
          *(_DWORD *)&v232[10] = v11;
          *(_WORD *)&v232[14] = 2080;
          *(void *)&v232[16] = v16;
          *(_WORD *)&v232[24] = 2048;
          *(void *)&v232[26] = v9;
          *(_WORD *)&v232[34] = 2048;
          *(void *)&v232[36] = v8;
          *(_WORD *)&v232[44] = 2080;
          *(void *)&v232[46] = v17;
          *(_WORD *)&v232[54] = 2048;
          *(void *)&v232[56] = a2;
          _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Error while setting buffer %p[%i] on Voice %s(%p):%llu: \"%s\" @ Frame %llu", buf, 0x54u);
        }
        goto LABEL_42;
      }
      break;
    case 1:
      int32x2_t v79 = vadd_s32(*(int32x2_t *)((char *)a3 + 12), (int32x2_t)0x200000010);
      uint64_t v80 = v5 + (int)*(void *)((char *)a3 + 12);
      int v81 = *(Phase::DspLayer::VoicePool **)v80;
      unint64_t v82 = *(void *)(v80 + 8);
      *(int32x2_t *)((char *)a3 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v79;
      uint64_t v83 = (Phase::Controller::DVM::VoiceGraph *)*((void *)this + 9);
      Phase::Controller::DVM::VoiceGraph::CallbackVoiceFinishedPlaying(v83, v81, v82);
      break;
    case 2:
      uint64_t v18 = (uint64_t *)(v5 + (int)*(void *)((char *)a3 + 12));
      uint64_t v19 = *v18;
      uint64_t v20 = v18[1];
      int v21 = *((_DWORD *)v18 + 4);
      *(int32x2_t *)((char *)a3 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = vadd_s32(*(int32x2_t *)((char *)a3 + 12), (int32x2_t)0x300000018);
      *(void *)buf = v19;
      *(void *)&uint8_t buf[8] = v20;
      *(_DWORD *)&uint8_t buf[16] = 0;
      *(void *)&v232[4] = v20;
      uint64_t v22 = *((void *)this + 9);
      __p[0] = *((void **)this + 9404);
      if ((v21 - 1) > 8) {
        char v23 = 8;
      }
      else {
        char v23 = byte_2220A58D0[v21 - 1];
      }
      Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(v22, (uint64_t)buf, 1, (uint64_t)__p, v23);
      break;
    case 3:
      uint64_t v24 = *((int *)a3 + 3);
      uint64_t v25 = *((int *)a3 + 4);
      uint64_t v27 = *(void *)(v5 + v24);
      uint64_t v26 = *(void *)(v5 + v24 + 8);
      *((_DWORD *)a3 + 3) = v24 + 16;
      *((_DWORD *)a3 + 4) = v25 + 2;
      LODWORD(v24) = *(unsigned __int8 *)(v5 + v25 + 2 + 8) != 84;
      *((_DWORD *)a3 + 4) = v25 + 3;
      *(void *)buf = v27;
      *(void *)&uint8_t buf[8] = v26;
      *(_DWORD *)&uint8_t buf[16] = 1;
      *(void *)&v232[4] = v26;
      uint64_t v28 = *((void *)this + 9);
      __p[0] = *((void **)this + 9404);
      Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(v28, (uint64_t)buf, 1, (uint64_t)__p, 8 * v24);
      break;
    case 4:
      int v29 = (uint64_t *)(v5 + (int)*(void *)((char *)a3 + 12));
      uint64_t v30 = *v29;
      uint64_t v31 = v29[1];
      int v32 = *((_DWORD *)v29 + 4);
      *(int32x2_t *)((char *)a3 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = vadd_s32(*(int32x2_t *)((char *)a3 + 12), (int32x2_t)0x300000018);
      *(void *)buf = v30;
      *(void *)&uint8_t buf[8] = v31;
      *(_DWORD *)&uint8_t buf[16] = 0;
      *(void *)&v232[4] = v31;
      uint64_t v33 = *((void *)this + 9);
      __p[0] = *((void **)this + 9404);
      if ((v32 - 1) > 8) {
        char v34 = 8;
      }
      else {
        char v34 = byte_2220A58D0[v32 - 1];
      }
      Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(v33, (uint64_t)buf, 0, (uint64_t)__p, v34);
      break;
    case 5:
      uint64_t v84 = *((int *)a3 + 3);
      uint64_t v85 = *((int *)a3 + 4);
      uint64_t v87 = *(void *)(v5 + v84);
      uint64_t v86 = *(void *)(v5 + v84 + 8);
      *((_DWORD *)a3 + 3) = v84 + 16;
      *((_DWORD *)a3 + 4) = v85 + 2;
      LODWORD(v84) = *(unsigned __int8 *)(v5 + v85 + 2 + 8) != 84;
      *((_DWORD *)a3 + 4) = v85 + 3;
      *(void *)buf = v87;
      *(void *)&uint8_t buf[8] = v86;
      *(_DWORD *)&uint8_t buf[16] = 1;
      *(void *)&v232[4] = v86;
      uint64_t v88 = *((void *)this + 9);
      __p[0] = *((void **)this + 9404);
      Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(v88, (uint64_t)buf, 0, (uint64_t)__p, 8 * v84);
      break;
    case 6:
      int32x2_t v89 = vadd_s32(*(int32x2_t *)((char *)a3 + 12), (int32x2_t)0x300000018);
      uint64_t v90 = v5 + (int)*(void *)((char *)a3 + 12);
      uint64_t v91 = *(void *)(v90 + 8);
      *(void *)buf = *(void *)v90;
      *(void *)&uint8_t buf[8] = v91;
      *(_DWORD *)&uint8_t buf[16] = 0;
      *(void *)&v232[4] = v91;
      int v92 = *(_DWORD *)(v90 + 16);
      *(int32x2_t *)((char *)a3 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v89;
      uint64_t v93 = *((void *)this + 9);
      __p[0] = *((void **)this + 9404);
      unsigned int v94 = v92 - 1;
      if (v94 > 8) {
        char v95 = 8;
      }
      else {
        char v95 = byte_2220A58D0[v94];
      }
      Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(v93, (uint64_t)buf, 2, (uint64_t)__p, v95);
      break;
    case 7:
      uint64_t v35 = *((int *)a3 + 3);
      uint64_t v36 = *((int *)a3 + 4);
      uint64_t v38 = *(void *)(v5 + v35);
      uint64_t v37 = *(void *)(v5 + v35 + 8);
      *((_DWORD *)a3 + 3) = v35 + 16;
      *((_DWORD *)a3 + 4) = v36 + 2;
      LODWORD(v35) = *(unsigned __int8 *)(v5 + v36 + 2 + 8) != 84;
      *((_DWORD *)a3 + 4) = v36 + 3;
      *(void *)buf = v38;
      *(void *)&uint8_t buf[8] = v37;
      *(_DWORD *)&uint8_t buf[16] = 1;
      *(void *)&v232[4] = v37;
      uint64_t v39 = *((void *)this + 9);
      __p[0] = *((void **)this + 9404);
      Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(v39, (uint64_t)buf, 2, (uint64_t)__p, 8 * v35);
      break;
    case 8:
      int32x2_t v96 = vadd_s32(*(int32x2_t *)((char *)a3 + 12), (int32x2_t)0x400000020);
      uint64_t v97 = v5 + (int)*(void *)((char *)a3 + 12);
      int v98 = *(_DWORD *)v97;
      unint64_t v99 = *(void *)(v97 + 8);
      unint64_t v100 = *(void *)(v97 + 16);
      int v101 = *(_DWORD *)(v97 + 24);
      *(int32x2_t *)((char *)a3 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v96;
      __int16 v102 = (Phase::Controller::DVM::VoiceGraph *)*((void *)this + 9);
      *(void *)buf = *((void *)this + 9404);
      Phase::Controller::DVM::VoiceGraph::CallbackPlayStateChanged(v102, v98, v99, v100, v101, buf, 0);
      break;
    case 9:
      int v40 = *((_DWORD *)a3 + 4);
      uint64_t v41 = *((int *)a3 + 3);
      int v42 = *(_DWORD *)(v5 + v41);
      uint64_t v43 = v41 + 8;
      *((_DWORD *)a3 + 3) = v41 + 8;
      *((_DWORD *)a3 + 4) = v40 + 1;
      switch(v42)
      {
        case 0:
          uint64_t v44 = *(void *)(v5 + v43);
          uint64_t v45 = *(void *)(v41 + v5 + 16);
          *((_DWORD *)a3 + 3) = v41 + 24;
          *((_DWORD *)a3 + 4) = v40 + 3;
          int v46 = *(_DWORD *)(v5 + v41 + 24);
          *((_DWORD *)a3 + 3) = v41 + 28;
          *((_DWORD *)a3 + 4) = v40 + 4;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v47 = *(void *)(v44 + 48);
            *(_DWORD *)buf = 136316674;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1367;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v47;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v44;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v45;
            *(_WORD *)&v232[28] = 1024;
            *(_DWORD *)&v232[30] = v46;
            *(_WORD *)&v232[34] = 2048;
            *(void *)&v232[36] = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Client render callback has failed to return a valid buffer to %s(%p):%llu. Will use a zero buffer and call back again in %i frames @ Frame %llu", buf, 0x40u);
          }
          goto LABEL_42;
        case 1:
          int64_t v112 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                               + 80)));
          if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1326;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = Phase::PhaseOSCMessage::GetNextString(a3);
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = a2;
            _os_log_impl(&dword_221E5E000, v112, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unknown DVM-RT command: %s @ Frame %llu", buf, 0x26u);
          }
          goto LABEL_46;
        case 2:
          int64_t v112 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                               + 80)));
          if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1333;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = Phase::PhaseOSCMessage::GetNextString(a3);
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = a2;
            _os_log_impl(&dword_221E5E000, v112, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Message cannot be scheduled for execution in the past: %s @ Frame %llu", buf, 0x26u);
          }
LABEL_46:

          break;
        case 3:
          uint64_t v113 = *(void *)(v5 + v43);
          uint64_t v114 = *(void *)(v41 + v5 + 16);
          *((_DWORD *)a3 + 3) = v41 + 24;
          *((_DWORD *)a3 + 4) = v40 + 3;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v115 = *(void *)(v113 + 48);
            *(_DWORD *)buf = 136316418;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1342;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v115;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v113;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v114;
            *(_WORD *)&v232[28] = 2048;
            *(void *)&v232[30] = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unknown Voice type to set buffer on callback %s(%p):%llu @ Frame %llu", buf, 0x3Au);
          }
          goto LABEL_42;
        case 4:
          uint64_t v116 = *(void *)(v5 + v43);
          uint64_t v117 = *(void *)(v41 + v5 + 16);
          *((_DWORD *)a3 + 3) = v41 + 24;
          *((_DWORD *)a3 + 4) = v40 + 3;
          int v118 = *(_DWORD *)(v5 + v41 + 24);
          uint64_t v119 = *(void *)(v41 + v5 + 28);
          uint64_t v120 = *(void *)(v41 + v5 + 36);
          *((_DWORD *)a3 + 3) = v41 + 44;
          *((_DWORD *)a3 + 4) = v40 + 6;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v121 = *(void *)(v116 + 48);
            *(_DWORD *)buf = 136317186;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1355;
            *(_WORD *)&unsigned char buf[18] = 1024;
            *(_DWORD *)v232 = v118;
            *(_WORD *)&v232[4] = 2048;
            *(void *)&v232[6] = v119;
            *(_WORD *)&v232[14] = 2080;
            *(void *)&v232[16] = v121;
            *(_WORD *)&v232[24] = 2048;
            *(void *)&v232[26] = v116;
            *(_WORD *)&v232[34] = 2048;
            *(void *)&v232[36] = v117;
            *(_WORD *)&v232[44] = 2080;
            *(void *)&v232[46] = Phase::DspLayer::VoicePoolErr_ToString(v120);
            *(_WORD *)&v232[54] = 2048;
            *(void *)&v232[56] = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unable to set parameter %d with value %g on Voice %s(%p):%llu with VoicePoolErr \"%s\" @ Frame %llu", buf, 0x54u);
          }
          goto LABEL_42;
        case 5:
          uint64_t v163 = *(void *)(v5 + v43);
          uint64_t v165 = *(void *)(v41 + v5 + 16);
          uint64_t v164 = *(void *)(v41 + v5 + 24);
          uint64_t v166 = *(void *)(v41 + v5 + 32);
          *((_DWORD *)a3 + 3) = v41 + 40;
          *((_DWORD *)a3 + 4) = v40 + 5;
          int v167 = *(_DWORD *)(v5 + v41 + 40);
          *((_DWORD *)a3 + 3) = v41 + 44;
          *((_DWORD *)a3 + 4) = v40 + 6;
          uint64_t v168 = *(int *)(v5 + v41 + 44);
          *((_DWORD *)a3 + 3) = v41 + 48;
          *((_DWORD *)a3 + 4) = v40 + 7;
          int v169 = *(_DWORD *)(v5 + v41 + 48);
          uint64_t v170 = *(void *)(v41 + v5 + 52);
          *((_DWORD *)a3 + 3) = v41 + 60;
          *((_DWORD *)a3 + 4) = v40 + 9;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            v171 = Phase::DspLayer::VoicePoolErr_ToString(v170);
            uint64_t v172 = *(void *)(v163 + 48);
            if (v168 > 5) {
              BOOL v173 = "bus";
            }
            else {
              BOOL v173 = off_2645F7460[v168];
            }
            uint64_t v211 = *(void *)(v164 + 48);
            *(_DWORD *)buf = 136318210;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1385;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v171;
            *(_WORD *)&v232[8] = 2080;
            *(void *)&v232[10] = v172;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v163;
            *(_WORD *)&v232[28] = 2048;
            *(void *)&v232[30] = v165;
            *(_WORD *)&v232[38] = 2080;
            *(void *)&v232[40] = v173;
            *(_WORD *)&v232[48] = 1024;
            *(_DWORD *)&v232[50] = v169;
            *(_WORD *)&v232[54] = 1024;
            *(_DWORD *)&v232[56] = v167;
            *(_WORD *)&v232[60] = 2080;
            *(void *)&v232[62] = v211;
            *(_WORD *)int v233 = 2048;
            *(void *)&v233[2] = v164;
            __int16 v234 = 2048;
            *(void *)int v235 = v166;
            *(_WORD *)&v235[8] = 2048;
            uint64_t v236 = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unable to add input connection to Voice with VoicePoolErr \"%s\". %s(%p):%llu] -%s:%i> %i[%s(%p):%llu @ Frame %llu", buf, 0x78u);
          }
          goto LABEL_42;
        case 6:
          uint64_t v174 = *(void *)(v5 + v43);
          uint64_t v176 = *(void *)(v41 + v5 + 16);
          uint64_t v175 = *(void *)(v41 + v5 + 24);
          uint64_t v177 = *(void *)(v41 + v5 + 32);
          *((_DWORD *)a3 + 3) = v41 + 40;
          *((_DWORD *)a3 + 4) = v40 + 5;
          int v178 = *(_DWORD *)(v5 + v41 + 40);
          *((_DWORD *)a3 + 3) = v41 + 44;
          *((_DWORD *)a3 + 4) = v40 + 6;
          uint64_t v179 = *(int *)(v5 + v41 + 44);
          *((_DWORD *)a3 + 3) = v41 + 48;
          *((_DWORD *)a3 + 4) = v40 + 7;
          int v180 = *(_DWORD *)(v5 + v41 + 48);
          *((_DWORD *)a3 + 3) = v41 + 52;
          *((_DWORD *)a3 + 4) = v40 + 8;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v181 = *(void *)(v174 + 48);
            if (v179 > 5) {
              uint64_t v182 = "bus";
            }
            else {
              uint64_t v182 = off_2645F7460[v179];
            }
            uint64_t v212 = *(void *)(v175 + 48);
            *(_DWORD *)buf = 136317954;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1401;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v181;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v174;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v176;
            *(_WORD *)&v232[28] = 2080;
            *(void *)&v232[30] = v182;
            *(_WORD *)&v232[38] = 1024;
            *(_DWORD *)&v232[40] = v180;
            *(_WORD *)&v232[44] = 1024;
            *(_DWORD *)&v232[46] = v178;
            *(_WORD *)&v232[50] = 2080;
            *(void *)&v232[52] = v212;
            *(_WORD *)&v232[60] = 2048;
            *(void *)&v232[62] = v175;
            *(_WORD *)int v233 = 2048;
            *(void *)&v233[2] = v177;
            __int16 v234 = 2048;
            *(void *)int v235 = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unable to add connection to child map. No more space in map. %s(%p):%llu] -%s:%i> %i[%s(%p):%llu @ Frame %llu", buf, 0x6Eu);
          }
          goto LABEL_42;
        case 7:
          uint64_t v122 = *(void *)(v5 + v43);
          uint64_t v124 = *(void *)(v41 + v5 + 16);
          uint64_t v123 = *(void *)(v41 + v5 + 24);
          uint64_t v125 = *(void *)(v41 + v5 + 32);
          *((_DWORD *)a3 + 3) = v41 + 40;
          *((_DWORD *)a3 + 4) = v40 + 5;
          int v126 = *(_DWORD *)(v5 + v41 + 40);
          *((_DWORD *)a3 + 3) = v41 + 44;
          *((_DWORD *)a3 + 4) = v40 + 6;
          uint64_t v127 = *(int *)(v5 + v41 + 44);
          *((_DWORD *)a3 + 3) = v41 + 48;
          *((_DWORD *)a3 + 4) = v40 + 7;
          int v128 = *(_DWORD *)(v5 + v41 + 48);
          *((_DWORD *)a3 + 3) = v41 + 52;
          *((_DWORD *)a3 + 4) = v40 + 8;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v129 = *(void *)(v122 + 48);
            if (v127 > 5) {
              uint64_t v130 = "bus";
            }
            else {
              uint64_t v130 = off_2645F7460[v127];
            }
            uint64_t v208 = *(void *)(v123 + 48);
            *(_DWORD *)buf = 136317954;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1417;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v129;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v122;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v124;
            *(_WORD *)&v232[28] = 2080;
            *(void *)&v232[30] = v130;
            *(_WORD *)&v232[38] = 1024;
            *(_DWORD *)&v232[40] = v128;
            *(_WORD *)&v232[44] = 1024;
            *(_DWORD *)&v232[46] = v126;
            *(_WORD *)&v232[50] = 2080;
            *(void *)&v232[52] = v208;
            *(_WORD *)&v232[60] = 2048;
            *(void *)&v232[62] = v123;
            *(_WORD *)int v233 = 2048;
            *(void *)&v233[2] = v125;
            __int16 v234 = 2048;
            *(void *)int v235 = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unable to add connection to parent map. No more space in map. %s(%p):%llu] -%s:%i> %i[%s(%p):%llu @ Frame %llu", buf, 0x6Eu);
          }
          goto LABEL_42;
        case 8:
          uint64_t v183 = *(void *)(v5 + v43);
          uint64_t v185 = *(void *)(v41 + v5 + 16);
          uint64_t v184 = *(void *)(v41 + v5 + 24);
          uint64_t v186 = *(void *)(v41 + v5 + 32);
          *((_DWORD *)a3 + 3) = v41 + 40;
          *((_DWORD *)a3 + 4) = v40 + 5;
          int v187 = *(_DWORD *)(v5 + v41 + 40);
          *((_DWORD *)a3 + 3) = v41 + 44;
          *((_DWORD *)a3 + 4) = v40 + 6;
          uint64_t v188 = *(int *)(v5 + v41 + 44);
          *((_DWORD *)a3 + 3) = v41 + 48;
          *((_DWORD *)a3 + 4) = v40 + 7;
          int v189 = *(_DWORD *)(v5 + v41 + 48);
          *((_DWORD *)a3 + 3) = v41 + 52;
          *((_DWORD *)a3 + 4) = v40 + 8;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v190 = *(void *)(v183 + 48);
            if (v188 > 5) {
              uint64_t v191 = "bus";
            }
            else {
              uint64_t v191 = off_2645F7460[v188];
            }
            uint64_t v213 = *(void *)(v184 + 48);
            *(_DWORD *)buf = 136317954;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1434;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v190;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v183;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v185;
            *(_WORD *)&v232[28] = 2080;
            *(void *)&v232[30] = v191;
            *(_WORD *)&v232[38] = 1024;
            *(_DWORD *)&v232[40] = v189;
            *(_WORD *)&v232[44] = 1024;
            *(_DWORD *)&v232[46] = v187;
            *(_WORD *)&v232[50] = 2080;
            *(void *)&v232[52] = v213;
            *(_WORD *)&v232[60] = 2048;
            *(void *)&v232[62] = v184;
            *(_WORD *)int v233 = 2048;
            *(void *)&v233[2] = v186;
            __int16 v234 = 2048;
            *(void *)int v235 = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unable to remove connection from child map. Connection does not exist. %s(%p):%llu] -%s:%i> %i[%s(%p):%llu @ Frame %llu", buf, 0x6Eu);
          }
          goto LABEL_42;
        case 9:
          uint64_t v131 = *(void *)(v5 + v43);
          uint64_t v133 = *(void *)(v41 + v5 + 16);
          uint64_t v132 = *(void *)(v41 + v5 + 24);
          uint64_t v134 = *(void *)(v41 + v5 + 32);
          *((_DWORD *)a3 + 3) = v41 + 40;
          *((_DWORD *)a3 + 4) = v40 + 5;
          int v135 = *(_DWORD *)(v5 + v41 + 40);
          uint64_t v136 = *(void *)(v41 + v5 + 44);
          *((_DWORD *)a3 + 3) = v41 + 52;
          *((_DWORD *)a3 + 4) = v40 + 7;
          int v137 = *(_DWORD *)(v5 + v41 + 52);
          *((_DWORD *)a3 + 3) = v41 + 56;
          *((_DWORD *)a3 + 4) = v40 + 8;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v138 = *(void *)(v131 + 48);
            if (v136 > 5) {
              unint64_t v139 = "bus";
            }
            else {
              unint64_t v139 = off_2645F7460[(int)v136];
            }
            uint64_t v209 = *(void *)(v132 + 48);
            *(_DWORD *)buf = 136317954;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1451;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v138;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v131;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v133;
            *(_WORD *)&v232[28] = 2080;
            *(void *)&v232[30] = v139;
            *(_WORD *)&v232[38] = 1024;
            *(_DWORD *)&v232[40] = v137;
            *(_WORD *)&v232[44] = 1024;
            *(_DWORD *)&v232[46] = v135;
            *(_WORD *)&v232[50] = 2080;
            *(void *)&v232[52] = v209;
            *(_WORD *)&v232[60] = 2048;
            *(void *)&v232[62] = v132;
            *(_WORD *)int v233 = 2048;
            *(void *)&v233[2] = v134;
            __int16 v234 = 2048;
            *(void *)int v235 = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unable to remove connection from parent map. Connection does not exist. %s(%p):%llu] -%s:%i> %i[%s(%p):%llu @ Frame %llu", buf, 0x6Eu);
          }
          goto LABEL_42;
        case 10:
          uint64_t v192 = *(void *)(v5 + v43);
          uint64_t v194 = *(void *)(v41 + v5 + 16);
          uint64_t v193 = *(void *)(v41 + v5 + 24);
          uint64_t v195 = *(void *)(v41 + v5 + 32);
          *((_DWORD *)a3 + 3) = v41 + 40;
          *((_DWORD *)a3 + 4) = v40 + 5;
          int v196 = *(_DWORD *)(v5 + v41 + 40);
          uint64_t v197 = *(void *)(v41 + v5 + 44);
          *((_DWORD *)a3 + 3) = v41 + 52;
          *((_DWORD *)a3 + 4) = v40 + 7;
          int v198 = *(_DWORD *)(v5 + v41 + 52);
          uint64_t v199 = *(void *)(v41 + v5 + 56);
          *((_DWORD *)a3 + 3) = v41 + 64;
          *((_DWORD *)a3 + 4) = v40 + 9;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v200 = Phase::DspLayer::VoicePoolErr_ToString(v199);
            uint64_t v201 = *(void *)(v192 + 48);
            if (v197 > 5) {
              uint64_t v202 = "bus";
            }
            else {
              uint64_t v202 = off_2645F7460[(int)v197];
            }
            uint64_t v214 = *(void *)(v193 + 48);
            *(_DWORD *)buf = 136318210;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1470;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v200;
            *(_WORD *)&v232[8] = 2080;
            *(void *)&v232[10] = v201;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v192;
            *(_WORD *)&v232[28] = 2048;
            *(void *)&v232[30] = v194;
            *(_WORD *)&v232[38] = 2080;
            *(void *)&v232[40] = v202;
            *(_WORD *)&v232[48] = 1024;
            *(_DWORD *)&v232[50] = v198;
            *(_WORD *)&v232[54] = 1024;
            *(_DWORD *)&v232[56] = v196;
            *(_WORD *)&v232[60] = 2080;
            *(void *)&v232[62] = v214;
            *(_WORD *)int v233 = 2048;
            *(void *)&v233[2] = v193;
            __int16 v234 = 2048;
            *(void *)int v235 = v195;
            *(_WORD *)&v235[8] = 2048;
            uint64_t v236 = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Failed to remove input from child Voice with VoicePoolErr \"%s\". There is no record of this connection. %s(%p):%llu] -%s:%i> %i[%s(%p):%llu @ Frame %llu", buf, 0x78u);
          }
          goto LABEL_42;
        case 11:
          *((_DWORD *)a3 + 3) = v41 + 32;
          *((_DWORD *)a3 + 4) = v40 + 4;
          break;
        case 12:
          uint64_t v140 = *(void *)(v5 + v43);
          uint64_t v142 = *(void *)(v41 + v5 + 16);
          uint64_t v141 = *(void *)(v41 + v5 + 24);
          uint64_t v228 = *(void *)(v41 + v5 + 32);
          *((_DWORD *)a3 + 3) = v41 + 40;
          *((_DWORD *)a3 + 4) = v40 + 5;
          int v143 = *(_DWORD *)(v5 + v41 + 40);
          uint64_t v144 = *(void *)(v41 + v5 + 44);
          *((_DWORD *)a3 + 3) = v41 + 52;
          *((_DWORD *)a3 + 4) = v40 + 7;
          int v145 = *(_DWORD *)(v5 + v41 + 52);
          float v146 = *(float *)(v41 + v5 + 56);
          uint64_t v147 = *(void *)(v41 + v5 + 60);
          *((_DWORD *)a3 + 3) = v41 + 68;
          *((_DWORD *)a3 + 4) = v40 + 10;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            int v148 = Phase::DspLayer::VoicePoolErr_ToString(v147);
            uint64_t v149 = *(void *)(v140 + 48);
            if (v144 > 5) {
              unint64_t v150 = "bus";
            }
            else {
              unint64_t v150 = off_2645F7460[(int)v144];
            }
            uint64_t v210 = *(void *)(v141 + 48);
            *(_DWORD *)buf = 136318466;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1490;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v148;
            *(_WORD *)&v232[8] = 2080;
            *(void *)&v232[10] = v149;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v140;
            *(_WORD *)&v232[28] = 2048;
            *(void *)&v232[30] = v142;
            *(_WORD *)&v232[38] = 2080;
            *(void *)&v232[40] = v150;
            *(_WORD *)&v232[48] = 1024;
            *(_DWORD *)&v232[50] = v145;
            *(_WORD *)&v232[54] = 2048;
            *(double *)&v232[56] = v146;
            *(_WORD *)&v232[64] = 1024;
            *(_DWORD *)&v232[66] = v143;
            *(_WORD *)int v233 = 2080;
            *(void *)&v233[2] = v210;
            __int16 v234 = 2048;
            *(void *)int v235 = v141;
            *(_WORD *)&v235[8] = 2048;
            uint64_t v236 = v228;
            *(_WORD *)uint64_t v237 = 2048;
            *(void *)&v237[2] = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Failed to set Voice input connection gain with VoicePoolErr \"%s\". There is no record of this connection. %s(%p):%llu] -%s:%i(%f)> %i[%s(%p):%llu @ Frame %llu", buf, 0x82u);
          }
          goto LABEL_42;
        case 13:
          uint64_t v203 = *(void *)(v5 + v43);
          uint64_t v204 = v41 + v5;
          uint64_t v206 = *(void *)(v204 + 16);
          uint64_t v205 = *(void *)(v204 + 24);
          *((_DWORD *)a3 + 3) = v41 + 32;
          *((_DWORD *)a3 + 4) = v40 + 4;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v207 = *(void *)(v203 + 48);
            *(_DWORD *)buf = 136316674;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1517;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v207;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v203;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v206;
            *(_WORD *)&v232[28] = 2048;
            *(void *)&v232[30] = v205;
            *(_WORD *)&v232[38] = 2048;
            *(void *)&v232[40] = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Tapper %s(%p):%llu configured with multiple callbacks %p @ Frame %llu", buf, 0x44u);
          }
          goto LABEL_42;
        case 14:
          uint64_t v151 = *(void *)(v5 + v43);
          uint64_t v152 = v41 + v5;
          uint64_t v154 = *(void *)(v152 + 16);
          uint64_t v153 = *(void *)(v152 + 24);
          *((_DWORD *)a3 + 3) = v41 + 32;
          *((_DWORD *)a3 + 4) = v40 + 4;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v155 = *(void *)(v151 + 48);
            *(_DWORD *)buf = 136316674;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1527;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v155;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v151;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v154;
            *(_WORD *)&v232[28] = 2048;
            *(void *)&v232[30] = v153;
            *(_WORD *)&v232[38] = 2048;
            *(void *)&v232[40] = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Sampler %s(%p):%llu configured with multiple callbacks %p @ Frame %llu", buf, 0x44u);
          }
          goto LABEL_42;
        case 15:
          uint64_t v156 = *(void *)(v5 + v43);
          uint64_t v157 = *(void *)(v41 + v5 + 16);
          *((_DWORD *)a3 + 3) = v41 + 24;
          *((_DWORD *)a3 + 4) = v40 + 3;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v158 = *(void *)(v156 + 48);
            *(_DWORD *)buf = 136316418;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1536;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v158;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v156;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v157;
            *(_WORD *)&v232[28] = 2048;
            *(void *)&v232[30] = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Sampler map out of memory when configuring %s(%p):%llu @ Frame %llu", buf, 0x3Au);
          }
          goto LABEL_42;
        case 16:
          uint64_t v159 = *(void *)(v5 + v43);
          uint64_t v160 = *(void *)(v41 + v5 + 16);
          *((_DWORD *)a3 + 3) = v41 + 24;
          *((_DWORD *)a3 + 4) = v40 + 3;
          uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                              + 80)));
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v161 = *(void *)(v159 + 48);
            *(_DWORD *)buf = 136316418;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1545;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v161;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = v159;
            *(_WORD *)&v232[18] = 2048;
            *(void *)&v232[20] = v160;
            *(_WORD *)&v232[28] = 2048;
            *(void *)&v232[30] = a2;
            _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Tapper map out of memory when configuring %s(%p):%llu @ Frame %llu", buf, 0x3Au);
          }
          goto LABEL_42;
        default:
          uint64_t v109 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                               + 80)));
          if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
          {
            Phase::PhaseOSCMessage::ToString(a3, __p);
            int v162 = v230 >= 0 ? __p : (void **)__p[0];
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1550;
            *(_WORD *)&unsigned char buf[18] = 2080;
            *(void *)v232 = v162;
            *(_WORD *)&v232[8] = 2048;
            *(void *)&v232[10] = a2;
            _os_log_impl(&dword_221E5E000, v109, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: %s @ Frame %llu", buf, 0x26u);
            if (v230 < 0) {
              operator delete(__p[0]);
            }
          }
          goto LABEL_33;
      }
      break;
    case 0xA:
      int v103 = *((_DWORD *)a3 + 4);
      uint64_t v104 = *((int *)a3 + 3);
      uint64_t v106 = *(Phase::DspLayer::VoicePool **)(v5 + v104);
      unint64_t v105 = *(void *)(v5 + v104 + 8);
      *((_DWORD *)a3 + 3) = v104 + 16;
      *((_DWORD *)a3 + 4) = v103 + 2;
      int v107 = *(_DWORD *)(v5 + v104 + 16);
      *((_DWORD *)a3 + 3) = v104 + 20;
      *((_DWORD *)a3 + 4) = v103 + 3;
      VoiceNode = Phase::Controller::DVM::VoiceGraph::GetVoiceNode(*((Phase::Controller::DVM::VoiceGraph **)this + 9), v106, v105);
      if (VoiceNode)
      {
        *((_DWORD *)VoiceNode + 4std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v107;
      }
      else
      {
        uint64_t v15 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(0)
                                                                                            + 80)));
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          uint64_t v111 = *((void *)v106 + 6);
          *(_DWORD *)buf = 136316418;
          *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 1268;
          *(_WORD *)&unsigned char buf[18] = 2080;
          *(void *)v232 = v111;
          *(_WORD *)&v232[8] = 2048;
          *(void *)&v232[10] = v106;
          *(_WORD *)&v232[18] = 2048;
          *(void *)&v232[20] = v105;
          *(_WORD *)&v232[28] = 2048;
          *(void *)&v232[30] = a2;
          _os_log_impl(&dword_221E5E000, v15, OS_LOG_TYPE_ERROR, "%25s:%-5d Setting tail length failed! No VoiceNode found for Voice %s(%p):%llu @ Frame %llu", buf, 0x3Au);
        }
LABEL_42:
      }
      break;
    case 0xB:
      int v48 = **(id **)(Phase::Logger::GetInstance(this) + 80);
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v49 = *(void *)a3;
        int v50 = *((_DWORD *)a3 + 4);
        uint64_t v51 = *((int *)a3 + 3);
        int v52 = *(_DWORD *)(*(void *)a3 + v51);
        *((_DWORD *)a3 + 3) = v51 + 4;
        *((_DWORD *)a3 + 4) = v50 + 1;
        int v226 = *(_DWORD *)(v49 + v51 + 4);
        int v227 = v52;
        *((_DWORD *)a3 + 3) = v51 + 8;
        *((_DWORD *)a3 + 4) = v50 + 2;
        int v53 = *(_DWORD *)(v49 + v51 + 8);
        *((_DWORD *)a3 + 3) = v51 + 12;
        *((_DWORD *)a3 + 4) = v50 + 3;
        int v224 = *(_DWORD *)(v49 + v51 + 12);
        int v225 = v53;
        *((_DWORD *)a3 + 3) = v51 + 16;
        *((_DWORD *)a3 + 4) = v50 + 4;
        int v54 = *(_DWORD *)(v49 + v51 + 16);
        *((_DWORD *)a3 + 3) = v51 + 20;
        *((_DWORD *)a3 + 4) = v50 + 5;
        int v222 = *(_DWORD *)(v49 + v51 + 20);
        int v223 = v54;
        *((_DWORD *)a3 + 3) = v51 + 24;
        *((_DWORD *)a3 + 4) = v50 + 6;
        int v55 = *(_DWORD *)(v49 + v51 + 24);
        *((_DWORD *)a3 + 3) = v51 + 28;
        *((_DWORD *)a3 + 4) = v50 + 7;
        int v220 = *(_DWORD *)(v49 + v51 + 28);
        int v221 = v55;
        *((_DWORD *)a3 + 3) = v51 + 32;
        *((_DWORD *)a3 + 4) = v50 + 8;
        int v56 = *(_DWORD *)(v49 + v51 + 32);
        *((_DWORD *)a3 + 3) = v51 + 36;
        *((_DWORD *)a3 + 4) = v50 + 9;
        int v218 = *(_DWORD *)(v49 + v51 + 36);
        int v219 = v56;
        *((_DWORD *)a3 + 3) = v51 + 40;
        *((_DWORD *)a3 + 4) = v50 + 10;
        int v57 = *(_DWORD *)(v49 + v51 + 40);
        *((_DWORD *)a3 + 3) = v51 + 44;
        *((_DWORD *)a3 + 4) = v50 + 11;
        int v216 = *(_DWORD *)(v49 + v51 + 44);
        int v217 = v57;
        *((_DWORD *)a3 + 3) = v51 + 48;
        *((_DWORD *)a3 + 4) = v50 + 12;
        int v215 = *(_DWORD *)(v49 + v51 + 48);
        *((_DWORD *)a3 + 3) = v51 + 52;
        *((_DWORD *)a3 + 4) = v50 + 13;
        int v58 = *(_DWORD *)(v49 + v51 + 52);
        *((_DWORD *)a3 + 3) = v51 + 56;
        *((_DWORD *)a3 + 4) = v50 + 14;
        int v59 = *(_DWORD *)(v49 + v51 + 56);
        *((_DWORD *)a3 + 3) = v51 + 60;
        *((_DWORD *)a3 + 4) = v50 + 15;
        int v60 = *(_DWORD *)(v49 + v51 + 60);
        *((_DWORD *)a3 + 3) = v51 + 64;
        *((_DWORD *)a3 + 4) = v50 + 16;
        int v61 = *(_DWORD *)(v49 + v51 + 64);
        *((_DWORD *)a3 + 3) = v51 + 68;
        *((_DWORD *)a3 + 4) = v50 + 17;
        int v62 = *(_DWORD *)(v49 + v51 + 68);
        *((_DWORD *)a3 + 3) = v51 + 72;
        *((_DWORD *)a3 + 4) = v50 + 18;
        int v63 = *(_DWORD *)(v49 + v51 + 72);
        *((_DWORD *)a3 + 3) = v51 + 76;
        *((_DWORD *)a3 + 4) = v50 + 19;
        int v64 = *(_DWORD *)(v49 + v51 + 76);
        *((_DWORD *)a3 + 3) = v51 + 80;
        *((_DWORD *)a3 + 4) = v50 + 20;
        int v65 = *(_DWORD *)(v49 + v51 + 80);
        *((_DWORD *)a3 + 3) = v51 + 84;
        *((_DWORD *)a3 + 4) = v50 + 21;
        int v66 = *(_DWORD *)(v49 + v51 + 84);
        *((_DWORD *)a3 + 3) = v51 + 88;
        *((_DWORD *)a3 + 4) = v50 + 22;
        int v67 = *(_DWORD *)(v49 + v51 + 88);
        *((_DWORD *)a3 + 3) = v51 + 92;
        *((_DWORD *)a3 + 4) = v50 + 23;
        int v68 = *(_DWORD *)(v49 + v51 + 92);
        *((_DWORD *)a3 + 3) = v51 + 96;
        *((_DWORD *)a3 + 4) = v50 + 24;
        int v69 = *(_DWORD *)(v49 + v51 + 96);
        *((_DWORD *)a3 + 3) = v51 + 100;
        *((_DWORD *)a3 + 4) = v50 + 25;
        int v70 = *(_DWORD *)(v49 + v51 + 100);
        *((_DWORD *)a3 + 3) = v51 + 104;
        *((_DWORD *)a3 + 4) = v50 + 26;
        int v71 = *(_DWORD *)(v49 + v51 + 104);
        *((_DWORD *)a3 + 3) = v51 + 108;
        *((_DWORD *)a3 + 4) = v50 + 27;
        int v72 = *(_DWORD *)(v49 + v51 + 108);
        *((_DWORD *)a3 + 3) = v51 + 112;
        *((_DWORD *)a3 + 4) = v50 + 28;
        int v73 = *(_DWORD *)(v49 + v51 + 112);
        *((_DWORD *)a3 + 3) = v51 + 116;
        *((_DWORD *)a3 + 4) = v50 + 29;
        int v74 = *(_DWORD *)(v49 + v51 + 116);
        *((_DWORD *)a3 + 4) = v50 + 30;
        *((_DWORD *)a3 + 3) = v51 + 120;
        int v75 = *(_DWORD *)(v49 + v51 + 120);
        *((_DWORD *)a3 + 4) = v50 + 31;
        *((_DWORD *)a3 + 3) = v51 + 124;
        int v76 = *(_DWORD *)(v49 + v51 + 124);
        *((_DWORD *)a3 + 3) = v51 + 128;
        *((_DWORD *)a3 + 4) = v50 + 32;
        int v77 = *(_DWORD *)(v49 + v51 + 128);
        *((_DWORD *)a3 + 3) = v51 + 132;
        *((_DWORD *)a3 + 4) = v50 + 33;
        int v78 = *(_DWORD *)(v49 + v51 + 132);
        *((_DWORD *)a3 + 4) = v50 + 34;
        *((_DWORD *)a3 + 3) = v51 + 136;
        LODWORD(v49) = *(_DWORD *)(v49 + v51 + 136);
        *((_DWORD *)a3 + 3) = v51 + 140;
        *((_DWORD *)a3 + 4) = v50 + 35;
        *(_DWORD *)((char *)&v236 + 2) = v59;
        *(_DWORD *)&v237[6] = v61;
        int v241 = v63;
        int v245 = v65;
        int v249 = v67;
        int v253 = v69;
        int v257 = v71;
        int v261 = v73;
        int v265 = v75;
        int v269 = v77;
        int v273 = v49;
        *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
        *(_DWORD *)&buf[14] = 1313;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)v232 = a2;
        *(_DWORD *)&v232[10] = v227;
        *(_DWORD *)&v232[16] = v226;
        *(_DWORD *)&v232[22] = v225;
        *(_DWORD *)&v232[28] = v224;
        *(_DWORD *)&v232[34] = v223;
        *(_DWORD *)&v232[40] = v222;
        *(_DWORD *)&v232[46] = v221;
        *(_DWORD *)&v232[52] = v220;
        *(_DWORD *)&v232[58] = v219;
        *(_DWORD *)&v232[64] = v218;
        *(_DWORD *)int v233 = v217;
        *(_DWORD *)&v233[6] = v216;
        *(_DWORD *)int v235 = v215;
        *(_DWORD *)&v235[6] = v58;
        *(_DWORD *)uint64_t v237 = v60;
        int v239 = v62;
        int v243 = v64;
        int v247 = v66;
        int v251 = v68;
        int v255 = v70;
        int v259 = v72;
        int v263 = v74;
        int v267 = v76;
        int v271 = v78;
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_WORD *)&v232[8] = 1024;
        *(_WORD *)&v232[14] = 1024;
        *(_WORD *)&v232[20] = 1024;
        *(_WORD *)&v232[26] = 1024;
        *(_WORD *)&v232[32] = 1024;
        *(_WORD *)&v232[38] = 1024;
        *(_WORD *)&v232[44] = 1024;
        *(_WORD *)&v232[50] = 1024;
        *(_WORD *)&v232[56] = 1024;
        *(_WORD *)&v232[62] = 1024;
        *(_WORD *)&v232[68] = 1024;
        *(_WORD *)&v233[4] = 1024;
        __int16 v234 = 1024;
        *(_WORD *)&v235[4] = 1024;
        LOWORD(v23std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1024;
        HIWORD(v23std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1024;
        *(_WORD *)&v237[4] = 1024;
        __int16 v238 = 1024;
        __int16 v240 = 1024;
        __int16 v242 = 1024;
        __int16 v244 = 1024;
        __int16 v246 = 1024;
        __int16 v248 = 1024;
        __int16 v250 = 1024;
        __int16 v252 = 1024;
        __int16 v254 = 1024;
        __int16 v256 = 1024;
        __int16 v258 = 1024;
        __int16 v260 = 1024;
        __int16 v262 = 1024;
        __int16 v264 = 1024;
        __int16 v266 = 1024;
        __int16 v268 = 1024;
        __int16 v270 = 1024;
        __int16 v272 = 1024;
        *(_DWORD *)buf = 136324610;
        _os_log_impl(&dword_221E5E000, v48, OS_LOG_TYPE_DEFAULT, "%25s:%-5d \n=== DVM-RT Statistics @ Frame %llu ===\n* NRT->RT: %i Mes./s (%i B/s)\n* NRT->RT: max. %i Mes. (%i B/s)\n* Scheduled Messages: %i Mes. (%i B/s)\n* RT->NRT: %i B/s\n* Num. Child Connections: %i/%i\n* Num. Parent Connections: %i/%i\n* Num. Sampler (a/p/t): %i/%i/%i\n* Num. SubmixGain (a/p/t): %i/%i/%i\n* Num. LinFade (a/p/t): %i/%i/%i\n* Num. Tapper: (a/t): %i/%i\n* Num. Convolver (a/p/t): %i/%i/%i\n* Num. Matrix Mixer (a/p/t): %i/%i/%i\n* Num. NullMixer (a/p/t): %i/%i/%i\n* Num. VoicePools: %i\n"
          "* Num. Currently Scheduled Messages: %i\n"
          "* Voice Count (a/p): %i/%i",
          buf,
          0xEEu);
      }
      break;
    default:
      uint64_t v109 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(this)
                                                                                           + 80)));
      if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
      {
        Phase::PhaseOSCMessage::ToString(a3, __p);
        unint64_t v110 = v230 >= 0 ? __p : (void **)__p[0];
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "DVMImplementation.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 1560;
        *(_WORD *)&unsigned char buf[18] = 2080;
        *(void *)v232 = v110;
        *(_WORD *)&v232[8] = 2048;
        *(void *)&v232[10] = a2;
        _os_log_impl(&dword_221E5E000, v109, OS_LOG_TYPE_ERROR, "%25s:%-5d DVM-RT Error: Unknown DVM-NRT command: %s @ Frame %llu", buf, 0x26u);
        if (v230 < 0) {
          operator delete(__p[0]);
        }
      }
LABEL_33:

      break;
  }
}

void sub_221F2E5B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMRTOSCCommand,int>(uint64_t *a1, unsigned int a2)
{
  uint64_t v2 = *((int *)a1 + 3);
  if (*((_DWORD *)a1 + 2) - (int)v2 < 20) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = *a1 + v2;
  *(void *)(v4 + 4) = a2;
  *(_WORD *)(v4 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 105;
  *(_DWORD *)(v4 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  uint64_t v5 = *a1;
  uint64_t v3 = 16;
  *(_DWORD *)(v5 + *((int *)a1 + 3)) = 16;
  *(_DWORD *)(v5 + 16) += 20;
  *((_DWORD *)a1 + 3) += 20;
  return v3;
}

uint64_t Phase::PhaseOSCBundle::WriteNextMessage<Phase::Controller::DVM_RT::DVMRTOSCCommand,int,Phase::DspLayer::VoicePool const*,long long>(uint64_t *a1, unsigned int a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = *((int *)a1 + 3);
  if (*((_DWORD *)a1 + 2) - (int)v5 < 36) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *a1 + v5;
  *(void *)(v7 + 4) = a2;
  *(_DWORD *)(v7 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3;
  *(void *)(v7 + 20) = a4;
  *(_DWORD *)(v7 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 6844521;
  *(void *)(v7 + 28) = a5;
  uint64_t v8 = *a1;
  uint64_t v6 = 32;
  *(_DWORD *)(v8 + *((int *)a1 + 3)) = 32;
  *(_DWORD *)(v8 + 16) += 36;
  *((_DWORD *)a1 + 3) += 36;
  return v6;
}

const char *Phase::DspLayer::VoicePoolErr_ToString(unsigned int a1)
{
  if (a1 > 0xC) {
    return "Unknown VoicePoolErr";
  }
  else {
    return off_2645F7490[a1];
  }
}

const char *Phase::PhaseOSCMessage::GetNextString(Phase::PhaseOSCMessage *this)
{
  uint64_t v2 = *((int *)this + 3);
  uint64_t v3 = (const char *)(*(void *)this + v2);
  int v4 = strlen(v3);
  int v5 = *((_DWORD *)this + 4) + 1;
  *((_DWORD *)this + 3) = v2 + (v4 & 0xFFFFFFFC) + 4;
  *((_DWORD *)this + 4) = v5;
  return v3;
}

uint64_t *std::unique_ptr<Phase::Controller::DVM_RT>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  *BOOL result = a2;
  if (v2)
  {
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v2 + 2440432);
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v2 + 2440392);
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void Phase::Controller::DVM::VoiceGraph::~VoiceGraph(Phase::Controller::DVM::VoiceGraph *this)
{
  std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>>>::destroy(*((void **)this + 98));
  std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>>>::destroy(*((void **)this + 95));
  uint64_t v2 = (void *)*((void *)this + 91);
  if (v2)
  {
    *((void *)this + 92) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 88);
  if (v3)
  {
    *((void *)this + 89) = v3;
    operator delete(v3);
  }
  std::__list_imp<Phase::Controller::DVM::DspNodePlayStateCommand>::clear((uint64_t *)this + 85);
  std::__list_imp<Phase::Controller::DVM::DspNodePlayStateCommand>::clear((uint64_t *)this + 82);
  free(*((void **)this + 78));
  free(*((void **)this + 79));
  free(*((void **)this + 74));
  free(*((void **)this + 75));
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>>>::~__hash_table((uint64_t)this + 552);
  std::__tree<Phase::SpatialCategory>::destroy((uint64_t)this + 528, *((void **)this + 67));
  std::__tree<Phase::SpatialCategory>::destroy((uint64_t)this + 504, *((void **)this + 64));
  std::__list_imp<std::unique_ptr<Phase::Controller::DVM::VoicePoolNode>>::clear((uint64_t *)this + 60);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Sink>>>::~__hash_table((uint64_t)this + 440);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Master>>>::~__hash_table((uint64_t)this + 400);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Renderer>>>::~__hash_table((uint64_t)this + 360);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Controller::DVM::Tap>>>::~__hash_table((uint64_t)this + 320);
  caulk::concurrent::guarded_lookup_hash_table<unsigned long long,Phase::Controller::DVM::Tap *,(caulk::concurrent::guarded_lookup_hash_table_options)0,std::function<unsigned int ()(unsigned long long)>>::~guarded_lookup_hash_table((uint64_t)this + 176);
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,Phase::Controller::DVM::Submix>>>::~__hash_table((uint64_t)this + 136);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 96);
}

void std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>>>::destroy(*a1);
    std::__tree<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::__map_value_compare<std::pair<Phase::DspLayer::VoicePool *,long long>,std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>,std::less<std::pair<Phase::DspLayer::VoicePool *,long long>>,true>,std::allocator<std::__value_type<std::pair<Phase::DspLayer::VoicePool *,long long>,Phase::Controller::DVM::VoiceNode *>>>::destroy(a1[1]);
    operator delete(a1);
  }
}

void Phase::Controller::DVM::Submix::Reset(Phase::Controller::DVM::Submix *this)
{
  *((_DWORD *)this + 9) = 0;
  if (*((unsigned char *)this + 44)) {
    *((unsigned char *)this + 44) = 0;
  }
  if (*((void *)this + 15))
  {
    uint64_t v2 = (void *)((char *)this + 96);
    std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::__deallocate_node(this + 96, *((void **)this + 14));
    *((void *)this + 14) = 0;
    uint64_t v3 = *((void *)this + 13);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*v2 + 8 * i) = 0;
    }
    *((void *)this + 15) = 0;
  }
  uint64_t v6 = *((void *)this + 9);
  for (uint64_t j = *((void *)this + 10);
        j != v6;
        std::allocator<Phase::Controller::DVM::Submix::ChannelStrip>::destroy[abi:ne180100]((uint64_t)this + 88, j))
  {
    j -= 72;
  }
  *((void *)this + 10) = v6;
}

void Phase::Controller::DVM::Submix::AddGenerator(uint64_t a1, int a2)
{
  if (a2 != 1)
  {
    if (!a2) {
      operator new();
    }
    std::terminate();
  }
  operator new();
}

void sub_221F2EEE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,void *>>>::operator()[abi:ne180100](v13, v12);
  _Unwind_Resume(a1);
}

void Phase::Controller::DVM::Submix::GetGeneratorIds(Phase::Controller::DVM::Submix *this@<X0>, char **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    int v4 = 0;
    int v5 = a2 + 2;
    do
    {
      uint64_t v6 = v2 + 2;
      if ((unint64_t)v4 >= *v5)
      {
        uint64_t v7 = (v4 - *a2) >> 4;
        if ((unint64_t)(v7 + 1) >> 60) {
          std::vector<Phase::MetaParamValue>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v8 = *v5 - (void)*a2;
        uint64_t v9 = v8 >> 3;
        if (v8 >> 3 <= (unint64_t)(v7 + 1)) {
          uint64_t v9 = v7 + 1;
        }
        if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v10 = v9;
        }
        if (v10) {
          int v11 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>((uint64_t)v5, v10);
        }
        else {
          int v11 = 0;
        }
        unsigned int v12 = &v11[16 * v7];
        *(_OWORD *)unsigned int v12 = *v6;
        uint64_t v14 = *a2;
        uint64_t v13 = a2[1];
        uint64_t v15 = v12;
        if (v13 != *a2)
        {
          do
          {
            *((_OWORD *)v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((_OWORD *)v13 - 1);
            v15 -= 16;
            v13 -= 16;
          }
          while (v13 != v14);
          uint64_t v13 = *a2;
        }
        int v4 = v12 + 16;
        *a2 = v15;
        a2[1] = v12 + 16;
        a2[2] = &v11[16 * v10];
        if (v13) {
          operator delete(v13);
        }
      }
      else
      {
        *(_OWORD *)int v4 = *v6;
        v4 += 16;
      }
      a2[1] = v4;
      uint64_t v2 = (void *)*v2;
    }
    while (v2);
  }
}

void sub_221F2F05C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Controller::DVM::Submix::GetAllValidDspNodes(Phase::Controller::DVM::Submix *this@<X0>, char **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    int v4 = 0;
    do
    {
      uint64_t v5 = v2[4];
      unint64_t v6 = (unint64_t)a2[2];
      if ((unint64_t)v4 >= v6)
      {
        uint64_t v8 = *a2;
        uint64_t v9 = (v4 - *a2) >> 3;
        unint64_t v10 = v9 + 1;
        if ((unint64_t)(v9 + 1) >> 61) {
          std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v11 = v6 - (void)v8;
        if (v11 >> 2 > v10) {
          unint64_t v10 = v11 >> 2;
        }
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v12 = v10;
        }
        if (v12)
        {
          if (v12 >> 61) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v13 = (char *)operator new(8 * v12);
        }
        else
        {
          uint64_t v13 = 0;
        }
        uint64_t v14 = &v13[8 * v9];
        *(void *)uint64_t v14 = v5;
        uint64_t v7 = v14 + 8;
        if (v4 != v8)
        {
          do
          {
            uint64_t v15 = *((void *)v4 - 1);
            v4 -= 8;
            *((void *)v14 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v15;
            v14 -= 8;
          }
          while (v4 != v8);
          int v4 = *a2;
        }
        *a2 = v14;
        a2[1] = v7;
        a2[2] = &v13[8 * v12];
        if (v4) {
          operator delete(v4);
        }
      }
      else
      {
        *(void *)int v4 = v5;
        uint64_t v7 = v4 + 8;
      }
      a2[1] = v7;
      uint64_t v2 = (void *)*v2;
      int v4 = v7;
    }
    while (v2);
  }
}

void sub_221F2F1A0(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    *(void *)(v1 + 8) = v2;
    operator delete(v2);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Controller::DVM::Submix::GetAllValidVoiceNodes(Phase::Controller::DVM::Submix *this@<X0>, void *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  for (uint64_t i = (void *)*((void *)this + 14); i; uint64_t i = (void *)*i)
  {
    uint64_t v5 = i[4];
    if (!v5) {
      std::terminate();
    }
    (*(void (**)(void **__return_ptr))(*(void *)v5 + 40))(&__p);
    std::vector<Phase::Controller::DVM::VoiceNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Phase::Controller::DVM::VoiceNode **>,std::__wrap_iter<Phase::Controller::DVM::VoiceNode **>>((uint64_t)a2, a2[1], (char *)__p, v9, (v9 - (unsigned char *)__p) >> 3);
    if (__p)
    {
      uint64_t v9 = (char *)__p;
      operator delete(__p);
    }
  }
  uint64_t v7 = (char **)*((void *)this + 9);
  unint64_t v6 = (char **)*((void *)this + 10);
  while (v7 != v6)
  {
    std::vector<Phase::Controller::DVM::VoiceNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Phase::Controller::DVM::VoiceNode * const*>,std::__wrap_iter<Phase::Controller::DVM::VoiceNode * const*>>((uint64_t)a2, a2[1], *v7, v7[1], (v7[1] - *v7) >> 3);
    v7 += 9;
  }
}

void sub_221F2F298(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  uint64_t v13 = *(void **)v11;
  if (*(void *)v11)
  {
    *(void *)(v11 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **Phase::Controller::DVM::Submix::ChannelStrip::GetHeadNodes@<X0>(uint64_t **this@<X0>, void *a2@<X8>)
{
  while (this[6] || this[7])
  {
    uint64_t v3 = this[8];
    if (!v3) {
      __assert_rtn("GetHeadNodes", "DVMSubmixNode.mm", 132, "nullptr != mChildSubmix.second");
    }
    if (v3[7] != 1) {
      __assert_rtn("GetHeadNodes", "DVMSubmixNode.mm", 133, "mChildSubmix.second->mSubmixType == PHASEMixerTypeSpatial");
    }
    this = (uint64_t **)v3[9];
    if (v3[10] - (void)this != 72) {
      __assert_rtn("GetHeadNodes", "DVMSubmixNode.mm", 134, "mChildSubmix.second->mChannelStrips.size() == 1");
    }
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  int v4 = *this;
  if (*this != this[1])
  {
    uint64_t v5 = *v4;
    if (!*v4) {
      __assert_rtn("GetHeadNodes", "DVMSubmixNode.mm", 143, "mEffects.front() != nullptr");
    }
    unint64_t v6 = operator new(8uLL);
    *a2 = v6;
    *unint64_t v6 = v5;
    this = (uint64_t **)(v6 + 1);
    a2[1] = this;
    a2[2] = this;
  }
  return this;
}

void Phase::Controller::DVM::Submix::~Submix(Phase::Controller::DVM::Submix *this)
{
  *(void *)this = &unk_26D476238;
  uint64_t v1 = (void **)((char *)this + 72);
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::~__hash_table((uint64_t)this + 96);
  uint64_t v2 = v1;
  std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__destroy_vector::operator()[abi:ne180100](&v2);
}

{
  void **v2;
  void **v3;

  *(void *)this = &unk_26D476238;
  uint64_t v2 = (void **)((char *)this + 72);
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::~__hash_table((uint64_t)this + 96);
  uint64_t v3 = v2;
  std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__destroy_vector::operator()[abi:ne180100](&v3);
  MEMORY[0x223C938A0](this, 0x10E1C404699A41BLL);
}

void *std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__vallocate[abi:ne180100](a1, a2);
    int v4 = (char *)a1[1];
    size_t v5 = 72 * ((72 * a2 - 72) / 0x48) + 72;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_221F2F540(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

char *std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__throw_length_error[abi:ne180100]();
  }
  BOOL result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::DVM::Submix::ChannelStrip>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[72 * v4];
  return result;
}

void std::vector<Phase::Controller::DVM::Submix::ChannelStrip>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::DVM::Submix::ChannelStrip>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(72 * a2);
}

void Phase::Controller::DVM::Sampler::~Sampler(Phase::Controller::DVM::Sampler *this)
{
  *(void *)this = &unk_26D4762C8;
  uint64_t v1 = (void **)((char *)this + 72);
  std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v1;
  uint64_t vars8;

  *(void *)this = &unk_26D4762C8;
  uint64_t v1 = (void **)((char *)this + 72);
  std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v1);

  JUMPOUT(0x223C938A0);
}

void Phase::Controller::DVM::Generator::Reset(Phase::Controller::DVM::Generator *this)
{
  *((_DWORD *)this + 9) = 0;
  if (*((unsigned char *)this + 44)) {
    *((unsigned char *)this + 44) = 0;
  }
  std::vector<Phase::VoiceDescriptor>::__clear[abi:ne180100]((uint64_t *)this + 9);
}

char *Phase::Controller::DVM::Generator::GetAllValidVoiceNodes@<X0>(char *this@<X0>, void **a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  uint64_t v2 = (uint64_t *)*((void *)this + 9);
  uint64_t v3 = (uint64_t *)*((void *)this + 10);
  if (v2 != v3)
  {
    uint64_t v5 = (uint64_t)(a2 + 2);
    do
    {
      uint64_t v6 = *v2;
      if (!*v2) {
        std::terminate();
      }
      uint64_t v8 = (char *)a2[1];
      unint64_t v7 = (unint64_t)a2[2];
      if ((unint64_t)v8 >= v7)
      {
        uint64_t v10 = (v8 - (unsigned char *)*a2) >> 3;
        if ((unint64_t)(v10 + 1) >> 61) {
          std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v11 = v7 - (void)*a2;
        uint64_t v12 = v11 >> 2;
        if (v11 >> 2 <= (unint64_t)(v10 + 1)) {
          uint64_t v12 = v10 + 1;
        }
        if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v13 = v12;
        }
        if (v13)
        {
          uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v5, v13);
          uint64_t v6 = *v2;
        }
        else
        {
          uint64_t v14 = 0;
        }
        uint64_t v15 = &v14[8 * v10];
        *(void *)uint64_t v15 = v6;
        uint64_t v9 = (uint64_t)(v15 + 8);
        unint64_t v17 = (char *)*a2;
        uint64_t v16 = (char *)a2[1];
        if (v16 != *a2)
        {
          do
          {
            uint64_t v18 = *((void *)v16 - 1);
            v16 -= 8;
            *((void *)v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v18;
            v15 -= 8;
          }
          while (v16 != v17);
          uint64_t v16 = (char *)*a2;
        }
        *a2 = v15;
        a2[1] = (void *)v9;
        a2[2] = &v14[8 * v13];
        if (v16) {
          operator delete(v16);
        }
      }
      else
      {
        *(void *)uint64_t v8 = v6;
        uint64_t v9 = (uint64_t)(v8 + 8);
      }
      a2[1] = (void *)v9;
      this = std::vector<Phase::Controller::DVM::VoiceNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Phase::Controller::DVM::VoiceNode * const*>,std::__wrap_iter<Phase::Controller::DVM::VoiceNode * const*>>((uint64_t)a2, v9, (char *)v2[1], (char *)v2[2], (v2[2] - v2[1]) >> 3);
      v2 += 4;
    }
    while (v2 != v3);
  }
  return this;
}

void sub_221F2F830(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::Controller::DVM::Sampler::Configure(Phase::Controller::DVM::Sampler *this, const Phase::Controller::DspGeneratorNode *a2)
{
  *((void *)this + 8) = *((void *)a2 + 6);
  uint64_t result = (*(uint64_t (**)(const Phase::Controller::DspGeneratorNode *))(*(void *)a2 + 16))(a2);
  if (!result) {
    std::terminate();
  }
  *((unsigned char *)this + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(unsigned char *)(result + 56);
  return result;
}

BOOL Phase::Controller::DVM::Sampler::IsOneShot(Phase::Controller::DVM::Sampler *this)
{
  return !*((unsigned char *)this + 96) && *((void *)this + 8) == 0;
}

void Phase::Controller::DVM::Generator::~Generator(Phase::Controller::DVM::Generator *this)
{
  *(void *)this = &unk_26D4762C8;
  uint64_t v1 = (void **)((char *)this + 72);
  std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v1;
  uint64_t vars8;

  *(void *)this = &unk_26D4762C8;
  uint64_t v1 = (void **)((char *)this + 72);
  std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v1);

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Controller::DVM::Generator::Configure(uint64_t this, const Phase::Controller::DspGeneratorNode *a2)
{
  *(void *)(this + 64) = *((void *)a2 + 6);
  return this;
}

BOOL Phase::Controller::DVM::Generator::IsOneShot(Phase::Controller::DVM::Generator *this)
{
  return *((void *)this + 8) == 0;
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,void *>>>::operator()[abi:ne180100](uint64_t a1, void *__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v3 = __p[4];
    __p[4] = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void Phase::Controller::DVM::Procedure::~Procedure(Phase::Controller::DVM::Procedure *this)
{
  *(void *)this = &unk_26D4762C8;
  uint64_t v1 = (void **)((char *)this + 72);
  std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v1);
}

{
  void **v1;
  uint64_t vars8;

  *(void *)this = &unk_26D4762C8;
  uint64_t v1 = (void **)((char *)this + 72);
  std::vector<Phase::VoiceDescriptor>::__destroy_vector::operator()[abi:ne180100](&v1);

  JUMPOUT(0x223C938A0);
}

uint64_t Phase::Controller::DVM::Procedure::Configure(Phase::Controller::DVM::Procedure *this, const Phase::Controller::DspGeneratorNode *a2)
{
  *((void *)this + 8) = *((void *)a2 + 6);
  uint64_t result = (*(uint64_t (**)(const Phase::Controller::DspGeneratorNode *))(*(void *)a2 + 24))(a2);
  if (!result || (int v4 = *(unsigned __int8 *)(result + 56), *((unsigned char *)this + 96) = v4, !v4)) {
    std::terminate();
  }
  return result;
}

uint64_t Phase::Controller::DVM::Procedure::IsOneShot(Phase::Controller::DVM::Procedure *this)
{
  if (!*((void *)this + 8)) {
    std::terminate();
  }
  return 0;
}

uint64_t *std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::__erase_unique<Phase::UniqueObjectId>(void *a1, void *a2)
{
  uint64_t result = std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::shared_ptr<Phase::ActionTreeObject>>>>::find<Phase::UniqueObjectId>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>>>::erase(void *a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  std::__hash_table<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::__unordered_map_hasher<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::hash<Phase::UniqueObjectId>,std::equal_to<Phase::UniqueObjectId>,true>,std::__unordered_map_equal<Phase::UniqueObjectId,std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>,std::equal_to<Phase::UniqueObjectId>,std::hash<Phase::UniqueObjectId>,true>,std::allocator<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::ClientTapReceiverObject>>>>::remove(a1, a2, (uint64_t)&__p);
  uint64_t v3 = __p;
  std::string __p = 0;
  if (v3) {
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<Phase::UniqueObjectId,std::unique_ptr<Phase::Controller::DVM::Generator>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  }
  return v2;
}

char *std::vector<Phase::Controller::DVM::VoiceNode *>::__insert_with_size[abi:ne180100]<std::__wrap_iter<Phase::Controller::DVM::VoiceNode **>,std::__wrap_iter<Phase::Controller::DVM::VoiceNode **>>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  unint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    unint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 + ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 >> 61) {
      std::vector<Phase::Controller::DVM::VoiceNode *>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v15 = (__dst - (uint64_t)v13) >> 3;
    uint64_t v16 = v10 - (void)v13;
    if (v16 >> 2 > v14) {
      unint64_t v14 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v14;
    }
    uint64_t v37 = v9;
    if (v17) {
      uint64_t v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v9, v17);
    }
    else {
      uint64_t v18 = 0;
    }
    uint64_t v28 = &v18[8 * v15];
    std::string __p = v18;
    char v34 = v28;
    uint64_t v36 = &v18[8 * v17];
    uint64_t v29 = 8 * a5;
    uint64_t v30 = &v28[8 * a5];
    do
    {
      uint64_t v31 = *(void *)v7;
      v7 += 8;
      *(void *)uint64_t v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    uint64_t v35 = v30;
    uint64_t v5 = std::vector<Phase::Controller::DVM::VoiceNode *>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34) {
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v19 = v12 - __dst;
  uint64_t v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    int v21 = &__src[8 * a5];
    char v23 = *(char **)(v9 - 8);
LABEL_17:
    uint64_t v24 = &v5[8 * a5];
    uint64_t v25 = &v23[-8 * a5];
    uint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      uint64_t v26 = v23;
      do
      {
        uint64_t v27 = *(void *)v25;
        v25 += 8;
        *(void *)uint64_t v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  int v21 = &__src[8 * v20];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  }
  char v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v19 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_221F2FDF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::SpatialModeler::ERClustering::GetTotalEnergySumOverBands(void *result)
{
  float v1 = 0.0;
  if (result && *result)
  {
    uint64_t v2 = 0;
    uint64_t v3 = (float *)(result + 2);
    uint64_t v4 = result[1];
    do
    {
      uint64_t v5 = v3;
      uint64_t v6 = result[1];
      if (v4)
      {
        do
        {
          float v7 = *v5++;
          float v1 = v1 + (float)(v7 * v7);
          --v6;
        }
        while (v6);
      }
      ++v2;
      v3 += v4;
    }
    while (v2 != *result);
  }
  return result;
}

char *Phase::SpatialModeler::ERClustering::DetectEarlyReflections(Phase::SpatialModeler::ERClustering *this, const Phase::SpatialModeler::SourceListenerResult *a2, const Phase::SpatialModeler::RayTracerState *a3, float a4)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  if (this)
  {
    return Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(this, (int)a2, 1, a4);
  }
  else
  {
    uint64_t v5 = **(NSObject ***)(Phase::Logger::GetInstance(0) + 1184);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136315394;
      float v7 = "EarlyReflectionClustering.cpp";
      __int16 v8 = 1024;
      int v9 = 52;
      _os_log_impl(&dword_221E5E000, v5, OS_LOG_TYPE_ERROR, "%25s:%-5d     No detector available for source handle.\n", (uint8_t *)&v6, 0x12u);
    }
    return 0;
  }
}

float Phase::SpatialModeler::ERClustering::ExtractPerceptualAttributes(uint64_t a1, void *a2)
{
  float result = 1000.0;
  *(void *)a1 = 0xC35C0000447A0000;
  uint64_t v3 = (void *)a2[13];
  if (v3)
  {
    uint64_t v6 = *v3;
    unint64_t v5 = v3[1];
    if (!*v3)
    {
      if (!v5) {
        return result;
      }
      float v21 = 1.1755e-38;
      goto LABEL_16;
    }
    float v7 = (float *)a2[7];
    unint64_t v8 = a2[12];
    if (v8 >= 2)
    {
      int v9 = v7 + 1;
      float v10 = *v7;
      uint64_t v11 = 4 * v8 - 4;
      unint64_t v12 = v7 + 1;
      do
      {
        float v13 = *v12++;
        float v14 = v13;
        if (v13 < v10)
        {
          float v10 = v14;
          float v7 = v9;
        }
        int v9 = v12;
        v11 -= 4;
      }
      while (v11);
    }
    float result = *v7 / 0.01;
    *(float *)a1 = result;
    if (v5)
    {
      uint64_t v15 = 0;
      uint64_t v16 = (float *)(v3 + 2);
      float v17 = 0.0;
      do
      {
        uint64_t v18 = v16;
        unint64_t v19 = v5;
        do
        {
          float v20 = *v18++;
          float v17 = v17 + (float)(v20 * v20);
          --v19;
        }
        while (v19);
        ++v15;
        v16 += v5;
        float v17 = v17 / (float)v5;
      }
      while (v15 != v6);
      float v21 = v17 + 1.1755e-38;
LABEL_16:
      float result = log10f(v21) * 10.0;
      *(float *)(a1 + 4) = result;
    }
  }
  return result;
}

void Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(void *a1, double a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v197 = *MEMORY[0x263EF8340];
  unsigned int v10 = -1227133513 * ((uint64_t)(a1[1] - *a1) >> 3);
  if (v10 >= a4) {
    unint64_t v11 = a4;
  }
  else {
    unint64_t v11 = v10;
  }
  unint64_t v155 = v11;
  std::vector<unsigned long long>::vector(v181, -1227133513 * ((uint64_t)(a1[1] - *a1) >> 3));
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::vector(v180, v10);
  uint64_t v154 = a7;
  std::vector<Phase::Vector<float,2ul>>::vector(&v178, v10);
  memset(v176, 0, sizeof(v176));
  int v177 = 1065353216;
  uint64_t v153 = v10;
  if (v10)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    float v15 = a2;
    float v160 = v15;
    uint64_t v16 = 56 * v10;
    do
    {
      float v17 = (unint64_t *)((char *)v181[0] + v13);
      *float v17 = *(void *)(*a1 + v14);
      Phase::SpatialModeler::RayTracerState::GetSourceListenerResult((Phase::SpatialModeler::RayTracerState *)a5, v17, (uint64_t)buf);
      unint64_t v19 = (uint64_t *)Phase::SpatialModeler::ERClustering::DetectEarlyReflections(*(Phase::SpatialModeler::ERClustering **)buf, *(const Phase::SpatialModeler::SourceListenerResult **)(a5 + 88), v18, *(float *)(a5 + 464));
      __p[0] = 0;
      __p[1] = 0;
      *(void *)&long long v168 = 0;
      if (v19) {
        std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection*,Phase::SpatialModeler::AudibleEarlyReflection*>(__p, *v19, v19[1], 0x8E38E38E38E38E39 * ((v19[1] - *v19) >> 5));
      }
      if (*(void *)&buf[16]) {
        float v20 = *(float *)(*(void *)&buf[16] + 40);
      }
      else {
        float v20 = 0.0;
      }
      float v21 = *(float *)(a5 + 464);
      float v22 = *(float *)(a5 + 104);
      int v23 = *(unsigned __int8 *)(a5 + 134);
      int v24 = *(_DWORD *)(a5 + 8);
      uint64_t Instance = Phase::Logger::GetInstance((Phase::Logger *)v19);
      if (v23) {
        uint64_t v26 = 0;
      }
      else {
        uint64_t v26 = (int)(v20 * a2);
      }
      float v27 = v20 * v21;
      if (v20 <= 0.0) {
        float v27 = 1.0;
      }
      float v28 = log10f((float)((float)(1.0 / (float)(v27 * v27)) * v22) + 1.0e-15) * 10.0;
      float v29 = expf((float)((float)(*(float *)(Instance + 1204) * 10.0) / 10.0) * 0.11513);
      *(float *)&double v30 = v21;
      *(float *)&double v31 = v160;
      *(float *)&double v32 = v28;
      LODWORD(v33) = v24;
      Phase::SpatialModeler::generateDirectionalMetadataER(__p, v30, v31, v32, v33, v29, a5 + 22776, v26, v180[0] + v12, a6);
      Phase::SpatialModeler::ERClustering::ExtractPerceptualAttributes((uint64_t)&v187, (void *)(v180[0] + v12));
      char v34 = (char *)v181[0] + v13;
      unint64_t v35 = *(void *)((char *)v181[0] + v13);
      *((float *)&v187.__begin_ + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((float *)&v187.__begin_ + 1) + (float)((float)((float)v35 * 5.421e-20) * 0.1);
      float v36 = *((float *)&v187.__begin_ + 1);
      uint64_t v37 = (float *)((char *)v178 + v13);
      *uint64_t v37 = *(float *)&v187.__begin_;
      v37[1] = v36;
      uint64_t v38 = (float *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v176, v35, v34);
      v38[6] = *v37;
      v38[7] = v37[1];
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (*(void *)&buf[24]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[24]);
      }
      if (*(void *)&buf[8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
      }
      v14 += 56;
      v13 += 8;
      v12 += 208;
    }
    while (v16 != v14);
  }
  BOOL v173 = 0;
  uint64_t v174 = 0;
  uint64_t v175 = 0;
  uint64_t v170 = 0;
  v171 = 0;
  uint64_t v172 = 0;
  *(_OWORD *)std::string __p = 0u;
  long long v168 = 0u;
  int v169 = 1065353216;
  std::unordered_map<unsigned long long,Phase::Vector<float,2ul>>::unordered_map((uint64_t)v166, (uint64_t)v176);
  unsigned int v39 = v155;
  Phase::SpatialModeler::getPerceptualCoordinatesFromNewDataAndPastAssignments(a5, v166, (uint64_t)&v173, (uint64_t)&v170, (float *)__p);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v166);
  int v40 = (uint8_t *)(v154 + 40);
  if ((void **)(v154 + 40) != &v173) {
    std::vector<Phase::Vector<float,2ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,2ul>*,Phase::Vector<float,2ul>*>((void *)(v154 + 40), v173, v174, (v174 - (unsigned char *)v173) >> 3);
  }
  if ((void **)(v154 + 88) != &v170) {
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((char *)(v154 + 88), (char *)v170, (uint64_t)v171, (v171 - (unsigned char *)v170) >> 3);
  }
  uint64_t v164 = 0x3F8000003B03126FLL;
  uint64_t v184 = 0;
  long long v185 = 0uLL;
  if (*(void *)(v154 + 48) == *(void *)(v154 + 40))
  {
    int v186 = 1;
    std::vector<Phase::Vector<float,2ul>>::vector(&v182, v155);
    memset(buf, 0, 24);
    std::vector<unsigned int>::vector(&v187, (v179 - (unsigned char *)v178) >> 3);
    int v55 = 0;
    float v56 = 3.4028e38;
    do
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      std::__sample[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<Phase::Vector<float,2ul> const*>,std::__wrap_iter<Phase::Vector<float,2ul> const*>,std::back_insert_iterator<std::vector<Phase::Vector<float,2ul>>>,long,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(v178, (uint64_t)v179, (uint64_t)buf, v155, (uint64_t)&v186);
      Phase::SpatialModeler::kmeans<2ul>::AssignClusterIndices(&v187, (uint64_t *)&v178, (uint64_t *)buf);
      if (v179 == v178)
      {
        float v66 = 0.0;
      }
      else
      {
        uint64_t v57 = 0;
        unint64_t v58 = (v179 - (unsigned char *)v178) >> 3;
        if (v58 <= 1) {
          uint64_t v59 = 1;
        }
        else {
          uint64_t v59 = (v179 - (unsigned char *)v178) >> 3;
        }
        float v60 = 0.0;
        do
        {
          uint64_t v61 = 0;
          char v62 = 1;
          float v63 = 0.0;
          do
          {
            char v64 = v62;
            float v65 = *((float *)v178 + 2 * v57 + v61) - *(float *)(*(void *)buf + 8 * v187.__begin_[v57] + 4 * v61);
            float v63 = v63 + (float)(v65 * v65);
            uint64_t v61 = 1;
            char v62 = 0;
          }
          while ((v64 & 1) != 0);
          float v60 = v60 + sqrtf(v63);
          ++v57;
        }
        while (v57 != v59);
        float v66 = v60 / (float)v58;
      }
      if (v66 < v56)
      {
        std::vector<Phase::Vector<float,2ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,2ul>*,Phase::Vector<float,2ul>*>(&v182, *(_DWORD **)buf, *(_DWORD **)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
        float v56 = v66;
      }
      ++v55;
    }
    while (v55 != 5);
    if (v187.__begin_)
    {
      v187.__end_ = v187.__begin_;
      operator delete(v187.__begin_);
    }
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    if (v184)
    {
      *(void *)&long long v185 = v184;
      operator delete(v184);
    }
    int v67 = v182;
    uint64_t v184 = v182;
    long long v185 = v183;
    int v68 = (char *)v183;
  }
  else
  {
    LODWORD(v182) = 1;
    std::vector<Phase::Vector<float,2ul>>::resize(&v184, v155);
    memset(buf, 0, 24);
    std::vector<unsigned int>::vector(&v187, (v179 - (unsigned char *)v178) >> 3);
    uint64_t v41 = *(void *)(v154 + 40);
    uint64_t v42 = v155 - ((unint64_t)(*(void *)(v154 + 48) - v41) >> 3);
    if ((int)v42 < 1)
    {
      if (v155)
      {
        int v69 = (char *)v184 + 4;
        int v70 = (int *)(v41 + 4);
        unint64_t v71 = v155;
        do
        {
          *(v69 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v70 - 1);
          int v72 = *v70;
          v70 += 2;
          *int v69 = v72;
          v69 += 2;
          --v71;
        }
        while (v71);
      }
    }
    else
    {
      int v43 = 0;
      float v44 = 3.4028e38;
      do
      {
        if (buf != v40) {
          std::vector<Phase::Vector<float,2ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,2ul>*,Phase::Vector<float,2ul>*>(buf, *(_DWORD **)(v154 + 40), *(_DWORD **)(v154 + 48), (uint64_t)(*(void *)(v154 + 48) - *(void *)(v154 + 40)) >> 3);
        }
        std::__sample[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<Phase::Vector<float,2ul> const*>,std::__wrap_iter<Phase::Vector<float,2ul> const*>,std::back_insert_iterator<std::vector<Phase::Vector<float,2ul>>>,long,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(v178, (uint64_t)v179, (uint64_t)buf, v42, (uint64_t)&v182);
        Phase::SpatialModeler::kmeans<2ul>::AssignClusterIndices(&v187, (uint64_t *)&v178, (uint64_t *)buf);
        if (v179 == v178)
        {
          float v54 = 0.0;
        }
        else
        {
          uint64_t v45 = 0;
          unint64_t v46 = (v179 - (unsigned char *)v178) >> 3;
          if (v46 <= 1) {
            uint64_t v47 = 1;
          }
          else {
            uint64_t v47 = (v179 - (unsigned char *)v178) >> 3;
          }
          float v48 = 0.0;
          do
          {
            uint64_t v49 = 0;
            char v50 = 1;
            float v51 = 0.0;
            do
            {
              char v52 = v50;
              float v53 = *((float *)v178 + 2 * v45 + v49) - *(float *)(*(void *)buf + 8 * v187.__begin_[v45] + 4 * v49);
              float v51 = v51 + (float)(v53 * v53);
              uint64_t v49 = 1;
              char v50 = 0;
            }
            while ((v52 & 1) != 0);
            float v48 = v48 + sqrtf(v51);
            ++v45;
          }
          while (v45 != v47);
          float v54 = v48 / (float)v46;
        }
        if (v54 < v44)
        {
          std::vector<Phase::Vector<float,2ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,2ul>*,Phase::Vector<float,2ul>*>(&v184, *(_DWORD **)buf, *(_DWORD **)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
          float v44 = v54;
        }
        ++v43;
      }
      while (v43 != 5);
    }
    if (v187.__begin_)
    {
      v187.__end_ = v187.__begin_;
      operator delete(v187.__begin_);
    }
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    int v67 = (char *)v184;
    int v68 = (char *)v185;
    unsigned int v39 = v155;
  }
  memset(&v187, 0, sizeof(v187));
  if (v68 != v67)
  {
    std::vector<Phase::Vector<float,2ul>>::__vallocate[abi:ne180100](&v187, (v68 - v67) >> 3);
    uint64_t v73 = 0;
    std::vector<unsigned int>::pointer end = v187.__end_;
    do
    {
      int v75 = &v67[v73 * 4];
      int v76 = &end[v73];
      unsigned int *v76 = *(_DWORD *)&v67[v73 * 4];
      v76[1] = *(_DWORD *)&v67[v73 * 4 + 4];
      v73 += 2;
    }
    while (v75 + 8 != v68);
    v187.__end_ = &end[v73];
  }
  std::vector<unsigned int>::vector(&v165, (v179 - (unsigned char *)v178) >> 3);
  int v77 = 0;
  size_t v78 = 8 * v39;
  while (2)
  {
    Phase::SpatialModeler::kmeans<2ul>::AssignClusterIndices(&v165, (uint64_t *)&v178, (uint64_t *)&v184);
    std::vector<Phase::Vector<float,2ul>>::resize(&v184, v155);
    bzero(v184, v78);
    memset(buf, 0, 24);
    if (v155)
    {
      std::vector<Phase::Vector<float,2ul>>::__vallocate[abi:ne180100](buf, v155);
      bzero(*(void **)&buf[8], v78);
      uint64_t v80 = *(unint64_t **)buf;
    }
    else
    {
      uint64_t v80 = 0;
    }
    if (v179 != v178)
    {
      unint64_t v81 = (v179 - (unsigned char *)v178) >> 3;
      begiuint64_t n = v165.__begin_;
      uint64_t v83 = (char *)v184;
      if (v81 <= 1) {
        unint64_t v81 = 1;
      }
      uint64_t v84 = (float *)((char *)v178 + 4);
      do
      {
        unsigned int v86 = *begin++;
        uint64_t v85 = v86;
        uint64_t v87 = (float *)&v83[8 * v86];
        float v88 = v87[1];
        *uint64_t v87 = *(v84 - 1) + *v87;
        float v89 = *v84;
        v84 += 2;
        v87[1] = v89 + v88;
        ++v80[v85];
        --v81;
      }
      while (v81);
    }
    unint64_t v90 = v155;
    if (v155)
    {
      uint64_t v91 = (float32x2_t *)v184;
      int v92 = v80;
      do
      {
        unint64_t v94 = *v92++;
        unint64_t v93 = v94;
        if (v94 >= 2)
        {
          *(float *)v79.i32 = (float)v93;
          int32x2_t v79 = (int32x2_t)vdiv_f32(*v91, (float32x2_t)vdup_lane_s32(v79, 0));
          *uint64_t v91 = (float32x2_t)v79;
        }
        ++v91;
        --v90;
      }
      while (v90);
    }
    else if (!v80)
    {
      goto LABEL_96;
    }
    *(void *)&uint8_t buf[8] = v80;
    operator delete(v80);
LABEL_96:
    if (v187.__end_ != v187.__begin_)
    {
      uint64_t v95 = 0;
      unint64_t v96 = ((char *)v187.__end_ - (char *)v187.__begin_) >> 3;
      if (v96 <= 1) {
        int64_t v97 = 1;
      }
      else {
        int64_t v97 = ((char *)v187.__end_ - (char *)v187.__begin_) >> 3;
      }
      BOOL v98 = 1;
LABEL_101:
      uint64_t v99 = 0;
      char v100 = 1;
      while (vabds_f32(*(float *)&v187.__begin_[2 * v95 + v99], *((float *)v184 + 2 * v95 + v99)) <= *((float *)&v164 + v99))
      {
        char v101 = v100;
        char v100 = 0;
        uint64_t v99 = 1;
        if ((v101 & 1) == 0)
        {
          BOOL v98 = ++v95 < v96;
          if (v95 != v97) {
            goto LABEL_101;
          }
          goto LABEL_108;
        }
      }
      if (v98)
      {
        std::vector<Phase::Vector<float,2ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,2ul>*,Phase::Vector<float,2ul>*>(&v187, v184, (_DWORD *)v185, (uint64_t)(v185 - (void)v184) >> 3);
        if (++v77 != 100) {
          continue;
        }
      }
    }
    break;
  }
LABEL_108:
  if (&v184 != (void **)v40) {
    std::vector<Phase::Vector<float,2ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,2ul>*,Phase::Vector<float,2ul>*>((void *)(v154 + 40), v184, (_DWORD *)v185, (uint64_t)(v185 - (void)v184) >> 3);
  }
  if (v187.__begin_)
  {
    v187.__end_ = v187.__begin_;
    operator delete(v187.__begin_);
  }
  __int16 v102 = (Phase::Logger *)v184;
  if (v184)
  {
    *(void *)&long long v185 = v184;
    operator delete(v184);
  }
  if (*(void *)(v154 + 48) != *(void *)(v154 + 40))
  {
    uint64_t v103 = 0;
    unint64_t v104 = 0;
    do
    {
      unint64_t v105 = **(NSObject ***)(Phase::Logger::GetInstance(v102) + 1184);
      __int16 v102 = (Phase::Logger *)os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT);
      if (v102)
      {
        uint64_t v106 = (float *)(*(void *)v40 + v103);
        double v107 = *v106;
        double v108 = v106[1];
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "EarlyReflectionClustering.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 218;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(double *)&unsigned char buf[20] = v107;
        *(_WORD *)&unsigned char buf[28] = 2048;
        *(double *)&buf[30] = v108;
        _os_log_impl(&dword_221E5E000, v105, OS_LOG_TYPE_DEFAULT, "%25s:%-5d kmeans, centroids begin %f %f", buf, 0x26u);
      }
      ++v104;
      v103 += 8;
    }
    while (v104 < (uint64_t)(*(void *)(v154 + 48) - *(void *)(v154 + 40)) >> 3);
  }
  uint64_t v109 = (float *)v154;
  if (v179 != v178)
  {
    uint64_t v110 = 0;
    unint64_t v111 = 0;
    do
    {
      int64_t v112 = **(NSObject ***)(Phase::Logger::GetInstance(v102) + 1184);
      __int16 v102 = (Phase::Logger *)os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT);
      if (v102)
      {
        double v113 = *(float *)((char *)v178 + v110);
        double v114 = *(float *)((char *)v178 + v110 + 4);
        *(_DWORD *)buf = 136315906;
        *(void *)&uint8_t buf[4] = "EarlyReflectionClustering.cpp";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 224;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(double *)&unsigned char buf[20] = v113;
        *(_WORD *)&unsigned char buf[28] = 2048;
        *(double *)&buf[30] = v114;
        _os_log_impl(&dword_221E5E000, v112, OS_LOG_TYPE_DEFAULT, "%25s:%-5d kmeans, data begin %f %f", buf, 0x26u);
      }
      ++v111;
      v110 += 8;
    }
    while (v111 < (v179 - (unsigned char *)v178) >> 3);
  }
  uint64_t v152 = (void *)(v154 + 64);
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::resize((uint64_t **)(v154 + 64), v155);
  uint64_t v115 = a5;
  if (v155)
  {
    for (uint64_t i = 0; i != v155; ++i)
    {
      uint64_t v117 = 0;
      uint64_t v118 = 0;
      memset(&v187, 0, sizeof(v187));
      do
      {
        if (i == v165.__begin_[v118])
        {
          std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v109, *((void *)v181[0] + v118), (void *)v181[0] + v118)[3] = i;
          std::vector<unsigned int>::pointer v119 = v187.__end_;
          if (v187.__end_ >= v187.__end_cap_.__value_)
          {
            std::vector<unsigned int>::pointer v120 = v187.__begin_;
            int64_t v121 = v187.__end_ - v187.__begin_;
            unint64_t v122 = v121 + 1;
            if ((unint64_t)(v121 + 1) >> 62) {
              std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
            }
            int64_t v123 = (char *)v187.__end_cap_.__value_ - (char *)v187.__begin_;
            if (((char *)v187.__end_cap_.__value_ - (char *)v187.__begin_) >> 1 > v122) {
              unint64_t v122 = v123 >> 1;
            }
            if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v124 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v124 = v122;
            }
            if (v124)
            {
              uint64_t v125 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v187.__end_cap_, v124);
              std::vector<unsigned int>::pointer v119 = v187.__end_;
              std::vector<unsigned int>::pointer v120 = v187.__begin_;
            }
            else
            {
              uint64_t v125 = 0;
            }
            int v126 = (unsigned int *)&v125[4 * v121];
            *int v126 = v118;
            uint64_t v117 = v126 + 1;
            while (v119 != v120)
            {
              unsigned int v127 = *--v119;
              *--int v126 = v127;
            }
            v187.__begin_ = v126;
            v187.__end_ = v117;
            v187.__end_cap_.__value_ = (unsigned int *)&v125[4 * v124];
            if (v120) {
              operator delete(v120);
            }
          }
          else
          {
            *v187.__end_ = v118;
            uint64_t v117 = v119 + 1;
          }
          v187.__end_ = v117;
        }
        ++v118;
      }
      while (v118 != v153);
      if (v117 != v187.__begin_)
      {
        *(void *)buf = &v178;
        std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>,false>(v117, v117, (uint64_t)v187.__begin_, v187.__begin_, (uint64_t **)buf, 126 - 2 * __clz(v117 - v187.__begin_), 1);
        uint64_t v128 = *v152 + 208 * i;
        std::vector<unsigned int>::pointer v129 = v187.__end_;
        if (v187.__end_ == v187.__begin_)
        {
          std::vector<unsigned int>::pointer v137 = v187.__end_;
        }
        else
        {
          unint64_t v130 = 0;
          uint64_t v131 = *v152 + 208 * i;
          uint64_t v161 = (void *)(v131 + 48);
          uint64_t v163 = (uint64_t *)(v131 + 8);
          uint64_t v158 = (void *)(v131 + 96);
          uint64_t v159 = (uint64_t *)(v131 + 56);
          uint64_t v157 = (uint64_t *)(v131 + 104);
          uint64_t v132 = (uint64_t *)(v131 + 144);
          uint64_t v133 = (void *)(v131 + 184);
          uint64_t v134 = (_OWORD *)(v131 + 192);
          std::vector<unsigned int>::pointer v129 = v187.__begin_;
          do
          {
            uint64_t v135 = v180[0] + 208 * v129[v130++];
            Phase::SpatialModeler::MorphDirectionalMetadata(v135, v128, (uint64_t)buf, 1.0 / (float)v130, 1.0 - (float)(1.0 / (float)v130));
            int v136 = *(_DWORD *)buf;
            *(unsigned char *)(v128 + 4) = buf[4];
            *(_DWORD *)uint64_t v128 = v136;
            std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](v163, (uint64_t *)&buf[8]);
            *uint64_t v161 = v189;
            std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](v159, &v190);
            *uint64_t v158 = v191[4];
            std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::operator=[abi:ne180100](v157, &v192);
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](v132, &v194);
            *uint64_t v133 = v195[4];
            *uint64_t v134 = v196;
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100](&v194);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v195);
            std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100](&v192, 0);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v193);
            std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v190);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v191);
            std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&buf[8]);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[16]);
            std::vector<unsigned int>::pointer v137 = v187.__end_;
            std::vector<unsigned int>::pointer v129 = v187.__begin_;
          }
          while (v130 < v187.__end_ - v187.__begin_);
          uint64_t v109 = (float *)v154;
          uint64_t v115 = a5;
        }
        uint64_t v138 = *(void **)(v128 + 104);
        TotalEnergySumOverBands = (Phase::Logger *)Phase::SpatialModeler::ERClustering::GetTotalEnergySumOverBands(v138);
        float v141 = v140;
        if (v138) {
          unint64_t v142 = v138[1];
        }
        else {
          unint64_t v142 = 0;
        }
        if ((double)v142 * 0.000000001 >= v140)
        {
          if (v137 != v129)
          {
            unint64_t v149 = 0;
            do
            {
              unint64_t v150 = (unint64_t *)((char *)v181[0] + 8 * v129[v149]);
              TotalEnergySumOverBands = (Phase::Logger *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v109, *v150, v150);
              *((void *)TotalEnergySumOverBands + 4) = 0;
              ++v149;
              std::vector<unsigned int>::pointer v129 = v187.__begin_;
            }
            while (v149 < v187.__end_ - v187.__begin_);
          }
          uint64_t v151 = **(NSObject ***)(Phase::Logger::GetInstance(TotalEnergySumOverBands) + 1184);
          if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315906;
            *(void *)&uint8_t buf[4] = "EarlyReflectionClustering.cpp";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 298;
            *(_WORD *)&unsigned char buf[18] = 1024;
            *(_DWORD *)&unsigned char buf[20] = i;
            *(_WORD *)&unsigned char buf[24] = 2048;
            *(double *)&buf[26] = v141;
            _os_log_impl(&dword_221E5E000, v151, OS_LOG_TYPE_ERROR, "%25s:%-5d Early Reflection Cluster (%i) has no energy (%f).", buf, 0x22u);
          }
        }
        else if (v137 != v129)
        {
          unint64_t v143 = 0;
          do
          {
            uint64_t v144 = v129[v143];
            Phase::SpatialModeler::ERClustering::GetTotalEnergySumOverBands(*(void **)(v180[0]
                                                                                       + 208 * v144
                                                                                       + 104));
            float v146 = v145;
            float v147 = *(float *)(v115 + 144);
            int v148 = (double *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v109, *((void *)v181[0] + v144), (void *)v181[0] + v144);
            v148[4] = fminf(fmaxf(log10f((float)(v146 / v141) + 1.1755e-38) * 10.0, -3.4028e38), v147);
            ++v143;
            std::vector<unsigned int>::pointer v129 = v187.__begin_;
          }
          while (v143 < v187.__end_ - v187.__begin_);
        }
        uint64_t v117 = v187.__begin_;
      }
      if (v117)
      {
        v187.__end_ = v117;
        operator delete(v117);
      }
    }
  }
  if (v165.__begin_)
  {
    v165.__end_ = v165.__begin_;
    operator delete(v165.__begin_);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)__p);
  if (v170)
  {
    v171 = v170;
    operator delete(v170);
  }
  if (v173)
  {
    uint64_t v174 = (char *)v173;
    operator delete(v173);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v176);
  if (v178)
  {
    uint64_t v179 = v178;
    operator delete(v178);
  }
  *(void *)buf = v180;
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  if (v181[0])
  {
    v181[1] = v181[0];
    operator delete(v181[0]);
  }
}

void sub_221F310A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,void *a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,void *a60,uint64_t a61,uint64_t a62,char a63)
{
  uint64_t v73 = (void *)STACK[0x230];
  if (STACK[0x230])
  {
    STACK[0x238] = (unint64_t)v73;
    operator delete(v73);
  }
  if (a69)
  {
    a70 = (uint64_t)a69;
    operator delete(a69);
  }
  int v74 = a72;
  if (a72)
  {
    STACK[0x200] = (unint64_t)a72;
    operator delete(v74);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&a43);
  if (a49)
  {
    a50 = (uint64_t)a49;
    operator delete(a49);
  }
  if (a52)
  {
    a53 = (uint64_t)a52;
    operator delete(a52);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&a55);
  if (a60)
  {
    a61 = (uint64_t)a60;
    operator delete(a60);
  }
  a55 = (uint64_t)&a63;
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a55);
  if (a66)
  {
    a67 = (uint64_t)a66;
    operator delete(a66);
  }
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::SourceListenerResult::~SourceListenerResult(Phase::SpatialModeler::SourceListenerResult *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::resize(uint64_t **a1, unint64_t a2)
{
  uint64_t v4 = *a1;
  unint64_t v5 = a1[1];
  unint64_t v6 = 0x4EC4EC4EC4EC4EC5 * (((char *)v5 - (char *)*a1) >> 4);
  unint64_t v7 = a2 - v6;
  if (a2 <= v6)
  {
    if (a2 < v6)
    {
      double v30 = &v4[26 * a2];
      while (v5 != v30)
      {
        v5 -= 26;
        std::allocator<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v5);
      }
      a1[1] = v30;
    }
  }
  else
  {
    unint64_t v8 = a1[2];
    if (0x4EC4EC4EC4EC4EC5 * (((char *)v8 - (char *)v5) >> 4) >= v7)
    {
      double v31 = &v5[26 * v7];
      do
      {
        *(_DWORD *)unint64_t v5 = 3;
        *((unsigned char *)v5 + 4) = 1;
        v5[1] = 0;
        *((_DWORD *)v5 + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
        v5[6] = 0;
        v5[7] = 0;
        void v5[5] = 0;
        v5[12] = 0;
        v5[13] = 0;
        v5[11] = 0;
        v5[17] = 0;
        v5[18] = 0;
        v5[23] = 0;
        v5[24] = 0;
        v5[22] = 0;
        *((_WORD *)v5 + 100) = 0;
        v5 += 26;
      }
      while (v5 != v31);
      a1[1] = v31;
    }
    else
    {
      if (a2 > 0x13B13B13B13B13BLL) {
        std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v9 = 0x4EC4EC4EC4EC4EC5 * (((char *)v8 - (char *)v4) >> 4);
      uint64_t v10 = 2 * v9;
      if (2 * v9 <= a2) {
        uint64_t v10 = a2;
      }
      if (v9 >= 0x9D89D89D89D89DLL) {
        unint64_t v11 = 0x13B13B13B13B13BLL;
      }
      else {
        unint64_t v11 = v10;
      }
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::DirectionalMetadataOutput<float>>>(v11);
      uint64_t v14 = &v12[208 * v6];
      float v15 = &v12[208 * a2];
      uint64_t v16 = v14;
      do
      {
        *(_DWORD *)uint64_t v16 = 3;
        v16[4] = 1;
        *((void *)v16 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
        *((_DWORD *)v16 + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
        *((void *)v16 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
        *((void *)v16 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
        *((void *)v16 + 5) = 0;
        *((void *)v16 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
        *((void *)v16 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0;
        *((void *)v16 + 1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
        *((void *)v16 + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
        *((void *)v16 + 18) = 0;
        *((void *)v16 + 23) = 0;
        *((void *)v16 + 24) = 0;
        *((void *)v16 + 22) = 0;
        *((_WORD *)v16 + 100) = 0;
        v16 += 208;
      }
      while (v16 != v15);
      float v17 = &v12[208 * v13];
      unint64_t v19 = *a1;
      uint64_t v18 = a1[1];
      if (v18 == *a1)
      {
        *a1 = (uint64_t *)v14;
        a1[1] = (uint64_t *)v15;
        a1[2] = (uint64_t *)v17;
      }
      else
      {
        uint64_t v20 = 0;
        do
        {
          float v21 = &v14[v20 * 8];
          float v22 = &v18[v20];
          *((void *)v21 - 2std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v18[v20 - 26];
          uint64_t v23 = v18[v20 - 25];
          v18[v20 - 25] = 0;
          *((void *)v21 - 25) = v23;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v14[v20 * 8 - 192], (uint64_t)&v18[v20 - 24]);
          uint64_t v24 = v18[v20 - 20];
          uint64_t v25 = v18[v20 - 19];
          *(v22 - 19) = 0;
          *((void *)v21 - 20) = v24;
          *((void *)v21 - 19) = v25;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v14[v20 * 8 - 144], (uint64_t)&v18[v20 - 18]);
          uint64_t v26 = v18[v20 - 14];
          uint64_t v27 = v18[v20 - 13];
          *(v22 - std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0;
          *((void *)v21 - 14) = v26;
          *((void *)v21 - std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = v27;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v14[v20 * 8 - 96], (uint64_t)&v18[v20 - 12]);
          uint64_t v28 = v18[v20 - 8];
          *(v22 - 8) = 0;
          *((void *)v21 - 8) = v28;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&v14[v20 * 8 - 56], (uint64_t)&v18[v20 - 7]);
          *((void *)v21 - 3) = v18[v20 - 3];
          *((_OWORD *)v21 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_OWORD *)&v18[v20 - 2];
          v20 -= 26;
        }
        while (&v18[v20] != v19);
        uint64_t v18 = *a1;
        float v29 = a1[1];
        *a1 = (uint64_t *)&v14[v20 * 8];
        a1[1] = (uint64_t *)v15;
        a1[2] = (uint64_t *)v17;
        while (v29 != v18)
        {
          v29 -= 26;
          std::allocator<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v29);
        }
      }
      if (v18)
      {
        operator delete(v18);
      }
    }
  }
}

void Phase::SpatialModeler::ERClustering::AssignSourcesToExistingRenderers(unsigned int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6)
{
  uint64_t v146 = *MEMORY[0x263EF8340];
  uint64_t v10 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a3 + 18936) - *(void *)(a3 + 18928)) >> 3);
  if (v10 >= a1) {
    unint64_t v11 = a1;
  }
  else {
    unint64_t v11 = v10;
  }
  unint64_t v105 = v11;
  unint64_t v12 = -1227133513 * ((uint64_t)(*(void *)(a3 + 18936) - *(void *)(a3 + 18928)) >> 3);
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::vector(&v129, v12);
  unint64_t v124 = 0;
  uint64_t v125 = 0;
  int v126 = 0;
  if (v12)
  {
    unint64_t v124 = operator new(40 * v12);
    int v126 = (char *)v124 + 40 * v12;
    size_t v13 = 40 * ((40 * v12 - 40) / 0x28) + 40;
    bzero(v124, v13);
    uint64_t v125 = (char *)v124 + v13;
  }
  unsigned int v104 = a1;
  uint64_t v102 = a5;
  memset(v127, 0, sizeof(v127));
  int v128 = 1065353216;
  uint64_t v14 = *(void *)(a3 + 18936) - *(void *)(a3 + 18928);
  if (v14)
  {
    uint64_t v15 = 0;
    unint64_t v16 = v14 / 56;
    float v17 = a6;
    float v109 = v17;
    if (v16 <= 1) {
      unint64_t v16 = 1;
    }
    unint64_t v106 = v16;
    do
    {
      unint64_t v18 = *(void *)(*(void *)(a3 + 18928) + 56 * v15);
      v134[0] = v18;
      uint64_t v19 = a2[18];
      uint64_t v20 = a2[13];
      uint64_t v21 = 0;
      if (v19)
      {
        uint64_t v22 = 0;
        uint64_t v23 = *(void *)(a3 + 22576);
        uint64_t v24 = v20 + 160;
        do
        {
          if (Phase::SpatialModeler::GetSoundSourceHash(*(void *)(v24 - 16), v23, v24) == v18) {
            uint64_t v21 = v22;
          }
          ++v22;
          v24 += 304;
        }
        while (v19 != v22);
      }
      unint64_t v25 = *(void *)(v20 + 304 * v21 + 288);
      unint64_t v26 = a2[12];
      if (v26) {
        BOOL v27 = v25 >= v26;
      }
      else {
        BOOL v27 = 1;
      }
      if (v27) {
        uint64_t v28 = 0;
      }
      else {
        uint64_t v28 = *(void *)(a2[7] + 336 * v25);
      }
      Phase::SpatialModeler::RayTracerState::GetSourceListenerResult((Phase::SpatialModeler::RayTracerState *)a3, v134, (uint64_t)buf);
      double v30 = (uint64_t *)Phase::SpatialModeler::ERClustering::DetectEarlyReflections(*(Phase::SpatialModeler::ERClustering **)buf, *(const Phase::SpatialModeler::SourceListenerResult **)(a3 + 88), v29, *(float *)(a3 + 464));
      __p[0] = 0;
      __p[1] = 0;
      v120[0] = 0;
      if (v30) {
        std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection*,Phase::SpatialModeler::AudibleEarlyReflection*>(__p, *v30, v30[1], 0x8E38E38E38E38E39 * ((v30[1] - *v30) >> 5));
      }
      if (*(void *)&buf[16]) {
        float v31 = *(float *)(*(void *)&buf[16] + 40);
      }
      else {
        float v31 = 0.0;
      }
      float v32 = *(float *)(a3 + 464);
      float v33 = *(float *)(a3 + 104);
      int v34 = *(unsigned __int8 *)(a3 + 134);
      int v35 = *(_DWORD *)(a3 + 8);
      uint64_t Instance = Phase::Logger::GetInstance((Phase::Logger *)v30);
      if (v34) {
        uint64_t v37 = 0;
      }
      else {
        uint64_t v37 = (int)(v31 * a6);
      }
      float v38 = v31 * v32;
      if (v31 <= 0.0) {
        float v38 = 1.0;
      }
      float v39 = log10f((float)((float)(1.0 / (float)(v38 * v38)) * v33) + 1.0e-15) * 10.0;
      float v40 = expf((float)((float)(*(float *)(Instance + 1204) * 10.0) / 10.0) * 0.11513);
      *(float *)&double v41 = v32;
      *(float *)&double v42 = v109;
      *(float *)&double v43 = v39;
      LODWORD(v44) = v35;
      Phase::SpatialModeler::generateDirectionalMetadataER(__p, v41, v42, v43, v44, v40, a3 + 22776, v37, v129 + 208 * v15, a4);
      Phase::SpatialModeler::ERClustering::ExtractPerceptualAttributes((uint64_t)&v131, (void *)(v129 + 208 * v15));
      uint64_t v45 = *(void *)(a3 + 18928) + 56 * v15;
      *(void *)&long long v46 = *(void *)(v45 + 24);
      DWORD2(v4std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v45 + 32);
      HIDWORD(v4std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v131;
      *((float *)&v131 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = (float)((float)((float)v18 * 5.421e-20) * 0.1) + *((float *)&v131 + 1);
      float v47 = *((float *)&v131 + 1);
      float v48 = (char *)v124;
      uint64_t v49 = (char *)v124 + 40 * v15;
      *(void *)uint64_t v49 = v18;
      *(_OWORD *)(v49 + 8) = v46;
      *((float *)v49 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v47;
      *((void *)v49 + 4) = v28;
      char v50 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v127, v18, v134);
      float v51 = &v48[40 * v15];
      *((_DWORD *)v50 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v51 + 5);
      *((_DWORD *)v50 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *((_DWORD *)v51 + 6);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (*(void *)&buf[24]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[24]);
      }
      if (*(void *)&buf[8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&buf[8]);
      }
      ++v15;
    }
    while (v15 != v106);
  }
  memset(v122, 0, sizeof(v122));
  *(_OWORD *)std::vector<unsigned int>::pointer v120 = 0u;
  long long v121 = 0u;
  *(_OWORD *)std::string __p = 0u;
  int v123 = 1065353216;
  std::unordered_map<unsigned long long,Phase::Vector<float,2ul>>::unordered_map((uint64_t)v118, (uint64_t)v127);
  char v52 = (float *)v102;
  Phase::SpatialModeler::getPerceptualCoordinatesFromNewDataAndPastAssignments(a3, v118, (uint64_t)__p, (uint64_t)&v120[1], (float *)v122);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v118);
  Phase::SpatialModeler::getAttackQueryAssignments((uint64_t *)&v124, (const Phase::SpatialModeler::SourcePreProcessData *)__p, v53);
  if ((void **)(v102 + 40) != __p) {
    std::vector<Phase::Vector<float,2ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,2ul>*,Phase::Vector<float,2ul>*>((void *)(v102 + 40), (_DWORD *)__p[0], (_DWORD *)__p[1], ((char *)__p[1] - (char *)__p[0]) >> 3);
  }
  if ((void **)(v102 + 88) != &v120[1]) {
    std::vector<unsigned long long>::__assign_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>((char *)(v102 + 88), (char *)v120[1], v121, (uint64_t)(v121 - (unint64_t)v120[1]) >> 3);
  }
  uint64_t v115 = 0;
  uint64_t v116 = 0;
  uint64_t v117 = 0;
  float v54 = (Phase::Logger *)Phase::SpatialModeler::AssignSourcesToRenderers(v104, (uint64_t *)&v124, __p, &v115);
  float v55 = *(float *)(a3 + 144);
  *(_OWORD *)uint64_t v134 = 0u;
  long long v135 = 0u;
  int v136 = 1065353216;
  float v56 = (unint64_t *)v115;
  if (v115 == v116)
  {
    unint64_t v57 = 0;
  }
  else
  {
    do
    {
      float v54 = (Phase::Logger *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long const&>((uint64_t)v134, v56, v56);
      ++v56;
    }
    while (v56 != (unint64_t *)v116);
    unint64_t v57 = *((void *)&v135 + 1);
  }
  if (v57 >= v105) {
    unint64_t v58 = v105;
  }
  else {
    unint64_t v58 = v57;
  }
  if (!v58)
  {
    unint64_t v96 = **(NSObject ***)(Phase::Logger::GetInstance(v54) + 1184);
    if (!os_log_type_enabled(v96, OS_LOG_TYPE_ERROR)) {
      goto LABEL_100;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "EarlyReflectionClustering.cpp";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 411;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&unsigned char buf[20] = *((void *)&v135 + 1);
    *(_WORD *)&unsigned char buf[28] = 2048;
    *(void *)&buf[30] = v105;
    int64_t v97 = "%25s:%-5d GenerateClusterMetadataFromResults - number of unique assigned clusters is %zu, inMaxExpectedNumClus"
          "ters %zu, nothing to do, returning";
LABEL_99:
    _os_log_impl(&dword_221E5E000, v96, OS_LOG_TYPE_ERROR, v97, buf, 0x26u);
    goto LABEL_100;
  }
  uint64_t v59 = v130;
  uint64_t v100 = v129;
  unint64_t v60 = 0x4EC4EC4EC4EC4EC5 * ((v130 - v129) >> 4);
  if (v60 != ((char *)v56 - (unsigned char *)v115) >> 3)
  {
    unint64_t v96 = **(NSObject ***)(Phase::Logger::GetInstance(v54) + 1184);
    if (!os_log_type_enabled(v96, OS_LOG_TYPE_ERROR)) {
      goto LABEL_100;
    }
    *(_DWORD *)buf = 136315906;
    *(void *)&uint8_t buf[4] = "EarlyReflectionClustering.cpp";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 420;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&unsigned char buf[20] = (v116 - (unsigned char *)v115) >> 3;
    *(_WORD *)&unsigned char buf[28] = 2048;
    *(void *)&buf[30] = v60;
    int64_t v97 = "%25s:%-5d GenerateClusterMetadataFromResults - number , inClusterIndices.size() [%zu] != numSources [%zu], returning";
    goto LABEL_99;
  }
  char v101 = (void *)(v102 + 64);
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::resize((uint64_t **)(v102 + 64), v58);
  uint64_t v61 = 0;
  uint64_t v62 = v100;
  uint64_t v98 = v59;
  unint64_t v99 = v60;
  unint64_t v103 = v58;
  do
  {
    uint64_t v131 = 0;
    uint64_t v132 = 0;
    uint64_t v133 = 0;
    if (v59 != v62)
    {
      float v63 = 0;
      uint64_t v64 = 0;
      unsigned int v65 = 0;
      do
      {
        unint64_t v66 = *((void *)v124 + 5 * v64);
        *(void *)buf = v66;
        if (*((void *)v115 + v64) == v61)
        {
          std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v52, v66, buf)[3] = v61;
          int v67 = v132;
          if (v132 >= v133)
          {
            int v68 = (char *)v131;
            uint64_t v69 = (v132 - (unsigned char *)v131) >> 2;
            unint64_t v70 = v69 + 1;
            if ((unint64_t)(v69 + 1) >> 62) {
              std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v71 = v133 - (unsigned char *)v131;
            if ((v133 - (unsigned char *)v131) >> 1 > v70) {
              unint64_t v70 = v71 >> 1;
            }
            if ((unint64_t)v71 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v72 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v72 = v70;
            }
            if (v72)
            {
              uint64_t v73 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v133, v72);
              int v68 = (char *)v131;
              int v67 = v132;
            }
            else
            {
              uint64_t v73 = 0;
            }
            int v74 = &v73[4 * v69];
            *(_DWORD *)int v74 = v65;
            float v63 = v74 + 4;
            while (v67 != v68)
            {
              int v75 = *((_DWORD *)v67 - 1);
              v67 -= 4;
              *((_DWORD *)v74 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v75;
              v74 -= 4;
            }
            uint64_t v131 = v74;
            uint64_t v132 = v63;
            uint64_t v133 = &v73[4 * v72];
            if (v68) {
              operator delete(v68);
            }
          }
          else
          {
            *(_DWORD *)uint64_t v132 = v65;
            float v63 = v67 + 4;
          }
          uint64_t v132 = v63;
        }
        uint64_t v64 = ++v65;
      }
      while (v60 > v65);
      if (v63 == v131)
      {
        uint64_t v85 = v59;
        uint64_t v86 = v62;
      }
      else
      {
        *(void *)buf = &v124;
        std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>,false>(v63, (unsigned int *)v63, (uint64_t)v131, (unsigned int *)v131, (uint64_t **)buf, 126 - 2 * __clz((v63 - (unsigned char *)v131) >> 2), 1);
        uint64_t v76 = *v101 + 208 * v61;
        float v63 = v132;
        if (v132 == v131)
        {
          uint64_t v85 = v59;
          uint64_t v86 = v62;
          uint64_t v84 = v132;
        }
        else
        {
          unint64_t v77 = 0;
          uint64_t v78 = *v101 + 208 * v61;
          double v114 = (uint64_t *)(v78 + 8);
          int64_t v112 = (void *)(v78 + 48);
          uint64_t v110 = (uint64_t *)(v78 + 56);
          double v108 = (void *)(v78 + 96);
          double v107 = (uint64_t *)(v78 + 104);
          int32x2_t v79 = (uint64_t *)(v78 + 144);
          uint64_t v80 = (void *)(v78 + 184);
          unint64_t v81 = (_OWORD *)(v78 + 192);
          float v63 = (char *)v131;
          do
          {
            uint64_t v82 = v129 + 208 * *(unsigned int *)&v63[4 * v77++];
            Phase::SpatialModeler::MorphDirectionalMetadata(v82, v76, (uint64_t)buf, 1.0 / (float)v77, 1.0 - (float)(1.0 / (float)v77));
            int v83 = *(_DWORD *)buf;
            *(unsigned char *)(v76 + 4) = buf[4];
            *(_DWORD *)uint64_t v76 = v83;
            std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](v114, (uint64_t *)&buf[8]);
            *int64_t v112 = v138;
            std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](v110, &v139);
            *double v108 = v140[4];
            std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::operator=[abi:ne180100](v107, &v141);
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](v79, &v143);
            *uint64_t v80 = v144[4];
            *unint64_t v81 = v145;
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100](&v143);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v144);
            std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100](&v141, 0);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v142);
            std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v139);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v140);
            std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&buf[8]);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[16]);
            float v63 = (char *)v131;
            uint64_t v84 = v132;
          }
          while (v77 < (v132 - (unsigned char *)v131) >> 2);
          char v52 = (float *)v102;
          uint64_t v85 = v98;
          unint64_t v60 = v99;
          uint64_t v86 = v100;
        }
        uint64_t v87 = *(void **)(v76 + 104);
        Phase::SpatialModeler::ERClustering::GetTotalEnergySumOverBands(v87);
        float v89 = v88;
        if (v87) {
          unint64_t v90 = v87[1];
        }
        else {
          unint64_t v90 = 0;
        }
        if ((double)v90 * 0.000000001 >= v88)
        {
          if (v84 != v63)
          {
            unint64_t v95 = 0;
            do
            {
              *(void *)buf = 0;
              *(void *)buf = *((void *)v124 + 5 * *(unsigned int *)&v63[4 * v95]);
              std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v52, *(unint64_t *)buf, buf)[4] = 0;
              ++v95;
              float v63 = (char *)v131;
            }
            while (v95 < (v132 - (unsigned char *)v131) >> 2);
          }
        }
        else if (v84 != v63)
        {
          unint64_t v91 = 0;
          do
          {
            Phase::SpatialModeler::ERClustering::GetTotalEnergySumOverBands(*(void **)(v129
                                                                                       + 208
                                                                                       * *(unsigned int *)&v63[4 * v91]
                                                                                       + 104));
            float v93 = v92;
            *(void *)buf = 0;
            *(void *)buf = *((void *)v124 + 5 * *(unsigned int *)&v63[4 * v91]);
            unint64_t v94 = (double *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v52, *(unint64_t *)buf, buf);
            v94[4] = fminf(fmaxf(log10f((float)(v93 / v89) + 1.1755e-38) * 10.0, -3.4028e38), v55);
            ++v91;
            float v63 = (char *)v131;
          }
          while (v91 < (v132 - (unsigned char *)v131) >> 2);
        }
      }
      uint64_t v62 = v86;
      uint64_t v59 = v85;
      unint64_t v58 = v103;
      if (v63)
      {
        uint64_t v132 = v63;
        operator delete(v63);
      }
    }
    ++v61;
  }
  while (v61 != v58);
LABEL_100:
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v134);
  if (v115)
  {
    uint64_t v116 = v115;
    operator delete(v115);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v122);
  if (v120[1])
  {
    *(void **)&long long v121 = v120[1];
    operator delete(v120[1]);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v127);
  if (v124)
  {
    uint64_t v125 = (char *)v124;
    operator delete(v124);
  }
  *(void *)buf = &v129;
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
}

void sub_221F32120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&a67);
  if (__p) {
    operator delete(__p);
  }
  Phase::SpatialModeler::ClusterPreProcessData::~ClusterPreProcessData((Phase::SpatialModeler::ClusterPreProcessData *)&a41);
  Phase::SpatialModeler::SourcePreProcessData::~SourcePreProcessData((Phase::SpatialModeler::SourcePreProcessData *)&a53);
  STACK[0x200] = (unint64_t)&a61;
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&STACK[0x200]);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::ClusterPreProcessData::~ClusterPreProcessData(Phase::SpatialModeler::ClusterPreProcessData *this)
{
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 48);
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v3;
    operator delete(v3);
  }
}

void Phase::SpatialModeler::SourcePreProcessData::~SourcePreProcessData(Phase::SpatialModeler::SourcePreProcessData *this)
{
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 24);
  uint64_t v2 = *(void **)this;
  if (*(void *)this)
  {
    *((void *)this + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v2;
    operator delete(v2);
  }
}

void *std::vector<unsigned long long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned long long>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_221F322DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    uint64_t v4 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::DirectionalMetadataOutput<float>>>(a2);
    *a1 = v4;
    a1[1] = v4;
    a1[2] = &v4[208 * v5];
    unint64_t v6 = &v4[208 * a2];
    do
    {
      *(_DWORD *)uint64_t v4 = 3;
      v4[4] = 1;
      *((void *)v4 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
      *((_DWORD *)v4 + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
      *((void *)v4 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *((void *)v4 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
      *((void *)v4 + 5) = 0;
      *((void *)v4 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
      *((void *)v4 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0;
      *((void *)v4 + 1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
      *((void *)v4 + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
      *((void *)v4 + 18) = 0;
      *((void *)v4 + 23) = 0;
      *((void *)v4 + 24) = 0;
      *((void *)v4 + 22) = 0;
      *((_WORD *)v4 + 100) = 0;
      v4 += 208;
    }
    while (v4 != v6);
    a1[1] = v6;
  }
  return a1;
}

void sub_221F323A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__throw_length_error[abi:ne180100]()
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::DirectionalMetadataOutput<float>>>(unint64_t a1)
{
  if (a1 >= 0x13B13B13B13B13CLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(208 * a1);
}

void std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (uint64_t *)**a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 26;
        std::allocator<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while (v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::allocator<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::destroy[abi:ne180100](uint64_t a1, uint64_t *a2)
{
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100](a2 + 18);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a2 + 19);
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100](a2 + 13, 0);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a2 + 14);
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](a2 + 7);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a2 + 8);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](a2 + 1);

  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a2 + 2);
}

void *std::vector<Phase::Vector<float,2ul>>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<Phase::Vector<float,2ul>>::__vallocate[abi:ne180100](a1, a2);
    uint64_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_221F32588(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Phase::Vector<float,2ul>>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__throw_length_error[abi:ne180100]();
  }
  float result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection*,Phase::SpatialModeler::AudibleEarlyReflection*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__vallocate[abi:ne180100](a1, a4);
    std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__construct_at_end<Phase::SpatialModeler::AudibleEarlyReflection*,Phase::SpatialModeler::AudibleEarlyReflection*>((uint64_t)a1, a2, a3);
  }
}

void sub_221F3263C(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0xE38E38E38E38E4) {
    std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__throw_length_error[abi:ne180100]();
  }
  float result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[288 * v4];
  return result;
}

void std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__construct_at_end<Phase::SpatialModeler::AudibleEarlyReflection*,Phase::SpatialModeler::AudibleEarlyReflection*>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a1 + 8);
  if (a2 != a3)
  {
    uint64_t v7 = 0;
    do
    {
      std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>::construct[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection,Phase::SpatialModeler::AudibleEarlyReflection&>(a1 + 16, v4 + v7, a2 + v7);
      v7 += 288;
    }
    while (a2 + v7 != a3);
    v4 += v7;
  }
  *(void *)(a1 + 8) = v4;
}

void sub_221F32724(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xE38E38E38E38E4) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(288 * a2);
}

float std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>::construct[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection,Phase::SpatialModeler::AudibleEarlyReflection&>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
  long long v5 = *(_OWORD *)(a3 + 32);
  long long v6 = *(_OWORD *)(a3 + 48);
  long long v7 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)(a2 + 64) = *(_OWORD *)(a3 + 64);
  *(_OWORD *)(a2 + 80) = v7;
  *(_OWORD *)(a2 + 32) = v5;
  *(_OWORD *)(a2 + 48) = v6;
  long long v8 = *(_OWORD *)(a3 + 96);
  long long v9 = *(_OWORD *)(a3 + 112);
  long long v10 = *(_OWORD *)(a3 + 128);
  *(_DWORD *)(a2 + 144) = *(_DWORD *)(a3 + 144);
  *(_OWORD *)(a2 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v9;
  *(_OWORD *)(a2 + 128) = v10;
  *(_OWORD *)(a2 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v8;
  uint64_t v11 = a3 + 148;
  do
  {
    unint64_t v12 = (_DWORD *)(a2 + 168 + v3);
    *(v12 - 5) = *(_DWORD *)(v11 + v3);
    *(v12 - 4) = *(_DWORD *)(v11 + v3 + 4);
    *(v12 - 3) = *(_DWORD *)(v11 + v3 + 8);
    *(v12 - 2) = *(_DWORD *)(v11 + v3 + 12);
    *(v12 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(v11 + v3 + 16);
    *unint64_t v12 = *(_DWORD *)(v11 + v3 + 20);
    v3 += 24;
  }
  while (v3 != 72);
  *(_DWORD *)(a2 + 220) = *(_DWORD *)(a3 + 220);
  *(_DWORD *)(a2 + 224) = *(_DWORD *)(a3 + 224);
  *(_DWORD *)(a2 + 228) = *(_DWORD *)(a3 + 228);
  *(_DWORD *)(a2 + 232) = *(_DWORD *)(a3 + 232);
  *(_DWORD *)(a2 + 23std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a3 + 236);
  *(_DWORD *)(a2 + 240) = *(_DWORD *)(a3 + 240);
  *(_DWORD *)(a2 + 244) = *(_DWORD *)(a3 + 244);
  *(_DWORD *)(a2 + 248) = *(_DWORD *)(a3 + 248);
  *(_DWORD *)(a2 + 252) = *(_DWORD *)(a3 + 252);
  uint64_t v13 = *(void *)(a3 + 256);
  *(_DWORD *)(a2 + 264) = *(_DWORD *)(a3 + 264);
  *(void *)(a2 + 25std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v13;
  *(_DWORD *)(a2 + 268) = *(_DWORD *)(a3 + 268);
  *(_DWORD *)(a2 + 272) = *(_DWORD *)(a3 + 272);
  *(_DWORD *)(a2 + 27std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a3 + 276);
  float result = *(float *)(a3 + 280);
  *(float *)(a2 + 280) = result;
  return result;
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::Vector<float,2ul>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    long long v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x20uLL);
  *uint64_t i = 0;
  i[1] = a2;
  i[2] = *a3;
  i[3] = 0;
  float v12 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    BOOL v14 = 1;
    if (v7 >= 3) {
      BOOL v14 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v15 = v14 | (2 * v7);
    unint64_t v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16) {
      size_t v17 = v16;
    }
    else {
      size_t v17 = v15;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>(a1, v17);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v18 = *(void *)a1;
  uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
  if (v19)
  {
    *uint64_t i = *v19;
LABEL_38:
    void *v19 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = i;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v20 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7) {
        v20 %= v7;
      }
    }
    else
    {
      v20 &= v7 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_221F32A70(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<unsigned long long,Phase::Vector<float,2ul>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  long long v5 = *(uint64_t **)(a2 + 16);
  if (v5)
  {
    long long v6 = (void *)(a1 + 16);
    unint64_t v7 = *(void *)(a1 + 8);
    do
    {
      unint64_t v8 = v5[2];
      if (v7)
      {
        uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] > 1uLL)
        {
          unint64_t v2 = v5[2];
          if (v7 <= v8) {
            unint64_t v2 = v8 % v7;
          }
        }
        else
        {
          unint64_t v2 = (v7 - 1) & v8;
        }
        long long v10 = *(void **)(*(void *)a1 + 8 * v2);
        if (v10)
        {
          for (uint64_t i = (void *)*v10; i; uint64_t i = (void *)*i)
          {
            unint64_t v12 = i[1];
            if (v12 == v8)
            {
              if (i[2] == v8) {
                goto LABEL_41;
              }
            }
            else
            {
              if (v9.u32[0] > 1uLL)
              {
                if (v12 >= v7) {
                  v12 %= v7;
                }
              }
              else
              {
                v12 &= v7 - 1;
              }
              if (v12 != v2) {
                break;
              }
            }
          }
        }
      }
      float v13 = operator new(0x20uLL);
      *float v13 = 0;
      v13[1] = v8;
      _OWORD v13[2] = v5[2];
      *((_DWORD *)v13 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v5 + 6);
      *((_DWORD *)v13 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *((_DWORD *)v5 + 7);
      float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v15 = *(float *)(a1 + 32);
      if (!v7 || (float)(v15 * (float)v7) < v14)
      {
        BOOL v16 = (v7 & (v7 - 1)) != 0;
        if (v7 < 3) {
          BOOL v16 = 1;
        }
        unint64_t v17 = v16 | (2 * v7);
        unint64_t v18 = vcvtps_u32_f32(v14 / v15);
        if (v17 <= v18) {
          size_t v19 = v18;
        }
        else {
          size_t v19 = v17;
        }
        std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>(a1, v19);
        unint64_t v7 = *(void *)(a1 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v8) {
            unint64_t v2 = v8 % v7;
          }
          else {
            unint64_t v2 = v8;
          }
        }
        else
        {
          unint64_t v2 = (v7 - 1) & v8;
        }
      }
      uint64_t v20 = *(void *)a1;
      uint64_t v21 = *(void **)(*(void *)a1 + 8 * v2);
      if (v21)
      {
        *float v13 = *v21;
      }
      else
      {
        *float v13 = *v6;
        *long long v6 = v13;
        *(void *)(v20 + 8 * v2) = v6;
        if (!*v13) {
          goto LABEL_40;
        }
        unint64_t v22 = *(void *)(*v13 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v22 >= v7) {
            v22 %= v7;
          }
        }
        else
        {
          v22 &= v7 - 1;
        }
        uint64_t v21 = (void *)(*(void *)a1 + 8 * v22);
      }
      *uint64_t v21 = v13;
LABEL_40:
      ++*(void *)(a1 + 24);
LABEL_41:
      long long v5 = (uint64_t *)*v5;
    }
    while (v5);
  }
  return a1;
}

void sub_221F32CBC(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

char *std::vector<Phase::Vector<float,2ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,2ul>*,Phase::Vector<float,2ul>*>(void *a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  long long v6 = a2;
  uint64_t v8 = a1[2];
  float result = (char *)*a1;
  if (a4 <= (v8 - (uint64_t)result) >> 3)
  {
    unint64_t v17 = (char *)a1[1];
    float v13 = a1 + 1;
    unint64_t v12 = v17;
    unint64_t v18 = (v17 - result) >> 3;
    if (v18 >= a4)
    {
      unint64_t v22 = result;
      if (a2 != a3)
      {
        uint64_t v23 = result;
        do
        {
          *(_DWORD *)uint64_t v23 = *v6;
          *((_DWORD *)v23 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6[1];
          v22 += 8;
          v6 += 2;
          v23 += 8;
        }
        while (v6 != a3);
      }
      BOOL v16 = (char *)(v22 - result);
      unint64_t v12 = result;
    }
    else
    {
      size_t v19 = &a2[2 * v18];
      if (v12 != result)
      {
        do
        {
          *(_DWORD *)float result = *v6;
          *((_DWORD *)result + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6[1];
          v6 += 2;
          result += 8;
        }
        while (v6 != v19);
      }
      uint64_t v20 = v12;
      if (v19 != a3)
      {
        uint64_t v21 = v12;
        do
        {
          *(_DWORD *)uint64_t v21 = *v19;
          *((_DWORD *)v21 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v19[1];
          v20 += 8;
          v19 += 2;
          v21 += 8;
        }
        while (v19 != a3);
      }
      BOOL v16 = (char *)(v20 - v12);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    float result = std::vector<Phase::Vector<float,2ul>>::__vallocate[abi:ne180100](a1, v11);
    float v14 = (char *)a1[1];
    float v13 = a1 + 1;
    unint64_t v12 = v14;
    float v15 = v14;
    if (v6 != a3)
    {
      float v15 = v12;
      do
      {
        *(_DWORD *)float v15 = *v6;
        *((_DWORD *)v15 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6[1];
        v15 += 8;
        v6 += 2;
      }
      while (v6 != a3);
    }
    BOOL v16 = (char *)(v15 - v12);
  }
  *float v13 = &v16[(void)v12];
  return result;
}

void Phase::SpatialModeler::kmeans<2ul>::AssignClusterIndices(std::vector<unsigned int> *a1, uint64_t *a2, uint64_t *a3)
{
  std::vector<unsigned int>::resize(a1, (a2[1] - *a2) >> 3);
  uint64_t v6 = *a2;
  uint64_t v7 = a2[1];
  uint64_t v8 = v7 - *a2;
  if (v7 != *a2)
  {
    uint64_t v9 = 0;
    uint64_t v10 = *a3;
    unint64_t v11 = a3[1] - *a3;
    uint64_t v12 = v11 & 0x7FFFFFFF8;
    begiuint64_t n = a1->__begin_;
    unint64_t v14 = v8 >> 3;
    uint64_t v15 = (v11 >> 3);
    if (v14 <= 1) {
      uint64_t v16 = 1;
    }
    else {
      uint64_t v16 = v14;
    }
    do
    {
      if (v12)
      {
        uint64_t v17 = 0;
        unsigned int v18 = 0;
        float v19 = 3.4028e38;
        do
        {
          uint64_t v20 = 0;
          float v21 = 0.0;
          char v22 = 1;
          do
          {
            char v23 = v22;
            float v24 = *(float *)(v6 + 8 * v9 + 4 * v20) - *(float *)(v10 + 8 * v17 + 4 * v20);
            float v21 = v21 + (float)(v24 * v24);
            uint64_t v20 = 1;
            char v22 = 0;
          }
          while ((v23 & 1) != 0);
          float v25 = sqrtf(v21);
          if (v25 < v19)
          {
            float v19 = v25;
            unsigned int v18 = v17;
          }
          ++v17;
        }
        while (v17 != v15);
      }
      else
      {
        unsigned int v18 = 0;
      }
      begin[v9++] = v18;
    }
    while (v9 != v16);
  }
}

uint64_t std::__sample[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<Phase::Vector<float,2ul> const*>,std::__wrap_iter<Phase::Vector<float,2ul> const*>,std::back_insert_iterator<std::vector<Phase::Vector<float,2ul>>>,long,std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>>(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6 = (a2 - (uint64_t)a1) >> 3;
  if ((uint64_t)v6 >= a4) {
    uint64_t v7 = a4;
  }
  else {
    uint64_t v7 = (a2 - (uint64_t)a1) >> 3;
  }
  if (v7)
  {
    uint64_t v9 = a1;
    do
    {
      unint64_t v10 = v6 - 1;
      if (v6 == 1)
      {
        uint64_t v13 = 0;
      }
      else if (v6)
      {
        unint64_t v11 = __clz(v6);
        if (((v6 << v11) & 0x7FFFFFFFFFFFFFFFLL) != 0) {
          uint64_t v12 = 64;
        }
        else {
          uint64_t v12 = 63;
        }
        std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine((uint64_t)v27, a5, v12 - v11);
        do
          uint64_t v13 = std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval((uint64_t)v27);
        while (v13 >= v6);
      }
      else
      {
        std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine((uint64_t)v27, a5, 0x40uLL);
        uint64_t v13 = std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval((uint64_t)v27);
      }
      if (v13 < v7)
      {
        uint64_t v15 = *(_DWORD **)(a3 + 8);
        unint64_t v14 = *(void *)(a3 + 16);
        if ((unint64_t)v15 >= v14)
        {
          uint64_t v17 = *(_DWORD **)a3;
          uint64_t v18 = ((uint64_t)v15 - *(void *)a3) >> 3;
          unint64_t v19 = v18 + 1;
          if ((unint64_t)(v18 + 1) >> 61) {
            std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v20 = v14 - (void)v17;
          if (v20 >> 2 > v19) {
            unint64_t v19 = v20 >> 2;
          }
          if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v21 = v19;
          }
          if (v21)
          {
            char v22 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(a3 + 16, v21);
            uint64_t v17 = *(_DWORD **)a3;
            uint64_t v15 = *(_DWORD **)(a3 + 8);
          }
          else
          {
            char v22 = 0;
          }
          char v23 = &v22[8 * v18];
          *(_DWORD *)char v23 = *v9;
          *((_DWORD *)v23 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v9[1];
          float v24 = v23;
          while (v15 != v17)
          {
            int v25 = *(v15 - 2);
            v15 -= 2;
            *((_DWORD *)v24 - 2) = v25;
            v24 -= 8;
            *((_DWORD *)v24 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v15[1];
          }
          uint64_t v16 = v23 + 8;
          *(void *)a3 = v24;
          *(void *)(a3 + 8) = v23 + 8;
          *(void *)(a3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = &v22[8 * v21];
          if (v17) {
            operator delete(v17);
          }
        }
        else
        {
          _DWORD *v15 = *v9;
          v15[1] = v9[1];
          uint64_t v16 = v15 + 2;
        }
        *(void *)(a3 + 8) = v16;
        --v7;
      }
      v9 += 2;
      unint64_t v6 = v10;
    }
    while (v7);
  }
  return a3;
}

uint64_t std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__independent_bits_engine(uint64_t result, uint64_t a2, unint64_t a3)
{
  *(void *)float result = a2;
  *(void *)(result + 8) = a3;
  if (a3 % 0x1E) {
    unint64_t v3 = a3 / 0x1E + 1;
  }
  else {
    unint64_t v3 = a3 / 0x1E;
  }
  unint64_t v4 = a3 / v3;
  *(void *)(result + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3 / v3;
  *(void *)(result + 24) = v3;
  unint64_t v5 = (-1 << (a3 / v3)) & 0x7FFFFFFE;
  if (a3 / v3 >= 0x40) {
    unint64_t v5 = 0;
  }
  *(void *)(result + 40) = v5;
  if ((v5 ^ 0x7FFFFFFE) > v5 / v3)
  {
    ++v3;
    unint64_t v4 = a3 / v3;
    *(void *)(result + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3 / v3;
    *(void *)(result + 24) = v3;
    if (a3 / v3 > 0x3F)
    {
      *(void *)(result + 32) = v3 + v4 * v3 - a3;
      *(void *)(result + 40) = 0;
      LODWORD(v4) = 64;
      goto LABEL_16;
    }
    *(void *)(result + 40) = (-1 << v4) & 0x7FFFFFFE;
  }
  *(void *)(result + 32) = v3 + a3 / v3 * v3 - a3;
  if (v4 >= 0x3F)
  {
LABEL_16:
    *(void *)(result + 48) = 0;
    int v8 = -(int)v4;
    unsigned int v7 = -1;
    *(_DWORD *)(result + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0xFFFFFFFF >> v8;
    goto LABEL_17;
  }
  *(void *)(result + 48) = 0x3FFFFFFFuLL >> v4 << (v4 + 1);
  unsigned int v6 = 0xFFFFFFFF >> -(char)v4;
  if (!v4) {
    unsigned int v6 = 0;
  }
  *(_DWORD *)(result + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v6;
  if (v4 >= 0x1F) {
    unsigned int v7 = -1;
  }
  else {
    unsigned int v7 = 0xFFFFFFFF >> ~(_BYTE)v4;
  }
LABEL_17:
  *(_DWORD *)(result + 60) = v7;
  return result;
}

uint64_t std::__independent_bits_engine<std::linear_congruential_engine<unsigned int,48271u,0u,2147483647u>,unsigned long>::__eval(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t result = 0;
    uint64_t v4 = 0;
    unint64_t v5 = *(void *)(a1 + 16);
    unsigned int v6 = **(_DWORD **)a1;
    do
    {
      do
      {
        unsigned int v7 = v6 / 0xADC8;
        unsigned int v8 = 48271 * (v6 % 0xADC8);
        v7 *= 3399;
        BOOL v9 = v8 >= v7;
        unsigned int v10 = v8 - v7;
        if (v9) {
          int v11 = 0;
        }
        else {
          int v11 = 0x7FFFFFFF;
        }
        unsigned int v6 = v11 + v10;
        unint64_t v12 = v6 - 1;
      }
      while (*(void *)(a1 + 40) <= v12);
      uint64_t v13 = result << v5;
      if (v5 >= 0x40) {
        uint64_t v13 = 0;
      }
      uint64_t result = v13 + (v12 & *(_DWORD *)(a1 + 56));
      ++v4;
    }
    while (v4 != v2);
    **(_DWORD **)a1 = v6;
  }
  else
  {
    uint64_t result = 0;
  }
  unint64_t v14 = *(void *)(a1 + 24);
  if (v2 < v14)
  {
    uint64_t v15 = *(unsigned int **)a1;
    unint64_t v16 = *(void *)(a1 + 48);
    unint64_t v17 = *(void *)(a1 + 16);
    int v18 = *(_DWORD *)(a1 + 60);
    unsigned int v19 = *v15;
    while (1)
    {
      unsigned int v20 = v19 / 0xADC8;
      unsigned int v21 = 48271 * (v19 % 0xADC8);
      v20 *= 3399;
      BOOL v9 = v21 >= v20;
      unsigned int v22 = v21 - v20;
      if (v9) {
        int v23 = 0;
      }
      else {
        int v23 = 0x7FFFFFFF;
      }
      unsigned int v19 = v23 + v22;
      unint64_t v24 = v19 - 1;
      if (v16 > v24)
      {
        uint64_t v25 = result << (v17 + 1);
        if (v17 >= 0x3F) {
          uint64_t v25 = 0;
        }
        uint64_t result = v25 + (v24 & v18);
        if (++v2 == v14) {
          break;
        }
      }
    }
    unsigned int *v15 = v19;
  }
  return result;
}

void std::vector<Phase::Vector<float,2ul>>::resize(void *a1, unint64_t a2)
{
  unint64_t v3 = (_DWORD *)*a1;
  uint64_t v4 = (char *)a1[1];
  unint64_t v5 = (uint64_t)&v4[-*a1] >> 3;
  if (a2 <= v5)
  {
    if (a2 >= v5) {
      return;
    }
    unsigned int v20 = (char *)&v3[2 * a2];
    goto LABEL_15;
  }
  unint64_t v6 = a2 - v5;
  uint64_t v7 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2];
  if (a2 - v5 <= (v8 - (uint64_t)v4) >> 3)
  {
    bzero(v4, 8 * v6);
    unsigned int v20 = &v4[8 * v6];
LABEL_15:
    a1[1] = v20;
    return;
  }
  if (a2 >> 61) {
    std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v9 = v8 - (void)v3;
  uint64_t v10 = v9 >> 2;
  if (v9 >> 2 <= a2) {
    uint64_t v10 = a2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v11 = v10;
  }
  unint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v7, v11);
  uint64_t v13 = (_DWORD *)*a1;
  unint64_t v14 = (_DWORD *)a1[1];
  uint64_t v15 = &v12[8 * v5];
  unint64_t v17 = &v12[8 * v16];
  bzero(v15, 8 * v6);
  int v18 = &v15[8 * v6];
  while (v14 != v13)
  {
    int v19 = *(v14 - 2);
    v14 -= 2;
    *((_DWORD *)v15 - 2) = v19;
    v15 -= 8;
    *((_DWORD *)v15 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v14[1];
  }
  *a1 = v15;
  a1[1] = v18;
  a1[2] = v17;
  if (v13)
  {
    operator delete(v13);
  }
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned int>::__vallocate[abi:ne180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_221F334C4(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SubmixRoutingOutput>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x28uLL);
  *uint64_t i = 0;
  i[1] = v5;
  i[2] = *a3;
  i[3] = -1;
  i[4] = 0;
  float v12 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v13 = a1[8];
  if (v7 && (float)(v13 * (float)v7) >= v12)
  {
    unint64_t v5 = v3;
    goto LABEL_64;
  }
  BOOL v14 = 1;
  if (v7 >= 3) {
    BOOL v14 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v15 = v14 | (2 * v7);
  unint64_t v16 = vcvtps_u32_f32(v12 / v13);
  if (v15 <= v16) {
    int8x8_t prime = (int8x8_t)v16;
  }
  else {
    int8x8_t prime = (int8x8_t)v15;
  }
  if (*(void *)&prime == 1)
  {
    int8x8_t prime = (int8x8_t)2;
  }
  else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
  {
    int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (*(void *)&prime <= v7)
  {
    if (*(void *)&prime >= v7) {
      goto LABEL_60;
    }
    unint64_t v24 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
    {
      unint64_t v24 = std::__next_prime(v24);
    }
    else
    {
      uint64_t v26 = 1 << -(char)__clz(v24 - 1);
      if (v24 >= 2) {
        unint64_t v24 = v26;
      }
    }
    if (*(void *)&prime <= v24) {
      int8x8_t prime = (int8x8_t)v24;
    }
    if (*(void *)&prime >= v7)
    {
      unint64_t v7 = *((void *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(void *)&prime)
    {
      float v33 = *(void **)a1;
      *(void *)a1 = 0;
      if (v33) {
        operator delete(v33);
      }
      unint64_t v7 = 0;
      *((void *)a1 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(void *)&prime >> 61) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  int v18 = operator new(8 * *(void *)&prime);
  int v19 = *(void **)a1;
  *(void *)a1 = v18;
  if (v19) {
    operator delete(v19);
  }
  uint64_t v20 = 0;
  *((int8x8_t *)a1 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = prime;
  do
    *(void *)(*(void *)a1 + 8 * v20++) = 0;
  while (*(void *)&prime != v20);
  unsigned int v21 = (void *)*((void *)a1 + 2);
  if (v21)
  {
    unint64_t v22 = v21[1];
    uint8x8_t v23 = (uint8x8_t)vcnt_s8(prime);
    v23.i16[0] = vaddlv_u8(v23);
    if (v23.u32[0] > 1uLL)
    {
      if (v22 >= *(void *)&prime) {
        v22 %= *(void *)&prime;
      }
    }
    else
    {
      v22 &= *(void *)&prime - 1;
    }
    *(void *)(*(void *)a1 + 8 * v22) = a1 + 4;
    BOOL v27 = (void *)*v21;
    if (*v21)
    {
      do
      {
        unint64_t v28 = v27[1];
        if (v23.u32[0] > 1uLL)
        {
          if (v28 >= *(void *)&prime) {
            v28 %= *(void *)&prime;
          }
        }
        else
        {
          v28 &= *(void *)&prime - 1;
        }
        if (v28 != v22)
        {
          if (!*(void *)(*(void *)a1 + 8 * v28))
          {
            *(void *)(*(void *)a1 + 8 * v28) = v21;
            goto LABEL_56;
          }
          *unsigned int v21 = *v27;
          *BOOL v27 = **(void **)(*(void *)a1 + 8 * v28);
          **(void **)(*(void *)a1 + 8 * v28) = v27;
          BOOL v27 = v21;
        }
        unint64_t v28 = v22;
LABEL_56:
        unsigned int v21 = v27;
        BOOL v27 = (void *)*v27;
        unint64_t v22 = v28;
      }
      while (v27);
    }
  }
  unint64_t v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  float v29 = *(void **)a1;
  double v30 = *(void **)(*(void *)a1 + 8 * v5);
  if (v30)
  {
    *uint64_t i = *v30;
LABEL_72:
    *double v30 = i;
    goto LABEL_73;
  }
  *uint64_t i = *((void *)a1 + 2);
  *((void *)a1 + 2) = i;
  v29[v5] = a1 + 4;
  if (*i)
  {
    unint64_t v31 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v31 >= v7) {
        v31 %= v7;
      }
    }
    else
    {
      v31 &= v7 - 1;
    }
    double v30 = (void *)(*(void *)a1 + 8 * v31);
    goto LABEL_72;
  }
LABEL_73:
  ++*((void *)a1 + 3);
  return i;
}

void sub_221F338C0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>,false>(_DWORD *a1, unsigned int *i, uint64_t a3, unsigned int *a4, uint64_t **a5, uint64_t a6, char a7)
{
  do
  {
    BOOL v14 = i;
    while (2)
    {
      while (2)
      {
        uint64_t v112 = (uint64_t)a1;
        uint64_t v15 = (uint64_t)a1;
        for (uint64_t i = v14; ; uint64_t i = v28)
        {
          uint64_t v16 = (char *)i - (char *)a4;
          unint64_t v17 = i - a4;
          if (v8 || !v7)
          {
            switch(v17)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                uint64_t v47 = *a4;
                uint64_t v48 = *(i - 1);
                if (*(float *)(**a5 + 8 * v47 + 4) < *(float *)(**a5 + 8 * v48 + 4))
                {
                  *(i - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v47;
                  *a4 = v48;
                }
                break;
              case 3uLL:
                uint64_t v49 = **a5;
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v112, (uint64_t)i, (uint64_t)(i - 1), (uint64_t)(i - 1), a3, (uint64_t)(a4 + 1), v49);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v112, (uint64_t)i, (uint64_t)(i - 1), (uint64_t)(i - 1), (uint64_t)(i - 2), (uint64_t)(i - 2), a3, (uint64_t)(a4 + 1), a5);
                break;
              case 5uLL:
                char v50 = i - 1;
                float v51 = i - 2;
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v112, (uint64_t)i, (uint64_t)(i - 1), (uint64_t)(i - 1), (uint64_t)(i - 2), (uint64_t)(i - 2), (uint64_t)(i - 3), (uint64_t)(i - 3), a5);
                uint64_t v52 = *a4;
                uint64_t v53 = *(i - 4);
                uint64_t v54 = **a5;
                if (*(float *)(v54 + 8 * v52 + 4) < *(float *)(v54 + 8 * v53 + 4))
                {
                  *(i - 4) = v52;
                  *a4 = v53;
                  uint64_t v55 = *(i - 4);
                  uint64_t v56 = *(i - 3);
                  float v57 = *(float *)(v54 + 8 * v55 + 4);
                  if (v57 < *(float *)(v54 + 8 * v56 + 4))
                  {
                    *(i - 4) = v56;
                    *(i - 3) = v55;
                    uint64_t v58 = *(i - 2);
                    if (v57 < *(float *)(v54 + 8 * v58 + 4))
                    {
                      unsigned int *v51 = v55;
                      *(i - 3) = v58;
                      uint64_t v59 = *v50;
                      if (v57 < *(float *)(v54 + 8 * v59 + 4))
                      {
                        unsigned int *v50 = v55;
                        unsigned int *v51 = v59;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v16 <= 95)
          {
            if (a7)
            {
              if (i != a4)
              {
                unint64_t v60 = i - 1;
                if (i - 1 != a4)
                {
                  uint64_t v61 = 0;
                  uint64_t v62 = **a5;
                  float v63 = i - 1;
                  do
                  {
                    unsigned int v65 = *--v63;
                    unsigned int v64 = v65;
                    uint64_t v66 = *v60;
                    float v67 = *(float *)(v62 + 8 * v65 + 4);
                    if (v67 < *(float *)(v62 + 8 * v66 + 4))
                    {
                      uint64_t v68 = v61;
                      do
                      {
                        uint64_t v69 = (char *)i + v68;
                        *(unsigned int *)((char *)i + v68 - 8) = v66;
                        if (!v68) {
                          break;
                        }
                        uint64_t v66 = *(unsigned int *)((char *)i + v68);
                        v68 += 4;
                      }
                      while (v67 < *(float *)(v62 + 8 * v66 + 4));
                      *((_DWORD *)v69 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v64;
                    }
                    v61 -= 4;
                    unint64_t v60 = v63;
                  }
                  while (v63 != a4);
                }
              }
            }
            else if (i != a4)
            {
              uint64_t v102 = i - 1;
              if (i - 1 != a4)
              {
                uint64_t v103 = **a5;
                unsigned int v104 = i - 2;
                unint64_t v105 = i - 1;
                do
                {
                  unsigned int v107 = *--v105;
                  unsigned int v106 = v107;
                  uint64_t v108 = *v102;
                  float v109 = *(float *)(v103 + 8 * v107 + 4);
                  if (v109 < *(float *)(v103 + 8 * v108 + 4))
                  {
                    uint64_t v110 = v104;
                    do
                    {
                      *uint64_t v110 = v108;
                      uint64_t v108 = v110[2];
                      ++v110;
                    }
                    while (v109 < *(float *)(v103 + 8 * v108 + 4));
                    *uint64_t v110 = v106;
                  }
                  --v104;
                  uint64_t v102 = v105;
                }
                while (v105 != a4);
              }
            }
            return;
          }
          if (!a6)
          {
            if (i != a4)
            {
              int64_t v70 = (v17 - 2) >> 1;
              int64_t v71 = v70;
              do
              {
                int64_t v72 = v71;
                uint64_t v73 = 4 * v71;
                if (v70 >= v73 >> 2)
                {
                  uint64_t v74 = v73 >> 1;
                  uint64_t v75 = v74 | 1;
                  uint64_t v76 = &i[-(v74 | 1)];
                  uint64_t v77 = v74 + 2;
                  uint64_t v78 = **a5;
                  if (v77 < (uint64_t)v17
                    && *(float *)(v78 + 8 * *(v76 - 1) + 4) < *(float *)(v78 + 8 * *(v76 - 2) + 4))
                  {
                    --v76;
                    uint64_t v75 = v77;
                  }
                  int32x2_t v79 = &i[-v72];
                  uint64_t v80 = *(v76 - 1);
                  uint64_t v81 = *(v79 - 1);
                  float v82 = *(float *)(v78 + 8 * v81 + 4);
                  if (*(float *)(v78 + 8 * v80 + 4) >= v82)
                  {
                    do
                    {
                      *(v79 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v80;
                      int32x2_t v79 = v76;
                      if (v70 < v75) {
                        break;
                      }
                      uint64_t v83 = 2 * v75;
                      uint64_t v75 = (2 * v75) | 1;
                      uint64_t v76 = &i[-v75];
                      uint64_t v84 = v83 + 2;
                      if (v84 < (uint64_t)v17
                        && *(float *)(v78 + 8 * *(v76 - 1) + 4) < *(float *)(v78 + 8 * *(v76 - 2) + 4))
                      {
                        --v76;
                        uint64_t v75 = v84;
                      }
                      uint64_t v80 = *(v76 - 1);
                    }
                    while (*(float *)(v78 + 8 * v80 + 4) >= v82);
                    *(v79 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v81;
                  }
                }
                int64_t v71 = v72 - 1;
              }
              while (v72);
              uint64_t v85 = (unint64_t)v16 >> 2;
              do
              {
                uint64_t v86 = 0;
                unsigned int v87 = *(i - 1);
                float v88 = *a5;
                float v89 = i;
                do
                {
                  unint64_t v90 = v89;
                  v89 += ~v86;
                  uint64_t v91 = 2 * v86;
                  uint64_t v86 = (2 * v86) | 1;
                  uint64_t v92 = v91 + 2;
                  if (v92 < v85 && *(float *)(*v88 + 8 * *(v89 - 1) + 4) < *(float *)(*v88 + 8 * *(v89 - 2) + 4))
                  {
                    --v89;
                    uint64_t v86 = v92;
                  }
                  *(v90 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v89 - 1);
                }
                while (v86 <= (uint64_t)((unint64_t)(v85 - 2) >> 1));
                float v93 = (char *)(v89 - 1);
                if (v89 == a4 + 1)
                {
                  *(_DWORD *)float v93 = v87;
                }
                else
                {
                  *(_DWORD *)float v93 = *a4;
                  *a4 = v87;
                  if ((char *)i - v93 >= 5)
                  {
                    unint64_t v94 = (((unint64_t)((char *)i - v93) >> 2) - 2) >> 1;
                    unint64_t v95 = &i[-v94];
                    uint64_t v96 = *(v95 - 1);
                    uint64_t v97 = *(unsigned int *)v93;
                    uint64_t v98 = *v88;
                    float v99 = *(float *)(v98 + 8 * v97 + 4);
                    if (*(float *)(v98 + 8 * v96 + 4) < v99)
                    {
                      do
                      {
                        uint64_t v100 = v95;
                        *(v89 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v96;
                        if (!v94) {
                          break;
                        }
                        unint64_t v94 = (v94 - 1) >> 1;
                        unint64_t v95 = &i[-v94];
                        uint64_t v96 = *(v95 - 1);
                        float v89 = v100;
                      }
                      while (*(float *)(v98 + 8 * v96 + 4) < v99);
                      *(v100 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v97;
                    }
                  }
                }
                ++a4;
              }
              while (v85-- > 2);
            }
            return;
          }
          unint64_t v18 = v17 >> 1;
          uint64_t v19 = (uint64_t)&i[-(v17 >> 1)];
          uint64_t v20 = **a5;
          if ((unint64_t)v16 >= 0x201)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v15, (uint64_t)i, (uint64_t)&i[-(v17 >> 1)], (uint64_t)&i[-(v17 >> 1)], (uint64_t)(a4 + 1), (uint64_t)(a4 + 1), v20);
            uint64_t v21 = (uint64_t)&i[1 - v18];
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>((uint64_t)(i - 1), (uint64_t)(i - 1), v21, v21, (uint64_t)(a4 + 2), (uint64_t)(a4 + 2), **a5);
            uint64_t v22 = (uint64_t)&i[~v18];
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>((uint64_t)(i - 2), (uint64_t)(i - 2), v22, v22, (uint64_t)(a4 + 3), (uint64_t)(a4 + 3), **a5);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v21, v21, v19, v19, v22, v22, **a5);
            int v23 = *(i - 1);
            *(i - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(v19 - 4);
            *(_DWORD *)(v19 - 4) = v23;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>((uint64_t)&i[-(v17 >> 1)], (uint64_t)&i[-(v17 >> 1)], v15, (uint64_t)i, (uint64_t)(a4 + 1), (uint64_t)(a4 + 1), v20);
          }
          --a6;
          if (a7) {
            break;
          }
          uint64_t v24 = *(i - 1);
          uint64_t v25 = **a5;
          float v26 = *(float *)(v25 + 8 * v24 + 4);
          if (*(float *)(v25 + 8 * *i + 4) < v26) {
            goto LABEL_31;
          }
          if (v26 >= *(float *)(v25 + 8 * *a4 + 4))
          {
            double v30 = i - 1;
            do
            {
              unint64_t v28 = v30;
              if (v30 <= a4) {
                break;
              }
              --v30;
            }
            while (v26 >= *(float *)(v25 + 8 * *(v28 - 1) + 4));
          }
          else
          {
            BOOL v27 = i;
            do
            {
              unint64_t v28 = v27 - 1;
              float v29 = *(float *)(v25 + 8 * *(v27 - 2) + 4);
              --v27;
            }
            while (v26 >= v29);
          }
          unint64_t v31 = a4;
          if (v28 > a4)
          {
            unint64_t v31 = a4;
            do
              unsigned int v32 = *v31++;
            while (v26 < *(float *)(v25 + 8 * v32 + 4));
          }
          while (v31 < v28)
          {
            unsigned int v33 = *(v28 - 1);
            *(v28 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v31 - 1);
            *(v31 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v33;
            do
            {
              uint64_t v34 = *(v28 - 2);
              --v28;
            }
            while (v26 >= *(float *)(v25 + 8 * v34 + 4));
            do
              unsigned int v35 = *v31++;
            while (v26 < *(float *)(v25 + 8 * v35 + 4));
          }
          BOOL v7 = v28 + 1 >= i;
          BOOL v8 = v28 + 1 == i;
          if (v28 + 1 != i) {
            *(i - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *v28;
          }
          a7 = 0;
          *unint64_t v28 = v24;
        }
        uint64_t v24 = *(i - 1);
        uint64_t v25 = **a5;
        float v26 = *(float *)(v25 + 8 * v24 + 4);
LABEL_31:
        uint64_t v36 = 0;
        do
        {
          float v37 = *(float *)(v25 + 8 * i[v36 - 2] + 4);
          --v36;
        }
        while (v37 < v26);
        float v38 = &i[v36];
        float v39 = a4;
        if (v36 == -1)
        {
          float v39 = a4;
          do
          {
            if (v39 >= v38) {
              break;
            }
            unsigned int v41 = *v39++;
          }
          while (*(float *)(v25 + 8 * v41 + 4) >= v26);
        }
        else
        {
          do
            unsigned int v40 = *v39++;
          while (*(float *)(v25 + 8 * v40 + 4) >= v26);
        }
        BOOL v14 = &i[v36];
        if (v39 < v38)
        {
          double v42 = v39;
          do
          {
            unsigned int v43 = *(v14 - 1);
            *(v14 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v42 - 1);
            *(v42 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v43;
            do
            {
              uint64_t v44 = *(v14 - 2);
              --v14;
            }
            while (*(float *)(v25 + 8 * v44 + 4) < v26);
            do
              unsigned int v45 = *v42++;
            while (*(float *)(v25 + 8 * v45 + 4) >= v26);
          }
          while (v42 < v14);
        }
        if (v14 + 1 != i) {
          *(i - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *v14;
        }
        unsigned int *v14 = v24;
        if (v39 < v38)
        {
LABEL_50:
          std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>,false>(v15, i, v14 + 1, v14 + 1, a5, a6, a7 & 1);
          a7 = 0;
          a1 = v14 + 1;
          continue;
        }
        break;
      }
      char v46 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v15, (uint64_t)i, (uint64_t)(v14 + 1), v14 + 1, a5);
      if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>((uint64_t)v14, (uint64_t)v14, a3, a4, a5))
      {
        a1 = v14 + 1;
        if (v46) {
          continue;
        }
        goto LABEL_50;
      }
      break;
    }
    a3 = (uint64_t)(v14 + 1);
    a4 = v14 + 1;
    a1 = (_DWORD *)v112;
  }
  while ((v46 & 1) == 0);
}

void std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = *(unsigned int *)(a4 - 4);
  uint64_t v8 = *(unsigned int *)(a2 - 4);
  float v9 = *(float *)(a7 + 8 * v7 + 4);
  float v10 = *(float *)(a7 + 8 * v8 + 4);
  uint64_t v11 = *(unsigned int *)(a6 - 4);
  float v12 = *(float *)(a7 + 8 * v11 + 4);
  if (v9 >= v10)
  {
    if (v12 < v9)
    {
      *(_DWORD *)(a4 - 4) = v11;
      *(_DWORD *)(a6 - 4) = v7;
      uint64_t v13 = *(unsigned int *)(a4 - 4);
      uint64_t v14 = *(unsigned int *)(a2 - 4);
      if (*(float *)(a7 + 8 * v13 + 4) < *(float *)(a7 + 8 * v14 + 4))
      {
        *(_DWORD *)(a2 - 4) = v13;
        *(_DWORD *)(a4 - 4) = v14;
      }
    }
  }
  else
  {
    if (v12 >= v9)
    {
      *(_DWORD *)(a2 - 4) = v7;
      *(_DWORD *)(a4 - 4) = v8;
      uint64_t v15 = *(unsigned int *)(a6 - 4);
      if (*(float *)(a7 + 8 * v15 + 4) >= v10) {
        return;
      }
      *(_DWORD *)(a4 - 4) = v15;
    }
    else
    {
      *(_DWORD *)(a2 - 4) = v11;
    }
    *(_DWORD *)(a6 - 4) = v8;
  }
}

uint64_t std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t **a5)
{
  char v8 = 1;
  switch((a2 - (uint64_t)a4) >> 2)
  {
    case 0:
    case 1:
      return v8 & 1;
    case 2:
      uint64_t v9 = *a4;
      uint64_t v10 = *(unsigned int *)(a2 - 4);
      if (*(float *)(**a5 + 8 * v9 + 4) < *(float *)(**a5 + 8 * v10 + 4))
      {
        *(_DWORD *)(a2 - 4) = v9;
        *a4 = v10;
      }
      goto LABEL_22;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a2 - 4, a2 - 4, a3, (uint64_t)(a4 + 1), **a5);
      goto LABEL_22;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a2 - 4, a2 - 4, a2 - 8, a2 - 8, a3, (uint64_t)(a4 + 1), a5);
      goto LABEL_22;
    case 5:
      int v23 = (_DWORD *)(a2 - 4);
      uint64_t v24 = (_DWORD *)(a2 - 8);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a2 - 4, a2 - 4, a2 - 8, a2 - 8, a2 - 12, a2 - 12, a5);
      uint64_t v25 = *a4;
      uint64_t v26 = *(unsigned int *)(a2 - 16);
      uint64_t v27 = **a5;
      if (*(float *)(v27 + 8 * v25 + 4) < *(float *)(v27 + 8 * v26 + 4))
      {
        *(_DWORD *)(a2 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v25;
        *a4 = v26;
        uint64_t v28 = *(unsigned int *)(a2 - 16);
        uint64_t v29 = *(unsigned int *)(a2 - 12);
        float v30 = *(float *)(v27 + 8 * v28 + 4);
        if (v30 < *(float *)(v27 + 8 * v29 + 4))
        {
          *(_DWORD *)(a2 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v29;
          *(_DWORD *)(a2 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v28;
          uint64_t v31 = *(unsigned int *)(a2 - 8);
          if (v30 < *(float *)(v27 + 8 * v31 + 4))
          {
            *uint64_t v24 = v28;
            *(_DWORD *)(a2 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v31;
            uint64_t v32 = *v23;
            if (v30 < *(float *)(v27 + 8 * v32 + 4))
            {
              *int v23 = v28;
              *uint64_t v24 = v32;
            }
          }
        }
      }
LABEL_22:
      char v8 = 1;
      return v8 & 1;
    default:
      uint64_t v11 = a2 - 8;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a2 - 4, a2 - 4, a2 - 8, a2 - 8, **a5);
      uint64_t v13 = (_DWORD *)(a2 - 12);
      if ((_DWORD *)(a2 - 12) == a4) {
        goto LABEL_15;
      }
      int v12 = 0;
      uint64_t v14 = **a5;
      uint64_t v15 = (_DWORD *)(a2 - 12);
      break;
  }
  while (1)
  {
    unsigned int v17 = *--v15;
    unsigned int v16 = v17;
    float v18 = *(float *)(v14 + 8 * v17 + 4);
    if (v18 < *(float *)(v14 + 8 * *(unsigned int *)(v11 - 4) + 4))
    {
      uint64_t v19 = v13;
      while (1)
      {
        *(v19 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *v19;
        if (v19 + 1 == (_DWORD *)a2) {
          break;
        }
        uint64_t v20 = v19 + 1;
        float v21 = *(float *)(v14 + 8 * v19[1] + 4);
        ++v19;
        if (v18 >= v21) {
          goto LABEL_13;
        }
      }
      uint64_t v20 = (_DWORD *)a2;
LABEL_13:
      *(v20 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v16;
      if (++v12 == 8) {
        break;
      }
    }
    uint64_t v11 = (uint64_t)v13;
    uint64_t v13 = v15;
    if (v15 == a4)
    {
LABEL_15:
      char v22 = 1;
      goto LABEL_25;
    }
  }
  char v22 = 0;
  LOBYTE(vstd::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v15 == a4;
LABEL_25:
  char v8 = v22 | v12;
  return v8 & 1;
}

void std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t **a9)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters(std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource> const&,Phase::Handle64,unsigned int,Phase::SpatialModeler::RayTracerState const&,double,unsigned long,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a3, a4, a5, a6, **a9);
  uint64_t v13 = *(unsigned int *)(a8 - 4);
  uint64_t v14 = *(unsigned int *)(a6 - 4);
  uint64_t v15 = **a9;
  if (*(float *)(v15 + 8 * v13 + 4) < *(float *)(v15 + 8 * v14 + 4))
  {
    *(_DWORD *)(a6 - 4) = v13;
    *(_DWORD *)(a8 - 4) = v14;
    uint64_t v16 = *(unsigned int *)(a6 - 4);
    uint64_t v17 = *(unsigned int *)(a4 - 4);
    if (*(float *)(v15 + 8 * v16 + 4) < *(float *)(v15 + 8 * v17 + 4))
    {
      *(_DWORD *)(a4 - 4) = v16;
      *(_DWORD *)(a6 - 4) = v17;
      uint64_t v18 = *(unsigned int *)(a4 - 4);
      uint64_t v19 = *(unsigned int *)(a2 - 4);
      if (*(float *)(v15 + 8 * v18 + 4) < *(float *)(v15 + 8 * v19 + 4))
      {
        *(_DWORD *)(a2 - 4) = v18;
        *(_DWORD *)(a4 - 4) = v19;
      }
    }
  }
}

void std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>,false>(_DWORD *a1, unsigned int *i, uint64_t a3, unsigned int *a4, uint64_t **a5, uint64_t a6, uint64_t a7)
{
  uint64_t v11 = a5;
  do
  {
    uint64_t v14 = (uint64_t)(a4 + 1);
    uint64_t v15 = i;
    while (2)
    {
      while (2)
      {
        uint64_t v115 = (uint64_t)a1;
        uint64_t v16 = (uint64_t)a1;
        for (uint64_t i = v15; ; uint64_t i = v34)
        {
          uint64_t v17 = (char *)i - (char *)a4;
          unint64_t v18 = i - a4;
          if (v8 || !v7)
          {
            switch(v18)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                unsigned int v52 = *(i - 1);
                if (*(float *)(**v11 + 40 * *a4 + 24) < *(float *)(**v11 + 40 * v52 + 24))
                {
                  *(i - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *a4;
                  *a4 = v52;
                }
                break;
              case 3uLL:
                uint64_t v53 = **v11;
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v115, (uint64_t)i, (uint64_t)(i - 1), (uint64_t)(i - 1), a3, (uint64_t)(a4 + 1), v53);
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v115, (uint64_t)i, (uint64_t)(i - 1), (uint64_t)(i - 1), (uint64_t)(i - 2), (uint64_t)(i - 2), a3, (uint64_t)(a4 + 1), v11);
                break;
              case 5uLL:
                uint64_t v54 = i - 1;
                uint64_t v55 = i - 2;
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v115, (uint64_t)i, (uint64_t)(i - 1), (uint64_t)(i - 1), (uint64_t)(i - 2), (uint64_t)(i - 2), (uint64_t)(i - 3), (uint64_t)(i - 3), v11);
                unsigned int v56 = *(i - 4);
                uint64_t v57 = **v11;
                if (*(float *)(v57 + 40 * *a4 + 24) < *(float *)(v57 + 40 * v56 + 24))
                {
                  *(i - 4) = *a4;
                  *a4 = v56;
                  unsigned int v58 = *(i - 4);
                  unsigned int v59 = *(i - 3);
                  float v60 = *(float *)(v57 + 40 * v58 + 24);
                  if (v60 < *(float *)(v57 + 40 * v59 + 24))
                  {
                    *(i - 4) = v59;
                    *(i - 3) = v58;
                    unsigned int v61 = *(i - 2);
                    if (v60 < *(float *)(v57 + 40 * v61 + 24))
                    {
                      *uint64_t v55 = v58;
                      *(i - 3) = v61;
                      unsigned int v62 = *v54;
                      if (v60 < *(float *)(v57 + 40 * *v54 + 24))
                      {
                        *uint64_t v54 = v58;
                        *uint64_t v55 = v62;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v17 <= 95)
          {
            if (a7)
            {
              if (i != a4)
              {
                float v63 = i - 1;
                if (i - 1 != a4)
                {
                  uint64_t v64 = 0;
                  uint64_t v65 = **v11;
                  uint64_t v66 = i - 1;
                  do
                  {
                    unsigned int v68 = *--v66;
                    unsigned int v67 = v68;
                    unsigned int v69 = *v63;
                    float v70 = *(float *)(v65 + 40 * v68 + 24);
                    if (v70 < *(float *)(v65 + 40 * v69 + 24))
                    {
                      uint64_t v71 = v64;
                      do
                      {
                        int64_t v72 = (char *)i + v71;
                        *(unsigned int *)((char *)i + v71 - 8) = v69;
                        if (!v71) {
                          break;
                        }
                        unsigned int v69 = *(unsigned int *)((char *)i + v71);
                        v71 += 4;
                      }
                      while (v70 < *(float *)(v65 + 40 * v69 + 24));
                      *((_DWORD *)v72 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v67;
                    }
                    v64 -= 4;
                    float v63 = v66;
                  }
                  while (v66 != a4);
                }
              }
            }
            else if (i != a4)
            {
              unint64_t v105 = i - 1;
              if (i - 1 != a4)
              {
                uint64_t v106 = **v11;
                unsigned int v107 = i - 2;
                uint64_t v108 = i - 1;
                do
                {
                  unsigned int v110 = *--v108;
                  unsigned int v109 = v110;
                  unsigned int v111 = *v105;
                  float v112 = *(float *)(v106 + 40 * v110 + 24);
                  if (v112 < *(float *)(v106 + 40 * v111 + 24))
                  {
                    double v113 = v107;
                    do
                    {
                      *double v113 = v111;
                      unsigned int v111 = v113[2];
                      ++v113;
                    }
                    while (v112 < *(float *)(v106 + 40 * v111 + 24));
                    *double v113 = v109;
                  }
                  --v107;
                  unint64_t v105 = v108;
                }
                while (v108 != a4);
              }
            }
            return;
          }
          if (!a6)
          {
            if (i != a4)
            {
              int64_t v73 = (v18 - 2) >> 1;
              int64_t v74 = v73;
              do
              {
                int64_t v75 = v74;
                uint64_t v76 = 4 * v74;
                if (v73 >= v76 >> 2)
                {
                  uint64_t v77 = v76 >> 1;
                  uint64_t v78 = v77 | 1;
                  int32x2_t v79 = &i[-(v77 | 1)];
                  uint64_t v80 = v77 + 2;
                  uint64_t v81 = **v11;
                  if (v80 < (uint64_t)v18
                    && *(float *)(v81 + 40 * *(v79 - 1) + 24) < *(float *)(v81 + 40 * *(v79 - 2) + 24))
                  {
                    --v79;
                    uint64_t v78 = v80;
                  }
                  float v82 = &i[-v75];
                  unsigned int v83 = *(v79 - 1);
                  unsigned int v84 = *(v82 - 1);
                  float v85 = *(float *)(v81 + 40 * v84 + 24);
                  if (*(float *)(v81 + 40 * v83 + 24) >= v85)
                  {
                    do
                    {
                      *(v82 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v83;
                      float v82 = v79;
                      if (v73 < v78) {
                        break;
                      }
                      uint64_t v86 = 2 * v78;
                      uint64_t v78 = (2 * v78) | 1;
                      int32x2_t v79 = &i[-v78];
                      uint64_t v87 = v86 + 2;
                      if (v87 < (uint64_t)v18
                        && *(float *)(v81 + 40 * *(v79 - 1) + 24) < *(float *)(v81 + 40 * *(v79 - 2) + 24))
                      {
                        --v79;
                        uint64_t v78 = v87;
                      }
                      unsigned int v83 = *(v79 - 1);
                    }
                    while (*(float *)(v81 + 40 * v83 + 24) >= v85);
                    *(v82 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v84;
                  }
                }
                int64_t v74 = v75 - 1;
              }
              while (v75);
              uint64_t v88 = (unint64_t)v17 >> 2;
              do
              {
                uint64_t v89 = 0;
                unsigned int v90 = *(i - 1);
                uint64_t v91 = *v11;
                uint64_t v92 = i;
                do
                {
                  float v93 = v92;
                  v92 += ~v89;
                  uint64_t v94 = 2 * v89;
                  uint64_t v89 = (2 * v89) | 1;
                  uint64_t v95 = v94 + 2;
                  if (v95 < v88
                    && *(float *)(*v91 + 40 * *(v92 - 1) + 24) < *(float *)(*v91 + 40 * *(v92 - 2) + 24))
                  {
                    --v92;
                    uint64_t v89 = v95;
                  }
                  *(v93 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v92 - 1);
                }
                while (v89 <= (uint64_t)((unint64_t)(v88 - 2) >> 1));
                uint64_t v96 = v92 - 1;
                if (v92 == a4 + 1)
                {
                  *uint64_t v96 = v90;
                }
                else
                {
                  *uint64_t v96 = *a4;
                  *a4 = v90;
                  if ((char *)i - (char *)v96 >= 5)
                  {
                    unint64_t v97 = (((unint64_t)((char *)i - (char *)v96) >> 2) - 2) >> 1;
                    uint64_t v98 = &i[-v97];
                    unsigned int v99 = *(v98 - 1);
                    unsigned int v100 = *v96;
                    uint64_t v101 = *v91;
                    float v102 = *(float *)(v101 + 40 * v100 + 24);
                    if (*(float *)(v101 + 40 * v99 + 24) < v102)
                    {
                      do
                      {
                        uint64_t v103 = v98;
                        *(v92 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v99;
                        if (!v97) {
                          break;
                        }
                        unint64_t v97 = (v97 - 1) >> 1;
                        uint64_t v98 = &i[-v97];
                        unsigned int v99 = *(v98 - 1);
                        uint64_t v92 = v103;
                      }
                      while (*(float *)(v101 + 40 * v99 + 24) < v102);
                      *(v103 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v100;
                    }
                  }
                }
                ++a4;
              }
              while (v88-- > 2);
            }
            return;
          }
          unint64_t v19 = v18 >> 1;
          uint64_t v20 = (uint64_t)&i[-(v18 >> 1)];
          uint64_t v21 = **v11;
          if ((unint64_t)v17 >= 0x201)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v16, (uint64_t)i, (uint64_t)&i[-(v18 >> 1)], (uint64_t)&i[-(v18 >> 1)], v14, v14, v21);
            uint64_t v116 = a6;
            uint64_t v22 = a7;
            uint64_t v23 = v14;
            uint64_t v24 = v16;
            uint64_t v25 = (uint64_t)&i[1 - v19];
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>((uint64_t)(i - 1), (uint64_t)(i - 1), v25, v25, (uint64_t)(a4 + 2), (uint64_t)(a4 + 2), **v11);
            uint64_t v26 = (uint64_t)&i[~v19];
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>((uint64_t)(i - 2), (uint64_t)(i - 2), v26, v26, (uint64_t)(a4 + 3), (uint64_t)(a4 + 3), **v11);
            uint64_t v27 = v25;
            uint64_t v28 = v25;
            uint64_t v16 = v24;
            uint64_t v14 = v23;
            a7 = v22;
            a6 = v116;
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v27, v28, v20, v20, v26, v26, **v11);
            int v29 = *(i - 1);
            *(i - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(v20 - 4);
            *(_DWORD *)(v20 - 4) = v29;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>((uint64_t)&i[-(v18 >> 1)], (uint64_t)&i[-(v18 >> 1)], v16, (uint64_t)i, v14, v14, v21);
          }
          --a6;
          if (a7) {
            break;
          }
          unsigned int v30 = *(i - 1);
          uint64_t v11 = a5;
          uint64_t v31 = **a5;
          float v32 = *(float *)(v31 + 40 * v30 + 24);
          if (*(float *)(v31 + 40 * *i + 24) < v32) {
            goto LABEL_32;
          }
          if (v32 >= *(float *)(v31 + 40 * *a4 + 24))
          {
            uint64_t v36 = i - 1;
            do
            {
              uint64_t v34 = v36;
              if (v36 <= a4) {
                break;
              }
              --v36;
            }
            while (v32 >= *(float *)(v31 + 40 * *(v34 - 1) + 24));
          }
          else
          {
            unsigned int v33 = i;
            do
            {
              uint64_t v34 = v33 - 1;
              float v35 = *(float *)(v31 + 40 * *(v33 - 2) + 24);
              --v33;
            }
            while (v32 >= v35);
          }
          float v37 = a4;
          if (v34 > a4)
          {
            float v37 = a4;
            do
              unsigned int v38 = *v37++;
            while (v32 < *(float *)(v31 + 40 * v38 + 24));
          }
          while (v37 < v34)
          {
            unsigned int v39 = *(v34 - 1);
            *(v34 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v37 - 1);
            *(v37 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v39;
            do
            {
              unsigned int v40 = *(v34 - 2);
              --v34;
            }
            while (v32 >= *(float *)(v31 + 40 * v40 + 24));
            do
              unsigned int v41 = *v37++;
            while (v32 < *(float *)(v31 + 40 * v41 + 24));
          }
          BOOL v7 = v34 + 1 >= i;
          BOOL v8 = v34 + 1 == i;
          if (v34 + 1 != i) {
            *(i - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *v34;
          }
          a7 = 0;
          *uint64_t v34 = v30;
        }
        unsigned int v30 = *(i - 1);
        uint64_t v11 = a5;
        uint64_t v31 = **a5;
        float v32 = *(float *)(v31 + 40 * v30 + 24);
LABEL_32:
        uint64_t v42 = 0;
        do
        {
          float v43 = *(float *)(v31 + 40 * i[v42 - 2] + 24);
          --v42;
        }
        while (v43 < v32);
        uint64_t v44 = &i[v42];
        unsigned int v45 = a4;
        if (v42 == -1)
        {
          unsigned int v45 = a4;
          do
          {
            if (v45 >= v44) {
              break;
            }
            unsigned int v47 = *v45++;
          }
          while (*(float *)(v31 + 40 * v47 + 24) >= v32);
        }
        else
        {
          do
            unsigned int v46 = *v45++;
          while (*(float *)(v31 + 40 * v46 + 24) >= v32);
        }
        uint64_t v15 = &i[v42];
        if (v45 < v44)
        {
          uint64_t v48 = v45;
          do
          {
            unsigned int v49 = *(v15 - 1);
            *(v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v48 - 1);
            *(v48 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v49;
            do
            {
              unsigned int v50 = *(v15 - 2);
              --v15;
            }
            while (*(float *)(v31 + 40 * v50 + 24) < v32);
            do
              unsigned int v51 = *v48++;
            while (*(float *)(v31 + 40 * v51 + 24) >= v32);
          }
          while (v48 < v15);
        }
        if (v15 + 1 != i) {
          *(i - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *v15;
        }
        unsigned int *v15 = v30;
        if (v45 < v44)
        {
LABEL_51:
          std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>,false>(v16, i, v15 + 1, v15 + 1, v11, a6, a7 & 1);
          a7 = 0;
          a1 = v15 + 1;
          continue;
        }
        break;
      }
      char v117 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(v16, (uint64_t)i, (uint64_t)(v15 + 1), v15 + 1, v11);
      if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>((uint64_t)v15, (uint64_t)v15, a3, a4, v11))
      {
        a1 = v15 + 1;
        if (v117) {
          continue;
        }
        goto LABEL_51;
      }
      break;
    }
    a3 = (uint64_t)(v15 + 1);
    a4 = v15 + 1;
    a1 = (_DWORD *)v115;
  }
  while ((v117 & 1) == 0);
}

void std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unsigned int v7 = *(_DWORD *)(a4 - 4);
  unsigned int v8 = *(_DWORD *)(a2 - 4);
  float v9 = *(float *)(a7 + 40 * v7 + 24);
  float v10 = *(float *)(a7 + 40 * v8 + 24);
  unsigned int v11 = *(_DWORD *)(a6 - 4);
  float v12 = *(float *)(a7 + 40 * v11 + 24);
  if (v9 >= v10)
  {
    if (v12 < v9)
    {
      *(_DWORD *)(a4 - 4) = v11;
      *(_DWORD *)(a6 - 4) = v7;
      unsigned int v13 = *(_DWORD *)(a4 - 4);
      unsigned int v14 = *(_DWORD *)(a2 - 4);
      if (*(float *)(a7 + 40 * v13 + 24) < *(float *)(a7 + 40 * v14 + 24))
      {
        *(_DWORD *)(a2 - 4) = v13;
        *(_DWORD *)(a4 - 4) = v14;
      }
    }
  }
  else
  {
    if (v12 >= v9)
    {
      *(_DWORD *)(a2 - 4) = v7;
      *(_DWORD *)(a4 - 4) = v8;
      unsigned int v15 = *(_DWORD *)(a6 - 4);
      if (*(float *)(a7 + 40 * v15 + 24) >= v10) {
        return;
      }
      *(_DWORD *)(a4 - 4) = v15;
    }
    else
    {
      *(_DWORD *)(a2 - 4) = v11;
    }
    *(_DWORD *)(a6 - 4) = v8;
  }
}

uint64_t std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, uint64_t **a5)
{
  char v8 = 1;
  switch((a2 - (uint64_t)a4) >> 2)
  {
    case 0:
    case 1:
      return v8 & 1;
    case 2:
      unsigned int v9 = *(_DWORD *)(a2 - 4);
      if (*(float *)(**a5 + 40 * *a4 + 24) < *(float *)(**a5 + 40 * v9 + 24))
      {
        *(_DWORD *)(a2 - 4) = *a4;
        *a4 = v9;
      }
      goto LABEL_22;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a2 - 4, a2 - 4, a3, (uint64_t)(a4 + 1), **a5);
      goto LABEL_22;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a2 - 4, a2 - 4, a2 - 8, a2 - 8, a3, (uint64_t)(a4 + 1), a5);
      goto LABEL_22;
    case 5:
      uint64_t v22 = (unsigned int *)(a2 - 4);
      uint64_t v23 = (unsigned int *)(a2 - 8);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a2 - 4, a2 - 4, a2 - 8, a2 - 8, a2 - 12, a2 - 12, a5);
      unsigned int v24 = *(_DWORD *)(a2 - 16);
      uint64_t v25 = **a5;
      if (*(float *)(v25 + 40 * *a4 + 24) < *(float *)(v25 + 40 * v24 + 24))
      {
        *(_DWORD *)(a2 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *a4;
        *a4 = v24;
        unsigned int v26 = *(_DWORD *)(a2 - 16);
        unsigned int v27 = *(_DWORD *)(a2 - 12);
        float v28 = *(float *)(v25 + 40 * v26 + 24);
        if (v28 < *(float *)(v25 + 40 * v27 + 24))
        {
          *(_DWORD *)(a2 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v27;
          *(_DWORD *)(a2 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v26;
          unsigned int v29 = *(_DWORD *)(a2 - 8);
          if (v28 < *(float *)(v25 + 40 * v29 + 24))
          {
            *uint64_t v23 = v26;
            *(_DWORD *)(a2 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v29;
            unsigned int v30 = *v22;
            if (v28 < *(float *)(v25 + 40 * *v22 + 24))
            {
              *uint64_t v22 = v26;
              *uint64_t v23 = v30;
            }
          }
        }
      }
LABEL_22:
      char v8 = 1;
      return v8 & 1;
    default:
      uint64_t v10 = a2 - 8;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a2 - 4, a2 - 4, a2 - 8, a2 - 8, **a5);
      float v12 = (unsigned int *)(a2 - 12);
      if ((unsigned int *)(a2 - 12) == a4) {
        goto LABEL_15;
      }
      int v11 = 0;
      uint64_t v13 = **a5;
      unsigned int v14 = (unsigned int *)(a2 - 12);
      break;
  }
  while (1)
  {
    unsigned int v16 = *--v14;
    unsigned int v15 = v16;
    float v17 = *(float *)(v13 + 40 * v16 + 24);
    if (v17 < *(float *)(v13 + 40 * *(unsigned int *)(v10 - 4) + 24))
    {
      unint64_t v18 = v12;
      while (1)
      {
        *(v18 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *v18;
        if (v18 + 1 == (unsigned int *)a2) {
          break;
        }
        unint64_t v19 = v18 + 1;
        float v20 = *(float *)(v13 + 40 * v18[1] + 24);
        ++v18;
        if (v17 >= v20) {
          goto LABEL_13;
        }
      }
      unint64_t v19 = (_DWORD *)a2;
LABEL_13:
      *(v19 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v15;
      if (++v11 == 8) {
        break;
      }
    }
    uint64_t v10 = (uint64_t)v12;
    float v12 = v14;
    if (v14 == a4)
    {
LABEL_15:
      char v21 = 1;
      goto LABEL_25;
    }
  }
  char v21 = 0;
  LOBYTE(v1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v14 == a4;
LABEL_25:
  char v8 = v21 | v11;
  return v8 & 1;
}

void std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t **a9)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::ERClustering::GenerateClusterMetadataFromResults(unsigned long,Phase::SpatialModeler::SourcePreProcessData const&,std::vector<unsigned long long> const&,float,std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>> &,Phase::SpatialModeler::ClusteringResult &)::$_0 &,std::reverse_iterator<std::__wrap_iter<unsigned int *>>>(a1, a2, a3, a4, a5, a6, **a9);
  unsigned int v13 = *(_DWORD *)(a8 - 4);
  unsigned int v14 = *(_DWORD *)(a6 - 4);
  uint64_t v15 = **a9;
  if (*(float *)(v15 + 40 * v13 + 24) < *(float *)(v15 + 40 * v14 + 24))
  {
    *(_DWORD *)(a6 - 4) = v13;
    *(_DWORD *)(a8 - 4) = v14;
    unsigned int v16 = *(_DWORD *)(a6 - 4);
    unsigned int v17 = *(_DWORD *)(a4 - 4);
    if (*(float *)(v15 + 40 * v16 + 24) < *(float *)(v15 + 40 * v17 + 24))
    {
      *(_DWORD *)(a4 - 4) = v16;
      *(_DWORD *)(a6 - 4) = v17;
      unsigned int v18 = *(_DWORD *)(a4 - 4);
      unsigned int v19 = *(_DWORD *)(a2 - 4);
      if (*(float *)(v15 + 40 * v18 + 24) < *(float *)(v15 + 40 * v19 + 24))
      {
        *(_DWORD *)(a2 - 4) = v18;
        *(_DWORD *)(a4 - 4) = v19;
      }
    }
  }
}

void Phase::SpatialModeler::ExecuteEarlyReflectionDebugCallbacks(Phase::SpatialModeler *this, Phase::SpatialModeler::RayTracerState *a2, Phase::Geometry::System *a3, Phase::Geometry::SystemState *a4)
{
  if (!*((void *)a2 + 345)) {
    return;
  }
  if (*((void *)this + 2367) == *((void *)this + 2366)) {
    return;
  }
  uint64_t v6 = Phase::Geometry::SystemDebugger::GetFromSystem((uint64_t)a2);
  if (!v6) {
    return;
  }
  uint64_t v7 = *((void *)this + 2366);
  if (*((void *)this + 2367) == v7) {
    return;
  }
  unint64_t v8 = 0;
  unsigned int v9 = (void *)(v6 + 112);
  uint64_t v96 = (void *)(v6 + 112);
  unint64_t v97 = a3;
  while (1)
  {
    uint64_t v10 = (unint64_t *)(v7 + 56 * v8);
    v150[0] = *v10;
    int v11 = (void *)*v9;
    if (*v9) {
      break;
    }
    Phase::SpatialModeler::RayTracerState::GetSourceListenerResult(this, v150, (uint64_t)&v147);
LABEL_109:
    if (v149) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v149);
    }
    if (v148) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v148);
    }
    ++v8;
    uint64_t v7 = *((void *)this + 2366);
    if (v8 >= 0x6DB6DB6DB6DB6DB7 * ((*((void *)this + 2367) - v7) >> 3)) {
      return;
    }
  }
  uint64_t v98 = (uint64_t *)(v7 + 56 * v8);
  unint64_t v12 = v10[6];
  unsigned int v99 = (uint64_t *)(v10 + 6);
  unsigned int v13 = v9;
  unsigned int v14 = (void *)*v9;
  do
  {
    unint64_t v15 = v14[4];
    BOOL v16 = v15 >= v12;
    if (v15 >= v12) {
      unsigned int v17 = v14;
    }
    else {
      unsigned int v17 = v14 + 1;
    }
    if (v16) {
      unsigned int v13 = v14;
    }
    unsigned int v14 = (void *)*v17;
  }
  while (*v17);
  if (v13 == v9)
  {
    float v20 = 0;
  }
  else
  {
    unint64_t v18 = v13[4];
    unsigned int v19 = v13 + 5;
    if (v18 <= v12) {
      float v20 = v19;
    }
    else {
      float v20 = 0;
    }
  }
  unint64_t v21 = *((void *)this + 2822);
  uint64_t v22 = v9;
  do
  {
    unint64_t v23 = v11[4];
    BOOL v24 = v23 >= v21;
    if (v23 >= v21) {
      uint64_t v25 = v11;
    }
    else {
      uint64_t v25 = v11 + 1;
    }
    if (v24) {
      uint64_t v22 = v11;
    }
    int v11 = (void *)*v25;
  }
  while (*v25);
  uint64_t v101 = v20;
  if (v22 == v9)
  {
    unsigned int v100 = 0;
  }
  else
  {
    unint64_t v26 = v22[4];
    unsigned int v27 = v22 + 5;
    if (v26 <= v21) {
      float v28 = v27;
    }
    else {
      float v28 = 0;
    }
    unsigned int v100 = v28;
  }
  Phase::SpatialModeler::RayTracerState::GetSourceListenerResult(this, v150, (uint64_t)&v147);
  if (!v101 || !v101[13]) {
    goto LABEL_67;
  }
  uint64_t v118 = 0;
  uint64_t v119 = 0;
  uint64_t v120 = 0;
  uint64_t v122 = 0;
  uint64_t v123 = 0;
  uint64_t v121 = 0;
  unint64_t v126 = 0;
  unint64_t v127 = 0;
  uint64_t v125 = 0;
  long long v129 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v140 = 0u;
  long long v145 = 0u;
  long long v146 = 0u;
  long long v143 = 0u;
  long long v144 = 0u;
  long long v141 = 0u;
  long long v142 = 0u;
  uint64_t v115 = 0;
  uint64_t v116 = 0;
  uint64_t v117 = 0;
  uint64_t v29 = *((void *)this + 2822);
  if (*((_DWORD *)a3 + 34) <= v29) {
    goto LABEL_115;
  }
  uint64_t v30 = *((void *)a3 + 15);
  if (*(_DWORD *)(v30 + 24 * v29 + 20) != HIDWORD(v29)) {
    goto LABEL_115;
  }
  uint64_t v31 = *(void *)(v30 + 24 * *((void *)this + 2822));
  if (!v31 || *(_DWORD *)v31 != 2) {
    goto LABEL_115;
  }
  uint64_t v113 = *(void *)(v31 + 64);
  int v114 = *(_DWORD *)(v31 + 72);
  unint64_t v126 = 0;
  EarlyReflections = (uint64_t *)Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(v147, *((_DWORD *)this + 22), 0, 343.0);
  unsigned int v110 = 0;
  unsigned int v111 = 0;
  uint64_t v112 = 0;
  std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection*,Phase::SpatialModeler::AudibleEarlyReflection*>(&v110, *EarlyReflections, EarlyReflections[1], 0x8E38E38E38E38E39 * ((EarlyReflections[1] - *EarlyReflections) >> 5));
  LODWORD(v10std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(void *)((char *)&v106 + 4) = 0;
  uint64_t v108 = 0;
  uint64_t v109 = 0;
  unsigned int v107 = 0;
  if (v111 != v110)
  {
    *(void *)&long long v106 = *(void *)((char *)v110 + 220);
    DWORD2(v10std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v110 + 57);
    uint64_t v108 = std::vector<Phase::Vector<float,3ul>>::__push_back_slow_path<Phase::Vector<float,3ul> const&>((uint64_t *)&v107, (_DWORD *)v110 + 58);
    unint64_t v33 = v126;
    if (v126 < v127) {
      goto LABEL_45;
    }
LABEL_46:
    uint64_t v36 = std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__push_back_slow_path<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource const&>(&v125, (uint64_t)&v106);
    goto LABEL_47;
  }
  uint64_t v34 = v7 + 56 * v8;
  int v35 = *(_DWORD *)(v34 + 32);
  *(void *)&long long v106 = *(void *)(v34 + 24);
  DWORD2(v10std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v35;
  uint64_t v108 = std::vector<Phase::Vector<float,3ul>>::__push_back_slow_path<Phase::Vector<float,3ul> const&>((uint64_t *)&v107, &v113);
  unint64_t v33 = v126;
  if (v126 >= v127) {
    goto LABEL_46;
  }
LABEL_45:
  std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__construct_one_at_end[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource const&>((uint64_t)&v125, (uint64_t)&v106);
  uint64_t v36 = v33 + 40;
LABEL_47:
  unint64_t v126 = v36;
  float v37 = (char *)v110;
  if ((int)(954437177 * ((unint64_t)(v111 - (unsigned char *)v110) >> 5)) >= 1)
  {
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    do
    {
      LODWORD(v102) = 0;
      *(void *)((char *)&v102 + 4) = 0;
      unsigned int v104 = 0;
      unint64_t v105 = 0;
      std::string __p = 0;
      unsigned int v40 = (float *)&v37[288 * v39];
      float v41 = v40[3];
      float v42 = *((float *)this + 116);
      float v43 = v40[1] * 0.017453;
      __float2 v44 = __sincosf_stret((float)(90.0 - v40[2]) * 0.017453);
      __float2 v45 = __sincosf_stret(v43);
      if (*(int *)v40 >= 1)
      {
        unsigned int v46 = 0;
        uint64_t v47 = 0;
        uint64_t v48 = v38;
        do
        {
          unsigned int v49 = &v37[v48];
          unsigned int v50 = &v37[v48 + 148];
          if ((unint64_t)v46 >= v105)
          {
            unsigned int v46 = (_DWORD *)std::vector<Phase::Vector<float,3ul>>::__push_back_slow_path<Phase::Vector<float,3ul> const&>((uint64_t *)&__p, v50);
            float v37 = (char *)v110;
          }
          else
          {
            _DWORD *v46 = *(_DWORD *)v50;
            v46[1] = *((_DWORD *)v49 + 38);
            v46[2] = *((_DWORD *)v49 + 39);
            v46 += 3;
          }
          unsigned int v104 = v46;
          ++v47;
          v48 += 24;
        }
        while (v47 < *(int *)&v37[288 * v39]);
      }
      float v51 = (float)(v41 * v42) * v44.__sinval;
      unsigned int v52 = (float *)&v37[288 * v39];
      float v53 = (float)(v45.__sinval * v51) + v52[58];
      float v54 = (float)((float)(v41 * v42) * v44.__cosval) + v52[59];
      float v55 = (float)(v45.__cosval * v51) + v52[60];
      *(float *)&long long v102 = v53;
      *((float *)&v102 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v54;
      *((float *)&v102 + 2) = v55;
      unint64_t v56 = v126;
      if (v126 >= v127)
      {
        uint64_t v57 = std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__push_back_slow_path<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource const&>(&v125, (uint64_t)&v102);
      }
      else
      {
        std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__construct_one_at_end[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource const&>((uint64_t)&v125, (uint64_t)&v102);
        uint64_t v57 = v56 + 40;
      }
      unint64_t v126 = v57;
      if (__p)
      {
        unsigned int v104 = __p;
        operator delete(__p);
      }
      ++v39;
      float v37 = (char *)v110;
      v38 += 288;
    }
    while (v39 < (int)(954437177 * ((unint64_t)(v111 - (unsigned char *)v110) >> 5)));
    uint64_t v36 = v126;
    unsigned int v9 = v96;
    a3 = v97;
  }
  uint64_t v116 = *v99;
  uint64_t v117 = 0;
  unint64_t v124 = 0xCCCCCCCCCCCCCCCDLL * ((v36 - v125) >> 3);
  std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::operator()((uint64_t)(v101 + 10), (uint64_t)&v115);
  if (v107)
  {
    uint64_t v108 = (uint64_t)v107;
    operator delete(v107);
  }
  if (v110)
  {
    unsigned int v111 = v110;
    operator delete(v110);
  }
  Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::~RoomSimulationDebugView((Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)&v115);
LABEL_67:
  if (!v100 || !v100[17]) {
    goto LABEL_109;
  }
  uint64_t v118 = 0;
  uint64_t v119 = 0;
  uint64_t v120 = 0;
  uint64_t v122 = 0;
  uint64_t v123 = 0;
  uint64_t v121 = 0;
  unint64_t v126 = 0;
  unint64_t v127 = 0;
  uint64_t v125 = 0;
  long long v129 = 0u;
  long long v130 = 0u;
  long long v131 = 0u;
  long long v132 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  long long v135 = 0u;
  long long v136 = 0u;
  long long v137 = 0u;
  long long v138 = 0u;
  long long v139 = 0u;
  long long v140 = 0u;
  long long v145 = 0u;
  long long v146 = 0u;
  long long v143 = 0u;
  long long v144 = 0u;
  long long v141 = 0u;
  long long v142 = 0u;
  uint64_t v115 = 0;
  uint64_t v116 = 0;
  uint64_t v117 = 0;
  uint64_t v58 = *v98;
  unsigned int v59 = operator new(8uLL);
  void *v59 = v58;
  *((void *)&v106 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v59 + 1;
  unsigned int v107 = v59 + 1;
  *(void *)&long long v106 = v59;
  unint64_t ClusterHash = Phase::SpatialModeler::GetClusterHash((uint64_t **)&v106, *((void *)this + 2822));
  operator delete(v59);
  int8x8_t v61 = *(int8x8_t *)((char *)this + 19392);
  if (!*(void *)&v61) {
    goto LABEL_86;
  }
  uint8x8_t v62 = (uint8x8_t)vcnt_s8(v61);
  v62.i16[0] = vaddlv_u8(v62);
  if (v62.u32[0] > 1uLL)
  {
    unint64_t v63 = ClusterHash;
    if (*(void *)&v61 <= ClusterHash) {
      unint64_t v63 = ClusterHash % *(void *)&v61;
    }
  }
  else
  {
    unint64_t v63 = (*(void *)&v61 - 1) & ClusterHash;
  }
  uint64_t v64 = *(void **)(*((void *)this + 2423) + 8 * v63);
  if (v64)
  {
    uint64_t v65 = (void *)*v64;
    if (*v64)
    {
      do
      {
        unint64_t v66 = v65[1];
        if (v66 == ClusterHash)
        {
          if (v65[2] == ClusterHash) {
            break;
          }
        }
        else
        {
          if (v62.u32[0] > 1uLL)
          {
            if (v66 >= *(void *)&v61) {
              v66 %= *(void *)&v61;
            }
          }
          else
          {
            v66 &= *(void *)&v61 - 1;
          }
          if (v66 != v63) {
            goto LABEL_86;
          }
        }
        uint64_t v65 = (void *)*v65;
      }
      while (v65);
    }
  }
  else
  {
LABEL_86:
    uint64_t v65 = 0;
  }
  uint64_t v67 = *((void *)this + 2822);
  if (*((_DWORD *)a3 + 34) > v67)
  {
    uint64_t v68 = *((void *)a3 + 15);
    if (*(_DWORD *)(v68 + 24 * v67 + 20) == HIDWORD(v67))
    {
      unsigned int v69 = *(float32x2_t **)(v68 + 24 * *((void *)this + 2822));
      if (v69)
      {
        if (v69->i32[0] == 2)
        {
          Phase::Inverse<float>(v69 + 6, (uint64_t)&v106);
          if (v65)
          {
            unint64_t v70 = v65[14];
            *(void *)&long long v102 = 0;
            DWORD2(v102) = 0;
            std::vector<Phase::Vector<float,3ul>>::assign((char **)&v129, v70, &v102);
            LODWORD(v102) = 0;
            std::vector<float>::assign((char **)&v130 + 1, v70, &v102);
            uint64_t v71 = v65[21];
            if (v71) {
              unint64_t v72 = *(void *)(v71 + 8);
            }
            else {
              unint64_t v72 = 0;
            }
            LODWORD(v110) = 0;
            std::vector<float>::vector(&v102, v72, &v110);
            std::vector<std::vector<float>>::assign((uint64_t *)&v132, v70, (uint64_t)&v102);
            if ((void)v102)
            {
              *((void *)&v102 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v102;
              operator delete((void *)v102);
            }
            LOBYTE(v102) = 0;
            std::vector<unsigned char>::assign((char **)&v133 + 1, v70, (char *)&v102);
            uint64_t v73 = *((void *)this + 2822);
            unint64_t v128 = v70;
            uint64_t v117 = v73;
            uint64_t v116 = *v99;
            if (v70)
            {
              uint64_t v74 = 0;
              for (uint64_t i = 0; i != v70; ++i)
              {
                uint64_t v76 = (float *)(v65[9] + 12 * i);
                float v77 = *v76;
                float v78 = v76[1];
                float v79 = (float)((float)(180.0 - v76[2]) - (float)(floorf((float)(180.0 - v76[2]) / 360.0) * 360.0)) + 0.0;
                if (v79 >= 360.0) {
                  float v79 = nextafterf(360.0, 0.0);
                }
                float v80 = v78 * 0.017453;
                float v81 = v79 * 0.017453;
                __float2 v82 = __sincosf_stret(v80);
                __float2 v83 = __sincosf_stret(v81);
                *(float *)&unsigned int v110 = (float)(v77 * v82.__sinval) * v83.__sinval;
                *((float *)&v110 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v77 * v82.__cosval;
                *(float *)&unsigned int v111 = (float)(v77 * v82.__sinval) * v83.__cosval;
                Phase::operator*<float>((float *)&v106, (float *)&v110, (float *)&v102);
                float v84 = *(float *)&v102;
                float v85 = *((float *)&v102 + 2);
                float v86 = sqrtf((float)((float)(v84 * v84) + (float)(*((float *)&v102 + 1) * *((float *)&v102 + 1)))+ (float)(v85 * v85));
                float v87 = acosf(*((float *)&v102 + 1) / v86);
                float v88 = atan2f(v84, v85);
                float v89 = (float)((float)(180.0 - (float)(v88 * 57.296))
                            - (float)(floorf((float)(180.0 - (float)(v88 * 57.296)) / 360.0) * 360.0))
                    + 0.0;
                if (v89 >= 360.0) {
                  float v89 = nextafterf(360.0, 0.0);
                }
                unsigned int v90 = (float *)(v129 + 12 * i);
                *unsigned int v90 = v86;
                v90[1] = v87 * 57.296;
                v90[2] = v89;
                *(_DWORD *)(*((void *)&v130 + 1) + 4 * i) = *(_DWORD *)(v65[15] + 4 * i);
                *(unsigned char *)(*((void *)&v133 + 1) + i) = *(unsigned char *)(v65[26] + i);
                uint64_t v91 = v65[21];
                uint64_t v92 = *(void *)(v91 + 8);
                if (v92)
                {
                  float v93 = *(_DWORD **)(v132 + 24 * i);
                  uint64_t v94 = (int *)(v91 + v92 * v74 + 16);
                  do
                  {
                    int v95 = *v94++;
                    *v93++ = v95;
                    --v92;
                  }
                  while (v92);
                }
                v74 += 4;
              }
            }
          }
          else
          {
            uint64_t v117 = *((void *)this + 2822);
            uint64_t v116 = *v99;
            unint64_t v128 = 0;
          }
          std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::operator()((uint64_t)(v100 + 14), (uint64_t)&v115);
          a3 = v97;
          Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::~RoomSimulationDebugView((Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)&v115);
          unsigned int v9 = v96;
          goto LABEL_109;
        }
      }
    }
  }
LABEL_115:
  Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::~RoomSimulationDebugView((Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)&v115);
  if (v149) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v149);
  }
  if (v148) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v148);
  }
}

void sub_221F35D88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::~RoomSimulationDebugView((Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)&a40);
  Phase::SpatialModeler::SourceListenerResult::~SourceListenerResult((Phase::SpatialModeler::SourceListenerResult *)(v40 - 200));
  _Unwind_Resume(a1);
}

uint64_t std::function<void ()(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (!v2) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v4);
}

char *std::vector<Phase::Vector<float,3ul>>::assign(char **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - (uint64_t)result) >> 2) >= a2)
  {
    unsigned int v13 = a1[1];
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v13 - result) >> 2);
    if (v14 >= a2) {
      unint64_t v15 = a2;
    }
    else {
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v13 - result) >> 2);
    }
    if (v15)
    {
      BOOL v16 = result;
      do
      {
        *(_DWORD *)BOOL v16 = *a3;
        *((_DWORD *)v16 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a3[1];
        *((_DWORD *)v16 + 2) = a3[2];
        v16 += 12;
        --v15;
      }
      while (v15);
    }
    BOOL v17 = a2 >= v14;
    unint64_t v18 = a2 - v14;
    if (v18 == 0 || !v17)
    {
      a1[1] = &result[12 * a2];
      return result;
    }
    unint64_t v12 = &v13[12 * v18];
    do
    {
      *(_DWORD *)unsigned int v13 = *a3;
      *((_DWORD *)v13 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a3[1];
      *((_DWORD *)v13 + 2) = a3[2];
      v13 += 12;
    }
    while (v13 != v12);
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 > 0x1555555555555555) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * (v6 >> 2);
    uint64_t v9 = 2 * v8;
    if (2 * v8 <= a2) {
      uint64_t v9 = a2;
    }
    if (v8 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x1555555555555555;
    }
    else {
      unint64_t v10 = v9;
    }
    uint64_t result = std::vector<Phase::Vector<float,3ul>>::__vallocate[abi:ne180100](a1, v10);
    int v11 = a1[1];
    unint64_t v12 = &v11[12 * a2];
    do
    {
      *(_DWORD *)int v11 = *a3;
      *((_DWORD *)v11 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a3[1];
      *((_DWORD *)v11 + 2) = a3[2];
      v11 += 12;
    }
    while (v11 != v12);
  }
  a1[1] = v12;
  return result;
}

char *std::vector<float>::assign(char **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6 = (uint64_t)a1[2];
  uint64_t result = *a1;
  if (a2 <= (v6 - (uint64_t)result) >> 2)
  {
    unsigned int v13 = a1[1];
    unint64_t v14 = (v13 - result) >> 2;
    if (v14 >= a2) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = (v13 - result) >> 2;
    }
    if (v15)
    {
      BOOL v16 = result;
      do
      {
        *(_DWORD *)BOOL v16 = *a3;
        v16 += 4;
        --v15;
      }
      while (v15);
    }
    if (a2 <= v14)
    {
      a1[1] = &result[4 * a2];
    }
    else
    {
      BOOL v17 = &v13[4 * (a2 - v14)];
      uint64_t v18 = 4 * a2 - 4 * v14;
      do
      {
        *(_DWORD *)unsigned int v13 = *a3;
        v13 += 4;
        v18 -= 4;
      }
      while (v18);
      a1[1] = v17;
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a2 >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = v6 >> 1;
    if (v6 >> 1 <= a2) {
      uint64_t v8 = a2;
    }
    if ((unint64_t)v6 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v9 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v8;
    }
    uint64_t result = std::vector<float>::__vallocate[abi:ne180100](a1, v9);
    unint64_t v10 = a1[1];
    int v11 = &v10[4 * a2];
    uint64_t v12 = 4 * a2;
    do
    {
      *(_DWORD *)unint64_t v10 = *a3;
      v10 += 4;
      v12 -= 4;
    }
    while (v12);
    a1[1] = v11;
  }
  return result;
}

void std::vector<std::vector<float>>::assign(uint64_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v6 = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= a2)
  {
    unint64_t v13 = (a1[1] - (uint64_t)v6) / 24;
    if (v13 >= a2) {
      uint64_t v14 = a2;
    }
    else {
      uint64_t v14 = (a1[1] - (uint64_t)v6) / 24;
    }
    for (; v14; --v14)
    {
      if (v6 != (char *)a3) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(v6, *(char **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
      }
      v6 += 24;
    }
    if (a2 <= v13)
    {
      uint64_t v18 = a1[1];
      uint64_t v19 = *a1 + 24 * a2;
      if (v18 != v19)
      {
        uint64_t v20 = a1[1];
        do
        {
          uint64_t v22 = *(void **)(v20 - 24);
          v20 -= 24;
          unint64_t v21 = v22;
          if (v22)
          {
            *(void *)(v18 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v21;
            operator delete(v21);
          }
          uint64_t v18 = v20;
        }
        while (v20 != v19);
      }
      a1[1] = v19;
    }
    else
    {
      uint64_t v15 = (void *)a1[1];
      BOOL v16 = &v15[3 * (a2 - v13)];
      uint64_t v17 = -24 * v13 + 24 * a2;
      do
      {
        void *v15 = 0;
        v15[1] = 0;
        void v15[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
        v15 += 3;
        v17 -= 24;
      }
      while (v17);
      a1[1] = (uint64_t)v16;
    }
  }
  else
  {
    std::vector<std::vector<float>>::__vdeallocate(a1);
    if (a2 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v7 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
    if (v7 <= a2) {
      unint64_t v7 = a2;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) >= 0x555555555555555) {
      unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v8 = v7;
    }
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, v8);
    unint64_t v9 = (void *)a1[1];
    uint64_t v10 = 3 * a2;
    int v11 = &v9[3 * a2];
    uint64_t v12 = 8 * v10;
    do
    {
      *unint64_t v9 = 0;
      v9[1] = 0;
      _OWORD v9[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v9, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2);
      v9 += 3;
      v12 -= 24;
    }
    while (v12);
    a1[1] = (uint64_t)v11;
  }
}

void sub_221F362D0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

char *std::vector<unsigned char>::assign(char **a1, unint64_t a2, char *a3)
{
  unint64_t v4 = a2;
  unint64_t v6 = (unint64_t)a1[2];
  uint64_t result = *a1;
  if (v6 - (unint64_t)result >= a2)
  {
    unint64_t v12 = a1[1] - result;
    if (v12 >= a2) {
      unint64_t v13 = a2;
    }
    else {
      unint64_t v13 = a1[1] - result;
    }
    for (; v13; --v13)
      *result++ = *a3;
    BOOL v14 = a2 >= v12;
    unint64_t v15 = a2 - v12;
    if (v15 != 0 && v14)
    {
      BOOL v16 = a1[1];
      uint64_t v17 = &v16[v15];
      do
      {
        *v16++ = *a3;
        --v15;
      }
      while (v15);
      a1[1] = v17;
    }
    else
    {
      a1[1] = &(*a1)[a2];
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      unint64_t v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if ((v4 & 0x8000000000000000) != 0) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v8 = 2 * v6;
    if (2 * v6 <= v4) {
      uint64_t v8 = v4;
    }
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v9 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v9 = v8;
    }
    uint64_t result = std::vector<unsigned char>::__vallocate[abi:ne180100](a1, v9);
    uint64_t v10 = a1[1];
    int v11 = &v10[v4];
    do
    {
      *v10++ = *a3;
      --v4;
    }
    while (v4);
    a1[1] = v11;
  }
  return result;
}

void Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::~RoomSimulationDebugView(Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView *this)
{
  uint64_t v2 = (void *)*((void *)this + 53);
  if (v2)
  {
    *((void *)this + 54) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 50);
  if (v3)
  {
    *((void *)this + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v3;
    operator delete(v3);
  }
  unint64_t v4 = (void *)*((void *)this + 47);
  if (v4)
  {
    *((void *)this + 48) = v4;
    operator delete(v4);
  }
  unint64_t v5 = (void *)*((void *)this + 44);
  if (v5)
  {
    *((void *)this + 45) = v5;
    operator delete(v5);
  }
  unint64_t v6 = (void *)*((void *)this + 39);
  if (v6)
  {
    *((void *)this + 40) = v6;
    operator delete(v6);
  }
  BOOL v14 = (void **)((char *)this + 288);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  unint64_t v7 = (void *)*((void *)this + 33);
  if (v7)
  {
    *((void *)this + 34) = v7;
    operator delete(v7);
  }
  uint64_t v8 = (void *)*((void *)this + 30);
  if (v8)
  {
    *((void *)this + 3Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v8;
    operator delete(v8);
  }
  size_t v9 = (void *)*((void *)this + 26);
  if (v9)
  {
    *((void *)this + 2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v9;
    operator delete(v9);
  }
  BOOL v14 = (void **)((char *)this + 184);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v14);
  uint64_t v10 = (void *)*((void *)this + 20);
  if (v10)
  {
    *((void *)this + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v10;
    operator delete(v10);
  }
  int v11 = (void *)*((void *)this + 17);
  if (v11)
  {
    *((void *)this + 18) = v11;
    operator delete(v11);
  }
  BOOL v14 = (void **)((char *)this + 104);
  std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__destroy_vector::operator()[abi:ne180100](&v14);
  unint64_t v12 = (void *)*((void *)this + 9);
  if (v12)
  {
    *((void *)this + 10) = v12;
    operator delete(v12);
  }
  unint64_t v13 = (void *)*((void *)this + 4);
  if (v13)
  {
    *((void *)this + 5) = v13;
    operator delete(v13);
  }
}

void std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__clear[abi:ne180100]((uint64_t *)v2);
    unint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 40)
  {
    unint64_t v4 = *(void **)(i - 24);
    if (v4)
    {
      *(void *)(i - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

uint64_t std::vector<Phase::Vector<float,3ul>>::__push_back_slow_path<Phase::Vector<float,3ul> const&>(uint64_t *a1, _DWORD *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 2);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0x1555555555555555) {
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 2);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0xAAAAAAAAAAAAAAALL) {
    unint64_t v9 = 0x1555555555555555;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Vector<float,3ul>>>(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  int v11 = &v10[12 * v4];
  std::string __p = v10;
  unint64_t v15 = v11;
  uint64_t v17 = &v10[12 * v9];
  *(_DWORD *)int v11 = *a2;
  *((_DWORD *)v11 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a2[1];
  *((_DWORD *)v11 + 2) = a2[2];
  BOOL v16 = v11 + 12;
  std::vector<Phase::Vector<float,3ul>>::__swap_out_circular_buffer(a1, &__p);
  uint64_t v12 = a1[1];
  if (v16 != v15) {
    BOOL v16 = &v15[(v16 - v15 - 12) % 0xCuLL];
  }
  if (__p) {
    operator delete(__p);
  }
  return v12;
}

void sub_221F366D4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__construct_one_at_end[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  *(_DWORD *)uint64_t v3 = *(_DWORD *)a2;
  *(_DWORD *)(v3 + 4) = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(v3 + 8) = *(_DWORD *)(a2 + 8);
  *(void *)(v3 + 24) = 0;
  *(void *)(v3 + 32) = 0;
  *(void *)(v3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  uint64_t result = std::vector<Phase::Vector<float,3ul>>::__init_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>((char *)(v3 + 16), *(_DWORD **)(a2 + 16), *(_DWORD **)(a2 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 2));
  *(void *)(a1 + 8) = v3 + 40;
  return result;
}

void sub_221F36790(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__push_back_slow_path<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x666666666666666) {
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333) {
    unint64_t v6 = 0x666666666666666;
  }
  else {
    unint64_t v6 = v4;
  }
  unint64_t v23 = a1 + 2;
  if (v6) {
    uint64_t v7 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>>((uint64_t)(a1 + 2), v6);
  }
  else {
    uint64_t v7 = 0;
  }
  unint64_t v8 = &v7[40 * v3];
  unint64_t v21 = v7;
  *(void *)uint64_t v22 = v8;
  *(void *)&v22[8] = v8;
  *(void *)&v22[16] = &v7[40 * v6];
  *(_DWORD *)unint64_t v8 = *(_DWORD *)a2;
  *((_DWORD *)v8 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(a2 + 4);
  int v9 = *(_DWORD *)(a2 + 8);
  *((void *)v8 + 2) = 0;
  v8 += 16;
  *((_DWORD *)v8 - 2) = v9;
  *((void *)v8 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)v8 + 2) = 0;
  std::vector<Phase::Vector<float,3ul>>::__init_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>(v8, *(_DWORD **)(a2 + 16), *(_DWORD **)(a2 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 2));
  uint64_t v10 = *(void *)v22;
  *(void *)&v22[8] += 40;
  uint64_t v12 = *a1;
  uint64_t v11 = a1[1];
  *(void *)&long long v27 = *(void *)v22;
  *((void *)&v27 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(void *)v22;
  long long v26 = v27;
  v24[0] = a1 + 2;
  v24[1] = &v26;
  v24[2] = &v27;
  for (char i = 0; v11 != v12; *((void *)&v27 + 1) -= 40)
  {
    int v13 = *(_DWORD *)(v11 - 40);
    v11 -= 40;
    *(_DWORD *)(v10 - 40) = v13;
    *(_DWORD *)(v10 - 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v11 + 4);
    int v14 = *(_DWORD *)(v11 + 8);
    *(void *)(v10 - 24) = 0;
    uint64_t v15 = v10 - 24;
    *(_DWORD *)(v15 - 8) = v14;
    *(void *)(v15 + 8) = 0;
    *(void *)(v15 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    std::vector<Phase::Vector<float,3ul>>::__init_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>((char *)v15, *(_DWORD **)(v11 + 16), *(_DWORD **)(v11 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v11 + 24) - *(void *)(v11 + 16)) >> 2));
    uint64_t v10 = *((void *)&v27 + 1) - 40;
  }
  char i = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,std::reverse_iterator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v24);
  uint64_t v16 = a1[2];
  long long v17 = *(_OWORD *)&v22[8];
  uint64_t v20 = *(void *)&v22[8];
  long long v18 = *(_OWORD *)a1;
  *a1 = v10;
  *(_OWORD *)uint64_t v22 = v18;
  *(_OWORD *)(a1 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v17;
  *(void *)&v22[16] = v16;
  unint64_t v21 = (char *)v18;
  std::__split_buffer<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::~__split_buffer((uint64_t)&v21);
  return v20;
}

void sub_221F36974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::__split_buffer<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::vector<Phase::Vector<float,3ul>>::__init_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>(char *result, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  if (a4)
  {
    unint64_t v6 = result;
    uint64_t result = std::vector<Phase::Vector<float,3ul>>::__vallocate[abi:ne180100](result, a4);
    uint64_t v7 = (_DWORD *)*((void *)v6 + 1);
    while (a2 != a3)
    {
      _DWORD *v7 = *a2;
      v7[1] = a2[1];
      void v7[2] = a2[2];
      v7 += 3;
      a2 += 3;
    }
    *((void *)v6 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v7;
  }
  return result;
}

void sub_221F36A08(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(40 * a2);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,std::reverse_iterator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 8);
    for (uint64_t i = *(void *)(*(void *)(a1 + 16) + 8); i != v3; i += 40)
    {
      unint64_t v5 = *(void **)(i + 16);
      if (v5)
      {
        *(void *)(i + 24) = v5;
        operator delete(v5);
      }
    }
  }
  return a1;
}

uint64_t std::__split_buffer<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v2 - 40;
    unint64_t v4 = *(void **)(v2 - 24);
    if (v4)
    {
      *(void *)(v2 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
      operator delete(v4);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 40;
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void *std::vector<float>::vector(void *a1, unint64_t a2, _DWORD *a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    unint64_t v6 = (_DWORD *)a1[1];
    uint64_t v7 = &v6[a2];
    uint64_t v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_221F36B98(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::vector<float>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](void *a1, size_t __sz)
{
  if ((__sz & 0x8000000000000000) != 0) {
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

Phase::SpatialModeler::EarlyReflectionDetector *Phase::SpatialModeler::EarlyReflectionDetector::EarlyReflectionDetector(Phase::SpatialModeler::EarlyReflectionDetector *this, const Phase::SpatialModeler::EarlyReflectionDetector *a2)
{
  unint64_t v4 = (void *)std::unordered_map<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>::unordered_map((uint64_t)this, (uint64_t)a2);
  void v4[5] = 0;
  v4[6] = 0;
  v4 += 5;
  v4[2] = 0;
  std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__init_with_size[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection*,Phase::SpatialModeler::AudibleEarlyReflection*>(v4, *((void *)a2 + 5), *((void *)a2 + 6), 0x8E38E38E38E38E39 * ((uint64_t)(*((void *)a2 + 6) - *((void *)a2 + 5)) >> 5));
  *((void *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((_OWORD *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  return this;
}

void sub_221F36C9C(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

float Phase::SpatialModeler::EarlyReflectionDetector::GetLastPathAngleError(Phase::SpatialModeler::EarlyReflectionDetector *this, const Phase::SpatialModeler::AudibleEarlyReflection *a2)
{
  uint64_t v2 = (float *)((char *)this + 24 * *(int *)this);
  float v3 = *((float *)this + 55) - v2[31];
  float v4 = *((float *)this + 56) - v2[32];
  float v5 = *((float *)this + 57) - v2[33];
  float result = (float)((float)((float)(v3 * *((float *)this + 61)) + (float)(v4 * *((float *)this + 62)))
                 + (float)(v5 * *((float *)this + 63)))
         / (float)(sqrtf((float)((float)(v3 * v3) + (float)(v4 * v4)) + (float)(v5 * v5))
                 * sqrtf((float)((float)(*((float *)this + 61) * *((float *)this + 61))+ (float)(*((float *)this + 62) * *((float *)this + 62)))+ (float)(*((float *)this + 63) * *((float *)this + 63))));
  if (result < -1.0 || result > 1.0) {
    return -1.0;
  }
  return result;
}

void Phase::SpatialModeler::EarlyReflectionDetector::AddToScoreBoard(Phase::SpatialModeler::EarlyReflectionDetector *this, const Phase::SpatialModeler::AudibleEarlyReflection *a2)
{
  if (*(int *)a2 < 1)
  {
    uint64_t v5 = 0;
  }
  else
  {
    uint64_t v4 = 0;
    uint64_t v5 = 0;
    unint64_t v6 = (const Phase::SpatialModeler::AudibleEarlyReflection *)((char *)a2 + 160);
    do
    {
      ++v4;
      v5 += Phase::SpatialModeler::AudibleEarlyReflection::sPlaneHashWithBucketNormal(v6, (float *)v6 - 3) * v4;
      unint64_t v6 = (Phase::SpatialModeler::AudibleEarlyReflection *)((char *)v6 + 24);
    }
    while (v4 < *(int *)a2);
  }
  uint64_t v14 = v5;
  uint64_t v7 = (unsigned int *)std::__hash_table<std::__hash_value_type<unsigned long long,int>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,int>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,int>>>::find<unsigned long long>(this, (unint64_t *)&v14);
  if (v7)
  {
    Phase::SpatialModeler::AudibleEarlyReflection::operator+=(v7 + 8, (unsigned int *)a2, v8, v9, v10, v11, v12, v13);
  }
  else
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>>>::__emplace_unique_key_args<unsigned long long,unsigned long long &,Phase::SpatialModeler::AudibleEarlyReflection const&>((uint64_t)this, (unint64_t *)&v14, &v14, (uint64_t)a2);
    if (*((void *)this + 3) >= 0x64uLL) {
      Phase::SpatialModeler::EarlyReflectionDetector::AutoSizeLimit(this);
    }
  }
}

void *Phase::SpatialModeler::EarlyReflectionDetector::AutoSizeLimit(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[2];
  while (v2)
  {
    if (*(float *)(v2 + 176) >= 0.001)
    {
      uint64_t v2 = *(void *)v2;
    }
    else
    {
      this = (void *)std::__hash_table<Phase::Controller::Renderer *,std::hash<Phase::Controller::Renderer *>,std::equal_to<Phase::Controller::Renderer *>,std::allocator<Phase::Controller::Renderer *>>::erase(v1, (uint64_t *)v2);
      uint64_t v2 = (uint64_t)this;
    }
  }
  if (v1[3] >= 0x65uLL)
  {
    do
    {
      float v3 = (float *)v1[2];
      for (uint64_t i = (uint64_t *)v3; v3; v3 = *(float **)v3)
      {
        if (v3[44] < *((float *)i + 44)) {
          uint64_t i = (uint64_t *)v3;
        }
      }
      this = (void *)std::__hash_table<Phase::Controller::Renderer *,std::hash<Phase::Controller::Renderer *>,std::equal_to<Phase::Controller::Renderer *>,std::allocator<Phase::Controller::Renderer *>>::erase(v1, i);
    }
    while (v1[3] > 0x64uLL);
  }
  return this;
}

char *Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(Phase::SpatialModeler::EarlyReflectionDetector *this, int a2, int a3, float a4)
{
  if (!a3) {
    return (char *)this + 40;
  }
  if (*((void *)this + 3))
  {
    unint64_t v6 = (unsigned char *)*((void *)this + 8);
    if ((*((void *)this + 10) - (void)v6) >> 4 <= 0x9AAuLL)
    {
      uint64_t v7 = (unsigned char *)*((void *)this + 9);
      double v8 = (char *)operator new(0x9AB0uLL);
      double v9 = &v8[(v7 - v6) & 0xFFFFFFFFFFFFFFF8];
      double v10 = v9;
      if (v7 != v6)
      {
        double v10 = &v8[(v7 - v6) & 0xFFFFFFFFFFFFFFF8];
        do
        {
          uint64_t v11 = *((void *)v7 - 1);
          v7 -= 8;
          *((void *)v10 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v11;
          v10 -= 8;
        }
        while (v7 != v6);
      }
      *((void *)this + 8) = v10;
      *((void *)this + 9) = v9;
      *((void *)this + 10) = v8 + 39600;
      if (v6) {
        operator delete(v6);
      }
    }
    double v12 = (unsigned char *)*((void *)this + 14);
    if (*((void *)this + 16) - (void)v12 <= 0x63FuLL)
    {
      double v13 = (unsigned char *)*((void *)this + 15);
      uint64_t v14 = (char *)operator new(0x640uLL);
      uint64_t v15 = &v14[(v13 - v12) & 0xFFFFFFFFFFFFFFF0];
      uint64_t v16 = v15;
      if (v13 != v12)
      {
        long long v17 = &v14[(v13 - v12) & 0xFFFFFFFFFFFFFFF0];
        do
        {
          uint64_t v16 = v17 - 16;
          *((_OWORD *)v17 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((_OWORD *)v13 - 1);
          v13 -= 16;
          v17 -= 16;
        }
        while (v13 != v12);
      }
      *((void *)this + 14) = v16;
      *((void *)this + 15) = v15;
      *((void *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v14 + 1600;
      if (v12) {
        operator delete(v12);
      }
    }
    uint64_t v19 = (uint64_t *)((char *)this + 88);
    uint64_t v18 = *((void *)this + 11);
    if (0x8E38E38E38E38E39 * ((*((void *)this + 13) - v18) >> 5) <= 0x63)
    {
      uint64_t v20 = *((void *)this + 12) - v18;
      long long v146 = (char *)this + 104;
      __p[0] = operator new(0x7080uLL);
      __p[1] = (char *)__p[0] + v20;
      long long v144 = (char *)__p[0] + v20;
      long long v145 = (char *)__p[0] + 28800;
      std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__swap_out_circular_buffer((uint64_t *)this + 11, __p);
      if (__p[0]) {
        operator delete(__p[0]);
      }
      uint64_t v18 = *v19;
    }
    *((void *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v18;
    *((void *)this + 15) = *((void *)this + 14);
    *((void *)this + 9) = *((void *)this + 8);
    unint64_t v21 = (float *)*((void *)this + 2);
    if (v21)
    {
      do
      {
        uint64_t v22 = *((unsigned int *)v21 + 43);
        if (v22)
        {
          unint64_t v23 = v21 + 12;
          float v24 = 0.0;
          do
          {
            float v25 = *v23++;
            float v24 = v24 + (float)(v25 * v25);
            --v22;
          }
          while (v22);
        }
        else
        {
          float v24 = 0.0;
        }
        v21[78] = v21[44] * (float)(v24 / (float)(v21[11] * v21[11]));
        float v26 = v21[66] - v21[63];
        float v27 = v21[67] - v21[64];
        v21[74] = sqrtf((float)((float)(v26 * v26) + (float)(v27 * v27))+ (float)((float)(v21[68] - v21[65]) * (float)(v21[68] - v21[65])))/ a4;
        Phase::SpatialModeler::AudibleEarlyReflection::updateISPositionEstimate((Phase::SpatialModeler::AudibleEarlyReflection *)(v21 + 8), a4);
        if (v21[44] > 0.000001)
        {
          unint64_t v29 = *((void *)this + 12);
          unint64_t v28 = *((void *)this + 13);
          if (v29 >= v28)
          {
            unint64_t v31 = 0x8E38E38E38E38E39 * ((uint64_t)(v29 - *v19) >> 5);
            unint64_t v32 = v31 + 1;
            if (v31 + 1 > 0xE38E38E38E38E3) {
LABEL_162:
            }
              std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__throw_length_error[abi:ne180100]();
            unint64_t v33 = 0x8E38E38E38E38E39 * ((uint64_t)(v28 - *v19) >> 5);
            if (2 * v33 > v32) {
              unint64_t v32 = 2 * v33;
            }
            if (v33 >= 0x71C71C71C71C71) {
              unint64_t v34 = 0xE38E38E38E38E3;
            }
            else {
              unint64_t v34 = v32;
            }
            long long v146 = (char *)this + 104;
            if (v34) {
              int v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>>((uint64_t)this + 104, v34);
            }
            else {
              int v35 = 0;
            }
            uint64_t v36 = &v35[288 * v31];
            __p[0] = v35;
            __p[1] = v36;
            long long v145 = &v35[288 * v34];
            std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>::construct[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection,Phase::SpatialModeler::AudibleEarlyReflection const&>((uint64_t)v36, (uint64_t)(v21 + 8));
            long long v144 = v36 + 288;
            std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__swap_out_circular_buffer((uint64_t *)this + 11, __p);
            unint64_t v30 = *((void *)this + 12);
            if (__p[0]) {
              operator delete(__p[0]);
            }
          }
          else
          {
            std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>::construct[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection,Phase::SpatialModeler::AudibleEarlyReflection const&>(*((void *)this + 12), (uint64_t)(v21 + 8));
            unint64_t v30 = v29 + 288;
          }
          *((void *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v30;
          unint64_t v37 = v30 - 288;
          uint64_t v39 = (char *)*((void *)this + 15);
          unint64_t v38 = *((void *)this + 16);
          if ((unint64_t)v39 >= v38)
          {
            float v41 = (char *)*((void *)this + 14);
            uint64_t v42 = (v39 - v41) >> 4;
            unint64_t v43 = v42 + 1;
            if ((unint64_t)(v42 + 1) >> 60) {
              std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v44 = v38 - (void)v41;
            if (v44 >> 3 > v43) {
              unint64_t v43 = v44 >> 3;
            }
            if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v45 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v45 = v43;
            }
            if (v45)
            {
              if (v45 >> 60) {
LABEL_161:
              }
                std::__throw_bad_array_new_length[abi:ne180100]();
              unsigned int v46 = (char *)operator new(16 * v45);
            }
            else
            {
              unsigned int v46 = 0;
            }
            uint64_t v47 = &v46[16 * v42];
            *(void *)uint64_t v47 = v37;
            *((_DWORD *)v47 + 2) = 0;
            uint64_t v48 = v47;
            if (v39 != v41)
            {
              do
              {
                *((_OWORD *)v48 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((_OWORD *)v39 - 1);
                v48 -= 16;
                v39 -= 16;
              }
              while (v39 != v41);
              uint64_t v39 = (char *)*((void *)this + 14);
            }
            uint64_t v40 = v47 + 16;
            *((void *)this + 14) = v48;
            *((void *)this + 15) = v47 + 16;
            *((void *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = &v46[16 * v45];
            if (v39) {
              operator delete(v39);
            }
          }
          else
          {
            *(void *)uint64_t v39 = v37;
            *((_DWORD *)v39 + 2) = 0;
            uint64_t v40 = v39 + 16;
          }
          *((void *)this + 15) = v40;
        }
        unint64_t v21 = *(float **)v21;
      }
      while (v21);
      unsigned int v49 = (char *)*((void *)this + 14);
      unsigned int v50 = (char *)*((void *)this + 15);
      uint64_t v51 = v50 - v49;
      if (v50 != v49)
      {
        unsigned int v52 = &v49[v51 & 0xFFFFFFFFFFFFFFF0];
        if (v51 >= 17)
        {
          unint64_t v53 = (unint64_t)((v51 >> 4) - 2) >> 1;
          unint64_t v54 = v53 + 1;
          float v55 = &v49[16 * v53];
          do
          {
            std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_0 &,std::__wrap_iter<Phase::SpatialModeler::EarlyReflectionDetector::AudibleEarlyReflectionWithStatus *>>((uint64_t)v49, v51 >> 4, v55);
            v55 -= 16;
            --v54;
          }
          while (v54);
        }
        if (v52 != v50)
        {
          unint64_t v56 = &v49[v51 & 0xFFFFFFFFFFFFFFF0];
          do
          {
            if (*(float *)(*(void *)v49 + 280) < *(float *)(*(void *)v56 + 280))
            {
              long long v57 = *(_OWORD *)v56;
              *(_OWORD *)unint64_t v56 = *(_OWORD *)v49;
              *(_OWORD *)unsigned int v49 = v57;
              std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_0 &,std::__wrap_iter<Phase::SpatialModeler::EarlyReflectionDetector::AudibleEarlyReflectionWithStatus *>>((uint64_t)v49, v51 >> 4, v49);
            }
            v56 += 16;
          }
          while (v56 != v50);
        }
        if (v51 >= 17)
        {
          uint64_t v58 = (unint64_t)v51 >> 4;
          do
          {
            uint64_t v59 = 0;
            *(_OWORD *)std::string __p = *(_OWORD *)v49;
            float v60 = v49;
            do
            {
              int8x8_t v61 = v60;
              v60 += 16 * v59 + 16;
              uint64_t v62 = 2 * v59;
              uint64_t v59 = (2 * v59) | 1;
              uint64_t v63 = v62 + 2;
              if (v63 < v58 && *(float *)(*((void *)v60 + 2) + 280) < *(float *)(*(void *)v60 + 280))
              {
                v60 += 16;
                uint64_t v59 = v63;
              }
              *(_OWORD *)int8x8_t v61 = *(_OWORD *)v60;
            }
            while (v59 <= (uint64_t)((unint64_t)(v58 - 2) >> 1));
            v52 -= 16;
            if (v60 == v52)
            {
              *(_OWORD *)float v60 = *(_OWORD *)__p;
            }
            else
            {
              *(_OWORD *)float v60 = *(_OWORD *)v52;
              *(_OWORD *)unsigned int v52 = *(_OWORD *)__p;
              uint64_t v64 = v60 - v49 + 16;
              if (v64 >= 17)
              {
                unint64_t v65 = (((unint64_t)v64 >> 4) - 2) >> 1;
                unint64_t v66 = &v49[16 * v65];
                uint64_t v67 = *(void *)v60;
                if (*(float *)(*(void *)v60 + 280) < *(float *)(*(void *)v66 + 280))
                {
                  uint64_t v68 = *((void *)v60 + 1);
                  do
                  {
                    unsigned int v69 = v60;
                    float v60 = v66;
                    *(_OWORD *)unsigned int v69 = *(_OWORD *)v66;
                    if (!v65) {
                      break;
                    }
                    unint64_t v65 = (v65 - 1) >> 1;
                    unint64_t v66 = &v49[16 * v65];
                  }
                  while (*(float *)(v67 + 280) < *(float *)(*(void *)v66 + 280));
                  *(void *)float v60 = v67;
                  *((void *)v60 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v68;
                }
              }
            }
          }
          while (v58-- > 2);
        }
      }
    }
    uint64_t v72 = *((void *)this + 14);
    uint64_t v71 = *((void *)this + 15);
    float v73 = 1.5 / a4;
    if (v71 != v72)
    {
      uint64_t v74 = 0;
      __int16 v75 = 0;
      do
      {
        unint64_t v76 = (unsigned __int16)(v75 + 1);
        unint64_t v77 = (v71 - v72) >> 4;
        unint64_t v78 = v76;
        unsigned __int16 v79 = v75 + 1;
        if (v77 > v76)
        {
          do
          {
            uint64_t v80 = *(void *)(v72 + 16 * v74);
            uint64_t v81 = *(void *)(v72 + 16 * v78);
            if (*(_DWORD *)v80 == *(_DWORD *)v81)
            {
              float v82 = *(float *)(v80 + 12) - *(float *)(v81 + 12);
              if (v82 < 0.0) {
                float v82 = -v82;
              }
              if (v82 <= v73)
              {
                float v83 = *(float *)(v80 + 268) - *(float *)(v81 + 268);
                float v84 = *(float *)(v80 + 272) - *(float *)(v81 + 272);
                float v85 = (float)((float)(v83 * v83) + (float)(v84 * v84))
                    + (float)((float)(*(float *)(v80 + 276) - *(float *)(v81 + 276))
                            * (float)(*(float *)(v80 + 276) - *(float *)(v81 + 276)));
                if (v85 < 2.25)
                {
                  float v87 = (float *)*((void *)this + 9);
                  unint64_t v86 = *((void *)this + 10);
                  if ((unint64_t)v87 >= v86)
                  {
                    float v89 = (float *)*((void *)this + 8);
                    uint64_t v90 = ((char *)v87 - (char *)v89) >> 3;
                    unint64_t v91 = v90 + 1;
                    if ((unint64_t)(v90 + 1) >> 61) {
                      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                    }
                    uint64_t v92 = v86 - (void)v89;
                    if (v92 >> 2 > v91) {
                      unint64_t v91 = v92 >> 2;
                    }
                    if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v93 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v93 = v91;
                    }
                    if (v93)
                    {
                      if (v93 >> 61) {
                        goto LABEL_161;
                      }
                      uint64_t v94 = (char *)operator new(8 * v93);
                    }
                    else
                    {
                      uint64_t v94 = 0;
                    }
                    int v95 = &v94[8 * v90];
                    *(float *)int v95 = v85;
                    *((_WORD *)v95 + 2) = v75;
                    *((_WORD *)v95 + 3) = v79;
                    uint64_t v96 = v95;
                    if (v87 != v89)
                    {
                      do
                      {
                        uint64_t v97 = *((void *)v87 - 1);
                        v87 -= 2;
                        *((void *)v96 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v97;
                        v96 -= 8;
                      }
                      while (v87 != v89);
                      float v87 = (float *)*((void *)this + 8);
                    }
                    uint64_t v98 = &v94[8 * v93];
                    float v88 = (float *)(v95 + 8);
                    *((void *)this + 8) = v96;
                    *((void *)this + 9) = v95 + 8;
                    *((void *)this + 10) = v98;
                    if (v87) {
                      operator delete(v87);
                    }
                  }
                  else
                  {
                    *float v87 = v85;
                    *((_WORD *)v87 + 2) = v75;
                    float v88 = v87 + 2;
                    *((_WORD *)v87 + 3) = v79;
                  }
                  *((void *)this + 9) = v88;
                  uint64_t v72 = *((void *)this + 14);
                  uint64_t v71 = *((void *)this + 15);
                }
              }
            }
            unint64_t v78 = ++v79;
          }
          while (v79 < (unint64_t)((v71 - v72) >> 4));
          unint64_t v77 = (v71 - v72) >> 4;
        }
        uint64_t v74 = (unsigned __int16)++v75;
      }
      while (v77 > v76);
    }
    unsigned int v99 = (float *)*((void *)this + 8);
    unsigned int v100 = (float *)*((void *)this + 9);
    unint64_t v101 = 126 - 2 * __clz(((char *)v100 - (char *)v99) >> 3);
    if (v100 == v99) {
      uint64_t v102 = 0;
    }
    else {
      uint64_t v102 = v101;
    }
    std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *,false>(v99, v100, v102, 1);
    uint64_t v108 = *((void *)this + 8);
    uint64_t v107 = *((void *)this + 9);
    if (v107 != v108)
    {
      uint64_t v109 = 0;
      unint64_t v110 = 0;
      do
      {
        uint64_t v111 = *((void *)this + 14);
        uint64_t v112 = (_DWORD *)(v111 + 16 * *(unsigned __int16 *)(v108 + v109 + 4));
        uint64_t v113 = v112 + 2;
        if (v112[2] != 2)
        {
          int v114 = (_DWORD *)(v111 + 16 * *(unsigned __int16 *)(v108 + v109 + 6));
          uint64_t v115 = v114 + 2;
          if (v114[2] != 2)
          {
            uint64_t v116 = *(unsigned int **)v112;
            uint64_t v117 = *(unsigned int **)v114;
            float v118 = *(float *)(*(void *)v112 + 12) - *(float *)(*(void *)v114 + 12);
            if (v118 < 0.0) {
              float v118 = -v118;
            }
            if (v118 <= v73)
            {
              uint64_t v119 = &v116[6 * *v116];
              uint64_t v120 = &v117[6 * *v117];
              float v121 = *((float *)v119 + 33) - *((float *)v120 + 33);
              double v122 = *(double *)(v120 + 31);
              float32x2_t v123 = vsub_f32(*(float32x2_t *)(v119 + 31), *(float32x2_t *)&v122);
              float32x2_t v124 = vmul_f32(v123, v123);
              v124.f32[0] = vaddv_f32(v124);
              *(float *)&double v103 = v124.f32[0] + (float)(v121 * v121);
              if (*(float *)&v103 < 2.25)
              {
                Phase::SpatialModeler::AudibleEarlyReflection::operator+=(v116, v117, v103, *(double *)&v124, v122, v104, v105, v106);
                *uint64_t v113 = 1;
                *uint64_t v115 = 2;
                uint64_t v108 = *((void *)this + 8);
                uint64_t v107 = *((void *)this + 9);
              }
            }
          }
        }
        ++v110;
        v109 += 8;
      }
      while (v110 < (v107 - v108) >> 3);
    }
    uint64_t v125 = (void *)((char *)this + 40);
    unint64_t v126 = *((void *)this + 5);
    uint64_t v127 = *((void *)this + 14);
    unint64_t v128 = (uint64_t *)*((void *)this + 15);
    if ((uint64_t *)v127 == v128)
    {
      *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v126;
    }
    else
    {
      unint64_t v129 = *((void *)this + 6);
      long long v130 = (uint64_t *)*((void *)this + 14);
      do
      {
        if (*((_DWORD *)v130 + 2) != 2)
        {
          uint64_t v131 = *v130;
          if (v126 == v129)
          {
            unint64_t v132 = v126;
          }
          else
          {
            unint64_t v132 = v126;
            while (*(void *)(v132 + 256) != *(void *)(v131 + 256))
            {
              v132 += 288;
              if (v132 == v129)
              {
                unint64_t v132 = v129;
                break;
              }
            }
          }
          if (v132 != v129)
          {
            unint64_t v133 = v126 + 32 * ((uint64_t)(v132 - v126) >> 5);
            *(float *)(v131 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(float *)(v133 + 12)
                                  + (float)((float)(*(float *)(v131 + 12) - *(float *)(v133 + 12)) * 0.05);
            *(float *)(v131 + 264) = *(float *)(v133 + 264)
                                   + (float)((float)(*(float *)(v131 + 264) - *(float *)(v133 + 264)) * 0.05);
          }
        }
        v130 += 2;
      }
      while (v130 != v128);
      *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v126;
      long long v134 = (unint64_t *)((char *)this + 56);
      do
      {
        if (*(_DWORD *)(v127 + 8) != 2)
        {
          uint64_t v135 = *(void *)v127;
          if (v126 >= *v134)
          {
            unint64_t v136 = 0x8E38E38E38E38E39 * ((uint64_t)(v126 - *v125) >> 5);
            unint64_t v137 = v136 + 1;
            if (v136 + 1 > 0xE38E38E38E38E3) {
              goto LABEL_162;
            }
            if (0x1C71C71C71C71C72 * ((uint64_t)(*v134 - *v125) >> 5) > v137) {
              unint64_t v137 = 0x1C71C71C71C71C72 * ((uint64_t)(*v134 - *v125) >> 5);
            }
            if (0x8E38E38E38E38E39 * ((uint64_t)(*v134 - *v125) >> 5) >= 0x71C71C71C71C71) {
              unint64_t v138 = 0xE38E38E38E38E3;
            }
            else {
              unint64_t v138 = v137;
            }
            long long v146 = (char *)this + 56;
            if (v138) {
              long long v139 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>>((uint64_t)this + 56, v138);
            }
            else {
              long long v139 = 0;
            }
            long long v140 = &v139[288 * v136];
            __p[0] = v139;
            __p[1] = v140;
            long long v145 = &v139[288 * v138];
            std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>::construct[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection,Phase::SpatialModeler::AudibleEarlyReflection const&>((uint64_t)v140, v135);
            long long v144 = v140 + 288;
            std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__swap_out_circular_buffer((uint64_t *)this + 5, __p);
            unint64_t v126 = *((void *)this + 6);
            if (__p[0]) {
              operator delete(__p[0]);
            }
          }
          else
          {
            std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>::construct[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection,Phase::SpatialModeler::AudibleEarlyReflection const&>(v126, *(void *)v127);
            v126 += 288;
          }
          *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v126;
        }
        v127 += 16;
      }
      while ((uint64_t *)v127 != v128);
    }
    return (char *)this + 40;
  }
  long long v141 = (char *)this + 88;
  *((void *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *((void *)this + 11);
  return v141;
}

void *std::ofstream::~ofstream(void *a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B0];
  uint64_t v3 = *MEMORY[0x263F8C2B0];
  *a1 = *MEMORY[0x263F8C2B0];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x223C93440](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x223C937D0](a1 + 52);
  return a1;
}

uint64_t std::unordered_map<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>(a1, *(void *)(a2 + 8));
  for (uint64_t i = *(void **)(a2 + 16); i; uint64_t i = (void *)*i)
    std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,Phase::SpatialModeler::AudibleEarlyReflection> const&>(a1, i + 2, i + 2);
  return a1;
}

void sub_221F37ACC(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,Phase::SpatialModeler::AudibleEarlyReflection> const&>(uint64_t a1, unint64_t *a2, uint64_t *a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    double v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      for (uint64_t i = *v9; i; uint64_t i = (void *)*i)
      {
        unint64_t v11 = i[1];
        if (v11 == v6)
        {
          if (i[2] == v6) {
            return i;
          }
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3) {
            break;
          }
        }
      }
    }
  }
  double v12 = (char *)operator new(0x140uLL);
  uint64_t i = v12;
  uint64_t v13 = 0;
  uint64_t v14 = *a3;
  *((void *)v12 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6;
  *((void *)v12 + 2) = v14;
  *((_DWORD *)v12 + 44) = *((_DWORD *)a3 + 40);
  *(void *)double v12 = 0;
  long long v15 = *((_OWORD *)a3 + 8);
  *((_OWORD *)v12 + 8) = *((_OWORD *)a3 + 7);
  *((_OWORD *)v12 + 9) = v15;
  *((_OWORD *)v12 + 10) = *((_OWORD *)a3 + 9);
  long long v16 = *((_OWORD *)a3 + 4);
  *((_OWORD *)v12 + 4) = *((_OWORD *)a3 + 3);
  *((_OWORD *)v12 + 5) = v16;
  long long v17 = *((_OWORD *)a3 + 6);
  *((_OWORD *)v12 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_OWORD *)a3 + 5);
  *((_OWORD *)v12 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v17;
  long long v18 = *((_OWORD *)a3 + 2);
  *((_OWORD *)v12 + 2) = *((_OWORD *)a3 + 1);
  *((_OWORD *)v12 + 3) = v18;
  do
  {
    uint64_t v19 = &v12[v13 * 8];
    *(_OWORD *)(v19 + 180) = *(_OWORD *)((char *)&a3[v13 + 20] + 4);
    *(void *)(v19 + 19std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(uint64_t *)((char *)&a3[v13 + 22] + 4);
    v13 += 3;
  }
  while (v13 != 9);
  *(_OWORD *)(v12 + 252) = *(_OWORD *)((char *)a3 + 236);
  *(_OWORD *)(v12 + 268) = *(_OWORD *)((char *)a3 + 252);
  *((_DWORD *)v12 + 7Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((_DWORD *)a3 + 67);
  *((void *)v12 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a3[34];
  *((_DWORD *)v12 + 74) = *((_DWORD *)a3 + 70);
  *(_OWORD *)(v12 + 300) = *(_OWORD *)((char *)a3 + 284);
  float v20 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v21 = *(float *)(a1 + 32);
  if (!v7 || (float)(v21 * (float)v7) < v20)
  {
    BOOL v22 = 1;
    if (v7 >= 3) {
      BOOL v22 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v23 = v22 | (2 * v7);
    unint64_t v24 = vcvtps_u32_f32(v20 / v21);
    if (v23 <= v24) {
      size_t v25 = v24;
    }
    else {
      size_t v25 = v23;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>(a1, v25);
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v6 >= v7) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v26 = *(void *)a1;
  float v27 = *(void **)(*(void *)a1 + 8 * v3);
  if (v27)
  {
    *uint64_t i = *v27;
LABEL_40:
    *float v27 = i;
    goto LABEL_41;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = i;
  *(void *)(v26 + 8 * v3) = a1 + 16;
  if (*i)
  {
    unint64_t v28 = *(void *)(*i + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v28 >= v7) {
        v28 %= v7;
      }
    }
    else
    {
      v28 &= v7 - 1;
    }
    float v27 = (void *)(*(void *)a1 + 8 * v28);
    goto LABEL_40;
  }
LABEL_41:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_221F37D7C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::AudibleEarlyReflection>>>::__emplace_unique_key_args<unsigned long long,unsigned long long &,Phase::SpatialModeler::AudibleEarlyReflection const&>(uint64_t a1, unint64_t *a2, uint64_t *a3, uint64_t a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    double v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t v13 = *a3;
  uint64_t v14 = (char *)operator new(0x140uLL);
  uint64_t i = v14;
  uint64_t v15 = 0;
  *((void *)v14 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v7;
  *((void *)v14 + 2) = v13;
  *((_DWORD *)v14 + 44) = *(_DWORD *)(a4 + 144);
  *(void *)uint64_t v14 = 0;
  long long v16 = *(_OWORD *)(a4 + 112);
  *((_OWORD *)v14 + 8) = *(_OWORD *)(a4 + 96);
  *((_OWORD *)v14 + 9) = v16;
  *((_OWORD *)v14 + 10) = *(_OWORD *)(a4 + 128);
  long long v17 = *(_OWORD *)(a4 + 48);
  *((_OWORD *)v14 + 4) = *(_OWORD *)(a4 + 32);
  *((_OWORD *)v14 + 5) = v17;
  long long v18 = *(_OWORD *)(a4 + 80);
  *((_OWORD *)v14 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_OWORD *)(a4 + 64);
  *((_OWORD *)v14 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v18;
  long long v19 = *(_OWORD *)(a4 + 16);
  *((_OWORD *)v14 + 2) = *(_OWORD *)a4;
  *((_OWORD *)v14 + 3) = v19;
  do
  {
    float v20 = &v14[v15];
    *(_OWORD *)(v20 + 180) = *(_OWORD *)(a4 + v15 + 148);
    *(void *)(v20 + 19std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a4 + v15 + 164);
    v15 += 24;
  }
  while (v15 != 72);
  *(_OWORD *)(v14 + 252) = *(_OWORD *)(a4 + 220);
  *(_OWORD *)(v14 + 268) = *(_OWORD *)(a4 + 236);
  *((_DWORD *)v14 + 7Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(a4 + 252);
  *((void *)v14 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a4 + 256);
  *((_DWORD *)v14 + 74) = *(_DWORD *)(a4 + 264);
  *(_OWORD *)(v14 + 300) = *(_OWORD *)(a4 + 268);
  float v21 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v22 = *(float *)(a1 + 32);
  if (!v8 || (float)(v22 * (float)v8) < v21)
  {
    BOOL v23 = 1;
    if (v8 >= 3) {
      BOOL v23 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v8);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t v26 = v25;
    }
    else {
      size_t v26 = v24;
    }
    std::__hash_table<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,Phase::Controller::OptionalProperties::Property>>>::__rehash<true>(a1, v26);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v27 = *(void *)a1;
  unint64_t v28 = *(void **)(*(void *)a1 + 8 * v4);
  if (v28)
  {
    *uint64_t i = *v28;
LABEL_40:
    *unint64_t v28 = i;
    goto LABEL_41;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = i;
  *(void *)(v27 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v29 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v29 >= v8) {
        v29 %= v8;
      }
    }
    else
    {
      v29 &= v8 - 1;
    }
    unint64_t v28 = (void *)(*(void *)a1 + 8 * v29);
    goto LABEL_40;
  }
LABEL_41:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_221F38030(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::vector<Phase::SpatialModeler::AudibleEarlyReflection>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v6 = a2[1];
  while (v4 != v5)
  {
    v6 -= 288;
    v4 -= 288;
    std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>::construct[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection,Phase::SpatialModeler::AudibleEarlyReflection const&>(v6, v4);
  }
  a2[1] = v6;
  uint64_t v7 = *a1;
  *a1 = v6;
  a2[1] = v7;
  uint64_t v8 = a1[1];
  a1[1] = a2[2];
  a2[2] = v8;
  uint64_t v9 = a1[2];
  a1[2] = a2[3];
  a2[3] = v9;
  *a2 = a2[1];
}

float std::allocator<Phase::SpatialModeler::AudibleEarlyReflection>::construct[abi:ne180100]<Phase::SpatialModeler::AudibleEarlyReflection,Phase::SpatialModeler::AudibleEarlyReflection const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = 0;
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v3;
  long long v4 = *(_OWORD *)(a2 + 32);
  long long v5 = *(_OWORD *)(a2 + 48);
  long long v6 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v6;
  *(_OWORD *)(a1 + 32) = v4;
  *(_OWORD *)(a1 + 48) = v5;
  long long v7 = *(_OWORD *)(a2 + 96);
  long long v8 = *(_OWORD *)(a2 + 112);
  long long v9 = *(_OWORD *)(a2 + 128);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(a2 + 144);
  *(_OWORD *)(a1 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v8;
  *(_OWORD *)(a1 + 128) = v9;
  *(_OWORD *)(a1 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v7;
  uint64_t v10 = a2 + 148;
  do
  {
    unint64_t v11 = (_DWORD *)(a1 + 168 + v2);
    *(v11 - 5) = *(_DWORD *)(v10 + v2);
    *(v11 - 4) = *(_DWORD *)(v10 + v2 + 4);
    *(v11 - 3) = *(_DWORD *)(v10 + v2 + 8);
    *(v11 - 2) = *(_DWORD *)(v10 + v2 + 12);
    *(v11 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(v10 + v2 + 16);
    _DWORD *v11 = *(_DWORD *)(v10 + v2 + 20);
    v2 += 24;
  }
  while (v2 != 72);
  *(_DWORD *)(a1 + 220) = *(_DWORD *)(a2 + 220);
  *(_DWORD *)(a1 + 224) = *(_DWORD *)(a2 + 224);
  *(_DWORD *)(a1 + 228) = *(_DWORD *)(a2 + 228);
  *(_DWORD *)(a1 + 232) = *(_DWORD *)(a2 + 232);
  *(_DWORD *)(a1 + 23std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 236);
  *(_DWORD *)(a1 + 240) = *(_DWORD *)(a2 + 240);
  *(_DWORD *)(a1 + 244) = *(_DWORD *)(a2 + 244);
  *(_DWORD *)(a1 + 248) = *(_DWORD *)(a2 + 248);
  *(_DWORD *)(a1 + 252) = *(_DWORD *)(a2 + 252);
  uint64_t v12 = *(void *)(a2 + 256);
  *(_DWORD *)(a1 + 264) = *(_DWORD *)(a2 + 264);
  *(void *)(a1 + 25std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v12;
  *(_DWORD *)(a1 + 268) = *(_DWORD *)(a2 + 268);
  *(_DWORD *)(a1 + 272) = *(_DWORD *)(a2 + 272);
  *(_DWORD *)(a1 + 27std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 276);
  float result = *(float *)(a2 + 280);
  *(float *)(a1 + 280) = result;
  return result;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_0 &,std::__wrap_iter<Phase::SpatialModeler::EarlyReflectionDetector::AudibleEarlyReflectionWithStatus *>>(uint64_t result, uint64_t a2, void *a3)
{
  if (a2 >= 2)
  {
    uint64_t v3 = (uint64_t)a3 - result;
    int64_t v4 = (unint64_t)(a2 - 2) >> 1;
    if (v4 >= ((uint64_t)a3 - result) >> 4)
    {
      uint64_t v5 = v3 >> 3;
      uint64_t v6 = (v3 >> 3) | 1;
      long long v7 = (void *)(result + 16 * v6);
      uint64_t v8 = v5 + 2;
      if (v8 < a2 && *(float *)(v7[2] + 280) < *(float *)(*v7 + 280))
      {
        v7 += 2;
        uint64_t v6 = v8;
      }
      uint64_t v9 = *a3;
      if (*(float *)(*a3 + 280) >= *(float *)(*v7 + 280))
      {
        uint64_t v10 = a3[1];
        do
        {
          unint64_t v11 = a3;
          a3 = v7;
          _OWORD *v11 = *(_OWORD *)v7;
          if (v4 < v6) {
            break;
          }
          uint64_t v12 = 2 * v6;
          uint64_t v6 = (2 * v6) | 1;
          long long v7 = (void *)(result + 16 * v6);
          uint64_t v13 = v12 + 2;
          if (v13 < a2 && *(float *)(v7[2] + 280) < *(float *)(*v7 + 280))
          {
            v7 += 2;
            uint64_t v6 = v13;
          }
        }
        while (*(float *)(v9 + 280) >= *(float *)(*v7 + 280));
        *a3 = v9;
        a3[1] = v10;
      }
    }
  }
  return result;
}

float *std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *,false>(float *result, float *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (unint64_t)result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                if (*(a2 - 2) < *(float *)v10)
                {
                  uint64_t v37 = *(void *)v10;
                  *(void *)unint64_t v10 = *((void *)a2 - 1);
                  *((void *)a2 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v37;
                }
                break;
              case 3uLL:
                float result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)v10, (float *)(v10 + 8), a2 - 2);
                break;
              case 4uLL:
                float result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)v10, (float *)(v10 + 8), (float *)(v10 + 16), (void *)a2 - 1);
                break;
              case 5uLL:
                unint64_t v38 = (float *)(v10 + 16);
                uint64_t v39 = (uint64_t *)(v10 + 24);
                float result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)v10, (float *)(v10 + 8), (float *)(v10 + 16), (void *)(v10 + 24));
                if (*(a2 - 2) < *(float *)(v10 + 24))
                {
                  uint64_t v40 = *v39;
                  *uint64_t v39 = *((void *)a2 - 1);
                  *((void *)a2 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v40;
                  if (*(float *)v39 < *v38)
                  {
                    uint64_t v41 = *(void *)v38;
                    uint64_t v42 = *v39;
                    *(void *)unint64_t v38 = *v39;
                    *uint64_t v39 = v41;
                    if (*(float *)(v10 + 8) > *(float *)&v42)
                    {
                      uint64_t v43 = *(void *)(v10 + 8);
                      *(void *)(v10 + 8) = v42;
                      *(void *)(v10 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v43;
                      if (*(float *)v10 > *(float *)&v42)
                      {
                        uint64_t v44 = *(void *)v10;
                        *(void *)unint64_t v10 = v42;
                        *(void *)(v10 + 8) = v44;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            unint64_t v45 = (float *)(v10 + 8);
            BOOL v47 = (float *)v10 == a2 || v45 == a2;
            if (a4)
            {
              if (!v47)
              {
                uint64_t v48 = 0;
                unint64_t v49 = v10;
                do
                {
                  unsigned int v50 = v45;
                  float v51 = *(float *)(v49 + 8);
                  if (v51 < *(float *)v49)
                  {
                    int v52 = *(_DWORD *)(v49 + 12);
                    uint64_t v53 = v48;
                    while (1)
                    {
                      *(void *)(v10 + v53 + 8) = *(void *)(v10 + v53);
                      if (!v53) {
                        break;
                      }
                      float v54 = *(float *)(v10 + v53 - 8);
                      v53 -= 8;
                      if (v54 <= v51)
                      {
                        uint64_t v55 = v10 + v53 + 8;
                        goto LABEL_83;
                      }
                    }
                    uint64_t v55 = v10;
LABEL_83:
                    *(float *)uint64_t v55 = v51;
                    *(_DWORD *)(v55 + 4) = v52;
                  }
                  unint64_t v45 = v50 + 2;
                  v48 += 8;
                  unint64_t v49 = (unint64_t)v50;
                }
                while (v50 + 2 != a2);
              }
            }
            else if (!v47)
            {
              do
              {
                unint64_t v81 = (unint64_t)v45;
                float v82 = *(float *)(v9 + 8);
                if (v82 < *(float *)v9)
                {
                  int v83 = *(_DWORD *)(v9 + 12);
                  do
                  {
                    float v84 = v45;
                    uint64_t v85 = *((void *)v45 - 1);
                    v45 -= 2;
                    *(void *)float v84 = v85;
                  }
                  while (*(v84 - 4) > v82);
                  float *v45 = v82;
                  *((_DWORD *)v45 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v83;
                }
                unint64_t v45 = (float *)(v81 + 8);
                unint64_t v9 = v81;
              }
              while ((float *)(v81 + 8) != a2);
            }
            return result;
          }
          if (!a3)
          {
            if ((float *)v10 != a2)
            {
              int64_t v56 = (v12 - 2) >> 1;
              int64_t v57 = v56;
              do
              {
                int64_t v58 = v57;
                if (v56 >= v57)
                {
                  uint64_t v59 = (2 * v57) | 1;
                  float v60 = (float *)(v10 + 8 * v59);
                  if (2 * v58 + 2 < (uint64_t)v12 && *v60 < v60[2])
                  {
                    v60 += 2;
                    uint64_t v59 = 2 * v58 + 2;
                  }
                  int8x8_t v61 = (float *)(v10 + 8 * v58);
                  float v62 = *v61;
                  if (*v60 >= *v61)
                  {
                    int v63 = *((_DWORD *)v61 + 1);
                    do
                    {
                      uint64_t v64 = v61;
                      int8x8_t v61 = v60;
                      *(void *)uint64_t v64 = *(void *)v60;
                      if (v56 < v59) {
                        break;
                      }
                      uint64_t v65 = 2 * v59;
                      uint64_t v59 = (2 * v59) | 1;
                      float v60 = (float *)(v10 + 8 * v59);
                      uint64_t v66 = v65 + 2;
                      if (v66 < (uint64_t)v12 && *v60 < v60[2])
                      {
                        v60 += 2;
                        uint64_t v59 = v66;
                      }
                    }
                    while (*v60 >= v62);
                    float *v61 = v62;
                    *((_DWORD *)v61 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v63;
                  }
                }
                int64_t v57 = v58 - 1;
              }
              while (v58);
              uint64_t v67 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v68 = 0;
                uint64_t v69 = *(void *)v10;
                unint64_t v70 = (float *)v10;
                do
                {
                  uint64_t v71 = v70;
                  v70 += 2 * v68 + 2;
                  uint64_t v72 = 2 * v68;
                  uint64_t v68 = (2 * v68) | 1;
                  uint64_t v73 = v72 + 2;
                  if (v73 < v67 && *v70 < v70[2])
                  {
                    v70 += 2;
                    uint64_t v68 = v73;
                  }
                  *(void *)uint64_t v71 = *(void *)v70;
                }
                while (v68 <= (uint64_t)((unint64_t)(v67 - 2) >> 1));
                a2 -= 2;
                if (v70 == a2)
                {
                  *(void *)unint64_t v70 = v69;
                }
                else
                {
                  *(void *)unint64_t v70 = *(void *)a2;
                  *(void *)a2 = v69;
                  uint64_t v74 = (uint64_t)v70 - v10 + 8;
                  if (v74 >= 9)
                  {
                    unint64_t v75 = (((unint64_t)v74 >> 3) - 2) >> 1;
                    unint64_t v76 = (float *)(v10 + 8 * v75);
                    float v77 = *v70;
                    if (*v76 < *v70)
                    {
                      int v78 = *((_DWORD *)v70 + 1);
                      do
                      {
                        unsigned __int16 v79 = v70;
                        unint64_t v70 = v76;
                        *(void *)unsigned __int16 v79 = *(void *)v76;
                        if (!v75) {
                          break;
                        }
                        unint64_t v75 = (v75 - 1) >> 1;
                        unint64_t v76 = (float *)(v10 + 8 * v75);
                      }
                      while (*v76 < v77);
                      float *v70 = v77;
                      *((_DWORD *)v70 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v78;
                    }
                  }
                }
              }
              while (v67-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          uint64_t v14 = (float *)(v10 + 8 * (v12 >> 1));
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)v9, (float *)(v9 + 8 * (v12 >> 1)), a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)(v9 + 8), v14 - 2, a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)(v9 + 16), (float *)(v9 + 8 + 8 * v13), a2 - 6);
            float result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>(v14 - 2, v14, (float *)(v9 + 8 + 8 * v13));
            uint64_t v15 = *(void *)v9;
            *(void *)unint64_t v9 = *(void *)v14;
            *(void *)uint64_t v14 = v15;
          }
          else
          {
            float result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)(v9 + 8 * (v12 >> 1)), (float *)v9, a2 - 2);
          }
          --a3;
          if (a4) {
            break;
          }
          float v16 = *(float *)v9;
          if (*(float *)(v9 - 8) < *(float *)v9) {
            goto LABEL_13;
          }
          if (*(a2 - 2) <= v16)
          {
            unint64_t v30 = v9 + 8;
            do
            {
              unint64_t v10 = v30;
              if (v30 >= (unint64_t)a2) {
                break;
              }
              v30 += 8;
            }
            while (*(float *)v10 <= v16);
          }
          else
          {
            unint64_t v10 = v9;
            do
            {
              float v29 = *(float *)(v10 + 8);
              v10 += 8;
            }
            while (v29 <= v16);
          }
          unint64_t v31 = a2;
          if (v10 < (unint64_t)a2)
          {
            unint64_t v31 = a2;
            do
            {
              float v32 = *(v31 - 2);
              v31 -= 2;
            }
            while (v32 > v16);
          }
          int v33 = *(_DWORD *)(v9 + 4);
          while (v10 < (unint64_t)v31)
          {
            uint64_t v34 = *(void *)v10;
            *(void *)unint64_t v10 = *(void *)v31;
            *(void *)unint64_t v31 = v34;
            do
            {
              float v35 = *(float *)(v10 + 8);
              v10 += 8;
            }
            while (v35 <= v16);
            do
            {
              float v36 = *(v31 - 2);
              v31 -= 2;
            }
            while (v36 > v16);
          }
          BOOL v4 = v10 - 8 >= v9;
          BOOL v5 = v10 - 8 == v9;
          if (v10 - 8 != v9) {
            *(void *)unint64_t v9 = *(void *)(v10 - 8);
          }
          a4 = 0;
          *(float *)(v10 - 8) = v16;
          *(_DWORD *)(v10 - 4) = v33;
        }
        float v16 = *(float *)v9;
LABEL_13:
        uint64_t v17 = 0;
        int v18 = *(_DWORD *)(v9 + 4);
        do
        {
          float v19 = *(float *)(v9 + v17 + 8);
          v17 += 8;
        }
        while (v19 < v16);
        unint64_t v20 = v9 + v17;
        float v21 = a2;
        if (v17 == 8)
        {
          float v21 = a2;
          do
          {
            if (v20 >= (unint64_t)v21) {
              break;
            }
            float v23 = *(v21 - 2);
            v21 -= 2;
          }
          while (v23 >= v16);
        }
        else
        {
          do
          {
            float v22 = *(v21 - 2);
            v21 -= 2;
          }
          while (v22 >= v16);
        }
        unint64_t v10 = v9 + v17;
        if (v20 < (unint64_t)v21)
        {
          unint64_t v24 = v21;
          do
          {
            uint64_t v25 = *(void *)v10;
            *(void *)unint64_t v10 = *(void *)v24;
            *(void *)unint64_t v24 = v25;
            do
            {
              float v26 = *(float *)(v10 + 8);
              v10 += 8;
            }
            while (v26 < v16);
            do
            {
              float v27 = *(v24 - 2);
              v24 -= 2;
            }
            while (v27 >= v16);
          }
          while (v10 < (unint64_t)v24);
        }
        if (v10 - 8 != v9) {
          *(void *)unint64_t v9 = *(void *)(v10 - 8);
        }
        *(float *)(v10 - 8) = v16;
        *(_DWORD *)(v10 - 4) = v18;
        if (v20 >= (unint64_t)v21) {
          break;
        }
LABEL_32:
        float result = (float *)std::__introsort<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *,false>(v9, v10 - 8, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>(v9, v10 - 8);
      float result = (float *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>(v10, (uint64_t)a2);
      if (result) {
        break;
      }
      if (!v28) {
        goto LABEL_32;
      }
    }
    a2 = (float *)(v10 - 8);
    if (!v28) {
      continue;
    }
    return result;
  }
}

float *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>(float *result, float *a2, float *a3)
{
  float v3 = *a2;
  float v4 = *a3;
  if (*a2 >= *result)
  {
    if (v4 < v3)
    {
      uint64_t v6 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v6;
      if (*a2 < *result)
      {
        uint64_t v7 = *(void *)result;
        *(void *)float result = *(void *)a2;
        *(void *)a2 = v7;
      }
    }
  }
  else
  {
    uint64_t v5 = *(void *)result;
    if (v4 >= v3)
    {
      *(void *)float result = *(void *)a2;
      *(void *)a2 = v5;
      if (*a3 >= *(float *)&v5) {
        return result;
      }
      *(void *)a2 = *(void *)a3;
    }
    else
    {
      *(void *)float result = *(void *)a3;
    }
    *(void *)a3 = v5;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(float *)(a2 - 8) < *(float *)a1)
      {
        uint64_t v6 = *(void *)a1;
        *(void *)a1 = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v6;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)a1, (float *)(a1 + 8), (float *)(a2 - 8));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16), (void *)(a2 - 8));
      return 1;
    case 5:
      float v16 = (float *)(a1 + 16);
      uint64_t v17 = (uint64_t *)(a1 + 24);
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16), (void *)(a1 + 24));
      if (*(float *)(a2 - 8) < *(float *)(a1 + 24))
      {
        uint64_t v18 = *v17;
        *uint64_t v17 = *(void *)(a2 - 8);
        *(void *)(a2 - 8) = v18;
        if (*(float *)v17 < *v16)
        {
          uint64_t v19 = *(void *)v16;
          uint64_t v20 = *v17;
          *(void *)float v16 = *v17;
          *uint64_t v17 = v19;
          if (*(float *)(a1 + 8) > *(float *)&v20)
          {
            uint64_t v21 = *(void *)(a1 + 8);
            *(void *)(a1 + 8) = v20;
            *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v21;
            if (*(float *)a1 > *(float *)&v20)
            {
              uint64_t v22 = *(void *)a1;
              *(void *)a1 = v20;
              *(void *)(a1 + 8) = v22;
            }
          }
        }
      }
      return 1;
    default:
      uint64_t v7 = (float *)(a1 + 16);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>((float *)a1, (float *)(a1 + 8), (float *)(a1 + 16));
      uint64_t v8 = a1 + 24;
      if (a1 + 24 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    float v11 = *(float *)v8;
    if (*(float *)v8 < *v7)
    {
      int v12 = *(_DWORD *)(v8 + 4);
      uint64_t v13 = v9;
      while (1)
      {
        *(void *)(a1 + v13 + 24) = *(void *)(a1 + v13 + 16);
        if (v13 == -16) {
          break;
        }
        float v14 = *(float *)(a1 + v13 + 8);
        v13 -= 8;
        if (v14 <= v11)
        {
          uint64_t v15 = a1 + v13 + 24;
          goto LABEL_13;
        }
      }
      uint64_t v15 = a1;
LABEL_13:
      *(float *)uint64_t v15 = v11;
      *(_DWORD *)(v15 + 4) = v12;
      if (++v10 == 8) {
        return v8 + 8 == a2;
      }
    }
    uint64_t v7 = (float *)v8;
    v9 += 8;
    v8 += 8;
    if (v8 == a2) {
      return 1;
    }
  }
}

float *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>(float *a1, float *a2, float *a3, void *a4)
{
  BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::SpatialModeler::EarlyReflectionDetector::FindEarlyReflections(int,BOOL,float)::$_1 &,Phase::SpatialModeler::EarlyReflectionDetector::AERpair *>(a1, a2, a3);
  if (*(float *)a4 < *a3)
  {
    uint64_t v9 = *(void *)a3;
    *(void *)a3 = *a4;
    *a4 = v9;
    if (*a3 < *a2)
    {
      uint64_t v10 = *(void *)a2;
      *(void *)a2 = *(void *)a3;
      *(void *)a3 = v10;
      if (*a2 < *a1)
      {
        uint64_t v11 = *(void *)a1;
        *(void *)a1 = *(void *)a2;
        *(void *)a2 = v11;
      }
    }
  }
  return result;
}

void *Phase::SpatialModeler::EarlyReflectionsSimulationImpl::AllocClusterQueryState@<X0>(Phase::SpatialModeler::EarlyReflectionsSimulationImpl *this@<X0>, Phase::SpatialModeler::EarlyReflectionsSimulation *a2@<X1>, void *a3@<X8>)
{
  v12[4] = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(*((void *)a2 + 11) + 48)) {
    uint64_t v6 = (char *)this + 26640;
  }
  else {
    uint64_t v6 = (char *)this + 1344;
  }
  uint64_t v7 = v6 + 25256;
  uint64_t v8 = (void *)Phase::SpatialModeler::SingleBlockAllocator::Alloc(v6 + 25256, 137856, 0x10uLL);
  bzero(v8, 0x21A80uLL);
  Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState::ClusterQueryState((Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *)v8);
  v12[0] = &unk_26D4763C8;
  v12[1] = v7;
  void v12[3] = v12;
  uint64_t v10 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v11, (uint64_t)v12);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v12);
  v8[9] = *((void *)this + 3);
  v8[17226] = Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin;
  uint64_t v10 = 0;
  *a3 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v11);
  std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v10, 0);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v11);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin@<X0>(float32x2_t *this@<X0>, Phase::SpatialModeler::RoomSimulation *a2@<X1>, Phase::SpatialModeler::Query *a3@<X2>, Phase::Logger *a4@<X8>)
{
  uint64_t v178 = *MEMORY[0x263EF8340];
  uint64_t Instance = Phase::Logger::GetInstance((Phase::Logger *)this);
  uint64_t v10 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 208));
  uint64_t v159 = v10;
  uint64_t v11 = (Phase::Logger *)Phase::Logger::GetInstance(v10);
  if (*((unsigned char *)v11 + 1192))
  {
    int v12 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v11)
                                                                                        + 1184)));
    uint64_t v13 = v12;
    if ((unint64_t)v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v13, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v10, "Phase_RoomSimulation_EarlyReflectionsBegin", "EarlyReflectionsBegin", buf, 2u);
    }
  }
  uint64_t v158 = (os_signpost_id_t *)&v159;
  Phase::SpatialModeler::RoomSimulationImpl::RoomSimulationBeginInitCommon((Phase::SpatialModeler::RoomSimulationImpl *)this, a2, a3, (uint64_t)v156);
  if (v157 == 2)
  {
    std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__copy_constructor((uint64_t)v155, (uint64_t)v156);
    Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v158, (uint64_t)v155);
    float v14 = v155;
LABEL_20:
    std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v14);
    return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v156);
  }
  uint64_t v15 = (float *)((char *)a3 + 112804);
  uint64_t v16 = *((void *)a2 + 8);
  uint64_t v17 = *((void *)a2 + 11);
  Phase::SpatialModeler::RoomSimulationImpl::ParseOptionalProperties((uint64_t)this, v16, v17, (uint64_t *)a3 + 16940, (float *)a3 + 28218, (float *)a3 + 28215, (uint64_t)buf);
  std::__variant_detail::__assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_assign[abi:ne180100]<std::__variant_detail::__move_assignment<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>>((uint64_t)v156, (uint64_t)buf);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
  if (v157 == 2)
  {
    std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__copy_constructor((uint64_t)v154, (uint64_t)v156);
    Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v158, (uint64_t)v154);
    float v14 = v154;
    goto LABEL_20;
  }
  if (*(unsigned char *)(v17 + 48)) {
    uint64_t v19 = this + 3340;
  }
  else {
    uint64_t v19 = this + 178;
  }
  if (*v15 <= 0.0)
  {
    Phase::SpatialModeler::RayTracerState::State::operator=((uint64_t)&v19[62], (uint64_t)a3 + 113248);
    Phase::SpatialModeler::EarlyReflectionsSimulationImpl::ClusterEarlyReflections((Phase::SpatialModeler::EarlyReflectionsSimulationImpl *)v153, (Phase::SpatialModeler::RoomSimulation *)this, a2, a3);
    Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v158, (uint64_t)v153);
    float v14 = v153;
    goto LABEL_20;
  }
  if (*(unsigned char *)(v17 + 48))
  {
    uint64_t v20 = (*(uint64_t (**)(float32x2_t *, float))(*(void *)this + 104))(this, *v15);
    if (v20 && *(void *)(v20 + 19408))
    {
      Phase::SpatialModeler::RayTracerState::operator=((uint64_t)&this[3340], v20);
      uint64_t v21 = (Phase::Logger *)Phase::SpatialModeler::RoomSimulationImpl::CheckClusterQueryInput((uint64_t)this, a2, (uint64_t)v160);
      if (v161 == 2)
      {
        std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)v151, (uint64_t)v160);
LABEL_154:
        std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v160);
        Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v158, (uint64_t)v151);
        float v14 = v151;
        goto LABEL_20;
      }
      if (this[5766])
      {
        uint64_t v32 = *((void *)a2 + 11);
        long long v143 = (uint64_t *)*((void *)a2 + 12);
        uint64_t v144 = *((void *)a2 + 8);
        int v33 = (int)*(double *)(v32 + 40);
        *(void *)&long long v34 = 0x101010101010101;
        *((void *)&v34 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0x101010101010101;
        v177[0] = v34;
        v177[1] = v34;
        uint64_t v35 = *(void *)(v32 + 144);
        unint64_t v36 = *(void *)(v32 + 96);
        if (v33 <= 1) {
          int v37 = 1;
        }
        else {
          int v37 = v33;
        }
        v162[0] = *(std::align_val_t *)(v32 + 144);
        uint64_t v164 = 8;
        std::vector<unsigned int> v165 = v162;
        *(void *)uint64_t v166 = &v164;
        Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::SubmixRoutingOutput*)#1} const&>(v35, (uint64_t)&v165, __p);
        int v38 = ((v37 - (v35 + v36)) & ((v37 - ((int)v35 + (int)v36)) >> 31)) + v35;
        unint64_t v142 = v36;
        uint64_t v139 = v38 & ~(v38 >> 31);
        uint64_t v39 = __p[0];
        __p[0] = 0;
        *(void *)buf = v39;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&__p[1]);
        *(void *)&unsigned char buf[40] = v35;
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)__p);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&__p[1]);
        long long v140 = v143 + 13;
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::operator=[abi:ne180100](v143 + 13, (uint64_t *)buf);
        unsigned char v143[18] = *(void *)&buf[40];
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
        std::vector<unsigned int> v165 = (std::align_val_t *)(v36 + v139);
        v162[0] = 16;
        Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::RenderGroup*)#1} const&>((Phase::Logger *)__p, v36 + v139, &v165, v162);
        uint64_t v40 = __p[0];
        __p[0] = 0;
        *(void *)buf = v40;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&__p[1]);
        *(void *)&unsigned char buf[40] = v36 + v139;
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)__p);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&__p[1]);
        long long v146 = v143 + 1;
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::operator=[abi:ne180100](v143 + 1, (uint64_t *)buf);
        v143[6] = *(void *)&buf[40];
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
        v162[0] = v36 + v139;
        uint64_t v164 = 1;
        std::vector<unsigned int> v165 = v162;
        *(void *)uint64_t v166 = &v164;
        Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(v36 + v139, (uint64_t)&v165, __p);
        uint64_t v41 = __p[0];
        __p[0] = 0;
        *(void *)buf = v41;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&__p[1]);
        unint64_t v138 = v36 + v139;
        *(void *)&unsigned char buf[40] = v36 + v139;
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)__p);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&__p[1]);
        long long v145 = v143 + 7;
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](v143 + 7, (uint64_t *)buf);
        v143[12] = *(void *)&buf[40];
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
        uint64_t v42 = (float32x2_t *)std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
        unint64_t v44 = *(void *)(v32 + 96);
        if (v44)
        {
          unint64_t v45 = v143;
          unint64_t v46 = v143[6];
          if (v44 >= v46) {
            unint64_t v47 = v143[6];
          }
          else {
            unint64_t v47 = *(void *)(v32 + 96);
          }
          if (v47)
          {
            uint64_t v48 = 0;
            for (uint64_t i = 0; i != v47; ++i)
            {
              unsigned int v50 = (long long *)(*(void *)(v32 + 56) + v48);
              uint64_t v51 = *v146 + v48;
              long long v52 = *v50;
              *(void *)(v51 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((void *)v50 + 2);
              *(_OWORD *)uint64_t v51 = v52;
              *(_DWORD *)(v51 + 24) = *((_DWORD *)v50 + 6);
              *(_DWORD *)(v51 + 28) = *((_DWORD *)v50 + 7);
              *(_DWORD *)(v51 + 32) = *((_DWORD *)v50 + 8);
              *(_DWORD *)(v51 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v50 + 9);
              *(_DWORD *)(v51 + 40) = *((_DWORD *)v50 + 10);
              *(_DWORD *)(v51 + 44) = *((_DWORD *)v50 + 11);
              *(_DWORD *)(v51 + 48) = *((_DWORD *)v50 + 12);
              *(_DWORD *)(v51 + 52) = *((_DWORD *)v50 + 13);
              uint64_t v42 = (float32x2_t *)memcpy((void *)(v51 + 56), (char *)v50 + 56, 0x109uLL);
              unint64_t v53 = *(void *)(*(void *)(v32 + 56) + v48);
              if (v53 <= 0x1F) {
                *((unsigned char *)v177 + v53) = 0;
              }
              *(unsigned char *)(*v145 + i) = 0;
              v48 += 336;
            }
            unint64_t v45 = v143;
            unint64_t v46 = v143[6];
          }
          if (v47 < v46)
          {
            uint64_t v54 = 336 * v47;
            do
            {
              uint64_t v55 = (void *)(v45[1] + v54);
              *uint64_t v55 = 0;
              v55[1] = 0;
              *(unsigned char *)(v45[7] + v47++) = 0;
              v54 += 336;
            }
            while (v47 < v45[6]);
          }
          if (*(void *)(v32 + 96))
          {
            uint64_t v56 = 0;
            unint64_t v57 = 0;
            do
            {
              int64_t v58 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v42) + 1184);
              uint64_t v42 = (float32x2_t *)os_log_type_enabled(v58, OS_LOG_TYPE_DEBUG);
              if (v42)
              {
                uint64_t v59 = *(void *)(*(void *)(v32 + 56) + v56);
                uint64_t v60 = *(void *)(v32 + 96);
                *(_DWORD *)buf = 136316162;
                *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = 751;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&unsigned char buf[20] = v57;
                *(_WORD *)&unsigned char buf[28] = 2048;
                *(void *)&buf[30] = v59;
                *(_WORD *)&unsigned char buf[38] = 2048;
                *(void *)&unsigned char buf[40] = v60;
                _os_log_impl(&dword_221E5E000, v58, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClusterCachedEarlyReflections Previous render group exists; input render group index %zu id "
                  "%llu, number of previous render groups %zu",
                  buf,
                  0x30u);
              }
              ++v57;
              v56 += 336;
            }
            while (v57 < *(void *)(v32 + 96));
          }
        }
        else
        {
          Phase::SpatialModeler::getRendererIdsInERClusteringResults((Phase::SpatialModeler *)&this[3340], (char **)buf);
          unint64_t v68 = v143[6];
          uint64_t v42 = *(float32x2_t **)buf;
          unint64_t v69 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 4;
          if (v69 >= v68) {
            unint64_t v69 = v143[6];
          }
          if (v69)
          {
            uint64_t v70 = 0;
            uint64_t v71 = 0;
            unint64_t v72 = v69;
            do
            {
              *(_OWORD *)(*v146 + v70) = *(_OWORD *)v42[v71].f32;
              uint64_t v42 = *(float32x2_t **)buf;
              unint64_t v73 = *(void *)(*(void *)buf + v71 * 8);
              if (v73 <= 0x1F) {
                *((unsigned char *)v177 + v73) = 0;
              }
              v70 += 336;
              v71 += 2;
              --v72;
            }
            while (v72);
            unint64_t v68 = v143[6];
          }
          if (v69 < v68)
          {
            uint64_t v74 = 336 * v69;
            do
            {
              unint64_t v75 = (void *)(v143[1] + v74);
              *unint64_t v75 = 0;
              v75[1] = 0;
              ++v69;
              v74 += 336;
            }
            while (v69 < v143[6]);
            uint64_t v42 = *(float32x2_t **)buf;
          }
          if (v42)
          {
            *(void *)&uint8_t buf[8] = v42;
            operator delete(v42);
          }
        }
        if (!*(void *)(v32 + 144))
        {
          unint64_t v141 = 0;
          unsigned __int16 v79 = v143;
LABEL_145:
          if (v141 <= v142 - 1) {
            unint64_t v126 = v142 - 1;
          }
          else {
            unint64_t v126 = v141;
          }
          if (v126 < v79[6])
          {
            std::vector<unsigned int> v165 = (std::align_val_t *)(v126 + 1);
            v162[0] = 16;
            Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::RenderGroup*)#1} const&>((Phase::Logger *)buf, v126 + 1, &v165, v162);
            uint64_t v127 = *(void **)buf;
            *(void *)buf = 0;
            __p[0] = v127;
            std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&__p[1], (uint64_t)&buf[8]);
            uint64_t v170 = v126 + 1;
            std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
            uint64_t v163 = 1;
            uint64_t v164 = v126 + 1;
            v162[0] = (std::align_val_t)&v164;
            v162[1] = (std::align_val_t)&v163;
            Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(v126 + 1, (uint64_t)v162, buf);
            uint64_t v128 = *(void *)buf;
            *(void *)buf = 0;
            std::vector<unsigned int> v165 = (std::align_val_t *)v128;
            std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v166, (uint64_t)&buf[8]);
            uint64_t v167 = v126 + 1;
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
            uint64_t v129 = 0;
            unint64_t v130 = v126 + 1;
            uint64_t v131 = 56;
            do
            {
              unint64_t v132 = (void *)(*v146 + v131);
              unint64_t v133 = (char *)__p[0] + v131;
              long long v134 = *(_OWORD *)(v132 - 7);
              *((void *)v133 - 5) = *(v132 - 5);
              *(_OWORD *)(v133 - 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v134;
              *((_DWORD *)v133 - 8) = *((_DWORD *)v132 - 8);
              *((_DWORD *)v133 - std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *((_DWORD *)v132 - 7);
              *((_DWORD *)v133 - std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v132 - 6);
              *((_DWORD *)v133 - 5) = *((_DWORD *)v132 - 5);
              *((_DWORD *)v133 - 4) = *((_DWORD *)v132 - 4);
              *((_DWORD *)v133 - 3) = *((_DWORD *)v132 - 3);
              *((_DWORD *)v133 - 2) = *((_DWORD *)v132 - 2);
              *((_DWORD *)v133 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *((_DWORD *)v132 - 1);
              memcpy(v133, v132, 0x109uLL);
              *((unsigned char *)v165 + v129) = *(unsigned char *)(*v145 + v129);
              ++v129;
              v131 += 336;
            }
            while (v130 != v129);
            uint64_t v135 = __p[0];
            __p[0] = 0;
            *(void *)buf = v135;
            std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&__p[1]);
            *(void *)&unsigned char buf[40] = v170;
            std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)__p, v146);
            uint64_t v170 = v143[6];
            std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::operator=[abi:ne180100](v146, (uint64_t *)buf);
            v143[6] = *(void *)&buf[40];
            std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
            unint64_t v136 = std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
            uint64_t v137 = (uint64_t)v165;
            std::vector<unsigned int> v165 = 0;
            *(void *)buf = v137;
            std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v136, (uint64_t)v166);
            *(void *)&unsigned char buf[40] = v167;
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v165, v145);
            uint64_t v167 = v143[12];
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](v145, (uint64_t *)buf);
            v143[12] = *(void *)&buf[40];
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
            std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v165);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v166);
            std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)__p);
            std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&__p[1]);
          }
          Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryCleanupCommon((Phase::SpatialModeler::RoomSimulationImpl *)this, a2, a3, v43);
          int v125 = 1;
          goto LABEL_153;
        }
        unint64_t v76 = 0;
        unint64_t v141 = 0;
        uint64_t v77 = 16;
        unsigned __int16 v79 = v143;
        uint64_t v78 = v144;
        while (1)
        {
          uint64_t v80 = *(void *)(v32 + 104);
          uint64_t v81 = v80 + 304 * v76;
          uint64_t v82 = *(void *)(v81 + 144);
          if (*(_DWORD *)(v78 + 136) <= v82) {
            break;
          }
          uint64_t v83 = *(void *)(v144 + 120);
          if (*(_DWORD *)(v83 + 24 * v82 + 20) != HIDWORD(v82)) {
            break;
          }
          uint64_t v42 = *(float32x2_t **)(v83 + 24 * *(void *)(v81 + 144));
          if (!v42 || v42->i32[0] != 3) {
            break;
          }
          float v84 = this[6190].f32[0] - v42[9].f32[0];
          float32x2_t v85 = vsub_f32(this[6189], v42[8]);
          float v86 = sqrtf(vaddv_f32(vmul_f32(v85, v85)) + (float)(v84 * v84));
          if (v86 <= 1000000.0) {
            float v87 = v86;
          }
          else {
            float v87 = 1000000.0;
          }
          uint64_t v88 = *(unsigned int *)(v81 + 140);
          if (v88)
          {
            float v89 = (float *)(v80 + v77);
            float v90 = -3.4028e38;
            do
            {
              float v91 = *v89++;
              float v92 = v91;
              if (v90 < v91) {
                float v90 = v92;
              }
              --v88;
            }
            while (v88);
          }
          else
          {
            float v90 = -3.4028e38;
          }
          v162[0] = *(std::align_val_t *)(*(void *)&this[5765] + 16);
          *(_OWORD *)std::string __p = xmmword_2220A59B0;
          LODWORD(v164) = 0;
          LODWORD(v163) = 2139095039;
          Phase::SpatialModeler::getClosestERClusterToSourceInClusteringResults(v42, &this[3340], v162, __p, &v164, (float *)&v163);
          if ((int)v139 < 1 || *(float *)&v163 < 0.005)
          {
            uint64_t v107 = v79[13];
            uint64_t v109 = (unint64_t *)(v107 + 16 * v76);
            *uint64_t v109 = 0;
            uint64_t v110 = v79[6];
            if (v110)
            {
              unint64_t v108 = 0;
              uint64_t v111 = *v146;
              while (*(void **)v111 != __p[0] || *(void **)(v111 + 8) != __p[1])
              {
                ++v108;
                v111 += 336;
                if (v110 == v108) {
                  goto LABEL_124;
                }
              }
              *(unsigned char *)(*v145 + v108) = 0;
              *(unsigned char *)(v111 + 320) = 1;
              *uint64_t v109 = v108;
              unint64_t v112 = v141;
              if (v141 <= v108) {
                unint64_t v112 = v108;
              }
              unint64_t v141 = v112;
            }
            else
            {
LABEL_124:
              unint64_t v108 = 0;
            }
          }
          else if (v142 >= v138)
          {
            uint64_t v107 = *v140;
            *(void *)(*v140 + 16 * v7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v141;
            unint64_t v108 = v141;
          }
          else
          {
            uint64_t NextAvailable = Phase::SpatialModeler::IndexStore<32ul,1ull,0ull>::GetNextAvailable((uint64_t)v177);
            uint64_t v94 = (uint64_t *)(*v146 + 336 * v142);
            *uint64_t v94 = NextAvailable;
            v94[1] = 0;
            *(void *)(*v140 + 16 * v7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v142;
            unint64_t v95 = v141;
            if (v141 <= v142) {
              unint64_t v95 = v142;
            }
            unint64_t v141 = v95;
            *(float *)&std::vector<unsigned int> v165 = v90;
            *((float *)&v165 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v90;
            v166[0] = v90;
            uint64_t v96 = (Phase::Logger *)Phase::Subbands<float>::Subbands((uint64_t)buf, &v165, 3);
            uint64_t v97 = (_OWORD *)(*v146 + 336 * v142);
            long long v98 = *(_OWORD *)buf;
            long long v99 = *(_OWORD *)&buf[16];
            long long v100 = v172;
            v97[14] = *(_OWORD *)&buf[32];
            v97[15] = v100;
            v97[12] = v98;
            v97[13] = v99;
            long long v101 = v173;
            long long v102 = v174;
            long long v103 = v176;
            v97[18] = v175;
            v97[19] = v103;
            v97[16] = v101;
            v97[17] = v102;
            uint64_t v104 = *v146 + 336 * v142;
            *(std::align_val_t *)(v104 + 184) = v162[0];
            *(unsigned char *)(v104 + 320) = 1;
            *(unsigned char *)(*v145 + v142) = 1;
            double v105 = **(id **)(Phase::Logger::GetInstance(v96) + 1184);
            uint64_t v42 = (float32x2_t *)os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG);
            if (v42)
            {
              uint64_t v106 = *(void *)(*v146 + 336 * v142);
              *(_DWORD *)buf = 136315906;
              *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 866;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&unsigned char buf[20] = v106;
              *(_WORD *)&unsigned char buf[28] = 2048;
              *(void *)&buf[30] = v76;
              _os_log_impl(&dword_221E5E000, v105, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClusterCachedEarlyReflections setting NEW render group ID %llu to submix %llu", buf, 0x26u);
            }
            unsigned __int16 v79 = v143;
            ++v142;
            uint64_t v107 = *v140;
            unint64_t v108 = *(void *)(*v140 + 16 * v76);
            LODWORD(v139) = v139 - 1;
          }
          float v113 = (float)(fmaxf(v87, 1.0) * -0.5) + -6.0;
          if (v113 >= *(float *)&v164) {
            float v114 = *(float *)&v164;
          }
          else {
            float v114 = (float)(v113 + *(float *)&v164) * 0.5;
          }
          double v115 = v114;
          *(double *)(v107 + 16 * v76 + 8) = v115;
          if (v108 < v79[6])
          {
            uint64_t v116 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v42) + 1184);
            uint64_t v42 = (float32x2_t *)os_log_type_enabled(v116, OS_LOG_TYPE_DEBUG);
            unsigned __int16 v79 = v143;
            if (v42)
            {
              uint64_t v117 = *(void *)(*(void *)(v32 + 104) + 304 * v76);
              float v118 = (uint64_t *)(*v140 + 16 * v76);
              uint64_t v120 = *v118;
              uint64_t v119 = v118[1];
              uint64_t v121 = *(void *)(*v146 + 336 * v120);
              int v122 = *(unsigned __int8 *)(v32 + 48);
              *(_DWORD *)buf = 136316674;
              *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 892;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&unsigned char buf[20] = v117;
              *(_WORD *)&unsigned char buf[28] = 2048;
              *(void *)&buf[30] = v121;
              *(_WORD *)&unsigned char buf[38] = 2048;
              *(void *)&unsigned char buf[40] = v120;
              LOWORD(v172) = 2048;
              *(void *)((char *)&v172 + 2) = v119;
              WORD5(v172) = 1024;
              HIDWORD(v172) = v122;
              _os_log_impl(&dword_221E5E000, v116, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClusterCachedEarlyReflections end Submix %llu assigned to render group %llu at index %lu, send level %f attack query %d", buf, 0x40u);
            }
            uint64_t v107 = *v140;
            double v115 = *(double *)(*v140 + 16 * v76 + 8);
          }
          float v123 = v115;
          uint64_t v78 = v144;
          if (*(void *)(v144 + 904)) {
            float v123 = v123 + (float)(*(float *)(v144 + 928) * (float)(0.0 - v123));
          }
          *(double *)(v107 + 16 * v76++ + 8) = v123;
          v77 += 304;
          if (v76 >= *(void *)(v32 + 144)) {
            goto LABEL_145;
          }
        }
        float32x2_t v124 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v42) + 1184);
        if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 785;
          _os_log_impl(&dword_221E5E000, v124, OS_LOG_TYPE_ERROR, "%25s:%-5d ClusterCachedEarlyReflections: Query input source not found in Geo Layer", buf, 0x12u);
        }
        uint64_t v66 = this + 9;
        uint64_t v67 = 6;
      }
      else
      {
        uint64_t v65 = **(id **)(Phase::Logger::GetInstance(v21) + 1184);
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315394;
          *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 700;
          _os_log_impl(&dword_221E5E000, v65, OS_LOG_TYPE_ERROR, "%25s:%-5d ER attack graph called ClusterCachedEarlyReflections but mERClusteringResults is empty", buf, 0x12u);
        }
        uint64_t v66 = this + 9;
        uint64_t v67 = 4;
      }
      v151[0] = v67;
      v151[1] = v66;
      int v125 = 2;
LABEL_153:
      int v152 = v125;
      goto LABEL_154;
    }
  }
  else
  {
    Phase::SpatialModeler::RoomSimulationImpl::RoomSimulationBeginHandleSustainQueryCommon((Phase::SpatialModeler::RoomSimulationImpl *)this, a2, a3, (Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *)&this[178], v18);
    uint64_t v24 = 0;
    uint64_t v25 = this + 3029;
    do
    {
      int v26 = v25->u8[v24];
      if (v25->i8[v24]) {
        BOOL v27 = 1;
      }
      else {
        BOOL v27 = v24 == 18;
      }
      ++v24;
    }
    while (!v27);
    if (v26) {
      goto LABEL_31;
    }
    if (this[202].i8[3]) {
      goto LABEL_40;
    }
    uint64_t v61 = 0;
    float v62 = (char *)&this[3031] + 3;
    do
    {
      int v63 = v62[v61];
      if (v62[v61]) {
        BOOL v64 = 1;
      }
      else {
        BOOL v64 = v61 == 18;
      }
      ++v61;
    }
    while (!v64);
    if (v63)
    {
LABEL_31:
      if (!this[3308].i8[0] || this[193].f32[0] != *((float *)a3 + 28218) || this[184].f32[1] != *v15)
      {
        BOOL v28 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v23)
                                                                                            + 1184)));
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
        {
          Phase::SpatialModeler::RoomSimulationLogging::MakeInfoString((uint64_t)&this[178], this[4].i32[0]);
          float v29 = v169 >= 0 ? __p : (void **)__p[0];
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 203;
          *(_WORD *)&unsigned char buf[18] = 2080;
          *(void *)&unsigned char buf[20] = v29;
          _os_log_impl(&dword_221E5E000, v28, OS_LOG_TYPE_DEBUG, "%25s:%-5d %s", buf, 0x1Cu);
          if (v169 < 0) {
            operator delete(__p[0]);
          }
        }
      }
    }
    else
    {
LABEL_40:
      Phase::SpatialModeler::RayTracerState::State::operator=((uint64_t)&this[240], (uint64_t)a3 + 113248);
      Phase::SpatialModeler::EarlyReflectionsSimulationImpl::ClusterEarlyReflections((Phase::SpatialModeler::EarlyReflectionsSimulationImpl *)v149, (Phase::SpatialModeler::RoomSimulation *)this, a2, a3);
      Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()((Phase::Logger *)v150, &v158, (uint64_t)v149);
      std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v150);
      std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v149);
    }
  }
  int v30 = *(_DWORD *)(v16 + 168)
     && !*(unsigned char *)(v16 + 932)
     && *(void *)&this[6] <= (unint64_t)((uint64_t)(*(void *)&v19[2617] - *(void *)&v19[2616]) >> 2);
  Phase::SpatialModeler::RoomSimulationImpl::PrepareRayTrace(a3, (Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *)v19, (Phase::SpatialModeler::RayTracerState *)this[7].u32[1], v30);
  unint64_t v31 = operator new(8uLL);
  void *v31 = a3;
  memset(buf, 0, 24);
  std::vector<Phase::Geometry::SceneQueryBatch *>::__init_with_size[abi:ne180100]<Phase::Geometry::SceneQueryBatch **,Phase::Geometry::SceneQueryBatch **>(buf, v31, (uint64_t)(v31 + 1), 1uLL);
  operator delete(v31);
  memset(v147, 0, sizeof(v147));
  std::vector<Phase::Geometry::SceneQueryBatch *>::__init_with_size[abi:ne180100]<Phase::Geometry::SceneQueryBatch **,Phase::Geometry::SceneQueryBatch **>(v147, *(const void **)buf, *(uint64_t *)&buf[8], (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
  int v148 = 3;
  Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v158, (uint64_t)v147);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v147);
  if (*(void *)buf)
  {
    *(void *)&uint8_t buf[8] = *(void *)buf;
    operator delete(*(void **)buf);
  }
  return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v156);
}

void sub_221F3A0F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62)
{
}

void Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RunCullQuery(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(_DWORD *)(*(void *)(a1 + 96) + 8) = 0;
  *(_DWORD *)(a2 + 24) = 1;
}

void Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RunClusterQuery(Phase::Logger *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  if (a3)
  {
    if (*(unsigned char *)(*(void *)(a2 + 88) + 48)) {
      uint64_t v8 = (char *)a1 + 26640;
    }
    else {
      uint64_t v8 = (char *)a1 + 1344;
    }
    uint64_t v9 = (uint64_t (**)(Phase::Logger *, uint64_t, uint64_t))(a3 + 137808);
    if (*(uint64_t (**)@<X0>(float32x2_t *@<X0>, Phase::SpatialModeler::RoomSimulation *@<X1>, Phase::SpatialModeler::Query *@<X2>, Phase::Logger *@<X8>))(a3 + 137808) == Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin)
    {
      uint64_t Instance = Phase::Logger::GetInstance(a1);
      uint64_t v11 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 208));
      *((void *)v8 + 296std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v11;
      int v12 = (Phase::Logger *)Phase::Logger::GetInstance(v11);
      if (*((unsigned char *)v12 + 1192))
      {
        uint64_t v13 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v12)
                                                                                            + 1184)));
        float v14 = v13;
        os_signpost_id_t v15 = *((void *)v8 + 2966);
        if (v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_221E5E000, v14, OS_SIGNPOST_INTERVAL_BEGIN, v15, "Phase_RoomSimulation_ERClusterQuery", "EarlyReflectionsClusterQuery", buf, 2u);
        }
      }
    }
    uint64_t v16 = (Phase::Logger *)(*v9)(a1, a2, a3);
    if (*(_DWORD *)(a4 + 24) == 1)
    {
      uint64_t v17 = (Phase::Logger *)Phase::Logger::GetInstance(v16);
      if (*((unsigned char *)v17 + 1192))
      {
        uint64_t v18 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v17)
                                                                                            + 1184)));
        uint64_t v19 = v18;
        os_signpost_id_t v20 = *((void *)v8 + 2966);
        if (v20 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v18))
        {
          *(_WORD *)uint64_t v21 = 0;
          _os_signpost_emit_with_name_impl(&dword_221E5E000, v19, OS_SIGNPOST_INTERVAL_END, v20, "Phase_RoomSimulation_ERClusterQuery", (const char *)&unk_222112ABB, v21, 2u);
        }
      }
    }
  }
  else
  {
    *(void *)a4 = 1;
    *(void *)(a4 + 8) = (char *)a1 + 72;
    *(_DWORD *)(a4 + 24) = 2;
  }
}

void sub_221F3A3FC(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RunSpatialQuery(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v112 = *MEMORY[0x263EF8340];
  uint64_t Instance = Phase::Logger::GetInstance((Phase::Logger *)a1);
  uint64_t v7 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 208));
  uint64_t v8 = (Phase::Logger *)Phase::Logger::GetInstance(v7);
  if (*((unsigned char *)v8 + 216))
  {
    uint64_t v9 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v8)
                                                                                       + 208)));
    uint64_t v10 = v9;
    if ((unint64_t)v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v10, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v7, "Phase_LateReverb_Spatial_Query_Begin", "EarlyReflectionsSimulation: Spatial Query Begin", buf, 2u);
    }
  }
  uint64_t v11 = Phase::Logger::GetInstance(v8);
  int v12 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(v11 + 208));
  uint64_t v13 = (Phase::Logger *)Phase::Logger::GetInstance(v12);
  if (*((unsigned char *)v13 + 1192))
  {
    float v14 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v13)
                                                                                        + 1184)));
    os_signpost_id_t v15 = v14;
    if ((unint64_t)v12 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v15, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v12, "Phase_RoomSimulation_ERSpatialQuery", "EarlyReflectionsSpatialQuery", buf, 2u);
    }
  }
  uint64_t v16 = Phase::Logger::GetInstance(v13);
  uint64_t v17 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(v16 + 416));
  uint64_t v18 = (Phase::Logger *)Phase::Logger::GetInstance(v17);
  if (*((unsigned char *)v18 + 1192))
  {
    uint64_t v19 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v18)
                                                                                        + 1184)));
    os_signpost_id_t v20 = v19;
    if ((unint64_t)v17 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v20, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v17, "Phase_RoomSimulation_HandleResultsEarlyReflections", "EarlyReflectionsHandleResults", buf, 2u);
    }
  }
  uint64_t v21 = Phase::SpatialModeler::RoomSimulationImpl::CheckSpatialQueryInput(a1, a2, (uint64_t)v107);
  if (v108 == 2)
  {
    std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor(a3, (uint64_t)v107);
    goto LABEL_89;
  }
  uint64_t v23 = a2[8];
  uint64_t v24 = a2[11];
  uint64_t v25 = *(void *)(v24 + 552);
  if (*(_DWORD *)(v23 + 136) <= v25
    || (uint64_t v26 = *(void *)(v23 + 120), *(_DWORD *)(v26 + 24 * v25 + 20) != HIDWORD(v25))
    || (BOOL v27 = *(float32x2_t **)(v26 + 24 * *(void *)(v24 + 552))) == 0
    || v27->i32[0] != 2)
  {
    BOOL v27 = 0;
  }
  uint64_t v106 = v27;
  uint64_t v28 = a2[12];
  if (*(void *)(v24 + 208))
  {
    float v29 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v21) + 1184);
    uint64_t v21 = os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
    if (v21)
    {
      *(_DWORD *)buf = 136315394;
      *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 955;
      _os_log_impl(&dword_221E5E000, v29, OS_LOG_TYPE_ERROR, "%25s:%-5d ER Spatial Query is called with an individual source but must be called with a cluster key.", buf, 0x12u);
    }
  }
  if (*(unsigned char *)(v24 + 48)) {
    uint64_t v30 = a1 + 26720;
  }
  else {
    uint64_t v30 = a1 + 1424;
  }
  unint64_t v31 = (_DWORD *)(v30 + 19016);
  if (*(float *)(v30 + 19512) > 0.0 && *v31)
  {
    if (!*(unsigned char *)(v30 + 168)) {
      goto LABEL_133;
    }
    uint64_t v32 = 0;
    uint64_t v33 = v30 + 22808;
    do
    {
      int v34 = *(unsigned __int8 *)(v33 + v32);
      if (*(unsigned char *)(v33 + v32)) {
        BOOL v35 = 1;
      }
      else {
        BOOL v35 = v32 == 18;
      }
      ++v32;
    }
    while (!v35);
    if (v34) {
      goto LABEL_133;
    }
    uint64_t v36 = 0;
    uint64_t v37 = v30 + 22827;
    do
    {
      int v38 = *(unsigned __int8 *)(v37 + v36);
      if (*(unsigned char *)(v37 + v36)) {
        BOOL v39 = 1;
      }
      else {
        BOOL v39 = v36 == 18;
      }
      ++v36;
    }
    while (!v39);
    if (v38)
    {
LABEL_133:
      float v40 = (float)(*(float *)(v30 + 19308) / (float)(*v31 - *(_DWORD *)(v30 + 64))) * 100.0;
      if (v40 > 3.0)
      {
        uint64_t v41 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v21) + 1184);
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 971;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(double *)&unsigned char buf[20] = v40;
          _os_log_impl(&dword_221E5E000, v41, OS_LOG_TYPE_ERROR, "%25s:%-5d High energy loss: %.1f%%.\n", buf, 0x1Cu);
        }
      }
    }
  }
  Phase::SpatialModeler::RoomSimulationLogging::logInvalidIntersections((Phase::SpatialModeler::RoomSimulationLogging *)v30, v22);
  int8x8_t v43 = *(int8x8_t *)(v30 + 19392);
  if (!*(void *)&v43) {
    goto LABEL_65;
  }
  unint64_t v44 = *(void *)(v24 + 376);
  uint8x8_t v45 = (uint8x8_t)vcnt_s8(v43);
  v45.i16[0] = vaddlv_u8(v45);
  if (v45.u32[0] > 1uLL)
  {
    unint64_t v46 = *(void *)(v24 + 376);
    if (*(void *)&v43 <= v44) {
      unint64_t v46 = v44 % *(void *)&v43;
    }
  }
  else
  {
    unint64_t v46 = (*(void *)&v43 - 1) & v44;
  }
  unint64_t v47 = *(void **)(*(void *)(v30 + 19384) + 8 * v46);
  if (!v47 || (uint64_t v48 = (void *)*v47) == 0)
  {
LABEL_65:
    if (*(void *)(v24 + 208))
    {
      unsigned int v50 = **(id **)(Phase::Logger::GetInstance(v42) + 1184);
      if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        goto LABEL_71;
      }
      uint64_t v51 = *(void *)(v24 + 376);
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1058;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&unsigned char buf[20] = v51;
      long long v52 = "%25s:%-5d No early directional metadata found for given cluster key %llu.";
    }
    else
    {
      unsigned int v50 = **(id **)(Phase::Logger::GetInstance(v42) + 1184);
      if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        goto LABEL_71;
      }
      uint64_t v53 = *(void *)(v24 + 208);
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 1053;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&unsigned char buf[20] = v53;
      long long v52 = "%25s:%-5d No early directional metadata found for given sound source handle %llu.";
    }
    _os_log_impl(&dword_221E5E000, v50, OS_LOG_TYPE_ERROR, v52, buf, 0x1Cu);
    goto LABEL_71;
  }
  while (1)
  {
    unint64_t v49 = v48[1];
    if (v49 == v44) {
      break;
    }
    if (v45.u32[0] > 1uLL)
    {
      if (v49 >= *(void *)&v43) {
        v49 %= *(void *)&v43;
      }
    }
    else
    {
      v49 &= *(void *)&v43 - 1;
    }
    if (v49 != v46) {
      goto LABEL_65;
    }
LABEL_64:
    uint64_t v48 = (void *)*v48;
    if (!v48) {
      goto LABEL_65;
    }
  }
  if (v48[2] != v44) {
    goto LABEL_64;
  }
  unint64_t v75 = (Phase::Logger *)Phase::SpatialModeler::CopyMetadata<float>((uint64_t)(v48 + 8), v28);
  uint64_t v76 = *(void *)(a1 + 48);
  memset(buf, 0, sizeof(buf));
  unsigned int v111 = v76;
  uint64_t v77 = (Phase::Logger *)Phase::Logger::GetInstance(v75);
  if (*(void *)(a1 + 48) == (uint64_t)(*((void *)v77 + 182) - *((void *)v77 + 181)) >> 2)
  {
    uint64_t v78 = (Phase::Logger *)Phase::Logger::GetInstance(v77);
    unsigned __int16 v79 = (unsigned char *)*((void *)v78 + 181);
    uint64_t v80 = Phase::Logger::GetInstance(v78);
    uint64_t v81 = *(unsigned char **)(v80 + 1456);
    if (v81 != v79) {
      uint64_t v80 = (uint64_t)memmove(buf, v79, v81 - v79);
    }
  }
  else
  {
    if (v111) {
      bzero(buf, 4 * v111);
    }
    uint64_t v82 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v77)
                                                                                        + 1184)));
    BOOL v83 = os_log_type_enabled(v82, OS_LOG_TYPE_ERROR);
    if (v83)
    {
      uint64_t v84 = Phase::Logger::GetInstance((Phase::Logger *)v83);
      uint64_t v85 = (uint64_t)(*(void *)(v84 + 1456) - *(void *)(v84 + 1448)) >> 2;
      uint64_t v86 = *(void *)(a1 + 48);
      *(_DWORD *)uint64_t v109 = 136315906;
      *(void *)&v109[4] = "EarlyReflectionsSimulationImpl.mm";
      *(_WORD *)&v109[12] = 1024;
      *(_DWORD *)&v109[14] = 1005;
      *(_WORD *)&v109[18] = 2048;
      *(void *)&v109[20] = v85;
      *(_WORD *)&v109[28] = 2048;
      *(void *)&v109[30] = v86;
      _os_log_impl(&dword_221E5E000, v82, OS_LOG_TYPE_ERROR, "%25s:%-5d Error setting phase_room_eq_er: Its sub-band count of %zu does not match the modeler internal sub-band count of %zu", v109, 0x26u);
    }
  }
  if ((*(_DWORD *)(v23 + 168) | 2) != 3) {
    goto LABEL_113;
  }
  uint64_t v80 = Phase::Logger::GetInstance((Phase::Logger *)v80);
  if (!*(unsigned char *)(v80 + 1440) || *(unsigned char *)(v23 + 932)) {
    goto LABEL_113;
  }
  uint64_t v87 = *(void *)(a1 + 48);
  switch(v87)
  {
    case 31:
      long long v88 = *(_OWORD *)(v23 + 584);
      *(_OWORD *)&v109[64] = *(_OWORD *)(v23 + 568);
      *(_OWORD *)&v109[80] = v88;
      *(_OWORD *)&v109[96] = *(_OWORD *)(v23 + 600);
      *(_OWORD *)&v109[108] = *(_OWORD *)(v23 + 612);
      long long v89 = *(_OWORD *)(v23 + 520);
      *(_OWORD *)uint64_t v109 = *(_OWORD *)(v23 + 504);
      *(_OWORD *)&v109[16] = v89;
      long long v90 = *(_OWORD *)(v23 + 552);
      *(_OWORD *)&v109[32] = *(_OWORD *)(v23 + 536);
      *(_OWORD *)&v109[48] = v90;
      *(_DWORD *)&v109[124] = 31;
LABEL_112:
      Phase::Subbands<float>::operator+=((float32x4_t *)buf, (float32x4_t *)v109);
      goto LABEL_113;
    case 10:
      long long v91 = *(_OWORD *)(v23 + 276);
      *(_OWORD *)uint64_t v109 = *(_OWORD *)(v23 + 260);
      *(_OWORD *)&v109[16] = v91;
      *(void *)&v109[32] = *(void *)(v23 + 292);
      memset(&v109[40], 0, 80);
      *(void *)&v109[120] = 0xA00000000;
      goto LABEL_112;
    case 3:
      *(void *)uint64_t v109 = *(void *)(v23 + 184);
      *(_DWORD *)&v109[8] = *(_DWORD *)(v23 + 192);
      *(_DWORD *)&v109[124] = 3;
      memset(&v109[12], 0, 112);
      goto LABEL_112;
  }
  long long v103 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v80) + 1184);
  uint64_t v80 = os_log_type_enabled(v103, OS_LOG_TYPE_ERROR);
  if (v80)
  {
    uint64_t v104 = *(void *)(a1 + 48);
    *(_DWORD *)uint64_t v109 = 136315650;
    *(void *)&v109[4] = "EarlyReflectionsSimulationImpl.mm";
    *(_WORD *)&v109[12] = 1024;
    *(_DWORD *)&v109[14] = 1034;
    *(_WORD *)&v109[18] = 2048;
    *(void *)&v109[20] = v104;
    _os_log_impl(&dword_221E5E000, v103, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported sub-band count: %zu\n", v109, 0x1Cu);
  }
LABEL_113:
  if (*(void *)(a1 + 48))
  {
    uint64_t v92 = 0;
    unsigned int v93 = 1;
    do
    {
      *(float *)&buf[4 * v92] = __exp10f(*(float *)&buf[4 * v92] / 20.0);
      uint64_t v92 = v93;
    }
    while (*(void *)(a1 + 48) > (unint64_t)v93++);
  }
  uint64_t v105 = a3;
  unint64_t v95 = *(vDSP_Length **)(v28 + 104);
  if (v95)
  {
    vDSP_Length v96 = *v95;
    if (*v95)
    {
      vDSP_Length v97 = v95[1];
      if (v97)
      {
        if (v97 == v111)
        {
          if (v96 <= 4 * v97)
          {
            uint64_t v101 = 0;
            do
            {
              long long v102 = (float *)(*(void *)(v28 + 104) + 4 * *(void *)(*(void *)(v28 + 104) + 8) * v101 + 16);
              vDSP_vmul(v102, 1, (const float *)buf, 1, v102, 1, v97);
              ++v101;
            }
            while (v96 != v101);
          }
          else
          {
            uint64_t v98 = 0;
            vDSP_Length v99 = v95[1];
            do
            {
              vDSP_vsmul((const float *)(*(void *)(v28 + 104) + v98 + 16), v97, (const float *)&buf[v98], (float *)(*(void *)(v28 + 104) + v98 + 16), v97, v96);
              v98 += 4;
              --v99;
            }
            while (v99);
          }
        }
        else
        {
          long long v100 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v80) + 224);
          if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t v109 = 136315394;
            *(void *)&v109[4] = "SpatialModelerQueryOutput.hpp";
            *(_WORD *)&v109[12] = 1024;
            *(_DWORD *)&v109[14] = 415;
            _os_log_impl(&dword_221E5E000, v100, OS_LOG_TYPE_ERROR, "%25s:%-5d Error in EqualizeMetadata: Given metadata and gains have different subband count.", v109, 0x12u);
          }
        }
      }
    }
  }
  a3 = v105;
LABEL_71:
  Phase::SpatialModeler::SortMetadataByDelay<float>(v28);
  uint64_t v56 = *(void *)(v23 + 904);
  if (v56)
  {
    float v57 = *(float *)(v23 + 928);
    if (v57 > 0.0)
    {
      int64_t v58 = *(uint64_t **)(a1 + 1280);
      uint64_t v59 = Phase::Logger::GetInstance(v54);
      Phase::SpatialModeler::SpaceBlending((unint64_t *)(v23 + 904), (float *)(v23 + 912), v58, 0, *(_DWORD *)(v59 + 1228), v28, *(void *)(a1 + 48), v57, -144.0, 1.0);
      *(_DWORD *)(a1 + 129std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v23 + 928);
      uint64_t v56 = *(void *)(v23 + 904);
    }
  }
  uint64_t v60 = 0;
  *(void *)(a1 + 1288) = v56;
  uint64_t v61 = v30 + 22846;
  do
  {
    int v62 = *(unsigned __int8 *)(v61 + v60);
    if (*(unsigned char *)(v61 + v60)) {
      BOOL v63 = 1;
    }
    else {
      BOOL v63 = v60 == 18;
    }
    ++v60;
  }
  while (!v63);
  if (v62)
  {
    __int32 v64 = v106[7].i32[1];
    float v65 = -v106[7].f32[0];
    *(float32x2_t *)buf = vneg_f32(v106[6]);
    *(float *)&uint8_t buf[8] = v65;
    *(_DWORD *)&unsigned char buf[12] = v64;
    Phase::SpatialModeler::RotateMetadata<float>(v28, (float *)buf);
    char v66 = 1;
  }
  else
  {
    char v66 = 0;
  }
  *(unsigned char *)(v28 + 4) = v66;
  Phase::SpatialModeler::ExecuteEarlyReflectionDebugCallbacks((Phase::SpatialModeler *)v30, *(Phase::SpatialModeler::RayTracerState **)(a1 + 16), (Phase::Geometry::System *)v23, v55);
  *(_DWORD *)&unsigned char buf[24] = 1;
  unint64_t v68 = (Phase::Logger *)Phase::Logger::GetInstance(v67);
  if (*((unsigned char *)v68 + 1192))
  {
    unint64_t v69 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v68)
                                                                                        + 1184)));
    uint64_t v70 = v69;
    if ((unint64_t)v17 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v69))
    {
      *(_WORD *)uint64_t v109 = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v70, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v17, "Phase_RoomSimulation_HandleResultsEarlyReflections", (const char *)&unk_222112ABB, v109, 2u);
    }
  }
  std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor(a3, (uint64_t)buf);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
LABEL_89:
  uint64_t v71 = (Phase::Logger *)std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v107);
  unint64_t v72 = (Phase::Logger *)Phase::Logger::GetInstance(v71);
  if (*((unsigned char *)v72 + 1192))
  {
    unint64_t v73 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v72)
                                                                                        + 1184)));
    uint64_t v74 = v73;
    if ((unint64_t)v12 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v73))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v74, OS_SIGNPOST_INTERVAL_END, (os_signpost_id_t)v12, "Phase_RoomSimulation_ERSpatialQuery", (const char *)&unk_222112ABB, buf, 2u);
    }
  }
}

void sub_221F3AFFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::RayTracerState::State::operator=(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  uint64_t v5 = 12;
  do
  {
    uint64_t v6 = 0;
    uint64_t v7 = a1 + v5;
    uint64_t v8 = a2 + v5;
    do
    {
      uint64_t v9 = v7 + v6;
      *(_DWORD *)(v9 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(v8 + v6 - 12);
      *(_DWORD *)(v9 - 8) = *(_DWORD *)(v8 + v6 - 8);
      *(_DWORD *)(v9 - 4) = *(_DWORD *)(v8 + v6 - 4);
      *(_DWORD *)(v7 + vstd::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v8 + v6);
      *(_DWORD *)(v9 + 4) = *(_DWORD *)(v8 + v6 + 4);
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v8 + v6 + 8);
      v6 += 24;
    }
    while (v6 != 72);
    ++v4;
    v5 += 72;
  }
  while (v4 != 256);
  if (a1 != a2)
  {
    std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseRoomSimulationSoundSource*,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*>((void *)(a1 + 18432), *(void *)(a2 + 18432), *(void *)(a2 + 18440), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 18440) - *(void *)(a2 + 18432)) >> 3));
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(a1 + 18456), *(char **)(a2 + 18456), *(void *)(a2 + 18464), (uint64_t)(*(void *)(a2 + 18464) - *(void *)(a2 + 18456)) >> 3);
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(a1 + 18480), *(char **)(a2 + 18480), *(void *)(a2 + 18488), (uint64_t)(*(void *)(a2 + 18488) - *(void *)(a2 + 18480)) >> 3);
  }
  memcpy((void *)(a1 + 18512), (const void *)(a2 + 18512), 0x160uLL);
  return a1;
}

uint64_t Phase::SpatialModeler::RoomChangeDetector::IncrementResultsFromTracerStates(Phase::SpatialModeler::RoomChangeDetector *this, const Phase::SpatialModeler::RayTracerState *a2)
{
  long long v2 = *((_OWORD *)a2 + 1227);
  long long v3 = *((_OWORD *)a2 + 1225);
  v18[4] = *((_OWORD *)a2 + 1224);
  v18[5] = v3;
  v18[6] = *((_OWORD *)a2 + 1226);
  long long v19 = v2;
  long long v4 = *((_OWORD *)a2 + 1221);
  v18[0] = *((_OWORD *)a2 + 1220);
  v18[1] = v4;
  long long v5 = *((_OWORD *)a2 + 1223);
  void v18[2] = *((_OWORD *)a2 + 1222);
  v18[3] = v5;
  uint64_t v6 = HIDWORD(v2);
  if (HIDWORD(v2))
  {
    uint64_t v7 = (float *)*((void *)a2 + 2616);
    if ((uint64_t)(*((void *)a2 + 2617) - (void)v7) >> 2 == HIDWORD(v19))
    {
      uint64_t v8 = (float *)v18;
      do
      {
        float v9 = *v7++;
        float *v8 = *v8 / v9;
        ++v8;
        --v6;
      }
      while (v6);
    }
  }
  float v10 = *((float *)a2 + 4876);
  unsigned int v11 = *((_DWORD *)a2 + 4911);
  if (v11)
  {
    int v12 = (float *)((char *)a2 + 19520);
    float v13 = 0.0;
    uint64_t v14 = *((unsigned int *)a2 + 4911);
    do
    {
      float v15 = *v12++;
      float v13 = v13 + v15;
      --v14;
    }
    while (v14);
    if (v11 >= 2) {
      float v13 = v13 / (float)v11;
    }
  }
  else
  {
    float v13 = 0.0;
  }
  int v16 = *((_DWORD *)a2 + 5700);
  uint64_t v20 = *((void *)a2 + 2849);
  int v21 = v16;
  return Phase::SpatialModeler::RoomChangeDetector::IncrementResultInternal<0ul,1ul,2ul,float,float,Phase::Vector<float,3ul>>(v10, v13, (uint64_t)this, (int *)this, (uint64_t)&v20);
}

uint64_t Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::operator=(uint64_t a1, uint64_t a2)
{
  long long v3 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_OWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v3;
  if (a1 != a2)
  {
    std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection*,Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection*>((char *)(a1 + 32), *(char **)(a2 + 32), *(void *)(a2 + 40), 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(a2 + 40) - *(void *)(a2 + 32)) >> 2));
    *(_OWORD *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_OWORD *)(a2 + 56);
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 72), *(char **)(a2 + 72), *(void *)(a2 + 80), (uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 2);
    long long v5 = *(_DWORD ***)(a2 + 104);
    *(void *)(a1 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a2 + 96);
    std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>((uint64_t *)(a1 + 104), v5, *(_DWORD ***)(a2 + 112), 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a2 + 112) - (void)v5) >> 3));
    uint64_t v6 = *(_DWORD **)(a2 + 136);
    *(void *)(a1 + 128) = *(void *)(a2 + 128);
    std::vector<Phase::Vector<float,3ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>((void *)(a1 + 136), v6, *(_DWORD **)(a2 + 144), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 144) - (void)v6) >> 2));
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 160), *(char **)(a2 + 160), *(void *)(a2 + 168), (uint64_t)(*(void *)(a2 + 168) - *(void *)(a2 + 160)) >> 2);
    std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a1 + 184, *(void *)(a2 + 184), *(void *)(a2 + 192), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 192) - *(void *)(a2 + 184)) >> 3));
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>((void *)(a1 + 208), *(char **)(a2 + 208), *(char **)(a2 + 216), *(void *)(a2 + 216) - *(void *)(a2 + 208));
    uint64_t v7 = *(_DWORD **)(a2 + 240);
    *(void *)(a1 + 232) = *(void *)(a2 + 232);
    std::vector<Phase::Vector<float,3ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>((void *)(a1 + 240), v7, *(_DWORD **)(a2 + 248), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 248) - (void)v7) >> 2));
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 264), *(char **)(a2 + 264), *(void *)(a2 + 272), (uint64_t)(*(void *)(a2 + 272) - *(void *)(a2 + 264)) >> 2);
    std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(a1 + 288, *(void *)(a2 + 288), *(void *)(a2 + 296), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 296) - *(void *)(a2 + 288)) >> 3));
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>((void *)(a1 + 312), *(char **)(a2 + 312), *(char **)(a2 + 320), *(void *)(a2 + 320) - *(void *)(a2 + 312));
    uint64_t v8 = *(void *)(a2 + 336);
    *(_DWORD *)(a1 + 344) = *(_DWORD *)(a2 + 344);
    *(void *)(a1 + 33std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v8;
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 352), *(char **)(a2 + 352), *(void *)(a2 + 360), (uint64_t)(*(void *)(a2 + 360) - *(void *)(a2 + 352)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 376), *(char **)(a2 + 376), *(void *)(a2 + 384), (uint64_t)(*(void *)(a2 + 384) - *(void *)(a2 + 376)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 400), *(char **)(a2 + 400), *(void *)(a2 + 408), (uint64_t)(*(void *)(a2 + 408) - *(void *)(a2 + 400)) >> 2);
    std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>((char *)(a1 + 424), *(char **)(a2 + 424), *(void *)(a2 + 432), (uint64_t)(*(void *)(a2 + 432) - *(void *)(a2 + 424)) >> 2);
  }
  return a1;
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationBegin(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(Phase::Logger *a1, os_signpost_id_t **a2, uint64_t a3)
{
  uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(a1);
  if (*((unsigned char *)Instance + 1192))
  {
    uint64_t v7 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(Instance)
                                                                                       + 1184)));
    uint64_t v8 = v7;
    os_signpost_id_t v9 = **a2;
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
    {
      *(_WORD *)unsigned int v11 = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v8, OS_SIGNPOST_INTERVAL_END, v9, "Phase_RoomSimulation_EarlyReflectionsBegin", (const char *)&unk_222112ABB, v11, 2u);
    }
  }
  return std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)a1, a3);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulationImpl::ClusterEarlyReflections(Phase::SpatialModeler::EarlyReflectionsSimulationImpl *this, Phase::SpatialModeler::RoomSimulation *a2, Phase::SpatialModeler::Query *a3, Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *a4)
{
  uint64_t v149 = *MEMORY[0x263EF8340];
  uint64_t v8 = Phase::SpatialModeler::RoomSimulationImpl::CheckClusterQueryInput((uint64_t)a2, a3, (uint64_t)v135);
  if (v136 == 2)
  {
    std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)this, (uint64_t)v135);
  }
  else
  {
    uint64_t v116 = a4;
    uint64_t v117 = a3;
    uint64_t v120 = a2;
    float v118 = this;
    uint64_t v9 = *((void *)a3 + 11);
    uint64_t v122 = *((void *)a3 + 8);
    float v123 = (void *)*((void *)a3 + 12);
    unint64_t v10 = *(void *)(v9 + 144);
    if (v10)
    {
      unint64_t v11 = 0;
      uint64_t v12 = 288;
      do
      {
        if (*(void *)(*(void *)(v9 + 104) + v12) < *(void *)(v9 + 96))
        {
          float v13 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v8) + 1184);
          uint64_t v8 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
          if (v8)
          {
            uint64_t v14 = (uint64_t *)(*(void *)(v9 + 104) + v12);
            uint64_t v15 = *(v14 - 36);
            uint64_t v16 = *v14;
            uint64_t v17 = *(void *)(*(void *)(v9 + 56) + 336 * v16);
            int v18 = *(unsigned __int8 *)(v9 + 48);
            *(_DWORD *)buf = 136316418;
            *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 447;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&unsigned char buf[20] = v15;
            *(_WORD *)&unsigned char buf[28] = 2048;
            *(void *)&buf[30] = v17;
            *(_WORD *)&unsigned char buf[38] = 2048;
            *(void *)&unsigned char buf[40] = v16;
            LOWORD(v14Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 1024;
            *(_DWORD *)((char *)&v141 + 2) = v18;
            _os_log_impl(&dword_221E5E000, v13, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClusterEarlyReflections begin Submix %llu assigned to render group %llu at index %lu, attack query %d", buf, 0x36u);
          }
          unint64_t v10 = *(void *)(v9 + 144);
        }
        ++v11;
        v12 += 304;
      }
      while (v11 < v10);
    }
    long long v19 = (char *)v120 + 26720;
    if (!*(unsigned char *)(v9 + 48)) {
      long long v19 = (char *)v120 + 1424;
    }
    uint64_t v124 = (uint64_t)v19;
    uint64_t v20 = *((void *)v19 + 2367) - *((void *)v19 + 2366);
    if (v20)
    {
      double v21 = fmax(*(double *)(*((void *)a3 + 11) + 40), 1.0);
      unint64_t v22 = (unint64_t)v21;
      unint64_t v23 = 0x6DB6DB6DB6DB6DB7 * (v20 >> 3);
      if (v23 >= (unint64_t)v21) {
        unint64_t v24 = (unint64_t)v21;
      }
      else {
        unint64_t v24 = v23;
      }
      memset(v128, 0, sizeof(v128));
      int v129 = 1065353216;
      *(_OWORD *)unint64_t v130 = 0u;
      long long v131 = 0u;
      long long v132 = 0u;
      *(_OWORD *)unint64_t v133 = 0u;
      uint64_t v134 = 0;
      if (*(unsigned char *)(Phase::Logger::GetInstance((Phase::Logger *)v8) + 1496)) {
        Phase::SpatialModeler::ERClustering::AssignSourcesToExistingRenderers(v24, (void *)v9, v124, *((void *)v120 + 6), (uint64_t)v128, *((double *)v120 + 5));
      }
      else {
        Phase::SpatialModeler::ERClustering::FindEarlyReflectionClusters((void *)(v124 + 18928), *((double *)v120 + 5), *(void *)(v124 + 22576), v24, v124, *((void *)v120 + 6), (uint64_t)v128);
      }
      if (v24)
      {
        if (0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v132 - *((void *)&v131 + 1)) >> 4) == (int)v24) {
          uint64_t v27 = v24;
        }
        else {
          uint64_t v27 = 0x4EC4EC4EC4EC4EC5 * ((uint64_t)(v132 - *((void *)&v131 + 1)) >> 4);
        }
        uint64_t v28 = *((void *)v120 + 2);
        if (*(void *)(v28 + 2760)
          && (uint64_t v29 = Phase::Geometry::SystemDebugger::GetFromSystem(v28)) != 0
          && *(unsigned char *)(v29 + 80)
          || *(unsigned char *)(v124 + 72))
        {
          Phase::SpatialModeler::GenerateEarlyScattering((std::__shared_weak_count *)v128, (uint64_t *)&v131 + 1, (Phase::SpatialModeler::RayTracerState *)v124, *((double *)v120 + 5), v124 + 22568, v9, *((void *)v120 + 6));
        }
        unint64_t v30 = *(void *)(v124 + 22496);
        if (v30 <= (int)v27) {
          unint64_t v30 = (int)v27;
        }
        if (v30 >= v22) {
          unint64_t v31 = (void *)v22;
        }
        else {
          unint64_t v31 = (void *)v30;
        }
        std::string __p = v31;
        unint64_t v138 = 16;
        Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::RenderGroup*)#1} const&>((Phase::Logger *)&v146, (uint64_t)v31, &__p, (std::align_val_t *)&v138);
        uint64_t v32 = v146;
        *(void *)&long long v146 = 0;
        *(void *)buf = v32;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v146 + 8);
        *(void *)&unsigned char buf[40] = v31;
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v146);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)&v146 + 1);
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::operator=[abi:ne180100](v123 + 1, (uint64_t *)buf);
        v123[6] = *(void *)&buf[40];
        std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
        uint64_t v33 = v123[6];
        uint64_t v137 = 1;
        unint64_t v138 = v33;
        std::string __p = &v138;
        unint64_t v126 = &v137;
        Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(v33, (uint64_t)&__p, &v146);
        uint64_t v34 = v146;
        *(void *)&long long v146 = 0;
        *(void *)buf = v34;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v146 + 8);
        *(void *)&unsigned char buf[40] = v33;
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v146);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)&v146 + 1);
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](v123 + 7, (uint64_t *)buf);
        v123[12] = *(void *)&buf[40];
        std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
        Phase::SpatialModeler::evaluateRendererKeepAliveFlagsAndUpdateState(v124, (int)v27, v22, v123 + 1, v123 + 7, (uint64_t)v133, 15.0);
        uint64_t v35 = *(void *)(v9 + 144);
        uint64_t v137 = 8;
        unint64_t v138 = v35;
        std::string __p = &v138;
        unint64_t v126 = &v137;
        Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::SubmixRoutingOutput*)#1} const&>(v35, (uint64_t)&__p, &v146);
        unint64_t v114 = (int)v27;
        uint64_t v115 = v27;
        uint64_t v121 = v123 + 1;
        uint64_t v36 = v146;
        *(void *)&long long v146 = 0;
        *(void *)buf = v36;
        std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)&buf[8], (uint64_t)&v146 + 8);
        *(void *)&unsigned char buf[40] = v35;
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v146);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)&v146 + 1);
        uint64_t v37 = (void **)(v123 + 13);
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::operator=[abi:ne180100](v123 + 13, (uint64_t *)buf);
        v123[18] = *(void *)&buf[40];
        std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)buf);
        std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&buf[8]);
        uint64_t v38 = v123[18];
        if (v38)
        {
          BOOL v39 = *v37;
          do
          {
            *BOOL v39 = -1;
            v39 += 2;
            --v38;
          }
          while (v38);
        }
        float v40 = (uint64_t *)(v9 + 104);
        if (*(void *)(v9 + 144))
        {
          unint64_t v41 = 0;
          do
          {
            uint64_t v42 = *v40 + 304 * v41;
            unint64_t SoundSourceHash = Phase::SpatialModeler::GetSoundSourceHash(*(void *)(v42 + 144), *(void *)(v124 + 22576), v42 + 160);
            if (*(void *)&v128[8])
            {
              uint8x8_t v44 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v128[8]);
              v44.i16[0] = vaddlv_u8(v44);
              if (v44.u32[0] > 1uLL)
              {
                unint64_t v45 = SoundSourceHash;
                if (SoundSourceHash >= *(void *)&v128[8]) {
                  unint64_t v45 = SoundSourceHash % *(void *)&v128[8];
                }
              }
              else
              {
                unint64_t v45 = (*(void *)&v128[8] - 1) & SoundSourceHash;
              }
              unint64_t v46 = *(uint64_t ***)(*(void *)v128 + 8 * v45);
              if (v46)
              {
                for (uint64_t i = *v46; i; uint64_t i = (uint64_t *)*i)
                {
                  unint64_t v48 = i[1];
                  if (v48 == SoundSourceHash)
                  {
                    if (i[2] == SoundSourceHash)
                    {
                      *(_OWORD *)&(*v37)[2 * v41] = *(_OWORD *)(i + 3);
                      long long v52 = *v37;
                      uint64_t v58 = (uint64_t)&(*v37)[2 * v41];
                      float v59 = *(double *)(v58 + 8);
                      if (*(void *)(v122 + 904)) {
                        float v59 = v59 + (float)(*(float *)(v122 + 928) * (float)(0.0 - v59));
                      }
                      *(double *)(v58 + 8) = v59;
                      goto LABEL_60;
                    }
                  }
                  else
                  {
                    if (v44.u32[0] > 1uLL)
                    {
                      if (v48 >= *(void *)&v128[8]) {
                        v48 %= *(void *)&v128[8];
                      }
                    }
                    else
                    {
                      v48 &= *(void *)&v128[8] - 1;
                    }
                    if (v48 != v45) {
                      break;
                    }
                  }
                }
              }
            }
            unint64_t v49 = &(*v37)[2 * v41];
            *unint64_t v49 = -1;
            v49[1] = 0;
            unsigned int v50 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)SoundSourceHash)
                                                             + 1184));
            unint64_t SoundSourceHash = os_log_type_enabled(v50, OS_LOG_TYPE_ERROR);
            if (SoundSourceHash)
            {
              uint64_t v51 = *(void *)(v42 + 144);
              *(_DWORD *)buf = 136315650;
              *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 574;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&unsigned char buf[20] = v51;
              _os_log_impl(&dword_221E5E000, v50, OS_LOG_TYPE_ERROR, "%25s:%-5d Query input source (%llu) not found in clustering results.", buf, 0x1Cu);
            }
            long long v52 = *v37;
LABEL_60:
            if (v52[2 * v41] < v123[6])
            {
              uint64_t v53 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)SoundSourceHash)
                                                               + 1184));
              if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v54 = *(void *)(*(void *)(v9 + 104) + 304 * v41);
                uint64_t v55 = (*v37)[2 * v41];
                uint64_t v56 = *(void *)(*v121 + 336 * v55);
                int v57 = *(unsigned __int8 *)(v9 + 48);
                *(_DWORD *)buf = 136316418;
                *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = 584;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&unsigned char buf[20] = v54;
                *(_WORD *)&unsigned char buf[28] = 2048;
                *(void *)&buf[30] = v56;
                *(_WORD *)&unsigned char buf[38] = 2048;
                *(void *)&unsigned char buf[40] = v55;
                LOWORD(v14Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 1024;
                *(_DWORD *)((char *)&v141 + 2) = v57;
                _os_log_impl(&dword_221E5E000, v53, OS_LOG_TYPE_DEBUG, "%25s:%-5d ClusterEarlyReflections end Submix %llu assigned to render group %llu at index %lu, attack query %d", buf, 0x36u);
              }
            }
            ++v41;
          }
          while (v41 < *(void *)(v9 + 144));
        }
        uint64_t v60 = v124 + 19384;
        std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::clear(v124 + 19384);
        if (v115 << 32)
        {
          unint64_t v61 = 0;
          uint64_t v62 = v114;
          if (v114 <= 1) {
            uint64_t v62 = 1;
          }
          uint64_t v119 = v62;
          long long v63 = 0uLL;
          do
          {
            std::string __p = 0;
            unint64_t v126 = 0;
            uint64_t v127 = 0;
            long long v146 = v63;
            long long v147 = v63;
            int v148 = 1065353216;
            if (*(void *)(v9 + 144))
            {
              uint64_t v64 = 0;
              unsigned int v65 = 0;
              float v66 = -3.4028e38;
              while (1)
              {
                uint64_t v67 = *v40;
                uint64_t v68 = *v40 + 304 * v64;
                if ((*v37)[2 * v64] == v61)
                {
                  unint64_t v138 = 0;
                  unint64_t v69 = (uint64_t *)Phase::SpatialModeler::GetSoundSourceHash(*(void *)(v68 + 144), *(void *)(v124 + 22576), v68 + 160);
                  unint64_t v70 = (unint64_t)v69;
                  unint64_t v138 = (unint64_t)v69;
                  uint64_t v71 = v126;
                  if (v126 >= v127)
                  {
                    unint64_t v69 = (uint64_t *)__p;
                    uint64_t v73 = ((char *)v126 - (unsigned char *)__p) >> 3;
                    unint64_t v74 = v73 + 1;
                    if ((unint64_t)(v73 + 1) >> 61) {
                      std::vector<Phase::SpatialModeler::OptionalPropertyDescription>::__throw_length_error[abi:ne180100]();
                    }
                    uint64_t v75 = (char *)v127 - (unsigned char *)__p;
                    if (((char *)v127 - (unsigned char *)__p) >> 2 > v74) {
                      unint64_t v74 = v75 >> 2;
                    }
                    if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
                      unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
                    }
                    else {
                      unint64_t v76 = v74;
                    }
                    if (v76)
                    {
                      uint64_t v77 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&v127, v76);
                      unint64_t v69 = (uint64_t *)__p;
                      uint64_t v71 = v126;
                      unint64_t v70 = v138;
                    }
                    else
                    {
                      uint64_t v77 = 0;
                    }
                    uint64_t v78 = (unint64_t *)&v77[8 * v73];
                    unint64_t *v78 = v70;
                    unint64_t v72 = (uint64_t *)(v78 + 1);
                    while (v71 != v69)
                    {
                      unint64_t v79 = *--v71;
                      *--uint64_t v78 = v79;
                    }
                    std::string __p = v78;
                    unint64_t v126 = v72;
                    uint64_t v127 = (uint64_t *)&v77[8 * v76];
                    if (v69) {
                      operator delete(v69);
                    }
                  }
                  else
                  {
                    *unint64_t v126 = (uint64_t)v69;
                    unint64_t v72 = v71 + 1;
                  }
                  unint64_t v126 = v72;
                  uint64_t v80 = *(void *)(v68 + 144);
                  if (*(_DWORD *)(v122 + 136) <= v80
                    || (uint64_t v81 = *(void *)(v122 + 120), *(_DWORD *)(v81 + 24 * v80 + 20) != HIDWORD(v80))
                    || (uint64_t v82 = *(void *)(v81 + 24 * *(void *)(v68 + 144))) == 0
                    || *(_DWORD *)v82 != 3)
                  {
                    unsigned int v111 = objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance((Phase::Logger *)v69)
                                                                      + 1184));
                    if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v112 = *(void *)(v68 + 144);
                      *(_DWORD *)buf = 136315650;
                      *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = 616;
                      *(_WORD *)&unsigned char buf[18] = 2048;
                      *(void *)&unsigned char buf[20] = v112;
                      _os_log_impl(&dword_221E5E000, v111, OS_LOG_TYPE_ERROR, "%25s:%-5d Query input source (%llu) not found in Geo Layer.", buf, 0x1Cu);
                    }
                    *(void *)float v118 = 6;
                    *((void *)v118 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = (char *)v120 + 72;
                    *((_DWORD *)v118 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 2;
                    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&v146);
                    if (__p)
                    {
                      unint64_t v126 = (uint64_t *)__p;
                      operator delete(__p);
                    }
                    goto LABEL_125;
                  }
                  uint64_t v83 = *(void *)(v82 + 64);
                  int v84 = *(_DWORD *)(v82 + 72);
                  double v85 = *(double *)&(*v37)[2 * v64 + 1];
                  *(void *)buf = &v138;
                  uint64_t v86 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)&v146, &v138, (uint64_t)&std::piecewise_construct, (void **)buf);
                  float v87 = v85;
                  v86[3] = v83;
                  *((_DWORD *)v86 + 8) = v84;
                  *((float *)v86 + 9) = v87;
                }
                uint64_t v88 = *(unsigned int *)(v68 + 140);
                if (v88)
                {
                  long long v89 = (float *)(v67 + 304 * v65 + 16);
                  do
                  {
                    float v90 = *v89++;
                    float v91 = v90;
                    if (v66 < v90) {
                      float v66 = v91;
                    }
                    --v88;
                  }
                  while (v88);
                }
                uint64_t v64 = ++v65;
                if (*(void *)(v9 + 144) <= (unint64_t)v65) {
                  goto LABEL_104;
                }
              }
            }
            float v66 = -3.4028e38;
LABEL_104:
            *(float *)&unint64_t v138 = v66;
            *((float *)&v138 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v66;
            float v139 = v66;
            Phase::Subbands<float>::Subbands((uint64_t)buf, &v138, 3);
            uint64_t v92 = (_OWORD *)(*v121 + 336 * v61);
            long long v93 = *(_OWORD *)buf;
            long long v94 = *(_OWORD *)&buf[16];
            long long v95 = v141;
            v92[14] = *(_OWORD *)&buf[32];
            v92[15] = v95;
            v92[12] = v93;
            v92[13] = v94;
            long long v96 = v142;
            long long v97 = v143;
            long long v98 = v145;
            v92[18] = v144;
            v92[19] = v98;
            v92[16] = v96;
            v92[17] = v97;
            unint64_t v138 = 0;
            if (v126 == __p)
            {
              unint64_t ClusterHash = 0;
            }
            else
            {
              unint64_t ClusterHash = Phase::SpatialModeler::GetClusterHash((uint64_t **)&__p, *(void *)(v124 + 22576));
              unint64_t v138 = ClusterHash;
            }
            *(void *)(*v121 + 336 * v61 + 184) = ClusterHash;
            *(void *)buf = &v138;
            long long v100 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v60, &v138, (uint64_t)&std::piecewise_construct, (void **)buf);
            if (v100 + 3 != (void *)&v146)
            {
              *((_DWORD *)v100 + 14) = v148;
              std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,void *> *>>(v100 + 3, (uint64_t *)v147, 0);
            }
            uint64_t v101 = *((void *)&v131 + 1);
            *(void *)buf = &v138;
            long long v102 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v60, &v138, (uint64_t)&std::piecewise_construct, (void **)buf);
            Phase::SpatialModeler::CopyMetadata<float>(v101 + 208 * v61, (uint64_t)(v102 + 8));
            uint64_t v103 = *v121;
            *(void *)buf = &v138;
            *((_OWORD *)std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v60, &v138, (uint64_t)&std::piecewise_construct, (void **)buf)+ 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *(_OWORD *)(v103 + 336 * v61);
            uint64_t v104 = (char *)v130[0];
            if (v61 < ((char *)v130[1] - (char *)v130[0]) >> 3)
            {
              *(void *)buf = &v138;
              uint64_t v105 = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v60, &v138, (uint64_t)&std::piecewise_construct, (void **)buf);
              uint64_t v106 = &v104[8 * v61];
              *((_DWORD *)v105 + 72) = *(_DWORD *)v106;
              *((_DWORD *)v105 + 73) = *((_DWORD *)v106 + 1);
            }
            std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)&v146);
            if (__p)
            {
              unint64_t v126 = (uint64_t *)__p;
              operator delete(__p);
            }
            ++v61;
            long long v63 = 0uLL;
          }
          while (v61 != v119);
        }
        if (!*(unsigned char *)(v9 + 48))
        {
          (*(void (**)(Phase::SpatialModeler::RoomSimulation *, uint64_t))(*(void *)v120 + 96))(v120, v124);
          if (!*(unsigned char *)(v124 + 195))
          {
            Phase::SpatialModeler::RoomSimulation::StoreRayTracerStateToERtoLRModelerCache((Phase::SpatialModeler::RoomSimulation *)v124, v107);
            Phase::SpatialModeler::RoomSimulationLogging::logInQuerySources((Phase::Logger *)(v9 + 104), (uint64_t)"Cluster ER - ER after Store", 27);
            Phase::SpatialModeler::RoomSimulationLogging::logRayTracerStateStatus((Phase::Logger *)v124, (uint64_t)"Cluster ER - ER after Store", 27);
          }
        }
        Phase::SpatialModeler::checkSubmixRendererChange(v9, v123);
        Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryCleanupCommon(v120, v117, v116, v108);
        *((_DWORD *)v118 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
        goto LABEL_125;
      }
      uint64_t v109 = **(id **)(Phase::Logger::GetInstance(v25) + 1184);
      if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
      {
        uint64_t v110 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v124 + 18936) - *(void *)(v124 + 18928)) >> 3);
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 490;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&unsigned char buf[20] = v110;
        _os_log_impl(&dword_221E5E000, v109, OS_LOG_TYPE_ERROR, "%25s:%-5d FindEarlyReflectionClusters: numClusters 0 after processing %zu sources, this is invalid output, returning", buf, 0x1Cu);
      }
      *(void *)float v118 = 4;
      *((void *)v118 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = (char *)v120 + 72;
      *((_DWORD *)v118 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 2;
LABEL_125:
      if (v133[0])
      {
        v133[1] = v133[0];
        operator delete(v133[0]);
      }
      *(void *)buf = (char *)&v131 + 8;
      std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
      if (v130[0])
      {
        v130[1] = v130[0];
        operator delete(v130[0]);
      }
      std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)v128);
    }
    else
    {
      uint64_t v26 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)v8) + 1184);
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315394;
        *(void *)&uint8_t buf[4] = "EarlyReflectionsSimulationImpl.mm";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 458;
        _os_log_impl(&dword_221E5E000, v26, OS_LOG_TYPE_ERROR, "%25s:%-5d ClusterEarlyReflections: persistingTracerState.mState.mSources.size() == 0, no simulated sources", buf, 0x12u);
      }
      *(void *)float v118 = 3;
      *((void *)v118 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = (char *)v120 + 72;
      *((_DWORD *)v118 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 2;
    }
  }
  return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v135);
}

void sub_221F3C3EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationFinish@<X0>(float32x2_t *this@<X0>, Phase::Geometry::SystemState **a2@<X1>, Phase::SpatialModeler::Query *a3@<X2>, Phase::Logger *a4@<X8>)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t Instance = Phase::Logger::GetInstance((Phase::Logger *)this);
  unint64_t v10 = (Phase::Logger *)os_signpost_id_generate(**(os_log_t **)(Instance + 416));
  uint64_t v35 = v10;
  unint64_t v11 = (Phase::Logger *)Phase::Logger::GetInstance(v10);
  if (*((unsigned char *)v11 + 1192))
  {
    uint64_t v12 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(v11)
                                                                                        + 1184)));
    float v13 = v12;
    if ((unint64_t)v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v13, OS_SIGNPOST_INTERVAL_BEGIN, (os_signpost_id_t)v10, "Phase_RoomSimulation_EarlyReflectionsFinish", "EarlyReflectionsFinish", buf, 2u);
    }
  }
  uint64_t v34 = (os_signpost_id_t *)&v35;
  Phase::SpatialModeler::RoomSimulationImpl::RoomSimulationFinishCommonPreProcess((Phase::SpatialModeler::RoomSimulationImpl *)this, a2, (std::chrono::steady_clock::time_point *)a3, (uint64_t)buf);
  if (v33 == 2)
  {
    std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__copy_constructor((uint64_t)v31, (uint64_t)buf);
    uint64_t v14 = v31;
    Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationFinish(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(a4, &v34, (uint64_t)v31);
    goto LABEL_26;
  }
  uint64_t v28 = a4;
  uint64_t v15 = (unsigned int *)((char *)a3 + 131768);
  uint64_t v16 = a2[8];
  if (*((unsigned char *)a2[11] + 48)) {
    uint64_t v17 = (Phase::SpatialModeler::RayTracerState *)&this[3340];
  }
  else {
    uint64_t v17 = (Phase::SpatialModeler::RayTracerState *)&this[178];
  }
  if (*((unsigned char *)a2[11] + 48))
  {
    Phase::SpatialModeler::RayTracerState::operator=((uint64_t)&this[3340], (uint64_t)a3 + 112752);
LABEL_22:
    if (*((_DWORD *)v16 + 42)) {
      BOOL v24 = *((unsigned char *)v16 + 932) == 0;
    }
    else {
      BOOL v24 = 0;
    }
    *(float *)&double v25 = Phase::SpatialModeler::RayTracerState::UpdateLaunchedRayHistory(v17, *v15);
    Phase::SpatialModeler::RoomSimulationImpl::RoomSimulationFinishHandleMatchReverbTimes((Phase::SpatialModeler::RoomSimulationImpl *)v24, (Phase::SpatialModeler::Query *)((char *)a3 + 112752), v17, v26, v25);
    Phase::SpatialModeler::EarlyReflectionsSimulationImpl::ClusterEarlyReflections((Phase::SpatialModeler::EarlyReflectionsSimulationImpl *)v29, (Phase::SpatialModeler::RoomSimulation *)this, (Phase::SpatialModeler::Query *)a2, a3);
    uint64_t v14 = v29;
    Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationFinish(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(v28, &v34, (uint64_t)v29);
    goto LABEL_26;
  }
  int v18 = (float *)((char *)a3 + 112872);
  if (!Phase::SpatialModeler::SimulationController::ShouldEnableListenerOutsideMitigation((Phase::SpatialModeler::SimulationController *)&this[10], (Phase::SpatialModeler::Query *)((char *)a3 + 112752), (Phase::SpatialModeler::RayTracerState *)&this[178], *((unsigned char *)v16 + 932))|| !*((unsigned char *)a3 + 112945))
  {
    Phase::SpatialModeler::SimulationController::AdjustAggregationCoefficientsDefault(*v18, *v18, (uint64_t)&this[10], (float *)a3 + 28190);
    if (this[199].i8[0] && this[199].i8[1]) {
      Phase::SpatialModeler::SimulationController::AdjustAggregationCoefficientsDynamic(this + 10, (uint64_t)&this[3029], (float *)a3 + 28190, *v18, *v18, this[2806].f32[1], (float)*v15);
    }
    Phase::SpatialModeler::RoomChangeDetector::IncrementResultsFromTracerStates((Phase::SpatialModeler::RoomChangeDetector *)&this[84], (Phase::SpatialModeler::Query *)((char *)a3 + 112752));
    Phase::SpatialModeler::GetRoomChangeProbabilityEstimate((Phase::SpatialModeler *)&this[84], v22);
    *((_DWORD *)a3 + 3344std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v23;
    Phase::SpatialModeler::RayTracerState::AggregateResultData((Phase::SpatialModeler::RayTracerState *)&this[178], (Phase::SpatialModeler::Query *)((char *)a3 + 112752), v16);
    Phase::SpatialModeler::RoomSimulationDebugger::RoomSimulationDebugView::operator=((uint64_t)&this[3078], (uint64_t)a3 + 135952);
    goto LABEL_22;
  }
  Phase::SpatialModeler::RayTracerState::UpdateResultData((Phase::SpatialModeler::RayTracerState *)&this[178], (Phase::SpatialModeler::Query *)((char *)a3 + 112752), v16);
  uint64_t v20 = **(id **)(Phase::Logger::GetInstance(v19) + 1184);
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    __int32 v21 = this[2807].i32[0];
    *(_DWORD *)uint64_t v36 = 136315650;
    uint64_t v37 = "EarlyReflectionsSimulationImpl.mm";
    __int16 v38 = 1024;
    int v39 = 241;
    __int16 v40 = 1024;
    __int32 v41 = v21;
    _os_log_impl(&dword_221E5E000, v20, OS_LOG_TYPE_DEFAULT, "%25s:%-5d listenerOutsideMitigation ER: Listener is outside, mitigating by skipping aggregation, counter %u", v36, 0x18u);
  }
  Phase::SpatialModeler::EarlyReflectionsSimulationImpl::ClusterEarlyReflections((Phase::SpatialModeler::EarlyReflectionsSimulationImpl *)v30, (Phase::SpatialModeler::RoomSimulation *)this, (Phase::SpatialModeler::Query *)a2, a3);
  uint64_t v14 = v30;
  Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationFinish(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(v28, &v34, (uint64_t)v30);
LABEL_26:
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v14);
  return std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)buf);
}

void sub_221F3C810(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)va);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulationImpl::RoomSimulationFinish(Phase::SpatialModeler::RoomSimulation &,Phase::SpatialModeler::Query &,Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState &)::$_0::operator()(Phase::Logger *a1, os_signpost_id_t **a2, uint64_t a3)
{
  uint64_t Instance = (Phase::Logger *)Phase::Logger::GetInstance(a1);
  if (*((unsigned char *)Instance + 1192))
  {
    uint64_t v7 = objc_retainAutoreleasedReturnValue(objc_retainAutorelease(**(id **)(Phase::Logger::GetInstance(Instance)
                                                                                       + 1184)));
    uint64_t v8 = v7;
    os_signpost_id_t v9 = **a2;
    if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
    {
      *(_WORD *)unint64_t v11 = 0;
      _os_signpost_emit_with_name_impl(&dword_221E5E000, v8, OS_SIGNPOST_INTERVAL_END, v9, "Phase_RoomSimulation_EarlyReflectionsFinish", (const char *)&unk_222112ABB, v11, 2u);
    }
  }
  return std::__variant_detail::__move_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__move_constructor((uint64_t)a1, a3);
}

uint64_t Phase::SpatialModeler::CopyMetadata<float>(uint64_t result, uint64_t a2)
{
  v34[4] = *MEMORY[0x263EF8340];
  long long v2 = *(uint64_t **)(result + 104);
  if (v2)
  {
    uint64_t v3 = *v2;
    if (*v2)
    {
      uint64_t v5 = result;
      *(_DWORD *)(a2 + 204) = *(_DWORD *)(result + 204);
      uint64_t v28 = 4;
      uint64_t v29 = v3;
      unint64_t v30 = &v29;
      v31[0] = &v28;
      Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>(v3, (uint64_t)&v30, &v33);
      uint64_t v6 = v33;
      int v33 = 0;
      unint64_t v30 = v6;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v31, (uint64_t)v34);
      uint64_t v32 = v3;
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v33);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v34);
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a2 + 8), (uint64_t *)&v30);
      *(void *)(a2 + 48) = v32;
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v30);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v31);
      uint64_t v28 = 4;
      uint64_t v29 = v3;
      unint64_t v30 = &v29;
      v31[0] = &v28;
      Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>(v3, (uint64_t)&v30, &v33);
      uint64_t v7 = v33;
      int v33 = 0;
      unint64_t v30 = v7;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v31, (uint64_t)v34);
      uint64_t v32 = v3;
      std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v33);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v34);
      std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a2 + 56), (uint64_t *)&v30);
      *(void *)(a2 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v32;
      std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v30);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v31);
      uint64_t v8 = *(void *)(v5 + 104);
      if (v8) {
        uint64_t v9 = *(void *)(v8 + 8);
      }
      else {
        uint64_t v9 = 0;
      }
      Phase::AllocPackedSubbandArray<float>(v3, v9, (void **)&v30);
      std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a2 + 104), (uint64_t *)&v30);
      std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v30, 0);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v31);
      uint64_t v28 = 1;
      uint64_t v29 = v3;
      unint64_t v30 = &v29;
      v31[0] = &v28;
      Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(v3, (uint64_t)&v30, &v33);
      uint64_t v10 = v33;
      int v33 = 0;
      unint64_t v30 = v10;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v31, (uint64_t)v34);
      uint64_t v32 = v3;
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v33);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v34);
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a2 + 144), (uint64_t *)&v30);
      *(void *)(a2 + 184) = v32;
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v30);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v31);
      uint64_t v11 = 0;
      uint64_t v12 = *(void *)(v5 + 8);
      uint64_t v13 = *(void *)(a2 + 8);
      uint64_t v14 = *(void *)(v5 + 56);
      uint64_t v15 = *(void *)(a2 + 56);
      uint64_t v16 = *(void *)(v5 + 104);
      uint64_t v17 = (int *)(v16 + 16);
      uint64_t v18 = *(void *)(v16 + 8);
      uint64_t v19 = *(void *)(a2 + 104) + 16;
      uint64_t v20 = *(void *)(v5 + 144);
      uint64_t v21 = *(void *)(a2 + 144);
      BOOL result = 4 * *(void *)(*(void *)(a2 + 104) + 8);
      do
      {
        unint64_t v22 = (_DWORD *)(v12 + 12 * v11);
        int v23 = (_DWORD *)(v13 + 12 * v11);
        *int v23 = *v22;
        v23[1] = v22[1];
        v23[2] = v22[2];
        *(_DWORD *)(v15 + 4 * v1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(v14 + 4 * v11);
        BOOL v24 = v17;
        double v25 = (_DWORD *)v19;
        for (uint64_t i = v18; i; --i)
        {
          int v27 = *v24++;
          *v25++ = v27;
        }
        *(unsigned char *)(v21 + v1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(unsigned char *)(v20 + v11);
        ++v11;
        v19 += result;
        v17 += v18;
      }
      while (v11 != v3);
      *(unsigned char *)(a2 + 20Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(unsigned char *)(v5 + 201);
    }
  }
  return result;
}

void Phase::SpatialModeler::ClusteringResult::~ClusteringResult(Phase::SpatialModeler::ClusteringResult *this)
{
  long long v2 = (void *)*((void *)this + 11);
  if (v2)
  {
    *((void *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v2;
    operator delete(v2);
  }
  long long v4 = (void **)((char *)this + 64);
  std::vector<Phase::SpatialModeler::DirectionalMetadataOutput<float>>::__destroy_vector::operator()[abi:ne180100](&v4);
  uint64_t v3 = (void *)*((void *)this + 5);
  if (v3)
  {
    *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v3;
    operator delete(v3);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this);
}

uint64_t Phase::SpatialModeler::IndexStore<32ul,1ull,0ull>::GetNextAvailable(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  for (uint64_t result = 1; result != 32; ++result)
  {
    if (*(unsigned char *)(a1 + result) == 1)
    {
      *(unsigned char *)(a1 + result) = 0;
      return result;
    }
  }
  uint64_t v3 = **(id **)(Phase::Logger::GetInstance((Phase::Logger *)0x20) + 1184);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    int v4 = 136315650;
    uint64_t v5 = "RayTracingTypes.hpp";
    __int16 v6 = 1024;
    int v7 = 700;
    __int16 v8 = 2048;
    uint64_t v9 = 0;
    _os_log_impl(&dword_221E5E000, v3, OS_LOG_TYPE_ERROR, "%25s:%-5d IndexStore: no indexes available, returning invalid value %llu", (uint8_t *)&v4, 0x1Cu);
  }
  return 0;
}

float32_t Phase::Subbands<float>::operator+=(float32x4_t *a1, float32x4_t *a2)
{
  uint64_t v2 = a1[7].u32[3];
  if (v2)
  {
    if (v2 == 10)
    {
      float32x4_t v4 = vaddq_f32(*a1, *a2);
      float32x4_t v11 = vaddq_f32(a1[1], a2[1]);
      float32x4_t v12 = vaddq_f32(a1[2], a2[2]);
      *a1 = v4;
      a1[1] = v11;
      a1[2] = v12;
    }
    else if (v2 == 31)
    {
      float32x4_t v3 = vaddq_f32(a1[1], a2[1]);
      float32x4_t v4 = vaddq_f32(*a1, *a2);
      float32x4_t v5 = vaddq_f32(a1[3], a2[3]);
      float32x4_t v6 = vaddq_f32(a1[2], a2[2]);
      float32x4_t v7 = vaddq_f32(a1[5], a2[5]);
      float32x4_t v8 = vaddq_f32(a1[4], a2[4]);
      float32x4_t v9 = vaddq_f32(a1[6], a2[6]);
      float32x4_t v10 = vaddq_f32(a1[7], a2[7]);
      v10.i32[3] = HIDWORD(*(_OWORD *)&a1[7]);
      *a1 = v4;
      a1[1] = v3;
      a1[2] = v6;
      a1[3] = v5;
      a1[4] = v8;
      a1[5] = v7;
      a1[6] = v9;
      a1[7] = v10;
    }
    else
    {
      uint64_t v13 = (float *)a1;
      do
      {
        float v14 = a2->f32[0];
        a2 = (float32x4_t *)((char *)a2 + 4);
        v4.f32[0] = v14 + *v13;
        *v13++ = v4.f32[0];
        --v2;
      }
      while (v2);
    }
  }
  return v4.f32[0];
}

void Phase::SpatialModeler::SortMetadataByDelay<float>(uint64_t a1)
{
  uint64_t v59 = *MEMORY[0x263EF8340];
  uint64_t v1 = *(unint64_t **)(a1 + 104);
  if (v1)
  {
    uint64_t v2 = (uint64_t *)*v1;
    if (*v1 >= 2)
    {
      std::vector<unsigned long>::vector(&__p, *v1);
      float32x4_t v4 = (uint64_t *)__p;
      float32x4_t v5 = v41;
      if (__p != v41)
      {
        uint64_t v6 = 0;
        float32x4_t v7 = (uint64_t *)__p;
        do
          *v7++ = v6++;
        while (v7 != v5);
      }
      unint64_t v8 = 126 - 2 * __clz(v5 - v4);
      uint64_t v56 = a1;
      if (v5 == v4) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = v8;
      }
      std::__introsort<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *,false>((uint64_t)v4, v5, &v56, v9, 1);
      unint64_t v45 = v2;
      uint64_t v48 = 4;
      unsigned int v50 = (uint64_t *)&v45;
      v51[0] = &v48;
      Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>((uint64_t)v2, (uint64_t)&v50, &v56);
      uint64_t v10 = v56;
      uint64_t v56 = 0;
      uint64_t v53 = v10;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v54, (uint64_t)v57);
      uint64_t v55 = v2;
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v56);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v57);
      uint64_t v48 = (uint64_t)v2;
      v42[0] = 4;
      unint64_t v45 = &v48;
      v46[0] = v42;
      Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>((uint64_t)v2, (uint64_t)&v45, &v56);
      uint64_t v11 = v56;
      uint64_t v56 = 0;
      unsigned int v50 = (uint64_t *)v11;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v51, (uint64_t)v57);
      long long v52 = v2;
      std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v56);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v57);
      uint64_t v12 = *(void *)(a1 + 104);
      if (v12) {
        uint64_t v13 = *(void *)(v12 + 8);
      }
      else {
        uint64_t v13 = 0;
      }
      Phase::AllocPackedSubbandArray<float>((uint64_t)v2, v13, (void **)&v48);
      uint64_t v43 = 1;
      uint8x8_t v44 = v2;
      v42[0] = &v44;
      v42[1] = &v43;
      Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>((uint64_t)v2, (uint64_t)v42, &v56);
      uint64_t v14 = v56;
      uint64_t v56 = 0;
      unint64_t v45 = (uint64_t *)v14;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v46, (uint64_t)v57);
      unint64_t v47 = v2;
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100](&v56);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v57);
      uint64_t v15 = 0;
      uint64_t v16 = *(void *)(a1 + 8);
      uint64_t v17 = __p;
      uint64_t v18 = v53;
      uint64_t v19 = *(void *)(a1 + 56);
      uint64_t v20 = (uint64_t)v50;
      uint64_t v21 = *(void *)(a1 + 104);
      uint64_t v22 = v21 + 16;
      uint64_t v23 = *(void *)(v21 + 8);
      BOOL v24 = (char *)(v48 + 16);
      uint64_t v25 = *(void *)(a1 + 144);
      uint64_t v26 = (uint64_t)v45;
      if ((unint64_t)v2 <= 1) {
        uint64_t v27 = 1;
      }
      else {
        uint64_t v27 = (uint64_t)v2;
      }
      uint64_t v28 = 4 * *(void *)(v48 + 8);
      do
      {
        uint64_t v29 = v17[v15];
        unint64_t v30 = (_DWORD *)(v16 + 12 * v29);
        unint64_t v31 = (_DWORD *)(v18 + 12 * v15);
        _DWORD *v31 = *v30;
        v31[1] = v30[1];
        _OWORD v31[2] = v30[2];
        *(_DWORD *)(v20 + 4 * v15) = *(_DWORD *)(v19 + 4 * v29);
        if (v23)
        {
          uint64_t v32 = (int *)(v22 + 4 * v29 * v23);
          int v33 = v24;
          uint64_t v34 = v23;
          do
          {
            int v35 = *v32++;
            *v33++ = v35;
            --v34;
          }
          while (v34);
        }
        *(unsigned char *)(v26 + v15++) = *(unsigned char *)(v25 + v29);
        v24 += v28;
      }
      while (v15 != v27);
      *(void *)(a1 + 8) = 0;
      uint64_t v56 = v16;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v57, a1 + 16);
      uint64_t v58 = *(uint64_t **)(a1 + 48);
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a1 + 8), &v53);
      *(void *)(a1 + 48) = v55;
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](&v53, &v56);
      uint64_t v55 = v58;
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v56);
      uint64_t v36 = std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v57);
      uint64_t v37 = *(void *)(a1 + 56);
      *(void *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      uint64_t v56 = v37;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v36, a1 + 64);
      uint64_t v58 = *(uint64_t **)(a1 + 96);
      std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a1 + 56), (uint64_t *)&v50);
      *(void *)(a1 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v52;
      std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v50, &v56);
      long long v52 = v58;
      std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v56);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v57);
      uint64_t v38 = *(void *)(a1 + 104);
      *(void *)(a1 + 104) = v48;
      uint64_t v48 = v38;
      std::__function::__value_func<void ()(void *)>::swap[abi:ne180100]((void *)(a1 + 112), v49);
      uint64_t v39 = *(void *)(a1 + 144);
      *(void *)(a1 + 144) = 0;
      uint64_t v56 = v39;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v57, a1 + 152);
      uint64_t v58 = *(uint64_t **)(a1 + 184);
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(a1 + 144), (uint64_t *)&v45);
      *(void *)(a1 + 184) = v47;
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v45, &v56);
      unint64_t v47 = v58;
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100](&v56);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v57);
      *(unsigned char *)(a1 + 20Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 1;
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v45);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v46);
      std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100](&v48, 0);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v49);
      std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v50);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v51);
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v53);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v54);
      if (__p)
      {
        __int32 v41 = (uint64_t *)__p;
        operator delete(__p);
      }
    }
  }
}

void sub_221F3D2F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100](&a23, 0);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&a24);
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&a28);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v29);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(v30 - 184));
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v28);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::RotateMetadata<float>(uint64_t a1, float *a2)
{
  uint64_t v2 = *(void **)(a1 + 104);
  if (v2 && *v2)
  {
    int v5 = *(_DWORD *)(a1 + 204);
    if (!v5) {
      Phase::SpatialModeler::ConvertMetadataSphericalToCartesian<float>(a1);
    }
    uint64_t v6 = 0;
    for (unint64_t i = 0; ; ++i)
    {
      unint64_t v8 = *(void **)(a1 + 104);
      if (v8) {
        unint64_t v8 = (void *)*v8;
      }
      if (i >= (unint64_t)v8) {
        break;
      }
      Phase::operator*<float>(a2, (float *)(*(void *)(a1 + 8) + v6), v10);
      uint64_t v9 = (float *)(*(void *)(a1 + 8) + v6);
      *uint64_t v9 = v10[0];
      v9[1] = v10[1];
      _OWORD v9[2] = v10[2];
      v6 += 12;
    }
    if (!v5) {
      Phase::SpatialModeler::ConvertMetadataCartesianToSpherical<float>(a1);
    }
  }
}

uint64_t std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::PhaseRoomSimulationSoundSource*,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v9 = (uint64_t)(a1 + 2);
  uint64_t v8 = a1[2];
  uint64_t v10 = (void *)*a1;
  if (0x6DB6DB6DB6DB6DB7 * ((v8 - *a1) >> 3) >= a4)
  {
    uint64_t v14 = a1 + 1;
    if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a1[1] - (void)v10) >> 3) >= a4)
    {
      uint64_t result = std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::SpatialModeler::PhaseRoomSimulationSoundSource *,Phase::SpatialModeler::PhaseRoomSimulationSoundSource *,Phase::SpatialModeler::PhaseRoomSimulationSoundSource *>((uint64_t)&v21, a2, a3, (uint64_t)v10);
      uint64_t v18 = v19 - (void)v10;
      goto LABEL_15;
    }
    uint64_t v17 = a2 + 8 * ((uint64_t)(a1[1] - (void)v10) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::SpatialModeler::PhaseRoomSimulationSoundSource *,Phase::SpatialModeler::PhaseRoomSimulationSoundSource *,Phase::SpatialModeler::PhaseRoomSimulationSoundSource *>((uint64_t)&v20, a2, v17, (uint64_t)v10);
    uint64_t v10 = (void *)*v14;
    uint64_t result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseRoomSimulationSoundSource>,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*>(v9, v17, a3, *v14);
  }
  else
  {
    if (v10)
    {
      a1[1] = v10;
      operator delete(v10);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x492492492492492) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = 0x6DB6DB6DB6DB6DB7 * (v8 >> 3);
    uint64_t v12 = 2 * v11;
    if (2 * v11 <= a4) {
      uint64_t v12 = a4;
    }
    if (v11 >= 0x249249249249249) {
      unint64_t v13 = 0x492492492492492;
    }
    else {
      unint64_t v13 = v12;
    }
    std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource>::__vallocate[abi:ne180100](a1, v13);
    uint64_t v15 = a1[1];
    uint64_t v14 = a1 + 1;
    uint64_t v10 = (void *)v15;
    uint64_t result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseRoomSimulationSoundSource>,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*>(v9, a2, a3, v15);
  }
  uint64_t v18 = result - (void)v10;
LABEL_15:
  uint64_t *v14 = (uint64_t)v10 + v18;
  return result;
}

void sub_221F3D5B8(_Unwind_Exception *a1)
{
  void *v1 = v2;
  _Unwind_Resume(a1);
}

char *std::vector<Phase::SpatialModeler::PhaseRoomSimulationSoundSource>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x492492492492493) {
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::EntityShapeTemplate>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[56 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseRoomSimulationSoundSource>,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*,Phase::SpatialModeler::PhaseRoomSimulationSoundSource*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = a4;
  while (a2 != a3)
  {
    *(void *)uint64_t result = *(void *)a2;
    *(_DWORD *)(result + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(result + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(result + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(result + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(result + 24) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(result + 28) = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(result + 32) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(result + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 36);
    *(_OWORD *)(result + 40) = *(_OWORD *)(a2 + 40);
    result += 56;
    a2 += 56;
  }
  return result;
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::SpatialModeler::PhaseRoomSimulationSoundSource *,Phase::SpatialModeler::PhaseRoomSimulationSoundSource *,Phase::SpatialModeler::PhaseRoomSimulationSoundSource *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  uint64_t result = a3;
  do
  {
    *(void *)a4 = *(void *)a2;
    *(_DWORD *)(a4 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a4 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a4 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a4 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a4 + 24) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a4 + 28) = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a4 + 32) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a4 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 36);
    *(_OWORD *)(a4 + 40) = *(_OWORD *)(a2 + 40);
    a4 += 56;
    a2 += 56;
  }
  while (a2 != a3);
  return result;
}

char *std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  float32x4_t v7 = result;
  uint64_t v8 = *((void *)result + 2);
  uint64_t v9 = *(char **)result;
  if (a4 > (v8 - *(void *)result) >> 3)
  {
    if (v9)
    {
      *((void *)result + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 >> 61) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 2;
    if (v8 >> 2 <= a4) {
      uint64_t v10 = a4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v10;
    }
    uint64_t result = std::vector<Phase::FrequencyBand<float>>::__vallocate[abi:ne180100](v7, v11);
    unint64_t v13 = (char *)v7[1];
    uint64_t v12 = (void **)(v7 + 1);
    uint64_t v9 = v13;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  uint64_t v12 = (void **)(result + 8);
  uint64_t v14 = (unsigned char *)*((void *)result + 1);
  unint64_t v15 = (v14 - v9) >> 3;
  if (v15 >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    uint64_t result = (char *)memmove(*(void **)result, __src, v14 - v9);
    uint64_t v9 = (char *)*v12;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    uint64_t result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *uint64_t v12 = &v9[v17];
  return result;
}

uint64_t Phase::SpatialModeler::RoomChangeDetector::IncrementResultInternal<0ul,1ul,2ul,float,float,Phase::Vector<float,3ul>>(float a1, float a2, uint64_t a3, int *a4, uint64_t a5)
{
  *(float *)&a4[a4[8]] = a1;
  Phase::SpatialModeler::ParameterHistory<float,8>::Increment((uint64_t)a4);
  *(float *)&a4[a4[22] + 14] = a2;
  Phase::SpatialModeler::ParameterHistory<float,8>::Increment((uint64_t)(a4 + 14));
  LODWORD(v9) = *(_DWORD *)(a5 + 8);
  uint64_t v10 = (uint64_t)&a4[3 * a4[34] + 28];
  double v11 = *(double *)a5;
  *(void *)uint64_t v10 = *(void *)a5;
  *(_DWORD *)(v10 + 8) = LODWORD(v9);

  return Phase::SpatialModeler::ParameterHistory<Phase::Vector<float,3ul>,2>::Increment((uint64_t)(a4 + 28), v9, v11, v8);
}

float Phase::SpatialModeler::ParameterHistory<float,8>::Increment(uint64_t a1)
{
  int v1 = ((*(_DWORD *)(a1 + 52) - (*(_DWORD *)(a1 + 48) + 1)) & ((*(_DWORD *)(a1 + 52) - (*(_DWORD *)(a1 + 48) + 1)) >> 31))
     + *(_DWORD *)(a1 + 48)
     + 1;
  *(_DWORD *)(a1 + 48) = v1;
  uint64_t v2 = *(int *)(a1 + 32);
  float v3 = (float)v1;
  int v4 = (v2 + 1) & 7;
  if ((int)v2 + 1 <= 0) {
    int v4 = -(-(v2 + 1) & 7);
  }
  float result = *(float *)(a1 + 44) + (float)((float)(*(float *)(a1 + 4 * v2) - *(float *)(a1 + 44)) / v3);
  *(float *)(a1 + 44) = result;
  *(_DWORD *)(a1 + 32) = v4;
  *(_DWORD *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v2;
  *(_DWORD *)(a1 + 40) += ((7 - *(_DWORD *)(a1 + 40)) & ((7 - *(_DWORD *)(a1 + 40)) >> 31)) + 1;
  return result;
}

uint64_t Phase::SpatialModeler::ParameterHistory<Phase::Vector<float,3ul>,2>::Increment(uint64_t result, double a2, double a3, double a4)
{
  int v4 = ((*(_DWORD *)(result + 52) - (*(_DWORD *)(result + 48) + 1)) & ((*(_DWORD *)(result + 52)
                                                                      - (*(_DWORD *)(result + 48)
                                                                       + 1)) >> 31))
     + *(_DWORD *)(result + 48)
     + 1;
  *(_DWORD *)(result + 48) = v4;
  int v5 = *(_DWORD *)(result + 24);
  uint64_t v6 = (float32x2_t *)(result + 12 * v5);
  float v7 = *(float *)(result + 44);
  *(float *)&a4 = (float)v4;
  float v8 = (float)(v6[1].f32[0] - v7) / (float)v4;
  *(float32x2_t *)(result + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = vadd_f32(*(float32x2_t *)(result + 36), vdiv_f32(vsub_f32(*v6, *(float32x2_t *)(result + 36)), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0)));
  *(float *)(result + 44) = v7 + v8;
  int v9 = (v5 + 1) & 1;
  if (v5 < -1) {
    int v9 = -v9;
  }
  *(_DWORD *)(result + 24) = v9;
  *(_DWORD *)(result + 28) = v5;
  *(_DWORD *)(result + 32) += ((1 - *(_DWORD *)(result + 32)) & ((1 - *(_DWORD *)(result + 32)) >> 31)) + 1;
  return result;
}

char *std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection*,Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  float v7 = result;
  uint64_t v8 = *((void *)result + 2);
  int v9 = *(char **)result;
  if (0x6DB6DB6DB6DB6DB7 * ((v8 - *(void *)result) >> 2) < a4)
  {
    if (v9)
    {
      *((void *)result + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if (a4 > 0x924924924924924) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x6DB6DB6DB6DB6DB7 * (v8 >> 2);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0x492492492492492) {
      unint64_t v12 = 0x924924924924924;
    }
    else {
      unint64_t v12 = v11;
    }
    float result = std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection>::__vallocate[abi:ne180100](v7, v12);
    uint64_t v14 = (char *)v7[1];
    unint64_t v13 = (void **)(v7 + 1);
    int v9 = v14;
LABEL_16:
    size_t v17 = a3 - (void)__src;
    if (v17)
    {
      uint64_t v18 = v9;
      uint64_t v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  unint64_t v13 = (void **)(result + 8);
  unint64_t v15 = (unsigned char *)*((void *)result + 1);
  if (0x6DB6DB6DB6DB6DB7 * ((v15 - v9) >> 2) >= a4) {
    goto LABEL_16;
  }
  uint64_t v16 = &__src[4 * ((v15 - v9) >> 2)];
  if (v15 != v9)
  {
    float result = (char *)memmove(*(void **)result, __src, v15 - v9);
    int v9 = (char *)*v13;
  }
  size_t v17 = a3 - (void)v16;
  if (v17)
  {
    uint64_t v18 = v9;
    uint64_t v19 = v16;
LABEL_18:
    float result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *unint64_t v13 = &v9[v17];
  return result;
}

char *std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x924924924924925) {
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  float result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[28 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugIntersection>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x924924924924925) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(28 * a2);
}

void std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>(uint64_t *a1, _DWORD **a2, _DWORD **a3, unint64_t a4)
{
  uint64_t v8 = (uint64_t)(a1 + 2);
  uint64_t v9 = *a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) < a4)
  {
    std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__vdeallocate(a1);
    if (a4 > 0x666666666666666) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333) {
      unint64_t v11 = 0x666666666666666;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__vallocate[abi:ne180100](a1, v11);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>(v8, (uint64_t)a2, (uint64_t)a3, a1[1]);
    goto LABEL_11;
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[1] - v9) >> 3) < a4)
  {
    unint64_t v13 = &a2[(a1[1] - v9) >> 3];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *>((uint64_t)&v18, a2, v13, v9);
    uint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>(v8, (uint64_t)v13, (uint64_t)a3, a1[1]);
LABEL_11:
    a1[1] = v12;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *>((uint64_t)&v19, a2, a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = a1[1];
  if (v16 != v14)
  {
    do
    {
      size_t v17 = *(void **)(v16 - 24);
      if (v17)
      {
        *(void *)(v16 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v17;
        operator delete(v17);
      }
      v16 -= 40;
    }
    while (v16 != v15);
  }
  a1[1] = v15;
}

void sub_221F3DD04(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_221F3DD0C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

char *std::vector<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>::__vallocate[abi:ne180100](void *a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
  }
  float result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[40 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v12 = a4;
  uint64_t v13 = a4;
  v10[0] = a1;
  v10[1] = &v12;
  void v10[2] = &v13;
  char v11 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      *(_DWORD *)uint64_t v4 = *(_DWORD *)v6;
      *(_DWORD *)(v4 + 4) = *(_DWORD *)(v6 + 4);
      int v7 = *(_DWORD *)(v6 + 8);
      *(void *)(v4 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      uint64_t v8 = v4 + 16;
      *(_DWORD *)(v8 - 8) = v7;
      *(void *)(v8 + 8) = 0;
      *(void *)(v8 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      std::vector<Phase::Vector<float,3ul>>::__init_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>((char *)v8, *(_DWORD **)(v6 + 16), *(_DWORD **)(v6 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v6 + 24) - *(void *)(v6 + 16)) >> 2));
      uint64_t v4 = v13 + 40;
      v13 += 40;
      v6 += 40;
    }
    while (v6 != a3);
  }
  char v11 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v10);
  return v4;
}

void sub_221F3DE68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  while (v1 != v2)
  {
    float v3 = *(void **)(v1 - 24);
    if (v3)
    {
      *(void *)(v1 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v3;
      operator delete(v3);
    }
    v1 -= 40;
  }
}

_DWORD **std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *,Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource *>(uint64_t a1, _DWORD **a2, _DWORD **a3, uint64_t a4)
{
  if (a2 == a3) {
    return a2;
  }
  int v5 = a3;
  uint64_t v6 = a2 + 2;
  do
  {
    int v7 = v6 - 2;
    *(_DWORD *)a4 = *((_DWORD *)v6 - 4);
    *(_DWORD *)(a4 + 4) = *((_DWORD *)v6 - 3);
    *(_DWORD *)(a4 + 8) = *((_DWORD *)v6 - 2);
    if ((_DWORD **)a4 != v6 - 2) {
      std::vector<Phase::Vector<float,3ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>((void *)(a4 + 16), *v6, v6[1], 0xAAAAAAAAAAAAAAABLL * (v6[1] - *v6));
    }
    a4 += 40;
    v6 += 5;
  }
  while (v7 + 5 != v5);
  return v5;
}

char *std::vector<Phase::Vector<float,3ul>>::__assign_with_size[abi:ne180100]<Phase::Vector<float,3ul>*,Phase::Vector<float,3ul>*>(void *a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = a1[2];
  float result = (char *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)result) >> 2) >= a4)
  {
    char v18 = (char *)a1[1];
    uint64_t v14 = a1 + 1;
    uint64_t v13 = v18;
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * ((v18 - result) >> 2);
    if (v19 >= a4)
    {
      uint64_t v23 = result;
      if (a2 != a3)
      {
        BOOL v24 = result;
        do
        {
          *(_DWORD *)BOOL v24 = *v6;
          *((_DWORD *)v24 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6[1];
          *((_DWORD *)v24 + 2) = v6[2];
          v23 += 12;
          v6 += 3;
          v24 += 12;
        }
        while (v6 != a3);
      }
      size_t v17 = (char *)(v23 - result);
      uint64_t v13 = result;
    }
    else
    {
      char v20 = &a2[3 * v19];
      if (v13 != result)
      {
        do
        {
          *(_DWORD *)float result = *v6;
          *((_DWORD *)result + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6[1];
          *((_DWORD *)result + 2) = v6[2];
          v6 += 3;
          result += 12;
        }
        while (v6 != v20);
      }
      char v21 = v13;
      if (v20 != a3)
      {
        uint64_t v22 = v13;
        do
        {
          *(_DWORD *)uint64_t v22 = *v20;
          *((_DWORD *)v22 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v20[1];
          *((_DWORD *)v22 + 2) = v20[2];
          v21 += 12;
          v20 += 3;
          v22 += 12;
        }
        while (v20 != a3);
      }
      size_t v17 = (char *)(v21 - v13);
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      uint64_t v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x1555555555555555) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 2);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    if (v10 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v12 = 0x1555555555555555;
    }
    else {
      unint64_t v12 = v11;
    }
    float result = std::vector<Phase::Vector<float,3ul>>::__vallocate[abi:ne180100](a1, v12);
    uint64_t v15 = (char *)a1[1];
    uint64_t v14 = a1 + 1;
    uint64_t v13 = v15;
    uint64_t v16 = v15;
    if (v6 != a3)
    {
      uint64_t v16 = v13;
      do
      {
        *(_DWORD *)uint64_t v16 = *v6;
        *((_DWORD *)v16 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6[1];
        *((_DWORD *)v16 + 2) = v6[2];
        v16 += 12;
        v6 += 3;
      }
      while (v6 != a3);
    }
    size_t v17 = (char *)(v16 - v13);
  }
  void *v14 = &v17[(void)v13];
  return result;
}

void std::vector<std::vector<float>>::__assign_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8 = a1 + 16;
  uint64_t v9 = *(char **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) < a4)
  {
    std::vector<std::vector<float>>::__vdeallocate((uint64_t *)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3);
    if (v10 <= a4) {
      unint64_t v10 = a4;
    }
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) >= 0x555555555555555) {
      unint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v10;
    }
    std::vector<std::vector<float>>::__vallocate[abi:ne180100]((void *)a1, v11);
    unint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v8, a2, a3, *(void **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3) < a4)
  {
    uint64_t v13 = a2 + 8 * ((uint64_t)(*(void *)(a1 + 8) - (void)v9) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>((int)&v20, a2, v13, v9);
    unint64_t v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(v8, v13, a3, *(void **)(a1 + 8));
LABEL_11:
    *(void *)(a1 + 8) = v12;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>((int)&v21, a2, a3, v9);
  uint64_t v15 = v14;
  uint64_t v16 = *(void *)(a1 + 8);
  if (v16 != v14)
  {
    uint64_t v17 = *(void *)(a1 + 8);
    do
    {
      unint64_t v19 = *(void **)(v17 - 24);
      v17 -= 24;
      char v18 = v19;
      if (v19)
      {
        *(void *)(v16 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v18;
        operator delete(v18);
      }
      uint64_t v16 = v17;
    }
    while (v17 != v15);
  }
  *(void *)(a1 + 8) = v15;
}

void sub_221F3E300(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_221F3E308(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a4;
  unint64_t v10 = a4;
  unint64_t v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  unint64_t v8[2] = &v11;
  char v9 = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    do
    {
      void *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(void *)(v6 + 8), (uint64_t)(*(void *)(v6 + 8) - *(void *)v6) >> 2);
      uint64_t v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  char v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_221F3E3B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = **(void **)(a1 + 16);
  uint64_t v2 = **(void **)(a1 + 8);
  if (v1 != v2)
  {
    uint64_t v3 = **(void **)(a1 + 16);
    do
    {
      int v5 = *(void **)(v3 - 24);
      v3 -= 24;
      uint64_t v4 = v5;
      if (v5)
      {
        *(void *)(v1 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
        operator delete(v4);
      }
      uint64_t v1 = v3;
    }
    while (v3 != v2);
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<float> *,std::vector<float> *,std::vector<float> *>(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if ((char *)v5 != a4) {
        std::vector<float>::__assign_with_size[abi:ne180100]<float const*,float const*>(a4, *(char **)v5, *(void *)(v5 + 8), (uint64_t)(*(void *)(v5 + 8) - *(void *)v5) >> 2);
      }
      v5 += 24;
      a4 += 24;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(void *result, char *__src, char *a3, unint64_t a4)
{
  int v7 = result;
  unint64_t v8 = result[2];
  char v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      unint64_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      void v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = 2 * v8;
    if (2 * v8 <= a4) {
      uint64_t v10 = a4;
    }
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v11 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v11 = v10;
    }
    float result = std::vector<unsigned char>::__vallocate[abi:ne180100](v7, v11);
    char v9 = (char *)v7[1];
    goto LABEL_17;
  }
  unint64_t v12 = (unsigned char *)result[1];
  size_t v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    size_t v16 = a3 - __src;
    if (v16) {
      float result = memmove(v9, __src, v16);
    }
    uint64_t v15 = &v9[v16];
    goto LABEL_20;
  }
  uint64_t v14 = &__src[v13];
  if (v12 != v9)
  {
    float result = memmove((void *)*result, __src, v13);
    char v9 = (char *)v7[1];
  }
  if (a3 != v14) {
    float result = memmove(v9, v14, a3 - v14);
  }
  uint64_t v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

uint64_t std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::__copy_constructor(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)a1 = 0;
  *(_DWORD *)(a1 + 24) = -1;
  std::__variant_detail::__ctor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_construct[abi:ne180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1> const&>(a1, a2);
  return a1;
}

void sub_221F3E600(_Unwind_Exception *a1)
{
  std::__variant_detail::__dtor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__variant_detail::__ctor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>>::__generic_construct[abi:ne180100]<std::__variant_detail::__copy_constructor<std::__variant_detail::__traits<std::monostate,Phase::SpatialModeler::ReturnSuccess,Phase::SpatialModeler::ReturnError,Phase::SpatialModeler::WaitOnSceneQueries,Phase::SpatialModeler::ClaimOrWaitOnToken,Phase::SpatialModeler::ReleaseToken>,(std::__variant_detail::_Trait)1> const&>(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(unsigned int *)(result + 24);
  if (v4 != -1) {
    float result = ((uint64_t (*)(char *, uint64_t))off_26D476358[v4])(&v7, result);
  }
  *(_DWORD *)(v3 + 24) = -1;
  uint64_t v5 = *(unsigned int *)(a2 + 24);
  if (v5 != -1)
  {
    float result = ((uint64_t (*)(char *, uint64_t, uint64_t))off_26D476388[v5])(&v6, v3, a2);
    *(_DWORD *)(v3 + 24) = v5;
  }
  return result;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm2ELm2EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSP_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEERKSX_EEEDcSP_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

void *_ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm3ELm3EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSP_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEERKSX_EEEDcSP_DpT0_(uint64_t a1, void *a2, uint64_t a3)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return std::vector<Phase::Geometry::SceneQueryBatch *>::__init_with_size[abi:ne180100]<Phase::Geometry::SceneQueryBatch **,Phase::Geometry::SceneQueryBatch **>(a2, *(const void **)a3, *(void *)(a3 + 8), (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 3);
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm4ELm4EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSP_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEERKSX_EEEDcSP_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm5ELm5EEE10__dispatchB8ne180100IOZNS0_6__ctorINS0_8__traitsIJNS_9monostateEN5Phase14SpatialModeler13ReturnSuccessENSA_11ReturnErrorENSA_18WaitOnSceneQueriesENSA_18ClaimOrWaitOnTokenENSA_12ReleaseTokenEEEEE19__generic_constructB8ne180100IRKNS0_18__copy_constructorISG_LNS0_6_TraitE1EEEEEvRSH_OT_EUlRSP_OT0_E_JRNS0_6__baseILSK_1EJS8_SB_SC_SD_SE_SF_EEERKSX_EEEDcSP_DpT0_(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState::ClusterQueryState(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *this)
{
  uint64_t v2 = 0;
  uint64_t v3 = (char *)this + 137808;
  *(void *)this = 0;
  *((void *)this + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((void *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
  *((_DWORD *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((void *)this + 9) = 0xFFFFFFFFLL;
  *((unsigned char *)this + 80) = 0x80;
  *(void *)((char *)this + 92) = 0;
  *(void *)((char *)this + 84) = 0;
  int32x2_t v4 = vdup_n_s32(0x7F7FFFFFu);
  *((_DWORD *)this + 25) = 0;
  do
  {
    uint64_t v5 = (char *)this + v2;
    *((void *)v5 + 14) = 0;
    *((void *)v5 + 15) = 0;
    *((_DWORD *)v5 + 34) = 0;
    *((void *)v5 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    *(int32x2_t *)(v5 + 140) = v4;
    *((_DWORD *)v5 + 3std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = -1;
    *((void *)v5 + 20) = 0;
    *((void *)v5 + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
    *((void *)v5 + 19) = 0;
    *((_DWORD *)v5 + 44) = 0;
    *(void *)(v5 + 180) = -1;
    v5[188] = 0;
    *((_DWORD *)v5 + 48) = 1065353216;
    *((_OWORD *)v5 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0uLL;
    *((_OWORD *)v5 + 14) = 0uLL;
    *((_OWORD *)v5 + 15) = 0uLL;
    *((_OWORD *)v5 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
    *((_OWORD *)v5 + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0uLL;
    *((_OWORD *)v5 + 18) = 0uLL;
    *((_OWORD *)v5 + 19) = 0uLL;
    *((_OWORD *)v5 + 20) = 0uLL;
    *((_OWORD *)v5 + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0uLL;
    *((_OWORD *)v5 + 22) = 0uLL;
    *((_OWORD *)v5 + 23) = 0uLL;
    *((_OWORD *)v5 + 24) = 0uLL;
    *((_OWORD *)v5 + 25) = 0uLL;
    *((_OWORD *)v5 + 2std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
    v2 += 352;
    *((_OWORD *)v5 + 2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0uLL;
    *((_OWORD *)v5 + 28) = 0uLL;
  }
  while (v2 != 90112);
  uint64_t v6 = 0;
  uint64_t v7 = 256;
  int32x2_t v8 = vdup_n_s32(0x7F7FFFFFu);
  do
  {
    char v9 = (char *)this + v6 + 90260;
    *(void *)(v9 - 28) = 0;
    *(void *)(v9 - 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    *((_DWORD *)v9 - 3) = 0;
    *(void *)(v9 - 20) = 0;
    *((int32x2_t *)v9 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v8;
    *(_DWORD *)char v9 = -1;
    *(void *)(v9 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
    *(void *)(v9 + 4) = 0;
    *(void *)(v9 + 20) = -1;
    *((_DWORD *)v9 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
    *(void *)(v9 + 44) = 0;
    v6 += 88;
    *(void *)(v9 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    --v7;
  }
  while (v7);
  Phase::SpatialModeler::RayTracerState::RayTracerState((Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState *)((char *)this + 112752));
  *(void *)uint64_t v3 = 0;
  *((void *)v3 + 3) = 0;
  *(_OWORD *)(v3 + 8) = xmmword_2220A4EB0;
  *((void *)v3 + 4) = 0x3F80000000000000;
  return this;
}

void sub_221F3E844(_Unwind_Exception *a1)
{
  std::__function::__value_func<void ()(Phase::Geometry::SceneQueryBatch *)>::~__value_func[abi:ne180100]((void *)(v1 + 24));
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 16);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::SingleBlockAllocator::Alloc(atomic_uchar *this, uint64_t a2, unint64_t a3)
{
  if (a3 >= 0x11) {
    std::terminate();
  }
  if (atomic_exchange(this, 1u))
  {
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "SingleBlockAllocator::Alloc does not support concurrent allocations.");
  }
  std::vector<unsigned __int128>::resize((uint64_t)(this + 8), (unint64_t)(a2 + 15) >> 4);
  return *((void *)this + 1);
}

void sub_221F3E8E8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void std::vector<unsigned __int128>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 16 * a2;
    }
  }
  else
  {
    std::vector<unsigned __int128>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<unsigned __int128>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    int32x2_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 4);
    if (v10 >> 60) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 4;
    uint64_t v12 = v5 - v8;
    if (v12 >> 3 > v10) {
      unint64_t v10 = v12 >> 3;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      uint64_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>(v4, v13);
      int32x2_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v15 = &v14[16 * v11];
    size_t v16 = &v14[16 * v13];
    bzero(v15, 16 * a2);
    uint64_t v17 = &v15[16 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 2);
      uint64_t v19 = *((void *)v7 - 1);
      v7 -= 16;
      *((void *)v15 - 2) = v18;
      *((void *)v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v19;
      v15 -= 16;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

Phase::SpatialModeler::RayTracerState *Phase::SpatialModeler::RayTracerState::RayTracerState(Phase::SpatialModeler::RayTracerState *this)
{
  *(_OWORD *)((char *)this + 8) = xmmword_2220A5940;
  unint64_t v2 = (char *)this + 23664;
  uint64_t v3 = (char *)this + 22568;
  *(_OWORD *)((char *)this + 24) = xmmword_2220A5950;
  uint64_t v4 = (char *)this + 19416;
  *(_OWORD *)((char *)this + 40) = xmmword_2220A5960;
  *((int32x2_t *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = vdup_n_s32(0x3E4CCCCDu);
  *((void *)this + 8) = 0x800000000100;
  *((unsigned char *)this + 72) = 0;
  *((_DWORD *)this + 19) = 1000593162;
  *((_OWORD *)this + 5) = xmmword_2220A5970;
  *((void *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 1000;
  *(_OWORD *)((char *)this + 104) = xmmword_2220A5980;
  *((void *)this + 15) = 0x4040000040800000;
  *((_DWORD *)this + 32) = 1167867904;
  *((_DWORD *)this + 33) = 0x1000000;
  *(_OWORD *)((char *)this + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = xmmword_2220A5990;
  *((_DWORD *)this + 38) = 4;
  *((unsigned char *)this + 15std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  *((void *)this + 20) = 0xC2700000C1D00000;
  *((_DWORD *)this + 42) = 16777473;
  *(void *)((char *)this + 172) = 0x4E20000003E8;
  *((unsigned char *)this + 180) = 1;
  *((void *)this + 23) = 0x430300003DDB22D1;
  *((_DWORD *)this + 48) = 256;
  *((_OWORD *)this + 2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((_OWORD *)this + 25) = 0u;
  *((_OWORD *)this + 2std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((_OWORD *)this + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0u;
  *((_OWORD *)this + 14) = 0u;
  *((_DWORD *)this + 11std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1135312896;
  *((void *)this + 59) = 0;
  *((_DWORD *)this + 120) = 1065353216;
  *((_DWORD *)this + 475std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((_OWORD *)this + 1188) = 0u;
  *((_OWORD *)this + 1190) = 0u;
  *((_OWORD *)this + 119Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0u;
  *((_OWORD *)this + 1192) = 0u;
  *((_OWORD *)this + 1193) = 0u;
  *((_OWORD *)this + 1194) = 0u;
  *((_OWORD *)this + 1195) = 0u;
  *((_OWORD *)this + 119std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + 119std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 1198) = 0u;
  *((_OWORD *)this + 1199) = 0u;
  *((_OWORD *)this + 1200) = 0u;
  *((_OWORD *)this + 120Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0u;
  *((_OWORD *)this + 1202) = 0u;
  *((_OWORD *)this + 1203) = 0u;
  *((_OWORD *)this + 1204) = 0u;
  *((_OWORD *)this + 1205) = 0u;
  *((_OWORD *)this + 120std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + 120std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 1208) = 0u;
  *((_OWORD *)this + 1209) = 0u;
  bzero((char *)this + 496, 0x4848uLL);
  *((void *)this + 2422) = 0;
  *((void *)this + 242Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)this + 2420) = (char *)this + 19368;
  *(_OWORD *)((char *)this + 19384) = 0u;
  *(_OWORD *)((char *)this + 19400) = 0u;
  *(_DWORD *)uint64_t v4 = 1065353216;
  *((_OWORD *)this + 1214) = 0u;
  *((_OWORD *)this + 1215) = 0u;
  *((_DWORD *)v4 + 10) = 1065353216;
  *(_OWORD *)((char *)this + 19464) = 0u;
  *(_OWORD *)((char *)this + 19480) = 0u;
  *((_DWORD *)v4 + 20) = 1065353216;
  *((void *)this + 2438) = 0;
  *((_DWORD *)v4 + 24) = 0;
  *((void *)this + 262Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)this + 2620) = 0;
  bzero((char *)this + 19520, 0x598uLL);
  *((void *)this + 2619) = (char *)this + 20960;
  *((_OWORD *)this + 131Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0u;
  *((_OWORD *)this + 13std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
  *((void *)this + 2679) = 0;
  *((_DWORD *)v4 + 50std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((_DWORD *)v4 + 508) = 0;
  v4[2036] = 0;
  *((void *)this + 2682) = 0;
  *(void *)((char *)this + 22164) = 0;
  bzero((char *)this + 21472, 0x2A4uLL);
  *((void *)this + 28std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
  *((void *)this + 281Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *(_OWORD *)((char *)this + 21032) = 0u;
  *(_OWORD *)((char *)this + 21048) = 0u;
  *(_OWORD *)((char *)this + 21064) = 0u;
  *(_OWORD *)((char *)this + 21080) = 0u;
  *(_OWORD *)((char *)this + 2109std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 211std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0u;
  *(_OWORD *)((char *)this + 21128) = 0u;
  *(_OWORD *)((char *)this + 21144) = 0u;
  *(_OWORD *)((char *)this + 21160) = 0u;
  *(_OWORD *)((char *)this + 2117std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 21192) = 0u;
  *(_OWORD *)((char *)this + 21208) = 0u;
  *(_OWORD *)((char *)this + 21224) = 0u;
  *(_OWORD *)((char *)this + 21240) = 0u;
  *(_OWORD *)((char *)this + 2125std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 21272) = 0u;
  *(_OWORD *)((char *)this + 21288) = 0u;
  *(_OWORD *)((char *)this + 21304) = 0u;
  *(_OWORD *)((char *)this + 21320) = 0u;
  *(_OWORD *)((char *)this + 2133std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 21352) = 0u;
  *(_OWORD *)((char *)this + 21368) = 0u;
  *(_OWORD *)((char *)this + 21384) = 0u;
  *(_OWORD *)((char *)this + 21400) = 0u;
  *((void *)this + 267std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
  *((void *)this + 2810) = (char *)this + 22488;
  *((void *)this + 2815) = 0;
  *((void *)this + 2814) = 0;
  *((void *)this + 28std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = (char *)this + 22512;
  v4[3112] = 1;
  *((_DWORD *)v4 + 779) = 1097859072;
  *(void *)&long long v5 = 0x101010101010101;
  *((void *)&v5 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0x101010101010101;
  *(_OWORD *)((char *)this + 2253std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v5;
  *(_OWORD *)((char *)this + 22552) = v5;
  *(_DWORD *)uint64_t v3 = 2;
  *((void *)this + 2823) = 0;
  *((void *)this + 2822) = 0;
  *((_DWORD *)v3 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(void *)(v3 + 28) = 1065353216;
  *(void *)(v3 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(_OWORD *)(v3 + 44) = xmmword_2220A59A0;
  *(void *)(v3 + 60) = 1065353216;
  *(void *)(v3 + 68) = 0;
  *((_DWORD *)v3 + 19) = 1065353216;
  v3[80] = 0;
  *((void *)this + 2838) = 0;
  *((_OWORD *)this + 1418) = 0u;
  *((_OWORD *)this + 141std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 141std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((void *)this + 2839) = 0xFFFFFFFFLL;
  *((void *)this + 2840) = 0x3FB999999999999ALL;
  *((_DWORD *)v3 + 40) = 0;
  *(void *)(v3 + 164) = 0;
  *((void *)this + 2843) = 0x3FF0000000000000;
  *((_OWORD *)this + 1422) = 0u;
  *((_OWORD *)this + 1423) = 0u;
  *((_DWORD *)v3 + 54) = 0;
  *(void *)(v3 + 220) = 1065353216;
  *(void *)(v3 + 228) = 0;
  *((_DWORD *)v3 + 59) = 1065353216;
  *(_OWORD *)((char *)this + 22808) = 0u;
  *(_OWORD *)((char *)this + 22824) = 0u;
  *(_OWORD *)((char *)this + 22840) = 0u;
  *(_OWORD *)((char *)this + 2285std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 22870) = 0u;
  *((_OWORD *)this + 144std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + 1445) = 0u;
  *((_OWORD *)this + 1444) = 0u;
  *((_OWORD *)this + 1443) = 0u;
  *((_OWORD *)this + 1442) = 0u;
  *((_OWORD *)this + 144Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0u;
  *((_OWORD *)this + 1440) = 0u;
  *((_OWORD *)this + 1439) = 0u;
  *((_OWORD *)this + 1438) = 0u;
  *((_OWORD *)this + 143std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 143std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + 1435) = 0u;
  *((_OWORD *)this + 1434) = 0u;
  *((_OWORD *)this + 1433) = 0u;
  *((_OWORD *)this + 1432) = 0u;
  *((_OWORD *)this + 143Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0u;
  *((_DWORD *)v3 + 14std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  *((void *)this + 289std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((_DWORD *)v3 + 152) = 1065353216;
  *((void *)this + 2905) = 0;
  *((void *)this + 2904) = 0;
  *((void *)this + 290std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((void *)this + 2910) = 0;
  *((void *)this + 2909) = 0;
  *((void *)this + 291Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)this + 2914) = 0;
  *((void *)this + 29std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0;
  *((void *)this + 2915) = 0;
  *(_OWORD *)((char *)this + 2341std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)((char *)this + 23400) = 0u;
  *(_OWORD *)((char *)this + 23384) = 0u;
  *(_OWORD *)((char *)this + 23368) = 0u;
  *(_OWORD *)((char *)this + 23352) = 0u;
  *(_OWORD *)((char *)this + 2333std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + 1470) = 0u;
  *((_OWORD *)this + 1469) = 0u;
  *((_OWORD *)this + 1468) = 0u;
  *((_OWORD *)this + 146std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 146std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + 1465) = 0u;
  *((_OWORD *)this + 147std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)this + 147std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)this + 1475) = 0u;
  *((_OWORD *)this + 1474) = 0u;
  *((_OWORD *)this + 1473) = 0u;
  *((_OWORD *)this + 1472) = 0u;
  char *v2 = 0;
  *((void *)this + 2902) = 0;
  *((_OWORD *)this + 1450) = 0u;
  *((_OWORD *)this + 1449) = 0u;
  int32x4_t v6 = vdupq_n_s32(0x7FC00000u);
  *(int32x4_t *)(v2 + 4) = v6;
  *(int32x4_t *)(v2 + 20) = v6;
  *(int32x4_t *)(v2 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v6;
  *(int32x4_t *)(v2 + 52) = v6;
  *(void *)(v2 + 68) = v6.i64[0];
  bzero((char *)this + 23744, 0x508uLL);
  *((_WORD *)v2 + 688) = 0;
  *((void *)this + 313Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  return this;
}

void Phase::Geometry::Listener::~Listener(Phase::Geometry::Listener *this)
{
  unint64_t v2 = (void *)*((void *)this + 15);
  if (v2)
  {
    *((void *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 12);
  if (v3)
  {
    *((void *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = v3;
    operator delete(v3);
  }
}

void Phase::SpatialModeler::RendererStates::~RendererStates(Phase::SpatialModeler::RendererStates *this)
{
}

void Phase::SpatialModeler::RayTracerState::Results::~Results(Phase::SpatialModeler::RayTracerState::Results *this)
{
  std::__tree<Phase::SpatialCategory>::destroy((uint64_t)this + 1592, *((void **)this + 200));
  unint64_t v2 = (void *)*((void *)this + 196);
  if (v2)
  {
    *((void *)this + 19std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v2;
    operator delete(v2);
  }
  std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::shared_ptr<Phase::Controller::Renderer>>>>::~__hash_table((uint64_t)this + 104);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>>>::~__hash_table((uint64_t)this + 64);
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::~__hash_table((uint64_t)this + 24);
  std::__tree<std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>>>::destroy((uint64_t)this, *((void **)this + 1));
}

void Phase::SpatialModeler::RayTracerState::State::~State(Phase::SpatialModeler::RayTracerState::State *this)
{
  unint64_t v2 = (void *)*((void *)this + 2310);
  if (v2)
  {
    *((void *)this + 231Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 2307);
  if (v3)
  {
    *((void *)this + 2308) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 2304);
  if (v4)
  {
    *((void *)this + 2305) = v4;
    operator delete(v4);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleLRClusterResult>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    unint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::SpatialModeler::SingleLRClusterResult>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::SpatialModeler::SingleLRClusterResult>,0>(uint64_t a1)
{
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }

  return std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(a1 + 8);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::~__hash_table(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::__deallocate_node(a1, *(void **)(a1 + 16));
  unint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2) {
    operator delete(v2);
  }
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::__deallocate_node(uint64_t a1, void *a2)
{
  if (a2)
  {
    unint64_t v2 = a2;
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::SpatialModeler::SingleERClusterResult>,0>(v2 + 2);
      operator delete(v2);
      unint64_t v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::SpatialModeler::SingleERClusterResult>,0>(uint64_t *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 1);
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100](a1 + 24);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a1 + 25);
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100](a1 + 19, 0);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a1 + 20);
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](a1 + 13);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a1 + 14);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](a1 + 7);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a1 + 8);

  return std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table(v2);
}

void std::__tree<std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,Phase::SpatialModeler::SourceListenerResult>>>::destroy(a1, a2[1]);
    std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::SpatialModeler::SourceListenerResult>,0>((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::SpatialModeler::SourceListenerResult>,0>(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
  if (v3)
  {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
}

void std::__function::__func<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_26D4763C8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_26D4763C8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1} &,void *>((unsigned __int8 **)(a1 + 8), a2);
}

void std::__invoke_void_return_wrapper<void,true>::__call[abi:ne180100]<std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&>(Phase::SpatialModeler::SingleBlockAllocator&&,std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>> Phase::details::Alloc<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,Phase::SpatialModeler::SingleBlockAllocator>(Phase::SpatialModeler::SingleBlockAllocator &,unsigned long)::{lambda(Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState*)#1} const&)::{lambda(void *)#1} &,void *>(unsigned __int8 **a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  Phase::SpatialModeler::RayTracerState::~RayTracerState((void **)(*a2 + 112752));
  std::__function::__value_func<void ()(Phase::Geometry::SceneQueryBatch *)>::~__value_func[abi:ne180100]((void *)(v3 + 24));
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 16);
  if (v4) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  }
  atomic_store(0, *a1);
}

uint64_t *std::unique_ptr<Phase::SpatialModeler::RoomSimulationImpl::ClusterQueryState,std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v3 = *result;
  *__n128 result = a2;
  if (v3) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v3);
  }
  return result;
}

void *Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::RenderGroup [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::RenderGroup>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::RenderGroup*)#1} const&>(Phase::Logger *a1, uint64_t a2, void *a3, std::align_val_t *a4)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (!a2)
  {
    uint64_t v12 = **(id **)(Phase::Logger::GetInstance(a1) + 112);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v14 = 136315394;
      *(void *)&v14[4] = "ManagedPtr.hpp";
      __int16 v15 = 1024;
      int v16 = 229;
      _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v14, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  int32x4_t v6 = (char *)operator new(336 * *a3, *a4);
  uint64_t v7 = &v6[336 * a2];
  int32x2_t v8 = v6;
  do
  {
    uint64_t v9 = 0;
    *((_DWORD *)v8 + 8) = 0;
    *(_OWORD *)int32x2_t v8 = 0u;
    *((_OWORD *)v8 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0u;
    *(void *)(v8 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1065353216;
    *(void *)(v8 + 44) = 0;
    *((_DWORD *)v8 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 1065353216;
    do
    {
      unint64_t v10 = &v8[v9];
      *((_DWORD *)v10 + 14) = 0;
      *((void *)v10 + 8) = 0;
      v9 += 16;
    }
    while (v9 != 128);
    *((void *)v8 + 23) = 0;
    memset(v14, 0, sizeof(v14));
    Phase::Subbands<float>::Subbands((uint64_t)(v8 + 192), v14, 3);
    v8[320] = 0;
    v8 += 336;
  }
  while (v8 != v7);
  *(void *)uint64_t v14 = &unk_26D476410;
  v14[8] = 0;
  uint64_t v17 = v14;
  *(void *)a1 = v6;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)a1 + 8, (uint64_t)v14);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v14);
}

void sub_221F3F5A8(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler11RenderGroupERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_ED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler11RenderGroupERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_26D476410;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler11RenderGroupERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEPNS0_6__baseISD_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D476410;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler11RenderGroupERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_EclEOSC_(uint64_t a1, void **a2)
{
}

void *Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int32x4_t v6 = **(id **)(Phase::Logger::GetInstance(0) + 112);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int32x2_t v8 = 136315394;
      *(void *)&void v8[4] = "ManagedPtr.hpp";
      __int16 v9 = 1024;
      int v10 = 229;
      _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v8, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  uint64_t v4 = operator new(**(void **)a2, **(std::align_val_t **)(a2 + 8));
  *(void *)int32x2_t v8 = &unk_26D4764E8;
  v8[8] = 0;
  uint64_t v11 = v8;
  *a3 = v4;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v8);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v8);
}

void sub_221F3F7B0(_Unwind_Exception *exception_object)
{
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayIbRKZNS3_10AllocArrayIbEENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS5_IbEESD_mmEUlPS7_E_EESD_mOT0_OT1_EUlSA_E_NS_9allocatorISP_EESB_ED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayIbRKZNS3_10AllocArrayIbEENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS5_IbEESD_mmEUlPS7_E_EESD_mOT0_OT1_EUlSA_E_NS_9allocatorISP_EESB_E7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_26D4764E8;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayIbRKZNS3_10AllocArrayIbEENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS5_IbEESD_mmEUlPS7_E_EESD_mOT0_OT1_EUlSA_E_NS_9allocatorISP_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D4764E8;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayIbRKZNS3_10AllocArrayIbEENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS5_IbEESD_mmEUlPS7_E_EESD_mOT0_OT1_EUlSA_E_NS_9allocatorISP_EESB_EclEOSA_(uint64_t a1, void **a2)
{
}

void *Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::SpatialModeler::SubmixRoutingOutput [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::SpatialModeler::SubmixRoutingOutput>(unsigned long,unsigned long)::{lambda(Phase::SpatialModeler::SubmixRoutingOutput*)#1} const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!a1)
  {
    int32x2_t v8 = **(id **)(Phase::Logger::GetInstance(0) + 112);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int v10 = 136315394;
      *(void *)&v10[4] = "ManagedPtr.hpp";
      __int16 v11 = 1024;
      int v12 = 229;
      _os_log_impl(&dword_221E5E000, v8, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [inCount == 0 is true]: \"Attempting to allocate an array of 0 elements\"", v10, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::logic_error::logic_error(exception, "Attempting to allocate an array of 0 elements");
  }
  long long v5 = operator new(16 * **(void **)a2, **(std::align_val_t **)(a2 + 8));
  int32x4_t v6 = v5;
  do
  {
    *int32x4_t v6 = -1;
    v6[1] = 0;
    v6 += 2;
  }
  while (v6 != &v5[2 * a1]);
  *(void *)int v10 = &unk_26D476458;
  v10[8] = 0;
  unint64_t v13 = v10;
  *a3 = v5;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v10);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v10);
}

void sub_221F3F9D8(_Unwind_Exception *exception_object)
{
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler19SubmixRoutingOutputERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_ED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler19SubmixRoutingOutputERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  *(void *)__n128 result = &unk_26D476458;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler19SubmixRoutingOutputERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEPNS0_6__baseISD_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D476458;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_14SpatialModeler19SubmixRoutingOutputERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_EclEOSC_(uint64_t a1, void **a2)
{
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::clear(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::__deallocate_node(a1, *(void **)(a1 + 16));
    *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2)
    {
      for (uint64_t i = 0; i != v2; ++i)
        *(void *)(*(void *)a1 + 8 * i) = 0;
    }
    *(void *)(a1 + 24) = 0;
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    int v10 = *(void ***)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      for (uint64_t i = *v10; i; uint64_t i = (void *)*i)
      {
        unint64_t v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7) {
            return i;
          }
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4) {
            break;
          }
        }
      }
    }
  }
  uint64_t i = operator new(0x28uLL);
  *uint64_t i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  i[4] = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    BOOL v15 = 1;
    if (v8 >= 3) {
      BOOL v15 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v8);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t v18 = v17;
    }
    else {
      size_t v18 = v16;
    }
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v18);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  uint64_t v19 = *(void *)a1;
  char v20 = *(void **)(*(void *)a1 + 8 * v4);
  if (v20)
  {
    *uint64_t i = *v20;
LABEL_38:
    *char v20 = i;
    goto LABEL_39;
  }
  *uint64_t i = *(void *)(a1 + 16);
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = i;
  *(void *)(v19 + 8 * v4) = a1 + 16;
  if (*i)
  {
    unint64_t v21 = *(void *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8) {
        v21 %= v8;
      }
    }
    else
    {
      v21 &= v8 - 1;
    }
    char v20 = (void *)(*(void *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(void *)(a1 + 24);
  return i;
}

void sub_221F3FCF8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, void **a4)
{
  unint64_t v7 = *a2;
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = *a2;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
    int v10 = *(void **)(*(void *)a1 + 8 * v4);
    if (v10)
    {
      __int16 v11 = (void *)*v10;
      if (*v10)
      {
        do
        {
          unint64_t v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == v7) {
              return v11;
            }
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8) {
                v12 %= v8;
              }
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4) {
              break;
            }
          }
          __int16 v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
  uint64_t v13 = a1 + 16;
  float v14 = (char *)operator new(0x128uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  *(void *)float v14 = 0;
  *((void *)v14 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v7;
  *((void *)v14 + 2) = **a4;
  *((void *)v14 + 35) = 0;
  *(_OWORD *)(v14 + 248) = 0u;
  *(_OWORD *)(v14 + 232) = 0u;
  *(_OWORD *)(v14 + 21std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(v14 + 200) = 0u;
  *(_OWORD *)(v14 + 184) = 0u;
  *(_OWORD *)(v14 + 168) = 0u;
  *(_OWORD *)(v14 + 152) = 0u;
  *(_OWORD *)(v14 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(v14 + 120) = 0u;
  *(_OWORD *)(v14 + 104) = 0u;
  *(_OWORD *)(v14 + 88) = 0u;
  *(_OWORD *)(v14 + 72) = 0u;
  *(_OWORD *)(v14 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 24) = 0u;
  *(_OWORD *)(v14 + 264) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  *((_DWORD *)v14 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 3;
  v14[68] = 1;
  *((void *)v14 + 14) = 0;
  *((void *)v14 + 15) = 0;
  *((void *)v14 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0;
  *((void *)v14 + 20) = 0;
  *((void *)v14 + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)v14 + 19) = 0;
  *((void *)v14 + 25) = 0;
  *((void *)v14 + 2std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((void *)v14 + 30) = 0;
  *((void *)v14 + 3Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)v14 + 32) = 0;
  *((_WORD *)v14 + 132) = 0;
  *((void *)v14 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  char v25 = 1;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    BOOL v17 = 1;
    if (v8 >= 3) {
      BOOL v17 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v8);
    unint64_t v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19) {
      size_t v20 = v19;
    }
    else {
      size_t v20 = v18;
    }
    std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::__rehash<true>(a1, v20);
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
      else {
        unint64_t v4 = v7;
      }
    }
    else
    {
      unint64_t v4 = (v8 - 1) & v7;
    }
  }
  unint64_t v21 = *(void **)(*(void *)a1 + 8 * v4);
  if (v21)
  {
    *(void *)v24[0] = *v21;
    *unint64_t v21 = v24[0];
  }
  else
  {
    *(void *)v24[0] = *(void *)(a1 + 16);
    *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v24[0];
    *(void *)(*(void *)a1 + 8 * v4) = v13;
    if (*(void *)v24[0])
    {
      unint64_t v22 = *(void *)(*(void *)v24[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8) {
          v22 %= v8;
        }
      }
      else
      {
        v22 &= v8 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v22) = v24[0];
    }
  }
  __int16 v11 = (void *)v24[0];
  v24[0] = 0;
  ++*(void *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return v11;
}

void sub_221F3FFD4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::SingleERClusterResult>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t **)a1;
  *(void *)a1 = a2;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:ne180100]<std::pair<unsigned long long const,Phase::SpatialModeler::SingleERClusterResult>,0>(v2 + 2);
    }
    operator delete(v2);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,void *> *>>(void *a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v6 = a1[1];
  if (!v6) {
    goto LABEL_9;
  }
  for (uint64_t i = 0; i != v6; *(void *)(*a1 + 8 * i++) = 0)
    ;
  unint64_t v8 = (uint64_t *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v8)
  {
    while (a2 != a3)
    {
      unint64_t v9 = a2[2];
      unint64_t v8[2] = v9;
      *((_DWORD *)v8 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)a2 + 6);
      *((_DWORD *)v8 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *((_DWORD *)a2 + 7);
      *((_DWORD *)v8 + 8) = *((_DWORD *)a2 + 8);
      *((_DWORD *)v8 + 9) = *((_DWORD *)a2 + 9);
      int v10 = (uint64_t *)*v8;
      v8[1] = v9;
      inserted = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__node_insert_multi_prepare((uint64_t)a1, v9, v8 + 2);
      std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::__node_insert_multi_perform(a1, v8, inserted);
      a2 = (uint64_t *)*a2;
      unint64_t v8 = v10;
      if (!v10) {
        goto LABEL_9;
      }
    }
    do
    {
      unint64_t v12 = (uint64_t *)*v8;
      operator delete(v8);
      unint64_t v8 = v12;
    }
    while (v12);
  }
  else
  {
LABEL_9:
    while (a2 != a3)
    {
      std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__emplace_multi<std::pair<unsigned long long const,Phase::SpatialModeler::ClusteredSourceInfo> const&>(a1, (uint64_t)(a2 + 2));
      a2 = (uint64_t *)*a2;
    }
  }
}

void sub_221F4013C(void *a1)
{
  __cxa_begin_catch(a1);
  do
  {
    uint64_t v2 = (void *)*v1;
    operator delete(v1);
    uint64_t v1 = v2;
  }
  while (v2);
  __cxa_rethrow();
}

void sub_221F4015C(_Unwind_Exception *a1)
{
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__node_insert_multi_prepare(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v6 = *(void *)(a1 + 8);
  float v7 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v8 = *(float *)(a1 + 32);
  if (!v6 || (float)(v8 * (float)v6) < v7)
  {
    uint64_t v9 = 2 * v6;
    BOOL v10 = v6 < 3 || (v6 & (v6 - 1)) != 0;
    size_t v11 = v10 | v9;
    unint64_t v12 = vcvtps_u32_f32(v7 / v8);
    if (v11 <= v12) {
      size_t v13 = v12;
    }
    else {
      size_t v13 = v11;
    }
    std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__rehash<false>(a1, v13);
    unint64_t v6 = *(void *)(a1 + 8);
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    unint64_t v15 = a2;
    if (v6 <= a2) {
      unint64_t v15 = a2 % v6;
    }
  }
  else
  {
    unint64_t v15 = (v6 - 1) & a2;
  }
  float v16 = *(void **)(*(void *)a1 + 8 * v15);
  if (!v16) {
    return 0;
  }
  int v17 = 0;
  do
  {
    __n128 result = v16;
    float v16 = (void *)*v16;
    if (!v16) {
      break;
    }
    unint64_t v19 = v16[1];
    if (v14.u32[0] > 1uLL)
    {
      unint64_t v20 = v16[1];
      if (v19 >= v6) {
        unint64_t v20 = v19 % v6;
      }
    }
    else
    {
      unint64_t v20 = v19 & (v6 - 1);
    }
    if (v20 != v15) {
      break;
    }
    BOOL v21 = v19 == a2 && v16[2] == *a3;
    int v22 = v17 & !v21;
    v17 |= v21;
  }
  while (v22 != 1);
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__rehash<false>(uint64_t a1, size_t __n)
{
  if (__n == 1)
  {
    size_t prime = 2;
  }
  else
  {
    size_t prime = __n;
    if ((__n & (__n - 1)) != 0) {
      size_t prime = std::__next_prime(__n);
    }
  }
  int8x8_t v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(void *)&v4) {
    goto LABEL_16;
  }
  if (prime < *(void *)&v4)
  {
    unint64_t v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      unint64_t v5 = std::__next_prime(v5);
    }
    else
    {
      uint64_t v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2) {
        unint64_t v5 = v7;
      }
    }
    if (prime <= v5) {
      size_t prime = v5;
    }
    if (prime < *(void *)&v4)
    {
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__do_rehash<false>(a1, prime);
    }
  }
}

void std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__do_rehash<false>(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (a2 >> 61) {
      std::__throw_bad_array_new_length[abi:ne180100]();
    }
    int8x8_t v4 = operator new(8 * a2);
    unint64_t v5 = *(void **)a1;
    *(void *)a1 = v4;
    if (v5) {
      operator delete(v5);
    }
    uint64_t v6 = 0;
    *(void *)(a1 + 8) = a2;
    do
      *(void *)(*(void *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    uint64_t v7 = *(void **)(a1 + 16);
    if (v7)
    {
      unint64_t v8 = v7[1];
      uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2) {
          v8 %= a2;
        }
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v8) = a1 + 16;
      for (uint64_t i = (void *)*v7; *v7; uint64_t i = (void *)*v7)
      {
        unint64_t v12 = i[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v12 >= a2) {
            v12 %= a2;
          }
        }
        else
        {
          v12 &= a2 - 1;
        }
        if (v12 == v8)
        {
          uint64_t v7 = i;
        }
        else
        {
          size_t v13 = i;
          if (*(void *)(*(void *)a1 + 8 * v12))
          {
            do
            {
              uint8x8_t v14 = v13;
              size_t v13 = (void *)*v13;
            }
            while (v13 && i[2] == v13[2]);
            void *v7 = v13;
            void *v14 = **(void **)(*(void *)a1 + 8 * v12);
            **(void **)(*(void *)a1 + 8 * vstd::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = i;
          }
          else
          {
            *(void *)(*(void *)a1 + 8 * vstd::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v7;
            uint64_t v7 = i;
            unint64_t v8 = v12;
          }
        }
      }
    }
  }
  else
  {
    BOOL v10 = *(void **)a1;
    *(void *)a1 = 0;
    if (v10) {
      operator delete(v10);
    }
    *(void *)(a1 + 8) = 0;
  }
}

char *std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__emplace_multi<std::pair<unsigned long long const,Phase::SpatialModeler::ClusteredSourceInfo> const&>(void *a1, uint64_t a2)
{
  int8x8_t v4 = (char *)operator new(0x28uLL);
  unint64_t v5 = *(void *)a2;
  *((void *)v4 + 2) = *(void *)a2;
  *(_OWORD *)(v4 + 24) = *(_OWORD *)(a2 + 8);
  *(void *)int8x8_t v4 = 0;
  *((void *)v4 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v5;
  inserted = std::__hash_table<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,Phase::SpatialModeler::ClusteredSourceInfo>>>::__node_insert_multi_prepare((uint64_t)a1, v5, (void *)v4 + 2);
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::__node_insert_multi_perform(a1, v4, inserted);
  return v4;
}

void sub_221F40598(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *Phase::AllocPackedSubbandArray<float>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void **a3@<X8>)
{
  void v8[4] = *MEMORY[0x263EF8340];
  v8[0] = &unk_26D4764A0;
  void v8[3] = v8;
  *a3 = operator new(4 * a1 * a2 + 16, (std::align_val_t)8uLL);
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)(a3 + 1), (uint64_t)v8);
  __n128 result = std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v8);
  uint64_t v7 = *a3;
  void *v7 = a1;
  v7[1] = a2;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>> Phase::details::AllocMem<Phase::PackedSubbandArray<float>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbandArray<float>*)#1},std::allocator<std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>> Phase::details::AllocMem<Phase::PackedSubbandArray<float>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbandArray<float>*)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>> Phase::details::AllocMem<Phase::PackedSubbandArray<float>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbandArray<float>*)#1},std::allocator<std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>> Phase::details::AllocMem<Phase::PackedSubbandArray<float>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbandArray<float>*)#1}>,void ()(void *)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_26D4764A0;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>> Phase::details::AllocMem<Phase::PackedSubbandArray<float>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbandArray<float>*)#1},std::allocator<std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>> Phase::details::AllocMem<Phase::PackedSubbandArray<float>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbandArray<float>*)#1}>,void ()(void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D4764A0;
}

void std::__function::__func<std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>> Phase::details::AllocMem<Phase::PackedSubbandArray<float>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbandArray<float>*)#1},std::allocator<std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>> Phase::details::AllocMem<Phase::PackedSubbandArray<float>>(unsigned long,unsigned long)::{lambda(Phase::PackedSubbandArray<float>*)#1}>,void ()(void *)>::operator()(uint64_t a1, void **a2)
{
}

void *std::vector<unsigned long>::vector(void *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<Phase::Vector<float,2ul>>::__vallocate[abi:ne180100](a1, a2);
    int8x8_t v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_221F40744(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *,false>(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, char a5)
{
  BOOL v10 = (uint64_t *)result;
LABEL_2:
  size_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    BOOL v10 = v11;
    uint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    unint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v22 = *(a2 - 1);
          uint64_t v23 = *v11;
          if (*(float *)(*(void *)(*a3 + 56) + 4 * v22) < *(float *)(*(void *)(*a3 + 56) + 4 * *v11))
          {
            uint64_t *v11 = v22;
            *(a2 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v23;
          }
          break;
        case 3uLL:
          __n128 result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11, v11 + 1, a2 - 1, (uint64_t)a3);
          break;
        case 4uLL:
          __n128 result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11, v11 + 1, v11 + 2, a2 - 1, (uint64_t)a3);
          break;
        case 5uLL:
          __n128 result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, (uint64_t)a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *,unsigned long *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    int v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11, &v11[v15 >> 1], a2 - 1, (uint64_t)a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11 + 1, v17 - 1, a2 - 2, (uint64_t)a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11 + 2, &v11[v16 + 1], a2 - 3, (uint64_t)a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v17 - 1, v17, &v11[v16 + 1], (uint64_t)a3);
      uint64_t v18 = *v11;
      uint64_t *v11 = *v17;
      *int v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(&v11[v15 >> 1], v11, a2 - 1, (uint64_t)a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(float *)(*(void *)(*a3 + 56) + 4 * *(v11 - 1)) >= *(float *)(*(void *)(*a3 + 56) + 4 * *v11))
    {
      __n128 result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &>(v11, a2, (uint64_t)a3);
      size_t v11 = (uint64_t *)result;
      goto LABEL_19;
    }
LABEL_14:
    unint64_t v19 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &>(v11, a2, (uint64_t)a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    BOOL v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11, v19, (uint64_t)a3);
    size_t v11 = v19 + 1;
    __n128 result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v19 + 1, a2, (uint64_t)a3);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      __n128 result = std::__introsort<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *,false>(v10, v19, a3, -v13, a5 & 1);
      size_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11, a2, (uint64_t)a3);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(v11, a2, (uint64_t)a3);
  }
}

uint64_t *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = *(void *)(*(void *)a3 + 56);
      uint64_t v5 = 8;
      char v6 = result;
      do
      {
        uint64_t v8 = *v6;
        uint64_t v7 = v6[1];
        char v6 = v3;
        float v9 = *(float *)(v4 + 4 * v7);
        if (v9 < *(float *)(v4 + 4 * v8))
        {
          uint64_t v10 = v5;
          while (1)
          {
            *(uint64_t *)((char *)result + v10) = v8;
            uint64_t v11 = v10 - 8;
            if (v10 == 8) {
              break;
            }
            uint64_t v8 = *(uint64_t *)((char *)result + v10 - 16);
            v10 -= 8;
            if (v9 >= *(float *)(v4 + 4 * v8))
            {
              uint64_t v12 = (uint64_t *)((char *)result + v11);
              goto LABEL_10;
            }
          }
          uint64_t v12 = result;
LABEL_10:
          *uint64_t v12 = v7;
        }
        uint64_t v3 = v6 + 1;
        v5 += 8;
      }
      while (v6 + 1 != a2);
    }
  }
  return result;
}

uint64_t *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(uint64_t *result, uint64_t *a2, uint64_t a3)
{
  if (result != a2)
  {
    uint64_t v3 = result + 1;
    if (result + 1 != a2)
    {
      uint64_t v4 = *(void *)(*(void *)a3 + 56);
      do
      {
        uint64_t v6 = *result;
        uint64_t v5 = result[1];
        __n128 result = v3;
        float v7 = *(float *)(v4 + 4 * v5);
        if (v7 < *(float *)(v4 + 4 * v6))
        {
          do
          {
            uint64_t *v3 = v6;
            uint64_t v6 = *(v3 - 2);
            --v3;
          }
          while (v7 < *(float *)(v4 + 4 * v6));
          uint64_t *v3 = v5;
        }
        uint64_t v3 = result + 1;
      }
      while (result + 1 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *a1;
  uint64_t v6 = *(void *)(*(void *)a4 + 56);
  float v7 = *(float *)(v6 + 4 * *a2);
  float v8 = *(float *)(v6 + 4 * *a1);
  uint64_t v9 = *a3;
  float v10 = *(float *)(v6 + 4 * *a3);
  if (v7 < v8)
  {
    if (v10 < v7)
    {
      *a1 = v9;
      *a3 = v5;
      return 1;
    }
    *a1 = v4;
    *a2 = v5;
    if (*(float *)(v6 + 4 * *a3) >= v8) {
      return 1;
    }
    *a2 = *a3;
    *a3 = v5;
    return 2;
  }
  if (v10 < v7)
  {
    *a2 = v9;
    *a3 = v4;
    uint64_t v11 = *a1;
    if (*(float *)(v6 + 4 * *a2) >= *(float *)(v6 + 4 * *a1)) {
      return 1;
    }
    *a1 = *a2;
    *a2 = v11;
    return 2;
  }
  return 0;
}

uint64_t *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)(*(void *)a3 + 56);
  float v5 = *(float *)(v4 + 4 * *a1);
  if (v5 >= *(float *)(v4 + 4 * *(a2 - 1)))
  {
    float v8 = a1 + 1;
    do
    {
      uint64_t v6 = v8;
      if (v8 >= a2) {
        break;
      }
      ++v8;
    }
    while (v5 >= *(float *)(v4 + 4 * *v6));
  }
  else
  {
    uint64_t v6 = a1;
    do
    {
      uint64_t v7 = v6[1];
      ++v6;
    }
    while (v5 >= *(float *)(v4 + 4 * v7));
  }
  if (v6 < a2)
  {
    do
      uint64_t v9 = *--a2;
    while (v5 < *(float *)(v4 + 4 * v9));
  }
  if (v6 < a2)
  {
    uint64_t v10 = *v6;
    uint64_t v11 = *a2;
    do
    {
      *uint64_t v6 = v11;
      *a2 = v10;
      do
      {
        uint64_t v12 = v6[1];
        ++v6;
        uint64_t v10 = v12;
      }
      while (v5 >= *(float *)(v4 + 4 * v12));
      do
      {
        uint64_t v13 = *--a2;
        uint64_t v11 = v13;
      }
      while (v5 < *(float *)(v4 + 4 * v13));
    }
    while (v6 < a2);
  }
  if (v6 - 1 != a1) {
    *a1 = *(v6 - 1);
  }
  *(v6 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v3;
  return v6;
}

uint64_t *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,unsigned long *,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = *a1;
  uint64_t v5 = *(void *)(*(void *)a3 + 56);
  float v6 = *(float *)(v5 + 4 * *a1);
  do
    uint64_t v7 = a1[++v3];
  while (*(float *)(v5 + 4 * v7) < v6);
  float v8 = &a1[v3];
  uint64_t v9 = &a1[v3 - 1];
  if (v3 == 1)
  {
    do
    {
      if (v8 >= a2) {
        break;
      }
      uint64_t v11 = *--a2;
    }
    while (*(float *)(v5 + 4 * v11) >= v6);
  }
  else
  {
    do
      uint64_t v10 = *--a2;
    while (*(float *)(v5 + 4 * v10) >= v6);
  }
  if (v8 < a2)
  {
    uint64_t v12 = *a2;
    uint64_t v13 = &a1[v3];
    uint64_t v14 = a2;
    do
    {
      *uint64_t v13 = v12;
      uint64_t *v14 = v7;
      do
      {
        uint64_t v15 = v13[1];
        ++v13;
        uint64_t v7 = v15;
      }
      while (*(float *)(v5 + 4 * v15) < v6);
      do
      {
        uint64_t v16 = *--v14;
        uint64_t v12 = v16;
      }
      while (*(float *)(v5 + 4 * v16) >= v6);
    }
    while (v13 < v14);
    uint64_t v9 = v13 - 1;
  }
  if (v9 != a1) {
    *a1 = *v9;
  }
  *uint64_t v9 = v4;
  return v9;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v8 = *(a2 - 1);
      uint64_t v9 = *a1;
      if (*(float *)(*(void *)(*(void *)a3 + 56) + 4 * v8) < *(float *)(*(void *)(*(void *)a3 + 56)
                                                                             + 4 * *a1))
      {
        *a1 = v8;
        *(a2 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v9;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(a1, a1 + 1, a2 - 1, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1, a3);
      return 1;
    default:
      uint64_t v10 = a1 + 2;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(a1, a1 + 1, a1 + 2, a3);
      uint64_t v11 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v12 = 0;
      uint64_t v13 = *(void *)(*(void *)a3 + 56);
      uint64_t v14 = 24;
      break;
  }
  while (1)
  {
    uint64_t v15 = *v11;
    uint64_t v16 = *v10;
    float v17 = *(float *)(v13 + 4 * *v11);
    if (v17 < *(float *)(v13 + 4 * *v10))
    {
      uint64_t v18 = v14;
      while (1)
      {
        *(uint64_t *)((char *)a1 + v18) = v16;
        uint64_t v19 = v18 - 8;
        if (v18 == 8) {
          break;
        }
        uint64_t v16 = *(uint64_t *)((char *)a1 + v18 - 16);
        v18 -= 8;
        if (v17 >= *(float *)(v13 + 4 * v16))
        {
          char v20 = (uint64_t *)((char *)a1 + v19);
          goto LABEL_12;
        }
      }
      char v20 = a1;
LABEL_12:
      *char v20 = v15;
      if (++v12 == 8) {
        return v11 + 1 == a2;
      }
    }
    uint64_t v10 = v11;
    v14 += 8;
    if (++v11 == a2) {
      return 1;
    }
  }
}

uint64_t std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(a1, a2, a3, a5);
  uint64_t v11 = *a3;
  uint64_t v12 = *(void *)(*(void *)a5 + 56);
  if (*(float *)(v12 + 4 * *a4) < *(float *)(v12 + 4 * *a3))
  {
    *a3 = *a4;
    *a4 = v11;
    uint64_t v13 = *a2;
    if (*(float *)(v12 + 4 * *a3) < *(float *)(v12 + 4 * *a2))
    {
      *a2 = *a3;
      *a3 = v13;
      uint64_t v14 = *a1;
      if (*(float *)(v12 + 4 * *a2) < *(float *)(v12 + 4 * *a1))
      {
        *a1 = *a2;
        *a2 = v14;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(a1, a2, a3, a4, a6);
  uint64_t v13 = *a4;
  uint64_t v14 = *(void *)(*(void *)a6 + 56);
  if (*(float *)(v14 + 4 * *a5) < *(float *)(v14 + 4 * *a4))
  {
    *a4 = *a5;
    *a5 = v13;
    uint64_t v15 = *a3;
    if (*(float *)(v14 + 4 * *a4) < *(float *)(v14 + 4 * *a3))
    {
      *a3 = *a4;
      *a4 = v15;
      uint64_t v16 = *a2;
      if (*(float *)(v14 + 4 * *a3) < *(float *)(v14 + 4 * *a2))
      {
        *a2 = *a3;
        *a3 = v16;
        uint64_t v17 = *a1;
        if (*(float *)(v14 + 4 * *a2) < *(float *)(v14 + 4 * *a1))
        {
          *a1 = *a2;
          *a2 = v17;
        }
      }
    }
  }
  return result;
}

uint64_t *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *,unsigned long *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  if (a1 != a2)
  {
    uint64_t v8 = (char *)a2 - (char *)a1;
    uint64_t v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 9)
    {
      unint64_t v10 = (unint64_t)(v9 - 2) >> 1;
      unint64_t v11 = v10 + 1;
      uint64_t v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    uint64_t v13 = a2;
    if (a2 != a3)
    {
      uint64_t v14 = a2;
      do
      {
        uint64_t v15 = *v14;
        if (*(float *)(*(void *)(*a4 + 56) + 4 * *v14) < *(float *)(*(void *)(*a4 + 56) + 4 * *a1))
        {
          uint64_t *v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      uint64_t v13 = a3;
    }
    if (v8 >= 9)
    {
      uint64_t v16 = (unint64_t)v8 >> 3;
      uint64_t v17 = a2 - 1;
      do
      {
        uint64_t v18 = *a1;
        uint64_t v19 = std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(a1, a4, v16);
        if (v17 == v19)
        {
          uint64_t *v19 = v18;
        }
        else
        {
          uint64_t *v19 = *v17;
          *uint64_t v17 = v18;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>((uint64_t)a1, (uint64_t)(v19 + 1), (uint64_t)a4, v19 + 1 - a1);
        }
        --v17;
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(uint64_t result, uint64_t *a2, uint64_t a3, uint64_t *a4)
{
  if (a3 >= 2)
  {
    uint64_t v4 = (uint64_t)a4 - result;
    int64_t v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 3)
    {
      uint64_t v6 = v4 >> 2;
      uint64_t v7 = (v4 >> 2) + 1;
      uint64_t v8 = (uint64_t *)(result + 8 * v7);
      uint64_t v9 = v6 + 2;
      uint64_t v10 = *a2;
      if (v9 >= a3)
      {
        uint64_t v11 = *(void *)(v10 + 56);
      }
      else
      {
        uint64_t v11 = *(void *)(v10 + 56);
        if (*(float *)(v11 + 4 * *v8) < *(float *)(v11 + 4 * v8[1]))
        {
          ++v8;
          uint64_t v7 = v9;
        }
      }
      uint64_t v12 = *v8;
      uint64_t v13 = *a4;
      float v14 = *(float *)(v11 + 4 * *a4);
      if (*(float *)(v11 + 4 * *v8) >= v14)
      {
        do
        {
          uint64_t v15 = v8;
          *a4 = v12;
          if (v5 < v7) {
            break;
          }
          uint64_t v16 = 2 * v7;
          uint64_t v7 = (2 * v7) | 1;
          uint64_t v8 = (uint64_t *)(result + 8 * v7);
          uint64_t v17 = v16 + 2;
          if (v17 < a3 && *(float *)(v11 + 4 * *v8) < *(float *)(v11 + 4 * v8[1]))
          {
            ++v8;
            uint64_t v7 = v17;
          }
          uint64_t v12 = *v8;
          a4 = v15;
        }
        while (*(float *)(v11 + 4 * *v8) >= v14);
        uint64_t *v15 = v13;
      }
    }
  }
  return result;
}

void *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(void *result, uint64_t *a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v4 = a3 - 2;
  if (a3 < 2) {
    uint64_t v4 = a3 - 1;
  }
  uint64_t v5 = v4 >> 1;
  uint64_t v6 = *a2;
  do
  {
    uint64_t v7 = result;
    result += v3 + 1;
    uint64_t v8 = 2 * v3;
    uint64_t v3 = (2 * v3) | 1;
    uint64_t v9 = v8 + 2;
    if (v9 < a3
      && *(float *)(*(void *)(v6 + 56) + 4 * *result) < *(float *)(*(void *)(v6 + 56) + 4 * result[1]))
    {
      ++result;
      uint64_t v3 = v9;
    }
    void *v7 = *result;
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,void Phase::SpatialModeler::SortMetadataByDelay<float>(Phase::SpatialModeler::DirectionalMetadataOutput<float> &)::{lambda(unsigned long,unsigned long)#1} &,unsigned long *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a4 >= 2)
  {
    unint64_t v4 = (unint64_t)(a4 - 2) >> 1;
    uint64_t v5 = (void *)(result + 8 * v4);
    uint64_t v6 = *v5;
    uint64_t v9 = *(void *)(a2 - 8);
    uint64_t v7 = (void *)(a2 - 8);
    uint64_t v8 = v9;
    uint64_t v10 = *(void *)(*(void *)a3 + 56);
    float v11 = *(float *)(v10 + 4 * v9);
    if (*(float *)(v10 + 4 * *v5) < v11)
    {
      do
      {
        uint64_t v12 = v5;
        void *v7 = v6;
        if (!v4) {
          break;
        }
        unint64_t v4 = (v4 - 1) >> 1;
        uint64_t v5 = (void *)(result + 8 * v4);
        uint64_t v6 = *v5;
        uint64_t v7 = v12;
      }
      while (*(float *)(v10 + 4 * *v5) < v11);
      *uint64_t v12 = v8;
    }
  }
  return result;
}

void *std::__function::__value_func<void ()(void *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F41734(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void Phase::SpatialModeler::ConvertMetadataSphericalToCartesian<float>(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 204) != 1)
  {
    uint64_t v2 = *(uint64_t **)(a1 + 104);
    if (v2)
    {
      uint64_t v3 = *v2;
      if (*v2)
      {
        unint64_t v4 = (float *)(*(void *)(a1 + 8) + 8);
        do
        {
          float v5 = *(v4 - 1);
          float v6 = (float)((float)(180.0 - *v4) - (float)(floorf((float)(180.0 - *v4) / 360.0) * 360.0)) + 0.0;
          if (v6 >= 360.0) {
            float v6 = nextafterf(360.0, 0.0);
          }
          float v7 = v5 * 0.017453;
          float v8 = v6 * 0.017453;
          float v9 = *(v4 - 2);
          __float2 v10 = __sincosf_stret(v7);
          __float2 v11 = __sincosf_stret(v8);
          *(v4 - 2) = (float)(v10.__sinval * v9) * v11.__sinval;
          *(v4 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v10.__cosval * v9;
          float *v4 = (float)(v10.__sinval * v9) * v11.__cosval;
          v4 += 3;
          --v3;
        }
        while (v3);
        *(_DWORD *)(a1 + 204) = 1;
      }
    }
  }
}

void Phase::SpatialModeler::ConvertMetadataCartesianToSpherical<float>(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 204))
  {
    uint64_t v2 = *(void **)(a1 + 104);
    if (v2)
    {
      if (*v2)
      {
        uint64_t v3 = 0;
        unint64_t v4 = 0;
LABEL_5:
        uint64_t v2 = (void *)*v2;
        while (v4 < (unint64_t)v2)
        {
          Phase::CartesianToSphericalXZ<float>((float *)(*(void *)(a1 + 8) + v3), (float *)&v7);
          float v8 = v8 * 57.296;
          float v5 = (float)((float)(180.0 - (float)(v9 * 57.296))
                     - (float)(floorf((float)(180.0 - (float)(v9 * 57.296)) / 360.0) * 360.0))
             + 0.0;
          if (v5 >= 360.0) {
            float v5 = nextafterf(360.0, 0.0);
          }
          float v9 = v5;
          uint64_t v6 = *(void *)(a1 + 8) + v3;
          *(_DWORD *)uint64_t v6 = v7;
          *(float *)(v6 + 4) = v8;
          *(float *)(v6 + 8) = v9;
          ++v4;
          uint64_t v2 = *(void **)(a1 + 104);
          v3 += 12;
          if (v2) {
            goto LABEL_5;
          }
        }
        *(_DWORD *)(a1 + 204) = 0;
      }
    }
  }
}

void Phase::SpatialModeler::EarlyReflectionsSimulation::GetSupportedQueryDescs(std::string **a1@<X8>)
{
  *(void *)&long long v29 = *MEMORY[0x263EF8340];
  char v14 = 4;
  strcpy((char *)&v13, "CULL");
  uint64_t v15 = 0;
  uint64_t v16 = 0x100000001;
  int v17 = 1;
  memset(v18, 0, sizeof(v18));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v18, 7uLL);
  uint64_t v3 = 0;
  uint64_t v4 = *(void *)v18;
  do
  {
    *(_DWORD *)(v4 + v3 * 4) = Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::sCullQueryPropertyUIDs[v3];
    ++v3;
  }
  while (v3 != 7);
  v19[23] = 7;
  strcpy(v19, "CLUSTER");
  uint64_t v20 = 1;
  uint64_t v21 = 0x200000003;
  int v22 = 1;
  memset(v23, 0, sizeof(v23));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v23, 7uLL);
  uint64_t v5 = 0;
  uint64_t v6 = *(void *)v23;
  do
  {
    *(_DWORD *)(v6 + v5 * 4) = Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::sClusterQueryPropertyUIDs[v5];
    ++v5;
  }
  while (v5 != 7);
  v24[23] = 7;
  strcpy(v24, "SPATIAL");
  uint64_t v25 = 2;
  uint64_t v26 = 0x300000002;
  int v27 = 2;
  memset(v28, 0, sizeof(v28));
  std::vector<unsigned int>::resize((std::vector<unsigned int> *)v28, 7uLL);
  uint64_t v7 = 0;
  uint64_t v8 = *(void *)v28;
  do
  {
    *(_DWORD *)(v8 + v7 * 4) = Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::sSpatialQueryPropertyUIDs[v7];
    ++v7;
  }
  while (v7 != 7);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  float v9 = (std::string *)operator new(0xF0uLL);
  *a1 = v9;
  a1[1] = v9;
  a1[2] = v9 + 10;
  uint64_t v10 = 0;
  a1[1] = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Phase::SpatialModeler::QueryDesc>,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc const*,Phase::SpatialModeler::QueryDesc*>((uint64_t)(a1 + 2), &v13, &v29, v9);
  do
  {
    __float2 v11 = (char *)&v13 + v10;
    uint64_t v12 = *(void **)&v28[v10];
    if (v12)
    {
      *((void *)v11 + 2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v12;
      operator delete(v12);
    }
    if (v11[183] < 0) {
      operator delete(*((void **)v11 + 20));
    }
    v10 -= 80;
  }
  while (v10 != -240);
}

void sub_221F41B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10, uint64_t a11, char a12)
{
  *(void *)(v12 + 8) = v13;
  std::vector<Phase::SpatialModeler::QueryDesc>::__destroy_vector::operator()[abi:ne180100](&a10);
  for (uint64_t i = 160; i != -80; i -= 80)
    Phase::SpatialModeler::QueryDesc::~QueryDesc((Phase::SpatialModeler::QueryDesc *)(&a12 + i));
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::GetEntityShapeTemplates@<X0>(Phase::SpatialModeler::EarlyReflectionsSimulation *this@<X0>, uint64_t *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  int v7 = 0;
  memset(v8, 0, sizeof(v8));
  int v9 = 1065353216;
  int v10 = 4;
  int v3 = *(_DWORD *)(Phase::Logger::GetInstance(this) + 1200);
  if (!v3) {
    int v3 = 3;
  }
  int v7 = v3;
  if ((v3 - 4) < 0xFFFFFFFD) {
    __assert_rtn("GetEntityShapeTemplates", "EarlyReflectionsSimulationModeler.cpp", 238, "occluderTemplate.mShapeType > Geometry::DefaultShapeType::Invalid && occluderTemplate.mShapeType < Geometry::DefaultShapeType::Count");
  }
  uint64_t v4 = (int *)a2[1];
  if ((unint64_t)v4 >= a2[2])
  {
    uint64_t v5 = std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__push_back_slow_path<Phase::SpatialModeler::EntityShapeTemplate const&>(a2, &v7);
  }
  else
  {
    int *v4 = v3;
    std::unordered_map<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,std::allocator<std::pair<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey const,Phase::OptionsValue>>>::unordered_map((uint64_t)(v4 + 2), (uint64_t)v8);
    v4[12] = v10;
    uint64_t v5 = (uint64_t)(v4 + 14);
    a2[1] = (uint64_t)(v4 + 14);
  }
  a2[1] = v5;
  return std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table((uint64_t)v8);
}

void sub_221F41CF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  uint64_t v13 = v12;
  *(void *)(v10 + 8) = v13;
  std::__hash_table<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,std::__unordered_map_hasher<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,true>,std::__unordered_map_equal<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalEqualTo,Phase::UnorderedStringMap<Phase::OptionsValue>::InternalHash,true>,std::allocator<std::__hash_value_type<Phase::UnorderedStringMap<Phase::OptionsValue>::InternalKey,Phase::OptionsValue>>>::~__hash_table(v11);
  a10 = (void **)v10;
  std::vector<Phase::SpatialModeler::EntityShapeTemplate>::__destroy_vector::operator()[abi:ne180100](&a10);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::EarlyReflectionsSimulation::Init(uint64_t a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  *(void *)(a1 + 40) = a2[3];
  *(_DWORD *)(a1 + 32) = 2;
  *(_DWORD *)(a1 + 60) = Phase::Geometry::SceneQueryTypeRegistry::DeriveNewType((Phase::Geometry::SceneQueryTypeRegistry *)(*(void *)(a1 + 16) + 2288), 3u);
  *(_DWORD *)(a1 + 64) = Phase::Geometry::SceneQueryTypeRegistry::DeriveNewType((Phase::Geometry::SceneQueryTypeRegistry *)(*(void *)(a1 + 16) + 2288), 3u);
  Phase::Geometry::System::GetCurrentState(*(Phase::Geometry::System **)(a1 + 16), &v12);
  uint64_t v4 = (long long *)a2[1];
  if (v4)
  {
    long long v5 = *v4;
    *(_OWORD *)(a1 + 1072) = v4[1];
    *(_OWORD *)(a1 + 105std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v5;
    long long v6 = v4[2];
    long long v7 = v4[3];
    long long v8 = v4[4];
    *(_OWORD *)(a1 + 113std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v4[5];
    *(_OWORD *)(a1 + 1120) = v8;
    *(_OWORD *)(a1 + 1104) = v7;
    *(_OWORD *)(a1 + 1088) = v6;
    long long v9 = v4[6];
    long long v10 = v4[7];
    long long v11 = v4[8];
    *(_DWORD *)(a1 + 1200) = *((_DWORD *)v4 + 36);
    *(_OWORD *)(a1 + 1184) = v11;
    *(_OWORD *)(a1 + 1168) = v10;
    *(_OWORD *)(a1 + 1152) = v9;
  }
  Phase::SpatialModeler::RoomSimulationConfig::ReadDefaultsWriteFlags((Phase::SpatialModeler::RoomSimulationConfig *)(a1 + 1056));
  *(void *)(a1 + 1280) = *a2;
  operator new();
}

void sub_221F420C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  if (a10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::Shutdown(Phase::SpatialModeler::EarlyReflectionsSimulation *this)
{
  uint64_t v1 = *((void *)this + 164);
  *((void *)this + 164) = 0;
  if (v1) {
    std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100]((uint64_t)this + 1312, v1);
  }

  return Phase::SpatialModeler::RoomSimulation::DeinitERtoLRModelerCache(this);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::RunQuery@<X0>(uint64_t result@<X0>, void *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v3 = a2[10];
  if (v3 > 2)
  {
    *(void *)a3 = 2;
    *(void *)(a3 + 8) = result + 72;
    *(_DWORD *)(a3 + 24) = 2;
  }
  else
  {
    uint64_t v4 = (_DWORD *)a2[11];
    if (v4
      && (long long v5 = Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::QueryTable[v3], *((_DWORD *)v5 + 4) == *v4))
    {
      long long v6 = (_DWORD *)a2[12];
      if (v6 && *((_DWORD *)v5 + 5) == *v6) {
        return (*((uint64_t (**)(void))v5 + 8))();
      }
      uint64_t v7 = result + 72;
      uint64_t v8 = 4;
    }
    else
    {
      uint64_t v7 = result + 72;
      uint64_t v8 = 3;
    }
    *(void *)a3 = v8;
    *(void *)(a3 + 8) = v7;
    *(_DWORD *)(a3 + 24) = 2;
  }
  return result;
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::AllocateQueryState@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  unint64_t v2 = *(void *)(a1 + 80);
  if (v2 <= 2)
  {
    unint64_t v3 = (uint64_t (*)(void))*((void *)Phase::SpatialModeler::EarlyReflectionsSimulationPrivate::QueryTable[v2] + 7);
    if (v3) {
      return v3();
    }
  }
  *a2 = 0;
  a2[4] = 0;
  return result;
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::GetGraphDescription@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  switch(a1)
  {
    case 2:
      *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x223C933A0](a2, "EarlyReflectionsSimSpatialQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t result = MEMORY[0x223C933A0](v4, "FullEarlyReflectionsSimSpatialGraph");
      goto LABEL_7;
    case 1:
      *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x223C933A0](a2, "EarlyReflectionsSimClusterQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t result = MEMORY[0x223C933A0](v4, "FullEarlyReflectionsSimClusterGraph");
      goto LABEL_7;
    case 0:
      *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
      *(_OWORD *)(a2 + 32) = 0uLL;
      *(_OWORD *)a2 = 0uLL;
      MEMORY[0x223C933A0](a2, "EarlyReflectionsSimCullQueryGraph");
      std::vector<Phase::SpatialModeler::GraphDescriptionNode>::resize((uint64_t *)(a2 + 24), 1uLL);
      uint64_t v4 = *(void *)(a2 + 24);
      uint64_t result = MEMORY[0x223C933A0](v4, "FullEarlyReflectionsSimCullGraph");
LABEL_7:
      *(void *)(v4 + 24) = 0xFFFFFFFFLL;
      return result;
  }
  *(_OWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0uLL;
  *(_OWORD *)(a2 + 32) = 0uLL;
  *(_OWORD *)a2 = 0uLL;
  return result;
}

void sub_221F42318(_Unwind_Exception *a1)
{
  Phase::SpatialModeler::GraphDescription::~GraphDescription(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::GetErrorCategory(Phase::SpatialModeler::EarlyReflectionsSimulation *this)
{
  return (uint64_t)this + 72;
}

BOOL Phase::SpatialModeler::EarlyReflectionsSimulation::IsQueryIndexValid(Phase::SpatialModeler::EarlyReflectionsSimulation *this, unint64_t a2)
{
  return a2 < 3;
}

void Phase::SpatialModeler::EarlyReflectionsSimulation::StoreRayTracerStateToCache(Phase::SpatialModeler::EarlyReflectionsSimulation *this, const Phase::SpatialModeler::RayTracerState *a2)
{
  uint64_t v2 = MEMORY[0x270FA5388](this);
  v5[3133] = *(void **)MEMORY[0x263EF8340];
  unint64_t v3 = *(unsigned int **)(v2 + 1312);
  Phase::SpatialModeler::RayTracerState::RayTracerState((Phase::SpatialModeler::RayTracerState *)v5, v4);
  caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::write(v3, (const Phase::SpatialModeler::RayTracerState *)v5);
  Phase::SpatialModeler::RayTracerState::~RayTracerState(v5);
}

void sub_221F423E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
}

uint64_t caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::write(unsigned int *a1, const Phase::SpatialModeler::RayTracerState *a2)
{
  int v10 = 0;
  if (a1[1] == 3) {
    unsigned int v4 = 0;
  }
  else {
    unsigned int v4 = a1[1];
  }
  for (unsigned int i = atomic_load(a1); ; unsigned int i = atomic_load(a1))
  {
    BOOL v6 = v4 == (unsigned __int16)i || v4 == HIWORD(i);
    if (!v6) {
      break;
    }
    caulk::concurrent::details::spinloop::spin((uint64_t)&v10);
    if (v4 == 2) {
      unsigned int v4 = 0;
    }
    else {
      ++v4;
    }
  }
  std::optional<Phase::SpatialModeler::RayTracerState>::operator=[abi:ne180100]<Phase::SpatialModeler::RayTracerState&,void>((Phase::SpatialModeler::RayTracerState *)&a1[6268 * v4 + 4], a2);
  unsigned int v7 = i;
  atomic_compare_exchange_strong((atomic_uint *volatile)a1, &v7, (unsigned __int16)i | ((unsigned __int16)v4 << 16));
  if (v7 != i)
  {
    unsigned int v8 = v7;
    do
    {
      atomic_compare_exchange_strong((atomic_uint *volatile)a1, &v8, (unsigned __int16)v7 | (v4 << 16));
      BOOL v6 = v8 == v7;
      unsigned int v7 = v8;
    }
    while (!v6);
  }
  a1[1] = v4 + 1;
  return (uint64_t)&a1[6268 * v4 + 4];
}

uint64_t Phase::SpatialModeler::EarlyReflectionsSimulation::LoadRayTracerStateFromCache(unsigned int **this)
{
  return caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::read_if (this[164]);
}

uint64_t caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>::read_if (unsigned int *a1)
{
  unsigned int v1 = atomic_load(a1);
  unsigned int v2 = HIWORD(v1);
  if (HIWORD(v1) == 0xFFFF)
  {
    LOWORD(v3) = v1;
LABEL_6:
    unsigned int v2 = (unsigned __int16)v3;
    if ((unsigned __int16)v3 == 0xFFFF) {
      return 0;
    }
  }
  else
  {
    unsigned int v3 = v1;
    while (1)
    {
      atomic_compare_exchange_strong((atomic_uint *volatile)a1, &v3, v2 | 0xFFFF0000);
      if (v3 == v1) {
        break;
      }
      unsigned int v2 = HIWORD(v3);
      unsigned int v1 = v3;
      if (HIWORD(v3) == 0xFFFF) {
        goto LABEL_6;
      }
    }
  }
  long long v5 = &a1[6268 * v2];
  if (*((unsigned char *)v5 + 25072)) {
    return (uint64_t)(v5 + 4);
  }
  _os_assert_log();
  uint64_t result = _os_crash();
  __break(1u);
  return result;
}

void Phase::SpatialModeler::EarlyReflectionsSimulation::~EarlyReflectionsSimulation(Phase::SpatialModeler::EarlyReflectionsSimulation *this)
{
  Phase::SpatialModeler::RoomSimulation::~RoomSimulation(this);

  JUMPOUT(0x223C938A0);
}

void Phase::SpatialModeler::RoomSimulation::~RoomSimulation(Phase::SpatialModeler::RoomSimulation *this)
{
  unsigned int v2 = (char *)this + 51784;
  *(void *)this = &unk_26D476688;
  uint64_t v3 = *((void *)this + 6495);
  *((void *)v2 + 22) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)v2 + 21);
  *((void *)v2 + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  long long v5 = (std::__shared_weak_count *)*((void *)v2 + 20);
  if (v5) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v5);
  }
  BOOL v6 = (void *)*((void *)v2 + 15);
  if (v6)
  {
    *((void *)v2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v6;
    operator delete(v6);
  }
  unsigned int v7 = (void *)*((void *)v2 + 6);
  if (v7)
  {
    *((void *)v2 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v7;
    operator delete(v7);
  }
  unsigned int v8 = (void *)*((void *)v2 + 3);
  if (v8)
  {
    *((void *)v2 + 4) = v8;
    operator delete(v8);
  }
  long long v9 = *(void **)v2;
  if (*(void *)v2)
  {
    *((void *)v2 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v9;
    operator delete(v9);
  }
  Phase::SpatialModeler::RayTracerState::~RayTracerState((void **)this + 3340);
  std::mutex::~mutex((std::mutex *)((char *)this + 26640));
  int v10 = (void *)*((void *)this + 3326);
  if (v10)
  {
    *((void *)this + 332std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v10;
    operator delete(v10);
  }
  long long v11 = (void *)*((void *)this + 3317);
  if (v11)
  {
    *((void *)this + 3318) = v11;
    operator delete(v11);
  }
  uint64_t v12 = (void *)*((void *)this + 3314);
  if (v12)
  {
    *((void *)this + 3315) = v12;
    operator delete(v12);
  }
  uint64_t v13 = (void *)*((void *)this + 3311);
  if (v13)
  {
    *((void *)this + 33std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v13;
    operator delete(v13);
  }
  Phase::SpatialModeler::RayTracerState::~RayTracerState((void **)this + 178);
  std::mutex::~mutex((std::mutex *)this + 21);
  Phase::SpatialModeler::HistogramPtrStack::Clear((Phase::SpatialModeler::RoomSimulation *)((char *)this + 1328));
  uint64_t v14 = *((void *)this + 164);
  *((void *)this + 164) = 0;
  if (v14) {
    std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100]((uint64_t)this + 1312, v14);
  }
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 120);
  std::__hash_table<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::__unordered_map_hasher<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::hash<Phase::SpatialCategory>,std::equal_to<Phase::SpatialCategory>,true>,std::__unordered_map_equal<Phase::SpatialCategory,std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>,std::equal_to<Phase::SpatialCategory>,std::hash<Phase::SpatialCategory>,true>,std::allocator<std::__hash_value_type<Phase::SpatialCategory,Phase::Controller::SpatialCategoryParameters>>>::~__hash_table((uint64_t)this + 80);
  std::error_category::~error_category((std::error_category *)this + 9);
  *(void *)this = &unk_26D471808;
  std::error_category::~error_category((std::error_category *)this + 1);
}

void Phase::SpatialModeler::HistogramPtrStack::Clear(Phase::SpatialModeler::HistogramPtrStack *this)
{
  atomic_fetch_add(Phase::SpatialModeler::HistogramPtrStack::sIsClearingPoolFlag, 1u);
  do
  {
    Phase::SpatialModeler::HistogramPtrStack::Pop(&v2);
    unint64_t v1 = v2;
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
  }
  while (v1);
  atomic_fetch_add(Phase::SpatialModeler::HistogramPtrStack::sIsClearingPoolFlag, 0xFFFFFFFF);
}

void Phase::SpatialModeler::HistogramPtrStack::Pop(unint64_t *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  uint64_t v3 = caulk::concurrent::stack<caulk::alloc::free_block,caulk::concurrent::intrusive_single_link_node<caulk::alloc::free_block>>::pop();
  if (v3)
  {
    unint64_t v4 = v3[1];
    unint64_t v5 = v3[2];
    if (v5)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
      BOOL v6 = (std::__shared_weak_count *)v3[2];
      *a1 = v4;
      a1[1] = v5;
      if (v6)
      {
        std::__shared_weak_count::__release_shared[abi:ne180100](v6);
      }
    }
    else
    {
      *a1 = v4;
      a1[1] = 0;
    }
  }
}

void std::default_delete<caulk::concurrent::multi_buffer<Phase::SpatialModeler::RayTracerState,3>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = 75216;
    for (uint64_t i = 50160; ; i -= 25072)
    {
      if (*(unsigned char *)(a2 + v3)) {
        Phase::SpatialModeler::RayTracerState::~RayTracerState((void **)(a2 + i));
      }
      v3 -= 25072;
      if (!v3)
      {
        JUMPOUT(0x223C938A0);
      }
    }
  }
}

Phase::SpatialModeler::RayTracerState *std::optional<Phase::SpatialModeler::RayTracerState>::operator=[abi:ne180100]<Phase::SpatialModeler::RayTracerState&,void>(Phase::SpatialModeler::RayTracerState *this, const Phase::SpatialModeler::RayTracerState *a2)
{
  uint64_t v3 = (char *)this + 25056;
  if (*((unsigned char *)this + 25056))
  {
    Phase::SpatialModeler::RayTracerState::operator=((uint64_t)this, (uint64_t)a2);
  }
  else
  {
    Phase::SpatialModeler::RayTracerState::RayTracerState(this, a2);
    unsigned char *v3 = 1;
  }
  return this;
}

void Phase::SpatialModeler::GenerateEarlyScattering(std::__shared_weak_count *a1, uint64_t *a2, Phase::SpatialModeler::RayTracerState *this, double a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v146 = *MEMORY[0x263EF8340];
  if (!a1[1].__vftable) {
    return;
  }
  long long v9 = a1;
  int v10 = 0;
  uint64_t v110 = (float *)((char *)this + 19512);
  float v11 = a4;
  float v109 = v11;
  unint64_t v114 = a1;
  do
  {
    unint64_t shared_weak_owners = (void *)v9->__shared_weak_owners_;
    if (!shared_weak_owners) {
      goto LABEL_90;
    }
    int v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    float v16 = 3.4028e38;
    do
    {
      if ((std::__shared_weak_count_vtbl *)shared_weak_owners[3] != v10) {
        goto LABEL_38;
      }
      int v17 = (unint64_t *)(v9->__shared_weak_owners_ + 16);
      Phase::SpatialModeler::RayTracerState::GetSourceListenerResult(this, v17, (uint64_t)&v118);
      if (v120)
      {
        if (v14)
        {
          Phase::SpatialModeler::DirectivityHistogram::operator+=((uint64_t)v14, v120);
          if (v15) {
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v18 = *((void *)this + 2367);
          uint64_t v19 = *((void *)this + 2366);
          uint64_t v20 = v18 - v19;
          if (v18 == v19)
          {
LABEL_23:
            char v26 = 0;
            if (!v15) {
              goto LABEL_25;
            }
          }
          else
          {
            uint64_t v21 = 0;
            uint64_t v22 = *(void *)(a6 + 144);
            unint64_t v23 = v20 / 56;
            if (v23 <= 1) {
              unint64_t v23 = 1;
            }
            while (1)
            {
              if (*v17 == *(void *)(v19 + 56 * v21) && v22)
              {
                uint64_t v24 = 0;
                uint64_t v25 = (unsigned char *)(*(void *)(a6 + 104) + 152);
                while (*((void *)v25 - 1) != *(void *)(v19 + 56 * v21 + 48))
                {
                  ++v24;
                  v25 += 304;
                  if (v22 == v24) {
                    goto LABEL_22;
                  }
                }
                if ((v24 & 0x8000000000000000) == 0 && !*v25 && v14[10] < 0.000029155) {
                  break;
                }
              }
LABEL_22:
              if (++v21 == v23) {
                goto LABEL_23;
              }
            }
            char v26 = 1;
            if (!v15)
            {
LABEL_25:
              ++v13;
              if ((v26 & 1) == 0 && *(float *)(v120 + 40) < v16) {
                float v16 = *(float *)(v120 + 40);
              }
LABEL_33:
              long long v9 = v114;
              goto LABEL_34;
            }
          }
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
          goto LABEL_25;
        }
        Phase::SpatialModeler::RayTracerState::CopyDirectivityHistogram(this, &v120, &v143);
        uint64_t v14 = v143;
        int v27 = v144[0];
        long long v143 = 0;
        v144[0] = 0;
        if (v15)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
          if (v144[0]) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v144[0]);
          }
        }
        ++v13;
        uint64_t v15 = v27;
        goto LABEL_33;
      }
LABEL_34:
      if (v121) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v121);
      }
      a1 = v119;
      if (v119) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v119);
      }
LABEL_38:
      unint64_t shared_weak_owners = (void *)*shared_weak_owners;
    }
    while (shared_weak_owners);
    if (v16 < 3.4028e38) {
      v14[10] = v16;
    }
    if (v13 >= 2) {
      a1 = (std::__shared_weak_count *)Phase::SpatialModeler::DirectivityHistogram::operator/=((uint64_t)v14, (float)v13);
    }
    if (v14)
    {
      float v28 = v14[10];
      float v29 = *((float *)this + 116);
      int v30 = *((unsigned __int8 *)this + 135);
      LODWORD(v118) = 3;
      BYTE4(v118) = 1;
      uint64_t v119 = 0;
      int v131 = 0;
      uint64_t v123 = 0;
      uint64_t v124 = 0;
      uint64_t v122 = 0;
      v125[4] = 0;
      unint64_t v126 = 0;
      v125[3] = 0;
      v127[3] = 0;
      uint64_t v128 = 0;
      memset(&v129[3], 0, 24);
      __int16 v130 = 0;
      float v31 = *v110;
      float v32 = *((float *)this + 32);
      float v34 = *((float *)this + 26);
      float v33 = *((float *)this + 27);
      uint64_t Instance = Phase::Logger::GetInstance((Phase::Logger *)a1);
      if (v30) {
        int v36 = 0;
      }
      else {
        int v36 = (v28 * a4);
      }
      float v37 = v28 * v29;
      if (v28 <= 0.0) {
        float v37 = 1.0;
      }
      float v38 = log10f((float)((float)(1.0 / (float)(v37 * v37)) * v34) + 1.0e-15) * 10.0;
      float v39 = expf((float)((float)(*(float *)(Instance + 1204) * 10.0) / 10.0) * 0.11513);
      Phase::SpatialModeler::generateDirectionalMetadataLR((Phase::SpatialModeler::DirectivityHistogram *)v14, v36, &v118, a7, v31, v29, v109, v38, v32, 0.0, v33, v39);
      uint64_t v40 = *a2;
      if (v126)
      {
        uint64_t v41 = *v126;
        if (*v126)
        {
          if (*(_DWORD *)(v40 + 208 * (void)v10 + 204) != v131) {
            goto LABEL_92;
          }
          uint64_t v42 = v126[1];
          if (!v42) {
            goto LABEL_92;
          }
          uint64_t v43 = v40 + 208 * (void)v10;
          uint8x8_t v44 = *(uint64_t **)(v43 + 104);
          int v108 = (uint64_t *)(v43 + 104);
          uint64_t v107 = *a2;
          if (v44)
          {
            uint64_t v45 = v44[1];
            if (!v45 || v45 == v42)
            {
              uint64_t v46 = *v44;
              goto LABEL_61;
            }
LABEL_92:
            std::terminate();
          }
          uint64_t v46 = 0;
LABEL_61:
          long long v132 = (uint64_t *)(v46 + v41);
          uint64_t v135 = 4;
          uint64_t v137 = (uint64_t *)&v132;
          v138[0] = &v135;
          Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>(v46 + v41, (uint64_t)&v137, &v143);
          uint64_t v47 = (uint64_t)v143;
          long long v143 = 0;
          uint64_t v140 = v47;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v141, (uint64_t)v144);
          uint64_t v142 = v46 + v41;
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v143);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v144);
          uint64_t v135 = v46 + v41;
          v115[0] = 4;
          long long v132 = &v135;
          v133[0] = v115;
          Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>(v46 + v41, (uint64_t)&v132, &v143);
          uint64_t v48 = (uint64_t)v143;
          long long v143 = 0;
          uint64_t v137 = (uint64_t *)v48;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v138, (uint64_t)v144);
          uint64_t v139 = v46 + v41;
          std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v143);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v144);
          if (v126) {
            uint64_t v49 = v126[1];
          }
          else {
            uint64_t v49 = 0;
          }
          Phase::AllocPackedSubbandArray<float>(v46 + v41, v49, (void **)&v135);
          uint64_t v116 = 1;
          uint64_t v117 = v46 + v41;
          v115[0] = &v117;
          v115[1] = &v116;
          Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(v46 + v41, (uint64_t)v115, &v143);
          uint64_t v50 = (uint64_t)v143;
          long long v143 = 0;
          long long v132 = (uint64_t *)v50;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v133, (uint64_t)v144);
          uint64_t v134 = v46 + v41;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v143);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v144);
          uint64_t v51 = v140;
          uint64_t v52 = (uint64_t)v137;
          uint64_t v53 = v135;
          if (v46)
          {
            uint64_t v54 = 0;
            uint64_t v55 = v107;
            uint64_t v56 = (void *)(v107 + 208 * (void)v10);
            uint64_t v57 = v56[1];
            uint64_t v58 = v56[7];
            uint64_t v59 = *v108 + 16;
            uint64_t v60 = *(void *)(*v108 + 8);
            unint64_t v61 = (char *)(v135 + 16);
            uint64_t v62 = *(void *)(v135 + 8);
            uint64_t v63 = v56[18];
            uint64_t v64 = (uint64_t)v132;
            do
            {
              unsigned int v65 = (_DWORD *)(v57 + 12 * v54);
              float v66 = (_DWORD *)(v51 + 12 * v54);
              *float v66 = *v65;
              v66[1] = v65[1];
              v66[2] = v65[2];
              *(_DWORD *)(v52 + 4 * v54) = *(_DWORD *)(v58 + 4 * v54);
              uint64_t v67 = (int *)v59;
              uint64_t v68 = v61;
              for (uint64_t i = v60; i; --i)
              {
                int v70 = *v67++;
                *v68++ = v70;
              }
              *(unsigned char *)(v64 + v54) = *(unsigned char *)(v63 + v54);
              ++v54;
              v61 += 4 * v62;
              v59 += 4 * v60;
            }
            while (v54 != v46);
          }
          else
          {
            uint64_t v62 = *(void *)(v135 + 8);
            uint64_t v64 = (uint64_t)v132;
            uint64_t v55 = v107;
          }
          uint64_t v71 = 0;
          unint64_t v72 = v119;
          uint64_t v73 = v124;
          unint64_t v74 = (int *)(v126 + 2);
          uint64_t v75 = v126[1];
          uint64_t v76 = v128;
          uint64_t v77 = 4 * v62;
          uint64_t v78 = v53 + v77 * v46 + 16;
          do
          {
            unint64_t v79 = (_DWORD *)((char *)v72 + 12 * v71);
            uint64_t v80 = (_DWORD *)(v51 + 12 * (v71 + v46));
            *uint64_t v80 = *v79;
            v80[1] = v79[1];
            v80[2] = v79[2];
            *(_DWORD *)(v52 + 4 * (v71 + v46)) = *(_DWORD *)(v73 + 4 * v71);
            uint64_t v81 = v74;
            uint64_t v82 = (_DWORD *)v78;
            for (uint64_t j = v75; j; --j)
            {
              int v84 = *v81++;
              *v82++ = v84;
            }
            *(unsigned char *)(v64 + v71 + v4std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(unsigned char *)(v76 + v71);
            ++v71;
            v78 += v77;
            v74 += v75;
          }
          while (v71 != v41);
          uint64_t v85 = v55 + 208 * (void)v10;
          uint64_t v86 = *(void *)(v85 + 8);
          *(void *)(v85 + 8) = 0;
          long long v143 = (float *)v86;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v144, v85 + 16);
          uint64_t v145 = *(void *)(v85 + 48);
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(v85 + 8), &v140);
          *(void *)(v85 + 48) = v142;
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](&v140, (uint64_t *)&v143);
          uint64_t v142 = v145;
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v143);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v144);
          uint64_t v87 = *(void *)(v85 + 56);
          *(void *)(v85 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
          long long v143 = (float *)v87;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v144, v85 + 64);
          uint64_t v145 = *(void *)(v85 + 96);
          std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)(v85 + 56), (uint64_t *)&v137);
          *(void *)(v85 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v139;
          std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v137, (uint64_t *)&v143);
          uint64_t v139 = v145;
          std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v143);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v144);
          uint64_t v88 = *v108;
          *int v108 = v135;
          uint64_t v135 = v88;
          std::__function::__value_func<void ()(void *)>::swap[abi:ne180100]((void *)(v85 + 112), v136);
          uint64_t v89 = *(void *)(v85 + 144);
          v85 += 144;
          *(void *)uint64_t v85 = 0;
          long long v143 = (float *)v89;
          std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v144, v85 + 8);
          uint64_t v145 = *(void *)(v85 + 40);
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)v85, (uint64_t *)&v132);
          *(void *)(v85 + 40) = v134;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100]((uint64_t *)&v132, (uint64_t *)&v143);
          uint64_t v134 = v145;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v143);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v144);
          *(unsigned char *)(v85 + 5std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
          std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v132);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v133);
          std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100](&v135, 0);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v136);
          std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v137);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v138);
          std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100](&v140);
          std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v141);
          uint64_t v40 = *a2;
        }
      }
      Phase::SpatialModeler::SortMetadataByDelay<float>(v40 + 208 * (void)v10);
      unint64_t v90 = *(void *)(*a2 + 208 * (void)v10 + 48);
      if (v90)
      {
        uint64_t v91 = 0;
        uint64_t v92 = 0;
        float v93 = *((float *)this + 19);
        float v94 = *((float *)this + 27) - v93;
        unsigned int v95 = ((float)(v93 + v93) * a4);
        unsigned int v96 = v95 >> 1;
        uint64_t v97 = *a2 + 208 * (void)v10;
        uint64_t v98 = *(void *)(v97 + 56);
        float v99 = (float)v95 + -1.0;
        uint64_t v100 = v97 + 104;
        do
        {
          float v101 = *(float *)(v98 + 4 * v92) - v94;
          if (v101 >= 0.0 && v101 < *((float *)this + 19))
          {
            float v103 = cosf((float)((float)(v96 + (v101 * a4)) * 6.2832) / v99);
            uint64_t v104 = *(void *)(*(void *)v100 + 8);
            if (v104)
            {
              float v105 = (float)(1.0 - v103) * 0.5;
              uint64_t v106 = (float *)(*(void *)v100 + v104 * v91 + 16);
              do
              {
                *uint64_t v106 = v105 * *v106;
                ++v106;
                --v104;
              }
              while (v104);
            }
          }
          ++v92;
          v91 += 4;
        }
        while (v90 > v92);
      }
      std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100](&v128);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v129);
      std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v126, 0);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v127);
      std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100](&v124);
      std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v125);
      std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v119);
      a1 = (std::__shared_weak_count *)std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](&v120);
      long long v9 = v114;
    }
    if (v15) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v15);
    }
LABEL_90:
    int v10 = (std::__shared_weak_count_vtbl *)((char *)v10 + 1);
  }
  while (v10 < v9[1].__vftable);
}

void sub_221F433A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42)
{
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&STACK[0x208], 0);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a10);
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&STACK[0x230]);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a13);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(v43 - 256));
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](a14);
  Phase::SpatialModeler::DirectionalMetadataOutput<float>::~DirectionalMetadataOutput(&a42);
  if (v42) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v42);
  }
  _Unwind_Resume(a1);
}

uint64_t *Phase::SpatialModeler::DirectionalMetadataOutput<float>::~DirectionalMetadataOutput(uint64_t *a1)
{
  return a1;
}

uint64_t Phase::SpatialModeler::EnergyHistogram::resizeEnergyHistogram(Phase::SpatialModeler::EnergyHistogram *this, float a2, int a3, float a4, float a5)
{
  *((float *)this + 4) = a4;
  *((float *)this + 5) = a2;
  *((float *)this + 10) = a5;
  unsigned int v6 = vcvtms_u32_f32(a2 / a4) + 1;
  if (*((_DWORD *)this + 7) != a3 || v6 != *((_DWORD *)this + 6))
  {
    *((_DWORD *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v6;
    *((_DWORD *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = a3;
    free(*((void **)this + 1));
    *((void *)this + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = malloc_type_malloc(4 * (*((_DWORD *)this + 7) * *((_DWORD *)this + 6)), 0x100004052888210uLL);
  }
  return 0;
}

void **Phase::SpatialModeler::EnergyHistogram::operator=(void **this, uint64_t a2)
{
  if ((void **)a2 != this)
  {
    Phase::SpatialModeler::EnergyHistogram::resizeEnergyHistogram((Phase::SpatialModeler::EnergyHistogram *)this, *(float *)(a2 + 20), *(_DWORD *)(a2 + 28), *(float *)(a2 + 16), *(float *)(a2 + 40));
    memcpy(this[1], *(const void **)(a2 + 8), 4 * (*((_DWORD *)this + 7) * *((_DWORD *)this + 6)));
    *((unsigned char *)this + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(unsigned char *)(a2 + 36);
    *((_DWORD *)this + 1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(_DWORD *)(a2 + 44);
    *((_DWORD *)this + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a2 + 48);
    *((_DWORD *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = *(_DWORD *)(a2 + 52);
    *((_DWORD *)this + 14) = *(_DWORD *)(a2 + 56);
    *((_DWORD *)this + 15) = *(_DWORD *)(a2 + 60);
    *((_DWORD *)this + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 64);
    *((_DWORD *)this + 1std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *(_DWORD *)(a2 + 68);
    *((_DWORD *)this + 18) = *(_DWORD *)(a2 + 72);
    *((_DWORD *)this + 19) = *(_DWORD *)(a2 + 76);
    *((_DWORD *)this + 10) = *(_DWORD *)(a2 + 40);
    *((_DWORD *)this + 8) = *(_DWORD *)(a2 + 32);
  }
  return this;
}

void Phase::SpatialModeler::EnergyHistogram::~EnergyHistogram(void **this)
{
  *this = &unk_26D476708;
  free(this[1]);
}

{
  uint64_t vars8;

  *this = &unk_26D476708;
  free(this[1]);

  JUMPOUT(0x223C938A0);
}

float Phase::SpatialModeler::EnergyHistogram::addEnergy_TS(uint64_t a1, unsigned int a2, uint64_t a3)
{
  float result = 0.0;
  if (*(_DWORD *)(a1 + 24) > a2)
  {
    LODWORD(v4) = *(_DWORD *)(a3 + 124);
    if (v4)
    {
      float v5 = 0.0;
      unsigned int v6 = (float *)a3;
      uint64_t v7 = *(unsigned int *)(a3 + 124);
      do
      {
        float v8 = *v6++;
        float v5 = v5 + v8;
        --v7;
      }
      while (v7);
      float result = 0.0;
      if (v5 > 1.1755e-38)
      {
        unsigned int v9 = *(_DWORD *)(a1 + 28);
        if (v9 >= v4) {
          uint64_t v4 = v4;
        }
        else {
          uint64_t v4 = v9;
        }
        if ((int)v4 >= 1)
        {
          int v10 = (float *)(*(void *)(a1 + 8) + 4 * v9 * a2);
          do
          {
            float v11 = *(float *)a3;
            a3 += 4;
            float *v10 = v11 + *v10;
            ++v10;
            --v4;
          }
          while (v4);
        }
        *(unsigned char *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
        int v12 = *(_DWORD *)(a1 + 44);
        if ((v12 + 1) < 0xC350) {
          int v13 = v12 + 1;
        }
        else {
          int v13 = 50000;
        }
        *(_DWORD *)(a1 + 44) = v13;
        return v5;
      }
    }
  }
  return result;
}

float Phase::SpatialModeler::EnergyHistogram::getTemporalEnergyEnvelope_Band@<S0>(Phase::SpatialModeler::EnergyHistogram *this@<X0>, unsigned int a2@<W1>, void *a3@<X8>)
{
  unint64_t v5 = *((unsigned int *)this + 6);
  int v13 = 0;
  unsigned int v6 = std::vector<float>::vector(a3, v5, &v13);
  if (!*((unsigned char *)this + 36))
  {
    uint64_t v8 = *((unsigned int *)this + 7);
    if (v8 > a2)
    {
      uint64_t v9 = *((unsigned int *)this + 6);
      if (v9)
      {
        int v10 = (float *)(*((void *)this + 1) + 4 * a2);
        float v11 = (_DWORD *)*v6;
        uint64_t v12 = 4 * v8;
        do
        {
          float result = *v10;
          *v11++ = *(_DWORD *)v10;
          int v10 = (float *)((char *)v10 + v12);
          --v9;
        }
        while (v9);
      }
    }
  }
  return result;
}

uint64_t Phase::SpatialModeler::EnergyHistogram::setEnergy(uint64_t this, float a2, unsigned int a3, unsigned int a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  unsigned int v4 = *(_DWORD *)(this + 28);
  if (v4 <= a3 || *(_DWORD *)(this + 24) <= a4)
  {
    unsigned int v6 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)this) + 1184);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315906;
      int v10 = "EnergyHistogram.cpp";
      __int16 v11 = 1024;
      int v12 = 246;
      __int16 v13 = 1024;
      unsigned int v14 = a3;
      __int16 v15 = 1024;
      unsigned int v16 = a4;
      _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Invalid band (%i) of timestep (%i) selected.\\n\"", buf, 0x1Eu);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Invalid band (%i) of timestep (%i) selected.\n");
  }
  if (a2 > 1.1755e-38)
  {
    *(float *)(*(void *)(this + 8) + 4 * (a3 + v4 * astd::__tree<Phase::SpatialCategory>::destroy((uint64_t)this + 24, *((void **)this + 4)) = a2;
    *(unsigned char *)(this + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  }
  return this;
}

void sub_221F438FC(_Unwind_Exception *exception_object)
{
}

float Phase::SpatialModeler::EnergyHistogram::getTotalEnergyDivBands(Phase::SpatialModeler::EnergyHistogram *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, uint64x2_t a9)
{
  if (*((unsigned char *)this + 36))
  {
    unsigned int v10 = *((_DWORD *)this + 7);
LABEL_3:
    float v11 = 0.0;
    return v11 / (float)v10;
  }
  unsigned int v10 = *((_DWORD *)this + 7);
  uint64_t v12 = v10 * *((_DWORD *)this + 6);
  if (!v12) {
    goto LABEL_3;
  }
  uint64_t v13 = (v12 + 3) & 0x1FFFFFFFCLL;
  uint64x2_t v14 = (uint64x2_t)vdupq_n_s64(v12 - 1);
  int64x2_t v15 = (int64x2_t)xmmword_2220A5510;
  int64x2_t v16 = (int64x2_t)xmmword_2220A5520;
  float32x4_t v17 = (float32x4_t)xmmword_2220A5530;
  uint64_t v18 = (__int32 *)(*((void *)this + 1) + 8);
  int64x2_t v19 = vdupq_n_s64(4uLL);
  do
  {
    float32x4_t v20 = v17;
    int32x4_t v21 = (int32x4_t)vcgeq_u64(v14, (uint64x2_t)v16);
    *(int32x2_t *)a9.i8 = vmovn_s64((int64x2_t)v21);
    *(int16x4_t *)v17.f32 = vmovn_s32((int32x4_t)a9);
    if (v17.i8[0]) {
      v17.i32[0] = *(v18 - 2);
    }
    if (vmovn_s32(*(int32x4_t *)&a9).i8[2]) {
      v17.i32[1] = *(v18 - 1);
    }
    a9 = vcgeq_u64(v14, (uint64x2_t)v15);
    int32x2_t v22 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v9, (int64x2_t)a9));
    if (v22.i8[4]) {
      v17.i32[2] = *v18;
    }
    int32x2_t v9 = (int32x2_t)vmovn_s32(vmovn_hight_s64(v22, (int64x2_t)a9));
    if (v9.i8[6]) {
      v17.i32[3] = v18[1];
    }
    float32x4_t v17 = vaddq_f32(v20, v17);
    int64x2_t v15 = vaddq_s64(v15, v19);
    int64x2_t v16 = vaddq_s64(v16, v19);
    v18 += 4;
    v13 -= 4;
  }
  while (v13);
  int8x16_t v23 = vbslq_s8((int8x16_t)vuzp1q_s32(v21, (int32x4_t)a9), (int8x16_t)v17, (int8x16_t)v20);
  float v11 = (float)(vaddv_f32(*(float32x2_t *)v23.i8) + *(float *)&v23.i32[2]) + *(float *)&v23.i32[3];
  return v11 / (float)v10;
}

uint64_t Phase::SpatialModeler::EnergyHistogram::operator+=(uint64_t result, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (vabds_f32(*(float *)(result + 16), *(float *)(a2 + 16)) > 0.000001
    || (int v2 = *(_DWORD *)(result + 28), v2 != *(_DWORD *)(a2 + 28)))
  {
    float v11 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)result) + 1184);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v13 = 136315394;
      uint64x2_t v14 = "EnergyHistogram.cpp";
      __int16 v15 = 1024;
      int v16 = 317;
      _os_log_impl(&dword_221E5E000, v11, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Histograms have unequal resolution, they cannot be added.\\n\"", (uint8_t *)&v13, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Histograms have unequal resolution, they cannot be added.\n");
  }
  unsigned int v3 = *(_DWORD *)(a2 + 24);
  if (v3 >= *(_DWORD *)(result + 24)) {
    unsigned int v3 = *(_DWORD *)(result + 24);
  }
  uint64_t v4 = v3 * v2;
  if (v4)
  {
    unint64_t v5 = *(float **)(a2 + 8);
    unsigned int v6 = *(float **)(result + 8);
    do
    {
      float v7 = *v5++;
      *unsigned int v6 = v7 + *v6;
      ++v6;
      --v4;
    }
    while (v4);
  }
  if (*(unsigned char *)(result + 36)) {
    BOOL v8 = *(unsigned char *)(a2 + 36) == 0;
  }
  else {
    BOOL v8 = 1;
  }
  char v9 = !v8;
  *(unsigned char *)(result + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v9;
  unsigned int v10 = *(_DWORD *)(a2 + 44) + *(_DWORD *)(result + 44);
  if (v10 >= 0xC350) {
    unsigned int v10 = 50000;
  }
  *(_DWORD *)(result + 44) = v10;
  return result;
}

void sub_221F43BA0(_Unwind_Exception *exception_object)
{
}

uint64_t Phase::SpatialModeler::EnergyHistogram::operator*=(uint64_t a1, float a2)
{
  if (a2 == 0.0)
  {
    int v13 = *(void **)(a1 + 8);
    if (v13) {
      bzero(v13, 4 * (*(_DWORD *)(a1 + 28) * *(_DWORD *)(a1 + 24)));
    }
    *(unsigned char *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
    *(_DWORD *)(a1 + 44) = 0;
  }
  else
  {
    uint64_t v3 = (*(_DWORD *)(a1 + 28) * *(_DWORD *)(a1 + 24));
    if (v3)
    {
      uint64_t v4 = (v3 + 3) & 0x1FFFFFFFCLL;
      uint64x2_t v5 = (uint64x2_t)vdupq_n_s64(v3 - 1);
      int64x2_t v6 = (int64x2_t)xmmword_2220A5510;
      int64x2_t v7 = (int64x2_t)xmmword_2220A5520;
      BOOL v8 = (float *)(*(void *)(a1 + 8) + 8);
      int64x2_t v9 = vdupq_n_s64(4uLL);
      do
      {
        int32x4_t v10 = (int32x4_t)vcgeq_u64(v5, (uint64x2_t)v7);
        *(int32x2_t *)v10.i8 = vmovn_s64((int64x2_t)v10);
        int32x2_t v11 = (int32x2_t)vmovn_s32(v10);
        if (v11.i8[0])
        {
          *(float *)v11.i32 = *(v8 - 2) * a2;
          *(v8 - 2) = *(float *)v11.i32;
        }
        if (vmovn_s32(v10).i8[2]) {
          *(v8 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v8 - 1) * a2;
        }
        int64x2_t v12 = (int64x2_t)vcgeq_u64(v5, (uint64x2_t)v6);
        if (vmovn_s32(vmovn_hight_s64(v11, v12)).i32[1]) {
          float *v8 = *v8 * a2;
        }
        if (vmovn_s32(vmovn_hight_s64(*(int32x2_t *)&v12, v12)).i8[6]) {
          v8[1] = v8[1] * a2;
        }
        int64x2_t v6 = vaddq_s64(v6, v9);
        int64x2_t v7 = vaddq_s64(v7, v9);
        v8 += 4;
        v4 -= 4;
      }
      while (v4);
    }
  }
  return a1;
}

uint64_t Phase::SpatialModeler::EnergyHistogram::MultiplyAdd(uint64_t this, const Phase::SpatialModeler::EnergyHistogram *a2, float a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (vabds_f32(*(float *)(this + 16), *((float *)a2 + 4)) > 0.000001
    || (int v3 = *(_DWORD *)(this + 28), v3 != *((_DWORD *)a2 + 7)))
  {
    int64x2_t v12 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)this) + 1184);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v14 = 136315394;
      __int16 v15 = "EnergyHistogram.cpp";
      __int16 v16 = 1024;
      int v17 = 385;
      _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"Histograms have unequal resolution, they cannot be multiply added.\\n\"", (uint8_t *)&v14, 0x12u);
    }
    exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
    std::invalid_argument::invalid_argument[abi:ne180100](exception, "Histograms have unequal resolution, they cannot be multiply added.\n");
  }
  unsigned int v4 = *((_DWORD *)a2 + 6);
  if (v4 >= *(_DWORD *)(this + 24)) {
    unsigned int v4 = *(_DWORD *)(this + 24);
  }
  uint64_t v5 = v4 * v3;
  if (v5)
  {
    int64x2_t v6 = (float *)*((void *)a2 + 1);
    int64x2_t v7 = *(float **)(this + 8);
    do
    {
      float v8 = *v6++;
      float *v7 = *v7 + (float)(v8 * a3);
      ++v7;
      --v5;
    }
    while (v5);
  }
  if (*(unsigned char *)(this + 36)) {
    BOOL v9 = *((unsigned char *)a2 + 36) == 0;
  }
  else {
    BOOL v9 = 1;
  }
  char v10 = !v9;
  *(unsigned char *)(this + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v10;
  unsigned int v11 = *((_DWORD *)a2 + 11) + *(_DWORD *)(this + 44);
  if (v11 >= 0xC350) {
    unsigned int v11 = 50000;
  }
  *(_DWORD *)(this + 44) = v11;
  return this;
}

void sub_221F43E64(_Unwind_Exception *exception_object)
{
}

uint64_t Phase::EQSphere::eq_point_set_polar(unsigned int a1, unsigned int a2, uint64_t *a3)
{
  if (a2 != 1)
  {
    if (!a2)
    {
      std::vector<std::vector<float>>::resize(a3, 0);
      return 0;
    }
    uint64_t v112 = 0;
    float v113 = 0;
    uint64_t v114 = 0;
    memset(&v111, 0, sizeof(v111));
    if (a1 == 1)
    {
      std::vector<float>::resize((uint64_t)&v112, a2);
      std::vector<unsigned int>::resize(&v111, a2);
      uint64_t v22 = 0;
      int8x16_t v23 = (float *)v112;
      begiuint64_t n = v111.__begin_;
      do
      {
        v23[v22] = (float)((float)((float)(v22 + 1) + (float)(v22 + 1)) * 3.1416)
                 / (float)(int)a2;
        begin[v22++] = 1;
      }
      while (a2 != v22);
    }
    else
    {
      if (a2 == 2)
      {
        unsigned int v25 = 0;
        float v26 = 6.2832;
        float v27 = 1.5708;
      }
      else
      {
        float v26 = 12.566 / (float)a2;
        float v28 = asinf(sqrtf(v26 / 3.1416) * 0.5);
        float v27 = v28 + v28;
        float v29 = sqrtf(v26);
        if (v29 <= 0.0)
        {
          unsigned int v25 = 0;
        }
        else if ((int)((3.14159265 - (float)(v27 + v27)) / v29 + 0.5) <= 1)
        {
          unsigned int v25 = 1;
        }
        else
        {
          unsigned int v25 = (int)((3.14159265 - (float)(v27 + v27)) / v29 + 0.5);
        }
      }
      std::string __p = 0;
      uint64_t v116 = 0;
      uint64_t v117 = 0;
      std::vector<float>::resize((uint64_t)&__p, v25 + 2);
      int v30 = (float *)__p;
      *(_DWORD *)std::string __p = 1065353216;
      if (v25)
      {
        uint64_t v31 = 0;
        float v32 = (float)((float)(v27 * -2.0) + 3.1416) / (float)v25;
        do
        {
          float v33 = sinf((float)(v27 + (float)((float)v31 * v32)) * 0.5);
          float v34 = (float)(v33 * v33) * 12.566;
          float v35 = sinf((float)(v27 + (float)((float)(v31 + 1) * v32)) * 0.5);
          v30[++v31] = (float)((float)((float)(v35 * v35) * 12.566) - v34) / v26;
        }
        while (v25 != v31);
      }
      v30[v25 + 1] = 1.0;
      std::vector<unsigned int>::resize(&v111, (v116 - (unsigned char *)v30) >> 2);
      int v36 = (float *)__p;
      std::vector<unsigned int>::pointer v37 = v111.__begin_;
      if (v116 != __p)
      {
        uint64_t v38 = 0;
        unint64_t v39 = (v116 - (unsigned char *)__p) >> 2;
        float v40 = 0.0;
        do
        {
          float v41 = v40 + v36[v38];
          unsigned int v42 = (int)(float)(v41 + 0.5);
          v37[v38] = v42;
          float v40 = v41 - (float)v42;
          ++v38;
        }
        while (v39 > v38);
      }
      std::vector<float>::resize((uint64_t)&v112, v111.__end_ - v37);
      uint64_t v43 = (char *)v112;
      *(float *)uint64_t v112 = v27;
      int64_t v44 = v111.__end_ - v111.__begin_;
      uint64_t v45 = (v44 - 2);
      if (v44 != 2)
      {
        uint64_t v46 = (float *)(v43 + 4);
        std::vector<unsigned int>::pointer v47 = v111.__begin_ + 1;
        unsigned int v48 = 1;
        do
        {
          int v49 = *v47++;
          v48 += v49;
          float v50 = asinf(sqrtf((float)(v26 * (float)v48) / 3.1416) * 0.5);
          *v46++ = v50 + v50;
          --v45;
        }
        while (v45);
      }
      *(_DWORD *)&v43[4 * (v44 - 1)] = 1078530011;
      if (__p)
      {
        uint64_t v116 = __p;
        operator delete(__p);
      }
    }
    unsigned int v107 = a1 - 1;
    if (a1 == 1)
    {
      std::vector<std::vector<float>>::resize(a3, 1uLL);
      uint64_t v51 = (float *)v112;
      if (((v113 - (unsigned char *)v112) & 0x3FFFFFFFCLL) != 0)
      {
        unint64_t v52 = 0;
        do
        {
          float v53 = v51[v52] - 3.14159265 / (float)a2;
          uint64_t v54 = *a3;
          uint64_t v55 = *(float **)(*a3 + 8);
          unint64_t v56 = *(void *)(*a3 + 16);
          if ((unint64_t)v55 >= v56)
          {
            uint64_t v58 = *(float **)v54;
            uint64_t v59 = ((uint64_t)v55 - *(void *)v54) >> 2;
            unint64_t v60 = v59 + 1;
            if ((unint64_t)(v59 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v61 = v56 - (void)v58;
            if (v61 >> 1 > v60) {
              unint64_t v60 = v61 >> 1;
            }
            if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v62 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v62 = v60;
            }
            if (v62)
            {
              uint64_t v63 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(*a3 + 16, v62);
              uint64_t v58 = *(float **)v54;
              uint64_t v55 = *(float **)(v54 + 8);
            }
            else
            {
              uint64_t v63 = 0;
            }
            uint64_t v64 = (float *)&v63[4 * v59];
            *uint64_t v64 = v53;
            uint64_t v57 = v64 + 1;
            while (v55 != v58)
            {
              int v65 = *((_DWORD *)v55-- - 1);
              *((_DWORD *)v64-- - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v65;
            }
            *(void *)uint64_t v54 = v64;
            *(void *)(v54 + 8) = v57;
            *(void *)(v54 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = &v63[4 * v62];
            if (v58) {
              operator delete(v58);
            }
          }
          else
          {
            *uint64_t v55 = v53;
            uint64_t v57 = v55 + 1;
          }
          *(void *)(v54 + 8) = v57;
          ++v52;
          uint64_t v51 = (float *)v112;
        }
        while (v52 < ((unint64_t)(v113 - (unsigned char *)v112) >> 2));
      }
LABEL_112:
      if (v111.__begin_)
      {
        v111.__end_ = v111.__begin_;
        operator delete(v111.__begin_);
      }
      if (v112)
      {
        float v113 = v112;
        operator delete(v112);
      }
      return 0;
    }
    std::vector<unsigned int>::pointer v67 = v111.__begin_;
    std::vector<unsigned int>::pointer end = v111.__end_;
    std::vector<std::vector<float>>::resize(a3, 2uLL);
    std::vector<float>::resize(*a3, a2);
    std::vector<float>::resize(*a3 + 24, a2);
    uint64_t v106 = ((unint64_t)((char *)end - (char *)v67) >> 2) - 2;
    if (((unint64_t)((char *)end - (char *)v67) >> 2) == 2)
    {
      uint64_t v103 = 1;
LABEL_111:
      uint64_t v104 = *a3;
      *(_DWORD *)(*(void *)*a3 + 4 * v103) = 0;
      *(_DWORD *)(*(void *)(v104 + 24) + 4 * v103) = 1078530011;
      goto LABEL_112;
    }
    uint64_t v68 = 0;
    int v69 = 2;
    float v70 = 0.0;
    while (1)
    {
      float v71 = *((float *)v112 + v68);
      uint64_t v72 = v68 + 1;
      float v73 = *((float *)v112 + v68 + 1);
      uint64_t v74 = v111.__begin_[v68 + 1];
      std::string __p = 0;
      uint64_t v116 = 0;
      uint64_t v117 = 0;
      Phase::EQSphere::eq_point_set_polar(v107, v74, &__p);
      float v109 = 0;
      uint64_t v110 = 0;
      p_p = 0;
      uint64_t v75 = *((void *)__p + 1);
      uint64_t v76 = v75 - *(void *)__p;
      if (v75 == *(void *)__p) {
        break;
      }
      uint64_t v77 = 0;
      unsigned int v78 = 0;
      do
      {
        ++v78;
        if (v77 >= v110)
        {
          unint64_t v79 = p_p;
          uint64_t v80 = ((char *)v77 - (char *)p_p) >> 2;
          unint64_t v81 = v80 + 1;
          if ((unint64_t)(v80 + 1) >> 62) {
            std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v82 = (char *)v110 - (char *)p_p;
          if (((char *)v110 - (char *)p_p) >> 1 > v81) {
            unint64_t v81 = v82 >> 1;
          }
          if ((unint64_t)v82 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v83 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v83 = v81;
          }
          if (v83)
          {
            int v84 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v110, v83);
            unint64_t v79 = p_p;
            uint64_t v77 = v109;
          }
          else
          {
            int v84 = 0;
          }
          uint64_t v85 = (void **)&v84[4 * v80];
          *(_DWORD *)uint64_t v85 = v78;
          uint64_t v86 = (void **)((char *)v85 + 4);
          while (v77 != v79)
          {
            int v87 = *((_DWORD *)v77 - 1);
            uint64_t v77 = (void **)((char *)v77 - 4);
            *((_DWORD *)v85 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v87;
            uint64_t v85 = (void **)((char *)v85 - 4);
          }
          p_p = v85;
          float v109 = v86;
          uint64_t v110 = (void **)&v84[4 * v83];
          if (v79) {
            operator delete(v79);
          }
          uint64_t v77 = v86;
        }
        else
        {
          *(_DWORD *)uint64_t v77 = v78;
          uint64_t v77 = (void **)((char *)v77 + 4);
        }
        float v109 = v77;
        uint64_t v88 = *(void *)__p;
        unint64_t v89 = (uint64_t)(*((void *)__p + 1) - *(void *)__p) >> 2;
      }
      while (v89 > v78);
      unint64_t v90 = p_p;
      unint64_t v91 = ((char *)v77 - (char *)p_p) >> 2;
      if (v77 == p_p) {
        goto LABEL_96;
      }
      uint64_t v92 = 0;
      uint64_t v93 = *(void *)*a3;
      do
      {
        float v94 = *(float *)(v88 + 4 * v92) + (float)(v70 * 6.2832);
        if (v94 >= 6.28318531) {
          float v94 = v94 + -6.2832;
        }
        *(float *)(v93 + 4 * (v69 - 2 + *((_DWORD *)v90 + v92++))) = v94;
      }
      while (v91 > v92);
      char v95 = 0;
      uint64_t v77 = v90;
LABEL_97:
      int v96 = v111.__begin_[(v68 + 2)];
      if ((int)v74 >= v96)
      {
        signed int v97 = v74;
        int v98 = v111.__begin_[(v68 + 2)];
        int v99 = v74;
        if ((int)v74 <= v96) {
          goto LABEL_101;
        }
      }
      else
      {
        signed int v97 = v111.__begin_[(v68 + 2)];
        int v98 = v74;
      }
      do
      {
        int v99 = v98;
        int v98 = v97 % v98;
        signed int v97 = v99;
      }
      while (v98);
LABEL_101:
      if (v95)
      {
        v69 += v89;
        if (!v77) {
          goto LABEL_108;
        }
      }
      else
      {
        uint64_t v100 = 0;
        uint64_t v101 = *(void *)(*a3 + 24);
        do
          *(float *)(v101 + 4 * (v69 - 2 + *((_DWORD *)v77 + v100++))) = (float)(v71 + v73) * 0.5;
        while (v91 > v100);
        v69 += v89;
      }
      float v109 = v77;
      operator delete(v77);
LABEL_108:
      float v102 = v70
           + (float)((float)((float)((float)(1.0 / (float)v96) - (float)(1.0 / (float)v74))
                           * 0.5)
                   + (float)((float)v99
                           / (float)((float)((float)v74 + (float)v74)
                                   * (float)v96)));
      float v70 = v102 - (float)(int)v102;
      p_p = &__p;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&p_p);
      uint64_t v68 = v72;
      if (v72 == v106)
      {
        uint64_t v103 = (v69 - 1);
        goto LABEL_111;
      }
    }
    unint64_t v91 = 0;
    uint64_t v77 = 0;
    unint64_t v89 = v76 >> 2;
LABEL_96:
    char v95 = 1;
    goto LABEL_97;
  }
  uint64_t v6 = a1;
  std::vector<std::vector<float>>::resize(a3, a1);
  if (a1)
  {
    uint64_t v7 = 0;
    do
    {
      uint64_t v8 = *a3 + 24 * v7;
      char v10 = (_DWORD **)(v8 + 8);
      BOOL v9 = *(_DWORD **)(v8 + 8);
      int64x2_t v12 = (void *)(v8 + 16);
      unint64_t v11 = *(void *)(v8 + 16);
      if ((unint64_t)v9 >= v11)
      {
        int v14 = *(_DWORD **)v8;
        uint64_t v15 = ((uint64_t)v9 - *(void *)v8) >> 2;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 62) {
          std::vector<float>::__throw_length_error[abi:ne180100]();
        }
        uint64_t v17 = v11 - (void)v14;
        if (v17 >> 1 > v16) {
          unint64_t v16 = v17 >> 1;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18)
        {
          int64x2_t v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v12, v18);
          BOOL v9 = *v10;
          int v14 = *(_DWORD **)v8;
        }
        else
        {
          int64x2_t v19 = 0;
        }
        float32x4_t v20 = &v19[4 * v15];
        *(_DWORD *)float32x4_t v20 = 0;
        int v13 = v20 + 4;
        while (v9 != v14)
        {
          int v21 = *--v9;
          *((_DWORD *)v20 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v21;
          v20 -= 4;
        }
        *(void *)uint64_t v8 = v20;
        const char *v10 = v13;
        *int64x2_t v12 = &v19[4 * v18];
        if (v14) {
          operator delete(v14);
        }
      }
      else
      {
        *BOOL v9 = 0;
        int v13 = v9 + 1;
      }
      const char *v10 = v13;
      ++v7;
    }
    while (v7 != v6);
  }
  return 0;
}

void sub_221F4470C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  if (__p) {
    operator delete(__p);
  }
  if (a18) {
    operator delete(a18);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 4 * a2;
    }
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 2);
    if (v10 >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 2;
    uint64_t v12 = v5 - v8;
    if (v12 >> 1 > v10) {
      unint64_t v10 = v12 >> 1;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v13 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      int v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
      uint64_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      int v14 = 0;
    }
    uint64_t v15 = &v14[4 * v11];
    unint64_t v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    uint64_t v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      int v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

void sub_221F449A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_221F44B74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_221F44D4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_221F44EE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_221F45278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void sub_221F45760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  if (v19) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

BOOL Phase::IsFeatureEnabled_SessionBasedMuting(Phase *this)
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_267F77B00, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_267F77B00))
  {
    _MergedGlobals_15 = _os_feature_enabled_impl();
    __cxa_guard_release(&qword_267F77B00);
  }
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_267F77B08, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_267F77B08))
  {
    byte_267F77AF9 = _os_feature_enabled_impl();
    __cxa_guard_release(&qword_267F77B08);
  }
  if (_MergedGlobals_15) {
    BOOL v1 = byte_267F77AF9 == 0;
  }
  else {
    BOOL v1 = 1;
  }
  return !v1;
}

void sub_221F458EC(_Unwind_Exception *a1)
{
}

void sub_221F45D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, void *a15, void *a16, void *a17)
{
  if (a14) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F462CC(_Unwind_Exception *a1)
{
  if (v3) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F46684(_Unwind_Exception *a1)
{
  if (v3) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F467DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_221F46C78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

void sub_221F46FFC(_Unwind_Exception *exception_object, int a2)
{
  if (a2)
  {
    __cxa_free_exception(v3);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v2 + 48);
    __cxa_end_catch();
    JUMPOUT(0x221F46F34);
  }
  _Unwind_Resume(exception_object);
}

void sub_221F474A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11)
{
  if (a11) {
    os_unfair_recursive_lock_unlock();
  }
  _Unwind_Resume(a1);
}

void sub_221F47890(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_221F47BD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  if (a2)
  {
    __cxa_free_exception(v16);
    __cxa_begin_catch(exception_object);
    Phase::Commandable<128,Phase::LockFreeQueueMPSC>::LogOverflow(v17 + 48);
    __cxa_end_catch();
    JUMPOUT(0x221F47ABCLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_221F47F38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, int a11)
{
  if (a11) {
    os_unfair_recursive_lock_unlock();
  }
  _Unwind_Resume(exception_object);
}

void sub_221F48254(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_221F48784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15)
{
  if (a15) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F48C48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, int a12, void *a13)
{
  if (a12) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F491BC(_Unwind_Exception *a1)
{
  if (v3) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F497E0(_Unwind_Exception *a1)
{
  if (v4) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F49CD4(_Unwind_Exception *a1)
{
  if (v3) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F4A0B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  if (a13) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F4A4C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  if (a13) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F4A8D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  if (a13) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F4ACE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  if (a13) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F4BBDC(_Unwind_Exception *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9, uint64_t a10, int a11, int a12, void *a13, void *a14, ...)
{
  va_start(va, a14);

  std::unique_ptr<Phase::Controller::StreamRenderer>::reset[abi:ne180100]((Phase::Controller::StreamRenderer **)va, 0);
  if (a12) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F4C2D8(_Unwind_Exception *a1)
{
  operator delete(v2);
  _Unwind_Resume(a1);
}

void sub_221F4C6B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11, void *a12)
{
  if (a11) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

void sub_221F4CBF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11, void *a12, uint64_t a13, uint64_t a14, void *a15)
{
  if (a11) {
    os_unfair_recursive_lock_unlock();
  }

  _Unwind_Resume(a1);
}

Phase::Logger *Phase::Envelope<float>::Envelope(Phase::Logger *a1, float *a2, float *a3)
{
  *(void *)a1 = 0;
  *((void *)a1 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)a1 + 2) = 0;
  Phase::Envelope<float>::InitializeFromSingleSegment(a1, a2, a3);
  return a1;
}

void sub_221F4CEA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::vector<Phase::Envelope<float>::SegmentInternal,std::allocator<Phase::Envelope<float>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void Phase::ExternalStreamSessionCommandExecutor::~ExternalStreamSessionCommandExecutor(Phase::ExternalStreamSessionCommandExecutor *this)
{
  Phase::Commandable<128,Phase::LockFreeQueueMPSC>::~Commandable(this);

  JUMPOUT(0x223C938A0);
}

void sub_221F4D07C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

Phase::FIRFilterUtils *Phase::FIRFilterUtils::FIRFilterUtils(Phase::FIRFilterUtils *this, Phase::DFTUtils *a2, int a3)
{
  *(void *)this = 0;
  *((void *)this + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v6 = operator new(0xCuLL);
  *(void *)uint64_t v6 = 0x447A000043FA0000;
  unint64_t v6[2] = 1167867904;
  *(void *)this = v6;
  *((void *)this + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v6 + 3;
  *((void *)this + 2) = v6 + 3;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  uint64_t v7 = operator new(0x28uLL);
  _OWORD *v7 = xmmword_2220A5AE0;
  v7[1] = unk_2220A5AF0;
  *((void *)v7 + 4) = 0x467A000045FA0000;
  *((void *)this + 3) = v7;
  *((void *)this + 4) = (char *)v7 + 40;
  *((void *)this + 5) = (char *)v7 + 40;
  *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *((void *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  uint64_t v8 = operator new(0x7CuLL);
  uint64_t v9 = 0;
  void v8[4] = xmmword_2220A5B48;
  void v8[5] = unk_2220A5B58;
  v8[6] = xmmword_2220A5B68;
  *(_OWORD *)((char *)v8 + 108) = *(long long *)((char *)&xmmword_2220A5B68 + 12);
  _OWORD *v8 = xmmword_2220A5B08;
  v8[1] = unk_2220A5B18;
  _OWORD v8[2] = xmmword_2220A5B28;
  void v8[3] = unk_2220A5B38;
  *((void *)this + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v8;
  *((void *)this + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = (char *)v8 + 124;
  *((void *)this + 8) = (char *)v8 + 124;
  *((void *)this + 9) = a2;
  int v10 = *(_DWORD *)a2;
  if (*(int *)a2 >= 0) {
    int v11 = *(_DWORD *)a2;
  }
  else {
    int v11 = v10 + 1;
  }
  *((_DWORD *)this + 20) = (v11 >> 1) + 1;
  *((_DWORD *)this + 2Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a3;
  *((_DWORD *)this + 22) = v10;
  do
  {
    uint64_t v12 = (char *)this + v9;
    *((void *)v12 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
    *((_DWORD *)v12 + 2std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    *((void *)v12 + 15) = 0;
    *((void *)v12 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
    *((void *)v12 + 14) = 0;
    *(_OWORD *)(v12 + 152) = 0uLL;
    *(_OWORD *)(v12 + 168) = 0uLL;
    *(_OWORD *)(v12 + 184) = 0uLL;
    *(_OWORD *)(v12 + 200) = 0uLL;
    v9 += 128;
    *((void *)v12 + 2std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
  }
  while (v9 != 384);
  return this;
}

void sub_221F4D1D8(_Unwind_Exception *a1)
{
  *(void *)(v1 + 32) = v2;
  operator delete(v2);
  int v4 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void Phase::FIRFilterUtils::ConstructFIREqFilter(uint64_t a1, int a2, uint64_t a3, int a4, float *__C, float *a6, DSPComplex *a7)
{
  uint64_t v36 = *MEMORY[0x263EF8340];
  vDSP_vclr(__C, 1, *(int *)(a1 + 80));
  vDSP_vclr(a6, 1, *(int *)(a1 + 80));
  uint64_t v14 = (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2;
  switch(v14)
  {
    case 31:
      float v20 = (float)*(int *)(a1 + 84);
      int v21 = *(_DWORD *)(a1 + 88);
      if (*(_DWORD *)(a1 + 352) != v21 || *(_DWORD *)(a1 + 356) != 31 || vabds_f32(*(float *)(a1 + 360), v20) >= 0.1) {
        Phase::LookupInterpolator::Initialize((Phase::LookupInterpolator *)(a1 + 352), v20, v21, 0x1Fu, *(float **)(a1 + 48));
      }
      uint64_t v17 = 2;
      break;
    case 10:
      float v18 = (float)*(int *)(a1 + 84);
      int v19 = *(_DWORD *)(a1 + 88);
      if (*(_DWORD *)(a1 + 224) != v19 || *(_DWORD *)(a1 + 228) != 10 || vabds_f32(*(float *)(a1 + 232), v18) >= 0.1) {
        Phase::LookupInterpolator::Initialize((Phase::LookupInterpolator *)(a1 + 224), v18, v19, 0xAu, *(float **)(a1 + 24));
      }
      uint64_t v17 = 1;
      break;
    case 3:
      float v15 = (float)*(int *)(a1 + 84);
      int v16 = *(_DWORD *)(a1 + 88);
      if (*(_DWORD *)(a1 + 96) != v16 || *(_DWORD *)(a1 + 100) != 3 || vabds_f32(*(float *)(a1 + 104), v15) >= 0.1) {
        Phase::LookupInterpolator::Initialize((Phase::LookupInterpolator *)(a1 + 96), v15, v16, 3u, *(float **)a1);
      }
      uint64_t v17 = 0;
      break;
    default:
      float v27 = **(NSObject ***)(Phase::Logger::GetInstance(v13) + 608);
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        uint64_t v28 = (uint64_t)(*(void *)(a3 + 8) - *(void *)a3) >> 2;
        int v30 = 136315650;
        uint64_t v31 = "FIRFilterUtils.cpp";
        __int16 v32 = 1024;
        int v33 = 89;
        __int16 v34 = 2048;
        uint64_t v35 = v28;
        _os_log_impl(&dword_221E5E000, v27, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::runtime_error): \"Given third octave filter must have 3, 10 or 31 bands (it has %lu coefficients\"", (uint8_t *)&v30, 0x1Cu);
      }
      exceptiouint64_t n = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      std::runtime_error::runtime_error(exception, "Given third octave filter must have 3, 10 or 31 bands (it has %lu coefficients");
  }
  Phase::LookupInterpolator::InterpolateWithFractions((Phase::LookupInterpolator *)(a1 + (v17 << 7) + 96), *(float **)a3, __C);
  if (a2)
  {
    if (a2 != 1)
    {
      unsigned int v25 = **(NSObject ***)(Phase::Logger::GetInstance(v22) + 608);
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        int v30 = 136315650;
        uint64_t v31 = "FIRFilterUtils.cpp";
        __int16 v32 = 1024;
        int v33 = 53;
        __int16 v34 = 1024;
        LODWORD(v35) = a2;
        _os_log_impl(&dword_221E5E000, v25, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument): \"FIR filter phase type requested is not supported. (FIRPhaseType: %d)\"", (uint8_t *)&v30, 0x18u);
      }
      float v26 = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
      std::invalid_argument::invalid_argument[abi:ne180100](v26, "FIR filter phase type requested is not supported. (FIRPhaseType: %d)");
    }
    v24.realp = __C;
    v24.imagp = a6;
    Phase::FIRFilterUtils::ConstructMinimumPhaseInPlace((Phase::FIRFilterUtils *)a1, v24, a7, v23);
  }
}

void sub_221F4D5A4(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void Phase::FIRFilterUtils::ConstructMinimumPhaseInPlace(Phase::FIRFilterUtils *this, DSPSplitComplex a2, DSPComplex *a3, float *a4)
{
  int v4 = a3;
  imagp = a2.imagp;
  realp = a2.realp;
  uint64_t v28 = *MEMORY[0x263EF8340];
  DSPSplitComplex __Z = a2;
  int v8 = *((_DWORD *)this + 20);
  if (!a3)
  {
    MEMORY[0x270FA5388](this);
    int v4 = (DSPComplex *)((char *)&v22 - v9);
    bzero((char *)&v22 - v9, v10);
  }
  int v25 = v8;
  float __B = 1.1755e-38;
  vDSP_vabs(realp, 1, realp, 1, v8);
  vDSP_vsadd(realp, 1, &__B, realp, 1, v8);
  vvlogf(realp, realp, &v25);
  uint64_t v11 = *((void *)this + 9);
  float *imagp = realp[*(_DWORD *)v11 / 2];
  vDSP_DFT_Execute(*(const vDSP_DFT_SetupStruct **)(v11 + 16), realp, imagp, realp, imagp);
  float v24 = 1.0 / (float)**((int **)this + 9);
  vDSP_ztoc(&__Z, 1, v4, 2, *((int *)this + 20));
  vDSP_vsmul((const float *)v4, 1, &v24, (float *)v4, 1, *((int *)this + 22));
  int v12 = *((_DWORD *)this + 22);
  float v13 = (float)v12 / 10.0;
  uint64_t v14 = (int)v13;
  int v15 = v12 + ~v14;
  int v16 = v12 - v14;
  if (v15 >= 0) {
    int v16 = v15;
  }
  int v17 = v16 >> 1;
  float v23 = 2.0;
  vDSP_vsmul(&v4->imag, 1, &v23, &v4->imag, 1, (v16 >> 1) - 1);
  if (v14)
  {
    for (uint64_t i = 0; i != v14; ++i)
      *(&v4->real + (v17 + i)) = *(&v4->real + (v17 + i))
                                             * (float)(cosf((float)((float)(1.0 / (float)(int)v13) * (float)i)* 3.1416)+ 1.0);
  }
  vDSP_vclr((float *)v4 + v17 + (int)v14, 1, *((int *)this + 22) - (uint64_t)(v17 + (int)v14));
  Phase::DFTUtils::ProcessDFT(*((const vDSP_DFT_SetupStruct ***)this + 9), v4, &__Z, 0.5);
  int v19 = __Z.realp;
  float v20 = __Z.imagp;
  int v21 = **((_DWORD **)this + 9) / 2;
  __Z.realp[v21] = *__Z.imagp;
  v20[v21] = 0.0;
  *float v20 = 0.0;
  vvexpf(v19, v19, &v25);
  vvcosf((float *)v4, __Z.imagp, &v25);
  vvsinf(__Z.imagp, __Z.imagp, &v25);
  vDSP_vmul(__Z.realp, 1, __Z.imagp, 1, __Z.imagp, 1, v25);
  vDSP_vmul(__Z.realp, 1, (const float *)v4, 1, __Z.realp, 1, v25);
}

void Phase::FIRFilterUtils::GetFrequencyVectorOfDFTBins(int *a1, uint64_t *a2)
{
  std::vector<float>::resize((uint64_t)a2, a1[20]);
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = v5 - *a2;
  if (v5 != *a2)
  {
    uint64_t v7 = 0;
    unint64_t v8 = v6 >> 2;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    uint64x2_t v9 = (uint64x2_t)vdupq_n_s64(v8 - 1);
    int64x2_t v10 = (int64x2_t)xmmword_2220A5520;
    float v11 = (float)a1[21] / (float)a1[22];
    int64x2_t v12 = vdupq_n_s64(2uLL);
    unint64_t v13 = (v8 + 1) & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      int32x2_t v14 = vmovn_s64((int64x2_t)vcgeq_u64(v9, (uint64x2_t)v10));
      if (v14.i8[0]) {
        *(float *)(v4 + 4 * vstd::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v11 * (float)(int)v7;
      }
      if (v14.i8[4]) {
        *(float *)(v4 + 4 * v7 + 4) = v11 * (float)(v7 + 1);
      }
      v7 += 2;
      int64x2_t v10 = vaddq_s64(v10, v12);
    }
    while (v13 != v7);
  }
}

void Phase::DspLayer::GainControl::GetNewRegistryEntry(Phase::DspLayer::GainControl *this)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  uint64_t v1 = malloc_type_malloc(0x38uLL, 0x1050040B063AAFAuLL);
  void *v1 = "Gain";
  v1[1] = 0x500000000;
  *(void *)((char *)v1 + 20) = 0x100000000;
  *((_DWORD *)v1 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 3;
  *((_OWORD *)v1 + 2) = xmmword_2220A4F90;
  v1[6] = 0x3FF0000000000000;
  operator new();
}

void sub_221F4DAE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void Phase::DspLayer::GainControl::~GainControl(Phase::DspLayer::GainControl *this)
{
  Phase::DspLayer::VoicePool::~VoicePool(this);

  JUMPOUT(0x223C938A0);
}

void anonymous namespace'::GainControlSlice::~GainControlSlice(_anonymous_namespace_::GainControlSlice *this)
{
}

double anonymous namespace'::GainControlSlice::Reset(_OWORD *a1)
{
  __asm { FMOV            V0.4S, #1.0 }
  a1[1] = _Q0;
  a1[2] = 0u;
  a1[259] = 0u;
  (*(void (**)(_OWORD *))(*(void *)a1 + 48))(a1);
  double result = 0.0;
  a1[520] = 0u;
  a1[519] = 0u;
  return result;
}

uint64_t anonymous namespace'::GainControlSlice::Reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7 = (_DWORD *)(a1 + 4 * a3);
  v7[4] = 1065353216;
  v7[8] = 0;
  v7[1036] = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 56))(a1);
  *(void *)(a1 + 8 * a3 + 8304) = a4;
  return result;
}

double anonymous namespace'::GainControlSlice::GetParameter(_anonymous_namespace_::GainControlSlice *this, int a2, int a3)
{
  if (!a2) {
    return *((float *)this + a3 + 4);
  }
  return result;
}

float anonymous namespace'::GainControlSlice::SetParameter(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, double a4)
{
  if (!a2)
  {
    *(float *)&a4 = a4;
    *((_DWORD *)this + a3 + 4) = LODWORD(a4);
  }
  return *(float *)&a4;
}

__n128 anonymous namespace'::GainControlSlice::UpdateParameters(__n128 *a1)
{
  __n128 v3 = a1[1];
  __n128 v4 = a1[259];
  memcpy(&a1[260], &a1[2], 0x1010uLL);
  a1[517] = v4;
  __n128 result = v3;
  a1[518] = v3;
  return result;
}

uint64_t anonymous namespace'::GainControlSlice::UpdateParameters(uint64_t result, uint64_t a2, int a3)
{
  __n128 v3 = (_DWORD *)(result + 4 * a3);
  int v4 = v3[1036];
  int v5 = v3[4];
  uint64_t v6 = v3[8];
  v3[1040] = v6;
  if ((int)v6 >= 1)
  {
    uint64_t v7 = (_DWORD *)(result + 4 * a3);
    do
    {
      v7[1044] = v7[12];
      v7[1048] = v7[16];
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  uint64_t v8 = result + 4 * a3;
  *(_DWORD *)(v8 + 8272) = v4;
  *(_DWORD *)(v8 + 8288) = v5;
  return result;
}

uint64_t anonymous namespace'::GainControlSlice::Run(uint64_t result, uint64_t a2, uint64_t a3, unsigned int a4)
{
  int32x4_t v4 = (int32x4_t)vandq_s8(*(int8x16_t *)(result + 4160), (int8x16_t)vcgtq_s32(vdupq_n_s32(a4), (int32x4_t)xmmword_2220A5190));
  int64x2_t v5 = (int64x2_t)vcgtzq_s32(v4);
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0])
  {
    uint64_t v6 = *(void *)(a2 + 56);
    uint64_t v7 = (float32x4_t *)(result + 4192);
    float32x4_t v8 = 0uLL;
    int32x4_t v9 = 0uLL;
    v10.i64[0] = 0x100000001;
    v10.i64[1] = 0x100000001;
    do
    {
      v11.i32[0] = *(_DWORD *)(v6 + 4 * v7[-1].i32[0]);
      v11.i32[1] = *(_DWORD *)(v6 + 4 * v7[-1].i32[1]);
      v11.i32[2] = *(_DWORD *)(v6 + 4 * v7[-1].i32[2]);
      v11.i32[3] = *(_DWORD *)(v6 + 4 * v7[-1].i32[3]);
      float32x4_t v8 = vmlaq_f32(v8, (float32x4_t)vandq_s8((int8x16_t)v5, v11), *v7);
      int32x4_t v9 = vaddq_s32(v9, v10);
      int64x2_t v5 = (int64x2_t)vcgtq_s32(v4, v9);
      v7 += 2;
    }
    while (vorrq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0]);
  }
  else
  {
    float32x4_t v8 = 0uLL;
  }
  HIDWORD(vstd::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = a4 - 1;
  LODWORD(vstd::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = a4 - 1;
  float32x4_t v13 = vmulq_f32(*(float32x4_t *)(result + 8288), v8);
  int8x16_t v14 = vandq_s8((int8x16_t)v13, vorrq_s8((int8x16_t)vcltzq_f32(v13), (int8x16_t)vcgezq_f32(v13)));
  switch((v12 >> 1))
  {
    case 0u:
      goto LABEL_10;
    case 1u:
      goto LABEL_9;
    case 3u:
      goto LABEL_8;
    case 7u:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(result + 828std::__tree<Phase::SpatialCategory>::destroy((uint64_t)this + 24, *((void **)this + 4)) = v14.i32[3];
LABEL_8:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(result + 8280)) = v14.i32[2];
LABEL_9:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(result + 8276)) = v14.i32[1];
LABEL_10:
      *(_DWORD *)(*(void *)(a2 + 56) + 4 * *(int *)(result + 8272)) = v14.i32[0];
      break;
    default:
      return result;
  }
  return result;
}

float anonymous namespace'::GainControlSlice::CopyVoiceState(_anonymous_namespace_::GainControlSlice *this, Phase::DspLayer::VoicePoolSlice *a2, int a3, int a4)
{
  int32x4_t v4 = (char *)a2 + 4 * a3;
  int64x2_t v5 = (char *)this + 4 * a4;
  *((_DWORD *)v5 + 4) = *((_DWORD *)v4 + 4);
  uint64_t v6 = *((unsigned int *)v4 + 8);
  *((_DWORD *)v5 + 8) = v6;
  if ((int)v6 >= 1)
  {
    uint64_t v7 = (_DWORD *)((char *)this + 4 * a4 + 64);
    float32x4_t v8 = (int *)((char *)a2 + 4 * a3 + 64);
    do
    {
      *(v7 - 4) = *(v8 - 4);
      int v9 = *v8;
      v8 += 8;
      _DWORD *v7 = v9;
      v7 += 8;
      --v6;
    }
    while (v6);
  }
  int32x4_t v10 = (char *)this + 4 * a4;
  int8x16_t v11 = (char *)a2 + 4 * a3;
  uint64_t v12 = *((unsigned int *)v11 + 1040);
  *((_DWORD *)v10 + 1040) = v12;
  if ((int)v12 >= 1)
  {
    float32x4_t v13 = v10 + 4192;
    int8x16_t v14 = (int *)(v11 + 4192);
    do
    {
      *(v13 - 4) = *(v14 - 4);
      int v15 = *v14;
      v14 += 8;
      *float32x4_t v13 = v15;
      v13 += 8;
      --v12;
    }
    while (v12);
  }
  *((_DWORD *)v10 + 103std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v11 + 1036);
  *((_DWORD *)v10 + 2068) = *((_DWORD *)v11 + 2068);
  float result = *((float *)v11 + 2072);
  *((float *)v10 + 2072) = result;
  *((void *)this + a4 + 1038) = *((void *)a2 + a3 + 1038);
  return result;
}

uint64_t anonymous namespace'::GainControlSlice::AddInput(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  uint64_t v7 = (char *)this + 32;
  uint64_t v8 = *((int *)this + a3 + 8);
  if ((int)v8 > 127) {
    return 6;
  }
  uint64_t result = 0;
  int v9 = (char *)this + 32 * v8 + 4 * a3;
  *((_DWORD *)v9 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = a4;
  *((float *)v9 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a5;
  *(_DWORD *)&v7[4 * a3] = v8 + 1;
  return result;
}

uint64_t anonymous namespace'::GainControlSlice::RemoveInput(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  else {
    return Phase::DspLayer::VoiceConnectionList<128>::RemoveConnection((uint64_t)this + 32, a3, a4);
  }
}

uint64_t anonymous namespace'::GainControlSlice::SetInputGain(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, int a4, float a5)
{
  if (a2) {
    return 8;
  }
  uint64_t v6 = *((unsigned int *)this + a3 + 8);
  if ((int)v6 < 1) {
    return 7;
  }
  uint64_t v7 = 0;
  for (uint64_t i = (float *)((char *)this + 4 * a3 + 64); *((_DWORD *)i - 4) != a4; i += 8)
  {
    if (v6 == ++v7) {
      return 7;
    }
  }
  if ((v7 & 0x80000000) != 0) {
    return 7;
  }
  uint64_t result = 0;
  *uint64_t i = a5;
  return result;
}

void anonymous namespace'::GainControlSlice::GetInputs(_anonymous_namespace_::GainControlSlice *this@<X0>, int a2@<W1>, int a3@<W2>, uint64_t a4@<X8>)
{
  if (a2)
  {
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  }
  else
  {
    Phase::DspLayer::VoiceConnectionList<128>::GetConnections((uint64_t)this + 32, a3, (char **)a4);
  }
}

uint64_t anonymous namespace'::GainControlSlice::ClearInputs(_anonymous_namespace_::GainControlSlice *this, int a2)
{
  *((_DWORD *)this + a2 + 8) = 0;
  return 0;
}

uint64_t anonymous namespace'::GainControlSlice::GetMaximumInputConnectionCount(_anonymous_namespace_::GainControlSlice *this, int a2)
{
  return (a2 == 0) << 7;
}

unint64_t anonymous namespace'::GainControlSlice::GetOutput(_anonymous_namespace_::GainControlSlice *this, int a2, int a3)
{
  if (a2) {
    return 0xFFFFFFFF00000008;
  }
  else {
    return (unint64_t)*((unsigned int *)this + a3 + 1036) << 32;
  }
}

uint64_t anonymous namespace'::GainControlSlice::SetOutput(_anonymous_namespace_::GainControlSlice *this, int a2, int a3, int a4)
{
  if (a2) {
    return 8;
  }
  uint64_t result = 0;
  *((_DWORD *)this + a3 + 103std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a4;
  return result;
}

void std::__function::__func<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::~__func()
{
}

void *std::__function::__func<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D4768E0;
  return result;
}

void std::__function::__func<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D4768E0;
}

void std::__function::__func<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0,std::allocator<Phase::DspLayer::GainControl::GetNewRegistryEntry(void)::$_0>,Phase::DspLayer::VoicePool * ()(Phase::DspLayer::VoiceEngine *,int)>::operator()()
{
}

void sub_221F4E238(_Unwind_Exception *a1)
{
  MEMORY[0x223C938A0](v1, 0x10F1C408EBD29CELL);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::generateDirectionalMetadataER(void *a1, double a2, double a3, double a4, double a5, float a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v63 = *MEMORY[0x263EF8340];
  if (a9)
  {
    int32x4_t v10 = a1;
    if ((int)(954437177 * ((uint64_t)(a1[1] - *a1) >> 5)) >= 1)
    {
      unint64_t v11 = a10;
      unint64_t v14 = *(unsigned int *)(*a1 + 140);
      uint64_t v46 = 954437177 * ((uint64_t)(a1[1] - *a1) >> 5);
      Phase::SpatialModeler::AllocMetadata<float>((uint64_t *)a9, v46, a10);
      uint64_t v16 = 0;
      uint64_t v45 = 4 * v11;
      uint64_t v52 = 16;
      uint64_t v53 = 0;
      unint64_t v51 = v11;
      unint64_t v47 = v14;
      while (1)
      {
        uint64_t v17 = *v10;
        if (v16 >= (int)(954437177 * ((v10[1] - *v10) >> 5)))
        {
LABEL_46:
          *(unsigned char *)(a9 + 20Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
          *(_DWORD *)(a9 + 204) = 0;
          return;
        }
        uint64_t v18 = v17 + 288 * v16;
        float v19 = *(float *)(v18 + 8);
        float v20 = (float)((float)(180.0 - *(float *)(v18 + 4))
                    - (float)(floorf((float)(180.0 - *(float *)(v18 + 4)) / 360.0) * 360.0))
            + 0.0;
        if (v20 >= 360.0) {
          float v20 = nextafterf(360.0, 0.0);
        }
        uint64_t v21 = *(void *)(a9 + 8) + 12 * v16;
        *(_DWORD *)uint64_t v21 = 1065353216;
        *(float *)(v21 + 4) = 90.0 - v19;
        *(float *)(v21 + 8) = v20;
        uint64_t v22 = (float *)(v17 + 288 * v16);
        float v23 = v22[3] - v22[66];
        uint64_t v24 = *(void *)(a9 + 56);
        if (v23 < 0.0) {
          float v23 = 0.0;
        }
        *(float *)(v24 + 4 * v1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v23;
        *(unsigned char *)(*(void *)(a9 + 144) + v1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
        float v25 = v22[67];
        float v49 = v22[58];
        float v50 = v22[59];
        float v26 = v22[68];
        float v48 = v22[60];
        float v27 = v22[69];
        uint64_t v28 = v22 + 4;
        uint64_t v54 = 0;
        uint64_t v55 = 0;
        uint64_t v56 = 0;
        if (v14 != v11) {
          break;
        }
        float v29 = 0;
LABEL_35:
        uint64_t v36 = v10;
        uint64_t v37 = *(void *)(a9 + 104);
        uint64_t v38 = *(void *)(v37 + 8);
        if (*(float *)(v24 + 4 * v16) == 0.0)
        {
          if (v11) {
            bzero((void *)(v37 + 4 * v38 * v16 + 16), v45);
          }
        }
        else if (v11)
        {
          float v39 = 1.0
              / sqrtf((float)((float)((float)(v49 - v25) * (float)(v49 - v25))+ (float)((float)(v50 - v26) * (float)(v50 - v26)))+ (float)((float)(v48 - v27) * (float)(v48 - v27)));
          float v40 = (float *)(*v10 + 288 * v16);
          unint64_t v41 = v51;
          unsigned int v42 = (float *)(*v10 + v52);
          uint64_t v43 = (float *)(v37 + v38 * v53 + 16);
          do
          {
            float v44 = fminf(fmaxf(v40[36], 0.0), 10.0) / 10.0;
            float *v43 = (float)((float)(v39 * fabsf(*v28))
                         * sqrtf((float)(v44 * v44)* fminf(fmaxf(fmaxf(Phase::SpatialModeler::EarlyReflectionDetector::GetLastPathAngleError((Phase::SpatialModeler::EarlyReflectionDetector *)v40, v15)+ -0.86603, 0.0)/ 0.040282, 0.0), 1.0)))* a6;
            if (*v42 < 0.0) {
              *(unsigned char *)(*(void *)(a9 + 144) + v1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
            }
            ++v42;
            ++v43;
            ++v28;
            --v41;
          }
          while (v41);
        }
        if (v29)
        {
          uint64_t v55 = v29;
          operator delete(v29);
        }
        ++v16;
        unint64_t v11 = v51;
        v52 += 288;
        v53 += 4;
        int32x4_t v10 = v36;
        unint64_t v14 = v47;
        if (v16 == v46) {
          goto LABEL_46;
        }
      }
      std::vector<float>::resize((uint64_t)&v54, v11);
      switch(v14)
      {
        case 0x1F:
          int v30 = 1;
          uint64_t v31 = &Phase::sThirdOctaveBandFrequencies;
          break;
        case 0xA:
          int v30 = 1;
          uint64_t v31 = &Phase::sOctaveBandFrequencies;
          break;
        case 3:
          int v30 = 1;
          uint64_t v31 = (int *)&Phase::sThreeBandFrequencies;
          break;
        default:
          int v30 = 0;
          uint64_t v31 = 0;
          break;
      }
      __int16 v32 = v54;
      if (v11 == 3)
      {
        int v33 = (int *)&Phase::sThreeBandFrequencies;
        if (!v30) {
          goto LABEL_24;
        }
      }
      else
      {
        if (v11 != 31)
        {
          if (v11 == 10)
          {
            int v33 = &Phase::sOctaveBandFrequencies;
            if (v30) {
              goto LABEL_33;
            }
          }
LABEL_24:
          if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
          {
            __int16 v34 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)v31) + 1184);
            if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315650;
              if (v30) {
                unint64_t v35 = v11;
              }
              else {
                unint64_t v35 = v14;
              }
              uint64_t v58 = "GeneratePlaneWaveList.hpp";
              __int16 v59 = 1024;
              int v60 = 177;
              __int16 v61 = 2048;
              unint64_t v62 = v35;
              _os_log_impl(&dword_221E5E000, v34, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
            }
            Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
          }
          bzero(v32, v45);
          goto LABEL_34;
        }
        int v33 = &Phase::sThirdOctaveBandFrequencies;
        if (!v30) {
          goto LABEL_24;
        }
      }
LABEL_33:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>((float *)v31, (float *)&v31[v14], (uint64_t)v28, (uint64_t)&v28[v14], (float *)v33, (float *)&v33[v11], (uint64_t)v54);
LABEL_34:
      float v29 = v54;
      uint64_t v24 = *(void *)(a9 + 56);
      uint64_t v28 = (float *)v54;
      goto LABEL_35;
    }
  }
}

void sub_221F4E728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *Phase::SpatialModeler::AllocMetadata<float>(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v16[4] = *MEMORY[0x263EF8340];
  uint64_t v10 = 4;
  uint64_t v11 = a2;
  uint64_t v12 = &v11;
  v13[0] = &v10;
  Phase::details::AllocArray<Phase::Vector<float,3ul>,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>> Phase::details::AllocArray<Phase::Vector<float,3ul>>(unsigned long,unsigned long)::{lambda(Phase::Vector<float,3ul>*)#1} const&>(a2, (uint64_t)&v12, &v15);
  uint64_t v6 = v15;
  int v15 = 0;
  uint64_t v12 = v6;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13, (uint64_t)v16);
  uint64_t v14 = a2;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v15);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v16);
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 1, (uint64_t *)&v12);
  a1[6] = v14;
  std::unique_ptr<Phase::Vector<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v12);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v13);
  uint64_t v10 = 4;
  uint64_t v11 = a2;
  uint64_t v12 = &v11;
  v13[0] = &v10;
  Phase::details::AllocArray<float,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<float [],std::function<void ()(void *)>> Phase::details::AllocArray<float>(unsigned long,unsigned long)::{lambda(float*)#1} const&>(a2, (uint64_t)&v12, &v15);
  uint64_t v7 = v15;
  int v15 = 0;
  uint64_t v12 = v7;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13, (uint64_t)v16);
  uint64_t v14 = a2;
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v15);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v16);
  std::unique_ptr<float [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 7, (uint64_t *)&v12);
  a1[12] = v14;
  std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v12);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v13);
  Phase::AllocPackedSubbandArray<float>(a2, a3, (void **)&v12);
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 13, (uint64_t *)&v12);
  std::unique_ptr<Phase::PackedSubbandArray<float>,std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v12, 0);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v13);
  uint64_t v10 = 1;
  uint64_t v11 = a2;
  uint64_t v12 = &v11;
  v13[0] = &v10;
  Phase::details::AllocArray<BOOL,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(void)#1} const&,std::unique_ptr<BOOL [],std::function<void ()(void *)>> Phase::details::AllocArray<BOOL>(unsigned long,unsigned long)::{lambda(BOOL*)#1} const&>(a2, (uint64_t)&v12, &v15);
  uint64_t v8 = v15;
  int v15 = 0;
  uint64_t v12 = v8;
  std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100]((uint64_t)v13, (uint64_t)v16);
  uint64_t v14 = a2;
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v15);
  std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v16);
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::operator=[abi:ne180100](a1 + 18, (uint64_t *)&v12);
  a1[23] = v14;
  std::unique_ptr<BOOL [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)&v12);
  return std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](v13);
}

void Phase::SpatialModeler::generateDirectionalMetadataLR(Phase::SpatialModeler::DirectivityHistogram *a1, int a2, uint64_t *a3, uint64_t a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12)
{
  Phase::SpatialModeler::DirectivityHistogram::updateWasHitVector(a1);
  switch(a4)
  {
    case 31:
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>((uint64_t)a1, 1, 0xFFD9u, a2, &v24, a5, a6, a7, a8, a9, a10, a11, a12);
      Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>((uint64_t)&v24, a3, 1);
      float v27 = (void **)&v24;
      std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100](&v27);
      break;
    case 10:
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>((uint64_t)a1, 1, 0xFFD9u, a2, &v24, a5, a6, a7, a8, a9, a10, a11, a12);
      Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>((uint64_t)&v24, a3, 1);
      float v27 = (void **)&v24;
      std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100](&v27);
      break;
    case 3:
      uint64_t v24 = 0;
      uint64_t v25 = 0;
      uint64_t v26 = 0;
      Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((uint64_t)a1, 1, 0xFFD9u, a2, &v24, a5, a6, a7, a8, a9, a10, a11, a12);
      Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>((uint64_t)&v24, a3, 1);
      float v27 = (void **)&v24;
      std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100](&v27);
      break;
  }
}

void sub_221F4EB64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(uint64_t a1, char a2, unsigned int a3, int a4, void *a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13)
{
  uint64_t v140 = *MEMORY[0x263EF8340];
  float v19 = __exp10f(fabsf(a9) / -20.0);
  float v20 = *(float *)(a1 + 16);
  if (*(float *)(a1 + 20) < a12) {
    float v21 = *(float *)(a1 + 20);
  }
  else {
    float v21 = a12;
  }
  uint64_t v134 = 0;
  long long v135 = 0uLL;
  long long v132 = 0;
  uint64_t v133 = 0;
  std::string __p = 0;
  int v131 = 0;
  uint64_t v137 = 0;
  memset(v136, 0, sizeof(v136));
  uint64_t v128 = (Phase::SpatialModeler::DirectivityHistogram *)a1;
  int v117 = *(_DWORD *)(a1 + 28);
  if (v117 == 3) {
    goto LABEL_25;
  }
  for (uint64_t i = 0; i != 72; i += 24)
    std::vector<float>::resize((uint64_t)v136 + i, 3uLL);
  uint64_t v24 = *((unsigned int *)v128 + 7);
  if (*((_DWORD *)v128 + 6)) {
    BOOL v25 = *((unsigned char *)v128 + 36) == 0;
  }
  else {
    BOOL v25 = 0;
  }
  if (v25) {
    uint64_t v26 = (_DWORD *)*((void *)v128 + 1);
  }
  else {
    uint64_t v26 = &Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
  }
  uint64_t v27 = *(void *)&v136[0];
  switch(v24)
  {
    case 0x1F:
      float v29 = &Phase::sThirdOctaveBandFrequencies;
      goto LABEL_19;
    case 0xA:
      float v29 = (int *)Phase::sOctaveBandFrequencies;
LABEL_19:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>((float *)v29, (float *)&v29[v24], (uint64_t)v26, (uint64_t)&v26[v24], Phase::sThreeBandFrequencies, Phase::sOctaveBandFrequencies, *(uint64_t *)&v136[0]);
      break;
    case 3:
      uint64_t v28 = *(void *)v26;
      *(_DWORD *)(*(void *)&v136[0] + 8) = v26[2];
      *(void *)uint64_t v27 = v28;
      break;
    default:
      if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
      {
        int v30 = **(NSObject ***)(Phase::Logger::GetInstance(v23) + 1184);
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "GeneratePlaneWaveList.hpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 177;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&unsigned char buf[20] = v24;
          _os_log_impl(&dword_221E5E000, v30, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
        }
        Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
      }
      *(_DWORD *)(v27 + 8) = 0;
      *(void *)uint64_t v27 = 0;
      break;
  }
LABEL_25:
  __int16 v32 = (void *)*a5;
  uint64_t v31 = a5[1];
  if (v31 != *a5)
  {
    uint64_t v33 = v31 - 32;
    __int16 v34 = (void *)(v31 - 32);
    unint64_t v35 = (void *)(v31 - 32);
    do
    {
      uint64_t v36 = *v35;
      v35 -= 4;
      (*(void (**)(void *))(v36 + 16))(v34);
      v33 -= 32;
      BOOL v25 = v34 == v32;
      __int16 v34 = v35;
    }
    while (!v25);
  }
  a5[1] = v32;
  if ((a2 & 1) == 0) {
    a3 = time(0);
  }
  srand(a3);
  int v37 = vcvtps_u32_f32(a8 * a11);
  signed int v122 = vcvtps_u32_f32(v21 * a8);
  int v38 = v117;
  if (v37 < v122)
  {
    unsigned int v39 = 0;
    float v40 = v20 * a8;
    double v116 = a7 * 12.5663706 * a7 * a7;
    float v123 = 0.0;
    while (1)
    {
      if (v37 % 50 == 1)
      {
        float v41 = a10;
        if (a6 >= 0.00000011921)
        {
          float v41 = v116 * (float)((float)v37 / a8) * (float)((float)v37 / a8) / a6;
          if (v41 > a10) {
            float v41 = a10;
          }
        }
        float v123 = (float)(1.0 / a8) * v41;
      }
      unsigned int v42 = (void *)rand();
      if ((float)((float)(int)v42 * 4.6566e-10) < v123)
      {
        uint64_t v43 = v131;
        if (v131 >= v132)
        {
          unsigned int v42 = __p;
          uint64_t v45 = v131 - __p;
          unint64_t v46 = v45 + 1;
          if ((unint64_t)(v45 + 1) >> 62) {
            std::vector<int>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v47 = (char *)v132 - (char *)__p;
          if (((char *)v132 - (char *)__p) >> 1 > v46) {
            unint64_t v46 = v47 >> 1;
          }
          if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v48 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v48 = v46;
          }
          if (v48)
          {
            float v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v132, v48);
            unsigned int v42 = __p;
            uint64_t v43 = v131;
          }
          else
          {
            float v49 = 0;
          }
          float v50 = (int *)&v49[4 * v45];
          int *v50 = v37;
          float v44 = v50 + 1;
          while (v43 != v42)
          {
            int v51 = *--v43;
            *--float v50 = v51;
          }
          std::string __p = v50;
          long long v132 = (int *)&v49[4 * v48];
          if (v42) {
            operator delete(v42);
          }
        }
        else
        {
          *int v131 = v37;
          float v44 = v131 + 1;
        }
        int v131 = v44;
      }
      unsigned int v52 = (int)(float)((float)v37 / v40);
      if ((int)v39 >= (int)v52) {
        goto LABEL_167;
      }
      int v124 = (int)(float)((float)v37 / v40);
      if (v38 == 3)
      {
        uint64_t v53 = __p;
        unint64_t v54 = (unint64_t)((char *)v131 - (char *)__p) >> 2;
        if (v54)
        {
          unsigned int v55 = *((_DWORD *)v128 + 6);
          int v56 = *((_DWORD *)v128 + 7);
          BOOL v57 = v55 > v39 && *((unsigned char *)v128 + 36) == 0;
          uint64_t v58 = *((void *)v128 + 1);
          if (v57) {
            __int16 v59 = (char *)(v58 + 4 * v56 * v39);
          }
          else {
            __int16 v59 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          if ((int)v55 <= v124)
          {
            std::vector<unsigned int>::pointer v67 = (char *)(v58 + 4 * v56 * (v55 - 1));
            if (!v55) {
              std::vector<unsigned int>::pointer v67 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            if (*((unsigned char *)v128 + 36)) {
              int v60 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else {
              int v60 = v67;
            }
          }
          else if (*((unsigned char *)v128 + 36) || v55 <= v124)
          {
            int v60 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          else
          {
            int v60 = (char *)(v58 + 4 * (v56 * v124));
          }
LABEL_97:
          unsigned int v70 = v39 - 1;
          if ((int)v39 < 1)
          {
            if (v38 == 3)
            {
              if (*((unsigned char *)v128 + 36)) {
                BOOL v72 = 1;
              }
              else {
                BOOL v72 = v55 == 0;
              }
              if (v72) {
                float v71 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              }
              else {
                float v71 = (char *)*((void *)v128 + 1);
              }
            }
            else
            {
              float v71 = *(char **)&v136[0];
            }
          }
          else if (v38 == 3)
          {
            if (*((unsigned char *)v128 + 36))
            {
              float v71 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else
            {
              float v71 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              if (v55 > v70) {
                float v71 = (char *)(*((void *)v128 + 1) + 4 * *((_DWORD *)v128 + 7) * v70);
              }
            }
          }
          else
          {
            float v71 = (char *)*((void *)v136 + 3 * (v70 % 3));
          }
          float v73 = 1.0;
          if (v54 >= 2) {
            float v73 = sqrtf(1.0 / (float)v54);
          }
          uint64_t v74 = 0;
          float v75 = v73 * a13;
          unsigned int v76 = (float)((float)((float)(*((float *)v128 + 4) * (float)v39) * a8) + 0.5);
          while (*(float *)&v71[v74] <= 1.1755e-37
               && *(float *)&v59[v74] <= 1.1755e-37
               && *(float *)&v60[v74] <= 1.1755e-37)
          {
            v74 += 4;
            if (v74 == 12) {
              goto LABEL_165;
            }
          }
          int v119 = v37;
          uint64_t v77 = 0;
          uint64_t v78 = v54;
          do
          {
            int v79 = rand();
            if (v79 >= 0) {
              int v80 = v79 & 1;
            }
            else {
              int v80 = -(v79 & 1);
            }
            int v81 = __p[v77];
            int v82 = rand();
            float v83 = (float)(v81 - v76) / v40;
            if (v83 < 0.0) {
              float v83 = 0.0;
            }
            if (v83 <= 1.0) {
              float v84 = v83;
            }
            else {
              float v84 = 1.0;
            }
            std::vector<float>::vector(buf, 3uLL);
            float v85 = (float)v82 * 4.6566e-10;
            uint64_t v86 = *(void *)buf;
            uint64_t v87 = 0;
            if (v84 >= 0.5)
            {
              float v89 = (float)(v85 * (float)((float)(v84 + -0.5) + (float)(v84 + -0.5)))
                  * (float)(v85 * (float)((float)(v84 + -0.5) + (float)(v84 + -0.5)));
              do
              {
                *(float *)(v86 + v8std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = (float)(v89 * *(float *)&v60[v87])
                                      + (float)((float)(1.0 - v89) * *(float *)&v59[v87]);
                v87 += 4;
              }
              while (v87 != 12);
            }
            else
            {
              float v88 = (float)(v85 * (float)((float)(0.5 - v84) + (float)(0.5 - v84)))
                  * (float)(v85 * (float)((float)(0.5 - v84) + (float)(0.5 - v84)));
              do
              {
                *(float *)(v86 + v8std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = (float)(v88 * *(float *)&v71[v87])
                                      + (float)((float)(1.0 - v88) * *(float *)&v59[v87]);
                v87 += 4;
              }
              while (v87 != 12);
            }
            if (v134) {
              operator delete(v134);
            }
            unint64_t v90 = *(float **)buf;
            uint64_t v134 = *(void **)buf;
            int v129 = *(float **)&buf[8];
            long long v135 = *(_OWORD *)&buf[8];
            int v91 = rand();
            int v92 = rand();
            if (!Phase::SpatialModeler::DirectivityHistogram::findImpactAngle_TS(v128, v39, (float *)&v133 + 1, (float *)&v133, (float)v91 * 4.6566e-10, (float)v92 * 4.6566e-10))
            {
              uint64_t v93 = 0;
              int v94 = __p[v77];
              do
              {
                v90[v93] = v75 * (float)(sqrtf(v90[v93]) * (float)(2 * v80 - 1));
                ++v93;
              }
              while (v93 != 3);
              if (v90 != v129)
              {
                int v95 = (v94 - a4) & ~((v94 - a4) >> 31);
                while (fabsf(*v90) <= v19)
                {
                  if (++v90 == v129) {
                    goto LABEL_138;
                  }
                }
                float v96 = (float)v95 / a8;
                unint64_t v98 = a5[1];
                unint64_t v97 = a5[2];
                if (v98 >= v97)
                {
                  uint64_t v101 = (uint64_t)(v98 - *a5) >> 5;
                  if ((unint64_t)(v101 + 1) >> 59) {
                    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                  }
                  uint64_t v102 = v97 - *a5;
                  uint64_t v103 = v102 >> 4;
                  if (v102 >> 4 <= (unint64_t)(v101 + 1)) {
                    uint64_t v103 = v101 + 1;
                  }
                  if ((unint64_t)v102 >= 0x7FFFFFFFFFFFFFE0) {
                    unint64_t v104 = 0x7FFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v104 = v103;
                  }
                  uint64_t v139 = a5 + 2;
                  if (v104) {
                    float v105 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::GraphDescriptionNode>>((uint64_t)(a5 + 2), v104);
                  }
                  else {
                    float v105 = 0;
                  }
                  *(void *)buf = v105;
                  *(void *)&uint8_t buf[8] = &v105[32 * v101];
                  *(void *)&uint8_t buf[16] = *(void *)&buf[8];
                  *(void *)&uint8_t buf[24] = &v105[32 * v104];
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::PhaseSpatialModelerMetadata_3Band(*(uint64_t *)&buf[8], (uint64_t *)&v134, *(float *)&v133, *((float *)&v133 + 1), v96);
                  uint64_t v106 = (void *)*a5;
                  unint64_t v107 = a5[1];
                  uint64_t v108 = *(void *)&buf[8];
                  uint64_t v109 = *(void *)&buf[16];
                  if (v107 == *a5)
                  {
                    int64x2_t v112 = vdupq_n_s64(v107);
                  }
                  else
                  {
                    uint64_t v110 = *(void *)&buf[8] - 32;
                    do
                    {
                      *(void *)(v108 - 32) = &unk_26D476928;
                      v108 -= 32;
                      long long v111 = *(_OWORD *)(v107 - 24);
                      *(void *)(v108 + 24) = *(void *)(v107 - 8);
                      *(_OWORD *)(v108 + 8) = v111;
                      v110 -= 32;
                      v107 -= 32;
                    }
                    while ((void *)v107 != v106);
                    int64x2_t v112 = *(int64x2_t *)a5;
                  }
                  uint64_t v100 = a5;
                  unint64_t v99 = v109 + 32;
                  *a5 = v108;
                  a5[1] = v109 + 32;
                  *(int64x2_t *)&uint8_t buf[8] = v112;
                  uint64_t v113 = a5[2];
                  a5[2] = *(void *)&buf[24];
                  *(void *)&uint8_t buf[24] = v113;
                  *(void *)buf = v112.i64[0];
                  std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::~__split_buffer((uint64_t)buf);
                }
                else
                {
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::PhaseSpatialModelerMetadata_3Band(a5[1], (uint64_t *)&v134, *(float *)&v133, *((float *)&v133 + 1), v96);
                  unint64_t v99 = v98 + 32;
                  uint64_t v100 = a5;
                  a5[1] = v98 + 32;
                }
                v100[1] = v99;
              }
            }
LABEL_138:
            ++v77;
          }
          while (v77 != v78);
          uint64_t v53 = __p;
          int v38 = v117;
          int v37 = v119;
LABEL_165:
          int v131 = v53;
          goto LABEL_166;
        }
        goto LABEL_166;
      }
      uint64_t v61 = *((unsigned int *)v128 + 7);
      BOOL v62 = *((_DWORD *)v128 + 6) > v52 && *((unsigned char *)v128 + 36) == 0;
      uint64_t v63 = v62
          ? (_DWORD *)(*((void *)v128 + 1) + 4 * v61 * v52)
          : &Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
      uint64_t v64 = (uint64_t *)v136 + 3 * (v52 % 3);
      uint64_t v65 = *v64;
      if (v61 == 31) {
        break;
      }
      if (v61 == 10)
      {
        uint64_t v68 = (int *)Phase::sOctaveBandFrequencies;
LABEL_86:
        Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>((float *)v68, (float *)&v68[v61], (uint64_t)v63, (uint64_t)&v63[v61], Phase::sThreeBandFrequencies, Phase::sOctaveBandFrequencies, *v64);
        goto LABEL_92;
      }
      if (v61 == 3)
      {
        uint64_t v66 = *(void *)v63;
        *(_DWORD *)(v65 + 8) = v63[2];
        *(void *)uint64_t v65 = v66;
      }
      else
      {
        if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
        {
          int v69 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)v42) + 1184);
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = "GeneratePlaneWaveList.hpp";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 177;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&unsigned char buf[20] = v61;
            _os_log_impl(&dword_221E5E000, v69, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
          }
          Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
        }
        *(_DWORD *)(v65 + 8) = 0;
        *(void *)uint64_t v65 = 0;
      }
LABEL_92:
      uint64_t v53 = __p;
      unint64_t v54 = (unint64_t)((char *)v131 - (char *)__p) >> 2;
      if (v54)
      {
        __int16 v59 = (char *)*((void *)v136 + 3 * (v39 % 3));
        unsigned int v55 = *((_DWORD *)v128 + 6);
        if ((int)v55 <= v124) {
          int v60 = (char *)*((void *)v136 + 3 * ((v55 - 1) % 3));
        }
        else {
          int v60 = (char *)*v64;
        }
        goto LABEL_97;
      }
LABEL_166:
      unsigned int v39 = v124;
LABEL_167:
      if (++v37 == v122) {
        goto LABEL_168;
      }
    }
    uint64_t v68 = &Phase::sThirdOctaveBandFrequencies;
    goto LABEL_86;
  }
LABEL_168:
  for (uint64_t j = 0; j != -72; j -= 24)
  {
    uint64_t v115 = *(void **)((char *)&v136[3] + j);
    if (v115)
    {
      *(void *)((char *)&v136[3] + j + 8) = v115;
      operator delete(v115);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  if (v134) {
    operator delete(v134);
  }
}

void sub_221F4F768(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v34 = 0;
  while (1)
  {
    unint64_t v35 = *(void **)(&a33 + v34 + 48);
    if (v35)
    {
      *(void *)(&a33 + v34 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v35;
      operator delete(v35);
    }
    v34 -= 24;
    if (v34 == -72)
    {
      if (__p) {
        operator delete(__p);
      }
      if (a30) {
        operator delete(a30);
      }
      _Unwind_Resume(exception_object);
    }
  }
}

uint64_t Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>(uint64_t result, uint64_t *a2, char a3)
{
  if (a2)
  {
    __n128 v3 = (uint64_t *)result;
    uint64_t result = *(void *)result;
    uint64_t v4 = v3[1];
    if (result != v4)
    {
      unint64_t v6 = (v4 - result) >> 5;
      unsigned int v7 = (**(uint64_t (***)(uint64_t))result)(result);
      Phase::SpatialModeler::AllocMetadata<float>(a2, v6, (int)v7);
      uint64_t v8 = 0;
      uint64_t v9 = *v3;
      uint64_t v10 = a2[1];
      uint64_t v11 = a2[7];
      uint64_t v12 = a2[18];
      uint64_t v28 = a2;
      uint64_t v13 = a2[13];
      uint64_t v14 = (float *)(v13 + 16);
      if (v6 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v6;
      }
      uint64_t v16 = v7;
      uint64_t v17 = 4 * *(void *)(v13 + 8);
      uint64_t v18 = (float *)(v9 + 20);
      uint64_t result = 1127481344;
      uint64_t v29 = v17;
      uint64_t v30 = v9;
      do
      {
        uint64_t v19 = v9 + 32 * v8;
        float v20 = *(float *)(v19 + 8);
        float v21 = (float)((float)(180.0 - *(float *)(v19 + 12))
                    - (float)(floorf((float)(180.0 - *(float *)(v19 + 12)) / 360.0) * 360.0))
            + 0.0;
        if (v21 >= 360.0)
        {
          uint64_t v22 = v15;
          float v21 = nextafterf(360.0, 0.0);
          uint64_t result = 1127481344;
          uint64_t v17 = v29;
          uint64_t v9 = v30;
          uint64_t v15 = v22;
        }
        uint64_t v23 = v10 + 12 * v8;
        *(_DWORD *)uint64_t v23 = 1065353216;
        *(float *)(v23 + 4) = 90.0 - v20;
        *(float *)(v23 + 8) = v21;
        *(_DWORD *)(v11 + 4 * v8) = *(_DWORD *)(v19 + 16);
        *(unsigned char *)(v12 + v8) = 0;
        uint64_t v24 = v18;
        BOOL v25 = v14;
        uint64_t v26 = v16;
        if ((int)v16 >= 1)
        {
          do
          {
            *BOOL v25 = fabsf(*v24);
            if (*v24 < 0.0) {
              *(unsigned char *)(v12 + v8) = 1;
            }
            ++v25;
            ++v24;
            --v26;
          }
          while (v26);
        }
        ++v8;
        uint64_t v14 = (float *)((char *)v14 + v17);
        v18 += 8;
      }
      while (v8 != v15);
      *((unsigned char *)v28 + 20Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a3;
      *((_DWORD *)v28 + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
    }
  }
  return result;
}

void Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(uint64_t a1, char a2, unsigned int a3, int a4, void *a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13)
{
  uint64_t v144 = *MEMORY[0x263EF8340];
  float v19 = __exp10f(fabsf(a9) / -20.0);
  float v20 = *(float *)(a1 + 16);
  if (*(float *)(a1 + 20) < a12) {
    float v21 = *(float *)(a1 + 20);
  }
  else {
    float v21 = a12;
  }
  unint64_t v138 = 0;
  long long v139 = 0uLL;
  int v136 = 0;
  uint64_t v137 = 0;
  std::string __p = 0;
  long long v135 = 0;
  uint64_t v141 = 0;
  memset(v140, 0, sizeof(v140));
  long long v132 = (Phase::SpatialModeler::DirectivityHistogram *)a1;
  int v121 = *(_DWORD *)(a1 + 28);
  if (v121 == 10) {
    goto LABEL_26;
  }
  for (uint64_t i = 0; i != 72; i += 24)
    std::vector<float>::resize((uint64_t)v140 + i, 0xAuLL);
  uint64_t v24 = *((unsigned int *)v132 + 7);
  if (*((_DWORD *)v132 + 6)) {
    BOOL v25 = *((unsigned char *)v132 + 36) == 0;
  }
  else {
    BOOL v25 = 0;
  }
  if (v25) {
    uint64_t v26 = (_OWORD *)*((void *)v132 + 1);
  }
  else {
    uint64_t v26 = &Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
  }
  uint64_t v27 = *(void *)&v140[0];
  switch(v24)
  {
    case 3:
      uint64_t v30 = Phase::sThreeBandFrequencies;
      goto LABEL_19;
    case 0x1F:
      uint64_t v30 = Phase::sThirdOctaveBandFrequencies;
LABEL_19:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v30, &v30[v24], (uint64_t)v26, (uint64_t)v26 + 4 * v24, Phase::sOctaveBandFrequencies, Phase::sThirdOctaveBandFrequencies, *(uint64_t *)&v140[0]);
      goto LABEL_26;
    case 0xA:
      long long v28 = *v26;
      long long v29 = v26[1];
      *(void *)(*(void *)&v140[0] + 32) = *((void *)v26 + 4);
      *(_OWORD *)(v27 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v29;
      break;
    default:
      if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
      {
        uint64_t v31 = **(NSObject ***)(Phase::Logger::GetInstance(v23) + 1184);
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "GeneratePlaneWaveList.hpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 177;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&unsigned char buf[20] = v24;
          _os_log_impl(&dword_221E5E000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
        }
        Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
      }
      *(void *)(v27 + 32) = 0;
      long long v28 = 0uLL;
      *(_OWORD *)(v27 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
      break;
  }
  *(_OWORD *)uint64_t v27 = v28;
LABEL_26:
  uint64_t v33 = (void *)*a5;
  uint64_t v32 = a5[1];
  if (v32 != *a5)
  {
    uint64_t v34 = v32 - 64;
    unint64_t v35 = (void *)(v32 - 64);
    uint64_t v36 = (void *)(v32 - 64);
    do
    {
      uint64_t v37 = *v36;
      v36 -= 8;
      (*(void (**)(void *))(v37 + 16))(v35);
      v34 -= 64;
      BOOL v25 = v35 == v33;
      unint64_t v35 = v36;
    }
    while (!v25);
  }
  a5[1] = v33;
  if ((a2 & 1) == 0) {
    a3 = time(0);
  }
  srand(a3);
  int v38 = vcvtps_u32_f32(a8 * a11);
  signed int v126 = vcvtps_u32_f32(v21 * a8);
  int v39 = v121;
  if (v38 < v126)
  {
    unsigned int v40 = 0;
    float v41 = v20 * a8;
    double v120 = a7 * 12.5663706 * a7 * a7;
    float v127 = 0.0;
    while (1)
    {
      if (v38 % 50 == 1)
      {
        float v42 = a10;
        if (a6 >= 0.00000011921)
        {
          float v42 = v120 * (float)((float)v38 / a8) * (float)((float)v38 / a8) / a6;
          if (v42 > a10) {
            float v42 = a10;
          }
        }
        float v127 = (float)(1.0 / a8) * v42;
      }
      uint64_t v43 = (void *)rand();
      if ((float)((float)(int)v43 * 4.6566e-10) < v127)
      {
        float v44 = v135;
        if (v135 >= v136)
        {
          uint64_t v43 = __p;
          uint64_t v46 = v135 - __p;
          unint64_t v47 = v46 + 1;
          if ((unint64_t)(v46 + 1) >> 62) {
            std::vector<int>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v48 = (char *)v136 - (char *)__p;
          if (((char *)v136 - (char *)__p) >> 1 > v47) {
            unint64_t v47 = v48 >> 1;
          }
          if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v49 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v49 = v47;
          }
          if (v49)
          {
            float v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v136, v49);
            uint64_t v43 = __p;
            float v44 = v135;
          }
          else
          {
            float v50 = 0;
          }
          int v51 = (int *)&v50[4 * v46];
          int *v51 = v38;
          uint64_t v45 = v51 + 1;
          while (v44 != v43)
          {
            int v52 = *--v44;
            *--int v51 = v52;
          }
          std::string __p = v51;
          int v136 = (int *)&v50[4 * v49];
          if (v43) {
            operator delete(v43);
          }
        }
        else
        {
          *long long v135 = v38;
          uint64_t v45 = v135 + 1;
        }
        long long v135 = v45;
      }
      unsigned int v53 = (int)(float)((float)v38 / v41);
      if ((int)v40 >= (int)v53) {
        goto LABEL_169;
      }
      int v128 = (int)(float)((float)v38 / v41);
      if (v39 == 10)
      {
        unint64_t v54 = __p;
        unint64_t v55 = (unint64_t)((char *)v135 - (char *)__p) >> 2;
        if (v55)
        {
          unsigned int v56 = *((_DWORD *)v132 + 6);
          int v57 = *((_DWORD *)v132 + 7);
          BOOL v58 = v56 > v40 && *((unsigned char *)v132 + 36) == 0;
          uint64_t v59 = *((void *)v132 + 1);
          if (v58) {
            int v60 = (char *)(v59 + 4 * v57 * v40);
          }
          else {
            int v60 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          if ((int)v56 <= v128)
          {
            int v69 = (char *)(v59 + 4 * v57 * (v56 - 1));
            if (!v56) {
              int v69 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            if (*((unsigned char *)v132 + 36)) {
              uint64_t v61 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else {
              uint64_t v61 = v69;
            }
          }
          else if (*((unsigned char *)v132 + 36) || v56 <= v128)
          {
            uint64_t v61 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          else
          {
            uint64_t v61 = (char *)(v59 + 4 * (v57 * v128));
          }
LABEL_99:
          unsigned int v72 = v40 - 1;
          if ((int)v40 < 1)
          {
            if (v39 == 10)
            {
              if (*((unsigned char *)v132 + 36)) {
                BOOL v74 = 1;
              }
              else {
                BOOL v74 = v56 == 0;
              }
              if (v74) {
                float v73 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              }
              else {
                float v73 = (char *)*((void *)v132 + 1);
              }
            }
            else
            {
              float v73 = *(char **)&v140[0];
            }
          }
          else if (v39 == 10)
          {
            if (*((unsigned char *)v132 + 36))
            {
              float v73 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else
            {
              float v73 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              if (v56 > v72) {
                float v73 = (char *)(*((void *)v132 + 1) + 4 * *((_DWORD *)v132 + 7) * v72);
              }
            }
          }
          else
          {
            float v73 = (char *)*((void *)v140 + 3 * (v72 % 3));
          }
          float v75 = 1.0;
          if (v55 >= 2) {
            float v75 = sqrtf(1.0 / (float)v55);
          }
          uint64_t v76 = 0;
          float v77 = v75 * a13;
          unsigned int v78 = (float)((float)((float)(*((float *)v132 + 4) * (float)v40) * a8) + 0.5);
          while (*(float *)&v73[v76] <= 1.1755e-37
               && *(float *)&v60[v76] <= 1.1755e-37
               && *(float *)&v61[v76] <= 1.1755e-37)
          {
            v76 += 4;
            if (v76 == 40) {
              goto LABEL_167;
            }
          }
          int v123 = v38;
          uint64_t v79 = 0;
          uint64_t v80 = v55;
          do
          {
            int v81 = rand();
            if (v81 >= 0) {
              int v82 = v81 & 1;
            }
            else {
              int v82 = -(v81 & 1);
            }
            int v83 = __p[v79];
            int v84 = rand();
            float v85 = (float)(v83 - v78) / v41;
            if (v85 < 0.0) {
              float v85 = 0.0;
            }
            if (v85 <= 1.0) {
              float v86 = v85;
            }
            else {
              float v86 = 1.0;
            }
            std::vector<float>::vector(buf, 0xAuLL);
            float v87 = (float)v84 * 4.6566e-10;
            uint64_t v88 = *(void *)buf;
            uint64_t v89 = 0;
            if (v86 >= 0.5)
            {
              float v91 = (float)(v87 * (float)((float)(v86 + -0.5) + (float)(v86 + -0.5)))
                  * (float)(v87 * (float)((float)(v86 + -0.5) + (float)(v86 + -0.5)));
              do
              {
                *(float *)(v88 + v89) = (float)(v91 * *(float *)&v61[v89])
                                      + (float)((float)(1.0 - v91) * *(float *)&v60[v89]);
                v89 += 4;
              }
              while (v89 != 40);
            }
            else
            {
              float v90 = (float)(v87 * (float)((float)(0.5 - v86) + (float)(0.5 - v86)))
                  * (float)(v87 * (float)((float)(0.5 - v86) + (float)(0.5 - v86)));
              do
              {
                *(float *)(v88 + v89) = (float)(v90 * *(float *)&v73[v89])
                                      + (float)((float)(1.0 - v90) * *(float *)&v60[v89]);
                v89 += 4;
              }
              while (v89 != 40);
            }
            if (v138) {
              operator delete(v138);
            }
            int v92 = *(float **)buf;
            unint64_t v138 = *(void **)buf;
            uint64_t v133 = *(float **)&buf[8];
            long long v139 = *(_OWORD *)&buf[8];
            int v93 = rand();
            int v94 = rand();
            if (!Phase::SpatialModeler::DirectivityHistogram::findImpactAngle_TS(v132, v40, (float *)&v137 + 1, (float *)&v137, (float)v93 * 4.6566e-10, (float)v94 * 4.6566e-10))
            {
              uint64_t v95 = 0;
              int v96 = __p[v79];
              do
              {
                v92[v95] = v77 * (float)(sqrtf(v92[v95]) * (float)(2 * v82 - 1));
                ++v95;
              }
              while (v95 != 10);
              if (v92 != v133)
              {
                int v97 = (v96 - a4) & ~((v96 - a4) >> 31);
                while (fabsf(*v92) <= v19)
                {
                  if (++v92 == v133) {
                    goto LABEL_140;
                  }
                }
                float v98 = (float)v97 / a8;
                unint64_t v100 = a5[1];
                unint64_t v99 = a5[2];
                if (v100 >= v99)
                {
                  uint64_t v103 = (uint64_t)(v100 - *a5) >> 6;
                  if ((unint64_t)(v103 + 1) >> 58) {
                    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                  }
                  uint64_t v104 = v99 - *a5;
                  uint64_t v105 = v104 >> 5;
                  if (v104 >> 5 <= (unint64_t)(v103 + 1)) {
                    uint64_t v105 = v103 + 1;
                  }
                  if ((unint64_t)v104 >= 0x7FFFFFFFFFFFFFC0) {
                    unint64_t v106 = 0x3FFFFFFFFFFFFFFLL;
                  }
                  else {
                    unint64_t v106 = v105;
                  }
                  long long v143 = a5 + 2;
                  if (v106) {
                    unint64_t v107 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Envelope<double>::SegmentInternal>>((uint64_t)(a5 + 2), v106);
                  }
                  else {
                    unint64_t v107 = 0;
                  }
                  *(void *)buf = v107;
                  *(void *)&uint8_t buf[8] = &v107[64 * v103];
                  *(void *)&uint8_t buf[16] = *(void *)&buf[8];
                  *(void *)&uint8_t buf[24] = &v107[64 * v106];
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::PhaseSpatialModelerMetadata_Octave(*(uint64_t *)&buf[8], (uint64_t)&v138, *(float *)&v137, *((float *)&v137 + 1), v98);
                  uint64_t v108 = (void *)*a5;
                  unint64_t v109 = a5[1];
                  uint64_t v110 = *(void *)&buf[8];
                  uint64_t v111 = *(void *)&buf[16];
                  if (v109 == *a5)
                  {
                    int64x2_t v116 = vdupq_n_s64(v109);
                  }
                  else
                  {
                    uint64_t v112 = *(void *)&buf[8] - 64;
                    do
                    {
                      *(void *)(v110 - 64) = &unk_26D476958;
                      v110 -= 64;
                      long long v113 = *(_OWORD *)(v109 - 56);
                      long long v114 = *(_OWORD *)(v109 - 40);
                      long long v115 = *(_OWORD *)(v109 - 24);
                      *(_DWORD *)(v110 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v109 - 8);
                      *(_OWORD *)(v110 + 40) = v115;
                      *(_OWORD *)(v110 + 24) = v114;
                      *(_OWORD *)(v110 + 8) = v113;
                      v112 -= 64;
                      v109 -= 64;
                    }
                    while ((void *)v109 != v108);
                    int64x2_t v116 = *(int64x2_t *)a5;
                  }
                  uint64_t v102 = a5;
                  unint64_t v101 = v111 + 64;
                  *a5 = v110;
                  a5[1] = v111 + 64;
                  *(int64x2_t *)&uint8_t buf[8] = v116;
                  uint64_t v117 = a5[2];
                  a5[2] = *(void *)&buf[24];
                  *(void *)&uint8_t buf[24] = v117;
                  *(void *)buf = v116.i64[0];
                  std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::~__split_buffer((uint64_t)buf);
                }
                else
                {
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::PhaseSpatialModelerMetadata_Octave(a5[1], (uint64_t)&v138, *(float *)&v137, *((float *)&v137 + 1), v98);
                  unint64_t v101 = v100 + 64;
                  uint64_t v102 = a5;
                  a5[1] = v100 + 64;
                }
                v102[1] = v101;
              }
            }
LABEL_140:
            ++v79;
          }
          while (v79 != v80);
          unint64_t v54 = __p;
          int v39 = v121;
          int v38 = v123;
LABEL_167:
          long long v135 = v54;
          goto LABEL_168;
        }
        goto LABEL_168;
      }
      uint64_t v62 = *((unsigned int *)v132 + 7);
      BOOL v63 = *((_DWORD *)v132 + 6) > v53 && *((unsigned char *)v132 + 36) == 0;
      uint64_t v64 = v63
          ? (_OWORD *)(*((void *)v132 + 1) + 4 * v62 * v53)
          : &Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
      uint64_t v65 = (uint64_t *)v140 + 3 * (v53 % 3);
      uint64_t v66 = *v65;
      if (v62 == 3) {
        break;
      }
      if (v62 == 31)
      {
        unsigned int v70 = Phase::sThirdOctaveBandFrequencies;
LABEL_87:
        Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v70, &v70[v62], (uint64_t)v64, (uint64_t)v64 + 4 * v62, Phase::sOctaveBandFrequencies, Phase::sThirdOctaveBandFrequencies, *v65);
        goto LABEL_94;
      }
      if (v62 == 10)
      {
        long long v67 = *v64;
        long long v68 = v64[1];
        *(void *)(v66 + 32) = *((void *)v64 + 4);
        *(_OWORD *)(v66 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v68;
      }
      else
      {
        if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
        {
          float v71 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)v43) + 1184);
          if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = "GeneratePlaneWaveList.hpp";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 177;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&unsigned char buf[20] = v62;
            _os_log_impl(&dword_221E5E000, v71, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
          }
          Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
        }
        *(void *)(v66 + 32) = 0;
        long long v67 = 0uLL;
        *(_OWORD *)(v66 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
      }
      *(_OWORD *)uint64_t v66 = v67;
LABEL_94:
      unint64_t v54 = __p;
      unint64_t v55 = (unint64_t)((char *)v135 - (char *)__p) >> 2;
      if (v55)
      {
        int v60 = (char *)*((void *)v140 + 3 * (v40 % 3));
        unsigned int v56 = *((_DWORD *)v132 + 6);
        if ((int)v56 <= v128) {
          uint64_t v61 = (char *)*((void *)v140 + 3 * ((v56 - 1) % 3));
        }
        else {
          uint64_t v61 = (char *)*v65;
        }
        goto LABEL_99;
      }
LABEL_168:
      unsigned int v40 = v128;
LABEL_169:
      if (++v38 == v126) {
        goto LABEL_170;
      }
    }
    unsigned int v70 = Phase::sThreeBandFrequencies;
    goto LABEL_87;
  }
LABEL_170:
  for (uint64_t j = 0; j != -72; j -= 24)
  {
    int v119 = *(void **)((char *)&v140[3] + j);
    if (v119)
    {
      *(void *)((char *)&v140[3] + j + 8) = v119;
      operator delete(v119);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  if (v138) {
    operator delete(v138);
  }
}

void sub_221F505C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v34 = 0;
  while (1)
  {
    unint64_t v35 = *(void **)(&a33 + v34 + 48);
    if (v35)
    {
      *(void *)(&a33 + v34 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v35;
      operator delete(v35);
    }
    v34 -= 24;
    if (v34 == -72)
    {
      if (__p) {
        operator delete(__p);
      }
      if (a30) {
        operator delete(a30);
      }
      _Unwind_Resume(exception_object);
    }
  }
}

uint64_t Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>(uint64_t result, uint64_t *a2, char a3)
{
  if (a2)
  {
    __n128 v3 = (uint64_t *)result;
    uint64_t result = *(void *)result;
    uint64_t v4 = v3[1];
    if (result != v4)
    {
      unint64_t v6 = (v4 - result) >> 6;
      unsigned int v7 = (**(uint64_t (***)(uint64_t))result)(result);
      Phase::SpatialModeler::AllocMetadata<float>(a2, v6, (int)v7);
      uint64_t v8 = 0;
      uint64_t v9 = *v3;
      uint64_t v10 = a2[1];
      uint64_t v11 = a2[7];
      uint64_t v12 = a2[18];
      long long v28 = a2;
      uint64_t v13 = a2[13];
      uint64_t v14 = (float *)(v13 + 16);
      if (v6 <= 1) {
        uint64_t v15 = 1;
      }
      else {
        uint64_t v15 = v6;
      }
      uint64_t v16 = v7;
      uint64_t v17 = 4 * *(void *)(v13 + 8);
      uint64_t v18 = (float *)(v9 + 20);
      uint64_t result = 1127481344;
      uint64_t v29 = v17;
      uint64_t v30 = v9;
      do
      {
        uint64_t v19 = v9 + (v8 << 6);
        float v20 = *(float *)(v19 + 8);
        float v21 = (float)((float)(180.0 - *(float *)(v19 + 12))
                    - (float)(floorf((float)(180.0 - *(float *)(v19 + 12)) / 360.0) * 360.0))
            + 0.0;
        if (v21 >= 360.0)
        {
          uint64_t v22 = v15;
          float v21 = nextafterf(360.0, 0.0);
          uint64_t result = 1127481344;
          uint64_t v17 = v29;
          uint64_t v9 = v30;
          uint64_t v15 = v22;
        }
        uint64_t v23 = v10 + 12 * v8;
        *(_DWORD *)uint64_t v23 = 1065353216;
        *(float *)(v23 + 4) = 90.0 - v20;
        *(float *)(v23 + 8) = v21;
        *(_DWORD *)(v11 + 4 * v8) = *(_DWORD *)(v19 + 16);
        *(unsigned char *)(v12 + v8) = 0;
        uint64_t v24 = v18;
        BOOL v25 = v14;
        uint64_t v26 = v16;
        if ((int)v16 >= 1)
        {
          do
          {
            *BOOL v25 = fabsf(*v24);
            if (*v24 < 0.0) {
              *(unsigned char *)(v12 + v8) = 1;
            }
            ++v25;
            ++v24;
            --v26;
          }
          while (v26);
        }
        ++v8;
        uint64_t v14 = (float *)((char *)v14 + v17);
        v18 += 16;
      }
      while (v8 != v15);
      *((unsigned char *)v28 + 20Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a3;
      *((_DWORD *)v28 + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
    }
  }
  return result;
}

void Phase::SpatialModeler::computePlaneWaveList_RayTracing<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(uint64_t a1, char a2, unsigned int a3, int a4, void *a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13)
{
  uint64_t v155 = *MEMORY[0x263EF8340];
  float v19 = __exp10f(fabsf(a9) / -20.0);
  float v20 = *(float *)(a1 + 16);
  if (*(float *)(a1 + 20) < a12) {
    float v21 = *(float *)(a1 + 20);
  }
  else {
    float v21 = a12;
  }
  uint64_t v149 = 0;
  long long v150 = 0uLL;
  long long v147 = 0;
  uint64_t v148 = 0;
  std::string __p = 0;
  uint64_t v146 = 0;
  uint64_t v152 = 0;
  memset(v151, 0, sizeof(v151));
  long long v143 = (Phase::SpatialModeler::DirectivityHistogram *)a1;
  int v132 = *(_DWORD *)(a1 + 28);
  if (v132 == 31) {
    goto LABEL_25;
  }
  for (uint64_t i = 0; i != 72; i += 24)
    std::vector<float>::resize((uint64_t)v151 + i, 0x1FuLL);
  uint64_t v24 = *((unsigned int *)v143 + 7);
  if (*((_DWORD *)v143 + 6)) {
    BOOL v25 = *((unsigned char *)v143 + 36) == 0;
  }
  else {
    BOOL v25 = 0;
  }
  if (v25) {
    uint64_t v26 = (long long *)*((void *)v143 + 1);
  }
  else {
    uint64_t v26 = (long long *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
  }
  uint64_t v27 = *(_OWORD **)&v151[0];
  switch(v24)
  {
    case 3:
      uint64_t v34 = Phase::sThreeBandFrequencies;
      goto LABEL_19;
    case 0xA:
      uint64_t v34 = Phase::sOctaveBandFrequencies;
LABEL_19:
      Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v34, &v34[v24], (uint64_t)v26, (uint64_t)v26 + 4 * v24, Phase::sThirdOctaveBandFrequencies, (float *)&xmmword_2220A5C40, *(uint64_t *)&v151[0]);
      break;
    case 0x1F:
      long long v28 = *v26;
      long long v29 = v26[1];
      long long v30 = v26[3];
      *(_OWORD *)(*(void *)&v151[0] + 32) = v26[2];
      v27[3] = v30;
      *uint64_t v27 = v28;
      v27[1] = v29;
      long long v31 = v26[4];
      long long v32 = v26[5];
      long long v33 = v26[6];
      *(_OWORD *)((char *)v27 + 108) = *(long long *)((char *)v26 + 108);
      void v27[5] = v32;
      v27[6] = v33;
      v27[4] = v31;
      break;
    default:
      if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
      {
        unint64_t v35 = **(NSObject ***)(Phase::Logger::GetInstance(v23) + 1184);
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "GeneratePlaneWaveList.hpp";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 177;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&unsigned char buf[20] = v24;
          _os_log_impl(&dword_221E5E000, v35, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
        }
        Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
      }
      *(_OWORD *)((char *)v27 + 108) = 0u;
      void v27[5] = 0u;
      v27[6] = 0u;
      v27[3] = 0u;
      v27[4] = 0u;
      v27[1] = 0u;
      v27[2] = 0u;
      *uint64_t v27 = 0u;
      break;
  }
LABEL_25:
  uint64_t v37 = (void *)*a5;
  uint64_t v36 = a5[1];
  if (v36 != *a5)
  {
    uint64_t v38 = v36 - 144;
    int v39 = (void *)(v36 - 144);
    unsigned int v40 = (void *)(v36 - 144);
    do
    {
      uint64_t v41 = *v40;
      v40 -= 18;
      (*(void (**)(void *))(v41 + 16))(v39);
      v38 -= 144;
      BOOL v25 = v39 == v37;
      int v39 = v40;
    }
    while (!v25);
  }
  a5[1] = v37;
  if ((a2 & 1) == 0) {
    a3 = time(0);
  }
  srand(a3);
  int v42 = vcvtps_u32_f32(a8 * a11);
  signed int v137 = vcvtps_u32_f32(v21 * a8);
  int v43 = v132;
  if (v42 < v137)
  {
    unsigned int v44 = 0;
    float v45 = v20 * a8;
    double v131 = a7 * 12.5663706 * a7 * a7;
    float v138 = 0.0;
    while (1)
    {
      if (v42 % 50 == 1)
      {
        float v46 = a10;
        if (a6 >= 0.00000011921)
        {
          float v46 = v131 * (float)((float)v42 / a8) * (float)((float)v42 / a8) / a6;
          if (v46 > a10) {
            float v46 = a10;
          }
        }
        float v138 = (float)(1.0 / a8) * v46;
      }
      unint64_t v47 = (void *)rand();
      if ((float)((float)(int)v47 * 4.6566e-10) < v138)
      {
        uint64_t v48 = v146;
        if (v146 >= v147)
        {
          unint64_t v47 = __p;
          uint64_t v50 = v146 - __p;
          unint64_t v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 62) {
            std::vector<int>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v52 = (char *)v147 - (char *)__p;
          if (((char *)v147 - (char *)__p) >> 1 > v51) {
            unint64_t v51 = v52 >> 1;
          }
          if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v53 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v53 = v51;
          }
          if (v53)
          {
            unint64_t v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v147, v53);
            unint64_t v47 = __p;
            uint64_t v48 = v146;
          }
          else
          {
            unint64_t v54 = 0;
          }
          unint64_t v55 = (int *)&v54[4 * v50];
          *unint64_t v55 = v42;
          unint64_t v49 = v55 + 1;
          while (v48 != v47)
          {
            int v56 = *--v48;
            *--unint64_t v55 = v56;
          }
          std::string __p = v55;
          long long v147 = (int *)&v54[4 * v53];
          if (v47) {
            operator delete(v47);
          }
        }
        else
        {
          *uint64_t v146 = v42;
          unint64_t v49 = v146 + 1;
        }
        uint64_t v146 = v49;
      }
      unsigned int v57 = (int)(float)((float)v42 / v45);
      if ((int)v44 >= (int)v57) {
        goto LABEL_167;
      }
      int v139 = (int)(float)((float)v42 / v45);
      if (v43 == 31)
      {
        BOOL v58 = __p;
        unint64_t v59 = (unint64_t)((char *)v146 - (char *)__p) >> 2;
        if (v59)
        {
          unsigned int v60 = *((_DWORD *)v143 + 6);
          int v61 = *((_DWORD *)v143 + 7);
          BOOL v62 = v60 > v44 && *((unsigned char *)v143 + 36) == 0;
          uint64_t v63 = *((void *)v143 + 1);
          if (v62) {
            uint64_t v64 = (char *)(v63 + 4 * v61 * v44);
          }
          else {
            uint64_t v64 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          if ((int)v60 <= v139)
          {
            float v77 = (char *)(v63 + 4 * v61 * (v60 - 1));
            if (!v60) {
              float v77 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            if (*((unsigned char *)v143 + 36)) {
              uint64_t v65 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else {
              uint64_t v65 = v77;
            }
          }
          else if (*((unsigned char *)v143 + 36) || v60 <= v139)
          {
            uint64_t v65 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
          }
          else
          {
            uint64_t v65 = (char *)(v63 + 4 * (v61 * v139));
          }
LABEL_97:
          unsigned int v80 = v44 - 1;
          if ((int)v44 < 1)
          {
            if (v43 == 31)
            {
              if (*((unsigned char *)v143 + 36)) {
                BOOL v82 = 1;
              }
              else {
                BOOL v82 = v60 == 0;
              }
              if (v82) {
                int v81 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              }
              else {
                int v81 = (char *)*((void *)v143 + 1);
              }
            }
            else
            {
              int v81 = *(char **)&v151[0];
            }
          }
          else if (v43 == 31)
          {
            if (*((unsigned char *)v143 + 36))
            {
              int v81 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
            }
            else
            {
              int v81 = (char *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
              if (v60 > v80) {
                int v81 = (char *)(*((void *)v143 + 1) + 4 * *((_DWORD *)v143 + 7) * v80);
              }
            }
          }
          else
          {
            int v81 = (char *)*((void *)v151 + 3 * (v80 % 3));
          }
          float v83 = 1.0;
          if (v59 >= 2) {
            float v83 = sqrtf(1.0 / (float)v59);
          }
          uint64_t v84 = 0;
          float v85 = v83 * a13;
          unsigned int v86 = (float)((float)((float)(*((float *)v143 + 4) * (float)v44) * a8) + 0.5);
          while (*(float *)&v81[v84] <= 1.1755e-37
               && *(float *)&v64[v84] <= 1.1755e-37
               && *(float *)&v65[v84] <= 1.1755e-37)
          {
            v84 += 4;
            if (v84 == 124) {
              goto LABEL_165;
            }
          }
          int v134 = v42;
          uint64_t v87 = 0;
          uint64_t v88 = v59;
          do
          {
            int v89 = rand();
            if (v89 >= 0) {
              int v90 = v89 & 1;
            }
            else {
              int v90 = -(v89 & 1);
            }
            int v91 = __p[v87];
            int v92 = rand();
            float v93 = (float)(v91 - v86) / v45;
            if (v93 < 0.0) {
              float v93 = 0.0;
            }
            if (v93 <= 1.0) {
              float v94 = v93;
            }
            else {
              float v94 = 1.0;
            }
            std::vector<float>::vector(buf, 0x1FuLL);
            float v95 = (float)v92 * 4.6566e-10;
            uint64_t v96 = *(void *)buf;
            uint64_t v97 = 0;
            if (v94 >= 0.5)
            {
              float v99 = (float)(v95 * (float)((float)(v94 + -0.5) + (float)(v94 + -0.5)))
                  * (float)(v95 * (float)((float)(v94 + -0.5) + (float)(v94 + -0.5)));
              do
              {
                *(float *)(v96 + v9std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = (float)(v99 * *(float *)&v65[v97])
                                      + (float)((float)(1.0 - v99) * *(float *)&v64[v97]);
                v97 += 4;
              }
              while (v97 != 124);
            }
            else
            {
              float v98 = (float)(v95 * (float)((float)(0.5 - v94) + (float)(0.5 - v94)))
                  * (float)(v95 * (float)((float)(0.5 - v94) + (float)(0.5 - v94)));
              do
              {
                *(float *)(v96 + v9std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = (float)(v98 * *(float *)&v81[v97])
                                      + (float)((float)(1.0 - v98) * *(float *)&v64[v97]);
                v97 += 4;
              }
              while (v97 != 124);
            }
            if (v149) {
              operator delete(v149);
            }
            unint64_t v100 = *(float **)buf;
            uint64_t v149 = *(void **)buf;
            uint64_t v144 = *(float **)&buf[8];
            long long v150 = *(_OWORD *)&buf[8];
            int v101 = rand();
            int v102 = rand();
            if (!Phase::SpatialModeler::DirectivityHistogram::findImpactAngle_TS(v143, v44, (float *)&v148 + 1, (float *)&v148, (float)v101 * 4.6566e-10, (float)v102 * 4.6566e-10))
            {
              uint64_t v103 = 0;
              int v104 = __p[v87];
              do
              {
                v100[v103] = v85 * (float)(sqrtf(v100[v103]) * (float)(2 * v90 - 1));
                ++v103;
              }
              while (v103 != 31);
              if (v100 != v144)
              {
                int v105 = (v104 - a4) & ~((v104 - a4) >> 31);
                while (fabsf(*v100) <= v19)
                {
                  if (++v100 == v144) {
                    goto LABEL_138;
                  }
                }
                float v106 = (float)v105 / a8;
                unint64_t v108 = a5[1];
                unint64_t v107 = a5[2];
                if (v108 >= v107)
                {
                  unint64_t v111 = 0x8E38E38E38E38E39 * ((uint64_t)(v108 - *a5) >> 4);
                  unint64_t v112 = v111 + 1;
                  if (v111 + 1 > 0x1C71C71C71C71C7) {
                    std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
                  }
                  unint64_t v113 = 0x8E38E38E38E38E39 * ((uint64_t)(v107 - *a5) >> 4);
                  if (2 * v113 > v112) {
                    unint64_t v112 = 2 * v113;
                  }
                  if (v113 >= 0xE38E38E38E38E3) {
                    unint64_t v114 = 0x1C71C71C71C71C7;
                  }
                  else {
                    unint64_t v114 = v112;
                  }
                  uint64_t v154 = a5 + 2;
                  if (v114) {
                    long long v115 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>((uint64_t)(a5 + 2), v114);
                  }
                  else {
                    long long v115 = 0;
                  }
                  *(void *)buf = v115;
                  *(void *)&uint8_t buf[8] = &v115[144 * v111];
                  *(void *)&uint8_t buf[16] = *(void *)&buf[8];
                  *(void *)&uint8_t buf[24] = &v115[144 * v114];
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::PhaseSpatialModelerMetadata_ThirdOctave(*(uint64_t *)&buf[8], (char **)&v149, *(float *)&v148, *((float *)&v148 + 1), v106);
                  int64x2_t v116 = (void *)*a5;
                  unint64_t v117 = a5[1];
                  uint64_t v118 = *(void *)&buf[8];
                  uint64_t v119 = *(void *)&buf[16];
                  if (v117 == *a5)
                  {
                    int64x2_t v127 = vdupq_n_s64(v117);
                  }
                  else
                  {
                    uint64_t v120 = *(void *)&buf[8] - 144;
                    do
                    {
                      *(void *)(v118 - 144) = &unk_26D476988;
                      v118 -= 144;
                      *(_OWORD *)(v118 + 8) = *(_OWORD *)(v117 - 136);
                      long long v121 = *(_OWORD *)(v117 - 120);
                      long long v122 = *(_OWORD *)(v117 - 104);
                      long long v123 = *(_OWORD *)(v117 - 88);
                      *(_OWORD *)(v118 + 72) = *(_OWORD *)(v117 - 72);
                      *(_OWORD *)(v118 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v123;
                      *(_OWORD *)(v118 + 40) = v122;
                      *(_OWORD *)(v118 + 24) = v121;
                      long long v124 = *(_OWORD *)(v117 - 56);
                      long long v125 = *(_OWORD *)(v117 - 40);
                      long long v126 = *(_OWORD *)(v117 - 24);
                      *(void *)(v118 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(v117 - 8);
                      *(_OWORD *)(v118 + 120) = v126;
                      *(_OWORD *)(v118 + 104) = v125;
                      *(_OWORD *)(v118 + 88) = v124;
                      v120 -= 144;
                      v117 -= 144;
                    }
                    while ((void *)v117 != v116);
                    int64x2_t v127 = *(int64x2_t *)a5;
                  }
                  uint64_t v110 = a5;
                  unint64_t v109 = v119 + 144;
                  *a5 = v118;
                  a5[1] = v119 + 144;
                  *(int64x2_t *)&uint8_t buf[8] = v127;
                  uint64_t v128 = a5[2];
                  a5[2] = *(void *)&buf[24];
                  *(void *)&uint8_t buf[24] = v128;
                  *(void *)buf = v127.i64[0];
                  std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::~__split_buffer((uint64_t)buf);
                }
                else
                {
                  Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::PhaseSpatialModelerMetadata_ThirdOctave(a5[1], (char **)&v149, *(float *)&v148, *((float *)&v148 + 1), v106);
                  unint64_t v109 = v108 + 144;
                  uint64_t v110 = a5;
                  a5[1] = v108 + 144;
                }
                v110[1] = v109;
              }
            }
LABEL_138:
            ++v87;
          }
          while (v87 != v88);
          BOOL v58 = __p;
          int v43 = v132;
          int v42 = v134;
LABEL_165:
          uint64_t v146 = v58;
          goto LABEL_166;
        }
        goto LABEL_166;
      }
      uint64_t v66 = *((unsigned int *)v143 + 7);
      BOOL v67 = *((_DWORD *)v143 + 6) > v57 && *((unsigned char *)v143 + 36) == 0;
      long long v68 = v67
          ? (long long *)(*((void *)v143 + 1) + 4 * v66 * v57)
          : (long long *)&Phase::SpatialModeler::EnergyHistogram::s_emptyTS;
      int v69 = (uint64_t *)v151 + 3 * (v57 % 3);
      unsigned int v70 = (_OWORD *)*v69;
      if (v66 == 3) {
        break;
      }
      if (v66 == 10)
      {
        unsigned int v78 = Phase::sOctaveBandFrequencies;
LABEL_86:
        Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(v78, &v78[v66], (uint64_t)v68, (uint64_t)v68 + 4 * v66, Phase::sThirdOctaveBandFrequencies, (float *)&xmmword_2220A5C40, *v69);
        goto LABEL_92;
      }
      if (v66 == 31)
      {
        long long v71 = *v68;
        long long v72 = v68[1];
        long long v73 = v68[3];
        v70[2] = v68[2];
        v70[3] = v73;
        _OWORD *v70 = v71;
        v70[1] = v72;
        long long v74 = v68[4];
        long long v75 = v68[5];
        long long v76 = v68[6];
        *(_OWORD *)((char *)v70 + 108) = *(long long *)((char *)v68 + 108);
        v70[5] = v75;
        v70[6] = v76;
        v70[4] = v74;
      }
      else
      {
        if ((Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce & 1) == 0)
        {
          uint64_t v79 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)v47) + 1184);
          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136315650;
            *(void *)&uint8_t buf[4] = "GeneratePlaneWaveList.hpp";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 177;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&unsigned char buf[20] = v66;
            _os_log_impl(&dword_221E5E000, v79, OS_LOG_TYPE_ERROR, "%25s:%-5d Unsupported subband count: %zu\n", buf, 0x1Cu);
          }
          Phase::SpatialModeler::convertSubbandCountMagnitudes(unsigned long,unsigned long,float const*,float *)::loggedOnce = 1;
        }
        *(_OWORD *)((char *)v70 + 108) = 0u;
        v70[5] = 0u;
        v70[6] = 0u;
        v70[3] = 0u;
        v70[4] = 0u;
        v70[1] = 0u;
        v70[2] = 0u;
        _OWORD *v70 = 0u;
      }
LABEL_92:
      BOOL v58 = __p;
      unint64_t v59 = (unint64_t)((char *)v146 - (char *)__p) >> 2;
      if (v59)
      {
        uint64_t v64 = (char *)*((void *)v151 + 3 * (v44 % 3));
        unsigned int v60 = *((_DWORD *)v143 + 6);
        if ((int)v60 <= v139) {
          uint64_t v65 = (char *)*((void *)v151 + 3 * ((v60 - 1) % 3));
        }
        else {
          uint64_t v65 = (char *)*v69;
        }
        goto LABEL_97;
      }
LABEL_166:
      unsigned int v44 = v139;
LABEL_167:
      if (++v42 == v137) {
        goto LABEL_168;
      }
    }
    unsigned int v78 = Phase::sThreeBandFrequencies;
    goto LABEL_86;
  }
LABEL_168:
  for (uint64_t j = 0; j != -72; j -= 24)
  {
    __int16 v130 = *(void **)((char *)&v151[3] + j);
    if (v130)
    {
      *(void *)((char *)&v151[3] + j + 8) = v130;
      operator delete(v130);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  if (v149) {
    operator delete(v149);
  }
}

void sub_221F514C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v34 = 0;
  while (1)
  {
    unint64_t v35 = *(void **)(&a33 + v34 + 48);
    if (v35)
    {
      *(void *)(&a33 + v34 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v35;
      operator delete(v35);
    }
    v34 -= 24;
    if (v34 == -72)
    {
      if (__p) {
        operator delete(__p);
      }
      if (a30) {
        operator delete(a30);
      }
      _Unwind_Resume(exception_object);
    }
  }
}

uint64_t Phase::SpatialModeler::convertRayTracingPlaneWaveListToDirectionalMetadata<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>(uint64_t result, uint64_t *a2, char a3)
{
  if (a2)
  {
    __n128 v3 = (uint64_t *)result;
    uint64_t result = *(void *)result;
    uint64_t v4 = v3[1];
    if (result != v4)
    {
      uint64_t v6 = (unsigned __int128)((v4 - result) * (__int128)0xE38E38E38E38E39) >> 64;
      unint64_t v7 = (v6 >> 3) + ((unint64_t)v6 >> 63);
      unsigned int v8 = (**(uint64_t (***)(uint64_t))result)(result);
      Phase::SpatialModeler::AllocMetadata<float>(a2, v7, (int)v8);
      uint64_t v9 = 0;
      uint64_t v10 = *v3;
      uint64_t v11 = a2[1];
      uint64_t v12 = a2[7];
      uint64_t v13 = a2[13];
      uint64_t v14 = (float *)(v13 + 16);
      uint64_t v15 = *(void *)(v13 + 8);
      if (v7 <= 1) {
        uint64_t v16 = 1;
      }
      else {
        uint64_t v16 = v7;
      }
      uint64_t v17 = v8;
      uint64_t v18 = 4 * v15;
      long long v31 = a2;
      uint64_t v32 = v8;
      uint64_t v19 = a2[18];
      float v20 = (float *)(v10 + 20);
      uint64_t result = 1119092736;
      do
      {
        uint64_t v21 = v10 + 144 * v9;
        float v22 = *(float *)(v21 + 8);
        float v23 = (float)((float)(180.0 - *(float *)(v21 + 12))
                    - (float)(floorf((float)(180.0 - *(float *)(v21 + 12)) / 360.0) * 360.0))
            + 0.0;
        if (v23 >= 360.0)
        {
          uint64_t v24 = v11;
          uint64_t v25 = v10;
          float v23 = nextafterf(360.0, 0.0);
          uint64_t result = 1119092736;
          uint64_t v17 = v32;
          uint64_t v10 = v25;
          uint64_t v11 = v24;
        }
        uint64_t v26 = v11 + 12 * v9;
        *(_DWORD *)uint64_t v26 = 1065353216;
        *(float *)(v26 + 4) = 90.0 - v22;
        *(float *)(v26 + 8) = v23;
        *(_DWORD *)(v12 + 4 * v9) = *(_DWORD *)(v10 + 144 * v9 + 16);
        *(unsigned char *)(v19 + v9) = 0;
        uint64_t v27 = v20;
        long long v28 = v14;
        uint64_t v29 = v17;
        if ((int)v17 >= 1)
        {
          do
          {
            *long long v28 = fabsf(*v27);
            if (*v27 < 0.0) {
              *(unsigned char *)(v19 + v9) = 1;
            }
            ++v28;
            ++v27;
            --v29;
          }
          while (v29);
        }
        ++v9;
        uint64_t v14 = (float *)((char *)v14 + v18);
        v20 += 36;
      }
      while (v9 != v16);
      *((unsigned char *)v31 + 20Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a3;
      *((_DWORD *)v31 + 5Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
    }
  }
  return result;
}

void Phase::GetValuesFromFrequencyResponse<float const*,float const*,float const*,float *,&float Phase::Square<float>,&float Phase::SquareRoot<float>>(float *a1, float *a2, uint64_t a3, uint64_t a4, float *a5, float *a6, uint64_t a7)
{
  uint64_t v10 = (char *)a2 - (char *)a1;
  if (a2 != a1)
  {
    for (uint64_t i = a1 + 1; i != a2; ++i)
    {
      float v13 = *(i - 1);
      float v12 = *i;
      if (v12 < v13) {
        __assert_rtn("GetValuesFromFrequencyResponse", "FrequencyResponse.hpp", 262, "std::is_sorted(inFrequenciesFirst, inFrequenciesLast)");
      }
    }
  }
  if (a5 != a6)
  {
    for (uint64_t j = a5 + 1; j != a6; ++j)
    {
      float v16 = *(j - 1);
      float v15 = *j;
      if (v15 < v16) {
        __assert_rtn("GetValuesFromFrequencyResponse", "FrequencyResponse.hpp", 263, "std::is_sorted(inOutputFrequenciesFirst, inOutputFrequenciesLast)");
      }
    }
  }
  Phase::GetBandsFromCenterFrequencies<float const*,float>(a1, a2, (float **)v89, 22000.0);
  Phase::GetBandsFromCenterFrequencies<float const*,float>(a5, a6, (float **)v88, 22000.0);
  std::string __p = 0;
  unsigned int v86 = 0;
  uint64_t v87 = 0;
  BOOL v82 = 0;
  float v83 = 0;
  uint64_t v84 = 0;
  uint64_t v79 = 0;
  int v81 = 0;
  if ((char *)a6 - (char *)a5 > 0)
  {
    uint64_t v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    uint64_t v21 = a6 - a5;
    uint64_t v22 = v10 >> 2;
    uint64_t v23 = (v10 >> 2) - 1;
    if (v21 <= 1) {
      uint64_t v21 = 1;
    }
    uint64_t v77 = v21;
    do
    {
      uint64_t v24 = (float *)((char *)v88[0] + 8 * v20);
      float v25 = *v24;
      float v26 = v24[1];
      unsigned int v86 = (float *)__p;
      float v83 = v18;
      unsigned int v80 = v17;
      if (v19 < v22)
      {
        uint64_t v27 = (float *)((char *)v89[0] + 8 * v19);
        float v28 = *v27;
        float v29 = v27[1];
        if (v26 < v29) {
          float v29 = v26;
        }
        if (v28 >= v25) {
          float v30 = *v27;
        }
        else {
          float v30 = v25;
        }
        float v31 = fmaxf(v29 - v30, 0.0);
        float v32 = v26;
        uint64_t v33 = v19;
        if (v31 == 0.0)
        {
LABEL_62:
          v19 -= v28 != v32;
        }
        else
        {
          while (1)
          {
            uint64_t v34 = v86;
            if (v86 >= v87)
            {
              uint64_t v36 = (float *)__p;
              uint64_t v37 = ((char *)v86 - (unsigned char *)__p) >> 2;
              unint64_t v38 = v37 + 1;
              if ((unint64_t)(v37 + 1) >> 62) {
                std::vector<float>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v39 = (char *)v87 - (unsigned char *)__p;
              if (((char *)v87 - (unsigned char *)__p) >> 1 > v38) {
                unint64_t v38 = v39 >> 1;
              }
              if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL) {
                unint64_t v40 = 0x3FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v40 = v38;
              }
              if (v40)
              {
                uint64_t v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v87, v40);
                uint64_t v36 = (float *)__p;
                uint64_t v34 = v86;
              }
              else
              {
                uint64_t v41 = 0;
              }
              int v42 = (float *)&v41[4 * v37];
              float *v42 = v31;
              unint64_t v35 = v42 + 1;
              while (v34 != v36)
              {
                int v43 = *((_DWORD *)v34-- - 1);
                *((_DWORD *)v42-- - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v43;
              }
              std::string __p = v42;
              unsigned int v86 = v35;
              uint64_t v87 = (float *)&v41[4 * v40];
              if (v36) {
                operator delete(v36);
              }
            }
            else
            {
              *unsigned int v86 = v31;
              unint64_t v35 = v34 + 1;
            }
            unsigned int v86 = v35;
            unsigned int v44 = v83;
            if (v83 >= v84)
            {
              float v45 = (char *)v82;
              uint64_t v46 = (v83 - (unsigned char *)v82) >> 3;
              unint64_t v47 = v46 + 1;
              if ((unint64_t)(v46 + 1) >> 61) {
                std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
              }
              uint64_t v48 = v84 - (unsigned char *)v82;
              if ((v84 - (unsigned char *)v82) >> 2 > v47) {
                unint64_t v47 = v48 >> 2;
              }
              if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v49 = v47;
              }
              if (v49)
              {
                uint64_t v50 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>((uint64_t)&v84, v49);
                float v45 = (char *)v82;
                unsigned int v44 = v83;
              }
              else
              {
                uint64_t v50 = 0;
              }
              unint64_t v51 = (uint64_t *)&v50[8 * v46];
              uint64_t *v51 = v19;
              uint64_t v18 = (char *)(v51 + 1);
              while (v44 != v45)
              {
                uint64_t v52 = *((void *)v44 - 1);
                v44 -= 8;
                *--unint64_t v51 = v52;
              }
              BOOL v82 = v51;
              float v83 = v18;
              uint64_t v84 = &v50[8 * v49];
              if (v45) {
                operator delete(v45);
              }
            }
            else
            {
              *(void *)float v83 = v19;
              uint64_t v18 = v44 + 8;
            }
            float v83 = v18;
            if (v19 == v23) {
              uint64_t v33 = v19;
            }
            if (++v19 == v22) {
              break;
            }
            unint64_t v53 = (float *)((char *)v89[0] + 8 * v19);
            float v28 = *v53;
            float v54 = v53[1];
            unint64_t v55 = (float *)((char *)v88[0] + 8 * v20);
            float v56 = *v55;
            float v32 = v55[1];
            if (v32 < v54) {
              float v54 = v55[1];
            }
            if (v28 >= v56) {
              float v56 = v28;
            }
            float v31 = fmaxf(v54 - v56, 0.0);
            if (v31 == 0.0) {
              goto LABEL_62;
            }
          }
          uint64_t v19 = v33;
        }
      }
      unsigned int v57 = v80;
      if (v18 == v82)
      {
        float v60 = 0.0;
      }
      else
      {
        unint64_t v58 = 0;
        float v59 = v26 - v25;
        float v60 = 0.0;
        int v61 = v80;
        uint64_t v18 = (char *)v82;
        do
        {
          float v62 = *((float *)__p + v58) / v59;
          float v63 = *(float *)(a3 + 4 * *(void *)&v18[8 * v58]);
          float v64 = v62 * (float)(v63 * v63);
          if (v61 >= v81)
          {
            uint64_t v65 = v79;
            uint64_t v66 = v61 - v79;
            unint64_t v67 = v66 + 1;
            if ((unint64_t)(v66 + 1) >> 62) {
              std::vector<float>::__throw_length_error[abi:ne180100]();
            }
            uint64_t v68 = (char *)v81 - (char *)v79;
            if (((char *)v81 - (char *)v79) >> 1 > v67) {
              unint64_t v67 = v68 >> 1;
            }
            if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFFCLL) {
              unint64_t v69 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v69 = v67;
            }
            if (v69)
            {
              unsigned int v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v81, v69);
              uint64_t v65 = v79;
              int v61 = v80;
            }
            else
            {
              unsigned int v70 = 0;
            }
            long long v71 = (float *)&v70[4 * v66];
            float *v71 = v64;
            unsigned int v57 = v71 + 1;
            while (v61 != v65)
            {
              int v72 = *((_DWORD *)v61-- - 1);
              *((_DWORD *)v71-- - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v72;
            }
            uint64_t v79 = v71;
            int v81 = (float *)&v70[4 * v69];
            if (v65) {
              operator delete(v65);
            }
          }
          else
          {
            float *v61 = v64;
            unsigned int v57 = v61 + 1;
          }
          float v60 = v60 + v62;
          unsigned int v80 = v57;
          ++v58;
          uint64_t v18 = (char *)v82;
          int v61 = v57;
        }
        while (v58 < (v83 - (unsigned char *)v82) >> 3);
      }
      uint64_t v17 = v79;
      double v73 = 0.0;
      if (v79 != v57)
      {
        long long v74 = v79;
        do
        {
          float v75 = *v74++;
          double v73 = v73 + v75;
        }
        while (v74 != v57);
      }
      float v76 = v73;
      uint64_t v23 = (v10 >> 2) - 1;
      *(float *)(a7 + 4 * v20++) = sqrtf(v76 / v60);
    }
    while (v20 != v77);
    if (v79)
    {
      operator delete(v79);
      uint64_t v18 = (char *)v82;
    }
    if (v18)
    {
      float v83 = v18;
      operator delete(v18);
    }
  }
  if (__p)
  {
    unsigned int v86 = (float *)__p;
    operator delete(__p);
  }
  if (v88[0])
  {
    v88[1] = v88[0];
    operator delete(v88[0]);
  }
  if (v89[0])
  {
    v89[1] = v89[0];
    operator delete(v89[0]);
  }
}

void sub_221F51CAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

Phase::Logger *Phase::GetBandsFromCenterFrequencies<float const*,float>@<X0>(float *a1@<X0>, float *a2@<X1>, float **a3@<X8>, float a4@<S0>)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  uint64_t v8 = (char *)a2 - (char *)a1;
  int64_t v9 = a2 - a1;
  *(void *)uint64_t v41 = 0;
  uint64_t result = (Phase::Logger *)std::vector<Phase::FrequencyBand<float>>::vector(a3, v9, v41);
  uint64_t v11 = *a3;
  **a3 = 10.0;
  if (v9 == 31)
  {
    if (a1 == a2)
    {
      BOOL v15 = 0;
      BOOL v20 = 1;
    }
    else
    {
      uint64_t v17 = a1 + 1;
      uint64_t v18 = (float *)&Phase::sThirdOctaveBandFrequencies;
      do
      {
        float v19 = *v18++;
        BOOL v20 = *(v17 - 1) == v19;
        BOOL v21 = *(v17 - 1) != v19 || v17 == a2;
        ++v17;
      }
      while (!v21);
      BOOL v15 = 0;
    }
  }
  else
  {
    if (v9 != 10)
    {
      BOOL v15 = 0;
LABEL_20:
      BOOL v20 = 0;
      goto LABEL_21;
    }
    if (a1 != a2)
    {
      float v12 = a1 + 1;
      float v13 = (float *)&Phase::sOctaveBandFrequencies;
      do
      {
        float v14 = *v13++;
        BOOL v15 = *(v12 - 1) == v14;
        BOOL v16 = *(v12 - 1) != v14 || v12 == a2;
        ++v12;
      }
      while (!v16);
      goto LABEL_20;
    }
    BOOL v20 = 0;
    BOOL v15 = 1;
  }
LABEL_21:
  if (v8 >= 1)
  {
    int64_t v22 = 0;
    int64_t v23 = v9 - 1;
    if (v9 <= 1) {
      uint64_t v24 = 1;
    }
    else {
      uint64_t v24 = v9;
    }
    float v25 = v11 + 2;
    float v26 = a1;
    do
    {
      float v27 = *v26;
      if (v15)
      {
        float v28 = v27 + (float)((float)(v27 / 1.4142) * 0.5);
        if (v28 >= a4) {
          float v28 = a4;
        }
        float v29 = 20.363;
      }
      else if (v20)
      {
        float v28 = v27 + (float)((float)(v27 / 4.2426) * 0.5);
        if (v28 >= a4) {
          float v28 = a4;
        }
        float v29 = 17.643;
      }
      else
      {
        if ((LODWORD(v27) & 0x7FFFFFFFu) >= 0x7F800000)
        {
          float v31 = **(NSObject ***)(Phase::Logger::GetInstance(result) + 1136);
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            double v32 = *v26;
            *(_DWORD *)uint64_t v41 = 136315650;
            *(void *)&v41[4] = "FrequencyResponse.hpp";
            __int16 v42 = 1024;
            int v43 = 99;
            __int16 v44 = 2048;
            double v45 = v32;
            _os_log_impl(&dword_221E5E000, v31, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [!std::isfinite(inFrequenciesFirst[i]) is true]: \"GetBandsFromCenterFrequencies: bad center frequency: %fHz\"", v41, 0x1Cu);
          }
          exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: bad center frequency: %fHz");
LABEL_60:
          exception->__vftable = (std::logic_error_vtbl *)(MEMORY[0x263F8C3A0] + 16);
        }
        if (v27 < 10.0)
        {
          uint64_t v36 = **(NSObject ***)(Phase::Logger::GetInstance(result) + 1136);
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            double v37 = *v26;
            *(_DWORD *)uint64_t v41 = 136315906;
            *(void *)&v41[4] = "FrequencyResponse.hpp";
            __int16 v42 = 1024;
            int v43 = 103;
            __int16 v44 = 2048;
            double v45 = v37;
            __int16 v46 = 2048;
            double v47 = 10.0;
            _os_log_impl(&dword_221E5E000, v36, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [inFrequenciesFirst[i] < lowestSupportedFreqInHz is true]: \"GetBandsFromCenterFrequencies: center frequency: %fHz cannot be below lowest supported frequency: %fHz\"", v41, 0x26u);
          }
          exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequency: %fHz cannot be below lowest supported frequency: %fHz");
          goto LABEL_60;
        }
        if (v27 > a4)
        {
          uint64_t v34 = **(NSObject ***)(Phase::Logger::GetInstance(result) + 1136);
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            double v35 = *v26;
            *(_DWORD *)uint64_t v41 = 136315906;
            *(void *)&v41[4] = "FrequencyResponse.hpp";
            __int16 v42 = 1024;
            int v43 = 107;
            __int16 v44 = 2048;
            double v45 = v35;
            __int16 v46 = 2048;
            double v47 = a4;
            _os_log_impl(&dword_221E5E000, v34, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [inFrequenciesFirst[i] > highestSupportedFreqInHz is true]: \"GetBandsFromCenterFrequencies: center frequency: %fHz cannot be above highest supported frequency: %fHz\"", v41, 0x26u);
          }
          exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
          std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequency: %fHz cannot be above highest supported frequency: %fHz");
          goto LABEL_60;
        }
        if (v22)
        {
          uint64_t v30 = (v22 - 1);
          if (a1[v30] >= v27)
          {
            unint64_t v38 = **(NSObject ***)(Phase::Logger::GetInstance(result) + 1136);
            if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
            {
              double v39 = a1[v30];
              double v40 = *v26;
              *(_DWORD *)uint64_t v41 = 136315906;
              *(void *)&v41[4] = "FrequencyResponse.hpp";
              __int16 v42 = 1024;
              int v43 = 111;
              __int16 v44 = 2048;
              double v45 = v39;
              __int16 v46 = 2048;
              double v47 = v40;
              _os_log_impl(&dword_221E5E000, v38, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::invalid_argument) [i > 0 && inFrequenciesFirst[i - 1] >= inFrequenciesFirst[i] is true]: \"GetBandsFromCenterFrequencies: center frequencies are not in ascending order. %fHz is before %fHz\"", v41, 0x26u);
            }
            exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
            std::logic_error::logic_error(exception, "GetBandsFromCenterFrequencies: center frequencies are not in ascending order. %fHz is before %fHz");
            goto LABEL_60;
          }
        }
        float v29 = 10.0;
        if (v23 <= v22) {
          float v28 = a4;
        }
        else {
          float v28 = v27 * sqrtf(v26[1] / v27);
        }
      }
      *(v25 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v28;
      float *v11 = v29;
      if (v23 > v22) {
        *float v25 = v28;
      }
      ++v22;
      ++v26;
      v25 += 2;
    }
    while (v24 != v22);
  }
  return result;
}

void sub_221F52228(_Unwind_Exception *a1)
{
  __cxa_free_exception(v2);
  uint64_t v4 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(a1);
}

void std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    int64x2_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 32;
      unint64_t v7 = v4 - 32;
      uint64_t v8 = v4 - 32;
      do
      {
        uint64_t v9 = *(void *)v8;
        v8 -= 32;
        (*(void (**)(char *))(v9 + 16))(v7);
        v6 -= 32;
        BOOL v10 = v7 == v2;
        unint64_t v7 = v8;
      }
      while (!v10);
      int64x2_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::PhaseSpatialModelerMetadata_3Band(uint64_t a1, uint64_t *a2, float a3, float a4, float a5)
{
  uint64_t v23 = *MEMORY[0x263EF8340];
  *(void *)a1 = &unk_26D476928;
  *(float *)(a1 + 8) = a3;
  *(float *)(a1 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = a4;
  *(float *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a5;
  uint64_t v6 = *a2;
  uint64_t v7 = (a2[1] - *a2) >> 2;
  switch(v7)
  {
    case 3:
      *(_DWORD *)(a1 + 20) = *(_DWORD *)v6;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)(v6 + 4);
      float v10 = *(float *)(v6 + 8);
LABEL_8:
      *(float *)(a1 + 28) = v10;
      return a1;
    case 31:
      float v11 = *(float *)(v6 + 44);
      *(float *)(a1 + 20) = sqrtf((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)(v6 + 4) * *(float *)(v6 + 4)) + (float)(*(float *)v6 * *(float *)v6)) + (float)(*(float *)(v6 + 8) * *(float *)(v6 + 8))) + (float)(*(float *)(v6 + 12) * *(float *)(v6 + 12)))+ (float)(*(float *)(v6 + 16) * *(float *)(v6 + 16)))+ (float)(*(float *)(v6 + 20)* *(float *)(v6 + 20)))+ (float)(*(float *)(v6 + 24)* *(float *)(v6 + 24)))+ (float)(*(float *)(v6 + 28) * *(float *)(v6 + 28)))+ (float)(*(float *)(v6 + 32) * *(float *)(v6 + 32)))+ (float)(*(float *)(v6 + 36) * *(float *)(v6 + 36)))+ (float)(*(float *)(v6 + 40) * *(float *)(v6 + 40)))+ (float)(v11 * v11))/ 12.0);
      float v12 = *(float *)(v6 + 92);
      *(float *)(a1 + 24) = sqrtf((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(*(float *)(v6 + 52) * *(float *)(v6 + 52)) + (float)(*(float *)(v6 + 48) * *(float *)(v6 + 48))) + (float)(*(float *)(v6 + 56) * *(float *)(v6 + 56))) + (float)(*(float *)(v6 + 60) * *(float *)(v6 + 60)))+ (float)(*(float *)(v6 + 64) * *(float *)(v6 + 64)))+ (float)(*(float *)(v6 + 68)* *(float *)(v6 + 68)))+ (float)(*(float *)(v6 + 72)* *(float *)(v6 + 72)))+ (float)(*(float *)(v6 + 76) * *(float *)(v6 + 76)))+ (float)(*(float *)(v6 + 80) * *(float *)(v6 + 80)))+ (float)(*(float *)(v6 + 84) * *(float *)(v6 + 84)))+ (float)(*(float *)(v6 + 88) * *(float *)(v6 + 88)))+ (float)(v12 * v12))/ 12.0);
      float v9 = (float)((float)((float)((float)((float)((float)(*(float *)(v6 + 100) * *(float *)(v6 + 100))
                                                 + (float)(*(float *)(v6 + 96) * *(float *)(v6 + 96)))
                                         + (float)(*(float *)(v6 + 104) * *(float *)(v6 + 104)))
                                 + (float)(*(float *)(v6 + 108) * *(float *)(v6 + 108)))
                         + (float)(*(float *)(v6 + 112) * *(float *)(v6 + 112)))
                 + (float)(*(float *)(v6 + 116) * *(float *)(v6 + 116)))
         + (float)(*(float *)(v6 + 120) * *(float *)(v6 + 120));
      float v8 = 7.0;
      goto LABEL_7;
    case 10:
      *(float *)(a1 + 20) = sqrtf((float)((float)((float)((float)(*(float *)(v6 + 4) * *(float *)(v6 + 4))+ (float)(*(float *)v6 * *(float *)v6))+ (float)(*(float *)(v6 + 8) * *(float *)(v6 + 8)))+ (float)(*(float *)(v6 + 12) * *(float *)(v6 + 12)))* 0.25);
      float v8 = 3.0;
      *(float *)(a1 + 24) = sqrtf((float)((float)((float)(*(float *)(v6 + 20) * *(float *)(v6 + 20))+ (float)(*(float *)(v6 + 16) * *(float *)(v6 + 16)))+ (float)(*(float *)(v6 + 24) * *(float *)(v6 + 24)))/ 3.0);
      float v9 = (float)((float)(*(float *)(v6 + 32) * *(float *)(v6 + 32))
                 + (float)(*(float *)(v6 + 28) * *(float *)(v6 + 28)))
         + (float)(*(float *)(v6 + 36) * *(float *)(v6 + 36));
LABEL_7:
      float v10 = sqrtf(v9 / v8);
      goto LABEL_8;
  }
  float v14 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 1184);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = (a2[1] - *a2) >> 2;
    int v17 = 136315650;
    uint64_t v18 = "RayTracingTypes.hpp";
    __int16 v19 = 1024;
    int v20 = 422;
    __int16 v21 = 2048;
    uint64_t v22 = v15;
    _os_log_impl(&dword_221E5E000, v14, OS_LOG_TYPE_ERROR, "%25s:%-5d PhaseSpatialModelerMetadata_3Band invalid number of subbands %zu", (uint8_t *)&v17, 0x1Cu);
  }
  *(_DWORD *)(a1 + 28) = 0;
  *(void *)(a1 + 20) = 0;
  return a1;
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::getNumBands(Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band *this)
{
  return 3;
}

float Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::getDelay(Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band *this)
{
  return *((float *)this + 4);
}

void Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band::~PhaseSpatialModelerMetadata_3Band(Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band *this)
{
}

uint64_t std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_3Band>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(i - 32);
    *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = i - 32;
    (*(void (**)(void))(v4 + 16))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    int64x2_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 64;
      uint64_t v7 = v4 - 64;
      float v8 = v4 - 64;
      do
      {
        uint64_t v9 = *(void *)v8;
        v8 -= 64;
        (*(void (**)(char *))(v9 + 16))(v7);
        v6 -= 64;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      int64x2_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::PhaseSpatialModelerMetadata_Octave(uint64_t a1, uint64_t a2, float a3, float a4, float a5)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  *(void *)a1 = &unk_26D476958;
  *(float *)(a1 + 8) = a3;
  *(float *)(a1 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = a4;
  *(float *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a5;
  uint64_t v7 = *(unsigned char **)a2;
  float v8 = *(unsigned char **)(a2 + 8);
  uint64_t v10 = (v8 - v7) >> 2;
  switch(v10)
  {
    case 3:
      *(_DWORD *)(a1 + 20) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 28) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 40) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 44) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 48) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 52) = *((_DWORD *)v7 + 2);
      float v11 = *((float *)v7 + 2);
LABEL_8:
      *(float *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v11;
      return a1;
    case 31:
      *(float *)(a1 + 20) = sqrtf((float)((float)((float)((float)(*((float *)v7 + 1) * *((float *)v7 + 1))+ (float)(*(float *)v7 * *(float *)v7))+ (float)(*((float *)v7 + 2) * *((float *)v7 + 2)))+ (float)(*((float *)v7 + 3) * *((float *)v7 + 3)))* 0.25);
      *(float *)(a1 + 24) = sqrtf((float)((float)((float)(*((float *)v7 + 5) * *((float *)v7 + 5))+ (float)(*((float *)v7 + 4) * *((float *)v7 + 4)))+ (float)(*((float *)v7 + 6) * *((float *)v7 + 6)))/ 3.0);
      *(float *)(a1 + 28) = sqrtf((float)((float)((float)(*((float *)v7 + 8) * *((float *)v7 + 8))+ (float)(*((float *)v7 + 7) * *((float *)v7 + 7)))+ (float)(*((float *)v7 + 9) * *((float *)v7 + 9)))/ 3.0);
      *(float *)(a1 + 32) = sqrtf((float)((float)((float)(*((float *)v7 + 11) * *((float *)v7 + 11))+ (float)(*((float *)v7 + 10) * *((float *)v7 + 10)))+ (float)(*((float *)v7 + 12) * *((float *)v7 + 12)))/ 3.0);
      *(float *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = sqrtf((float)((float)((float)(*((float *)v7 + 14) * *((float *)v7 + 14))+ (float)(*((float *)v7 + 13) * *((float *)v7 + 13)))+ (float)(*((float *)v7 + 15) * *((float *)v7 + 15)))/ 3.0);
      *(float *)(a1 + 40) = sqrtf((float)((float)((float)(*((float *)v7 + 17) * *((float *)v7 + 17))+ (float)(*((float *)v7 + 16) * *((float *)v7 + 16)))+ (float)(*((float *)v7 + 18) * *((float *)v7 + 18)))/ 3.0);
      *(float *)(a1 + 44) = sqrtf((float)((float)((float)(*((float *)v7 + 20) * *((float *)v7 + 20))+ (float)(*((float *)v7 + 19) * *((float *)v7 + 19)))+ (float)(*((float *)v7 + 21) * *((float *)v7 + 21)))/ 3.0);
      *(float *)(a1 + 48) = sqrtf((float)((float)((float)(*((float *)v7 + 23) * *((float *)v7 + 23))+ (float)(*((float *)v7 + 22) * *((float *)v7 + 22)))+ (float)(*((float *)v7 + 24) * *((float *)v7 + 24)))/ 3.0);
      *(float *)(a1 + 52) = sqrtf((float)((float)((float)(*((float *)v7 + 26) * *((float *)v7 + 26))+ (float)(*((float *)v7 + 25) * *((float *)v7 + 25)))+ (float)(*((float *)v7 + 27) * *((float *)v7 + 27)))/ 3.0);
      float v11 = sqrtf((float)((float)((float)(*((float *)v7 + 29) * *((float *)v7 + 29))+ (float)(*((float *)v7 + 28) * *((float *)v7 + 28)))+ (float)(*((float *)v7 + 30) * *((float *)v7 + 30)))/ 3.0);
      goto LABEL_8;
    case 10:
      if (v8 != v7) {
        memmove((void *)(a1 + 20), v7, v8 - v7);
      }
      break;
    default:
      float v12 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 1184);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2;
        int v15 = 136315650;
        BOOL v16 = "RayTracingTypes.hpp";
        __int16 v17 = 1024;
        int v18 = 514;
        __int16 v19 = 2048;
        uint64_t v20 = v13;
        _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d PhaseSpatialModelerMetadata_Octave invalid number of subbands %zu", (uint8_t *)&v15, 0x1Cu);
      }
      *(void *)(a1 + 52) = 0;
      *(_OWORD *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
      *(_OWORD *)(a1 + 20) = 0u;
      break;
  }
  return a1;
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::getNumBands(Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave *this)
{
  return 10;
}

float Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::getDelay(Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave *this)
{
  return *((float *)this + 4);
}

void Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave::~PhaseSpatialModelerMetadata_Octave(Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave *this)
{
}

uint64_t std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_Octave>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(i - 64);
    *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = i - 64;
    (*(void (**)(void))(v4 + 16))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    int64x2_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 144;
      uint64_t v7 = v4 - 144;
      float v8 = v4 - 144;
      do
      {
        uint64_t v9 = *(void *)v8;
        v8 -= 144;
        (*(void (**)(char *))(v9 + 16))(v7);
        v6 -= 144;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      int64x2_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::PhaseSpatialModelerMetadata_ThirdOctave(uint64_t a1, char **a2, float a3, float a4, float a5)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  *(void *)a1 = &unk_26D476988;
  *(float *)(a1 + 8) = a3;
  *(float *)(a1 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = a4;
  *(float *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = a5;
  uint64_t v7 = *a2;
  float v8 = a2[1];
  uint64_t v10 = (v8 - v7) >> 2;
  switch(v10)
  {
    case 3:
      *(_DWORD *)(a1 + 20) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 28) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 40) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 44) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 48) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 52) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 60) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 64) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 68) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 72) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 80) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 84) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 92) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 100) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 104) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 108) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 11std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 120) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 124) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 128) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 132) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 2);
      int v11 = *((_DWORD *)v7 + 2);
      goto LABEL_6;
    case 31:
      if (v8 != v7) {
        memmove((void *)(a1 + 20), v7, v8 - v7);
      }
      break;
    case 10:
      *(_DWORD *)(a1 + 20) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 24) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 28) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 32) = *(_DWORD *)v7;
      *(_DWORD *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 40) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 44) = *((_DWORD *)v7 + 1);
      *(_DWORD *)(a1 + 48) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 52) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 2);
      *(_DWORD *)(a1 + 60) = *((_DWORD *)v7 + 3);
      *(_DWORD *)(a1 + 64) = *((_DWORD *)v7 + 3);
      *(_DWORD *)(a1 + 68) = *((_DWORD *)v7 + 3);
      *(_DWORD *)(a1 + 72) = *((_DWORD *)v7 + 4);
      *(_DWORD *)(a1 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 4);
      *(_DWORD *)(a1 + 80) = *((_DWORD *)v7 + 4);
      *(_DWORD *)(a1 + 84) = *((_DWORD *)v7 + 5);
      *(_DWORD *)(a1 + 88) = *((_DWORD *)v7 + 5);
      *(_DWORD *)(a1 + 92) = *((_DWORD *)v7 + 5);
      *(_DWORD *)(a1 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 6);
      *(_DWORD *)(a1 + 100) = *((_DWORD *)v7 + 6);
      *(_DWORD *)(a1 + 104) = *((_DWORD *)v7 + 6);
      *(_DWORD *)(a1 + 108) = *((_DWORD *)v7 + 7);
      *(_DWORD *)(a1 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *((_DWORD *)v7 + 7);
      *(_DWORD *)(a1 + 11std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 7);
      *(_DWORD *)(a1 + 120) = *((_DWORD *)v7 + 8);
      *(_DWORD *)(a1 + 124) = *((_DWORD *)v7 + 8);
      *(_DWORD *)(a1 + 128) = *((_DWORD *)v7 + 8);
      *(_DWORD *)(a1 + 132) = *((_DWORD *)v7 + 9);
      *(_DWORD *)(a1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *((_DWORD *)v7 + 9);
      int v11 = *((_DWORD *)v7 + 9);
LABEL_6:
      *(_DWORD *)(a1 + 140) = v11;
      return a1;
    default:
      float v12 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 1184);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = (a2[1] - *a2) >> 2;
        int v15 = 136315650;
        BOOL v16 = "RayTracingTypes.hpp";
        __int16 v17 = 1024;
        int v18 = 639;
        __int16 v19 = 2048;
        uint64_t v20 = v13;
        _os_log_impl(&dword_221E5E000, v12, OS_LOG_TYPE_ERROR, "%25s:%-5d PhaseSpatialModelerMetadata_ThirdOctave invalid number of subbands %zu", (uint8_t *)&v15, 0x1Cu);
      }
      *(_OWORD *)(a1 + 128) = 0u;
      *(_OWORD *)(a1 + 11std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
      *(_OWORD *)(a1 + 100) = 0u;
      *(_OWORD *)(a1 + 84) = 0u;
      *(_OWORD *)(a1 + 68) = 0u;
      *(_OWORD *)(a1 + 52) = 0u;
      *(_OWORD *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
      *(_OWORD *)(a1 + 20) = 0u;
      break;
  }
  return a1;
}

uint64_t Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::getNumBands(Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave *this)
{
  return 31;
}

float Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::getDelay(Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave *this)
{
  return *((float *)this + 4);
}

void Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave::~PhaseSpatialModelerMetadata_ThirdOctave(Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave *this)
{
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1C71C71C71C71C8) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(144 * a2);
}

uint64_t std::__split_buffer<Phase::SpatialModeler::PhaseSpatialModelerMetadata_ThirdOctave>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void *)(i - 144);
    *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = i - 144;
    (*(void (**)(void))(v4 + 16))();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::CardioidDirectivity>())()
{
  return Phase::GetTypeId<Phase::Geometry::CardioidDirectivity>;
}

void Phase::Geometry::CreateCardioidDirectivity(void *a1@<X1>, void *a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  *(void *)&long long v6 = "DirectivityDataMapSize";
  *((void *)&v6 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 22;
  if (a1 && (uint64_t v3 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a1, &v6)) != 0 && *((_DWORD *)v3 + 24) == 1)
  {
    int v4 = *((_DWORD *)v3 + 14);
    if (v4 <= 0) {
      std::terminate();
    }
  }
  else
  {
    int v4 = 1;
  }
  int64x2_t v5 = operator new(0x58uLL);
  v5[1] = 0;
  void v5[2] = 0;
  void *v5 = &unk_26D4769B8;
  *((_DWORD *)v5 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  v5[10] = 0;
  *((_OWORD *)v5 + 4) = 0u;
  *a2 = v5 + 3;
  a2[1] = v5;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v5 + 8, v4);
  operator new();
}

void sub_221F5319C(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(uint64_t *result, unint64_t a2)
{
  unint64_t v2 = 0xCCCCCCCCCCCCCCCDLL * ((result[1] - *result) >> 3);
  BOOL v3 = a2 >= v2;
  unint64_t v4 = a2 - v2;
  if (v4 != 0 && v3) {
    return (uint64_t *)std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__append(result, v4);
  }
  if (!v3) {
    return std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__base_destruct_at_end[abi:ne180100](result, *result + 40 * a2);
  }
  return result;
}

uint64_t *std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::operator=[abi:ne180100](uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  *a2 = 0;
  std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::reset[abi:ne180100](a1, v4);
  std::__function::__value_func<void ()(void *)>::operator=[abi:ne180100](a1 + 1, (uint64_t)(a2 + 1));
  return a1;
}

uint64_t *Phase::Geometry::CreateCardioidDirectivityFromDirectivity@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  if (*(_DWORD *)a1 != 1) {
    std::terminate();
  }
  uint64_t v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = &unk_26D4769B8;
  *((_DWORD *)v4 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  v4[10] = 0;
  *((_OWORD *)v4 + 4) = 0u;
  *a2 = v4 + 3;
  a2[1] = v4;
  uint64_t result = std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v4 + 8, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 3));
  if (*(void *)(a1 + 48) != *(void *)(a1 + 40)) {
    operator new();
  }
  return result;
}

void sub_221F53464(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::Geometry::Directivity>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4769B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::Directivity>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D4769B8;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

void std::__shared_ptr_emplace<Phase::Geometry::Directivity>::__on_zero_shared(uint64_t a1)
{
  unint64_t v2 = (void **)(a1 + 64);
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  unint64_t v2 = (void **)(a1 + 40);
  std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  unint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__base_destruct_at_end[abi:ne180100](v2, (uint64_t)*v2);
    BOOL v3 = **a1;
    operator delete(v3);
  }
}

void *std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__base_destruct_at_end[abi:ne180100](void *result, uint64_t a2)
{
  BOOL v3 = result;
  for (uint64_t i = result[1]; i != a2; i -= 40)
  {
    std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(i - 40), 0);
    uint64_t result = std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)(i - 32));
  }
  v3[1] = a2;
  return result;
}

void **std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (void **)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(result - 1);
  if (0xCCCCCCCCCCCCCCCDLL * ((v6 - (uint64_t)v7) >> 3) >= a2)
  {
    if (a2)
    {
      uint64_t v13 = &v7[5 * a2];
      do
      {
        void *v7 = 0;
        v7[4] = 0;
        v7 += 5;
      }
      while (v7 != v13);
      uint64_t v7 = v13;
    }
    a1[1] = (uint64_t)v7;
  }
  else
  {
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x666666666666666) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xCCCCCCCCCCCCCCCDLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x333333333333333) {
      unint64_t v11 = 0x666666666666666;
    }
    else {
      unint64_t v11 = v9;
    }
    v16[4] = result;
    if (v11) {
      float v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::SpatialModeler::RoomSimulationDebugger::DebugImageSource>>((uint64_t)result, v11);
    }
    else {
      float v12 = 0;
    }
    float v14 = &v12[40 * v8];
    v16[0] = v12;
    v16[1] = v14;
    void v16[3] = &v12[40 * v11];
    int v15 = &v14[40 * a2];
    do
    {
      *(void *)float v14 = 0;
      *((void *)v14 + 4) = 0;
      v14 += 40;
    }
    while (v14 != v15);
    void v16[2] = v15;
    std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__swap_out_circular_buffer(a1, v16);
    return std::__split_buffer<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::~__split_buffer(v16);
  }
  return result;
}

void sub_221F53720(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  _OWORD v13[2] = &v16;
  char v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    unint64_t v9 = a3;
    do
    {
      uint64_t v10 = *(v9 - 5);
      v9 -= 5;
      *unint64_t v9 = 0;
      *(void *)(v7 - 40) = v10;
      std::__function::__value_func<void ()(void *)>::__value_func[abi:ne180100](v7 - 32, (uint64_t)(v9 + 1));
      uint64_t v7 = *((void *)&v16 + 1) - 40;
      *((void *)&v16 + 1) -= 40;
    }
    while (v9 != a5);
    uint64_t v11 = v16;
  }
  char v14 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v13);
  return v11;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  }
  return a1;
}

void *std::_AllocatorDestroyRangeReverse<std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>,std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v1 = (uint64_t *)a1[2];
  uint64_t v3 = *v1;
  uint64_t v2 = v1[1];
  uint64_t v15 = v3;
  uint64_t v16 = v2;
  uint64_t v17 = v3;
  uint64_t v18 = v2;
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t *)a1[1];
  uint64_t v7 = *v5;
  uint64_t v6 = v5[1];
  uint64_t v10 = v7;
  uint64_t v11 = v6;
  uint64_t v12 = v7;
  uint64_t v13 = v6;
  return std::__allocator_destroy[abi:ne180100]<std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>>(v4, (uint64_t)v14, (uint64_t)v9);
}

void *std::__allocator_destroy[abi:ne180100]<std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>,std::reverse_iterator<std::reverse_iterator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  for (uint64_t i = *(uint64_t **)(a2 + 32); i != *(uint64_t **)(a3 + 32); *(void *)(a2 + 32) = i)
  {
    std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::reset[abi:ne180100](i, 0);
    uint64_t result = std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100](i + 1);
    uint64_t i = (uint64_t *)(*(void *)(a2 + 32) + 40);
  }
  return result;
}

void **std::__split_buffer<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destruct_at_end[abi:ne180100](void *result, uint64_t a2)
{
  uint64_t v2 = result[2];
  if (v2 != a2)
  {
    uint64_t v4 = result;
    do
    {
      v4[2] = v2 - 40;
      std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)(v2 - 40), 0);
      uint64_t result = std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)(v2 - 32));
      uint64_t v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D4769F0;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D4769F0;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::CardioidDirectivity>(Phase::Geometry::CardioidDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    JUMPOUT(0x223C938A0);
  }
  return result;
}

uint64_t *std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result, uint64_t a2)
{
  uint64_t v3 = *result;
  *uint64_t result = a2;
  if (v3) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v3);
  }
  return result;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::ConeDirectivity>())()
{
  return Phase::GetTypeId<Phase::Geometry::ConeDirectivity>;
}

void Phase::Geometry::CreateConeDirectivity(void *a1@<X1>, void *a2@<X8>)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  *(void *)&long long v6 = "DirectivityDataMapSize";
  *((void *)&v6 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 22;
  if (a1 && (uint64_t v3 = Phase::UnorderedStringMap<Phase::OptionsValue>::Find(a1, &v6)) != 0 && *((_DWORD *)v3 + 24) == 1)
  {
    int v4 = *((_DWORD *)v3 + 14);
    if (v4 <= 0) {
      std::terminate();
    }
  }
  else
  {
    int v4 = 1;
  }
  uint64_t v5 = operator new(0x58uLL);
  v5[1] = 0;
  void v5[2] = 0;
  void *v5 = &unk_26D4769B8;
  *((_DWORD *)v5 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 2;
  *((_OWORD *)v5 + 2) = 0u;
  *((_OWORD *)v5 + 3) = 0u;
  v5[10] = 0;
  *((_OWORD *)v5 + 4) = 0u;
  *a2 = v5 + 3;
  a2[1] = v5;
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v5 + 8, v4);
  operator new();
}

void sub_221F53CD8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

uint64_t *Phase::Geometry::CreateConeDirectivityFromDirectivity@<X0>(uint64_t a1@<X1>, void *a2@<X8>)
{
  if (*(_DWORD *)a1 != 2) {
    std::terminate();
  }
  int v4 = operator new(0x58uLL);
  v4[1] = 0;
  v4[2] = 0;
  void *v4 = &unk_26D4769B8;
  *((_DWORD *)v4 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 2;
  *((_OWORD *)v4 + 2) = 0u;
  *((_OWORD *)v4 + 3) = 0u;
  v4[10] = 0;
  *((_OWORD *)v4 + 4) = 0u;
  *a2 = v4 + 3;
  a2[1] = v4;
  uint64_t result = std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::resize(v4 + 8, 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 48) - *(void *)(a1 + 40)) >> 3));
  if (*(void *)(a1 + 48) != *(void *)(a1 + 40)) {
    operator new();
  }
  return result;
}

void sub_221F53F40(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D476A38;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D476A38;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::ConeDirectivity>(Phase::Geometry::ConeDirectivity *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    JUMPOUT(0x223C938A0);
  }
  return result;
}

uint64_t Phase::Geometry::DirectivityFactory::Create@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = *(void *)result;
  uint64_t v6 = *(void *)(*(void *)result + 224);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)result + 232) - v6) >> 5) <= a2) {
    __assert_rtn("GetTypeDef", "GeoDirectivityTypeRegistry.cpp", 33, "IsValid(inDirectivityType)");
  }
  uint64_t v7 = v6 + 96 * a2;
  if (*(void *)(v7 + 32))
  {
    return std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(v7 + 8, v5, a3);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
  return result;
}

uint64_t std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, a2, &v5);
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *Phase::Geometry::DirectivityTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v3) >> 5) <= a2) {
    __assert_rtn("CustomizeType", "GeoDirectivityTypeRegistry.cpp", 43, "IsValid(inDirectivityType)");
  }

  return std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((void *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;
  uint64_t vars8;

  uint64_t v3 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v3) >> 5) <= a2) {
    __assert_rtn("CustomizeType", "GeoDirectivityTypeRegistry.cpp", 54, "IsValid(inDirectivityType)");
  }

  return std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((void *)(v3 + 96 * a2 + 40), a3);
}

void *std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void *std::function<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void std::vector<Phase::Geometry::DirectivityTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::DirectivityTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void std::vector<Phase::Geometry::LoadDirectivityFunctionTableEntry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    BOOL v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 40;
        std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100]((void *)v4 - 4);
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    BOOL v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F5485C(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    BOOL v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F54AC8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::vector<Phase::Geometry::DirectivityTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::DirectivityTypeDefinition>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<Phase::Geometry::DirectivityTypeDefinition>::__throw_length_error[abi:ne180100]()
{
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::DirectivityTypeDefinition>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DirectivityTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a3;
    while (1)
    {
      uint64_t v13 = a7 + v11;
      uint64_t v14 = a3 + v11;
      *(void *)(a7 + v11 - 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a3 + v11 - 96);
      uint64_t v15 = *(void *)(a3 + v11 - 64);
      if (!v15) {
        break;
      }
      if (v14 - 88 != v15)
      {
        uint64_t v16 = (void *)(v12 - 64);
        *(void *)(v13 - 64) = v15;
LABEL_7:
        void *v16 = 0;
        goto LABEL_9;
      }
      *(void *)(v13 - 64) = v13 - 88;
      (*(void (**)(void))(**(void **)(v14 - 64) + 24))(*(void *)(v14 - 64));
LABEL_9:
      uint64_t v17 = a7 + v11;
      uint64_t v18 = a3 + v11;
      uint64_t v19 = *(void *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(void *)(v17 - 32) = v17 - 56;
          (*(void (**)(void))(**(void **)(v18 - 32) + 24))(*(void *)(v18 - 32));
          goto LABEL_15;
        }
        uint64_t v20 = (void *)(v12 - 32);
        *(void *)(v17 - 32) = v19;
      }
      else
      {
        uint64_t v20 = (void *)(v17 - 32);
      }
      *uint64_t v20 = 0;
LABEL_15:
      v12 -= 96;
      uint64_t v21 = a7 + v11;
      uint64_t v22 = a3 + v11;
      *(void *)(v21 - 24) = 0;
      *(void *)(v21 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(void *)(v21 - 8) = *(void *)(a3 + v11 - 8);
      *(void *)(v22 - 24) = 0;
      *(void *)(v22 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5) {
        return a6;
      }
    }
    uint64_t v16 = (void *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

void *std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 8);
  uint64_t v5 = (void **)(a2 + 72);
  std::vector<Phase::Geometry::LoadDirectivityFunctionTableEntry>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::Geometry::Directivity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100]((void *)(a2 + 40));
  return std::__function::__value_func<std::shared_ptr<Phase::Geometry::Directivity> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v3);
}

void **std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::clear[abi:ne180100](void *result)
{
  uint64_t v2 = result[1];
  uint64_t v1 = result[2];
  if (v1 != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = v3[4];
      v3[2] = v1 - 96;
      uint64_t result = std::allocator<Phase::Geometry::DirectivityTypeDefinition>::destroy[abi:ne180100](v4, v1 - 96);
      uint64_t v1 = v3[2];
    }
    while (v1 != v2);
  }
  return result;
}

void std::vector<Phase::Geometry::DirectivityTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      size_t v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL) {
      std::vector<Phase::Geometry::DirectivityTypeDefinition>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x155555555555555) {
      unint64_t v11 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    uint64_t v16 = &v12[96 * v8];
    uint64_t v18 = &v12[96 * v11];
    size_t v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    std::vector<Phase::Geometry::DirectivityTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_221F54F84(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::DirectivityTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::DistanceModelFactory::Create@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = *(void *)result;
  uint64_t v6 = *(void *)(*(void *)result + 472);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)result + 480) - v6) >> 5) <= a2) {
    __assert_rtn("GetTypeDef", "GeoDistanceModelTypeRegistry.cpp", 33, "IsValid(inDistanceModelType)");
  }
  uint64_t v7 = v6 + 96 * a2;
  if (*(void *)(v7 + 32))
  {
    return std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(v7 + 8, v5, a3);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
  return result;
}

uint64_t std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, a2, &v5);
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *Phase::Geometry::DistanceModelTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v3) >> 5) <= a2) {
    __assert_rtn("CustomizeType", "GeoDistanceModelTypeRegistry.cpp", 43, "IsValid(inDistanceModelType)");
  }

  return std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((void *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;
  uint64_t vars8;

  uint64_t v3 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v3) >> 5) <= a2) {
    __assert_rtn("CustomizeType", "GeoDistanceModelTypeRegistry.cpp", 54, "IsValid(inDistanceModelType)");
  }

  return std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((void *)(v3 + 96 * a2 + 40), a3);
}

void *std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void *std::function<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void std::vector<Phase::Geometry::DistanceModelTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::DistanceModelTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void std::vector<Phase::Geometry::LoadDistanceModelFunctionTableEntry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    BOOL v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 40;
        std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100]((void *)v4 - 4);
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    BOOL v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F55804(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    BOOL v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F55A70(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::DistanceModelTypeDefinition>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__throw_length_error[abi:ne180100]()
{
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::DistanceModelTypeDefinition>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>,std::reverse_iterator<Phase::Geometry::DistanceModelTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a3;
    while (1)
    {
      uint64_t v13 = a7 + v11;
      uint64_t v14 = a3 + v11;
      *(void *)(a7 + v11 - 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a3 + v11 - 96);
      uint64_t v15 = *(void *)(a3 + v11 - 64);
      if (!v15) {
        break;
      }
      if (v14 - 88 != v15)
      {
        uint64_t v16 = (void *)(v12 - 64);
        *(void *)(v13 - 64) = v15;
LABEL_7:
        void *v16 = 0;
        goto LABEL_9;
      }
      *(void *)(v13 - 64) = v13 - 88;
      (*(void (**)(void))(**(void **)(v14 - 64) + 24))(*(void *)(v14 - 64));
LABEL_9:
      uint64_t v17 = a7 + v11;
      uint64_t v18 = a3 + v11;
      uint64_t v19 = *(void *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(void *)(v17 - 32) = v17 - 56;
          (*(void (**)(void))(**(void **)(v18 - 32) + 24))(*(void *)(v18 - 32));
          goto LABEL_15;
        }
        uint64_t v20 = (void *)(v12 - 32);
        *(void *)(v17 - 32) = v19;
      }
      else
      {
        uint64_t v20 = (void *)(v17 - 32);
      }
      *uint64_t v20 = 0;
LABEL_15:
      v12 -= 96;
      uint64_t v21 = a7 + v11;
      uint64_t v22 = a3 + v11;
      *(void *)(v21 - 24) = 0;
      *(void *)(v21 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(void *)(v21 - 8) = *(void *)(a3 + v11 - 8);
      *(void *)(v22 - 24) = 0;
      *(void *)(v22 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5) {
        return a6;
      }
    }
    uint64_t v16 = (void *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

void *std::allocator<Phase::Geometry::DistanceModelTypeDefinition>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 8);
  uint64_t v5 = (void **)(a2 + 72);
  std::vector<Phase::Geometry::LoadDistanceModelFunctionTableEntry>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::Geometry::DistanceModel const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100]((void *)(a2 + 40));
  return std::__function::__value_func<std::shared_ptr<Phase::Geometry::DistanceModel> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v3);
}

void **std::__split_buffer<Phase::Geometry::DistanceModelTypeDefinition>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<Phase::Geometry::DistanceModelTypeDefinition>::clear[abi:ne180100](void *result)
{
  uint64_t v2 = result[1];
  uint64_t v1 = result[2];
  if (v1 != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = v3[4];
      v3[2] = v1 - 96;
      uint64_t result = std::allocator<Phase::Geometry::DistanceModelTypeDefinition>::destroy[abi:ne180100](v4, v1 - 96);
      uint64_t v1 = v3[2];
    }
    while (v1 != v2);
  }
  return result;
}

void std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      size_t v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL) {
      std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x155555555555555) {
      unint64_t v11 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    uint64_t v16 = &v12[96 * v8];
    uint64_t v18 = &v12[96 * v11];
    size_t v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    std::vector<Phase::Geometry::DistanceModelTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::DistanceModelTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_221F55F2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::DistanceModelTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::Entity::AddShape(void *a1, uint64_t a2)
{
  uint64_t v5 = (char *)a1[15];
  uint64_t v6 = (char *)a1[16];
  uint64_t v7 = (v6 - v5) >> 3;
  uint64_t v8 = (uint64_t)(a1 + 17);
  unint64_t v9 = a1[17];
  if ((unint64_t)v6 >= v9)
  {
    if ((unint64_t)(v7 + 1) >> 61) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v11 = v9 - (void)v5;
    unint64_t v12 = (uint64_t)(v9 - (void)v5) >> 2;
    if (v12 <= v7 + 1) {
      unint64_t v12 = v7 + 1;
    }
    if (v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v12;
    }
    if (v13)
    {
      size_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v8, v13);
      uint64_t v5 = (char *)a1[15];
      uint64_t v6 = (char *)a1[16];
    }
    else
    {
      size_t v14 = 0;
    }
    uint64_t v15 = &v14[8 * v7];
    uint64_t v16 = &v14[8 * v13];
    *(void *)uint64_t v15 = a2;
    unint64_t v10 = v15 + 8;
    while (v6 != v5)
    {
      uint64_t v17 = *((void *)v6 - 1);
      v6 -= 8;
      *((void *)v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v17;
      v15 -= 8;
    }
    a1[15] = v15;
    a1[16] = v10;
    a1[17] = v16;
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *(void *)uint64_t v6 = a2;
    unint64_t v10 = v6 + 8;
  }
  a1[16] = v10;
  return v7;
}

BOOL Phase::Geometry::Entity::AddChild(void *a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 88);
  if (!v2)
  {
    uint64_t v5 = (uint64_t)(a1 + 14);
    unint64_t v6 = a1[14];
    uint64_t v7 = (char *)a1[13];
    if ((unint64_t)v7 >= v6)
    {
      unint64_t v9 = (char *)a1[12];
      uint64_t v10 = (v7 - v9) >> 3;
      if ((unint64_t)(v10 + 1) >> 61) {
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v11 = v6 - (void)v9;
      unint64_t v12 = (uint64_t)(v6 - (void)v9) >> 2;
      if (v12 <= v10 + 1) {
        unint64_t v12 = v10 + 1;
      }
      if (v11 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      if (v13)
      {
        size_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v5, v13);
        unint64_t v9 = (char *)a1[12];
        uint64_t v7 = (char *)a1[13];
      }
      else
      {
        size_t v14 = 0;
      }
      uint64_t v15 = &v14[8 * v10];
      uint64_t v16 = &v14[8 * v13];
      *(void *)uint64_t v15 = *(void *)(a2 + 8);
      uint64_t v8 = v15 + 8;
      while (v7 != v9)
      {
        uint64_t v17 = *((void *)v7 - 1);
        v7 -= 8;
        *((void *)v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v17;
        v15 -= 8;
      }
      a1[12] = v15;
      a1[13] = v8;
      a1[14] = v16;
      if (v9) {
        operator delete(v9);
      }
    }
    else
    {
      *(void *)uint64_t v7 = *(void *)(a2 + 8);
      uint64_t v8 = v7 + 8;
    }
    a1[13] = v8;
    *(void *)(a2 + 88) = a1[1];
    *(unsigned char *)(a2 + 80) = 1;
  }
  return v2 == 0;
}

uint64_t Phase::Geometry::Entity::RemoveChild(void *a1, uint64_t a2)
{
  if (a1[1] != *(void *)(a2 + 88)) {
    return 0;
  }
  uint64_t v3 = a1[12];
  uint64_t v2 = a1[13];
  if (v2 == v3) {
    return 0;
  }
  unint64_t v4 = (v2 - v3) >> 3;
  if (v4 <= 1) {
    uint64_t v5 = 1;
  }
  else {
    uint64_t v5 = (v2 - v3) >> 3;
  }
  for (uint64_t i = (void *)a1[12]; *(void *)(a2 + 8) != *i; ++i)
  {
    if (!--v5) {
      return 0;
    }
  }
  *uint64_t i = *(void *)(v3 + 8 * v4 - 8);
  a1[13] = v2 - 8;
  *(void *)(a2 + 88) = 0;
  uint64_t result = 1;
  *(unsigned char *)(a2 + 80) = 1;
  return result;
}

void Phase::Geometry::EntityFactory::Create(int a1@<W1>, void *a2@<X8>)
{
  switch(a1)
  {
    case 1:
      Phase::Geometry::CreateEntity<Phase::Geometry::Entity>();
    case 2:
      Phase::Geometry::CreateEntity<Phase::Geometry::Listener>();
    case 3:
      Phase::Geometry::CreateEntity<Phase::Geometry::Source>();
    case 4:
      Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>();
    case 5:
      Phase::Geometry::CreateEntity<Phase::Geometry::Environment>();
    default:
      *a2 = 0;
      a2[1] = 0;
      return;
  }
}

void Phase::Geometry::CreateEntity<Phase::Geometry::Entity>()
{
}

void sub_221F56304(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::CreateEntity<Phase::Geometry::Environment>()
{
}

void sub_221F563F0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::CreateEntity<Phase::Geometry::Listener>()
{
}

void sub_221F564F4(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>()
{
}

void sub_221F565DC(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::CreateEntity<Phase::Geometry::Source>()
{
}

void sub_221F566D0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
  if (v3) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::EntityFactory::Create(_DWORD *a1@<X1>, void *a2@<X8>)
{
  switch(*a1)
  {
    case 1:
      Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>();
    case 2:
      Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>();
    case 3:
      Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>();
    case 4:
      Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>();
    case 5:
      Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>();
    default:
      *a2 = 0;
      a2[1] = 0;
      return;
  }
}

void Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>()
{
}

void sub_221F568B4(void *a1)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(v1);
  __cxa_rethrow();
}

void sub_221F568C8(_Unwind_Exception *a1)
{
}

void Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>()
{
}

void sub_221F56A44(void *a1)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(v1);
  __cxa_rethrow();
}

void sub_221F56A58(_Unwind_Exception *a1)
{
}

void Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>()
{
}

void sub_221F56B90(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>()
{
}

void sub_221F56D28(void *a1)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(v1);
  __cxa_rethrow();
}

void sub_221F56D3C(_Unwind_Exception *a1)
{
}

void Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>()
{
}

void sub_221F56EE4(void *a1)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(v1);
  __cxa_rethrow();
}

void sub_221F56EF8(_Unwind_Exception *a1)
{
}

void std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_221F56F8C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_221F56FA4(_Unwind_Exception *a1)
{
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    unint64_t v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x223C938A0);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_221F57148(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_221F57160(_Unwind_Exception *a1)
{
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    unint64_t v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x223C938A0);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_221F57304(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_221F5731C(_Unwind_Exception *a1)
{
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    unint64_t v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x223C938A0);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_221F574C0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_221F574D8(_Unwind_Exception *a1)
{
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    unint64_t v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x223C938A0);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::shared_ptr<Phase::Geometry::Entity>::shared_ptr[abi:ne180100]<Phase::Geometry::Entity,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},void>(void *a1, uint64_t a2)
{
  *a1 = a2;
  operator new();
}

void sub_221F5767C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, __int16 a11, char a12, char a13)
{
  __cxa_begin_catch(a1);
  std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()((uint64_t)&a13, v13);
  __cxa_rethrow();
}

void sub_221F57694(_Unwind_Exception *a1)
{
}

void std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(uint64_t a1, void *a2)
{
  if (a2)
  {
    uint64_t v3 = (void *)a2[15];
    if (v3)
    {
      a2[16] = v3;
      operator delete(v3);
    }
    unint64_t v4 = (void *)a2[12];
    if (v4)
    {
      a2[13] = v4;
      operator delete(v4);
    }
    JUMPOUT(0x223C938A0);
  }
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Handle64,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void *std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (void *)result[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Entity>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void *std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (void *)result[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Environment>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

uint64_t Phase::Geometry::Listener::operator=(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = *(_OWORD *)a2;
  *(_DWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 16);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a1 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 76);
  *(_OWORD *)(a1 + 80) = *(_OWORD *)(a2 + 80);
  if (a1 != a2)
  {
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(a1 + 96), *(char **)(a2 + 96), *(void *)(a2 + 104), (uint64_t)(*(void *)(a2 + 104) - *(void *)(a2 + 96)) >> 3);
    std::vector<Phase::SpatialModeler::DirectivityHistogram *>::__assign_with_size[abi:ne180100]<Phase::SpatialModeler::DirectivityHistogram **,Phase::SpatialModeler::DirectivityHistogram **>((char *)(a1 + 120), *(char **)(a2 + 120), *(void *)(a2 + 128), (uint64_t)(*(void *)(a2 + 128) - *(void *)(a2 + 120)) >> 3);
  }
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(_DWORD *)(a1 + 160) = *(_DWORD *)(a2 + 160);
  *(_DWORD *)(a1 + 164) = *(_DWORD *)(a2 + 164);
  *(_DWORD *)(a1 + 168) = *(_DWORD *)(a2 + 168);
  long long v4 = *(_OWORD *)(a2 + 176);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(_OWORD *)(a1 + 17std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v4;
  return a1;
}

void *std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (void *)result[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Listener>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void *std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (void *)result[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Occluder>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void *std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1}::operator()(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = (void *)result[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_pointer<Phase::Geometry::Entity *,std::shared_ptr<Phase::Geometry::Entity> Phase::Geometry::CreateEntityFromEntity<Phase::Geometry::Source>(Phase::Geometry::System &,Phase::Geometry::Entity const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)::{lambda(void)#1}::operator() const(void)::{lambda(void *)#1},std::allocator<Phase::Geometry::Entity>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[15];
    if (v2)
    {
      v1[16] = v2;
      operator delete(v2);
    }
    uint64_t v3 = (void *)v1[12];
    if (v3)
    {
      v1[13] = v3;
      operator delete(v3);
    }
    JUMPOUT(0x223C938A0);
  }
  return result;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::EnvelopeDistanceModel>())()
{
  return Phase::GetTypeId<Phase::Geometry::EnvelopeDistanceModel>;
}

void Phase::Geometry::CreateEnvelopeDistanceModel(void *a1@<X8>)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  uint64_t v2 = operator new(0x58uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = &unk_26D476CB0;
  *((_DWORD *)v2 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 2;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  v2[10] = 0;
  *a1 = v2 + 3;
  a1[1] = v2;
  operator new();
}

void sub_221F58044(_Unwind_Exception *a1)
{
  std::__function::__value_func<float ()(float)>::~__value_func[abi:ne180100](v3);
  MEMORY[0x223C938A0](v2, 0xA0C40987D6AD5);
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Phase::Geometry::CreateEnvelopeDistanceModelFromDistanceModel(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)a1 == 2)
  {
    long long v4 = operator new(0x58uLL);
    v4[1] = 0;
    v4[2] = 0;
    void *v4 = &unk_26D476CB0;
    *((_DWORD *)v4 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 2;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *((_OWORD *)v4 + 4) = 0u;
    v4[10] = 0;
    *a2 = v4 + 3;
    a2[1] = v4;
    if (**(void **)(a1 + 40)) {
      operator new();
    }
    __assert_rtn("CreateEnvelopeDistanceModelFromDistanceModel", "GeoEnvelopeDistanceModel.mm", 48, "pSrcDistanceModel");
  }
  __assert_rtn("CreateEnvelopeDistanceModelFromDistanceModel", "GeoEnvelopeDistanceModel.mm", 43, "inDistanceModel.mType == DefaultDistanceModelType::Envelope");
}

void sub_221F582BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::vector<Phase::Envelope<float>::SegmentInternal,std::allocator<Phase::Envelope<float>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  MEMORY[0x223C938A0](v4, 0xA0C40987D6AD5);
  std::__shared_weak_count::__release_shared[abi:ne180100](v3);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<Phase::Geometry::DistanceModel>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D476CB0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::DistanceModel>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D476CB0;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

void std::__shared_ptr_emplace<Phase::Geometry::DistanceModel>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = (void **)(a1 + 64);
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](&v2);
  uint64_t v2 = (void **)(a1 + 40);
  std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__destroy_vector::operator()[abi:ne180100](&v2);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D476CE8;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D476CE8;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::EnvelopeDistanceModel>(Phase::Geometry::EnvelopeDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v4 = (void **)(v2 + 16);
    std::vector<Phase::Envelope<float>::SegmentInternal,std::allocator<Phase::Envelope<float>::SegmentInternal>>::__destroy_vector::operator()[abi:ne180100](&v4);
    return MEMORY[0x223C938A0](v2, 0xA0C40987D6AD5);
  }
  return result;
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::GeometricSpreadingDistanceModel>())()
{
  return Phase::GetTypeId<Phase::Geometry::GeometricSpreadingDistanceModel>;
}

void Phase::Geometry::CreateGeometricSpreadingDistanceModel(void *a1@<X8>)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  uint64_t v2 = operator new(0x58uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = &unk_26D476CB0;
  *((_DWORD *)v2 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  *((_OWORD *)v2 + 2) = 0u;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  v2[10] = 0;
  *a1 = v2 + 3;
  a1[1] = v2;
  operator new();
}

void sub_221F58614(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Phase::Geometry::CreateGeometricSpreadingDistanceModelFromDistanceModel(uint64_t a1@<X1>, void *a2@<X8>)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  if (*(_DWORD *)a1 == 1)
  {
    uint64_t v4 = operator new(0x58uLL);
    v4[1] = 0;
    v4[2] = 0;
    void *v4 = &unk_26D476CB0;
    *((_DWORD *)v4 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *((_OWORD *)v4 + 4) = 0u;
    v4[10] = 0;
    *a2 = v4 + 3;
    a2[1] = v4;
    if (**(void **)(a1 + 40)) {
      operator new();
    }
    __assert_rtn("CreateGeometricSpreadingDistanceModelFromDistanceModel", "GeoGeometricSpreadingDistanceModel.mm", 48, "pSrcDistanceModel");
  }
  __assert_rtn("CreateGeometricSpreadingDistanceModelFromDistanceModel", "GeoGeometricSpreadingDistanceModel.mm", 43, "inDistanceModel.mType == DefaultDistanceModelType::GeometricSpreading");
}

void sub_221F587D8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D476D30;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D476D30;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::GeometricSpreadingDistanceModel>(Phase::Geometry::GeometricSpreadingDistanceModel *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    JUMPOUT(0x223C938A0);
  }
  return result;
}

uint64_t Phase::Geometry::MaterialFactory::Create@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = *(void *)result;
  uint64_t v6 = *(void *)(*(void *)result + 968);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)result + 976) - v6) >> 5) <= a2) {
    __assert_rtn("GetTypeDef", "GeoMaterialTypeRegistry.cpp", 33, "IsValid(inMaterialType)");
  }
  uint64_t v7 = v6 + 96 * a2;
  if (*(void *)(v7 + 32))
  {
    return std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(v7 + 8, v5, a3);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
  return result;
}

uint64_t std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, a2, &v5);
}

uint64_t Phase::Geometry::MaterialFactory::Create@<X0>(uint64_t result@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v6 = *(void *)result;
  unint64_t v7 = *a2;
  uint64_t v8 = *(void *)(*(void *)result + 968);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)result + 976) - v8) >> 5) <= v7) {
    __assert_rtn("GetTypeDef", "GeoMaterialTypeRegistry.cpp", 33, "IsValid(inMaterialType)");
  }
  uint64_t v9 = v8 + 96 * v7;
  if (*(void *)(v9 + 64))
  {
    return std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(v9 + 40, v6, (uint64_t)a2, a3);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
  return result;
}

uint64_t std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a4;
  uint64_t v4 = *(void *)(a1 + 24);
  if (!v4) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t *))(*(void *)v4 + 48))(v4, a2, a3, &v6);
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *Phase::Geometry::MaterialTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v3) >> 5) <= a2) {
    __assert_rtn("CustomizeType", "GeoMaterialTypeRegistry.cpp", 43, "IsValid(inMaterialType)");
  }

  return std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((void *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;
  uint64_t vars8;

  uint64_t v3 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v3) >> 5) <= a2) {
    __assert_rtn("CustomizeType", "GeoMaterialTypeRegistry.cpp", 54, "IsValid(inMaterialType)");
  }

  return std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((void *)(v3 + 96 * a2 + 40), a3);
}

void *std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void *std::function<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void std::vector<Phase::Geometry::MaterialTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::MaterialTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::MaterialTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void std::vector<Phase::Geometry::LoadMaterialFunctionTableEntry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    BOOL v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 40;
        std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100]((void *)v4 - 4);
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    BOOL v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F591E4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    BOOL v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F59450(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::vector<Phase::Geometry::MaterialTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::MaterialTypeDefinition>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<Phase::Geometry::MaterialTypeDefinition>::__throw_length_error[abi:ne180100]()
{
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::MaterialTypeDefinition>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MaterialTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a3;
    while (1)
    {
      uint64_t v13 = a7 + v11;
      uint64_t v14 = a3 + v11;
      *(void *)(a7 + v11 - 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a3 + v11 - 96);
      uint64_t v15 = *(void *)(a3 + v11 - 64);
      if (!v15) {
        break;
      }
      if (v14 - 88 != v15)
      {
        uint64_t v16 = (void *)(v12 - 64);
        *(void *)(v13 - 64) = v15;
LABEL_7:
        void *v16 = 0;
        goto LABEL_9;
      }
      *(void *)(v13 - 64) = v13 - 88;
      (*(void (**)(void))(**(void **)(v14 - 64) + 24))(*(void *)(v14 - 64));
LABEL_9:
      uint64_t v17 = a7 + v11;
      uint64_t v18 = a3 + v11;
      uint64_t v19 = *(void *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(void *)(v17 - 32) = v17 - 56;
          (*(void (**)(void))(**(void **)(v18 - 32) + 24))(*(void *)(v18 - 32));
          goto LABEL_15;
        }
        uint64_t v20 = (void *)(v12 - 32);
        *(void *)(v17 - 32) = v19;
      }
      else
      {
        uint64_t v20 = (void *)(v17 - 32);
      }
      *uint64_t v20 = 0;
LABEL_15:
      v12 -= 96;
      uint64_t v21 = a7 + v11;
      uint64_t v22 = a3 + v11;
      *(void *)(v21 - 24) = 0;
      *(void *)(v21 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(void *)(v21 - 8) = *(void *)(a3 + v11 - 8);
      *(void *)(v22 - 24) = 0;
      *(void *)(v22 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5) {
        return a6;
      }
    }
    uint64_t v16 = (void *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

void *std::allocator<Phase::Geometry::MaterialTypeDefinition>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 8);
  uint64_t v5 = (void **)(a2 + 72);
  std::vector<Phase::Geometry::LoadMaterialFunctionTableEntry>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::Geometry::Material const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100]((void *)(a2 + 40));
  return std::__function::__value_func<std::shared_ptr<Phase::Geometry::Material> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v3);
}

void **std::__split_buffer<Phase::Geometry::MaterialTypeDefinition>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<Phase::Geometry::MaterialTypeDefinition>::clear[abi:ne180100](void *result)
{
  uint64_t v2 = result[1];
  uint64_t v1 = result[2];
  if (v1 != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = v3[4];
      v3[2] = v1 - 96;
      uint64_t result = std::allocator<Phase::Geometry::MaterialTypeDefinition>::destroy[abi:ne180100](v4, v1 - 96);
      uint64_t v1 = v3[2];
    }
    while (v1 != v2);
  }
  return result;
}

void std::vector<Phase::Geometry::MaterialTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      size_t v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL) {
      std::vector<Phase::Geometry::MaterialTypeDefinition>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x155555555555555) {
      unint64_t v11 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    uint64_t v16 = &v12[96 * v8];
    uint64_t v18 = &v12[96 * v11];
    size_t v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    std::vector<Phase::Geometry::MaterialTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::MaterialTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_221F5990C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::MaterialTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void Phase::Geometry::MdlMeshReader::MdlMeshReader(Phase::MdlMeshAsset *a1, const Phase::MdlMeshAsset *a2)
{
}

void sub_221F59968(_Unwind_Exception *a1)
{
  std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100]((id **)(v1 + 8), 0);
  _Unwind_Resume(a1);
}

void Phase::Geometry::MdlMeshReader::SetupVertexDescriptor(Phase::Geometry::MdlMeshReader *this)
{
  *(_OWORD *)std::string __p = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::resize((uint64_t *)&v12, 2uLL);
  std::vector<Phase::MdlMeshAsset::VertexDescriptor::Layout>::resize((uint64_t)&__p[1], 1uLL);
  Phase::sGetStdStringFromNsString((Phase *)*MEMORY[0x263F135C8], &v15);
  long long v8 = v15;
  uint64_t v10 = v16;
  uint64_t v2 = v12;
  if (*(char *)(v12 + 23) < 0) {
    operator delete(*(void **)v12);
  }
  *(_OWORD *)uint64_t v2 = v8;
  *(void *)(v2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v10;
  uint64_t v3 = (void *)v12;
  *(unsigned char *)(v12 + 24) = 47;
  v3[5] = 0;
  v3[6] = 0;
  v3[4] = 0;
  for (uint64_t i = 56; i != 68; i += 4)
    *(_DWORD *)(v12 + i) = 0;
  Phase::sGetStdStringFromNsString((Phase *)*MEMORY[0x263F135B8], &v15);
  long long v9 = v15;
  uint64_t v11 = v16;
  uint64_t v5 = v12;
  uint64_t v6 = v12 + 72;
  if (*(char *)(v12 + 95) < 0)
  {
    operator delete(*(void **)v6);
    uint64_t v5 = v12;
  }
  *(_OWORD *)uint64_t v6 = v9;
  *(void *)(v6 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v11;
  *(unsigned char *)(v5 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 47;
  *(void *)(v5 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = 0;
  *(void *)(v5 + 120) = 0;
  *(void *)(v5 + 104) = 12;
  for (uint64_t j = 128; j != 140; j += 4)
    *(_DWORD *)(v12 + j) = 0;
  *(void *)__p[1] = 24;
  Phase::MdlMeshAsset::SetVertexDescriptor((uint64_t)this, (uint64_t *)&v12);
  if (__p[1])
  {
    *(void **)&long long v14 = __p[1];
    operator delete(__p[1]);
  }
  *(void *)&long long v15 = &v12;
  std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destroy_vector::operator()[abi:ne180100]((void ***)&v15);
}

void sub_221F59AF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  Phase::MdlMeshAsset::VertexDescriptor::~VertexDescriptor((Phase::MdlMeshAsset::VertexDescriptor *)va);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::MdlMeshReader::CalculateAABB@<X0>(id **this@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)a2 = xmmword_2220A5C60;
  *(void *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0x80000000800000;
  uint64_t result = [*this[1] vertexCount];
  if (result)
  {
    uint64_t v5 = (float *)(this[2] + 1);
    float v6 = -3.4028e38;
    float v7 = 3.4028e38;
    float v8 = 3.4028e38;
    float v9 = 3.4028e38;
    float v10 = -3.4028e38;
    float v11 = -3.4028e38;
    do
    {
      float v12 = *(v5 - 2);
      float v13 = *(v5 - 1);
      float v7 = fminf(v7, v12);
      float v8 = fminf(v8, v13);
      float v14 = *v5;
      v5 += 6;
      float v9 = fminf(v9, v14);
      float v6 = fmaxf(v6, v12);
      float v10 = fmaxf(v10, v13);
      float v11 = fmaxf(v11, v14);
      --result;
    }
    while (result);
    *(float *)a2 = v7;
    *(float *)(a2 + 4) = v8;
    *(float *)(a2 + 8) = v9;
    *(float *)(a2 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v6;
    *(float *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v10;
    *(float *)(a2 + 20) = v11;
  }
  return result;
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0x8E38E38E38E38E39 * ((v3 - *a1) >> 3);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 72 * a2;
    while (v3 != v7)
    {
      if (*(char *)(v3 - 49) < 0) {
        operator delete(*(void **)(v3 - 72));
      }
      v3 -= 72;
    }
    a1[1] = v7;
  }
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Layout>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2) {
      *(void *)(a1 + 8) = *(void *)a1 + 8 * a2;
    }
  }
  else
  {
    std::vector<Phase::MdlMeshAsset::VertexDescriptor::Layout>::__append((char **)a1, a2 - v2);
  }
}

void Phase::MdlMeshAsset::VertexDescriptor::~VertexDescriptor(Phase::MdlMeshAsset::VertexDescriptor *this)
{
  unint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    *((void *)this + 4) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void **)this;
  std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destroy_vector::operator()[abi:ne180100](&v3);
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  unint64_t v2 = *a1;
  if (*v2)
  {
    std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__clear[abi:ne180100]((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 72)
  {
    if (*(char *)(i - 49) < 0) {
      operator delete(*(void **)(i - 72));
    }
  }
  a1[1] = v2;
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v13 = 72 * ((72 * a2 - 72) / 0x48) + 72;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0x8E38E38E38E38E39 * ((v7 - *a1) >> 3);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x38E38E38E38E38ELL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0x8E38E38E38E38E39 * ((v5 - *a1) >> 3);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x1C71C71C71C71C7) {
      unint64_t v11 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      float v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::DVM::Submix::ChannelStrip>>(v4, v11);
    }
    else {
      float v12 = 0;
    }
    long long v15 = v12;
    uint64_t v16 = &v12[72 * v8];
    uint64_t v18 = &v12[72 * v11];
    size_t v14 = 72 * ((72 * a2 - 72) / 0x48) + 72;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::~__split_buffer((uint64_t)&v15);
  }
}

void sub_221F59F10(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v17 = a6;
  *((void *)&v17 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a7;
  long long v16 = v17;
  v14[0] = a1;
  v14[1] = &v16;
  void v14[2] = &v17;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 72);
      *(void *)(v9 - 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a3 - 56);
      *(_OWORD *)(v9 - 72) = v10;
      *(void *)(a3 - 64) = 0;
      *(void *)(a3 - 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(a3 - 72) = 0;
      long long v11 = *(_OWORD *)(a3 - 48);
      long long v12 = *(_OWORD *)(a3 - 16);
      *(_OWORD *)(v9 - 32) = *(_OWORD *)(a3 - 32);
      *(_OWORD *)(v9 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v12;
      *(_OWORD *)(v9 - 48) = v11;
      v9 -= 72;
      v7 -= 72;
      a3 -= 72;
    }
    while (a3 != a5);
    *((void *)&v17 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v9;
  }
  char v15 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v14);
  return a6;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<Phase::MdlMeshAsset::VertexDescriptor::Attribute>,std::reverse_iterator<Phase::MdlMeshAsset::VertexDescriptor::Attribute*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 72;
  }
}

uint64_t std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<Phase::MdlMeshAsset::VertexDescriptor::Attribute>::__destruct_at_end[abi:ne180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 9;
      *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v2 - 9;
      if (*((char *)v2 - 49) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void std::vector<Phase::MdlMeshAsset::VertexDescriptor::Layout>::__append(char **a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = *a1;
    uint64_t v9 = v7 - *a1;
    unint64_t v10 = a2 + (v9 >> 3);
    if (v10 >> 61) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = v9 >> 3;
    uint64_t v12 = v5 - v8;
    if (v12 >> 2 > v10) {
      unint64_t v10 = v12 >> 2;
    }
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v13 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v13 = v10;
    }
    if (v13)
    {
      size_t v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<void *>>(v4, v13);
      uint64_t v8 = *a1;
      uint64_t v7 = a1[1];
    }
    else
    {
      size_t v14 = 0;
    }
    char v15 = &v14[8 * v11];
    long long v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    long long v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      uint64_t v18 = *((void *)v7 - 1);
      v7 -= 8;
      *((void *)v15 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
    {
      operator delete(v8);
    }
  }
}

uint64_t Phase::Geometry::MediumFactory::Create@<X0>(uint64_t result@<X0>, unsigned int a2@<W1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v5 = *(void *)result;
  uint64_t v6 = *(void *)(*(void *)result + 720);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(*(void *)result + 728) - v6) >> 5) <= a2) {
    __assert_rtn("GetTypeDef", "GeoMediumTypeRegistry.cpp", 33, "IsValid(inMediumType)");
  }
  uint64_t v7 = v6 + 96 * a2;
  if (*(void *)(v7 + 32))
  {
    return std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(v7 + 8, v5, a3);
  }
  else
  {
    *a4 = 0;
    a4[1] = 0;
  }
  return result;
}

uint64_t std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v3 = *(void *)(a1 + 24);
  if (!v3) {
    std::__throw_bad_function_call[abi:ne180100]();
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, a2, &v5);
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *Phase::Geometry::MediumTypeRegistry::CustomizeType(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v3) >> 5) <= a2) {
    __assert_rtn("CustomizeType", "GeoMediumTypeRegistry.cpp", 43, "IsValid(inMediumType)");
  }

  return std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((void *)(v3 + 96 * a2 + 8), a3);
}

{
  uint64_t v3;
  uint64_t vars8;

  uint64_t v3 = *(void *)(a1 + 8);
  if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(a1 + 16) - v3) >> 5) <= a2) {
    __assert_rtn("CustomizeType", "GeoMediumTypeRegistry.cpp", 54, "IsValid(inMediumType)");
  }

  return std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=((void *)(v3 + 96 * a2 + 40), a3);
}

void *std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void *std::function<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::operator=(void *a1, uint64_t a2)
{
  v4[4] = *MEMORY[0x263EF8340];
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100]((uint64_t)v4, a2);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](v4, a1);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v4);
  return a1;
}

void std::vector<Phase::Geometry::MediumTypeDefinition>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 5);
  BOOL v5 = a2 >= v4;
  unint64_t v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<Phase::Geometry::MediumTypeDefinition>::__append(a1, v6);
  }
  else if (!v5)
  {
    uint64_t v7 = *a1 + 96 * a2;
    while (v3 != v7)
    {
      v3 -= 96;
      std::allocator<Phase::Geometry::MediumTypeDefinition>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
    }
    a1[1] = v7;
  }
}

void std::vector<Phase::Geometry::LoadMediumFunctionTableEntry>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    unint64_t v4 = (char *)v1[1];
    BOOL v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        unint64_t v6 = v4 - 40;
        std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Asset &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100]((void *)v4 - 4);
        unint64_t v4 = v6;
      }
      while (v6 != v2);
      BOOL v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    BOOL v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F5AAE8(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

void *std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::swap[abi:ne180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x263EF8340];
  if (a2 != result)
  {
    uint64_t v3 = result;
    unint64_t v4 = (void *)result[3];
    BOOL v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void sub_221F5AD54(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::__value_func[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::vector<Phase::Geometry::MediumTypeDefinition>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::MediumTypeDefinition>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void std::vector<Phase::Geometry::MediumTypeDefinition>::__throw_length_error[abi:ne180100]()
{
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Phase::Geometry::MediumTypeDefinition>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>,std::reverse_iterator<Phase::Geometry::MediumTypeDefinition*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    uint64_t v11 = 0;
    uint64_t v12 = a3;
    while (1)
    {
      uint64_t v13 = a7 + v11;
      uint64_t v14 = a3 + v11;
      *(void *)(a7 + v11 - 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a3 + v11 - 96);
      uint64_t v15 = *(void *)(a3 + v11 - 64);
      if (!v15) {
        break;
      }
      if (v14 - 88 != v15)
      {
        long long v16 = (void *)(v12 - 64);
        *(void *)(v13 - 64) = v15;
LABEL_7:
        void *v16 = 0;
        goto LABEL_9;
      }
      *(void *)(v13 - 64) = v13 - 88;
      (*(void (**)(void))(**(void **)(v14 - 64) + 24))(*(void *)(v14 - 64));
LABEL_9:
      uint64_t v17 = a7 + v11;
      uint64_t v18 = a3 + v11;
      uint64_t v19 = *(void *)(a3 + v11 - 32);
      if (v19)
      {
        if (v18 - 56 == v19)
        {
          *(void *)(v17 - 32) = v17 - 56;
          (*(void (**)(void))(**(void **)(v18 - 32) + 24))(*(void *)(v18 - 32));
          goto LABEL_15;
        }
        uint64_t v20 = (void *)(v12 - 32);
        *(void *)(v17 - 32) = v19;
      }
      else
      {
        uint64_t v20 = (void *)(v17 - 32);
      }
      *uint64_t v20 = 0;
LABEL_15:
      v12 -= 96;
      uint64_t v21 = a7 + v11;
      uint64_t v22 = a3 + v11;
      *(void *)(v21 - 24) = 0;
      *(void *)(v21 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v21 - 8) = 0;
      *(_OWORD *)(v21 - 24) = *(_OWORD *)(a3 + v11 - 24);
      *(void *)(v21 - 8) = *(void *)(a3 + v11 - 8);
      *(void *)(v22 - 24) = 0;
      *(void *)(v22 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
      *(void *)(v22 - 8) = 0;
      v11 -= 96;
      if (a3 + v11 == a5) {
        return a6;
      }
    }
    long long v16 = (void *)(v13 - 64);
    goto LABEL_7;
  }
  return a6;
}

void *std::allocator<Phase::Geometry::MediumTypeDefinition>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (void *)(a2 + 8);
  uint64_t v5 = (void **)(a2 + 72);
  std::vector<Phase::Geometry::LoadMediumFunctionTableEntry>::__destroy_vector::operator()[abi:ne180100](&v5);
  std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::Geometry::Medium const&,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100]((void *)(a2 + 40));
  return std::__function::__value_func<std::shared_ptr<Phase::Geometry::Medium> ()(Phase::Geometry::System &,Phase::UnorderedStringMap<Phase::OptionsValue> *)>::~__value_func[abi:ne180100](v3);
}

void **std::__split_buffer<Phase::Geometry::MediumTypeDefinition>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void *std::__split_buffer<Phase::Geometry::MediumTypeDefinition>::clear[abi:ne180100](void *result)
{
  uint64_t v2 = result[1];
  uint64_t v1 = result[2];
  if (v1 != v2)
  {
    uint64_t v3 = result;
    do
    {
      uint64_t v4 = v3[4];
      v3[2] = v1 - 96;
      uint64_t result = std::allocator<Phase::Geometry::MediumTypeDefinition>::destroy[abi:ne180100](v4, v1 - 96);
      uint64_t v1 = v3[2];
    }
    while (v1 != v2);
  }
  return result;
}

void std::vector<Phase::Geometry::MediumTypeDefinition>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 5) >= a2)
  {
    if (a2)
    {
      size_t v13 = 96 * ((96 * a2 - 96) / 0x60) + 96;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 5);
    unint64_t v9 = v8 + a2;
    if (v8 + a2 > 0x2AAAAAAAAAAAAAALL) {
      std::vector<Phase::Geometry::MediumTypeDefinition>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 5);
    if (2 * v10 > v9) {
      unint64_t v9 = 2 * v10;
    }
    if (v10 >= 0x155555555555555) {
      unint64_t v11 = 0x2AAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v11 = v9;
    }
    uint64_t v19 = v4;
    if (v11) {
      uint64_t v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::Controller::VoiceData>>(v4, v11);
    }
    else {
      uint64_t v12 = 0;
    }
    uint64_t v15 = v12;
    long long v16 = &v12[96 * v8];
    uint64_t v18 = &v12[96 * v11];
    size_t v14 = 96 * ((96 * a2 - 96) / 0x60) + 96;
    bzero(v16, v14);
    uint64_t v17 = &v16[v14];
    std::vector<Phase::Geometry::MediumTypeDefinition>::__swap_out_circular_buffer(a1, &v15);
    std::__split_buffer<Phase::Geometry::MediumTypeDefinition>::~__split_buffer(&v15);
  }
}

void sub_221F5B210(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Phase::Geometry::MediumTypeDefinition>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t (*Phase::GetTypeId<Phase::Geometry::Mesh>())()
{
  return Phase::GetTypeId<Phase::Geometry::Mesh>;
}

void Phase::Geometry::CreateMesh(void *a1@<X8>)
{
  uint64_t v2 = (char *)operator new(0xC0uLL);
  *((_DWORD *)v2 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 1;
  *((void *)v2 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
  *((void *)v2 + 2) = 0;
  *(void *)uint64_t v2 = &unk_26D476E40;
  *((_OWORD *)v2 + 2) = xmmword_2220A5C70;
  *((_OWORD *)v2 + 3) = 0u;
  *((_OWORD *)v2 + 4) = 0u;
  *(_OWORD *)(v2 + 7std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)v2 + std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0u;
  *((_OWORD *)v2 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0u;
  *((_OWORD *)v2 + 8) = 0u;
  *((_OWORD *)v2 + 9) = 0u;
  *((_OWORD *)v2 + 10) = 0u;
  *((_OWORD *)v2 + 1Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = xmmword_2220A5C80;
  *a1 = v2 + 24;
  a1[1] = v2;
  Phase::Geometry::AddMesh((uint64_t)(v2 + 24), 0);
}

void sub_221F5B2C4(_Unwind_Exception *a1)
{
  std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void Phase::Geometry::AddMesh(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v2 = 2 * a2;
  unint64_t v3 = 2 * a2 + 4;
  uint64_t v4 = (void *)(a1 + 96);
  unint64_t v5 = (uint64_t)(*(void *)(a1 + 104) - *(void *)(a1 + 96)) >> 4;
  std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize((uint64_t *)(a1 + 96), v3);
  if (v5 < v3)
  {
    uint64_t v6 = v5 - v2 - 4;
    uint64_t v7 = 16 * v5;
    do
    {
      unint64_t v8 = (char *)operator new(0x40uLL);
      *((void *)v8 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
      *((void *)v8 + 2) = 0;
      *(void *)unint64_t v8 = &unk_26D476D78;
      *((void *)v8 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
      *(_OWORD *)(v8 + 24) = 0u;
      *(_OWORD *)(v8 + 40) = 0u;
      unint64_t v9 = (void *)(*v4 + v7);
      unint64_t v10 = (std::__shared_weak_count *)v9[1];
      *unint64_t v9 = v8 + 24;
      v9[1] = v8;
      if (v10) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v10);
      }
      v7 += 16;
    }
    while (!__CFADD__(v6++, 1));
  }
  operator new();
}

void sub_221F5B6D0(_Unwind_Exception *exception_object)
{
  if (v1) {
    MEMORY[0x223C93870](v1, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void Phase::Geometry::CreateMeshFromMdlMesh(uint64_t a1, const Phase::MdlMeshAsset *a2)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  Phase::Geometry::MdlMeshReader::MdlMeshReader((Phase::MdlMeshAsset *)v2, a2);
}

void sub_221F5C590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34)
{
  if (__p)
  {
    a34 = (uint64_t)__p;
    operator delete(__p);
  }
  std::__shared_weak_count::__release_shared[abi:ne180100](v34);
  std::unique_ptr<Phase::details::MdlMeshAssetImplementation>::reset[abi:ne180100]((id **)&a31, 0);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::DataStreamReference<Phase::Vector<float,3ul>>::Resize(uint64_t result, unint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void *)(**(void **)result + 16 * *(void *)(result + 8));
  unint64_t v5 = *(void *)(v4 + 24);
  if (v5 == a2)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = *(void *)(v4 + 8);
    *(void *)(v4 + 8) = 0;
    if (a2)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v4 + 16), *(void *)(v4 + 32) * a2, &v18);
      uint64_t v7 = v18;
      uint64_t v18 = 0;
      uint64_t result = *(void *)(v4 + 8);
      *(void *)(v4 + 8) = v7;
      if (result)
      {
        MEMORY[0x223C93870](result, 0x1000C8077774924);
        uint64_t result = v18;
        uint64_t v18 = 0;
        if (result) {
          uint64_t result = MEMORY[0x223C93870](result, 0x1000C8077774924);
        }
      }
    }
    *(void *)(v4 + 24) = a2;
  }
  if (v5 >= a2) {
    unint64_t v8 = a2;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    unint64_t v9 = (_DWORD *)(*(void *)(v4 + 8) + 8);
    unint64_t v10 = (int *)(v6 + 8);
    unint64_t v11 = v8;
    do
    {
      *(v9 - 2) = *(v10 - 2);
      *(v9 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(v10 - 1);
      int v12 = *v10;
      v10 += 3;
      *unint64_t v9 = v12;
      v9 += 3;
      --v11;
    }
    while (v11);
  }
  if (v5 < a2)
  {
    uint64_t v13 = *(void *)(**(void **)v3 + 16 * *(void *)(v3 + 8));
    uint64_t v14 = *(void *)(v13 + 8);
    uint64_t v15 = *(void *)(v13 + 32);
    unint64_t v16 = a2 - v8;
    uint64_t v17 = (_DWORD *)(v14 + v15 * v8 + 8);
    do
    {
      *((void *)v17 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
      *uint64_t v17 = 0;
      uint64_t v17 = (_DWORD *)((char *)v17 + v15);
      --v16;
    }
    while (v16);
  }
  if (v6) {
    return MEMORY[0x223C93870](v6, 0x1000C8077774924);
  }
  return result;
}

void sub_221F5C790(_Unwind_Exception *exception_object)
{
  if (v1) {
    MEMORY[0x223C93870](v1, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<float>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (unsigned char *)*a1) >> 2)
  {
    if (a2 >> 62) {
      std::vector<float>::__throw_length_error[abi:ne180100]();
    }
    int64_t v5 = (unsigned char *)a1[1] - (unsigned char *)*a1;
    uint64_t v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v3, a2);
    uint64_t v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    unint64_t v9 = &v6[4 * v8];
    unint64_t v10 = (char *)*a1;
    unint64_t v11 = (char *)a1[1];
    int v12 = v7;
    if (v11 != *a1)
    {
      int v12 = v7;
      do
      {
        int v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

uint64_t Phase::Geometry::DataStreamReference<unsigned int>::Resize(uint64_t result, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = *(void *)(result + 16 * a2);
  unint64_t v5 = *(void *)(v4 + 24);
  if (v5 == a3)
  {
    if (!a3) {
      return result;
    }
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = *(void *)(v4 + 8);
    *(void *)(v4 + 8) = 0;
    if (a3)
    {
      Phase::Geometry::DataStream::Alloc(*(std::align_val_t *)(v4 + 16), *(void *)(v4 + 32) * a3, &v10);
      uint64_t v7 = v10;
      uint64_t v10 = 0;
      uint64_t result = *(void *)(v4 + 8);
      *(void *)(v4 + 8) = v7;
      if (result)
      {
        MEMORY[0x223C93870](result, 0x1000C8077774924);
        uint64_t result = v10;
        uint64_t v10 = 0;
        if (result) {
          uint64_t result = MEMORY[0x223C93870](result, 0x1000C8077774924);
        }
      }
    }
    *(void *)(v4 + 24) = v3;
    if (v5 < v3) {
      unint64_t v3 = v5;
    }
    if (!v3)
    {
      if (!v6) {
        return result;
      }
      return MEMORY[0x223C93870](v6, 0x1000C8077774924);
    }
  }
  uint64_t v8 = 0;
  uint64_t v9 = *(void *)(v4 + 8);
  do
  {
    *(_DWORD *)(v9 + 4 * v8) = *(_DWORD *)(v6 + 4 * v8);
    ++v8;
  }
  while (v3 != v8);
  return MEMORY[0x223C93870](v6, 0x1000C8077774924);
}

void sub_221F5C964(_Unwind_Exception *exception_object)
{
  if (v1) {
    MEMORY[0x223C93870](v1, 0x1000C8077774924);
  }
  _Unwind_Resume(exception_object);
}

BOOL Phase::Geometry::MdlMeshReader::GetTriangle<unsigned int>(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, _DWORD *a5, unsigned int *a6, uint64_t a7, float *a8)
{
  *a4 = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>((id **)a1, a2, a3);
  *a5 = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>((id **)a1, a2, a3 + 1);
  unsigned int Vertex = Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>((id **)a1, a2, a3 + 2);
  *a6 = Vertex;
  uint64_t v17 = *(void *)(a1 + 16);
  uint64_t v18 = (_DWORD *)(v17 + 24 * *a4);
  *(_DWORD *)a7 = *v18;
  *(_DWORD *)(a7 + 4) = v18[1];
  *(_DWORD *)(a7 + 8) = v18[2];
  uint64_t v19 = (_DWORD *)(v17 + 24 * *a5);
  *(_DWORD *)(a7 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *v19;
  *(_DWORD *)(a7 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v19[1];
  *(_DWORD *)(a7 + 20) = v19[2];
  uint64_t v20 = (_DWORD *)(v17 + 24 * Vertex);
  *(_DWORD *)(a7 + 24) = *v20;
  *(_DWORD *)(a7 + 28) = v20[1];
  *(_DWORD *)(a7 + 32) = v20[2];
  Phase::UnnormalizedNormalCCW<float>((float *)a7, &v23);
  float v21 = sqrtf((float)((float)(v23 * v23) + (float)(v24 * v24)) + (float)(v25 * v25)) * 0.5;
  *a8 = v21;
  return v21 > 0.00000011921;
}

float Phase::Enclose<float>@<S0>(float *a1@<X0>, float *a2@<X1>, float *a3@<X8>)
{
  float v3 = a2[1];
  float v5 = a2[2];
  float v4 = a2[3];
  float v6 = a2[4];
  float v7 = a2[5];
  float v8 = a2[6];
  float v9 = a2[7];
  float v10 = fminf(fminf(*a2, v4), v8);
  float v11 = fminf(fminf(v3, v6), v9);
  float v12 = a2[8];
  float v13 = fminf(fminf(v5, v7), v12);
  float v14 = fmaxf(*a2, v4);
  float v15 = fmaxf(fmaxf(v3, v6), v9);
  float v16 = fmaxf(fmaxf(v5, v7), v12);
  float v17 = fminf(*a1, v10);
  float v18 = fminf(a1[1], v11);
  float v19 = a1[3];
  float v20 = fminf(a1[2], v13);
  *a3 = v17;
  a3[1] = v18;
  float result = fmaxf(v19, fmaxf(v14, v8));
  float v22 = fmaxf(a1[4], v15);
  float v23 = fmaxf(a1[5], v16);
  a3[2] = v20;
  a3[3] = result;
  a3[4] = v22;
  a3[5] = v23;
  return result;
}

void Phase::Geometry::CreateMeshFromShape(_DWORD *a1@<X1>, void *a2@<X2>, void *a3@<X8>)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  if (*a1 == 1)
  {
    Phase::Geometry::ForcedCopyTagsIncludingMaterialListFromOptions(1uLL, a2, &__p);
    std::vector<unsigned int>::pointer end = __p.__end_;
    if (__p.__end_ >= __p.__end_cap_.__value_)
    {
      begiuint64_t n = __p.__begin_;
      int64_t v8 = __p.__end_ - __p.__begin_;
      unint64_t v9 = v8 + 1;
      if ((unint64_t)(v8 + 1) >> 62) {
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      }
      int64_t v10 = (char *)__p.__end_cap_.__value_ - (char *)__p.__begin_;
      if (((char *)__p.__end_cap_.__value_ - (char *)__p.__begin_) >> 1 > v9) {
        unint64_t v9 = v10 >> 1;
      }
      if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v11 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v11 = v9;
      }
      if (v11)
      {
        float v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&__p.__end_cap_, v11);
        begiuint64_t n = __p.__begin_;
        std::vector<unsigned int>::pointer end = __p.__end_;
      }
      else
      {
        float v12 = 0;
      }
      float v13 = (unsigned int *)&v12[4 * v8];
      float v14 = (unsigned int *)&v12[4 * v11];
      *float v13 = 4;
      float v6 = v13 + 1;
      while (end != begin)
      {
        unsigned int v15 = *--end;
        *--float v13 = v15;
      }
      __p.__begin_ = v13;
      __p.__end_ = v6;
      __p.__end_cap_.__value_ = v14;
      if (begin) {
        operator delete(begin);
      }
    }
    else
    {
      *__p.__end_ = 4;
      float v6 = end + 1;
    }
    __p.__end_ = v6;
    std::allocate_shared[abi:ne180100]<Phase::Geometry::Shape,std::allocator<Phase::Geometry::Shape>,Phase::Geometry::Shape&,std::vector<unsigned int> &,void>((uint64_t)a1, (__int32 **)&__p, a3);
    operator new();
  }
  std::terminate();
}

void sub_221F5CDFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

float Phase::Geometry::GetNormals(uint64_t a1, unsigned int *a2, int a3, uint64_t a4, int a5, uint64_t a6)
{
  uint64_t v6 = a3 * a6;
  if (v6 >= 1)
  {
    float v7 = (unsigned int *)((char *)a2 + v6);
    uint64_t v8 = *(void *)(**(void **)(a1 + 48) + 16 * *(void *)(a1 + 56));
    uint64_t v9 = *(void *)(v8 + 8);
    uint64_t v10 = *(void *)(v8 + 32);
    unint64_t v11 = (float *)(a4 + 8);
    do
    {
      unint64_t v12 = *a2;
      uint64_t v13 = *(void *)(**(void **)(v9 + v10 * (v12 >> 24) + 48) + 16 * *(void *)(v9 + v10 * (v12 >> 24) + 56));
      uint64_t v14 = *(void *)(v13 + 8) + *(void *)(v13 + 32) * (v12 & 0xFFFFFF);
      *(v11 - 2) = *(float *)v14;
      *(v11 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = *(float *)(v14 + 4);
      float result = *(float *)(v14 + 8);
      float *v11 = result;
      a2 = (unsigned int *)((char *)a2 + a3);
      unint64_t v11 = (float *)((char *)v11 + a5);
    }
    while (a2 < v7);
  }
  return result;
}

{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float *v11;
  float *v12;
  float result;

  uint64_t v6 = a3 * a6;
  if (v6 >= 1)
  {
    float v7 = (unsigned int *)((char *)a2 + v6);
    uint64_t v8 = *(void *)(**(void **)(a1 + 48) + 16 * *(void *)(a1 + 56));
    uint64_t v9 = *(void *)(v8 + 8);
    uint64_t v10 = *(void *)(v8 + 32);
    unint64_t v11 = (float *)(a4 + 8);
    do
    {
      unint64_t v12 = (float *)(v9 + v10 * *a2);
      *(v11 - 2) = *v12;
      *(v11 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v12[1];
      float result = v12[2];
      float *v11 = result;
      a2 = (unsigned int *)((char *)a2 + a3);
      unint64_t v11 = (float *)((char *)v11 + a5);
    }
    while (a2 < v7);
  }
  return result;
}

{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float *v14;
  float *v15;
  float result;

  uint64_t v6 = a3 * a6;
  if (v6 >= 1)
  {
    float v7 = (unsigned int *)((char *)a2 + v6);
    uint64_t v8 = *(void *)(*(void *)(**(void **)(a1 + 40) + 16 * *(void *)(a1 + 48)) + 8);
    uint64_t v9 = *(void **)(**(void **)(v8 + 40) + 16 * *(void *)(v8 + 48));
    uint64_t v10 = v9[1] + (v9[3] - 1) * v9[4];
    unint64_t v11 = *(void *)(**(void **)(v10 + 40) + 16 * *(void *)(v10 + 48));
    unint64_t v12 = *(void *)(v11 + 8);
    uint64_t v13 = *(void *)(v11 + 32);
    uint64_t v14 = (float *)(a4 + 8);
    do
    {
      unsigned int v15 = (float *)(v12 + v13 * *a2);
      *(v14 - 2) = *v15;
      *(v14 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v15[1];
      float result = v15[2];
      unsigned int *v14 = result;
      a2 = (unsigned int *)((char *)a2 + a3);
      uint64_t v14 = (float *)((char *)v14 + a5);
    }
    while (a2 < v7);
  }
  return result;
}

float Phase::Geometry::GetNormals(uint64_t a1, float *a2, unsigned int *a3, int a4, uint64_t a5, int a6, uint64_t a7)
{
  uint64_t v7 = a4;
  uint64_t v8 = a4 * a7;
  if (v8 >= 1)
  {
    uint64_t v9 = a3;
    uint64_t v12 = a6;
    unint64_t v13 = (unint64_t)a3 + v8;
    uint64_t v14 = (_DWORD *)(a5 + 8);
    do
    {
      unint64_t v15 = *v9;
      uint64_t v16 = *(void *)(**(void **)(a1 + 48) + 16 * *(void *)(a1 + 56));
      uint64_t v17 = *(void *)(**(void **)(*(void *)(v16 + 8) + *(void *)(v16 + 32) * (v15 >> 24) + 48)
                      + 16 * *(void *)(*(void *)(v16 + 8) + *(void *)(v16 + 32) * (v15 >> 24) + 56));
      Phase::operator*<float>(a2, (float *)(*(void *)(v17 + 8) + *(void *)(v17 + 32) * (v15 & 0xFFFFFF)), (float *)&v19);
      *((void *)v14 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v19;
      float result = v20;
      *(float *)uint64_t v14 = v20;
      uint64_t v9 = (unsigned int *)((char *)v9 + v7);
      uint64_t v14 = (_DWORD *)((char *)v14 + v12);
    }
    while ((unint64_t)v9 < v13);
  }
  return result;
}

{
  uint64_t v7;
  uint64_t v8;
  unsigned int *v9;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  float result;
  uint64_t v19;
  float v20;

  uint64_t v7 = a4;
  uint64_t v8 = a4 * a7;
  if (v8 >= 1)
  {
    uint64_t v9 = a3;
    unint64_t v11 = a6;
    uint64_t v12 = (unint64_t)a3 + v8;
    unint64_t v13 = *(void *)(*(void *)(**(void **)(a1 + 40) + 16 * *(void *)(a1 + 48)) + 8);
    uint64_t v14 = *(void **)(**(void **)(v13 + 40) + 16 * *(void *)(v13 + 48));
    unint64_t v15 = v14[1] + (v14[3] - 1) * v14[4];
    uint64_t v16 = (_DWORD *)(a5 + 8);
    do
    {
      uint64_t v17 = *(void *)(**(void **)(v15 + 40) + 16 * *(void *)(v15 + 48));
      Phase::operator*<float>(a2, (float *)(*(void *)(v17 + 8) + *(void *)(v17 + 32) * *v9), (float *)&v19);
      *((void *)v16 - Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v19;
      float result = v20;
      *(float *)uint64_t v16 = v20;
      uint64_t v9 = (unsigned int *)((char *)v9 + v7);
      uint64_t v16 = (_DWORD *)((char *)v16 + v11);
    }
    while ((unint64_t)v9 < v12);
  }
  return result;
}

void Phase::Geometry::GetMaterials(BOOL a1, unsigned int *a2, int a3, void *a4, int a5, uint64_t a6)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  uint64_t v6 = a3;
  uint64_t v7 = a3 * a6;
  if (v7 >= 1)
  {
    uint64_t v9 = a2;
    uint64_t v10 = a1;
    uint64_t v20 = a5;
    unint64_t v11 = (unint64_t)a2 + v7;
    while (1)
    {
      unint64_t v12 = (unint64_t)*v9 >> 24;
      unint64_t v13 = *(void **)(**(void **)(v10 + 48) + 16 * *(void *)(v10 + 56));
      unint64_t v14 = v13[3];
      if (v14 <= v12) {
        break;
      }
      uint64_t v15 = *(unsigned int *)(v13[1] + v13[4] * v12 + 28);
      uint64_t v16 = *(void *)(**(void **)(*(void *)(v10 + 8) + 144) + 16 * *(void *)(*(void *)(v10 + 8) + 152));
      unsigned int v17 = *(_DWORD *)(v16 + 24);
      if (v15 >= v17) {
        goto LABEL_7;
      }
      uint64_t v18 = *(void *)(*(void *)(v16 + 8) + *(void *)(v16 + 32) * v15);
LABEL_10:
      *a4 = v18;
      a4 = (void *)((char *)a4 + v20);
      uint64_t v9 = (unsigned int *)((char *)v9 + v6);
      if ((unint64_t)v9 >= v11) {
        return;
      }
    }
    LODWORD(v15) = -1;
    unsigned int v17 = -1;
LABEL_7:
    uint64_t v19 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 208);
    a1 = os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    if (a1)
    {
      *(_DWORD *)buf = 136316418;
      float v22 = "GeoMesh.cpp";
      __int16 v23 = 1024;
      int v24 = 576;
      __int16 v25 = 1024;
      int v26 = v12;
      __int16 v27 = 1024;
      int v28 = v14;
      __int16 v29 = 1024;
      int v30 = v15;
      __int16 v31 = 1024;
      unsigned int v32 = v17;
      _os_log_impl(&dword_221E5E000, v19, OS_LOG_TYPE_ERROR, "%25s:%-5d GeoMesh.cpp: GetMaterials: Index out of range. Submesh Index: %i, Count:%i, Material Index: %i, Count:%i.\n", buf, 0x2Au);
    }
    uint64_t v18 = 0;
    goto LABEL_10;
  }
}

{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v9;
  uint64_t v10;
  unint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  __int16 v37;
  int v38;
  __int16 v39;
  unsigned int v40;
  uint64_t v41;

  uint64_t v41 = *MEMORY[0x263EF8340];
  uint64_t v6 = a3;
  uint64_t v7 = a3 * a6;
  if (v7 >= 1)
  {
    uint64_t v9 = a2;
    uint64_t v10 = a1;
    __int16 v23 = (unint64_t)a2 + v7;
    int v24 = a5;
    while (1)
    {
      unint64_t v11 = *v9;
      unint64_t v12 = *(void **)(**(void **)(v10 + 64) + 16 * *(void *)(v10 + 72));
      if (v12[3] <= v11) {
        break;
      }
      unint64_t v13 = *(unsigned __int16 *)(v12[1] + v12[4] * v11);
      unint64_t v14 = *(void *)(**(void **)(v10 + 80) + 16 * *(void *)(v10 + 88));
      uint64_t v15 = *(_DWORD *)(v14 + 24);
      if ((int)v13 >= v15) {
        goto LABEL_8;
      }
      uint64_t v16 = *(unsigned int *)(*(void *)(v14 + 8) + *(void *)(v14 + 32) * v13 + 56);
      unsigned int v17 = *(void *)(**(void **)(*(void *)(v10 + 8) + 144) + 16 * *(void *)(*(void *)(v10 + 8) + 152));
      uint64_t v18 = *(_DWORD *)(v17 + 24);
      if (v16 >= v18) {
        goto LABEL_9;
      }
      uint64_t v19 = *(void *)(*(void *)(v17 + 8) + *(void *)(v17 + 32) * v16);
LABEL_12:
      *a4 = v19;
      a4 = (void *)((char *)a4 + v24);
      uint64_t v9 = (unsigned int *)((char *)v9 + v6);
      if ((unint64_t)v9 >= v23) {
        return;
      }
    }
    LODWORD(vstd::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 13) = 0xFFFF;
    uint64_t v15 = -1;
LABEL_8:
    LODWORD(v1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = -1;
    uint64_t v18 = -1;
LABEL_9:
    uint64_t v20 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)a1) + 208);
    a1 = os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
    if (a1)
    {
      float v21 = *v9;
      float v22 = *(void *)(*(void *)(**(void **)(v10 + 64) + 16 * *(void *)(v10 + 72)) + 24);
      *(_DWORD *)buf = 136316930;
      int v26 = "GeoMpsMesh.cpp";
      __int16 v27 = 1024;
      int v28 = 468;
      __int16 v29 = 1024;
      int v30 = v21;
      __int16 v31 = 1024;
      unsigned int v32 = v22;
      uint64_t v33 = 1024;
      uint64_t v34 = v13;
      double v35 = 1024;
      uint64_t v36 = v15;
      double v37 = 1024;
      unint64_t v38 = v16;
      double v39 = 1024;
      double v40 = v18;
      _os_log_impl(&dword_221E5E000, v20, OS_LOG_TYPE_ERROR, "%25s:%-5d GeoMpsMesh.cpp: GetMaterials: index out of range. Primitive Index: %i, Count: %i, Submesh Index: %i, Count: %i, Material Index: %i, Count: %i.\n", buf, 0x36u);
    }
    uint64_t v19 = 0;
    goto LABEL_12;
  }
}

void std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3 = a1[1];
  unint64_t v4 = (v3 - *a1) >> 4;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v6 = *a1 + 16 * a2;
      while (v3 != v6)
      {
        uint64_t v7 = *(std::__shared_weak_count **)(v3 - 8);
        if (v7) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v7);
        }
        v3 -= 16;
      }
      a1[1] = v6;
    }
  }
  else
  {
    unint64_t v5 = a2 - v4;
    std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::__append(a1, v5);
  }
}

void std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t v4 = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - *a1;
    unint64_t v9 = a2 + (v8 >> 4);
    if (v9 >> 60) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 4;
    uint64_t v11 = v5 - *a1;
    if (v11 >> 3 > v9) {
      unint64_t v9 = v11 >> 3;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v12 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    uint64_t v18 = v4;
    if (v12) {
      unint64_t v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<Phase::UniqueObjectId>>(v4, v12);
    }
    else {
      unint64_t v13 = 0;
    }
    unint64_t v14 = v13;
    uint64_t v15 = &v13[16 * v10];
    unsigned int v17 = &v13[16 * v12];
    bzero(v15, 16 * a2);
    uint64_t v16 = &v15[16 * a2];
    std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<std::shared_ptr<Phase::Geometry::SharedDataStream>>::~__split_buffer(&v14);
  }
}

void sub_221F5D2CC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<std::shared_ptr<Phase::Geometry::SharedDataStream>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<Phase::Geometry::SharedDataStream>>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>>((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::shared_ptr<Phase::Geometry::SharedDataStream>>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    uint64_t v10 = a6;
  }
  else
  {
    uint64_t v8 = (_OWORD *)(a7 - 16);
    do
    {
      long long v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      _OWORD *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((void *)&v15 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    uint64_t v10 = v15;
  }
  char v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<Phase::Geometry::SharedDataStream>>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<Phase::Geometry::SharedDataStream>>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<Phase::Geometry::SharedDataStream>>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>>::operator()[abi:ne180100](a1);
  }
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::shared_ptr<Phase::Geometry::SharedDataStream>>,std::reverse_iterator<std::shared_ptr<Phase::Geometry::SharedDataStream>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v1 + 8);
    if (v3) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v3);
    }
    v1 += 16;
  }
}

void **std::__split_buffer<std::shared_ptr<Phase::Geometry::SharedDataStream>>::~__split_buffer(void **a1)
{
  if (*a1) {
    operator delete(*a1);
  }
  return a1;
}

void std::__split_buffer<std::shared_ptr<Phase::Geometry::SharedDataStream>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v1 = *(void *)(a1 + 16);
  while (v1 != v2)
  {
    *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v1 - 16;
    uint64_t v4 = *(std::__shared_weak_count **)(v1 - 8);
    if (v4)
    {
      std::__shared_weak_count::__release_shared[abi:ne180100](v4);
      uint64_t v1 = *(void *)(a1 + 16);
    }
    else
    {
      v1 -= 16;
    }
  }
}

void std::__shared_ptr_emplace<Phase::Geometry::SharedDataStream>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D476D78;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::SharedDataStream>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D476D78;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

uint64_t std::__shared_ptr_emplace<Phase::Geometry::SharedDataStream>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (result) {
    JUMPOUT(0x223C93870);
  }
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1}>,void ()(void *)>::~__func()
{
}

void *std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1}>,void ()(void *)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_26D476DB0;
  return result;
}

void std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1}>,void ()(void *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_26D476DB0;
}

uint64_t std::__function::__func<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1},std::allocator<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>> Phase::Geometry::MakeDataMapPtr<Phase::Geometry::Mesh>(Phase::Geometry::Mesh *)::{lambda(void *)#1}>,void ()(void *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    JUMPOUT(0x223C938A0);
  }
  return result;
}

void *Phase::Geometry::DataStream::Alloc@<X0>(std::align_val_t this@<X0>, size_t __sz@<X1>, void *a3@<X8>)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (__sz)
  {
    if (this)
    {
      if ((this & (this - 1)) != 0)
      {
        uint64_t v6 = **(NSObject ***)(Phase::Logger::GetInstance((Phase::Logger *)this) + 416);
        if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        {
          int v8 = 136315650;
          long long v9 = "GeoData.hpp";
          __int16 v10 = 1024;
          int v11 = 186;
          __int16 v12 = 2048;
          std::align_val_t v13 = this;
          _os_log_impl(&dword_221E5E000, v6, OS_LOG_TYPE_ERROR, "%25s:%-5d EXCEPTION (std::logic_error) [!Phase::IsPowerOfTwo(inAlignment) is true]: \"Error allocating memory - alignment must be power of two. Alignment requested %zu\"", (uint8_t *)&v8, 0x1Cu);
        }
        exceptiouint64_t n = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
        std::logic_error::logic_error(exception, "Error allocating memory - alignment must be power of two. Alignment requested %zu");
      }
      uint64_t result = operator new(__sz, this);
    }
    else
    {
      uint64_t result = operator new(__sz);
    }
  }
  else
  {
    uint64_t result = 0;
  }
  *a3 = result;
  return result;
}

void sub_221F5D76C(_Unwind_Exception *exception_object)
{
}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n, const std::vector<unsigned int>::value_type *__x)
{
  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<unsigned int>::__vallocate[abi:ne180100](this, __n);
    std::vector<unsigned int>::pointer end = this->__end_;
    uint64_t v7 = &end[__n];
    std::vector<unsigned int>::size_type v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_221F5D7F0(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18PrimitiveSortEntryERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_ED0Ev()
{
}

unsigned char *_ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18PrimitiveSortEntryERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEv(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  *(void *)uint64_t result = &unk_26D476DF8;
  result[8] = *(unsigned char *)(a1 + 8);
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18PrimitiveSortEntryERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_E7__cloneEPNS0_6__baseISD_EE(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_26D476DF8;
  *(unsigned char *)(a2 + 8) = *(unsigned char *)(result + 8);
  return result;
}

void _ZNSt3__110__function6__funcIZN5Phase7details10AllocArrayINS2_8Geometry18PrimitiveSortEntryERKZNS3_10AllocArrayIS6_EENS_10unique_ptrIA_T_NS_8functionIFvPvEEEEEmmEUlvE_RKZNS7_IS6_EESF_mmEUlPS9_E_EESF_mOT0_OT1_EUlSC_E_NS_9allocatorISR_EESD_EclEOSC_(uint64_t a1, void **a2)
{
}

uint64_t *std::unique_ptr<Phase::Geometry::PrimitiveSortEntry [],std::function<void ()(void *)>>::reset[abi:ne180100](uint64_t *result)
{
  uint64_t v1 = *result;
  *uint64_t result = 0;
  if (v1) {
    return (uint64_t *)std::function<void ()(void *)>::operator()((uint64_t)(result + 1), v1);
  }
  return result;
}

void std::__introsort<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  while (2)
  {
    unint64_t v10 = a1;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          a1 = v10;
          uint64_t v11 = a2 - v10;
          unint64_t v12 = (uint64_t)(a2 - v10) >> 5;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return;
              case 2uLL:
                unint64_t v49 = *(void *)v10;
                if (*(void *)(a2 - 32) < *(void *)v10)
                {
                  int v50 = *(_DWORD *)(v10 + 16);
                  uint64_t v51 = *(void *)(v10 + 8);
                  uint64_t v129 = *(void *)(v10 + 20);
                  int v137 = *(_DWORD *)(v10 + 28);
                  *(void *)unint64_t v10 = *(void *)(a2 - 32);
                  *(_DWORD *)(v10 + 8) = *(_DWORD *)(a2 - 24);
                  *(_DWORD *)(v10 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a2 - 20);
                  *(_DWORD *)(v10 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 - 16);
                  uint64_t v52 = *(void *)(a2 - 12);
                  *(_DWORD *)(v10 + 28) = *(_DWORD *)(a2 - 4);
                  *(void *)(v10 + 20) = v52;
                  *(void *)(a2 - 32) = v49;
                  *(void *)(a2 - 24) = v51;
                  *(_DWORD *)(a2 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v50;
                  *(_DWORD *)(a2 - 4) = v137;
                  *(void *)(a2 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v129;
                }
                break;
              case 3uLL:
                std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)v10, (unint64_t *)(v10 + 32), (unint64_t *)(a2 - 32));
                break;
              case 4uLL:
                std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(v10, v10 + 32, v10 + 64, a2 - 32);
                break;
              case 5uLL:
                std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,0>(v10, v10 + 32, v10 + 64, v10 + 96, a2 - 32);
                break;
              default:
                JUMPOUT(0);
            }
            return;
          }
          if (v11 <= 767)
          {
            unint64_t v53 = v10 + 32;
            BOOL v55 = v10 == a2 || v53 == a2;
            if (a4)
            {
              if (!v55)
              {
                uint64_t v56 = 0;
                unint64_t v57 = v10;
                do
                {
                  unint64_t v58 = v53;
                  unint64_t v59 = *(void *)(v57 + 32);
                  if (v59 < *(void *)v57)
                  {
                    uint64_t v60 = *(void *)(v57 + 40);
                    int v61 = *(_DWORD *)(v57 + 48);
                    uint64_t v130 = *(void *)(v57 + 52);
                    int v138 = *(_DWORD *)(v57 + 60);
                    unint64_t v62 = *(void *)v57;
                    uint64_t v63 = v56;
                    while (1)
                    {
                      uint64_t v64 = v10 + v63;
                      uint64_t v65 = *(void *)(v10 + v63 + 8);
                      *(void *)(v64 + 32) = v62;
                      *(void *)(v64 + 40) = v65;
                      *(_DWORD *)(v64 + 48) = *(_DWORD *)(v10 + v63 + 16);
                      *(void *)(v64 + 52) = *(void *)(v10 + v63 + 20);
                      *(_DWORD *)(v64 + 60) = *(_DWORD *)(v10 + v63 + 28);
                      if (!v63) {
                        break;
                      }
                      unint64_t v62 = *(void *)(v64 - 32);
                      v63 -= 32;
                      if (v59 >= v62)
                      {
                        uint64_t v66 = v10 + v63 + 32;
                        goto LABEL_79;
                      }
                    }
                    uint64_t v66 = v10;
LABEL_79:
                    *(void *)uint64_t v66 = v59;
                    *(void *)(v66 + 8) = v60;
                    *(_DWORD *)(v66 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v61;
                    *(_DWORD *)(v64 + 28) = v138;
                    *(void *)(v64 + 20) = v130;
                  }
                  unint64_t v53 = v58 + 32;
                  v56 += 32;
                  unint64_t v57 = v58;
                }
                while (v58 + 32 != a2);
              }
            }
            else if (!v55)
            {
              unint64_t v110 = v10 + 52;
              do
              {
                unint64_t v111 = v53;
                unint64_t v112 = *(void *)(a1 + 32);
                if (v112 < *(void *)a1)
                {
                  uint64_t v113 = *(void *)(a1 + 40);
                  int v114 = *(_DWORD *)(a1 + 48);
                  uint64_t v133 = *(void *)(a1 + 52);
                  int v141 = *(_DWORD *)(a1 + 60);
                  unint64_t v115 = *(void *)a1;
                  unint64_t v116 = v110;
                  do
                  {
                    unint64_t v117 = v116;
                    *(void *)(v116 - 20) = v115;
                    *(void *)(v116 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(void *)(v116 - 44);
                    int v118 = *(_DWORD *)(v116 - 36);
                    uint64_t v119 = *(void *)(v116 - 32);
                    v116 -= 32;
                    *(_DWORD *)(v117 - 4) = v118;
                    *(void *)unint64_t v117 = v119;
                    *(_DWORD *)(v117 + 8) = *(_DWORD *)(v117 - 24);
                    unint64_t v115 = *(void *)(v117 - 84);
                  }
                  while (v112 < v115);
                  *(void *)(v116 - 20) = v112;
                  *(void *)(v116 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v113;
                  *(_DWORD *)(v116 - 4) = v114;
                  *(_DWORD *)(v116 + 8) = v141;
                  *(void *)unint64_t v116 = v133;
                }
                unint64_t v53 = v111 + 32;
                v110 += 32;
                a1 = v111;
              }
              while (v111 + 32 != a2);
            }
            return;
          }
          if (!a3)
          {
            if (v10 != a2)
            {
              int64_t v67 = (v12 - 2) >> 1;
              int64_t v68 = v67;
              do
              {
                int64_t v69 = v68;
                if (v67 >= v68)
                {
                  uint64_t v70 = (2 * v68) | 1;
                  unint64_t v71 = v10 + 32 * v70;
                  if (2 * v69 + 2 < (uint64_t)v12)
                  {
                    unint64_t v73 = *(void *)(v71 + 32);
                    BOOL v72 = *(void *)v71 >= v73;
                    if (*(void *)v71 > v73) {
                      unint64_t v73 = *(void *)v71;
                    }
                    if (!v72)
                    {
                      v71 += 32;
                      uint64_t v70 = 2 * v69 + 2;
                    }
                  }
                  else
                  {
                    unint64_t v73 = *(void *)v71;
                  }
                  unint64_t v74 = v10 + 32 * v69;
                  unint64_t v75 = *(void *)v74;
                  if (v73 >= *(void *)v74)
                  {
                    unint64_t v76 = v10 + 32 * v69;
                    uint64_t v77 = *(void *)(v76 + 8);
                    int v78 = *(_DWORD *)(v76 + 16);
                    int v139 = *(_DWORD *)(v76 + 28);
                    uint64_t v131 = *(void *)(v76 + 20);
                    do
                    {
                      unint64_t v79 = v74;
                      unint64_t v74 = v71;
                      *(void *)unint64_t v79 = v73;
                      *(_DWORD *)(v79 + 8) = *(_DWORD *)(v71 + 8);
                      *(_DWORD *)(v79 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(v71 + 12);
                      *(_DWORD *)(v79 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v71 + 16);
                      unint64_t v81 = v71 + 20;
                      uint64_t v80 = *(void *)(v71 + 20);
                      *(_DWORD *)(v79 + 28) = *(_DWORD *)(v81 + 8);
                      *(void *)(v79 + 20) = v80;
                      if (v67 < v70) {
                        break;
                      }
                      uint64_t v82 = (2 * v70) | 1;
                      unint64_t v71 = v10 + 32 * v82;
                      uint64_t v70 = 2 * v70 + 2;
                      if (v70 < (uint64_t)v12)
                      {
                        unint64_t v73 = *(void *)v71;
                        unint64_t v83 = *(void *)(v71 + 32);
                        BOOL v84 = *(void *)v71 >= v83;
                        if (*(void *)v71 <= v83) {
                          unint64_t v73 = *(void *)(v71 + 32);
                        }
                        if (*(void *)v71 < v83) {
                          v71 += 32;
                        }
                        if (v84) {
                          uint64_t v70 = v82;
                        }
                      }
                      else
                      {
                        unint64_t v73 = *(void *)v71;
                        uint64_t v70 = v82;
                      }
                    }
                    while (v73 >= v75);
                    *(void *)unint64_t v74 = v75;
                    *(void *)(v74 + 8) = v77;
                    *(_DWORD *)(v74 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v78;
                    *(void *)unint64_t v81 = v131;
                    *(_DWORD *)(v81 + 8) = v139;
                  }
                }
                int64_t v68 = v69 - 1;
              }
              while (v69);
              uint64_t v85 = (unint64_t)v11 >> 5;
              do
              {
                uint64_t v86 = 0;
                unint64_t v87 = *(void *)v10;
                int v89 = *(_DWORD *)(v10 + 8);
                int v88 = *(_DWORD *)(v10 + 12);
                int v90 = *(_DWORD *)(v10 + 16);
                uint64_t v122 = *(void *)(v10 + 20);
                int v125 = *(_DWORD *)(v10 + 28);
                unint64_t v91 = v10;
                do
                {
                  uint64_t v92 = v91 + 32 * v86 + 32;
                  uint64_t v93 = (2 * v86) | 1;
                  uint64_t v86 = 2 * v86 + 2;
                  if (v86 >= v85)
                  {
                    unint64_t v94 = *(void *)v92;
                    uint64_t v86 = v93;
                  }
                  else
                  {
                    unint64_t v94 = *(void *)v92;
                    unint64_t v95 = *(void *)(v92 + 32);
                    if (*(void *)v92 <= v95) {
                      unint64_t v94 = *(void *)(v92 + 32);
                    }
                    if (*(void *)v92 >= v95) {
                      uint64_t v86 = v93;
                    }
                    else {
                      v92 += 32;
                    }
                  }
                  *(void *)unint64_t v91 = v94;
                  *(_DWORD *)(v91 + 8) = *(_DWORD *)(v92 + 8);
                  *(_DWORD *)(v91 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(v92 + 12);
                  *(_DWORD *)(v91 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v92 + 16);
                  uint64_t v96 = (uint64_t *)(v92 + 20);
                  uint64_t v97 = *(void *)(v92 + 20);
                  *(_DWORD *)(v91 + 28) = *(_DWORD *)(v92 + 28);
                  *(void *)(v91 + 20) = v97;
                  unint64_t v91 = v92;
                }
                while (v86 <= (uint64_t)((unint64_t)(v85 - 2) >> 1));
                if (v92 == a2 - 32)
                {
                  *(void *)uint64_t v92 = v87;
                  *(_DWORD *)(v92 + 8) = v89;
                  *(_DWORD *)(v92 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v88;
                  *(_DWORD *)(v92 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v90;
                  *(_DWORD *)(v92 + 28) = v125;
                  *uint64_t v96 = v122;
                }
                else
                {
                  *(void *)uint64_t v92 = *(void *)(a2 - 32);
                  *(_DWORD *)(v92 + 8) = *(_DWORD *)(a2 - 24);
                  *(_DWORD *)(v92 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a2 - 20);
                  *(_DWORD *)(v92 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 - 16);
                  uint64_t v98 = *(void *)(a2 - 12);
                  *(_DWORD *)(v92 + 28) = *(_DWORD *)(a2 - 4);
                  *uint64_t v96 = v98;
                  *(void *)(a2 - 32) = v87;
                  *(_DWORD *)(a2 - 24) = v89;
                  *(_DWORD *)(a2 - 20) = v88;
                  *(_DWORD *)(a2 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v90;
                  *(_DWORD *)(a2 - 4) = v125;
                  *(void *)(a2 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v122;
                  uint64_t v99 = v92 - v10 + 32;
                  if (v99 >= 33)
                  {
                    unint64_t v100 = (((unint64_t)v99 >> 5) - 2) >> 1;
                    uint64_t v101 = v10 + 32 * v100;
                    uint64_t v102 = *(void *)v101;
                    unint64_t v103 = *(void *)v92;
                    if (*(void *)v101 < *(void *)v92)
                    {
                      uint64_t v104 = *(void *)(v92 + 8);
                      int v105 = *(_DWORD *)(v92 + 16);
                      int v140 = *(_DWORD *)(v92 + 28);
                      uint64_t v132 = *v96;
                      do
                      {
                        uint64_t v106 = v92;
                        uint64_t v92 = v101;
                        *(void *)uint64_t v106 = v102;
                        *(_DWORD *)(v106 + 8) = *(_DWORD *)(v101 + 8);
                        *(_DWORD *)(v106 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(v101 + 12);
                        *(_DWORD *)(v106 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v101 + 16);
                        uint64_t v107 = v101 + 20;
                        uint64_t v108 = *(void *)(v101 + 20);
                        *(_DWORD *)(v106 + 28) = *(_DWORD *)(v107 + 8);
                        *(void *)(v106 + 20) = v108;
                        if (!v100) {
                          break;
                        }
                        unint64_t v100 = (v100 - 1) >> 1;
                        uint64_t v101 = v10 + 32 * v100;
                        uint64_t v102 = *(void *)v101;
                      }
                      while (*(void *)v101 < v103);
                      *(void *)uint64_t v92 = v103;
                      *(void *)(v92 + 8) = v104;
                      *(_DWORD *)(v92 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v105;
                      *(void *)uint64_t v107 = v132;
                      *(_DWORD *)(v107 + 8) = v140;
                    }
                  }
                }
                a2 -= 32;
              }
              while (v85-- > 2);
            }
            return;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 32 * (v12 >> 1);
          if ((unint64_t)v11 > 0x1000)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)a1, (unint64_t *)(a1 + 32 * (v12 >> 1)), (unint64_t *)(a2 - 32));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)(a1 + 32), (unint64_t *)(v14 - 32), (unint64_t *)(a2 - 64));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)(a1 + 64), (unint64_t *)(a1 + 32 + 32 * v13), (unint64_t *)(a2 - 96));
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)(v14 - 32), (unint64_t *)v14, (unint64_t *)(a1 + 32 + 32 * v13));
            unint64_t v15 = *(void *)a1;
            int v16 = *(_DWORD *)(a1 + 16);
            uint64_t v17 = *(void *)(a1 + 8);
            uint64_t v126 = *(void *)(a1 + 20);
            int v134 = *(_DWORD *)(a1 + 28);
            *(void *)a1 = *(void *)v14;
            *(void *)(a1 + 8) = *(void *)(v14 + 8);
            *(_DWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v14 + 16);
            int v18 = *(_DWORD *)(v14 + 28);
            *(void *)(a1 + 20) = *(void *)(v14 + 20);
            *(_DWORD *)(a1 + 28) = v18;
            *(void *)unint64_t v14 = v15;
            *(void *)(v14 + 8) = v17;
            *(_DWORD *)(v14 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v16;
            *(void *)(v14 + 20) = v126;
            *(_DWORD *)(v14 + 28) = v134;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)(a1 + 32 * (v12 >> 1)), (unint64_t *)a1, (unint64_t *)(a2 - 32));
          }
          --a3;
          unint64_t v19 = *(void *)a1;
          if ((a4 & 1) != 0 || *(void *)(a1 - 32) < v19) {
            break;
          }
          uint64_t v36 = *(void *)(a1 + 8);
          int v37 = *(_DWORD *)(a1 + 16);
          uint64_t v121 = *(void *)(a1 + 20);
          int v124 = *(_DWORD *)(a1 + 28);
          if (v19 >= *(void *)(a2 - 32))
          {
            unint64_t v39 = a1 + 32;
            do
            {
              unint64_t v10 = v39;
              if (v39 >= a2) {
                break;
              }
              v39 += 32;
            }
            while (v19 >= *(void *)v10);
          }
          else
          {
            unint64_t v10 = a1;
            do
            {
              unint64_t v38 = *(void *)(v10 + 32);
              v10 += 32;
            }
            while (v19 >= v38);
          }
          unint64_t v40 = a2;
          if (v10 < a2)
          {
            unint64_t v40 = a2;
            do
            {
              unint64_t v41 = *(void *)(v40 - 32);
              v40 -= 32;
            }
            while (v19 < v41);
          }
          if (v10 < v40)
          {
            unint64_t v42 = *(void *)v10;
            do
            {
              int v43 = *(_DWORD *)(v10 + 16);
              uint64_t v44 = *(void *)(v10 + 8);
              int v136 = *(_DWORD *)(v10 + 28);
              uint64_t v128 = *(void *)(v10 + 20);
              *(void *)unint64_t v10 = *(void *)v40;
              *(_DWORD *)(v10 + 8) = *(_DWORD *)(v40 + 8);
              *(_DWORD *)(v10 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(v40 + 12);
              *(_DWORD *)(v10 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v40 + 16);
              uint64_t v45 = *(void *)(v40 + 20);
              *(_DWORD *)(v10 + 28) = *(_DWORD *)(v40 + 28);
              *(void *)(v10 + 20) = v45;
              *(void *)unint64_t v40 = v42;
              *(void *)(v40 + 8) = v44;
              *(_DWORD *)(v40 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v43;
              *(void *)(v40 + 20) = v128;
              *(_DWORD *)(v40 + 28) = v136;
              do
              {
                unint64_t v46 = *(void *)(v10 + 32);
                v10 += 32;
                unint64_t v42 = v46;
              }
              while (v19 >= v46);
              do
              {
                unint64_t v47 = *(void *)(v40 - 32);
                v40 -= 32;
              }
              while (v19 < v47);
            }
            while (v10 < v40);
          }
          BOOL v4 = v10 - 32 >= a1;
          BOOL v5 = v10 - 32 == a1;
          if (v10 - 32 != a1)
          {
            *(void *)a1 = *(void *)(v10 - 32);
            *(_DWORD *)(a1 + 8) = *(_DWORD *)(v10 - 24);
            *(_DWORD *)(a1 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(v10 - 20);
            *(_DWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v10 - 16);
            uint64_t v48 = *(void *)(v10 - 12);
            *(_DWORD *)(a1 + 28) = *(_DWORD *)(v10 - 4);
            *(void *)(a1 + 20) = v48;
          }
          a4 = 0;
          *(void *)(v10 - 32) = v19;
          *(void *)(v10 - 24) = v36;
          *(_DWORD *)(v10 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v37;
          *(_DWORD *)(v10 - 4) = v124;
          *(void *)(v10 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v121;
        }
        uint64_t v20 = 0;
        uint64_t v21 = *(void *)(a1 + 8);
        int v22 = *(_DWORD *)(a1 + 16);
        uint64_t v120 = *(void *)(a1 + 20);
        int v123 = *(_DWORD *)(a1 + 28);
        do
        {
          unint64_t v23 = *(void *)(a1 + v20 + 32);
          v20 += 32;
        }
        while (v23 < v19);
        unint64_t v24 = a1 + v20;
        unint64_t v25 = a2;
        if (v20 == 32)
        {
          unint64_t v25 = a2;
          do
          {
            if (v24 >= v25) {
              break;
            }
            unint64_t v27 = *(void *)(v25 - 32);
            v25 -= 32;
          }
          while (v27 >= v19);
        }
        else
        {
          do
          {
            unint64_t v26 = *(void *)(v25 - 32);
            v25 -= 32;
          }
          while (v26 >= v19);
        }
        unint64_t v10 = a1 + v20;
        if (v24 < v25)
        {
          unint64_t v28 = v25;
          do
          {
            int v29 = *(_DWORD *)(v10 + 16);
            uint64_t v30 = *(void *)(v10 + 8);
            int v135 = *(_DWORD *)(v10 + 28);
            uint64_t v127 = *(void *)(v10 + 20);
            *(void *)unint64_t v10 = *(void *)v28;
            *(_DWORD *)(v10 + 8) = *(_DWORD *)(v28 + 8);
            *(_DWORD *)(v10 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(v28 + 12);
            *(_DWORD *)(v10 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v28 + 16);
            uint64_t v31 = *(void *)(v28 + 20);
            *(_DWORD *)(v10 + 28) = *(_DWORD *)(v28 + 28);
            *(void *)(v10 + 20) = v31;
            *(void *)unint64_t v28 = v23;
            *(void *)(v28 + 8) = v30;
            *(_DWORD *)(v28 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v29;
            *(void *)(v28 + 20) = v127;
            *(_DWORD *)(v28 + 28) = v135;
            do
            {
              unint64_t v32 = *(void *)(v10 + 32);
              v10 += 32;
              unint64_t v23 = v32;
            }
            while (v32 < v19);
            do
            {
              unint64_t v33 = *(void *)(v28 - 32);
              v28 -= 32;
            }
            while (v33 >= v19);
          }
          while (v10 < v28);
        }
        if (v10 - 32 != a1)
        {
          *(void *)a1 = *(void *)(v10 - 32);
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(v10 - 24);
          *(_DWORD *)(a1 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(v10 - 20);
          *(_DWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(v10 - 16);
          uint64_t v34 = *(void *)(v10 - 12);
          *(_DWORD *)(a1 + 28) = *(_DWORD *)(v10 - 4);
          *(void *)(a1 + 20) = v34;
        }
        *(void *)(v10 - 32) = v19;
        *(void *)(v10 - 24) = v21;
        *(_DWORD *)(v10 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v22;
        *(_DWORD *)(v10 - 4) = v123;
        *(void *)(v10 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v120;
        if (v24 >= v25) {
          break;
        }
LABEL_30:
        std::__introsort<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,false>(a1, v10 - 32, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v35 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(a1, v10 - 32);
      if (std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(v10, a2))
      {
        break;
      }
      if (!v35) {
        goto LABEL_30;
      }
    }
    a2 = v10 - 32;
    if (!v35) {
      continue;
    }
    break;
  }
}

float std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  float result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(a1, a2, a3, a4);
  uint64_t v11 = *(void *)a4;
  if (*(void *)a5 < *(void *)a4)
  {
    float result = *(float *)(a4 + 16);
    unint64_t v12 = (void *)(a4 + 20);
    uint64_t v26 = *(void *)(a4 + 20);
    int v30 = *(_DWORD *)(a4 + 28);
    *(void *)a4 = *(void *)a5;
    uint64_t v13 = *(void *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = *(_DWORD *)(a5 + 8);
    *(_DWORD *)(a4 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a5 + 12);
    *(_DWORD *)(a4 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a5 + 16);
    int v14 = *(_DWORD *)(a5 + 28);
    *(void *)(a4 + 20) = *(void *)(a5 + 20);
    *(_DWORD *)(a4 + 28) = v14;
    *(void *)a5 = v11;
    *(void *)(a5 + 8) = v13;
    *(float *)(a5 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
    *(void *)(a5 + 20) = v26;
    *(_DWORD *)(a5 + 28) = v30;
    uint64_t v15 = *(void *)a3;
    if (*(void *)a4 < *(void *)a3)
    {
      float result = *(float *)(a3 + 16);
      int v16 = (void *)(a3 + 20);
      uint64_t v27 = *(void *)(a3 + 20);
      int v31 = *(_DWORD *)(a3 + 28);
      *(void *)a3 = *(void *)a4;
      uint64_t v17 = *(void *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
      *(_DWORD *)(a3 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a4 + 12);
      *(_DWORD *)(a3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a4 + 16);
      int v18 = *(_DWORD *)(a4 + 28);
      *(void *)(a3 + 20) = *v12;
      *(_DWORD *)(a3 + 28) = v18;
      *(void *)a4 = v15;
      *(void *)(a4 + 8) = v17;
      *(float *)(a4 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
      *unint64_t v12 = v27;
      *(_DWORD *)(a4 + 28) = v31;
      uint64_t v19 = *(void *)a2;
      if (*(void *)a3 < *(void *)a2)
      {
        float result = *(float *)(a2 + 16);
        uint64_t v20 = (void *)(a2 + 20);
        uint64_t v28 = *(void *)(a2 + 20);
        int v32 = *(_DWORD *)(a2 + 28);
        *(void *)a2 = *(void *)a3;
        uint64_t v21 = *(void *)(a2 + 8);
        *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
        *(_DWORD *)(a2 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a3 + 12);
        *(_DWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a3 + 16);
        int v22 = *(_DWORD *)(a3 + 28);
        *(void *)(a2 + 20) = *v16;
        *(_DWORD *)(a2 + 28) = v22;
        *(void *)a3 = v19;
        *(void *)(a3 + 8) = v21;
        *(float *)(a3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
        void *v16 = v28;
        *(_DWORD *)(a3 + 28) = v32;
        uint64_t v23 = *(void *)a1;
        if (*(void *)a2 < *(void *)a1)
        {
          float result = *(float *)(a1 + 16);
          uint64_t v29 = *(void *)(a1 + 20);
          int v33 = *(_DWORD *)(a1 + 28);
          *(void *)a1 = *(void *)a2;
          uint64_t v24 = *(void *)(a1 + 8);
          *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
          *(_DWORD *)(a1 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a2 + 12);
          *(_DWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 16);
          int v25 = *(_DWORD *)(a2 + 28);
          *(void *)(a1 + 20) = *v20;
          *(_DWORD *)(a1 + 28) = v25;
          *(void *)a2 = v23;
          *(void *)(a2 + 8) = v24;
          *(float *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
          *uint64_t v20 = v29;
          *(_DWORD *)(a2 + 28) = v33;
        }
      }
    }
  }
  return result;
}

unint64_t *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *a2;
  unint64_t v4 = *result;
  unint64_t v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      int v10 = *((_DWORD *)a2 + 4);
      uint64_t v11 = (uint64_t *)((char *)a2 + 20);
      unint64_t v25 = *(unint64_t *)((char *)a2 + 20);
      int v29 = *((_DWORD *)a2 + 7);
      *a2 = v5;
      unint64_t v12 = a2[1];
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a2 + 3) = *((_DWORD *)a3 + 3);
      *((_DWORD *)a2 + 4) = *((_DWORD *)a3 + 4);
      int v13 = *((_DWORD *)a3 + 7);
      *(unint64_t *)((char *)a2 + 20) = *(unint64_t *)((char *)a3 + 20);
      *((_DWORD *)a2 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v13;
      *a3 = v3;
      a3[1] = v12;
      *((_DWORD *)a3 + 4) = v10;
      *(unint64_t *)((char *)a3 + 20) = v25;
      *((_DWORD *)a3 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v29;
      unint64_t v14 = *result;
      if (*a2 < *result)
      {
        int v15 = *((_DWORD *)result + 4);
        uint64_t v26 = *(unint64_t *)((char *)result + 20);
        int v30 = *((_DWORD *)result + 7);
        *float result = *a2;
        unint64_t v16 = result[1];
        *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
        *((_DWORD *)result + 3) = *((_DWORD *)a2 + 3);
        *((_DWORD *)result + 4) = *((_DWORD *)a2 + 4);
        int v17 = *((_DWORD *)a2 + 7);
        *(unint64_t *)((char *)result + 20) = *v11;
        *((_DWORD *)result + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v17;
        *a2 = v14;
        a2[1] = v16;
        *((_DWORD *)a2 + 4) = v15;
        uint64_t *v11 = v26;
        *((_DWORD *)a2 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v30;
      }
    }
  }
  else
  {
    uint64_t v6 = (uint64_t *)((char *)result + 20);
    if (v5 >= v3)
    {
      int v18 = *((_DWORD *)result + 2);
      int v19 = *((_DWORD *)result + 3);
      int v20 = *((_DWORD *)result + 4);
      uint64_t v27 = *v6;
      int v31 = *((_DWORD *)result + 7);
      *float result = v3;
      *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
      *((_DWORD *)result + 3) = *((_DWORD *)a2 + 3);
      *((_DWORD *)result + 4) = *((_DWORD *)a2 + 4);
      uint64_t v21 = (uint64_t *)((char *)a2 + 20);
      uint64_t v22 = *(unint64_t *)((char *)a2 + 20);
      *((_DWORD *)result + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = *((_DWORD *)a2 + 7);
      *uint64_t v6 = v22;
      *a2 = v4;
      *((_DWORD *)a2 + 2) = v18;
      *((_DWORD *)a2 + 3) = v19;
      *((_DWORD *)a2 + 4) = v20;
      *(unint64_t *)((char *)a2 + 20) = v27;
      *((_DWORD *)a2 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v31;
      if (*a3 >= v4) {
        return result;
      }
      uint64_t v24 = *v21;
      int v28 = *((_DWORD *)a2 + 7);
      *a2 = *a3;
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a2 + 3) = *((_DWORD *)a3 + 3);
      *((_DWORD *)a2 + 4) = *((_DWORD *)a3 + 4);
      int v23 = *((_DWORD *)a3 + 7);
      *uint64_t v21 = *(unint64_t *)((char *)a3 + 20);
      *((_DWORD *)a2 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v23;
      *a3 = v4;
      *((_DWORD *)a3 + 2) = v18;
      *((_DWORD *)a3 + 3) = v19;
      *((_DWORD *)a3 + 4) = v20;
    }
    else
    {
      int v7 = *((_DWORD *)result + 4);
      uint64_t v24 = *v6;
      int v28 = *((_DWORD *)result + 7);
      *float result = v5;
      unint64_t v8 = result[1];
      *((_DWORD *)result + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)result + 3) = *((_DWORD *)a3 + 3);
      *((_DWORD *)result + 4) = *((_DWORD *)a3 + 4);
      int v9 = *((_DWORD *)a3 + 7);
      *uint64_t v6 = *(unint64_t *)((char *)a3 + 20);
      *((_DWORD *)result + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v9;
      *a3 = v4;
      a3[1] = v8;
      *((_DWORD *)a3 + 4) = v7;
    }
    *(unint64_t *)((char *)a3 + 20) = v24;
    *((_DWORD *)a3 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = v28;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v6 = *(void *)(a2 - 32);
      unint64_t v7 = *(void *)a1;
      if (v6 < *(void *)a1)
      {
        int v8 = *(_DWORD *)(a1 + 16);
        uint64_t v23 = *(void *)(a1 + 20);
        int v25 = *(_DWORD *)(a1 + 28);
        *(void *)a1 = v6;
        uint64_t v9 = *(void *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 - 24);
        *(_DWORD *)(a1 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a2 - 20);
        *(_DWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 - 16);
        int v10 = *(_DWORD *)(a2 - 4);
        *(void *)(a1 + 20) = *(void *)(a2 - 12);
        *(_DWORD *)(a1 + 28) = v10;
        *(void *)(a2 - 32) = v7;
        *(void *)(a2 - 24) = v9;
        *(_DWORD *)(a2 - 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v8;
        *(void *)(a2 - std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = v23;
        *(_DWORD *)(a2 - 4) = v25;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)a1, (unint64_t *)(a1 + 32), (unint64_t *)(a2 - 32));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(a1, a1 + 32, a1 + 64, a2 - 32);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *,0>(a1, a1 + 32, a1 + 64, a1 + 96, a2 - 32);
      return 1;
    default:
      uint64_t v11 = (unint64_t *)(a1 + 64);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)a1, (unint64_t *)(a1 + 32), (unint64_t *)(a1 + 64));
      uint64_t v12 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (1)
  {
    unint64_t v15 = *(void *)v12;
    if (*(void *)v12 < *v11)
    {
      uint64_t v16 = *(void *)(v12 + 8);
      int v17 = *(_DWORD *)(v12 + 16);
      uint64_t v24 = *(void *)(v12 + 20);
      int v26 = *(_DWORD *)(v12 + 28);
      unint64_t v18 = *v11;
      uint64_t v19 = v13;
      while (1)
      {
        uint64_t v20 = a1 + v19;
        uint64_t v21 = *(void *)(a1 + v19 + 72);
        *(void *)(v20 + 9std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v18;
        *(void *)(v20 + 104) = v21;
        *(_DWORD *)(v20 + 1std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a1 + v19 + 80);
        *(void *)(v20 + 11std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a1 + v19 + 84);
        *(_DWORD *)(v20 + 124) = *(_DWORD *)(a1 + v19 + 92);
        if (v19 == -64) {
          break;
        }
        unint64_t v18 = *(void *)(v20 + 32);
        v19 -= 32;
        if (v15 >= v18)
        {
          uint64_t v22 = a1 + v19 + 96;
          goto LABEL_12;
        }
      }
      uint64_t v22 = a1;
LABEL_12:
      *(void *)uint64_t v22 = v15;
      *(void *)(v22 + 8) = v16;
      *(_DWORD *)(v22 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = v17;
      *(void *)(v20 + 84) = v24;
      *(_DWORD *)(v20 + 92) = v26;
      if (++v14 == 8) {
        return v12 + 32 == a2;
      }
    }
    uint64_t v11 = (unint64_t *)v12;
    v13 += 32;
    v12 += 32;
    if (v12 == a2) {
      return 1;
    }
  }
}

float std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,Phase::Geometry::SortPrimitivesByMortonNumber(Phase::Geometry::System &,Phase::Geometry::Mesh *,Phase::Geometry::MeshOptions::PrimitiveSortType)::$_0 &,Phase::Geometry::PrimitiveSortEntry *>((unint64_t *)a1, (unint64_t *)a2, (unint64_t *)a3);
  unint64_t v9 = *(void *)a3;
  if (*(void *)a4 < *(void *)a3)
  {
    float result = *(float *)(a3 + 16);
    int v10 = (void *)(a3 + 20);
    uint64_t v20 = *(void *)(a3 + 20);
    int v23 = *(_DWORD *)(a3 + 28);
    *(void *)a3 = *(void *)a4;
    uint64_t v11 = *(void *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a3 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a4 + 12);
    *(_DWORD *)(a3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a4 + 16);
    int v12 = *(_DWORD *)(a4 + 28);
    *(void *)(a3 + 20) = *(void *)(a4 + 20);
    *(_DWORD *)(a3 + 28) = v12;
    *(void *)a4 = v9;
    *(void *)(a4 + 8) = v11;
    *(float *)(a4 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
    *(void *)(a4 + 20) = v20;
    *(_DWORD *)(a4 + 28) = v23;
    unint64_t v13 = *(void *)a2;
    if (*(void *)a3 < *(void *)a2)
    {
      float result = *(float *)(a2 + 16);
      int v14 = (void *)(a2 + 20);
      uint64_t v21 = *(void *)(a2 + 20);
      int v24 = *(_DWORD *)(a2 + 28);
      *(void *)a2 = *(void *)a3;
      uint64_t v15 = *(void *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a2 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a3 + 12);
      *(_DWORD *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a3 + 16);
      int v16 = *(_DWORD *)(a3 + 28);
      *(void *)(a2 + 20) = *v10;
      *(_DWORD *)(a2 + 28) = v16;
      *(void *)a3 = v13;
      *(void *)(a3 + 8) = v15;
      *(float *)(a3 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
      void *v10 = v21;
      *(_DWORD *)(a3 + 28) = v24;
      unint64_t v17 = *(void *)a1;
      if (*(void *)a2 < *(void *)a1)
      {
        float result = *(float *)(a1 + 16);
        uint64_t v22 = *(void *)(a1 + 20);
        int v25 = *(_DWORD *)(a1 + 28);
        *(void *)a1 = *(void *)a2;
        uint64_t v18 = *(void *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a1 + std::unique_ptr<float [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 12) = *(_DWORD *)(a2 + 12);
        *(_DWORD *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 16);
        int v19 = *(_DWORD *)(a2 + 28);
        *(void *)(a1 + 20) = *v14;
        *(_DWORD *)(a1 + 28) = v19;
        *(void *)a2 = v17;
        *(void *)(a2 + 8) = v18;
        *(float *)(a2 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = result;
        void *v14 = v22;
        *(_DWORD *)(a2 + 28) = v25;
      }
    }
  }
  return result;
}

void std::__shared_ptr_emplace<Phase::Geometry::Shape>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D476E40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<Phase::Geometry::Shape>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_26D476E40;
  std::__shared_weak_count::~__shared_weak_count(a1);

  JUMPOUT(0x223C938A0);
}

void std::__shared_ptr_emplace<Phase::Geometry::Shape>::__on_zero_shared(uint64_t a1)
{
  std::allocator<Phase::Geometry::Shape>::destroy[abi:ne180100]((uint64_t)&v1, a1 + 24);
}

void std::allocator<Phase::Geometry::Shape>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (void **)(a2 + 120);
  std::vector<std::unique_ptr<Phase::Geometry::DataMap,std::function<void ()(void *)>>>::__destroy_vector::operator()[abi:ne180100](&v4);
  uint64_t v4 = (void **)(a2 + 96);
  std::vector<std::shared_ptr<Phase::Geometry::MpsCpuScene>>::__destroy_vector::operator()[abi:ne180100](&v4);
  unint64_t v3 = *(void **)(a2 + 72);
  if (v3)
  {
    *(void *)(a2 + 80) = v3;
    operator delete(v3);
  }
}

uint64_t Phase::Geometry::MdlMeshReader::GetVertexIndex<unsigned int>(id **a1, uint64_t a2, uint64_t a3)
{
  id Submesh = Phase::MdlMeshAsset::GetSubmesh(a1, a2);
  int IndexBufferFormat = Phase::MdlMeshAsset::Submesh::GetIndexBufferFormat(&Submesh);
  switch(IndexBufferFormat)
  {
    case 3:
      return *(unsigned int *)(Phase::MdlMeshAsset::Submesh::GetIndexBuffer(&Submesh) + 4 * a3);
    case 2:
      return *(unsigned __int16 *)(Phase::MdlMeshAsset::Submesh::GetIndexBuffer(&Submesh) + 2 * a3);
    case 1:
      return *(unsigned __int8 *)(Phase::MdlMeshAsset::Submesh::GetIndexBuffer(&Submesh) + a3);
  }
  return 0;
}

float Phase::UnnormalizedNormalCCW<float>@<S0>(float *a1@<X0>, float *a2@<X8>)
{
  float v2 = a1[1];
  float v3 = a1[2];
  float v4 = a1[3] - *a1;
  float v5 = a1[6] - *a1;
  float v6 = a1[4] - v2;
  float v7 = a1[5] - v3;
  float v8 = a1[7] - v2;
  float v9 = a1[8] - v3;
  float v10 = (float)(v6 * v9) - (float)(v7 * v8);
  float v11 = (float)(v7 * v5) - (float)(v4 * v9);
  float result = (float)(v4 * v8) - (float)(v6 * v5);
  *a2 = v10;
  a2[1] = v11;
  a2[2] = result;
  return result;
}

void *std::allocate_shared[abi:ne180100]<Phase::Geometry::Shape,std::allocator<Phase::Geometry::Shape>,Phase::Geometry::Shape&,std::vector<unsigned int> &,void>@<X0>(uint64_t a1@<X1>, __int32 **a2@<X2>, void *a3@<X8>)
{
  float v6 = operator new(0xC0uLL);
  float result = std::__shared_ptr_emplace<Phase::Geometry::Shape>::__shared_ptr_emplace[abi:ne180100]<Phase::Geometry::Shape&,std::vector<unsigned int> &,std::allocator<Phase::Geometry::Shape>,0>(v6, a1, a2);
  *a3 = v6 + 3;
  a3[1] = v6;
  return result;
}

void sub_221F5ED9C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__shared_ptr_emplace<Phase::Geometry::Shape>::__shared_ptr_emplace[abi:ne180100]<Phase::Geometry::Shape&,std::vector<unsigned int> &,std::allocator<Phase::Geometry::Shape>,0>(void *a1, uint64_t a2, __int32 **a3)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_26D476E40;
  Phase::Geometry::Shape::Shape((uint64_t)(a1 + 3), a2, a3);
  return a1;
}

void sub_221F5EDF8(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t Phase::Geometry::Shape::Shape(uint64_t a1, uint64_t a2, __int32 **a3)
{
  *(_DWORD *)a1 = *(_DWORD *)a2;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 1std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(void *)(a2 + 16);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(a1 + 3std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 36);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
  *(_DWORD *)(a1 + 5std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = *(_DWORD *)(a2 + 56);
  uint64_t v6 = *(void *)(a2 + 60);
  *(void *)(a1 + 72) = 0;
  uint64_t v7 = a1 + 72;
  *(void *)(a1 + 60) = v6;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((void *)(a1 + 72), *(const void **)(a2 + 72), *(void *)(a2 + 80), (uint64_t)(*(void *)(a2 + 80) - *(void *)(a2 + 72)) >> 2);
  float v8 = Phase::Geometry::DataSet::DataSet((uint64_t *)(v7 + 24), (uint64_t *)(a2 + 96), a3);
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 13std::unique_ptr<Phase::PackedSubbands<float,3ul> [],std::function<void ()(void *)>>::reset[abi:ne180100]((uint64_t *)this + 6) = 0;
  *(void *)(a1 + 144) = v8;
  *(_OWORD *)(a1 + 152) = *(_OWORD *)(a2 + 152);
  return a1;
}

void sub_221F5EEE8(_Unwind_Exception *exception_object)
{
  float v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 80) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *Phase::Geometry::DataSet::DataSet(uint64_t *a1, uint64_t *a2, __int32 **a3)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v7 = *a2;
  uint64_t v6 = a2[1];
  unint64_t v8 = (v6 - *a2) >> 4;
  std::vector<std::shared_ptr<Phase::Geometry::SharedDataStream>>::resize(a1, v8);
  if (v6 != v7)
  {
    uint64_t v9 = 0;
    if (v8 <= 1) {
      unint64_t v8 = 1;
    }
    do
    {
      float v10 = a3[1];
      float v11 = wmemchr(*a3, **(_DWORD **)(*a2 + v9), v10 - *a3);
      if (v11) {
        int v12 = v11;
      }
      else {
        int v12 = v10;
      }
      if (v12 == a3[1])
      {
        uint64_t v16 = *a1;
        long long v17 = *(_OWORD *)(*a2 + v9);
        uint64_t v18 = *(void *)(*a2 + v9 + 8);
        if (v18) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v19 = v16 + v9;
        uint64_t v20 = *(std::__shared_weak_count **)(v19 + 8);
        *(_OWORD *)uint64_t v19 = v17;
        if (v20) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v20);
        }
      }
      else
      {
        unint64_t v13 = (char *)operator new(0x40uLL);
        *((void *)v13 + Phase::Dispatch::ExternalStreamClientDirectDispatcher::~ExternalStreamClientDirectDispatcher(this - 1) = 0;
        *((void *)v13 + 2) = 0;
        *(void *)unint64_t v13 = &unk_26D476D78;
        *((void *)v13 + std::__function::__value_func<void ()(void *)>::~__value_func[abi:ne180100]((void *)this + 7) = 0;
        *(_OWORD *)(v13 + 24) = 0u;
        *(_OWORD *)(v13 + 40) = 0u;
        int v14 = (void *)(*a1 + v9);
        uint64_t v15 = (std::__shared_weak_count *)v14[1];
        void *v14 = v13 + 24;
        v14[1] = v13;
        if (v15) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
        }
        Phase::Geometry::DataStream::operator=(*(void *)(*a1 + v9), *(void *)(*a2 + v9));
      }
      v9 += 16;
      --v8;
    }
    while (v8);
  }
  return a1;
}