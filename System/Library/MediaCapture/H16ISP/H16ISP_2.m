void sub_246947890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, int a19, __int16 a20,char a21,char a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,char a36,int a37,__int16 a38,char a39,char a40,int a41,__int16 a42,char a43,char a44)
{
  NamedValues::~NamedValues((NamedValues *)&a29);
  NamedValues::~NamedValues((NamedValues *)&a18);
  NamedValues::~NamedValues((NamedValues *)&a20);
  NamedValues::~NamedValues((NamedValues *)&a24);
  _Unwind_Resume(a1);
}

void anonymous namespace'::AppendMetadataList(__CFArray **this, NamedValues *a2, __CFArray **a3, NamedValues *a4)
{
  NamedValue::NamedValue((NamedValue *)&v5, (const char *)a2, 0, *a3);
  NamedValues::push_back(this, &v5);
  NamedValue::~NamedValue((NamedValue *)&v5);
}

void sub_246947C3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  NamedValue::~NamedValue((NamedValue *)va);
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::AppendMetadataItem<unsigned long>(__CFArray **a1)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v8);
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v9, __p);
  if (v6 >= 0) {
    v2 = __p;
  }
  else {
    v2 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v7, "size", (const char *)v2, 0);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v7);
  NamedValue::~NamedValue((NamedValue *)&v7);
  v8[0] = *MEMORY[0x263F8C2B8];
  uint64_t v3 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v8 + *(void *)(v8[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v8[2] = v3;
  v9[0] = MEMORY[0x263F8C318] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v11);
}

void sub_246947E10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<unsigned short>(__CFArray **a1, const char *a2, _WORD *a3, int a4)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v17);
  if (a4 == 1)
  {
    char v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)"0x", 2);
    *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 8) = *(_DWORD *)((unsigned char *)v10 + *(void *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 8;
    goto LABEL_11;
  }
  if (a4 != 2)
  {
LABEL_11:
    std::ostream::operator<<();
    goto LABEL_12;
  }
  if (*a3) {
    v8 = "yes";
  }
  else {
    v8 = "no";
  }
  if (*a3) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)v8, v9);
LABEL_12:
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v19, __p);
  if (v15 >= 0) {
    uint64_t v11 = __p;
  }
  else {
    uint64_t v11 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v16, a2, (const char *)v11, 0);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v16);
  NamedValue::~NamedValue((NamedValue *)&v16);
  v17[0] = *MEMORY[0x263F8C2B8];
  uint64_t v12 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v17 + *(void *)(v17[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v18 = v12;
  v19[0] = MEMORY[0x263F8C318] + 16;
  if (v20 < 0) {
    operator delete((void *)v19[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v21);
}

void sub_246948098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<unsigned long long>(__CFArray **a1, const char *a2, uint64_t a3, int a4)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v14);
  if (a4 == 1)
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v15, (uint64_t)"0x", 2);
    *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24) + 8) = *(_DWORD *)((unsigned char *)v7 + *(void *)(*v7 - 24) + 8) & 0xFFFFFFB5 | 8;
  }
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v16, __p);
  if (v12 >= 0) {
    v8 = __p;
  }
  else {
    v8 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v13, a2, (const char *)v8, 0);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v13);
  NamedValue::~NamedValue((NamedValue *)&v13);
  v14[0] = *MEMORY[0x263F8C2B8];
  uint64_t v9 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v14 + *(void *)(v14[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v15 = v9;
  v16[0] = MEMORY[0x263F8C318] + 16;
  if (v17 < 0) {
    operator delete((void *)v16[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v18);
}

void sub_2469482EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<unsigned int>(__CFArray **a1, const char *a2, _DWORD *a3, int a4)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v17);
  if (a4 == 1)
  {
    char v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)"0x", 2);
    *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 8) = *(_DWORD *)((unsigned char *)v10 + *(void *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 8;
    goto LABEL_11;
  }
  if (a4 != 2)
  {
LABEL_11:
    std::ostream::operator<<();
    goto LABEL_12;
  }
  if (*a3) {
    v8 = "yes";
  }
  else {
    v8 = "no";
  }
  if (*a3) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)v8, v9);
LABEL_12:
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v19, __p);
  if (v15 >= 0) {
    uint64_t v11 = __p;
  }
  else {
    uint64_t v11 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v16, a2, (const char *)v11, 0);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v16);
  NamedValue::~NamedValue((NamedValue *)&v16);
  v17[0] = *MEMORY[0x263F8C2B8];
  uint64_t v12 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v17 + *(void *)(v17[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v18 = v12;
  v19[0] = MEMORY[0x263F8C318] + 16;
  if (v20 < 0) {
    operator delete((void *)v19[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v21);
}

void sub_246948574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C328] + 104;
  *(void *)(a1 + 128) = MEMORY[0x263F8C328] + 104;
  uint64_t v3 = a1 + 16;
  uint64_t v4 = MEMORY[0x263F8C328] + 64;
  *(void *)(a1 + 16) = MEMORY[0x263F8C328] + 64;
  v5 = (void *)MEMORY[0x263F8C2B8];
  uint64_t v6 = *(void *)(MEMORY[0x263F8C2B8] + 24);
  uint64_t v7 = *(void *)(MEMORY[0x263F8C2B8] + 16);
  *(void *)a1 = v7;
  *(void *)(a1 + *(void *)(v7 - 24)) = v6;
  *(void *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  uint64_t v9 = MEMORY[0x263F8C328] + 24;
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  uint64_t v10 = v5[5];
  uint64_t v11 = v5[4];
  *(void *)(a1 + 16) = v11;
  *(void *)(v3 + *(void *)(v11 - 24)) = v10;
  uint64_t v12 = v5[1];
  *(void *)a1 = v12;
  *(void *)(a1 + *(void *)(v12 - 24)) = v5[6];
  *(void *)a1 = v9;
  *(void *)(a1 + 128) = v2;
  *(void *)(a1 + 16) = v4;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_246948864(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x24C53D6A0](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B8];
  uint64_t v3 = *MEMORY[0x263F8C2B8];
  *(void *)a1 = *MEMORY[0x263F8C2B8];
  uint64_t v4 = *(void *)(v2 + 72);
  *(void *)(a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 64);
  *(void *)(a1 + 16) = v4;
  *(void *)(a1 + 24) = MEMORY[0x263F8C318] + 16;
  if (*(char *)(a1 + 111) < 0) {
    operator delete(*(void **)(a1 + 88));
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x24C53D6A0](a1 + 128);
  return a1;
}

void *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x24C53D4A0](v13, a1);
  if (v13[0])
  {
    uint64_t v6 = (uint64_t)a1 + *(void *)(*a1 - 24);
    uint64_t v7 = *(void *)(v6 + 40);
    int v8 = *(_DWORD *)(v6 + 8);
    int v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
      uint64_t v10 = std::locale::use_facet(&v14, MEMORY[0x263F8C108]);
      int v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20) {
      uint64_t v11 = a2 + a3;
    }
    else {
      uint64_t v11 = a2;
    }
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9)) {
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
    }
  }
  MEMORY[0x24C53D4B0](v13);
  return a1;
}

void sub_246948B00(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x24C53D4B0](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(void *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x246948AE0);
}

void sub_246948B54(_Unwind_Exception *a1)
{
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6 = a1;
  if (a1)
  {
    uint64_t v11 = *(void *)(a5 + 24);
    if (v11 <= a4 - a2) {
      int64_t v12 = 0;
    }
    else {
      int64_t v12 = v11 - (a4 - a2);
    }
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(void *)a1 + 96))(a1) != a3 - a2) {
      return 0;
    }
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      uint64_t v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(void *)v6 + 96))(v6, v13, v12);
      if (v18 < 0) {
        operator delete(__p[0]);
      }
      if (v14 != v12) {
        return 0;
      }
    }
    uint64_t v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 96))(v6, a3, v15) == v15) {
      *(void *)(a5 + 24) = 0;
    }
    else {
      return 0;
    }
  }
  return v6;
}

void sub_246948CD4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::string::basic_string[abi:ne180100](void *__b, size_t __len, int __c)
{
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((unsigned char *)__b + 23) = __len;
    uint64_t v6 = __b;
    if (!__len) {
      goto LABEL_9;
    }
  }
  memset(v6, __c, __len);
LABEL_9:
  *((unsigned char *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::str[abi:ne180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  uint64_t result = std::stringbuf::view[abi:ne180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  v5 = (const void *)result;
  size_t v6 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    int v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((unsigned char *)a2 + 23) = v4;
    if (!v4) {
      goto LABEL_9;
    }
  }
  uint64_t result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((unsigned char *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:ne180100](uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    unint64_t v3 = *(void *)(a1 + 48);
    if (*(void *)(a1 + 88) < v3) {
      *(void *)(a1 + 88) = v3;
    }
    return *(void *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(void *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t anonymous namespace'::AppendMetadataItem<char const*>(__CFArray **a1, const char *a2, const char **a3)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v14);
  size_t v6 = *a3;
  size_t v7 = strlen(v6);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v15, (uint64_t)v6, v7);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v16, __p);
  if (v12 >= 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v13, a2, (const char *)v8, 0);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v13);
  NamedValue::~NamedValue((NamedValue *)&v13);
  v14[0] = *MEMORY[0x263F8C2B8];
  uint64_t v9 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v14 + *(void *)(v14[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v15 = v9;
  v16[0] = MEMORY[0x263F8C318] + 16;
  if (v17 < 0) {
    operator delete((void *)v16[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v18);
}

void sub_246949058(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<unsigned char>(__CFArray **a1, const char *a2, unsigned char *a3, int a4)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
  if (a4 == 3)
  {
    if (*a3) {
      uint64_t v8 = "on";
    }
    else {
      uint64_t v8 = "off";
    }
    if (*a3) {
      uint64_t v9 = 2;
    }
    else {
      uint64_t v9 = 3;
    }
    goto LABEL_15;
  }
  if (a4 == 2)
  {
    if (*a3) {
      uint64_t v8 = "yes";
    }
    else {
      uint64_t v8 = "no";
    }
    if (*a3) {
      uint64_t v9 = 3;
    }
    else {
      uint64_t v9 = 2;
    }
LABEL_15:
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)v8, v9);
    goto LABEL_17;
  }
  LOBYTE(__p[0]) = *a3;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v17, (uint64_t)__p, 1);
LABEL_17:
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v18, __p);
  if (v14 >= 0) {
    uint64_t v10 = __p;
  }
  else {
    uint64_t v10 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v15, a2, (const char *)v10, 0);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v15);
  NamedValue::~NamedValue((NamedValue *)&v15);
  v16[0] = *MEMORY[0x263F8C2B8];
  uint64_t v11 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v16 + *(void *)(v16[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v17 = v11;
  v18[0] = MEMORY[0x263F8C318] + 16;
  if (v19 < 0) {
    operator delete((void *)v18[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v20);
}

void sub_2469492D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<int>(__CFArray **a1, const char *a2, uint64_t a3, int a4)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v14);
  if (a4 == 1)
  {
    size_t v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v15, (uint64_t)"0x", 2);
    *(_DWORD *)((char *)v7 + *(void *)(*v7 - 24) + 8) = *(_DWORD *)((unsigned char *)v7 + *(void *)(*v7 - 24) + 8) & 0xFFFFFFB5 | 8;
  }
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v16, __p);
  if (v12 >= 0) {
    uint64_t v8 = __p;
  }
  else {
    uint64_t v8 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v13, a2, (const char *)v8, 0);
  if (v12 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v13);
  NamedValue::~NamedValue((NamedValue *)&v13);
  v14[0] = *MEMORY[0x263F8C2B8];
  uint64_t v9 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v14 + *(void *)(v14[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v15 = v9;
  v16[0] = MEMORY[0x263F8C318] + 16;
  if (v17 < 0) {
    operator delete((void *)v16[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v18);
}

void sub_24694952C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<double>(__CFArray **a1, const char *a2)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v10);
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v11, __p);
  if (v8 >= 0) {
    unint64_t v4 = __p;
  }
  else {
    unint64_t v4 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v9, a2, (const char *)v4, 0);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v9);
  NamedValue::~NamedValue((NamedValue *)&v9);
  v10[0] = *MEMORY[0x263F8C2B8];
  uint64_t v5 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v10[2] = v5;
  v11[0] = MEMORY[0x263F8C318] + 16;
  if (v12 < 0) {
    operator delete((void *)v11[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v13);
}

void sub_24694972C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<short>(__CFArray **a1, const char *a2, _WORD *a3, int a4)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v17);
  if (a4 == 1)
  {
    uint64_t v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)"0x", 2);
    *(_DWORD *)((char *)v10 + *(void *)(*v10 - 24) + 8) = *(_DWORD *)((unsigned char *)v10 + *(void *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 8;
    goto LABEL_11;
  }
  if (a4 != 2)
  {
LABEL_11:
    std::ostream::operator<<();
    goto LABEL_12;
  }
  if (*a3) {
    char v8 = "yes";
  }
  else {
    char v8 = "no";
  }
  if (*a3) {
    uint64_t v9 = 3;
  }
  else {
    uint64_t v9 = 2;
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v18, (uint64_t)v8, v9);
LABEL_12:
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v19, __p);
  if (v15 >= 0) {
    uint64_t v11 = __p;
  }
  else {
    uint64_t v11 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v16, a2, (const char *)v11, 0);
  if (v15 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v16);
  NamedValue::~NamedValue((NamedValue *)&v16);
  v17[0] = *MEMORY[0x263F8C2B8];
  uint64_t v12 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v17 + *(void *)(v17[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v18 = v12;
  v19[0] = MEMORY[0x263F8C318] + 16;
  if (v20 < 0) {
    operator delete((void *)v19[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v21);
}

void sub_2469499B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<char [4]>(__CFArray **a1, const char *a2)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v10);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v11, (uint64_t)"...", 3);
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v12, __p);
  if (v8 >= 0) {
    unint64_t v4 = __p;
  }
  else {
    unint64_t v4 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v9, a2, (const char *)v4, 0);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v9);
  NamedValue::~NamedValue((NamedValue *)&v9);
  v10[0] = *MEMORY[0x263F8C2B8];
  uint64_t v5 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v11 = v5;
  v12[0] = MEMORY[0x263F8C318] + 16;
  if (v13 < 0) {
    operator delete((void *)v12[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v14);
}

void sub_246949BB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<float>(__CFArray **a1, const char *a2)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v10);
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v11, __p);
  if (v8 >= 0) {
    unint64_t v4 = __p;
  }
  else {
    unint64_t v4 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v9, a2, (const char *)v4, 0);
  if (v8 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v9);
  NamedValue::~NamedValue((NamedValue *)&v9);
  v10[0] = *MEMORY[0x263F8C2B8];
  uint64_t v5 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  void v10[2] = v5;
  v11[0] = MEMORY[0x263F8C318] + 16;
  if (v12 < 0) {
    operator delete((void *)v11[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v13);
}

void sub_246949DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem<eCIspFocusingMethod>(__CFArray **a1)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v8);
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v9, __p);
  if (v6 >= 0) {
    uint64_t v2 = __p;
  }
  else {
    uint64_t v2 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v7, "lastFocusingMethod", (const char *)v2, 0);
  if (v6 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(a1, &v7);
  NamedValue::~NamedValue((NamedValue *)&v7);
  v8[0] = *MEMORY[0x263F8C2B8];
  uint64_t v3 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v8 + *(void *)(v8[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  v8[2] = v3;
  v9[0] = MEMORY[0x263F8C318] + 16;
  if (v10 < 0) {
    operator delete((void *)v9[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v11);
}

void sub_246949FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t anonymous namespace'::AppendMetadataItem(__CFArray **this, NamedValues *a2, const char *a3, double a4, double a5, double a6)
{
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:ne180100]((uint64_t)v16);
  *(void *)((char *)&v18[1] + *(void *)(v17 - 24)) = 5;
  char v8 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)", ", 2);
  uint64_t v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)", ", 2);
  std::ostream::operator<<();
  std::stringbuf::str[abi:ne180100]<std::allocator<char>>((uint64_t)v18, __p);
  if (v14 >= 0) {
    char v10 = __p;
  }
  else {
    char v10 = (void **)__p[0];
  }
  NamedValue::NamedValue((NamedValue *)&v15, (const char *)a2, (const char *)v10, 0);
  if (v14 < 0) {
    operator delete(__p[0]);
  }
  NamedValues::push_back(this, &v15);
  NamedValue::~NamedValue((NamedValue *)&v15);
  v16[0] = *MEMORY[0x263F8C2B8];
  uint64_t v11 = *(void *)(MEMORY[0x263F8C2B8] + 72);
  *(void *)((char *)v16 + *(void *)(v16[0] - 24)) = *(void *)(MEMORY[0x263F8C2B8] + 64);
  uint64_t v17 = v11;
  v18[0] = MEMORY[0x263F8C318] + 16;
  if (v19 < 0) {
    operator delete((void *)v18[8]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x24C53D6A0](&v20);
}

void sub_24694A224(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, int a16, __int16 a17, char a18, char a19)
{
}

uint64_t PDAF::PixelEngine::SetupBuffers(uint64_t result)
{
  if (!result) {
    PDAF::PixelEngine::SetupBuffers();
  }
  uint64_t v1 = 0;
  unint64_t v2 = 0;
  unint64_t v3 = 0;
  *(_OWORD *)(result + 487296) = 0u;
  *(_OWORD *)(result + 487268) = 0u;
  *(_OWORD *)(result + 487284) = 0u;
  *(_OWORD *)(result + 487252) = 0u;
  do
  {
    uint64_t v4 = result + v1;
    int v5 = *(_DWORD *)(result + v1 + 160);
    unint64_t v6 = (2 * (v5 + 271)) & 0x1FFFFFFF0;
    if (v6 <= v2) {
      unint64_t v6 = v2;
    }
    if (v5) {
      unint64_t v2 = v6;
    }
    int v7 = *(_DWORD *)(v4 + 168);
    if (v7)
    {
      unint64_t v8 = (2 * (v7 + 4 * *(_DWORD *)(v4 + 164) + 263)) & 0x1FFFFFFF0;
      if (v8 > v3) {
        unint64_t v3 = v8;
      }
    }
    v1 += 56;
  }
  while (v1 != 112);
  unsigned int v9 = 16 - (((_BYTE)result - 108) & 0xF);
  if (v2)
  {
    *(_DWORD *)(result + 487252) = v9;
    *(_DWORD *)(result + 487256) = v2;
    int v10 = v9 + v2;
    *(_DWORD *)(result + 487260) = v2;
    *(_DWORD *)(result + 487264) = v10;
    *(_DWORD *)(result + 487268) = v2;
    *(_DWORD *)(result + 487272) = v2;
    int v11 = v10 + v2;
    *(_DWORD *)(result + 487276) = v11;
    *(_DWORD *)(result + 487280) = v2;
    unsigned int v9 = v11 + v2;
    *(_DWORD *)(result + 487284) = v2;
  }
  if (v3)
  {
    *(_DWORD *)(result + 487288) = v9;
    *(_DWORD *)(result + 487292) = v3;
    *(_DWORD *)(result + 487296) = v3;
    *(_DWORD *)(result + 487300) = v9 + v3;
    v9 += v3 + v3;
    *(_DWORD *)(result + 487304) = v3;
    *(_DWORD *)(result + 487308) = v3;
  }
  if (v9 > 0x8000) {
    PDAF::PixelEngine::SetupBuffers();
  }
  return result;
}

void PDAF::PixelEngine::Process_x1(uint64_t a1, uint64_t a2)
{
  uint64_t v65 = *MEMORY[0x263EF8340];
  if (!a1) {
    PDAF::PixelEngine::Process_x1();
  }
  if (!a2) {
    PDAF::PixelEngine::Process_x1();
  }
  bzero((void *)(a2 + 469808), 0x4424uLL);
  *(_DWORD *)(a2 + 469804) = *(_DWORD *)(a2 + 288);
  int v4 = *(_DWORD *)(a2 + 4);
  switch(v4)
  {
    case 2:
      uint64_t v62 = a1;
      uint64_t v63 = 0;
      break;
    case 4:
      if (*(_DWORD *)(a2 + 696))
      {
        uint64_t v57 = *(unsigned __int16 *)(a2 + 32);
        uint64_t v55 = *(unsigned __int16 *)(a2 + 34);
        if ((v55 * v57) >= 0x81) {
          PDAF::PixelEngine::Process_x1();
        }
        uint64_t v5 = *(unsigned int *)(a2 + 256);
        bzero((void *)(a2 + 427308), 0x3800uLL);
        int v7 = *(unsigned __int16 *)(a2 + 250) - *(unsigned __int16 *)(a2 + 246);
        if (v7)
        {
          int v8 = 0;
          int v9 = *(unsigned __int16 *)(a2 + 260);
          int v10 = *(unsigned __int16 *)(a2 + 262);
          uint64_t v11 = *(unsigned __int16 *)(a2 + 252);
          int v12 = *(unsigned __int16 *)(a2 + 248) - *(unsigned __int16 *)(a2 + 244);
          uint64_t v13 = a1 + v5 + *(unsigned __int16 *)(a2 + 246) * v11 + 2 * *(unsigned __int16 *)(a2 + 244);
          uint64_t v14 = a2 + 427308 + 112 * -(int)v57;
          int v15 = *(__int16 *)(a2 + 712);
          do
          {
            BOOL v16 = v8 == 0;
            if (!v8) {
              int v8 = v10;
            }
            unsigned int v17 = v57;
            if (!v16) {
              unsigned int v17 = 0;
            }
            v14 += 112 * v17;
            if (v12 >= 1)
            {
              uint64_t v18 = 0;
              int v19 = 0;
              uint64_t v20 = v14 - 112;
              int v21 = v12 + 1;
              do
              {
                BOOL v22 = v19 == 0;
                if (!v19) {
                  int v19 = v9;
                }
                v20 += 112 * v22;
                int v23 = *(unsigned __int16 *)(v13 + v18);
                if (v23 != 0x3FFF)
                {
                  int v24 = v23 + v15;
                  unsigned int v25 = v24 ^ (v24 >> 31);
                  unsigned int v26 = 32 - __clz(v25);
                  if (v25) {
                    unsigned int v27 = v26;
                  }
                  else {
                    unsigned int v27 = 0;
                  }
                  int v28 = v27 ^ (v24 >> 31);
                  if (v28 >= 6) {
                    int v29 = 6;
                  }
                  else {
                    int v29 = v28;
                  }
                  int v30 = v29 + 7;
                  if (v28 >= -7) {
                    unsigned int v31 = v30;
                  }
                  else {
                    unsigned int v31 = 0;
                  }
                  int32x2_t v6 = vadd_s32(*(int32x2_t *)(v20 + 8 * v31), (int32x2_t)(*(unsigned __int16 *)(v13 + v18) | 0x100000000));
                  *(int32x2_t *)(v20 + 8 * v31) = v6;
                }
                --v19;
                --v21;
                v18 += 2;
              }
              while (v21 > 1);
            }
            v13 += v11;
            --v8;
            --v7;
          }
          while (v7);
        }
        if (v55)
        {
          for (uint64_t i = 0; i != v55; ++i)
          {
            if (v57)
            {
              uint64_t v33 = 0;
              float v34 = *(float *)(a2 + 292);
              float v35 = *(float *)(a2 + 296);
              float v36 = *(float *)(a2 + 300);
              unsigned int v37 = *(_DWORD *)(a2 + 704);
              do
              {
                uint64_t v38 = 0;
                do
                {
                  uint64_t v61 = 0;
                  uint64_t v58 = v38;
                  if (v38 == 1)
                  {
                    int v39 = 0;
                    BOOL v40 = 0;
                    int v41 = 0;
                    char v42 = 1;
                    float v43 = -255.0;
                    do
                    {
                      int v44 = 0;
                      char v59 = v42;
                      char v45 = 1;
                      do
                      {
                        char v46 = v45;
                        char v45 = 0;
                        *(float *)v6.i32 = v36 * (float)(v35 * (float)(*((float *)&v61 + 1) - v34));
                        if (v43 < *(float *)v6.i32 && v61 >= v37)
                        {
                          float v43 = v36 * (float)(v35 * (float)(*((float *)&v61 + 1) - v34));
                          int v41 = v61;
                          BOOL v40 = v61 >= v37;
                        }
                        int v44 = 1;
                      }
                      while ((v46 & 1) != 0);
                      char v42 = 0;
                      int v39 = 1;
                    }
                    while ((v59 & 1) != 0);
                  }
                  else
                  {
                    if (v38) {
                      int v47 = -1;
                    }
                    else {
                      int v47 = 0;
                    }
                    *(float *)v6.i32 = v35 * (float)(*((float *)&v61 + 1) - v34);
                    float v43 = v36 * *(float *)v6.i32;
                    int v41 = v61;
                    BOOL v40 = v61 >= v37;
                  }
                  *((float *)&v62 + v58) = v43;
                  v64[v58] = v41;
                  v60[v58] = v40;
                  uint64_t v38 = v58 + 1;
                }
                while (v58 != 2);
                v6.i32[0] = v63;
                int v48 = v64[2];
                int v49 = v60[2];
                if (*(unsigned char *)(a2 + 718))
                {
                  uint64_t v50 = 0;
                  char v51 = 2;
                  char v52 = 1;
                  do
                  {
                    char v53 = v52;
                    if (v60[v50] && *(float *)v6.i32 < *((float *)&v62 + v50))
                    {
                      int v48 = v64[v50];
                      LOBYTE(v49) = 1;
                      char v51 = v50;
                      v6.i32[0] = *((_DWORD *)&v62 + v50);
                    }
                    char v52 = 0;
                    uint64_t v50 = 1;
                  }
                  while ((v53 & 1) != 0);
                  v49 &= 1u;
                }
                else
                {
                  char v51 = 2;
                }
                uint64_t v56 = i * v57;
                if (v49) {
                  int v54 = 0xFFFF;
                }
                else {
                  int v54 = 0;
                }
                *(_DWORD *)(a2 + 52 * (v33 + i * v57) + 480048) = v48;
                *(_DWORD *)(a2 + 52 * (v33 + v56) + 480052) = v54;
                *(_DWORD *)(a2 + 52 * (v33 + v56) + 480056) = v6.i32[0];
                *(_DWORD *)(a2 + 52 * (v33 + v56) + 480060) = 0;
                *(_DWORD *)(a2 + 52 * (v33 + v56) + 480064) = 0;
                *(unsigned char *)(a2 + 52 * (v33 + v56) + 480068) = ((40 * v49) | (v51 << 6)) ^ 8;
                ++v33;
              }
              while (v33 != v57);
            }
          }
        }
      }
      break;
    case 3:
      PDAF::PixelEngine::Process_x1();
    default:
      PDAF::PixelEngine::Process_x1();
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::Process(uint64_t a1, uint64_t a2)
{
  uint64_t v529 = *MEMORY[0x263EF8340];
  if (*(unsigned __int16 *)(a2 + 34) * *(unsigned __int16 *)(a2 + 32) >= 0x81) {
  unsigned int v500 = *(_DWORD *)(a2 + 8);
  }
  if (v500 >= 2) {
  int v3 = *(_DWORD *)(a2 + 4);
  }
  if ((v3 - 2) >= 2)
  {
    if (v3 == 4) {
  }
    }
  uint64_t v5 = (_DWORD *)(a2 + 12);
  v421 = (unsigned int *)(a2 + 12);
  v422 = (_DWORD *)(a2 + 616);
  if (!*(_DWORD *)(a2 + 616)) {
    goto LABEL_250;
  }
  int v10 = (unsigned int *)(a2 + 487252);
  switch(*v5)
  {
    case 0:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      if (*(_DWORD *)(a2 + 156))
      }
      {
        unsigned int v11 = 0;
        int v12 = (unsigned __int16 *)(a2 + 487316 + *v10);
        uint64_t v13 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487264));
        v482 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487288));
        v463 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487300));
        v451 = (_WORD *)(a2 + 487316 + *(unsigned int *)(a2 + 487276));
        int v14 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v15 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v11 % *(_DWORD *)(a2 + 132)) + 8);
          BOOL v16 = (unsigned int *)(a2 + 487256);
          uint64_t v17 = 5;
          do
          {
            bzero((void *)(a2 + 487316 + *(v16 - 1)), *v16);
            v16 += 3;
            --v17;
          }
          while (v17);
          if ((unsigned __int16)v14 >= v15) {
            unint64_t v18 = v15;
          }
          else {
            unint64_t v18 = (unsigned __int16)v14;
          }
          LOWORD(v14) = v14 - v15;
          ++v11;
        }
        while (v11 < *(_DWORD *)(a2 + 156));
      }
      break;
    case 1:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      uint64_t v19 = a2 + 487316;
      }
      uint64_t v20 = *v10;
      uint64_t v21 = *(unsigned int *)(a2 + 487264);
      uint64_t v22 = *(unsigned int *)(a2 + 487288);
      uint64_t v23 = *(unsigned int *)(a2 + 487300);
      uint64_t v24 = *(unsigned int *)(a2 + 487276);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v25 = 0;
        unsigned int v26 = (unsigned __int16 *)(v19 + v20);
        unsigned int v27 = (unsigned __int16 *)(v19 + v21);
        v464 = (unsigned __int16 *)(v19 + v23);
        v483 = (unsigned __int16 *)(v19 + v22);
        v452 = (_WORD *)(v19 + v24);
        int v28 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v29 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v25 % *(_DWORD *)(a2 + 132)) + 8);
          int v30 = (unsigned int *)(a2 + 487256);
          uint64_t v31 = 5;
          do
          {
            bzero((void *)(v19 + *(v30 - 1)), *v30);
            v30 += 3;
            --v31;
          }
          while (v31);
          if ((unsigned __int16)v28 >= v29) {
            unint64_t v32 = v29;
          }
          else {
            unint64_t v32 = (unsigned __int16)v28;
          }
          LOWORD(v28) = v28 - v29;
          ++v25;
        }
        while (v25 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v20 = *(unsigned int *)(a2 + 487252);
        uint64_t v21 = *(unsigned int *)(a2 + 487264);
        uint64_t v22 = *(unsigned int *)(a2 + 487288);
        uint64_t v23 = *(unsigned int *)(a2 + 487300);
        uint64_t v24 = *(unsigned int *)(a2 + 487276);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
      if (*(_DWORD *)(a2 + 212))
      }
      {
        unsigned int v33 = 0;
        int v34 = 0;
        float v35 = (unsigned __int16 *)(v19 + v20);
        float v36 = (unsigned __int16 *)(v19 + v21);
        v465 = (unsigned __int16 *)(v19 + v23);
        v484 = (unsigned __int16 *)(v19 + v22);
        v453 = (_WORD *)(v19 + v24);
        int v37 = *(_DWORD *)(a2 + 16);
        v439 = v10 + 1;
        do
        {
          unsigned int v38 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v33 % *(_DWORD *)(a2 + 188)) + 8);
          int v39 = v439;
          uint64_t v40 = 5;
          do
          {
            bzero((void *)(v19 + *(v39 - 1)), *v39);
            v39 += 3;
            --v40;
          }
          while (v40);
          if ((unsigned __int16)v37 >= v38) {
            unint64_t v41 = v38;
          }
          else {
            unint64_t v41 = (unsigned __int16)v37;
          }
          v34 += v38;
          LOWORD(v37) = v37 - v38;
          ++v33;
        }
        while (v33 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 2:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      if (*(_DWORD *)(a2 + 156))
      }
      {
        unsigned int v42 = 0;
        float v43 = (unsigned __int16 *)(a2 + 487316 + *v10);
        int v44 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487264));
        v485 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487288));
        v466 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487300));
        int v45 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v46 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v42 % *(_DWORD *)(a2 + 132)) + 8);
          int v47 = (unsigned int *)(a2 + 487256);
          uint64_t v48 = 5;
          do
          {
            bzero((void *)(a2 + 487316 + *(v47 - 1)), *v47);
            v47 += 3;
            --v48;
          }
          while (v48);
          if ((unsigned __int16)v45 >= v46) {
            unsigned int v49 = v46;
          }
          else {
            unsigned int v49 = (unsigned __int16)v45;
          }
          LOWORD(v45) = v45 - v46;
          ++v42;
        }
        while (v42 < *(_DWORD *)(a2 + 156));
      }
      break;
    case 3:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      uint64_t v50 = a2 + 487316;
      }
      uint64_t v51 = *v10;
      uint64_t v52 = *(unsigned int *)(a2 + 487264);
      uint64_t v53 = *(unsigned int *)(a2 + 487288);
      uint64_t v54 = *(unsigned int *)(a2 + 487300);
      uint64_t v55 = *(unsigned int *)(a2 + 487276);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v56 = 0;
        uint64_t v57 = (unsigned __int16 *)(v50 + v51);
        uint64_t v58 = (unsigned __int16 *)(v50 + v52);
        v467 = (unsigned __int16 *)(v50 + v54);
        v486 = (unsigned __int16 *)(v50 + v53);
        v454 = (_WORD *)(v50 + v55);
        int v59 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v60 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v56 % *(_DWORD *)(a2 + 132)) + 8);
          uint64_t v61 = (unsigned int *)(a2 + 487256);
          uint64_t v62 = 5;
          do
          {
            bzero((void *)(v50 + *(v61 - 1)), *v61);
            v61 += 3;
            --v62;
          }
          while (v62);
          if ((unsigned __int16)v59 >= v60) {
            unint64_t v63 = v60;
          }
          else {
            unint64_t v63 = (unsigned __int16)v59;
          }
          LOWORD(v59) = v59 - v60;
          ++v56;
        }
        while (v56 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v51 = *(unsigned int *)(a2 + 487252);
        uint64_t v52 = *(unsigned int *)(a2 + 487264);
        uint64_t v53 = *(unsigned int *)(a2 + 487288);
        uint64_t v54 = *(unsigned int *)(a2 + 487300);
        uint64_t v55 = *(unsigned int *)(a2 + 487276);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
      if (*(_DWORD *)(a2 + 212))
      }
      {
        unsigned int v64 = 0;
        int v65 = 0;
        v66 = (unsigned __int16 *)(v50 + v51);
        v67 = (unsigned __int16 *)(v50 + v52);
        v468 = (unsigned __int16 *)(v50 + v54);
        v487 = (unsigned __int16 *)(v50 + v53);
        v455 = (_WORD *)(v50 + v55);
        int v68 = *(_DWORD *)(a2 + 16);
        v440 = v10 + 1;
        do
        {
          unsigned int v69 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v64 % *(_DWORD *)(a2 + 188)) + 8);
          v70 = v440;
          uint64_t v71 = 5;
          do
          {
            bzero((void *)(v50 + *(v70 - 1)), *v70);
            v70 += 3;
            --v71;
          }
          while (v71);
          if ((unsigned __int16)v68 >= v69) {
            unint64_t v72 = v69;
          }
          else {
            unint64_t v72 = (unsigned __int16)v68;
          }
          v65 += v69;
          LOWORD(v68) = v68 - v69;
          ++v64;
        }
        while (v64 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 4:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      uint64_t v73 = a2 + 487316;
      }
      uint64_t v74 = *v10;
      uint64_t v75 = *(unsigned int *)(a2 + 487264);
      uint64_t v76 = *(unsigned int *)(a2 + 487288);
      uint64_t v77 = *(unsigned int *)(a2 + 487300);
      uint64_t v78 = *(unsigned int *)(a2 + 487276);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v79 = 0;
        v80 = (unsigned __int16 *)(v73 + v74);
        v81 = (unsigned __int16 *)(v73 + v75);
        v469 = (unsigned __int16 *)(v73 + v77);
        v488 = (unsigned __int16 *)(v73 + v76);
        v456 = (_WORD *)(v73 + v78);
        int v82 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v83 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v79 % *(_DWORD *)(a2 + 132)) + 8);
          v84 = (unsigned int *)(a2 + 487256);
          uint64_t v85 = 5;
          do
          {
            bzero((void *)(v73 + *(v84 - 1)), *v84);
            v84 += 3;
            --v85;
          }
          while (v85);
          if ((unsigned __int16)v82 >= v83) {
            unint64_t v86 = v83;
          }
          else {
            unint64_t v86 = (unsigned __int16)v82;
          }
          LOWORD(v82) = v82 - v83;
          ++v79;
        }
        while (v79 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v74 = *(unsigned int *)(a2 + 487252);
        uint64_t v75 = *(unsigned int *)(a2 + 487264);
        uint64_t v76 = *(unsigned int *)(a2 + 487288);
        uint64_t v77 = *(unsigned int *)(a2 + 487300);
        uint64_t v78 = *(unsigned int *)(a2 + 487276);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
      if (*(_DWORD *)(a2 + 212))
      }
      {
        unsigned int v87 = 0;
        int v88 = 0;
        v89 = (unsigned __int16 *)(v73 + v74);
        v90 = (unsigned __int16 *)(v73 + v75);
        v470 = (unsigned __int16 *)(v73 + v77);
        v489 = (unsigned __int16 *)(v73 + v76);
        v457 = (_WORD *)(v73 + v78);
        int v91 = *(_DWORD *)(a2 + 16);
        v441 = v10 + 1;
        do
        {
          unsigned int v92 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v87 % *(_DWORD *)(a2 + 188)) + 8);
          v93 = v441;
          uint64_t v94 = 5;
          do
          {
            bzero((void *)(v73 + *(v93 - 1)), *v93);
            v93 += 3;
            --v94;
          }
          while (v94);
          if ((unsigned __int16)v91 >= v92) {
            unint64_t v95 = v92;
          }
          else {
            unint64_t v95 = (unsigned __int16)v91;
          }
          v88 += v92;
          LOWORD(v91) = v91 - v92;
          ++v87;
        }
        while (v87 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 5:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      uint64_t v96 = a2 + 487316;
      }
      uint64_t v97 = *v10;
      uint64_t v98 = *(unsigned int *)(a2 + 487264);
      uint64_t v99 = *(unsigned int *)(a2 + 487288);
      uint64_t v100 = *(unsigned int *)(a2 + 487300);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v101 = 0;
        v102 = (unsigned __int16 *)(v96 + v97);
        v103 = (unsigned __int16 *)(v96 + v98);
        v471 = (unsigned __int16 *)(v96 + v100);
        v490 = (unsigned __int16 *)(v96 + v99);
        int v104 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v105 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v101 % *(_DWORD *)(a2 + 132)) + 8);
          v106 = (unsigned int *)(a2 + 487256);
          uint64_t v107 = 5;
          do
          {
            bzero((void *)(v96 + *(v106 - 1)), *v106);
            v106 += 3;
            --v107;
          }
          while (v107);
          if ((unsigned __int16)v104 >= v105) {
            unsigned int v108 = v105;
          }
          else {
            unsigned int v108 = (unsigned __int16)v104;
          }
          LOWORD(v104) = v104 - v105;
          ++v101;
        }
        while (v101 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v97 = *(unsigned int *)(a2 + 487252);
        uint64_t v98 = *(unsigned int *)(a2 + 487264);
        uint64_t v99 = *(unsigned int *)(a2 + 487288);
        uint64_t v100 = *(unsigned int *)(a2 + 487300);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
      if (*(_DWORD *)(a2 + 212))
      }
      {
        unsigned int v109 = 0;
        int v110 = 0;
        v111 = (unsigned __int16 *)(v96 + v97);
        v112 = (unsigned __int16 *)(v96 + v98);
        v472 = (unsigned __int16 *)(v96 + v100);
        v491 = (unsigned __int16 *)(v96 + v99);
        int v113 = *(_DWORD *)(a2 + 16);
        *(void *)v447 = v10 + 1;
        do
        {
          unsigned int v114 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v109 % *(_DWORD *)(a2 + 188)) + 8);
          v115 = *(unsigned int **)v447;
          uint64_t v116 = 5;
          do
          {
            bzero((void *)(v96 + *(v115 - 1)), *v115);
            v115 += 3;
            --v116;
          }
          while (v116);
          if ((unsigned __int16)v113 >= v114) {
            unint64_t v117 = v114;
          }
          else {
            unint64_t v117 = (unsigned __int16)v113;
          }
          v110 += v114;
          LOWORD(v113) = v113 - v114;
          ++v109;
        }
        while (v109 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 6:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      uint64_t v118 = a2 + 487316;
      }
      uint64_t v119 = *v10;
      uint64_t v120 = *(unsigned int *)(a2 + 487264);
      uint64_t v121 = *(unsigned int *)(a2 + 487288);
      uint64_t v122 = *(unsigned int *)(a2 + 487300);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v123 = 0;
        v124 = (unsigned __int16 *)(v118 + v119);
        v125 = (unsigned __int16 *)(v118 + v120);
        v473 = (unsigned __int16 *)(v118 + v122);
        v492 = (unsigned __int16 *)(v118 + v121);
        int v126 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v127 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v123 % *(_DWORD *)(a2 + 132)) + 8);
          v128 = (unsigned int *)(a2 + 487256);
          uint64_t v129 = 5;
          do
          {
            bzero((void *)(v118 + *(v128 - 1)), *v128);
            v128 += 3;
            --v129;
          }
          while (v129);
          if ((unsigned __int16)v126 >= v127) {
            unsigned int v130 = v127;
          }
          else {
            unsigned int v130 = (unsigned __int16)v126;
          }
          LOWORD(v126) = v126 - v127;
          ++v123;
        }
        while (v123 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v119 = *(unsigned int *)(a2 + 487252);
        uint64_t v120 = *(unsigned int *)(a2 + 487264);
        uint64_t v121 = *(unsigned int *)(a2 + 487288);
        uint64_t v122 = *(unsigned int *)(a2 + 487300);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
      if (*(_DWORD *)(a2 + 212))
      }
      {
        unsigned int v131 = 0;
        int v132 = 0;
        v133 = (unsigned __int16 *)(v118 + v119);
        v134 = (unsigned __int16 *)(v118 + v120);
        v474 = (unsigned __int16 *)(v118 + v122);
        v493 = (unsigned __int16 *)(v118 + v121);
        int v135 = *(_DWORD *)(a2 + 16);
        *(void *)v448 = v10 + 1;
        do
        {
          unsigned int v136 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v131 % *(_DWORD *)(a2 + 188)) + 8);
          v137 = *(unsigned int **)v448;
          uint64_t v138 = 5;
          do
          {
            bzero((void *)(v118 + *(v137 - 1)), *v137);
            v137 += 3;
            --v138;
          }
          while (v138);
          if ((unsigned __int16)v135 >= v136) {
            unint64_t v139 = v136;
          }
          else {
            unint64_t v139 = (unsigned __int16)v135;
          }
          v132 += v136;
          LOWORD(v135) = v135 - v136;
          ++v131;
        }
        while (v131 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 7:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      uint64_t v140 = a2 + 487316;
      }
      uint64_t v141 = *v10;
      uint64_t v142 = *(unsigned int *)(a2 + 487264);
      uint64_t v143 = *(unsigned int *)(a2 + 487288);
      uint64_t v144 = *(unsigned int *)(a2 + 487300);
      uint64_t v145 = *(unsigned int *)(a2 + 487276);
      if (*(_DWORD *)(a2 + 156))
      {
        unsigned int v146 = 0;
        v147 = (unsigned __int16 *)(v140 + v141);
        v148 = (unsigned __int16 *)(v140 + v142);
        v475 = (unsigned __int16 *)(v140 + v144);
        v494 = (unsigned __int16 *)(v140 + v143);
        v458 = (_WORD *)(v140 + v145);
        int v149 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v150 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v146 % *(_DWORD *)(a2 + 132)) + 8);
          v151 = (unsigned int *)(a2 + 487256);
          uint64_t v152 = 5;
          do
          {
            bzero((void *)(v140 + *(v151 - 1)), *v151);
            v151 += 3;
            --v152;
          }
          while (v152);
          if ((unsigned __int16)v149 >= v150) {
            unint64_t v153 = v150;
          }
          else {
            unint64_t v153 = (unsigned __int16)v149;
          }
          LOWORD(v149) = v149 - v150;
          ++v146;
        }
        while (v146 < *(_DWORD *)(a2 + 156));
        int v10 = (unsigned int *)(a2 + 487252);
        uint64_t v141 = *(unsigned int *)(a2 + 487252);
        uint64_t v142 = *(unsigned int *)(a2 + 487264);
        uint64_t v143 = *(unsigned int *)(a2 + 487288);
        uint64_t v144 = *(unsigned int *)(a2 + 487300);
        uint64_t v145 = *(unsigned int *)(a2 + 487276);
      }
      if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a2 + 216)) {
      if (*(_DWORD *)(a2 + 212))
      }
      {
        unsigned int v154 = 0;
        int v155 = 0;
        v156 = (unsigned __int16 *)(v140 + v141);
        v157 = (unsigned __int16 *)(v140 + v142);
        v476 = (unsigned __int16 *)(v140 + v144);
        v495 = (unsigned __int16 *)(v140 + v143);
        v459 = (_WORD *)(v140 + v145);
        int v158 = *(_DWORD *)(a2 + 16);
        v442 = v10 + 1;
        do
        {
          unsigned int v159 = *(unsigned __int16 *)(a2 + 188 + 4 * (unsigned __int16)(v154 % *(_DWORD *)(a2 + 188)) + 8);
          v160 = v442;
          uint64_t v161 = 5;
          do
          {
            bzero((void *)(v140 + *(v160 - 1)), *v160);
            v160 += 3;
            --v161;
          }
          while (v161);
          if ((unsigned __int16)v158 >= v159) {
            unint64_t v162 = v159;
          }
          else {
            unint64_t v162 = (unsigned __int16)v158;
          }
          v155 += v159;
          LOWORD(v158) = v158 - v159;
          ++v154;
        }
        while (v154 < *(_DWORD *)(a2 + 212));
      }
      break;
    case 8:
      if (*(_DWORD *)(a2 + 16) != *(_DWORD *)(a2 + 160)) {
      if (*(_DWORD *)(a2 + 156))
      }
      {
        unsigned int v163 = 0;
        v164 = (unsigned __int16 *)(a2 + 487316 + *v10);
        v165 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487264));
        v496 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487288));
        v477 = (unsigned __int16 *)(a2 + 487316 + *(unsigned int *)(a2 + 487300));
        v460 = (_WORD *)(a2 + 487316 + *(unsigned int *)(a2 + 487276));
        int v166 = *(_DWORD *)(a2 + 20);
        do
        {
          unsigned int v167 = *(unsigned __int16 *)(a2 + 132 + 4 * (unsigned __int16)(v163 % *(_DWORD *)(a2 + 132)) + 8);
          v168 = (unsigned int *)(a2 + 487256);
          uint64_t v169 = 5;
          do
          {
            bzero((void *)(a2 + 487316 + *(v168 - 1)), *v168);
            v168 += 3;
            --v169;
          }
          while (v169);
          if ((unsigned __int16)v166 >= v167) {
            unint64_t v170 = v167;
          }
          else {
            unint64_t v170 = (unsigned __int16)v166;
          }
          LOWORD(v166) = v166 - v167;
          ++v163;
        }
        while (v163 < *(_DWORD *)(a2 + 156));
      }
      break;
    default:
  }
  if (!*v422) {
    goto LABEL_250;
  }
  unsigned int v171 = *(_DWORD *)(a2 + 12);
  if (v171 >= 9) {
  int v425 = *(_DWORD *)(a2 + 684);
  }
  float v172 = *(float *)(a2 + 692);
  float v173 = *(float *)(a2 + 292);
  float v174 = *(float *)(a2 + 296);
  float v175 = *(float *)(a2 + 300);
  unsigned int v176 = 8;
  int v177 = 1 << v171;
  int v443 = *(_DWORD *)(a2 + 688);
  unsigned int v434 = *(unsigned __int16 *)(a2 + 664);
  unsigned int v429 = 8u / *(_DWORD *)(a2 + 164);
  if ((v177 & 0x62) != 0) {
    goto LABEL_160;
  }
  if ((v177 & 0x98) != 0)
  {
    unsigned int v176 = 4;
LABEL_160:
    if (8u / *(_DWORD *)(a2 + 164) != v176 / *(_DWORD *)(a2 + 220)) {
    int v449 = 1;
    }
    goto LABEL_163;
  }
  int v449 = 0;
LABEL_163:
  uint64_t v437 = a2 + 288;
  float v504 = 0.0;
  float v505 = 0.0;
  int v178 = *(unsigned __int8 *)(a2 + 672);
  if (*(unsigned char *)(a2 + 672))
  {
    uint64_t v179 = 0;
    unsigned int v180 = *(_DWORD *)(a2 + 676);
    float v181 = *(float *)(a2 + 680);
    do
    {
      uint64_t v478 = v179;
      uint64_t v182 = a2 + 56 * v179;
      *(void *)v501 = *(unsigned int *)(v182 + 156);
      if (v501[0])
      {
        uint64_t v183 = 0;
        uint64_t v184 = a2 + 184320 * v179 + 58668;
        unsigned int v497 = *(_DWORD *)(v182 + 184);
        do
        {
          if (v497)
          {
            uint64_t v185 = 0;
            float v186 = (float)*(int *)(a2 + 628);
            do
            {
              v187 = (_DWORD *)(v184 + v185);
              int v506 = 0;
              LODWORD(v507) = 0;
              unsigned int v188 = *(_DWORD *)(v184 + v185 + 340);
              float v189 = (float)v188;
              if (v188) {
                float v190 = (float)v188;
              }
              else {
                float v190 = 1.0;
              }
              float v191 = *(float *)(v184 + v185 + 160) / v190;
              float v192 = *(float *)(v184 + v185 + 168) / v190;
              float v193 = v191 * v189;
              float v194 = (float)(v191 * v189) * v186;
              float v195 = v192 * v189;
              float v196 = v195 * v186;
              float v197 = *(float *)(v184 + v185 + 164) - (float)(v193 * v191);
              if (v194 == 0.0) {
                float v198 = 1.0;
              }
              else {
                float v198 = v194;
              }
              float v199 = v197 / v198;
              float v200 = *(float *)(v184 + v185 + 176) - (float)(v195 * v192);
              if (v196 == 0.0) {
                float v201 = 1.0;
              }
              else {
                float v201 = v196;
              }
              v187[88] = fmaxf((float)(v199 + (float)(v200 / v201)) * 65536.0, 0.0);
              float v202 = *(float *)&v507;
              v187[86] = v507;
              v187[87] = v506;
              if (v202 >= v181 && v187[88] >= v180) {
                *(unsigned char *)(v184 + v185 + 356) = 1;
              }
              v185 += 360;
            }
            while (360 * v497 != v185);
            v184 += v185;
          }
          ++v183;
        }
        while (v183 != *(void *)v501);
      }
      uint64_t v179 = v478 + 1;
    }
    while (v478 != v449);
  }
  *(unsigned char *)(a2 + 644) = 0;
  v461 = (void *)*(unsigned __int16 *)(a2 + 34);
  if (*(_WORD *)(a2 + 34))
  {
    v432 = 0;
    int v203 = (__int16)(v434 + (v434 >> 15));
    int v204 = -(v203 >> 1);
    float v423 = (float)(v425 - v443);
    if (v172 == 1.0) {
      float v205 = 1.0;
    }
    else {
      float v205 = 1.0 - v172;
    }
    float v206 = (float)(v429 >> 1);
    int v427 = v203 >> 1;
    if (v204 <= v203 >> 1) {
      int v207 = v203 >> 1;
    }
    else {
      int v207 = -(v203 >> 1);
    }
    int v502 = v207;
    v479 = (unsigned __int16 *)*(unsigned __int16 *)(a2 + 32);
    int v435 = -(v203 >> 1);
    do
    {
      if (v479)
      {
        v498 = 0;
        uint64_t v430 = (void)v432 * (void)v479;
        do
        {
          uint64_t v528 = 0;
          long long v526 = 0u;
          long long v527 = 0u;
          long long v524 = 0u;
          long long v525 = 0u;
          long long v522 = 0u;
          long long v523 = 0u;
          long long v520 = 0u;
          long long v521 = 0u;
          long long v518 = 0u;
          long long v519 = 0u;
          long long v517 = 0u;
          long long v515 = 0u;
          memset(v516, 0, sizeof(v516));
          long long v513 = 0u;
          long long v514 = 0u;
          long long v511 = 0u;
          long long v512 = 0u;
          long long v509 = 0u;
          long long v510 = 0u;
          long long v507 = 0u;
          long long v508 = 0u;
          if (v204 <= v427)
          {
            int v209 = 0;
            unsigned int v208 = 0;
            int v210 = v204;
            do
            {
              int v444 = v210;
              unsigned int v211 = v210 + v432;
              do
              {
                if (v204 + (int)v498 < v479 && v211 < v461)
                {
                  uint64_t v213 = 0;
                  float v214 = (float)*(int *)(a2 + 668);
                  uint64_t v215 = a2 + 58684;
                  do
                  {
                    uint64_t v216 = a2 + 56 * v213;
                    if (v213) {
                      __int16 v217 = v204 + (_WORD)v498;
                    }
                    else {
                      __int16 v217 = v211;
                    }
                    __int16 v218 = *(_WORD *)(v216 + 132);
                    unsigned __int16 v219 = v217 * v218;
                    LODWORD(v220) = (unsigned __int16)(v218 + v217 * v218);
                    unsigned int v221 = *(unsigned __int16 *)(v216 + 156);
                    if (v220 >= v221) {
                      uint64_t v220 = v221;
                    }
                    else {
                      uint64_t v220 = v220;
                    }
                    if (v220 > v219)
                    {
                      if (v213) {
                        unsigned __int16 v222 = v211;
                      }
                      else {
                        unsigned __int16 v222 = v204 + (_WORD)v498;
                      }
                      unsigned int v223 = *(_DWORD *)(a2 + 56 * v213 + 184);
                      if ((unsigned __int16)(v222 + 1) >= (unsigned __int16)v223) {
                        uint64_t v224 = (unsigned __int16)v223;
                      }
                      else {
                        uint64_t v224 = (unsigned __int16)(v222 + 1);
                      }
                      uint64_t v225 = v219;
                      unsigned int v226 = v223 * v219 + v222;
                      uint64_t v227 = a2 + 184320 * v213 + 360 * v226 + 58668;
                      uint64_t v228 = v215 + 360 * v226;
                      do
                      {
                        uint64_t v229 = v228;
                        uint64_t v230 = v222;
                        uint64_t v231 = v227;
                        if (v222 < v224)
                        {
                          do
                          {
                            if (!v178 || *(unsigned char *)(v231 + 356) == 1)
                            {
                              uint64_t v232 = 0;
                              unsigned int v233 = *(_DWORD *)(v231 + 340);
                              do
                              {
                                v234 = (float32x4_t *)((char *)&v507 + v232);
                                float32x4_t *v234 = vaddq_f32(*(float32x4_t *)(v231 + v232), *(float32x4_t *)((char *)&v507 + v232));
                                v234[1].f32[0] = *(float *)(v229 + v232) + *(float *)((char *)&v507 + v232 + 16);
                                v232 += 20;
                              }
                              while (v232 != 340);
                              v209 += v233;
                              float v235 = (float)*(int *)(a2 + 628);
                              float v236 = (float)v233;
                              if (v233) {
                                float v237 = (float)v233;
                              }
                              else {
                                float v237 = 1.0;
                              }
                              float v238 = *(float *)(v231 + 160) / v237;
                              float v239 = *(float *)(v231 + 168) / v237;
                              float v240 = v238 * v236;
                              float v241 = (float)(v238 * v236) * v235;
                              float v242 = v239 * v236;
                              float v243 = v242 * v235;
                              float v244 = *(float *)(v231 + 164) - (float)(v240 * v238);
                              if (v241 == 0.0) {
                                float v245 = 1.0;
                              }
                              else {
                                float v245 = v241;
                              }
                              float v246 = v244 / v245;
                              float v247 = *(float *)(v231 + 176) - (float)(v242 * v239);
                              if (v243 == 0.0) {
                                float v243 = 1.0;
                              }
                              v208 += fmaxf((float)(v246 + (float)(v247 / v243)) * v214, 0.0);
                            }
                            v231 += 360;
                            ++v230;
                            v229 += 360;
                          }
                          while (v230 != v224);
                        }
                        v227 += 360 * v223;
                        ++v225;
                        v228 += 360 * v223;
                      }
                      while (v225 != v220);
                    }
                    ++v213;
                    v215 += 184320;
                  }
                  while (v213 != v449 + 1);
                }
                BOOL v251 = v204++ == v502;
              }
              while (!v251);
              int v210 = v444 + 1;
              int v204 = v435;
            }
            while (v444 != v502);
            DWORD1(v527) = v209;
          }
          else
          {
            unsigned int v208 = 0;
          }
          BOOL v248 = v505 <= v172 || v208 <= v425 - (float)((float)((float)(v505 - v172) * v423) / v205);
          int v204 = v435;
          float v249 = v174 * (float)((float)(v206 * v504) - v173);
          v250 = v498;
          BOOL v251 = !v248;
          if (v248) {
            unsigned int v252 = 0;
          }
          else {
            unsigned int v252 = v208;
          }
          uint64_t v253 = a2 + 52 * ((void)v498 + v430) + 480048;
          *(_DWORD *)(v253 + 24) = (float)(v505 * 1000.0);
          *(_DWORD *)(v253 + 28) = v252;
          if (v251) {
            char v254 = -96;
          }
          else {
            char v254 = -120;
          }
          *(float *)(a2 + 52 * ((void)v498 + v430) + 480080) = v175 * v249;
          *(_DWORD *)(a2 + 52 * ((void)v498 + v430) + 480084) = 0;
          *(_DWORD *)(a2 + 52 * ((void)v498 + v430) + 480088) = 0;
          *(unsigned char *)(a2 + 52 * ((void)v498 + v430) + 480092) = v254;
          v498 = (unsigned __int16 *)((char *)v498 + 1);
        }
        while ((unsigned __int16 *)((char *)v250 + 1) != v479);
      }
      v432 = (char *)v432 + 1;
    }
    while (v432 != v461);
  }
LABEL_250:
  unsigned int v255 = *(unsigned __int16 *)(a2 + 32);
  int v256 = *(unsigned __int16 *)(a2 + 34);
  int v257 = v256 * v255;
  if (v256 * v255)
  {
    uint64_t v258 = a2 + 6956;
    uint64_t v259 = a2 + 7100;
    unint64_t v260 = vcvts_n_s32_f32(*(float *)(a2 + 292), 0xCuLL);
    v261 = (uint64_t *)(a2 + 6972);
    do
    {
      uint64_t v262 = 0;
      uint64_t v263 = v258;
      uint64_t v264 = v259;
      do
      {
        for (uint64_t i = 0; i != 24; i += 8)
        {
          uint64_t v266 = *(void *)(v263 + i);
          *(void *)(v263 + i) = *(void *)(v264 + i);
          *(void *)(v264 + i) = v266;
        }
        ++v262;
        v264 -= 24;
        v263 += 24;
      }
      while (v262 != 3);
      uint64_t v267 = 0;
      v268 = v261;
      do
      {
        uint64_t v269 = *(v268 - 1);
              - ((uint64_t)(v269 * v260 + 2048) >> 12)) << v270;
        *(v268 - 1) = v269 << v270;
        uint64_t *v268 = v271;
        ++v267;
        v268 += 3;
      }
      while (v267 != 14);
      v258 += 404;
      v259 += 404;
      v261 = (uint64_t *)((char *)v261 + 404);
      --v257;
    }
    while (v257);
  }
  signed int v272 = a2 + 463660;
  bzero((void *)(a2 + 441644), 0x6E00uLL);
  if (v256)
  {
    float v273 = *(float *)(a2 + 296) * *(float *)(a2 + 300);
    float v274 = *(float *)(a2 + 312);
    uint64_t v275 = a2 + 6956;
    uint64_t v276 = a2 + 463676;
    uint64_t v277 = a2 + 441644;
    do
    {
      if (v255)
      {
        v278 = (void *)(v275 + 16);
        v279 = (_DWORD *)v276;
        unsigned int v280 = v255;
        uint64_t v281 = v277;
        do
        {
          uint64_t v282 = 0;
          unint64_t v283 = 0;
          uint64_t v284 = 0;
          v285 = (void *)(v275 + 388);
          v286 = v278;
          do
          {
            uint64_t v287 = *(v286 - 1);
            unsigned int v288 = (float)((float)v287 / v274);
            if (v288)
            {
              float v289 = v273 * (float)((float)((*v286 << 8) / v287) * 0.0039062);
              if (v289 < 0.0) {
                float v290 = -0.5;
              }
              else {
                float v290 = 0.5;
              }
              int v291 = (int)(float)(v289 + v290);
              uint64_t v292 = *((unsigned int *)v286 - 4);
            }
            else
            {
              int v291 = 0;
              uint64_t v292 = 0;
            }
            v293 = (_DWORD *)(v281 + v282 * 4);
            _DWORD *v293 = v292;
            v293[14] = v288;
            v293[28] = v291;
            v283 += v292;
            ++v282;
            v286 += 3;
          }
          while (v282 != 14);
          uint64_t v294 = *(unsigned int *)(v275 + 384);
          if (v294 && *v285)
          {
            unint64_t v295 = 0;
            uint64_t v296 = *v285 * *v285;
            unint64_t v297 = 16 * v284;
            if (v283 <= 1) {
              unint64_t v298 = 1;
            }
            else {
              unint64_t v298 = v283;
            }
            v299 = (unsigned __int16 *)(a2 + 330);
            int64_t v300 = v297 / v298;
            do
            {
              int v302 = *v299;
              v299 += 2;
              int v301 = v302;
              if (v295 > 2) {
                break;
              }
              ++v295;
              BOOL v303 = v301 == 0xFFFF || v300 < (__int16)v301;
            }
            while (!v303);
            BOOL v304 = 10000 * (*(void *)(v275 + 396) * v294 - v296) / v296 > (__int16)*(v299 - 1);
          }
          else
          {
            BOOL v304 = 0;
          }
          *(unsigned char *)(v281 + 168) = v304;
          v305 = v279;
          for (uint64_t j = 344; j != 392; j += 12)
          {
            *(v305 - 4) = *(_DWORD *)(v275 + j - 8);
            _DWORD *v305 = *(_DWORD *)(v275 + j - 4);
            v305[4] = *(_DWORD *)(v275 + j);
            ++v305;
          }
          v275 += 404;
          v281 += 172;
          v278 = (void *)((char *)v278 + 404);
          v279 += 12;
          --v280;
        }
        while (v280);
      }
      v277 += 172 * v255;
      v276 += 48 * v255;
      --v256;
    }
    while (v256);
  }
  if (*(_DWORD *)(a2 + 316) != 1) {
  uint64_t v307 = 0;
  }
  v445 = (_WORD *)(a2 + 486704);
  char v308 = 1;
  do
  {
    char v480 = v308;
    int v309 = *(_DWORD *)(a2 + 4 * v307 + 316);
    if (v309 >= 1)
    {
      uint64_t v310 = a2 + (v307 << 11) + 469808;
      signed int v311 = *(unsigned __int16 *)(a2 + 32);
      int v312 = *(unsigned __int16 *)(a2 + 34);
      if (v309 == 1)
      {
        int v313 = v312 * v311;
        if (v312 * v311)
        {
          uint64_t v314 = a2 + 441644;
          do
          {
            v314 += 172;
            v310 += 16;
            --v313;
          }
          while (v313);
        }
      }
      else
      {
        int v315 = 0;
        if (v311 >= v309) {
          signed int v272 = v309;
        }
        else {
          signed int v272 = *(unsigned __int16 *)(a2 + 32);
        }
        if (v312 >= v309) {
          int v316 = v309;
        }
        else {
          int v316 = *(unsigned __int16 *)(a2 + 34);
        }
        do
        {
          if (v272 <= v311)
          {
            int v317 = 0;
            do
            {
              unsigned int v318 = v317 + v311 * v315;
              long long v515 = 0u;
              memset(v516, 0, 28);
              long long v513 = 0u;
              long long v514 = 0u;
              long long v511 = 0u;
              long long v512 = 0u;
              long long v509 = 0u;
              long long v510 = 0u;
              long long v507 = 0u;
              long long v508 = 0u;
              if (v316)
              {
                char v319 = 0;
                int v320 = 0;
                uint64_t v321 = a2 + 441644 + 172 * v318;
                unsigned int v322 = v311;
                uint64_t v323 = a2 + 441756 + 172 * (v317 + v315 * v311);
                uint64_t v324 = 172 * v311;
                int v325 = v316;
                do
                {
                  uint64_t v326 = v323;
                  signed int v327 = v272;
                  for (uint64_t k = v321; v327; --v327)
                  {
                    if (*(unsigned char *)(k + 168))
                    {
                      for (uint64_t m = 0; m != 56; m += 4)
                      {
                        *(_DWORD *)((char *)&v507 + m) += *(_DWORD *)(v326 + m - 112);
                        int v330 = *(_DWORD *)(v326 + m - 56);
                        v331 = (_DWORD *)((char *)&v510 + m + 8);
                        _DWORD *v331 = *(_DWORD *)((char *)&v510 + m + 8) + v330;
                        v331[14] = *(_DWORD *)((char *)&v514 + m) + *(_DWORD *)(v326 + m) * v330;
                      }
                      char v319 = ++v320;
                    }
                    k += 172;
                    v326 += 172;
                  }
                  v321 += 172 * v322;
                  v323 += v324;
                  --v325;
                }
                while (v325);
                v516[24] = v319;
              }
              uint64_t v332 = 0;
              uint64_t v333 = v310 + 16 * v318;
              do
              {
                v334 = (char *)&v507 + v332;
                int v335 = *(_DWORD *)((char *)&v510 + v332 + 8);
                if (v335)
                {
                  int v336 = *((_DWORD *)v334 + 28);
                  int v337 = v335 >> 1;
                  if (v336 < 0) {
                    int v337 = -v337;
                  }
                  *((_DWORD *)v334 + 28) = (v337 + v336) / v335;
                }
                v332 += 4;
              }
              while (v332 != 56);
              signed int v311 = *(unsigned __int16 *)(a2 + 32);
              BOOL v303 = v317++ < v311 - v272;
            }
            while (v303);
            int v312 = *(unsigned __int16 *)(a2 + 34);
          }
          BOOL v303 = v315++ < v312 - v316;
        }
        while (v303);
      }
    }
    char v308 = 0;
    uint64_t v307 = 1;
  }
  while ((v480 & 1) != 0);
  uint64_t v338 = *(int *)(a2 + 12);
  if (v338 >= 9) {
  int v339 = *(unsigned __int16 *)(a2 + 34);
  }
  int v340 = v339 * *(unsigned __int16 *)(a2 + 32);
  v341 = (_DWORD *)(a2 + 463660);
  if (v340)
  {
    uint64_t v342 = qword_2469EE1E8[v338];
    int v343 = v339 * *(unsigned __int16 *)(a2 + 32);
    do
    {
      v344 = v341;
      uint64_t v345 = v342;
      do
      {
        v344[2561] = *v344;
        v344[2565] = v344[4];
        v344[2569] = v344[8];
        ++v344;
        --v345;
      }
      while (v345);
      v341 += 12;
      --v343;
    }
    while (v343);
  }
  *(_DWORD *)(a2 + 487240) = *(_DWORD *)(a2 + 6869);
  *(unsigned char *)(a2 + 487244) = *(unsigned char *)(a2 + 6873);
  if (*(unsigned char *)(a2 + 6868))
  {
    uint64_t v346 = (unsigned __int16)*v445;
    if (v340 && v346 <= 0x7F)
    {
      v347 = (float *)(a2 + 486708 + 4 * v346);
      int v348 = v340 - 1;
      uint64_t v349 = a2 + 473904;
      do
      {
        LOWORD(v346) = *v445;
        if (v350 >= 0.0)
        {
          *v347++ = v350;
          LOWORD(v346) = v346 + 1;
          _WORD *v445 = v346;
        }
        if (!v348) {
          break;
        }
        v349 += 48;
        --v348;
      }
      while ((unsigned __int16)v346 < 0x80u);
    }
    if ((_WORD)v346)
    {
      uint64_t v351 = 0;
      unsigned int v352 = (unsigned __int16)*v445;
      do
      {
        unint64_t v353 = (42949673 * (unint64_t)(*(unsigned __int8 *)(a2 + 487240 + v351) * v352 + 50)) >> 32;
        if (v353 >= v352) {
          LODWORD(v353) = v352 - 1;
        }
        *(_DWORD *)(a2 + 487220 + 4 * v351++) = *(_DWORD *)&v445[2 * (int)v353 + 2];
      }
      while (v351 != 5);
    }
    uint64_t v354 = 0;
    uint64_t v355 = a2 + 6876;
    while (2)
    {
      unint64_t v356 = 0;
      do
      {
        float v357 = *(float *)(v355 + 4 * v356);
        if (v357 < 0.0) {
          goto LABEL_352;
        }
        float v358 = *(float *)(a2 + 487220 + 4 * v356);
        if (v356 > 3) {
          break;
        }
        ++v356;
      }
      while (v357 <= v358);
      if (v357 > v358)
      {
LABEL_352:
        if (*(unsigned __int8 *)(a2 + 487248) >= 5u) {
        break;
        }
      }
      *(unsigned char *)(a2 + 487248) = ++v354;
      v355 += 20;
      if (v354 != 4) {
        continue;
      }
      break;
    }
  }
  if (*(unsigned char *)(a2 + 408))
  {
    float v359 = *(float *)(a2 + 412);
    if (*(unsigned char *)(a2 + 487248) && v359 > *(float *)(a2 + 416)) {
      float v359 = *(float *)(a2 + 416);
    }
  }
  else
  {
    float v359 = 0.0;
  }
  uint64_t v360 = 0;
  float v361 = (float)((float)(*(float *)(a2 + 296) * *(float *)(a2 + 292)) * *(float *)(a2 + 300)) * -0.5;
  char v362 = 1;
  do
  {
    char v503 = v362;
    int v363 = *(_DWORD *)(a2 + 4 * v360 + 316);
    if (v363 >= 1)
    {
      unsigned int v364 = *(unsigned __int16 *)(a2 + 34);
      unsigned int v365 = v364 - v363;
      if (v364 >= v363)
      {
        int v366 = 0;
        float v367 = (float)*(int *)(a2 + 469804);
        uint64_t v368 = a2 + (v360 << 11) + 469808;
        uint64_t v369 = a2 + 20 * v360;
        v499 = (unsigned __int16 *)(v369 + 368);
        unsigned int v370 = *(unsigned __int16 *)(a2 + 32);
        v450 = (unsigned int *)(v369 + 380);
        v462 = (_DWORD *)(v369 + 376);
        v438 = (unsigned int *)(v369 + 372);
        v446 = (unsigned int *)(v369 + 384);
        char v371 = (_BYTE)v360 << 6;
        unsigned int v481 = v370 - v363;
        uint64_t v372 = *(unsigned __int16 *)(a2 + 32);
        uint64_t v374 = a2 + 480048;
        uint64_t v373 = a2 + 473904;
        unsigned int v426 = v365;
        unsigned int v424 = v370;
        while (v370 < v363)
        {
LABEL_426:
          v373 += 48 * v372;
          v368 += 16 * v372;
          v374 += 52 * v372;
          BOOL v251 = v366++ == v365;
          if (v251) {
            goto LABEL_428;
          }
        }
        int v436 = v366;
        int v375 = 0;
        uint64_t v428 = v374;
        uint64_t v431 = v373;
        uint64_t v433 = v368;
        while (1)
        {
          unsigned int v377 = *(unsigned char *)(a2 + 348) ? v272 & 0xFFFFFFFE | (*(unsigned char *)(v368 + 12) == 0) : v272 & 0xFFFFFFFE;
          if (*(unsigned char *)(a2 + 352))
          {
            int v378 = *(_DWORD *)(v368 + 8);
            float v379 = (float)((float)v378 * 0.0625) + v367;
            float v380 = (float)*(int *)(a2 + 364);
            BOOL v381 = v379 >= v380 || v378 < *(_DWORD *)(a2 + 356);
            unsigned int v382 = v381
                 ? v377 & 0xFFFFFFFB | (4 * (v379 >= v380))
                 : v377 & 0xFFFFFFFB | (4 * (v379 <= (float)*(int *)(a2 + 360)));
          }
          else
          {
            unsigned int v382 = v377 & 0xFFFFFFFB;
          }
          if (*(unsigned char *)v499)
          {
            unsigned int v383 = *v438;
            if (*v438 <= 1) {
              unsigned int v383 = 1;
            }
            unsigned int v384 = *(_DWORD *)(v368 + 4);
            unsigned int v385 = *(_DWORD *)v368 / v383;
            float v386 = (float)((float)*(int *)(v368 + 8) * 0.0625) - v361;
            if (v386 < 0.0) {
              float v386 = -v386;
            }
            float v387 = (float)((float)(1.0 - (float)((float)(v386 + -16.0) * 0.0625)) * 20.0)
                 + (float)((float)((float)(v386 + -16.0) * 0.0625) * 10.0);
            if (v386 > 32.0) {
              float v387 = 10.0;
            }
            if (v386 <= 16.0) {
              float v387 = (float)((float)(1.0 - (float)((float)(v386 + -8.0) * 0.125)) * 40.0)
            }
                   + (float)((float)((float)(v386 + -8.0) * 0.125) * 20.0);
            float v388 = v386 > 8.0 ? v387 : 40.0;
            unsigned int v389 = (*v462 * (float)((float)(fabsf(sqrtf((float)v385)) * v388) + 0.5)) >> 8;
            BOOL v390 = v385 >= *v446 || v384 >= *v450;
            BOOL v391 = v390 && v384 >= v389;
            int v392 = v391 ? 0 : 8;
            unsigned int v393 = v392 | v382 & 0xFFFFFFF7;
          }
          else
          {
            unsigned int v393 = v382 & 0xFFFFFFF7;
          }
          unsigned int v394 = *(unsigned char *)(a2 + 408) ? v393 & 0xFFFFFFEF | (16 * (v376 >= v359)) : v393 & 0xFFFFFFEF;
          signed int v272 = v394 & 0xFFFFFFDD;
          float v395 = (float)*(int *)(v368 + 8) * 0.0625;
          if (v363 != 1) {
            break;
          }
          if ((v503 & 1) == 0) {
          *(void *)uint64_t v374 = *(void *)v368;
          }
          *(float *)(v374 + 8) = v395;
          *(float *)(v374 + 12) = v376;
          *(_DWORD *)(v374 + 16) = 0;
          *(_DWORD *)(v374 + 20) = v394 & 0xDD;
          *(unsigned char *)(v374 + 20) = v371 | (32 * ((v394 & 0x1D) == 0)) | v394 & 0x1D;
LABEL_423:
          v368 += 16;
          v373 += 48;
          v374 += 52;
          BOOL v251 = v375++ == v481;
          if (v251)
          {
            uint64_t v372 = *(unsigned __int16 *)(a2 + 32);
            unsigned int v365 = v426;
            int v366 = v436;
            uint64_t v373 = v431;
            uint64_t v368 = v433;
            unsigned int v370 = v424;
            uint64_t v374 = v428;
            goto LABEL_426;
          }
        }
        if (v503) {
        if ((v394 & 0xD) != 0)
        }
          goto LABEL_423;
        unsigned int v396 = *(unsigned __int8 *)(v368 + 12);
        int v397 = v363;
        uint64_t v398 = v374;
LABEL_408:
        v399 = (float *)(v398 + 20);
        int v400 = v363;
        while (1)
        {
          char v401 = *(unsigned char *)v399;
          if (((*(unsigned char *)v399 & 0x10) != 0 || (*(unsigned char *)v399 & 1) != 0 && (v363 * v363) >> 1 >= v396)
            && !*(unsigned char *)(a2 + 328))
          {
            goto LABEL_421;
          }
          if (*(unsigned char *)(a2 + 346) == 1)
          {
            if ((*(unsigned char *)v399 & 0x20) != 0 && *(v399 - 3) <= v395) {
              goto LABEL_421;
            }
          }
          else
          {
            if (*(unsigned char *)(a2 + 346)) {
            if ((*(unsigned char *)v399 & 0x20) != 0 && *(v399 - 3) >= v395)
            }
              goto LABEL_421;
          }
          *(void *)(v399 - 5) = *(void *)v368;
          *(v399 - 3) = v395;
          *(unsigned char *)v399 = v371 | v401 & 0x33 | 0x20;
LABEL_421:
          v399 += 13;
          if (!--v400)
          {
            v398 += 52 * *(unsigned __int16 *)(a2 + 32);
            if (!--v397) {
              goto LABEL_423;
            }
            goto LABEL_408;
          }
        }
      }
    }
LABEL_428:
    char v362 = 0;
    uint64_t v360 = 1;
  }
  while ((v503 & 1) != 0);
  if (*(unsigned char *)(a2 + 420))
  {
    if (*v422)
    {
      int v402 = *(unsigned __int16 *)(a2 + 34) * *(unsigned __int16 *)(a2 + 32);
      if (v402)
      {
        v403 = (float *)(a2 + 480092);
        do
        {
          if (*(unsigned char *)(a2 + 421) && (*(unsigned char *)v403 & 0x20) == 0) {
            *((unsigned char *)v403 - 24) = *(unsigned char *)(v403 - 6) & 0xDD | 2;
          }
          char v404 = *((unsigned char *)v403 - 24);
          if ((v404 & 0x20) != 0)
          {
            if (*(unsigned char *)(a2 + 422))
            {
              float v409 = *(v403 - 9);
              if ((v409 <= 0.0 || *(v403 - 3) >= 0.0) && (v409 >= 0.0 || *(v403 - 3) <= 0.0))
              {
                float v410 = -v409;
                if (v409 >= 0.0) {
                  float v410 = *(v403 - 9);
                }
                if (v410 > 1.0)
                {
                  float v411 = *(v403 - 3);
                  float v412 = -v411;
                  if (v411 >= 0.0) {
                    float v412 = *(v403 - 3);
                  }
                  if (v412 <= v410) {
                    uint64_t v413 = a2 + 456;
                  }
                  else {
                    uint64_t v413 = a2 + 512;
                  }
                  if (v412 <= v410) {
                    float v414 = v412;
                  }
                  else {
                    float v414 = v410;
                  }
                  if (v412 <= v410) {
                    float v415 = v410;
                  }
                  else {
                    float v415 = v412;
                  }
                  if (v414 == 0.0) {
                    float v417 = 1.0;
                  }
                  else {
                    float v417 = v414;
                  }
                  float v418 = powf(v415 / v417, v416);
                  *(v403 - 9) = (float)(v411 * v419) + (float)(v409 * (float)(1.0 - v419));
                  *(v403 - 7) = v419;
                }
              }
            }
          }
          else if (*(unsigned char *)(a2 + 423) && (*(unsigned char *)v403 & 0x20) != 0)
          {
            unsigned int v405 = *((_DWORD *)v403 - 5);
            float v407 = (float)*((unsigned int *)v403 - 4);
            unsigned int v408 = (float)((float)(v406
            *((_DWORD *)v403 - 11) = v405;
            *((_DWORD *)v403 - 10) = v408;
            *(v403 - 9) = *(v403 - 3);
            *(v403 - 7) = 1.0;
            *((unsigned char *)v403 - 24) = v404 & 0x1F | (32 * (v408 != 0)) | 0xC0;
          }
          v403 += 13;
          --v402;
        }
        while (v402);
      }
    }
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::WeightMapProcess(uint64_t result)
{
  if (*(unsigned char *)(result + 720))
  {
    unsigned int v1 = *(unsigned __int8 *)(result + 721);
    int v2 = *(unsigned __int8 *)(result + 722) == v1 ? 1 : *(unsigned __int8 *)(result + 722) - v1;
    int v3 = *(unsigned __int16 *)(result + 34);
    if (*(_WORD *)(result + 34))
    {
      int v4 = 0;
      int v5 = *(_DWORD *)(result + 276);
      uint64_t v6 = result + 480048;
      int v7 = *(_DWORD *)(result + 284);
      unsigned int v8 = *(unsigned __int16 *)(result + 266);
      int v32 = *(_DWORD *)(result + 272);
      int v9 = *(unsigned __int16 *)(result + 32);
      int v10 = (((v2 + ((unsigned __int16)(v2 & 0x8000) >> 15)) >> 1) + 0x10000) / v2;
      do
      {
        int v11 = v7 + v5;
        unsigned int v12 = (v5 >> 8) & ~(v5 >> 31);
        if (v12 >= v8) {
          unsigned int v12 = v8;
        }
        unsigned int v13 = ((v11 + 255) >> 8) & ~((v11 + 255) >> 31);
        if (v13 >= v8) {
          unsigned int v13 = v8;
        }
        int v14 = v13 - v12;
        if (v13 < v12) {
          int v14 = 0;
        }
        if (v9)
        {
          int v15 = 0;
          int v16 = *(_DWORD *)(result + 280);
          unsigned int v17 = *(unsigned __int16 *)(result + 264);
          uint64_t v18 = *(unsigned __int16 *)(result + 268);
          int v19 = v32;
          do
          {
            int v20 = 0;
            unsigned int v21 = (v19 >> 8) & ~(v19 >> 31);
            v19 += v16;
            if (v21 >= v17) {
              unsigned int v21 = v17;
            }
            unsigned int v22 = ((v19 + 255) >> 8) & ~((v19 + 255) >> 31);
            if (v22 >= v17) {
              unsigned int v22 = v17;
            }
            unsigned int v23 = v22 - v21;
            if (v22 < v21) {
              unsigned int v23 = 0;
            }
            if (v13 > v12)
            {
              int v20 = 0;
              uint64_t v24 = result + 723 + v12 * v18 + v21;
              if (v23 <= 1) {
                uint64_t v25 = 1;
              }
              else {
                uint64_t v25 = v23;
              }
              int v26 = v14;
              do
              {
                if (v22 > v21)
                {
                  for (uint64_t i = 0; i != v25; ++i)
                  {
                    unsigned int v28 = *(unsigned __int8 *)(v24 + i);
                    if (v28 <= v1) {
                      unsigned int v28 = v1;
                    }
                    v20 += v28;
                  }
                }
                v24 += v18;
                BOOL v29 = __OFSUB__(v26--, 1);
              }
              while (!((v26 < 0) ^ v29 | (v26 == 0)));
              if (v22 > v21) {
                v20 /= (int)(v23 * v14);
              }
            }
            int v30 = (v20 - v1) * v10;
            if (v30 >= 0x10000) {
              char v31 = -1;
            }
            else {
              char v31 = BYTE1(v30) & ~(v30 >> 31);
            }
            *(unsigned char *)(v6 + 48) = v31;
            v6 += 52;
            ++v15;
          }
          while (v15 != v9);
        }
        ++v4;
        int v5 = v11;
      }
      while (v4 != v3);
    }
  }
  return result;
}

uint64_t PDAF::PixelEngine::Process_x2(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  v8[2] = *MEMORY[0x263EF8340];
  if (!a1) {
    PDAF::PixelEngine::Process_x2();
  }
  if (!a2) {
    PDAF::PixelEngine::Process_x2();
  }
  if (!a3) {
    PDAF::PixelEngine::Process_x2();
  }
  bzero(a3 + 117452, 0x4424uLL);
  a3[117451] = a3[72];
  int v6 = a3[1];
  if (v6 != 3)
  {
    if (v6 != 4)
    {
      if (v6 == 2) {
        PDAF::PixelEngine::Process_x2();
      }
      PDAF::PixelEngine::Process_x2();
    }
    PDAF::PixelEngine::Process_x2();
  }
  v8[0] = a1;
  v8[1] = a2;
}

void PDAF::PixelEngine::Process_x3(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          bzero(a4 + 117452, 0x4424uLL);
          a4[117451] = a4[72];
          int v5 = a4[1];
          if (v5 != 4)
          {
            if (v5 != 3)
            {
              if (v5 == 2) {
                __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4383, "false");
              }
              __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4395, "false");
            }
            __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4387, "false");
          }
          __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4391, "false");
        }
        __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4378, "pContext != nullptr");
      }
      __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4377, "pIn2 != nullptr");
    }
    __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4376, "pIn1 != nullptr");
  }
  __assert_rtn("Process_x3", "PDAFPixelEngine.cpp", 4375, "pIn0 != nullptr");
}

void PDAF::PixelEngine::Process_x4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            bzero(a5 + 117452, 0x4424uLL);
            a5[117451] = a5[72];
            int v6 = a5[1];
            if (v6 != 4)
            {
              if (v6 != 3)
              {
                if (v6 == 2) {
                  __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4418, "false");
                }
                __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4430, "false");
              }
              __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4422, "false");
            }
            __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4426, "false");
          }
          __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4413, "pContext != nullptr");
        }
        __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4412, "pIn3 != nullptr");
      }
      __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4411, "pIn2 != nullptr");
    }
    __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4410, "pIn1 != nullptr");
  }
  __assert_rtn("Process_x4", "PDAFPixelEngine.cpp", 4409, "pIn0 != nullptr");
}

uint64_t PDAF::PixelEngine::anonymous namespace'::AFEGetInputs(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  int v4 = 0;
  uint64_t v5 = 0;
  int v6 = 0;
  uint64_t v7 = 1;
  uint64_t v70 = a3;
  while (2)
  {
    uint64_t result = v7;
    uint64_t v9 = a3 + 80 * v5;
    *(_OWORD *)(v9 + 64) = 0u;
    *(_OWORD *)(v9 + 32) = 0u;
    *(_OWORD *)uint64_t v9 = 0u;
    *(_OWORD *)(v9 + 48) = 0u;
    int v10 = (unsigned int *)(v9 + 48);
    *(_OWORD *)(v9 + 16) = 0u;
    int v11 = (unsigned int *)(v9 + 16);
    unsigned int v12 = (PDAF::PixelEngine::_anonymous_namespace_ *)*a1;
    unsigned int v13 = &a1[12 * v5];
    *(_DWORD *)uint64_t v9 = v12;
    *(void *)(v9 + 20) = -1;
    int v14 = (_DWORD *)(v9 + 20);
    *(void *)(v9 + 52) = -1;
    int v15 = (_DWORD *)(v9 + 52);
    unsigned int v18 = v13[9];
    unsigned int v17 = v13 + 9;
    unsigned int v16 = v18;
    int v20 = v17 - 1;
    unsigned int v19 = *(v17 - 1);
    unsigned int v22 = v17[1];
    unsigned int v21 = v17[2];
    BOOL v23 = v22 >= v19;
    unsigned int v24 = v22 - v19;
    if (v24 == 0 || !v23 || v21 <= v16) {
      goto LABEL_53;
    }
    uint64_t v26 = *(void *)(a2 + 8 * v5);
    if (!v26) {
    uint64_t v27 = a3 + 80 * v5;
    }
    *(_DWORD *)(v27 + 4) = v21 - v16;
    unsigned int v28 = (_DWORD *)(v27 + 4);
    BOOL v29 = (unsigned int *)(v9 + 24);
    int v30 = (int *)(v9 + 56);
    unsigned int v75 = result;
    int v76 = v6;
    uint64_t v73 = v10;
    uint64_t v74 = v11;
    uint64_t v72 = v26;
    switch((int)v12)
    {
      case 0:
      case 8:
        unsigned int v31 = a1[12 * v5 + 12];
        if (v31 >= 2) {
        int v32 = a1[12 * v5 + 13];
        }
        if (v32 != -1) {
        goto LABEL_18;
        }
      case 1:
      case 3:
      case 4:
      case 7:
        unsigned int v31 = a1[12 * v5 + 12];
        if (v31 >= 2) {
        int v32 = a1[12 * v5 + 13];
        }
        if ((v32 - 4) <= 0xFFFFFFFD) {
        goto LABEL_18;
        }
      case 2:
        if (a1[12 * v5 + 12]) {
        if (a1[12 * v5 + 13] != -1)
        }
        unsigned int v31 = 0;
        goto LABEL_26;
      case 5:
      case 6:
        if (a1[12 * v5 + 12]) {
        if (a1[12 * v5 + 13] != 2)
        }
        unsigned int v31 = 0;
        int v32 = 2;
LABEL_18:
        if (v12 > 8) {
        if (((1 << (char)v12) & 0xD2) != 0)
        }
        {
          *int v11 = v24;
          *int v14 = 0;
          *BOOL v29 = v31;
          *int v10 = v24;
          *int v15 = 1;
          *int v30 = v32;
        }
        else if (((1 << (char)v12) & 0x105) != 0)
        {
LABEL_26:
          *int v11 = v24;
          *int v14 = 0;
          *BOOL v29 = v31;
          *(void *)int v10 = 0xFFFFFFFF00000000;
          *int v30 = -1;
        }
        else
        {
          *int v10 = v24;
          *int v15 = 0;
          *int v30 = v32;
          *int v11 = v24;
          *int v14 = 1;
          *BOOL v29 = v31;
        }
        unsigned int v33 = &a1[12 * v5];
        int v35 = v33[14];
        int v34 = (int *)(v33 + 14);
        if (v12 > 8) {
        int v37 = v17 - 3;
        }
        int v38 = 1 << (char)v12;
        int v71 = v4;
        if (((1 << (char)v12) & 0xFA) != 0)
        {
          unint64_t v39 = a1[12 * v5 + 7];
          if (AFEDelayV >= v39) {
          unint64_t v40 = *v17;
          }
          if (v40 >= v39) {
          int v41 = v12 - 1;
          }
          if ((v12 - 1) >= 7 || ((0x7Du >> v41) & 1) == 0) {
          uint64_t v42 = qword_2469EE1B0[v41];
          }
          unint64_t v43 = v42 * *v37;
          unint64_t v44 = 2 * v40 - AFEDelayV;
          if (AFEDelayV > v40) {
            unint64_t v44 = *v17;
          }
          unint64_t v45 = (v39 + ~v40);
          uint64_t v46 = (2 * v39 - 1);
          uint64_t v47 = AFEDelayV + v46 - 2 * v45;
          uint64_t v48 = v46 - v45;
          if (AFEDelayV <= v45) {
            uint64_t v48 = v47;
          }
          uint64_t v49 = v42 * *v20;
          unint64_t v68 = v49 + v43 * v48;
          uint64_t v69 = v49 + v43 * v44;
        }
        else
        {
          if ((v38 & 0x101) == 0)
          {
            uint64_t v62 = *v37;
            unint64_t v63 = 16 * v62 * (unint64_t)*v17;
            unsigned int v64 = 2 * *v20;
            a3 = v70;
            uint64_t v65 = v70 + 80 * v5;
            *(void *)(v65 + 8) = 8 * v62;
            uint64_t v51 = (void *)(v65 + 8);
            uint64_t v61 = v63 + 8 * v64;
            v51[3] = 0;
            v51[7] = 0;
            uint64_t result = v75;
            int v58 = v76;
            unsigned int v56 = v73;
            int v59 = v74;
            uint64_t v60 = v72;
            goto LABEL_49;
          }
          unint64_t v43 = 8 * *v37;
          unint64_t v68 = 0;
          uint64_t v69 = v43 * 2 * *v17 + 8 * *v20;
        }
        uint64_t v50 = v70 + 80 * v5;
        *(void *)(v50 + 8) = v43 >> 1;
        uint64_t v51 = (void *)(v50 + 8);
        v51[3] = 0;
        v51[7] = 0;
        a3 = v70;
        if ((v38 & 0xFA) == 0)
        {
          uint64_t result = v75;
          int v58 = v76;
          unsigned int v56 = v73;
          int v59 = v74;
          uint64_t v60 = v72;
          uint64_t v61 = v69;
LABEL_49:
          uint64_t v57 = 0;
          *(void *)(a3 + 80 * v5 + 40) = v60 + v61;
          goto LABEL_50;
        }
        unint64_t v53 = *v17;
        if (v52 > v53) {
          v51[3] = v52 - v53;
        }
        unint64_t v54 = a1[12 * v5 + 7] + ~v52;
        BOOL v23 = v54 >= v53;
        uint64_t v55 = v54 - v53;
        if (v23) {
          v51[7] = v55;
        }
        unsigned int v56 = v73;
        *(void *)(v70 + 80 * v5 + 40) = v72 + v69;
        uint64_t v57 = v72 + v68;
        uint64_t result = v75;
        int v58 = v76;
        int v59 = v74;
LABEL_50:
        *(void *)(a3 + 80 * v5 + 72) = v57;
        if (!*v51) {
        if (*v28 != a1[2])
        }
        int v6 = *v56 + v58;
        int v4 = *v59 + v71;
LABEL_53:
        uint64_t v7 = 0;
        uint64_t v5 = 1;
        if (result) {
          continue;
        }
        unsigned int v66 = a1[1];
        if (v4 && v4 != v66) {
        if (v6)
        }
        {
          if (v6 != v66) {
        }
          }
        return result;
      default:
    }
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlowAccumulate(uint64_t result, uint64_t a2, uint64_t a3, int32x4_t a4, int32x4_t a5, __n128 a6, __n128 a7)
{
  uint64_t v818 = *MEMORY[0x263EF8340];
  int v10 = (int16x8_t *)(a2 + 12);
  uint64_t v807 = *(unsigned __int16 *)(a2 + 32);
  if (result == 1)
  {
    uint64_t v69 = a2 + 6956;
    unsigned int v70 = *(_DWORD *)(a2 + 12);
    if (v70 - 3 < 6 || v70 < 2)
    {
      int v72 = *(_DWORD *)(a2 + 20);
      int v73 = *(_DWORD *)(a2 + 28);
      int v808 = 0;
      uint64_t v74 = a2 + 304;
      int v75 = 2 * v72;
      int v798 = 2 * v73;
      switch(v70)
      {
        case 0u:
          if (!v75) {
            return result;
          }
          int16x8_t v76 = vdupq_n_s16(*(char *)(a2 + 308));
          int v77 = *(_DWORD *)(a2 + 24);
          int v766 = *(_DWORD *)(a2 + 16);
          int v781 = *(_DWORD *)(a3 + 16);
          if (v781) {
            uint64_t v78 = a3 + 16;
          }
          else {
            uint64_t v78 = a3 + 96;
          }
          uint64_t v756 = v78;
          v79.i64[0] = 0x1000100010001;
          v79.i64[1] = 0x1000100010001;
          v80.i64[0] = -1;
          v80.i64[1] = -1;
          v81.i64[0] = 0x2000200020002;
          v81.i64[1] = 0x2000200020002;
          v82.i64[0] = 0x4000400040004;
          v82.i64[1] = 0x4000400040004;
          v83.i64[0] = 0x7000700070007;
          v83.i64[1] = 0x7000700070007;
          v84.i64[0] = 0xF000F000F000FLL;
          v84.i64[1] = 0xF000F000F000FLL;
          v85.i64[0] = 0x5000500050005;
          v85.i64[1] = 0x5000500050005;
          int v86 = v798;
          while (1)
          {
            int v87 = v781;
            if (v766 < 1) {
              goto LABEL_105;
            }
            v7.i32[0] = 0;
            int v88 = 0;
            int v89 = *(_DWORD *)(v756 + 8);
            v8.i32[0] = v89 & 1;
            int8x8_t v90 = (int8x8_t)vdup_lane_s32(vceq_s32(*(int32x2_t *)v8.i8, v7), 0);
            int32x2_t v7 = (int32x2_t)vorr_s8((int8x8_t)(*(void *)&v90 & 0xFF00FF00FF00FF00), (int8x8_t)(*(void *)&vmvn_s8(v90) & 0xFF00FF00FF00FFLL));
            uint64_t v91 = v69 - 404;
            unsigned int v92 = *(const __int16 **)(a3 + 40);
            int v87 = v781;
            int v93 = v766;
LABEL_79:
            uint64_t v94 = *(const __int16 **)(a3 + 120);
            int v95 = *(_DWORD *)(a3 + 96);
            if (!v87)
            {
              int v87 = *(_DWORD *)(a3 + 96);
              unsigned int v92 = *(const __int16 **)(a3 + 120);
            }
            if (v87 > 7) {
              break;
            }
            int v96 = v93;
            if (v87 == v93) {
              goto LABEL_84;
            }
            if (v87 < 1) {
            unint64_t v97 = 0;
            }
            uint64_t v98 = 2 * v87;
            do
            {
              v809.i16[v97 / 2] = *v92;
              v817.i16[v97 / 2] = v92[1];
              v816.i16[v97 / 2] = v92[2];
              v815.i16[v97 / 2] = v92[3];
              v97 += 2;
              v92 += 4;
            }
            while (v98 != v97);
            if (v93 >= 8) {
              int v99 = 8;
            }
            else {
              int v99 = v93;
            }
            if (v87 < v99)
            {
              uint64_t v100 = &v815.i16[(unint64_t)v98 / 2];
              unsigned int v101 = &v816.i16[(unint64_t)v98 / 2];
              v102 = &v817.i16[(unint64_t)v98 / 2];
              v103 = &v809.i16[(unint64_t)v98 / 2];
              int v104 = v87;
              do
              {
                *v103++ = *v94;
                *v102++ = v94[1];
                *v101++ = v94[2];
                *v100++ = v94[3];
                v94 += 4;
                ++v104;
              }
              while (v99 > v104);
            }
            int16x8_t v8 = (int16x8_t)v809;
            v819.val[1] = v817;
            v819.val[3] = v815;
            v819.val[2] = v816;
            v87 += v95 - v99;
            unsigned int v92 = v94;
LABEL_95:
            uint64_t v105 = 0;
            int8x16_t v106 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v8, v82));
            int16x8_t v107 = (int16x8_t)vandq_s8((int8x16_t)v819.val[1], v83);
            int16x8_t v108 = vshrq_n_s16(v8, 3uLL);
            int8x16_t v109 = (int8x16_t)vaddq_s16(v819.val[3], (int16x8_t)vbslq_s8((int8x16_t)vcltzq_s16(vshlq_n_s16((int16x8_t)vmovl_u8((uint8x8_t)v7), 0xFuLL)), (int8x16_t)vnegq_s16(v108), (int8x16_t)v108));
            int8x16_t v110 = (int8x16_t)vcgtq_u16((uint16x8_t)v107, v85);
            int8x16_t v111 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v819.val[1], 3uLL)), 4uLL);
            int16x8_t v112 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8((int8x16_t)v819.val[2], v84), (int16x8_t)vbicq_s8(v79, (int8x16_t)v8)), vorrq_s8(v110, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v8, v81))));
            int16x8_t v113 = vaddq_s16((int16x8_t)vbslq_s8(v110, (int8x16_t)vaddq_s16(v107, v80), (int8x16_t)v107), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v8), (int8x16_t)vcgtq_s16(v819.val[1], v80)), v83));
            int16x8_t v114 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v110, (int8x16_t)vshrq_n_u16((uint16x8_t)v111, 1uLL), v111), 1uLL);
            int16x8_t v115 = vqshlq_s16(vqdmulhq_s16(v114, vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v112, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v819.val[2], 4uLL))), v76);
            int8x16_t v116 = (int8x16_t)vqdmulhq_s16(v115, v114);
            int8x16_t v117 = (int8x16_t)vqdmulhq_s16(v115, (int16x8_t)vshrq_n_u16(vqshlq_n_u16((uint16x8_t)vabsq_s16(v108), 4uLL), 1uLL));
            int8x16_t v118 = (int8x16_t)vceqzq_s16(v112);
            int8x16_t v809 = (int8x16_t)v113;
            int8x16_t v810 = vornq_s8(vandq_s8((int8x16_t)v112, v106), v106);
            int8x16_t v811 = vbslq_s8(v118, v109, v116);
            int8x16_t v812 = vbslq_s8(v118, (int8x16_t)v819.val[3], v117);
            int16x8_t v817 = (int16x8_t)v109;
            uint64_t v119 = &v811;
            while (1)
            {
              BOOL v120 = v88 == 0;
              if (!v88) {
                int v88 = v77;
              }
              uint64_t v121 = v91 + 404 * v120;
              unsigned int v122 = v119[-2].u16[0];
              uint64_t v123 = v119[-1].u16[0];
              uint64_t v124 = v119->u16[0];
              uint64_t v125 = v119[1].u16[0];
              ++*(_DWORD *)(v121 + 384);
              uint64_t v126 = v817.u16[v105];
              *(void *)(v121 + 388) += v126;
              uint64_t result = v121 + 396;
              *(void *)(v121 + 396) += v126 * (unint64_t)v126;
              if (v123)
              {
                if (v123 != 0xFFFF)
                {
                  unsigned int v127 = (void *)(v121 + 24 * v122);
                  uint64_t result = v127[1] + v124;
                  *v127 += v123;
                  v127[1] = result;
                  v127[2] += v125;
                }
              }
              else
              {
                v128 = (_DWORD *)(v91 + 404 * v120 + 12 * v89);
                ++v128[84];
                v128[85] += v124;
                v128[86] += v125;
              }
              ++v808;
              if (v93 - 1 == v105) {
                break;
              }
              uint64_t v119 = (int8x16_t *)((char *)v119 + 2);
              v89 ^= 1u;
              --v88;
              ++v105;
              v91 += 404 * v120;
              if (v105 == 8)
              {
                v93 -= 8;
                uint64_t v91 = v121;
                if (v93 + 1 > 1) {
                  goto LABEL_79;
                }
                break;
              }
            }
LABEL_105:
            if (v87) {
            if (*(_DWORD *)a3 > 8u)
            }
            int v129 = 1 << *(_DWORD *)a3;
            if ((v129 & 0xFA) != 0)
            {
              uint64_t v130 = *(void *)(a3 + 32);
              if (v130)
              {
                *(void *)(a3 + 32) = v130 - 1;
                uint64_t v131 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v131 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v131;
              int v133 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v129 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v132 = *(int32x2_t *)(a3 + 20);
                v8.i32[0] = vadd_s32(v132, (int32x2_t)0x100000001).u32[0];
                int32x2_t v7 = (int32x2_t)veor_s8((int8x8_t)v132, (int8x8_t)0x100000001);
                v8.i32[1] = v7.i32[1];
                *(void *)(a3 + 20) = v8.i64[0];
                goto LABEL_115;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v133 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v133;
LABEL_115:
            unsigned int v134 = *(_DWORD *)(a3 + 80);
            if (v134 > 8) {
            int v135 = 1 << v134;
            }
            if ((v135 & 0xFA) != 0)
            {
              uint64_t v136 = *(void *)(a3 + 112);
              if (v136)
              {
                *(void *)(a3 + 112) = v136 - 1;
                uint64_t v137 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v137 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v137;
              int v139 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_123;
            }
            if ((v135 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v139 = *(_DWORD *)(a3 + 100) + 1;
LABEL_123:
              *(_DWORD *)(a3 + 100) = v139;
              goto LABEL_124;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v138 = *(int32x2_t *)(a3 + 100);
            v8.i32[0] = vadd_s32(v138, (int32x2_t)0x100000001).u32[0];
            int32x2_t v7 = (int32x2_t)veor_s8((int8x8_t)v138, (int8x8_t)0x100000001);
            v8.i32[1] = v7.i32[1];
            *(void *)(a3 + 100) = v8.i64[0];
LABEL_124:
            unsigned int v140 = v807;
            if (v86 != 1) {
              unsigned int v140 = 0;
            }
            v69 += 404 * v140;
            if (v86 == 1) {
              int v86 = v798;
            }
            else {
              --v86;
            }
            if (!--v75) {
              return result;
            }
          }
          int v96 = 8;
LABEL_84:
          v87 -= v96;
          *(int16x8x4_t *)v8.i8 = vld4q_s16(v92);
          v92 += 32;
          goto LABEL_95;
        case 1u:
          if (!v75) {
            return result;
          }
          uint64_t v774 = a3 + 96;
          uint64_t v790 = a3 + 16;
          uint64_t v760 = a3 + 48;
          int v511 = 2 * v73;
          int v512 = -2 * v72;
          while (1)
          {
            if (*(_DWORD *)a3 > 8u) {
            int v515 = 1 << *(_DWORD *)a3;
            }
            if ((v515 & 0xFA) != 0)
            {
              uint64_t v516 = *(void *)(a3 + 32);
              if (v516)
              {
                *(void *)(a3 + 32) = v516 - 1;
                uint64_t v517 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v517 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v517;
              int v519 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v515 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v518 = *(int32x2_t *)(a3 + 20);
                v514.i32[0] = vadd_s32(v518, (int32x2_t)0x100000001).u32[0];
                *(int8x8_t *)v513.i8 = veor_s8((int8x8_t)v518, (int8x8_t)0x100000001);
                v514.i32[1] = v513.i32[1];
                *(void *)(a3 + 20) = v514.i64[0];
                goto LABEL_643;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v519 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v519;
LABEL_643:
            unsigned int v520 = *(_DWORD *)(a3 + 80);
            if (v520 > 8) {
            int v521 = 1 << v520;
            }
            if ((v521 & 0xFA) != 0)
            {
              uint64_t v522 = *(void *)(a3 + 112);
              if (v522)
              {
                *(void *)(a3 + 112) = v522 - 1;
                uint64_t v523 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v523 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v523;
              int v525 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_651;
            }
            if ((v521 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v525 = *(_DWORD *)(a3 + 100) + 1;
LABEL_651:
              *(_DWORD *)(a3 + 100) = v525;
              goto LABEL_652;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v524 = *(int32x2_t *)(a3 + 100);
            v514.i32[0] = vadd_s32(v524, (int32x2_t)0x100000001).u32[0];
            *(int8x8_t *)v513.i8 = veor_s8((int8x8_t)v524, (int8x8_t)0x100000001);
            v514.i32[1] = v513.i32[1];
            *(void *)(a3 + 100) = v514.i64[0];
LABEL_652:
            if (*(_DWORD *)a3 > 8u) {
            int v526 = 1 << *(_DWORD *)a3;
            }
            if ((v526 & 0x9A) != 0)
            {
              uint64_t v527 = *(void *)(a3 + 64);
              if (v527)
              {
                *(void *)(a3 + 64) = v527 - 1;
                uint64_t v528 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v528 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v528;
              int32x2_t v531 = *(int32x2_t *)(a3 + 52);
              a5.i32[0] = vadd_s32(v531, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v531, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 52) = a5.i64[0];
            }
            else
            {
              if ((v526 & 0x60) == 0) {
              uint64_t v529 = *(void *)(a3 + 64);
              }
              if (v529)
              {
                *(void *)(a3 + 64) = v529 - 1;
                uint64_t v530 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v530 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v530;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v532 = *(_DWORD *)(a3 + 80);
            if (v532 > 8) {
            int v533 = 1 << v532;
            }
            if ((v533 & 0x9A) != 0)
            {
              uint64_t v534 = *(void *)(a3 + 144);
              if (v534)
              {
                *(void *)(a3 + 144) = v534 - 1;
                uint64_t v535 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v535 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v535;
              int32x2_t v538 = *(int32x2_t *)(a3 + 132);
              a5.i32[0] = vadd_s32(v538, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v538, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 132) = a5.i64[0];
            }
            else
            {
              if ((v533 & 0x60) == 0) {
              uint64_t v536 = *(void *)(a3 + 144);
              }
              if (v536)
              {
                *(void *)(a3 + 144) = v536 - 1;
                uint64_t v537 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v537 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v537;
              *(_DWORD *)(a3 + 132) += 2;
            }
            unsigned int v539 = v807;
            if (v511 != 2) {
              unsigned int v539 = 0;
            }
            v69 += 404 * v539;
            if (v511 == 2) {
              int v511 = v798;
            }
            else {
              v511 -= 2;
            }
            v512 += 2;
            if (!v512) {
              return result;
            }
          }
        case 2u:
          goto LABEL_197;
        case 3u:
          if (!v75) {
            return result;
          }
          uint64_t v775 = a3 + 128;
          uint64_t v791 = a3 + 48;
          uint64_t v761 = a3 + 16;
          int v540 = 2 * v73;
          int v541 = -2 * v72;
          while (1)
          {
            if (*(_DWORD *)a3 > 8u) {
            int v544 = 1 << *(_DWORD *)a3;
            }
            if ((v544 & 0x9A) != 0)
            {
              uint64_t v545 = *(void *)(a3 + 64);
              if (v545)
              {
                *(void *)(a3 + 64) = v545 - 1;
                uint64_t v546 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v546 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v546;
              int32x2_t v549 = *(int32x2_t *)(a3 + 52);
              v543.i32[0] = vadd_s32(v549, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v542.i8 = veor_s8((int8x8_t)v549, (int8x8_t)0x100000001);
              v543.i32[1] = v542.i32[1];
              *(void *)(a3 + 52) = v543.i64[0];
            }
            else
            {
              if ((v544 & 0x60) == 0) {
              uint64_t v547 = *(void *)(a3 + 64);
              }
              if (v547)
              {
                *(void *)(a3 + 64) = v547 - 1;
                uint64_t v548 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v548 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v548;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v550 = *(_DWORD *)(a3 + 80);
            if (v550 > 8) {
            int v551 = 1 << v550;
            }
            if ((v551 & 0x9A) != 0)
            {
              uint64_t v552 = *(void *)(a3 + 144);
              if (v552)
              {
                *(void *)(a3 + 144) = v552 - 1;
                uint64_t v553 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v553 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v553;
              int32x2_t v556 = *(int32x2_t *)(a3 + 132);
              v543.i32[0] = vadd_s32(v556, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v542.i8 = veor_s8((int8x8_t)v556, (int8x8_t)0x100000001);
              v543.i32[1] = v542.i32[1];
              *(void *)(a3 + 132) = v543.i64[0];
            }
            else
            {
              if ((v551 & 0x60) == 0) {
              uint64_t v554 = *(void *)(a3 + 144);
              }
              if (v554)
              {
                *(void *)(a3 + 144) = v554 - 1;
                uint64_t v555 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v555 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v555;
              *(_DWORD *)(a3 + 132) += 2;
            }
            if (*(_DWORD *)a3 > 8u) {
            int v557 = 1 << *(_DWORD *)a3;
            }
            if ((v557 & 0xFA) != 0)
            {
              uint64_t v558 = *(void *)(a3 + 32);
              if (v558)
              {
                *(void *)(a3 + 32) = v558 - 1;
                uint64_t v559 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v559 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v559;
              int v561 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v557 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v560 = *(int32x2_t *)(a3 + 20);
                a5.i32[0] = vadd_s32(v560, (int32x2_t)0x100000001).u32[0];
                *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v560, (int8x8_t)0x100000001);
                a5.i32[1] = a4.i32[1];
                *(void *)(a3 + 20) = a5.i64[0];
                goto LABEL_716;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v561 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v561;
LABEL_716:
            unsigned int v562 = *(_DWORD *)(a3 + 80);
            if (v562 > 8) {
            int v563 = 1 << v562;
            }
            if ((v563 & 0xFA) != 0)
            {
              uint64_t v564 = *(void *)(a3 + 112);
              if (v564)
              {
                *(void *)(a3 + 112) = v564 - 1;
                uint64_t v565 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v565 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v565;
              int v567 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_724;
            }
            if ((v563 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v567 = *(_DWORD *)(a3 + 100) + 1;
LABEL_724:
              *(_DWORD *)(a3 + 100) = v567;
              goto LABEL_725;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v566 = *(int32x2_t *)(a3 + 100);
            a5.i32[0] = vadd_s32(v566, (int32x2_t)0x100000001).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v566, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 100) = a5.i64[0];
LABEL_725:
            unsigned int v568 = v807;
            if (v540 != 2) {
              unsigned int v568 = 0;
            }
            v69 += 404 * v568;
            if (v540 == 2) {
              int v540 = v798;
            }
            else {
              v540 -= 2;
            }
            v541 += 2;
            if (!v541) {
              return result;
            }
          }
        case 4u:
          if (!v75) {
            return result;
          }
          uint64_t v776 = a3 + 128;
          uint64_t v792 = a3 + 48;
          uint64_t v762 = a3 + 16;
          int v569 = 2 * v73;
          int v570 = -2 * v72;
          while (1)
          {
            if (*(_DWORD *)a3 > 8u) {
            int v573 = 1 << *(_DWORD *)a3;
            }
            if ((v573 & 0x9A) != 0)
            {
              uint64_t v574 = *(void *)(a3 + 64);
              if (v574)
              {
                *(void *)(a3 + 64) = v574 - 1;
                uint64_t v575 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v575 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v575;
              int32x2_t v578 = *(int32x2_t *)(a3 + 52);
              v572.i32[0] = vadd_s32(v578, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v571.i8 = veor_s8((int8x8_t)v578, (int8x8_t)0x100000001);
              v572.i32[1] = v571.i32[1];
              *(void *)(a3 + 52) = v572.i64[0];
            }
            else
            {
              if ((v573 & 0x60) == 0) {
              uint64_t v576 = *(void *)(a3 + 64);
              }
              if (v576)
              {
                *(void *)(a3 + 64) = v576 - 1;
                uint64_t v577 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v577 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v577;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v579 = *(_DWORD *)(a3 + 80);
            if (v579 > 8) {
            int v580 = 1 << v579;
            }
            if ((v580 & 0x9A) != 0)
            {
              uint64_t v581 = *(void *)(a3 + 144);
              if (v581)
              {
                *(void *)(a3 + 144) = v581 - 1;
                uint64_t v582 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v582 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v582;
              int32x2_t v585 = *(int32x2_t *)(a3 + 132);
              v572.i32[0] = vadd_s32(v585, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v571.i8 = veor_s8((int8x8_t)v585, (int8x8_t)0x100000001);
              v572.i32[1] = v571.i32[1];
              *(void *)(a3 + 132) = v572.i64[0];
            }
            else
            {
              if ((v580 & 0x60) == 0) {
              uint64_t v583 = *(void *)(a3 + 144);
              }
              if (v583)
              {
                *(void *)(a3 + 144) = v583 - 1;
                uint64_t v584 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v584 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v584;
              *(_DWORD *)(a3 + 132) += 2;
            }
            if (*(_DWORD *)a3 > 8u) {
            int v586 = 1 << *(_DWORD *)a3;
            }
            if ((v586 & 0xFA) != 0)
            {
              uint64_t v587 = *(void *)(a3 + 32);
              if (v587)
              {
                *(void *)(a3 + 32) = v587 - 1;
                uint64_t v588 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v588 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v588;
              int v590 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v586 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v589 = *(int32x2_t *)(a3 + 20);
                a5.i32[0] = vadd_s32(v589, (int32x2_t)0x100000001).u32[0];
                *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v589, (int8x8_t)0x100000001);
                a5.i32[1] = a4.i32[1];
                *(void *)(a3 + 20) = a5.i64[0];
                goto LABEL_767;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v590 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v590;
LABEL_767:
            unsigned int v591 = *(_DWORD *)(a3 + 80);
            if (v591 > 8) {
            int v592 = 1 << v591;
            }
            if ((v592 & 0xFA) != 0)
            {
              uint64_t v593 = *(void *)(a3 + 112);
              if (v593)
              {
                *(void *)(a3 + 112) = v593 - 1;
                uint64_t v594 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v594 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v594;
              int v596 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_775;
            }
            if ((v592 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v596 = *(_DWORD *)(a3 + 100) + 1;
LABEL_775:
              *(_DWORD *)(a3 + 100) = v596;
              goto LABEL_776;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v595 = *(int32x2_t *)(a3 + 100);
            a5.i32[0] = vadd_s32(v595, (int32x2_t)0x100000001).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v595, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 100) = a5.i64[0];
LABEL_776:
            unsigned int v597 = v807;
            if (v569 != 2) {
              unsigned int v597 = 0;
            }
            v69 += 404 * v597;
            if (v569 == 2) {
              int v569 = v798;
            }
            else {
              v569 -= 2;
            }
            v570 += 2;
            if (!v570) {
              return result;
            }
          }
        case 5u:
          if (!v75) {
            return result;
          }
          v777 = (int *)(a3 + 128);
          v793 = (int *)(a3 + 48);
          v763 = (int *)(a3 + 16);
          int v598 = 2 * v73;
          int v599 = -2 * v72;
          while (1)
          {
            if (*(_DWORD *)a3 > 8u) {
            int v600 = 1 << *(_DWORD *)a3;
            }
            if ((v600 & 0x9A) != 0)
            {
              uint64_t v601 = *(void *)(a3 + 64);
              if (v601)
              {
                *(void *)(a3 + 64) = v601 - 1;
                uint64_t v602 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v602 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v602;
              int32x2_t v605 = *(int32x2_t *)(a3 + 52);
              LODWORD(v606) = vadd_s32(v605, (int32x2_t)0x200000002).u32[0];
              HIDWORD(v606) = veor_s8(*(int8x8_t *)&v605, (int8x8_t)0x100000001).i32[1];
              *(void *)(a3 + 52) = v606;
            }
            else
            {
              if ((v600 & 0x60) == 0) {
              uint64_t v603 = *(void *)(a3 + 64);
              }
              if (v603)
              {
                *(void *)(a3 + 64) = v603 - 1;
                uint64_t v604 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v604 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v604;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v607 = *(_DWORD *)(a3 + 80);
            if (v607 > 8) {
            int v608 = 1 << v607;
            }
            if ((v608 & 0x9A) != 0)
            {
              uint64_t v609 = *(void *)(a3 + 144);
              if (v609)
              {
                *(void *)(a3 + 144) = v609 - 1;
                uint64_t v610 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v610 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v610;
              int32x2_t v613 = *(int32x2_t *)(a3 + 132);
              LODWORD(v614) = vadd_s32(v613, (int32x2_t)0x200000002).u32[0];
              HIDWORD(v614) = veor_s8(*(int8x8_t *)&v613, (int8x8_t)0x100000001).i32[1];
              *(void *)(a3 + 132) = v614;
            }
            else
            {
              if ((v608 & 0x60) == 0) {
              uint64_t v611 = *(void *)(a3 + 144);
              }
              if (v611)
              {
                *(void *)(a3 + 144) = v611 - 1;
                uint64_t v612 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v612 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v612;
              *(_DWORD *)(a3 + 132) += 2;
            }
            if (*(_DWORD *)a3 > 8u) {
            int v615 = 1 << *(_DWORD *)a3;
            }
            if ((v615 & 0xFA) != 0)
            {
              uint64_t v616 = *(void *)(a3 + 32);
              if (v616)
              {
                *(void *)(a3 + 32) = v616 - 1;
                uint64_t v617 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v617 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v617;
              int v620 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v615 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v618 = *(int32x2_t *)(a3 + 20);
                LODWORD(v619) = vadd_s32(v618, (int32x2_t)0x100000001).u32[0];
                HIDWORD(v619) = veor_s8(*(int8x8_t *)&v618, (int8x8_t)0x100000001).i32[1];
                *(void *)(a3 + 20) = v619;
                goto LABEL_818;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v620 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v620;
LABEL_818:
            unsigned int v621 = *(_DWORD *)(a3 + 80);
            if (v621 > 8) {
            int v622 = 1 << v621;
            }
            if ((v622 & 0xFA) != 0)
            {
              uint64_t v623 = *(void *)(a3 + 112);
              if (v623)
              {
                *(void *)(a3 + 112) = v623 - 1;
                uint64_t v624 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v624 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v624;
              int v627 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_826;
            }
            if ((v622 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v627 = *(_DWORD *)(a3 + 100) + 1;
LABEL_826:
              *(_DWORD *)(a3 + 100) = v627;
              goto LABEL_827;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v625 = *(int32x2_t *)(a3 + 100);
            LODWORD(v626) = vadd_s32(v625, (int32x2_t)0x100000001).u32[0];
            HIDWORD(v626) = veor_s8(*(int8x8_t *)&v625, (int8x8_t)0x100000001).i32[1];
            *(void *)(a3 + 100) = v626;
LABEL_827:
            unsigned int v628 = v807;
            if (v598 != 2) {
              unsigned int v628 = 0;
            }
            v69 += 404 * v628;
            if (v598 == 2) {
              int v598 = v798;
            }
            else {
              v598 -= 2;
            }
            v599 += 2;
            if (!v599) {
              return result;
            }
          }
        case 6u:
          if (!v75) {
            return result;
          }
          v778 = (int *)(a3 + 128);
          v794 = (int *)(a3 + 48);
          v764 = (int *)(a3 + 16);
          int v629 = 2 * v73;
          int v630 = -2 * v72;
          while (1)
          {
            if (*(_DWORD *)a3 > 8u) {
            int v631 = 1 << *(_DWORD *)a3;
            }
            if ((v631 & 0x9A) != 0)
            {
              uint64_t v632 = *(void *)(a3 + 64);
              if (v632)
              {
                *(void *)(a3 + 64) = v632 - 1;
                uint64_t v633 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v633 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v633;
              int32x2_t v636 = *(int32x2_t *)(a3 + 52);
              LODWORD(v637) = vadd_s32(v636, (int32x2_t)0x200000002).u32[0];
              HIDWORD(v637) = veor_s8(*(int8x8_t *)&v636, (int8x8_t)0x100000001).i32[1];
              *(void *)(a3 + 52) = v637;
            }
            else
            {
              if ((v631 & 0x60) == 0) {
              uint64_t v634 = *(void *)(a3 + 64);
              }
              if (v634)
              {
                *(void *)(a3 + 64) = v634 - 1;
                uint64_t v635 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v635 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v635;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v638 = *(_DWORD *)(a3 + 80);
            if (v638 > 8) {
            int v639 = 1 << v638;
            }
            if ((v639 & 0x9A) != 0)
            {
              uint64_t v640 = *(void *)(a3 + 144);
              if (v640)
              {
                *(void *)(a3 + 144) = v640 - 1;
                uint64_t v641 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v641 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v641;
              int32x2_t v644 = *(int32x2_t *)(a3 + 132);
              LODWORD(v645) = vadd_s32(v644, (int32x2_t)0x200000002).u32[0];
              HIDWORD(v645) = veor_s8(*(int8x8_t *)&v644, (int8x8_t)0x100000001).i32[1];
              *(void *)(a3 + 132) = v645;
            }
            else
            {
              if ((v639 & 0x60) == 0) {
              uint64_t v642 = *(void *)(a3 + 144);
              }
              if (v642)
              {
                *(void *)(a3 + 144) = v642 - 1;
                uint64_t v643 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v643 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v643;
              *(_DWORD *)(a3 + 132) += 2;
            }
            if (*(_DWORD *)a3 > 8u) {
            int v646 = 1 << *(_DWORD *)a3;
            }
            if ((v646 & 0xFA) != 0)
            {
              uint64_t v647 = *(void *)(a3 + 32);
              if (v647)
              {
                *(void *)(a3 + 32) = v647 - 1;
                uint64_t v648 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v648 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v648;
              int v651 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v646 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v649 = *(int32x2_t *)(a3 + 20);
                LODWORD(v650) = vadd_s32(v649, (int32x2_t)0x100000001).u32[0];
                HIDWORD(v650) = veor_s8(*(int8x8_t *)&v649, (int8x8_t)0x100000001).i32[1];
                *(void *)(a3 + 20) = v650;
                goto LABEL_869;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v651 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v651;
LABEL_869:
            unsigned int v652 = *(_DWORD *)(a3 + 80);
            if (v652 > 8) {
            int v653 = 1 << v652;
            }
            if ((v653 & 0xFA) != 0)
            {
              uint64_t v654 = *(void *)(a3 + 112);
              if (v654)
              {
                *(void *)(a3 + 112) = v654 - 1;
                uint64_t v655 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v655 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v655;
              int v658 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_877;
            }
            if ((v653 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v658 = *(_DWORD *)(a3 + 100) + 1;
LABEL_877:
              *(_DWORD *)(a3 + 100) = v658;
              goto LABEL_878;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v656 = *(int32x2_t *)(a3 + 100);
            LODWORD(v657) = vadd_s32(v656, (int32x2_t)0x100000001).u32[0];
            HIDWORD(v657) = veor_s8(*(int8x8_t *)&v656, (int8x8_t)0x100000001).i32[1];
            *(void *)(a3 + 100) = v657;
LABEL_878:
            unsigned int v659 = v807;
            if (v629 != 2) {
              unsigned int v659 = 0;
            }
            v69 += 404 * v659;
            if (v629 == 2) {
              int v629 = v798;
            }
            else {
              v629 -= 2;
            }
            v630 += 2;
            if (!v630) {
              return result;
            }
          }
        case 7u:
          if (!v75) {
            return result;
          }
          uint64_t v779 = a3 + 128;
          uint64_t v795 = a3 + 48;
          uint64_t v765 = a3 + 16;
          int v660 = 2 * v73;
          int v661 = -2 * v72;
          while (1)
          {
            if (*(_DWORD *)a3 > 8u) {
            int v664 = 1 << *(_DWORD *)a3;
            }
            if ((v664 & 0x9A) != 0)
            {
              uint64_t v665 = *(void *)(a3 + 64);
              if (v665)
              {
                *(void *)(a3 + 64) = v665 - 1;
                uint64_t v666 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v666 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v666;
              int32x2_t v669 = *(int32x2_t *)(a3 + 52);
              v663.i32[0] = vadd_s32(v669, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v662.i8 = veor_s8((int8x8_t)v669, (int8x8_t)0x100000001);
              v663.i32[1] = v662.i32[1];
              *(void *)(a3 + 52) = v663.i64[0];
            }
            else
            {
              if ((v664 & 0x60) == 0) {
              uint64_t v667 = *(void *)(a3 + 64);
              }
              if (v667)
              {
                *(void *)(a3 + 64) = v667 - 1;
                uint64_t v668 = 2 * *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v668 = *(void *)(a3 + 8);
              }
              *(void *)(a3 + 72) += 2 * v668;
              *(_DWORD *)(a3 + 52) += 2;
            }
            unsigned int v670 = *(_DWORD *)(a3 + 80);
            if (v670 > 8) {
            int v671 = 1 << v670;
            }
            if ((v671 & 0x9A) != 0)
            {
              uint64_t v672 = *(void *)(a3 + 144);
              if (v672)
              {
                *(void *)(a3 + 144) = v672 - 1;
                uint64_t v673 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v673 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v673;
              int32x2_t v676 = *(int32x2_t *)(a3 + 132);
              v663.i32[0] = vadd_s32(v676, (int32x2_t)0x200000002).u32[0];
              *(int8x8_t *)v662.i8 = veor_s8((int8x8_t)v676, (int8x8_t)0x100000001);
              v663.i32[1] = v662.i32[1];
              *(void *)(a3 + 132) = v663.i64[0];
            }
            else
            {
              if ((v671 & 0x60) == 0) {
              uint64_t v674 = *(void *)(a3 + 144);
              }
              if (v674)
              {
                *(void *)(a3 + 144) = v674 - 1;
                uint64_t v675 = 2 * *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v675 = *(void *)(a3 + 88);
              }
              *(void *)(a3 + 152) += 2 * v675;
              *(_DWORD *)(a3 + 132) += 2;
            }
            if (*(_DWORD *)a3 > 8u) {
            int v677 = 1 << *(_DWORD *)a3;
            }
            if ((v677 & 0xFA) != 0)
            {
              uint64_t v678 = *(void *)(a3 + 32);
              if (v678)
              {
                *(void *)(a3 + 32) = v678 - 1;
                uint64_t v679 = *(void *)(a3 + 8);
              }
              else
              {
                uint64_t v679 = 2 * *(void *)(a3 + 8);
              }
              *(void *)(a3 + 40) += 2 * v679;
              int v681 = *(_DWORD *)(a3 + 20) + 2;
            }
            else
            {
              if ((v677 & 0x101) != 0)
              {
                *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
                int32x2_t v680 = *(int32x2_t *)(a3 + 20);
                a5.i32[0] = vadd_s32(v680, (int32x2_t)0x100000001).u32[0];
                *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v680, (int8x8_t)0x100000001);
                a5.i32[1] = a4.i32[1];
                *(void *)(a3 + 20) = a5.i64[0];
                goto LABEL_920;
              }
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int v681 = *(_DWORD *)(a3 + 20) + 1;
            }
            *(_DWORD *)(a3 + 20) = v681;
LABEL_920:
            unsigned int v682 = *(_DWORD *)(a3 + 80);
            if (v682 > 8) {
            int v683 = 1 << v682;
            }
            if ((v683 & 0xFA) != 0)
            {
              uint64_t v684 = *(void *)(a3 + 112);
              if (v684)
              {
                *(void *)(a3 + 112) = v684 - 1;
                uint64_t v685 = *(void *)(a3 + 88);
              }
              else
              {
                uint64_t v685 = 2 * *(void *)(a3 + 88);
              }
              *(void *)(a3 + 120) += 2 * v685;
              int v687 = *(_DWORD *)(a3 + 100) + 2;
              goto LABEL_928;
            }
            if ((v683 & 0x101) == 0)
            {
              *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
              int v687 = *(_DWORD *)(a3 + 100) + 1;
LABEL_928:
              *(_DWORD *)(a3 + 100) = v687;
              goto LABEL_929;
            }
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int32x2_t v686 = *(int32x2_t *)(a3 + 100);
            a5.i32[0] = vadd_s32(v686, (int32x2_t)0x100000001).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v686, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 100) = a5.i64[0];
LABEL_929:
            unsigned int v688 = v807;
            if (v660 != 2) {
              unsigned int v688 = 0;
            }
            v69 += 404 * v688;
            if (v660 == 2) {
              int v660 = v798;
            }
            else {
              v660 -= 2;
            }
            v661 += 2;
            if (!v661) {
              return result;
            }
          }
        case 8u:
          if (!v75) {
            return result;
          }
          int16x8_t v689 = vdupq_n_s16(*(char *)(a2 + 308));
          int v690 = *(_DWORD *)(a2 + 24);
          int v796 = *(_DWORD *)(a3 + 16);
          if (v796) {
            uint64_t v691 = a3 + 16;
          }
          else {
            uint64_t v691 = a3 + 96;
          }
          int v780 = *(_DWORD *)(a2 + 16);
          uint64_t v758 = v691;
          v692.i64[0] = 0x1000100010001;
          v692.i64[1] = 0x1000100010001;
          v693.i64[0] = -1;
          v693.i64[1] = -1;
          v694.i64[0] = 0x2000200020002;
          v694.i64[1] = 0x2000200020002;
          v695.i64[0] = 0x4000400040004;
          v695.i64[1] = 0x4000400040004;
          v696.i64[0] = 0x7000700070007;
          v696.i64[1] = 0x7000700070007;
          v697.i64[0] = 0xF000F000F000FLL;
          v697.i64[1] = 0xF000F000F000FLL;
          v698.i64[0] = 0x5000500050005;
          v698.i64[1] = 0x5000500050005;
          int v699 = v798;
          break;
        default:
      }
      while (1)
      {
        int v700 = v796;
        if (v780 < 1) {
          goto LABEL_971;
        }
        int v701 = 0;
        int v702 = *(_DWORD *)(v758 + 8);
        int8x16_t v703 = (int8x16_t)vdupq_n_s16(-(v702 & 1));
        uint64_t v704 = v69 - 404;
        v705 = *(const __int16 **)(a3 + 40);
        int v700 = v796;
        int v706 = v780;
LABEL_945:
        v707 = *(const __int16 **)(a3 + 120);
        int v708 = *(_DWORD *)(a3 + 96);
        if (!v700)
        {
          int v700 = *(_DWORD *)(a3 + 96);
          v705 = *(const __int16 **)(a3 + 120);
        }
        if (v700 > 7) {
          break;
        }
        int v709 = v706;
        if (v700 == v706) {
          goto LABEL_950;
        }
        if (v700 < 1) {
        unint64_t v710 = 0;
        }
        uint64_t v711 = 2 * v700;
        do
        {
          v809.i16[v710 / 2] = *v705;
          v817.i16[v710 / 2] = v705[1];
          v816.i16[v710 / 2] = v705[2];
          v815.i16[v710 / 2] = v705[3];
          v710 += 2;
          v705 += 4;
        }
        while (v711 != v710);
        if (v706 >= 8) {
          int v712 = 8;
        }
        else {
          int v712 = v706;
        }
        if (v700 < v712)
        {
          v713 = &v815.i16[(unint64_t)v711 / 2];
          v714 = &v816.i16[(unint64_t)v711 / 2];
          v715 = &v817.i16[(unint64_t)v711 / 2];
          v716 = &v809.i16[(unint64_t)v711 / 2];
          int v717 = v700;
          do
          {
            *v716++ = *v707;
            *v715++ = v707[1];
            *v714++ = v707[2];
            *v713++ = v707[3];
            v707 += 4;
            ++v717;
          }
          while (v712 > v717);
        }
        v820.val[0] = (int16x8_t)v809;
        v820.val[1] = v817;
        v820.val[3] = v815;
        v820.val[2] = v816;
        v700 += v708 - v712;
        v705 = v707;
LABEL_961:
        uint64_t v718 = 0;
        int8x16_t v719 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v820.val[0], v695));
        int16x8_t v720 = (int16x8_t)vandq_s8((int8x16_t)v820.val[1], v696);
        int16x8_t v721 = vshrq_n_s16(v820.val[0], 3uLL);
        int8x16_t v722 = (int8x16_t)vaddq_s16(v820.val[3], (int16x8_t)vbslq_s8(v703, (int8x16_t)vnegq_s16(v721), (int8x16_t)v721));
        int8x16_t v723 = (int8x16_t)vcgtq_u16((uint16x8_t)v720, v698);
        int8x16_t v724 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v820.val[1], 3uLL)), 4uLL);
        int16x8_t v725 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8((int8x16_t)v820.val[2], v697), (int16x8_t)vbicq_s8(v692, (int8x16_t)v820.val[0])), vorrq_s8(v723, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v820.val[0], v694))));
        int16x8_t v726 = vaddq_s16((int16x8_t)vbslq_s8(v723, (int8x16_t)vaddq_s16(v720, v693), (int8x16_t)v720), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v820.val[0]), (int8x16_t)vcgtq_s16(v820.val[1], v693)), v696));
        int16x8_t v727 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v723, (int8x16_t)vshrq_n_u16((uint16x8_t)v724, 1uLL), v724), 1uLL);
        int16x8_t v728 = vqshlq_s16(vqdmulhq_s16(v727, vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v725, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v820.val[2], 4uLL))), v689);
        int8x16_t v729 = (int8x16_t)vqdmulhq_s16(v728, v727);
        int8x16_t v730 = (int8x16_t)vqdmulhq_s16(v728, (int16x8_t)vshrq_n_u16(vqshlq_n_u16((uint16x8_t)vabsq_s16(v721), 4uLL), 1uLL));
        int8x16_t v731 = (int8x16_t)vceqzq_s16(v725);
        int8x16_t v809 = (int8x16_t)v726;
        int8x16_t v810 = vornq_s8(vandq_s8((int8x16_t)v725, v719), v719);
        int8x16_t v811 = vbslq_s8(v731, v722, v729);
        int8x16_t v812 = vbslq_s8(v731, (int8x16_t)v820.val[3], v730);
        int16x8_t v817 = (int16x8_t)v722;
        v732 = &v811;
        while (1)
        {
          BOOL v733 = v701 == 0;
          if (!v701) {
            int v701 = v690;
          }
          uint64_t v734 = v704 + 404 * v733;
          unsigned int v735 = v732[-2].u16[0];
          uint64_t v736 = v732[-1].u16[0];
          uint64_t v737 = v732->u16[0];
          uint64_t v738 = v732[1].u16[0];
          ++*(_DWORD *)(v734 + 384);
          uint64_t v739 = v817.u16[v718];
          *(void *)(v734 + 388) += v739;
          uint64_t result = v734 + 396;
          *(void *)(v734 + 396) += v739 * (unint64_t)v739;
          if (v736)
          {
            if (v736 != 0xFFFF)
            {
              v740 = (void *)(v734 + 24 * v735);
              uint64_t result = v740[1] + v737;
              *v740 += v736;
              v740[1] = result;
              v740[2] += v738;
            }
          }
          else
          {
            v741 = (_DWORD *)(v704 + 404 * v733 + 12 * v702);
            ++v741[84];
            v741[85] += v737;
            v741[86] += v738;
          }
          ++v808;
          if (v706 - 1 == v718) {
            break;
          }
          v732 = (int8x16_t *)((char *)v732 + 2);
          --v701;
          ++v718;
          v704 += 404 * v733;
          if (v718 == 8)
          {
            v706 -= 8;
            uint64_t v704 = v734;
            if (v706 + 1 > 1) {
              goto LABEL_945;
            }
            break;
          }
        }
LABEL_971:
        if (v700) {
        if (*(_DWORD *)a3 > 8u)
        }
        int v742 = 1 << *(_DWORD *)a3;
        if ((v742 & 0xFA) != 0)
        {
          uint64_t v743 = *(void *)(a3 + 32);
          if (v743)
          {
            *(void *)(a3 + 32) = v743 - 1;
            uint64_t v744 = *(void *)(a3 + 8);
          }
          else
          {
            uint64_t v744 = 2 * *(void *)(a3 + 8);
          }
          *(void *)(a3 + 40) += 2 * v744;
          int v747 = *(_DWORD *)(a3 + 20) + 2;
        }
        else
        {
          if ((v742 & 0x101) != 0)
          {
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int32x2_t v745 = *(int32x2_t *)(a3 + 20);
            LODWORD(v746) = vadd_s32(v745, (int32x2_t)0x100000001).u32[0];
            HIDWORD(v746) = veor_s8(*(int8x8_t *)&v745, (int8x8_t)0x100000001).i32[1];
            *(void *)(a3 + 20) = v746;
            goto LABEL_981;
          }
          *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
          int v747 = *(_DWORD *)(a3 + 20) + 1;
        }
        *(_DWORD *)(a3 + 20) = v747;
LABEL_981:
        unsigned int v748 = *(_DWORD *)(a3 + 80);
        if (v748 > 8) {
        int v749 = 1 << v748;
        }
        if ((v749 & 0xFA) != 0)
        {
          uint64_t v750 = *(void *)(a3 + 112);
          if (v750)
          {
            *(void *)(a3 + 112) = v750 - 1;
            uint64_t v751 = *(void *)(a3 + 88);
          }
          else
          {
            uint64_t v751 = 2 * *(void *)(a3 + 88);
          }
          *(void *)(a3 + 120) += 2 * v751;
          int v754 = *(_DWORD *)(a3 + 100) + 2;
          goto LABEL_989;
        }
        if ((v749 & 0x101) == 0)
        {
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int v754 = *(_DWORD *)(a3 + 100) + 1;
LABEL_989:
          *(_DWORD *)(a3 + 100) = v754;
          goto LABEL_990;
        }
        *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
        int32x2_t v752 = *(int32x2_t *)(a3 + 100);
        LODWORD(v753) = vadd_s32(v752, (int32x2_t)0x100000001).u32[0];
        HIDWORD(v753) = veor_s8(*(int8x8_t *)&v752, (int8x8_t)0x100000001).i32[1];
        *(void *)(a3 + 100) = v753;
LABEL_990:
        unsigned int v755 = v807;
        if (v699 != 1) {
          unsigned int v755 = 0;
        }
        v69 += 404 * v755;
        if (v699 == 1) {
          int v699 = v798;
        }
        else {
          --v699;
        }
        if (!--v75) {
          return result;
        }
      }
      int v709 = 8;
LABEL_950:
      v700 -= v709;
      int16x8x4_t v820 = vld4q_s16(v705);
      v705 += 32;
      goto LABEL_961;
    }
    if (v70 != 2) {
    int v75 = *(_DWORD *)(a2 + 20);
    }
    int v798 = *(_DWORD *)(a2 + 28);
    int v808 = 0;
LABEL_197:
    if (!v75) {
      return result;
    }
    uint64_t v199 = a3 + 96;
    int16x8_t v200 = vdupq_n_s16(*(char *)(a2 + 308));
    int v201 = 2 * *(_DWORD *)(a2 + 24);
    int v202 = 2 * *(_DWORD *)(a2 + 16);
    int v768 = v202 - 2;
    uint64_t v783 = a3 + 16;
    v203.i64[0] = 0x1000100010001;
    v203.i64[1] = 0x1000100010001;
    v204.i64[0] = -1;
    v204.i64[1] = -1;
    v205.i64[0] = 0x2000200020002;
    v205.i64[1] = 0x2000200020002;
    v206.i64[0] = 0x4000400040004;
    v206.i64[1] = 0x4000400040004;
    uint64_t result = 12;
    v207.i64[0] = 0x7000700070007;
    v207.i64[1] = 0x7000700070007;
    v208.i64[0] = 0xF000F000F000FLL;
    v208.i64[1] = 0xF000F000F000FLL;
    v209.i64[0] = 0x5000500050005;
    v209.i64[1] = 0x5000500050005;
    int v210 = v798;
    uint64_t v759 = a3 + 96;
    int v757 = v202;
    while (1)
    {
      if (v202 < 1) {
        goto LABEL_240;
      }
      int v211 = 0;
      int v212 = *(_DWORD *)(a3 + 16);
      int v214 = v768;
      uint64_t v213 = v783;
      if (!v212) {
        uint64_t v213 = v199;
      }
      uint64_t v215 = *(int *)(v213 + 8);
      int v216 = 2 * v212;
      uint64_t v217 = v69 - 404;
      __int16 v218 = *(__int16 **)(a3 + 40);
      int v219 = v202;
LABEL_203:
      uint64_t v220 = *(__int16 **)(a3 + 120);
      int v221 = *(_DWORD *)(a3 + 96);
      int v222 = v216 ? v216 : 2 * v221;
      unsigned int v223 = v216 ? v218 : *(__int16 **)(a3 + 120);
      if (v222 >= 16) {
        break;
      }
      int v224 = v219;
      if (v222 == v219) {
        goto LABEL_212;
      }
      if (v222 <= 0) {
      uint64_t v232 = v222 >> 1;
      }
      if (v222 != 1)
      {
        if (v232 <= 1) {
          uint64_t v233 = 1;
        }
        else {
          uint64_t v233 = v232;
        }
        v234 = v223 + 4;
        float v235 = &v814;
        float v236 = &v813;
        float v237 = &v815;
        float v238 = &v816;
        float v239 = &v817;
        float v240 = &v809;
        do
        {
          v240->i16[0] = *v234;
          float v240 = (int8x16_t *)((char *)v240 + 2);
          v239->i16[0] = v234[1];
          float v239 = (int16x8_t *)((char *)v239 + 2);
          v238->i16[0] = v234[2];
          float v238 = (int16x8_t *)((char *)v238 + 2);
          v237->i16[0] = v234[3];
          float v237 = (int16x8_t *)((char *)v237 + 2);
          __int16 v241 = *(v234 - 1);
          v236->i16[0] = v241;
          float v236 = (int16x8_t *)((char *)v236 + 2);
          v235->i16[0] = v241 - (*(v234 - 4) >> 3);
          float v235 = (int8x16_t *)((char *)v235 + 2);
          v234 += 8;
          --v233;
        }
        while (v233);
      }
      LODWORD(v242) = v219 >> 1;
      if (v219 <= 15) {
        uint64_t v242 = v242;
      }
      else {
        uint64_t v242 = 8;
      }
      if (v232 >= v242)
      {
        uint64_t v199 = v759;
        int v202 = v757;
      }
      else
      {
        uint64_t v243 = v232;
        uint64_t v199 = v759;
        int v202 = v757;
        do
        {
          v809.i16[v243] = v220[4];
          v817.i16[v243] = v220[5];
          v816.i16[v243] = v220[6];
          v815.i16[v243] = v220[7];
          __int16 v244 = v220[3];
          v813.i16[v243] = v244;
          v814.i16[v243] = v244 - (*v220 >> 3);
          v220 += 8;
          ++v243;
        }
        while (v242 != v243);
      }
      int16x8_t v226 = (int16x8_t)v809;
      int16x8_t v227 = v817;
      int8x16_t v230 = (int8x16_t)v815;
      int8x16_t v228 = (int8x16_t)v816;
      int16x8_t v229 = v813;
      int8x16_t v231 = v814;
      int v216 = 2 * (v221 - v242 + v232);
      __int16 v218 = v220;
LABEL_229:
      uint64_t v245 = 0;
      int8x16_t v246 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v226, v206));
      int16x8_t v247 = (int16x8_t)vandq_s8((int8x16_t)v227, v207);
      int8x16_t v248 = (int8x16_t)vcgtq_u16((uint16x8_t)v247, v209);
      int8x16_t v249 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v227, 3uLL)), 4uLL);
      uint16x8_t v250 = vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v226, 3uLL)), 4uLL);
      int16x8_t v251 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8(v228, v208), (int16x8_t)vbicq_s8(v203, (int8x16_t)v226)), vorrq_s8(v248, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v226, v205))));
      int8x16_t v252 = (int8x16_t)vaddq_s16((int16x8_t)vbslq_s8(v248, (int8x16_t)vaddq_s16(v247, v204), (int8x16_t)v247), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v226), (int8x16_t)vcgtq_s16(v227, v204)), v207));
      int16x8_t v253 = vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v251, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v228, 4uLL));
      int16x8_t v254 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v248, (int8x16_t)vshrq_n_u16((uint16x8_t)v249, 1uLL), v249), 1uLL);
      int16x8_t v255 = vqshlq_s16(vqdmulhq_s16(v254, v253), v200);
      int8x16_t v256 = (int8x16_t)vceqzq_s16(v251);
      int16x8_t v817 = (int16x8_t)v231;
      int8x16_t v809 = vornq_s8(vandq_s8((int8x16_t)v251, v246), v246);
      int8x16_t v810 = vbslq_s8(v256, v231, (int8x16_t)vqdmulhq_s16(v255, v254));
      int8x16_t v811 = vbslq_s8(v256, (int8x16_t)v229, (int8x16_t)vqdmulhq_s16(v255, (int16x8_t)vshrq_n_u16(v250, 1uLL)));
      int8x16_t v812 = vbslq_s8(v256, v230, v252);
      while (1)
      {
        BOOL v257 = v211 == 0;
        if (!v211) {
          int v211 = v201;
        }
        uint64_t v258 = v217 + 404 * v257;
        uint64_t v259 = v809.u16[v245];
        ++*(_DWORD *)(v258 + 384);
        uint64_t v260 = v817.u16[v245];
        *(void *)(v258 + 388) += v260;
        *(void *)(v258 + 396) += v260 * (unint64_t)v260;
        if (v259)
        {
          if (v259 != 0xFFFF)
          {
            uint64_t v261 = v811.u16[v245];
            uint64_t v262 = (void *)(v258 + 24 * v812.u16[v245]);
            uint64_t v263 = v262[1] + *(unsigned __int16 *)((char *)&v809 + v245 * 2 + 16);
            *v262 += v259;
            v262[1] = v263;
            v262[2] += v261;
          }
        }
        else
        {
          int v264 = *(unsigned __int16 *)((char *)&v809 + v245 * 2 + 16);
          int v265 = v811.u16[v245];
          int v266 = v812.u16[v245];
          uint64_t v267 = v217 + 404 * v257 + 336;
          v268 = (_DWORD *)(v267 + 12 * (int)v215);
          int v269 = v268[1] + v264;
          ++*v268;
          v268[1] = v269;
          v268[2] += v265;
          int v270 = (_DWORD *)(v267 + 12 * (v215 + 1));
          int v271 = v270[1];
          ++*v270;
          v270[1] = v271 + v264;
          v270[2] += v266;
        }
        ++v808;
        if (v214 == (v245 * 2)) {
          break;
        }
        v211 -= 2;
        ++v245;
        uint64_t v217 = v258;
        if (v245 == 8)
        {
          v214 -= 16;
          uint64_t v217 = v258;
          BOOL v272 = v219 <= 16;
          v219 -= 16;
          if (v272) {
            break;
          }
          goto LABEL_203;
        }
      }
LABEL_240:
      if (*(_DWORD *)a3 > 8u) {
      int v273 = 1 << *(_DWORD *)a3;
      }
      if ((v273 & 0xFA) != 0)
      {
        uint64_t v274 = *(void *)(a3 + 32);
        if (v274)
        {
          *(void *)(a3 + 32) = v274 - 1;
          uint64_t v275 = *(void *)(a3 + 8);
        }
        else
        {
          uint64_t v275 = 2 * *(void *)(a3 + 8);
        }
        *(void *)(a3 + 40) += 2 * v275;
        int v278 = *(_DWORD *)(a3 + 20) + 2;
      }
      else
      {
        if ((v273 & 0x101) != 0)
        {
          *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
          int32x2_t v276 = *(int32x2_t *)(a3 + 20);
          LODWORD(v277) = vadd_s32(v276, (int32x2_t)0x100000001).u32[0];
          HIDWORD(v277) = veor_s8(*(int8x8_t *)&v276, (int8x8_t)0x100000001).i32[1];
          *(void *)(a3 + 20) = v277;
          goto LABEL_249;
        }
        *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
        int v278 = *(_DWORD *)(a3 + 20) + 1;
      }
      *(_DWORD *)(a3 + 20) = v278;
LABEL_249:
      unsigned int v279 = *(_DWORD *)(a3 + 80);
      if (v279 > 8) {
      int v280 = 1 << v279;
      }
      if ((v280 & 0xFA) != 0)
      {
        uint64_t v281 = *(void *)(a3 + 112);
        if (v281)
        {
          *(void *)(a3 + 112) = v281 - 1;
          uint64_t v282 = *(void *)(a3 + 88);
        }
        else
        {
          uint64_t v282 = 2 * *(void *)(a3 + 88);
        }
        *(void *)(a3 + 120) += 2 * v282;
        int v285 = *(_DWORD *)(a3 + 100) + 2;
        goto LABEL_257;
      }
      if ((v280 & 0x101) == 0)
      {
        *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
        int v285 = *(_DWORD *)(a3 + 100) + 1;
LABEL_257:
        *(_DWORD *)(a3 + 100) = v285;
        goto LABEL_258;
      }
      *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
      int32x2_t v283 = *(int32x2_t *)(a3 + 100);
      LODWORD(v284) = vadd_s32(v283, (int32x2_t)0x100000001).u32[0];
      HIDWORD(v284) = veor_s8(*(int8x8_t *)&v283, (int8x8_t)0x100000001).i32[1];
      *(void *)(a3 + 100) = v284;
LABEL_258:
      unsigned int v286 = v807;
      if (v210 != 1) {
        unsigned int v286 = 0;
      }
      v69 += 404 * v286;
      if (v210 == 1) {
        int v210 = v798;
      }
      else {
        --v210;
      }
      if (!--v75) {
        return result;
      }
    }
    int v224 = 16;
LABEL_212:
    uint64_t v225 = v223;
    int16x8x4_t v821 = vld4q_s16(v225);
    v225 += 32;
    int16x8x4_t v822 = vld4q_s16(v225);
    int16x8_t v226 = vuzp2q_s16(v821.val[0], v822.val[0]);
    int16x8_t v227 = vuzp2q_s16(v821.val[1], v822.val[1]);
    int8x16_t v228 = (int8x16_t)vuzp2q_s16(v821.val[2], v822.val[2]);
    int16x8_t v229 = vuzp1q_s16(v821.val[3], v822.val[3]);
    int8x16_t v230 = (int8x16_t)vuzp2q_s16(v821.val[3], v822.val[3]);
    int8x16_t v231 = (int8x16_t)vsraq_n_s16(v229, vuzp1q_s16(v821.val[0], v822.val[0]), 3uLL);
    __int16 v218 = v223 + 64;
    int v216 = v222 - v224;
    goto LABEL_229;
  }
  if (result) {
  uint64_t v11 = a2 + 6956;
  }
  unsigned int v12 = *(_DWORD *)(a2 + 12);
  if (v12 - 3 < 6 || v12 < 2)
  {
    int v14 = *(_DWORD *)(a2 + 20);
    int v15 = *(_DWORD *)(a2 + 28);
    v809.i32[0] = 0;
    uint64_t v16 = a2 + 304;
    int v17 = 2 * v14;
    uint64_t v18 = (2 * v15);
    int v19 = 2 * v15;
    switch(v12)
    {
      case 0u:
        if (!v17) {
          return result;
        }
        int v20 = *(_DWORD *)(a2 + 24);
        int v21 = *(_DWORD *)(a3 + 16);
        int v797 = *(_DWORD *)(a2 + 16);
        int8x8_t v22 = (int8x8_t)vdup_n_s32(0x7FF8u);
        int v23 = v18;
        while (1)
        {
          int v24 = v21;
          if (v797 >= 1)
          {
            int v25 = 0;
            uint64_t v26 = v11 - 404;
            int v27 = *(_DWORD *)(a3 + 24);
            unsigned int v28 = *(unsigned __int16 **)(a3 + 40);
            int v29 = v797 + 1;
            int v24 = v21;
            char v30 = *(unsigned char *)(a2 + 308);
            do
            {
              BOOL v31 = v24 == 0;
              if (v24)
              {
                int v32 = v27;
              }
              else
              {
                int v24 = *(_DWORD *)(a3 + 96);
                int v32 = *(_DWORD *)(a3 + 104);
              }
              if (v31) {
                unsigned int v28 = *(unsigned __int16 **)(a3 + 120);
              }
              BOOL v33 = v25 == 0;
              if (!v25) {
                int v25 = v20;
              }
              uint64_t v34 = v26 + 404 * v33;
              unsigned int v35 = *v28;
              int v36 = (__int16)v35 >> 3;
              int v37 = v28[3];
              if (v32) {
                int v38 = -v36;
              }
              else {
                LOWORD(v38) = (__int16)v35 >> 3;
              }
              unsigned __int16 v39 = v38 + v37;
              ++*(_DWORD *)(v34 + 384);
              *(void *)(v34 + 388) += (unsigned __int16)(v38 + v37);
              *(void *)(v34 + 396) += (unsigned __int16)(v38 + v37) * (unint64_t)(unsigned __int16)(v38 + v37);
              if ((v35 & 4) == 0)
              {
                int v40 = (__int16)v28[1];
                unsigned int v41 = v40 & 7;
                if ((v35 & 1) != 0 || (((v40 & 7u) < 6) & (v35 >> 1)) != 0)
                {
                  unint64_t v54 = (_DWORD *)(v26 + 404 * v33 + 12 * v32);
                  ++v54[84];
                  v54[85] += v39;
                  v54[86] += v37;
                }
                else
                {
                  __int16 v42 = v41 > 5;
                  unsigned int v43 = v28[2];
                  uint64_t v44 = (v43 & 0xF) + 1;
                  unsigned int v45 = v43 >> 4;
                  int v46 = v40 >> 3;
                  if (v40 < 0) {
                    int v46 = -v46;
                  }
                  if (v36 < 0) {
                    int v36 = -v36;
                  }
                  unsigned __int16 v47 = v41 - v42;
                  unsigned int v48 = (16 * (v46 & 0xFFFu)) >> v42;
                  unsigned int v49 = (v44 >> 1) * v45;
                  if (((v40 ^ v35) & 0x8000u) == 0) {
                    unsigned __int16 v50 = v47 + 7;
                  }
                  else {
                    unsigned __int16 v50 = v47;
                  }
                  uint64_t v51 = v34 + 24 * v50;
                  a6.n128_u32[0] = v48;
                  v52.i32[0] = vshr_n_u32((uint32x2_t)a6.n128_u64[0], 1uLL).u32[0];
                  a6.n128_u32[1] = 8 * v36;
                  v52.i32[1] = vand_s8(*(int8x8_t *)&a6, v22).i32[1];
                  signed int v53 = (v52.i32[0] * v49) >> 15 << v30;
                  if (v53 <= -32768) {
                    signed int v53 = -32768;
                  }
                  if (v53 >= 0x7FFF) {
                    signed int v53 = 0x7FFF;
                  }
                  *(void *)v51 += v44;
                  a6 = (__n128)vaddw_u32(*(uint64x2_t *)(v51 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v53), v52), 0xFuLL));
                  *(__n128 *)(v51 + 8) = a6;
                }
              }
              v28 += 4;
              --v24;
              --v25;
              ++v809.i32[0];
              int v27 = v32 ^ 1;
              --v29;
              uint64_t v26 = v34;
            }
            while (v29 > 1);
          }
          if (v24) {
          if (*(_DWORD *)a3 > 8u)
          }
          int v55 = 1 << *(_DWORD *)a3;
          if ((v55 & 0xFA) != 0)
          {
            uint64_t v56 = *(void *)(a3 + 32);
            int v57 = v19;
            if (v56)
            {
              *(void *)(a3 + 32) = v56 - 1;
              uint64_t v58 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v58 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v58;
            int v61 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            int v57 = v19;
            if ((v55 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v59 = *(int32x2_t *)(a3 + 20);
              LODWORD(v60) = vadd_s32(v59, (int32x2_t)0x100000001).u32[0];
              a6.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v59, (int8x8_t)0x100000001);
              HIDWORD(v60) = a6.n128_u32[1];
              *(void *)(a3 + 20) = v60;
              goto LABEL_49;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v61 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v61;
LABEL_49:
          unsigned int v62 = *(_DWORD *)(a3 + 80);
          if (v62 > 8) {
          int v63 = 1 << v62;
          }
          if ((v63 & 0xFA) != 0)
          {
            uint64_t v64 = *(void *)(a3 + 112);
            if (v64)
            {
              *(void *)(a3 + 112) = v64 - 1;
              uint64_t v65 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v65 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v65;
            int v68 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_57;
          }
          if ((v63 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v68 = *(_DWORD *)(a3 + 100) + 1;
LABEL_57:
            *(_DWORD *)(a3 + 100) = v68;
            goto LABEL_58;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v66 = *(int32x2_t *)(a3 + 100);
          LODWORD(v67) = vadd_s32(v66, (int32x2_t)0x100000001).u32[0];
          a6.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v66, (int8x8_t)0x100000001);
          HIDWORD(v67) = a6.n128_u32[1];
          *(void *)(a3 + 100) = v67;
LABEL_58:
          uint64_t result = v807;
          if (v23 != 1) {
            uint64_t result = 0;
          }
          v11 += 404 * result;
          if (v23 == 1) {
            int v23 = v57;
          }
          else {
            --v23;
          }
          if (!--v17) {
            return result;
          }
        }
      case 1u:
        if (!v17) {
          return result;
        }
        v784 = (int *)(a3 + 48);
        v800 = (int *)(a3 + 96);
        int v287 = 2 * v15;
        int v288 = -2 * v14;
        while (1)
        {
          if (*(_DWORD *)a3 > 8u) {
          int v291 = 1 << *(_DWORD *)a3;
          }
          if ((v291 & 0xFA) != 0)
          {
            uint64_t v292 = *(void *)(a3 + 32);
            if (v292)
            {
              *(void *)(a3 + 32) = v292 - 1;
              uint64_t v293 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v293 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v293;
            int v295 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v291 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v294 = *(int32x2_t *)(a3 + 20);
              v290.n128_u32[0] = vadd_s32(v294, (int32x2_t)0x100000001).u32[0];
              int8x8_t v289 = veor_s8((int8x8_t)v294, (int8x8_t)0x100000001);
              v290.n128_u32[1] = v289.u32[1];
              *(void *)(a3 + 20) = v290.n128_u64[0];
              goto LABEL_278;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v295 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v295;
LABEL_278:
          unsigned int v296 = *(_DWORD *)(a3 + 80);
          if (v296 > 8) {
          int v297 = 1 << v296;
          }
          if ((v297 & 0xFA) != 0)
          {
            uint64_t v298 = *(void *)(a3 + 112);
            if (v298)
            {
              *(void *)(a3 + 112) = v298 - 1;
              uint64_t v299 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v299 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v299;
            int v301 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_286;
          }
          if ((v297 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v301 = *(_DWORD *)(a3 + 100) + 1;
LABEL_286:
            *(_DWORD *)(a3 + 100) = v301;
            goto LABEL_287;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v300 = *(int32x2_t *)(a3 + 100);
          v290.n128_u32[0] = vadd_s32(v300, (int32x2_t)0x100000001).u32[0];
          int8x8_t v289 = veor_s8((int8x8_t)v300, (int8x8_t)0x100000001);
          v290.n128_u32[1] = v289.u32[1];
          *(void *)(a3 + 100) = v290.n128_u64[0];
LABEL_287:
          if (*(_DWORD *)a3 > 8u) {
          int v302 = 1 << *(_DWORD *)a3;
          }
          if ((v302 & 0x9A) != 0)
          {
            uint64_t v303 = *(void *)(a3 + 64);
            if (v303)
            {
              *(void *)(a3 + 64) = v303 - 1;
              uint64_t v304 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v304 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v304;
            int32x2_t v307 = *(int32x2_t *)(a3 + 52);
            a5.i32[0] = vadd_s32(v307, (int32x2_t)0x200000002).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v307, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 52) = a5.i64[0];
          }
          else
          {
            if ((v302 & 0x60) == 0) {
            uint64_t v305 = *(void *)(a3 + 64);
            }
            if (v305)
            {
              *(void *)(a3 + 64) = v305 - 1;
              uint64_t v306 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v306 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v306;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v308 = *(_DWORD *)(a3 + 80);
          if (v308 > 8) {
          int v309 = 1 << v308;
          }
          if ((v309 & 0x9A) != 0)
          {
            uint64_t v310 = *(void *)(a3 + 144);
            if (v310)
            {
              *(void *)(a3 + 144) = v310 - 1;
              uint64_t v311 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v311 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v311;
            int32x2_t v314 = *(int32x2_t *)(a3 + 132);
            a5.i32[0] = vadd_s32(v314, (int32x2_t)0x200000002).u32[0];
            *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v314, (int8x8_t)0x100000001);
            a5.i32[1] = a4.i32[1];
            *(void *)(a3 + 132) = a5.i64[0];
          }
          else
          {
            if ((v309 & 0x60) == 0) {
            uint64_t v312 = *(void *)(a3 + 144);
            }
            if (v312)
            {
              *(void *)(a3 + 144) = v312 - 1;
              uint64_t v313 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v313 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v313;
            *(_DWORD *)(a3 + 132) += 2;
          }
          unsigned int v315 = v807;
          if (v287 != 2) {
            unsigned int v315 = 0;
          }
          v11 += 404 * v315;
          if (v287 == 2) {
            int v287 = v18;
          }
          else {
            v287 -= 2;
          }
          v288 += 2;
          if (!v288) {
            return result;
          }
        }
      case 2u:
        goto LABEL_135;
      case 3u:
        if (!v17) {
          return result;
        }
        v785 = (int *)(a3 + 16);
        v801 = (int *)(a3 + 128);
        v769 = (int *)(a3 + 96);
        int v316 = 2 * v15;
        int v317 = -2 * v14;
        while (1)
        {
          if (*(_DWORD *)a3 > 8u) {
          int v320 = 1 << *(_DWORD *)a3;
          }
          if ((v320 & 0x9A) != 0)
          {
            uint64_t v321 = *(void *)(a3 + 64);
            if (v321)
            {
              *(void *)(a3 + 64) = v321 - 1;
              uint64_t v322 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v322 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v322;
            int32x2_t v325 = *(int32x2_t *)(a3 + 52);
            v319.n128_u32[0] = vadd_s32(v325, (int32x2_t)0x200000002).u32[0];
            int8x8_t v318 = veor_s8((int8x8_t)v325, (int8x8_t)0x100000001);
            v319.n128_u32[1] = v318.u32[1];
            *(void *)(a3 + 52) = v319.n128_u64[0];
          }
          else
          {
            if ((v320 & 0x60) == 0) {
            uint64_t v323 = *(void *)(a3 + 64);
            }
            if (v323)
            {
              *(void *)(a3 + 64) = v323 - 1;
              uint64_t v324 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v324 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v324;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v326 = *(_DWORD *)(a3 + 80);
          if (v326 > 8) {
          int v327 = 1 << v326;
          }
          if ((v327 & 0x9A) != 0)
          {
            uint64_t v328 = *(void *)(a3 + 144);
            if (v328)
            {
              *(void *)(a3 + 144) = v328 - 1;
              uint64_t v329 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v329 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v329;
            int32x2_t v332 = *(int32x2_t *)(a3 + 132);
            v319.n128_u32[0] = vadd_s32(v332, (int32x2_t)0x200000002).u32[0];
            int8x8_t v318 = veor_s8((int8x8_t)v332, (int8x8_t)0x100000001);
            v319.n128_u32[1] = v318.u32[1];
            *(void *)(a3 + 132) = v319.n128_u64[0];
          }
          else
          {
            if ((v327 & 0x60) == 0) {
            uint64_t v330 = *(void *)(a3 + 144);
            }
            if (v330)
            {
              *(void *)(a3 + 144) = v330 - 1;
              uint64_t v331 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v331 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v331;
            *(_DWORD *)(a3 + 132) += 2;
          }
          if (*(_DWORD *)a3 > 8u) {
          int v333 = 1 << *(_DWORD *)a3;
          }
          if ((v333 & 0xFA) != 0)
          {
            uint64_t v334 = *(void *)(a3 + 32);
            if (v334)
            {
              *(void *)(a3 + 32) = v334 - 1;
              uint64_t v335 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v335 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v335;
            int v337 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v333 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v336 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v336, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v336, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_351;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v337 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v337;
LABEL_351:
          unsigned int v338 = *(_DWORD *)(a3 + 80);
          if (v338 > 8) {
          int v339 = 1 << v338;
          }
          if ((v339 & 0xFA) != 0)
          {
            uint64_t v340 = *(void *)(a3 + 112);
            if (v340)
            {
              *(void *)(a3 + 112) = v340 - 1;
              uint64_t v341 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v341 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v341;
            int v343 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_359;
          }
          if ((v339 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v343 = *(_DWORD *)(a3 + 100) + 1;
LABEL_359:
            *(_DWORD *)(a3 + 100) = v343;
            goto LABEL_360;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v342 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v342, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v342, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_360:
          unsigned int v344 = v807;
          if (v316 != 2) {
            unsigned int v344 = 0;
          }
          v11 += 404 * v344;
          if (v316 == 2) {
            int v316 = v18;
          }
          else {
            v316 -= 2;
          }
          v317 += 2;
          if (!v317) {
            return result;
          }
        }
      case 4u:
        if (!v17) {
          return result;
        }
        v786 = (int *)(a3 + 128);
        v802 = (int *)(a3 + 48);
        v770 = (int *)(a3 + 16);
        int v345 = 2 * v15;
        int v346 = -2 * v14;
        while (1)
        {
          if (*(_DWORD *)a3 > 8u) {
          int v349 = 1 << *(_DWORD *)a3;
          }
          if ((v349 & 0x9A) != 0)
          {
            uint64_t v350 = *(void *)(a3 + 64);
            if (v350)
            {
              *(void *)(a3 + 64) = v350 - 1;
              uint64_t v351 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v351 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v351;
            int32x2_t v354 = *(int32x2_t *)(a3 + 52);
            v348.n128_u32[0] = vadd_s32(v354, (int32x2_t)0x200000002).u32[0];
            int8x8_t v347 = veor_s8((int8x8_t)v354, (int8x8_t)0x100000001);
            v348.n128_u32[1] = v347.u32[1];
            *(void *)(a3 + 52) = v348.n128_u64[0];
          }
          else
          {
            if ((v349 & 0x60) == 0) {
            uint64_t v352 = *(void *)(a3 + 64);
            }
            if (v352)
            {
              *(void *)(a3 + 64) = v352 - 1;
              uint64_t v353 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v353 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v353;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v355 = *(_DWORD *)(a3 + 80);
          if (v355 > 8) {
          int v356 = 1 << v355;
          }
          if ((v356 & 0x9A) != 0)
          {
            uint64_t v357 = *(void *)(a3 + 144);
            if (v357)
            {
              *(void *)(a3 + 144) = v357 - 1;
              uint64_t v358 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v358 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v358;
            int32x2_t v361 = *(int32x2_t *)(a3 + 132);
            v348.n128_u32[0] = vadd_s32(v361, (int32x2_t)0x200000002).u32[0];
            int8x8_t v347 = veor_s8((int8x8_t)v361, (int8x8_t)0x100000001);
            v348.n128_u32[1] = v347.u32[1];
            *(void *)(a3 + 132) = v348.n128_u64[0];
          }
          else
          {
            if ((v356 & 0x60) == 0) {
            uint64_t v359 = *(void *)(a3 + 144);
            }
            if (v359)
            {
              *(void *)(a3 + 144) = v359 - 1;
              uint64_t v360 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v360 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v360;
            *(_DWORD *)(a3 + 132) += 2;
          }
          if (*(_DWORD *)a3 > 8u) {
          int v362 = 1 << *(_DWORD *)a3;
          }
          if ((v362 & 0xFA) != 0)
          {
            uint64_t v363 = *(void *)(a3 + 32);
            if (v363)
            {
              *(void *)(a3 + 32) = v363 - 1;
              uint64_t v364 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v364 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v364;
            int v366 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v362 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v365 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v365, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v365, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_402;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v366 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v366;
LABEL_402:
          unsigned int v367 = *(_DWORD *)(a3 + 80);
          if (v367 > 8) {
          int v368 = 1 << v367;
          }
          if ((v368 & 0xFA) != 0)
          {
            uint64_t v369 = *(void *)(a3 + 112);
            if (v369)
            {
              *(void *)(a3 + 112) = v369 - 1;
              uint64_t v370 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v370 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v370;
            int v372 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_410;
          }
          if ((v368 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v372 = *(_DWORD *)(a3 + 100) + 1;
LABEL_410:
            *(_DWORD *)(a3 + 100) = v372;
            goto LABEL_411;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v371 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v371, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v371, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_411:
          unsigned int v373 = v807;
          if (v345 != 2) {
            unsigned int v373 = 0;
          }
          v11 += 404 * v373;
          if (v345 == 2) {
            int v345 = v18;
          }
          else {
            v345 -= 2;
          }
          v346 += 2;
          if (!v346) {
            return result;
          }
        }
      case 5u:
        if (!v17) {
          return result;
        }
        uint64_t v787 = a3 + 128;
        uint64_t v803 = a3 + 48;
        uint64_t v771 = a3 + 16;
        int v374 = 2 * v15;
        int v375 = -2 * v14;
        while (1)
        {
          if (*(_DWORD *)a3 > 8u) {
          int v379 = 1 << *(_DWORD *)a3;
          }
          if ((v379 & 0x9A) != 0)
          {
            uint64_t v380 = *(void *)(a3 + 64);
            if (v380)
            {
              *(void *)(a3 + 64) = v380 - 1;
              uint64_t v381 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v381 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v381;
            int32x2_t v384 = *(int32x2_t *)(a3 + 52);
            LODWORD(v377) = vadd_s32(v384, (int32x2_t)0x200000002).u32[0];
            int8x8_t v376 = veor_s8((int8x8_t)v384, (int8x8_t)0x100000001);
            HIDWORD(v377) = v376.i32[1];
            *(double *)(a3 + 52) = v377;
          }
          else
          {
            if ((v379 & 0x60) == 0) {
            uint64_t v382 = *(void *)(a3 + 64);
            }
            if (v382)
            {
              *(void *)(a3 + 64) = v382 - 1;
              uint64_t v383 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v383 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v383;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v385 = *(_DWORD *)(a3 + 80);
          if (v385 > 8) {
          int v386 = 1 << v385;
          }
          if ((v386 & 0x9A) != 0)
          {
            uint64_t v387 = *(void *)(a3 + 144);
            if (v387)
            {
              *(void *)(a3 + 144) = v387 - 1;
              uint64_t v388 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v388 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v388;
            int32x2_t v391 = *(int32x2_t *)(a3 + 132);
            LODWORD(v377) = vadd_s32(v391, (int32x2_t)0x200000002).u32[0];
            int8x8_t v376 = veor_s8((int8x8_t)v391, (int8x8_t)0x100000001);
            HIDWORD(v377) = v376.i32[1];
            *(double *)(a3 + 132) = v377;
          }
          else
          {
            if ((v386 & 0x60) == 0) {
            uint64_t v389 = *(void *)(a3 + 144);
            }
            if (v389)
            {
              *(void *)(a3 + 144) = v389 - 1;
              uint64_t v390 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v390 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v390;
            *(_DWORD *)(a3 + 132) += 2;
          }
          if (*(_DWORD *)a3 > 8u) {
          int v392 = 1 << *(_DWORD *)a3;
          }
          if ((v392 & 0xFA) != 0)
          {
            uint64_t v393 = *(void *)(a3 + 32);
            if (v393)
            {
              *(void *)(a3 + 32) = v393 - 1;
              uint64_t v394 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v394 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v394;
            int v396 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v392 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v395 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v395, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v395, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_453;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v396 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v396;
LABEL_453:
          unsigned int v397 = *(_DWORD *)(a3 + 80);
          if (v397 > 8) {
          int v398 = 1 << v397;
          }
          if ((v398 & 0xFA) != 0)
          {
            uint64_t v399 = *(void *)(a3 + 112);
            if (v399)
            {
              *(void *)(a3 + 112) = v399 - 1;
              uint64_t v400 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v400 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v400;
            int v402 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_461;
          }
          if ((v398 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v402 = *(_DWORD *)(a3 + 100) + 1;
LABEL_461:
            *(_DWORD *)(a3 + 100) = v402;
            goto LABEL_462;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v401 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v401, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v401, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_462:
          unsigned int v403 = v807;
          if (v374 != 2) {
            unsigned int v403 = 0;
          }
          v11 += 404 * v403;
          if (v374 == 2) {
            int v374 = v18;
          }
          else {
            v374 -= 2;
          }
          v375 += 2;
          if (!v375) {
            return result;
          }
        }
      case 6u:
        if (!v17) {
          return result;
        }
        uint64_t v788 = a3 + 128;
        uint64_t v804 = a3 + 48;
        uint64_t v772 = a3 + 16;
        int v404 = 2 * v15;
        int v405 = -2 * v14;
        while (1)
        {
          if (*(_DWORD *)a3 > 8u) {
          int v409 = 1 << *(_DWORD *)a3;
          }
          if ((v409 & 0x9A) != 0)
          {
            uint64_t v410 = *(void *)(a3 + 64);
            if (v410)
            {
              *(void *)(a3 + 64) = v410 - 1;
              uint64_t v411 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v411 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v411;
            int32x2_t v414 = *(int32x2_t *)(a3 + 52);
            LODWORD(v407) = vadd_s32(v414, (int32x2_t)0x200000002).u32[0];
            int8x8_t v406 = veor_s8((int8x8_t)v414, (int8x8_t)0x100000001);
            HIDWORD(v407) = v406.i32[1];
            *(double *)(a3 + 52) = v407;
          }
          else
          {
            if ((v409 & 0x60) == 0) {
            uint64_t v412 = *(void *)(a3 + 64);
            }
            if (v412)
            {
              *(void *)(a3 + 64) = v412 - 1;
              uint64_t v413 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v413 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v413;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v415 = *(_DWORD *)(a3 + 80);
          if (v415 > 8) {
          int v416 = 1 << v415;
          }
          if ((v416 & 0x9A) != 0)
          {
            uint64_t v417 = *(void *)(a3 + 144);
            if (v417)
            {
              *(void *)(a3 + 144) = v417 - 1;
              uint64_t v418 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v418 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v418;
            int32x2_t v421 = *(int32x2_t *)(a3 + 132);
            LODWORD(v407) = vadd_s32(v421, (int32x2_t)0x200000002).u32[0];
            int8x8_t v406 = veor_s8((int8x8_t)v421, (int8x8_t)0x100000001);
            HIDWORD(v407) = v406.i32[1];
            *(double *)(a3 + 132) = v407;
          }
          else
          {
            if ((v416 & 0x60) == 0) {
            uint64_t v419 = *(void *)(a3 + 144);
            }
            if (v419)
            {
              *(void *)(a3 + 144) = v419 - 1;
              uint64_t v420 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v420 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v420;
            *(_DWORD *)(a3 + 132) += 2;
          }
          if (*(_DWORD *)a3 > 8u) {
          int v422 = 1 << *(_DWORD *)a3;
          }
          if ((v422 & 0xFA) != 0)
          {
            uint64_t v423 = *(void *)(a3 + 32);
            if (v423)
            {
              *(void *)(a3 + 32) = v423 - 1;
              uint64_t v424 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v424 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v424;
            int v426 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v422 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v425 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v425, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v425, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_504;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v426 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v426;
LABEL_504:
          unsigned int v427 = *(_DWORD *)(a3 + 80);
          if (v427 > 8) {
          int v428 = 1 << v427;
          }
          if ((v428 & 0xFA) != 0)
          {
            uint64_t v429 = *(void *)(a3 + 112);
            if (v429)
            {
              *(void *)(a3 + 112) = v429 - 1;
              uint64_t v430 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v430 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v430;
            int v432 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_512;
          }
          if ((v428 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v432 = *(_DWORD *)(a3 + 100) + 1;
LABEL_512:
            *(_DWORD *)(a3 + 100) = v432;
            goto LABEL_513;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v431 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v431, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v431, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_513:
          unsigned int v433 = v807;
          if (v404 != 2) {
            unsigned int v433 = 0;
          }
          v11 += 404 * v433;
          if (v404 == 2) {
            int v404 = v18;
          }
          else {
            v404 -= 2;
          }
          v405 += 2;
          if (!v405) {
            return result;
          }
        }
      case 7u:
        if (!v17) {
          return result;
        }
        v789 = (int *)(a3 + 128);
        v805 = (int *)(a3 + 48);
        v773 = (int *)(a3 + 16);
        int v434 = 2 * v15;
        int v435 = -2 * v14;
        while (1)
        {
          if (*(_DWORD *)a3 > 8u) {
          int v438 = 1 << *(_DWORD *)a3;
          }
          if ((v438 & 0x9A) != 0)
          {
            uint64_t v439 = *(void *)(a3 + 64);
            if (v439)
            {
              *(void *)(a3 + 64) = v439 - 1;
              uint64_t v440 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v440 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v440;
            int32x2_t v443 = *(int32x2_t *)(a3 + 52);
            v437.n128_u32[0] = vadd_s32(v443, (int32x2_t)0x200000002).u32[0];
            int8x8_t v436 = veor_s8((int8x8_t)v443, (int8x8_t)0x100000001);
            v437.n128_u32[1] = v436.u32[1];
            *(void *)(a3 + 52) = v437.n128_u64[0];
          }
          else
          {
            if ((v438 & 0x60) == 0) {
            uint64_t v441 = *(void *)(a3 + 64);
            }
            if (v441)
            {
              *(void *)(a3 + 64) = v441 - 1;
              uint64_t v442 = 2 * *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v442 = *(void *)(a3 + 8);
            }
            *(void *)(a3 + 72) += 2 * v442;
            *(_DWORD *)(a3 + 52) += 2;
          }
          unsigned int v444 = *(_DWORD *)(a3 + 80);
          if (v444 > 8) {
          int v445 = 1 << v444;
          }
          if ((v445 & 0x9A) != 0)
          {
            uint64_t v446 = *(void *)(a3 + 144);
            if (v446)
            {
              *(void *)(a3 + 144) = v446 - 1;
              uint64_t v447 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v447 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v447;
            int32x2_t v450 = *(int32x2_t *)(a3 + 132);
            v437.n128_u32[0] = vadd_s32(v450, (int32x2_t)0x200000002).u32[0];
            int8x8_t v436 = veor_s8((int8x8_t)v450, (int8x8_t)0x100000001);
            v437.n128_u32[1] = v436.u32[1];
            *(void *)(a3 + 132) = v437.n128_u64[0];
          }
          else
          {
            if ((v445 & 0x60) == 0) {
            uint64_t v448 = *(void *)(a3 + 144);
            }
            if (v448)
            {
              *(void *)(a3 + 144) = v448 - 1;
              uint64_t v449 = 2 * *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v449 = *(void *)(a3 + 88);
            }
            *(void *)(a3 + 152) += 2 * v449;
            *(_DWORD *)(a3 + 132) += 2;
          }
          if (*(_DWORD *)a3 > 8u) {
          int v451 = 1 << *(_DWORD *)a3;
          }
          if ((v451 & 0xFA) != 0)
          {
            uint64_t v452 = *(void *)(a3 + 32);
            if (v452)
            {
              *(void *)(a3 + 32) = v452 - 1;
              uint64_t v453 = *(void *)(a3 + 8);
            }
            else
            {
              uint64_t v453 = 2 * *(void *)(a3 + 8);
            }
            *(void *)(a3 + 40) += 2 * v453;
            int v455 = *(_DWORD *)(a3 + 20) + 2;
          }
          else
          {
            if ((v451 & 0x101) != 0)
            {
              *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
              int32x2_t v454 = *(int32x2_t *)(a3 + 20);
              a5.i32[0] = vadd_s32(v454, (int32x2_t)0x100000001).u32[0];
              *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v454, (int8x8_t)0x100000001);
              a5.i32[1] = a4.i32[1];
              *(void *)(a3 + 20) = a5.i64[0];
              goto LABEL_555;
            }
            *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
            int v455 = *(_DWORD *)(a3 + 20) + 1;
          }
          *(_DWORD *)(a3 + 20) = v455;
LABEL_555:
          unsigned int v456 = *(_DWORD *)(a3 + 80);
          if (v456 > 8) {
          int v457 = 1 << v456;
          }
          if ((v457 & 0xFA) != 0)
          {
            uint64_t v458 = *(void *)(a3 + 112);
            if (v458)
            {
              *(void *)(a3 + 112) = v458 - 1;
              uint64_t v459 = *(void *)(a3 + 88);
            }
            else
            {
              uint64_t v459 = 2 * *(void *)(a3 + 88);
            }
            *(void *)(a3 + 120) += 2 * v459;
            int v461 = *(_DWORD *)(a3 + 100) + 2;
            goto LABEL_563;
          }
          if ((v457 & 0x101) == 0)
          {
            *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
            int v461 = *(_DWORD *)(a3 + 100) + 1;
LABEL_563:
            *(_DWORD *)(a3 + 100) = v461;
            goto LABEL_564;
          }
          *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
          int32x2_t v460 = *(int32x2_t *)(a3 + 100);
          a5.i32[0] = vadd_s32(v460, (int32x2_t)0x100000001).u32[0];
          *(int8x8_t *)a4.i8 = veor_s8((int8x8_t)v460, (int8x8_t)0x100000001);
          a5.i32[1] = a4.i32[1];
          *(void *)(a3 + 100) = a5.i64[0];
LABEL_564:
          unsigned int v462 = v807;
          if (v434 != 2) {
            unsigned int v462 = 0;
          }
          v11 += 404 * v462;
          if (v434 == 2) {
            int v434 = v18;
          }
          else {
            v434 -= 2;
          }
          v435 += 2;
          if (!v435) {
            return result;
          }
        }
      case 8u:
        if (!v17) {
          return result;
        }
        int v463 = *(_DWORD *)(a2 + 24);
        int v464 = *(_DWORD *)(a3 + 16);
        int v806 = *(_DWORD *)(a2 + 16);
        int8x8_t v465 = (int8x8_t)vdup_n_s32(0x7FF8u);
        int v466 = v18;
        break;
      default:
    }
    while (1)
    {
      int v467 = v464;
      if (v806 >= 1)
      {
        int v468 = 0;
        uint64_t v469 = v11 - 404;
        int v470 = *(_DWORD *)(a3 + 24);
        v471 = *(unsigned __int16 **)(a3 + 40);
        int v472 = v806 + 1;
        int v467 = v464;
        char v473 = *(unsigned char *)(a2 + 308);
        do
        {
          if (v467) {
            int v474 = v467;
          }
          else {
            int v474 = *(_DWORD *)(a3 + 96);
          }
          if (!v467)
          {
            int v470 = *(_DWORD *)(a3 + 104);
            v471 = *(unsigned __int16 **)(a3 + 120);
          }
          BOOL v475 = v468 == 0;
          if (!v468) {
            int v468 = v463;
          }
          uint64_t v476 = v469 + 404 * v475;
          unsigned int v477 = *v471;
          int v478 = (__int16)v477 >> 3;
          int v479 = v471[3];
          if (v470) {
            int v480 = -v478;
          }
          else {
            LOWORD(v480) = (__int16)v477 >> 3;
          }
          unsigned __int16 v481 = v480 + v479;
          ++*(_DWORD *)(v476 + 384);
          *(void *)(v476 + 388) += (unsigned __int16)(v480 + v479);
          *(void *)(v476 + 396) += (unsigned __int16)(v480 + v479) * (unint64_t)(unsigned __int16)(v480 + v479);
          if ((v477 & 4) == 0)
          {
            int v482 = (__int16)v471[1];
            unsigned int v483 = v482 & 7;
            if ((v477 & 1) != 0 || (((v482 & 7u) < 6) & (v477 >> 1)) != 0)
            {
              v496 = (_DWORD *)(v469 + 404 * v475 + 12 * v470);
              ++v496[84];
              v496[85] += v481;
              v496[86] += v479;
            }
            else
            {
              __int16 v484 = v483 > 5;
              unsigned int v485 = v471[2];
              uint64_t v486 = (v485 & 0xF) + 1;
              unsigned int v487 = v485 >> 4;
              int v488 = v482 >> 3;
              if (v482 < 0) {
                int v488 = -v488;
              }
              if (v478 < 0) {
                int v478 = -v478;
              }
              unsigned __int16 v489 = v483 - v484;
              unsigned int v490 = (16 * (v488 & 0xFFFu)) >> v484;
              unsigned int v491 = (v486 >> 1) * v487;
              if (((v482 ^ v477) & 0x8000u) == 0) {
                unsigned __int16 v492 = v489 + 7;
              }
              else {
                unsigned __int16 v492 = v489;
              }
              uint64_t v493 = v476 + 24 * v492;
              a6.n128_u32[0] = v490;
              v494.i32[0] = vshr_n_u32((uint32x2_t)a6.n128_u64[0], 1uLL).u32[0];
              a6.n128_u32[1] = 8 * v478;
              v494.i32[1] = vand_s8(*(int8x8_t *)&a6, v465).i32[1];
              signed int v495 = (v494.i32[0] * v491) >> 15 << v473;
              if (v495 <= -32768) {
                signed int v495 = -32768;
              }
              if (v495 >= 0x7FFF) {
                signed int v495 = 0x7FFF;
              }
              *(void *)v493 += v486;
              a6 = (__n128)vaddw_u32(*(uint64x2_t *)(v493 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v495), v494), 0xFuLL));
              *(__n128 *)(v493 + 8) = a6;
            }
          }
          v471 += 4;
          int v467 = v474 - 1;
          --v468;
          ++v809.i32[0];
          --v472;
          uint64_t v469 = v476;
        }
        while (v472 > 1);
      }
      if (v467) {
      if (*(_DWORD *)a3 > 8u)
      }
      int v497 = 1 << *(_DWORD *)a3;
      if ((v497 & 0xFA) != 0)
      {
        uint64_t v498 = *(void *)(a3 + 32);
        int v499 = v19;
        if (v498)
        {
          *(void *)(a3 + 32) = v498 - 1;
          uint64_t v500 = *(void *)(a3 + 8);
        }
        else
        {
          uint64_t v500 = 2 * *(void *)(a3 + 8);
        }
        *(void *)(a3 + 40) += 2 * v500;
        int v503 = *(_DWORD *)(a3 + 20) + 2;
      }
      else
      {
        int v499 = v19;
        if ((v497 & 0x101) != 0)
        {
          *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
          int32x2_t v501 = *(int32x2_t *)(a3 + 20);
          LODWORD(v502) = vadd_s32(v501, (int32x2_t)0x100000001).u32[0];
          a6.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v501, (int8x8_t)0x100000001);
          HIDWORD(v502) = a6.n128_u32[1];
          *(void *)(a3 + 20) = v502;
          goto LABEL_614;
        }
        *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
        int v503 = *(_DWORD *)(a3 + 20) + 1;
      }
      *(_DWORD *)(a3 + 20) = v503;
LABEL_614:
      unsigned int v504 = *(_DWORD *)(a3 + 80);
      if (v504 > 8) {
      int v505 = 1 << v504;
      }
      if ((v505 & 0xFA) != 0)
      {
        uint64_t v506 = *(void *)(a3 + 112);
        if (v506)
        {
          *(void *)(a3 + 112) = v506 - 1;
          uint64_t v507 = *(void *)(a3 + 88);
        }
        else
        {
          uint64_t v507 = 2 * *(void *)(a3 + 88);
        }
        *(void *)(a3 + 120) += 2 * v507;
        int v510 = *(_DWORD *)(a3 + 100) + 2;
        goto LABEL_622;
      }
      if ((v505 & 0x101) == 0)
      {
        *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
        int v510 = *(_DWORD *)(a3 + 100) + 1;
LABEL_622:
        *(_DWORD *)(a3 + 100) = v510;
        goto LABEL_623;
      }
      *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
      int32x2_t v508 = *(int32x2_t *)(a3 + 100);
      LODWORD(v509) = vadd_s32(v508, (int32x2_t)0x100000001).u32[0];
      a6.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v508, (int8x8_t)0x100000001);
      HIDWORD(v509) = a6.n128_u32[1];
      *(void *)(a3 + 100) = v509;
LABEL_623:
      uint64_t result = v807;
      if (v466 != 1) {
        uint64_t result = 0;
      }
      v11 += 404 * result;
      if (v466 == 1) {
        int v466 = v499;
      }
      else {
        --v466;
      }
      if (!--v17) {
        return result;
      }
    }
  }
  if (v12 != 2) {
  int v17 = *(_DWORD *)(a2 + 20);
  }
  uint64_t v18 = *(unsigned int *)(a2 + 28);
  v809.i32[0] = 0;
LABEL_135:
  if (v17)
  {
    uint64_t v141 = a3 + 16;
    int v142 = *(_DWORD *)(a3 + 16);
    int v143 = 2 * *(_DWORD *)(a2 + 24);
    int v799 = 2 * v142;
    if (!v142) {
      uint64_t v141 = a3 + 96;
    }
    uint64_t v767 = v141;
    int v782 = 2 * *(_DWORD *)(a2 + 16);
    int8x8_t v144 = (int8x8_t)vdup_n_s32(0x7FF8u);
    uint64_t result = 0x7FFFLL;
    int v145 = v18;
    do
    {
      uint64_t v146 = v18;
      int v147 = v799;
      if (v782 >= 1)
      {
        int v148 = 0;
        uint64_t v149 = v11 - 404;
        uint64_t v150 = *(int *)(v767 + 8);
        uint64_t v151 = *(void *)(a3 + 40) + 8;
        char v152 = *(unsigned char *)(a2 + 308);
        int v153 = v782 + 2;
        int v147 = v799;
        do
        {
          if (v147) {
            int v154 = v147;
          }
          else {
            int v154 = 2 * *(_DWORD *)(a3 + 96);
          }
          if (v147) {
            int v155 = (unsigned __int16 *)v151;
          }
          else {
            int v155 = (unsigned __int16 *)(*(void *)(a3 + 120) + 8);
          }
          BOOL v156 = v148 == 0;
          if (v148) {
            int v157 = v148;
          }
          else {
            int v157 = v143;
          }
          uint64_t v158 = v149 + 404 * (v148 == 0);
          int v159 = *(v155 - 1);
          unsigned int v160 = v155[3];
          unsigned int v161 = v159 + ((__int16)*(v155 - 4) >> 3);
          unsigned int v162 = *v155;
          ++*(_DWORD *)(v158 + 384);
          *(void *)(v158 + 388) += (unsigned __int16)v161;
          *(void *)(v158 + 396) += (unsigned __int16)v161 * (unint64_t)(unsigned __int16)v161;
          if ((v162 & 4) == 0)
          {
            int v163 = (__int16)v155[1];
            unsigned int v164 = v163 & 7;
            if ((v162 & 1) != 0 || (((v163 & 7u) < 6) & (v162 >> 1)) != 0)
            {
              uint64_t v179 = v149 + 404 * v156 + 336;
              int8x8_t v180 = (int8x8_t)__PAIR64__(v160, v161);
              float v181 = (int32x2_t *)(v179 + 12 * (int)v150);
              int32x2_t v182 = (int32x2_t)vand_s8(v180, (int8x8_t)0xFFFF0000FFFFLL);
              v183.i32[0] = 1;
              v183.i32[1] = v182.i32[0];
              *float v181 = vadd_s32(*v181, v183);
              v181[1].i32[0] += v159;
              uint64_t v184 = v179 + 12 * (v150 + 1);
              ++*(_DWORD *)v184;
              a7.n128_u64[0] = (unint64_t)vadd_s32(*(int32x2_t *)(v184 + 4), v182);
              *(void *)(v184 + 4) = a7.n128_u64[0];
            }
            else
            {
              __int16 v165 = v164 > 5;
              unsigned int v166 = v155[2];
              uint64_t v167 = (v166 & 0xF) + 1;
              unsigned int v168 = v166 >> 4;
              int v169 = (__int16)v162 >> 3;
              int v170 = v163 >> 3;
              if (v163 < 0) {
                int v170 = -v170;
              }
              if (v169 < 0) {
                int v169 = -v169;
              }
              unsigned __int16 v171 = v164 - v165;
              unsigned int v172 = (16 * (v170 & 0xFFFu)) >> v165;
              unsigned int v173 = (v167 >> 1) * v168;
              int v174 = 8 * v169;
              if (((v163 ^ v162) & 0x8000u) == 0) {
                unsigned __int16 v175 = v171 + 7;
              }
              else {
                unsigned __int16 v175 = v171;
              }
              uint64_t v176 = v158 + 24 * v175;
              a7.n128_u32[0] = v172;
              v177.i32[0] = vshr_n_u32((uint32x2_t)a7.n128_u64[0], 1uLL).u32[0];
              a7.n128_u32[1] = v174;
              v177.i32[1] = vand_s8(*(int8x8_t *)&a7, v144).i32[1];
              signed int v178 = (v177.i32[0] * v173) >> 15 << v152;
              if (v178 <= -32768) {
                signed int v178 = -32768;
              }
              if (v178 >= 0x7FFF) {
                signed int v178 = 0x7FFF;
              }
              *(void *)v176 += v167;
              a7 = (__n128)vaddw_u32(*(uint64x2_t *)(v176 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v178), v177), 0xFuLL));
              *(__n128 *)(v176 + 8) = a7;
            }
          }
          uint64_t v151 = (uint64_t)(v155 + 8);
          int v147 = v154 - 2;
          int v148 = v157 - 2;
          ++v809.i32[0];
          v153 -= 2;
          uint64_t v149 = v158;
        }
        while (v153 > 2);
      }
      if (v147) {
      if (*(_DWORD *)a3 > 8u)
      }
      int v185 = 1 << *(_DWORD *)a3;
      if ((v185 & 0xFA) != 0)
      {
        uint64_t v186 = *(void *)(a3 + 32);
        uint64_t v18 = v146;
        if (v186)
        {
          *(void *)(a3 + 32) = v186 - 1;
          uint64_t v187 = *(void *)(a3 + 8);
        }
        else
        {
          uint64_t v187 = 2 * *(void *)(a3 + 8);
        }
        *(void *)(a3 + 40) += 2 * v187;
        int v190 = *(_DWORD *)(a3 + 20) + 2;
      }
      else
      {
        uint64_t v18 = v146;
        if ((v185 & 0x101) != 0)
        {
          *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
          int32x2_t v188 = *(int32x2_t *)(a3 + 20);
          LODWORD(v189) = vadd_s32(v188, (int32x2_t)0x100000001).u32[0];
          a7.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v188, (int8x8_t)0x100000001);
          HIDWORD(v189) = a7.n128_u32[1];
          *(void *)(a3 + 20) = v189;
          goto LABEL_177;
        }
        *(void *)(a3 + 40) += 2 * *(void *)(a3 + 8);
        int v190 = *(_DWORD *)(a3 + 20) + 1;
      }
      *(_DWORD *)(a3 + 20) = v190;
LABEL_177:
      unsigned int v191 = *(_DWORD *)(a3 + 80);
      if (v191 > 8) {
      int v192 = 1 << v191;
      }
      if ((v192 & 0xFA) != 0)
      {
        uint64_t v193 = *(void *)(a3 + 112);
        if (v193)
        {
          *(void *)(a3 + 112) = v193 - 1;
          uint64_t v194 = *(void *)(a3 + 88);
        }
        else
        {
          uint64_t v194 = 2 * *(void *)(a3 + 88);
        }
        *(void *)(a3 + 120) += 2 * v194;
        int v197 = *(_DWORD *)(a3 + 100) + 2;
        goto LABEL_185;
      }
      if ((v192 & 0x101) == 0)
      {
        *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
        int v197 = *(_DWORD *)(a3 + 100) + 1;
LABEL_185:
        *(_DWORD *)(a3 + 100) = v197;
        goto LABEL_186;
      }
      *(void *)(a3 + 120) += 2 * *(void *)(a3 + 88);
      int32x2_t v195 = *(int32x2_t *)(a3 + 100);
      LODWORD(v196) = vadd_s32(v195, (int32x2_t)0x100000001).u32[0];
      a7.n128_u64[0] = (unint64_t)veor_s8((int8x8_t)v195, (int8x8_t)0x100000001);
      HIDWORD(v196) = a7.n128_u32[1];
      *(void *)(a3 + 100) = v196;
LABEL_186:
      unsigned int v198 = v807;
      if (v145 != 1) {
        unsigned int v198 = 0;
      }
      v11 += 404 * v198;
      if (v145 == 1) {
        int v145 = v18;
      }
      else {
        --v145;
      }
      --v17;
    }
    while (v17);
  }
  return result;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::GetAFEDelayV(PDAF::PixelEngine::_anonymous_namespace_ *this, int a2)
{
  int v2 = (int)this;
  uint64_t result = 0;
  switch(v2)
  {
    case 0:
    case 2:
    case 8:
      return result;
    case 1:
      if (!a2) {
        return 2;
      }
      if (a2 != 1) {
      return 1;
      }
    case 3:
      if (!a2) {
        return 3;
      }
      if (a2 != 1) {
      return 1;
      }
    case 4:
    case 7:
      if (!a2) {
        return 4;
      }
      if (a2 != 1) {
      return 2;
      }
    case 5:
      if (!a2) {
        return 1;
      }
      if (a2 != 1) {
      return 0;
      }
    case 6:
      if (!a2) {
        return 2;
      }
      if (a2 != 1) {
      return 1;
      }
    default:
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlowAccumulateRow1x1Scalar<1>(uint64_t result, uint64_t a2, int a3, int *a4, int *a5, uint64_t a6, _DWORD *a7, double a8, __n128 a9)
{
  int v9 = *a4;
  int v10 = *(_DWORD *)(result + 4);
  if (v10 >= 1)
  {
    int v11 = 0;
    int v12 = *(_DWORD *)(result + 12);
    uint64_t v13 = a6 - 404;
    int v14 = a4[2];
    int v15 = v10 + 1;
    uint64_t v16 = (unsigned __int16 *)*((void *)a4 + 3);
    char v17 = *(unsigned char *)(a2 + 4);
    int8x8_t v18 = (int8x8_t)vdup_n_s32(0x7FF8u);
    do
    {
      int v19 = *a5;
      if (v9) {
        int v19 = v9;
      }
      else {
        int v14 = a5[2];
      }
      if (!v9) {
        uint64_t v16 = (unsigned __int16 *)*((void *)a5 + 3);
      }
      BOOL v20 = v11 == 0;
      if (v11) {
        int v21 = v11;
      }
      else {
        int v21 = v12;
      }
      uint64_t v22 = v13 + 404 * (v11 == 0);
      unsigned int v23 = *v16;
      int v24 = (__int16)v23 >> 3;
      int v25 = v16[3];
      if (v14) {
        int v26 = -v24;
      }
      else {
        int v26 = (__int16)v23 >> 3;
      }
      unsigned __int16 v27 = v26 + v25;
      ++*(_DWORD *)(v22 + 384);
      *(void *)(v22 + 388) += v27;
      *(void *)(v22 + 396) += v27 * (unint64_t)v27;
      if ((v23 & 4) == 0)
      {
        int v28 = (__int16)v16[1];
        unsigned int v29 = v28 & 7;
        if ((v23 & 1) != 0 || (((v28 & 7u) < 6) & (v23 >> 1)) != 0)
        {
          unsigned int v43 = (_DWORD *)(v13 + 404 * v20 + 12 * v14);
          ++v43[84];
          v43[85] += v27;
          v43[86] += v25;
        }
        else
        {
          __int16 v30 = v29 > 5;
          unsigned int v31 = v16[2];
          uint64_t v32 = (v31 & 0xF) + 1;
          unsigned int v33 = v31 >> 4;
          int v34 = v28 >> 3;
          if (v28 < 0) {
            int v34 = -v34;
          }
          if (v24 < 0) {
            int v24 = -v24;
          }
          unsigned __int16 v35 = v29 - v30;
          unsigned int v36 = (16 * (v34 & 0xFFFu)) >> v30;
          unsigned int v37 = (v32 >> 1) * v33;
          int v38 = 8 * v24;
          if (((v28 ^ v23) & 0x8000u) == 0) {
            unsigned __int16 v39 = v35 + 7;
          }
          else {
            unsigned __int16 v39 = v35;
          }
          uint64_t v40 = v22 + 24 * v39;
          a9.n128_u32[0] = v36;
          v41.i32[0] = vshr_n_u32((uint32x2_t)a9.n128_u64[0], 1uLL).u32[0];
          a9.n128_u32[1] = v38;
          v41.i32[1] = vand_s8(*(int8x8_t *)&a9, v18).i32[1];
          signed int v42 = (v41.i32[0] * v37) >> 15 << v17;
          if (v42 <= -32768) {
            signed int v42 = -32768;
          }
          if (v42 >= 0x7FFF) {
            signed int v42 = 0x7FFF;
          }
          *(void *)v40 += v32;
          a9 = (__n128)vaddw_u32(*(uint64x2_t *)(v40 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v42), v41), 0xFuLL));
          *(__n128 *)(v40 + 8) = a9;
        }
      }
      v16 += 4;
      int v9 = v19 - 1;
      int v11 = v21 - 1;
      uint64_t result = (*a7 + 1);
      *a7 = result;
      v14 ^= a3;
      --v15;
      uint64_t v13 = v22;
    }
    while (v15 > 1);
  }
  if (v9) {
  return result;
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlowAccumulateRow2x1Scalar<5,true>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, double a7, double a8, __n128 a9)
{
  int v9 = 2 * *(_DWORD *)a3;
  int v10 = 2 * *(_DWORD *)(result + 4);
  if (v10 >= 1)
  {
    int v11 = 0;
    int v12 = 2 * *(_DWORD *)(result + 12);
    uint64_t v13 = a5 - 404;
    if (*(_DWORD *)a3) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = a4;
    }
    uint64_t v15 = *(int *)(v14 + 8);
    uint64_t v16 = *(unsigned __int16 **)(a3 + 24);
    char v17 = *(unsigned char *)(a2 + 4);
    int v18 = v10 + 2;
    int8x8_t v19 = (int8x8_t)vdup_n_s32(0x7FF8u);
    do
    {
      int v20 = 2 * *(_DWORD *)a4;
      if (v9) {
        int v20 = v9;
      }
      else {
        uint64_t v16 = *(unsigned __int16 **)(a4 + 24);
      }
      BOOL v21 = v11 == 0;
      if (v11) {
        int v22 = v11;
      }
      else {
        int v22 = v12;
      }
      uint64_t result = v13 + 404 * (v11 == 0);
      unsigned int v23 = v16[3];
      int v24 = v16[7];
      unsigned int v25 = v24 - ((__int16)v16[4] >> 3);
      unsigned int v26 = *v16;
      ++*(_DWORD *)(result + 384);
      *(void *)(result + 388) += (unsigned __int16)v25;
      *(void *)(result + 396) += (unsigned __int16)v25 * (unint64_t)(unsigned __int16)v25;
      if ((v26 & 4) == 0)
      {
        int v27 = (__int16)v16[1];
        unsigned int v28 = v27 & 7;
        if ((v26 & 1) != 0 || (((v27 & 7u) < 6) & (v26 >> 1)) != 0)
        {
          uint64_t v43 = v13 + 404 * v21 + 336;
          uint64_t v44 = v43 + 12 * (int)v15;
          ++*(_DWORD *)v44;
          a9.n128_u64[0] = (unint64_t)vand_s8((int8x8_t)__PAIR64__(v23, v25), (int8x8_t)0xFFFF0000FFFFLL);
          *(int32x2_t *)(v44 + 4) = vadd_s32(*(int32x2_t *)(v44 + 4), (int32x2_t)a9.n128_u64[0]);
          unsigned int v45 = (_DWORD *)(v43 + 12 * (v15 + 1));
          unsigned __int32 v46 = v45[1] + a9.n128_u32[0];
          ++*v45;
          v45[1] = v46;
          v45[2] += v24;
        }
        else
        {
          __int16 v29 = v28 > 5;
          unsigned int v30 = v16[2];
          uint64_t v31 = (v30 & 0xF) + 1;
          unsigned int v32 = v30 >> 4;
          int v33 = (__int16)v26 >> 3;
          int v34 = v27 >> 3;
          if (v27 < 0) {
            int v34 = -v34;
          }
          if (v33 < 0) {
            int v33 = -v33;
          }
          unsigned __int16 v35 = v28 - v29;
          unsigned int v36 = (16 * (v34 & 0xFFFu)) >> v29;
          unsigned int v37 = (v31 >> 1) * v32;
          int v38 = 8 * v33;
          if (((v27 ^ v26) & 0x8000u) == 0) {
            unsigned __int16 v39 = v35 + 7;
          }
          else {
            unsigned __int16 v39 = v35;
          }
          uint64_t v40 = result + 24 * v39;
          a9.n128_u32[0] = v36;
          v41.i32[0] = vshr_n_u32((uint32x2_t)a9.n128_u64[0], 1uLL).u32[0];
          a9.n128_u32[1] = v38;
          v41.i32[1] = vand_s8(*(int8x8_t *)&a9, v19).i32[1];
          signed int v42 = (v41.i32[0] * v37) >> 15 << v17;
          if (v42 <= -32768) {
            signed int v42 = -32768;
          }
          if (v42 >= 0x7FFF) {
            signed int v42 = 0x7FFF;
          }
          *(void *)v40 += v31;
          a9 = (__n128)vaddw_u32(*(uint64x2_t *)(v40 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v42), v41), 0xFuLL));
          *(__n128 *)(v40 + 8) = a9;
        }
      }
      v16 += 8;
      int v9 = v20 - 2;
      int v11 = v22 - 2;
      ++*a6;
      v18 -= 2;
      uint64_t v13 = result;
    }
    while (v18 > 2);
  }
  if (v9) {
  return result;
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlowAccumulateRow2x1Scalar<6,false>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, double a7, double a8, __n128 a9)
{
  int v9 = 2 * *(_DWORD *)a3;
  int v10 = 2 * *(_DWORD *)(result + 4);
  if (v10 >= 1)
  {
    int v11 = 0;
    int v12 = 2 * *(_DWORD *)(result + 12);
    uint64_t v13 = a5 - 404;
    if (*(_DWORD *)a3) {
      uint64_t v14 = a3;
    }
    else {
      uint64_t v14 = a4;
    }
    uint64_t v15 = *(int *)(v14 + 8);
    uint64_t v16 = (unsigned __int16 *)(*(void *)(a3 + 24) + 8);
    char v17 = *(unsigned char *)(a2 + 4);
    int v18 = v10 + 2;
    int8x8_t v19 = (int8x8_t)vdup_n_s32(0x7FF8u);
    do
    {
      int v20 = 2 * *(_DWORD *)a4;
      if (v9) {
        int v20 = v9;
      }
      else {
        uint64_t v16 = (unsigned __int16 *)(*(void *)(a4 + 24) + 8);
      }
      BOOL v21 = v11 == 0;
      if (v11) {
        int v22 = v11;
      }
      else {
        int v22 = v12;
      }
      uint64_t result = v13 + 404 * (v11 == 0);
      int v23 = *(v16 - 1);
      unsigned int v24 = v16[3];
      unsigned int v25 = v23 + ((__int16)*(v16 - 4) >> 3);
      unsigned int v26 = *v16;
      ++*(_DWORD *)(result + 384);
      *(void *)(result + 388) += (unsigned __int16)v25;
      *(void *)(result + 396) += (unsigned __int16)v25 * (unint64_t)(unsigned __int16)v25;
      if ((v26 & 4) == 0)
      {
        int v27 = (__int16)v16[1];
        unsigned int v28 = v27 & 7;
        if ((v26 & 1) != 0 || (((v27 & 7u) < 6) & (v26 >> 1)) != 0)
        {
          uint64_t v43 = v13 + 404 * v21 + 336;
          uint64_t v44 = (int32x2_t *)(v43 + 12 * (int)v15);
          int32x2_t v45 = (int32x2_t)vand_s8((int8x8_t)__PAIR64__(v24, v25), (int8x8_t)0xFFFF0000FFFFLL);
          v46.i32[0] = 1;
          v46.i32[1] = v45.i32[0];
          *uint64_t v44 = vadd_s32(*v44, v46);
          v44[1].i32[0] += v23;
          uint64_t v47 = v43 + 12 * (v15 + 1);
          ++*(_DWORD *)v47;
          a9.n128_u64[0] = (unint64_t)vadd_s32(*(int32x2_t *)(v47 + 4), v45);
          *(void *)(v47 + 4) = a9.n128_u64[0];
        }
        else
        {
          __int16 v29 = v28 > 5;
          unsigned int v30 = v16[2];
          uint64_t v31 = (v30 & 0xF) + 1;
          unsigned int v32 = v30 >> 4;
          int v33 = (__int16)v26 >> 3;
          int v34 = v27 >> 3;
          if (v27 < 0) {
            int v34 = -v34;
          }
          if (v33 < 0) {
            int v33 = -v33;
          }
          unsigned __int16 v35 = v28 - v29;
          unsigned int v36 = (16 * (v34 & 0xFFFu)) >> v29;
          unsigned int v37 = (v31 >> 1) * v32;
          int v38 = 8 * v33;
          if (((v27 ^ v26) & 0x8000u) == 0) {
            unsigned __int16 v39 = v35 + 7;
          }
          else {
            unsigned __int16 v39 = v35;
          }
          uint64_t v40 = result + 24 * v39;
          a9.n128_u32[0] = v36;
          v41.i32[0] = vshr_n_u32((uint32x2_t)a9.n128_u64[0], 1uLL).u32[0];
          a9.n128_u32[1] = v38;
          v41.i32[1] = vand_s8(*(int8x8_t *)&a9, v19).i32[1];
          signed int v42 = (v41.i32[0] * v37) >> 15 << v17;
          if (v42 <= -32768) {
            signed int v42 = -32768;
          }
          if (v42 >= 0x7FFF) {
            signed int v42 = 0x7FFF;
          }
          *(void *)v40 += v31;
          a9 = (__n128)vaddw_u32(*(uint64x2_t *)(v40 + 8), (uint32x2_t)vshr_n_s32(vmul_s32(vdup_n_s32(v42), v41), 0xFuLL));
          *(__n128 *)(v40 + 8) = a9;
        }
      }
      v16 += 8;
      int v9 = v20 - 2;
      int v11 = v22 - 2;
      ++*a6;
      v18 -= 2;
      uint64_t v13 = result;
    }
    while (v18 > 2);
  }
  if (v9) {
  return result;
  }
}

int16x8_t *PDAF::PixelEngine::anonymous namespace'::FlowAccumulateRow1x1Neon64<1>(int16x8_t *result, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, int32x4_t a8, int32x4_t a9)
{
  uint64_t v72 = *MEMORY[0x263EF8340];
  int v9 = *(_DWORD *)a4;
  if (*(_DWORD *)a4) {
    uint64_t v10 = a4;
  }
  else {
    uint64_t v10 = a5;
  }
  int v11 = *(_DWORD *)(v10 + 8);
  int v12 = result->i32[1];
  if (a3)
  {
    a8.i32[0] = 0;
    a9.i32[0] = v11 & 1;
    int8x16_t v13 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(a9, a8), 0);
    v14.i64[0] = 0xFFFF0000FFFFLL;
    v14.i64[1] = 0xFFFF0000FFFFLL;
    v15.i64[0] = 0xFFFF0000FFFF0000;
    v15.i64[1] = 0xFFFF0000FFFF0000;
    int8x16_t v16 = vbslq_s8(v13, v15, v14);
  }
  else
  {
    int8x16_t v16 = (int8x16_t)vdupq_n_s16(-(v11 & 1));
  }
  if (v12 < 1) {
    goto LABEL_35;
  }
  __int32 v17 = 0;
  int v18 = *(const __int16 **)(a4 + 24);
  uint64_t v19 = a6 - 404;
  int16x8_t v20 = vdupq_n_s16(*(char *)(a2 + 4));
  __int32 v21 = result->i32[3];
  int v22 = v68;
  v23.i64[0] = 0x1000100010001;
  v23.i64[1] = 0x1000100010001;
  v24.i64[0] = -1;
  v24.i64[1] = -1;
  v25.i64[0] = 0x2000200020002;
  v25.i64[1] = 0x2000200020002;
  v26.i64[0] = 0x4000400040004;
  v26.i64[1] = 0x4000400040004;
  v27.i64[0] = 0x7000700070007;
  v27.i64[1] = 0x7000700070007;
  v28.i64[0] = 0xF000F000F000FLL;
  v28.i64[1] = 0xF000F000F000FLL;
  v29.i64[0] = 0x5000500050005;
  v29.i64[1] = 0x5000500050005;
  uint64_t result = &v70;
LABEL_9:
  unsigned int v30 = *(const __int16 **)(a5 + 24);
  int v31 = *(_DWORD *)a5;
  if (!v9)
  {
    int v9 = *(_DWORD *)a5;
    int v18 = *(const __int16 **)(a5 + 24);
  }
  if (v9 > 7)
  {
    int v32 = 8;
LABEL_14:
    v9 -= v32;
    int16x8x4_t v73 = vld4q_s16(v18);
    v18 += 32;
    goto LABEL_25;
  }
  int v32 = v12;
  if (v9 == v12) {
    goto LABEL_14;
  }
  if (v9 < 1) {
  unint64_t v33 = 0;
  }
  uint64_t v34 = 2 * v9;
  do
  {
    v67[0].i16[v33 / 2] = *v18;
    v71.i16[v33 / 2] = v18[1];
    v70.i16[v33 / 2] = v18[2];
    v69.i16[v33 / 2] = v18[3];
    v33 += 2;
    v18 += 4;
  }
  while (v34 != v33);
  if (v12 >= 8) {
    int v35 = 8;
  }
  else {
    int v35 = v12;
  }
  if (v9 < v35)
  {
    unsigned int v36 = &v69.i16[(unint64_t)v34 / 2];
    unsigned int v37 = &v70.i16[(unint64_t)v34 / 2];
    int v38 = &v71.i16[(unint64_t)v34 / 2];
    unsigned __int16 v39 = &v67[0].i16[(unint64_t)v34 / 2];
    int v40 = v9;
    do
    {
      *v39++ = *v30;
      *v38++ = v30[1];
      *v37++ = v30[2];
      *v36++ = v30[3];
      v30 += 4;
      ++v40;
    }
    while (v35 > v40);
  }
  v73.val[0] = v67[0];
  v73.val[2] = v70;
  v73.val[1] = v71;
  v73.val[3] = v69;
  v9 += v31 - v35;
  int v18 = v30;
LABEL_25:
  uint64_t v41 = 0;
  int8x16_t v42 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v73.val[0], v26));
  int16x8_t v43 = (int16x8_t)vandq_s8((int8x16_t)v73.val[1], v27);
  int16x8_t v44 = vshrq_n_s16(v73.val[0], 3uLL);
  int8x16_t v45 = (int8x16_t)vaddq_s16(v73.val[3], (int16x8_t)vbslq_s8(v16, (int8x16_t)vnegq_s16(v44), (int8x16_t)v44));
  int8x16_t v46 = (int8x16_t)vcgtq_u16((uint16x8_t)v43, v29);
  int8x16_t v47 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v73.val[1], 3uLL)), 4uLL);
  int16x8_t v48 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8((int8x16_t)v73.val[2], v28), (int16x8_t)vbicq_s8(v23, (int8x16_t)v73.val[0])), vorrq_s8(v46, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v73.val[0], v25))));
  int16x8_t v49 = vaddq_s16((int16x8_t)vbslq_s8(v46, (int8x16_t)vaddq_s16(v43, v24), (int8x16_t)v43), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v73.val[0]), (int8x16_t)vcgtq_s16(v73.val[1], v24)), v27));
  int16x8_t v50 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v46, (int8x16_t)vshrq_n_u16((uint16x8_t)v47, 1uLL), v47), 1uLL);
  int16x8_t v51 = vqshlq_s16(vqdmulhq_s16(v50, vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v48, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v73.val[2], 4uLL))), v20);
  int8x16_t v52 = (int8x16_t)vqdmulhq_s16(v51, v50);
  int8x16_t v53 = (int8x16_t)vqdmulhq_s16(v51, (int16x8_t)vshrq_n_u16(vqshlq_n_u16((uint16x8_t)vabsq_s16(v44), 4uLL), 1uLL));
  int8x16_t v54 = (int8x16_t)vceqzq_s16(v48);
  v67[0] = v49;
  v67[1] = (int16x8_t)vornq_s8(vandq_s8((int8x16_t)v48, v42), v42);
  v68[0] = vbslq_s8(v54, v45, v52);
  v68[1] = vbslq_s8(v54, (int8x16_t)v73.val[3], v53);
  int16x8_t v71 = (int16x8_t)v45;
  int v55 = v22;
  uint64_t v56 = (unsigned __int16 *)v22;
  while (1)
  {
    BOOL v57 = v17 == 0;
    if (!v17) {
      __int32 v17 = v21;
    }
    uint64_t v58 = v19 + 404 * v57;
    unsigned int v59 = *(v56 - 16);
    uint64_t v60 = *(v56 - 8);
    uint64_t v61 = *v56;
    uint64_t v62 = v56[8];
    ++*(_DWORD *)(v58 + 384);
    uint64_t v63 = v71.u16[v41];
    *(void *)(v58 + 388) += v63;
    *(void *)(v58 + 396) += v63 * (unint64_t)v63;
    if (v60)
    {
      if (v60 != 0xFFFF)
      {
        uint64_t v64 = (void *)(v58 + 24 * v59);
        uint64_t v65 = v64[1] + v61;
        *v64 += v60;
        v64[1] = v65;
        v64[2] += v62;
      }
    }
    else
    {
      int32x2_t v66 = (_DWORD *)(v19 + 404 * v57 + 12 * v11);
      ++v66[84];
      v66[85] += v61;
      v66[86] += v62;
    }
    ++*a7;
    if (v12 - 1 == v41) {
      break;
    }
    ++v56;
    v11 ^= a3;
    --v17;
    ++v41;
    v19 += 404 * v57;
    if (v41 == 8)
    {
      v12 -= 8;
      uint64_t v19 = v58;
      int v22 = v55;
      if (v12 + 1 > 1) {
        goto LABEL_9;
      }
      break;
    }
  }
LABEL_35:
  if (v9) {
  return result;
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlowAccumulateRow2x1Neon64<5,1ul>(uint64_t result, uint64_t a2, int *a3, int *a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v78 = *MEMORY[0x263EF8340];
  int v6 = 2 * *(_DWORD *)(result + 4);
  if (v6 < 1) {
    return result;
  }
  int v7 = 0;
  int16x8_t v8 = vdupq_n_s16(*(char *)(a2 + 4));
  int v9 = 2 * *(_DWORD *)(result + 12);
  if (*a3) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = a4;
  }
  uint64_t v11 = v10[2];
  int v12 = 2 * *a3;
  uint64_t v13 = a5 - 404;
  int8x16_t v14 = (const __int16 *)*((void *)a3 + 3);
  int v15 = v6 - 2;
  v16.i64[0] = 0x1000100010001;
  v16.i64[1] = 0x1000100010001;
  v17.i64[0] = -1;
  v17.i64[1] = -1;
  v18.i64[0] = 0x2000200020002;
  v18.i64[1] = 0x2000200020002;
  v19.i64[0] = 0x4000400040004;
  v19.i64[1] = 0x4000400040004;
  v20.i64[0] = 0x7000700070007;
  v20.i64[1] = 0x7000700070007;
  v21.i64[0] = 0xF000F000F000FLL;
  v21.i64[1] = 0xF000F000F000FLL;
  uint64_t result = 24;
  v22.i64[0] = 0x5000500050005;
  v22.i64[1] = 0x5000500050005;
LABEL_6:
  int8x16_t v23 = (const __int16 *)*((void *)a4 + 3);
  int v24 = *a4;
  int v25 = 2 * *a4;
  if (v12) {
    int v25 = v12;
  }
  else {
    int8x16_t v14 = (const __int16 *)*((void *)a4 + 3);
  }
  if (v25 > 15)
  {
    int v26 = 16;
LABEL_12:
    int8x16_t v27 = v14;
    int16x8x4_t v79 = vld4q_s16(v27);
    v27 += 32;
    int16x8x4_t v80 = vld4q_s16(v27);
    int16x8_t v28 = vuzp1q_s16(v79.val[0], v80.val[0]);
    int16x8_t v29 = vuzp1q_s16(v79.val[1], v80.val[1]);
    int8x16_t v30 = (int8x16_t)vuzp1q_s16(v79.val[2], v80.val[2]);
    int8x16_t v31 = (int8x16_t)vuzp1q_s16(v79.val[3], v80.val[3]);
    int16x8_t v32 = vuzp2q_s16(v79.val[3], v80.val[3]);
    int8x16_t v33 = (int8x16_t)vsubq_s16(v32, vshrq_n_s16(vuzp2q_s16(v79.val[0], v80.val[0]), 3uLL));
    v14 += 64;
    int v12 = v25 - v26;
    goto LABEL_27;
  }
  int v26 = v6;
  if (v25 == v6) {
    goto LABEL_12;
  }
  if (v25 <= 0) {
  unsigned int v34 = v25 >> 1;
  }
  if (v25 != 1)
  {
    if (v34 <= 1) {
      uint64_t v35 = 1;
    }
    else {
      uint64_t v35 = v34;
    }
    unsigned int v36 = &v74;
    unsigned int v37 = &v73;
    int v38 = &v75;
    unsigned __int16 v39 = &v76;
    int v40 = &v77;
    uint64_t v41 = (__int16 *)v72;
    do
    {
      *v41++ = *v14;
      v40->i16[0] = v14[1];
      int v40 = (int16x8_t *)((char *)v40 + 2);
      v39->i16[0] = v14[2];
      unsigned __int16 v39 = (int8x16_t *)((char *)v39 + 2);
      v38->i16[0] = v14[3];
      int v38 = (int8x16_t *)((char *)v38 + 2);
      __int16 v42 = v14[7];
      v37->i16[0] = v42;
      unsigned int v37 = (int16x8_t *)((char *)v37 + 2);
      v36->i16[0] = v42 + (v14[4] >> 3);
      unsigned int v36 = (int8x16_t *)((char *)v36 + 2);
      v14 += 8;
      --v35;
    }
    while (v35);
  }
  if (v6 <= 15) {
    uint64_t v43 = v6 >> 1;
  }
  else {
    uint64_t v43 = 8;
  }
  if (v34 < v43)
  {
    uint64_t v44 = 0;
    do
    {
      *((_WORD *)v72 + v34 + v44) = *v23;
      v77.i16[v34 + v44] = v23[1];
      v76.i16[v34 + v44] = v23[2];
      v75.i16[v34 + v44] = v23[3];
      __int16 v45 = v23[7];
      v73.i16[v34 + v44] = v45;
      v74.i16[v34 + v44] = v45 + (v23[4] >> 3);
      v23 += 8;
      ++v44;
    }
    while (v43 - v34 != v44);
  }
  int16x8_t v28 = (int16x8_t)v72[0];
  int16x8_t v29 = v77;
  int8x16_t v31 = v75;
  int8x16_t v30 = v76;
  int16x8_t v32 = v73;
  int8x16_t v33 = v74;
  int v12 = 2 * (v24 - v43 + v34);
  int8x16_t v14 = v23;
LABEL_27:
  unint64_t v46 = 0;
  int8x16_t v47 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v28, v19));
  int16x8_t v48 = (int16x8_t)vandq_s8((int8x16_t)v29, v20);
  int8x16_t v49 = (int8x16_t)vcgtq_u16((uint16x8_t)v48, v22);
  int8x16_t v50 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v29, 3uLL)), 4uLL);
  uint16x8_t v51 = vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v28, 3uLL)), 4uLL);
  int16x8_t v52 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8(v30, v21), (int16x8_t)vbicq_s8(v16, (int8x16_t)v28)), vorrq_s8(v49, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v28, v18))));
  int8x16_t v53 = (int8x16_t)vaddq_s16((int16x8_t)vbslq_s8(v49, (int8x16_t)vaddq_s16(v48, v17), (int8x16_t)v48), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v28), (int8x16_t)vcgtq_s16(v29, v17)), v20));
  int16x8_t v54 = vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v52, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v30, 4uLL));
  int16x8_t v55 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v49, (int8x16_t)vshrq_n_u16((uint16x8_t)v50, 1uLL), v50), 1uLL);
  int16x8_t v56 = vqshlq_s16(vqdmulhq_s16(v55, v54), v8);
  int8x16_t v57 = (int8x16_t)vceqzq_s16(v52);
  int16x8_t v77 = (int16x8_t)v33;
  v72[0] = vornq_s8(vandq_s8((int8x16_t)v52, v47), v47);
  v72[1] = vbslq_s8(v57, v33, (int8x16_t)vqdmulhq_s16(v56, v55));
  v72[2] = vbslq_s8(v57, v31, (int8x16_t)vqdmulhq_s16(v56, (int16x8_t)vshrq_n_u16(v51, 1uLL)));
  v72[3] = vbslq_s8(v57, (int8x16_t)v32, v53);
  v6 -= 16;
  while (1)
  {
    BOOL v58 = v7 == 0;
    if (!v7) {
      int v7 = v9;
    }
    uint64_t v59 = v13 + 404 * v58;
    uint64_t v60 = *(unsigned __int16 *)((char *)v72 + v46);
    ++*(_DWORD *)(v59 + 384);
    uint64_t v61 = v77.u16[v46 / 2];
    *(void *)(v59 + 388) += v61;
    *(void *)(v59 + 396) += v61 * (unint64_t)v61;
    if (v60)
    {
      if (v60 != 0xFFFF)
      {
        uint64_t v62 = *(unsigned __int16 *)((char *)&v72[2] + v46);
        uint64_t v63 = (void *)(v59 + 24 * *(unsigned __int16 *)((char *)&v72[3] + v46));
        uint64_t v64 = v63[1] + *(unsigned __int16 *)((char *)&v72[1] + v46);
        *v63 += v60;
        v63[1] = v64;
        v63[2] += v62;
      }
    }
    else
    {
      int v65 = *(unsigned __int16 *)((char *)&v72[1] + v46);
      int v66 = *(unsigned __int16 *)((char *)&v72[2] + v46);
      int v67 = *(unsigned __int16 *)((char *)&v72[3] + v46);
      uint64_t v68 = v13 + 404 * v58 + 336;
      int16x8_t v69 = (_DWORD *)(v68 + 12 * (int)v11);
      int v70 = v69[1] + v65;
      ++*v69;
      v69[1] = v70;
      v69[2] += v66;
      int16x8_t v71 = (_DWORD *)(v68 + 12 * (v11 + 1));
      LODWORD(v69) = v71[1];
      ++*v71;
      v71[1] = v69 + v65;
      v71[2] += v67;
    }
    ++*a6;
    if (v15 == v46) {
      return result;
    }
    v7 -= 2;
    v46 += 2;
    uint64_t v13 = v59;
    if (v46 == 16)
    {
      v15 -= 16;
      uint64_t v13 = v59;
      if (v6 > 0) {
        goto LABEL_6;
      }
      return result;
    }
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlowAccumulateRow2x1Neon64<6,0ul>(uint64_t result, uint64_t a2, int *a3, int *a4, uint64_t a5, _DWORD *a6)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  int v6 = 2 * *(_DWORD *)(result + 4);
  if (v6 < 1) {
    return result;
  }
  int v7 = 0;
  int16x8_t v8 = vdupq_n_s16(*(char *)(a2 + 4));
  int v9 = 2 * *(_DWORD *)(result + 12);
  if (*a3) {
    uint64_t v10 = a3;
  }
  else {
    uint64_t v10 = a4;
  }
  uint64_t v11 = v10[2];
  int v12 = 2 * *a3;
  uint64_t v13 = a5 - 404;
  int8x16_t v14 = (__int16 *)*((void *)a3 + 3);
  int v15 = v6 - 2;
  v16.i64[0] = 0x1000100010001;
  v16.i64[1] = 0x1000100010001;
  v17.i64[0] = -1;
  v17.i64[1] = -1;
  v18.i64[0] = 0x2000200020002;
  v18.i64[1] = 0x2000200020002;
  v19.i64[0] = 0x4000400040004;
  v19.i64[1] = 0x4000400040004;
  v20.i64[0] = 0x7000700070007;
  v20.i64[1] = 0x7000700070007;
  v21.i64[0] = 0xF000F000F000FLL;
  v21.i64[1] = 0xF000F000F000FLL;
  uint64_t result = 24;
  v22.i64[0] = 0x5000500050005;
  v22.i64[1] = 0x5000500050005;
LABEL_6:
  int8x16_t v23 = (__int16 *)*((void *)a4 + 3);
  int v24 = *a4;
  if (v12) {
    int v25 = v12;
  }
  else {
    int v25 = 2 * *a4;
  }
  if (v12) {
    int v26 = v14;
  }
  else {
    int v26 = (__int16 *)*((void *)a4 + 3);
  }
  if (v25 > 15)
  {
    int v27 = 16;
LABEL_15:
    int16x8_t v28 = v26;
    int16x8x4_t v81 = vld4q_s16(v28);
    v28 += 32;
    int16x8x4_t v82 = vld4q_s16(v28);
    int16x8_t v29 = vuzp2q_s16(v81.val[0], v82.val[0]);
    int16x8_t v30 = vuzp2q_s16(v81.val[1], v82.val[1]);
    int8x16_t v31 = (int8x16_t)vuzp2q_s16(v81.val[2], v82.val[2]);
    int16x8_t v32 = vuzp1q_s16(v81.val[3], v82.val[3]);
    int8x16_t v33 = (int8x16_t)vuzp2q_s16(v81.val[3], v82.val[3]);
    int8x16_t v34 = (int8x16_t)vsraq_n_s16(v32, vuzp1q_s16(v81.val[0], v82.val[0]), 3uLL);
    int8x16_t v14 = v26 + 64;
    int v12 = v25 - v27;
    goto LABEL_30;
  }
  int v27 = v6;
  if (v25 == v6) {
    goto LABEL_15;
  }
  if (v25 <= 0) {
  unsigned int v35 = v25 >> 1;
  }
  if (v25 != 1)
  {
    if (v35 <= 1) {
      uint64_t v36 = 1;
    }
    else {
      uint64_t v36 = v35;
    }
    unsigned int v37 = v26 + 4;
    int v38 = &v76;
    unsigned __int16 v39 = &v75;
    int v40 = &v77;
    uint64_t v41 = &v78;
    __int16 v42 = &v79;
    uint64_t v43 = v74;
    do
    {
      *v43++ = *v37;
      v42->i16[0] = v37[1];
      __int16 v42 = (int16x8_t *)((char *)v42 + 2);
      v41->i16[0] = v37[2];
      uint64_t v41 = (int8x16_t *)((char *)v41 + 2);
      v40->i16[0] = v37[3];
      int v40 = (int8x16_t *)((char *)v40 + 2);
      __int16 v44 = *(v37 - 1);
      v39->i16[0] = v44;
      unsigned __int16 v39 = (int16x8_t *)((char *)v39 + 2);
      v38->i16[0] = v44 - ((__int16)*(v37 - 4) >> 3);
      int v38 = (int8x16_t *)((char *)v38 + 2);
      v37 += 8;
      --v36;
    }
    while (v36);
  }
  LODWORD(v45) = v6 >> 1;
  if (v6 <= 15) {
    uint64_t v45 = v45;
  }
  else {
    uint64_t v45 = 8;
  }
  if (v35 < v45)
  {
    uint64_t v46 = 0;
    do
    {
      *((_WORD *)v74 + v35 + v46) = v23[4];
      v79.i16[v35 + v46] = v23[5];
      v78.i16[v35 + v46] = v23[6];
      v77.i16[v35 + v46] = v23[7];
      __int16 v47 = v23[3];
      v75.i16[v35 + v46] = v47;
      v76.i16[v35 + v46] = v47 - (*v23 >> 3);
      v23 += 8;
      ++v46;
    }
    while (v45 - v35 != v46);
  }
  int16x8_t v29 = (int16x8_t)v74[0];
  int16x8_t v30 = v79;
  int8x16_t v33 = v77;
  int8x16_t v31 = v78;
  int16x8_t v32 = v75;
  int8x16_t v34 = v76;
  int v12 = 2 * (v24 - v45 + v35);
  int8x16_t v14 = v23;
LABEL_30:
  unint64_t v48 = 0;
  int8x16_t v49 = (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v29, v19));
  int16x8_t v50 = (int16x8_t)vandq_s8((int8x16_t)v30, v20);
  int8x16_t v51 = (int8x16_t)vcgtq_u16((uint16x8_t)v50, v22);
  int8x16_t v52 = (int8x16_t)vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v30, 3uLL)), 4uLL);
  uint16x8_t v53 = vqshlq_n_u16((uint16x8_t)vabsq_s16(vshrq_n_s16(v29, 3uLL)), 4uLL);
  int16x8_t v54 = (int16x8_t)vandq_s8((int8x16_t)vaddq_s16((int16x8_t)vandq_s8(v31, v21), (int16x8_t)vbicq_s8(v16, (int8x16_t)v29)), vorrq_s8(v51, (int8x16_t)vceqzq_s16((int16x8_t)vandq_s8((int8x16_t)v29, v18))));
  int8x16_t v55 = (int8x16_t)vaddq_s16((int16x8_t)vbslq_s8(v51, (int8x16_t)vaddq_s16(v50, v17), (int8x16_t)v50), (int16x8_t)vandq_s8(veorq_s8((int8x16_t)vcltzq_s16(v29), (int8x16_t)vcgtq_s16(v30, v17)), v20));
  int16x8_t v56 = vmulq_s16((int16x8_t)vshrq_n_u16((uint16x8_t)v54, 1uLL), (int16x8_t)vshrq_n_u16((uint16x8_t)v31, 4uLL));
  int16x8_t v57 = (int16x8_t)vshrq_n_u16((uint16x8_t)vbslq_s8(v51, (int8x16_t)vshrq_n_u16((uint16x8_t)v52, 1uLL), v52), 1uLL);
  int16x8_t v58 = vqshlq_s16(vqdmulhq_s16(v57, v56), v8);
  int8x16_t v59 = (int8x16_t)vceqzq_s16(v54);
  int16x8_t v79 = (int16x8_t)v34;
  v74[0] = vornq_s8(vandq_s8((int8x16_t)v54, v49), v49);
  v74[1] = vbslq_s8(v59, v34, (int8x16_t)vqdmulhq_s16(v58, v57));
  v74[2] = vbslq_s8(v59, (int8x16_t)v32, (int8x16_t)vqdmulhq_s16(v58, (int16x8_t)vshrq_n_u16(v53, 1uLL)));
  v74[3] = vbslq_s8(v59, v33, v55);
  v6 -= 16;
  while (1)
  {
    BOOL v60 = v7 == 0;
    if (!v7) {
      int v7 = v9;
    }
    uint64_t v61 = v13 + 404 * v60;
    uint64_t v62 = *(unsigned __int16 *)((char *)v74 + v48);
    ++*(_DWORD *)(v61 + 384);
    uint64_t v63 = v79.u16[v48 / 2];
    *(void *)(v61 + 388) += v63;
    *(void *)(v61 + 396) += v63 * (unint64_t)v63;
    if (v62)
    {
      if (v62 != 0xFFFF)
      {
        uint64_t v64 = *(unsigned __int16 *)((char *)&v74[2] + v48);
        int v65 = (void *)(v61 + 24 * *(unsigned __int16 *)((char *)&v74[3] + v48));
        uint64_t v66 = v65[1] + *(unsigned __int16 *)((char *)&v74[1] + v48);
        *v65 += v62;
        v65[1] = v66;
        v65[2] += v64;
      }
    }
    else
    {
      int v67 = *(unsigned __int16 *)((char *)&v74[1] + v48);
      int v68 = *(unsigned __int16 *)((char *)&v74[2] + v48);
      int v69 = *(unsigned __int16 *)((char *)&v74[3] + v48);
      uint64_t v70 = v13 + 404 * v60 + 336;
      int16x8_t v71 = (_DWORD *)(v70 + 12 * (int)v11);
      int v72 = v71[1] + v67;
      ++*v71;
      v71[1] = v72;
      v71[2] += v68;
      int16x8_t v73 = (_DWORD *)(v70 + 12 * (v11 + 1));
      LODWORD(v71) = v73[1];
      ++*v73;
      v73[1] = v71 + v67;
      v73[2] += v69;
    }
    ++*a6;
    if (v15 == v48) {
      return result;
    }
    v7 -= 2;
    v48 += 2;
    uint64_t v13 = v61;
    if (v48 == 16)
    {
      v15 -= 16;
      uint64_t v13 = v61;
      if (v6 > 0) {
        goto LABEL_6;
      }
      return result;
    }
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::CorrProfileSumRows1x1H(unsigned int *a1, unint64_t a2, char a3, uint64_t a4, _WORD *a5, _WORD *a6, _WORD *a7)
{
  uint64_t v14 = a1[4];
  unsigned int v15 = a1[159];
  bzero(a7, a1[121820]);
  if (!a2) {
  uint64_t v16 = 0;
  }
  int v17 = *(_DWORD *)(a4 + 16);
  uint64_t v18 = 24;
  if (!v17) {
    uint64_t v18 = 104;
  }
  int v19 = *(_DWORD *)(a4 + v18);
  unsigned int v20 = *(_DWORD *)a4;
  int8x16_t v21 = *(__int16 **)(a4 + 40);
  int v22 = *(_DWORD *)(a4 + 24);
  unsigned int v23 = (unsigned __int16)(v15 >> 4);
  do
  {
    int v24 = v17;
    uint64_t v25 = v14;
    int v26 = a7;
    int v27 = a6;
    int16x8_t v28 = a5;
    LOBYTE(v29) = v22;
    int16x8_t v30 = v21;
    if (v14)
    {
      do
      {
        if (!v24)
        {
          int16x8_t v30 = *(__int16 **)(a4 + 120);
          int v24 = *(_DWORD *)(a4 + 96);
          int v29 = *(_DWORD *)(a4 + 104);
        }
        int v31 = *v30 >> 3;
        unsigned int v32 = (unsigned __int16)v30[3];
        if (v29) {
          int v31 = -v31;
        }
        unsigned int v33 = (unsigned __int16)(v31 + v32);
        *v28 += (unsigned __int16)v30[3] >> 2;
        *v27 += v33 >> 2;
        if (v23 < v32 || v23 < v33) {
          ++*v26;
        }
        ++v26;
        v30 += 4;
        ++v28;
        ++v27;
        --v24;
        LOBYTE(v29) = v29 ^ a3;
        --v25;
      }
      while (v25);
    }
    if (v20 > 8) {
    if (((1 << v20) & 0xFA) != 0)
    }
    {
      uint64_t v35 = *(void *)(a4 + 32);
      if (v35)
      {
        *(void *)(a4 + 32) = v35 - 1;
        uint64_t v36 = *(void *)(a4 + 8);
      }
      else
      {
        uint64_t v36 = 2 * *(void *)(a4 + 8);
      }
      v21 += v36;
      *(void *)(a4 + 40) = v21;
      int v37 = *(_DWORD *)(a4 + 20) + 2;
    }
    else
    {
      if (((1 << v20) & 0x101) != 0)
      {
        v21 += *(void *)(a4 + 8);
        *(void *)(a4 + 40) = v21;
        v22 ^= 1u;
        ++*(_DWORD *)(a4 + 20);
        *(_DWORD *)(a4 + 24) = v22;
        goto LABEL_25;
      }
      v21 += *(void *)(a4 + 8);
      *(void *)(a4 + 40) = v21;
      int v37 = *(_DWORD *)(a4 + 20) + 1;
    }
    *(_DWORD *)(a4 + 20) = v37;
LABEL_25:
    unsigned int v38 = *(_DWORD *)(a4 + 80);
    if (v38 > 8) {
    int v39 = 1 << v38;
    }
    if ((v39 & 0xFA) != 0)
    {
      uint64_t v40 = *(void *)(a4 + 112);
      if (v40)
      {
        *(void *)(a4 + 112) = v40 - 1;
        uint64_t v41 = *(void *)(a4 + 88);
      }
      else
      {
        uint64_t v41 = 2 * *(void *)(a4 + 88);
      }
      *(void *)(a4 + 120) += 2 * v41;
      int v44 = *(_DWORD *)(a4 + 100) + 2;
    }
    else
    {
      if ((v39 & 0x101) != 0)
      {
        *(void *)(a4 + 120) += 2 * *(void *)(a4 + 88);
        int32x2_t v42 = *(int32x2_t *)(a4 + 100);
        LODWORD(v43) = vadd_s32(v42, (int32x2_t)0x100000001).u32[0];
        HIDWORD(v43) = veor_s8(*(int8x8_t *)&v42, (int8x8_t)0x100000001).i32[1];
        *(void *)(a4 + 100) = v43;
        goto LABEL_34;
      }
      *(void *)(a4 + 120) += 2 * *(void *)(a4 + 88);
      int v44 = *(_DWORD *)(a4 + 100) + 1;
    }
    *(_DWORD *)(a4 + 100) = v44;
LABEL_34:
    if (v24) {
    ++v16;
    }
  }
  while (v16 != a2);
}

void PDAF::PixelEngine::anonymous namespace'::CorrProfileProcess(int a1, unsigned int *a2, uint64_t a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int16 *a7, uint64_t a8)
{
  unsigned int v15 = a2[8];
  switch(v15)
  {
    case 4u:
      break;
    case 2u:
      break;
    case 1u:
      memcpy(a6, a4, 2 * a2[7]);
      memcpy(a7, a5, 2 * a2[7]);
      break;
    default:
  }
  if (a1 == 1)
  {
    if ((*(_DWORD *)(a3 + 4) & 0x80000000) == 0) {
    if (*(int *)(a3 + 8) <= 0)
    }
    if (a2[13])
    {
      unsigned int v40 = 0;
      unsigned int v41 = 0;
      unsigned int v42 = a2[10];
      do
      {
        if (a2[12] + v41 >= a2[11]) {
          unsigned int v41 = a2[11];
        }
        else {
          v41 += a2[12];
        }
        unsigned int v43 = (v41 - v42) & 0xFFFFFFF8;
        *(_DWORD *)(a8 + 340) = v43;
        int v44 = (int16x8_t *)&a6[v42];
        uint64_t v45 = (int8x16_t *)&a7[v42];
        a8 += 360;
        ++v40;
        unsigned int v42 = v41;
      }
      while (v40 < a2[13]);
    }
  }
  else
  {
    if (a1) {
    uint64_t v18 = *(int *)(a3 + 4);
    }
    if ((v18 & 0x80000000) == 0) {
    int v19 = *(_DWORD *)(a3 + 8);
    }
    if (v19 <= 0) {
    unsigned int v20 = a2[13];
    }
    if (v20)
    {
      int v21 = 0;
      unsigned int v22 = 0;
      unsigned int v24 = a2[11];
      unsigned int v23 = a2[12];
      int v25 = v19 + 1;
      unsigned int v26 = a2[10];
      do
      {
        int v27 = &a6[v26];
        int16x8_t v28 = &a7[v26];
        v22 += v23;
        if (v22 >= v24) {
          unsigned int v22 = v24;
        }
        unsigned int v29 = (v22 - v26) & 0xFFFFFFF8;
        *(_DWORD *)(a8 + 340) = v29;
        uint64_t v30 = v18;
        int v31 = (float32x4_t *)a8;
        do
        {
          unsigned int v32 = 0;
          int32x4_t v33 = 0uLL;
          if (v29)
          {
            unsigned int v34 = v29;
            uint64_t v35 = v27;
            uint64_t v36 = &v28[v30];
            do
            {
              int v37 = *v35;
              if (v37 != 0xFFFF)
              {
                unsigned int v38 = *v36;
                if (v38 != 0xFFFF)
                {
                  v32 += v38 * v38;
                  v39.i32[0] = *v35;
                  v39.i32[1] = v37 * v37;
                  v39.i64[1] = __PAIR64__(v38 * v37, v38);
                  int32x4_t v33 = vaddq_s32(v33, v39);
                }
              }
              ++v35;
              ++v36;
              --v34;
            }
            while (v34);
          }
          v31[1].f32[0] = v31[1].f32[0] + (float)v32;
          *int v31 = vaddq_f32(*v31, vcvtq_f32_u32((uint32x4_t)v33));
          int v31 = (float32x4_t *)((char *)v31 + 20);
          ++v30;
        }
        while (v25 != v30);
        ++v21;
        a8 += 360;
        unsigned int v26 = v22;
      }
      while (v21 != v20);
    }
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::CorrProfileScaleMirrorSat(uint64_t result, int a2, uint64_t a3, char a4, _WORD *a5, _WORD *a6, _WORD *a7)
{
  unsigned int v7 = *(unsigned __int16 *)(result + 24);
  if (!*(unsigned char *)(result + 16)) {
    unsigned int v7 = 0xFFFF;
  }
  for (; a3; --a3)
  {
    *a5 = ((unsigned __int16)*a5 * a2) >> 5;
    unsigned int v8 = (unsigned __int16)*a6 * a2;
    *a6 = v8 >> 5;
    unsigned int v9 = (unsigned __int16)*a5;
    unsigned int v10 = (v8 >> 4) & 0xFFFE;
    BOOL v11 = v10 >= v9;
    __int16 v12 = v10 - v9;
    if (!v11) {
      __int16 v12 = 0;
    }
    if (a4)
    {
      *a5 = v12;
      __int16 v12 = v9;
    }
    *a6 = v12;
    if (v7 <= (unsigned __int16)*a7)
    {
      *a7 = 1;
      *a5 = -1;
      *a6 = -1;
    }
    ++a7;
    ++a5;
    ++a6;
    a4 ^= 1u;
  }
  return result;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::CorrProfileUpSample2x(uint64_t this, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t v4 = this - 1;
  if (this != 1)
  {
    do
    {
      *a3 = *a2;
      int v5 = *a2;
      if (v5 == 0xFFFF)
      {
        LOWORD(v7) = -1;
      }
      else
      {
        int v6 = a2[1];
        unsigned int v7 = (v5 + v6 + 1) >> 1;
        if (v6 == 0xFFFF) {
          LOWORD(v7) = -1;
        }
      }
      a3[1] = v7;
      ++a2;
      a3 += 2;
      --v4;
    }
    while (v4);
  }
  *a3 = *a2;
  return this;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::CorrProfileUpSample4x(uint64_t this, unsigned __int16 *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t v4 = this - 1;
  if (this != 1)
  {
    do
    {
      int v5 = *a2;
      *a3 = v5;
      int v6 = *a2;
      if (v6 == 0xFFFF || (int v7 = a2[1], v7 == 0xFFFF))
      {
        *(_DWORD *)(a3 + 1) = -1;
        LOWORD(v9) = -1;
      }
      else
      {
        unsigned int v8 = v6 + v7 + 1;
        a3[2] = v8 >> 1;
        a3[1] = (v5 + (v8 >> 1) + 1) >> 1;
        unsigned int v9 = (a2[1] + (v8 >> 1) + 1) >> 1;
      }
      a3[3] = v9;
      ++a2;
      a3 += 4;
      --v4;
    }
    while (v4);
  }
  *a3 = *a2;
  return this;
}

float PDAF::PixelEngine::anonymous namespace'::CorrChunkAccumNeon64(int a1, int16x8_t *a2, int8x16_t *a3, uint64_t a4)
{
  if (a1 < 1)
  {
    int32x4_t v21 = 0uLL;
    float v92 = 0.0;
    float v91 = 0.0;
    float v90 = 0.0;
    float v89 = 0.0;
    float v88 = 0.0;
    float v87 = 0.0;
    float v86 = 0.0;
    float v85 = 0.0;
    int32x4_t v20 = 0uLL;
    int32x4_t v19 = 0uLL;
    int32x4_t v18 = 0uLL;
    int32x4_t v17 = 0uLL;
    int32x4_t v16 = 0uLL;
    int32x4_t v14 = 0uLL;
    int32x4_t v12 = 0uLL;
  }
  else
  {
    unsigned int v4 = 0;
    unsigned int v5 = 0;
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = 0;
    unsigned int v10 = 0;
    unsigned int v11 = 0;
    int32x4_t v12 = 0uLL;
    v13.i64[0] = -1;
    v13.i64[1] = -1;
    int32x4_t v14 = 0uLL;
    unsigned int v15 = a1 + 8;
    int32x4_t v16 = 0uLL;
    int32x4_t v17 = 0uLL;
    int32x4_t v18 = 0uLL;
    int32x4_t v19 = 0uLL;
    int32x4_t v20 = 0uLL;
    int32x4_t v21 = 0uLL;
    do
    {
      int16x8_t v22 = (int16x8_t)a3[-1];
      int16x8_t v23 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 2uLL);
      int16x8_t v24 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 4uLL);
      int16x8_t v25 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 6uLL);
      int16x8_t v26 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 8uLL);
      int16x8_t v27 = *a2++;
      int16x8_t v28 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 0xAuLL);
      int16x8_t v29 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 0xCuLL);
      int16x8_t v30 = (int16x8_t)vextq_s8((int8x16_t)v22, *a3, 0xEuLL);
      uint16x8_t v31 = (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v27, v13));
      int32x4_t v32 = (int32x4_t)vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v22, v13)));
      int16x8_t v33 = (int16x8_t)vminq_u16((uint16x8_t)v27, (uint16x8_t)v32);
      int16x8_t v34 = (int16x8_t)vminq_u16((uint16x8_t)v22, (uint16x8_t)v32);
      int32x4_t v35 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v33.i8, *(uint16x4_t *)v33.i8), (uint16x8_t)v33, (uint16x8_t)v33);
      int32x4_t v36 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v34.i8, *(uint16x4_t *)v34.i8), (uint16x8_t)v34, (uint16x8_t)v34);
      int32x4_t v37 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v33.i8, *(uint16x4_t *)v34.i8), (uint16x8_t)v33, (uint16x8_t)v34);
      v32.i16[0] = vaddvq_s16(v33);
      v33.i16[0] = vaddvq_s16(v34);
      uint16x8_t v38 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v23, v13)));
      int16x8_t v39 = (int16x8_t)vminq_u16((uint16x8_t)v27, v38);
      int16x8_t v40 = (int16x8_t)vminq_u16((uint16x8_t)v23, v38);
      v32.i32[1] = v33.i32[0];
      int32x4_t v41 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)v39.i8), (uint16x8_t)v39, (uint16x8_t)v39);
      int32x4_t v42 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v40.i8, *(uint16x4_t *)v40.i8), (uint16x8_t)v40, (uint16x8_t)v40);
      int v43 = vaddvq_s32(v37);
      int32x4_t v44 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v39.i8, *(uint16x4_t *)v40.i8), (uint16x8_t)v39, (uint16x8_t)v40);
      v37.i16[0] = vaddvq_s16(v39);
      v40.i16[0] = vaddvq_s16(v40);
      v37.i32[1] = v40.i32[0];
      v39.i32[0] = vaddvq_s32(v35);
      int32x4_t v45 = (int32x4_t)vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v24, v13)));
      int16x8_t v46 = (int16x8_t)vminq_u16((uint16x8_t)v27, (uint16x8_t)v45);
      int v47 = vaddvq_s32(v44);
      int16x8_t v48 = (int16x8_t)vminq_u16((uint16x8_t)v24, (uint16x8_t)v45);
      int32x4_t v49 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v48.i8, *(uint16x4_t *)v48.i8), (uint16x8_t)v48, (uint16x8_t)v48);
      v45.i32[0] = vaddvq_s32(v41);
      int32x4_t v50 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v46.i8, *(uint16x4_t *)v48.i8), (uint16x8_t)v46, (uint16x8_t)v48);
      int v51 = vaddvq_s32(v50);
      v44.i16[0] = vaddvq_s16(v46);
      v50.i16[0] = vaddvq_s16(v48);
      int v52 = v43;
      v44.i32[1] = v50.i32[0];
      v46.i32[0] = vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v46.i8, *(uint16x4_t *)v46.i8), (uint16x8_t)v46, (uint16x8_t)v46));
      *(int8x8_t *)v32.i8 = vand_s8(*(int8x8_t *)v32.i8, (int8x8_t)0xFFFF0000FFFFLL);
      uint16x8_t v53 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v25, v13)));
      int16x8_t v54 = (int16x8_t)vminq_u16((uint16x8_t)v27, v53);
      int16x8_t v55 = (int16x8_t)vminq_u16((uint16x8_t)v25, v53);
      v32.i64[1] = __PAIR64__(vaddvq_s32(v36), v39.u32[0]);
      int32x4_t v56 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v54.i8, *(uint16x4_t *)v54.i8), (uint16x8_t)v54, (uint16x8_t)v54);
      int32x4_t v57 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v55.i8, *(uint16x4_t *)v55.i8), (uint16x8_t)v55, (uint16x8_t)v55);
      int v58 = v47;
      int32x4_t v59 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v54.i8, *(uint16x4_t *)v55.i8), (uint16x8_t)v54, (uint16x8_t)v55);
      v60.i32[0] = vaddvq_s32(v59);
      v54.i16[0] = vaddvq_s16(v54);
      v59.i16[0] = vaddvq_s16(v55);
      *(int8x8_t *)v55.i8 = vand_s8(*(int8x8_t *)v37.i8, (int8x8_t)0xFFFF0000FFFFLL);
      v54.i32[1] = v59.i32[0];
      int v61 = v51;
      uint16x8_t v62 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v26, v13)));
      int16x8_t v63 = (int16x8_t)vminq_u16((uint16x8_t)v27, v62);
      int16x8_t v64 = (int16x8_t)vminq_u16((uint16x8_t)v26, v62);
      int32x4_t v65 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v63.i8, *(uint16x4_t *)v63.i8), (uint16x8_t)v63, (uint16x8_t)v63);
      *(int8x8_t *)v26.i8 = vand_s8(*(int8x8_t *)v44.i8, (int8x8_t)0xFFFF0000FFFFLL);
      int32x4_t v66 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v64.i8, *(uint16x4_t *)v64.i8), (uint16x8_t)v64, (uint16x8_t)v64);
      int v67 = vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v63.i8, *(uint16x4_t *)v64.i8), (uint16x8_t)v63, (uint16x8_t)v64));
      __int32 v68 = v60.i32[0];
      v60.i16[0] = vaddvq_s16(v63);
      v64.i16[0] = vaddvq_s16(v64);
      v60.i32[1] = v64.i32[0];
      *(int8x8_t *)v64.i8 = vand_s8(*(int8x8_t *)v54.i8, (int8x8_t)0xFFFF0000FFFFLL);
      uint16x8_t v69 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v28, v13)));
      int16x8_t v70 = (int16x8_t)vminq_u16((uint16x8_t)v27, v69);
      int16x8_t v71 = (int16x8_t)vminq_u16((uint16x8_t)v28, v69);
      int v72 = v67;
      v55.i64[1] = __PAIR64__(vaddvq_s32(v42), v45.u32[0]);
      int v73 = vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v70.i8, *(uint16x4_t *)v71.i8), (uint16x8_t)v70, (uint16x8_t)v71));
      int32x4_t v74 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v71.i8, *(uint16x4_t *)v71.i8), (uint16x8_t)v71, (uint16x8_t)v71);
      v26.i64[1] = __PAIR64__(vaddvq_s32(v49), v46.u32[0]);
      v46.i16[0] = vaddvq_s16(v70);
      v71.i16[0] = vaddvq_s16(v71);
      v46.i32[1] = v71.i32[0];
      v64.i64[1] = __PAIR64__(vaddvq_s32(v57), vaddvq_s32(v56));
      v4 += v52;
      *(int8x8_t *)v45.i8 = vand_s8(v60, (int8x8_t)0xFFFF0000FFFFLL);
      v45.i64[1] = __PAIR64__(vaddvq_s32(v66), vaddvq_s32(v65));
      v5 += v58;
      v6 += v61;
      *(int8x8_t *)v71.i8 = vand_s8(*(int8x8_t *)v46.i8, (int8x8_t)0xFFFF0000FFFFLL);
      v71.i64[1] = __PAIR64__(vaddvq_s32(v74), vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v70.i8, *(uint16x4_t *)v70.i8), (uint16x8_t)v70, (uint16x8_t)v70)));
      v7 += v68;
      v8 += v72;
      v9 += v73;
      uint16x8_t v75 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v29, v13)));
      int16x8_t v76 = (int16x8_t)vminq_u16((uint16x8_t)v27, v75);
      int16x8_t v77 = (int16x8_t)vminq_u16((uint16x8_t)v29, v75);
      int32x4_t v78 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v76.i8, *(uint16x4_t *)v76.i8), (uint16x8_t)v76, (uint16x8_t)v76);
      int32x4_t v79 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v77.i8, *(uint16x4_t *)v77.i8), (uint16x8_t)v77, (uint16x8_t)v77);
      v10 += vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v76.i8, *(uint16x4_t *)v77.i8), (uint16x8_t)v76, (uint16x8_t)v77));
      v76.i16[0] = vaddvq_s16(v76);
      v77.i16[0] = vaddvq_s16(v77);
      v76.i32[1] = v77.i32[0];
      *(int8x8_t *)v76.i8 = vand_s8(*(int8x8_t *)v76.i8, (int8x8_t)0xFFFF0000FFFFLL);
      int32x4_t v12 = vaddq_s32(v32, v12);
      v76.i64[1] = __PAIR64__(vaddvq_s32(v79), vaddvq_s32(v78));
      int32x4_t v14 = vaddq_s32((int32x4_t)v55, v14);
      uint16x8_t v80 = vminq_u16(v31, (uint16x8_t)vmvnq_s8((int8x16_t)vceqq_s16(v30, v13)));
      int16x8_t v81 = (int16x8_t)vminq_u16((uint16x8_t)v27, v80);
      int32x4_t v16 = vaddq_s32((int32x4_t)v26, v16);
      int16x8_t v82 = (int16x8_t)vminq_u16((uint16x8_t)v30, v80);
      int32x4_t v83 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v81.i8, *(uint16x4_t *)v81.i8), (uint16x8_t)v81, (uint16x8_t)v81);
      int32x4_t v84 = (int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v82.i8, *(uint16x4_t *)v82.i8), (uint16x8_t)v82, (uint16x8_t)v82);
      int32x4_t v17 = vaddq_s32((int32x4_t)v64, v17);
      v11 += vaddvq_s32((int32x4_t)vmlal_high_u16(vmull_u16(*(uint16x4_t *)v81.i8, *(uint16x4_t *)v82.i8), (uint16x8_t)v81, (uint16x8_t)v82));
      int32x4_t v18 = vaddq_s32(v45, v18);
      v81.i16[0] = vaddvq_s16(v81);
      v82.i16[0] = vaddvq_s16(v82);
      v81.i32[1] = v82.i32[0];
      int32x4_t v19 = vaddq_s32((int32x4_t)v71, v19);
      *(int8x8_t *)v81.i8 = vand_s8(*(int8x8_t *)v81.i8, (int8x8_t)0xFFFF0000FFFFLL);
      v81.i64[1] = __PAIR64__(vaddvq_s32(v84), vaddvq_s32(v83));
      int32x4_t v20 = vaddq_s32((int32x4_t)v76, v20);
      v15 -= 8;
      ++a3;
      int32x4_t v21 = vaddq_s32((int32x4_t)v81, v21);
    }
    while (v15 > 8);
    float v85 = (float)v4;
    float v86 = (float)v5;
    float v87 = (float)v6;
    float v88 = (float)v7;
    float v89 = (float)v8;
    float v90 = (float)v9;
    float v91 = (float)v10;
    float v92 = (float)v11;
  }
  *(float32x2_t *)a4 = vcvt_f32_u32((uint32x2_t)vzip1_s32(*(int32x2_t *)v12.i8, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v12, (int8x16_t)v12, 8uLL)));
  *(float *)(a4 + 8) = (float)v12.u32[1];
  *(float *)(a4 + 12) = v85;
  *(float32x4_t *)(a4 + 16) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v12, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v12, v14), v14), 0xCuLL));
  *(float *)(a4 + 32) = v86;
  *(float32x4_t *)(a4 + 36) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v14, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v14, v16), v16), 0xCuLL));
  *(float *)(a4 + 52) = v87;
  *(float32x4_t *)(a4 + 56) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v16, v17), v17), 0xCuLL));
  *(float *)(a4 + 72) = v88;
  *(float32x4_t *)(a4 + 76) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v17, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v17, v18), v18), 0xCuLL));
  *(float *)(a4 + 92) = v89;
  *(float32x4_t *)(a4 + 96) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v18, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v18, v19), v19), 0xCuLL));
  *(float *)(a4 + 112) = v90;
  *(float32x4_t *)(a4 + 116) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v19, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v19, v20), v20), 0xCuLL));
  *(float *)(a4 + 132) = v91;
  *(float32x4_t *)(a4 + 136) = vcvtq_f32_u32((uint32x4_t)vextq_s8((int8x16_t)v20, (int8x16_t)vuzp2q_s32(vtrn1q_s32(v20, v21), v21), 0xCuLL));
  *(float *)v21.i32 = (float)v21.u32[3];
  *(float *)(a4 + 152) = v92;
  *(float *)(a4 + 156) = (float)v21.u32[3];
  return *(float *)v21.i32;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::CorrProfileSumCols1x1V(unsigned int *a1, int a2, unint64_t a3, int *a4, _WORD *a5, _WORD *a6, _WORD *a7)
{
  uint64_t v9 = a1[5];
  int v10 = *a4;
  int v37 = a4[12];
  uint64_t v11 = *((void *)a4 + 8);
  uint64_t v12 = *((void *)a4 + 9);
  int v13 = a4[20];
  uint64_t v43 = *((void *)a4 + 11);
  uint64_t v44 = *((void *)a4 + 1);
  int v14 = a4[32];
  uint64_t v16 = *((void *)a4 + 18);
  unsigned int v15 = (__int16 *)*((void *)a4 + 19);
  unsigned int v36 = a1[159];
  bzero(a7, a1[121820]);
  if (!a3) {
  uint64_t v17 = 14;
  }
  if (!a4[12]) {
    uint64_t v17 = 34;
  }
  int v18 = a4[v17];
  if (v9)
  {
    uint64_t v19 = 0;
    int v20 = v37 - a2;
    if (v37 - a2 >= 1) {
      int v21 = 0;
    }
    else {
      int v21 = v14;
    }
    int v22 = v21 + v20;
    unsigned int v23 = (unsigned __int16)(v36 >> 4);
    int16x8_t v24 = a5;
    int16x8_t v25 = a6;
    char v26 = v18;
    int16x8_t v27 = a7;
    do
    {
      if (v20 >= 1) {
        int16x8_t v28 = (__int16 *)(v12 + 8 * a2);
      }
      else {
        int16x8_t v28 = &v15[-4 * v20];
      }
      unint64_t v29 = a3;
      int v30 = v22;
      do
      {
        if (!v30)
        {
          int16x8_t v28 = v15;
          int v30 = v14;
        }
        int v31 = *v28 >> 3;
        unsigned int v32 = (unsigned __int16)v28[3];
        if (v26) {
          int v31 = -v31;
        }
        *v24 += (unsigned __int16)v28[3] >> 2;
        *v25 += (unsigned __int16)(v31 + v32) >> 2;
        if (v23 < v32 || v23 < (unsigned __int16)(v31 + v32)) {
          ++*v27;
        }
        v28 += 4;
        --v30;
        --v29;
      }
      while (v29);
      if ((v10 - 3) >= 5)
      {
        switch(v10)
        {
          case 0:
          case 2:
          case 8:
          case 1:
            break;
          default:
        }
      }
      if ((v13 - 3) >= 5)
      {
        switch(v13)
        {
          case 0:
          case 2:
          case 8:
          case 1:
            break;
          default:
        }
      }
      v12 += 2 * (v44 << (v11 != 0));
      if (v11) {
        --v11;
      }
      else {
        uint64_t v11 = 0;
      }
      uint64_t v34 = v16 - 1;
      if (!v16) {
        uint64_t v34 = 0;
      }
      v15 += v43 << (v16 != 0);
      ++v24;
      ++v25;
      ++v27;
      v26 ^= 1u;
      ++v19;
      uint64_t v16 = v34;
    }
    while (v19 != v9);
  }
}

uint64_t PDAF::PixelEngine::anonymous namespace'::CorrProfileSumRows2x1H(uint64_t a1, unsigned int a2, uint64_t a3, _WORD *a4, _WORD *a5)
{
  if (!a2) {
  int v5 = 0;
  }
  uint64_t v6 = *(unsigned int *)(a1 + 4);
  int v7 = *(_DWORD *)(a3 + 16);
  unsigned int v8 = *(_DWORD *)a3;
  uint64_t v9 = *(void *)(a3 + 40);
  do
  {
    int v10 = v7;
    uint64_t v11 = v6;
    uint64_t v12 = a5;
    int v13 = a4;
    uint64_t v14 = v9;
    if (v6)
    {
      do
      {
        if (!v10)
        {
          uint64_t v14 = *(void *)(a3 + 120);
          int v10 = *(_DWORD *)(a3 + 96);
        }
        *v13++ += *(_WORD *)(v14 + 6) >> 2;
        *v12++ += *(_WORD *)(v14 + 14) >> 2;
        v14 += 16;
        --v10;
        --v11;
      }
      while (v11);
    }
    if (v8 > 8) {
    if (((1 << v8) & 0xFA) != 0)
    }
    {
      uint64_t v15 = *(void *)(a3 + 32);
      if (v15)
      {
        *(void *)(a3 + 32) = v15 - 1;
        uint64_t v16 = *(void *)(a3 + 8);
      }
      else
      {
        uint64_t v16 = 2 * *(void *)(a3 + 8);
      }
      v9 += 2 * v16;
      *(void *)(a3 + 40) = v9;
      int v19 = *(_DWORD *)(a3 + 20) + 2;
    }
    else
    {
      if (((1 << v8) & 0x101) != 0)
      {
        v9 += 2 * *(void *)(a3 + 8);
        *(void *)(a3 + 40) = v9;
        int32x2_t v17 = *(int32x2_t *)(a3 + 20);
        LODWORD(v18) = vadd_s32(v17, (int32x2_t)0x100000001).u32[0];
        HIDWORD(v18) = veor_s8(*(int8x8_t *)&v17, (int8x8_t)0x100000001).i32[1];
        *(void *)(a3 + 20) = v18;
        goto LABEL_16;
      }
      v9 += 2 * *(void *)(a3 + 8);
      *(void *)(a3 + 40) = v9;
      int v19 = *(_DWORD *)(a3 + 20) + 1;
    }
    *(_DWORD *)(a3 + 20) = v19;
LABEL_16:
    unsigned int v20 = *(_DWORD *)(a3 + 80);
    if (v20 > 8) {
    int v21 = 1 << v20;
    }
    if ((v21 & 0xFA) != 0)
    {
      uint64_t v22 = *(void *)(a3 + 112);
      if (v22)
      {
        *(void *)(a3 + 112) = v22 - 1;
        uint64_t v23 = *(void *)(a3 + 88);
      }
      else
      {
        uint64_t v23 = 2 * *(void *)(a3 + 88);
      }
      uint64_t result = *(void *)(a3 + 120);
      *(void *)(a3 + 120) = result + 2 * v23;
      int v27 = *(_DWORD *)(a3 + 100) + 2;
    }
    else
    {
      if ((v21 & 0x101) != 0)
      {
        uint64_t result = *(void *)(a3 + 120);
        *(void *)(a3 + 120) = result + 2 * *(void *)(a3 + 88);
        int32x2_t v25 = *(int32x2_t *)(a3 + 100);
        LODWORD(v26) = vadd_s32(v25, (int32x2_t)0x100000001).u32[0];
        HIDWORD(v26) = veor_s8(*(int8x8_t *)&v25, (int8x8_t)0x100000001).i32[1];
        *(void *)(a3 + 100) = v26;
        goto LABEL_25;
      }
      uint64_t result = *(void *)(a3 + 120);
      *(void *)(a3 + 120) = result + 2 * *(void *)(a3 + 88);
      int v27 = *(_DWORD *)(a3 + 100) + 1;
    }
    *(_DWORD *)(a3 + 100) = v27;
LABEL_25:
    if (v10) {
    ++v5;
    }
  }
  while (v5 != a2);
  if (v6)
  {
    unsigned int v28 = 0x80 / a2;
    do
    {
      *a4 = (v28 * (unsigned __int16)*a4) >> 5;
      ++a4;
      *a5 = (v28 * (unsigned __int16)*a5) >> 5;
      ++a5;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::CorrProfileSumCols2x1V(uint64_t result, int a2, unint64_t a3, int *a4, _WORD *a5, _WORD *a6)
{
  if (!a3) {
  uint64_t v6 = *(unsigned int *)(result + 20);
  }
  if (v6)
  {
    uint64_t v7 = 0;
    int v8 = *a4;
    uint64_t v9 = *((void *)a4 + 1);
    uint64_t v11 = *((void *)a4 + 8);
    uint64_t v10 = *((void *)a4 + 9);
    int v12 = a4[20];
    uint64_t v13 = *((void *)a4 + 11);
    uint64_t result = a4[32];
    uint64_t v14 = 8 * a2;
    int v15 = a4[12] - a2;
    if (v15 >= 1) {
      int v16 = 0;
    }
    else {
      int v16 = a4[32];
    }
    int v17 = v16 + v15;
    uint64_t v19 = *((void *)a4 + 18);
    uint64_t v18 = *((void *)a4 + 19);
    unsigned int v20 = a6;
    int v21 = a5;
    do
    {
      uint64_t v22 = v18 + -16 * v15;
      if (v15 >= 1) {
        uint64_t v22 = v10 + 2 * v14;
      }
      unint64_t v23 = a3;
      int v24 = v17;
      do
      {
        if (!v24)
        {
          uint64_t v22 = v18;
          int v24 = result;
        }
        *v21 += *(_WORD *)(v22 + 6) >> 2;
        *v20 += *(_WORD *)(v22 + 14) >> 2;
        v22 += 16;
        --v24;
        --v23;
      }
      while (v23);
      if ((v8 - 3) >= 5)
      {
        switch(v8)
        {
          case 0:
          case 2:
          case 8:
          case 1:
            break;
          default:
        }
      }
      if ((v12 - 3) >= 5)
      {
        switch(v12)
        {
          case 0:
          case 2:
          case 8:
          case 1:
            break;
          default:
        }
      }
      v10 += 2 * (v9 << (v11 != 0));
      if (v11-- == 0) {
        uint64_t v11 = 0;
      }
      uint64_t v26 = v19 - 1;
      if (!v19) {
        uint64_t v26 = 0;
      }
      v18 += 2 * (v13 << (v19 != 0));
      ++v21;
      ++v20;
      ++v7;
      uint64_t v19 = v26;
    }
    while (v7 != v6);
    unint64_t v27 = 0x80 / a3;
    do
    {
      *a5 = ((unsigned __int16)*a5 * v27) >> 5;
      ++a5;
      *a6 = ((unsigned __int16)*a6 * v27) >> 5;
      ++a6;
      --v6;
    }
    while (v6);
  }
  return result;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::CorrGetPhaseChunk(uint64_t result, uint64_t a2, float *a3, float *a4)
{
  uint64_t v4 = 0;
  uint64_t v50 = *MEMORY[0x263EF8340];
  float v5 = (float)*(unsigned int *)(a2 + 340);
  uint64_t v6 = (float *)(a2 + 8);
  do
  {
    float v7 = *(v6 - 2);
    float v8 = (float)(*(v6 - 1) * v5) - (float)(v7 * v7);
    float v9 = 0.0;
    if (v8 >= 0.0)
    {
      float v10 = *v6;
      float v11 = (float)(v6[2] * v5) - (float)(v10 * v10);
      if (v11 >= 0.0)
      {
        double v12 = (float)((float)(v10 * (float)-v7) + (float)(v6[1] * v5));
        double v13 = sqrt(v8) * sqrt(v11);
        if (v13 == 0.0) {
          double v13 = 1.0;
        }
        float v9 = v12 / v13;
      }
    }
    v49[v4++] = v9;
    v6 += 5;
  }
  while (v4 != 17);
  int v14 = *(_DWORD *)(result + 336) - *(_DWORD *)(result + 332);
  int v15 = v14 + 2;
  if (v14 >= -1) {
    int v15 = v14 + 1;
  }
  int v16 = v15 >> 1;
  if (v14 < 0)
  {
    float v19 = -1.0;
    float v18 = 1.0;
    int v20 = v16;
  }
  else
  {
    uint64_t v17 = 0;
    float v18 = 1.0;
    float v19 = -1.0;
    int v20 = v16;
    do
    {
      float v21 = v49[v17];
      if (v19 < v21)
      {
        int v20 = v17;
        float v19 = v49[v17];
      }
      if (v18 > v21) {
        float v18 = v49[v17];
      }
      ++v17;
    }
    while (v14 + 1 != v17);
  }
  char v22 = *(unsigned char *)(result + 356);
  if (!v22) {
    goto LABEL_46;
  }
  if (v20 > 0xF || ((1 << v20) & 0x8101) == 0)
  {
    float v24 = *(float *)(result + 360);
    if (v20 >= 8) {
      unint64_t v25 = 7;
    }
    else {
      unint64_t v25 = 14;
    }
    if (v20 >= 8) {
      unint64_t v26 = 1;
    }
    else {
      unint64_t v26 = 9;
    }
    unint64_t v27 = &v49[v26];
    BOOL v28 = v25 >= v26;
    unint64_t v29 = v25 - v26;
    if (!v28) {
      unint64_t v29 = 0;
    }
    unint64_t v30 = v29 + 1;
    float v31 = -1.0;
    do
    {
      float v32 = *v27;
      if (v31 < *v27 && *(v27 - 1) < (float)(v24 + v32) && v27[1] < (float)(v24 + v32)) {
        float v31 = *v27;
      }
      ++v27;
      --v30;
    }
    while (v30);
    char v22 = (float)(v19 - v31) < *(float *)(result + 364);
  }
  else
  {
    char v22 = 0;
  }
  BOOL v33 = 0;
  if (v20 < 2 || v20 >= v14 - 1) {
    goto LABEL_47;
  }
  float v34 = v49[v20];
  float v35 = *(float *)(result + 368);
  if (v34 >= (float)(v35 + v49[v20 - 1]) || v34 >= (float)(v35 + v49[v20 + 1]))
  {
LABEL_46:
    BOOL v33 = 0;
    goto LABEL_47;
  }
  if (v34 < (float)(v35 + v49[v20 - 2]))
  {
LABEL_59:
    *a4 = 0.0;
    float v38 = 0.0;
    goto LABEL_64;
  }
  BOOL v33 = v34 < (float)(v35 + v49[v20 + 2]);
LABEL_47:
  if ((float)(v19 - v18) < *(float *)(result + 372) || (v22 & 1) != 0 || v33) {
    goto LABEL_59;
  }
  if (v19 < 0.0) {
    float v19 = 0.0;
  }
  if (v19 > 1.0) {
    float v19 = 1.0;
  }
  *a4 = v19;
  if (v20) {
    BOOL v36 = v20 < v14;
  }
  else {
    BOOL v36 = 0;
  }
  if (v36)
  {
    uint64_t v39 = v20 - 1;
    float v40 = (float)v20;
    uint64_t v41 = v20 + 1;
    float v42 = v49[v39];
    float v43 = v49[v20];
    float v44 = v49[v41];
    float v45 = v43 - v42;
    float v46 = v42 - v44;
    float v47 = v44 - v43;
    float v48 = (float)((float)(v46 * (float)v20) + (float)((float)(int)v41 * v45)) + (float)((float)(int)v39 * v47);
    if (v48 != 0.0) {
      float v40 = (float)((float)((float)((float)(v40 * v40) * v46) + (float)((float)((float)(int)v41 * (float)(int)v41) * v45))
    }
                  + (float)((float)((float)(int)v39 * (float)(int)v39) * v47))
          / (float)(v48 + v48);
    float v37 = v40 - (float)v16;
  }
  else
  {
    float v37 = (float)(v20 - v16);
  }
  float v38 = v37 * -2.0;
LABEL_64:
  *a3 = v38;
  return result;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlowStatsEdgeToOutput(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = 0;
  int32x2_t v4 = 0;
  float v5 = 0.0;
  do
  {
    float v6 = (float)*(unsigned int *)(a2 + v3 * 4);
    *(float *)v4.i32 = *(float *)v4.i32 + (float)(v6 - v7);
    float v5 = v5 + v7;
    ++v3;
  }
  while (v3 != 14);
  if (v5 == 0.0) {
    float v8 = 1.0;
  }
  else {
    float v8 = v5;
  }
  float v9 = (float)(*(float *)v4.i32 / v8) + -1.0;
  if (*(float *)v4.i32 == 0.0) {
    float v10 = 1.0;
  }
  else {
    float v10 = *(float *)v4.i32;
  }
  if (v5 <= *(float *)v4.i32) {
    float v11 = 1.0 - (float)(v5 / v10);
  }
  else {
    float v11 = v9;
  }
  if (v11 >= 0.0) {
    float v12 = v11;
  }
  else {
    float v12 = -v11;
  }
  float v13 = 0.0;
  if (v12 > 0.2)
  {
    float v13 = 1.0;
    if (v12 < 0.6) {
      float v13 = (float)(v12 + -0.2) / 0.4;
    }
  }
  uint64_t v14 = 0;
  if (v11 >= 0.0) {
    *(float *)v4.i32 = v13 * *(float *)(result + 36);
  }
  else {
    *(float *)v4.i32 = -(float)(v13 * *(float *)(result + 36));
  }
  float v15 = (float)(*(float *)v4.i32 + 1.0) * 0.5;
  *(float *)v4.i32 = 1.0 - v15;
  float32x4_t v16 = (float32x4_t)vdupq_lane_s32(v4, 0);
  uint64_t v17 = a2 + 116;
  float32x4_t v18 = (float32x4_t)vdupq_n_s32(0x3A800000u);
  int32x4_t v19 = 0uLL;
  v20.i64[0] = 0x7F0000007FLL;
  v20.i64[1] = 0x7F0000007FLL;
  int8x16_t v21 = (int8x16_t)vdupq_n_s32(0x7F800000u);
  __asm { FMOV            V16.4S, #1.0 }
  int32x4_t v27 = 0uLL;
  int32x4_t v28 = 0uLL;
  int32x4_t v29 = 0uLL;
  int32x4_t v30 = 0uLL;
  do
  {
    int32x4_t v31 = *(int32x4_t *)(v17 + v14 * 4 - 112);
    float32x4_t v32 = vmulq_f32(vcvtq_f32_u32((uint32x4_t)v31), v18);
    float32x4_t v33 = (float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v32, v20), v21, (int8x16_t)vabsq_f32(vsqrtq_f32(v32)));
    int32x4_t v35 = (int32x4_t)vcvtq_u32_f32(v34);
    int32x4_t v29 = vaddq_s32(v29, v35);
    int32x4_t v28 = vaddq_s32(v28, v36);
    int32x4_t v30 = vaddq_s32(v31, v30);
    int32x4_t v37 = *(int32x4_t *)(v17 + v14 * 4);
    int32x4_t v27 = vmlaq_s32(v27, v37, v35);
    int32x4_t v19 = vmlaq_s32(v19, v37, v36);
    v14 += 4;
  }
  while (v14 != 12);
  int v38 = vaddvq_s32(v29);
  int v39 = vaddvq_s32(v28);
  int v40 = vaddvq_s32(v27);
  int v41 = vaddvq_s32(v19);
  if (v38) {
    int v40 = 16 * v40 / v38;
  }
  int v42 = v41;
  if (v39) {
    int v42 = 16 * v41 / v39;
  }
  *(unsigned char *)(a3 + 12) = *(unsigned char *)(a2 + 168);
  if (v38)
  {
    *(_DWORD *)a3 = (vaddvq_s32(v30) + 8) >> 4;
    *(_DWORD *)(a3 + 4) = v38;
    *(_DWORD *)(a3 + 8) = v40;
    if (v39)
    {
      if (v42 >= 0) {
        unsigned int v43 = v42;
      }
      else {
        unsigned int v43 = -v42;
      }
      if (v43 >= 0xA1)
      {
        if (v43 < 0x140) {
          *(_DWORD *)(a3 + 8) = (int)(((v43 << 10) - 163840) / 0xA0 * v42 + (1024 - ((v43 << 10) - 163840) / 0xA0) * v40) >> 10;
        }
        else {
          *(_DWORD *)(a3 + 8) = v42;
        }
      }
    }
  }
  else
  {
    *(_DWORD *)(a3 + 8) = 0;
    *(void *)a3 = 0;
  }
  return result;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlowEstimateGainError(uint64_t result, uint64_t a2)
{
  if (result >= 9) {
  uint64_t v2 = qword_2469EE1E8[(int)result];
  }
  switch((int)result)
  {
    case 0:
    case 1:
    case 3:
    case 4:
    case 7:
    case 8:
      uint64_t v3 = (unsigned int *)(a2 + 32);
      float v4 = -1.0;
      do
      {
        unsigned int v5 = *(v3 - 4);
        if (v5 && *v3 && *(v3 - 8) >= 0x41)
        {
          float v6 = (float)((float)v5 / (float)*v3) + -1.0;
          if (v6 < 0.0) {
            float v6 = -v6;
          }
          if (v6 > v4 || v4 < 0.0) {
            float v4 = v6;
          }
        }
        ++v3;
        --v2;
      }
      while (v2);
      break;
    case 2:
      return result;
    case 5:
      uint64_t v8 = 0;
      float v9 = -1.0;
      do
      {
        if ((v8 & 0x7FFFFFFD) != 0)
        {
          uint64_t v10 = a2 + 4 * v8;
          unsigned int v11 = *(_DWORD *)(v10 + 16);
          if (v11)
          {
            unsigned int v12 = *(_DWORD *)(v10 + 32);
            if (v12)
            {
              if (*(_DWORD *)(a2 + 4 * v8) >= 0x41u)
              {
                float v13 = (float)((float)v11 / (float)v12) + -1.0;
                if (v13 < 0.0) {
                  float v13 = -v13;
                }
                if (v13 > v9 || v9 < 0.0) {
                  float v9 = v13;
                }
              }
            }
          }
        }
        ++v8;
      }
      while (v2 != v8);
      break;
    case 6:
      uint64_t v15 = 0;
      float v16 = -1.0;
      do
      {
        if ((v15 & 0x7FFFFFFD) != 1)
        {
          uint64_t v17 = a2 + 4 * v15;
          unsigned int v18 = *(_DWORD *)(v17 + 16);
          if (v18)
          {
            unsigned int v19 = *(_DWORD *)(v17 + 32);
            if (v19)
            {
              if (*(_DWORD *)(a2 + 4 * v15) >= 0x41u)
              {
                float v20 = (float)((float)v18 / (float)v19) + -1.0;
                if (v20 < 0.0) {
                  float v20 = -v20;
                }
                if (v20 > v16 || v16 < 0.0) {
                  float v16 = v20;
                }
              }
            }
          }
        }
        ++v15;
      }
      while (v2 != v15);
      break;
    default:
  }
  return result;
}

uint64_t PDAF::PixelEngine::anonymous namespace'::FlareCompareGainError(PDAF::PixelEngine::_anonymous_namespace_ *this, const float *a2, const float *a3)
{
  if (*(float *)this >= *a2) {
    unsigned int v3 = 0;
  }
  else {
    unsigned int v3 = -1;
  }
  if (*(float *)this > *a2) {
    return 1;
  }
  else {
    return v3;
  }
}

float PDAF::PixelEngine::anonymous namespace'::CurveEstimate(uint64_t a1, unint64_t a2, float a3)
{
  if (a2 < 2)
  {
    unint64_t v4 = 1;
  }
  else
  {
    unsigned int v3 = (float *)(a1 + 8);
    unint64_t v4 = 1;
    while (*v3 <= a3)
    {
      ++v4;
      v3 += 2;
      if (a2 == v4)
      {
        unint64_t v4 = a2;
        break;
      }
    }
  }
  if (v4 >= a2 - 1) {
    unint64_t v4 = a2 - 1;
  }
  unsigned int v5 = (float *)(a1 + 8 * v4);
  float v6 = *(v5 - 2);
  if (*v5 == v6) {
    return *(v5 - 1);
  }
  float v8 = (float)(a3 - v6) / (float)(*v5 - v6);
  if (v8 <= 1.0) {
    float v9 = v8;
  }
  else {
    float v9 = 1.0;
  }
  BOOL v10 = v8 < 0.0;
  float v11 = 0.0;
  if (!v10) {
    float v11 = v9;
  }
  return (float)((float)(1.0 - v11) * *(v5 - 1)) + (float)(v11 * v5[1]);
}

uint64_t PDAF::PixelEngine::anonymous namespace'::ShiftMapTileLevelProcess(uint64_t result, int a2, int a3, int a4, int a5, int a6, int a7, float *a8, float a9, unsigned int *a10)
{
  uint64_t v43 = *MEMORY[0x263EF8340];
  int v10 = *(__int16 *)(result + 712);
  LOWORD(a9) = *(_WORD *)(result + 714);
  float v11 = (float)LODWORD(a9);
  float v12 = (float)(100 - *(_DWORD *)(result + 708)) / 200.0;
  memset(v42, 0, sizeof(v42));
  float v13 = 0.0;
  if (a5 <= a7)
  {
    signed int v14 = a7 + a3;
    unsigned int v15 = a5 + a3;
    unsigned int v16 = a4 + a2;
    int v17 = a6 + a2;
    if (a6 + a2 <= a4 + a2) {
      int v17 = a4 + a2;
    }
    if (v14 <= (int)v15) {
      signed int v14 = a5 + a3;
    }
    do
    {
      if ((v15 & 0x80000000) == 0 && v15 < *(unsigned __int16 *)(result + 34) && a4 <= a6)
      {
        unsigned int v19 = v16;
        do
        {
          if ((v19 & 0x80000000) == 0)
          {
            unsigned int v20 = *(unsigned __int16 *)(result + 32);
            if (v19 < v20)
            {
              uint64_t v21 = 0;
              uint64_t v22 = result + 427308 + 112 * (int)(v19 + v15 * v20);
              do
              {
                *(int32x2_t *)((char *)v42 + v21) = vadd_s32(*(int32x2_t *)((char *)v42 + v21), *(int32x2_t *)(v22 + v21));
                v21 += 8;
              }
              while (v21 != 112);
            }
          }
          BOOL v23 = v19++ == v17;
        }
        while (!v23);
      }
      BOOL v23 = v15++ == v14;
    }
    while (!v23);
    float v13 = (float)DWORD1(v42[0]);
  }
  float v24 = (float)v10;
  float v25 = v11 * 0.000030518;
  float v26 = 1.0 - v12;
  v40[0] = v13;
  uint64_t v27 = 1;
  uint64_t v28 = 12;
  do
  {
    float v13 = v13 + (float)*(unsigned int *)((char *)v42 + v28);
    v40[v27++] = v13;
    v28 += 8;
  }
  while (v27 != 14);
  if (v41 != 0.0)
  {
    for (uint64_t i = 0; i != 14; ++i)
      v40[i] = v40[i] / v41;
  }
  uint64_t v30 = 0;
  __int16 v31 = 0;
  __int16 v32 = 13;
  do
  {
    float v33 = v40[v30];
    if (v33 <= v12 && v40[v30 + 1] > v12) {
      __int16 v31 = v30 + 1;
    }
    if (v33 < v26 && v40[v30 + 1] >= v26) {
      __int16 v32 = v30 + 1;
    }
    ++v30;
  }
  while (v30 != 13);
  if (v31 > v32)
  {
    unsigned int v34 = 0;
LABEL_41:
    float v39 = 0.0;
    goto LABEL_42;
  }
  unsigned int v34 = 0;
  uint64_t v35 = v32 - (uint64_t)v31 + 1;
  int32x4_t v36 = (int *)(((unint64_t)v42 + 8 * v31) | 4);
  float v37 = 0.0;
  do
  {
    float v37 = v37 + (float)*(v36 - 1);
    int v38 = *v36;
    v36 += 2;
    v34 += v38;
    --v35;
  }
  while (v35);
  if (!v34) {
    goto LABEL_41;
  }
  float v39 = -(float)((float)((float)(v37 / (float)v34) + v24) * v25);
LABEL_42:
  *a8 = v39;
  *a10 = v34;
  return result;
}

H16ISP::H16ISPGraphExclaveAutoExposureNode *H16ISP::H16ISPGraphExclaveAutoExposureNode::H16ISPGraphExclaveAutoExposureNode(H16ISP::H16ISPGraphExclaveAutoExposureNode *this, H16ISP::H16ISPDevice *a2, int a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  H16ISP::H16ISPFilterGraphNode::H16ISPFilterGraphNode((uint64_t)this, 19);
  *(void *)uint64_t v6 = &unk_26FAECA10;
  *(unsigned char *)(v6 + 80) = 0;
  *(void *)(v6 + 88) = a2;
  *(_DWORD *)(v6 + 96) = a3;
  float v7 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    float v7 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v7;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    int v8 = *((_DWORD *)this + 24);
    int v10 = 136315394;
    float v11 = "H16ISPGraphExclaveAutoExposureNode";
    __int16 v12 = 1024;
    int v13 = v8;
    _os_log_impl(&dword_24680F000, v7, OS_LOG_TYPE_INFO, "%s - [Exclaves]: channel %d\n", (uint8_t *)&v10, 0x12u);
  }
  return this;
}

void H16ISP::H16ISPGraphExclaveAutoExposureNode::~H16ISPGraphExclaveAutoExposureNode(H16ISP::H16ISPGraphExclaveAutoExposureNode *this)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26FAECA10;
  uint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    uint64_t v2 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    int v3 = 136315138;
    unint64_t v4 = "~H16ISPGraphExclaveAutoExposureNode";
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_INFO, "%s - [Exclaves]: ~H16ISPGraphExclaveAutoExposureNode\n", (uint8_t *)&v3, 0xCu);
  }
  H16ISP::H16ISPFilterGraphNode::~H16ISPFilterGraphNode(this);
}

{
  uint64_t vars8;

  H16ISP::H16ISPGraphExclaveAutoExposureNode::~H16ISPGraphExclaveAutoExposureNode(this);

  JUMPOUT(0x24C53D6E0);
}

uint64_t H16ISP::H16ISPGraphExclaveAutoExposureNode::onActivate(H16ISP::H16ISPGraphExclaveAutoExposureNode *this)
{
  unsigned int v1 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    unsigned int v1 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl(&dword_24680F000, v1, OS_LOG_TYPE_INFO, "[Exclaves]: H16ISPGraphAutoExposureNode::onActivate\n", v3, 2u);
  }
  return 0;
}

uint64_t H16ISP::H16ISPGraphExclaveAutoExposureNode::onDeactivate(H16ISP::H16ISPGraphExclaveAutoExposureNode *this)
{
  unsigned int v1 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    unsigned int v1 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl(&dword_24680F000, v1, OS_LOG_TYPE_INFO, "[Exclaves]: H16ISPGraphAutoExposureNode::onDeactivate\n", v3, 2u);
  }
  return 0;
}

uint64_t H16ISP::H16ISPGraphExclaveAutoExposureNode::onMessageProcessing(H16ISP::H16ISPGraphExclaveAutoExposureNode *this, H16ISP::H16ISPFilterGraphMessage *a2)
{
  uint64_t v51 = *MEMORY[0x263EF8340];
  unint64_t v4 = (pthread_mutex_t *)((char *)a2 + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
  int v5 = *((_DWORD *)a2 + 90);
  int v6 = *((unsigned __int8 *)a2 + 388);
  pthread_mutex_unlock(v4);
  if (H16ISP::H16ISPDevice::enabledExclaveDebug(*((H16ISP::H16ISPDevice **)this + 11)))
  {
    float v7 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      float v7 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v7;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *((_DWORD *)this + 24);
      *(_DWORD *)buf = 136315650;
      *(void *)int v38 = "onMessageProcessing";
      *(_WORD *)&v38[8] = 1024;
      *(_DWORD *)&v38[10] = v8;
      *(_WORD *)&v38[14] = 1024;
      *(_DWORD *)&v38[16] = v5;
      _os_log_impl(&dword_24680F000, v7, OS_LOG_TYPE_DEFAULT, "[Exclaves]: H16ISPGraphExclaveAutoExposureNode::%s EK AE RunKit CamChan %d, requestID=0x%08X\n", buf, 0x18u);
    }
  }
  BOOL isSensorType = H16ISP::H16ISPDevice::isSensorType(*((void *)this + 11), *((_DWORD *)this + 24), 1718186595);
  uint64_t v10 = *((void *)this + 11);
  if (isSensorType)
  {
    uint64_t v11 = *(void *)(v10 + 136);
    int v35 = *((_DWORD *)this + 24);
    int v36 = 2;
    kdebug_trace();
    LODWORD(v11) = ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitaev2(v11, (uint64_t)&v35);
    kdebug_trace();
    if (v11) {
      BOOL v12 = 1;
    }
    else {
      BOOL v12 = *(_DWORD *)&v40[8] == 2;
    }
    if (v12)
    {
      int v13 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        int v13 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v13;
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPGraphExclaveAutoExposureNode::onMessageProcessing();
      }
      return 0;
    }
    if (*(_DWORD *)&v40[8] == 1)
    {
      if (H16ISP::H16ISPDevice::enabledExclaveDebug(*((H16ISP::H16ISPDevice **)this + 11)))
      {
        unsigned int v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          unsigned int v15 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v15;
        }
        uint64_t v16 = 0;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v42 = 136315394;
          *(void *)uint64_t v43 = "onMessageProcessing";
          *(_WORD *)&v43[8] = 1024;
          *(_DWORD *)&v43[10] = v5;
          int v17 = "[Exclaves]: H16ISPGraphExclaveAutoExposureNode::%s EK RunKit AE skipped for reqID 0x%08X\n";
          unsigned int v18 = (uint8_t *)&v42;
          goto LABEL_32;
        }
        return v16;
      }
      return 0;
    }
    *(void *)&long long v46 = *(unsigned int *)buf;
    *(void *)&long long v23 = *(void *)&v38[12];
    *((void *)&v46 + 1) = *(void *)&v38[4];
    *((void *)&v23 + 1) = *(void *)&v39[4];
    long long v47 = v23;
    long long v48 = *(_OWORD *)&v39[12];
    uint64_t v49 = *(void *)v40;
    int v50 = *(_DWORD *)v39;
    float v24 = (H16ISP::H16ISPDevice *)*((void *)this + 11);
    if (v6)
    {
      if (!H16ISP::H16ISPDevice::enabledExclaveDebug(v24)) {
        return 0;
      }
      float v25 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        float v25 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v25;
      }
      uint64_t v16 = 0;
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        return v16;
      }
      unsigned int v42 = 136315138;
      *(void *)uint64_t v43 = "onMessageProcessing";
      int v17 = "[Exclaves]: H16ISPGraphAutoExposureNode::%s In concurrent mode, skip apply AE Settings to FW\n";
      unsigned int v18 = (uint8_t *)&v42;
LABEL_49:
      unsigned int v19 = v25;
      os_log_type_t v20 = OS_LOG_TYPE_DEFAULT;
      uint32_t v21 = 12;
      goto LABEL_50;
    }
    uint64_t v29 = H16ISP::H16ISPDevice::SetExclaveAEConfig(v24, *((_DWORD *)this + 24), &v46);
    if (!v29)
    {
      if (!H16ISP::H16ISPDevice::enabledExclaveDebug(*((H16ISP::H16ISPDevice **)this + 11))) {
        return 0;
      }
      float v33 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        float v33 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v33;
      }
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_INFO)) {
        return 0;
      }
      unsigned int v42 = 136316930;
      *(void *)uint64_t v43 = "onMessageProcessing";
      *(_WORD *)&v43[8] = 2048;
      *(void *)&v43[10] = v46;
      *(_WORD *)&v43[18] = 2048;
      *(void *)float v44 = *((void *)&v46 + 1);
      *(_WORD *)&v44[8] = 1024;
      *(_DWORD *)&v44[10] = DWORD2(v47);
      *(_WORD *)&v44[14] = 1024;
      *(_DWORD *)&v44[16] = HIDWORD(v47);
      *(_WORD *)&v44[20] = 1024;
      *(_DWORD *)&v44[22] = v47;
      *(_WORD *)&v44[26] = 1024;
      *(_DWORD *)float v45 = DWORD1(v47);
      *(_WORD *)&v45[4] = 1024;
      *(_DWORD *)&v45[6] = v50;
      int v17 = "[Exclaves]: H16ISPGraphAutoExposureNode::%s Debug AE results: reqID %llu aeCounter %llu exp %d ET %d Sensor "
            "AG %d Sensor DG %d ISP DG %d\n";
      unsigned int v18 = (uint8_t *)&v42;
      unsigned int v19 = v33;
      os_log_type_t v20 = OS_LOG_TYPE_INFO;
      uint32_t v21 = 62;
      goto LABEL_50;
    }
    uint64_t v16 = v29;
    uint64_t v30 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v30 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v30;
    }
    if (!os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      return v16;
    }
    goto LABEL_57;
  }
  if (!H16ISP::H16ISPDevice::isSensorType(v10, *((_DWORD *)this + 24), 1718775412)
    && !H16ISP::H16ISPDevice::isSensorType(*((void *)this + 11), *((_DWORD *)this + 24), 1718776695))
  {
    return 0;
  }
  uint64_t v14 = *(void *)(*((void *)this + 11) + 184);
  int v35 = *((_DWORD *)this + 24);
  int v36 = 2;
  kdebug_trace();
  LODWORD(v14) = isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitaev2(v14, (uint64_t)&v35);
  kdebug_trace();
  if (v14 || *(_DWORD *)&v45[8] == 2)
  {
    uint64_t v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v22 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v22;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPGraphExclaveAutoExposureNode::onMessageProcessing();
    }
    return 0;
  }
  if (*(_DWORD *)&v45[8] != 1)
  {
    *(void *)&long long v46 = v42;
    *(void *)&long long v26 = *(void *)&v43[12];
    *((void *)&v46 + 1) = *(void *)&v43[4];
    *((void *)&v26 + 1) = *(void *)&v44[4];
    long long v47 = v26;
    long long v48 = *(_OWORD *)&v44[12];
    uint64_t v49 = *(void *)v45;
    int v50 = *(_DWORD *)v44;
    uint64_t v27 = (H16ISP::H16ISPDevice *)*((void *)this + 11);
    if (v6)
    {
      if (!H16ISP::H16ISPDevice::enabledExclaveDebug(v27)) {
        return 0;
      }
      float v25 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        float v25 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v25;
      }
      uint64_t v16 = 0;
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        return v16;
      }
      *(_DWORD *)buf = 136315138;
      *(void *)int v38 = "onMessageProcessing";
      int v17 = "[Exclaves]: H16ISPGraphAutoExposureNode::%s In concurrent mode, skip apply AE Settings to FW\n";
      unsigned int v18 = buf;
      goto LABEL_49;
    }
    uint64_t v31 = H16ISP::H16ISPDevice::SetExclaveAEConfig(v27, *((_DWORD *)this + 24), &v46);
    if (!v31)
    {
      if (!H16ISP::H16ISPDevice::enabledExclaveDebug(*((H16ISP::H16ISPDevice **)this + 11))) {
        return 0;
      }
      unsigned int v34 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        unsigned int v34 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v34;
      }
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_INFO)) {
        return 0;
      }
      *(_DWORD *)buf = 136317186;
      *(void *)int v38 = "onMessageProcessing";
      *(_WORD *)&v38[8] = 2048;
      *(void *)&v38[10] = v46;
      *(_WORD *)&v38[18] = 2048;
      *(void *)float v39 = *((void *)&v46 + 1);
      *(_WORD *)&v39[8] = 1024;
      *(_DWORD *)&v39[10] = DWORD2(v47);
      *(_WORD *)&v39[14] = 1024;
      *(_DWORD *)&v39[16] = HIDWORD(v47);
      *(_WORD *)&v39[20] = 1024;
      *(_DWORD *)&v39[22] = v47;
      *(_WORD *)&v39[26] = 1024;
      *(_DWORD *)int v40 = DWORD1(v47);
      *(_WORD *)&v40[4] = 1024;
      *(_DWORD *)&v40[6] = v50;
      *(_WORD *)&v40[10] = 1024;
      int v41 = *(_DWORD *)&v45[8];
      int v17 = "[Exclaves]: H16ISPGraphAutoExposureNode::%s Debug AE results: reqID %llu aeCounter %llu exp %d ET %d Sensor "
            "AG %d Sensor DG %d ISP DG %d ipcresult=%{BOOL}d\n";
      unsigned int v18 = buf;
      unsigned int v19 = v34;
      os_log_type_t v20 = OS_LOG_TYPE_INFO;
      uint32_t v21 = 68;
      goto LABEL_50;
    }
    uint64_t v16 = v31;
    __int16 v32 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      __int16 v32 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v32;
    }
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
      return v16;
    }
LABEL_57:
    H16ISP::H16ISPGraphExclaveAutoExposureNode::onMessageProcessing();
    return v16;
  }
  if (!H16ISP::H16ISPDevice::enabledExclaveDebug(*((H16ISP::H16ISPDevice **)this + 11))) {
    return 0;
  }
  unsigned int v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    unsigned int v15 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v15;
  }
  uint64_t v16 = 0;
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)int v38 = "onMessageProcessing";
    *(_WORD *)&v38[8] = 1024;
    *(_DWORD *)&v38[10] = v5;
    int v17 = "[Exclaves]: H16ISPGraphExclaveAutoExposureNode::%s EK RunKit AE skipped for reqID 0x%08X\n";
    unsigned int v18 = buf;
LABEL_32:
    unsigned int v19 = v15;
    os_log_type_t v20 = OS_LOG_TYPE_DEFAULT;
    uint32_t v21 = 18;
LABEL_50:
    _os_log_impl(&dword_24680F000, v19, v20, v17, v18, v21);
    return 0;
  }
  return v16;
}

uint64_t H16ISP::H16ISPGraphExclaveAutoExposureNode::GetNodeProcessingState(H16ISP::H16ISPGraphExclaveAutoExposureNode *this)
{
  return *((unsigned __int8 *)this + 80);
}

void H16ISP::SystemStatus::~SystemStatus(CFTypeRef *this)
{
  if (objc_opt_class())
  {
    [(id)H16ISP::stMediaStatusDomainPublisher invalidate];

    H16ISP::stMediaStatusDomainPublisher = 0;
    if (*this)
    {
      CFRelease(*this);
      *this = 0;
    }
  }
}

void H16ISP::SystemStatus::updateData(H16ISP::SystemStatus *this, audit_token_t *a2, char a3)
{
  if (objc_opt_class())
  {
    if (objc_opt_class())
    {
      if (objc_opt_class())
      {
        if (objc_opt_class())
        {
          if (H16ISP::stMediaStatusDomainPublisher)
          {
            long long v6 = *(_OWORD *)&a2->val[4];
            v19[0] = *(_OWORD *)a2->val;
            v19[1] = v6;
            uint64_t v7 = [MEMORY[0x263F7C2B0] attributionWithAuditToken:v19];
            if (v7)
            {
              uint64_t v8 = v7;
              uint64_t v9 = [objc_alloc(MEMORY[0x263F7C2D8]) initWithCameraIdentifier:*(void *)this];
              if (v9)
              {
                uint64_t v10 = (void *)v9;
                uint64_t v13 = 0;
                uint64_t v14 = &v13;
                uint64_t v15 = 0x3052000000;
                uint64_t v16 = __Block_byref_object_copy__2;
                int v17 = __Block_byref_object_dispose__2;
                uint64_t v18 = 0;
                uint64_t v18 = [objc_alloc(MEMORY[0x263F7C2D0]) initWithCameraDescriptor:v9 activityAttribution:v8];

                if (v14[5])
                {
                  v11[0] = MEMORY[0x263EF8330];
                  v11[1] = 3221225472;
                  v11[2] = ___ZN6H16ISP12SystemStatus10updateDataE13audit_token_tb_block_invoke;
                  v11[3] = &unk_2651E96A8;
                  char v12 = a3;
                  v11[4] = &v13;
                  [(id)H16ISP::stMediaStatusDomainPublisher updateVolatileDataWithBlock:v11];
                }
                _Block_object_dispose(&v13, 8);
              }
            }
          }
        }
      }
    }
  }
}

void sub_24695598C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__2(uint64_t a1)
{
}

void ___ZN6H16ISP12SystemStatus10updateDataE13audit_token_tb_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  if (*(unsigned char *)(a1 + 40)) {
    [a2 addCameraAttribution:v3];
  }
  else {
    [a2 removeCameraAttribution:v3];
  }
  unint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
}

uint64_t H16ISPFirmwareWork::verifyAndCreateFilepath(H16ISPFirmwareWork *this, char *__s, unsigned int a3, char *a4)
{
  size_t v7 = strlen(__s);
  if (v7 != a3) {
    return 0;
  }
  size_t v8 = v7;
  if (strstr(__s, "./")) {
    return 0;
  }
  uint64_t v10 = strstr(__s, "../");
  uint64_t result = 0;
  if (a3 <= 0xC0 && !v10)
  {
    if (!a4) {
      operator new[]();
    }
    strcpy(a4, "/private/var/mobile/Media/DCIM");
    if (*__s != 47) {
      *(_WORD *)&a4[strlen(a4)] = 47;
    }
    strncat(a4, __s, v8);
    return 1;
  }
  return result;
}

uint64_t H16ISPFirmwareWork::RPCFileInfo(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 1)
  {
    if (*(void *)(a2 + 8) == 208) {
      operator new[]();
    }
    unint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v4 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::RPCFileInfo();
    }
  }
  else
  {
    uint64_t v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v3 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::RPCFileInfo();
    }
  }
  return 3;
}

uint64_t H16ISPFirmwareWork::RPCFileRead(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (a3 == 2)
  {
    if (*(void *)(a2 + 8) == 208) {
      operator new[]();
    }
    unint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v4 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::RPCFileRead();
    }
  }
  else
  {
    uint64_t v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v3 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::RPCFileRead();
    }
  }
  return 3;
}

uint64_t H16ISPFirmwareWork::RPCFileWrite(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  if (a3 == 2)
  {
    if (*(void *)(a2 + 8) == 208) {
      operator new[]();
    }
    unint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v4 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::RPCFileWrite();
    }
  }
  else
  {
    uint64_t v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v3 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::RPCFileWrite();
    }
  }
  return 3;
}

uint64_t H16ISPFirmwareWork::PDAFProcessX1Wrapper(uint64_t a1, uint64_t *a2, int a3)
{
  if (a3 != 2)
  {
    unint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v4 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::PDAFProcessX1Wrapper();
    }
    return 3;
  }
  if ((unint64_t)a2[4] <= 0x7EF93)
  {
    uint64_t v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v3 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::PDAFProcessX1Wrapper();
    }
    return 3;
  }
  PDAF::PixelEngine::Process_x1(*a2, a2[3]);
  return 0;
}

uint64_t H16ISPFirmwareWork::PDAFProcessX2Wrapper(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 3)
  {
    unint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v4 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::PDAFProcessX2Wrapper();
    }
    return 3;
  }
  if (*(void *)(a2 + 56) <= 0x7EF93uLL)
  {
    uint64_t v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v3 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::PDAFProcessX2Wrapper();
    }
    return 3;
  }
  PDAF::PixelEngine::Process_x2(*(void *)a2, *(void *)(a2 + 24), *(_DWORD **)(a2 + 48));
  return 0;
}

uint64_t H16ISPFirmwareWork::PDAFProcessX3Wrapper(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 4)
  {
    if (*(void *)(a2 + 80) > 0x7EF93uLL) {
      PDAF::PixelEngine::Process_x3(*(void *)a2, *(void *)(a2 + 24), *(void *)(a2 + 48), *(_DWORD **)(a2 + 72));
    }
    uint64_t v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v3 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::PDAFProcessX3Wrapper();
    }
  }
  else
  {
    unint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v4 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::PDAFProcessX3Wrapper();
    }
  }
  return 3;
}

uint64_t H16ISPFirmwareWork::PDAFProcessX4Wrapper(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 5)
  {
    if (*(void *)(a2 + 104) > 0x7EF93uLL) {
      PDAF::PixelEngine::Process_x4(*(void *)a2, *(void *)(a2 + 24), *(void *)(a2 + 48), *(void *)(a2 + 72), *(_DWORD **)(a2 + 96));
    }
    uint64_t v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v3 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::PDAFProcessX4Wrapper();
    }
  }
  else
  {
    unint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v4 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::PDAFProcessX4Wrapper();
    }
  }
  return 3;
}

uint64_t H16ISPFirmwareWork::BlurMProcessWrapper(uint64_t a1, uint64_t a2, int a3)
{
  v11[3] = *MEMORY[0x263EF8340];
  memset(v11, 0, 24);
  if (a3 == 4)
  {
    uint64_t v3 = 0;
    int v5 = (uint64_t *)(a2 + 24);
    unint64_t v4 = *(int **)a2;
    do
    {
      uint64_t v6 = *v5;
      v5 += 3;
      v11[v3++] = v6;
    }
    while (v3 != 3);
    if (*(void *)(a2 + 8) == 591796)
    {
      BlurM::Process(v4, (uint64_t)v11);
      return 0;
    }
    uint64_t v10 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v10 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v10;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::BlurMProcessWrapper();
    }
  }
  else
  {
    uint64_t v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v9 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v9;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::BlurMProcessWrapper(a3, v9);
    }
  }
  return 3;
}

uint64_t H16ISPFirmwareWork::SPDProcessWrapper(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 != 2)
  {
    unint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v4 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::SPDProcessWrapper();
    }
    return 3;
  }
  if (*(void *)(a2 + 8) <= 0x10008FuLL)
  {
    uint64_t v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v3 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR)) {
      H16ISPFirmwareWork::SPDProcessWrapper();
    }
    return 3;
  }
  SPD::Process(*(int **)a2, *(void *)(a2 + 24));
  return 0;
}

uint64_t H16ISPFirmwareWork::FirmwareRPC(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v26 = *MEMORY[0x263EF8340];
  int v4 = gFirmwareWorkCFPrefs;
  if (*(_DWORD *)(a2 + 32))
  {
    unint64_t v7 = 0;
    size_t v8 = (uint64_t *)(a2 + 488);
    uint64_t v9 = (int *)(a2 + 48);
    do
    {
      int v10 = v9[10];
      if (v4)
      {
        uint64_t v11 = *(H16ISPMetrics **)(a1 + 8 * *(v9 - 3));
        if (v11) {
          H16ISPMetrics::StartTimer(v11);
        }
      }
      *a3 = 0;
      uint64_t v12 = kdebug_trace();
      int v13 = 5;
      switch(*(v9 - 3))
      {
        case 4:
          int v14 = H16ISPFirmwareWork::RPCFileInfo(v12, (uint64_t)v8, v10);
          goto LABEL_10;
        case 5:
          int v14 = H16ISPFirmwareWork::RPCFileRead(v12, (uint64_t)v8, v10);
          goto LABEL_10;
        case 6:
          int v14 = H16ISPFirmwareWork::RPCFileWrite(v12, (uint64_t)v8, v10);
LABEL_10:
          int v13 = v14;
          *a3 = 1;
          break;
        case 13:
          uint64_t v15 = *(void *)(a1 + 168);
          if (!v15) {
            operator new();
          }
          int v13 = GMCProcessor::run(v15, (uint64_t)v8);
          *uint64_t v9 = v13;
          break;
        case 14:
          int v16 = H16ISPFirmwareWork::PDAFProcessX1Wrapper(v12, v8, v10);
          goto LABEL_20;
        case 15:
          int v16 = H16ISPFirmwareWork::PDAFProcessX2Wrapper(v12, (uint64_t)v8, v10);
          goto LABEL_20;
        case 16:
          int v16 = H16ISPFirmwareWork::PDAFProcessX3Wrapper(v12, (uint64_t)v8, v10);
          goto LABEL_20;
        case 17:
          int v16 = H16ISPFirmwareWork::PDAFProcessX4Wrapper(v12, (uint64_t)v8, v10);
          goto LABEL_20;
        case 18:
          int v16 = H16ISPFirmwareWork::BlurMProcessWrapper(v12, (uint64_t)v8, v10);
          goto LABEL_20;
        case 19:
          int v16 = H16ISPFirmwareWork::SPDProcessWrapper(v12, (uint64_t)v8, v10);
LABEL_20:
          int v13 = v16;
          break;
        default:
          break;
      }
      kdebug_trace();
      *uint64_t v9 = v13;
      int v4 = gFirmwareWorkCFPrefs;
      if (gFirmwareWorkCFPrefs)
      {
        int v17 = *(H16ISPMetrics **)(a1 + 8 * *(v9 - 3));
        if (v17)
        {
          H16ISPMetrics::StopTimer(v17);
          int v4 = gFirmwareWorkCFPrefs;
        }
        else
        {
          int v4 = 1;
        }
      }
      ++*(_DWORD *)(a1 + 160);
      ++v7;
      v8 += 24;
      v9 += 14;
    }
    while (v7 < *(unsigned int *)(a2 + 32));
  }
  if (v4 && *(_DWORD *)(a1 + 160) >= 0x400u)
  {
    uint64_t v18 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    uint64_t v19 = &_os_log_internal;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v18 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v18;
    }
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24680F000, v18, OS_LOG_TYPE_DEFAULT, "*** Metrics report for firmware work processor ***\n", buf, 2u);
    }
    for (uint64_t i = 0; i != 20; ++i)
    {
      if (*(void *)(a1 + 8 * i))
      {
        uint32_t v21 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v19)
        {
          uint32_t v21 = os_log_create("com.apple.isp", "general");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v21;
        }
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 67109120;
          int v25 = i;
          _os_log_impl(&dword_24680F000, v21, OS_LOG_TYPE_DEFAULT, "*** Metrics for command %d ***\n", buf, 8u);
        }
        H16ISPMetrics::PrintMetricsSummary(*(H16ISPMetrics **)(a1 + 8 * i));
      }
    }
    uint64_t v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v19)
    {
      uint64_t v22 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v22;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24680F000, v22, OS_LOG_TYPE_DEFAULT, "*** End report ***\n", buf, 2u);
    }
    *(_DWORD *)(a1 + 160) = 0;
  }
  return 0;
}

void sub_246956FE4(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x1020C40D64496FCLL);
  _Unwind_Resume(a1);
}

void H16ISPFirmwareWork::H16ISPFirmwareWork(H16ISPFirmwareWork *this, H16ISP::H16ISPDevice *a2)
{
  *((_DWORD *)this + 40) = 0;
  *((void *)this + 21) = 0;
  *((void *)this + 22) = a2;
  unsigned int v2 = H16ISP::H16ISPGetCFPreferenceNumber(@"FirmwareWorkMetrics", @"com.apple.coremedia", 0);
  gFirmwareWorkCFPrefs = v2 != 0;
  if (v2) {
    operator new();
  }
}

void sub_2469570E8(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x1010C40C6958149);
  _Unwind_Resume(a1);
}

void H16ISPFirmwareWork::~H16ISPFirmwareWork(H16ISPFirmwareWork *this)
{
  if (gFirmwareWorkCFPrefs)
  {
    for (uint64_t i = 0; i != 160; i += 8)
    {
      uint64_t v3 = *(H16ISPMetrics **)((char *)this + i);
      if (v3)
      {
        H16ISPMetrics::~H16ISPMetrics(v3);
        MEMORY[0x24C53D6E0]();
      }
    }
  }
  int v4 = (GMCProcessor *)*((void *)this + 21);
  if (v4)
  {
    GMCProcessor::~GMCProcessor(v4);
    MEMORY[0x24C53D6E0]();
    *((void *)this + 21) = 0;
  }
}

void OUTLINED_FUNCTION_8_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x20u);
}

BOOL GMC_SingularityTest(uint64_t a1, double a2)
{
  uint64_t v2 = 0;
  long long v3 = *(_OWORD *)(a1 + 48);
  void v10[2] = *(_OWORD *)(a1 + 32);
  void v10[3] = v3;
  double v11 = *(double *)(a1 + 64);
  long long v4 = *(_OWORD *)(a1 + 16);
  v10[0] = *(_OWORD *)a1;
  v10[1] = v4;
  uint64_t v5 = 1;
  do
  {
    uint64_t v6 = v5;
    unsigned int v7 = v2;
    do
    {
      if (*((double *)v10 + v6) < *((double *)v10 + v7)) {
        unsigned int v7 = v6;
      }
      ++v6;
    }
    while (v6 != 9);
    uint64_t v8 = *((void *)v10 + v7);
    *((void *)v10 + v7) = *((void *)v10 + v2);
    *((void *)v10 + v2) = v8;
    ++v5;
    ++v2;
  }
  while (v2 != 8);
  return v11 / *((double *)v10 + 1) < a2;
}

void GMC_ConstrainWorldPoints(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v6 = *(_DWORD *)(a1 + 20);
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  uint64_t v16 = 0;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0uLL;
  uint64_t v11 = 0;
  Matrix<double>::Matrix((uint64_t)&v9, 3, v6);
  uint64_t v9 = &unk_26FAEB100;
  Matrix<double>::Matrix((uint64_t)&v8, 3, v6);
  uint64_t v8 = &unk_26FAEB100;
  Matrix<unsigned int>::Matrix((uint64_t)&v7, a5, 0, -1);
}

void sub_246957898(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
}

void Matrix<unsigned int>::Matrix(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(void *)a1 = &unk_26FAEBCE0;
  int v4 = *(_DWORD *)(a2 + 20);
  int v5 = *(_DWORD *)(a2 + 16) - a3;
  if (a4 != -1) {
    int v5 = a4;
  }
  uint64_t v6 = *(void *)(a2 + 8) + 4 * (v4 * a3);
  long long v7 = &unk_26FAEBCE0;
  uint64_t v8 = v6;
  int v9 = v5;
  int v10 = v4;
  char v11 = 0;
  *(_DWORD *)(a1 + 16) = v5;
  *(_DWORD *)(a1 + 20) = v4;
  operator new[]();
}

void sub_246957A08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

H16ISP::H16ISPBufferReceiver *H16ISP::H16ISPBufferReceiver::H16ISPBufferReceiver(H16ISP::H16ISPBufferReceiver *this, H16ISP::H16ISPDevice *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  *(_DWORD *)this = 0;
  *((void *)this + 40) = 0;
  *((_DWORD *)this + 82) = 0;
  *((void *)this + 42) = 0;
  *((void *)this + 43) = a2;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *((void *)this + 61) = 0x4000000000000000;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  pthread_mutex_init((pthread_mutex_t *)this + 3, 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 16), 0);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 88), 0);
  *((void *)this + 10) = 0;
  *((void *)this + 19) = 0;
  pthread_mutexattr_init(&v5);
  pthread_mutexattr_settype(&v5, 2);
  pthread_mutex_init((pthread_mutex_t *)this + 4, &v5);
  pthread_mutexattr_destroy(&v5);
  unsigned int v4 = 0;
  H16ISP::H16ISPDevice::GetISPCounterFrequency(*((H16ISP::H16ISPDevice **)this + 43), &v4, (double *)this + 45);
  mach_timebase_info((mach_timebase_info_t)this + 46);
  bzero((char *)this + 496, 0x30uLL);
  return this;
}

void sub_246957B28(_Unwind_Exception *a1)
{
  std::deque<__CVBuffer *>::~deque[abi:ne180100]((void *)(v1 + 424));
  std::deque<__CVBuffer *>::~deque[abi:ne180100](v2);
  _Unwind_Resume(a1);
}

void H16ISP::H16ISPBufferReceiver::~H16ISPBufferReceiver(H16ISP::H16ISPBufferReceiver *this)
{
  if (*(_DWORD *)this) {
    H16ISP::H16ISPBufferReceiver::stopReceive(this);
  }
  if (*((void *)this + 42)) {
    H16ISP::H16ISPBufferReceiver::removeIODispatcherFromRunLoop(this);
  }
  while (1)
  {
    uint64_t v2 = *((void *)this + 52);
    if (!v2) {
      break;
    }
    long long v3 = *(H16ISP::H16ISPFrameReceiverBufferPool **)(*(void *)(*((void *)this + 48)
                                                               + ((*((void *)this + 51) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                   + 8 * (*((void *)this + 51) & 0x1FFLL));
    ++*((void *)this + 51);
    *((void *)this + 52) = v2 - 1;
    std::deque<__CVBuffer *>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)this + 376, 1);
    if (v3)
    {
      H16ISP::H16ISPFrameReceiverBufferPool::~H16ISPFrameReceiverBufferPool(v3);
      MEMORY[0x24C53D6E0]();
    }
  }
  pthread_mutex_destroy((pthread_mutex_t *)this + 3);
  pthread_mutex_destroy((pthread_mutex_t *)this + 4);
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 16));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 88));
  std::deque<__CVBuffer *>::~deque[abi:ne180100]((void *)this + 53);
  std::deque<__CVBuffer *>::~deque[abi:ne180100]((void *)this + 47);
}

uint64_t H16ISP::H16ISPBufferReceiver::stopReceive(H16ISP::H16ISPBufferReceiver *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 192);
  pthread_mutex_lock((pthread_mutex_t *)this + 3);
  if (*(_DWORD *)this)
  {
    kdebug_trace();
    pthread_mutex_lock((pthread_mutex_t *)this + 4);
    *((unsigned char *)this + 352) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)this + 4);
    uint64_t v3 = *((void *)this + 48);
    uint64_t v4 = *((void *)this + 49);
    pthread_mutexattr_t v5 = (void *)(v3 + 8 * (*((void *)this + 51) >> 9));
    if (v4 == v3) {
      uint64_t v6 = 0;
    }
    else {
      uint64_t v6 = (uint64_t *)(*v5 + 8 * (*((void *)this + 51) & 0x1FFLL));
    }
    while (1)
    {
      if (v4 == v3)
      {
        uint64_t v9 = 0;
      }
      else
      {
        unint64_t v8 = *((void *)this + 52) + *((void *)this + 51);
        uint64_t v9 = *(void *)(v3 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF);
      }
      if (v6 == (uint64_t *)v9) {
        break;
      }
      uint64_t v10 = *v6;
      pthread_mutex_lock((pthread_mutex_t *)this + 4);
      *(unsigned char *)(v10 + 144) = 1;
      pthread_mutex_unlock((pthread_mutex_t *)this + 4);
      uint64_t v11 = H16ISP::H16ISPDevice::ReturnAllBuffersInPool(*((H16ISP::H16ISPDevice **)this + 43), 0, *(_DWORD *)(v10 + 20));
      if (v11)
      {
        uint64_t v7 = v11;
        int v25 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
        {
          int v25 = os_log_create("com.apple.isp", "general");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v25;
        }
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPBufferReceiver::stopReceive();
        }
        goto LABEL_37;
      }
      if ((uint64_t *)((char *)++v6 - *v5) == (uint64_t *)4096)
      {
        long long v12 = (uint64_t *)v5[1];
        ++v5;
        uint64_t v6 = v12;
      }
      uint64_t v3 = *((void *)this + 48);
      uint64_t v4 = *((void *)this + 49);
    }
    for (int i = 0; i != 2001; ++i)
    {
      uint64_t v14 = *((void *)this + 48);
      uint64_t v15 = *((void *)this + 49);
      uint64_t v16 = (void *)(v14 + 8 * (*((void *)this + 51) >> 9));
      if (v15 == v14) {
        long long v17 = 0;
      }
      else {
        long long v17 = (uint64_t *)(*v16 + 8 * (*((void *)this + 51) & 0x1FFLL));
      }
      int v18 = 0;
      while (1)
      {
        if (v15 == v14)
        {
          uint64_t v20 = 0;
        }
        else
        {
          unint64_t v19 = *((void *)this + 52) + *((void *)this + 51);
          uint64_t v20 = *(void *)(v14 + ((v19 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v19 & 0x1FF);
        }
        if (v17 == (uint64_t *)v20) {
          break;
        }
        uint64_t v21 = *v17++;
        pthread_mutex_lock((pthread_mutex_t *)this + 4);
        int v22 = *(_DWORD *)(v21 + 120);
        pthread_mutex_unlock((pthread_mutex_t *)this + 4);
        if ((uint64_t *)((char *)v17 - *v16) == (uint64_t *)4096)
        {
          long long v23 = (uint64_t *)v16[1];
          ++v16;
          long long v17 = v23;
        }
        v18 += v22;
        uint64_t v14 = *((void *)this + 48);
        uint64_t v15 = *((void *)this + 49);
      }
      if (!v18)
      {
        uint64_t v7 = 0;
        goto LABEL_37;
      }
      usleep(0x3E8u);
    }
    float v24 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      float v24 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v24;
    }
    uint64_t v7 = 3758097084;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPBufferReceiver::stopReceive();
    }
LABEL_37:
    *(_DWORD *)this = 0;
    for (uint64_t j = *((void *)this + 58); j; uint64_t j = *((void *)this + 58))
    {
      uint64_t v27 = *(CVPixelBufferRef **)(*(void *)(*((void *)this + 54)
                                             + ((*((void *)this + 57) >> 6) & 0x3FFFFFFFFFFFFF8))
                                 + 8 * (*((void *)this + 57) & 0x1FFLL));
      ++*((void *)this + 57);
      *((void *)this + 58) = j - 1;
      std::deque<__CVBuffer *>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)this + 424, 1);
      if (v27)
      {
        CVPixelBufferRelease(*v27);
        MEMORY[0x24C53D6E0](v27, 0x1020C4093CA8EA1);
      }
    }
    pthread_mutex_unlock(v2);
    kdebug_trace();
  }
  else
  {
    pthread_mutex_unlock(v2);
    return 3758097122;
  }
  return v7;
}

void H16ISP::H16ISPBufferReceiver::removeIODispatcherFromRunLoop(H16ISP::H16ISPBufferReceiver *this)
{
  uint64_t v2 = (__CFRunLoopSource *)*((void *)this + 42);
  if (v2)
  {
    CFRunLoopRemoveSource(*((CFRunLoopRef *)this + 1), v2, (CFRunLoopMode)*MEMORY[0x263EFFE88]);
    CFRelease(*((CFTypeRef *)this + 42));
    *((void *)this + 42) = 0;
  }
  uint64_t v3 = (__CFMachPort *)*((void *)this + 40);
  if (v3)
  {
    CFMachPortInvalidate(v3);
    CFRelease(*((CFTypeRef *)this + 40));
    *((void *)this + 40) = 0;
  }
  mach_port_name_t v4 = *((_DWORD *)this + 82);
  if (v4)
  {
    mach_port_mod_refs(*MEMORY[0x263EF8960], v4, 1u, -1);
    *((_DWORD *)this + 82) = 0;
  }
}

uint64_t H16ISP::H16ISPBufferReceiver::setupBufferReceiver(H16ISP::H16ISPBufferReceiver *this)
{
  *((void *)this + 1) = CFRunLoopGetCurrent();

  return H16ISP::H16ISPBufferReceiver::addIODispatcherToRunLoop(this);
}

uint64_t H16ISP::H16ISPBufferReceiver::addIODispatcherToRunLoop(H16ISP::H16ISPBufferReceiver *this)
{
  uint64_t v2 = IOCreateReceivePort(0x39u, (mach_port_t *)this + 82);
  if (!v2)
  {
    uint64_t v2 = 3758097085;
    Boolean shouldFreeInfo = 0;
    context.version = 1;
    context.info = this;
    memset(&context.retain, 0, 24);
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    mach_port_name_t v4 = CFMachPortCreateWithPort((CFAllocatorRef)*MEMORY[0x263EFFB08], *((_DWORD *)this + 82), MEMORY[0x263F0EBE0], &context, &shouldFreeInfo);
    *((void *)this + 40) = v4;
    if (v4)
    {
      RunLoopSource = CFMachPortCreateRunLoopSource(v3, v4, 0);
      *((void *)this + 42) = RunLoopSource;
      if (RunLoopSource)
      {
        CFRunLoopAddSource(*((CFRunLoopRef *)this + 1), RunLoopSource, (CFRunLoopMode)*MEMORY[0x263EFFE88]);
        return 0;
      }
    }
  }
  return v2;
}

uint64_t H16ISP::H16ISPBufferReceiver::removeBufferPoolFromBufferReceiver(H16ISP::H16ISPBufferReceiver *this, int a2)
{
  mach_port_name_t v4 = (pthread_mutex_t *)((char *)this + 192);
  pthread_mutex_lock((pthread_mutex_t *)this + 3);
  unint64_t v5 = *((void *)this + 51);
  uint64_t v6 = *((void *)this + 48);
  uint64_t v7 = *((void *)this + 49);
  unint64_t v8 = (char *)(v6 + 8 * (v5 >> 9));
  if (v7 == v6) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = (char *)(*(void *)v8 + 8 * (*((void *)this + 51) & 0x1FFLL));
  }
LABEL_4:
  uint64_t v10 = v9;
  while (1)
  {
    if (v7 == v6) {
      uint64_t v11 = 0;
    }
    else {
      uint64_t v11 = *(void *)(v6 + (((*((void *)this + 52) + v5) >> 6) & 0x3FFFFFFFFFFFFF8))
    }
          + 8 * ((*((void *)this + 52) + v5) & 0x1FF);
    if (v10 == (char *)v11)
    {
      uint64_t v14 = 3758097136;
      goto LABEL_23;
    }
    uint64_t v12 = *(void *)v10;
    if (*(_DWORD *)(*(void *)v10 + 20) == a2) {
      break;
    }
    v10 += 8;
    v9 += 8;
    if ((char *)(*(void *)v8 + 4096) == v9)
    {
      long long v13 = (char *)*((void *)v8 + 1);
      v8 += 8;
      uint64_t v9 = v13;
      goto LABEL_4;
    }
  }
  if ((*(_DWORD *)this - 1) > 1) {
    goto LABEL_22;
  }
  uint64_t v15 = (pthread_mutex_t *)((char *)this + 256);
  pthread_mutex_lock((pthread_mutex_t *)this + 4);
  *(unsigned char *)(v12 + 144) = 1;
  pthread_mutex_unlock((pthread_mutex_t *)this + 4);
  uint64_t v14 = H16ISP::H16ISPDevice::ReturnAllBuffersInPool(*((H16ISP::H16ISPDevice **)this + 43), 0, a2);
  if (!v14)
  {
    int v16 = 2001;
    while (1)
    {
      pthread_mutex_lock(v15);
      int v17 = *(_DWORD *)(v12 + 120);
      pthread_mutex_unlock(v15);
      if (!v17) {
        break;
      }
      usleep(0x3E8u);
      if (!--v16)
      {
        int v18 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
        {
          int v18 = os_log_create("com.apple.isp", "general");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v18;
        }
        uint64_t v14 = 3758097084;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPBufferReceiver::removeBufferPoolFromBufferReceiver((_DWORD *)(v12 + 20), v12 + 120, v18);
        }
        goto LABEL_23;
      }
    }
LABEL_22:
    std::deque<H16ISP::H16ISPFrameReceiverBufferPool *>::erase((int64x2_t *)((char *)this + 376), v8, v9);
    H16ISP::H16ISPFrameReceiverBufferPool::~H16ISPFrameReceiverBufferPool((H16ISP::H16ISPFrameReceiverBufferPool *)v12);
    MEMORY[0x24C53D6E0]();
    uint64_t v14 = 0;
  }
LABEL_23:
  pthread_mutex_unlock(v4);
  return v14;
}

uint64_t H16ISP::H16ISPBufferReceiver::addBufferPoolToBufferReceiver(uint64_t a1, uint64_t a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, int a10, int a11, int a12, int a13, int a14)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  int v18 = (pthread_mutex_t *)(a1 + 192);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 192));
  unint64_t v19 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    unint64_t v19 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v19;
  }
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    buf[0] = 136316931;
    *(void *)&buf[1] = "addBufferPoolToBufferReceiver";
    __int16 v31 = 1024;
    int v32 = a3;
    __int16 v33 = 1025;
    int v34 = a4;
    __int16 v35 = 1025;
    int v36 = a5;
    __int16 v37 = 1025;
    int v38 = a8;
    __int16 v39 = 1024;
    int v40 = a14;
    __int16 v41 = 1024;
    int v42 = a11;
    __int16 v43 = 1024;
    int v44 = a13;
    _os_log_impl(&dword_24680F000, v19, OS_LOG_TYPE_DEFAULT, "%s - PoolID:0x%x W:%{private}u H:%{private}u FMT:%{private}u Option:%u BufCnt:%u PrimeCnt:%u\n", (uint8_t *)buf, 0x36u);
  }
  unint64_t v20 = *(void *)(a1 + 408);
  uint64_t v21 = *(void *)(a1 + 384);
  uint64_t v22 = *(void *)(a1 + 392);
  long long v23 = (void *)(v21 + 8 * (v20 >> 9));
  if (v22 == v21) {
    uint64_t v24 = 0;
  }
  else {
    uint64_t v24 = *v23 + 8 * (*(void *)(a1 + 408) & 0x1FFLL);
  }
LABEL_8:
  uint64_t v25 = v24 - 4096;
  while (1)
  {
    uint64_t v26 = v22 == v21
        ? 0
        : *(void *)(v21 + (((*(void *)(a1 + 416) + v20) >> 6) & 0x3FFFFFFFFFFFFF8))
        + 8 * ((*(void *)(a1 + 416) + v20) & 0x1FF);
    if (v24 == v26) {
      operator new();
    }
    if (*(_DWORD *)(*(void *)v24 + 20) == a3) {
      break;
    }
    v24 += 8;
    v25 += 8;
    if (*v23 == v25)
    {
      uint64_t v27 = v23[1];
      ++v23;
      uint64_t v24 = v27;
      goto LABEL_8;
    }
  }
  pthread_mutex_unlock(v18);
  return 3758097122;
}

void sub_2469586FC(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x10E0C404726C66ELL);
  _Unwind_Resume(a1);
}

uint64_t H16ISP::H16ISPBufferReceiver::sendInitialBuffersToFirmware(H16ISP::H16ISPBufferReceiver *this, H16ISP::H16ISPFrameReceiverBufferPool *a2)
{
  MEMORY[0x270FA5388](this, a2);
  CFAllocatorRef v3 = v2;
  uint64_t v24 = *MEMORY[0x263EF8340];
  mach_port_name_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v5 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    mach_port_name_t v4 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *((_DWORD *)v3 + 5);
    int v7 = *((_DWORD *)v3 + 25);
    int v8 = *((_DWORD *)v3 + 28);
    int v9 = *((_DWORD *)v3 + 29);
    *(_DWORD *)buf = 136316162;
    uint64_t v15 = "sendInitialBuffersToFirmware";
    __int16 v16 = 1024;
    int v17 = v8;
    __int16 v18 = 1024;
    int v19 = v6;
    __int16 v20 = 1024;
    int v21 = v7;
    __int16 v22 = 1024;
    int v23 = v9;
    _os_log_impl(&dword_24680F000, v4, OS_LOG_TYPE_DEFAULT, "%s - Sending %d initial buffers to firmware (PoolID:0x%x, poolSize=%d), 0x%08x\n", buf, 0x24u);
  }
  uint64_t v10 = 3758097084;
  if (*((_DWORD *)v3 + 28))
  {
    CVPixelBufferRef pixelBuffer = 0;
    if (!H16ISP::H16ISPFrameReceiverBufferPool::allocateBuffer(v3, &pixelBuffer, 1)) {
      operator new();
    }
    uint64_t v11 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v5)
    {
      uint64_t v11 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v11;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPBufferReceiver::sendInitialBuffersToFirmware();
    }
    return 3758097085;
  }
  return v10;
}

uint64_t H16ISP::H16ISPBufferReceiver::getBufferPool(H16ISP::H16ISPBufferReceiver *this, int a2)
{
  unint64_t v2 = *((void *)this + 51);
  uint64_t v3 = *((void *)this + 48);
  uint64_t v4 = *((void *)this + 49);
  uint64_t v5 = (void *)(v3 + 8 * (v2 >> 9));
  if (v4 == v3) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *v5 + 8 * (*((void *)this + 51) & 0x1FFLL);
  }
LABEL_4:
  uint64_t v7 = v6 - 4096;
  while (1)
  {
    uint64_t v8 = v4 == v3
       ? 0
       : *(void *)(v3 + (((*((void *)this + 52) + v2) >> 6) & 0x3FFFFFFFFFFFFF8))
       + 8 * ((*((void *)this + 52) + v2) & 0x1FF);
    if (v6 == v8) {
      return 0;
    }
    uint64_t v9 = *(void *)v6;
    if (*(_DWORD *)(*(void *)v6 + 20) == a2) {
      return v9;
    }
    v6 += 8;
    v7 += 8;
    if (*v5 == v7)
    {
      uint64_t v10 = v5[1];
      ++v5;
      uint64_t v6 = v10;
      goto LABEL_4;
    }
  }
}

uint64_t H16ISP::H16ISPBufferReceiver::registerBufferReceiveCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 160) = a2;
  *(void *)(a1 + 168) = a3;
  return 0;
}

uint64_t H16ISP::H16ISPBufferReceiver::registerMessageCallback(H16ISP::H16ISPBufferReceiver *this, void (*a2)(unsigned int, unsigned int, unsigned int, void *, void *, void *), void *a3)
{
  *((void *)this + 22) = a2;
  *((void *)this + 23) = a3;
  return 0;
}

uint64_t H16ISP::H16ISPBufferReceiver::startReceive(pthread_mutex_t *this)
{
  unint64_t v2 = this + 3;
  pthread_mutex_lock(this + 3);
  if (LODWORD(this->__sig))
  {
    pthread_mutex_unlock(v2);
    return 3758097122;
  }
  kdebug_trace();
  this[5].__opaque[24] = 0;
  LODWORD(this->__sig) = 1;
  uint64_t sig = this[6].__sig;
  if (this[7].__opaque[24])
  {
    uint64_t v5 = *(void *)this[6].__opaque;
    goto LABEL_29;
  }
  uint64_t v6 = (void *)(sig + 8 * (*(void *)&this[6].__opaque[16] >> 9));
  uint64_t v5 = *(void *)this[6].__opaque;
  if (v5 == sig) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = (H16ISP::H16ISPFrameReceiverBufferPool **)(*v6 + 8 * (*(void *)&this[6].__opaque[16] & 0x1FFLL));
  }
  while (v5 != sig)
  {
    unint64_t v8 = *(void *)&this[6].__opaque[24] + *(void *)&this[6].__opaque[16];
    if (v7 == (H16ISP::H16ISPFrameReceiverBufferPool **)(*(void *)(sig + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8))
                                                        + 8 * (v8 & 0x1FF)))
    {
      this[7].__opaque[24] = 1;
      uint64_t v10 = (void *)(sig + 8 * (*(void *)&this[6].__opaque[16] >> 9));
      uint64_t v7 = (H16ISP::H16ISPFrameReceiverBufferPool **)(*v10 + 8 * (*(void *)&this[6].__opaque[16] & 0x1FFLL));
      goto LABEL_25;
    }
LABEL_12:
    if (H16ISP::H16ISPFrameReceiverBufferPool::activatePool(*v7, 0))
    {
      uint64_t v3 = 3758097085;
      goto LABEL_43;
    }
    if ((H16ISP::H16ISPFrameReceiverBufferPool **)((char *)++v7 - *v6) == (H16ISP::H16ISPFrameReceiverBufferPool **)4096)
    {
      uint64_t v9 = (H16ISP::H16ISPFrameReceiverBufferPool **)v6[1];
      ++v6;
      uint64_t v7 = v9;
    }
    uint64_t sig = this[6].__sig;
    uint64_t v5 = *(void *)this[6].__opaque;
  }
  if (v7) {
    goto LABEL_12;
  }
  this[7].__opaque[24] = 1;
  uint64_t v10 = (void *)(sig + 8 * (*(void *)&this[6].__opaque[16] >> 9));
LABEL_25:
  while (1)
  {
    if (v5 == sig)
    {
      uint64_t v16 = 0;
    }
    else
    {
      unint64_t v15 = *(void *)&this[6].__opaque[24] + *(void *)&this[6].__opaque[16];
      uint64_t v16 = *(void *)(sig + ((v15 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v15 & 0x1FF);
    }
    if (v7 == (H16ISP::H16ISPFrameReceiverBufferPool **)v16) {
      break;
    }
    uint64_t v11 = *(void (**)(uint64_t, void, void, uint64_t, void, void))&this[2].__opaque[40];
    if (v11)
    {
      uint64_t v12 = *v7;
      uint64_t v13 = *((void *)*v7 + 23);
      if (!v13) {
        uint64_t v13 = *((void *)v12 + 20);
      }
      v11(7, *((unsigned int *)v12 + 4), 0, v13, *((void *)v12 + 21), *(void *)&this[2].__opaque[48]);
    }
    if ((H16ISP::H16ISPFrameReceiverBufferPool **)((char *)++v7 - *v10) == (H16ISP::H16ISPFrameReceiverBufferPool **)4096)
    {
      uint64_t v14 = (H16ISP::H16ISPFrameReceiverBufferPool **)v10[1];
      ++v10;
      uint64_t v7 = v14;
    }
    uint64_t sig = this[6].__sig;
    uint64_t v5 = *(void *)this[6].__opaque;
  }
LABEL_29:
  int v17 = (void *)(sig + 8 * (*(void *)&this[6].__opaque[16] >> 9));
  if (v5 == sig) {
    __int16 v18 = 0;
  }
  else {
    __int16 v18 = (H16ISP::H16ISPFrameReceiverBufferPool **)(*v17 + 8 * (*(void *)&this[6].__opaque[16] & 0x1FFLL));
  }
  while (1)
  {
    if (*(void *)this[6].__opaque == sig)
    {
      uint64_t v22 = 0;
    }
    else
    {
      unint64_t v21 = *(void *)&this[6].__opaque[24] + *(void *)&this[6].__opaque[16];
      uint64_t v22 = *(void *)(sig + ((v21 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v21 & 0x1FF);
    }
    if (v18 == (H16ISP::H16ISPFrameReceiverBufferPool **)v22)
    {
      uint64_t v3 = 0;
      goto LABEL_43;
    }
    if ((*((unsigned char *)*v18 + 116) & 1) == 0)
    {
      uint64_t v19 = H16ISP::H16ISPBufferReceiver::sendInitialBuffersToFirmware((H16ISP::H16ISPBufferReceiver *)this, *v18);
      if (v19) {
        break;
      }
    }
    if ((H16ISP::H16ISPFrameReceiverBufferPool **)((char *)++v18 - *v17) == (H16ISP::H16ISPFrameReceiverBufferPool **)4096)
    {
      __int16 v20 = (H16ISP::H16ISPFrameReceiverBufferPool **)v17[1];
      ++v17;
      __int16 v18 = v20;
    }
    uint64_t sig = this[6].__sig;
  }
  uint64_t v3 = v19;
LABEL_43:
  pthread_mutex_unlock(v2);
  kdebug_trace();
  return v3;
}

uint64_t H16ISP::H16ISPBufferReceiver::ProcessFrameMetadata(H16ISP::H16ISPBufferReceiver *this, unsigned int a2, __CVBuffer *a3, unint64_t *a4)
{
  uint64_t CameraTime = H16ISP::H16ISPDevice::ISP_GetCameraTime(*((void *)this + 43), &v8);
  if (!CameraTime) {
    operator new();
  }
  uint64_t v5 = CameraTime;
  uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    uint64_t v6 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
    H16ISP::H16ISPFrameReceiver::ProcessFrameMetadata();
  }
  return v5;
}

void sub_246958EA0(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x1020C405A04CE29);
  _Unwind_Resume(a1);
}

void H16ISP::H16ISPBufferReceiver::BufferDone(H16ISP::H16ISPBufferReceiver *this, void *a2, int a3, unint64_t *a4)
{
  uint64_t v4 = MEMORY[0x270FA5388](this, a2);
  int v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v4;
  uint64_t v67 = *MEMORY[0x263EF8340];
  uint64_t v57 = mach_absolute_time();
  kdebug_trace();
  pthread_mutex_lock((pthread_mutex_t *)(v9 + 256));
  uint64_t v10 = (v6 - 2);
  if (v6 != 2)
  {
    uint64_t v11 = 0;
    char v56 = 0;
    unsigned int v58 = 0;
    unint64_t v59 = 0;
    do
    {
      CVPixelBufferRef pixelBuffer = 0;
      unint64_t v12 = *(void *)(v9 + 456);
      uint64_t v13 = *(void *)(v9 + 432);
      uint64_t v14 = *(void *)(v9 + 440);
      uint64_t v15 = v13 + 8 * (v12 >> 9);
      if (v14 == v13) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = (char *)(*(void *)v15 + 8 * (*(void *)(v9 + 456) & 0x1FFLL));
      }
      uint64_t v17 = (v11 + 2);
LABEL_7:
      __int16 v18 = v16;
      while (1)
      {
        uint64_t v19 = v14 == v13
            ? 0
            : *(void *)(v13 + (((*(void *)(v9 + 464) + v12) >> 6) & 0x3FFFFFFFFFFFFF8))
            + 8 * ((*(void *)(v9 + 464) + v12) & 0x1FF);
        if (v18 == (char *)v19) {
          break;
        }
        uint64_t v20 = *(void *)v18;
        if (*(void *)(v8 + 8 * v17) == *(_DWORD *)(*(void *)v18 + 8))
        {
          uint64_t v23 = *(void *)(v20 + 16);
          --*(_DWORD *)(v23 + 120);
          if (*(unsigned char *)(v9 + 352) || *(unsigned char *)(v23 + 144))
          {
            H16ISP::H16ISPFrameReceiverBufferPool::updateTracking((H16ISP::H16ISPFrameReceiverBufferPool *)v23);
            CVPixelBufferRelease(*(CVPixelBufferRef *)v20);
            std::deque<H16ISP::H16ISPFrameReceiverBufferPool *>::erase((int64x2_t *)(v9 + 424), (char *)v15, v16);
            MEMORY[0x24C53D6E0](v20, 0x1020C4093CA8EA1);
          }
          else
          {
            H16ISP::H16ISPFrameReceiverBufferPool::allocateBuffer((H16ISP::H16ISPFrameReceiverBufferPool *)v23, &pixelBuffer, 0);
            if (!pixelBuffer) {
              goto LABEL_29;
            }
            uint64_t v24 = *(H16ISP::H16ISPFrameReceiverBufferPool **)(v20 + 16);
            if (*((_DWORD *)v24 + 5) != 43
              || (uint64_t v25 = &v66[v58],
                  *(void *)uint64_t v25 = *(void *)v20,
                  *((_DWORD *)v25 + 2) = *((_DWORD *)v24 + 4),
                  *((_DWORD *)v25 + 3) = 43,
                  H16ISP::H16ISPFrameReceiverBufferPool::updateTracking(v24),
                  CVPixelBufferRetain(*(CVPixelBufferRef *)v20),
                  ++v58,
                  pixelBuffer))
            {
              CVPixelBufferRelease(*(CVPixelBufferRef *)v20);
              *(void *)uint64_t v20 = pixelBuffer;
              IOSurface = CVPixelBufferGetIOSurface(pixelBuffer);
              IOSurfaceID ID = IOSurfaceGetID(IOSurface);
              *(_DWORD *)(v20 + 8) = ID;
              uint64_t v28 = &v65[7 * v59];
              *uint64_t v28 = H16ISP::H16ISPBufferReceiver::BufferDone;
              v28[1] = v9;
              *((_DWORD *)v28 + 4) = ID;
              uint64_t v29 = *(void *)(v20 + 16);
              *(void *)&long long v30 = *(void *)(v29 + 24);
              DWORD2(v30) = *(_DWORD *)(v29 + 40);
              HIDWORD(v30) = *(_DWORD *)(v29 + 20);
              *(_OWORD *)((char *)v28 + 20) = v30;
              ++v59;
            }
            else
            {
LABEL_29:
              __int16 v31 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
              if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
              {
                __int16 v31 = os_log_create("com.apple.isp", "general");
                GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v31;
              }
              BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
              __int16 v33 = *(H16ISP::H16ISPFrameReceiverBufferPool **)(v20 + 16);
              if (v32)
              {
                int v38 = *((_DWORD *)v33 + 5);
                int v39 = *((_DWORD *)v33 + 30);
                *(_DWORD *)buf = 136315650;
                uint16x8_t v62 = "BufferDone";
                __int16 v63 = 1024;
                LODWORD(v64[0]) = v38;
                WORD2(v64[0]) = 1024;
                *(_DWORD *)((char *)v64 + 6) = v39;
                _os_log_error_impl(&dword_24680F000, v31, OS_LOG_TYPE_ERROR, "%s - Unable to allocate a replacement buffer (PoolID:0x%x / InFW:%u)\n", buf, 0x18u);
                __int16 v33 = *(H16ISP::H16ISPFrameReceiverBufferPool **)(v20 + 16);
              }
              H16ISP::H16ISPFrameReceiverBufferPool::updateTracking(v33);
              int v34 = &v65[7 * v59];
              *int v34 = H16ISP::H16ISPBufferReceiver::BufferDone;
              v34[1] = v9;
              *((_DWORD *)v34 + 4) = *(_DWORD *)(v20 + 8);
              uint64_t v35 = *(void *)(v20 + 16);
              *(void *)&long long v36 = *(void *)(v35 + 24);
              DWORD2(v36) = *(_DWORD *)(v35 + 40);
              HIDWORD(v36) = *(_DWORD *)(v35 + 20);
              *(_OWORD *)((char *)v34 + 20) = v36;
              ++v59;
              char v56 = 1;
            }
          }
          goto LABEL_23;
        }
        v18 += 8;
        v16 += 8;
        if ((char *)(*(void *)v15 + 4096) == v16)
        {
          unint64_t v21 = *(char **)(v15 + 8);
          v15 += 8;
          uint64_t v16 = v21;
          goto LABEL_7;
        }
      }
      uint64_t v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
      {
        uint64_t v22 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v22;
      }
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = *(void *)(v8 + 8 * v17);
        *(_DWORD *)buf = 136315394;
        uint16x8_t v62 = "BufferDone";
        __int16 v63 = 1024;
        LODWORD(v64[0]) = v37;
        _os_log_error_impl(&dword_24680F000, v22, OS_LOG_TYPE_ERROR, "%s - Unable to locate surface ID %d\n", buf, 0x12u);
      }
LABEL_23:
      ++v11;
    }
    while (v11 != v10);
    if (v59)
    {
      if (H16ISP::H16ISPDevice::ISP_SendBuffers(*(void *)(v9 + 344), v65, v59, *(_DWORD *)(v9 + 328)))
      {
        int v40 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
        {
          int v40 = os_log_create("com.apple.isp", "general");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v40;
        }
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPBufferReceiver::BufferDone();
        }
      }
      else
      {
        uint64_t v41 = 0;
        unint64_t v42 = *(void *)(v9 + 408);
        uint64_t v43 = *(void *)(v9 + 384);
        uint64_t v44 = *(void *)(v9 + 392);
        do
        {
          if (v44 == v43) {
            uint64_t v45 = 0;
          }
          else {
            uint64_t v45 = *(void *)(v43 + 8 * (v42 >> 9)) + 8 * (v42 & 0x1FF);
          }
          long long v46 = (void *)(v43 + 8 * (v42 >> 9));
LABEL_45:
          uint64_t v47 = v45 - 4096;
          while (1)
          {
            uint64_t v48 = v44 == v43
                ? 0
                : *(void *)(v43 + (((*(void *)(v9 + 416) + v42) >> 6) & 0x3FFFFFFFFFFFFF8))
                + 8 * ((*(void *)(v9 + 416) + v42) & 0x1FF);
            if (v45 == v48) {
              break;
            }
            if (*(_DWORD *)(*(void *)v45 + 20) == LODWORD(v65[7 * v41 + 4]))
            {
              ++*(_DWORD *)(*(void *)v45 + 120);
              break;
            }
            v45 += 8;
            v47 += 8;
            if (*v46 == v47)
            {
              uint64_t v49 = v46[1];
              ++v46;
              uint64_t v45 = v49;
              goto LABEL_45;
            }
          }
          ++v41;
        }
        while (v59 > v41);
      }
    }
    if (v58)
    {
      int v50 = *(void (**)(void, void, void, _OWORD *))(v9 + 160);
      if (v50) {
        v50(*(void *)(v9 + 168), 0, v58, v66);
      }
    }
    if ((v56 & 1) != 0 && *(void *)(v9 + 176))
    {
      uint64_t v51 = mach_absolute_time();
      (*(void (**)(void, uint64_t, uint64_t, void, void, void))(v9 + 176))(0, HIDWORD(v51), v51, 0, 0, *(void *)(v9 + 184));
    }
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v9 + 256));
  uint64_t v52 = mach_absolute_time();
  mach_timebase_info((mach_timebase_info_t)&pixelBuffer);
  unint64_t v53 = (v52 - v57) * pixelBuffer / HIDWORD(pixelBuffer);
  unint64_t v54 = (v53 * (unsigned __int128)0x431BDE82D7B634DBuLL) >> 64;
  if (v53 < 0x30A32C0)
  {
    kdebug_trace();
  }
  else
  {
    kdebug_trace();
    int16x8_t v55 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      int16x8_t v55 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v55;
    }
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315394;
      uint16x8_t v62 = "BufferDone";
      __int16 v63 = 2048;
      v64[0] = v54 >> 18;
      _os_log_impl(&dword_24680F000, v55, OS_LOG_TYPE_DEFAULT, "%s - Long Delay: %llu msec\n", buf, 0x16u);
    }
  }
}

uint64_t H16ISP::H16ISPBufferReceiver::startNoBufferAvailableTimer(H16ISP::H16ISPBufferReceiver *this)
{
  unint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    unint64_t v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
    H16ISP::H16ISPBufferReceiver::startNoBufferAvailableTimer(v2);
  }
  uint64_t result = pthread_mutex_lock((pthread_mutex_t *)((char *)this + 88));
  if (!*((void *)this + 19))
  {
    context.version = 0;
    context.info = this;
    memset(&context.retain, 0, 24);
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    int v5 = CFRunLoopTimerCreate(0, Current + 0.01, 0.0, 0, 0, (CFRunLoopTimerCallBack)H16ISP::H16ISPBufferReceiver::TryToTopOffFirmwareBufferPools, &context);
    *((void *)this + 19) = v5;
    if (v5) {
      CFRunLoopAddTimer(*((CFRunLoopRef *)this + 1), v5, (CFRunLoopMode)*MEMORY[0x263EFFE88]);
    }
    return pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 88));
  }
  return result;
}

uint64_t H16ISP::H16ISPBufferReceiver::TryToTopOffFirmwareBufferPools(H16ISP::H16ISPBufferReceiver *this, __CFRunLoopTimer *a2, void *a3)
{
  MEMORY[0x270FA5388](this, a2);
  uint64_t v4 = v3;
  uint64_t v32 = *MEMORY[0x263EF8340];
  int v5 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    int v5 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v5;
  }
  CVPixelBufferRef pixelBuffer = 0;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    __int16 v31 = "TryToTopOffFirmwareBufferPools";
    _os_log_impl(&dword_24680F000, v5, OS_LOG_TYPE_DEFAULT, "%s - \n", buf, 0xCu);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v4 + 256));
  H16ISP::H16ISPBufferReceiver::stopNoBufferAvailableTimer((H16ISP::H16ISPBufferReceiver *)v4);
  uint64_t v6 = *(void *)(v4 + 384);
  uint64_t v7 = *(void *)(v4 + 392);
  uint64_t v8 = (void *)(v6 + 8 * (*(void *)(v4 + 408) >> 9));
  if (v7 == v6) {
    uint64_t v9 = 0;
  }
  else {
    uint64_t v9 = *v8 + 8 * (*(void *)(v4 + 408) & 0x1FFLL);
  }
  char v10 = 0;
  while (1)
  {
    if (v7 == v6)
    {
      uint64_t v12 = 0;
    }
    else
    {
      unint64_t v11 = *(void *)(v4 + 416) + *(void *)(v4 + 408);
      uint64_t v12 = *(void *)(v6 + ((v11 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v11 & 0x1FF);
    }
    if (v9 == v12) {
      break;
    }
    uint64_t v13 = *(void *)v9;
    if (*(_DWORD *)(*(void *)v9 + 112) > *(_DWORD *)(*(void *)v9 + 120)
      && !*(unsigned char *)(v4 + 352)
      && !*(unsigned char *)(v13 + 144))
    {
      H16ISP::H16ISPFrameReceiverBufferPool::allocateBuffer((H16ISP::H16ISPFrameReceiverBufferPool *)v13, &pixelBuffer, 0);
      if (pixelBuffer)
      {
        *(void *)uint64_t v23 = 0;
        operator new();
      }
      unsigned int v14 = *(_DWORD *)(v13 + 120);
      if (v14 < *(_DWORD *)(v13 + 112))
      {
        uint64_t v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
        {
          uint64_t v15 = os_log_create("com.apple.isp", "general");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v15;
        }
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = *(_DWORD *)(v13 + 20);
          uint64_t v17 = "noBuffer";
          if (v14) {
            uint64_t v17 = "lowBuffer";
          }
          *(_DWORD *)uint64_t v23 = 136315906;
          *(void *)&v23[4] = "TryToTopOffFirmwareBufferPools";
          __int16 v24 = 2080;
          uint64_t v25 = v17;
          __int16 v26 = 1024;
          int v27 = v16;
          __int16 v28 = 1024;
          unsigned int v29 = v14;
          _os_log_impl(&dword_24680F000, v15, OS_LOG_TYPE_DEFAULT, "%s - %s on receiver PoolID 0x%x, FW has %d buffers\n", v23, 0x22u);
        }
        __int16 v18 = *(void (**)(BOOL, void, void, uint64_t, uint64_t, void))(v4 + 176);
        if (v18) {
          v18(v14 != 0, 0, *(unsigned int *)(v13 + 16), v13, v4, *(void *)(v4 + 184));
        }
        char v10 = 1;
      }
    }
    v9 += 8;
    if (v9 - *v8 == 4096)
    {
      uint64_t v19 = v8[1];
      ++v8;
      uint64_t v9 = v19;
    }
    uint64_t v6 = *(void *)(v4 + 384);
    uint64_t v7 = *(void *)(v4 + 392);
  }
  if (v10)
  {
    H16ISP::H16ISPBufferReceiver::startNoBufferAvailableTimer((H16ISP::H16ISPBufferReceiver *)v4);
  }
  else
  {
    uint64_t v20 = *(void (**)(uint64_t, void, void, void, uint64_t, void))(v4 + 176);
    if (v20) {
      v20(2, 0, 0, 0, v4, *(void *)(v4 + 184));
    }
  }
  return pthread_mutex_unlock((pthread_mutex_t *)(v4 + 256));
}

uint64_t H16ISP::H16ISPBufferReceiver::stopNoBufferAvailableTimer(H16ISP::H16ISPBufferReceiver *this)
{
  unint64_t v2 = (pthread_mutex_t *)((char *)this + 88);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 88));
  uint64_t v3 = (__CFRunLoopTimer *)*((void *)this + 19);
  if (v3)
  {
    CFRunLoopTimerInvalidate(v3);
    CFRelease(*((CFTypeRef *)this + 19));
    *((void *)this + 19) = 0;
  }

  return pthread_mutex_unlock(v2);
}

void std::deque<H16ISP::H16ISPBufferReceiverAllocatedBufferStruct *>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<H16ISP::H16ISPBufferReceiverAllocatedBufferStruct *>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

uint64_t H16ISP::H16ISPBufferReceiver::AllocateAndSendOneShotBuffers()
{
  return 3758097095;
}

uint64_t H16ISP::H16ISPBufferReceiver::AllocateOneShotBuffer()
{
  return 3758097095;
}

BOOL H16ISP::H16ISPBufferReceiver::HasPool(H16ISP::H16ISPBufferReceiver *this, int a2)
{
  return H16ISP::H16ISPBufferReceiver::getBufferPool(this, a2) != 0;
}

uint64_t H16ISP::CreateH16ISPBufferReceiver(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  pthread_t v6 = 0;
  H16ISP::H16ISPThreadReadySyncer::H16ISPThreadReadySyncer((H16ISP::H16ISPThreadReadySyncer *)&v12);
  uint64_t v7 = 0;
  long long v2 = *(_OWORD *)(a1 + 32);
  long long v8 = *(_OWORD *)(a1 + 16);
  long long v9 = v2;
  uint64_t v10 = *(void *)(a1 + 8);
  unint64_t v11 = &v12;
  uint64_t v5 = 48;
  pthread_attr_init(&v13);
  pthread_attr_setschedparam(&v13, (const sched_param *)&v5);
  pthread_attr_setdetachstate(&v13, 2);
  pthread_create(&v6, &v13, (void *(__cdecl *)(void *))H16ISP::H16ISPBufferReceiverRTThreadMain, &v7);
  pthread_attr_destroy(&v13);
  H16ISP::H16ISPThreadReadySyncer::wait(&v12);
  **(void **)a1 = v7;
  if (v7) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 3758097084;
  }
  H16ISP::H16ISPThreadReadySyncer::~H16ISPThreadReadySyncer((H16ISP::H16ISPThreadReadySyncer *)&v12);
  return v3;
}

void sub_246959DC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

void H16ISP::H16ISPBufferReceiverRTThreadMain(uint64_t a1)
{
}

void sub_246959F44(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x10A0C401EE1CF77);
  _Unwind_Resume(a1);
}

uint64_t H16ISP::DestroyH16ISPBufferReceiver(H16ISP *this, H16ISP::H16ISPBufferReceiver *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  uint64_t v3 = (void *)*((void *)this + 1);
  CFRetain(v3);
  uint64_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v5 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    uint64_t v4 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
  }
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    pthread_mutex_t v12 = "DestroyH16ISPBufferReceiver";
    _os_log_impl(&dword_24680F000, v4, OS_LOG_TYPE_DEFAULT, "%s - Stopping\n", buf, 0xCu);
  }
  pthread_t v6 = dispatch_group_create();
  dispatch_group_enter(v6);
  uint64_t v7 = (const void *)*MEMORY[0x263EFFE88];
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZN6H16ISP27DestroyH16ISPBufferReceiverEPNS_20H16ISPBufferReceiverE_block_invoke;
  block[3] = &__block_descriptor_tmp_10;
  block[4] = this;
  block[5] = v3;
  block[6] = v6;
  CFRunLoopPerformBlock((CFRunLoopRef)v3, v7, block);
  CFRunLoopWakeUp((CFRunLoopRef)v3);
  dispatch_group_wait(v6, 0xFFFFFFFFFFFFFFFFLL);
  long long v8 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v5)
  {
    long long v8 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v8;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    pthread_mutex_t v12 = "DestroyH16ISPBufferReceiver";
    _os_log_impl(&dword_24680F000, v8, OS_LOG_TYPE_DEFAULT, "%s - Stopped\n", buf, 0xCu);
  }
  dispatch_release(v6);
  CFRelease(v3);
  return 0;
}

void ___ZN6H16ISP27DestroyH16ISPBufferReceiverEPNS_20H16ISPBufferReceiverE_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  long long v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    long long v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    uint64_t v5 = "DestroyH16ISPBufferReceiver_block_invoke";
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "%s - Stopping in the runloop\n", (uint8_t *)&v4, 0xCu);
  }
  uint64_t v3 = *(H16ISP::H16ISPBufferReceiver **)(a1 + 32);
  if (v3)
  {
    H16ISP::H16ISPBufferReceiver::~H16ISPBufferReceiver(v3);
    MEMORY[0x24C53D6E0]();
  }
  CFRunLoopStop(*(CFRunLoopRef *)(a1 + 40));
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
}

void std::deque<H16ISP::H16ISPBufferReceiverAllocatedBufferStruct *>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    uint64_t v7 = (void *)a1[1];
    long long v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    long long v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)long long v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)std::allocator<__CVBuffer **>::allocate_at_least[abi:ne180100](v5, v33);
      uint64_t v35 = &v34[8 * (v33 >> 2)];
      uint64_t v37 = &v34[8 * v36];
      int v38 = (uint64_t *)a1[1];
      long long v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        long long v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        uint64_t v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)uint64_t v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    uint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      long long v9 = (char *)a1[1];
    }
    long long v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<__CVBuffer **>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<__CVBuffer **>::push_front((uint64_t)a1, &v54);
    uint64_t v44 = (void *)a1[1];
    long long v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    long long v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      int v34 = (char *)std::allocator<__CVBuffer **>::allocate_at_least[abi:ne180100]((uint64_t)(a1 + 3), v46);
      uint64_t v35 = &v34[8 * (v46 >> 2)];
      uint64_t v37 = &v34[8 * v47];
      uint64_t v48 = (uint64_t *)a1[1];
      long long v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        long long v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      uint64_t v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        long long v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  char v56 = a1 + 3;
  *(void *)&long long v54 = std::allocator<__CVBuffer **>::allocate_at_least[abi:ne180100]((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unint64_t v53 = operator new(0x1000uLL);
  std::__split_buffer<__CVBuffer **>::push_back(&v54, &v53);
  int v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<__CVBuffer **>::push_front((uint64_t)&v54, v27);
  }
  unsigned int v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_24695A538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void BayerArray::BayerArray(BayerArray *this)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = 0x43F800000;
}

{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((void *)this + 4) = 0x43F800000;
}

void BayerArray::BayerArray(BayerArray *this, const unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = a5;
  *((float *)this + 8) = 1.0 / (float)(unint64_t)(a5 * a4);
  *((_DWORD *)this + 9) = a6;
}

{
  *(void *)this = a2;
  *((void *)this + 1) = a3;
  *((void *)this + 2) = a4;
  *((void *)this + 3) = a5;
  *((float *)this + 8) = 1.0 / (float)(unint64_t)(a5 * a4);
  *((_DWORD *)this + 9) = a6;
}

float BayerArray::Average(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = 0;
    unint64_t v4 = 0;
    uint64_t v5 = *(void *)(a1 + 8);
    if (a2 >= 0) {
      int v6 = a2;
    }
    else {
      int v6 = a2 + 1;
    }
    uint64_t v7 = *(void *)a1 + 2 * v5 * ((uint64_t)v6 >> 1) + 2 * (int)(a2 - (v6 & 0xFFFFFFFE));
    uint64_t v8 = 4 * v5;
    do
    {
      if (*(void *)(a1 + 16))
      {
        uint64_t v9 = 0;
        uint64_t v10 = *(void *)(a1 + 16);
        do
        {
          v4 += (unint64_t)*(unsigned __int16 *)(v7 + v9) >> 4;
          v9 += 4;
          --v10;
        }
        while (v10);
      }
      ++v3;
      v7 += v8;
    }
    while (v3 != v2);
  }
  else
  {
    unint64_t v4 = 0;
  }
  return *(float *)(a1 + 32) * (float)v4;
}

float BayerArray::Average(BayerArray *this, float *a2, float *a3, float *a4, float *a5)
{
  uint64_t v5 = *((void *)this + 3);
  if (v5)
  {
    unint64_t v6 = 0;
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = 0;
    uint64_t v11 = *(unsigned __int16 **)this;
    uint64_t v12 = *((void *)this + 1);
    uint64_t v13 = v12;
    uint64_t v14 = 4 * v12;
    do
    {
      uint64_t v15 = v11;
      for (uint64_t i = *((void *)this + 2); i; --i)
      {
        v6 += *v15;
        v7 += v15[1];
        v8 += v15[v13];
        v9 += v15[v13 + 1];
        v15 += 2;
      }
      ++v10;
      uint64_t v11 = (unsigned __int16 *)((char *)v11 + v14);
    }
    while (v10 != v5);
  }
  else
  {
    unint64_t v9 = 0;
    unint64_t v8 = 0;
    unint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  int v17 = *((_DWORD *)this + 9);
  *a2 = *((float *)this + 8) * (float)(v6 >> v17);
  *a3 = *((float *)this + 8) * (float)(v7 >> v17);
  *a4 = *((float *)this + 8) * (float)(v8 >> v17);
  float result = *((float *)this + 8) * (float)(v9 >> v17);
  *a5 = result;
  return result;
}

uint64_t BayerArray::DefineSubBayerArray(BayerArray *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, BayerArray *a6, int a7)
{
  if (!a7) {
    goto LABEL_7;
  }
  uint64_t v7 = 0;
  if (((a3 | a2) & 0x8000000000000000) == 0 && ((a5 | a4) & 0x80000000) == 0)
  {
    if ((unint64_t)(a4 + a2) > *((void *)this + 2) || (unint64_t)(a5 + a3) > *((void *)this + 3)) {
      return 0;
    }
LABEL_7:
    uint64_t v8 = *((void *)this + 1);
    int v9 = *((_DWORD *)this + 9);
    *(void *)a6 = *(void *)this + 4 * (a2 + v8 * a3);
    *((void *)a6 + 1) = v8;
    *((void *)a6 + 2) = (int)a4;
    *((void *)a6 + 3) = (int)a5;
    *((float *)a6 + 8) = 1.0 / (float)(a5 * a4);
    *((_DWORD *)a6 + 9) = v9;
    return 1;
  }
  return v7;
}

uint64_t BayerArray::Dump(uint64_t this, unsigned int a2)
{
  if (a2)
  {
    uint64_t v2 = this;
    if (*(void *)this && *(void *)(this + 16) && (uint64_t v3 = *(void *)(this + 24)) != 0)
    {
      this = printf("[base=%p, width = %zd, height = %zd]\n", *(const void **)this, *(void *)(this + 16), v3);
      if (*(void *)(v2 + 24))
      {
        uint64_t v5 = 0;
        uint64_t v6 = 0;
        if (a2 >= 2) {
          uint64_t v7 = "/";
        }
        else {
          uint64_t v7 = "";
        }
        if (a2 >= 4) {
          uint64_t v8 = "/";
        }
        else {
          uint64_t v8 = "";
        }
        if (a2 >= 8) {
          int v9 = "/";
        }
        else {
          int v9 = "";
        }
        for (uint64_t i = 2; ; i += 4)
        {
          uint64_t v13 = v6;
          if (*(void *)(v2 + 16)) {
            break;
          }
LABEL_29:
          this = putchar(10);
          uint64_t v6 = v13 + 1;
          v5 += 4;
          if ((unint64_t)(v13 + 1) >= *(void *)(v2 + 24)) {
            return this;
          }
        }
        uint64_t v11 = 0;
        unint64_t v12 = 0;
        while (1)
        {
          if (a2)
          {
            printf("%5d%s", *(unsigned __int16 *)(*(void *)v2 + v5 * *(void *)(v2 + 8) + v11) >> *(_DWORD *)(v2 + 36), v7);
            if ((a2 & 2) == 0)
            {
LABEL_20:
              if ((a2 & 4) != 0) {
                goto LABEL_27;
              }
              goto LABEL_21;
            }
          }
          else if ((a2 & 2) == 0)
          {
            goto LABEL_20;
          }
          printf("%5d%s", *(unsigned __int16 *)(*(void *)v2 + v5 * *(void *)(v2 + 8) + v11 + 2) >> *(_DWORD *)(v2 + 36), v8);
          if ((a2 & 4) != 0)
          {
LABEL_27:
            printf("%5d%s", *(unsigned __int16 *)(*(void *)v2 + i * *(void *)(v2 + 8) + v11) >> *(_DWORD *)(v2 + 36), v9);
            if ((a2 & 8) == 0) {
              goto LABEL_23;
            }
LABEL_22:
            printf("%5d  ", *(unsigned __int16 *)(*(void *)v2 + i * *(void *)(v2 + 8) + v11 + 2) >> *(_DWORD *)(v2 + 36));
            goto LABEL_23;
          }
LABEL_21:
          if ((a2 & 8) != 0) {
            goto LABEL_22;
          }
LABEL_23:
          ++v12;
          v11 += 4;
          if (v12 >= *(void *)(v2 + 16)) {
            goto LABEL_29;
          }
        }
      }
    }
    else
    {
      return puts("BayerArray::Dump -- empty array");
    }
  }
  return this;
}

uint64_t BayerArray::GetPackedPixel(BayerArray *this, unint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  switch(a4)
  {
    case 14:
      unint64_t v7 = *(void *)this + ((a5 * a3) & 0xFFFFFFFFFFFFFFFCLL) + 28 * (a2 >> 4);
      switch(a2 & 0xF)
      {
        case 1uLL:
          uint64_t result = (*(_DWORD *)v7 >> 2) & 0x3FC0 | (*(_DWORD *)(v7 + 4) >> 6) & 0x3Fu;
          break;
        case 2uLL:
          uint64_t result = (*(_DWORD *)v7 >> 10) & 0x3FC0 | (*(_DWORD *)(v7 + 4) >> 12) & 0x3Fu;
          break;
        case 3uLL:
          uint64_t result = (*(_DWORD *)v7 >> 18) & 0x3FC0 | (*(_DWORD *)(v7 + 4) >> 18) & 0x3Fu;
          break;
        case 4uLL:
          int v14 = HIBYTE(*(_DWORD *)(v7 + 4));
          LOBYTE(v7) = *(unsigned char *)(v7 + 11);
          goto LABEL_44;
        case 5uLL:
          uint64_t result = (*(_DWORD *)(v7 + 8) >> 30) & 0xFFFFC003 | (*(_DWORD *)(v7 + 8) << 6) | (4 * (*(_DWORD *)(v7 + 12) & 0xF));
          break;
        case 6uLL:
          uint64_t result = (*(_DWORD *)(v7 + 8) >> 2) & 0x3FC0 | (*(_DWORD *)(v7 + 12) >> 4) & 0x3Fu;
          break;
        case 7uLL:
          uint64_t result = (*(_DWORD *)(v7 + 8) >> 10) & 0x3FC0 | ((unsigned __int16)*(_DWORD *)(v7 + 12) >> 10);
          break;
        case 8uLL:
          int v14 = BYTE2(*(_DWORD *)(v7 + 12));
          LOWORD(v7) = *(_WORD *)(v7 + 18);
LABEL_44:
          uint64_t result = v7 & 0x3F | (v14 << 6);
          break;
        case 9uLL:
          uint64_t result = (*(_DWORD *)(v7 + 12) >> 18) & 0x3FC0 | (*(_DWORD *)(v7 + 16) >> 22) & 0x3Fu;
          break;
        case 0xAuLL:
          uint64_t result = (*(_DWORD *)(v7 + 16) >> 28) & 0xFFFFC00F | (*(_DWORD *)(v7 + 16) << 6) | (16 * (*(_DWORD *)(v7 + 20) & 3));
          break;
        case 0xBuLL:
          uint64_t result = (*(_DWORD *)(v7 + 16) >> 2) & 0x3FC0 | (*(_DWORD *)(v7 + 20) >> 2);
          break;
        case 0xCuLL:
          uint64_t result = (*(_DWORD *)(v7 + 20) >> 2) & 0x3FC0 | (*(_DWORD *)(v7 + 24) >> 8) & 0x3Fu;
          break;
        case 0xDuLL:
          uint64_t result = (*(_DWORD *)(v7 + 20) >> 10) & 0x3FC0 | (*(_DWORD *)(v7 + 24) >> 14) & 0x3Fu;
          break;
        case 0xEuLL:
          uint64_t result = (*(_DWORD *)(v7 + 20) >> 18) & 0x3FC0 | (*(_DWORD *)(v7 + 24) >> 20) & 0x3Fu;
          break;
        case 0xFuLL:
          HIDWORD(v15) = *(_DWORD *)(v7 + 24);
          LODWORD(v15) = HIDWORD(v15);
          uint64_t result = (v15 >> 26) & 0x3FFF;
          break;
        default:
          uint64_t result = *(_DWORD *)(v7 + 4) & 0x3F | (*(_DWORD *)v7 << 6);
          break;
      }
      break;
    case 12:
      uint64_t v8 = (unsigned int *)(*(void *)this + ((a5 * a3) & 0xFFFFFFFFFFFFFFFCLL) + 12 * (a2 >> 3));
      switch(a2 & 7)
      {
        case 1uLL:
          uint64_t result = (*v8 >> 4) & 0xFF0 | (*v8 >> 20) & 0xF;
          break;
        case 2uLL:
          uint64_t result = (*v8 >> 20) & 0xFF0 | (v8[1] >> 8) & 0xF;
          break;
        case 3uLL:
          unsigned int v9 = v8[1];
          int v10 = (unsigned __int16)v9 >> 12;
          goto LABEL_14;
        case 4uLL:
          uint64_t result = v8[2] & 0xF | (16 * BYTE2(v8[1]));
          break;
        case 5uLL:
          uint64_t result = (v8[1] >> 20) & 0xFF0 | (v8[2] >> 4);
          break;
        case 6uLL:
          uint64_t result = (v8[2] >> 4) & 0xFF0 | HIBYTE(v8[2]) & 0xF;
          break;
        case 7uLL:
          uint64_t result = (v8[2] >> 12) & 0xFF0 | (v8[2] >> 28);
          break;
        default:
          unsigned int v9 = *v8;
          int v10 = HIWORD(v9) & 0xF;
LABEL_14:
          uint64_t result = v10 & 0xFFFFF00F | (16 * v9);
          break;
      }
      break;
    case 10:
      unint64_t v5 = *(void *)this + ((a5 * a3) & 0xFFFFFFFFFFFFFFFCLL) + 20 * (a2 >> 4);
      switch(a2 & 0xF)
      {
        case 1uLL:
          return (*(_DWORD *)v5 >> 6) & 0x3FC | (*(_DWORD *)(v5 + 4) >> 2) & 3u;
        case 2uLL:
          return (*(_DWORD *)v5 >> 14) & 0x3FC | (*(_DWORD *)(v5 + 4) >> 4) & 3u;
        case 3uLL:
          return (*(_DWORD *)v5 >> 22) & 0x3FC | (*(_DWORD *)(v5 + 4) >> 6);
        case 4uLL:
          return (*(_DWORD *)(v5 + 4) >> 6) & 0x3FC | (*(_DWORD *)(v5 + 8) >> 8) & 3u;
        case 5uLL:
          return (*(_DWORD *)(v5 + 4) >> 14) & 0x3FC | (*(_DWORD *)(v5 + 8) >> 10) & 3u;
        case 6uLL:
          return (*(_DWORD *)(v5 + 4) >> 22) & 0x3FC | (*(_DWORD *)(v5 + 8) >> 12) & 3u;
        case 7uLL:
          unsigned int v11 = *(_DWORD *)(v5 + 8);
          int v12 = (unsigned __int16)v11 >> 14;
          goto LABEL_33;
        case 8uLL:
          int v13 = BYTE2(*(_DWORD *)(v5 + 8));
          LOWORD(v5) = *(_WORD *)(v5 + 14);
          goto LABEL_31;
        case 9uLL:
          return (*(_DWORD *)(v5 + 8) >> 22) & 0x3FC | (*(_DWORD *)(v5 + 12) >> 18) & 3u;
        case 0xAuLL:
          unsigned int v11 = *(_DWORD *)(v5 + 12);
          int v12 = (v11 >> 20) & 3;
          goto LABEL_33;
        case 0xBuLL:
          return (*(_DWORD *)(v5 + 12) >> 6) & 0x3FC | (*(_DWORD *)(v5 + 12) >> 22) & 3u;
        case 0xCuLL:
          int v13 = HIBYTE(*(_DWORD *)(v5 + 12));
          LOBYTE(v5) = *(unsigned char *)(v5 + 19);
LABEL_31:
          uint64_t result = v5 & 3 | (4 * v13);
          break;
        case 0xDuLL:
          unsigned int v11 = *(_DWORD *)(v5 + 16);
          int v12 = (v11 >> 26) & 3;
LABEL_33:
          uint64_t result = v12 & 0xFFFFFC03 | (4 * v11);
          break;
        case 0xEuLL:
          uint64_t result = (*(_DWORD *)(v5 + 16) >> 6) & 0x3FC | (*(_DWORD *)(v5 + 16) >> 28) & 3u;
          break;
        case 0xFuLL:
          uint64_t result = (*(_DWORD *)(v5 + 16) >> 14) & 0x3FCu | (*(_DWORD *)(v5 + 16) >> 30);
          break;
        default:
          uint64_t result = *(_DWORD *)(v5 + 4) & 3 | (4 * *(_DWORD *)v5);
          break;
      }
      break;
    default:
      return 0;
  }
  return result;
}

void H16ISP::H16ISPMotionManager::~H16ISPMotionManager(H16ISP::H16ISPMotionManager *this)
{
  uint64_t v3 = 0;
  uint64_t v2 = (_opaque_pthread_t *)*((void *)this + 7);
  if (v2) {
    pthread_join(v2, &v3);
  }
  if (*((void *)this + 1))
  {
    if (objc_opt_respondsToSelector()) {
      [*((id *)this + 1) setSidebandTimeSyncHandler:0];
    }

    *((void *)this + 1) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)this + 1);
}

void GMCProcessorInternal::GMCProcessorInternal(GMCProcessorInternal *this)
{
  *(void *)this = dispatch_queue_create("com.apple.gmc.postprocess", 0);
}

{
  *(void *)this = dispatch_queue_create("com.apple.gmc.postprocess", 0);
}

void GMCProcessorInternal::~GMCProcessorInternal(dispatch_queue_t *this)
{
  *this = 0;
}

{
  dispatch_sync(*this, &__block_literal_global_9);
  dispatch_release(*this);
  *this = 0;
}

void GMCProcessorInternal::runPostProcessingBlock(dispatch_queue_t *a1, void *a2)
{
}

uint64_t GMCProcessorInternal::updatePCECalibWithISF(dispatch_queue_t *a1, double a2, double a3, double a4, double a5, uint64_t a6, uint64_t a7)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  uint64_t v24 = 0;
  unint64_t v25 = &v24;
  uint64_t v26 = 0xE6002000000;
  int v27 = __Block_byref_object_copy__3;
  uint64_t v28 = __Block_byref_object_dispose__3;
  int v13 = fopen("/var/mobile/Library/ISP/Pearl/IsfIRHistory.bin", "rb");
  if (v13)
  {
    fread(&v29, 0xE38uLL, 1uLL, v13);
    fclose(v13);
  }
  else
  {
    int v29 = 1;
    char v30 = 1;
  }
  int v14 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v15 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    int v14 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v14;
  }
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    long long v32 = "updatePCECalibWithISF";
    _os_log_impl(&dword_24680F000, v14, OS_LOG_TYPE_DEFAULT, "%s - ISF\n", buf, 0xCu);
  }
  kdebug_trace();
  PearlIRIsf::PearlIRIsf((PearlIRIsf *)v23);
  uint64_t v16 = PearlIRIsf::Run((uint64_t)v23, (_DWORD *)v25 + 10, &v21, a2, a3, a4, a5);
  kdebug_trace();
  int v17 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v15)
  {
    int v17 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v17;
  }
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    long long v32 = "updatePCECalibWithISF";
    __int16 v33 = 1024;
    LODWORD(v34) = v16;
    _os_log_impl(&dword_24680F000, v17, OS_LOG_TYPE_DEFAULT, "%s - ISF status: %d\n", buf, 0x12u);
  }
  v20[0] = MEMORY[0x263EF8330];
  v20[1] = 0x40000000;
  v20[2] = ___ZN20GMCProcessorInternal21updatePCECalibWithISFEddddRK26sCIspCmdChPearlCalibrationRS0__block_invoke;
  v20[3] = &unk_2651E9730;
  v20[4] = &v24;
  dispatch_async(*a1, v20);
  if (!v16)
  {
    PearlIRIsf::updatePCECalib((uint64_t)v23, (uint64_t)(v25 + 5), a7);
    uint64_t v18 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v15)
    {
      uint64_t v18 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v18;
    }
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      long long v32 = "updatePCECalibWithISF";
      __int16 v33 = 2048;
      uint64_t v34 = v21.i64[0];
      __int16 v35 = 2048;
      uint64_t v36 = v21.i64[1];
      __int16 v37 = 2048;
      uint64_t v38 = v22;
      _os_log_impl(&dword_24680F000, v18, OS_LOG_TYPE_DEFAULT, "%s - GMC post-ISF rotation angles, rotX: %.5lf, rotY: %.5lf, rotZ: %.5lf\n", buf, 0x2Au);
    }
  }
  PearlIRIsf::~PearlIRIsf((PearlIRIsf *)v23);
  _Block_object_dispose(&v24, 8);
  return v16;
}

void sub_24695B37C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__3(uint64_t a1, uint64_t a2)
{
  return memcpy((void *)(a1 + 40), (const void *)(a2 + 40), 0xE38uLL);
}

void ___ZN20GMCProcessorInternal21updatePCECalibWithISFEddddRK26sCIspCmdChPearlCalibrationRS0__block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v3 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    uint64_t v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    int v10 = "updatePCECalibWithISF_block_invoke";
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "%s - Writing GMC ISF file\n", (uint8_t *)&v9, 0xCu);
  }
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v5 = fopen("/var/mobile/Library/ISP/Pearl/IsfIRHistory.bin.bak", "wb");
  if (v5)
  {
    uint64_t v6 = v5;
    fwrite((const void *)(v4 + 40), 0xE38uLL, 1uLL, v5);
    fclose(v6);
    rename((const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/Pearl/IsfIRHistory.bin.bak", (const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/Pearl/IsfIRHistory.bin", v7);
  }
  uint64_t v8 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
  {
    uint64_t v8 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v8;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 136315138;
    int v10 = "updatePCECalibWithISF_block_invoke";
    _os_log_impl(&dword_24680F000, v8, OS_LOG_TYPE_DEFAULT, "%s - OK\n", (uint8_t *)&v9, 0xCu);
  }
}

double GMCProcessorInternal::updatePCECalibWithGMCResults(dispatch_queue_t *a1, uint64_t a2, double *a3, int a4, void *__src, char *__dst, uint64_t a7, int a8)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  memcpy(__dst, __src, 0x3370uLL);
  long long v33 = 0uLL;
  double v34 = 0.0;
  GeomUtils::CalcRotationAngleFromMatrix<double>(a2, (long double *)&v33);
  *(_OWORD *)(a7 + 40) = v33;
  *(double *)(a7 + 56) = v34;
  *(unsigned char *)(a7 + 64) = 0;
  uint64_t v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v16 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    uint64_t v15 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v15;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    double v17 = *a3;
    *(_DWORD *)buf = 136316162;
    uint64_t v36 = "updatePCECalibWithGMCResults";
    __int16 v37 = 2048;
    uint64_t v38 = v33;
    __int16 v39 = 2048;
    uint64_t v40 = *((void *)&v33 + 1);
    __int16 v41 = 2048;
    double v42 = v34;
    __int16 v43 = 2048;
    double v44 = v17;
    _os_log_impl(&dword_24680F000, v15, OS_LOG_TYPE_DEFAULT, "%s - GMC raw rotation angles, rotX: %.5lf, rotY: %.5lf, rotZ: %.5lf, spatial_coverage: %.3lf\n", buf, 0x34u);
  }
  uint64_t v18 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (a3[47] < 0.0 || (a4 & 1) == 0)
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v16)
    {
      uint64_t v18 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v18;
    }
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v36 = "updatePCECalibWithGMCResults";
    __int16 v37 = 1024;
    LODWORD(v38) = a4;
    uint64_t v22 = "%s - Front camera supports auto-focus: %d\n";
    uint64_t v23 = v18;
    goto LABEL_20;
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v16)
  {
    uint64_t v18 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v18;
  }
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v36 = "updatePCECalibWithGMCResults";
    _os_log_impl(&dword_24680F000, v18, OS_LOG_TYPE_DEFAULT, "%s - GMC controller succeeded and front camera supports auto-focus, running ISF...\n", buf, 0xCu);
  }
  mach_timebase_info(&info);
  uint64_t v32 = mach_absolute_time();
  int updated = GMCProcessorInternal::updatePCECalibWithISF(a1, *(double *)&v33, *((double *)&v33 + 1), v34, *a3, v19, (uint64_t)__dst);
  *(double *)a7 = (double)((mach_absolute_time() - v32) * info.numer / info.denom / 0x3E8) / 1000.0;
  *(unsigned char *)(a7 + 64) = 1;
  *(double *)(a7 + 24) = *a3;
  if (updated)
  {
    int64x2_t v21 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v16)
    {
      int64x2_t v21 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v21;
    }
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136315394;
    uint64_t v36 = "updatePCECalibWithGMCResults";
    __int16 v37 = 1024;
    LODWORD(v38) = updated;
    uint64_t v22 = "%s - ISF run failed, status: %d, using raw/unfiltered GMC results.\n";
    uint64_t v23 = v21;
LABEL_20:
    _os_log_impl(&dword_24680F000, v23, OS_LOG_TYPE_DEFAULT, v22, buf, 0x12u);
LABEL_21:
    long long v24 = *(_OWORD *)(a2 + 16);
    long long v25 = *(_OWORD *)(a2 + 32);
    long long v26 = *(_OWORD *)(a2 + 48);
    *((void *)__dst + 1639) = *(void *)(a2 + 64);
    long long v27 = *(_OWORD *)a2;
    *(_OWORD *)(__dst + 13080) = v25;
    *(_OWORD *)(__dst + 13096) = v26;
    *(_OWORD *)(__dst + 13048) = v27;
    *(_OWORD *)(__dst + 13064) = v24;
  }
  if (a8 == 10)
  {
    *((void *)__dst + 1640) = *(void *)(a2 + 80);
    double v28 = -*(double *)(a2 + 72);
  }
  else
  {
    *((void *)__dst + 1640) = *(void *)(a2 + 72);
    double v28 = *(double *)(a2 + 80);
  }
  *((double *)__dst + 1641) = v28;
  *((void *)__dst + 1642) = *(void *)(a2 + 88);
  double result = *(double *)(a2 + 96) * *((double *)__src + 1098);
  *((double *)__dst + 1099) = result;
  return result;
}

void GMCProcessor::GMCProcessor(GMCProcessor *this, H16ISP::H16ISPDevice *a2)
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  *((void *)this + 1) = 0xBFF0000000000000;
  *((void *)this + 2) = -1;
  *((void *)this + 3) = -1;
  *((void *)this + 4) = 0xBFF0000000000000;
  *((void *)this + 5) = -1;
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 8) = 0;
  *((unsigned char *)this + 72) = 0;
  *((_DWORD *)this + 20) = 0;
  *((unsigned char *)this + 84) = 0;
  operator new();
}

void GMCProcessor::~GMCProcessor(dispatch_queue_t **this)
{
  uint64_t v1 = *this;
  if (*this)
  {
    dispatch_sync(*v1, &__block_literal_global_9);
    dispatch_release(*v1);
    *uint64_t v1 = 0;
    MEMORY[0x24C53D6E0](v1, 0x20C4093837F09);
  }
}

uint64_t GMCProcessor::run(uint64_t a1, uint64_t a2)
{
  MEMORY[0x270FA5388](a1, a2);
  unsigned int v4 = v3;
  uint64_t v35 = *MEMORY[0x263EF8340];
  unint64_t v5 = v2[6];
  if (v3 < 3 || *(_DWORD *)v5 == 4)
  {
    if (v3 == 6) {
      operator new[]();
    }
    if (v3 == 3)
    {
      uint64_t v6 = *v2;
      long long v24 = (unint64_t *)(*v2 + 32);
      GMC_Verbose = 0;
      uint64_t v12 = *(void *)(v5 + 26);
      v13.i64[0] = (int)v12;
      v13.i64[1] = SHIDWORD(v12);
      float64x2_t v14 = vcvtq_f64_s64(v13);
      uint64_t v15 = *(void *)(v5 + 30);
      v13.i64[0] = v15;
      v13.i64[1] = HIDWORD(v15);
      float64x2_t v27 = v14;
      float64x2_t v28 = vcvtq_f64_u64((uint64x2_t)v13);
      if (!*((unsigned char *)v5 + 48))
      {
        __asm { FMOV            V0.2D, #-1.0 }
        float64x2_t v28 = _Q0;
        float64x2_t v27 = _Q0;
      }
      mach_timebase_info(&info);
      uint64_t v26 = mach_absolute_time();
      if (!*((_DWORD *)v5 + 17)) {
        *((_DWORD *)v5 + 19) = *((_DWORD *)v5 + 10);
      }
      int64x2_t v21 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
      {
        int64x2_t v21 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v21;
      }
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        int v29 = 136315138;
        char v30 = "run";
        _os_log_impl(&dword_24680F000, v21, OS_LOG_TYPE_DEFAULT, "%s - Running GMC\n", (uint8_t *)&v29, 0xCu);
      }
      kdebug_trace();
      runGmcOnGmsBuffer((uint64_t)v24, *v6);
    }
    uint64_t v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      uint64_t v22 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v22;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      int v29 = 136315394;
      char v30 = "run";
      __int16 v31 = 1024;
      int v32 = v4;
      int v9 = "%s - Number of buffers is not 3 or 6 (%d)\n";
      int v10 = v22;
      uint32_t v11 = 18;
      goto LABEL_24;
    }
  }
  else
  {
    unint64_t v7 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      unint64_t v7 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v7;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)v5;
      int v29 = 136315650;
      char v30 = "run";
      __int16 v31 = 1024;
      int v32 = 4;
      __int16 v33 = 1024;
      int v34 = v8;
      int v9 = "%s - expected GMC parameters buffer v%d, got v%d\n";
      int v10 = v7;
      uint32_t v11 = 24;
LABEL_24:
      _os_log_impl(&dword_24680F000, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v29, v11);
    }
  }
  return 3;
}

uint64_t GMCProcessor::populateGMSBuffer(GMCProcessor *this, unint64_t *a2, int a3, int a4, int a5, const unsigned __int16 *a6, int a7, const unsigned __int16 *a8, int a9, const unsigned __int8 *a10, int a11, int a12)
{
  uint64_t result = 0;
  if (a5 >= 1 && a3 >= 1)
  {
    uint64_t v13 = 0;
    uint64_t result = 0;
    if (a7 >= 0) {
      int v14 = a7;
    }
    else {
      int v14 = a7 + 1;
    }
    int v15 = v14 >> 1;
    unint64_t v16 = a5;
    uint64_t v18 = 2 * v15;
    do
    {
      if (a4 >= 1)
      {
        uint64_t v19 = 0;
        do
        {
          if (a10[v19] >= a12)
          {
            unint64_t v20 = *a2 & 0xFFFFFFFFF0000000 | (unsigned __int16)v19 | ((unsigned __int16)(v13 & 0xFFF) << 16);
            *a2 = v20;
            unint64_t v21 = v20 & 0xFFFFFC000FFFFFFFLL | ((unint64_t)(a6[v19] & 0x3FFF) << 28);
            *a2 = v21;
            unint64_t v22 = v21 & 0xFF0003FFFFFFFFFFLL | ((unint64_t)(a8[v19] & 0x3FFF) << 42);
            *a2 = v22;
            *a2++ = v22 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a10[v19] << 56);
            uint64_t result = (result + 1);
            if ((int)result >= a3) {
              break;
            }
          }
          ++v19;
        }
        while (a4 != v19);
      }
      if (++v13 >= v16) {
        break;
      }
      a10 += a11;
      a8 += a9 / 2;
      a6 = (const unsigned __int16 *)((char *)a6 + v18);
    }
    while ((int)result < a3);
  }
  return result;
}

void GMCProcessor::postProcessProjectorGMC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (dispatch_queue_t **)MEMORY[0x270FA5388](a1, a2);
  char v4 = v3;
  uint64_t v6 = v5;
  int v8 = v7;
  int v10 = v9;
  uint64_t v18 = *MEMORY[0x263EF8340];
  uint32_t v11 = *v2;
  block[0] = MEMORY[0x263EF8330];
  block[1] = 0x40000000;
  block[2] = ___ZN12GMCProcessor23postProcessProjectorGMCE26sCIspCmdChPearlCalibrationS0_j18GMCInnerStatisticsyb_block_invoke;
  block[3] = &__block_descriptor_tmp_3_2;
  block[4] = v2;
  memcpy(v14, v12, sizeof(v14));
  memcpy(v15, v6, sizeof(v15));
  int v16 = v8;
  memcpy(v17, v10, 0x3370uLL);
  v17[13168] = v4;
  dispatch_async(*v11, block);
}

void GMCProcessor::postProcessStereoGMC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (dispatch_queue_t **)MEMORY[0x270FA5388](a1, a2);
  char v4 = v3;
  uint64_t v6 = v5;
  int v8 = v7;
  int v10 = v9;
  uint64_t v26 = *MEMORY[0x263EF8340];
  uint32_t v11 = *v2;
  v15[0] = MEMORY[0x263EF8330];
  v15[1] = 1174405120;
  v15[2] = ___ZN12GMCProcessor20postProcessStereoGMCE12_GMC_Results26sCIspCmdChPearlCalibration18GMCInnerStatisticsyb_block_invoke;
  v15[3] = &__block_descriptor_tmp_4;
  memcpy(v24, v12, sizeof(v24));
  memcpy(v25, v8, 0x3370uLL);
  long long v13 = *v10;
  long long v17 = v10[1];
  long long v14 = v10[3];
  long long v18 = v10[2];
  long long v19 = v14;
  v15[4] = v6;
  uint64_t v20 = *((void *)v10 + 8);
  long long v16 = v13;
  long long v21 = *(long long *)((char *)v10 + 72);
  uint64_t v22 = *((void *)v10 + 11);
  uint64_t v23 = *((void *)v10 + 12);
  v25[13168] = v4;
  dispatch_async(*v11, v15);
}

void ___ZN12GMCProcessor23postProcessProjectorGMCE26sCIspCmdChPearlCalibrationS0_j18GMCInnerStatisticsyb_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t v2 = *(void *)(a1 + 32);
  char v3 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v4 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    char v3 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315138;
    int v9 = "postProcessProjectorGMC_block_invoke";
    _os_log_impl(&dword_24680F000, v3, OS_LOG_TYPE_DEFAULT, "%s - projector GMC reporting analytics\n", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v5 = a1 + 40;
  reportProjectorGmcResults(a1 + 40, a1 + 13208, *(unsigned int *)(a1 + 13800), a1 + 13804, (void *)(v2 + 8));
  if (*(unsigned char *)(a1 + 26972) && *(double *)(a1 + 13584) >= 0.0)
  {
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v4)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136315138;
      int v9 = "postProcessProjectorGMC_block_invoke";
      _os_log_impl(&dword_24680F000, v6, OS_LOG_TYPE_DEFAULT, "%s - Updating PCECalib on disk\n", (uint8_t *)&v8, 0xCu);
    }
    kdebug_trace();
    PCECalibration::save(v5);
  }
  int v7 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v4)
  {
    int v7 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v7;
  }
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136315138;
    int v9 = "postProcessProjectorGMC_block_invoke";
    _os_log_impl(&dword_24680F000, v7, OS_LOG_TYPE_DEFAULT, "%s - Projector-GMC post processing done\n", (uint8_t *)&v8, 0xCu);
  }
}

void ___ZN12GMCProcessor20postProcessStereoGMCE12_GMC_Results26sCIspCmdChPearlCalibration18GMCInnerStatisticsyb_block_invoke(uint64_t a1)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v3 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    uint64_t v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315138;
    uint64_t v26 = "postProcessStereoGMC_block_invoke";
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "%s - Stereo GMC reporting analytics\n", buf, 0xCu);
  }
  uint64_t v4 = a1 + 736;
  reportStereoGmcResults();
  if (*(double *)(a1 + 520) >= 0.0)
  {
    readAnalyticsIsfThresholds((uint64_t)v20, v5);
    int v7 = fopen("/var/mobile/Library/ISP/Pearl/IsfHistory.bin", "rb");
    if (v7)
    {
      fread(buf, 0xE38uLL, 1uLL, v7);
      fclose(v7);
    }
    else
    {
      *(_DWORD *)buf = 3;
      LOBYTE(v26) = 1;
    }
    PearlIsf::PearlIsf((PearlIsf *)v19);
    double v15 = 0.0;
    double v16 = 0.0;
    double v17 = 0.0;
    GeomUtils::CalcRotationAngleFromMatrix<double>(a1 + 40, &v15);
    int v8 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      int v8 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v8;
    }
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long v21 = 136315138;
      uint64_t v22 = "postProcessStereoGMC_block_invoke";
      _os_log_impl(&dword_24680F000, v8, OS_LOG_TYPE_DEFAULT, "%s - ISF\n", v21, 0xCu);
    }
    kdebug_trace();
    int v9 = PearlIsf::RunFromGmc((uint64_t)v19, buf, &v18, v15, v16, v17);
    kdebug_trace();
    uint64_t v10 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v10 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v10;
    }
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long v21 = 136315394;
      uint64_t v22 = "postProcessStereoGMC_block_invoke";
      __int16 v23 = 1024;
      int v24 = v9;
      _os_log_impl(&dword_24680F000, v10, OS_LOG_TYPE_DEFAULT, "%s - ISF status: %d\n", v21, 0x12u);
    }
    reportIsfResults(v9, (double *)v18.i64, 2, 0, a1 + 736, (uint64_t)v20);
    writeAnalyticsIsfThresholds(v20);
    uint32_t v11 = fopen("/var/mobile/Library/ISP/Pearl/IsfHistory.bin.bak", "wb");
    if (v11)
    {
      fwrite(buf, 0xE38uLL, 1uLL, v11);
      fclose(v11);
      rename((const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/Pearl/IsfHistory.bin.bak", (const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/Pearl/IsfHistory.bin", v12);
    }
    if (*(unsigned char *)(a1 + 13904))
    {
      long long v13 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
      {
        long long v13 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v13;
      }
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long v21 = 136315138;
        uint64_t v22 = "postProcessStereoGMC_block_invoke";
        _os_log_impl(&dword_24680F000, v13, OS_LOG_TYPE_DEFAULT, "%s - Updating PCECalib on disk\n", v21, 0xCu);
      }
      kdebug_trace();
      PCECalibration::save(v4);
    }
    long long v14 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      long long v14 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v14;
    }
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long v21 = 136315138;
      uint64_t v22 = "postProcessStereoGMC_block_invoke";
      _os_log_impl(&dword_24680F000, v14, OS_LOG_TYPE_DEFAULT, "%s - Stereo-GMC post processing done\n", v21, 0xCu);
    }
    PearlIsf::~PearlIsf((PearlIsf *)v19);
  }
  else
  {
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v26 = "postProcessStereoGMC_block_invoke";
      _os_log_impl(&dword_24680F000, v6, OS_LOG_TYPE_DEFAULT, "%s - Stereo-GMC post processing done\n", buf, 0xCu);
    }
  }
}

void sub_24695D02C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  PearlIsf::~PearlIsf((PearlIsf *)va);
  _Unwind_Resume(a1);
}

double __copy_helper_block_e8_40c18_ZTS12_GMC_Results(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a2 + 40);
  long long v2 = *(_OWORD *)(a2 + 56);
  long long v3 = *(_OWORD *)(a2 + 72);
  long long v4 = *(_OWORD *)(a2 + 88);
  *(void *)(a1 + 104) = *(void *)(a2 + 104);
  *(_OWORD *)(a1 + 88) = v4;
  *(_OWORD *)(a1 + 72) = v3;
  *(_OWORD *)(a1 + 56) = v2;
  long long v5 = *(_OWORD *)(a2 + 112);
  *(void *)(a1 + 128) = *(void *)(a2 + 128);
  *(_OWORD *)(a1 + 112) = v5;
  double result = *(double *)(a2 + 136);
  *(double *)(a1 + 136) = result;
  return result;
}

uint64_t H16ISP::H16ISPGraphExclaveSensorMetadataNode::H16ISPGraphExclaveSensorMetadataNode(uint64_t a1, H16ISP::H16ISPDevice *this, int a3, int a4)
{
  uint64_t result = H16ISP::H16ISPExclaveGraphNode::H16ISPExclaveGraphNode(a1, 26, this, a3, a4);
  *(void *)uint64_t result = &unk_26FAECAD8;
  *(unsigned char *)(result + 96) = 0;
  return result;
}

uint64_t H16ISP::H16ISPGraphExclaveSensorMetadataNode::onMessageProcessing(H16ISP::H16ISPGraphExclaveSensorMetadataNode *this, H16ISP::H16ISPFilterGraphMessage *a2)
{
  uint64_t v2 = 3758097136;
  if (!a2) {
    return 3758097090;
  }
  if ((*((void *)a2 + 9) & (1 << H16ISP::H16ISPFilterGraphNode::GetType(this))) == 0) {
    return 3758097130;
  }
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
  uint64_t v5 = *((void *)a2 + 47);
  *((unsigned char *)this + 96) = *((unsigned char *)a2 + 388);
  pthread_mutex_unlock((pthread_mutex_t *)((char *)a2 + 8));
  if (!v5)
  {
    int v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      int v9 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v9;
    }
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPGraphExclaveSensorMetadataNode::onMessageProcessing(this, v9);
    }
    return v2;
  }
  unint64_t v6 = H16ISP::H16ISPGraphExclaveSensorMetadataNode::computePTS(this, *(void *)(v5 + 4));
  *(void *)(v5 + 4) = FigHostTimeToNanoseconds();
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
  *((void *)a2 + 11) = v6;
  pthread_mutex_unlock((pthread_mutex_t *)((char *)a2 + 8));
  int v7 = *(uint64_t (**)(H16ISP::H16ISPGraphExclaveSensorMetadataNode *, uint64_t))(*(void *)this + 80);

  return v7(this, v5);
}

unint64_t H16ISP::H16ISPGraphExclaveSensorMetadataNode::computePTS(H16ISP::H16ISPGraphExclaveSensorMetadataNode *this, uint64_t a2)
{
  double v11 = 0.0;
  unsigned int v9 = 0;
  uint64_t v4 = H16ISP::H16ISPExclaveGraphNode::ISPDevice(this);
  if (H16ISP::H16ISPDevice::ISP_GetCameraTime(v4, outputStruct))
  {
    uint64_t v5 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v5 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v5;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPGraphExclaveSensorMetadataNode::computePTS();
    }
  }
  else
  {
    unint64_t v6 = (H16ISP::H16ISPDevice *)H16ISP::H16ISPExclaveGraphNode::ISPDevice(this);
    if (H16ISP::H16ISPDevice::GetISPCounterFrequency(v6, &v9, &v11))
    {
      int v7 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        int v7 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v7;
      }
      if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPGraphExclaveSensorMetadataNode::computePTS();
      }
    }
    else
    {
      return (unint64_t)((double)outputStruct[0] - (double)(outputStruct[1] - a2) * v11);
    }
  }
  return a2;
}

uint64_t H16ISP::H16ISPGraphExclaveRGBSensorMetadataNode::H16ISPGraphExclaveRGBSensorMetadataNode(H16ISP::H16ISPGraphExclaveRGBSensorMetadataNode *this, H16ISP::H16ISPDevice *a2, int a3)
{
  uint64_t result = H16ISP::H16ISPExclaveGraphNode::H16ISPExclaveGraphNode((uint64_t)this, 26, a2, a3, 1);
  *(unsigned char *)(result + 96) = 0;
  *(void *)uint64_t result = &unk_26FAECB40;
  return result;
}

{
  uint64_t result;

  uint64_t result = H16ISP::H16ISPExclaveGraphNode::H16ISPExclaveGraphNode((uint64_t)this, 26, a2, a3, 1);
  *(unsigned char *)(result + 96) = 0;
  *(void *)uint64_t result = &unk_26FAECB40;
  return result;
}

uint64_t H16ISP::H16ISPGraphExclaveRGBSensorMetadataNode::sendSensorMetadata(uint64_t a1, int *a2)
{
  uint64_t v60 = *MEMORY[0x263EF8340];
  H16ISP::H16ISPExclaveGraphNode::GetModuleParams((H16ISP::H16ISPDevice **)a1, (H16ISPModuleParams *)&v36);
  float v4 = 1.0 / *((float *)&v58 + 3);
  float v5 = ComputeLensPSF(*((unsigned char *)a2 + 100), *((unsigned char *)a2 + 101), *((unsigned char *)a2 + 102), *((unsigned __int16 *)a2 + 46), *((unsigned __int16 *)a2 + 47), *((unsigned __int16 *)a2 + 48), *((unsigned __int16 *)a2 + 49));
  float v6 = v5;
  uint64_t v7 = &_os_log_internal;
  if (*((unsigned char *)a2 + 128))
  {
    float v8 = (float)a2[31] * 0.0000152587891 * 1000.0 * v4 * v5;
  }
  else
  {
    unsigned int v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      unsigned int v9 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v9;
    }
    float v8 = 1.0;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPGraphExclaveRGBSensorMetadataNode::sendSensorMetadata(v9);
    }
  }
  double v10 = ComputeOpticalCenter(*((unsigned char *)a2 + 100), *((unsigned char *)a2 + 101), *((unsigned char *)a2 + 102), *((unsigned __int16 *)a2 + 46), *((unsigned __int16 *)a2 + 47), *((unsigned __int16 *)a2 + 48), *((unsigned __int16 *)a2 + 49), v6, v4, a2[29], (double)*(unint64_t *)(a2 + 1), a2[30], 0);
  double v12 = v11;
  uint64_t v13 = H16ISP::H16ISPExclaveGraphNode::ConclaveClient((H16ISP::H16ISPExclaveGraphNode *)a1);
  if (v13)
  {
    uint64_t v14 = v13;
    int v17 = H16ISP::H16ISPExclaveGraphNode::Channel((H16ISP::H16ISPExclaveGraphNode *)a1);
    int v18 = *a2;
    int v36 = v17;
    int v37 = v18;
    uint64_t v38 = *(void *)(a2 + 1);
    uint64_t v39 = *(void *)(a2 + 3);
    __int16 v40 = *((_WORD *)a2 + 10);
    uint64_t v41 = *((void *)a2 + 3);
    *(void *)&long long v19 = *((void *)a2 + 4);
    *((void *)&v19 + 1) = *(void *)(a2 + 11);
    long long v42 = v19;
    uint64_t v20 = *(void *)(a2 + 15);
    uint64_t v43 = *(void *)(a2 + 13);
    uint64_t v44 = v20;
    uint64_t v45 = *(void *)(a2 + 17);
    int v21 = a2[19];
    int v22 = *(unsigned __int8 *)(a1 + 96);
    char v48 = *(unsigned char *)(a1 + 96);
    int v23 = *((unsigned __int16 *)a2 + 20);
    int v46 = v21;
    int v47 = v23;
    float v49 = v8;
    int v50 = 0;
    float v16 = v10;
    float v51 = v16;
    int v52 = 0;
    float v53 = v8;
    float v15 = v12;
    float v54 = v15;
    int v55 = 0;
    int v56 = 0;
    int v57 = 1065353216;
    *(void *)&long long v19 = *(void *)(a2 + 21);
    *((void *)&v19 + 1) = *((void *)a2 + 13);
    long long v58 = v19;
    int v59 = a2[28];
    if (H16ISP::H16ISPExclaveGraphNode::Verbose((H16ISP::H16ISPDevice **)a1))
    {
      int v24 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == v7)
      {
        int v24 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v24;
      }
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109632;
        int v31 = v36;
        __int16 v32 = 1024;
        int v33 = v37;
        __int16 v34 = 1024;
        int v35 = v22;
        _os_log_impl(&dword_24680F000, v24, OS_LOG_TYPE_DEFAULT, "sending sensor metadata channel=%u frameid=%u concurrentmode=%d \n", buf, 0x14u);
      }
    }
    kdebug_trace();
    int v27 = isprgbexclavekitmodule_isprgbexclavekit_sendcmdchsensormetadatav3(v14, (uint64_t)&v36);
    kdebug_trace();
    float64x2_t v28 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == v7)
    {
      float64x2_t v28 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v28;
    }
    uint64_t v26 = 3758097084;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109632;
      int v31 = v27;
      __int16 v32 = 1024;
      int v33 = 0;
      __int16 v34 = 1024;
      int v35 = v37;
      _os_log_error_impl(&dword_24680F000, v28, OS_LOG_TYPE_ERROR, "failed to send rgb sensor metadata tberr=%u result=%{BOOL}d frameid=%u\n", buf, 0x14u);
    }
  }
  else
  {
    long long v25 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == v7)
    {
      long long v25 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v25;
    }
    uint64_t v26 = 3758097136;
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPGraphExclaveRGBSensorMetadataNode::sendSensorMetadata(v25);
    }
  }
  return v26;
}

uint64_t H16ISP::H16ISPGraphExclaveIRSensorMetadataNode::H16ISPGraphExclaveIRSensorMetadataNode(H16ISP::H16ISPGraphExclaveIRSensorMetadataNode *this, H16ISP::H16ISPDevice *a2, int a3)
{
  uint64_t result = H16ISP::H16ISPExclaveGraphNode::H16ISPExclaveGraphNode((uint64_t)this, 26, a2, a3, 0);
  *(unsigned char *)(result + 96) = 0;
  *(void *)uint64_t result = &unk_26FAECBA8;
  return result;
}

{
  uint64_t result;

  uint64_t result = H16ISP::H16ISPExclaveGraphNode::H16ISPExclaveGraphNode((uint64_t)this, 26, a2, a3, 0);
  *(unsigned char *)(result + 96) = 0;
  *(void *)uint64_t result = &unk_26FAECBA8;
  return result;
}

uint64_t H16ISP::H16ISPGraphExclaveIRSensorMetadataNode::sendSensorMetadata(uint64_t a1, int *a2)
{
  uint64_t v56 = *MEMORY[0x263EF8340];
  H16ISP::H16ISPExclaveGraphNode::GetModuleParams((H16ISP::H16ISPDevice **)a1, (H16ISPModuleParams *)&v34);
  float v4 = 1.0 / *((float *)&v54 + 3);
  float v5 = ComputeLensPSF(*((unsigned char *)a2 + 100), *((unsigned char *)a2 + 101), *((unsigned char *)a2 + 102), *((unsigned __int16 *)a2 + 46), *((unsigned __int16 *)a2 + 47), *((unsigned __int16 *)a2 + 48), *((unsigned __int16 *)a2 + 49));
  double v6 = ComputeOpticalCenter(*((unsigned char *)a2 + 100), *((unsigned char *)a2 + 101), *((unsigned char *)a2 + 102), *((unsigned __int16 *)a2 + 46), *((unsigned __int16 *)a2 + 47), *((unsigned __int16 *)a2 + 48), *((unsigned __int16 *)a2 + 49), v5, v4, a2[29], (double)*(unint64_t *)(a2 + 1), a2[30], 0);
  double v8 = v7;
  uint64_t v9 = H16ISP::H16ISPExclaveGraphNode::ConclaveClient((H16ISP::H16ISPExclaveGraphNode *)a1);
  if (v9)
  {
    uint64_t v10 = v9;
    int v13 = H16ISP::H16ISPExclaveGraphNode::Channel((H16ISP::H16ISPExclaveGraphNode *)a1);
    int v14 = *a2;
    int v34 = v13;
    int v35 = v14;
    uint64_t v36 = *(void *)(a2 + 1);
    uint64_t v37 = *(void *)(a2 + 3);
    __int16 v38 = *((_WORD *)a2 + 10);
    uint64_t v39 = *((void *)a2 + 3);
    *(void *)&long long v15 = *((void *)a2 + 4);
    *((void *)&v15 + 1) = *(void *)(a2 + 11);
    long long v40 = v15;
    uint64_t v16 = *(void *)(a2 + 15);
    uint64_t v41 = *(void *)(a2 + 13);
    uint64_t v42 = v16;
    uint64_t v43 = *(void *)(a2 + 17);
    int v17 = a2[19];
    int v18 = *(unsigned __int8 *)(a1 + 96);
    char v46 = *(unsigned char *)(a1 + 96);
    int v19 = *((unsigned __int16 *)a2 + 20);
    int v44 = v17;
    int v45 = v19;
    uint64_t v47 = 1065353216;
    float v12 = v6;
    float v48 = v12;
    uint64_t v49 = 0x3F80000000000000;
    float v11 = v8;
    float v50 = v11;
    int v51 = 0;
    int v52 = 0;
    int v53 = 1065353216;
    *(void *)&long long v15 = *(void *)(a2 + 21);
    *((void *)&v15 + 1) = *((void *)a2 + 13);
    long long v54 = v15;
    int v55 = a2[28];
    char v20 = H16ISP::H16ISPExclaveGraphNode::Verbose((H16ISP::H16ISPDevice **)a1);
    uint64_t v21 = &_os_log_internal;
    if (v20)
    {
      int v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        int v22 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v22;
      }
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109632;
        int v29 = v34;
        __int16 v30 = 1024;
        int v31 = v35;
        __int16 v32 = 1024;
        int v33 = v18;
        _os_log_impl(&dword_24680F000, v22, OS_LOG_TYPE_DEFAULT, "sending sensor metadata channel=%u frameid=%u concurrentmode=%d\n", buf, 0x14u);
      }
    }
    kdebug_trace();
    int v25 = ispirexclavekitmodule_ispirexclavekit_sendcmdchsensormetadatav3(v10, (uint64_t)&v34);
    kdebug_trace();
    uint64_t v26 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == v21)
    {
      uint64_t v26 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v26;
    }
    uint64_t v24 = 3758097084;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109632;
      int v29 = v25;
      __int16 v30 = 1024;
      int v31 = 0;
      __int16 v32 = 1024;
      int v33 = v35;
      _os_log_error_impl(&dword_24680F000, v26, OS_LOG_TYPE_ERROR, "failed to send IR sensor metadata tberr=%u result=%{BOOL}d frameid=%u\n", buf, 0x14u);
    }
  }
  else
  {
    int v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      int v23 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v23;
    }
    uint64_t v24 = 3758097136;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPGraphExclaveIRSensorMetadataNode::sendSensorMetadata(v23);
    }
  }
  return v24;
}

void H16ISP::H16ISPGraphExclaveRGBSensorMetadataNode::~H16ISPGraphExclaveRGBSensorMetadataNode(H16ISP::H16ISPGraphExclaveRGBSensorMetadataNode *this)
{
  H16ISP::H16ISPFilterGraphNode::~H16ISPFilterGraphNode(this);

  JUMPOUT(0x24C53D6E0);
}

void H16ISP::H16ISPGraphExclaveIRSensorMetadataNode::~H16ISPGraphExclaveIRSensorMetadataNode(H16ISP::H16ISPGraphExclaveIRSensorMetadataNode *this)
{
  H16ISP::H16ISPFilterGraphNode::~H16ISPFilterGraphNode(this);

  JUMPOUT(0x24C53D6E0);
}

uint64_t H16ISP::H16ISPDevice::CacheNumChannels(H16ISP::H16ISPDevice *this)
{
  return H16ISP::H16ISPDevice::ISP_GetNumChannels(this, (unsigned int *)this + 1187);
}

uint64_t H16ISP::H16ISPDevice::GetNumCameraConfigs(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  if (*((_DWORD *)this + 1187) > a2 && *((unsigned char *)this + 4)) {
    return *(unsigned int *)(*((void *)this + 5) + 432 * a2);
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  uint64_t result = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  if (result)
  {
    H16ISP::H16ISPDevice::GetNumCameraConfigs();
    return 0;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetUnitInfoPropertyDict(H16ISP::H16ISPDevice *this, __CFDictionary **a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t v2 = 3758097085;
  CFErrorRef err = 0;
  uint64_t result = 3758097090;
  if (a2 && !*a2)
  {
    if (byte_26B11BF5A)
    {
      return 0;
    }
    else
    {
      CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
      CFURLRef v6 = CFURLCreateWithFileSystemPath((CFAllocatorRef)*MEMORY[0x263EFFB08], @"/usr/local/share/firmware/isp/ISPUnitInfo.plist", kCFURLPOSIXPathStyle, 0);
      if (v6)
      {
        CFURLRef v7 = v6;
        CFPropertyListFormat format = 0;
        double v8 = CFReadStreamCreateWithFile(v5, v6);
        if (v8)
        {
          uint64_t v9 = v8;
          if (CFReadStreamOpen(v8))
          {
            if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
              GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
            }
            uint64_t v10 = &_os_log_internal;
            if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136315138;
              char v20 = "GetUnitInfoPropertyDict";
              _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_INFO, "%s - Parsing ISPUnitInfo.plist\n", buf, 0xCu);
            }
            float v11 = (__CFDictionary *)CFPropertyListCreateWithStream(v5, v9, 0, 0, &format, &err);
            if (err)
            {
              if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v10) {
                GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
              }
              BOOL v12 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
              if (v12) {
                H16ISP::H16ISPDevice::GetUnitInfoPropertyDict(v12, v13, v14);
              }
              CFStringRef v15 = CFErrorCopyDescription(err);
              if (v15)
              {
                CFStringRef v16 = v15;
                CFShow(v15);
                CFRelease(v16);
              }
            }
            else
            {
              uint64_t v2 = 0;
              *a2 = v11;
            }
          }
          else
          {
            uint64_t v2 = 3758097136;
          }
          CFReadStreamClose(v9);
          CFRelease(v9);
        }
        CFRelease(v7);
        return v2;
      }
      else
      {
        return 3758097085;
      }
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::CreateISPUnitInfoDictionary(H16ISP::H16ISPDevice *this, __CFDictionary **a2)
{
  uint64_t v2 = (H16ISP::H16ISPDevice *)MEMORY[0x270FA5388](this, a2);
  float v4 = v3;
  CFAllocatorRef v5 = v2;
  uint64_t v99 = *MEMORY[0x263EF8340];
  uint64_t v6 = 3758097085;
  unsigned int length = 40960;
  if (!H16ISP::H16ISPDevice::ISP_IsPowered(v2))
  {
    Mutable = 0;
    uint64_t v6 = 3758097123;
    goto LABEL_10;
  }
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  if (Mutable)
  {
    int length_4 = *((_DWORD *)v5 + 1094);
    CFNumberRef v9 = CFNumberCreate(0, kCFNumberIntType, &length_4);
    CFDictionarySetValue(Mutable, @"PlatformID", v9);
    CFRelease(v9);
    uint64_t v10 = MGCopyAnswer();
    if (v10)
    {
      float v11 = (const void *)v10;
      TypeIOSurfaceID ID = CFStringGetTypeID();
      if (TypeID == CFGetTypeID(v11)) {
        CFDictionarySetValue(Mutable, @"iOSBuildVersion", v11);
      }
      CFRelease(v11);
    }
    bzero(v92, 0xA8uLL);
    __int16 v93 = 6;
    uint64_t v13 = H16ISP::H16ISPDevice::ISP_SendCommand(v5, v92, 0xA8u, 0, 0xFFFFFFFF);
    if (v13)
    {
      uint64_t v6 = v13;
      CFRelease(Mutable);
      Mutable = 0;
      goto LABEL_10;
    }
    CFStringRef v15 = CFStringCreateWithCString(0, v94, 0);
    if (v15)
    {
      CFStringRef v16 = v15;
      CFDictionarySetValue(Mutable, @"FirmwareName", v15);
      CFRelease(v16);
    }
    CFStringRef v17 = CFStringCreateWithCString(0, v95, 0);
    if (v17)
    {
      CFStringRef v18 = v17;
      CFDictionarySetValue(Mutable, @"FirmwareLinkDate", v17);
      CFRelease(v18);
    }
    CFStringRef v19 = CFStringCreateWithCString(0, v96, 0);
    if (v19)
    {
      CFStringRef v20 = v19;
      CFDictionarySetValue(Mutable, @"FirmwareReleaseVersion", v19);
      CFRelease(v20);
    }
    CFStringRef v21 = CFStringCreateWithCString(0, v97, 0);
    if (v21)
    {
      CFStringRef v22 = v21;
      CFDictionarySetValue(Mutable, @"FirmwareToolchainName", v21);
      CFRelease(v22);
    }
    CFStringRef v23 = CFStringCreateWithCString(0, v98, 0);
    if (v23)
    {
      CFStringRef v24 = v23;
      CFDictionarySetValue(Mutable, @"FirmwareToolchainVersion", v23);
      CFRelease(v24);
    }
    mach_port_t v25 = *MEMORY[0x263F0EC90];
    CFDictionaryRef v26 = IOServiceNameMatching("AppleARMPE");
    io_service_t MatchingService = IOServiceGetMatchingService(v25, v26);
    float64x2_t v28 = (void *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"IOPlatformSerialNumber", v7, 3u);
    if (v28)
    {
      int v29 = v28;
      CFDictionarySetValue(Mutable, @"DeviceSerialNumber", v28);
      CFRelease(v29);
    }
    CFDictionaryRef theDict = 0;
    H16ISP::H16ISPDevice::GetUnitInfoPropertyDict((H16ISP::H16ISPDevice *)v28, &theDict);
    CFDataRef v30 = (const __CFData *)IORegistryEntrySearchCFProperty(*((_DWORD *)v5 + 1104), "IOService", @"multi-camera-cal-wide", v7, 3u);
    CFDataRef Value = v30;
    if (v30 || theDict && (CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, @"MultiCameraCalWide")) != 0)
    {
      CFIndex v32 = CFDataGetLength(Value);
      BytePtr = CFDataGetBytePtr(Value);
      if (BytePtr)
      {
        CFDataRef v34 = CFDataCreate(0, BytePtr, v32);
        CFDictionarySetValue(Mutable, @"MultiCameraCalWide", v34);
        CFRelease(v34);
      }
      if (v30) {
        CFRelease(v30);
      }
    }
    CFDataRef v35 = (const __CFData *)IORegistryEntrySearchCFProperty(*((_DWORD *)v5 + 1104), "IOService", @"multi-camera-cal-swide", v7, 3u);
    CFDataRef v36 = v35;
    if (v35 || theDict && (CFDataRef v36 = (const __CFData *)CFDictionaryGetValue(theDict, @"MultiCameraCalSwide")) != 0)
    {
      CFIndex v37 = CFDataGetLength(v36);
      __int16 v38 = CFDataGetBytePtr(v36);
      if (v38)
      {
        CFDataRef v39 = CFDataCreate(0, v38, v37);
        CFDictionarySetValue(Mutable, @"MultiCameraCalSwide", v39);
        CFRelease(v39);
      }
      if (v35) {
        CFRelease(v35);
      }
    }
    CFDataRef v40 = (const __CFData *)IORegistryEntrySearchCFProperty(*((_DWORD *)v5 + 1104), "IOService", @"front-camera-cal-swide", v7, 3u);
    CFDataRef v41 = v40;
    if (v40) {
      goto LABEL_38;
    }
    if (!theDict)
    {
LABEL_47:
      int length_4 = 4142;
      CFNumberRef v45 = CFNumberCreate(0, kCFNumberIntType, &length_4);
      CFDictionarySetValue(Mutable, @"MetadataVersion", v45);
      CFRelease(v45);
      CFMutableArrayRef v46 = CFArrayCreateMutable(v7, *((unsigned int *)v5 + 1187), MEMORY[0x263EFFF70]);
      if (!v46) {
        goto LABEL_67;
      }
      CFMutableArrayRef v47 = v46;
      int16x8_t v76 = v4;
      if (!*((_DWORD *)v5 + 1187)) {
        goto LABEL_66;
      }
      CFIndex v48 = 0;
      uint64_t v49 = (const CFDictionaryKeyCallBacks *)MEMORY[0x263EFFF88];
      float v50 = (const CFDictionaryValueCallBacks *)MEMORY[0x263EFFF90];
      while (1)
      {
        CFMutableDictionaryRef v51 = CFDictionaryCreateMutable(v7, 0, v49, v50);
        if (v51)
        {
          int v52 = v51;
          int length_4 = v48;
          CFNumberRef v53 = CFNumberCreate(0, kCFNumberIntType, &length_4);
          CFDictionarySetValue(v52, @"Index", v53);
          CFRelease(v53);
          if (!H16ISP::H16ISPDevice::ISP_GetModuleParams(v5, v48, (H16ISPModuleParams *)v84))
          {
            if (v84[4])
            {
              int length_4 = v85;
              CFNumberRef v54 = CFNumberCreate(0, kCFNumberIntType, &length_4);
              CFDictionarySetValue(v52, @"SensorID", v54);
              CFRelease(v54);
              int length_4 = v86;
              CFNumberRef v55 = CFNumberCreate(0, kCFNumberIntType, &length_4);
              CFDictionarySetValue(v52, @"ModuleIntegrator", v55);
              CFRelease(v55);
              int length_4 = v87;
              CFNumberRef v56 = CFNumberCreate(0, kCFNumberIntType, &length_4);
              CFDictionarySetValue(v52, @"ModuleLensID", v56);
              CFRelease(v56);
              int length_4 = v90;
              CFNumberRef v57 = CFNumberCreate(0, kCFNumberIntType, &length_4);
              CFDictionarySetValue(v52, @"ModuleIRFilterID", v57);
              CFRelease(v57);
              unsigned int length = 40960;
              if (H16ISP::H16ISPDevice::GetSensorNVMBytes(v5, v48, bytes, 0, &length)) {
                goto LABEL_66;
              }
              CFDataRef v58 = CFDataCreate(0, bytes, length);
              CFDictionarySetValue(v52, @"NVM", v58);
              CFRelease(v58);
              if (v88)
              {
                uint64_t valuePtr = v89;
                CFNumberRef v59 = CFNumberCreate(0, kCFNumberLongType, &valuePtr);
                CFDictionarySetValue(v52, @"SetfileVersion", v59);
                CFRelease(v59);
                unsigned int v79 = 0;
                if (!H16ISP::H16ISPDevice::ISP_GetSetfileSize(v5, v48, &v79)) {
                  operator new[]();
                }
              }
            }
            LOWORD(valuePtr) = 0;
            LOWORD(v79) = 0;
            *(_DWORD *)int32x4_t v78 = 0;
            if (H16ISP::H16ISPDevice::GetColorCalData(v5, v48, (unsigned __int16 *)&valuePtr, (unsigned __int16 *)&v79, &v78[1], v78))goto LABEL_66; {
            CFMutableDictionaryRef v60 = CFDictionaryCreateMutable(v7, 0, v49, v50);
            }
            if (!v60) {
              goto LABEL_66;
            }
            int v61 = v60;
            uint16x8_t v62 = v47;
            __int16 v63 = v50;
            int16x8_t v64 = v49;
            int length_4 = (unsigned __int16)valuePtr;
            CFNumberRef v65 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v61, @"LowCCTrgBias", v65);
            CFRelease(v65);
            int length_4 = (unsigned __int16)v79;
            CFNumberRef v66 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v61, @"LowCCTbgBias", v66);
            CFRelease(v66);
            int length_4 = v78[1];
            CFNumberRef v67 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v61, @"HiCCTrgBias", v67);
            CFRelease(v67);
            int length_4 = v78[0];
            CFNumberRef v68 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v61, @"HiCCTbgBias", v68);
            CFRelease(v68);
            CFDictionarySetValue(v52, @"ColorCalibrationData", v61);
            unsigned __int8 v77 = 0;
            if (H16ISP::H16ISPDevice::GetAbsoluteColorCal(v5, v48, (unsigned __int16 *)&valuePtr, (unsigned __int16 *)&v79, &v78[1], v78, &v77)|| (CFMutableDictionaryRef v69 = CFDictionaryCreateMutable(v7, 0, v64, v63)) == 0)
            {
              CFMutableArrayRef v47 = v62;
LABEL_66:
              CFDictionarySetValue(Mutable, @"ChannelArray", v47);
              float v4 = v76;
LABEL_67:
              uint64_t v6 = 0;
              goto LABEL_10;
            }
            int16x8_t v70 = v69;
            int length_4 = (unsigned __int16)valuePtr;
            CFNumberRef v71 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v70, @"LowCCTrgAbs", v71);
            CFRelease(v71);
            int length_4 = (unsigned __int16)v79;
            CFNumberRef v72 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v70, @"LowCCTbgAbs", v72);
            CFRelease(v72);
            int length_4 = v78[1];
            CFNumberRef v73 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v70, @"HiCCTrgAbs", v73);
            CFRelease(v73);
            int length_4 = v78[0];
            CFNumberRef v74 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v70, @"HiCCTbgAbs", v74);
            CFRelease(v74);
            int length_4 = v77;
            CFNumberRef v75 = CFNumberCreate(0, kCFNumberIntType, &length_4);
            CFDictionarySetValue(v70, @"AbsoluteColorCalFlags", v75);
            CFRelease(v75);
            CFDictionarySetValue(v52, @"AbsoluteColorCalibrationData", v70);
            uint64_t v49 = v64;
            float v50 = v63;
            CFMutableArrayRef v47 = v62;
          }
          CFArraySetValueAtIndex(v47, v48, v52);
          CFRelease(v52);
        }
        if (++v48 >= (unint64_t)*((unsigned int *)v5 + 1187)) {
          goto LABEL_66;
        }
      }
    }
    CFDataRef v41 = (const __CFData *)CFDictionaryGetValue(theDict, @"FrontCameraCalSwide");
    if (v41)
    {
LABEL_38:
      CFIndex v42 = CFDataGetLength(v41);
      uint64_t v43 = CFDataGetBytePtr(v41);
      if (v43)
      {
        CFDataRef v44 = CFDataCreate(0, v43, v42);
        CFDictionarySetValue(Mutable, @"FrontCameraCalSwide", v44);
        CFRelease(v44);
      }
      if (v40) {
        CFRelease(v40);
      }
    }
    if (theDict)
    {
      CFRelease(theDict);
      CFDictionaryRef theDict = 0;
    }
    goto LABEL_47;
  }
LABEL_10:
  *float v4 = Mutable;
  return v6;
}

uint64_t H16ISP::H16ISPDevice::GetSensorNVMBytes(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned __int8 *a3, unsigned int a4, unsigned int *a5)
{
  if (*((unsigned char *)this + 4))
  {
    uint64_t v5 = 3758097090;
    if (*((_DWORD *)this + 1187) > a2)
    {
      uint64_t v6 = *((void *)this + 5);
      if (*(_DWORD *)(v6 + 432 * a2))
      {
        unsigned int v7 = *(_DWORD *)(v6 + 432 * a2 + 72);
        if (v7 > a4)
        {
          unsigned int v8 = *a5;
          if (*a5 >= v7) {
            unsigned int v8 = v7;
          }
          if (v8 + a4 <= v7) {
            unsigned int v9 = v8;
          }
          else {
            unsigned int v9 = v7 - a4;
          }
          if (v9) {
            operator new[]();
          }
        }
      }
      else
      {
        return 3758097088;
      }
    }
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v5 = 3758097112;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::GetSensorNVMBytes();
    }
  }
  return v5;
}

uint64_t H16ISP::H16ISPDevice::ISP_GetSetfileSize(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int *a3)
{
  input[1] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  uint64_t output = 0;
  input[0] = a2;
  uint32_t outputCnt = 1;
  uint64_t result = IOConnectCallScalarMethod(v3, 0x14u, input, 1u, &output, &outputCnt);
  if (!result) {
    *a3 = output;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_CopySetfile(H16ISP::H16ISPDevice *this, uint64_t a2, unsigned int a3, unsigned int a4)
{
  v7[3] = *MEMORY[0x263EF8340];
  mach_port_t v4 = *((_DWORD *)this + 1106);
  if (!v4) {
    return 3758097084;
  }
  v7[0] = a2;
  v7[1] = a3;
  v7[2] = a4;
  uint64_t v5 = IOConnectCallScalarMethod(v4, 0x38u, v7, 3u, 0, 0);
  if (v5)
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ISP_CopySetfile();
    }
  }
  return v5;
}

uint64_t H16ISP::H16ISPDevice::GetColorCalData(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6)
{
  bzero(v13, 0x14uLL);
  __int16 v14 = 2053;
  int v15 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x14u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v16;
    *a4 = v17;
    *a5 = v18;
    *a6 = v19;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetAbsoluteColorCal(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int8 *a7)
{
  bzero(v15, 0x18uLL);
  __int16 v16 = 2056;
  int v17 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x18u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v18;
    *a4 = v19;
    *a5 = v20;
    *a6 = v21;
    *a7 = v22;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetLSCCoefficients(uint64_t a1, unsigned int a2, unsigned int a3, void *__dst)
{
  uint64_t v4 = 3758097090;
  if (*(unsigned char *)(a1 + 4))
  {
    if (*(_DWORD *)(a1 + 4748) > a2)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      if (*(_DWORD *)(v5 + 432 * a2) > a3)
      {
        memmove(__dst, (const void *)(*(void *)(v5 + 432 * a2 + 24) + 72 * a3), 0x48uLL);
        return 0;
      }
    }
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v4 = 3758097112;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::GetLSCCoefficients();
    }
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::AllExpectedSensorsDetected(H16ISP::H16ISPDevice *this)
{
  unint64_t v1 = *((unsigned int *)this + 1187);
  if (!v1) {
    goto LABEL_9;
  }
  char v2 = *((unsigned char *)this + 4);
  if (!v2) {
    return v2 & 1;
  }
  uint64_t v3 = *((void *)this + 548);
  if (!v3)
  {
LABEL_9:
    char v2 = 0;
    return v2 & 1;
  }
  uint64_t v4 = 0;
  char v2 = 0;
  uint64_t v5 = (int *)(v3 + 12);
  uint64_t v6 = 44;
  do
  {
    int v7 = *v5;
    v5 += 24;
    if (v7 && !*(_WORD *)(*((void *)this + 5) + v6)) {
      break;
    }
    char v2 = ++v4 >= v1;
    v6 += 432;
  }
  while (v1 != v4);
  return v2 & 1;
}

uint64_t H16ISP::H16ISPDevice::SetStillFESConfig(H16ISP::H16ISPDevice *a1, __int16 a2, int a3, char a4, int a5, int a6, uint64_t a7, uint64_t a8)
{
  bzero(v17, 0x2CuLL);
  __int16 v19 = a2;
  __int16 v18 = 2308;
  char v20 = a4;
  int v21 = a3;
  uint64_t v22 = a7;
  uint64_t v23 = a8;
  int v24 = a5;
  int v25 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v17, 0x2Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableVisPipeOutput(uint64_t a1, uint64_t a2)
{
  unsigned int v9 = (H16ISP::H16ISPDevice *)MEMORY[0x270FA5388](a1, a2);
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t result = 3758097090;
  if (v8 <= 4)
  {
    unsigned int v11 = v2;
    if (*((_DWORD *)v9 + 1187) > v2)
    {
      unsigned int v12 = v8;
      __int16 v13 = v7;
      __int16 v14 = v6;
      char v15 = v5;
      int v16 = v4;
      int v17 = v3;
      unint64_t v18 = HIDWORD(v4);
      unint64_t v19 = HIDWORD(v3);
      bzero(v20, 0x1CuLL);
      __int16 v21 = 20488;
      unsigned int v22 = v11;
      int v23 = v17;
      int v25 = v16;
      int v26 = v18;
      unsigned int v24 = v19;
      uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(v9, v20, 0x1Cu, 0, 0xFFFFFFFF);
      if (!result)
      {
        bzero(v20, 0x14uLL);
        unsigned int v22 = v11;
        __int16 v21 = 20489;
        LOWORD(v23) = v14;
        HIWORD(v23) = v13;
        unsigned int v24 = v12;
        uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(v9, v20, 0x14u, 0, 0xFFFFFFFF);
        if (!result)
        {
          bzero(v20, 0x10uLL);
          unsigned int v22 = v11;
          __int16 v21 = 20487;
          LOBYTE(v23) = v15;
          return H16ISP::H16ISPDevice::ISP_SendCommand(v9, v20, 0x10u, 0, 0xFFFFFFFF);
        }
      }
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::StopCamera(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v6[1] = *MEMORY[0x263EF8340];
  uint64_t v3 = 3758097112;
  mach_port_t v4 = *((_DWORD *)this + 1106);
  if (!v4) {
    return 3758097084;
  }
  if (*((unsigned char *)this + 4))
  {
    v6[0] = a2;
    return IOConnectCallScalarMethod(v4, 0x37u, v6, 1u, 0, 0);
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::StopCamera();
    }
  }
  return v3;
}

uint64_t H16ISP::H16ISPDevice::ReturnAllUnusedBuffers(H16ISP::H16ISPDevice *this, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x270FA5388](this, a2);
  int v4 = v3;
  uint64_t v11 = *MEMORY[0x263EF8340];
  if (*(unsigned char *)(v2 + 4))
  {
    char v5 = (H16ISP::H16ISPDevice *)v2;
    bzero(v8, 0xCuLL);
    int v10 = v4;
    __int16 v9 = 260;
    return H16ISP::H16ISPDevice::ISP_SendCommand(v5, v8, 0xCu, 0, 0xFFFFFFFF);
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v6 = 3758097112;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ReturnAllUnusedBuffers();
    }
  }
  return v6;
}

uint64_t H16ISP::H16ISPDevice::ReturnAllBuffersInPool(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 347;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ReturnAllSharedBuffersInPool(H16ISP::H16ISPDevice *this, __int16 a2, __int16 a3, int a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 13323;
  __int16 v11 = a2;
  __int16 v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ReconfigureFaceDetect(H16ISP::H16ISPDevice *this, int a2, char a3, int a4)
{
  bzero(v9, 0x18uLL);
  __int16 v10 = 3331;
  int v11 = a2;
  int v12 = a4;
  char v13 = a3 & 1;
  BOOL v14 = (a3 & 2) != 0;
  BOOL v15 = (a3 & 4) != 0;
  BOOL v16 = (a3 & 8) == 0;
  BOOL v17 = (a3 & 0x10) == 0;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::StopFaceDetect(H16ISP::H16ISPDevice *this, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x270FA5388](this, a2);
  int v4 = v3;
  char v5 = (H16ISP::H16ISPDevice *)v2;
  uint64_t v10 = *MEMORY[0x263EF8340];
  bzero(v7, 0xCuLL);
  int v9 = v4;
  __int16 v8 = 3329;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(v5, v7, 0xCu, 0, 0xFFFFFFFF);
  if (!result)
  {
    bzero(v7, 0xCuLL);
    int v9 = v4;
    __int16 v8 = 3332;
    return H16ISP::H16ISPDevice::ISP_SendCommand(v5, v7, 0xCu, 0, 0xFFFFFFFF);
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_SetExclaveMaximumFrameRate(H16ISP::H16ISPDevice *this, unsigned int a2, int a3)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v3 = 3758097084;
  if (!*((_DWORD *)this + 1106)) {
    return v3;
  }
  if (*((_DWORD *)this + 1187) <= a2)
  {
    BOOL v17 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      BOOL v17 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v17;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ISP_SetExclaveMaximumFrameRate();
    }
  }
  else
  {
    if (a2 > 5) {
      return 0;
    }
    uint64_t v4 = *((void *)this + 548);
    if (!*(_DWORD *)(v4 + 96 * a2 + 8)) {
      return 0;
    }
    int v5 = *(_DWORD *)(v4 + 96 * a2 + 16);
    if (v5 == 1718776695 || v5 == 1718775412)
    {
      if (*((void *)this + 23))
      {
        kdebug_trace();
        int v7 = isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeframeratemaxset();
        kdebug_trace();
        if (byte_26B11BF60)
        {
          __int16 v8 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            __int16 v8 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v8;
          }
          if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 67109376;
            unsigned int v50 = a2;
            __int16 v51 = 1024;
            int v52 = a3;
            _os_log_impl(&dword_24680F000, v8, OS_LOG_TYPE_INFO, "RGB AE max framerate: channel=%u, maxfps=%u\n", buf, 0xEu);
          }
        }
        if (!v7) {
          return 0;
        }
        int v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          int v9 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v9;
        }
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::ISP_SetExclaveMaximumFrameRate(v9, v10, v11, v12, v13, v14, v15, v16);
        }
      }
      else
      {
        int v29 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          int v29 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v29;
        }
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::ISP_SetExclaveMaximumFrameRate(v29, v30, v31, v32, v33, v34, v35, v36);
        }
      }
    }
    else
    {
      if (v5 != 1718186595) {
        return 0;
      }
      if (*((void *)this + 17))
      {
        kdebug_trace();
        int v18 = ispirexclavekitmodule_ispirexclavekit_sendcmdchaeframeratemaxset();
        kdebug_trace();
        if (byte_26B11BF60)
        {
          unint64_t v19 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            unint64_t v19 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v19;
          }
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 67109376;
            unsigned int v50 = a2;
            __int16 v51 = 1024;
            int v52 = a3;
            _os_log_impl(&dword_24680F000, v19, OS_LOG_TYPE_INFO, "IR AE max framerate: channel=%u, maxfps=%u\n", buf, 0xEu);
          }
        }
        if (v18)
        {
          char v20 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            char v20 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v20;
          }
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            H16ISP::H16ISPDevice::ISP_SetExclaveMaximumFrameRate(v20, v21, v22, v23, v24, v25, v26, v27);
          }
          return v3;
        }
        return 0;
      }
      CFIndex v37 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        CFIndex v37 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v37;
      }
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::ISP_SetExclaveMaximumFrameRate(v37, v38, v39, v40, v41, v42, v43, v44);
      }
    }
  }
  return v3;
}

uint64_t H16ISP::H16ISPDevice::SetMaximumFrameRateForAllocation(H16ISP::H16ISPDevice *this, __int16 a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 369;
  __int16 v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetExclaveMinimumFrameRate(H16ISP::H16ISPDevice *this, unsigned int a2, int a3)
{
  uint64_t v53 = *MEMORY[0x263EF8340];
  uint64_t v3 = 3758097084;
  if (!*((_DWORD *)this + 1106)) {
    return v3;
  }
  if (*((_DWORD *)this + 1187) <= a2)
  {
    BOOL v17 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      BOOL v17 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v17;
    }
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ISP_SetExclaveMinimumFrameRate();
    }
  }
  else
  {
    if (a2 > 5) {
      return 0;
    }
    uint64_t v4 = *((void *)this + 548);
    if (!*(_DWORD *)(v4 + 96 * a2 + 8)) {
      return 0;
    }
    int v5 = *(_DWORD *)(v4 + 96 * a2 + 16);
    if (v5 == 1718776695 || v5 == 1718775412)
    {
      if (*((void *)this + 23))
      {
        kdebug_trace();
        int v7 = isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeframerateminset();
        kdebug_trace();
        if (byte_26B11BF60)
        {
          __int16 v8 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            __int16 v8 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v8;
          }
          if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 67109376;
            unsigned int v50 = a2;
            __int16 v51 = 1024;
            int v52 = a3;
            _os_log_impl(&dword_24680F000, v8, OS_LOG_TYPE_INFO, "RGB AE min framerate: channel=%u, minfps=%u\n", buf, 0xEu);
          }
        }
        if (!v7) {
          return 0;
        }
        __int16 v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          __int16 v9 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v9;
        }
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::ISP_SetExclaveMinimumFrameRate(v9, v10, v11, v12, v13, v14, v15, v16);
        }
      }
      else
      {
        int v29 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          int v29 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v29;
        }
        if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::ISP_SetExclaveMinimumFrameRate(v29, v30, v31, v32, v33, v34, v35, v36);
        }
      }
    }
    else
    {
      if (v5 != 1718186595) {
        return 0;
      }
      if (*((void *)this + 17))
      {
        kdebug_trace();
        int v18 = ispirexclavekitmodule_ispirexclavekit_sendcmdchaeframerateminset();
        kdebug_trace();
        if (byte_26B11BF60)
        {
          unint64_t v19 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            unint64_t v19 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v19;
          }
          if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 67109376;
            unsigned int v50 = a2;
            __int16 v51 = 1024;
            int v52 = a3;
            _os_log_impl(&dword_24680F000, v19, OS_LOG_TYPE_INFO, "IR AE min framerate: channel=%u, minfps=%u\n", buf, 0xEu);
          }
        }
        if (v18)
        {
          char v20 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            char v20 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v20;
          }
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            H16ISP::H16ISPDevice::ISP_SetExclaveMinimumFrameRate(v20, v21, v22, v23, v24, v25, v26, v27);
          }
          return v3;
        }
        return 0;
      }
      CFIndex v37 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        CFIndex v37 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v37;
      }
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::ISP_SetExclaveMinimumFrameRate(v37, v38, v39, v40, v41, v42, v43, v44);
      }
    }
  }
  return v3;
}

uint64_t H16ISP::H16ISPDevice::GetMinimumFrameRate(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3)
{
  if ((*((_DWORD *)this + 1093) >> a2))
  {
    uint64_t result = 0;
    *a3 = 0;
  }
  else
  {
    bzero(v7, 0x10uLL);
    __int16 v8 = 521;
    int v9 = a2;
    uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
    if (!result) {
      *a3 = v10;
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetDeviceNVMBytes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6)
{
  if (*a6) {
    operator new[]();
  }
  return 3758097090;
}

uint64_t H16ISP::H16ISPDevice::ReloadNVMBytes(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  uint64_t v3 = 3758097112;
  if (*((unsigned char *)this + 4))
  {
    if (*((_DWORD *)this + 1187) <= a2)
    {
      return 3758097090;
    }
    else
    {
      uint64_t v5 = *((void *)this + 5);
      if (*(_DWORD *)(v5 + 432 * a2))
      {
        bzero(v9, 0x14uLL);
        __int16 v10 = 1282;
        unsigned int v11 = a2;
        int v12 = 0;
        int v13 = *(_DWORD *)(v5 + 432 * a2 + 72);
        uint64_t v3 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
        if (!v3) {
          return H16ISP::H16ISPDevice::CacheDeviceConfigs(this, v7);
        }
      }
      else
      {
        return 3758097088;
      }
    }
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ReloadNVMBytes();
    }
  }
  return v3;
}

uint64_t H16ISP::H16ISPDevice::EnableAWB(H16ISP::H16ISPDevice *this, unsigned int a2, int a3)
{
  if (*((_DWORD *)this + 1187) <= a2) {
    return 3758097090;
  }
  if (a3)
  {
    bzero(v7, 0xCuLL);
    __int16 v5 = 768;
  }
  else
  {
    bzero(v7, 0xCuLL);
    __int16 v5 = 769;
  }
  __int16 v8 = v5;
  unsigned int v9 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetFaceDetectionWindowParam(H16ISP::H16ISPDevice *a1, int a2, uint64_t a3)
{
  bzero(v7, 0x14uLL);
  __int16 v8 = 3340;
  int v9 = a2;
  uint64_t v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetFaceDetectionWindowParam(H16ISP::H16ISPDevice *a1, int a2, void *a3)
{
  bzero(v7, 0x14uLL);
  __int16 v8 = 3341;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x14u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetLensTemperature(H16ISP::H16ISPDevice *this, int a2, int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1961;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableHighFrameRateAF(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1038;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableReplaySifDMA(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 355;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::WritePropertyValue(H16ISP::H16ISPDevice *this, int a2, int a3, int a4, unsigned int a5)
{
  bzero(v15, 0x14uLL);
  __int16 v16 = 290;
  int v17 = a2;
  int v18 = a3;
  int v19 = a4;
  uint64_t v10 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x14u, 0, a5);
  uint64_t v11 = v10;
  if (a3 == 6914 && !v10)
  {
    if (*((_DWORD *)this + 1187))
    {
      unsigned int v12 = 0;
      while (1)
      {
        uint64_t updated = H16ISP::H16ISPDevice::UpdateChannelConfigCache(this, v12);
        if (updated) {
          break;
        }
        if (++v12 >= *((_DWORD *)this + 1187)) {
          return 0;
        }
      }
      uint64_t v11 = updated;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::WritePropertyValue();
      }
    }
    else
    {
      return 0;
    }
  }
  return v11;
}

uint64_t H16ISP::H16ISPDevice::ReadPropertyValue(H16ISP::H16ISPDevice *this, int a2, int a3, unsigned int *a4, unsigned int a5)
{
  bzero(v11, 0x14uLL);
  __int16 v12 = 291;
  int v13 = a2;
  int v14 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v11, 0x14u, 0, a5);
  if (!result) {
    *a4 = v15;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SendFirmwareObjectSpecialFunc(H16ISP::H16ISPDevice *this, int a2, const char **a3)
{
  uint64_t v28 = *MEMORY[0x263EF8340];
  if (a2 != 6) {
    return 3758097090;
  }
  bzero(v19, 0x40uLL);
  __int16 v20 = 5;
  strncpy(v22, a3[1], 0x20uLL);
  uint64_t v5 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v19, 0x40u, 1u, 0xFFFFFFFF);
  if (v5)
  {
    uint64_t v6 = v5;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::SendFirmwareObjectSpecialFunc((uint64_t)(a3 + 1), v6, v7, v8, v9, v10, v11, v12);
    }
  }
  else
  {
    unint64_t v13 = v27;
    unint64_t v14 = strtoul(a3[2], 0, 0);
    unint64_t v15 = strtoul(a3[3], 0, 0);
    unint64_t v16 = strtoul(a3[4], 0, 0);
    unint64_t v17 = strtoul(a3[5], 0, 0);
    printf("Special function: name: %s, parameters %llu %llu %llu %llu\n", v22, v14, v15, v16, v17);
    bzero(v19, 0x38uLL);
    __int16 v20 = 28;
    int v21 = 1;
    unint64_t v23 = v13;
    unint64_t v24 = v14;
    unint64_t v25 = v15;
    unint64_t v26 = v16;
    unint64_t v27 = v17;
    return H16ISP::H16ISPDevice::ISP_SendCommand(this, v19, 0x38u, 1u, 0xFFFFFFFF);
  }
  return v6;
}

uint64_t H16ISP::H16ISPDevice::SetBinningMode(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1293;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetFocusMode(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31734;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetAFMatrixModeConfig(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int16 *a7)
{
  bzero(v15, 0x18uLL);
  __int16 v16 = -31732;
  int v17 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x18u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v18;
    *a4 = v19;
    *a5 = v20;
    *a6 = v21;
    *a7 = v22;
  }
  return result;
}

void H16ISP::H16ISPDevice::GetLSC(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned __int8 *a5, unsigned __int16 *a6, unsigned __int8 *a7, unsigned __int8 *a8, float *a9, float *a10)
{
}

float H16ISP::H16ISPDevice::GetLSCStrength(H16ISP::H16ISPDevice *this, int a2, float *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2637;
  int v9 = a2;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF))
  {
    float result = v10;
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::LTMUpdateSuspend(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 8194;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::LTMUpdateResume(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 8195;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::LTMStateSet(H16ISP::H16ISPDevice *this, int a2, int a3, __int16 a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 8201;
  int v11 = a2;
  int v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::LTMHWConfigSet(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2633;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::LSCIdealPercentSet(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2638;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::CLRProcGammaConfigSet(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2634;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::LSCModulationSuspend(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0x10uLL);
  __int16 v6 = 2610;
  int v7 = a2;
  char v8 = 1;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::LSCModulationResume(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0x10uLL);
  __int16 v6 = 2610;
  int v7 = a2;
  char v8 = 0;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetTNRAlgorithm(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -16103;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetOISPosition(H16ISP::H16ISPDevice *this, int a2, int a3, int a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 1856;
  int v11 = a2;
  int v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetOISPosition(H16ISP::H16ISPDevice *this, int a2, int *a3, int *a4, __int16 *a5, __int16 *a6)
{
  bzero(v14, 0x18uLL);
  __int16 v15 = 1857;
  int v16 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v14, 0x18u, 0, 0xFFFFFFFF);
  if (!result)
  {
    int v13 = v18;
    *a3 = v17;
    *a4 = v13;
    *a5 = v19;
    *a6 = v20;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetOISParams(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1858;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetOISMode(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1862;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetOISTemperature(H16ISP::H16ISPDevice *this, int a2, __int16 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1860;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetOISStatus(H16ISP::H16ISPDevice *this, int a2, int *a3, __int16 *a4, __int16 *a5, __int16 *a6, __int16 *a7, __int16 *a8)
{
  bzero(v17, 0x1CuLL);
  __int16 v18 = 1861;
  int v19 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v17, 0x1Cu, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v20;
    *a4 = v21;
    *a5 = v22;
    *a6 = v23;
    *a7 = v24;
    *a8 = v25;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetOISContactStop(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1872;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableRawAverageMetadata(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -16361;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableLocalHistogram(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -16358;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetVISParams(H16ISP::H16ISPDevice *this, int a2, int a3, int a4, int a5, int a6)
{
  bzero(v13, 0x1CuLL);
  __int16 v14 = 18177;
  int v15 = a2;
  int v16 = a3;
  int v17 = a4;
  int v18 = a5;
  int v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DisableHardwareBlock(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -32511;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableHardwareBlock(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -32512;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetFlickerFrequencyHint(H16ISP::H16ISPDevice *this, int a2, double a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -32238;
  int v9 = a2;
  unsigned int v10 = vcvtd_n_u64_f64(a3, 0x10uLL);
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetFlickerFrequency(uint64_t a1, uint64_t a2)
{
  bzero(v25, 0xD8uLL);
  uint64_t v4 = 0;
  v25[2] = 20;
  unsigned int v26 = v26 & 0x7FFF0000 | 0x80000000;
  int v5 = *(_DWORD *)(a2 + 4);
  char v27 = *(_DWORD *)a2;
  char v28 = v5;
  unsigned int v6 = vcvtd_n_s64_f64(*(double *)(a2 + 72), 0x10uLL);
  int v7 = *(_DWORD *)(a2 + 104);
  __int16 v29 = *(_DWORD *)(a2 + 108);
  unsigned int v32 = v6;
  int v34 = v7;
  long long v33 = *(_OWORD *)(a2 + 80);
  char v8 = 1;
  do
  {
    char v9 = v8;
    unsigned int v10 = (double *)(a2 + 8 * v4);
    v30[v4] = vcvtd_n_u64_f64(v10[1], 0x10uLL);
    int v11 = &v25[v4];
    v11[12] = (int)v10[3];
    v11[14] = vcvtd_n_s64_f64(v10[5], 8uLL);
    uint64_t v4 = 1;
    char v8 = 0;
  }
  while ((v9 & 1) != 0);
  int32x2_t v31 = vmovn_s64(vcvtq_n_s64_f64(*(float64x2_t *)(a2 + 56), 0x10uLL));
  long long v12 = *(_OWORD *)(a2 + 132);
  long long v35 = *(_OWORD *)(a2 + 116);
  long long v36 = v12;
  long long v37 = *(_OWORD *)(a2 + 148);
  uint64_t v38 = *(void *)(a2 + 164);
  long long v41 = *(_OWORD *)(a2 + 204);
  long long v42 = *(_OWORD *)(a2 + 220);
  v43[0] = *(_OWORD *)(a2 + 236);
  *(_OWORD *)((char *)v43 + 14) = *(_OWORD *)(a2 + 250);
  long long v39 = *(_OWORD *)(a2 + 172);
  long long v40 = *(_OWORD *)(a2 + 188);
  H16ISP::H16ISPDevice::ISP_SendCommand((H16ISP::H16ISPDevice *)a1, (unsigned __int8 *)v25, 0xD8u, 0, 0xFFFFFFFF);
  BOOL v24 = 0;
  uint64_t ExclaveEnablementStatus = H16ISP::H16ISPDevice::ISP_GetExclaveEnablementStatus((H16ISP::H16ISPDevice *)a1, &v24);
  if (ExclaveEnablementStatus) {
    return ExclaveEnablementStatus;
  }
  if (!v24) {
    return 0;
  }
  int v14 = *(_DWORD *)(a1 + 96);
  if (v14 == 2)
  {
    uint64_t ExclaveEnablementStatus = 3758097084;
    if (!*(void *)(a1 + 184)) {
      return ExclaveEnablementStatus;
    }
    mach_absolute_time();
    FigHostTimeToNanoseconds();
    if (isprgbexclavekitmodule_isprgbexclavekit_sendcmdaeflickerfreqset())
    {
      int v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        int v15 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v15;
      }
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
        goto LABEL_12;
      }
      return ExclaveEnablementStatus;
    }
    return 0;
  }
  uint64_t ExclaveEnablementStatus = 0;
  if (v14 != 3) {
    return ExclaveEnablementStatus;
  }
  uint64_t ExclaveEnablementStatus = 3758097084;
  if (!*(void *)(a1 + 136)) {
    return ExclaveEnablementStatus;
  }
  mach_absolute_time();
  FigHostTimeToNanoseconds();
  if (!ispirexclavekitmodule_ispirexclavekit_sendcmdaeflickerfreqset()) {
    return 0;
  }
  int v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    int v15 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v15;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
LABEL_12:
  }
    H16ISP::H16ISPDevice::SetFlickerFrequency(v15, v16, v17, v18, v19, v20, v21, v22);
  return ExclaveEnablementStatus;
}

uint64_t H16ISP::H16ISPDevice::SuspendAEHdrRatioUpdate(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 570;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ResumeAEHdrRatioUpdate(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 571;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetHDRRatioManual(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -15608;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableMotionCaptureControl(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 17920;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SendAccelerometerSampleToFirmware(H16ISP::H16ISPDevice *this, uint64_t a2, int a3, int a4, int a5)
{
  bzero(v11, 0x1CuLL);
  __int16 v12 = 17921;
  uint64_t v13 = a2;
  int v14 = a3;
  int v15 = a4;
  int v16 = a5;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v11, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableRowColSumStats(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -16359;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetRowColSumWindow(H16ISP::H16ISPDevice *a1, int a2, uint64_t a3)
{
  bzero(v7, 0x14uLL);
  __int16 v8 = -16360;
  int v9 = a2;
  uint64_t v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEPanoMaxExpAdjustment(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 568;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAEPanoMaxExpAdjustment(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 569;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableHITH(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 8206;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableSemanticMasks(H16ISP::H16ISPDevice *this, int a2, char a3, char a4, char a5, char a6)
{
  bzero(v13, 0x10uLL);
  __int16 v14 = 2842;
  int v15 = a2;
  char v16 = a3;
  char v17 = a4;
  char v18 = a5;
  char v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableBand0Modulation(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -16100;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::TNRSuspend(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = -16108;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableAWBMultiIlluminant(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31959;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableANSTThumbnail(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2848;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMaxCurrentTorch(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1560;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMaxCurrentFlashLight(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1562;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMaxCurrentPreFlash(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1558;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMaxCurrentMainFlash(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1559;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::OverrideTotalStrobeMaxCurrent(H16ISP::H16ISPDevice *this, int a2, int a3, int a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 1561;
  int v11 = a2;
  int v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetTorchManualLevel(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v10, 0x10uLL);
  __int16 v11 = 1541;
  int v12 = a2;
  __int16 v13 = a3;
  uint64_t v6 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v10, 0x10u, 0, 0xFFFFFFFF);
  H16ISP::H16ISPDevice::GetTorchCurrents(this, a2, &v9, &v8);
  return v6;
}

uint64_t H16ISP::H16ISPDevice::GetTorchCurrents(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  bzero(v16, 0x10uLL);
  *(_WORD *)&v16[4] = 1543;
  *(_DWORD *)&v16[8] = a2;
  uint64_t v8 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v16, 0x10u, 0, 0xFFFFFFFF);
  if (!v8)
  {
    if (*((unsigned char *)this + 4720))
    {
      unsigned __int16 v9 = *(NSObject **)(*((void *)this + 9) + 72);
      if (v9)
      {
        block[0] = MEMORY[0x263EF8330];
        block[1] = 0x40000000;
        block[2] = ___ZN6H16ISP12H16ISPDevice16GetTorchCurrentsEjPtS1__block_invoke;
        block[3] = &__block_descriptor_tmp_121;
        block[4] = this;
        long long v15 = *(_OWORD *)v16;
        dispatch_async(v9, block);
      }
    }
    if (*((unsigned char *)this + 4736))
    {
      __int16 v10 = *(NSObject **)(*((void *)this + 9) + 72);
      if (v10)
      {
        v12[0] = MEMORY[0x263EF8330];
        v12[1] = 0x40000000;
        v12[2] = ___ZN6H16ISP12H16ISPDevice16GetTorchCurrentsEjPtS1__block_invoke_2;
        v12[3] = &__block_descriptor_tmp_122;
        v12[4] = this;
        long long v13 = *(_OWORD *)v16;
        dispatch_async(v10, v12);
      }
    }
    *a3 = *(_WORD *)&v16[12];
    *a4 = *(_WORD *)&v16[14];
  }
  return v8;
}

uint64_t H16ISP::H16ISPDevice::SetTorchColorMode(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v12, 0x10uLL);
  __int16 v13 = 1542;
  int v14 = a2;
  __int16 v15 = a3;
  __int16 v16 = a4;
  uint64_t v8 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v12, 0x10u, 0, 0xFFFFFFFF);
  H16ISP::H16ISPDevice::GetTorchCurrents(this, a2, &v11, &v10);
  return v8;
}

uint64_t H16ISP::H16ISPDevice::SetIndividualTorchLEDLevels(H16ISP::H16ISPDevice *this, int a2, unsigned int a3)
{
  bzero(v14, 0x10uLL);
  __int16 v15 = 1554;
  int v16 = a2;
  unsigned int v17 = a3;
  uint64_t v6 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v14, 0x10u, 0, 0xFFFFFFFF);
  if (!v6)
  {
    if (*((unsigned char *)this + 4704))
    {
      int v7 = *(NSObject **)(*((void *)this + 9) + 72);
      if (v7)
      {
        unsigned int v8 = HIBYTE(a3) + a3 + BYTE1(a3) + BYTE2(a3);
        block[0] = MEMORY[0x263EF8330];
        block[1] = 0x40000000;
        block[2] = ___ZN6H16ISP12H16ISPDevice27SetIndividualTorchLEDLevelsEjj_block_invoke;
        block[3] = &__block_descriptor_tmp_119;
        if (v8 >= 0xFF) {
          LOWORD(v8) = 255;
        }
        block[4] = this;
        __int16 v13 = v8;
        dispatch_async(v7, block);
      }
    }
  }
  H16ISP::H16ISPDevice::GetTorchCurrents(this, a2, &v11, &v10);
  return v6;
}

uint64_t ___ZN6H16ISP12H16ISPDevice27SetIndividualTorchLEDLevelsEjj_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  notify_set_state(*(_DWORD *)(v1 + 4708), *(unsigned __int16 *)(a1 + 40));
  uint64_t v2 = *(const char **)(v1 + 4696);

  return notify_post(v2);
}

uint64_t H16ISP::H16ISPDevice::SetSegmentTorchLEDLevels(H16ISP::H16ISPDevice *this, int a2, int a3, __int16 a4, unsigned int a5, unsigned __int16 *a6, const unint64_t *a7)
{
  bzero(v16, 0x6CuLL);
  __int16 v17 = 1579;
  int v18 = a2;
  uint64_t result = H16ISP::H16ISPDevice::PackTorchSegments(v14, a3, a4, a5, a6, (uint64_t)a7, (uint64_t)&v19);
  if (!result) {
    return H16ISP::H16ISPDevice::ISP_SendCommand(this, v16, 0x6Cu, 0, 0xFFFFFFFF);
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::PackTorchSegments(uint64_t a1, int a2, __int16 a3, unsigned int a4, unsigned __int16 *a5, uint64_t a6, uint64_t a7)
{
  uint64_t result = 3758097090;
  if (!a7) {
    return result;
  }
  *(_OWORD *)(a7 + 64) = 0u;
  *(_OWORD *)(a7 + 80) = 0u;
  *(_OWORD *)(a7 + 32) = 0u;
  *(_OWORD *)(a7 + 48) = 0u;
  *(_OWORD *)a7 = 0u;
  *(_OWORD *)(a7 + 16) = 0u;
  *(_WORD *)a7 = a2;
  if (!a2)
  {
    if (a4 > 8 || !a5 || !a6) {
      return result;
    }
    *(_WORD *)(a7 + 2) = a4;
    if (a4)
    {
      uint64_t v9 = 0;
      uint64_t v10 = a7 + 24;
      do
      {
        unsigned int v11 = a5[v9];
        if (v11 >= 0xFF) {
          LOWORD(v11) = 255;
        }
        *(_WORD *)(v10 + 2 * v9 - 20) = v11;
        *(void *)(v10 + 8 * v9) = *(void *)(a6 + 8 * v9);
        ++v9;
      }
      while (a4 != v9);
    }
    return 0;
  }
  if (a2 != 170) {
    return 3758097122;
  }
  *(_WORD *)(a7 + 2) = a3;
  if (!a5) {
    return 0;
  }
  uint64_t result = 0;
  unsigned int v8 = *a5;
  if (v8 >= 0xFF) {
    LOWORD(v8) = 255;
  }
  *(_WORD *)(a7 + 4) = v8;
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetTorchBeamWidth(H16ISP::H16ISPDevice *this, __int16 a2, float a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1584;
  __int16 v9 = a2;
  float v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetScalerCrop(H16ISP::H16ISPDevice *a1, int a2, unint64_t a3, unint64_t a4)
{
  int v4 = a4;
  int v5 = a3;
  unint64_t v8 = HIDWORD(a3);
  unint64_t v9 = HIDWORD(a4);
  bzero(v11, 0x1CuLL);
  __int16 v12 = 2058;
  int v13 = a2;
  int v14 = v5;
  int v15 = v8;
  int v16 = v4;
  int v17 = v9;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v11, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEMode(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 565;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetPanoAELimits(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 567;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEBracketingMode(H16ISP::H16ISPDevice *this, int a2, __int16 a3, int a4)
{
  bzero(v9, 0x18uLL);
  __int16 v10 = 564;
  int v11 = a2;
  __int16 v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableStaticLUTForLTM(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 8198;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

__n128 H16ISP::H16ISPDevice::GetDistortionInfo(H16ISP::H16ISPDevice *a1, int a2, int a3, uint64_t a4)
{
  bzero(v14, 0xDCuLL);
  __int16 v15 = 28673;
  int v16 = a2;
  int v17 = a3;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(a1, v14, 0xDCu, 0, 0xFFFFFFFF))
  {
    long long v9 = *(_OWORD *)v29;
    *(_OWORD *)(a4 + 160) = v28;
    *(_OWORD *)(a4 + 176) = v9;
    *(_OWORD *)(a4 + 188) = *(_OWORD *)&v29[12];
    long long v10 = v25;
    *(_OWORD *)(a4 + 96) = v24;
    *(_OWORD *)(a4 + 112) = v10;
    long long v11 = v27;
    *(_OWORD *)(a4 + 128) = v26;
    *(_OWORD *)(a4 + 144) = v11;
    long long v12 = v21;
    *(_OWORD *)(a4 + 32) = v20;
    *(_OWORD *)(a4 + 48) = v12;
    long long v13 = v23;
    *(_OWORD *)(a4 + 64) = v22;
    *(_OWORD *)(a4 + 80) = v13;
    __n128 result = v19;
    *(_OWORD *)a4 = v18;
    *(__n128 *)(a4 + 16) = result;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::StartHighlightRecovery(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 4096;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::StopHighlightRecovery(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 4097;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::StartLocalToneMapping(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 0x2000;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::StopLocalToneMapping(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 8193;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableTorch(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v13, 0x10uLL);
  __int16 v14 = 1539;
  int v15 = a2;
  int v16 = a3;
  uint64_t v6 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x10u, 0, 0xFFFFFFFF);
  if (!v6)
  {
    if (*((unsigned char *)this + 4704))
    {
      int v7 = *(NSObject **)(*((void *)this + 9) + 72);
      if (v7)
      {
        block[0] = MEMORY[0x263EF8330];
        block[1] = 0x40000000;
        block[2] = ___ZN6H16ISP12H16ISPDevice11EnableTorchEjt_block_invoke;
        block[3] = &__block_descriptor_tmp_120;
        block[4] = this;
        __int16 v12 = a3;
        dispatch_async(v7, block);
      }
    }
  }
  H16ISP::H16ISPDevice::GetTorchCurrents(this, a2, &v10, &v9);
  return v6;
}

uint64_t ___ZN6H16ISP12H16ISPDevice11EnableTorchEjt_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  notify_set_state(*(_DWORD *)(v1 + 4708), *(unsigned __int16 *)(a1 + 40));
  uint64_t v2 = *(const char **)(v1 + 4696);

  return notify_post(v2);
}

uint64_t ___ZN6H16ISP12H16ISPDevice16GetTorchCurrentsEjPtS1__block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  notify_set_state(*(_DWORD *)(v1 + 4724), *(unsigned __int16 *)(a1 + 52));
  uint64_t v2 = *(const char **)(v1 + 4712);

  return notify_post(v2);
}

uint64_t ___ZN6H16ISP12H16ISPDevice16GetTorchCurrentsEjPtS1__block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  notify_set_state(*(_DWORD *)(v1 + 4740), *(unsigned __int16 *)(a1 + 54));
  uint64_t v2 = *(const char **)(v1 + 4728);

  return notify_post(v2);
}

uint64_t H16ISP::H16ISPDevice::DisableTorch(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v10, 0xCuLL);
  __int16 v11 = 1538;
  int v12 = a2;
  uint64_t v4 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v10, 0xCu, 0, 0xFFFFFFFF);
  if (!v4)
  {
    if (*((unsigned char *)this + 4704))
    {
      int v5 = *(NSObject **)(*((void *)this + 9) + 72);
      if (v5)
      {
        block[0] = MEMORY[0x263EF8330];
        block[1] = 0x40000000;
        block[2] = ___ZN6H16ISP12H16ISPDevice12DisableTorchEj_block_invoke;
        block[3] = &__block_descriptor_tmp_123;
        block[4] = this;
        dispatch_async(v5, block);
      }
    }
  }
  H16ISP::H16ISPDevice::GetTorchCurrents(this, a2, &v8, &v7);
  return v4;
}

uint64_t ___ZN6H16ISP12H16ISPDevice12DisableTorchEj_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  notify_set_state(*(_DWORD *)(v1 + 4708), 0);
  uint64_t v2 = *(const char **)(v1 + 4696);

  return notify_post(v2);
}

uint64_t H16ISP::H16ISPDevice::SetManualFocusPosition(H16ISP::H16ISPDevice *this, int a2, char a3, int a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 1794;
  int v11 = a2;
  char v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableKnobManualMode(H16ISP::H16ISPDevice *a1, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2579;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetSharpness(H16ISP::H16ISPDevice *a1, int a2, int a3, unsigned char *a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 2579;
  int v11 = a2;
  int v12 = 1;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x10u, 0, 0xFFFFFFFF);
  if (!result)
  {
    bzero(v9, 0x14uLL);
    __int16 v10 = 2570;
    int v11 = a2;
    int v12 = a3;
    uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x14u, 0, 0xFFFFFFFF);
    if (!result) {
      *a4 = v13;
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetLCEStrength(H16ISP::H16ISPDevice *a1, __int16 a2, int a3, unsigned char *a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 2625;
  __int16 v11 = a2;
  int v12 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x14u, 0, 0xFFFFFFFF);
  if (!result) {
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetRNFStrength(H16ISP::H16ISPDevice *a1, __int16 a2, int a3, unsigned char *a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 2622;
  __int16 v11 = a2;
  int v12 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x14u, 0, 0xFFFFFFFF);
  if (!result) {
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetChromaSupression(H16ISP::H16ISPDevice *this, int a2, char a3, char a4, char a5)
{
  bzero(v11, 0x10uLL);
  __int16 v12 = 2579;
  int v13 = a2;
  int v14 = 2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v11, 0x10u, 0, 0xFFFFFFFF);
  if (!result)
  {
    bzero(v11, 0x10uLL);
    __int16 v12 = 2573;
    int v13 = a2;
    LOBYTE(v14) = a3;
    BYTE1(v14) = a4;
    BYTE2(v14) = a5;
    return H16ISP::H16ISPDevice::ISP_SendCommand(this, v11, 0x10u, 0, 0xFFFFFFFF);
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableBPC(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  if (a3)
  {
    bzero(v7, 0xCuLL);
    __int16 v5 = 2050;
  }
  else
  {
    bzero(v7, 0xCuLL);
    __int16 v5 = 2051;
  }
  __int16 v8 = v5;
  int v9 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEIntegrationTime(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 527;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetHDRRatioClipScoreIIRStrength(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -15610;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetHDRRatioHightLightClipDetectSensitivity(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -15609;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetOISActuator(H16ISP::H16ISPDevice *this, int a2, __int16 *a3, __int16 *a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1871;
  int v11 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v12;
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetOISActuator(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1866;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableFocusPixels(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31728;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableContinuousFocus(H16ISP::H16ISPDevice *this, int a2, char a3, char a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = -31729;
  int v11 = a2;
  char v13 = a4;
  char v12 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableFocusDACLimiting(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1800;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAWBManualGain(H16ISP::H16ISPDevice *this, int a2, int a3, int a4, int a5, int a6)
{
  bzero(v13, 0x1CuLL);
  __int16 v14 = 786;
  int v15 = a2;
  int v16 = a3;
  int v17 = a4;
  int v18 = a5;
  int v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetSyncZoomFactorLimits(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 2067;
  int v11 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v12;
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetCurrentZoomFactor(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 2065;
  int v11 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v12;
    *a4 = v13;
  }
  return result;
}

double H16ISP::H16ISPDevice::GetAEParams(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6, unsigned int *a7, double *a8)
{
  bzero(v19, 0x24uLL);
  __int16 v20 = 530;
  int v21 = a2;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(this, v19, 0x24u, 0, 0xFFFFFFFF))
  {
    unsigned int v17 = v23;
    *a3 = v22;
    *a4 = v17;
    unsigned int v18 = v25;
    *a5 = v24;
    *a6 = v18;
    *a7 = v26;
    LODWORD(result) = v27;
    double result = (double)*(unint64_t *)&result * 0.0000152587891;
    *a8 = result;
  }
  return result;
}

__n128 H16ISP::H16ISPDevice::GetAWBCalibrationMatrix(H16ISP::H16ISPDevice *a1, int a2, uint64_t a3)
{
  bzero(v8, 0x5CuLL);
  __int16 v9 = -31973;
  int v10 = a2;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(a1, v8, 0x5Cu, 0, 0xFFFFFFFF))
  {
    __n128 result = v12;
    long long v7 = v14;
    *(_OWORD *)(a3 + 32) = v13;
    *(_OWORD *)(a3 + 48) = v7;
    *(_OWORD *)(a3 + 64) = v15;
    *(_OWORD *)a3 = v11;
    *(__n128 *)(a3 + 16) = result;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetZoomFactor(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2064;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetTargetToHostFrameDeliveryCadenceInMicroSeconds(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 13;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::TimeMachineCapture(H16ISP::H16ISPDevice *a1, int a2, __int16 a3, __int16 a4, uint64_t a5, __int16 a6, long long *a7)
{
  bzero(v16, 0x30uLL);
  __int16 v17 = 298;
  int v18 = a2;
  __int16 v20 = a3;
  __int16 v19 = a4;
  uint64_t v22 = a5;
  if (a5) {
    __int16 v14 = 1;
  }
  else {
    __int16 v14 = 2;
  }
  __int16 v21 = v14;
  __int16 v23 = a6;
  if (a7) {
    long long v24 = *a7;
  }
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v16, 0x30u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DPCStart(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = -15091;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DPCStop(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = -15090;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEAGC(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 514;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetManualCCT(H16ISP::H16ISPDevice *this, int a2, unsigned int a3, int a4, int a5)
{
  bzero(v10, 0x14uLL);
  __int16 v11 = 773;
  int v12 = a2;
  int v13 = a4;
  int v14 = a5;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v10, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAFWindow(H16ISP::H16ISPDevice *this, int a2, int a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  bzero(v15, 0x18uLL);
  __int16 v16 = -31743;
  int v17 = a2;
  int v18 = a3;
  __int16 v19 = a4;
  __int16 v20 = a5;
  __int16 v21 = a6;
  __int16 v22 = a7;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAFWindowWeights(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  bzero(v7, 0x1CuLL);
  __int16 v8 = -31741;
  int v9 = a2;
  long long v10 = *(_OWORD *)a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEWindow(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)
{
  bzero(v13, 0x18uLL);
  __int16 v14 = -32256;
  int v15 = a2;
  int v16 = 0;
  __int16 v17 = a3;
  __int16 v18 = a4;
  __int16 v19 = a5;
  __int16 v20 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMultiCamAEWindowParams(H16ISP::H16ISPDevice *a1, unsigned int a2, const void *a3)
{
  bzero(v7, 0x70uLL);
  __int16 v8 = -32237;
  unsigned int v9 = a2;
  memcpy(&v10, a3, 16 * a2);
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x70u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMultiCamAFWindowParams(H16ISP::H16ISPDevice *a1, unsigned int a2, const void *a3)
{
  bzero(v7, 0x3B8uLL);
  __int16 v8 = -31716;
  unsigned int v9 = a2;
  memcpy(&v10, a3, 156 * a2);
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x3B8u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMultiCamROIForCameraControls(H16ISP::H16ISPDevice *a1, unsigned int a2, const void *a3)
{
  bzero(v7, 0x58uLL);
  __int16 v8 = 2073;
  unsigned int v9 = a2;
  memcpy(&v10, a3, 12 * a2);
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x58u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMultiCamLumaHistogramROI(H16ISP::H16ISPDevice *a1, unsigned int a2, const void *a3)
{
  bzero(v7, 0x70uLL);
  __int16 v8 = 2074;
  unsigned int v9 = a2;
  memcpy(&v10, a3, 16 * a2);
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x70u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAWBWindow(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)
{
  bzero(v13, 0x18uLL);
  __int16 v14 = -31997;
  int v15 = a2;
  int v16 = 1;
  __int16 v17 = a3;
  __int16 v18 = a4;
  __int16 v19 = a5;
  __int16 v20 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableAFPeakPrediction(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31739;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetISPDGain(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 544;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetSensorDGain(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 543;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetMaxIntegrationTime(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 525;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetMinIntegrationTime(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 554;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetMinimumGainCap(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 558;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEMaxGainCapWithExposureUpdate(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 560;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEGainCapOffExposureUpdate(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 562;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAWB1stGainManual(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  bzero(v15, 0x18uLL);
  __int16 v16 = 785;
  int v17 = a2;
  __int16 v18 = a3;
  __int16 v19 = a4;
  __int16 v20 = a5;
  __int16 v21 = a6;
  __int16 v22 = a7;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetMinimumGainCap(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 557;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  *a3 = v10;
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetAEMaxGainCapWithExposureUpdate(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 559;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  *a3 = v10;
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetAEGainCapOffExposureUpdate(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 561;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  *a3 = v10;
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAEOutlierClipCount(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 518;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEConvergenceSpeed(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 536;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAPSDistance(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1922;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAPSDistance(H16ISP::H16ISPDevice *this, int a2, int *a3, int *a4)
{
  bzero(v10, 0x14uLL);
  __int16 v11 = 1923;
  int v12 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v10, 0x14u, 0, 0xFFFFFFFF);
  if (!result)
  {
    int v9 = v14;
    *a3 = v13;
    *a4 = v9;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAPSPosition(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1920;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetLumaHistogramROI(H16ISP::H16ISPDevice *a1, int a2, char a3, uint64_t a4)
{
  bzero(v9, 0x18uLL);
  __int16 v10 = 2072;
  int v11 = a2;
  char v12 = a3;
  uint64_t v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAPSPosition(H16ISP::H16ISPDevice *this, int a2, int *a3, int *a4, __int16 *a5, __int16 *a6, int *a7, int *a8, int *a9, int *a10, int *a11, int *a12, int *a13, int *a14, int *a15, int *a16)
{
  bzero(v31, 0x40uLL);
  __int16 v32 = 1921;
  int v33 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v31, 0x40u, 0, 0xFFFFFFFF);
  if (!result)
  {
    int v25 = v35;
    *a3 = v34;
    *a4 = v25;
    *a5 = v36;
    *a6 = v37;
    int v26 = v39;
    *a7 = v38;
    *a8 = v26;
    int v27 = v41;
    *a9 = v40;
    *a10 = v27;
    int v28 = v43;
    *a11 = v42;
    *a12 = v28;
    int v29 = v45;
    *a13 = v44;
    *a14 = v29;
    int v30 = v47;
    *a15 = v46;
    *a16 = v30;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetAPSMode(H16ISP::H16ISPDevice *a1, int a2, _DWORD *a3)
{
  bzero(v7, 0x10uLL);
  int v9 = a2;
  __int16 v8 = 1925;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAPSClampingMode(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1937;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAPSClampingMode(H16ISP::H16ISPDevice *this, int a2, int *a3)
{
  bzero(v7, 0x10uLL);
  int v9 = a2;
  __int16 v8 = 1938;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAPSBeta(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  int v11 = a2;
  __int16 v10 = 1926;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAPSFocusOffset(H16ISP::H16ISPDevice *this, int a2, int a3, char a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 1927;
  int v11 = a2;
  int v12 = a3;
  char v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAPSSearchRange(H16ISP::H16ISPDevice *this, int a2, int a3, int a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 1932;
  int v11 = a2;
  int v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetDynamicVoltageLevel(H16ISP::H16ISPDevice *this, int a2, char a3, float a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1666;
  int v11 = a2;
  char v13 = a3;
  __int16 v12 = vcvts_n_s32_f32(a4, 8uLL);
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetLPDPEqualization(H16ISP::H16ISPDevice *this, int a2, __int16 a3, int a4, int a5, int a6, int a7, int a8, unsigned int a9, unsigned int a10, unsigned __int16 a11)
{
  bzero(v20, 0x34uLL);
  __int16 v21 = 332;
  int v22 = a2;
  __int16 v23 = a3;
  int v24 = a4;
  int v25 = a5;
  int v26 = a6;
  int v27 = a7;
  unsigned int v31 = a9;
  unsigned int v32 = a10;
  int v28 = a8;
  int v29 = 0;
  unsigned __int16 v30 = a11;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v20, 0x34u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAPSRawOffset(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7, int a8, int a9)
{
  bzero(v18, 0x20uLL);
  int v20 = a2;
  __int16 v19 = 1930;
  __int16 v21 = a3;
  __int16 v22 = a4;
  __int16 v23 = a5;
  __int16 v24 = a6;
  __int16 v25 = a7;
  int v26 = a8;
  int v27 = a9;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v18, 0x20u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAPSEFL(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1928;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetAPSActuator(H16ISP::H16ISPDevice *this, int a2, __int16 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1960;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAPSActuator(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1929;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableAPSDelta(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1933;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAPSDeltaEnabled(H16ISP::H16ISPDevice *this, __int16 a2, BOOL *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1934;
  __int16 v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableAPSModeSwitch(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1951;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableAPSOffsetCalculation(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1952;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAPSOffsetCorrectionScheme(H16ISP::H16ISPDevice *this, __int16 a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1959;
  __int16 v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableDACClamp(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1954;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAPSManualOffset(H16ISP::H16ISPDevice *this, __int16 a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1955;
  __int16 v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableAFRingingControl(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1806;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAFRingingControl(H16ISP::H16ISPDevice *this, __int16 a2, BOOL *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1807;
  __int16 v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10 != 0;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableVibeMitigation(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1969;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableAEStageDetect(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 598;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAEStageDetect(H16ISP::H16ISPDevice *this, __int16 a2, BOOL *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 599;
  __int16 v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10 != 0;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetOISEndStopParams(H16ISP::H16ISPDevice *this, int a2, double a3, double a4, double a5, double a6)
{
  bzero(v13, 0x1CuLL);
  __int16 v14 = 1873;
  int v15 = a2;
  unsigned int v16 = vcvtd_n_s64_f64(a4, 8uLL);
  unsigned int v17 = vcvtd_n_s64_f64(a3, 8uLL);
  unsigned int v18 = vcvtd_n_s64_f64(a6, 8uLL);
  unsigned int v19 = vcvtd_n_s64_f64(a5, 8uLL);
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetOISIdentificationCalibration(H16ISP::H16ISPDevice *a1, __int16 a2, long long *a3)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  bzero(v9, 0x50uLL);
  __int16 v10 = 1942;
  __int16 v11 = a2;
  long long v6 = *a3;
  long long v13 = a3[1];
  long long v7 = a3[3];
  long long v14 = a3[2];
  long long v15 = v7;
  int v16 = *((_DWORD *)a3 + 16);
  long long v12 = v6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x50u, 0, 0xFFFFFFFF);
}

__n128 H16ISP::H16ISPDevice::RunOISIdentificationCalibration(H16ISP::H16ISPDevice *a1, __int16 a2, uint64_t a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  bzero(v8, 0x50uLL);
  __int16 v9 = 1941;
  __int16 v10 = a2;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(a1, v8, 0x50u, 0, 3u))
  {
    __n128 result = v12;
    long long v7 = v14;
    *(_OWORD *)(a3 + 32) = v13;
    *(_OWORD *)(a3 + 48) = v7;
    *(_DWORD *)(a3 + 64) = v15;
    *(_OWORD *)a3 = v11;
    *(__n128 *)(a3 + 16) = result;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetOISEndStopCalibration(H16ISP::H16ISPDevice *a1, __int16 a2, long long *a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  bzero(v8, 0x48uLL);
  __int16 v9 = 1948;
  __int16 v10 = a2;
  long long v6 = a3[1];
  long long v11 = *a3;
  long long v12 = v6;
  *(_OWORD *)long long v13 = a3[2];
  *(_OWORD *)&v13[12] = *(long long *)((char *)a3 + 44);
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v8, 0x48u, 0, 0xFFFFFFFF);
}

double H16ISP::H16ISPDevice::RunOISEndStopCalibration(H16ISP::H16ISPDevice *a1, __int16 a2, _OWORD *a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  bzero(v8, 0x48uLL);
  __int16 v9 = 1947;
  __int16 v10 = a2;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(a1, v8, 0x48u, 0, 3u))
  {
    long long v7 = v12;
    *a3 = v11;
    a3[1] = v7;
    a3[2] = *(_OWORD *)v13;
    double result = *(double *)&v13[12];
    *(_OWORD *)((char *)a3 + 44) = *(_OWORD *)&v13[12];
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAFIdentificationCalibration(H16ISP::H16ISPDevice *a1, __int16 a2, long long *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  bzero(v9, 0x4CuLL);
  __int16 v10 = 1944;
  __int16 v11 = a2;
  long long v6 = a3[1];
  long long v12 = *a3;
  long long v13 = v6;
  long long v7 = a3[3];
  long long v14 = a3[2];
  long long v15 = v7;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x4Cu, 0, 0xFFFFFFFF);
}

double H16ISP::H16ISPDevice::RunAFIdentificationCalibration(H16ISP::H16ISPDevice *a1, __int16 a2, _OWORD *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  bzero(v9, 0x4CuLL);
  __int16 v10 = 1943;
  __int16 v11 = a2;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x4Cu, 0, 3u))
  {
    long long v7 = v13;
    *a3 = v12;
    a3[1] = v7;
    double result = *(double *)&v14;
    long long v8 = v15;
    a3[2] = v14;
    a3[3] = v8;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAPSOISInteractionCalibration(H16ISP::H16ISPDevice *a1, __int16 a2, long long *a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  bzero(v9, 0x60uLL);
  long long v6 = a3[3];
  long long v14 = a3[2];
  long long v15 = v6;
  long long v16 = a3[4];
  long long v7 = a3[1];
  long long v12 = *a3;
  __int16 v10 = 1946;
  __int16 v11 = a2;
  int v17 = *((_DWORD *)a3 + 20);
  long long v13 = v7;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x60u, 0, 0xFFFFFFFF);
}

double H16ISP::H16ISPDevice::RunAPSOISInteractionCalibration(H16ISP::H16ISPDevice *a1, __int16 a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  bzero(v9, 0x60uLL);
  __int16 v10 = 1945;
  __int16 v11 = a2;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x60u, 0, 3u))
  {
    long long v7 = v15;
    *(_OWORD *)(a3 + 32) = v14;
    *(_OWORD *)(a3 + 48) = v7;
    *(_OWORD *)(a3 + 64) = v16;
    *(_DWORD *)(a3 + 80) = v17;
    double result = *(double *)&v12;
    long long v8 = v13;
    *(_OWORD *)a3 = v12;
    *(_OWORD *)(a3 + 16) = v8;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetCNRLevel(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2605;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetCNRLevel(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2606;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetNoiseReductionLevel(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2571;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetNoiseReductionLevel(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2572;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetDynamicVoltageEnable(H16ISP::H16ISPDevice *this, unsigned __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1664;
  int v9 = v9 & 0x7FFF0000 | a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetProResSharpeningTuning(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2841;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetIrRgbStereo(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 31;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetPrimaryFrameSkippingRatio(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 367;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMasterSlaveAPSFocus(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31722;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMasterSlaveContrastFocus(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31721;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetFocusSlavePos(H16ISP::H16ISPDevice *this, int a2, int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31720;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetFocusSlaveDistance(H16ISP::H16ISPDevice *this, int a2, int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31719;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAFEarlyOutParams(H16ISP::H16ISPDevice *this, int a2, char a3, char a4, char a5, char a6)
{
  bzero(v13, 0x10uLL);
  __int16 v14 = 1027;
  int v15 = a2;
  char v16 = a3;
  char v17 = a4;
  char v18 = a5;
  char v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetScalerSharpening(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2567;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetCurrentCCT(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 772;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetManualCCTRange(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3, unsigned int *a4)
{
  bzero(v10, 0x14uLL);
  __int16 v11 = 787;
  int v12 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v10, 0x14u, 0, 0xFFFFFFFF);
  if (!result)
  {
    unsigned int v9 = v14;
    *a3 = v13;
    *a4 = v9;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetColorCalibrationData(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 2052;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetExposureBias(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 515;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetAEStable(H16ISP::H16ISPDevice *this, __int16 a2, unsigned __int8 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 595;
  __int16 v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetAWBStable(H16ISP::H16ISPDevice *this, __int16 a2, unsigned __int8 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31965;
  __int16 v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetSensorCustomSettings(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3, unsigned __int16 *a4, unsigned __int8 *a5)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  unsigned int v6 = *((_DWORD *)this + 1187);
  uint64_t result = 3758097090;
  if (v6 > a2 && a3 <= 0x40)
  {
    bzero(v13, 0xD0uLL);
    __int16 v14 = 1285;
    unsigned int v15 = a2;
    __int16 v16 = a3;
    if (a3)
    {
      uint64_t v12 = 0;
      do
      {
        v17[v12] = a4[v12];
        *((unsigned char *)&v17[64] + v12) = a5[v12];
        ++v12;
      }
      while (a3 != v12);
    }
    return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0xD0u, 0, 0xFFFFFFFF);
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetAFLimits(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1792;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAFLimits(H16ISP::H16ISPDevice *this, int a2, __int16 *a3, __int16 *a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1793;
  int v11 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v12;
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetPreflashParams(H16ISP::H16ISPDevice *this, int a2, char a3, char a4, char a5, char a6)
{
  bzero(v13, 0x10uLL);
  __int16 v14 = 549;
  int v15 = a2;
  char v16 = a3;
  char v17 = a4;
  char v18 = a5;
  char v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAWBFlashGain(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, __int16 a5)
{
  bzero(v11, 0x14uLL);
  __int16 v12 = 782;
  int v13 = a2;
  __int16 v14 = a3;
  __int16 v15 = a4;
  __int16 v16 = a5;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v11, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableFullResLSC(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 2577;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DisableFullResLSC(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 2578;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAETarget(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 548;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAETarget(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 547;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ProcessRawStart(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 265;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ProcessRawStop(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 266;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAWBScheme(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31995;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAWBScheme(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31994;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetCurrentFocusPosition(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1795;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetCurrentFocusDacPosition(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1801;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetMaxResolutionSensorConfigIndex(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned __int16 *a3)
{
  uint64_t v3 = 3758097084;
  if (*((unsigned char *)this + 4))
  {
    if (*((_DWORD *)this + 1187) >= a2)
    {
      uint64_t v4 = *((void *)this + 5);
      uint64_t v5 = *(unsigned int *)(v4 + 432 * a2);
      if (v5)
      {
        uint64_t v6 = 0;
        char v7 = 0;
        unsigned __int16 v8 = 0;
        unsigned __int16 v9 = 0;
        unsigned __int16 v10 = (unsigned __int16 *)(*(void *)(v4 + 432 * a2 + 8) + 6);
        do
        {
          if (*(v10 - 1) >= v9 && *v10 >= v8)
          {
            *a3 = v6;
            unsigned __int16 v9 = *(v10 - 1);
            unsigned __int16 v8 = *v10;
            char v7 = 1;
          }
          ++v6;
          v10 += 106;
        }
        while (v5 != v6);
        if (v7) {
          return 0;
        }
        else {
          return 3758097084;
        }
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v3 = 3758097112;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::GetMaxResolutionSensorConfigIndex();
    }
  }
  return v3;
}

uint64_t H16ISP::H16ISPDevice::SetStatsFEThumbnailMaskConfig(H16ISP::H16ISPDevice *this, int a2, char a3, char a4, char a5, char a6, unsigned __int16 *a7)
{
  if (*((_DWORD *)this + 1187) < (unsigned __int16)a2) {
    return 3758097090;
  }
  uint64_t v8 = 0xC01E00000000;
  int v15 = 0;
  int v9 = a2;
  char v10 = a3;
  char v11 = a4;
  char v12 = a5;
  char v13 = a6;
  uint64_t v14 = *(void *)a7;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, (unsigned __int8 *)&v8, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableStatsFEThumbnailMask(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 a3)
{
  if (*((_DWORD *)this + 1187) < (unsigned __int16)a2) {
    return 3758097090;
  }
  uint64_t v4 = 0xC01D00000000;
  int v5 = a2;
  int v6 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, (unsigned __int8 *)&v4, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableDesGenFlow2Features(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  if (*((_DWORD *)this + 1187) < (unsigned __int16)a2) {
    return 3758097090;
  }
  uint64_t v4 = 0x380000000000;
  int v5 = a2;
  int v6 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, (unsigned __int8 *)&v4, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetMLVNRConfiguration(H16ISP::H16ISPDevice *a1, unsigned __int16 a2, int a3, int a4, int a5, int a6, int a7, char a8)
{
  if (a2 > *((_DWORD *)a1 + 1187)) {
    return 3758097090;
  }
  uint64_t v9 = 0xC11F00000000;
  uint64_t v16 = 0;
  int v10 = a2;
  int v11 = a3;
  int v12 = a4;
  int v13 = a5;
  int v14 = a6;
  int v15 = a7;
  BYTE4(v16) = a8;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, (unsigned __int8 *)&v9, 0x28u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetCommonBufferPool(H16ISP::H16ISPDevice *this, int a2, char a3, __int16 a4, unsigned __int8 *a5, size_t a6)
{
  *(void *)&v18[45] = *MEMORY[0x263EF8340];
  bzero(v13, 0x3CuLL);
  __int16 v14 = 363;
  int v15 = a2;
  char v17 = a3;
  __int16 v16 = a4;
  memcpy(v18, a5, a6);
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x3Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetRegistrationPriority(H16ISP::H16ISPDevice *a1, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -16098;
  int v9 = a2;
  BOOL v10 = a3 != 0;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DCS_FPGACtrl(H16ISP::H16ISPDevice *this, char a2, char a3)
{
  bzero(v7, 0xCuLL);
  __int16 v8 = -24572;
  char v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DCS_FPGAStatusQuery(H16ISP::H16ISPDevice *a1, _OWORD *a2)
{
  if (!a2) {
    return 3758097090;
  }
  bzero(v5, 0x1CuLL);
  *(_WORD *)&unsigned __int8 v5[4] = -24573;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v5, 0x1Cu, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a2 = *(_OWORD *)v5;
    *(_OWORD *)((char *)a2 + 12) = *(_OWORD *)&v5[12];
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::DCS_FPGASyncOffsetCtrl(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -24569;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DCS_FPGASyncCtrl(H16ISP::H16ISPDevice *this, int a2, char a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = -24570;
  int v11 = a2;
  char v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetHistogramWindow(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)
{
  bzero(v13, 0x14uLL);
  __int16 v14 = 2587;
  int v15 = a2;
  __int16 v16 = a3;
  __int16 v17 = a4;
  __int16 v18 = a5;
  __int16 v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAFFocusPosOverride(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31738;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAEMaxFrameRateGainLimit(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -32247;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetAEMaxFrameRateGainLimit(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -32246;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  *a3 = v10;
  return result;
}

uint64_t H16ISP::H16ISPDevice::BinningCompensationStart(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = -15872;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::BinningCompensationStop(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = -15871;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DRCStart(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 3072;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SNFStart(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = -15360;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SNFStop(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = -15359;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetSNFParams(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -15358;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetSNFParams(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -15357;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::OverrideAbsoluteColorCal(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6, char a7)
{
  bzero(v15, 0x18uLL);
  __int16 v16 = 2057;
  int v17 = a2;
  __int16 v18 = a3;
  __int16 v19 = a4;
  __int16 v20 = a5;
  __int16 v21 = a6;
  char v22 = a7;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetLuxTableMode(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 2583;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::AEUpdateSuspend(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 550;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::AEUpdateResume(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 551;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ALSSuspend(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 2603;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ALSResume(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 2604;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ALSFastMode(H16ISP::H16ISPDevice *this, unsigned __int16 a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2627;
  int v9 = a2;
  BOOL v10 = a3 != 0;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::BLCSuspend(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 1289;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::BLCResume(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 1290;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::TestPatternConfig(H16ISP::H16ISPDevice *this, unsigned int a2, __int16 a3, CFTypeRef cf)
{
  __int16 valuePtr = 0;
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 != CFStringGetTypeID())
  {
    CFTypeID v11 = CFGetTypeID(cf);
    if (v11 != CFNumberGetTypeID()) {
      return 3758097090;
    }
    CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt16Type, &valuePtr);
    __int16 v12 = valuePtr;
LABEL_66:
    bzero(v30, 0x10uLL);
    __int16 v31 = 1283;
    unsigned int v32 = a2;
    __int16 v33 = a3;
    __int16 v34 = v12;
    return H16ISP::H16ISPDevice::ISP_SendCommand(this, v30, 0x10u, 0, 0xFFFFFFFF);
  }
  uint64_t v9 = 0;
  for (uint64_t i = (CFTypeRef *)&off_2691BF368; !CFEqual(cf, *i); i += 2)
  {
    if (++v9 == 25) {
      return 3758097090;
    }
  }
  __int16 v12 = v9;
  if (!(_WORD)v9)
  {
    a3 = v9;
    goto LABEL_66;
  }
  uint64_t v13 = 3758097090;
  if ((unsigned __int16)v9 == 25) {
    return v13;
  }
  int v14 = *(_DWORD *)(*((void *)this + 5) + 432 * a2 + 64);
  if (v14 <= 1794)
  {
    if (v14 > 1282)
    {
      if ((v14 - 1539) > 0x30 || ((1 << (v14 - 3)) & 0x1000000030001) == 0)
      {
        BOOL v19 = (v14 - 1283) > 0x11 || ((1 << (v14 - 3)) & 0x20005) == 0;
        if (v19 && (v14 - 1394) >= 2) {
          goto LABEL_64;
        }
      }
      goto LABEL_61;
    }
    if ((v14 - 835) <= 0x2F && ((1 << (v14 - 67)) & 0x8000000A0001) != 0)
    {
LABEL_61:
      int v17 = &H16ISP::sensorIMX343TestPatternIndex;
      goto LABEL_62;
    }
    unsigned int v21 = v14 - 1027;
    BOOL v22 = v21 > 0x11;
    int v23 = (1 << v21) & 0x20005;
LABEL_57:
    if (v22 || v23 == 0) {
      goto LABEL_64;
    }
    goto LABEL_61;
  }
  if (v14 <= 2306)
  {
    if (v14 > 1905)
    {
      if (v14 > 2067)
      {
        if (v14 != 2068 && v14 != 2131) {
          goto LABEL_64;
        }
      }
      else if (v14 != 1906 && v14 != 2051)
      {
        goto LABEL_64;
      }
      goto LABEL_61;
    }
    unsigned int v27 = v14 - 1795;
    BOOL v22 = v27 > 0x11;
    int v23 = (1 << v27) & 0x30001;
    goto LABEL_57;
  }
  if (v14 <= 2391)
  {
    unsigned int v24 = v14 - 2307;
    BOOL v22 = v24 > 0x20;
    uint64_t v25 = (1 << v24) & 0x100030003;
    if (v22 || v25 == 0) {
      goto LABEL_64;
    }
    goto LABEL_61;
  }
  if ((v14 - 2392) <= 0x2A && ((1 << (v14 - 88)) & 0x4000C000001) != 0) {
    goto LABEL_61;
  }
  if (v14 != 3414 && v14 != 20584) {
    goto LABEL_64;
  }
  int v17 = &H16ISP::sensorVD56G0TestPatternIndex;
LABEL_62:
  __int16 valuePtr = v17[v9];
  __int16 v12 = valuePtr;
  if (valuePtr != 255)
  {
LABEL_65:
    a3 = 1;
    goto LABEL_66;
  }
  if (CFEqual(cf, @"TestPatternPN9"))
  {
LABEL_64:
    __int16 v12 = 5;
    __int16 valuePtr = 5;
    goto LABEL_65;
  }
  return v13;
}

uint64_t H16ISP::H16ISPDevice::GetSupportedTestPatterns(H16ISP::H16ISPDevice *this, unsigned int a2, CFMutableArrayRef theArray)
{
  uint64_t result = 3758097090;
  if (!theArray) {
    return result;
  }
  int v6 = *(_DWORD *)(*((void *)this + 5) + 432 * a2 + 64);
  if (v6 > 1794)
  {
    if (v6 > 2306)
    {
      if (v6 <= 2391)
      {
        unsigned int v16 = v6 - 2307;
        BOOL v14 = v16 > 0x20;
        uint64_t v17 = (1 << v16) & 0x100030003;
        if (v14 || v17 == 0) {
          return result;
        }
      }
      else if ((v6 - 2392) > 0x2A || ((1 << (v6 - 88)) & 0x4000C000001) == 0)
      {
        if (v6 != 3414 && v6 != 20584) {
          return result;
        }
        uint64_t v9 = (char *)&H16ISP::sensorVD56G0TestPatternIndex;
        goto LABEL_52;
      }
      goto LABEL_51;
    }
    if (v6 > 1905)
    {
      if (v6 > 2067)
      {
        if (v6 != 2068 && v6 != 2131) {
          return result;
        }
      }
      else if (v6 != 1906 && v6 != 2051)
      {
        return result;
      }
      goto LABEL_51;
    }
    unsigned int v19 = v6 - 1795;
    BOOL v14 = v19 > 0x11;
    int v15 = (1 << v19) & 0x30001;
LABEL_47:
    if (v14 || v15 == 0) {
      return result;
    }
    goto LABEL_51;
  }
  if (v6 > 1282)
  {
    if ((v6 - 1539) > 0x30 || ((1 << (v6 - 3)) & 0x1000000030001) == 0)
    {
      BOOL v11 = (v6 - 1283) > 0x11 || ((1 << (v6 - 3)) & 0x20005) == 0;
      if (v11 && (v6 - 1394) >= 2) {
        return result;
      }
    }
    goto LABEL_51;
  }
  if ((v6 - 835) > 0x2F || ((1 << (v6 - 67)) & 0x8000000A0001) == 0)
  {
    unsigned int v13 = v6 - 1027;
    BOOL v14 = v13 > 0x11;
    int v15 = (1 << v13) & 0x20005;
    goto LABEL_47;
  }
LABEL_51:
  uint64_t v9 = (char *)&H16ISP::sensorIMX343TestPatternIndex;
LABEL_52:
  for (uint64_t i = 0; i != 50; i += 2)
  {
    if (*(_WORD *)&v9[i] != 255) {
      CFArrayAppendValue(theArray, *((const void **)&H16ISP::sensorTestPatterns + i + 1));
    }
  }
  return 0;
}

uint64_t H16ISP::H16ISPDevice::DisableALS(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 2589;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetBinningGainLuxThresholds(H16ISP::H16ISPDevice *this, int a2, int a3, int a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = -32244;
  int v11 = a2;
  int v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAFSoftLanding(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, int a5, int a6)
{
  bzero(v13, 0x18uLL);
  __int16 v14 = 1036;
  int v15 = a2;
  __int16 v16 = a3;
  __int16 v17 = a4;
  int v18 = a5;
  int v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x18u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAFWindowFDConfig(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = -31740;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetAFWindowFloatConfig(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -31726;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableAEGainConvergenceNormalization(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -32241;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableLTMHLGGammaCurve(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 8200;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::AWBUpdateSuspend(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 783;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::AWBUpdateResume(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 784;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::LuxAdaptiveSettingSuspend(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2596;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::LuxAdaptiveSettingResume(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2597;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableContextSwitchingWithType(H16ISP::H16ISPDevice *a1, int a2, int a3, int a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = -32510;
  int v11 = a2;
  int v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetSensorNoiseModelForSensorMode(H16ISP::H16ISPDevice *a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, _DWORD *a7)
{
  bzero(v17, 0x20uLL);
  __int16 v18 = -32507;
  int v19 = a2;
  int v20 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v17, 0x20u, 0, 0xFFFFFFFF);
  if (!result)
  {
    int v15 = v22;
    *a4 = v21;
    *a5 = v15;
    int v16 = v24;
    *a6 = v23;
    *a7 = v16;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetIdealColorCal(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int8 *a7)
{
  bzero(v15, 0x18uLL);
  __int16 v16 = 2055;
  int v17 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x18u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v18;
    *a4 = v19;
    *a5 = v20;
    *a6 = v21;
    *a7 = v22;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetIdealColorCal(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)
{
  bzero(v13, 0x14uLL);
  __int16 v14 = 2054;
  int v15 = a2;
  __int16 v16 = a3;
  __int16 v17 = a4;
  __int16 v18 = a5;
  __int16 v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetMSAERatio(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3, unsigned __int8 *a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 606;
  int v11 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v12;
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetMultiABSColorCal(H16ISP::H16ISPDevice *this, int a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6, unsigned __int8 *a7)
{
  bzero(v15, 0x18uLL);
  __int16 v16 = 2071;
  int v17 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x18u, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v18;
    *a4 = v19;
    *a5 = v20;
    *a6 = v21;
    *a7 = v22;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetFrameCount(H16ISP::H16ISPDevice *this, int a2, int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1311;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetISOParamsForSensorMode(H16ISP::H16ISPDevice *a1, int a2, int a3, void *a4)
{
  bzero(v9, 0x18uLL);
  __int16 v10 = 285;
  int v11 = a2;
  int v12 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x18u, 0, 0xFFFFFFFF);
  if (!result) {
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetMIPIFrequency(H16ISP::H16ISPDevice *this, int a2, int a3, unsigned int *a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 282;
  int v11 = a2;
  int v12 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
  if (!result) {
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetLPDPFrequency(H16ISP::H16ISPDevice *this, int a2, int a3, unint64_t *a4)
{
  bzero(v9, 0x18uLL);
  __int16 v10 = 352;
  int v11 = a2;
  int v12 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x18u, 0, 0xFFFFFFFF);
  if (!result) {
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetCurrentMIPIFrequencyIndex(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 281;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetSensorTemperature(H16ISP::H16ISPDevice *this, int a2, int *a3, __int16 *a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 1286;
  int v11 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
  if (!result)
  {
    if (a3) {
      *a3 = v12;
    }
    if (a4) {
      *a4 = v13;
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableSensorSideband(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1294;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::DPCEnable(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = -15104;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetLedParms(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1545;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableNTCStatus(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1546;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetNTCStatus(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1544;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetProjectorOff(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 1548;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetProjectorParams(H16ISP::H16ISPDevice *this, int a2, char a3, __int16 a4, __int16 a5, __int16 a6, int a7, int a8)
{
  bzero(v17, 0x1CuLL);
  __int16 v18 = 1549;
  int v19 = a2;
  char v20 = a3;
  __int16 v21 = a4;
  __int16 v22 = a5;
  __int16 v23 = a6;
  int v24 = a7;
  int v25 = a8;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v17, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetProjectorSequence(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0x12CuLL);
  __int16 v6 = 1572;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0x12Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetProxOff(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1574;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetProjectorTemp(H16ISP::H16ISPDevice *this, int a2, int *a3, int *a4, int *a5, int *a6, int *a7, int *a8, int *a9)
{
  bzero(v21, 0x28uLL);
  __int16 v22 = 1555;
  int v23 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v21, 0x28u, 0, 0xFFFFFFFF);
  if (!result)
  {
    int v18 = v25;
    *a3 = v24;
    *a4 = v18;
    int v19 = v27;
    *a5 = v26;
    *a6 = v19;
    int v20 = v29;
    *a7 = v28;
    *a8 = v20;
    *a9 = v30;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetProjectorOverheatLimit(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  return H16ISP::H16ISPDevice::WritePropertyValue(this, a2, 1447, a3, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetProjectorOverheatLimit(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  unsigned int v5 = 0;
  uint64_t result = H16ISP::H16ISPDevice::ReadPropertyValue(this, a2, 1447, &v5, 0xFFFFFFFF);
  if (!result) {
    *a3 = v5;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetDscStreamingMode(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 302;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::IRModeSelect(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 24580;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableFocus(H16ISP::H16ISPDevice *this, int a2, __int16 a3, __int16 a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 1802;
  int v11 = a2;
  __int16 v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableCFOV(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2066;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableSensorBLCRead(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1300;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableCNRForStillCapture(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2614;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetFirmwareRunMode(H16ISP::H16ISPDevice *this, __int16 a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 14;
  __int16 v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::OverrideFocusGravityZ(H16ISP::H16ISPDevice *this, int a2, char a3, __int16 a4)
{
  bzero(v9, 0x10uLL);
  __int16 v10 = 1803;
  int v11 = a2;
  char v12 = a3;
  __int16 v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::PrepareCommand(H16ISP::H16ISPDevice *a1, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 309;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetOisBoostMode(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1867;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetOisBoostMode(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1868;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableAvEvMinus(H16ISP::H16ISPDevice *this, int a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 308;
  int v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::CreateSensorConfig(H16ISP::H16ISPDevice *this, int a2, char a3, __int16 a4, __int16 a5, __int16 a6, __int16 a7)
{
  bzero(v16, 0x18uLL);
  __int16 v17 = 1296;
  int v18 = a2;
  char v19 = a3;
  __int16 v20 = a4;
  __int16 v21 = a5;
  __int16 v22 = a6;
  __int16 v23 = a7;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v16, 0x18u, 0, 0xFFFFFFFF);
  if (!result)
  {
    H16ISP::H16ISPDevice::InitDeviceConfigsCache(this);
    return H16ISP::H16ISPDevice::CacheDeviceConfigs(this, v15);
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ConfigureStillImageIntermediateTapDMA(H16ISP::H16ISPDevice *a1, int a2, int a3, int a4, int a5, char a6)
{
  bzero(v13, 0x20uLL);
  __int16 v14 = 2830;
  int v15 = a2;
  int v16 = a3;
  int v17 = a4;
  int v18 = a5;
  char v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v13, 0x20u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetNumberOfMipiFrequencies(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 307;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetDPCCount(H16ISP::H16ISPDevice *this, int a2, int a3, unsigned int *a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 1303;
  int v11 = a2;
  int v12 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
  if (!result) {
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::CaptureNow(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 306;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableMultiBit(H16ISP::H16ISPDevice *this, char a2)
{
  bzero(v5, 0x10uLL);
  __int16 v6 = 319;
  char v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetRPCEnableFlag(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 19;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetHighSpeedOutputLevel(H16ISP::H16ISPDevice *this, __int16 a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 1306;
  __int16 v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetCurrentChargePumpFrequencyIndex(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 324;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetChargePumpFrequencyForIndex(H16ISP::H16ISPDevice *this, int a2, int a3, unsigned int *a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 325;
  int v11 = a2;
  int v12 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
  if (!result) {
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetChargePumpFrequencyCount(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 323;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetPixClockFrequencyIndex(H16ISP::H16ISPDevice *this, __int16 a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 288;
  __int16 v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetCurrentPixClockFrequencyIndex(H16ISP::H16ISPDevice *this, int a2, unsigned int *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 286;
  int v9 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetPixClockFrequencyForIndex(H16ISP::H16ISPDevice *this, int a2, int a3, unsigned int *a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 287;
  int v11 = a2;
  int v12 = a3;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x14u, 0, 0xFFFFFFFF);
  if (!result) {
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_GetToFClockParam(uint64_t a1, unsigned int a2, unsigned int a3, void *outputStruct)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v4 = *(_DWORD *)(a1 + 4424);
  if (!v4) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  size_t v6 = 24;
  return IOConnectCallMethod(v4, 0x49u, input, 2u, 0, 0, 0, 0, outputStruct, &v6);
}

uint64_t H16ISP::H16ISPDevice::ISP_GetToFClockNumParams(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int *a3)
{
  input[1] = *MEMORY[0x263EF8340];
  *a3 = 0;
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  uint64_t output = 0;
  input[0] = a2;
  uint32_t outputCnt = 1;
  uint64_t result = IOConnectCallScalarMethod(v3, 0x46u, input, 1u, &output, &outputCnt);
  if (!result) {
    *a3 = output;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_RunToFSelectionAlgorithm(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int *a3, unsigned int a4)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  mach_port_t v4 = *((_DWORD *)this + 1106);
  if (!v4) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = (uint64_t)a3;
  uint64_t input[2] = a4;
  uint32_t outputCnt = 0;
  return IOConnectCallScalarMethod(v4, 0x4Bu, input, 3u, 0, &outputCnt);
}

uint64_t H16ISP::H16ISPDevice::GetPixClockFrequencyCount(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t result = H16ISP::H16ISPDevice::GetCameraConfig((uint64_t)this, a2, 0, v5, v6);
  if (!result) {
    *a3 = v7;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableFOD(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 26880;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_GetCameraStatus(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 24;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0xFu, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_PearlCamProjectorSafe(H16ISP::H16ISPDevice *this, unsigned int a2, uint64_t a3, unsigned int a4)
{
  v6[3] = *MEMORY[0x263EF8340];
  mach_port_t v4 = *((_DWORD *)this + 1106);
  if (!v4) {
    return 3758097084;
  }
  v6[0] = a2;
  v6[1] = a3;
  uint64_t v6[2] = a4;
  return IOConnectCallScalarMethod(v4, 0x33u, v6, 3u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::FIDStart(H16ISP::H16ISPDevice *this, int a2, char a3, int a4)
{
  bzero(v9, 0x1CuLL);
  __int16 v10 = 12288;
  int v11 = a2;
  char v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x1Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::FIDStop(H16ISP::H16ISPDevice *this, int a2)
{
  bzero(v5, 0x10uLL);
  __int16 v6 = 12289;
  int v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetISPProcessingConfig(H16ISP::H16ISPDevice *a1, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 331;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableSqrtToneCurve(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2617;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetMBNRConfiguration(H16ISP::H16ISPDevice *a1, __int16 a2, int a3, unsigned int a4, _DWORD *a5, BOOL *a6, unsigned char *a7, unsigned char *a8)
{
  if (a4 > 5) {
    return 3758097090;
  }
  uint64_t v27 = v8;
  uint64_t v28 = v9;
  bzero(v23, 0x3CuLL);
  __int16 v24 = 2620;
  __int16 v25 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v23, 0x3Cu, 0, 0xFFFFFFFF);
  if (!result)
  {
    char v19 = &v23[16 * a3];
    *a5 = *((_DWORD *)v19 + 3);
    *a6 = v19[16] != 0;
    if (a4)
    {
      uint64_t v20 = a4;
      __int16 v21 = (char *)&v26[a3];
      do
      {
        *a7++ = *(v21 - 1);
        char v22 = *v21;
        v21 += 2;
        *a8++ = v22;
        --v20;
      }
      while (v20);
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableKeypointDetection(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 20491;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetKeypointDetectionEnabled(H16ISP::H16ISPDevice *this, unsigned int a2, BOOL *a3)
{
  *a3 = 1;
  return 0;
}

uint64_t H16ISP::H16ISPDevice::SetKeypointConfiguration(H16ISP::H16ISPDevice *this, __int16 a2, __int16 a3, __int16 a4, __int16 a5, __int16 a6)
{
  bzero(v13, 0x14uLL);
  __int16 v14 = 20490;
  __int16 v15 = a2;
  __int16 v16 = a3;
  __int16 v17 = a4;
  __int16 v18 = a5;
  __int16 v19 = a6;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v13, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetKeypointConfiguration(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned __int16 *a3, unsigned __int16 *a4, unsigned __int16 *a5, unsigned __int16 *a6)
{
  *a3 = 0;
  *a4 = 0;
  *a5 = 64;
  *a6 = 64;
  return 0;
}

uint64_t H16ISP::H16ISPDevice::GetVioInputConfiguration(H16ISP::H16ISPDevice *this, __int16 a2, unsigned int *a3, unsigned int *a4, unsigned int *a5, unsigned int *a6)
{
  bzero(v15, 0x2CuLL);
  __int16 v16 = 12550;
  __int16 v17 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v15, 0x2Cu, 0, 0xFFFFFFFF);
  if (!result)
  {
    unsigned int v13 = v19;
    *a3 = v18;
    *a4 = v13;
    unsigned int v14 = v21;
    *a5 = v20;
    *a6 = v14;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SuspendVio(H16ISP::H16ISPDevice *this, int a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 12552;
  int v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SuspendTimeMachine(H16ISP::H16ISPDevice *this, __int16 a2, __int16 a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 336;
  __int16 v9 = a2;
  __int16 v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::GetTimeMachinePTSRange(H16ISP::H16ISPDevice *this, __int16 a2, unint64_t *a3, unint64_t *a4)
{
  bzero(v9, 0x1CuLL);
  __int16 v10 = 337;
  __int16 v11 = a2;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x1Cu, 0, 0xFFFFFFFF);
  if (!result)
  {
    *a3 = v12;
    *a4 = v13;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::EnableManualControl(H16ISP::H16ISPDevice *a1, __int16 a2, int a3, int a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 344;
  __int16 v11 = a2;
  int v12 = a3;
  int v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ConfigureManualControl(H16ISP::H16ISPDevice *a1, __int16 a2, unsigned int a3, const void *a4, unsigned int a5)
{
  unsigned int v10 = a5 + 532;
  if (((1 << a3) & 0x608) == 0) {
    unsigned int v10 = 532;
  }
  if (a3 <= 0xA) {
    size_t v11 = v10;
  }
  else {
    size_t v11 = 532;
  }
  int v12 = malloc_type_malloc(v11, 0xF09746CBuLL);
  if (!v12) {
    return 3758097085;
  }
  int v13 = v12;
  bzero(v12, 0x214uLL);
  v13[2] = 345;
  unsigned __int8 v13[4] = a2;
  *((_DWORD *)v13 + 3) = a3;
  if (a3 <= 0xA) {
    memcpy(v13 + 8, a4, a5);
  }
  uint64_t v14 = H16ISP::H16ISPDevice::ISP_SendCommand(a1, (unsigned __int8 *)v13, v11, 0, 0xFFFFFFFF);
  free(v13);
  return v14;
}

uint64_t H16ISP::H16ISPDevice::EnableScalerOutput(H16ISP::H16ISPDevice *a1, __int16 a2, int a3, char a4)
{
  bzero(v9, 0x14uLL);
  __int16 v10 = 2834;
  __int16 v11 = a2;
  int v12 = a3;
  char v13 = a4;
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x14u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableTimeLapseConfiguration(H16ISP::H16ISPDevice *this, __int16 a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 13568;
  __int16 v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::EnableTimeLapseSmoothing(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 13569;
  __int16 v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetTimeLapseSamplingRate(H16ISP::H16ISPDevice *this, __int16 a2, int a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 13571;
  __int16 v9 = a2;
  int v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SavePersistFile(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x270FA5388](a1, a2);
  mach_port_t v4 = v3;
  __int16 v6 = v5;
  int v8 = v7;
  __int16 v10 = v9;
  __int16 v11 = (H16ISP::H16ISPDevice *)v2;
  uint64_t v20 = *MEMORY[0x263EF8340];
  bzero(v14, 0x102CuLL);
  __int16 v15 = 357;
  __int16 v16 = v10;
  int v17 = v8;
  uint64_t v12 = H16ISP::H16ISPDevice::ISP_SendCommand(v11, v14, 0x102Cu, 0, 0xFFFFFFFF);
  if (!v12)
  {
    memcpy(v6, v19, 0x1018uLL);
    *mach_port_t v4 = v18 != 0;
  }
  return v12;
}

float H16ISP::H16ISPDevice::GetAmbientViewingLevel(H16ISP::H16ISPDevice *this, __int16 a2, float *a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 8203;
  __int16 v9 = a2;
  if (!H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF))
  {
    float result = v10;
    *a3 = v10;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::UpdateDisplayBrightness(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x6Bu, v4, 1u, 0, 0);
}

void H16ISP::H16ISPDevice::~H16ISPDevice(H16ISP::H16ISPDevice *this)
{
  if (*((_DWORD *)this + 1106)) {
    H16ISP::H16ISPDevice::H16ISPDeviceClose(this);
  }
  io_object_t v2 = *((_DWORD *)this + 1105);
  if (v2)
  {
    IOObjectRelease(v2);
    *((_DWORD *)this + 1105) = 0;
  }
  mach_port_t v3 = (H16ISP::SystemStatus *)*((void *)this + 27);
  if (v3)
  {
    H16ISP::SystemStatus::~SystemStatus(v3);
    MEMORY[0x24C53D6E0]();
  }
  mach_port_t v4 = (char *)this + 4512;
  unsigned int v5 = (H16ISP::H16ISPMotionManager *)*((void *)this + 13);
  if (v5)
  {
    H16ISP::H16ISPMotionManager::~H16ISPMotionManager(v5);
    MEMORY[0x24C53D6E0]();
    *((void *)this + 13) = 0;
  }
  H16ISP::H16ISPDevice::InitDeviceConfigsCache(this);
  uint64_t v6 = 0;
  int v7 = (char *)this + 4512;
  do
  {
    int v8 = *v7;
    v7 += 16;
    if (v8)
    {
      __int16 v9 = *(NSObject **)(*((void *)this + 9) + 72);
      if (v9)
      {
        block[0] = MEMORY[0x263EF8330];
        block[1] = 0x40000000;
        block[2] = ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke;
        block[3] = &__block_descriptor_tmp_205;
        block[4] = this;
        int v21 = v6;
        dispatch_sync(v9, block);
      }
    }
    if (v4[96])
    {
      float v10 = *(NSObject **)(*((void *)this + 9) + 72);
      if (v10)
      {
        v18[0] = MEMORY[0x263EF8330];
        v18[1] = 0x40000000;
        v18[2] = ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke_2;
        v18[3] = &__block_descriptor_tmp_206;
        unsigned __int8 v18[4] = this;
        int v19 = v6;
        dispatch_sync(v10, v18);
      }
    }
    ++v6;
    mach_port_t v4 = v7;
  }
  while (v6 != 6);
  if (*((unsigned char *)this + 4704))
  {
    __int16 v11 = *(NSObject **)(*((void *)this + 9) + 72);
    if (v11)
    {
      v17[0] = MEMORY[0x263EF8330];
      v17[1] = 0x40000000;
      void v17[2] = ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke_3;
      v17[3] = &__block_descriptor_tmp_207;
      unsigned __int8 v17[4] = this;
      dispatch_sync(v11, v17);
    }
  }
  if (*((unsigned char *)this + 4720))
  {
    uint64_t v12 = *(NSObject **)(*((void *)this + 9) + 72);
    if (v12)
    {
      v16[0] = MEMORY[0x263EF8330];
      v16[1] = 0x40000000;
      void v16[2] = ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke_4;
      v16[3] = &__block_descriptor_tmp_208;
      unsigned __int8 v16[4] = this;
      dispatch_sync(v12, v16);
    }
  }
  if (*((unsigned char *)this + 4736))
  {
    char v13 = *(NSObject **)(*((void *)this + 9) + 72);
    if (v13)
    {
      v15[0] = MEMORY[0x263EF8330];
      v15[1] = 0x40000000;
      v15[2] = ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke_5;
      v15[3] = &__block_descriptor_tmp_209;
      unsigned __int8 v15[4] = this;
      dispatch_sync(v13, v15);
    }
  }
  uint64_t v14 = (const void *)*((void *)this + 11);
  if (v14)
  {
    CFRelease(v14);
    *((void *)this + 11) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 4432));
}

uint64_t H16ISP::H16ISPDevice::H16ISPDeviceClose(H16ISP::H16ISPDevice *this)
{
  io_object_t v2 = (pthread_mutex_t *)((char *)this + 4432);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 4432));
  uint64_t v3 = IOConnectCallScalarMethod(*((_DWORD *)this + 1106), 4u, 0, 0, 0, 0);
  io_connect_t v4 = *((_DWORD *)this + 1106);
  if (v4)
  {
    IOServiceClose(v4);
    *((_DWORD *)this + 1106) = 0;
    *((void *)this + 7) = 0;
    *((void *)this + 8) = 0;
  }
  else
  {
    uint64_t v3 = 3758097101;
  }
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t H16ISP::H16ISPDevice::DisableDeviceMessages(H16ISP::H16ISPDevice *this)
{
  uint64_t result = *((unsigned int *)this + 1105);
  if (result)
  {
    uint64_t result = IOObjectRelease(result);
    *((_DWORD *)this + 1105) = 0;
  }
  return result;
}

uint64_t ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 4504;
  uint64_t result = notify_cancel(*(_DWORD *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 12));
  *(unsigned char *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 8) = 0;
  return result;
}

uint64_t ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32) + 4600;
  uint64_t result = notify_cancel(*(_DWORD *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 12));
  *(unsigned char *)(v2 + 16 * *(unsigned int *)(a1 + 40) + 8) = 0;
  return result;
}

uint64_t ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = notify_cancel(*(_DWORD *)(v1 + 4708));
  *(unsigned char *)(v1 + 4704) = 0;
  return result;
}

uint64_t ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke_4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = notify_cancel(*(_DWORD *)(v1 + 4724));
  *(unsigned char *)(v1 + 4720) = 0;
  return result;
}

uint64_t ___ZN6H16ISP12H16ISPDeviceD2Ev_block_invoke_5(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = notify_cancel(*(_DWORD *)(v1 + 4740));
  *(unsigned char *)(v1 + 4736) = 0;
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_PreMapClientSurface(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x51u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_ReleasePreMappedClientSurface(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x52u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_DetectFaces(uint64_t a1, void *inputStruct)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x17u, inputStruct, 0x10uLL, 0, 0);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_FlushInactiveDARTMappings(H16ISP::H16ISPDevice *this)
{
  mach_port_t v1 = *((_DWORD *)this + 1106);
  if (v1) {
    return IOConnectCallScalarMethod(v1, 0x21u, 0, 0, 0, 0);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_ProcessRawImagePrepare(uint64_t a1, void *inputStruct)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x12u, inputStruct, 0x34uLL, 0, 0);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_ProcessRawImageGo(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x13u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_EnableFirmwareChannels(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x3Au, v4, 1u, 0, 0);
}

H16ISP::H16ISPDevice *H16ISP::H16ISPDevice::ISP_ColdBootPowerCycle(H16ISP::H16ISPDevice *this)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  int v2 = -10;
  uint64_t v3 = &_os_log_internal;
  do
  {
    if (!H16ISP::H16ISPDevice::ISP_IsPowered(this)) {
      break;
    }
    usleep(0x186A0u);
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v3) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      uint64_t v14 = "ISP_ColdBootPowerCycle";
      _os_log_impl(&dword_24680F000, v3, OS_LOG_TYPE_DEFAULT, "%s - Camera powered on...waiting\n", buf, 0xCu);
    }
    usleep(0x493E0u);
  }
  while (!__CFADD__(v2++, 1));
  uint64_t v5 = H16ISP::H16ISPDevice::ISP_ForgetFirmware(this);
  if (v5)
  {
    Firmware = (H16ISP::H16ISPDevice *)v5;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v3) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ISP_ColdBootPowerCycle();
    }
  }
  else
  {
    int v7 = (void *)os_transaction_create();
    Firmware = H16ISP::H16ISPDevice::ISP_LoadFirmware(this);
    os_release(v7);
    if (Firmware)
    {
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v3) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::ISP_ColdBootPowerCycle();
      }
    }
    else
    {
      uint64_t v9 = H16ISP::H16ISPDevice::ISP_PowerOnCamera(this, v8);
      if (v9)
      {
        Firmware = (H16ISP::H16ISPDevice *)v9;
        int v10 = 0;
        BOOL v11 = 0;
      }
      else if (H16ISP::H16ISPDevice::ISP_IsPowered(this))
      {
        Firmware = (H16ISP::H16ISPDevice *)H16ISP::H16ISPDevice::ISP_PowerOffCamera(this);
        BOOL v11 = Firmware == 0;
        int v10 = 1;
      }
      else
      {
        int v10 = 0;
        BOOL v11 = 0;
        Firmware = 0;
      }
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v3) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315906;
        uint64_t v14 = "ISP_ColdBootPowerCycle";
        __int16 v15 = 1024;
        int v16 = v10;
        __int16 v17 = 1024;
        BOOL v18 = v11;
        __int16 v19 = 1024;
        int v20 = (int)Firmware;
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - poweredOn=%d, poweredOff=%d, res=0x%08X\n", buf, 0x1Eu);
      }
    }
  }
  return Firmware;
}

uint64_t H16ISP::H16ISPDevice::ISP_ForgetFirmware(H16ISP::H16ISPDevice *this)
{
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  uint64_t result = IOConnectCallScalarMethod(v2, 9u, 0, 0, 0, 0);
  if (!result)
  {
    H16ISP::H16ISPDevice::InitDeviceConfigsCache(this);
    return 0;
  }
  return result;
}

H16ISP::H16ISPDevice *H16ISP::H16ISPDevice::ISP_LoadFirmware(H16ISP::H16ISPDevice *this)
{
  input[12] = *MEMORY[0x263EF8340];
  FirmwareBinary = (H16ISP::H16ISPDevice *)H16ISP::H16ISPDevice::LoadFirmwareBinary(this);
  if (!FirmwareBinary)
  {
    CFDictionaryRef theDict = 0;
    H16ISP::H16ISPDevice::GetUnitInfoPropertyDict(FirmwareBinary, &theDict);
    H16ISP::H16ISPDevice::ISP_SetFrontCameraOffsetFromDisplayCenter(this);
    H16ISP::LoadSavageDATFile(this, v5);
    H16ISP::LoadFrontIRHPRFile(this, v6);
    H16ISP::LoadYonkersDATFile(this, v7);
    H16ISP::H16ISPDevice::SendDataFileToFirmware(this, "/System/Library/PrivateFrameworks/AppleCVHWA.framework/Firmware/lacc_VIO_ISP_IR.bin", 0, 0, 0, 8u, 0, 0);
    strcpy((char *)input, "/System/Library/PrivateFrameworks/AppleCVHWA.framework/Firmware/");
    *(void *)buf = 0;
    io_registry_entry_t v8 = IORegistryEntryFromPath(*MEMORY[0x263F0EC88], "IODeviceTree:/arm-io");
    if (v8)
    {
      CFDataRef CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(v8, @"soc-generation", 0, 0);
      CFDataRef v10 = CFProperty;
      if (CFProperty)
      {
        CFTypeID v11 = CFGetTypeID(CFProperty);
        if (v11 == CFDataGetTypeID())
        {
          CFIndex Length = CFDataGetLength(v10);
          if ((unint64_t)(Length - 8) > 0xFFFFFFFFFFFFFFF8)
          {
            size_t v29 = Length;
            BytePtr = (const char *)CFDataGetBytePtr(v10);
            strncpy((char *)buf, BytePtr, v29);
          }
          else
          {
            if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
              GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
            }
            BOOL v13 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
            if (v13) {
              H16ISP::H16ISPDevice::ISP_LoadFirmware(v13, v14, v15, v16, v17, v18, v19, v20);
            }
          }
          goto LABEL_22;
        }
      }
    }
    else
    {
      CFDataRef v10 = 0;
    }
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    BOOL v21 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    if (v21) {
      H16ISP::H16ISPDevice::ISP_LoadFirmware(v21, v22, v23, v24, v25, v26, v27, v28);
    }
    if (!v10) {
LABEL_23:
    }
      operator new[]();
LABEL_22:
    CFRelease(v10);
    goto LABEL_23;
  }
  uint64_t v3 = FirmwareBinary;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
    H16ISP::H16ISPDevice::ISP_LoadFirmware();
  }
  return v3;
}

uint64_t H16ISP::H16ISPDevice::ISP_PowerOffCamera(H16ISP::H16ISPDevice *this)
{
  kdebug_trace();
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (v2) {
    uint64_t v3 = IOConnectCallScalarMethod(v2, 0xCu, 0, 0, 0, 0);
  }
  else {
    uint64_t v3 = 3758097084;
  }
  kdebug_trace();
  return v3;
}

uint64_t H16ISP::H16ISPDevice::ISP_PublishToIOReg(H16ISP::H16ISPDevice *this, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4)
{
  uint64_t input[4] = *MEMORY[0x263EF8340];
  mach_port_t v4 = *((_DWORD *)this + 1106);
  if (!v4) {
    return 3758097084;
  }
  input[0] = (uint64_t)a2;
  if (*a2)
  {
    uint64_t v5 = 0;
    do
      uint64_t v6 = v5 + 1;
    while (a2[++v5]);
  }
  else
  {
    uint64_t v6 = 0;
  }
  input[1] = v6;
  uint64_t input[2] = (uint64_t)a3;
  uint64_t input[3] = a4;
  return IOConnectCallScalarMethod(v4, 0x65u, input, 4u, 0, 0);
}

float H16ISP::H16ISPDevice::GetFrontCameraOffsetFromDisplayCenter(H16ISP::H16ISPDevice *this)
{
  uint64_t v66 = *MEMORY[0x263EF8340];
  float valuePtr = 0.0;
  if (*((_DWORD *)this + 1106))
  {
    if (MGIsQuestionValid())
    {
      CFArrayRef v1 = (const __CFArray *)MGCopyAnswerWithError();
      if (v1)
      {
        CFArrayRef v2 = v1;
        CFTypeID v3 = CFGetTypeID(v1);
        if (v3 == CFArrayGetTypeID() && CFArrayGetCount(v2) == 3)
        {
          CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(v2, 0);
          if (ValueAtIndex)
          {
            CFNumberRef v5 = ValueAtIndex;
            CFTypeID v6 = CFGetTypeID(ValueAtIndex);
            if (v6 == CFNumberGetTypeID()
              && CFNumberIsFloatType(v5)
              && CFNumberGetValue(v5, kCFNumberFloatType, &valuePtr))
            {
              float v7 = valuePtr;
              CFNumberRef v8 = (const __CFNumber *)CFArrayGetValueAtIndex(v2, 1);
              if (v8
                && (v9 = v8, CFTypeID v10 = CFGetTypeID(v8), v10 == CFNumberGetTypeID())
                && CFNumberIsFloatType(v9)
                && CFNumberGetValue(v9, kCFNumberFloatType, &valuePtr))
              {
                CFNumberRef v11 = (const __CFNumber *)CFArrayGetValueAtIndex(v2, 2);
                if (!v11
                  || (CFNumberRef v12 = v11, v13 = CFGetTypeID(v11), v13 != CFNumberGetTypeID())
                  || !CFNumberIsFloatType(v12)
                  || !CFNumberGetValue(v12, kCFNumberFloatType, &valuePtr))
                {
                  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
                    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
                  }
                  BOOL v55 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                  if (v55) {
                    H16ISP::H16ISPDevice::GetFrontCameraOffsetFromDisplayCenter(v55, v56, v57, v58, v59, v60, v61, v62);
                  }
                }
              }
              else
              {
                if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
                  GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
                }
                BOOL v47 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
                if (v47) {
                  H16ISP::H16ISPDevice::GetFrontCameraOffsetFromDisplayCenter(v47, v48, v49, v50, v51, v52, v53, v54);
                }
              }
              goto LABEL_41;
            }
          }
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
          }
          BOOL v39 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          if (v39) {
            H16ISP::H16ISPDevice::GetFrontCameraOffsetFromDisplayCenter(v39, v40, v41, v42, v43, v44, v45, v46);
          }
        }
        else
        {
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
          }
          BOOL v22 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
          if (v22) {
            H16ISP::H16ISPDevice::GetFrontCameraOffsetFromDisplayCenter(v22, v23, v24, v25, v26, v27, v28, v29);
          }
        }
        float v7 = 0.0;
LABEL_41:
        CFRelease(v2);
        return v7;
      }
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      BOOL v30 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
      float v7 = 0.0;
      if (v30) {
        H16ISP::H16ISPDevice::GetFrontCameraOffsetFromDisplayCenter(v30, v31, v32, v33, v34, v35, v36, v37);
      }
    }
    else
    {
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      float v7 = 0.0;
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315138;
        CFNumberRef v65 = "GetFrontCameraOffsetFromDisplayCenter";
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - Device has no Front Camera Offset Data!\n", buf, 0xCu);
      }
    }
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    BOOL v14 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    float v7 = 0.0;
    if (v14) {
      H16ISP::H16ISPDevice::GetFrontCameraOffsetFromDisplayCenter(v14, v15, v16, v17, v18, v19, v20, v21);
    }
  }
  return v7;
}

uint64_t H16ISP::H16ISPDevice::ISP_SetFrontCameraOffsetFromDisplayCenter(H16ISP::H16ISPDevice *this)
{
  uint64_t v25 = *MEMORY[0x263EF8340];
  uint64_t v1 = 3758097136;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  int v24 = 0;
  uint64_t v23 = 0;
  uint64_t v2 = &_os_log_internal;
  if (*((_DWORD *)this + 1106))
  {
    if (MGIsQuestionValid())
    {
      mach_port_t v4 = (const void *)MGCopyAnswerWithError();
      if (v4)
      {
        CFNumberRef v5 = v4;
        CFStringRef v6 = CFCopyDescription(v4);
        if (v6)
        {
          CFStringRef v7 = v6;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v2) {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136315394;
            uint64_t v20 = "ISP_SetFrontCameraOffsetFromDisplayCenter";
            __int16 v21 = 2080;
            CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
            _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - kMGQFrontCameraOffsetFromDisplayCenter Description=%s\n", buf, 0x16u);
          }
          CFRelease(v7);
        }
        CFTypeID v8 = CFGetTypeID(v5);
        if (v8 == CFArrayGetTypeID() && CFArrayGetCount((CFArrayRef)v5) == 3)
        {
          CFIndex v9 = 0;
          CFTypeID v10 = &v23;
          while (1)
          {
            CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex((CFArrayRef)v5, v9);
            if (!ValueAtIndex) {
              break;
            }
            CFNumberRef v12 = ValueAtIndex;
            CFTypeID v13 = CFGetTypeID(ValueAtIndex);
            if (v13 != CFNumberGetTypeID() || !CFNumberIsFloatType(v12)) {
              goto LABEL_26;
            }
            int Value = CFNumberGetValue(v12, kCFNumberFloatType, v10);
            if (Value)
            {
              CFTypeID v10 = (uint64_t *)((char *)v10 + 4);
              if (v9++ != 2) {
                continue;
              }
            }
            if (Value) {
              uint64_t v1 = 0;
            }
            else {
              uint64_t v1 = 3758097102;
            }
            if (Value)
            {
              uint64_t v17 = v23;
              LODWORD(v18) = v24;
              uint64_t v1 = IOConnectCallStructMethod(*((_DWORD *)this + 1106), 0x56u, &v17, 0xCuLL, 0, 0);
              goto LABEL_36;
            }
            break;
          }
        }
        else
        {
LABEL_26:
          uint64_t v1 = 3758096385;
        }
      }
      else
      {
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v2) {
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
        }
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::ISP_SetFrontCameraOffsetFromDisplayCenter();
        }
        CFNumberRef v5 = 0;
      }
    }
    else
    {
      CFNumberRef v5 = 0;
      uint64_t v1 = 3758097095;
    }
  }
  else
  {
    CFNumberRef v5 = 0;
    uint64_t v1 = 3758097087;
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v2) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR))
  {
    H16ISP::H16ISPDevice::ISP_SetFrontCameraOffsetFromDisplayCenter();
    if (!v5) {
      return v1;
    }
    goto LABEL_36;
  }
  if (v5) {
LABEL_36:
  }
    CFRelease(v5);
  return v1;
}

uint64_t H16ISP::H16ISPDevice::LoadFirmwareBinary(H16ISP::H16ISPDevice *this)
{
  outputStructCnt[3] = *MEMORY[0x263EF8340];
  outputStructCnt[0] = 24;
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2 || (IOConnectCallStructMethod(v2, 0xFu, 0, 0, outputStruct, outputStructCnt), !outputStruct[20]))
  {
    CFTypeID v3 = fopen("/usr/local/share/firmware/isp/isp_fw.bin", "rb");
    mach_port_t v4 = fopen(0, "rb");
    if (v4)
    {
      CFNumberRef v5 = v4;
      if (v3) {
        fclose(v3);
      }
    }
    else
    {
      CFNumberRef v5 = v3;
    }
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v6 = &_os_log_internal;
    BOOL v7 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    if (v7)
    {
      H16ISP::H16ISPDevice::LoadFirmwareBinary(v7, v8, v9, v10, v11, v12, v13, v14);
      if (v5)
      {
LABEL_12:
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v6) {
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
        }
        BOOL v15 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
        if (v15) {
          H16ISP::H16ISPDevice::LoadFirmwareBinary(v15, v16, v17);
        }
        fseeko(v5, 0, 2);
        ftello(v5);
        fseeko(v5, 0, 0);
        operator new[]();
      }
    }
    else if (v5)
    {
      goto LABEL_12;
    }
    perror("error loading ISPCPU firmware ");
  }
  outputStructCnt[0] = 0;
  outputStructCnt[1] = 0;
  outputStructCnt[2] = *((unsigned int *)this + 1094);
  return IOConnectCallScalarMethod(*((_DWORD *)this + 1106), 7u, outputStructCnt, 3u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::SendDataFileToFirmware(H16ISP::H16ISPDevice *this, const char *__filename, const char *a3, const unsigned __int8 *a4, unsigned int a5, unsigned int a6, unsigned int a7, int a8)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  if (a8) {
    unsigned int v11 = a7 | 0x80000000;
  }
  else {
    unsigned int v11 = a7;
  }
  if (a3)
  {
    uint64_t v12 = fopen(a3, "rb");
    if (v12)
    {
      uint64_t v13 = v12;
      goto LABEL_9;
    }
  }
  uint64_t v14 = fopen(__filename, "rb");
  if (v14)
  {
    uint64_t v13 = v14;
LABEL_9:
    fseeko(v13, 0, 2);
    ftello(v13);
    rewind(v13);
    operator new[]();
  }
  if (a4) {
    operator new[]();
  }
  uint64_t DataFile = H16ISP::H16ISPDevice::ISP_LoadDataFile(this, v11, 0, 0, a6);
  uint64_t v16 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316418;
    BOOL v22 = "SendDataFileToFirmware";
    __int16 v23 = 1024;
    unsigned int v24 = a6;
    __int16 v25 = 1024;
    int v26 = 0;
    __int16 v27 = 1024;
    *(_DWORD *)uint64_t v28 = 0;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = a8;
    *(_WORD *)uint64_t v29 = 1024;
    *(_DWORD *)&v29[2] = DataFile;
    _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - type=0x%X, isOverride=%d, size=%u, isEarlyBoot=%d, status=%08x\n", buf, 0x2Au);
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v16) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136316674;
    BOOL v22 = "SendDataFileToFirmware";
    __int16 v23 = 1024;
    unsigned int v24 = a6;
    __int16 v25 = 1024;
    int v26 = 0;
    __int16 v27 = 2080;
    *(void *)uint64_t v28 = __filename;
    *(_WORD *)&v28[8] = 1024;
    *(_DWORD *)uint64_t v29 = 0;
    *(_WORD *)&v29[4] = 1024;
    int v30 = a8;
    __int16 v31 = 1024;
    int v32 = DataFile;
    _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - type=0x%X, isOverride=%d, file=%s, size=%u, isEarlyBoot=%d, status=%08x\n", buf, 0x34u);
  }
  return DataFile;
}

void H16ISP::H16ISPDevice::LoadFDRCalDataFile(H16ISP::H16ISPDevice *this)
{
  uint64_t v33 = *MEMORY[0x263EF8340];
  mach_port_t v2 = *MEMORY[0x263F0EC90];
  CFDictionaryRef v3 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(v2, v3);
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFTypeRef v6 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"BackCameraModuleSerialNumString", (CFAllocatorRef)*MEMORY[0x263EFFB08], 3u);
  if (v6)
  {
    BOOL v7 = v6;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v8 = &_os_log_internal;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "backCameraModuleSerialNumString exists - load FDR CmCl calibration data\n\n", buf, 2u);
    }
    CFRelease(v7);
    uint64_t v9 = fopen("/usr/local/share/firmware/isp/CmCl-Override.DAT", "rb");
    if (v9)
    {
      uint64_t v10 = v9;
      fseeko(v9, 0, 2);
      ftello(v10);
      fseeko(v10, 0, 0);
      operator new[]();
    }
    CFStringRef v14 = CFStringCreateWithCString(v5, "CmCl", 0x8000100u);
    Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    CFDictionaryAddValue(Mutable, @"CopyAllowUnsealed", (const void *)*MEMORY[0x263EFFB40]);
    MEMORY[0x24C53BCA0](H16ISP::fdrLogMessages);
    uint64_t v16 = AMFDRSealingMapCopyLocalDataForClass();
    if (v16)
    {
      CFDataRef v17 = (const __CFData *)v16;
      int v18 = -1431699456;
    }
    else
    {
      uint64_t v25 = *((void *)this + 548);
      if (!v25 || !*(unsigned char *)(v25 + 623) || (uint64_t v26 = AMFDRSealingManifestCopyLocalDataForClass()) == 0)
      {
        H16ISP::H16ISPDevice::ISP_LoadDataFile(this, 0x80000000, 0, 0, 0xCCCC0300);
LABEL_26:
        if (v14) {
          CFRelease(v14);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        return;
      }
      CFDataRef v17 = (const __CFData *)v26;
      int v18 = -1145372672;
    }
    BytePtr = CFDataGetBytePtr(v17);
    unsigned int Length = CFDataGetLength(v17);
    int DataFile = H16ISP::H16ISPDevice::ISP_LoadDataFile(this, 0x80000000, BytePtr, Length, v18 | 0x300u);
    CFStringRef v22 = CFCopyDescription(v17);
    if (v22)
    {
      CFStringRef v23 = v22;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v8) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        CStringPtr = CFStringGetCStringPtr(v23, 0);
        *(_DWORD *)buf = 136315650;
        uint64_t v28 = "LoadFDRCalDataFile";
        __int16 v29 = 1024;
        int v30 = DataFile;
        __int16 v31 = 2080;
        int v32 = CStringPtr;
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - Status = %#08x; CmCl data - %s\n",
          buf,
          0x1Cu);
      }
      CFRelease(v23);
    }
    CFRelease(v17);
    goto LABEL_26;
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  BOOL v11 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  if (v11) {
    H16ISP::H16ISPDevice::LoadFDRCalDataFile(v11, v12, v13);
  }
}

void H16ISP::H16ISPDevice::LoadFDRFCClDataFile(H16ISP::H16ISPDevice *this)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  mach_port_t v2 = *MEMORY[0x263F0EC90];
  CFDictionaryRef v3 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(v2, v3);
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  CFTypeRef v6 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"FrontCameraModuleSerialNumString", (CFAllocatorRef)*MEMORY[0x263EFFB08], 3u);
  if (v6)
  {
    BOOL v7 = v6;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v8 = &_os_log_internal;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "FrontCameraModuleSerialNumString exists - load FDR FCCl calibration data\n\n", buf, 2u);
    }
    CFRelease(v7);
    IOObjectRelease(MatchingService);
    uint64_t v9 = 0;
    uint64_t v10 = (_DWORD *)(*((void *)this + 548) + 16);
    while (!*(v10 - 2) || *v10 != 1718775412 && *v10 != 1718776695)
    {
      v10 += 24;
      if (++v9 == 6)
      {
        LODWORD(v9) = 0;
        break;
      }
    }
    BOOL v11 = fopen("/usr/local/share/firmware/isp/FCCl-Override.DAT", "rb");
    if (v11)
    {
      uint64_t v12 = v11;
      fseeko(v11, 0, 2);
      ftello(v12);
      fseeko(v12, 0, 0);
      operator new[]();
    }
    CFStringRef v21 = CFStringCreateWithCString(v5, "FCCl", 0x8000100u);
    Mutable = CFDictionaryCreateMutable(v5, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
    CFDictionaryAddValue(Mutable, @"CopyAllowUnsealed", (const void *)*MEMORY[0x263EFFB40]);
    MEMORY[0x24C53BCA0](H16ISP::fdrLogMessages);
    uint64_t v23 = AMFDRSealingMapCopyLocalDataForClass();
    if (v23)
    {
      CFDataRef v24 = (const __CFData *)v23;
      int v25 = -1431699456;
    }
    else
    {
      uint64_t v31 = *((void *)this + 548);
      if (!v31 || !*(unsigned char *)(v31 + 623) || (uint64_t v32 = AMFDRSealingManifestCopyLocalDataForClass()) == 0)
      {
        H16ISP::H16ISPDevice::ISP_LoadDataFile(this, v9 | 0x80000000, 0, 0, 0xCCCC0300);
LABEL_31:
        if (v21) {
          CFRelease(v21);
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
        return;
      }
      CFDataRef v24 = (const __CFData *)v32;
      int v25 = -1145372672;
    }
    BytePtr = CFDataGetBytePtr(v24);
    unsigned int Length = CFDataGetLength(v24);
    int DataFile = H16ISP::H16ISPDevice::ISP_LoadDataFile(this, v9 | 0x80000000, BytePtr, Length, v25 | 0x300u);
    CFStringRef v29 = CFCopyDescription(v24);
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v8) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      CStringPtr = CFStringGetCStringPtr(v29, 0);
      *(_DWORD *)buf = 136315650;
      uint64_t v34 = "LoadFDRFCClDataFile";
      __int16 v35 = 1024;
      int v36 = DataFile;
      __int16 v37 = 2080;
      int v38 = CStringPtr;
      _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - Status = %#08x; FCCl data - %s\n",
        buf,
        0x1Cu);
    }
    CFRelease(v29);
    CFRelease(v24);
    goto LABEL_31;
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  BOOL v13 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
  if (v13) {
    H16ISP::H16ISPDevice::LoadFDRFCClDataFile(v13, v14, v15, v16, v17, v18, v19, v20);
  }
  IOObjectRelease(MatchingService);
}

void H16ISP::H16ISPDevice::LoadFDRDataFileCMPM(H16ISP::H16ISPDevice *this)
{
  *(void *)((char *)&v47[2] + 2) = *MEMORY[0x263EF8340];
  mach_port_t v2 = fopen("/var/mobile/Library/ISP/CalData/DCNUMetadata_0", "rb");
  if (v2)
  {
    fclose(v2);
    remove((const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/CalData/DCNUMetadata_0", v3);
  }
  mach_port_t v4 = fopen("/var/mobile/Library/ISP/CalData/DCNUPixbuf_0", "rb");
  if (v4)
  {
    fclose(v4);
    remove((const std::__fs::filesystem::path *)"/var/mobile/Library/ISP/CalData/DCNUPixbuf_0", v5);
  }
  mach_port_t v6 = *MEMORY[0x263F0EC88];
  CFDictionaryRef v7 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(v6, v7);
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  unint64_t v10 = (unint64_t)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"BackCameraSNUM", (CFAllocatorRef)*MEMORY[0x263EFFB08], 3u);
  CFAllocatorRef allocator = v9;
  unint64_t v11 = (unint64_t)IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"BackSuperWideCameraSNUM", v9, 3u);
  if (!(v10 | v11))
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    BOOL v12 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    if (v12) {
      H16ISP::H16ISPDevice::LoadFDRDataFileCMPM(v12, v13, v14);
    }
    return;
  }
  uint64_t v15 = (const void *)v11;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "BackCameraSNUM/BackSuperWideCameraSNUM exists - load FDR CmPM calibration data\n\n", buf, 2u);
  }
  if (!v15)
  {
    unsigned int v38 = 0;
    if (!v10) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
  CFRelease(v15);
  unsigned int v38 = 4;
  if (v10)
  {
LABEL_16:
    CFRelease((CFTypeRef)v10);
    unsigned int v38 = 0;
  }
LABEL_17:
  MEMORY[0x24C53BCA0](H16ISP::fdrLogMessages);
  Mutable = CFDictionaryCreateMutable(v9, 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  CFDictionaryAddValue(Mutable, @"CopyAllowUnsealed", (const void *)*MEMORY[0x263EFFB40]);
  CFStringRef v36 = CFStringCreateWithCString(v9, "CmPM", 0x8000100u);
  __int16 v37 = Mutable;
  CFDictionaryRef v17 = (const __CFDictionary *)AMFDRSealingMapCopyLocalDictForClass();
  for (uint64_t i = 0; i != 6; ++i)
  {
    if (v17)
    {
      CFStringRef v19 = CFStringCreateWithCString(allocator, off_2651E9A20[3 * i + 1], 0x8000100u);
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v17, v19);
      if (Value)
      {
        CFDataRef v21 = Value;
        BytePtr = CFDataGetBytePtr(Value);
        int v23 = -1431699456;
        unsigned int Length = CFDataGetLength(v21);
        goto LABEL_23;
      }
    }
    else
    {
      CFStringRef v19 = 0;
    }
    BytePtr = 0;
    unsigned int Length = 0;
    int v23 = -859045888;
LABEL_23:
    int v25 = &off_2651E9A20[3 * i];
    int v26 = *((_DWORD *)v25 + 4);
    if (v26 != 771)
    {
      H16ISP::H16ISPDevice::SendDataFileToFirmware(this, 0, *v25, BytePtr, Length, v26 | v23, v38, 1);
      if (!v19) {
        continue;
      }
LABEL_27:
      CFRelease(v19);
      continue;
    }
    __int16 v27 = fopen(*v25, "rb");
    if (v27)
    {
      uint64_t v28 = v27;
      fseeko(v27, 0, 2);
      ftello(v28);
      rewind(v28);
      operator new[]();
    }
    if (BytePtr)
    {
      int correction_model_from_fdr = bfpn_create_correction_model_from_fdr();
      int v30 = &_os_log_internal;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal)
      {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
        int v30 = &_os_log_internal;
      }
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136315650;
        uint64_t v45 = "LoadFDRDataFileCMPM";
        __int16 v46 = 1024;
        LODWORD(v47[0]) = correction_model_from_fdr;
        WORD2(v47[0]) = 2048;
        *(void *)((char *)v47 + 6) = 8;
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - uint64_t result = %d, outputPixelBufferRef = %lu\n", buf, 0x1Cu);
      }
      if (!correction_model_from_fdr)
      {
        if (mkdir("/var/mobile/Library/ISP/", 0x1FFu) && *__error() != 17)
        {
          uint64_t v33 = &_os_log_internal;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal)
          {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
            uint64_t v33 = &_os_log_internal;
          }
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
            H16ISP::H16ISPDevice::LoadFDRDataFileCMPM(v42, &v43);
          }
        }
        else if (mkdir("/var/mobile/Library/ISP/CalData", 0x1FFu) && *__error() != 17)
        {
          uint64_t v34 = &_os_log_internal;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal)
          {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
            uint64_t v34 = &_os_log_internal;
          }
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
            H16ISP::H16ISPDevice::LoadFDRDataFileCMPM(v40, &v41);
          }
        }
        else
        {
          uint64_t v31 = fopen("/var/mobile/Library/ISP/CalData/DCNUMetadata_0", "wb");
          if (v31)
          {
            uint64_t v32 = v31;
            fwrite(0, 1uLL, MEMORY[2], v31);
            fclose(v32);
            H16ISP::H16ISPDevice::SendDataFileToFirmware(this, "/var/mobile/Library/ISP/CalData/DCNUMetadata_0", 0, 0, 0, v23 | 0x304, v38, 1);
            H16ISP::H16ISPDevice::SendDataFileToFirmware(this, "/var/mobile/Library/ISP/CalData/DCNUPixbuf_0", 0, 0, 0, v23 | 0x303, v38, 1);
          }
          else
          {
            __int16 v35 = &_os_log_internal;
            if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal)
            {
              GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
              __int16 v35 = &_os_log_internal;
            }
            if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136315394;
              uint64_t v45 = "LoadFDRDataFileCMPM";
              __int16 v46 = 2080;
              v47[0] = "/var/mobile/Library/ISP/CalData/DCNUMetadata_0";
              _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s - Could not open %s file\n", buf, 0x16u);
            }
          }
        }
      }
    }
    if (v19) {
      goto LABEL_27;
    }
  }
  if (v17) {
    CFRelease(v17);
  }
  if (v36) {
    CFRelease(v36);
  }
  if (v37) {
    CFRelease(v37);
  }
}

void H16ISP::H16ISPDevice::LoadOCClCalDataFile(H16ISP::H16ISPDevice *this)
{
  uint64_t v48 = *MEMORY[0x263EF8340];
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  mach_port_t v4 = *MEMORY[0x263F0EC88];
  CFDictionaryRef v5 = IOServiceNameMatching("AppleH16CamIn");
  io_service_t MatchingService = IOServiceGetMatchingService(v4, v5);
  CFTypeRef v7 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"FrontCameraModuleSerialNumString", v2, 3u);
  if (!v7)
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    BOOL v28 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    if (v28) {
      H16ISP::H16ISPDevice::LoadOCClCalDataFile(v28, v29, v30, v31, v32, v33, v34, v35);
    }
    goto LABEL_38;
  }
  uint64_t v8 = v7;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  uint64_t v9 = &_os_log_internal;
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "FrontCameraModuleSerialNumString exists - load OCCl calibration data\n\n", buf, 2u);
  }
  CFRelease(v8);
  CFTypeRef v10 = IORegistryEntrySearchCFProperty(MatchingService, "IOService", @"BackTeleCameraModuleSerialNumString", v2, 3u);
  if (!v10)
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v9) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    BOOL v36 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    if (v36) {
      H16ISP::H16ISPDevice::LoadOCClCalDataFile(v36, v37, v38);
    }
LABEL_38:
    IOObjectRelease(MatchingService);
    return;
  }
  unint64_t v11 = v10;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v9) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "backTeleCameraModuleSerialNumString exists - load OCCl calibration data\n\n", buf, 2u);
  }
  CFRelease(v11);
  IOObjectRelease(MatchingService);
  CFStringRef v12 = CFStringCreateWithCString(v2, "OCCl", 0x8000100u);
  MEMORY[0x24C53BCA0](H16ISP::fdrLogMessages);
  CFDictionaryAddValue(Mutable, @"CopyAllowUnsealed", (const void *)*MEMORY[0x263EFFB40]);
  CFDictionaryRef v13 = (const __CFDictionary *)AMFDRSealingMapCopyLocalDictForClass();
  uint64_t v39 = this;
  uint64_t v14 = 0;
  do
  {
    while (1)
    {
      uint64_t v15 = v14;
      uint64_t v16 = fopen(off_2651E99F0[3 * v14], "rb");
      if (v16)
      {
        CFDictionaryRef v17 = v16;
        fseeko(v16, 0, 2);
        ftello(v17);
        fseeko(v17, 0, 0);
        operator new[]();
      }
      if (v13) {
        break;
      }
      uint64_t v14 = 1;
      if (v15) {
        goto LABEL_26;
      }
    }
    uint64_t v18 = off_2651E99F0[3 * v15 + 1];
    CFStringRef v19 = CFStringCreateWithCString(v2, v18, 0x8000100u);
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(v13, v19);
    if (Value)
    {
      CFDataRef v21 = Value;
      BytePtr = CFDataGetBytePtr(Value);
      unsigned int Length = CFDataGetLength(v21);
      int DataFile = H16ISP::H16ISPDevice::ISP_LoadDataFile(v39, 0x80000000, BytePtr, Length, off_2651E99F0[3 * v15 + 2]);
      CFStringRef v25 = CFCopyDescription(v21);
      if (v25)
      {
        CFStringRef v26 = v25;
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
        {
          CStringPtr = CFStringGetCStringPtr(v26, 0);
          *(_DWORD *)buf = 136315906;
          uint64_t v41 = "LoadOCClCalDataFile";
          __int16 v42 = 1024;
          int v43 = DataFile;
          __int16 v44 = 2080;
          uint64_t v45 = v18;
          __int16 v46 = 2080;
          BOOL v47 = CStringPtr;
          _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s : Status = %08x; OCCl (%s) data - %s \n",
            buf,
            0x26u);
        }
        CFRelease(v26);
      }
    }
    if (v19) {
      CFRelease(v19);
    }
    uint64_t v14 = 1;
  }
  while (!v15);
  CFRelease(v13);
LABEL_26:
  if (v12) {
    CFRelease(v12);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

uint64_t H16ISP::H16ISPDevice::LoadSyscfgCalDataFiles(H16ISP::H16ISPDevice *this, __CFDictionary *a2)
{
  uint64_t v4 = 0;
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v6[2] = xmmword_2651E99B0;
  v6[3] = *(_OWORD *)&off_2651E99C0;
  uint64_t v6[4] = xmmword_2651E99D0;
  v6[5] = off_2651E99E0;
  v6[0] = xmmword_2651E9990;
  v6[1] = *(_OWORD *)&off_2651E99A0;
  do
  {
    uint64_t result = H16ISP::H16ISPDevice::SendSysConfigCalibrationDataByKey(this, (uint64_t)&v6[v4], a2);
    v4 += 2;
  }
  while (v4 != 6);
  return result;
}

void H16ISP::H16ISPDevice::LoadIspAneNetworkFile(H16ISP::H16ISPDevice *this)
{
  uint64_t v38 = *MEMORY[0x263EF8340];
  CFStringRef v1 = (const __CFString *)MGCopyAnswer();
  if (!v1)
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    BOOL v7 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    if (v7) {
      H16ISP::H16ISPDevice::LoadIspAneNetworkFile(v7, v8, v9);
    }
    return;
  }
  CFStringRef v2 = v1;
  CFIndex Length = CFStringGetLength(v1);
  int HasSuffix = CFStringHasSuffix(v2, @"AP");
  CFDictionaryRef v5 = (CFAllocatorRef *)MEMORY[0x263EFFB08];
  if (HasSuffix)
  {
    v6.unsigned int length = Length - 2;
  }
  else
  {
    if (!CFStringHasSuffix(v2, @"DEV"))
    {
      CFAllocatorRef v10 = *v5;
      goto LABEL_13;
    }
    v6.unsigned int length = Length - 3;
  }
  CFAllocatorRef v10 = *v5;
  if (v6.length >= 1)
  {
    v6.location = 0;
    CFStringRef v11 = CFStringCreateWithSubstring(*v5, v2, v6);
    CFRelease(v2);
    CFStringRef v2 = v11;
  }
LABEL_13:
  CFMutableStringRef MutableCopy = CFStringCreateMutableCopy(v10, 0, v2);
  CFStringLowercase(MutableCopy, 0);
  CFShow(MutableCopy);
  CFRelease(v2);
  if (MutableCopy)
  {
    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    long long v32 = 0u;
    long long v33 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v24 = 0u;
    long long v25 = 0u;
    memset(__s, 0, sizeof(__s));
    strcat(__s, "/System/Library/Isp/afpp/");
    CStringPtr = CFStringGetCStringPtr(MutableCopy, 0x8000100u);
    strcat(__s, CStringPtr);
    strcat(__s, "/ispane.afpp");
    CFRelease(MutableCopy);
    uint64_t v14 = fopen(__s, "rb");
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v15 = &_os_log_internal;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 136315138;
      CFStringRef v22 = __s;
      _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "Loading file for ISP-ANE networks - %s\n", (uint8_t *)&v21, 0xCu);
    }
    uint64_t v16 = fopen("/usr/local/share/firmware/isp/ispane.afpp", "rb");
    if (v16)
    {
      CFDictionaryRef v17 = v16;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v15) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v21) = 0;
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "Using override ISP-ANE AFPP file\n", (uint8_t *)&v21, 2u);
      }
      if (v14) {
        fclose(v14);
      }
      uint64_t v14 = v17;
LABEL_27:
      fseeko(v14, 0, 2);
      ftello(v14);
      fseeko(v14, 0, 0);
      operator new[]();
    }
    if (v14) {
      goto LABEL_27;
    }
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == v15) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    BOOL v18 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    if (v18) {
      H16ISP::H16ISPDevice::LoadIspAneNetworkFile(v18, v19, v20);
    }
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_RegisterFirmwareWorkProcessor(uint64_t a1, _DWORD *inputStruct)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097084;
  }
  long long v5 = 0u;
  return IOConnectCallAsyncMethod(v2, 0x28u, inputStruct[4], &reference, 8u, 0, 0, inputStruct, 0x18uLL, 0, 0, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_UnregisterFirmwareWorkProcessor(H16ISP::H16ISPDevice *this, mach_port_t wake_port)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  long long v5 = 0u;
  return IOConnectCallAsyncMethod(v2, 0x29u, wake_port, &reference, 8u, 0, 0, 0, 0, 0, 0, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_GetFirmwareWorkProcessorItem(uint64_t a1, mach_port_t wake_port, uint64_t a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a3;
  input[1] = 2024;
  long long v6 = 0u;
  return IOConnectCallAsyncMethod(v3, 0x2Au, wake_port, &reference, 8u, input, 2u, 0, 0, 0, 0, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_CompleteFirmwareWorkProcessorItem(uint64_t a1, mach_port_t wake_port, uint64_t a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a3;
  input[1] = 2024;
  long long v6 = 0u;
  return IOConnectCallAsyncMethod(v3, 0x2Bu, wake_port, &reference, 8u, input, 2u, 0, 0, 0, 0, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_ReleaseFirmwareWorkProcessorBuffers(H16ISP::H16ISPDevice *this, mach_port_t wake_port)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  long long v5 = 0u;
  return IOConnectCallAsyncMethod(v2, 0x2Eu, wake_port, &reference, 8u, 0, 0, 0, 0, 0, 0, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_ReleaseChannel(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x31u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_EnableS2R(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x42u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_EnableFirmwareRecovery(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x32u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_GetPearlStatistics(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 3028;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x3Du, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_GetPowerStatistics(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 40;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x4Cu, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_GetToFSACAnalytics(uint64_t a1, unsigned int a2, void *outputStruct)
{
  input[1] = *MEMORY[0x263EF8340];
  uint64_t result = 3758097084;
  mach_port_t v5 = *(_DWORD *)(a1 + 4424);
  if (v5)
  {
    if (outputStruct)
    {
      size_t v6 = 584;
      input[0] = a2;
      return IOConnectCallMethod(v5, 0x4Du, input, 1u, 0, 0, 0, 0, outputStruct, &v6);
    }
    else
    {
      return 3758097090;
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_GetCamStreamingStatistics(uint64_t a1, unsigned int a2, void *outputStruct)
{
  input[1] = *MEMORY[0x263EF8340];
  size_t v5 = 8;
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  return IOConnectCallMethod(v3, 0x63u, input, 1u, 0, 0, 0, 0, outputStruct, &v5);
}

uint64_t H16ISP::H16ISPDevice::ISP_GetFWErrorStatistics(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 16;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x64u, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_MemoryDiagnostics(H16ISP::H16ISPDevice *this)
{
  mach_port_t v1 = *((_DWORD *)this + 1106);
  if (v1) {
    return IOConnectCallScalarMethod(v1, 0x3Eu, 0, 0, 0, 0);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_EnableMOVReplay(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 353;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_DestroyMultiCameraSession(H16ISP::H16ISPDevice *this)
{
  mach_port_t v1 = *((_DWORD *)this + 1106);
  if (v1) {
    return IOConnectCallScalarMethod(v1, 0x45u, 0, 0, 0, 0);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_IsFirmwareLoaded(H16ISP::H16ISPDevice *this)
{
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = *((unsigned int *)this + 1106);
  if (result) {
    return !IOConnectCallScalarMethod(result, 0x39u, 0, 0, &output, &outputCnt) && output == 1;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_GetSensorConfigInfo(uint64_t a1, unsigned int a2, unsigned int a3, void *outputStruct)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  size_t v6 = 212;
  mach_port_t v4 = *(_DWORD *)(a1 + 4424);
  if (!v4) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallMethod(v4, 0x1Cu, input, 2u, 0, 0, 0, 0, outputStruct, &v6);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetDriverLoggingFlags(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x10u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetFullStatsMode(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x16u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetFirmwareBootArg(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallScalarMethod(v3, 0x43u, input, 2u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_CreateClientLoggingSession(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallScalarMethod(v3, 0x1Eu, input, 2u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_TerminateClientLoggingSession(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x1Fu, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_ShowSharedMemoryAllocations(H16ISP::H16ISPDevice *this, uint64_t a2)
{
  uint64_t input = a2;
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (v2) {
    return IOConnectCallScalarMethod(v2, 0x11u, &input, 1u, 0, 0);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::SetClientPrivateData(uint64_t this, void *a2)
{
  *(void *)(this + 4400) = a2;
  return this;
}

uint64_t H16ISP::H16ISPDevice::GetClientPrivateData(H16ISP::H16ISPDevice *this)
{
  return *((void *)this + 550);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetBestMIPIFrequencyIndex(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallScalarMethod(v3, 0x1Du, input, 2u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetBestChargePumpFrequencyIndex(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallScalarMethod(v3, 0x2Du, input, 2u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetBestPixClockFrequencyIndex(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallScalarMethod(v3, 0x3Cu, input, 2u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_InstallFakeSensor(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallScalarMethod(v3, 0x2Fu, input, 2u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_PPMAdmissionCheck(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, _DWORD *a5)
{
  uint64_t input[3] = *MEMORY[0x263EF8340];
  mach_port_t v5 = *(_DWORD *)(a1 + 4424);
  if (!v5) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  uint64_t input[2] = a4;
  uint32_t outputCnt = 1;
  uint64_t result = IOConnectCallScalarMethod(v5, 0x34u, input, 3u, &output, &outputCnt);
  *a5 = output;
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_PPMActivityStopped(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  v6[3] = *MEMORY[0x263EF8340];
  mach_port_t v4 = *(_DWORD *)(a1 + 4424);
  if (!v4) {
    return 3758097084;
  }
  v6[0] = a2;
  v6[1] = a3;
  uint64_t v6[2] = a4;
  return IOConnectCallScalarMethod(v4, 0x35u, v6, 3u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_GetSavagePubKey(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  *(void *)&v15[732] = *MEMORY[0x263EF8340];
  if (*a4 != 128) {
    return 3758097090;
  }
  bzero(v11, 0x2F0uLL);
  __int16 v12 = 1308;
  int v13 = a2;
  size_t __n = 0x8000000000;
  uint64_t v8 = H16ISP::H16ISPDevice::ISP_SendCommand(this, v11, 0x2F0u, 0, 0xFFFFFFFF);
  if (!v8)
  {
    unsigned __int8 v9 = BYTE4(__n);
    memcpy(a3, v15, HIDWORD(__n));
    *a4 = v9;
  }
  return v8;
}

uint64_t H16ISP::H16ISPDevice::ISP_SetHostPubKey(H16ISP::H16ISPDevice *this, int a2, unsigned __int8 *a3, int a4, uint64_t a5)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  if (a4 != 128) {
    return 3758097090;
  }
  bzero(v14, 0x2F0uLL);
  uint64_t v17 = 0x8000000003;
  long long v9 = *((_OWORD *)a3 + 5);
  long long v22 = *((_OWORD *)a3 + 4);
  long long v23 = v9;
  long long v10 = *((_OWORD *)a3 + 7);
  long long v24 = *((_OWORD *)a3 + 6);
  long long v25 = v10;
  long long v11 = *((_OWORD *)a3 + 1);
  long long v18 = *(_OWORD *)a3;
  long long v19 = v11;
  long long v12 = *((_OWORD *)a3 + 3);
  long long v20 = *((_OWORD *)a3 + 2);
  __int16 v15 = 1308;
  int v16 = a2;
  uint64_t v26 = a5;
  long long v21 = v12;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v14, 0x2F0u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_YonkersFusing(H16ISP::H16ISPDevice *this, unsigned int a2, const unsigned __int8 *a3, unsigned int a4)
{
  uint64_t v17 = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  if (*((_DWORD *)this + 1106))
  {
    long long v9 = fopen("/usr/local/share/firmware/isp/Yonkers/YonkersPatchOverride.DAT", "rb");
    if (v9)
    {
      long long v10 = v9;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "Trying to use override YonkersPatchOverride.DAT file\n", buf, 2u);
      }
      fseeko(v10, 0, 2);
      ftello(v10);
      fseeko(v10, 0, 0);
      operator new[]();
    }
    uint64_t v16 = a2;
    if (a3 && a4)
    {
      *(void *)buf = a3;
      uint64_t v15 = a4;
      return IOConnectCallScalarMethod(*((_DWORD *)this + 1106), 0x41u, (const uint64_t *)buf, 3u, 0, 0);
    }
    else
    {
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)
        && (H16ISP::H16ISPDevice::ISP_YonkersFusing(0, v12, v13) & 1) != 0)
      {
        MEMORY[0x24C53D6C0](0, 0x1000C8077774924);
      }
    }
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::ISP_LoadIspAneAFPPFile(H16ISP::H16ISPDevice *this, const unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (v3)
  {
    *(void *)size_t v6 = a2;
    *(void *)&v6[8] = a3;
    uint64_t v4 = IOConnectCallScalarMethod(v3, 0x62u, (const uint64_t *)v6, 2u, 0, 0);
  }
  else
  {
    uint64_t v4 = 3758097084;
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)size_t v6 = 136315394;
    *(void *)&uint64_t v6[4] = "ISP_LoadIspAneAFPPFile";
    *(_WORD *)&v6[12] = 1024;
    *(_DWORD *)&v6[14] = v4;
    _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - status: %08x\n", v6, 0x12u);
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::ISP_SavageFusing(H16ISP::H16ISPDevice *this, unsigned int a2, const unsigned __int8 *a3, unsigned int a4, unsigned int a5)
{
  uint64_t v19 = *MEMORY[0x263EF8340];
  uint64_t v5 = 3758097084;
  if (*((_DWORD *)this + 1106))
  {
    long long v11 = fopen("/usr/local/share/firmware/isp/Savage/SavagePatchOverride.DAT", "rb");
    if (v11)
    {
      uint64_t v12 = v11;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "Trying to use SavagePatchOverride.DAT file\n", buf, 2u);
      }
      fseeko(v12, 0, 2);
      ftello(v12);
      fseeko(v12, 0, 0);
      operator new[]();
    }
    uint64_t v18 = a2;
    if (a3 && a4)
    {
      *(void *)buf = a3;
      uint64_t v17 = a4;
      if (H16ISP::H16ISPDevice::ISP_LoadDataFile(this, a2, a3, a4, a5) != -536870212) {
        return IOConnectCallScalarMethod(*((_DWORD *)this + 1106), 2u, (const uint64_t *)buf, 3u, 0, 0);
      }
    }
    else
    {
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)
        && (H16ISP::H16ISPDevice::ISP_SavageFusing(0, v13, v14) & 1) != 0)
      {
        MEMORY[0x24C53D6C0](0, 0x1000C8077774924);
      }
    }
  }
  return v5;
}

uint64_t H16ISP::H16ISPDevice::ISP_LoadDataFile(H16ISP::H16ISPDevice *this, int a2, const unsigned __int8 *a3, unsigned int a4, unsigned int a5)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  mach_port_t v7 = *((_DWORD *)this + 1106);
  if (v7)
  {
    long long v11 = a3;
    uint64_t v12 = a4;
    uint64_t v13 = (const char *)a2;
    uint64_t v14 = a5;
    uint64_t v8 = IOConnectCallScalarMethod(v7, 0x25u, (const uint64_t *)&v11, 4u, 0, 0);
  }
  else
  {
    uint64_t v8 = 3758097084;
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v11) = 67109890;
    HIDWORD(v11) = a2 & 0x7FFFFFFF;
    long long v9 = "false";
    LOWORD(v12) = 1024;
    if (a2 < 0) {
      long long v9 = "true";
    }
    *(_DWORD *)((char *)&v12 + 2) = a5;
    HIWORD(v12) = 2080;
    uint64_t v13 = v9;
    LOWORD(v14) = 1024;
    *(_DWORD *)((char *)&v14 + 2) = v8;
    _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "Load data file: channel: %d, type: %d, isEarlyBootDataFile: %s, status: %08x\n\n", (uint8_t *)&v11, 0x1Eu);
  }
  return v8;
}

uint64_t H16ISP::H16ISPDevice::ISP_SavageAuth(H16ISP::H16ISPDevice *this, unsigned int a2, const unsigned __int8 *a3, uint64_t a4, unsigned int a5)
{
  v22[1] = *MEMORY[0x263EF8340];
  mach_port_t v6 = *((_DWORD *)this + 1106);
  if (v6)
  {
    if (a3 && a4)
    {
      *(void *)&long long buf = a3;
      *((void *)&buf + 1) = a4;
      v22[0] = a2;
      uint64_t v9 = IOConnectCallScalarMethod(v6, 0x6Du, v22, 1u, 0, 0);
      if (v9)
      {
        uint64_t v10 = v9;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
        }
        if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = 136315394;
          uint64_t v18 = "ISP_SavageAuth";
          __int16 v19 = 1024;
          int v20 = v10;
          long long v11 = &_os_log_internal;
          uint64_t v12 = "%s: Savage Pre Auth failed, status = 0x%x\n";
LABEL_28:
          p_long long buf = (uint8_t *)&v17;
          uint32_t v14 = 18;
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t DataFile = H16ISP::H16ISPDevice::ISP_LoadDataFile(this, a2, (const unsigned __int8 *)buf, DWORD2(buf), a5);
        if (DataFile)
        {
          uint64_t v10 = DataFile;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
          {
            int v17 = 136315394;
            uint64_t v18 = "ISP_SavageAuth";
            __int16 v19 = 1024;
            int v20 = v10;
            long long v11 = &_os_log_internal;
            uint64_t v12 = "%s: Data file load failed, status = 0x%x\n";
            goto LABEL_28;
          }
        }
        else
        {
          uint64_t v10 = IOConnectCallScalarMethod(*((_DWORD *)this + 1106), 0x6Eu, v22, 1u, 0, 0);
          if (v10)
          {
            if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
              GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
            }
            if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
            {
              int v17 = 136315394;
              uint64_t v18 = "ISP_SavageAuth";
              __int16 v19 = 1024;
              int v20 = v10;
              long long v11 = &_os_log_internal;
              uint64_t v12 = "%s: Savage Auth failed, status = 0x%x\n";
              goto LABEL_28;
            }
          }
        }
      }
    }
    else
    {
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 136315138;
        *(void *)((char *)&buf + 4) = "ISP_SavageAuth";
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s: Invalid data file arguments\n", (uint8_t *)&buf, 0xCu);
      }
      return 3758096385;
    }
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    uint64_t v10 = 3758097084;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "ISP_SavageAuth";
      long long v11 = &_os_log_internal;
      uint64_t v12 = "%s: Invalid connection\n";
      p_long long buf = (uint8_t *)&buf;
      uint32_t v14 = 12;
LABEL_29:
      _os_log_impl(&dword_24680F000, v11, OS_LOG_TYPE_DEFAULT, v12, p_buf, v14);
    }
  }
  return v10;
}

uint64_t H16ISP::H16ISPDevice::CopyFileToBuffer(H16ISP::H16ISPDevice *this, const char *__filename, unsigned __int8 **a3, uint64_t *a4)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097090;
  if (a3 && a4)
  {
    *a3 = 0;
    *a4 = 0;
    uint64_t v8 = fopen(__filename, "rb");
    if (v8)
    {
      uint64_t v9 = v8;
      fseeko(v8, 0, 2);
      off_t v10 = ftello(v9);
      fseeko(v9, 0, 0);
      long long v11 = (unsigned __int8 *)malloc_type_calloc(v10, 1uLL, 0xFCA9B5AFuLL);
      if (v11)
      {
        uint64_t v12 = v11;
        size_t v13 = fread(v11, 1uLL, v10, v9);
        if (v13 == v10)
        {
          *a3 = v12;
          *a4 = v10;
          size_t v14 = v10;
        }
        else
        {
          size_t v14 = v13;
          free(v12);
        }
      }
      else
      {
        size_t v14 = 0;
      }
      fclose(v9);
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
      }
      uint64_t v4 = 0;
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 136315906;
        int v17 = "CopyFileToBuffer";
        __int16 v18 = 2080;
        __int16 v19 = __filename;
        __int16 v20 = 2048;
        off_t v21 = v10;
        __int16 v22 = 2048;
        size_t v23 = v14;
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - Trying to use %s: Size = %lld (== %lld ?);\n",
          (uint8_t *)&v16,
          0x2Au);
        return 0;
      }
    }
    else
    {
      return 3758097136;
    }
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::SendSysConfigCalibrationDataByKey(H16ISP::H16ISPDevice *a1, uint64_t a2, const __CFDictionary *a3)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  uint64_t DataFile = 3758097090;
  BytePtr = 0;
  *(void *)__int16 v19 = 0;
  if (a2)
  {
    uint64_t v5 = *(const char **)(a2 + 8);
    if (v5)
    {
      if (*(int *)(a2 + 4) >= 1024)
      {
        long long v25 = 0u;
        long long v26 = 0u;
        memset(__str, 0, sizeof(__str));
        uint64_t v8 = (H16ISP::H16ISPDevice *)snprintf(__str, 0x40uLL, "%s%s.%s", "/usr/local/share/firmware/isp/", v5, "DAT");
        int v9 = H16ISP::H16ISPDevice::CopyFileToBuffer(v8, __str, &BytePtr, (uint64_t *)v19);
        if (v9)
        {
          if (!a3) {
            goto LABEL_34;
          }
          CFDataRef Value = CFDictionaryGetValue(a3, *(const void **)(a2 + 16));
          if (!Value) {
            goto LABEL_34;
          }
          CFDataRef v11 = (const __CFData *)CFRetain(Value);
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = *(void *)(a2 + 8);
            *(_DWORD *)long long buf = 136315394;
            off_t v21 = "SendSysConfigCalibrationDataByKey";
            __int16 v22 = 2080;
            uint64_t v23 = v12;
            _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - Using %s from unit info plist\n", buf, 0x16u);
          }
          if (!v11)
          {
LABEL_34:
            mach_port_t v13 = *MEMORY[0x263F0EC90];
            CFDictionaryRef v14 = IOServiceNameMatching("AppleH16CamIn");
            io_service_t MatchingService = IOServiceGetMatchingService(v13, v14);
            CFDataRef v11 = (const __CFData *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", *(CFStringRef *)(a2 + 24), (CFAllocatorRef)*MEMORY[0x263EFFB08], 3u);
            if (!v11) {
              return 3758097084;
            }
          }
          *(void *)__int16 v19 = CFDataGetLength(v11);
          BytePtr = (unsigned __int8 *)CFDataGetBytePtr(v11);
        }
        else
        {
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136315138;
            off_t v21 = __str;
            _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "Loaded calibration file from override path: %s\n", buf, 0xCu);
          }
          CFDataRef v11 = 0;
        }
        uint64_t DataFile = 0;
        if (BytePtr && *(void *)v19)
        {
          uint64_t DataFile = H16ISP::H16ISPDevice::ISP_LoadDataFile(a1, *(_DWORD *)a2 | 0x80000000, BytePtr, v19[0], *(_DWORD *)(a2 + 4));
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
          }
          if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v16 = *(void *)(a2 + 8);
            *(_DWORD *)__str = 136315906;
            *(void *)&__str[4] = "SendSysConfigCalibrationDataByKey";
            *(_WORD *)&__str[12] = 2080;
            *(void *)&__str[14] = v16;
            *(_WORD *)&__str[22] = 2048;
            *(void *)&__str[24] = *(void *)v19;
            LOWORD(v25) = 1024;
            *(_DWORD *)((char *)&v25 + 2) = DataFile;
            _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - %s - unsigned int length = %ld; status = %08x\n",
              (uint8_t *)__str,
              0x26u);
          }
        }
        if (!v9 && BytePtr) {
          free(BytePtr);
        }
        if (v11) {
          CFRelease(v11);
        }
      }
    }
  }
  return DataFile;
}

void H16ISP::fdrLogMessages(H16ISP *this, uint64_t a2, const char *a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
  }
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315394;
    uint64_t v5 = "fdrLogMessages";
    __int16 v6 = 2080;
    uint64_t v7 = a2;
    _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "%s - %s\n", (uint8_t *)&v4, 0x16u);
  }
}

BOOL H16ISP::H16ISPDevice::isYonkersSensorSupported(H16ISP::H16ISPDevice *this, unsigned int *a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = *((void *)this + 548);
  int v4 = *(unsigned __int8 *)(v3 + 600);
  for (uint64_t i = (_DWORD *)(v3 + 16); ; i += 24)
  {
    if (*(i - 2))
    {
      if (*i == 1718776695 || *i == 1718775412) {
        break;
      }
    }
    if (++v2 == 6) {
      return v4 != 0;
    }
  }
  *a2 = v2;
  return v4 != 0;
}

BOOL H16ISP::H16ISPDevice::isSavageSensorSupported(H16ISP::H16ISPDevice *this, unsigned int *a2)
{
  unint64_t v2 = 0;
  uint64_t v3 = (_DWORD *)(*((void *)this + 548) + 16);
  BOOL v4 = 1;
  while (*v3 != 1718186595 || *(v3 - 2) != 1)
  {
    BOOL v4 = v2 < 5;
    v3 += 24;
    if (++v2 == 6) {
      return 0;
    }
  }
  *a2 = v2;
  return v4;
}

uint64_t H16ISP::H16ISPDevice::ISP_IsSupportedFrontAutoFocus(H16ISP::H16ISPDevice *this)
{
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t result = *((unsigned int *)this + 1106);
  if (result)
  {
    if (IOConnectCallScalarMethod(result, 0x53u, 0, 0, &output, &outputCnt)) {
      BOOL v2 = 1;
    }
    else {
      BOOL v2 = output == 0;
    }
    return !v2;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::GetFlickerDetectorHWType(uint64_t result, _DWORD *a2)
{
  if (a2) {
    *a2 = *(_DWORD *)(*(void *)(result + 4384) + 616);
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_SetDARTCacheTTL(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x1Au, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_EnableMIPIClockAdjustments(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x1Bu, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_ClockSet(H16ISP::H16ISPDevice *this, char a2)
{
  bzero(v5, 0xCuLL);
  __int16 v6 = 32;
  char v7 = a2;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_GeneralProcessStart(H16ISP::H16ISPDevice *a1, unsigned int a2, _WORD *a3)
{
  if (a2 > 6) {
    return 3758097090;
  }
  uint64_t v13 = v3;
  uint64_t v14 = v4;
  __int16 v7 = word_2469EE398[a2];
  bzero(v9, 0x10uLL);
  __int16 v10 = 303;
  __int16 v11 = v7;
  uint64_t result = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0x10u, 0, 0xFFFFFFFF);
  if (!result) {
    *a3 = v12;
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_GeneralProcessStop(H16ISP::H16ISPDevice *this, __int16 a2)
{
  bzero(v5, 0x10uLL);
  __int16 v7 = a2;
  __int16 v6 = 304;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v5, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_GeneralProcessGeneric(uint64_t a1, void *inputStruct, mach_port_t a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  if (a3)
  {
    long long v6 = 0u;
    return IOConnectCallAsyncMethod(v3, 0x27u, a3, &reference, 8u, 0, 0, inputStruct, 0x478uLL, 0, 0, 0, 0);
  }
  else
  {
    return IOConnectCallStructMethod(v3, 0x27u, inputStruct, 0x478uLL, 0, 0);
  }
}

uint64_t H16ISP::H16ISPDevice::ISP_GeneralProcess(uint64_t a1, void *inputStruct, mach_port_t a3)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097084;
  }
  if (a3)
  {
    long long v6 = 0u;
    return IOConnectCallAsyncMethod(v3, 0x26u, a3, &reference, 8u, 0, 0, inputStruct, 0x3C8uLL, 0, 0, 0, 0);
  }
  else
  {
    return IOConnectCallStructMethod(v3, 0x26u, inputStruct, 0x3C8uLL, 0, 0);
  }
}

uint64_t H16ISP::H16ISPDevice::GetMultiCamSessionStatus(H16ISP::H16ISPDevice *a1, void *a2, unsigned __int16 *a3)
{
  bzero(v9, 0xB4uLL);
  __int16 v10 = 13315;
  uint64_t v6 = H16ISP::H16ISPDevice::ISP_SendCommand(a1, v9, 0xB4u, 0, 0xFFFFFFFF);
  unsigned __int16 v7 = v11;
  memcpy(a2, &v12, 28 * v11);
  *a3 = v7;
  return v6;
}

uint64_t H16ISP::H16ISPDevice::ISP_GetJasperStatistics(uint64_t a1, void *outputStruct)
{
  size_t outputStructCnt = 100;
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (v2) {
    return IOConnectCallStructMethod(v2, 0x4Eu, 0, 0, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::GetDriverPerformanceMetrics(uint64_t a1, void *outputStruct)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097112;
  }
  size_t v4 = 8;
  return IOConnectCallMethod(v2, 0x6Fu, 0, 0, 0, 0, 0, 0, outputStruct, &v4);
}

uint64_t H16ISP::H16ISPDevice::GetDriverKextInfo(uint64_t a1, void *outputStruct)
{
  mach_port_t v2 = *(_DWORD *)(a1 + 4424);
  if (!v2) {
    return 3758097112;
  }
  size_t v4 = 75;
  return IOConnectCallMethod(v2, 0x70u, 0, 0, 0, 0, 0, 0, outputStruct, &v4);
}

uint64_t H16ISP::H16ISPDevice::ISP_MapMPMMemory(H16ISP::H16ISPDevice *this, uint64_t a2, uint64_t a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v3 = *((_DWORD *)this + 1106);
  if (!v3) {
    return 3758097084;
  }
  input[0] = a2;
  input[1] = a3;
  return IOConnectCallScalarMethod(v3, 0x54u, input, 2u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_UnmapMPMMemory(H16ISP::H16ISPDevice *this, uint64_t a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x55u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetLowMemoryMode(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x6Au, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_GetLowMemoryMode(H16ISP::H16ISPDevice *this, BOOL *a2)
{
  uint64_t result = 3758097084;
  mach_port_t v4 = *((_DWORD *)this + 1106);
  if (v4)
  {
    if (a2)
    {
      uint64_t output = 0;
      uint32_t outputCnt = 1;
      uint64_t result = IOConnectCallScalarMethod(v4, 0x6Cu, 0, 0, &output, &outputCnt);
      if (!result) {
        *a2 = output != 0;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::SetDeskViewEnabled(H16ISP::H16ISPDevice *this, int a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v8 = 2640;
  int v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_SetAudioBufferReceiverCallbackBlock(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4760) = a2;
  uint64_t v2 = *(void *)(a1 + 4792);
  if (v2) {
    H16ISP::DCSAudioAccelManager::SetCallbackBlock(v2, a2);
  }
  return 0;
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_SetAudioBufferReceiverCallbackPtr(H16ISP::H16ISPDevice *this, void (*a2)(__CVBuffer *, CMTime *__struct_ptr))
{
  *((void *)this + 596) = a2;
  uint64_t v2 = *((void *)this + 599);
  if (v2) {
    H16ISP::DCSAudioAccelManager::SetCallbackPtr(v2, a2);
  }
  return 0;
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_SetAudioBufferReceiverMessageCallbackBlock(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 4776) = a2;
  uint64_t v2 = *(void *)(a1 + 4792);
  if (v2) {
    H16ISP::DCSAudioAccelManager::SetMessageCallbackBlock(v2, a2);
  }
  return 0;
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_SetAudioBufferReceiverMessageCallbackPtr(H16ISP::H16ISPDevice *this, void (*a2)(unsigned int, unsigned int, unsigned int))
{
  *((void *)this + 598) = a2;
  uint64_t v2 = *((void *)this + 599);
  if (v2) {
    H16ISP::DCSAudioAccelManager::SetMessageCallbackPtr(v2, a2);
  }
  return 0;
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_SetAudioTestMode(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  *((void *)this + 594) = a2;
  uint64_t v2 = (void *)*((void *)this + 599);
  if (v2) {
    H16ISP::DCSAudioAccelManager::SetTestMode(v2, a2);
  }
  return 0;
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_EnableAudioAccelStreaming(H16ISP::H16ISPDevice *this, int a2, uint64_t a3, H16ISP::DCSAudioAccelManager **a4)
{
  uint64_t v5 = (H16ISP::H16ISPDevice ***)((char *)this + 4792);
  uint64_t result = *((void *)this + 599);
  if (!a2)
  {
    if (!result) {
      return result;
    }
    BOOL v9 = 0;
    if (!H16ISP::DCSAudioAccelManager::GetStreamingStatus((H16ISP::DCSAudioAccelManager *)result, &v9))
    {
      if (v9)
      {
        uint64_t result = H16ISP::DCSAudioAccelManager::StopStreaming(*v5);
        if (result) {
          return result;
        }
        uint64_t result = H16ISP::DCSAudioAccelManager::DestroyStreamSession((H16ISP::DCSAudioAccelManager *)*v5);
        if (result) {
          return result;
        }
        uint64_t result = H16ISP::DestroyAudioAccelManager(v5, v7);
        if (result) {
          return result;
        }
        const char *v5 = 0;
      }
      return 0;
    }
    return 3758097084;
  }
  if (!result) {
    H16ISP::CreateAudioAccelManager(this, (H16ISP::H16ISPDevice *)((char *)this + 4752), (DCSAudioAccelClientConfigStruct *)v5, a4);
  }
  BOOL v8 = 0;
  if (H16ISP::DCSAudioAccelManager::GetStreamingStatus((H16ISP::DCSAudioAccelManager *)result, &v8)) {
    return 3758097084;
  }
  if (v8) {
    return 0;
  }
  uint64_t result = H16ISP::DCSAudioAccelManager::CreateStreamSession((H16ISP::DCSAudioAccelManager *)*v5);
  if (!result)
  {
    uint64_t result = H16ISP::DCSAudioAccelManager::StartStreaming(*v5);
    if (!result) {
      return 0;
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_GetAudioAccelStreaming(H16ISP::H16ISPDevice *this, BOOL *a2)
{
  mach_port_t v3 = (H16ISP::DCSAudioAccelManager *)*((void *)this + 599);
  if (v3)
  {
    BOOL v6 = 0;
    if (H16ISP::DCSAudioAccelManager::GetStreamingStatus(v3, &v6)) {
      return 3758097084;
    }
    BOOL v5 = v6;
  }
  else
  {
    BOOL v5 = 0;
  }
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_EnableAudio(H16ISP::H16ISPDevice *this, char a2, char a3)
{
  bzero(v7, 0xCuLL);
  __int16 v8 = -24576;
  char v9 = a2;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0xCu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_DCS_GetAudioConfig(H16ISP::H16ISPDevice *a1, void *a2)
{
  if (!a2) {
    return 3758097090;
  }
  bzero(a2, 0x18uLL);
  *((_WORD *)a2 + 2) = -24574;

  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, (unsigned __int8 *)a2, 0x18u, 0, 0xFFFFFFFF);
}

BOOL H16ISP::H16ISPDevice::isConclaveRunning(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  BOOL v3 = a2 > 5
    || (uint64_t v2 = *((void *)this + 548), !*(_DWORD *)(v2 + 96 * a2 + 8))
    || *(_DWORD *)(v2 + 96 * a2 + 16) != 1718186595;
  mach_port_t v4 = (char *)this + 48 * v3;
  int v5 = v4[144];
  if (!v4[144])
  {
    BOOL v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      BOOL v6 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::isConclaveRunning();
    }
  }
  return v5 != 0;
}

uint64_t H16ISP::H16ISPDevice::SetupConclave(H16ISP::H16ISPDevice *this, unsigned int a2, BOOL *a3)
{
  if (!*((unsigned char *)this + 4368)) {
    return 3758097095;
  }
  BOOL v4 = a2 > 5
    || (uint64_t v3 = *((void *)this + 548), !*(_DWORD *)(v3 + 96 * a2 + 8))
    || *(_DWORD *)(v3 + 96 * a2 + 16) != 1718186595;
  int v5 = (char *)this + 48 * v4;
  *((_DWORD *)v5 + 32) = v4;
  uint64_t v6 = H16ISPConclaveService::SetUpEndPoint((H16ISPConclaveService *)(v5 + 120));
  if (v6)
  {
    uint64_t v9 = v6;
    unsigned __int16 v11 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      unsigned __int16 v11 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v11;
    }
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::SetupConclave();
    }
  }
  else
  {
    uint64_t v7 = H16ISPConclaveService::InitializeExclaveKit((H16ISPConclaveService *)(v5 + 120));
    if (v7)
    {
      uint64_t v9 = v7;
      uint64_t v12 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        uint64_t v12 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v12;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::SetupConclave();
      }
    }
    else
    {
      v5[144] = 1;
      __int16 v8 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        __int16 v8 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v8;
      }
      uint64_t v9 = 0;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v13 = 0;
        _os_log_impl(&dword_24680F000, v8, OS_LOG_TYPE_DEFAULT, "[Conclave] All ExclaveKits are successfully setup. Conclave is now fully enabled\n", v13, 2u);
        return 0;
      }
    }
  }
  return v9;
}

uint64_t H16ISPConclaveService::SetUpEndPoint(H16ISPConclaveService *this)
{
  uint64_t v15 = *MEMORY[0x263EF8340];
  this->var0 = 0;
  int v2 = tb_conclave_endpoint_for_service();
  if (v2 || (uint64_t v6 = this->var0) == 0)
  {
    uint64_t v3 = 3758097084;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      int var1 = this->var1;
      var0 = this->var0;
      int v9 = 67109632;
      int v10 = var1;
      __int16 v11 = 1024;
      int v12 = v2;
      __int16 v13 = 2048;
      uint64_t v14 = var0;
      _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "[Conclave] tb_conclave_endpoint_for_service failed (EKType:%d / kr:%u / mConclaveEndpoint:%lu)\n", (uint8_t *)&v9, 0x18u);
    }
  }
  else
  {
    uint64_t v3 = 0;
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = this->var1;
      int v9 = 67109632;
      int v10 = v7;
      __int16 v11 = 1024;
      int v12 = 0;
      __int16 v13 = 2048;
      uint64_t v14 = v6;
      _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "[Conclave] tb_conclave_endpoint_for_service is success (EKType:%d / kr:%u / mConclaveEndpoint:%lu)\n", (uint8_t *)&v9, 0x18u);
      return 0;
    }
  }
  return v3;
}

uint64_t H16ISPConclaveService::InitializeExclaveKit(H16ISPConclaveService *this)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  int var1 = this->var1;
  if (var1 != 1)
  {
    if (var1)
    {
      uint64_t v4 = 0;
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v10) = 0;
        _os_log_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEFAULT, "[Conclave] Invalid EK Type!", (uint8_t *)&v10, 2u);
        return 0;
      }
      return v4;
    }
    p_var4 = &this->var4;
    if (ispirexclavekitmodule_ispirexclavekit_init((uint64_t *)&this->var4))
    {
      uint64_t v4 = 3758097084;
      if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = this->var1;
        int v10 = 67109120;
        int v11 = v5;
        uint64_t v6 = &_os_log_internal;
        int v7 = "[Conclave] (EKType:%d) Failed to setup IR client\n";
LABEL_9:
        _os_log_impl(&dword_24680F000, v6, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v10, 8u);
        return v4;
      }
      return v4;
    }
LABEL_12:
    uint64_t v4 = 0;
    this->var2 = p_var4;
    return v4;
  }
  p_var4 = &this->var5;
  if (!isprgbexclavekitmodule_isprgbexclavekit_init((uint64_t *)&this->var5)) {
    goto LABEL_12;
  }
  uint64_t v4 = 3758097084;
  if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = this->var1;
    int v10 = 67109120;
    int v11 = v8;
    uint64_t v6 = &_os_log_internal;
    int v7 = "[Conclave] (EKType:%d) Failed to setup RGB client\n";
    goto LABEL_9;
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::ISP_SecureStreamConfig(uint64_t a1, void *inputStruct, void *outputStruct)
{
  size_t outputStructCnt = 60;
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (v3) {
    return IOConnectCallStructMethod(v3, 0x58u, inputStruct, 0x14uLL, outputStruct, &outputStructCnt);
  }
  else {
    return 3758097084;
  }
}

uint64_t H16ISP::H16ISPDevice::SetExclusiveExclaveStreamingMode(H16ISP::H16ISPDevice *this, __int16 a2, int a3)
{
  char v3 = a3;
  int v6 = 1 << a2;
  if (a3) {
    int v7 = *((_DWORD *)this + 1093) | v6;
  }
  else {
    int v7 = *((_DWORD *)this + 1093) & ~v6;
  }
  *((_DWORD *)this + 1093) = v7;
  bzero(v9, 0x10uLL);
  __int16 v11 = a2;
  __int16 v10 = -28670;
  char v12 = v3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v9, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::SetExclaveOutputMetadata(H16ISP::H16ISPDevice *this, __int16 a2, char a3)
{
  bzero(v7, 0x10uLL);
  __int16 v9 = a2;
  __int16 v8 = -28669;
  char v10 = a3;
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, v7, 0x10u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::PowerOnExclaveKit(H16ISP::H16ISPDevice *this, unsigned int a2, BOOL *a3)
{
  uint64_t v47 = *MEMORY[0x263EF8340];
  uint64_t v5 = H16ISP::H16ISPDevice::SetupConclave(this, a2, a3);
  if (v5) {
    return v5;
  }
  if (a2 > 5) {
    goto LABEL_28;
  }
  uint64_t v6 = *((void *)this + 548);
  if (!*(_DWORD *)(v6 + 96 * a2 + 8)) {
    goto LABEL_28;
  }
  int v7 = *(_DWORD *)(v6 + 96 * a2 + 16);
  if (v7 == 1718776695 || v7 == 1718775412)
  {
    uint64_t v9 = *((void *)this + 23);
    char v44 = 0;
    if (v9)
    {
      kdebug_trace();
      int v10 = isprgbexclavekitmodule_isprgbexclavekit_sendcmdon();
      kdebug_trace();
      if (!v10)
      {
        if (!byte_26B11BF60) {
          goto LABEL_32;
        }
        __int16 v11 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          __int16 v11 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v11;
        }
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_32;
        }
        *(_WORD *)int v43 = 0;
        char v12 = "[Exclaves]: Sent RGB cmd on!\n";
        goto LABEL_27;
      }
      long long v33 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        long long v33 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v33;
      }
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::PowerOnExclaveKit();
      }
    }
    else
    {
      long long v25 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        long long v25 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v25;
      }
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::PowerOnExclaveKit(v25, v26, v27, v28, v29, v30, v31, v32);
      }
    }
    return 3758097084;
  }
  if (v7 != 1718186595)
  {
LABEL_28:
    uint64_t v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v15 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v15;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::PowerOnExclaveKit(v15, v16, v17, v18, v19, v20, v21, v22);
    }
    goto LABEL_32;
  }
  uint64_t v13 = *((void *)this + 17);
  if (v13) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 3758097084;
  }
  char v44 = 0;
  if (v13)
  {
    kdebug_trace();
    int v14 = ispirexclavekitmodule_ispirexclavekit_sendcmdon();
    kdebug_trace();
    if (!v14)
    {
      if (!byte_26B11BF60) {
        goto LABEL_32;
      }
      __int16 v11 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        __int16 v11 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v11;
      }
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_32;
      }
      *(_WORD *)int v43 = 0;
      char v12 = "[Exclaves]: Sent IR cmd on!\n";
LABEL_27:
      _os_log_impl(&dword_24680F000, v11, OS_LOG_TYPE_DEFAULT, v12, v43, 2u);
LABEL_32:
      uint64_t v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        uint64_t v23 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v23;
      }
      if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136315138;
        __int16 v46 = "PowerOnExclaveKit";
        _os_log_impl(&dword_24680F000, v23, OS_LOG_TYPE_INFO, "%s - Power ON EK Success\n", buf, 0xCu);
      }
      return 0;
    }
    __int16 v42 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      __int16 v42 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v42;
    }
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::PowerOnExclaveKit();
    }
  }
  else
  {
    long long v34 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      long long v34 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v34;
    }
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::PowerOnExclaveKit(v34, v35, v36, v37, v38, v39, v40, v41);
    }
  }
  return v5;
}

uint64_t H16ISP::H16ISPDevice::enabledExclaveDebug(H16ISP::H16ISPDevice *this)
{
  return byte_26B11BF60;
}

uint64_t H16ISP::H16ISPDevice::PowerOffExclaveKit(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  if (a2 > 5) {
    goto LABEL_33;
  }
  uint64_t v2 = *((void *)this + 548);
  if (!*(_DWORD *)(v2 + 96 * a2 + 8)) {
    goto LABEL_33;
  }
  uint64_t v3 = 3758097084;
  int v4 = *(_DWORD *)(v2 + 96 * a2 + 16);
  if (v4 != 1718776695 && v4 != 1718775412)
  {
    if (v4 == 1718186595)
    {
      char v43 = 0;
      uint64_t v12 = *((void *)this + 17);
      if (v12) {
        uint64_t v7 = 0;
      }
      else {
        uint64_t v7 = 3758097084;
      }
      if (!v12)
      {
        uint64_t v31 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          uint64_t v31 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v31;
        }
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::PowerOffExclaveKit(v31, v32, v33, v34, v35, v36, v37, v38);
        }
        goto LABEL_30;
      }
      kdebug_trace();
      int v8 = ispirexclavekitmodule_ispirexclavekit_sendcmdoff();
      kdebug_trace();
      if (v8)
      {
        uint64_t v39 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          uint64_t v39 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v39;
        }
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::PowerOffExclaveKit();
        }
        goto LABEL_31;
      }
      if (byte_26B11BF60)
      {
        uint64_t v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          uint64_t v9 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v9;
        }
        int v8 = 0;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          int v10 = "[Exclaves]: Sent IR cmd off!\n";
          __int16 v11 = buf;
          goto LABEL_29;
        }
        goto LABEL_31;
      }
LABEL_30:
      int v8 = 0;
      goto LABEL_31;
    }
LABEL_33:
    uint64_t v13 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v13 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v13;
    }
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::PowerOffExclaveKit(v13, v14, v15, v16, v17, v18, v19, v20);
    }
    return 0;
  }
  char v41 = 0;
  uint64_t v6 = *((void *)this + 23);
  if (v6) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = 3758097084;
  }
  if (!v6)
  {
    uint64_t v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v22 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v22;
    }
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::PowerOffExclaveKit(v22, v23, v24, v25, v26, v27, v28, v29);
    }
    goto LABEL_30;
  }
  kdebug_trace();
  int v8 = isprgbexclavekitmodule_isprgbexclavekit_sendcmdoff();
  kdebug_trace();
  if (v8)
  {
    uint64_t v30 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v30 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v30;
    }
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::PowerOffExclaveKit();
    }
    goto LABEL_31;
  }
  if (!byte_26B11BF60) {
    goto LABEL_30;
  }
  uint64_t v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    uint64_t v9 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v9;
  }
  int v8 = 0;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v40 = 0;
    int v10 = "[Exclaves]: Sent RGB cmd off!\n";
    __int16 v11 = (uint8_t *)&v40;
LABEL_29:
    _os_log_impl(&dword_24680F000, v9, OS_LOG_TYPE_DEFAULT, v10, v11, 2u);
    goto LABEL_30;
  }
LABEL_31:
  if (!v8) {
    return v7;
  }
  return v3;
}

uint64_t H16ISP::H16ISPDevice::ISP_RegisterEPipeDoneCallback(uint64_t a1, _DWORD *inputStruct)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t result = 3758097084;
  mach_port_t v4 = *(_DWORD *)(a1 + 4424);
  if (v4)
  {
    if (inputStruct)
    {
      long long v6 = 0u;
      return IOConnectCallAsyncMethod(v4, 0x59u, inputStruct[6], &reference, 8u, 0, 0, inputStruct, 0x20uLL, 0, 0, 0, 0);
    }
    else
    {
      return 3758097090;
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_UnregisterEPipeDoneCallback(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v6[1] = *MEMORY[0x263EF8340];
  uint64_t v3 = 3758097090;
  mach_port_t v4 = *((_DWORD *)this + 1106);
  if (!v4) {
    return 3758097084;
  }
  if (*((_DWORD *)this + 1187) <= a2)
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    if (os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ISP_UnregisterEPipeDoneCallback();
    }
  }
  else
  {
    v6[0] = a2;
    return IOConnectCallScalarMethod(v4, 0x5Au, v6, 1u, 0, 0);
  }
  return v3;
}

uint64_t H16ISP::H16ISPDevice::GetExclaveCameraConfig(uint64_t a1, unsigned int a2, unsigned int a3, void *__dst)
{
  uint64_t v4 = 3758097090;
  if (*(unsigned char *)(a1 + 4))
  {
    if (*(_DWORD *)(a1 + 4748) > a2)
    {
      uint64_t v5 = *(void *)(a1 + 40);
      if (*(_DWORD *)(v5 + 432 * a2) > a3)
      {
        memmove(__dst, (const void *)(*(void *)(v5 + 432 * a2 + 16) + 60 * a3), 0x3CuLL);
        return 0;
      }
    }
  }
  else
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog == &_os_log_internal) {
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_deviceLog = (uint64_t)os_log_create("com.apple.isp", "device");
    }
    BOOL v6 = os_log_type_enabled(&_os_log_internal, OS_LOG_TYPE_ERROR);
    uint64_t v4 = 3758097112;
    if (v6) {
      H16ISP::H16ISPDevice::GetExclaveCameraConfig(v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::ReadPropertyValueExclave(H16ISP::H16ISPDevice *this, unsigned int a2, int a3, unsigned int *a4)
{
  uint64_t v57 = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  *a4 = 0;
  if (!*((_DWORD *)this + 1106)) {
    return v4;
  }
  if (*((_DWORD *)this + 1187) <= a2)
  {
    uint64_t v20 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v20 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v20;
    }
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ReadPropertyValueExclave();
    }
    return v4;
  }
  if (a2 > 5) {
    return 0;
  }
  uint64_t v5 = *((void *)this + 548);
  if (!*(_DWORD *)(v5 + 96 * a2 + 8)) {
    return 0;
  }
  int v7 = *(_DWORD *)(v5 + 96 * a2 + 16);
  if (v7 != 1718776695 && v7 != 1718775412)
  {
    if (v7 == 1718186595)
    {
      uint64_t v21 = *((void *)this + 17);
      if (v21)
      {
        unsigned int v51 = a2;
        int v52 = a3;
        kdebug_trace();
        int v22 = ispirexclavekitmodule_ispirexclavekit_sendcmdexclavechpropertyread(v21, (uint64_t)&v51);
        kdebug_trace();
        if (byte_26B11BF60)
        {
          uint64_t v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            uint64_t v23 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v23;
          }
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 67109376;
            unsigned int v54 = v51;
            __int16 v55 = 1024;
            int v56 = v52;
            _os_log_impl(&dword_24680F000, v23, OS_LOG_TYPE_INFO, "IR property read: channel=%u, property=%u\n", buf, 0xEu);
          }
        }
        if (v22)
        {
          uint64_t v24 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            uint64_t v24 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v24;
          }
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
            H16ISP::H16ISPDevice::ReadPropertyValueExclave(v24, v25, v26, v27, v28, v29, v30, v31);
          }
LABEL_37:
          unsigned int v32 = -559038737;
LABEL_45:
          *a4 = v32;
          return v4;
        }
        goto LABEL_44;
      }
      __int16 v42 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        __int16 v42 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v42;
      }
      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::ReadPropertyValueExclave(v42, v43, v44, v45, v46, v47, v48, v49);
      }
      return v4;
    }
    return 0;
  }
  uint64_t v9 = *((void *)this + 23);
  if (v9)
  {
    unsigned int v51 = a2;
    int v52 = a3;
    kdebug_trace();
    int v10 = isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavechpropertyread(v9, (uint64_t)&v51);
    kdebug_trace();
    if (byte_26B11BF60)
    {
      uint64_t v11 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        uint64_t v11 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v11;
      }
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 67109376;
        unsigned int v54 = v51;
        __int16 v55 = 1024;
        int v56 = v52;
        _os_log_impl(&dword_24680F000, v11, OS_LOG_TYPE_INFO, "RGB property read: channel=%u, property=%u\n", buf, 0xEu);
      }
    }
    if (v10)
    {
      uint64_t v12 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        uint64_t v12 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v12;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::ReadPropertyValueExclave(v12, v13, v14, v15, v16, v17, v18, v19);
      }
      goto LABEL_37;
    }
LABEL_44:
    uint64_t v4 = 0;
    unsigned int v32 = v50;
    goto LABEL_45;
  }
  uint64_t v34 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    uint64_t v34 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v34;
  }
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
    H16ISP::H16ISPDevice::ReadPropertyValueExclave(v34, v35, v36, v37, v38, v39, v40, v41);
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::WritePropertyValueExclave(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3, unsigned int a4)
{
  uint64_t v58 = *MEMORY[0x263EF8340];
  uint64_t v4 = 3758097084;
  if (!*((_DWORD *)this + 1106)) {
    return v4;
  }
  if (*((_DWORD *)this + 1187) <= a2)
  {
    uint64_t v19 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v19 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v19;
    }
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::WritePropertyValueExclave();
    }
  }
  else
  {
    if (a2 > 5) {
      return 0;
    }
    uint64_t v5 = *((void *)this + 548);
    if (!*(_DWORD *)(v5 + 96 * a2 + 8)) {
      return 0;
    }
    int v6 = *(_DWORD *)(v5 + 96 * a2 + 16);
    if (v6 == 1718776695 || v6 == 1718775412)
    {
      char v51 = 0;
      uint64_t v8 = *((void *)this + 23);
      if (v8)
      {
        unsigned int v48 = a2;
        unsigned int v49 = a3;
        unsigned int v50 = a4;
        kdebug_trace();
        int v9 = isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavechpropertywrite(v8, (uint64_t)&v48);
        kdebug_trace();
        if (byte_26B11BF60)
        {
          int v10 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            int v10 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v10;
          }
          if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 67109632;
            unsigned int v53 = v48;
            __int16 v54 = 1024;
            unsigned int v55 = v49;
            __int16 v56 = 1024;
            unsigned int v57 = v50;
            _os_log_impl(&dword_24680F000, v10, OS_LOG_TYPE_INFO, "RGB property write: channel=%u, property=%u, value=%u\n", buf, 0x14u);
          }
        }
        if (!v9) {
          return 0;
        }
        uint64_t v11 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          uint64_t v11 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v11;
        }
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::WritePropertyValueExclave(v11, v12, v13, v14, v15, v16, v17, v18);
        }
      }
      else
      {
        unsigned int v32 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
        {
          unsigned int v32 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v32;
        }
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPDevice::WritePropertyValueExclave(v32, v33, v34, v35, v36, v37, v38, v39);
        }
      }
    }
    else
    {
      if (v6 != 1718186595) {
        return 0;
      }
      char v51 = 0;
      uint64_t v20 = *((void *)this + 17);
      if (v20)
      {
        unsigned int v48 = a2;
        unsigned int v49 = a3;
        unsigned int v50 = a4;
        kdebug_trace();
        int v21 = ispirexclavekitmodule_ispirexclavekit_sendcmdexclavechpropertywrite(v20, (uint64_t)&v48);
        kdebug_trace();
        if (byte_26B11BF60)
        {
          int v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            int v22 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v22;
          }
          if (os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 67109376;
            unsigned int v53 = v49;
            __int16 v54 = 1024;
            unsigned int v55 = v50;
            _os_log_impl(&dword_24680F000, v22, OS_LOG_TYPE_INFO, "[Exclaves]: IR property write: property=%u, value=%u\n", buf, 0xEu);
          }
        }
        if (v21)
        {
          uint64_t v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
          {
            uint64_t v23 = os_log_create("com.apple.isp", "exclaves");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v23;
          }
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
            H16ISP::H16ISPDevice::WritePropertyValueExclave(v23, v24, v25, v26, v27, v28, v29, v30);
          }
          return v4;
        }
        return 0;
      }
      uint64_t v40 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
      {
        uint64_t v40 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v40;
      }
      if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR)) {
        H16ISP::H16ISPDevice::WritePropertyValueExclave(v40, v41, v42, v43, v44, v45, v46, v47);
      }
    }
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::SetExclaveAEConfig(H16ISP::H16ISPDevice *a1, int a2, long long *a3)
{
  long long v3 = a3[1];
  long long v7 = *a3;
  *(void *)uint64_t v5 = 0x900400000000;
  int v6 = a2;
  long long v8 = v3;
  *(_OWORD *)int v9 = a3[2];
  *(_OWORD *)&v9[12] = *(long long *)((char *)a3 + 44);
  return H16ISP::H16ISPDevice::ISP_SendCommand(a1, v5, 0x48u, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPDevice::ISP_IsSafeToStartConclave(H16ISP::H16ISPDevice *this, BOOL *a2)
{
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097111;
  }
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  uint64_t v4 = IOConnectCallScalarMethod(v2, 0x5Du, 0, 0, &output, &outputCnt);
  if (v4)
  {
    uint64_t v5 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      uint64_t v5 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v5;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ISP_IsSafeToStartConclave();
    }
  }
  else
  {
    *a2 = output != 0;
  }
  return v4;
}

uint64_t H16ISP::H16ISPDevice::ISP_GetPDPConfig(uint64_t a1, unsigned int a2, void *a3)
{
  input[1] = *MEMORY[0x263EF8340];
  outputStruct = 0;
  size_t v9 = -3;
  mach_port_t v3 = *(_DWORD *)(a1 + 4424);
  if (!v3) {
    return 3758097111;
  }
  input[0] = a2;
  uint64_t v5 = IOConnectCallMethod(v3, 0x5Eu, input, 1u, 0, 0, 0, 0, &outputStruct, &v9);
  if (v5)
  {
    long long v7 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      long long v7 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v7;
    }
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      H16ISP::H16ISPDevice::ISP_GetPDPConfig();
    }
  }
  else
  {
    memcpy(a3, outputStruct, v9);
  }
  return v5;
}

uint64_t H16ISP::H16ISPDevice::SetExclaveTargetFrameRate(H16ISP::H16ISPDevice *this, int a2, float a3)
{
  uint64_t v4 = 0x900600000000;
  int v5 = a2;
  unsigned int v6 = vcvts_n_u32_f32(a3, 8uLL);
  return H16ISP::H16ISPDevice::ISP_SendCommand(this, (unsigned __int8 *)&v4, 0x10u, 0, 0xFFFFFFFF);
}

float H16ISP::H16ISPDevice::ISP_GetOpticalfNumber(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  float result = -1.0;
  if (*((unsigned char *)this + 4))
  {
    if (*((_DWORD *)this + 1187) > a2) {
      return *(float *)(*((void *)this + 6) + 156 * a2 + 140);
    }
  }
  return result;
}

float H16ISP::H16ISPDevice::ISP_GetOpticalEffectiveFocalLength(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  float result = -1.0;
  if (*((unsigned char *)this + 4))
  {
    if (*((_DWORD *)this + 1187) > a2) {
      return *(float *)(*((void *)this + 6) + 156 * a2 + 144);
    }
  }
  return result;
}

float H16ISP::H16ISPDevice::ISP_GetOpticalManualParamsFoV(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  float result = -1.0;
  if (*((unsigned char *)this + 4))
  {
    if (*((_DWORD *)this + 1187) > a2) {
      return *(float *)(*((void *)this + 6) + 156 * a2 + 152);
    }
  }
  return result;
}

uint64_t H16ISP::H16ISPDevice::ISP_UnloadDataFile(H16ISP::H16ISPDevice *this, unsigned int a2, unsigned int a3)
{
  uint64_t input[2] = *MEMORY[0x263EF8340];
  mach_port_t v5 = *((_DWORD *)this + 1106);
  if (v5)
  {
    input[0] = a2;
    input[1] = a3;
    uint64_t v6 = IOConnectCallScalarMethod(v5, 0x67u, input, 2u, 0, 0);
  }
  else
  {
    uint64_t v6 = 3758097084;
  }
  printf("Unload data file: channel: %d, type: %d, status: 0x%08X\n", a2, a3, v6);
  return v6;
}

uint64_t H16ISP::H16ISPDevice::ISP_SavagePrePersonalize(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_SavagePreFusing(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 1u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_YonkersPrePersonalize(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x3Fu, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_YonkersPreFusing(H16ISP::H16ISPDevice *this, unsigned int a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097084;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x40u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetStrobeState(H16ISP::H16ISPDevice *this, uint64_t a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097111;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x60u, v4, 1u, 0, 0);
}

uint64_t H16ISP::H16ISPDevice::ISP_SetLidarState(H16ISP::H16ISPDevice *this, uint64_t a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  mach_port_t v2 = *((_DWORD *)this + 1106);
  if (!v2) {
    return 3758097111;
  }
  v4[0] = a2;
  return IOConnectCallScalarMethod(v2, 0x61u, v4, 1u, 0, 0);
}

void OUTLINED_FUNCTION_3_4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

unsigned char *OUTLINED_FUNCTION_4_3(unsigned char *result, unsigned char *a2)
{
  *float result = 0;
  *a2 = 0;
  return result;
}

void OUTLINED_FUNCTION_9_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 8u);
}

void OUTLINED_FUNCTION_14_0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0x18u);
}

double linearInterpolate(double *a1, double *a2, double a3)
{
  return ((*a2 - a3) * a1[1] + (a3 - *a1) * a2[1]) / (a3 - *a1 + *a2 - a3);
}

double bilinearInterpolate(double *a1, double *a2, double a3, double a4)
{
  double v4 = a3 - *a2;
  double v5 = a2[2] - a3;
  return ((v5 * a1[1] + v4 * a1[3]) / (v4 + v5) * (a2[3] - a4) + (a4 - a2[1]) * ((v5 * *a1 + v4 * a1[2]) / (v4 + v5)))
       / (a4 - a2[1] + a2[3] - a4);
}

double InitCubicPoly(double *a1, double a2, double a3, double a4, double a5)
{
  *a1 = a2;
  a1[1] = a4;
  double v5 = a3 * 3.0 + a2 * -3.0 + a4 * -2.0 - a5;
  double result = a3 * -2.0 + a2 * 2.0 + a4 + a5;
  a1[2] = v5;
  a1[3] = result;
  return result;
}

double InitNonuniformCatmullRom(double *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v8 = (a3 - a2) / a6 - (a4 - a2) / (a6 + a7);
  double v9 = (a4 - a3) / a7;
  *(float *)&double v8 = v9 + v8;
  float v10 = (a5 - a4) / a8 + v9 - (a5 - a3) / (a7 + a8);
  *(float *)&double v8 = *(float *)&v8 * a7;
  float v11 = v10 * a7;
  double v12 = *(float *)&v8;
  double v13 = v11;
  *a1 = a3;
  a1[1] = v12;
  double v14 = a4 * 3.0 + a3 * -3.0 + v12 * -2.0 - v13;
  double result = a4 * -2.0 + a3 * 2.0 + v12 + v13;
  a1[2] = v14;
  a1[3] = result;
  return result;
}

double cubicInterpolateNonuniform(double *a1, double *a2, double a3)
{
  InitNonuniformCatmullRom(v5, *a1, a1[1], a1[2], a1[3], a2[1] - *a2, a2[2] - a2[1], a2[3] - a2[2]);
  return v5[0] + a3 * (v5[1] + a3 * (v5[2] + v5[3] * a3));
}

void bicubicInterpolateNonuniform(double (*a1)[4], double *a2, double *a3, double a4, double a5)
{
  unsigned __int8 v10[4] = *(double *)MEMORY[0x263EF8340];
  v10[0] = cubicInterpolateNonuniform((double *)a1, a3, a5);
  v10[1] = cubicInterpolateNonuniform(&(*a1)[4], a3, a5);
  void v10[2] = cubicInterpolateNonuniform(&(*a1)[8], a3, a5);
  void v10[3] = cubicInterpolateNonuniform(&(*a1)[12], a3, a5);
  cubicInterpolateNonuniform(v10, a2, a4);
}

void ComputeIdealLs(unsigned __int16 *a1, long double *a2, unsigned int a3)
{
  uint64_t v3 = a1[7];
  if (a1[7])
  {
    int v6 = 0;
    double v7 = (double)(*a1 + 1) * 0.5 + (double)(__int16)a1[8];
    uint64_t v8 = a1[6];
    double v9 = (double)(a1[1] + 1) * 0.5 + (double)(__int16)a1[9];
    double v10 = 0.0;
    do
    {
      if (a1[6])
      {
        unsigned int v11 = a1[4];
        double v12 = (double)(a1[5] + v6 * a1[3]) - v9;
        double v13 = v12 * v12;
        int v14 = a1[6];
        do
        {
          double v15 = sqrt(((double)v11 - v7) * ((double)v11 - v7) + v13);
          if (v15 > v10) {
            double v10 = v15;
          }
          v11 += a1[2];
          --v14;
        }
        while (v14);
      }
      ++v6;
    }
    while (v6 != v3);
    long double v16 = pow((double)a3 / 100.0, 0.25);
    uint64_t v17 = 0;
    do
    {
      if (v8)
      {
        unsigned int v18 = a1[4];
        int v19 = a1[2];
        unsigned int v20 = a1[5] + v17 * a1[3];
        double v21 = ((double)v20 - v9) * ((double)v20 - v9);
        long double v22 = acos(v16);
        uint64_t v23 = v8;
        uint64_t v24 = a2;
        double v25 = v10 / tan(v22);
        do
        {
          long double v26 = atan(sqrt(((double)v18 - v7) * ((double)v18 - v7) + v21) / v25);
          long double v27 = cos(v26);
          *v24++ = pow(v27, 4.0);
          v18 += v19;
          --v23;
        }
        while (v23);
      }
      ++v17;
      a2 += v8;
    }
    while (v17 != v3);
  }
}

uint64_t FTCInterpolateNvm(uint64_t result, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  unsigned int v15 = a3[7];
  if (!a3[7]) {
    return result;
  }
  unsigned int v16 = 0;
  int v17 = a3[3];
  int v18 = a3[2];
  int v19 = a3[5];
  int v20 = a3[4];
  unsigned int v21 = a3[6];
  do
  {
    if (!v21) {
      goto LABEL_33;
    }
    unsigned int v22 = 0;
    double v23 = (double)(v19 + v16 * v17);
    do
    {
      double v24 = (double)(v20 + v22 * v18);
      uint64_t v25 = a4[20];
      if (a4[20])
      {
        uint64_t v26 = 0;
        LOWORD(a12) = *a4;
        *(float *)&a12 = (float)LODWORD(a12);
        while (v24 >= (float)(*(float *)&a4[2 * v26 + 28] * *(float *)&a12))
        {
          if (v25 == ++v26)
          {
            int v27 = a4[20];
            goto LABEL_12;
          }
        }
        int v27 = (unsigned __int16)v26;
      }
      else
      {
        int v27 = 0;
      }
LABEL_12:
      double v28 = (double)(v27 - 1);
      uint64_t v29 = a4[21];
      LOWORD(a12) = a4[1];
      *(float *)&a12 = (float)LODWORD(a12);
      if (a4[21])
      {
        uint64_t v30 = 0;
        while (v23 >= (float)(*(float *)&a4[2 * v30 + 170] * *(float *)&a12))
        {
          if (v29 == ++v30)
          {
            LOWORD(v30) = a4[21];
            break;
          }
        }
        if (!v27) {
          double v28 = 0.0;
        }
        if ((_WORD)v30)
        {
          double v31 = (double)((unsigned __int16)v30 - 1);
          goto LABEL_24;
        }
      }
      else if (!v27)
      {
        double v28 = 0.0;
      }
      double v31 = 0.0;
LABEL_24:
      if (v28 >= (double)((int)v25 - 2)) {
        double v28 = (double)((int)v25 - 2);
      }
      if (v31 >= (double)((int)v29 - 2)) {
        double v31 = (double)((int)v29 - 2);
      }
      unsigned int v32 = vcvtmd_u64_f64(v28);
      unsigned int v33 = vcvtmd_u64_f64(v31);
      unsigned int v34 = v32 + v33 * v25;
      LOBYTE(v28) = *(unsigned char *)(a2 + v34);
      LOBYTE(v12) = *(unsigned char *)(a2 + v34 + 1);
      double v12 = ((double)*(unint64_t *)&v12 + -128.0) * 0.125 * 0.0078125 + 1.0;
      unsigned int v35 = v32 + (v33 + 1) * v25;
      LOBYTE(v13) = *(unsigned char *)(a2 + v35);
      LOBYTE(v14) = *(unsigned char *)(a2 + v35 + 1);
      double v36 = ((double)*(unint64_t *)&v14 + -128.0) * 0.125 * 0.0078125 + 1.0;
      float v37 = (float)*a4;
      float v38 = roundf(*(float *)&a4[2 * v32 + 28] * v37);
      double v39 = roundf(*(float *)&a4[2 * v33 + 170] * *(float *)&a12);
      double v14 = roundf(*(float *)&a4[2 * v32 + 30] * v37);
      float v40 = roundf(*(float *)&a4[2 * v33 + 172] * *(float *)&a12);
      double v41 = v24 - v38;
      double v42 = v14 - v24;
      double v43 = (((double)*(unint64_t *)&v13 + -128.0) * 0.125 * 0.0078125 + 1.0) * v42 + v41 * v36;
      double v13 = v41 + v42;
      double v44 = fmin(((v40 - v23)* (((((double)*(unint64_t *)&v28 + -128.0) * 0.125 * 0.0078125 + 1.0) * v42 + v41 * v12)/ (v41 + v42))+ (v23 - v39) * (v43 / (v41 + v42)))/ (v23 - v39 + v40 - v23), 2.0);
      a12 = v44 * 4096.0;
      if (v44 <= 0.0) {
        double v45 = 0.0;
      }
      else {
        double v45 = v44 * 4096.0;
      }
      *(_WORD *)(result + 2 * (v22 + v21 * v16)) = llround(fmin(v45, 65535.0));
      ++v22;
      unsigned int v21 = a3[6];
    }
    while (v22 < v21);
    unsigned int v15 = a3[7];
LABEL_33:
    ++v16;
  }
  while (v16 < v15);
  return result;
}

uint64_t LSCComputeGain(uint64_t result, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, unsigned int a7, int a8)
{
  unsigned int v8 = *(unsigned __int16 *)(a5 + 14);
  if (*(_WORD *)(a5 + 14))
  {
    unsigned __int16 v9 = 0;
    unsigned int v10 = 0;
    unsigned int v11 = *(unsigned __int16 *)(a5 + 12);
    do
    {
      if (v11)
      {
        for (unsigned int i = 0; i < v11; ++i)
        {
          uint64_t v13 = i + v10 * v11;
          int v14 = 1 << a6;
          if (a8 != 2) {
            LOWORD(v14) = llround(fmin(*(double *)(a3 + 8 * v13) / *(double *)(a4 + 8 * v13) * (double)(1 << a6), (double)a7));
          }
          *(_WORD *)(result + 2 * v13) = v14;
          if ((unsigned __int16)v14 > v9) {
            unsigned __int16 v9 = v14;
          }
          unsigned int v11 = *(unsigned __int16 *)(a5 + 12);
        }
        unsigned int v8 = *(unsigned __int16 *)(a5 + 14);
      }
      ++v10;
    }
    while (v10 < v8);
  }
  else
  {
    unsigned __int16 v9 = 0;
  }
  *a2 = v9;
  return result;
}

uint64_t ApplyFTCGain(uint64_t result, unsigned __int16 *a2, uint64_t a3, uint64_t a4, double a5, double a6)
{
  unsigned int v6 = *(unsigned __int16 *)(a4 + 14);
  if (*(_WORD *)(a4 + 14))
  {
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    unsigned __int16 v9 = 0;
    unsigned int v10 = *(unsigned __int16 *)(a4 + 12);
    do
    {
      if (v10)
      {
        uint64_t v11 = 0;
        do
        {
          uint64_t v12 = v11 + v7 * v10;
          LOWORD(a6) = *(_WORD *)(result + 2 * v12);
          HIWORD(v13) = 17792;
          LOWORD(v13) = *(_WORD *)(a3 + 2 * v12);
          a6 = fmin((float)((float)((float)LODWORD(a6) * 4096.0) / (float)v13), 65535.0);
          unsigned int v14 = llround(a6);
          *(_WORD *)(result + 2 * v12) = v14;
          if (v9 <= v14) {
            unsigned __int16 v9 = v14;
          }
          unsigned int v10 = *(unsigned __int16 *)(a4 + 12);
          ++v11;
        }
        while (v11 < v10);
        unsigned int v6 = *(unsigned __int16 *)(a4 + 14);
      }
      ++v8;
      ++v7;
    }
    while (v8 < v6);
  }
  else
  {
    unsigned __int16 v9 = 0;
  }
  *a2 = v9;
  return result;
}

uint64_t CICComputeGain(uint64_t result, unsigned __int16 *a2, uint64_t a3, uint64_t a4, char a5)
{
  unsigned int v5 = *(unsigned __int16 *)(a4 + 14);
  if (*(_WORD *)(a4 + 14))
  {
    uint64_t v6 = 0;
    unsigned __int16 v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = *(unsigned __int16 *)(a4 + 12);
    do
    {
      if (v9)
      {
        uint64_t v10 = 0;
        do
        {
          uint64_t v11 = v10 + v6 * v9;
          unsigned int v12 = llround(fmin(1.0 / *(double *)(a3 + 8 * v11) * (double)(1 << a5), 65535.0));
          *(_WORD *)(result + 2 * v11) = v12;
          if (v7 <= v12) {
            unsigned __int16 v7 = v12;
          }
          unsigned int v9 = *(unsigned __int16 *)(a4 + 12);
          ++v10;
        }
        while (v10 < v9);
        unsigned int v5 = *(unsigned __int16 *)(a4 + 14);
      }
      ++v8;
      ++v6;
    }
    while (v8 < v5);
  }
  else
  {
    unsigned __int16 v7 = 0;
  }
  *a2 = v7;
  return result;
}

_WORD *flip(_WORD *result, int a2, int a3)
{
  int64_t v3 = ((unint64_t)(a2 * a3) << 32) - 0x100000000;
  if (v3 >= 1)
  {
    unint64_t v4 = (unint64_t)&result[HIDWORD(v3) - 1];
    do
    {
      __int16 v5 = *(_WORD *)(v4 + 2);
      *(_WORD *)(v4 + 2) = *result;
      *result++ = v5;
      BOOL v6 = v4 > (unint64_t)result;
      v4 -= 2;
    }
    while (v6);
  }
  return result;
}

uint64_t FTCComputeFromNVMApple(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, unsigned __int16 *a7, unsigned __int16 *a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, uint64_t a17)
{
  v65[4] = *MEMORY[0x263EF8340];
  if (a3)
  {
    int v21 = 0;
    do
    {
      v61[v21] = *(_DWORD *)(a5 + 4 * v21);
      ++v21;
    }
    while (a3 > v21);
  }
  if (a4)
  {
    int v22 = 0;
    do
    {
      v61[v22 + 71] = *(_DWORD *)(a6 + 4 * v22);
      ++v22;
    }
    while (a4 > v22);
  }
  unsigned int v23 = a3 - 1;
  int64x2_t v55 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  int v24 = a4 - 1;
  v65[0] = a1 + 18;
  v65[1] = a1 + 36;
  v65[2] = a1 + 54;
  v65[3] = a1 + 72;
  v54[0] = *(_WORD *)(a1 + 14) >> 1;
  int v25 = *(unsigned __int16 *)(a1 + 16) >> 1;
  v54[1] = *(_WORD *)(a1 + 16) >> 1;
  __int16 v58 = a3;
  __int16 v59 = a4;
  double v56 = 0.98 / (double)(int)(a3 - 1);
  double v57 = 0.98 / (double)(int)(a4 - 1);
  uint64_t v60 = 0x406F400000000000;
  v62[0] = v54[0];
  v62[1] = v25;
  int v63 = *(_DWORD *)(a1 + 20);
  LODWORD(v64) = *(_DWORD *)(a1 + 28);
  uint64_t v26 = *(unsigned __int16 *)(a1 + 32);
  HIDWORD(v64) = *(_DWORD *)(a1 + 32);
  uint64_t v27 = HIWORD(v64);
  FTCInterpolateNvm(a17, a2, v62, v54, 0.98 / (double)v24, v56, (double)v24, a12, a13, a14, a15, a16);
  if (v27)
  {
    unint64_t v29 = 0;
    uint64_t v30 = a4 >> 1;
    uint64_t v31 = a17;
    do
    {
      if (v26)
      {
        for (uint64_t i = 0; i != v26; ++i)
        {
          if (i < *a7 - 1 || i >= (unint64_t)a7[v23] || v29 > a8[v30 - 1] && v29 < a8[v30]) {
            *(_WORD *)(v31 + 2 * i) = 4096;
          }
        }
      }
      ++v29;
      v31 += 2 * v26;
    }
    while (v29 != v27);
  }
  unint64_t v33 = *a8;
  int v34 = v33 - 1;
  if (v33 > 1)
  {
    int64_t v35 = v33 - 2;
    double v36 = (_WORD *)(a17 + 2 * (int)v35 * (uint64_t)(int)v26);
    float v37 = (__int16 *)(a17 + 2 * v34 * (uint64_t)(int)v26);
    do
    {
      uint64_t v38 = v26;
      double v39 = v37;
      float v40 = v36;
      if (v26)
      {
        do
        {
          __int16 v41 = *v39++;
          *v40++ = v41;
          --v38;
        }
        while (v38);
      }
      v36 -= v26;
      v37 -= v26;
    }
    while (v35-- > 0);
  }
  uint64_t v43 = a8[v24];
  if (v43 < a4)
  {
    unint64_t v44 = a8[v24] * (unint64_t)v26;
    double v45 = (__int16 *)(a17 + 2 * ((int)v43 - 1) * (uint64_t)(int)v26);
    do
    {
      uint64_t v46 = v26;
      uint64_t v47 = v45;
      unint64_t v48 = v44;
      if (v26)
      {
        do
        {
          __int16 v49 = *v47++;
          *(_WORD *)(a17 + 2 * v48++) = v49;
          --v46;
        }
        while (v46);
      }
      ++v43;
      v44 += v26;
      v45 += v26;
    }
    while (v43 != a4);
  }
  uint64_t v50 = 0;
  uint64_t v51 = a1 + 92;
  do
  {
    uint64_t v52 = v65[v50];
    int v63 = *(_DWORD *)(v52 + 2);
    double v64 = *(double *)(v52 + 10);
    uint64_t result = ApplyFTCGain(v51 + 2 * *(unsigned __int16 *)(v52 + 6), (unsigned __int16 *)v52, a17, (uint64_t)v62, v64, v28);
    ++v50;
  }
  while (v50 != 4);
  return result;
}

uint64_t LSCFlipApple(uint64_t result)
{
  uint64_t v1 = 0;
  unsigned __int8 v9[4] = *MEMORY[0x263EF8340];
  v9[0] = result + 18;
  v9[1] = result + 36;
  v9[2] = result + 54;
  v9[3] = result + 72;
  do
  {
    mach_port_t v2 = (unsigned __int16 *)v9[v1];
    int64_t v3 = ((unint64_t)(v2[7] * v2[8]) << 32) - 0x100000000;
    if (v3 >= 1)
    {
      uint64_t v4 = v2[3];
      __int16 v5 = (_WORD *)(result + 92 + 2 * v4);
      unint64_t v6 = result + 90 + (((unint64_t)v3 >> 31) & 0x1FFFFFFFELL) + 2 * v4;
      do
      {
        __int16 v7 = *(_WORD *)(v6 + 2);
        *(_WORD *)(v6 + 2) = *v5;
        *v5++ = v7;
        BOOL v8 = v6 > (unint64_t)v5;
        v6 -= 2;
      }
      while (v8);
    }
    ++v1;
  }
  while (v1 != 4);
  return result;
}

void ALS2RotateApple()
{
}

unint64_t LSCFlipPerModule(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = a1[1] * *a1;
  uint64_t v5 = (v4 - 1);
  uint64_t v6 = a2 + v5;
  __int16 v7 = a1 + 264;
  BOOL v8 = &a1[v5 + 264];
  do
  {
    unsigned int v9 = v7;
    uint64_t v10 = v8;
    uint64_t v11 = a2;
    uint64_t v12 = v6;
    do
    {
      *(unsigned char *)(v11 + v2) = v10[v2];
      unint64_t result = v11 + v2 + 1;
      *(unsigned char *)(v12 + v2) = v9[v2];
      --v12;
      ++v11;
      --v10;
      ++v9;
    }
    while (v12 + v2 >= result);
    ++v3;
    v2 += v4;
  }
  while (v3 != 4);
  return result;
}

_WORD *averageGreen(_WORD *result, unsigned __int16 *a2, int a3, int a4)
{
  if (a4 * a3)
  {
    int v4 = 0;
    do
    {
      unsigned int v5 = (*a2 + (unsigned __int16)*result) >> 1;
      *result++ = v5;
      *a2++ = v5;
      ++v4;
    }
    while (a4 * a3 > (unsigned __int16)v4);
  }
  return result;
}

unsigned __int16 *LSCAverageGreenApple(unsigned __int16 *result)
{
  int v1 = result[16];
  if (v1 != result[43]) {
    LSCAverageGreenApple();
  }
  int v2 = result[17];
  if (v2 != result[44]) {
    LSCAverageGreenApple();
  }
  unsigned int v3 = v2 * v1;
  if (v3)
  {
    int v4 = 0;
    unsigned int v5 = &result[result[39] + 46];
    uint64_t v6 = &result[result[12] + 46];
    do
    {
      unsigned int v7 = (*v5 + *v6) >> 1;
      *v6++ = v7;
      *v5++ = v7;
      ++v4;
    }
    while (v3 > (unsigned __int16)v4);
  }
  return result;
}

unint64_t LSCComputeSNFRadialGains(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v8 = 0;
  v88[4] = *MEMORY[0x263EF8340];
  unsigned int v9 = *(unsigned __int16 *)(a3 + 14);
  unsigned int v10 = *(unsigned __int16 *)(a3 + 16);
  v88[0] = a3 + 18;
  v88[1] = a3 + 36;
  v88[2] = a3 + 54;
  v88[3] = a3 + 72;
  memset(v87, 0, 32);
  do
  {
    v87[v8] = a3 + 92 + 2 * *(unsigned __int16 *)(v88[v8] + 6);
    ++v8;
  }
  while (v8 != 4);
  uint64_t v11 = 0;
  float v12 = (double)v9 * 0.5;
  float v13 = (double)v10 * 0.5;
  v86[0] = 0;
  v86[1] = v9;
  float v14 = (float)a5 + v12;
  float v15 = (float)a6 + v13;
  v86[2] = 0;
  v86[3] = v9;
  uint64_t v83 = 0;
  unsigned int v84 = v10;
  unsigned int v85 = v10;
  v82[0] = 0;
  v82[1] = 0;
  float v16 = 0.0;
  do
  {
    double v17 = (float)(v14 - (float)(int)v86[v11]);
    double v18 = (float)(v15 - (float)*(int *)((char *)&v83 + v11 * 4));
    float v19 = sqrt(v17 * v17 + v18 * v18);
    *(float *)((char *)v82 + v11 * 4) = v19;
    if (v16 < v19) {
      float v16 = v19;
    }
    ++v11;
  }
  while (v11 != 4);
  bzero(v81, 0x808uLL);
  bzero(v80, 0x404uLL);
  float v20 = log2f(v16 * 0.0039062);
  uint64_t v24 = 0;
  unsigned int v25 = vcvtps_s32_f32(v20);
  *(_WORD *)(a1 + 12) = v25;
  int v26 = v25 * v25;
  int v27 = v26 << 8;
  do
  {
    uint64_t v28 = 0;
    unint64_t result = v88[v24];
    unsigned int v30 = *(unsigned __int16 *)(result + 2);
    unsigned int v31 = *(unsigned __int16 *)(result + 4);
    double v32 = (double)v31;
    do
    {
      unsigned int v33 = 0;
      uint64_t v34 = 0;
      float v35 = (float)(int)v86[v28] - v14;
      float v36 = *((float *)v82 + v28);
      float v37 = (float)*((int *)&v83 + v28) - v15;
      do
      {
        if ((float)((float)v33 * 0.0039062) >= v16) {
          float v38 = v16;
        }
        else {
          float v38 = (float)v33 * 0.0039062;
        }
        double v39 = (float)(v14 + (float)((float)(v38 * v35) / v36)) * 0.5;
        unsigned int v40 = (int)(v39 / (double)v30);
        if ((v40 & 0x80000000) != 0) {
          break;
        }
        double v41 = (float)(v15 + (float)((float)(v38 * v37) / v36)) * 0.5;
        double v42 = v41 / v32;
        int v43 = (int)(v41 / v32);
        if (v43 < 0) {
          break;
        }
        int v44 = *(unsigned __int16 *)(result + 14);
        if (v44 - 2 < (int)v40) {
          break;
        }
        if (*(unsigned __int16 *)(result + 16) - 2 < v43) {
          break;
        }
        uint64_t v45 = v87[v24];
        uint64_t v46 = (_WORD *)(v45 + 2 * v44 * v43 + 2 * v40);
        LOWORD(v42) = *v46;
        LOWORD(v21) = v46[1];
        double v21 = (float)((float)LODWORD(v21) * 0.00024414);
        uint64_t v47 = (_WORD *)(v45 + 2 * (v43 + 1) * v44 + 2 * v40);
        LOWORD(v22) = *v47;
        LOWORD(v23) = v47[1];
        double v48 = (float)((float)LODWORD(v23) * 0.00024414);
        int v49 = v40 * v30;
        double v23 = v39 - (double)v49;
        double v50 = (double)(int)(v30 + v49) - v39;
        double v51 = v50 * (float)((float)LODWORD(v22) * 0.00024414) + v23 * v48;
        double v22 = v23 + v50;
        v81[v34] = v81[v34]
                 + (((double)(int)((v43 + 1) * v31) - v41)
                  * ((v50 * (float)((float)LODWORD(v42) * 0.00024414) + v23 * v21)
                   / (v23 + v50))
                  + (v41 - (double)(int)(v43 * v31)) * (v51 / (v23 + v50)))
                 / (v41 - (double)(int)(v43 * v31) + (double)(int)((v43 + 1) * v31) - v41);
        ++v80[v34++];
        v33 += v27;
      }
      while (v34 != 257);
      ++v28;
    }
    while (v28 != 4);
    ++v24;
  }
  while (v24 != 4);
  for (uint64_t i = 0; i != 257; ++i)
  {
    int v53 = v80[i];
    double v54 = v81[i];
    if (v53 >= 1)
    {
      double v32 = (double)v53;
      double v54 = v54 / (double)v53;
      v81[i] = v54;
    }
    *(_WORD *)(a1 + 14 + 2 * i) = vcvtd_n_s64_f64(1.0 / v54, 0xCuLL);
  }
  if (a2)
  {
    uint64_t v55 = 0;
    double v56 = 0.0;
    double v57 = 0.0;
    do
    {
      uint64_t v58 = v88[v55];
      unint64_t v59 = *(unsigned __int16 *)(v58 + 14);
      uint64_t v60 = v87[v55];
      LOWORD(v32) = *(_WORD *)(v60 + 2 * (v59 >> 1));
      double v61 = (float)((float)LODWORD(v32) * 0.00024414);
      double v62 = v57 + v61;
      LODWORD(v58) = *(unsigned __int16 *)(v58 + 16);
      unint64_t result = (v58 - 1);
      LOWORD(v61) = *(_WORD *)(v60 + 2 * ((v59 >> 1) + result * v59));
      double v63 = (float)((float)LODWORD(v61) * 0.00024414);
      double v57 = v62 + v63;
      LODWORD(v58) = (v58 >> 1) * v59;
      LOWORD(v63) = *(_WORD *)(v60 + 2 * v58);
      double v64 = (float)((float)LODWORD(v63) * 0.00024414);
      double v65 = v56 + v64;
      LOWORD(v64) = *(_WORD *)(v60 + 2 * (v59 + v58 - 1));
      double v32 = (float)((float)LODWORD(v64) * 0.00024414);
      double v56 = v65 + v32;
      ++v55;
    }
    while (v55 != 4);
    int v66 = 0;
    uint64_t v67 = 0;
    double v68 = v57 * 0.125;
    double v69 = v56 * 0.125;
    while (v81[v67] <= v69)
    {
      ++v67;
      v66 -= v27;
      if (v67 == 257)
      {
        double v70 = v12;
        goto LABEL_35;
      }
    }
    double v70 = v12;
    if ((v67 - 1) <= 0xFF)
    {
      double v71 = v81[v67];
      double v72 = v81[(v67 - 1)];
      double v73 = 0.5;
      if (vabdd_f64(v71, v72) > 1.0e-10) {
        double v73 = (v69 - v72) / (v71 - v72);
      }
      double v70 = v73 * (float)((float)-v66 * 0.0039062)
          + (1.0 - v73) * (float)((float)-(v66 + (v26 << 8)) * 0.0039062);
    }
LABEL_35:
    int v74 = 0;
    uint64_t v75 = 0;
    while (v81[v75] <= v68)
    {
      ++v75;
      v74 -= v27;
      if (v75 == 257)
      {
        double v76 = v13;
        goto LABEL_43;
      }
    }
    double v76 = v13;
    if ((v75 - 1) <= 0xFF)
    {
      double v77 = v81[v75];
      double v78 = v81[(v75 - 1)];
      double v79 = 0.5;
      if (vabdd_f64(v77, v78) > 1.0e-10) {
        double v79 = (v68 - v78) / (v77 - v78);
      }
      double v76 = v79 * (float)((float)-v74 * 0.0039062)
          + (1.0 - v79) * (float)((float)-(v74 + (v26 << 8)) * 0.0039062);
    }
LABEL_43:
    *(_WORD *)(a2 + 12) = llround(fmin(v70 / v12 * 4096.0 + 0.5, 65535.0));
    *(_WORD *)(a2 + 14) = llround(fmin(v76 / v13 * 4096.0 + 0.5, 65535.0));
  }
  return result;
}

void LSCComputeFromNVMApple<unsigned char>(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7, int a8, int a9, uint64_t a10, uint64_t a11)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  int v11 = *(unsigned __int16 *)(a1 + 14) >> 1;
  __int16 v27 = *(_WORD *)(a1 + 14) >> 1;
  int v12 = *(unsigned __int16 *)(a1 + 16) >> 1;
  __int16 v28 = *(_WORD *)(a1 + 16) >> 1;
  if (a8 >= 0) {
    unsigned int v13 = a8;
  }
  else {
    unsigned int v13 = a8 + 1;
  }
  __int16 v33 = v13 >> 1;
  __int16 v34 = a9 / 2;
  if (a3)
  {
    int v14 = 0;
    do
    {
      v26[v14] = *(_DWORD *)(a10 + 4 * v14);
      ++v14;
    }
    while (a3 > v14);
  }
  if (a4)
  {
    int v15 = 0;
    do
    {
      v26[v15 + 27] = *(_DWORD *)(a11 + 4 * v15);
      ++v15;
    }
    while (a4 > v15);
  }
  uint64_t v35 = a1 + 18;
  uint64_t v36 = a1 + 36;
  uint64_t v37 = a1 + 54;
  uint64_t v38 = a1 + 72;
  __int16 v19 = v11;
  __int16 v20 = v12;
  __int16 v23 = a3;
  __int16 v24 = a4;
  int32x2_t v16 = vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)-1);
  v17.i64[0] = v16.i32[0];
  v17.i64[1] = v16.i32[1];
  int64x2_t v21 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  float64x2_t v22 = vdivq_f64((float64x2_t)vdupq_n_s64(0x3FEF5C28F5C28F5CuLL), vcvtq_f64_s64(v17));
  double v25 = (double)(1 << (a5 - 8)) * 250.0;
  int v18 = *(_DWORD *)(a1 + 28);
  int v29 = *(_DWORD *)(a1 + 20);
  int v30 = v18;
  __int16 v31 = *(_WORD *)(a1 + 32);
  __int16 v32 = *(_WORD *)(a1 + 34);
  operator new[]();
}

void LSCInterpolateNvm<unsigned char>(uint64_t a1, uint64_t a2, unsigned __int16 *a3, uint64_t a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  v80[16] = *(double *)MEMORY[0x263EF8340];
  uint64_t v70 = a3[7];
  if (a3[7])
  {
    int v69 = a3[3];
    int v16 = a3[2];
    int v68 = a3[5];
    uint64_t v17 = a4 + 56;
    uint64_t v18 = a4 + 164;
    int v19 = a3[4];
    uint64_t v20 = a3[6];
    int v74 = v19;
    uint64_t v75 = a2 - 2;
    uint64_t v73 = v20;
    uint64_t v71 = 0;
    int v72 = v16;
    while (!v20)
    {
LABEL_50:
      if (++v71 == v70) {
        return;
      }
    }
    uint64_t v21 = 0;
    double v22 = (double)(v68 + v71 * v69);
    uint64_t v23 = *(unsigned __int16 *)(a4 + 40);
    uint64_t v24 = *(unsigned __int16 *)(a4 + 42);
    double v25 = -3.0;
    uint64_t v26 = v71 * v20;
    while (1)
    {
      double v27 = (double)(v19 + v21 * v16);
      if (v23)
      {
        uint64_t v28 = 0;
        LOWORD(v25) = *(_WORD *)a4;
        *(float *)&double v25 = (float)LODWORD(v25);
        while (v27 >= (float)(*(float *)(v17 + 4 * v28) * *(float *)&v25))
        {
          if (v23 == ++v28)
          {
            LOWORD(v28) = v23;
            if (v24) {
              goto LABEL_12;
            }
            goto LABEL_17;
          }
        }
        if (v24) {
          goto LABEL_12;
        }
      }
      else
      {
        LOWORD(v28) = 0;
        if (v24)
        {
LABEL_12:
          uint64_t v29 = 0;
          LOWORD(v25) = *(_WORD *)(a4 + 2);
          *(float *)&double v25 = (float)LODWORD(v25);
          while (v22 >= (float)(*(float *)(v18 + 4 * v29) * *(float *)&v25))
          {
            if (v24 == ++v29)
            {
              unsigned __int16 v30 = v24;
              goto LABEL_19;
            }
          }
          unsigned __int16 v30 = v29;
          goto LABEL_19;
        }
      }
LABEL_17:
      unsigned __int16 v30 = 0;
LABEL_19:
      uint64_t v31 = (unsigned __int16)v28;
      uint64_t v32 = (unsigned __int16)v28 - 1;
      double v33 = (double)(int)v32;
      unsigned int v34 = v30;
      uint64_t v35 = v30 - 1;
      double v36 = (double)(int)v35;
      if (v31 < 2
        || (signed int v37 = v34 - 2, v34 < 2)
        || ((double)v23 + -3.0 >= v33 ? (BOOL v38 = a5 == 0) : (BOOL v38 = 1),
            !v38 ? (BOOL v39 = (double)v24 + -3.0 < v36) : (BOOL v39 = 1),
            v39))
      {
        if (!v31) {
          double v33 = 0.0;
        }
        if (!v34) {
          double v36 = 0.0;
        }
        if (v33 >= (double)((int)v23 - 2)) {
          double v33 = (double)((int)v23 - 2);
        }
        if (v36 >= (double)((int)v24 - 2)) {
          double v36 = (double)((int)v24 - 2);
        }
        unsigned int v54 = vcvtmd_u64_f64(v33);
        unsigned int v55 = vcvtmd_u64_f64(v36);
        unsigned int v56 = v54 + v55 * v23;
        LOBYTE(v33) = *(unsigned char *)(a2 + v56);
        double v57 = *(double *)(a4 + 48);
        LOBYTE(a9) = *(unsigned char *)(a2 + v56 + 1);
        unsigned int v58 = v54 + (v55 + 1) * v23;
        LOBYTE(a10) = *(unsigned char *)(a2 + v58);
        LOBYTE(a11) = *(unsigned char *)(a2 + v58 + 1);
        LOWORD(a13) = *(_WORD *)a4;
        float v59 = (float)LODWORD(a13);
        float v60 = roundf(*(float *)(a4 + 56 + 4 * v54) * v59);
        LOWORD(v13) = *(_WORD *)(a4 + 2);
        float v61 = (float)LODWORD(v13);
        float v62 = roundf(*(float *)(a4 + 164 + 4 * v55) * v61);
        a13 = roundf(*(float *)(a4 + 56 + 4 * (v54 + 1)) * v59);
        double v13 = roundf(*(float *)(a4 + 164 + 4 * (v55 + 1)) * v61);
        double v63 = v27 - v60;
        double v64 = a13 - v27;
        double v65 = (double)*(unint64_t *)&a10 / v57 * v64 + v63 * ((double)*(unint64_t *)&a11 / v57);
        a11 = v63 + v64;
        a10 = v65 / (v63 + v64);
        double v66 = ((double)*(unint64_t *)&v33 / v57 * v64 + v63 * ((double)*(unint64_t *)&a9 / v57))
            / (v63 + v64);
        a9 = v13 - v22;
        double v67 = fmin(((v13 - v22) * v66 + (v22 - v62) * a10) / (v22 - v62 + v13 - v22), 1.0);
        double v25 = 1.0 / v57;
        if (v67 <= 1.0 / v57) {
          double v67 = 1.0 / v57;
        }
        *(double *)(a1 + 8 * (v26 + v21)) = v67;
      }
      else
      {
        uint64_t v40 = 0;
        double v41 = *(double *)(a4 + 48);
        uint64_t v42 = v37;
        int v43 = (unsigned char *)(v75 + v31 + (int)v23 * (uint64_t)v37);
        int v44 = v80;
        do
        {
          uint64_t v45 = 0;
          v79[v40] = *(float *)(a4 + 4 * (v40 + (int)v31 - 2) + 56);
          double v46 = *(float *)(a4 + 4 * (v40 + v42) + 164);
          v78[v40] = v46;
          uint64_t v47 = v43;
          do
          {
            LOBYTE(v46) = *v47;
            double v46 = (double)*(unint64_t *)&v46 / v41;
            v44[v45] = v46;
            v47 += v23;
            ++v45;
          }
          while (v45 != 4);
          ++v40;
          ++v43;
          v44 += 4;
        }
        while (v40 != 4);
        LOWORD(v46) = *(_WORD *)a4;
        double v48 = v27 / (double)*(unint64_t *)&v46;
        float v49 = *(float *)(a4 + 56 + 4 * v32);
        double v50 = v48 - v49;
        *(double *)&unint64_t v51 = (float)(*(float *)(a4 + 56 + 4 * v31) - v49);
        double v52 = v50 / *(double *)&v51;
        LOWORD(v51) = *(_WORD *)(a4 + 2);
        bicubicInterpolateNonuniform((double (*)[4])v80, v79, v78, v52, (v22 / (double)v51 - *(float *)(a4 + 164 + 4 * v35))/ (float)(*(float *)(a4 + 164 + 4 * v34) - *(float *)(a4 + 164 + 4 * v35)));
        double v25 = 1.0 / v41;
        if (v53 >= 1.0)
        {
          int v16 = v72;
          uint64_t v20 = v73;
          int v19 = v74;
          if (v25 < 1.0) {
            double v25 = 1.0;
          }
        }
        else
        {
          int v16 = v72;
          uint64_t v20 = v73;
          int v19 = v74;
          if (v53 > v25) {
            double v25 = v53;
          }
        }
        *(double *)(a1 + 8 * (v26 + v21)) = v25;
      }
      if (++v21 == v20) {
        goto LABEL_50;
      }
    }
  }
}

void LSCComputeFromNVMApple<unsigned short>(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, char a5, uint64_t a6, uint64_t a7, int a8, int a9, uint64_t a10, uint64_t a11)
{
  uint64_t v39 = *MEMORY[0x263EF8340];
  int v11 = *(unsigned __int16 *)(a1 + 14) >> 1;
  __int16 v27 = *(_WORD *)(a1 + 14) >> 1;
  int v12 = *(unsigned __int16 *)(a1 + 16) >> 1;
  __int16 v28 = *(_WORD *)(a1 + 16) >> 1;
  if (a8 >= 0) {
    unsigned int v13 = a8;
  }
  else {
    unsigned int v13 = a8 + 1;
  }
  __int16 v33 = v13 >> 1;
  __int16 v34 = a9 / 2;
  if (a3)
  {
    int v14 = 0;
    do
    {
      v26[v14] = *(_DWORD *)(a10 + 4 * v14);
      ++v14;
    }
    while (a3 > v14);
  }
  if (a4)
  {
    int v15 = 0;
    do
    {
      v26[v15 + 27] = *(_DWORD *)(a11 + 4 * v15);
      ++v15;
    }
    while (a4 > v15);
  }
  uint64_t v35 = a1 + 18;
  uint64_t v36 = a1 + 36;
  uint64_t v37 = a1 + 54;
  uint64_t v38 = a1 + 72;
  __int16 v19 = v11;
  __int16 v20 = v12;
  __int16 v23 = a3;
  __int16 v24 = a4;
  int32x2_t v16 = vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)-1);
  v17.i64[0] = v16.i32[0];
  v17.i64[1] = v16.i32[1];
  int64x2_t v21 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  float64x2_t v22 = vdivq_f64((float64x2_t)vdupq_n_s64(0x3FEF5C28F5C28F5CuLL), vcvtq_f64_s64(v17));
  double v25 = (double)(1 << (a5 - 8)) * 250.0;
  int v18 = *(_DWORD *)(a1 + 28);
  int v29 = *(_DWORD *)(a1 + 20);
  int v30 = v18;
  __int16 v31 = *(_WORD *)(a1 + 32);
  __int16 v32 = *(_WORD *)(a1 + 34);
  operator new[]();
}

uint64_t LSCInterpolateNvm<unsigned short>(uint64_t result, uint64_t a2, unsigned __int16 *a3, uint64_t a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13)
{
  v81[16] = *(double *)MEMORY[0x263EF8340];
  uint64_t v70 = a3[7];
  if (a3[7])
  {
    uint64_t v71 = 0;
    uint64_t v72 = result;
    int v69 = a3[3];
    int v15 = a3[2];
    int v68 = a3[5];
    uint64_t v16 = a4 + 56;
    uint64_t v17 = a4 + 164;
    uint64_t v75 = a2 - 4;
    int v76 = v15;
    int v18 = a3[4];
    uint64_t v19 = a3[6];
    uint64_t v73 = v19;
    int v74 = v18;
    while (!v19)
    {
LABEL_50:
      if (++v71 == v70) {
        return result;
      }
    }
    uint64_t v20 = 0;
    double v21 = (double)(v68 + v71 * v69);
    uint64_t v22 = *(unsigned __int16 *)(a4 + 40);
    uint64_t v23 = *(unsigned __int16 *)(a4 + 42);
    double v24 = -3.0;
    uint64_t v25 = v71 * v19;
    uint64_t v26 = 2 * v22;
    while (1)
    {
      double v27 = (double)(v18 + v20 * v15);
      if (v22)
      {
        uint64_t v28 = 0;
        LOWORD(v24) = *(_WORD *)a4;
        *(float *)&double v24 = (float)LODWORD(v24);
        while (v27 >= (float)(*(float *)(v16 + 4 * v28) * *(float *)&v24))
        {
          if (v22 == ++v28)
          {
            LOWORD(v28) = v22;
            if (v23) {
              goto LABEL_12;
            }
            goto LABEL_17;
          }
        }
        if (v23) {
          goto LABEL_12;
        }
      }
      else
      {
        LOWORD(v28) = 0;
        if (v23)
        {
LABEL_12:
          uint64_t v29 = 0;
          LOWORD(v24) = *(_WORD *)(a4 + 2);
          *(float *)&double v24 = (float)LODWORD(v24);
          while (v21 >= (float)(*(float *)(v17 + 4 * v29) * *(float *)&v24))
          {
            if (v23 == ++v29)
            {
              unsigned __int16 v30 = v23;
              goto LABEL_19;
            }
          }
          unsigned __int16 v30 = v29;
          goto LABEL_19;
        }
      }
LABEL_17:
      unsigned __int16 v30 = 0;
LABEL_19:
      unsigned int v31 = (unsigned __int16)v28;
      uint64_t v32 = (unsigned __int16)v28 - 1;
      double v33 = (double)(int)v32;
      unsigned int v34 = v30;
      uint64_t v35 = v30 - 1;
      double v36 = (double)(int)v35;
      if (v31 < 2
        || (signed int v37 = v34 - 2, v34 < 2)
        || ((double)v22 + -3.0 >= v33 ? (BOOL v38 = a5 == 0) : (BOOL v38 = 1),
            !v38 ? (BOOL v39 = (double)v23 + -3.0 < v36) : (BOOL v39 = 1),
            v39))
      {
        if (!v31) {
          double v33 = 0.0;
        }
        if (!v34) {
          double v36 = 0.0;
        }
        if (v33 >= (double)((int)v22 - 2)) {
          double v33 = (double)((int)v22 - 2);
        }
        if (v36 >= (double)((int)v23 - 2)) {
          double v36 = (double)((int)v23 - 2);
        }
        unsigned int v54 = vcvtmd_u64_f64(v33);
        unsigned int v55 = vcvtmd_u64_f64(v36);
        unsigned int v56 = v54 + v55 * v22;
        LOWORD(v33) = *(_WORD *)(a2 + 2 * v56);
        double v57 = *(double *)(a4 + 48);
        LOWORD(a9) = *(_WORD *)(a2 + 2 * (v56 + 1));
        unsigned int v58 = v54 + (v55 + 1) * v22;
        LOWORD(a10) = *(_WORD *)(a2 + 2 * v58);
        LOWORD(a11) = *(_WORD *)(a2 + 2 * (v58 + 1));
        LOWORD(a13) = *(_WORD *)a4;
        float v59 = (float)LODWORD(a13);
        float v60 = roundf(*(float *)(a4 + 56 + 4 * v54) * v59);
        LOWORD(v13) = *(_WORD *)(a4 + 2);
        float v61 = (float)LODWORD(v13);
        float v62 = roundf(*(float *)(a4 + 164 + 4 * v55) * v61);
        a13 = roundf(*(float *)(a4 + 56 + 4 * (v54 + 1)) * v59);
        double v13 = roundf(*(float *)(a4 + 164 + 4 * (v55 + 1)) * v61);
        double v63 = v27 - v60;
        double v64 = a13 - v27;
        double v65 = (double)*(unint64_t *)&a10 / v57 * v64 + v63 * ((double)*(unint64_t *)&a11 / v57);
        a11 = v63 + v64;
        a10 = v65 / (v63 + v64);
        double v66 = ((double)*(unint64_t *)&v33 / v57 * v64 + v63 * ((double)*(unint64_t *)&a9 / v57))
            / (v63 + v64);
        a9 = v13 - v21;
        double v67 = fmin(((v13 - v21) * v66 + (v21 - v62) * a10) / (v21 - v62 + v13 - v21), 1.0);
        double v24 = 1.0 / v57;
        if (v67 <= 1.0 / v57) {
          double v67 = 1.0 / v57;
        }
        *(double *)(result + 8 * (v25 + v20)) = v67;
      }
      else
      {
        uint64_t v40 = 0;
        double v41 = *(double *)(a4 + 48);
        uint64_t v42 = v37;
        int v43 = (_WORD *)(v75 + 2 * v31 + (int)v26 * (uint64_t)v37);
        int v44 = v81;
        do
        {
          uint64_t v45 = 0;
          v80[v40] = *(float *)(a4 + 4 * (v40 + (int)(v31 - 2)) + 56);
          double v46 = *(float *)(a4 + 4 * (v40 + v42) + 164);
          v79[v40] = v46;
          uint64_t v47 = v43;
          do
          {
            LOWORD(v46) = *v47;
            double v46 = (double)*(unint64_t *)&v46 / v41;
            v44[v45] = v46;
            uint64_t v47 = (_WORD *)((char *)v47 + v26);
            ++v45;
          }
          while (v45 != 4);
          ++v40;
          ++v43;
          v44 += 4;
        }
        while (v40 != 4);
        LOWORD(v46) = *(_WORD *)a4;
        double v48 = v27 / (double)*(unint64_t *)&v46;
        float v49 = *(float *)(a4 + 56 + 4 * v32);
        double v50 = v48 - v49;
        *(double *)&unint64_t v51 = (float)(*(float *)(a4 + 56 + 4 * v31) - v49);
        double v52 = v50 / *(double *)&v51;
        LOWORD(v51) = *(_WORD *)(a4 + 2);
        bicubicInterpolateNonuniform((double (*)[4])v81, v80, v79, v52, (v21 / (double)v51 - *(float *)(a4 + 164 + 4 * v35))/ (float)(*(float *)(a4 + 164 + 4 * v34) - *(float *)(a4 + 164 + 4 * v35)));
        double v24 = 1.0 / v41;
        if (v53 >= 1.0)
        {
          unint64_t result = v72;
          uint64_t v19 = v73;
          int v15 = v76;
          int v18 = v74;
          if (v24 < 1.0) {
            double v24 = 1.0;
          }
        }
        else
        {
          unint64_t result = v72;
          uint64_t v19 = v73;
          int v15 = v76;
          int v18 = v74;
          if (v53 > v24) {
            double v24 = v53;
          }
        }
        *(double *)(result + 8 * (v25 + v20)) = v24;
      }
      if (++v20 == v19) {
        goto LABEL_50;
      }
    }
  }
  return result;
}

void CICComputeFromNVMApple<unsigned char>(uint64_t a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, int a7, int __e)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  int v8 = *(unsigned __int16 *)(a1 + 14) >> 1;
  __int16 v23 = *(_WORD *)(a1 + 14) >> 1;
  int v9 = *(unsigned __int16 *)(a1 + 16) >> 1;
  __int16 v24 = *(_WORD *)(a1 + 16) >> 1;
  if (a3)
  {
    int v10 = 0;
    do
    {
      v22[v10] = *(_DWORD *)(a5 + 4 * v10);
      ++v10;
    }
    while (a3 > v10);
  }
  if (a4)
  {
    int v11 = 0;
    do
    {
      v22[v11 + 17] = *(_DWORD *)(a6 + 4 * v11);
      ++v11;
    }
    while (a4 > v11);
  }
  uint64_t v29 = a1 + 18;
  uint64_t v30 = a1 + 36;
  uint64_t v31 = a1 + 54;
  uint64_t v32 = a1 + 72;
  uint64_t v33 = a1 + 90;
  uint64_t v34 = a1 + 108;
  uint64_t v35 = a1 + 126;
  uint64_t v36 = a1 + 144;
  uint64_t v37 = a1 + 162;
  uint64_t v38 = a1 + 180;
  uint64_t v39 = a1 + 198;
  uint64_t v40 = a1 + 216;
  uint64_t v41 = a1 + 234;
  uint64_t v42 = a1 + 252;
  uint64_t v43 = a1 + 270;
  uint64_t v44 = a1 + 288;
  __int16 v15 = v8;
  __int16 v16 = v9;
  int64x2_t v17 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  __int16 v19 = a3;
  __int16 v20 = a4;
  int32x2_t v12 = vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)-1);
  v13.i64[0] = v12.i32[0];
  v13.i64[1] = v12.i32[1];
  float64x2_t v18 = vdivq_f64((float64x2_t)vdupq_n_s64(0x3FEF5C28F5C28F5CuLL), vcvtq_f64_s64(v13));
  double v21 = ldexp(1.0, __e) * 128.0;
  int v14 = *(_DWORD *)(v29 + 10);
  int v25 = *(_DWORD *)(v29 + 2);
  int v26 = v14;
  __int16 v27 = *(_WORD *)(v29 + 14);
  __int16 v28 = *(_WORD *)(v29 + 16);
  operator new[]();
}

uint64_t CICInterpolateNvm<unsigned short>(uint64_t result, uint64_t a2, unsigned __int16 *a3, uint64_t a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  v81[16] = *(double *)MEMORY[0x263EF8340];
  uint64_t v71 = a3[7];
  if (a3[7])
  {
    uint64_t v72 = 0;
    int v70 = a3[3];
    int v13 = a3[2];
    uint64_t v14 = a4 + 56;
    uint64_t v15 = a4 + 124;
    uint64_t v76 = a2 - 4;
    int v77 = v13;
    int v69 = a3[5];
    int v16 = a3[4];
    uint64_t v17 = a3[6];
    uint64_t v74 = v17;
    int v75 = v16;
    uint64_t v73 = result;
    while (!v17)
    {
LABEL_44:
      if (++v72 == v71) {
        return result;
      }
    }
    uint64_t v18 = 0;
    double v19 = (double)(v69 + v72 * v70);
    uint64_t v20 = *(unsigned __int16 *)(a4 + 40);
    uint64_t v21 = *(unsigned __int16 *)(a4 + 42);
    double v22 = -3.0;
    uint64_t v23 = v72 * v17;
    uint64_t v24 = 2 * v20;
    while (1)
    {
      double v25 = (double)(v16 + v18 * v13);
      if (v20)
      {
        uint64_t v26 = 0;
        LOWORD(v22) = *(_WORD *)a4;
        *(float *)&double v22 = (float)LODWORD(v22);
        while (v25 >= (float)(*(float *)(v14 + 4 * v26) * *(float *)&v22))
        {
          if (v20 == ++v26)
          {
            LOWORD(v26) = v20;
            if (v21) {
              goto LABEL_12;
            }
            goto LABEL_17;
          }
        }
        if (v21) {
          goto LABEL_12;
        }
      }
      else
      {
        LOWORD(v26) = 0;
        if (v21)
        {
LABEL_12:
          uint64_t v27 = 0;
          LOWORD(v22) = *(_WORD *)(a4 + 2);
          *(float *)&double v22 = (float)LODWORD(v22);
          while (v19 >= (float)(*(float *)(v15 + 4 * v27) * *(float *)&v22))
          {
            if (v21 == ++v27)
            {
              unsigned __int16 v28 = v21;
              goto LABEL_19;
            }
          }
          unsigned __int16 v28 = v27;
          goto LABEL_19;
        }
      }
LABEL_17:
      unsigned __int16 v28 = 0;
LABEL_19:
      unsigned int v29 = (unsigned __int16)v26;
      uint64_t v30 = (unsigned __int16)v26 - 1;
      double v31 = (double)(int)v30;
      unsigned int v32 = v28;
      uint64_t v33 = v28 - 1;
      double v34 = (double)(int)v33;
      if (v29 < 2
        || (signed int v35 = v32 - 2, v32 < 2)
        || ((double)v20 + -3.0 >= v31 ? (BOOL v36 = (double)v21 + -3.0 < v34) : (BOOL v36 = 1), v36))
      {
        if (!v29) {
          double v31 = 0.0;
        }
        if (!v32) {
          double v34 = 0.0;
        }
        if (v31 >= (double)((int)v20 - 2)) {
          double v31 = (double)((int)v20 - 2);
        }
        unsigned int v51 = vcvtmd_u64_f64(v31);
        if (v34 >= (double)((int)v21 - 2)) {
          double v52 = (double)((int)v21 - 2);
        }
        else {
          double v52 = v34;
        }
        unsigned int v53 = vcvtmd_u64_f64(v52);
        unsigned int v54 = v51 + v53 * v20;
        LOWORD(v52) = *(_WORD *)(a2 + 2 * v54);
        double v55 = *(double *)(a4 + 48);
        double v56 = (double)*(unint64_t *)&v52 / v55;
        LOWORD(a8) = *(_WORD *)(a2 + 2 * (v54 + 1));
        double v57 = (double)*(unint64_t *)&a8 / v55;
        unsigned int v58 = v51 + (v53 + 1) * v20;
        LOWORD(a9) = *(_WORD *)(a2 + 2 * v58);
        double v59 = (double)*(unint64_t *)&a9 / v55;
        LOWORD(a10) = *(_WORD *)(a2 + 2 * (v58 + 1));
        double v60 = (double)*(unint64_t *)&a10 / v55;
        LOWORD(a11) = *(_WORD *)a4;
        float v61 = (float)LODWORD(a11);
        float v62 = roundf(*(float *)(a4 + 56 + 4 * v51) * v61);
        LOWORD(v11) = *(_WORD *)(a4 + 2);
        float v63 = (float)LODWORD(v11);
        double v64 = roundf(*(float *)(a4 + 124 + 4 * v53) * v63);
        a11 = roundf(*(float *)(a4 + 56 + 4 * (v51 + 1)) * v61);
        double v11 = roundf(*(float *)(a4 + 124 + 4 * (v53 + 1)) * v63);
        a10 = v25 - v62;
        double v65 = a11 - v25;
        double v66 = v59 * v65 + a10 * v60;
        a9 = a10 + v65;
        double v67 = v66 / (a10 + v65);
        double v68 = (v56 * v65 + a10 * v57) / (a10 + v65);
        a8 = v11 - v19;
        double v22 = v19 - v64 + v11 - v19;
        *(double *)(result + 8 * (v23 + v18)) = fmax(fmin(((v11 - v19) * v68 + (v19 - v64) * v67) / v22, 2.0), 0.5);
      }
      else
      {
        uint64_t v37 = 0;
        double v38 = *(double *)(a4 + 48);
        uint64_t v39 = v35;
        uint64_t v40 = (_WORD *)(v76 + 2 * v29 + (int)v24 * (uint64_t)v35);
        uint64_t v41 = v81;
        do
        {
          uint64_t v42 = 0;
          v80[v37] = *(float *)(a4 + 4 * (v37 + (int)(v29 - 2)) + 56);
          double v43 = *(float *)(a4 + 4 * (v37 + v39) + 124);
          v79[v37] = v43;
          uint64_t v44 = v40;
          do
          {
            LOWORD(v43) = *v44;
            double v43 = (double)*(unint64_t *)&v43 / v38;
            v41[v42] = v43;
            uint64_t v44 = (_WORD *)((char *)v44 + v24);
            ++v42;
          }
          while (v42 != 4);
          ++v37;
          ++v40;
          v41 += 4;
        }
        while (v37 != 4);
        LOWORD(v38) = *(_WORD *)a4;
        double v45 = v25 / (double)*(unint64_t *)&v38;
        float v46 = *(float *)(a4 + 56 + 4 * v30);
        double v47 = v45 - v46;
        *(double *)&unint64_t v48 = (float)(*(float *)(a4 + 56 + 4 * v29) - v46);
        double v49 = v47 / *(double *)&v48;
        LOWORD(v48) = *(_WORD *)(a4 + 2);
        bicubicInterpolateNonuniform((double (*)[4])v81, v80, v79, v49, (v19 / (double)v48 - *(float *)(a4 + 124 + 4 * v33))/ (float)(*(float *)(a4 + 124 + 4 * v32) - *(float *)(a4 + 124 + 4 * v33)));
        double v22 = 2.0;
        if (v50 < 2.0)
        {
          double v22 = 0.5;
          if (v50 > 0.5) {
            double v22 = v50;
          }
        }
        unint64_t result = v73;
        uint64_t v17 = v74;
        *(double *)(v73 + 8 * (v23 + v18)) = v22;
        int v13 = v77;
        int v16 = v75;
      }
      if (++v18 == v17) {
        goto LABEL_44;
      }
    }
  }
  return result;
}

void CICComputeFromNVMApple<unsigned short>(uint64_t a1, int a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, int a7, int __e)
{
  uint64_t v45 = *MEMORY[0x263EF8340];
  int v8 = *(unsigned __int16 *)(a1 + 14) >> 1;
  __int16 v23 = *(_WORD *)(a1 + 14) >> 1;
  int v9 = *(unsigned __int16 *)(a1 + 16) >> 1;
  __int16 v24 = *(_WORD *)(a1 + 16) >> 1;
  if (a3)
  {
    int v10 = 0;
    do
    {
      v22[v10] = *(_DWORD *)(a5 + 4 * v10);
      ++v10;
    }
    while (a3 > v10);
  }
  if (a4)
  {
    int v11 = 0;
    do
    {
      v22[v11 + 17] = *(_DWORD *)(a6 + 4 * v11);
      ++v11;
    }
    while (a4 > v11);
  }
  uint64_t v29 = a1 + 18;
  uint64_t v30 = a1 + 36;
  uint64_t v31 = a1 + 54;
  uint64_t v32 = a1 + 72;
  uint64_t v33 = a1 + 90;
  uint64_t v34 = a1 + 108;
  uint64_t v35 = a1 + 126;
  uint64_t v36 = a1 + 144;
  uint64_t v37 = a1 + 162;
  uint64_t v38 = a1 + 180;
  uint64_t v39 = a1 + 198;
  uint64_t v40 = a1 + 216;
  uint64_t v41 = a1 + 234;
  uint64_t v42 = a1 + 252;
  uint64_t v43 = a1 + 270;
  uint64_t v44 = a1 + 288;
  __int16 v15 = v8;
  __int16 v16 = v9;
  int64x2_t v17 = vdupq_n_s64(0x3F847AE147AE147BuLL);
  __int16 v19 = a3;
  __int16 v20 = a4;
  int32x2_t v12 = vadd_s32((int32x2_t)__PAIR64__(a4, a3), (int32x2_t)-1);
  v13.i64[0] = v12.i32[0];
  v13.i64[1] = v12.i32[1];
  float64x2_t v18 = vdivq_f64((float64x2_t)vdupq_n_s64(0x3FEF5C28F5C28F5CuLL), vcvtq_f64_s64(v13));
  double v21 = ldexp(1.0, __e) * 128.0;
  int v14 = *(_DWORD *)(v29 + 10);
  int v25 = *(_DWORD *)(v29 + 2);
  int v26 = v14;
  __int16 v27 = *(_WORD *)(v29 + 14);
  __int16 v28 = *(_WORD *)(v29 + 16);
  operator new[]();
}

H16ISP *H16ISP::createExtrinsicsArray(H16ISP *this, double (*a2)[3], double *a3)
{
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF70]);
  for (uint64_t i = 0; i != 3; ++i)
  {
    for (uint64_t j = 0; j != 24; j += 8)
      H16ISP::addNumberToArray(Mutable, v5, *(double *)((char *)this + j));
    H16ISP::addNumberToArray(Mutable, v5, (*a2)[i]);
    this = (H16ISP *)((char *)this + 24);
  }
  return Mutable;
}

void H16ISP::addNumberToArray(H16ISP *this, __CFArray *a2, double a3)
{
  double valuePtr = a3;
  CFNumberRef v4 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberDoubleType, &valuePtr);
  CFArrayAppendValue(this, v4);
  CFRelease(v4);
}

__n128 ISPExclaveSensorMetadata::ISPExclaveSensorMetadata(uint64_t a1, _OWORD *a2, long long *a3, __n128 *a4)
{
  long long v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  long long v5 = a2[2];
  long long v6 = a2[3];
  long long v7 = a2[4];
  *(_OWORD *)(a1 + 76) = *(_OWORD *)((char *)a2 + 76);
  *(_OWORD *)(a1 + 48) = v6;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 32) = v5;
  long long v8 = *a3;
  *(void *)(a1 + 108) = *((void *)a3 + 2);
  *(_OWORD *)(a1 + 92) = v8;
  __n128 result = *a4;
  *(__n128 *)(a1 + 116) = *a4;
  return result;
}

{
  long long v4;
  long long v5;
  long long v6;
  long long v7;
  long long v8;
  __n128 result;

  long long v4 = a2[1];
  *(_OWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 16) = v4;
  long long v5 = a2[2];
  long long v6 = a2[3];
  long long v7 = a2[4];
  *(_OWORD *)(a1 + 76) = *(_OWORD *)((char *)a2 + 76);
  *(_OWORD *)(a1 + 48) = v6;
  *(_OWORD *)(a1 + 64) = v7;
  *(_OWORD *)(a1 + 32) = v5;
  long long v8 = *a3;
  *(void *)(a1 + 108) = *((void *)a3 + 2);
  *(_OWORD *)(a1 + 92) = v8;
  __n128 result = *a4;
  *(__n128 *)(a1 + 116) = *a4;
  return result;
}

void H16ISP::H16ISPGraphExclaveSyncNode::H16ISPGraphExclaveSyncNode(H16ISP::H16ISPGraphExclaveSyncNode *this, H16ISP::H16ISPDevice *a2)
{
  H16ISP::H16ISPFilterGraphNode::H16ISPFilterGraphNode((uint64_t)this, 24);
  *(void *)uint64_t v3 = &unk_26FAECC58;
  *(void *)(v3 + 80) = a2;
  *(void *)(v3 + 88) = 0x4059000000000000;
  *(_DWORD *)(v3 + 96) = 6;
  *(void *)(v3 + 112) = 0;
  *(void *)(v3 + 120) = 0;
  *(void *)(v3 + 104) = 0;
}

{
  uint64_t v3;

  H16ISP::H16ISPFilterGraphNode::H16ISPFilterGraphNode((uint64_t)this, 24);
  *(void *)uint64_t v3 = &unk_26FAECC58;
  *(void *)(v3 + 80) = a2;
  *(void *)(v3 + 88) = 0x4059000000000000;
  *(_DWORD *)(v3 + 96) = 6;
  *(void *)(v3 + 112) = 0;
  *(void *)(v3 + 120) = 0;
  *(void *)(v3 + 104) = 0;
}

void H16ISP::H16ISPGraphExclaveSyncNode::~H16ISPGraphExclaveSyncNode(H16ISP::H16ISPGraphExclaveSyncNode *this)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  *(void *)this = &unk_26FAECC58;
  int v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    int v2 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    int v4 = 136315138;
    long long v5 = "~H16ISPGraphExclaveSyncNode";
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_INFO, "%s - [Exclaves]: Sync Node being deconstructed!\n", (uint8_t *)&v4, 0xCu);
  }
  (*(void (**)(H16ISP::H16ISPGraphExclaveSyncNode *))(*(void *)this + 56))(this);
  uint64_t v3 = (void *)*((void *)this + 13);
  if (v3)
  {
    *((void *)this + 14) = v3;
    operator delete(v3);
  }
  H16ISP::H16ISPFilterGraphNode::~H16ISPFilterGraphNode(this);
}

{
  uint64_t vars8;

  H16ISP::H16ISPGraphExclaveSyncNode::~H16ISPGraphExclaveSyncNode(this);

  JUMPOUT(0x24C53D6E0);
}

void sub_2469773F4(_Unwind_Exception *a1, int a2)
{
  if (!a2) {
    _Unwind_Resume(a1);
  }
  __clang_call_terminate(a1);
}

uint64_t H16ISP::H16ISPGraphExclaveSyncNode::onActivate(H16ISP::H16ISPGraphExclaveSyncNode *this)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  int v1 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    int v1 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v1;
  }
  if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
  {
    int v3 = 136315138;
    int v4 = "onActivate";
    _os_log_impl(&dword_24680F000, v1, OS_LOG_TYPE_INFO, "%s - [Exclaves]: Sync node activated!\n", (uint8_t *)&v3, 0xCu);
  }
  return 0;
}

uint64_t H16ISP::H16ISPGraphExclaveSyncNode::onDeactivate(H16ISP::H16ISPGraphExclaveSyncNode *this)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
  {
    int v2 = os_log_create("com.apple.isp", "exclaves");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    int v5 = 136315138;
    uint64_t v6 = "onDeactivate";
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_INFO, "%s - [Exclaves]: Sync node being deactivated!\n", (uint8_t *)&v5, 0xCu);
  }
  int v3 = (H16ISP::H16ISPFilterGraphMessage **)*((void *)this + 13);
  if (v3 != *((H16ISP::H16ISPFilterGraphMessage ***)this + 14))
  {
    do
    {
      H16ISP::H16ISPFilterGraphMessage::Release(*v3);
      v3 += 2;
    }
    while (v3 != *((H16ISP::H16ISPFilterGraphMessage ***)this + 14));
    int v3 = (H16ISP::H16ISPFilterGraphMessage **)*((void *)this + 13);
  }
  *((void *)this + 14) = v3;
  return 0;
}

uint64_t H16ISP::H16ISPGraphExclaveSyncNode::onMessageProcessing(H16ISP::H16ISPDevice **this, H16ISP::H16ISPFilterGraphMessage *a2)
{
  int v2 = a2;
  uint64_t v42 = *MEMORY[0x263EF8340];
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = 0;
  int v4 = (pthread_mutex_t *)((char *)a2 + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
  if (H16ISP::H16ISPDevice::enabledExclaveDebug(this[10]))
  {
    int v5 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == &_os_log_internal)
    {
      int v5 = os_log_create("com.apple.isp", "exclaves");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v5;
    }
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *((_DWORD *)v2 + 90);
      *(_DWORD *)long long buf = 136315650;
      uint64_t v37 = "onMessageProcessing";
      __int16 v38 = 1024;
      int v39 = v6;
      __int16 v40 = 1024;
      int v41 = (unsigned __int16)v6;
      _os_log_impl(&dword_24680F000, v5, OS_LOG_TYPE_DEFAULT, "%s - [Exclaves]: Sync Node current message requestID=0x%08X, frameID=%U\n", buf, 0x18u);
    }
  }
  long long v8 = (H16ISP::H16ISPFilterGraphMessage **)this[13];
  uint64_t v7 = this + 13;
  if (v8 == (H16ISP::H16ISPFilterGraphMessage **)this[14])
  {
LABEL_11:
    pthread_mutex_unlock(v4);
    pthread_mutex_lock(v4);
    ++*(_DWORD *)v2;
    pthread_mutex_unlock(v4);
    v11.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
    std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = v11.__d_.__rep_;
    int32x2_t v12 = this[15];
    int64x2_t v13 = (std::chrono::steady_clock::time_point *)this[14];
    if (v13 >= (std::chrono::steady_clock::time_point *)v12)
    {
      uint64_t v15 = ((char *)v13 - (char *)*v7) >> 4;
      unint64_t v16 = v15 + 1;
      if ((unint64_t)(v15 + 1) >> 60) {
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v17 = v12 - *v7;
      if (v17 >> 3 > v16) {
        unint64_t v16 = v17 >> 3;
      }
      if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v18 = v16;
      }
      if (v18) {
        __int16 v19 = (char *)std::allocator<H16ISP::ExclaveMessageStruct>::allocate_at_least[abi:ne180100]((uint64_t)(this + 15), v18);
      }
      else {
        __int16 v19 = 0;
      }
      double v21 = (std::chrono::steady_clock::time_point *)&v19[16 * v15];
      double v22 = (H16ISP::H16ISPDevice *)&v19[16 * v18];
      v21->__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)v2;
      v21[1].__d_.__rep_ = v11.__d_.__rep_;
      int v14 = v21 + 2;
      __int16 v24 = this[13];
      __int16 v23 = this[14];
      if (v23 != v24)
      {
        do
        {
          *(_OWORD *)&v21[-2].__d_.__rep_ = *((_OWORD *)v23 - 1);
          v21 -= 2;
          __int16 v23 = (H16ISP::H16ISPDevice *)((char *)v23 - 16);
        }
        while (v23 != v24);
        __int16 v23 = *v7;
      }
      this[13] = (H16ISP::H16ISPDevice *)v21;
      this[14] = (H16ISP::H16ISPDevice *)v14;
      this[15] = v22;
      if (v23) {
        operator delete(v23);
      }
    }
    else
    {
      v13->__d_.__rep_ = (std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep)v2;
      v13[1].__d_.__rep_ = v11.__d_.__rep_;
      int v14 = v13 + 2;
    }
    this[14] = (H16ISP::H16ISPDevice *)v14;
    H16ISP::H16ISPGraphExclaveSyncNode::cleanupMessageList((uint64_t)this, &rep);
  }
  else
  {
    uint64_t v9 = -(uint64_t)v8;
    while (1)
    {
      int v10 = (char *)*v8;
      pthread_mutex_lock((pthread_mutex_t *)((char *)*v8 + 8));
      if (*((unsigned __int16 *)v10 + 180) == *((unsigned __int16 *)v2 + 180)
        && (*((unsigned char *)v2 + 387) != 0) != (v10[387] != 0))
      {
        break;
      }
      pthread_mutex_unlock((pthread_mutex_t *)((char *)*v8 + 8));
      v8 += 2;
      v9 -= 16;
      if (v8 == (H16ISP::H16ISPFilterGraphMessage **)this[14]) {
        goto LABEL_11;
      }
    }
    if (v10[387])
    {
      *((void *)v2 + 11) = *((void *)v10 + 11);
      uint64_t v20 = (uint64_t)*v8;
    }
    else
    {
      uint64_t v20 = (uint64_t)*v8;
      *((void *)v10 + 11) = *((void *)v2 + 11);
      int v2 = (H16ISP::H16ISPFilterGraphMessage *)v20;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(v20 + 8));
    pthread_mutex_unlock(v4);
    int v26 = this[4];
    __int16 v27 = this[5];
    __int16 v28 = (void *)((char *)v26 + 8 * ((unint64_t)this[7] >> 9));
    if (v27 == v26) {
      uint64_t v29 = 0;
    }
    else {
      uint64_t v29 = (void *)(*v28 + 8 * ((unint64_t)this[7] & 0x1FF));
    }
    while (1)
    {
      if (v27 == v26)
      {
        uint64_t v32 = 0;
      }
      else
      {
        unint64_t v31 = (unint64_t)this[7] + (void)this[8];
        uint64_t v32 = *(void *)((char *)v26 + ((v31 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v31 & 0x1FF);
      }
      if (v29 == (void *)v32) {
        break;
      }
      (*(void (**)(void, H16ISP::H16ISPFilterGraphMessage *))(*(void *)*v29 + 32))(*v29, v2);
      if ((void *)((char *)++v29 - *v28) == (void *)4096)
      {
        uint64_t v30 = (void *)v28[1];
        ++v28;
        uint64_t v29 = v30;
      }
      int v26 = this[4];
      __int16 v27 = this[5];
    }
    H16ISP::H16ISPFilterGraphMessage::Release(*v8);
    uint64_t v33 = this[14];
    uint64_t v34 = (char *)v33 - (16 - v9);
    if (v33 != (H16ISP::H16ISPDevice *)(16 - v9)) {
      memmove((void *)-v9, (const void *)(16 - v9), (size_t)v33 - (16 - v9));
    }
    this[14] = (H16ISP::H16ISPDevice *)&v34[-v9];
  }
  return 3758097130;
}

void H16ISP::H16ISPGraphExclaveSyncNode::cleanupMessageList(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x263EF8340];
  int v3 = *(uint64_t **)(a1 + 104);
  uint64_t v4 = &_os_log_internal;
  int v5 = &loc_2469D2000;
  if (v3 == *(uint64_t **)(a1 + 112))
  {
    int64x2_t v13 = *(char **)(a1 + 104);
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 104);
    do
    {
      if ((double)(v3[1] - *a2) / 1000000.0 > *(double *)(a1 + 88))
      {
        uint64_t v8 = *v3;
        pthread_mutex_lock((pthread_mutex_t *)(*v3 + 8));
        int v9 = *(_DWORD *)(v8 + 360);
        pthread_mutex_unlock((pthread_mutex_t *)(*v3 + 8));
        H16ISP::H16ISPFilterGraphMessage::Release((H16ISP::H16ISPFilterGraphMessage *)*v3);
        uint64_t v10 = *(void *)(a1 + 112);
        uint64_t v11 = v10 - (v7 + 16);
        if (v10 != v7 + 16) {
          memmove((void *)v7, (const void *)(v7 + 16), v10 - (v7 + 16));
        }
        *(void *)(a1 + 112) = v7 + v11;
        int32x2_t v12 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == v4)
        {
          int32x2_t v12 = os_log_create("com.apple.isp", "exclaves");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v12;
        }
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315394;
          __int16 v24 = "cleanupMessageList";
          __int16 v25 = 1024;
          int v26 = v9;
          _os_log_error_impl(&dword_24680F000, v12, OS_LOG_TYPE_ERROR, "%s - [Exclaves]: Message Drop Timeout!, requestid=0x%0X\n", buf, 0x12u);
        }
      }
      v3 += 2;
      v7 += 16;
    }
    while (v3 != *(uint64_t **)(a1 + 112));
    int64x2_t v13 = *(char **)(a1 + 104);
    int v5 = (void *)&loc_2469D2000;
  }
  BOOL v14 = *(unsigned int *)(a1 + 96) >= (unint64_t)(((char *)v3 - v13) >> 4) || v13 == (char *)v3;
  if (!v14)
  {
    uint64_t v15 = (uint64_t *)(v13 + 16);
    int v22 = v5[253];
    do
    {
      uint64_t v16 = *(v15 - 2);
      pthread_mutex_lock((pthread_mutex_t *)(v16 + 8));
      int v17 = *(_DWORD *)(v16 + 360);
      pthread_mutex_unlock((pthread_mutex_t *)(*(v15 - 2) + 8));
      H16ISP::H16ISPFilterGraphMessage::Release((H16ISP::H16ISPFilterGraphMessage *)*(v15 - 2));
      unint64_t v18 = *(uint64_t **)(a1 + 112);
      uint64_t v19 = (char *)v18 - (v13 + 16);
      if (v18 != (uint64_t *)(v13 + 16)) {
        memmove(v13, v13 + 16, (char *)v18 - (v13 + 16));
      }
      *(void *)(a1 + 112) = &v13[v19];
      uint64_t v20 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog == v4)
      {
        uint64_t v20 = os_log_create("com.apple.isp", "exclaves");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_exclavesLog = (uint64_t)v20;
      }
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = v22;
        __int16 v24 = "cleanupMessageList";
        __int16 v25 = 1024;
        int v26 = v17;
        _os_log_error_impl(&dword_24680F000, v20, OS_LOG_TYPE_ERROR, "%s - [Exclaves]: Message Drop due to above queue size!, requestid=0x%0X\n", buf, 0x12u);
      }
      double v21 = *(uint64_t **)(a1 + 112);
      if (*(unsigned int *)(a1 + 96) >= (unint64_t)(((uint64_t)v21 - *(void *)(a1 + 104)) >> 4)) {
        break;
      }
      v13 += 16;
      BOOL v14 = v15 == v21;
      v15 += 2;
    }
    while (!v14);
  }
}

void *std::allocator<H16ISP::ExclaveMessageStruct>::allocate_at_least[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >> 60) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(16 * a2);
}

uint64_t ImageUtils::Cornerfinder(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v14 = *(_DWORD *)(a1 + 20);
  uint64_t v15 = *(const void **)(a1 + 8);
  Matrix<double>::Resize(a5, 2, v14);
  memcpy(*(void **)(a5 + 8), v15, 8 * (2 * v14));
  Matrix<BOOL>::Resize(a6, 1, v14);
  Matrix<BOOL>::Resize(a7, 1, v14);
  Matrix<BOOL>::Resize(a8, 1, v14);
  signed int v27 = a3;
  unsigned int v28 = a4;
  Matrix<double>::Matrix((uint64_t)v34, (2 * a4) | 1, (2 * a3) | 1);
  Matrix<double>::Matrix((uint64_t)v32, (2 * a4) | 1, (2 * a3) | 1);
  int v29 = (2 * a3) | 1;
  Matrix<double>::Matrix((uint64_t)v30, (2 * a4) | 1, v29);
  int v16 = -a4;
  if ((signed int)-v28 <= (int)v28)
  {
    int v17 = -a3;
    unint64_t v18 = v31;
    uint64_t v19 = v33;
    uint64_t v20 = v35;
    double v21 = (double)a3;
    do
    {
      if (v17 <= v27)
      {
        double v22 = exp(-((double)v16 / (double)v28 * ((double)v16 / (double)v28)));
        int v23 = v29;
        int v24 = v17;
        do
        {
          *v20++ = v22 * exp(-((double)v24 / v21 * ((double)v24 / v21)));
          *v19++ = (double)v24;
          *v18++ = (double)v16;
          ++v24;
          --v23;
        }
        while (v23);
      }
    }
    while (v16++ != v28);
  }
  if (v14) {
    operator new[]();
  }
  Matrix<double>::~Matrix((uint64_t)v30);
  Matrix<double>::~Matrix((uint64_t)v32);
  return Matrix<double>::~Matrix((uint64_t)v34);
}

void sub_24697850C(_Unwind_Exception *a1)
{
  Matrix<double>::~Matrix(v1 - 216);
  Matrix<double>::~Matrix(v1 - 184);
  _Unwind_Resume(a1);
}

double ImageUtils::DetectArucoMarker(uint64_t a1)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  int v2 = *(_DWORD *)(a1 + 20);
  uint64_t v4 = *(double **)(a1 + 8);
  Matrix<BOOL>::Matrix((uint64_t)v21, v3, v2);
  int v5 = v22;
  ImageUtils::OtsuThreshold(a1);
  int v7 = v2 * v3;
  if (v2 * v3)
  {
    do
    {
      double v8 = *v4++;
      *v5++ = v8 > v6;
      --v7;
    }
    while (v7);
  }
  uint64_t v9 = 0;
  unsigned int v10 = vcvtmd_u64_f64((double)v3 / 7.0);
  int v11 = v2 * v10;
  uint64_t v12 = v2 - v10;
LABEL_4:
  unint64_t v13 = 0;
  if (v9 == 6 || v9 == 0) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = 6;
  }
  while (1)
  {
    if (v10)
    {
      int v16 = 0;
      unsigned int v17 = 0;
      unint64_t v18 = &v22[(v11 * v9) + v13 * v10];
      do
      {
        uint64_t v19 = 0;
        do
          v17 += v18[v19++];
        while (v10 != v19);
        ++v16;
        v18 += v10 + v12;
      }
      while (v16 != v10);
      if (v17 > (v10 * v10) >> 1) {
        break;
      }
    }
    v13 += v15;
    if (v13 > 6)
    {
      if (++v9 == 7) {
        operator new[]();
      }
      goto LABEL_4;
    }
  }
  Matrix<BOOL>::~Matrix((uint64_t)v21);
  return -1.0;
}

void sub_2469789D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  Matrix<BOOL>::~Matrix((uint64_t)va);
  Matrix<BOOL>::~Matrix((uint64_t)va1);
  Matrix<BOOL>::~Matrix(v9 - 112);
  _Unwind_Resume(a1);
}

uint64_t CheckParity(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = *(_OWORD **)(a1 + 8);
  Matrix<BOOL>::Resize(a2, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  uint64_t v4 = 0;
  unsigned int v5 = 0;
  double v6 = *(_OWORD **)(a2 + 8);
  long long v7 = *(_OWORD *)((char *)v3 + 9);
  *double v6 = *v3;
  *(_OWORD *)((char *)v6 + 9) = v7;
  double v8 = (char *)v6 + 4;
  do
  {
    switch((*((unsigned __int8 *)v3 + v4) == *((unsigned __int8 *)v3 + v4 + 1)) | (2
                                                                                   * (*((unsigned __int8 *)v3 + v4 + 2) != *((unsigned __int8 *)v3 + v4 + 3))) | (4 * ((*((unsigned __int8 *)v3 + v4 + 2) ^ *((unsigned __int8 *)v3 + v4 + 1)) != *((unsigned __int8 *)v3 + v4 + 4))))
    {
      case 1:
        ++v5;
        v8[v4 - 4] ^= 1u;
        break;
      case 2:
        ++v5;
        v8[v4 - 1] ^= 1u;
        break;
      case 3:
      case 7:
        v5 += 2;
        break;
      case 4:
        ++v5;
        v8[v4] ^= 1u;
        break;
      case 5:
        ++v5;
        v8[v4 - 3] ^= 1u;
        break;
      case 6:
        ++v5;
        v8[v4 - 2] ^= 1u;
        break;
      default:
        break;
    }
    v4 += 5;
  }
  while (v4 != 25);
  if (v5 == 1) {
    return 0;
  }
  else {
    return v5;
  }
}

void ImageUtils::GetInitialGuessLineScan(uint64_t *a1, uint64_t *a2, uint64_t a3, _DWORD *a4, uint64_t a5, unsigned int a6)
{
  unint64_t v10 = *(unsigned int *)(a3 + 20);
  uint64_t v11 = *(double **)(a3 + 8);
  Matrix<double>::Matrix((uint64_t)&v95, 2, *(_DWORD *)(a3 + 20));
  int v95 = &unk_26FAEC0F0;
  uint64_t v12 = v96;
  Matrix<BOOL>::Matrix((uint64_t)&v91, 1, v10);
  float v91 = &unk_26FAEC730;
  bzero(v92, (v94 * v93));
  if (v10)
  {
    uint64_t v13 = 0;
    unsigned int v14 = 0;
    uint64_t v15 = v92;
    int v16 = v92 + 1;
    int v17 = v10 - 1;
    unint64_t v18 = v11 + 1;
    do
    {
      if (v15[v13])
      {
        ++v13;
      }
      else
      {
        unsigned int v19 = 1;
        v15[v13] = 1;
        double v20 = *v11;
        double v21 = v11[v10];
        if (++v13 >= v10)
        {
          double v26 = *v11;
          double v25 = v11[v10];
        }
        else
        {
          double v22 = v18;
          int v23 = v17;
          int v24 = v16;
          double v25 = v11[v10];
          double v26 = *v11;
          do
          {
            double v27 = *v22;
            double v28 = v22[v10];
            if (sqrt((v20 - *v22) * (v20 - *v22) + (v21 - v28) * (v21 - v28)) <= 5.0)
            {
              *int v24 = 1;
              double v26 = v26 + v27;
              double v25 = v25 + v28;
              ++v19;
            }
            ++v24;
            ++v22;
            --v23;
          }
          while (v23);
        }
        if (v19 >= a6)
        {
          *uint64_t v12 = v26 / (double)v19;
          v12[v10] = v25 / (double)v19;
          ++v12;
          ++v14;
        }
      }
      ++v11;
      ++v16;
      --v17;
      ++v18;
    }
    while (v13 != v10);
  }
  else
  {
    unsigned int v14 = 0;
  }
  Matrix<double>::Matrix((uint64_t)&v89, 2, v14);
  unsigned int v89 = &unk_26FAEC0F0;
  memcpy(v90, v96, 8 * v14);
  memcpy(&v90[8 * v14], &v96[v10], 8 * v14);
  uint64_t v87 = 2;
  char v88 = 0;
  unsigned int v85 = &unk_26FAEC0F0;
  unsigned __int16 v86 = 0;
  v83[1] = 0;
  v83[2] = 1;
  char v84 = 0;
  v83[0] = &unk_26FAEC730;
  uint16x8_t v80 = 0;
  uint64_t v81 = 1;
  char v82 = 0;
  double v79 = &unk_26FAEC730;
  uint64_t v76 = 0;
  uint64_t v77 = 1;
  char v78 = 0;
  int v75 = &unk_26FAEC730;
  ImageUtils::Cornerfinder((uint64_t)&v89, a5, 3u, 3u, (uint64_t)&v85, (uint64_t)v83, (uint64_t)&v79, (uint64_t)&v75);
  uint64_t v29 = v14;
  unsigned int v30 = 0;
  if (v14)
  {
    unint64_t v31 = v76;
    uint64_t v32 = v80;
    uint64_t v33 = v86;
    uint64_t v34 = v90;
    do
    {
      if (!*v32 && !*v31)
      {
        *uint64_t v34 = *v33;
        v34[v29] = v33[v29];
        ++v34;
        ++v30;
      }
      ++v32;
      ++v31;
      ++v33;
      --v14;
    }
    while (v14);
  }
  Matrix<double>::Matrix((uint64_t)&v73, 2, v30);
  uint64_t v73 = &unk_26FAEC0F0;
  memcpy(__dst, v90, 8 * v30);
  memcpy((char *)__dst + 8 * v30, &v90[8 * v29], 8 * v30);
  Matrix<int>::Matrix((uint64_t)&v69, 2, v30);
  int v69 = &unk_26FAECD38;
  memset(__b, 255, 4 * (v72 * v71));
  uint64_t v35 = __b;
  Matrix<int>::Matrix((uint64_t)v65, a4[1] + 1, *a4 + 1);
  memset(v66, 255, 4 * (a4[1] + 1 + (a4[1] + 1) * *a4));
  Matrix<unsigned int>::Matrix((uint64_t)v64, 1, v30);
  v64[0] = &unk_26FAEC6F8;
  uint64_t v36 = v64[1];
  Matrix<BOOL>::Matrix((uint64_t)v61, 1, v30);
  v61[0] = &unk_26FAEC730;
  bzero((void *)v61[1], (v63 * v62));
  Matrix<unsigned int>::Matrix((uint64_t)&v60, 1, v30);
  double v60 = &unk_26FAEC6F8;
  Matrix<BOOL>::Matrix((uint64_t)v57, 1, v30);
  uint64_t v48 = v30;
  v57[0] = &unk_26FAEC730;
  bzero((void *)v57[1], (v59 * v58));
  uint64_t v37 = *a1;
  unint64_t v38 = (unint64_t)(a1[1] - *a1) >> 5;
  if (v38)
  {
    int v39 = 0;
    uint64_t v40 = *a2;
    uint64_t v47 = v36;
    do
    {
      uint64_t v55 = 1;
      char v56 = 0;
      unsigned int v54 = 0;
      unsigned int v53 = &unk_26FAEAF48;
      uint64_t v51 = 1;
      char v52 = 0;
      uint64_t v50 = 0;
      double v49 = &unk_26FAEC6F8;
      NearestNeighbor((uint64_t)&v73, v40, (uint64_t)&v53, (uint64_t)&v49);
      if (*v54 <= 3.0 && v54[1] <= 3.0 && v54[2] <= 3.0 && v54[3] <= 3.0)
      {
        uint64_t v41 = 0;
        uint64_t v42 = v50;
        uint64_t v43 = *(void *)(v37 + 8);
        do
        {
          uint64_t v44 = *(unsigned int *)(v43 + v41);
          unsigned int v45 = *(_DWORD *)(v43 + v41 + 16);
          v35[*(unsigned int *)(v42 + v41)] = v44;
          v35[v48 + *(unsigned int *)(v42 + v41)] = v45;
          if (v67 <= v45 || v68 <= v44) {
            __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
          }
          *((_DWORD *)v66 + v44 + v68 * v45) = *(_DWORD *)(v42 + v41);
          *(_DWORD *)(v47 + v41) = *(_DWORD *)(v42 + v41);
          v41 += 4;
        }
        while (v41 != 16);
        v47 += v41;
      }
      Matrix<unsigned int>::~Matrix((uint64_t)&v49);
      Matrix<double>::~Matrix((uint64_t)&v53);
      ++v39;
      v37 += 32;
      v40 += 32;
    }
    while (v39 != v38);
  }
  unsigned int v53 = &unk_26FAEAF18;
  operator new[]();
}

void sub_24697A26C(_Unwind_Exception *a1)
{
  Matrix<double>::~Matrix((uint64_t)&STACK[0x238]);
  Matrix<BOOL>::~Matrix((uint64_t)&STACK[0x258]);
  Matrix<unsigned int>::~Matrix((uint64_t)&STACK[0x278]);
  Matrix<BOOL>::~Matrix((uint64_t)&STACK[0x298]);
  Matrix<unsigned int>::~Matrix((uint64_t)&STACK[0x2B8]);
  Matrix<int>::~Matrix((uint64_t)&STACK[0x2D8]);
  Matrix<int>::~Matrix((uint64_t)&STACK[0x2F8]);
  Matrix<double>::~Matrix((uint64_t)&STACK[0x318]);
  Matrix<BOOL>::~Matrix((uint64_t)&STACK[0x338]);
  Matrix<BOOL>::~Matrix((uint64_t)&STACK[0x358]);
  Matrix<BOOL>::~Matrix((uint64_t)&STACK[0x378]);
  Matrix<double>::~Matrix(v1 - 232);
  Matrix<double>::~Matrix(v1 - 200);
  Matrix<BOOL>::~Matrix(v1 - 168);
  Matrix<double>::~Matrix(v1 - 136);
  _Unwind_Resume(a1);
}

uint64_t NearestNeighbor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(unsigned int *)(a2 + 20);
  double v8 = *(double **)(a2 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 20);
  Matrix<double>::Resize(a3, 1, v7);
  unint64_t v10 = *(double **)(a3 + 8);
  uint64_t result = Matrix<float>::Resize(a4, 1, v7);
  if (v7)
  {
    int v12 = 0;
    uint64_t v13 = *(_DWORD **)(a4 + 8);
    do
    {
      double v14 = *v8;
      double v15 = v8[v7];
      int v16 = *(double **)(a1 + 8);
      double v17 = sqrt((*v16 - *v8) * (*v16 - *v8) + (v16[v9] - v15) * (v16[v9] - v15));
      *unint64_t v10 = v17;
      _DWORD *v13 = 0;
      if (v9 >= 2)
      {
        uint64_t v18 = 1;
        do
        {
          double v19 = sqrt((v16[v18] - v14) * (v16[v18] - v14) + (v16[v9 + v18] - v15) * (v16[v9 + v18] - v15));
          if (v19 < v17)
          {
            *unint64_t v10 = v19;
            _DWORD *v13 = v18;
            double v17 = v19;
          }
          ++v18;
        }
        while (v9 != v18);
      }
      ++v12;
      ++v8;
      ++v10;
      ++v13;
    }
    while (v12 != v7);
  }
  return result;
}

void ScanPointsOnLine(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(_DWORD *)(a2 + 20) == 1)
  {
    if (*(_DWORD *)(a3 + 20) == 1)
    {
      if (*(_DWORD *)(a5 + 20) == 1) {
        operator new[]();
      }
      ScanPointsOnLine();
    }
    ScanPointsOnLine();
  }
  ScanPointsOnLine();
}

void sub_24697AB44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  Matrix<double>::~Matrix((uint64_t)&a23);
  Matrix<double>::~Matrix((uint64_t)&a27);
  Matrix<double>::~Matrix((uint64_t)&a31);
  Matrix<double>::~Matrix((uint64_t)&a35);
  Matrix<double>::~Matrix(v35 - 176);
  _Unwind_Resume(a1);
}

uint64_t MatrixNxPts<2u,double>::operator*@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  Matrix<double>::operator*(a1, (uint64_t)&v7, a3);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a2 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a2 = &unk_26FAEC0F0;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v5;
  return Matrix<double>::~Matrix((uint64_t)&v7);
}

void ImageUtils::FindMarkersOnImage()
{
}

void sub_24697BA00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,void **a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  Matrix<double>::~Matrix((uint64_t)&a22);
  Matrix<double>::~Matrix(a11);
  Matrix<double>::~Matrix((uint64_t)&a32);
  Matrix<double>::~Matrix((uint64_t)&a36);
  Matrix<double>::~Matrix((uint64_t)&a43);
  a26 = (void **)&a40;
  std::vector<ImageUtils::Marker>::__destroy_vector::operator()[abi:ne180100](&a26);
  Matrix<double>::~Matrix((uint64_t)&a47);
  Matrix<double>::~Matrix((uint64_t)&a51);
  a26 = (void **)&a55;
  std::vector<ImageUtils::Rect>::__destroy_vector::operator()[abi:ne180100](&a26);
  a26 = (void **)&a58;
  std::vector<ImageUtils::Blob>::__destroy_vector::operator()[abi:ne180100](&a26);
  Matrix<BOOL>::~Matrix((uint64_t)&a61);
  a26 = (void **)&a65;
  std::vector<ImageUtils::Blob>::__destroy_vector::operator()[abi:ne180100](&a26);
  Matrix<unsigned short>::~Matrix(v65 - 248);
  Matrix<BOOL>::~Matrix(v65 - 216);
  Matrix<BOOL>::~Matrix(v65 - 184);
  Matrix<BOOL>::~Matrix(v65 - 152);
  _Unwind_Resume(a1);
}

uint64_t MatrixNxPts<2u,double>::operator+@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  Matrix<double>::operator+(a1, (uint64_t)&v7, a3);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a2 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a2 = &unk_26FAEC0F0;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v5;
  return Matrix<double>::~Matrix((uint64_t)&v7);
}

uint64_t MatrixNxPts<2u,double>::operator/@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  Matrix<double>::operator/(a1, (uint64_t)&v7, a3);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a2 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a2 = &unk_26FAEC0F0;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v5;
  return Matrix<double>::~Matrix((uint64_t)&v7);
}

uint64_t MatrixNxPts<2u,double>::operator-@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  Matrix<double>::operator-(a1, (uint64_t)&v7, a3);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a2 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a2 = &unk_26FAEC0F0;
  *(void *)(a2 + 8) = v4;
  *(_DWORD *)(a2 + 16) = 2;
  *(_DWORD *)(a2 + 20) = v5;
  return Matrix<double>::~Matrix((uint64_t)&v7);
}

double Circshift(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6 = *(unsigned int *)(a1 + 20);
  Matrix<double>::Resize(a3, 2, v6);
  if (v6)
  {
    uint64_t v8 = *(void *)(a1 + 8);
    int v9 = *(void **)(a3 + 8);
    unsigned int v10 = -a2;
    int v11 = v6;
    do
    {
      int v12 = (void *)(v8 + 8 * (v10 % v6));
      *int v9 = *v12;
      double result = *(double *)&v12[v6];
      *(double *)&v9[v6] = result;
      ++v9;
      ++v10;
      --v11;
    }
    while (v11);
  }
  return result;
}

void ImageUtils::SubPixelRefinement()
{
  v0 = &unk_26FAEAF18;
  operator new[]();
}

void sub_24697BF60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t SurfaceFittingSubPixelRefinement@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v5 = a2;
  int v30 = *(_DWORD *)(a1 + 20);
  int v31 = *(_DWORD *)(a1 + 16);
  uint64_t v8 = *(unsigned int *)(a2 + 20);
  Matrix<double>::Matrix(a4, 2, v8);
  *(void *)a4 = &unk_26FAEC0F0;
  memcpy(*(void **)(a4 + 8), *(const void **)(v5 + 8), 8 * (2 * v8));
  int v9 = *(double **)(a4 + 8);
  LODWORD(v5) = ((2 * a3) | 1) * ((2 * a3) | 1);
  Matrix<double>::Matrix((uint64_t)v33, v5, 6);
  Matrix<double>::Matrix((uint64_t)v32, 1, v5);
  v32[0] = &unk_26FAEAF48;
  if (v8)
  {
    int v10 = 0;
    if (a3 >= 0) {
      int v11 = a3;
    }
    else {
      int v11 = -a3;
    }
    do
    {
      signed int v12 = llround(*v9);
      signed int v13 = llround(v9[v8]);
      if (v12 >= a3 && v12 + a3 < v30 && v13 >= a3 && v13 + a3 < v31)
      {
        if ((a3 & 0x80000000) == 0)
        {
          double v17 = (void *)v32[1];
          uint64_t v18 = v34;
          unsigned int v19 = *(_DWORD *)(a1 + 16);
          int v20 = -a3;
          int v21 = v13 - a3;
          int v22 = (v13 - a3) * (v12 - a3);
          do
          {
            unsigned int v23 = v20 + v13;
            unsigned int v24 = *(_DWORD *)(a1 + 20);
            int v25 = v22;
            uint64_t v26 = (v12 - a3);
            int v27 = a3 + v11 + 1;
            do
            {
              *(double *)uint64_t v18 = (double)((int)v26 * (int)v26);
              *(double *)(v18 + 8) = (double)v25;
              *(double *)(v18 + 16) = (double)(int)(v23 * v23);
              *(double *)(v18 + 24) = (double)(int)v26;
              *(double *)(v18 + 32) = (double)(v20 + v13);
              *(void *)(v18 + 40) = 0x3FF0000000000000;
              if (v23 >= v19 || v26 >= v24) {
                __assert_rtn("operator()", "Matrix.hpp", 125, "row < m_rows && col < m_cols");
              }
              *v17++ = *(void *)(*(void *)(a1 + 8) + 8 * v24 * v21 + 8 * v26);
              v18 += 48;
              ++v26;
              v25 += v21;
              --v27;
            }
            while (v27);
            ++v21;
            v22 += v12 - a3;
          }
          while (v20++ != v11);
        }
        Matrix<double>::SolveUsingQR((uint64_t)v33, (uint64_t)v32);
      }
      ++v10;
      ++v9;
    }
    while (v10 != v8);
  }
  Matrix<double>::~Matrix((uint64_t)v32);
  return Matrix<double>::~Matrix((uint64_t)v33);
}

void sub_24697C324(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v10 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  Matrix<double>::~Matrix((uint64_t)va);
  Matrix<double>::~Matrix((uint64_t)va1);
  Matrix<double>::~Matrix((uint64_t)va2);
  Matrix<double>::~Matrix(a2);
  _Unwind_Resume(a1);
}

uint64_t ImageUtils::DetectAndTrackChessBoard(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6, unsigned char *a7, uint64_t *a8)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  *a6 = 0;
  *a7 = 0;
  uint64_t v8 = *a1;
  unint64_t v9 = a1[1] - *a1;
  std::vector<Matrix<double>>::resize(a8, (v9 >> 5));
  for (char i = 1; (i & 1) != 0; char i = 0)
  {
    if ((v9 & 0x1FFFFFFFE0) != 0) {
      Matrix<double>::Matrix((uint64_t)v12, v8, 0, -1);
    }
  }
  return 1;
}

void sub_24697CF74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,void **a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,char a58,uint64_t a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  Matrix<unsigned int>::~Matrix((uint64_t)&a39);
  Matrix<double>::~Matrix((uint64_t)&a43);
  Matrix<double>::~Matrix((uint64_t)&a47);
  Matrix<double>::~Matrix((uint64_t)&a51);
  a51 = (void **)&a55;
  std::vector<ImageUtils::Rect>::__destroy_vector::operator()[abi:ne180100](&a51);
  a51 = (void **)&a58;
  std::vector<ImageUtils::Marker>::__destroy_vector::operator()[abi:ne180100](&a51);
  Matrix<double>::~Matrix((uint64_t)&a61);
  Matrix<double>::~Matrix((uint64_t)&a65);
  Matrix<double>::~Matrix((uint64_t)&a69);
  *(void *)(v69 - 208) = &STACK[0x200];
  std::vector<Matrix<double>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v69 - 208));
  *(void *)(v69 - 208) = &STACK[0x218];
  std::vector<MatrixNxPts<2u,unsigned int>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v69 - 208));
  Matrix<unsigned int>::~Matrix((uint64_t)&STACK[0x230]);
  *(void *)(v69 - 208) = &STACK[0x250];
  std::vector<ImageUtils::Rect>::__destroy_vector::operator()[abi:ne180100]((void ***)(v69 - 208));
  *(void *)(v69 - 208) = &STACK[0x268];
  std::vector<ImageUtils::Marker>::__destroy_vector::operator()[abi:ne180100]((void ***)(v69 - 208));
  Matrix<double>::~Matrix((uint64_t)&STACK[0x2A0]);
  Matrix<double>::~Matrix(v69 - 240);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<Matrix<double>>::resize(uint64_t *result, unint64_t a2)
{
  int v2 = result;
  uint64_t v3 = result[1];
  unint64_t v4 = (v3 - *result) >> 5;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      uint64_t v6 = *result + 32 * a2;
      if (v3 != v6)
      {
        uint64_t v7 = v3 - 32;
        uint64_t v8 = (uint64_t (***)(void))(v3 - 32);
        unint64_t v9 = (uint64_t (***)(void))(v3 - 32);
        do
        {
          uint64_t v10 = *v9;
          v9 -= 4;
          double result = (uint64_t *)(*v10)(v8);
          v7 -= 32;
          BOOL v11 = v8 == (uint64_t (***)(void))v6;
          uint64_t v8 = v9;
        }
        while (!v11);
      }
      v2[1] = v6;
    }
  }
  else
  {
    unint64_t v5 = a2 - v4;
    return (uint64_t *)std::vector<Matrix<double>>::__append(result, v5);
  }
  return result;
}

uint64_t MatrixNxPts<2u,double>::operator-@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  Matrix<double>::operator-(a1, a2, (uint64_t)&v7);
  uint64_t v4 = v8;
  int v5 = v9;
  *(unsigned char *)(a3 + 24) = v10;
  uint64_t v8 = 0;
  char v10 = 0;
  *(void *)a3 = &unk_26FAEC0F0;
  *(void *)(a3 + 8) = v4;
  *(_DWORD *)(a3 + 16) = 2;
  *(_DWORD *)(a3 + 20) = v5;
  return Matrix<double>::~Matrix((uint64_t)&v7);
}

uint64_t Matrix<int>::~Matrix(uint64_t a1)
{
  *(void *)a1 = &unk_26FAECCD0;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x24C53D6C0]();
    *(void *)(a1 + 8) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void Matrix<int>::~Matrix(uint64_t a1)
{
  Matrix<int>::~Matrix(a1);

  JUMPOUT(0x24C53D6E0);
}

void std::vector<ImageUtils::Rect>::__construct_one_at_end[abi:ne180100]<ImageUtils::Rect const&>(uint64_t a1, uint64_t a2)
{
}

void sub_24697D32C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<ImageUtils::Rect>::__push_back_slow_path<ImageUtils::Rect const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if (!((unint64_t)(v4 + 1) >> 59))
  {
    uint64_t v7 = (uint64_t)(a1 + 2);
    uint64_t v8 = a1[2] - v3;
    if (v8 >> 4 > v5) {
      unint64_t v5 = v8 >> 4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v5;
    }
    uint64_t v13 = a1 + 2;
    if (v9) {
      char v10 = (char *)std::allocator<Matrix<double>>::allocate_at_least[abi:ne180100](v7, v9);
    }
    else {
      char v10 = 0;
    }
    BOOL v11 = v10;
    uint64_t v12 = &v10[32 * v9];
    Matrix<double>::Matrix((uint64_t)&v10[32 * v4], a2, 0, -1);
  }
  std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
}

void sub_24697D42C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<ImageUtils::Rect>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<ImageUtils::Rect>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ImageUtils::Rect>,std::reverse_iterator<ImageUtils::Rect*>,std::reverse_iterator<ImageUtils::Rect*>,std::reverse_iterator<ImageUtils::Rect*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ImageUtils::Rect>,std::reverse_iterator<ImageUtils::Rect*>,std::reverse_iterator<ImageUtils::Rect*>,std::reverse_iterator<ImageUtils::Rect*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5) {
    Matrix<double>::Matrix(a7 - 32, a3 - 32, 0, -1);
  }
  return a6;
}

void sub_24697D558(_Unwind_Exception *exception_object)
{
  for (; v2; v2 += 32)
    Matrix<double>::~Matrix(v1 + v2);
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<ImageUtils::Rect>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    Matrix<double>::~Matrix(i - 32);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<ImageUtils::Marker>::__construct_one_at_end[abi:ne180100]<ImageUtils::Marker const&>(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  *uint64_t v2 = *a2;
  Matrix<double>::Matrix((uint64_t)(v2 + 1), (uint64_t)(a2 + 1), 0, -1);
}

void sub_24697D628(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<ImageUtils::Marker>::__push_back_slow_path<ImageUtils::Marker const&>(uint64_t *a1, void *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 <= 0x666666666666666)
  {
    uint64_t v7 = (uint64_t)(a1 + 2);
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((a1[2] - v3) >> 3);
    if (2 * v8 > v5) {
      unint64_t v5 = 2 * v8;
    }
    if (v8 >= 0x333333333333333) {
      unint64_t v9 = 0x666666666666666;
    }
    else {
      unint64_t v9 = v5;
    }
    int v16 = a1 + 2;
    if (v9) {
      char v10 = (char *)std::allocator<ImageUtils::Marker>::allocate_at_least[abi:ne180100](v7, v9);
    }
    else {
      char v10 = 0;
    }
    BOOL v11 = &v10[40 * v4];
    uint64_t v12 = v10;
    uint64_t v13 = v11;
    uint64_t v14 = v11;
    double v15 = &v10[40 * v9];
    *(void *)BOOL v11 = *a2;
    Matrix<double>::Matrix((uint64_t)(v11 + 8), (uint64_t)(a2 + 1), 0, -1);
  }
  std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
}

void sub_24697D750(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<ImageUtils::Marker>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<ImageUtils::Marker>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ImageUtils::Marker>,std::reverse_iterator<ImageUtils::Marker*>,std::reverse_iterator<ImageUtils::Marker*>,std::reverse_iterator<ImageUtils::Marker*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::allocator<ImageUtils::Marker>::allocate_at_least[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(40 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ImageUtils::Marker>,std::reverse_iterator<ImageUtils::Marker*>,std::reverse_iterator<ImageUtils::Marker*>,std::reverse_iterator<ImageUtils::Marker*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5)
  {
    *(void *)(a7 - 40) = *(void *)(a3 - 40);
    Matrix<double>::Matrix(a7 - 32, a3 - 32, 0, -1);
  }
  return a6;
}

void sub_24697D8C8(_Unwind_Exception *exception_object)
{
  if (v2)
  {
    uint64_t v4 = v1 + 8;
    do
    {
      Matrix<double>::~Matrix(v4 + v2);
      v2 += 40;
    }
    while (v2);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<ImageUtils::Marker>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 40;
    Matrix<double>::~Matrix(i - 32);
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<ImageUtils::Marker>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        uint64_t v6 = v4 - 40;
        Matrix<double>::~Matrix((uint64_t)(v4 - 32));
        uint64_t v4 = v6;
      }
      while (v6 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::vector<ImageUtils::Rect>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = **a1;
  if (v2)
  {
    uint64_t v4 = (uint64_t)v1[1];
    uint64_t v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        uint64_t v4 = Matrix<double>::~Matrix(v4 - 32);
      while ((void *)v4 != v2);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void Matrix<double>::SolveUsingQR(uint64_t a1, uint64_t a2)
{
  __CLPK_integer v4 = *(_DWORD *)(a1 + 16);
  __CLPK_integer __n = *(_DWORD *)(a1 + 20);
  __CLPK_integer v5 = __n;
  __CLPK_integer __lda = v4;
  Matrix<double>::Matrix((uint64_t)v20, v4, __n);
  if (v5 >= 1)
  {
    uint64_t v6 = *(__CLPK_doublereal **)(a1 + 8);
    uint64_t v7 = &v6[v5];
    uint64_t v8 = __a;
    uint64_t v9 = v4 * v5;
    do
    {
      if ((int)v9 >= 1)
      {
        char v10 = v6;
        do
        {
          *v8++ = *v10;
          v10 += v5;
        }
        while (v10 < &v6[v9]);
      }
      ++v6;
    }
    while (v6 < v7);
  }
  __woruint64_t k = 0.0;
  __mach_timebase_info info = 0;
  __CLPK_integer v18 = -1;
  char __trans = 78;
  if (v4 <= v5) {
    __CLPK_integer v11 = v5;
  }
  else {
    __CLPK_integer v11 = v4;
  }
  __CLPK_integer __ldb = v11;
  __CLPK_integer __nrhs = 1;
  Matrix<double>::Matrix((uint64_t)&v12, 1, v11);
  uint64_t v12 = &unk_26FAEAF48;
  memcpy(__dst, *(const void **)(a2 + 8), 8 * *(unsigned int *)(a2 + 20));
  dgels_(&__trans, &__lda, &__n, &__nrhs, __a, &__lda, (__CLPK_doublereal *)__dst, &__ldb, &__work, &v18, &__info);
  if (!__info)
  {
    __CLPK_integer v18 = (int)__work;
    operator new[]();
  }
  __assert_rtn("SolveUsingQR", "Matrix.hpp", 2234, "!info");
}

void sub_24697DC80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  Matrix<double>::~Matrix((uint64_t)va);
  Matrix<double>::~Matrix((uint64_t)va1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<Matrix<double>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v6 = a1[2];
  uint64_t result = (uint64_t)(a1 + 2);
  uint64_t v5 = v6;
  uint64_t v7 = *(void *)(result - 8);
  if (a2 <= (v6 - v7) >> 5)
  {
    if (a2)
    {
      uint64_t v14 = v7 + 32 * a2;
      uint64_t v15 = *(void *)(result - 8);
      do
      {
        *(void *)(v7 + 8) = 0;
        *(void *)(v7 + 16) = 0;
        *(void *)uint64_t v7 = &unk_26FAEAF18;
        *(unsigned char *)(v7 + 24) = 0;
        v15 += 32;
        v7 += 32;
      }
      while (v7 != v14);
      uint64_t v7 = v14;
    }
    a1[1] = v7;
  }
  else
  {
    uint64_t v8 = v7 - *a1;
    unint64_t v9 = a2 + (v8 >> 5);
    if (v9 >> 59) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v10 = v8 >> 5;
    uint64_t v11 = v5 - *a1;
    if (v11 >> 4 > v9) {
      unint64_t v9 = v11 >> 4;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v12 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v9;
    }
    unsigned __int8 v19[4] = result;
    if (v12) {
      uint64_t v13 = (char *)std::allocator<Matrix<double>>::allocate_at_least[abi:ne180100](result, v12);
    }
    else {
      uint64_t v13 = 0;
    }
    int v16 = &v13[32 * v10];
    v19[0] = v13;
    v19[1] = v16;
    v19[3] = &v13[32 * v12];
    double v17 = &v16[32 * a2];
    __CLPK_integer v18 = v16;
    do
    {
      *((void *)v18 + 1) = 0;
      *((void *)v18 + 2) = 0;
      *(void *)__CLPK_integer v18 = &unk_26FAEAF18;
      v18[24] = 0;
      v16 += 32;
      v18 += 32;
    }
    while (v18 != v17);
    unsigned int v19[2] = v17;
    std::vector<Matrix<double>>::__swap_out_circular_buffer(a1, v19);
    return std::__split_buffer<Matrix<double>>::~__split_buffer((uint64_t)v19);
  }
  return result;
}

void sub_24697DDF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Matrix<double>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<MatrixNxPts<2u,unsigned int>>::__construct_one_at_end[abi:ne180100]<MatrixNxPts<2u,unsigned int> const&>(uint64_t a1, uint64_t a2)
{
}

void sub_24697DE60(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<MatrixNxPts<2u,unsigned int>>::__push_back_slow_path<MatrixNxPts<2u,unsigned int> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if (!((unint64_t)(v4 + 1) >> 59))
  {
    uint64_t v7 = (uint64_t)(a1 + 2);
    uint64_t v8 = a1[2] - v3;
    if (v8 >> 4 > v5) {
      unint64_t v5 = v8 >> 4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v5;
    }
    uint64_t v13 = a1 + 2;
    if (v9) {
      uint64_t v10 = (char *)std::allocator<Matrix<double>>::allocate_at_least[abi:ne180100](v7, v9);
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = v10;
    unint64_t v12 = &v10[32 * v9];
    Matrix<unsigned int>::Matrix((uint64_t)&v10[32 * v4], a2, 0, -1);
  }
  std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
}

void sub_24697DF60(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<MatrixNxPts<2u,unsigned int>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void MatrixNxPts<2u,unsigned int>::~MatrixNxPts(uint64_t a1)
{
  Matrix<unsigned int>::~Matrix(a1);

  JUMPOUT(0x24C53D6E0);
}

uint64_t std::vector<MatrixNxPts<2u,unsigned int>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,unsigned int>>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,unsigned int>>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5) {
    Matrix<unsigned int>::Matrix(a7 - 32, a3 - 32, 0, -1);
  }
  return a6;
}

void sub_24697E0C4(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,unsigned int>>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>>();
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<MatrixNxPts<2u,unsigned int>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = *(void (***)(void))(i - 32);
    *(void *)(a1 + 16) = i - 32;
    (*v4)();
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::vector<MatrixNxPts<2u,double>>::__construct_one_at_end[abi:ne180100]<MatrixNxPts<2u,double> const&>(uint64_t a1, uint64_t a2)
{
}

void sub_24697E1A0(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<MatrixNxPts<2u,double>>::__push_back_slow_path<MatrixNxPts<2u,double> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if (!((unint64_t)(v4 + 1) >> 59))
  {
    uint64_t v7 = (uint64_t)(a1 + 2);
    uint64_t v8 = a1[2] - v3;
    if (v8 >> 4 > v5) {
      unint64_t v5 = v8 >> 4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v5;
    }
    uint64_t v13 = a1 + 2;
    if (v9) {
      uint64_t v10 = (char *)std::allocator<Matrix<double>>::allocate_at_least[abi:ne180100](v7, v9);
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = v10;
    unint64_t v12 = &v10[32 * v9];
    Matrix<double>::Matrix((uint64_t)&v10[32 * v4], a2, 0, -1);
  }
  std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
}

void sub_24697E2A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Matrix<double>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<MatrixNxPts<2u,double>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,double>>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,double>>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5) {
    Matrix<double>::Matrix(a7 - 32, a3 - 32, 0, -1);
  }
  return a6;
}

void sub_24697E3CC(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,double>>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>>();
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MatrixNxPts<3u,double>>::__construct_one_at_end[abi:ne180100]<MatrixNxPts<3u,double> const&>(uint64_t a1, uint64_t a2)
{
}

void sub_24697E43C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<MatrixNxPts<3u,double>>::__push_back_slow_path<MatrixNxPts<3u,double> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  uint64_t v4 = (a1[1] - *a1) >> 5;
  unint64_t v5 = v4 + 1;
  if (!((unint64_t)(v4 + 1) >> 59))
  {
    uint64_t v7 = (uint64_t)(a1 + 2);
    uint64_t v8 = a1[2] - v3;
    if (v8 >> 4 > v5) {
      unint64_t v5 = v8 >> 4;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
      unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v9 = v5;
    }
    uint64_t v13 = a1 + 2;
    if (v9) {
      uint64_t v10 = (char *)std::allocator<Matrix<double>>::allocate_at_least[abi:ne180100](v7, v9);
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v11 = v10;
    unint64_t v12 = &v10[32 * v9];
    Matrix<double>::Matrix((uint64_t)&v10[32 * v4], a2, 0, -1);
  }
  std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
}

void sub_24697E53C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<Matrix<double>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<MatrixNxPts<3u,double>>::__swap_out_circular_buffer(uint64_t *a1, void *a2)
{
  uint64_t result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<3u,double>>,std::reverse_iterator<MatrixNxPts<3u,double>*>,std::reverse_iterator<MatrixNxPts<3u,double>*>,std::reverse_iterator<MatrixNxPts<3u,double>*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<3u,double>>,std::reverse_iterator<MatrixNxPts<3u,double>*>,std::reverse_iterator<MatrixNxPts<3u,double>*>,std::reverse_iterator<MatrixNxPts<3u,double>*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a3 != a5) {
    Matrix<double>::Matrix(a7 - 32, a3 - 32, 0, -1);
  }
  return a6;
}

void sub_24697E668(_Unwind_Exception *exception_object)
{
  if (v1) {
    std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,double>>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>>();
  }
  _Unwind_Resume(exception_object);
}

void std::vector<MatrixNxPts<2u,unsigned int>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    uint64_t v4 = (char *)v1[1];
    uint64_t v5 = **a1;
    if (v4 != v2)
    {
      uint64_t v6 = v4 - 32;
      uint64_t v7 = v4 - 32;
      uint64_t v8 = v4 - 32;
      do
      {
        unint64_t v9 = *(void (***)(char *))v8;
        v8 -= 32;
        (*v9)(v7);
        v6 -= 32;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      uint64_t v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t Matrix<int>::Matrix(uint64_t result, int a2, int a3)
{
  *(void *)uint64_t result = &unk_26FAECCD0;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

void MatrixNxPts<2u,int>::~MatrixNxPts(uint64_t a1)
{
  Matrix<int>::~Matrix(a1);

  JUMPOUT(0x24C53D6E0);
}

void Matrix<double>::operator+(uint64_t a1@<X0>, uint64_t a2@<X8>, double a3@<D0>)
{
  double v5 = a3;
  Matrix<double>::Matrix(a2, *(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 20));
  vDSPVsadd<double>(*(const double **)(a1 + 8), 1, &v5, *(double **)(a2 + 8), 1, *(_DWORD *)(a1 + 20) * *(_DWORD *)(a1 + 16));
}

void sub_24697E864(_Unwind_Exception *a1)
{
  Matrix<double>::~Matrix(v1);
  _Unwind_Resume(a1);
}

uint64_t OUTLINED_FUNCTION_1_5()
{
  return v0;
}

uint64_t dumpTailspinOnDispatchQueue(char *a1, const char *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v80 = *MEMORY[0x263EF8340];
  CFStringRef v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x263EFFB08], a2, 0x8000100u);
  uint64_t v9 = &_os_log_internal;
  if (!v8)
  {
    int v27 = GetCameraUserspaceLogStream__servicesLog;
    if (GetCameraUserspaceLogStream__servicesLog == &_os_log_internal)
    {
      int v27 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v27;
    }
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
      dumpTailspinOnDispatchQueue_cold_1((uint64_t)a2, v27);
    }
    return 0;
  }
  CFStringRef v10 = v8;
  uint64_t v11 = os_variant_has_internal_diagnostics() ^ 1;
  uint64_t v12 = *MEMORY[0x263F8C838];
  v64[0] = v10;
  uint64_t v13 = *MEMORY[0x263F8C858];
  v63[0] = v12;
  v63[1] = v13;
  v64[1] = [NSNumber numberWithInt:getpid()];
  v63[2] = *MEMORY[0x263F8C840];
  uint64_t v14 = [NSNumber numberWithBool:v11];
  uint64_t v15 = *MEMORY[0x263F8C828];
  void v64[2] = v14;
  _DWORD v64[3] = MEMORY[0x263EFFA88];
  uint64_t v16 = *MEMORY[0x263F8C800];
  v63[3] = v15;
  v63[4] = v16;
  uint64_t v17 = *MEMORY[0x263F8C808];
  void v64[4] = MEMORY[0x263EFFA88];
  v64[5] = MEMORY[0x263EFFA88];
  uint64_t v18 = *MEMORY[0x263F8C7F8];
  v63[5] = v17;
  v63[6] = v18;
  v63[7] = *MEMORY[0x263F8C810];
  v64[6] = MEMORY[0x263EFFA88];
  v64[7] = MEMORY[0x263EFFA88];
  uint64_t v19 = [NSDictionary dictionaryWithObjects:v64 forKeys:v63 count:8];
  CFRelease(v10);
  int v20 = GetCameraUserspaceLogStream__servicesLog;
  if (GetCameraUserspaceLogStream__servicesLog == v9)
  {
    int v20 = os_log_create("com.apple.isp", "services");
    GetCameraUserspaceLogStream__servicesLog = (uint64_t)v20;
  }
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136315906;
    uint64_t v73 = a1;
    __int16 v74 = 2112;
    uint64_t v75 = v19;
    __int16 v76 = 2048;
    uint64_t v77 = a3;
    __int16 v78 = 2048;
    uint64_t v79 = a4;
    _os_log_impl(&dword_24680F000, v20, OS_LOG_TYPE_DEFAULT, "dumpTailspinWithOptionsOnQueue %s %@ %p %p\n", buf, 0x2Au);
  }
  size_t v21 = strlen(a1);
  if (v21 >= 0x401)
  {
    double v28 = GetCameraUserspaceLogStream__servicesLog;
    if (GetCameraUserspaceLogStream__servicesLog == v9)
    {
      double v28 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v28;
    }
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
      dumpTailspinOnDispatchQueue_cold_6(v28, v29, v30, v31, v32, v33, v34, v35);
    }
    return 0;
  }
  size_t v22 = v21;
  unsigned int v23 = strrchr(a1, 47);
  if (v23)
  {
    unsigned int v24 = v23;
    int64_t v25 = v23 - a1;
    __strncpy_chk();
    buf[v25] = 0;
    uint64_t v26 = GetCameraUserspaceLogStream__servicesLog;
    if (GetCameraUserspaceLogStream__servicesLog == v9)
    {
      uint64_t v26 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v26;
    }
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v65) = 136315138;
      *(void *)((char *)&v65 + 4) = buf;
      _os_log_impl(&dword_24680F000, v26, OS_LOG_TYPE_DEFAULT, "creating directory %s\n", (uint8_t *)&v65, 0xCu);
    }
    if (mkdir((const char *)buf, 0x1EDu) && *__error() != 17)
    {
      uint64_t v50 = GetCameraUserspaceLogStream__servicesLog;
      if (GetCameraUserspaceLogStream__servicesLog == &_os_log_internal)
      {
        uint64_t v50 = os_log_create("com.apple.isp", "services");
        GetCameraUserspaceLogStream__servicesLog = (uint64_t)v50;
      }
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
        dumpTailspinOnDispatchQueue_cold_5((uint64_t)buf, v50);
      }
      return 0;
    }
    strncpy((char *)&buf[v25], v24, v22 - v25);
  }
  else
  {
    strncpy((char *)buf, a1, 0x400uLL);
  }
  time_t v62 = 0;
  if (time(&v62) == -1)
  {
    uint64_t v42 = GetCameraUserspaceLogStream__servicesLog;
    if (GetCameraUserspaceLogStream__servicesLog == v9)
    {
      uint64_t v42 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v42;
    }
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
      dumpTailspinOnDispatchQueue_cold_2(v42, v43, v44, v45, v46, v47, v48, v49);
    }
    return 0;
  }
  uint64_t v36 = localtime(&v62);
  size_t v37 = strftime((char *)&buf[v22], 1024 - v22, "_%Y.%m.%d_%H-%M-%S%z.tailspin", v36);
  unint64_t v38 = GetCameraUserspaceLogStream__servicesLog;
  if (!v37)
  {
    if (GetCameraUserspaceLogStream__servicesLog == v9)
    {
      unint64_t v38 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v38;
    }
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
      dumpTailspinOnDispatchQueue_cold_3(v38, v51, v52, v53, v54, v55, v56, v57);
    }
    return 0;
  }
  if (GetCameraUserspaceLogStream__servicesLog == v9)
  {
    unint64_t v38 = os_log_create("com.apple.isp", "services");
    GetCameraUserspaceLogStream__servicesLog = (uint64_t)v38;
  }
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v65) = 136315138;
    *(void *)((char *)&v65 + 4) = buf;
    _os_log_impl(&dword_24680F000, v38, OS_LOG_TYPE_DEFAULT, "creating tailspin file %s\n", (uint8_t *)&v65, 0xCu);
  }
  int v39 = open((const char *)buf, 514, 420);
  if (v39 < 0)
  {
    int v58 = GetCameraUserspaceLogStream__servicesLog;
    if (GetCameraUserspaceLogStream__servicesLog == v9)
    {
      int v58 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v58;
    }
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR)) {
      dumpTailspinOnDispatchQueue_cold_4();
    }
    return 0;
  }
  int v40 = v39;
  if (a3)
  {
    *(void *)&long long v65 = MEMORY[0x263EF8330];
    *((void *)&v65 + 1) = 3221225472;
    double v66 = __dumpTailspinWithOptionsOnQueue_block_invoke;
    unsigned int v67 = &unk_2651F0278;
    int v71 = v39;
    uint64_t v69 = a4;
    int v70 = a1;
    uint64_t v68 = v19;
    tailspin_dump_output_with_options();
    return 1;
  }
  else
  {
    double v60 = GetCameraUserspaceLogStream__servicesLog;
    if (GetCameraUserspaceLogStream__servicesLog == v9)
    {
      double v60 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v60;
    }
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v65) = 136315138;
      *(void *)((char *)&v65 + 4) = buf;
      _os_log_impl(&dword_24680F000, v60, OS_LOG_TYPE_DEFAULT, "Dump tailspin to %s begin ...\n", (uint8_t *)&v65, 0xCu);
    }
    uint64_t v41 = tailspin_dump_output_with_options_sync();
    float v61 = GetCameraUserspaceLogStream__servicesLog;
    if (GetCameraUserspaceLogStream__servicesLog == v9)
    {
      float v61 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v61;
    }
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v65) = 0;
      _os_log_impl(&dword_24680F000, v61, OS_LOG_TYPE_DEFAULT, "Dump tailspin end ...\n", (uint8_t *)&v65, 2u);
    }
    fsync(v40);
    close(v40);
  }
  return v41;
}

uint64_t dumpTailspinInBackground(char *a1, const char *a2, uint64_t a3)
{
  dispatch_queue_global_t global_queue = dispatch_get_global_queue(9, 0);

  return dumpTailspinOnDispatchQueue(a1, a2, (uint64_t)global_queue, a3);
}

uint64_t dumpTailspinSync(char *a1, const char *a2)
{
  return dumpTailspinOnDispatchQueue(a1, a2, 0, 0);
}

uint64_t __dumpTailspinWithOptionsOnQueue_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  fsync(*(_DWORD *)(a1 + 56));
  close(*(_DWORD *)(a1 + 56));
  uint64_t v4 = GetCameraUserspaceLogStream__servicesLog;
  if (a2)
  {
    if (GetCameraUserspaceLogStream__servicesLog == &_os_log_internal)
    {
      uint64_t v4 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = [*(id *)(a1 + 32) objectForKeyedSubscript:*MEMORY[0x263F8C838]];
      uint64_t v6 = *(void *)(a1 + 48);
      int v8 = 138412546;
      uint64_t v9 = v5;
      __int16 v10 = 2080;
      uint64_t v11 = v6;
      _os_log_impl(&dword_24680F000, v4, OS_LOG_TYPE_DEFAULT, "Tailspin with reason '%@' stored at path %s\n", (uint8_t *)&v8, 0x16u);
    }
  }
  else
  {
    if (GetCameraUserspaceLogStream__servicesLog == &_os_log_internal)
    {
      uint64_t v4 = os_log_create("com.apple.isp", "services");
      GetCameraUserspaceLogStream__servicesLog = (uint64_t)v4;
    }
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
      __dumpTailspinWithOptionsOnQueue_block_invoke_cold_1(a1);
    }
  }
  uint64_t result = *(void *)(a1 + 40);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(result + 16))(result, a2);
  }
  return result;
}

H16ISP::H16ISPGeneralProcessFrameReceiver *H16ISP::H16ISPGeneralProcessFrameReceiver::H16ISPGeneralProcessFrameReceiver(H16ISP::H16ISPGeneralProcessFrameReceiver *this, H16ISP::H16ISPDevice *a2)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  *(_DWORD *)this = 0;
  *((unsigned char *)this + 184) = 0;
  *((void *)this + 33) = 0;
  *((_DWORD *)this + 68) = 0;
  *((void *)this + 35) = 0;
  *((void *)this + 36) = a2;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *((void *)this + 44) = 0x4000000000000000;
  *((_DWORD *)this + 90) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 48), 0);
  pthread_mutex_init((pthread_mutex_t *)this + 3, 0);
  *((void *)this + 32) = 0;
  pthread_mutexattr_init(&v4);
  pthread_mutexattr_settype(&v4, 2);
  pthread_mutex_init((pthread_mutex_t *)((char *)this + 112), &v4);
  pthread_mutexattr_destroy(&v4);
  *((void *)this + 22) = dispatch_semaphore_create(0);
  return this;
}

void sub_24697F268(_Unwind_Exception *a1)
{
  std::deque<__CVBuffer *>::~deque[abi:ne180100](v1);
  _Unwind_Resume(a1);
}

void H16ISP::H16ISPGeneralProcessFrameReceiver::~H16ISPGeneralProcessFrameReceiver(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  if (*(_DWORD *)this) {
    H16ISP::H16ISPGeneralProcessFrameReceiver::stopReceive(this);
  }
  if (*((void *)this + 35)) {
    H16ISP::H16ISPGeneralProcessFrameReceiver::removeIODispatcherFromRunLoop(this);
  }
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 48));
  pthread_mutex_destroy((pthread_mutex_t *)((char *)this + 112));
  pthread_mutex_destroy((pthread_mutex_t *)this + 3);
  H16ISP::H16ISPDevice::ISP_FlushInactiveDARTMappings(*((H16ISP::H16ISPDevice **)this + 36));
  dispatch_release(*((dispatch_object_t *)this + 22));
  std::deque<__CVBuffer *>::~deque[abi:ne180100]((void *)this + 37);
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::stopReceive(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  uint64_t v2 = 3758097110;
  uint64_t v3 = (pthread_mutex_t *)((char *)this + 48);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  if (*(_DWORD *)this)
  {
    H16ISP::H16ISPGeneralProcessFrameReceiver::stopNoDataTimer(this);
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 112));
    *((unsigned char *)this + 344) = 1;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 112));
    int v4 = 2001;
    do
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)this + 112));
      if (!*((void *)this + 42))
      {
        uint64_t v2 = 0;
        goto LABEL_32;
      }
      usleep(0x3E8u);
      --v4;
    }
    while (v4);
    printf("H16ISPGeneralProcessFrameReceiver: Did not get all pending requests back from kernel. remaining: %d.\n", *((void *)this + 42));
    uint64_t v5 = (void **)*((void *)this + 38);
    uint64_t v6 = (void **)*((void *)this + 39);
    uint64_t v7 = &v5[*((void *)this + 41) >> 9];
    if (v6 == v5) {
      int v8 = 0;
    }
    else {
      int v8 = (uint64_t *)((char *)*v7 + 8 * (*((void *)this + 41) & 0x1FFLL));
    }
    while (1)
    {
      unint64_t v9 = (char *)v6 - (char *)v5;
      if (v9)
      {
        unint64_t v10 = *((void *)this + 42) + *((void *)this + 41);
        uint64_t v11 = *(uint64_t *)((char *)v5 + ((v10 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v10 & 0x1FF);
      }
      else
      {
        uint64_t v11 = 0;
      }
      if (v8 == (uint64_t *)v11) {
        break;
      }
      uint64_t v12 = *v8;
      if (*v8)
      {
        CVPixelBufferRelease(*(CVPixelBufferRef *)(v12 + 8));
        CVPixelBufferRelease(*(CVPixelBufferRef *)(v12 + 24));
        uint64_t v13 = *(__CVBuffer **)(v12 + 32);
        if (v13) {
          CVPixelBufferRelease(v13);
        }
        if (*(_DWORD *)(v12 + 944))
        {
          unint64_t v14 = 0;
          do
            CVPixelBufferRelease(*(CVPixelBufferRef *)(v12 + 40 + 8 * v14++));
          while (v14 < *(unsigned int *)(v12 + 944));
        }
        printf("H16ISPGeneralProcessFrameReceiver: Request not returned 0x%p\n", (const void *)v12);
        MEMORY[0x24C53D6E0](v12, 0x10E0C400629D57DLL);
      }
      else
      {
        printf("H16ISPGeneralProcessFrameReceiver: Request not returned 0x%p\n", 0);
      }
      if ((char *)++v8 - (unsigned char *)*v7 == 4096)
      {
        uint64_t v15 = (uint64_t *)v7[1];
        ++v7;
        int v8 = v15;
      }
      uint64_t v5 = (void **)*((void *)this + 38);
      uint64_t v6 = (void **)*((void *)this + 39);
    }
    *((void *)this + 42) = 0;
    if (v9 >= 0x11)
    {
      do
      {
        operator delete(*v5);
        uint64_t v16 = *((void *)this + 39);
        uint64_t v5 = (void **)(*((void *)this + 38) + 8);
        *((void *)this + 38) = v5;
        unint64_t v9 = v16 - (void)v5;
      }
      while (v9 > 0x10);
    }
    if (v9 >> 3 == 1)
    {
      uint64_t v17 = 256;
    }
    else
    {
      if (v9 >> 3 != 2)
      {
LABEL_32:
        pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 112));
        *((unsigned char *)this + 344) = 0;
        *(_DWORD *)this = 0;
        goto LABEL_33;
      }
      uint64_t v17 = 512;
    }
    *((void *)this + 41) = v17;
    goto LABEL_32;
  }
  uint64_t v2 = 3758097122;
LABEL_33:
  pthread_mutex_unlock(v3);
  return v2;
}

void H16ISP::H16ISPGeneralProcessFrameReceiver::removeIODispatcherFromRunLoop(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  uint64_t v2 = (__CFRunLoopSource *)*((void *)this + 35);
  if (v2)
  {
    CFRunLoopRemoveSource(*((CFRunLoopRef *)this + 1), v2, (CFRunLoopMode)*MEMORY[0x263EFFE88]);
    CFRelease(*((CFTypeRef *)this + 35));
    *((void *)this + 35) = 0;
  }
  uint64_t v3 = (__CFMachPort *)*((void *)this + 33);
  if (v3)
  {
    CFMachPortInvalidate(v3);
    CFRelease(*((CFTypeRef *)this + 33));
    *((void *)this + 33) = 0;
  }
  mach_port_name_t v4 = *((_DWORD *)this + 68);
  if (v4)
  {
    mach_port_mod_refs(*MEMORY[0x263EF8960], v4, 1u, -1);
    *((_DWORD *)this + 68) = 0;
  }
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::setupFrameReceiver(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  *((void *)this + 1) = CFRunLoopGetCurrent();

  return H16ISP::H16ISPGeneralProcessFrameReceiver::addIODispatcherToRunLoop(this);
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::addIODispatcherToRunLoop(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  uint64_t v2 = IOCreateReceivePort(0x39u, (mach_port_t *)this + 68);
  if (!v2)
  {
    uint64_t v2 = 3758097085;
    Boolean shouldFreeInfo = 0;
    context.version = 1;
    context.mach_timebase_info info = this;
    memset(&context.retain, 0, 24);
    CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x263EFFB08];
    mach_port_name_t v4 = CFMachPortCreateWithPort((CFAllocatorRef)*MEMORY[0x263EFFB08], *((_DWORD *)this + 68), MEMORY[0x263F0EBE0], &context, &shouldFreeInfo);
    *((void *)this + 33) = v4;
    if (v4)
    {
      RunLoopSource = CFMachPortCreateRunLoopSource(v3, v4, 0);
      *((void *)this + 35) = RunLoopSource;
      if (RunLoopSource)
      {
        CFRunLoopAddSource(*((CFRunLoopRef *)this + 1), RunLoopSource, (CFRunLoopMode)*MEMORY[0x263EFFE88]);
        return 0;
      }
    }
  }
  return v2;
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::registerFrameReceiveCallback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  return 0;
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::registerMessageCallback(H16ISP::H16ISPGeneralProcessFrameReceiver *this, void (*a2)(unsigned int, unsigned int, unsigned int, void *, void *, void *), void *a3)
{
  *((void *)this + 4) = a2;
  *((void *)this + 5) = a3;
  return 0;
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::startReceive(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 48);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  if (*(_DWORD *)this == 1)
  {
    uint64_t v3 = 3758097122;
  }
  else
  {
    uint64_t v3 = 0;
    *((unsigned char *)this + 344) = 0;
    *(_DWORD *)this = 1;
  }
  pthread_mutex_unlock(v2);
  return v3;
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::stopNoDataTimer(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 192);
  pthread_mutex_lock((pthread_mutex_t *)this + 3);
  uint64_t v3 = (__CFRunLoopTimer *)*((void *)this + 32);
  if (v3)
  {
    CFRunLoopTimerInvalidate(v3);
    CFRelease(*((CFTypeRef *)this + 32));
    *((void *)this + 32) = 0;
  }

  return pthread_mutex_unlock(v2);
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::completeAllRequests(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  uint64_t v2 = (pthread_mutex_t *)((char *)this + 48);
  pthread_mutex_lock((pthread_mutex_t *)((char *)this + 48));
  if (*(_DWORD *)this)
  {
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 112));
    if (*((void *)this + 42))
    {
      *((unsigned char *)this + 184) = 1;
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 112));
      dispatch_time_t v3 = dispatch_time(0, 2000000000);
      if (dispatch_semaphore_wait(*((dispatch_semaphore_t *)this + 22), v3))
      {
        mach_port_name_t v4 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
        {
          mach_port_name_t v4 = os_log_create("com.apple.isp", "general");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v4;
        }
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR)) {
          H16ISP::H16ISPGeneralProcessFrameReceiver::completeAllRequests((uint64_t *)this + 42, v4);
        }
        uint64_t v5 = *((void *)this + 38);
        uint64_t v6 = *((void *)this + 39);
        uint64_t v7 = (void *)(v5 + 8 * (*((void *)this + 41) >> 9));
        if (v6 == v5) {
          int v8 = 0;
        }
        else {
          int v8 = (const void **)(*v7 + 8 * (*((void *)this + 41) & 0x1FFLL));
        }
        while (1)
        {
          if (v6 == v5)
          {
            uint64_t v11 = 0;
          }
          else
          {
            unint64_t v10 = *((void *)this + 42) + *((void *)this + 41);
            uint64_t v11 = *(void *)(v5 + ((v10 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v10 & 0x1FF);
          }
          if (v8 == (const void **)v11) {
            break;
          }
          uint64_t v12 = *v8++;
          printf("H16ISPGeneralProcessFrameReceiver: Request not returned 0x%p\n", v12);
          if ((const void **)((char *)v8 - *v7) == (const void **)4096)
          {
            uint64_t v13 = (const void **)v7[1];
            ++v7;
            int v8 = v13;
          }
          uint64_t v5 = *((void *)this + 38);
          uint64_t v6 = *((void *)this + 39);
        }
        uint64_t v9 = 3758097110;
        goto LABEL_22;
      }
    }
    else
    {
      pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 112));
    }
    uint64_t v9 = 0;
LABEL_22:
    pthread_mutex_lock((pthread_mutex_t *)((char *)this + 112));
    *((unsigned char *)this + 184) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)((char *)this + 112));
    pthread_mutex_unlock(v2);
    return v9;
  }
  pthread_mutex_unlock(v2);
  return 3758097122;
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::GeneralProcess(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = MEMORY[0x270FA5388](a1, a2);
  char v4 = v3;
  uint64_t v6 = v5;
  uint64_t v7 = v2;
  uint64_t v164 = *MEMORY[0x263EF8340];
  int v8 = (pthread_mutex_t *)(v2 + 48);
  pthread_mutex_lock((pthread_mutex_t *)(v2 + 48));
  if (*(unsigned char *)(v7 + 344) || *(_DWORD *)v7 != 1)
  {
    pthread_mutex_unlock(v8);
    return 3758097122;
  }
  uint64_t v9 = (__CVBuffer *)*((void *)v6 + 1);
  if (v9)
  {
    if (*((void *)v6 + 3))
    {
      uint64_t v10 = *((unsigned int *)v6 + 236);
      if ((v10 - 21) >= 0xFFFFFFEC)
      {
        uint64_t v13 = 0;
        uint64_t v14 = 8 * v10;
        do
        {
          if (!*(void *)&v6[v13 + 40]) {
            goto LABEL_6;
          }
          v13 += 8;
        }
        while (v14 != v13);
        int32x2_t v132 = v8;
        if ((v4 & 1) == 0)
        {
          CVPixelBufferRetain(v9);
          uint64_t v15 = (__CVBuffer *)*((void *)v6 + 2);
          if (v15) {
            CVPixelBufferRetain(v15);
          }
          CVPixelBufferRetain(*((CVPixelBufferRef *)v6 + 3));
          uint64_t v16 = (__CVBuffer *)*((void *)v6 + 4);
          if (v16) {
            CVPixelBufferRetain(v16);
          }
          if (*((_DWORD *)v6 + 236))
          {
            unint64_t v17 = 0;
            do
              CVPixelBufferRetain(*(CVPixelBufferRef *)&v6[8 * v17++ + 40]);
            while (v17 < *((unsigned int *)v6 + 236));
          }
        }
        bzero(inputStruct, 0x3C8uLL);
        IOSurface = CVPixelBufferGetIOSurface(*((CVPixelBufferRef *)v6 + 1));
        IOSurfaceID ID = IOSurfaceGetID(IOSurface);
        uint64_t v19 = (__CVBuffer *)*((void *)v6 + 2);
        char v133 = v4;
        if (v19)
        {
          int v20 = CVPixelBufferGetIOSurface(v19);
          LODWORD(v19) = IOSurfaceGetID(v20);
        }
        int v150 = (int)v19;
        unsigned int v134 = v6;
        size_t v22 = (__CVBuffer *)*((void *)v6 + 1);
        size_t v21 = (CVPixelBufferRef *)(v6 + 8);
        PixelFormatType = (H16ISP *)CVPixelBufferGetPixelFormatType(v22);
        H16ISP::getFrameFormatMetaInfo((int)PixelFormatType, &v142);
        int FrameFormat = H16ISP::getFrameFormat(PixelFormatType);
        int Width = CVPixelBufferGetWidth(*v21);
        int Height = CVPixelBufferGetHeight(*v21);
        int v25 = *((_DWORD *)v134 + 54);
        int v156 = Height;
        int v157 = v25;
        if (FrameFormat == 15 || !FrameFormat)
        {
          int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(*((CVPixelBufferRef *)v134 + 1), 0);
          int DataSize = CVPixelBufferGetHeight(*((CVPixelBufferRef *)v134 + 1)) * BytesPerRowOfPlane;
          int v27 = CVPixelBufferGetBytesPerRowOfPlane(*((CVPixelBufferRef *)v134 + 1), 1uLL);
          unsigned int v148 = (CVPixelBufferGetHeight(*((CVPixelBufferRef *)v134 + 1)) * v27) >> 1;
          int BytesPerRowOfTileDataOfPlane = CVPixelBufferGetBytesPerRowOfPlane(*((CVPixelBufferRef *)v134 + 1), 0);
          double v28 = (CVPixelBufferRef *)v134;
          uint64_t v29 = (__CVBuffer *)*((void *)v134 + 2);
          if (!v29) {
            goto LABEL_28;
          }
          int v30 = CVPixelBufferGetBytesPerRowOfPlane(v29, 0);
          int v151 = CVPixelBufferGetHeight(*((CVPixelBufferRef *)v134 + 2)) * v30;
          int v31 = CVPixelBufferGetBytesPerRowOfPlane(*((CVPixelBufferRef *)v134 + 2), 1uLL);
          unsigned int v152 = (CVPixelBufferGetHeight(*((CVPixelBufferRef *)v134 + 2)) * v31) >> 1;
          int v32 = CVPixelBufferGetBytesPerRowOfPlane(*((CVPixelBufferRef *)v134 + 2), 0);
          goto LABEL_26;
        }
        uint64_t v121 = (__CVBuffer *)*((void *)v134 + 1);
        if (v143 == 2)
        {
          unsigned int v122 = CVPixelBufferGetIOSurface(v121);
          int BaseAddressOfCompressedTileDataRegionOfPlane = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
          int v124 = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
          int AllocSize = IOSurfaceGetAllocSize(v122);
          int DataSize = v124 - BaseAddressOfCompressedTileDataRegionOfPlane;
          unsigned int v148 = AllocSize - (v124 - BaseAddressOfCompressedTileDataRegionOfPlane);
          int BytesPerRowOfTileDataOfPlane = IOSurfaceGetBytesPerRowOfTileDataOfPlane();
          double v28 = (CVPixelBufferRef *)v134;
          uint64_t v126 = (__CVBuffer *)*((void *)v134 + 2);
          if (v126)
          {
            unsigned int v127 = CVPixelBufferGetIOSurface(v126);
            int v128 = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
            int v129 = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
            int v130 = IOSurfaceGetAllocSize(v127);
            int v151 = v129 - v128;
            unsigned int v152 = v130 - DataSize;
            int v32 = IOSurfaceGetBytesPerRowOfTileDataOfPlane();
LABEL_26:
            int BytesPerRow = v32;
LABEL_27:
            double v28 = (CVPixelBufferRef *)v134;
          }
        }
        else
        {
          int BytesPerRowOfTileDataOfPlane = CVPixelBufferGetBytesPerRow(v121);
          int DataSize = CVPixelBufferGetDataSize(*((CVPixelBufferRef *)v134 + 1));
          unsigned int v148 = 0;
          double v28 = (CVPixelBufferRef *)v134;
          uint64_t v131 = (__CVBuffer *)*((void *)v134 + 2);
          if (v131)
          {
            int BytesPerRow = CVPixelBufferGetBytesPerRow(v131);
            int v151 = CVPixelBufferGetDataSize(*((CVPixelBufferRef *)v134 + 2));
            unsigned int v152 = 0;
            goto LABEL_27;
          }
        }
LABEL_28:
        BOOL v33 = 0;
        if (PixelFormatType != 875704438
          && PixelFormatType != 2016686640
          && PixelFormatType != 2037741171)
        {
          BOOL v33 = v143 != 2 || BYTE8(v142) != 0;
        }
        BOOL v158 = v33;
        uint64_t v35 = CVPixelBufferGetIOSurface(v28[3]);
        IOSurfaceID v159 = IOSurfaceGetID(v35);
        int v160 = CVPixelBufferGetDataSize(v28[3]);
        uint64_t v36 = v134;
        size_t v37 = (__CVBuffer *)*((void *)v134 + 4);
        if (v37)
        {
          unint64_t v38 = CVPixelBufferGetIOSurface(v37);
          v162[195] = IOSurfaceGetID(v38);
          v162[196] = CVPixelBufferGetDataSize(*((CVPixelBufferRef *)v134 + 4));
          uint64_t v36 = v134;
        }
        LODWORD(v39) = *((_DWORD *)v36 + 236);
        if (v39)
        {
          unint64_t v40 = 0;
          do
          {
            uint64_t v41 = &v36[8 * v40];
            uint64_t v43 = (__CVBuffer *)*((void *)v41 + 5);
            uint64_t v42 = (CVPixelBufferRef *)(v41 + 40);
            OSType v44 = CVPixelBufferGetPixelFormatType(v43);
            uint64_t v45 = CVPixelBufferGetIOSurface(*v42);
            uint64_t v46 = &inputStruct[2 * v40];
            *((_DWORD *)v46 + 18) = IOSurfaceGetID(v45);
            int FrameFormatMetaInfo = H16ISP::getFrameFormatMetaInfo(v44, &v140);
            int v48 = DWORD1(v140);
            if (!FrameFormatMetaInfo) {
              int v48 = 0;
            }
            *((_DWORD *)v46 + 98) = v48;
            if (!v48 || (v48 != 15 ? (BOOL v49 = v141 == 2) : (BOOL v49 = 1), v49)) {
              int v50 = CVPixelBufferGetBytesPerRowOfPlane(*v42, 0);
            }
            else {
              int v50 = CVPixelBufferGetBytesPerRow(*v42);
            }
            uint64_t v51 = (double *)&v134[32 * v40];
            unsigned int v52 = v51[28];
            unsigned int v53 = v51[29];
            double v54 = v51[30];
            double v55 = v51[31];
            uint64_t v56 = &inputStruct[2 * v40];
            v56[78] = v50;
            v56[118] = v52;
            v56[138] = v53;
            v56[158] = v54;
            v56[178] = v55;
            uint64_t v57 = &inputStruct[v40];
            v57[396] = CVPixelBufferGetWidth(*v42);
            v57[416] = CVPixelBufferGetHeight(*v42);
            v57[436] = *(_DWORD *)&v134[4 * v40 + 864];
            int v58 = *((_DWORD *)v46 + 98);
            if (v58 != 15 && v58)
            {
              time_t v62 = *v42;
              if (v141 == 2)
              {
                int v63 = CVPixelBufferGetIOSurface(v62);
                int v64 = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
                int v65 = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
                int v66 = IOSurfaceGetAllocSize(v63);
                v162[2 * v40] = v65 - v64;
                unsigned int v61 = v66 - (v65 - v64);
              }
              else
              {
                int v67 = CVPixelBufferGetBytesPerRow(v62);
                int v68 = CVPixelBufferGetHeight(*v42);
                unsigned int v61 = 0;
                v162[2 * v40] = v68 * v67;
              }
            }
            else
            {
              int v59 = CVPixelBufferGetBytesPerRowOfPlane(*v42, 0);
              v162[2 * v40] = CVPixelBufferGetHeight(*v42) * v59;
              int v60 = CVPixelBufferGetBytesPerRowOfPlane(*v42, 1uLL);
              unsigned int v61 = (CVPixelBufferGetHeight(*v42) * v60) >> 1;
            }
            BOOL v69 = 0;
            v162[2 * v40 + 1] = v61;
            uint64_t v36 = v134;
            if (v44 != 875704438 && v44 != 2016686640 && v44 != 2037741171) {
              BOOL v69 = v141 != 2 || BYTE8(v140) != 0;
            }
            *((unsigned char *)&v162[190] + v40++) = v69;
            unint64_t v39 = *((unsigned int *)v134 + 236);
          }
          while (v40 < v39);
        }
        inputStruct[0] = *(_WORD *)v36;
        __int16 v71 = inputStruct[0];
        int v72 = *((_DWORD *)v36 + 1);
        int v161 = v39;
        int v145 = v72;
        int v163 = H16ISP::H16ISPGeneralProcessFrameReceiver::FrameDone;
        bzero(__src, 0xE08uLL);
        LOWORD(__src[0]) = v71;
        extraRowsOnBottouint64_t m = 0;
        size_t extraColumnsOnRight = 0;
        BOOL v73 = v143 == 2;
        BYTE2(__src[0]) = v143 == 2;
        WORD2(__src[0]) = 1;
        uint64_t v75 = (__CVBuffer *)*((void *)v36 + 1);
        __int16 v74 = (CVPixelBufferRef *)(v36 + 8);
        CVPixelBufferGetExtendedPixels(v75, 0, &extraColumnsOnRight, 0, &extraRowsOnBottom);
        __int16 v76 = CVPixelBufferGetIOSurface(*v74);
        size_t PlaneCount = CVPixelBufferGetPlaneCount(*v74);
        if (v143 == 2)
        {
          unint64_t v78 = PlaneCount;
          if (PlaneCount)
          {
            size_t v79 = 0;
            unsigned int v80 = 1;
            do
            {
              int v81 = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
              int BaseAddressOfCompressedTileHeaderRegionOfPlane = IOSurfaceGetBaseAddressOfCompressedTileHeaderRegionOfPlane();
              *((_DWORD *)&__src[1] + 7 * v79) = 0;
              __int32 v83 = IOSurfaceGetBytesPerRowOfTileDataOfPlane();
              char v84 = (int32x2_t *)((char *)&__src[1] + 28 * v79);
              v84->i32[1] = v83;
              v84[1] = vdup_n_s32(BaseAddressOfCompressedTileHeaderRegionOfPlane - v81);
              v84[2].i32[0] = *(&DataSize + v79) - (BaseAddressOfCompressedTileHeaderRegionOfPlane - v81);
              __int16 WidthOfPlane = IOSurfaceGetWidthOfPlane(v76, v79);
              *((_WORD *)&__src[3] + 14 * v79 + 2) = extraColumnsOnRight + WidthOfPlane;
              __int16 HeightOfPlane = IOSurfaceGetHeightOfPlane(v76, v79);
              *((_WORD *)&__src[3] + 14 * v79 + 3) = extraRowsOnBottom + HeightOfPlane;
              *((_DWORD *)&__src[4] + 7 * v79) = IOSurfaceGetCompressionFootprintOfPlane();
              size_t v79 = v80;
              BOOL v87 = v78 > v80++;
            }
            while (v87);
            BOOL v73 = 1;
          }
          BYTE2(__src[0]) = v73;
        }
        char v88 = v134;
        unsigned int v89 = (__CVBuffer *)*((void *)v134 + 2);
        if (v89)
        {
          WORD2(__src[0]) = 2;
          CVPixelBufferGetExtendedPixels(v89, 0, &extraColumnsOnRight, 0, &extraRowsOnBottom);
          unsigned __int16 v90 = CVPixelBufferGetIOSurface(*((CVPixelBufferRef *)v134 + 2));
          OSType v91 = CVPixelBufferGetPixelFormatType(*((CVPixelBufferRef *)v134 + 2));
          size_t v92 = CVPixelBufferGetPlaneCount(*((CVPixelBufferRef *)v134 + 2));
          int v93 = H16ISP::getFrameFormatMetaInfo(v91, &v135);
          int v94 = v136 == 2 ? v93 : 0;
          char v88 = v134;
          if (v94 == 1)
          {
            if (v92)
            {
              size_t v95 = 0;
              unsigned int v96 = 1;
              do
              {
                int v97 = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
                int v98 = IOSurfaceGetBaseAddressOfCompressedTileHeaderRegionOfPlane();
                *((_DWORD *)&__src[15] + 7 * v95) = 0;
                __int32 v99 = IOSurfaceGetBytesPerRowOfTileDataOfPlane();
                uint64_t v100 = (int32x2_t *)((char *)__src + 28 * v95);
                v100[15].i32[1] = v99;
                v100[16] = vdup_n_s32(v98 - v97);
                v100[17].i32[0] = *(&DataSize + v95) - (v98 - v97);
                __int16 v101 = IOSurfaceGetWidthOfPlane(v90, v95);
                *((_WORD *)&__src[17] + 14 * v95 + 2) = extraColumnsOnRight + v101;
                __int16 v102 = IOSurfaceGetHeightOfPlane(v90, v95);
                *((_WORD *)&__src[17] + 14 * v95 + 3) = extraRowsOnBottom + v102;
                *((_DWORD *)&__src[18] + 7 * v95) = IOSurfaceGetCompressionFootprintOfPlane();
                size_t v95 = v96;
                BOOL v87 = v92 > v96++;
              }
              while (v87);
              BOOL v73 = 1;
              char v88 = v134;
            }
            BYTE2(__src[0]) = v73;
          }
        }
        int v103 = *((_DWORD *)v88 + 236);
        HIWORD(__src[0]) = v103;
        if (v103)
        {
          unsigned __int16 v104 = 0;
          char v105 = BYTE3(__src[0]);
          do
          {
            int8x16_t v106 = (CVPixelBufferRef *)&v88[8 * v104];
            int16x8_t v107 = v106[5];
            v106 += 5;
            int16x8_t v108 = CVPixelBufferGetIOSurface(v107);
            OSType v109 = CVPixelBufferGetPixelFormatType(*v106);
            size_t v110 = CVPixelBufferGetPlaneCount(*v106);
            CVPixelBufferGetExtendedPixels(*v106, 0, &extraColumnsOnRight, 0, &extraRowsOnBottom);
            H16ISP::getFrameFormatMetaInfo(v109, &v140);
            if (v110)
            {
              size_t v111 = 0;
              unsigned int v112 = 1;
              do
              {
                if (v141 == 2)
                {
                  int v113 = IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane();
                  int v114 = IOSurfaceGetBaseAddressOfCompressedTileHeaderRegionOfPlane();
                  *((_DWORD *)&__src[14 * v104 + 225] + 7 * v111) = 0;
                  __int32 v115 = IOSurfaceGetBytesPerRowOfTileDataOfPlane();
                  int8x16_t v116 = (int32x2_t *)((char *)&__src[14 * v104] + 28 * v111);
                  v116[225].i32[1] = v115;
                  v116[226] = vdup_n_s32(v114 - v113);
                  v116[227].i32[0] = *(_DWORD *)&inputStruct[4 * v104 + 76 + 2 * v111] - (v114 - v113);
                  __int16 v117 = IOSurfaceGetWidthOfPlane(v108, v111);
                  *((_WORD *)&__src[14 * v104 + 227] + 14 * v111 + 2) = extraColumnsOnRight + v117;
                  __int16 v118 = IOSurfaceGetHeightOfPlane(v108, v111);
                  *((_WORD *)&__src[14 * v104 + 227] + 14 * v111 + 3) = extraRowsOnBottom + v118;
                  *((_DWORD *)&__src[14 * v104 + 228] + 7 * v111) = IOSurfaceGetCompressionFootprintOfPlane();
                  char v105 = 1;
                }
                else
                {
                  char v105 = 0;
                }
                size_t v111 = v112;
                BOOL v87 = v110 > v112++;
              }
              while (v87);
            }
            ++v104;
            char v88 = v134;
          }
          while (*((_DWORD *)v134 + 236) > v104);
          BYTE3(__src[0]) = v105;
        }
        uint64_t v119 = (CVPixelBufferRef *)(v88 + 24);
        CVPixelBufferLockBaseAddress(*((CVPixelBufferRef *)v88 + 3), 0);
        BaseAddress = (char *)CVPixelBufferGetBaseAddress(*v119);
        memcpy(&BaseAddress[*((unsigned int *)BaseAddress + 7)], __src, 0xE08uLL);
        CVPixelBufferUnlockBaseAddress(*v119, 0);
        if ((v133 & 1) == 0) {
          operator new();
        }
        uint64_t v11 = H16ISP::H16ISPDevice::ISP_GeneralProcess(*(void *)(v7 + 288), inputStruct, 0);
        pthread_mutex_unlock(v132);
        return v11;
      }
    }
  }
LABEL_6:
  uint64_t v11 = 3758097090;
  pthread_mutex_unlock(v8);
  return v11;
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::FrameDone(uint64_t this, void *a2, void *a3, unint64_t *a4)
{
  if (this)
  {
    int v4 = (int)a4;
    int v6 = (int)a2;
    uint64_t v7 = this;
    int v8 = (pthread_mutex_t *)(this + 112);
    pthread_mutex_lock((pthread_mutex_t *)(this + 112));
    unint64_t v9 = *(void *)(v7 + 328);
    uint64_t v10 = *(void *)(v7 + 304);
    uint64_t v11 = *(void *)(v7 + 312);
    uint64_t v12 = v10 + 8 * (v9 >> 9);
    if (v11 == v10) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = (char *)(*(void *)v12 + 8 * (*(void *)(v7 + 328) & 0x1FFLL));
    }
LABEL_6:
    uint64_t v14 = v13;
    while (1)
    {
      uint64_t v15 = v11 == v10
          ? 0
          : *(void *)(v10 + (((*(void *)(v7 + 336) + v9) >> 6) & 0x3FFFFFFFFFFFFF8))
          + 8 * ((*(void *)(v7 + 336) + v9) & 0x1FF);
      if (v14 == (char *)v15) {
        break;
      }
      uint64_t v16 = *(void *)v14;
      if (*(void *)v14 && a3[2] == *(_DWORD *)(v16 + 1400))
      {
        std::deque<H16ISP::H16ISPFrameReceiverBufferPool *>::erase((int64x2_t *)(v7 + 296), (char *)v12, v13);
        *(_DWORD *)(v16 + 948) = v6;
        if (v4 < 5)
        {
          uint64_t v18 = 0;
          *(void *)(v16 + 952) = 0;
        }
        else
        {
          *(void *)(v16 + 952) = a3[3];
          uint64_t v18 = a3[4];
        }
        *(void *)(v16 + 960) = v18;
        uint64_t v19 = *(void (**)(void, uint64_t))(v7 + 16);
        if (v19) {
          v19(*(void *)(v7 + 24), v16);
        }
        int v20 = *(__CVBuffer **)(v16 + 8);
        if (v20) {
          CVPixelBufferRelease(v20);
        }
        size_t v21 = *(__CVBuffer **)(v16 + 16);
        if (v21) {
          CVPixelBufferRelease(v21);
        }
        size_t v22 = *(__CVBuffer **)(v16 + 24);
        if (v22) {
          CVPixelBufferRelease(v22);
        }
        unsigned int v23 = *(__CVBuffer **)(v16 + 208);
        if (v23) {
          CVPixelBufferRelease(v23);
        }
        unsigned int v24 = *(__CVBuffer **)(v16 + 200);
        if (v24) {
          CVPixelBufferRelease(v24);
        }
        int v25 = *(__CVBuffer **)(v16 + 32);
        if (v25) {
          CVPixelBufferRelease(v25);
        }
        if (*(_DWORD *)(v16 + 944))
        {
          unint64_t v26 = 0;
          do
            CVPixelBufferRelease(*(CVPixelBufferRef *)(v16 + 40 + 8 * v26++));
          while (v26 < *(unsigned int *)(v16 + 944));
        }
        MEMORY[0x24C53D6E0](v16, 0x10E0C400629D57DLL);
        if (*(void *)(v7 + 336)) {
          H16ISP::H16ISPGeneralProcessFrameReceiver::tickleNoDataTimer((pthread_mutex_t *)v7);
        }
        else {
          H16ISP::H16ISPGeneralProcessFrameReceiver::stopNoDataTimer((H16ISP::H16ISPGeneralProcessFrameReceiver *)v7);
        }
        if (*(unsigned char *)(v7 + 184) && !*(void *)(v7 + 336)) {
          dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v7 + 176));
        }
        break;
      }
      v14 += 8;
      v13 += 8;
      if ((char *)(*(void *)v12 + 4096) == v13)
      {
        unint64_t v17 = *(char **)(v12 + 8);
        v12 += 8;
        uint64_t v13 = v17;
        goto LABEL_6;
      }
    }
    return pthread_mutex_unlock(v8);
  }
  return this;
}

void std::deque<H16ISP::H16ISPGeneralProcessFrameReceiverRequest *>::push_back(void *a1, void *a2)
{
  uint64_t v4 = a1[2];
  uint64_t v5 = a1[1];
  if (v4 == v5) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = ((v4 - v5) << 6) - 1;
  }
  uint64_t v7 = a1[5];
  unint64_t v8 = v7 + a1[4];
  if (v6 == v8)
  {
    std::deque<H16ISP::H16ISPGeneralProcessFrameReceiverRequest *>::__add_back_capacity(a1);
    uint64_t v5 = a1[1];
    uint64_t v7 = a1[5];
    unint64_t v8 = a1[4] + v7;
  }
  *(void *)(*(void *)(v5 + ((v8 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v8 & 0x1FF)) = *a2;
  a1[5] = v7 + 1;
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::startNoDataTimer(H16ISP::H16ISPGeneralProcessFrameReceiver *this)
{
  unsigned int v2 = H16ISP::H16ISPGetCFPreferenceNumber(@"EnableISPBringup", @"com.apple.coremedia", 0);
  pthread_mutex_lock((pthread_mutex_t *)this + 3);
  char v3 = (__CFRunLoopTimer *)*((void *)this + 32);
  if (v3)
  {
    CFRunLoopTimerInvalidate(v3);
    CFRelease(*((CFTypeRef *)this + 32));
    *((void *)this + 32) = 0;
  }
  context.version = 0;
  context.mach_timebase_info info = this;
  memset(&context.retain, 0, 24);
  double v4 = CFAbsoluteTimeGetCurrent() + *((double *)this + 44);
  double v5 = 200.0;
  if (!v2) {
    double v5 = 0.0;
  }
  uint64_t v6 = CFRunLoopTimerCreate(0, v5 + v4, 0.0, 0, 0, (CFRunLoopTimerCallBack)H16ISP::H16ISPGeneralProcessFrameReceiver::NoDataTimeout, &context);
  *((void *)this + 32) = v6;
  if (v6) {
    CFRunLoopAddTimer(*((CFRunLoopRef *)this + 1), v6, (CFRunLoopMode)*MEMORY[0x263EFFE88]);
  }
  return pthread_mutex_unlock((pthread_mutex_t *)this + 3);
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::GeneralProcessGeneric(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6 = (pthread_mutex_t *)(a1 + 48);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 48));
  if (*(unsigned char *)(a1 + 344) || *(_DWORD *)a1 != 1)
  {
    pthread_mutex_unlock(v6);
    return 3758097122;
  }
  else
  {
    if (*(void *)(a2 + 208))
    {
      uint64_t v7 = *(__CVBuffer **)(a2 + 200);
      if (v7)
      {
        uint64_t v8 = *(unsigned int *)(a2 + 944);
        if ((v8 - 21) >= 0xFFFFFFEC)
        {
          uint64_t v11 = 0;
          uint64_t v12 = 8 * v8;
          while (*(void *)(a2 + v11 + 40))
          {
            v11 += 8;
            if (v12 == v11)
            {
              if ((a3 & 1) == 0)
              {
                CVPixelBufferRetain(v7);
                CVPixelBufferRetain(*(CVPixelBufferRef *)(a2 + 208));
                uint64_t v13 = *(__CVBuffer **)(a2 + 32);
                if (v13) {
                  CVPixelBufferRetain(v13);
                }
                if (*(_DWORD *)(a2 + 944))
                {
                  unint64_t v14 = 0;
                  do
                    CVPixelBufferRetain(*(CVPixelBufferRef *)(a2 + 40 + 8 * v14++));
                  while (v14 < *(unsigned int *)(a2 + 944));
                }
              }
              bzero(inputStruct, 0x478uLL);
              IOSurface = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)(a2 + 208));
              IOSurfaceID ID = IOSurfaceGetID(IOSurface);
              int DataSize = CVPixelBufferGetDataSize(*(CVPixelBufferRef *)(a2 + 208));
              uint64_t v16 = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)(a2 + 200));
              IOSurfaceID v41 = IOSurfaceGetID(v16);
              int v42 = CVPixelBufferGetDataSize(*(CVPixelBufferRef *)(a2 + 200));
              unint64_t v17 = *(__CVBuffer **)(a2 + 32);
              if (v17)
              {
                uint64_t v18 = CVPixelBufferGetIOSurface(v17);
                IOSurfaceID v43 = IOSurfaceGetID(v18);
                int v44 = CVPixelBufferGetDataSize(*(CVPixelBufferRef *)(a2 + 32));
              }
              LODWORD(v19) = *(_DWORD *)(a2 + 944);
              if (v19)
              {
                uint64_t v20 = 0;
                size_t v21 = v46;
                uint64_t v22 = 216;
                do
                {
                  uint64_t v23 = a2 + 8 * v20;
                  unsigned int v24 = CVPixelBufferGetIOSurface(*(CVPixelBufferRef *)(v23 + 40));
                  *(_DWORD *)(v21 - 46) = IOSurfaceGetID(v24);
                  PixelFormatType = (H16ISP *)CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)(v23 + 40));
                  int FrameFormat = H16ISP::getFrameFormat(PixelFormatType);
                  *(_DWORD *)(v21 - 26) = FrameFormat;
                  *(_DWORD *)(v21 - 34) = CVPixelBufferGetBytesPerRowOfPlane(*(CVPixelBufferRef *)(v23 + 40), 0);
                  *(int32x4_t *)(v21 - 22) = vuzp1q_s32((int32x4_t)vcvtq_u64_f64(*(float64x2_t *)(a2 + 32 * v20 + 224)), (int32x4_t)vcvtq_u64_f64(*(float64x2_t *)(a2 + 32 * v20 + 240)));
                  *((_WORD *)v21 - 3) = CVPixelBufferGetWidth(*(CVPixelBufferRef *)(v23 + 40));
                  *((_WORD *)v21 - 2) = CVPixelBufferGetHeight(*(CVPixelBufferRef *)(v23 + 40));
                  OSType v27 = CVPixelBufferGetPixelFormatType(*(CVPixelBufferRef *)(v23 + 40));
                  *((_WORD *)v21 - 1) = *(_DWORD *)(a2 + 4 * v22);
                  double v28 = *(__CVBuffer **)(v23 + 40);
                  if (FrameFormat)
                  {
                    int BytesPerRow = CVPixelBufferGetBytesPerRow(v28);
                    int Height = CVPixelBufferGetHeight(*(CVPixelBufferRef *)(v23 + 40));
                    unsigned int v31 = 0;
                    *(_DWORD *)(v21 - 42) = Height * BytesPerRow;
                  }
                  else
                  {
                    int BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(v28, 0);
                    *(_DWORD *)(v21 - 42) = CVPixelBufferGetHeight(*(CVPixelBufferRef *)(v23 + 40)) * BytesPerRowOfPlane;
                    int v33 = CVPixelBufferGetBytesPerRowOfPlane(*(CVPixelBufferRef *)(v23 + 40), 1uLL);
                    unsigned int v31 = (CVPixelBufferGetHeight(*(CVPixelBufferRef *)(v23 + 40)) * v33) >> 1;
                  }
                  *(_DWORD *)(v21 - 38) = v31;
                  BOOL v35 = v27 != 2037741171 && v27 != 875704438;
                  *size_t v21 = v35;
                  v21 += 48;
                  ++v20;
                  unint64_t v19 = *(unsigned int *)(a2 + 944);
                  unint64_t v36 = v22 - 215;
                  ++v22;
                }
                while (v36 < v19);
              }
              int v45 = v19;
              __int16 v38 = *(_DWORD *)a2;
              *(void *)&v46[918] = H16ISP::H16ISPGeneralProcessFrameReceiver::FrameDone;
              if ((a3 & 1) == 0) {
                operator new();
              }
              uint64_t v9 = H16ISP::H16ISPDevice::ISP_GeneralProcessGeneric(*(void *)(a1 + 288), inputStruct, 0);
              goto LABEL_7;
            }
          }
        }
      }
    }
    uint64_t v9 = 3758097090;
LABEL_7:
    pthread_mutex_unlock(v6);
  }
  return v9;
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::tickleNoDataTimer(pthread_mutex_t *this)
{
  unsigned int v2 = this + 3;
  pthread_mutex_lock(this + 3);
  uint64_t sig = (__CFRunLoopTimer *)this[4].__sig;
  if (sig)
  {
    CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
    CFRunLoopTimerSetNextFireDate(sig, Current + *(double *)&this[5].__opaque[24]);
  }

  return pthread_mutex_unlock(v2);
}

uint64_t H16ISP::H16ISPGeneralProcessFrameReceiver::NoDataTimeout(H16ISP::H16ISPGeneralProcessFrameReceiver *this, __CFRunLoopTimer *a2, void *a3)
{
  uint64_t result = puts("H16ISPGeneralProcessFrameReceiver::NoDataTimeout!");
  uint64_t v5 = *((void *)a2 + 38);
  uint64_t v6 = *((void *)a2 + 39);
  uint64_t v7 = (void *)(v5 + 8 * (*((void *)a2 + 41) >> 9));
  if (v6 == v5) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = (const void **)(*v7 + 8 * (*((void *)a2 + 41) & 0x1FFLL));
  }
  while (1)
  {
    if (v6 == v5)
    {
      uint64_t v10 = 0;
    }
    else
    {
      unint64_t v9 = *((void *)a2 + 42) + *((void *)a2 + 41);
      uint64_t v10 = *(void *)(v5 + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v9 & 0x1FF);
    }
    if (v8 == (const void **)v10) {
      break;
    }
    uint64_t v11 = *v8++;
    uint64_t result = printf("H16ISPGeneralProcessFrameReceiver: Request not returned 0x%p\n", v11);
    if ((const void **)((char *)v8 - *v7) == (const void **)4096)
    {
      uint64_t v12 = (const void **)v7[1];
      ++v7;
      uint64_t v8 = v12;
    }
    uint64_t v5 = *((void *)a2 + 38);
    uint64_t v6 = *((void *)a2 + 39);
  }
  uint64_t v13 = (uint64_t (*)(void, void, void, void, void, uint64_t))*((void *)a2 + 4);
  if (v13)
  {
    uint64_t v14 = *((void *)a2 + 5);
    return v13(0, 0, 0, 0, 0, v14);
  }
  return result;
}

uint64_t H16ISP::CreateH16ISPGeneralProcessFrameReceiver(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  pthread_t v5 = 0;
  H16ISP::H16ISPThreadReadySyncer::H16ISPThreadReadySyncer((H16ISP::H16ISPThreadReadySyncer *)&v11);
  uint64_t v6 = 0;
  long long v2 = *(_OWORD *)(a1 + 32);
  long long v7 = *(_OWORD *)(a1 + 16);
  long long v8 = v2;
  uint64_t v9 = *(void *)(a1 + 8);
  uint64_t v10 = &v11;
  pthread_attr_init(&v12);
  pthread_attr_setdetachstate(&v12, 2);
  pthread_create(&v5, &v12, (void *(__cdecl *)(void *))H16ISP::H16ISPGeneralProcessFrameReceiverRTThreadStart, &v6);
  pthread_attr_destroy(&v12);
  H16ISP::H16ISPThreadReadySyncer::wait(&v11);
  **(void **)a1 = v6;
  if (v6) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = 3758097084;
  }
  H16ISP::H16ISPThreadReadySyncer::~H16ISPThreadReadySyncer((H16ISP::H16ISPThreadReadySyncer *)&v11);
  return v3;
}

void sub_24698112C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

void H16ISP::H16ISPGeneralProcessFrameReceiverRTThreadStart(uint64_t a1)
{
  pthread_setname_np("H16ISPGeneralProcessFrameReceiverRealTimeThread");
  long long v2 = pthread_self();
  uint64_t v3 = (H16ISP *)pthread_mach_thread_np(v2);
  H16ISP::H16ISPSetMachThreadPriority(v3, 47);
  H16ISP::H16ISPThreadReadySyncer::lock(*(pthread_mutex_t **)(a1 + 48));
  operator new();
}

void sub_24698121C(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x10A0C4053130460);
  _Unwind_Resume(a1);
}

uint64_t H16ISP::DestroyH16ISPGeneralProcessFrameReceiver(H16ISP *this, H16ISP::H16ISPGeneralProcessFrameReceiver *a2)
{
  uint64_t v3 = (void *)*((void *)this + 1);
  CFRetain(v3);
  H16ISP::H16ISPGeneralProcessFrameReceiver::~H16ISPGeneralProcessFrameReceiver(this);
  MEMORY[0x24C53D6E0]();
  CFRunLoopStop((CFRunLoopRef)v3);
  CFRelease(v3);
  return 0;
}

void std::deque<H16ISP::H16ISPGeneralProcessFrameReceiverRequest *>::__add_back_capacity(void *a1)
{
  unint64_t v2 = a1[4];
  BOOL v3 = v2 >= 0x200;
  unint64_t v4 = v2 - 512;
  if (v3)
  {
    uint64_t v5 = (uint64_t)(a1 + 3);
    uint64_t v6 = (char *)a1[3];
    a1[4] = v4;
    long long v7 = (void *)a1[1];
    long long v8 = (char *)a1[2];
    uint64_t v11 = *v7;
    uint64_t v9 = (char *)(v7 + 1);
    uint64_t v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(void *)long long v8 = v10;
      a1[2] += 8;
      return;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v33 = 1;
      }
      else {
        unint64_t v33 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::allocator<__CVBuffer **>::allocate_at_least[abi:ne180100](v5, v33);
      BOOL v35 = &v34[8 * (v33 >> 2)];
      size_t v37 = &v34[8 * v36];
      __int16 v38 = (uint64_t *)a1[1];
      long long v8 = v35;
      uint64_t v39 = a1[2] - (void)v38;
      if (v39)
      {
        long long v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v40 = 8 * (v39 >> 3);
        IOSurfaceID v41 = &v34[8 * (v33 >> 2)];
        do
        {
          uint64_t v42 = *v38++;
          *(void *)IOSurfaceID v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    uint64_t v13 = v12 >> 3;
    BOOL v14 = v12 >> 3 < -1;
    uint64_t v15 = (v12 >> 3) + 2;
    if (v14) {
      uint64_t v16 = v15;
    }
    else {
      uint64_t v16 = v13 + 1;
    }
    uint64_t v17 = -(v16 >> 1);
    uint64_t v18 = v16 >> 1;
    unint64_t v19 = &v9[-8 * v18];
    int64_t v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      uint64_t v9 = (char *)a1[1];
    }
    long long v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  uint64_t v21 = a1[2];
  unint64_t v22 = (v21 - a1[1]) >> 3;
  uint64_t v23 = a1[3];
  uint64_t v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(void *)&long long v54 = operator new(0x1000uLL);
      std::__split_buffer<__CVBuffer **>::push_back(a1, &v54);
      return;
    }
    *(void *)&long long v54 = operator new(0x1000uLL);
    std::__split_buffer<__CVBuffer **>::push_front((uint64_t)a1, &v54);
    int v44 = (void *)a1[1];
    long long v8 = (char *)a1[2];
    uint64_t v45 = *v44;
    uint64_t v9 = (char *)(v44 + 1);
    uint64_t v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3]) {
      goto LABEL_33;
    }
    uint64_t v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1) {
        unint64_t v46 = 1;
      }
      else {
        unint64_t v46 = (uint64_t)&v8[-*a1] >> 2;
      }
      uint64_t v34 = (char *)std::allocator<__CVBuffer **>::allocate_at_least[abi:ne180100]((uint64_t)(a1 + 3), v46);
      BOOL v35 = &v34[8 * (v46 >> 2)];
      size_t v37 = &v34[8 * v47];
      int v48 = (uint64_t *)a1[1];
      long long v8 = v35;
      uint64_t v49 = a1[2] - (void)v48;
      if (v49)
      {
        long long v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        uint64_t v50 = 8 * (v49 >> 3);
        uint64_t v51 = &v34[8 * (v46 >> 2)];
        do
        {
          uint64_t v52 = *v48++;
          *(void *)uint64_t v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      IOSurfaceID v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        long long v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1) {
    unint64_t v25 = 1;
  }
  else {
    unint64_t v25 = v24 >> 2;
  }
  uint64_t v56 = a1 + 3;
  *(void *)&long long v54 = std::allocator<__CVBuffer **>::allocate_at_least[abi:ne180100]((uint64_t)(a1 + 3), v25);
  *((void *)&v54 + 1) = v54 + 8 * v22;
  *(void *)&long long v55 = *((void *)&v54 + 1);
  *((void *)&v55 + 1) = v54 + 8 * v26;
  unsigned int v53 = operator new(0x1000uLL);
  std::__split_buffer<__CVBuffer **>::push_back(&v54, &v53);
  OSType v27 = (void *)a1[2];
  uint64_t v28 = -7 - (void)v27;
  while (v27 != (void *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<__CVBuffer **>::push_front((uint64_t)&v54, v27);
  }
  uint64_t v29 = (char *)*a1;
  long long v30 = v54;
  long long v31 = v55;
  *(void *)&long long v54 = *a1;
  *((void *)&v54 + 1) = v27;
  long long v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  long long v55 = v32;
  if (v27 != (void *)v32) {
    *(void *)&long long v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  }
  if (v29) {
    operator delete(v29);
  }
}

void sub_246981568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  operator delete(v13);
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

BOOL GMC_FaceCoverageTest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, double *a6)
{
  bzero(*(void **)(a4 + 8), (*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16)));
  *a5 = 0;
  int v12 = *(_DWORD *)(a3 + 16);
  int v13 = *(_DWORD *)(a3 + 20);
  unsigned int v14 = v13 * v12;
  if (!(v13 * v12)) {
    GMC_ExtractTestSamples();
  }
  if (v14 <= 2) {
    GMC_ExtractTestSamples();
  }
  if (v14 == 3) {
    GMC_ExtractTestSamples();
  }
  unint64_t v15 = *(unsigned int *)(a1 + 20);
  if (v15)
  {
    unsigned int v16 = 0;
    unint64_t v17 = 0;
    uint64_t v18 = *(double **)(a3 + 8);
    double v19 = *v18 + v18[2];
    double v20 = v18[1] + v18[3];
    double v21 = 0.0;
    double v22 = 1.0e10;
    double v23 = 0.0;
    double v24 = 1.0e10;
    do
    {
      unsigned int v25 = *(_DWORD *)(a1 + 16);
      if (!v25) {
        MatrixNxPts<3u,double>::CloneColumn();
      }
      unsigned int v26 = *(_DWORD *)(a3 + 20) * *(_DWORD *)(a3 + 16);
      if (!v26) {
        GMC_ExtractTestSamples();
      }
      uint64_t v27 = *(void *)(a1 + 8);
      double v28 = *(double *)(v27 + 8 * v17);
      uint64_t v29 = *(double **)(a3 + 8);
      if (v28 > *v29 && v28 < v19)
      {
        if (v25 <= 1) {
          MatrixNxPts<3u,double>::CloneColumn();
        }
        if (v26 <= 1) {
          GMC_ExtractTestSamples();
        }
        double v31 = *(double *)(v27 + 8 * v15 + 8 * v17);
        if (v31 > v29[1] && v31 < v20)
        {
          if (v17 >= (*(_DWORD *)(a4 + 20) * *(_DWORD *)(a4 + 16))) {
            GMC_ExtractTestSamples();
          }
          *(unsigned char *)(*(void *)(a4 + 8) + v17) = 1;
          unint64_t v33 = (double *)(*(void *)(a1 + 8) + 8 * v17);
          if (*v33 < v24) {
            double v24 = *v33;
          }
          if (*v33 > v23) {
            double v23 = *v33;
          }
          double v34 = v33[v15];
          if (v34 < v22) {
            double v22 = v33[v15];
          }
          if (v34 > v21) {
            double v21 = v33[v15];
          }
          *a5 = ++v16;
          unint64_t v15 = *(unsigned int *)(a1 + 20);
        }
      }
      ++v17;
    }
    while (v17 < v15);
    int v12 = *(_DWORD *)(a3 + 16);
    int v13 = *(_DWORD *)(a3 + 20);
    double v35 = (v23 - v24) * (v21 - v22);
  }
  else
  {
    unsigned int v16 = 0;
    double v35 = 1.0e20;
  }
  unsigned int v36 = v13 * v12;
  if (v36 <= 2) {
    GMC_ExtractTestSamples();
  }
  if (v36 == 3) {
    GMC_ExtractTestSamples();
  }
  double v37 = v35 / (*(double *)(*(void *)(a3 + 8) + 16) * *(double *)(*(void *)(a3 + 8) + 24));
  *a6 = v37;
  return v37 > *(double *)(a2 + 712) && v16 > *(_DWORD *)(a2 + 720);
}

void runGmcOnGmsBuffer(uint64_t a1, int a2)
{
}

void runGmcOnGmsPoints(uint64_t a1, int a2)
{
}

void sub_246982E64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  Matrix<double>::~Matrix((uint64_t)&a51);
  Matrix<double>::~Matrix((uint64_t)&a55);
  Matrix<double>::~Matrix((uint64_t)&a59);
  Matrix<double>::~Matrix((uint64_t)&a63);
  _GMC_Params::~_GMC_Params((_GMC_Params *)&a67);
  _Unwind_Resume(a1);
}

void _GMC_Params::~_GMC_Params(_GMC_Params *this)
{
  unint64_t v2 = (char *)this + 776;
  Matrix<double>::~Matrix((uint64_t)this + 872);
  Matrix<double>::~Matrix((uint64_t)this + 840);
  Matrix<double>::~Matrix((uint64_t)this + 808);
  Matrix<double>::~Matrix((uint64_t)v2);
  Matrix<double>::~Matrix((uint64_t)this + 744);
  Matrix<double>::~Matrix((uint64_t)this + 256);
  Matrix<double>::~Matrix((uint64_t)this + 224);
  Matrix<double>::~Matrix((uint64_t)this + 192);
  Matrix<double>::~Matrix((uint64_t)this + 160);
  Matrix<double>::~Matrix((uint64_t)this + 128);
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::onActivate(H16ISP::H16ISPGraphVIOCameraControlNode *this)
{
  unint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    unint64_t v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unint64_t v4 = 0;
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::onActivate\n", v4, 2u);
  }
  return H16ISP::H16ISPGraphVIOCameraControlNode::InitVIO(this);
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::InitVIO(H16ISP::H16ISPGraphVIOCameraControlNode *this)
{
  uint64_t v102 = *MEMORY[0x263EF8340];
  unint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  BOOL v3 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    unint64_t v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO\n\n", buf, 2u);
  }
  int v4 = CVHWAFeatureExtractionCreate();
  if (v4)
  {
    int v5 = v4;
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    uint64_t v7 = 3758097084;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v97 = v5;
      long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - CVHWAFeatureExtractionCreate failed: %d\n\n";
LABEL_20:
      uint64_t v11 = buf;
LABEL_21:
      int v12 = v6;
LABEL_22:
      uint32_t v13 = 8;
LABEL_23:
      _os_log_impl(&dword_24680F000, v12, OS_LOG_TYPE_DEFAULT, v8, v11, v13);
      return v7;
    }
    return v7;
  }
  bzero(v82, 0x10uLL);
  __int16 v83 = 12551;
  int v84 = *((_DWORD *)this + 24);
  __int16 v85 = *((_WORD *)this + 120) << 10;
  char v86 = *((unsigned char *)this + 262);
  uint64_t v9 = H16ISP::H16ISPDevice::ISP_SendCommand(*((H16ISP::H16ISPDevice **)this + 10), v82, 0x10u, 0, 0xFFFFFFFF);
  if (v9)
  {
    uint64_t v7 = v9;
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v97 = v7;
      long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - sCIspCmdChVIODownScaleFactorSet failed: 0x%08X\n\n";
      goto LABEL_20;
    }
    return v7;
  }
  bzero(v77, 0x14uLL);
  __int16 v78 = 12549;
  int v79 = *((_DWORD *)this + 24);
  int v80 = 1;
  int v81 = *((_DWORD *)this + 64);
  uint64_t v10 = H16ISP::H16ISPDevice::ISP_SendCommand(*((H16ISP::H16ISPDevice **)this + 10), v77, 0x14u, 0, 0xFFFFFFFF);
  if (v10)
  {
    uint64_t v7 = v10;
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v97 = v7;
      long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - sCIspCmdChVioEnable failed: 0x%08X\n\n";
      goto LABEL_20;
    }
    return v7;
  }
  bzero(buf, 0x2CuLL);
  LOWORD(v97) = 12550;
  int v98 = *((_DWORD *)this + 24);
  uint64_t v7 = H16ISP::H16ISPDevice::ISP_SendCommand(*((H16ISP::H16ISPDevice **)this + 10), buf, 0x2Cu, 0, 0xFFFFFFFF);
  unint64_t v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (v7)
  {
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      unint64_t v15 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v15;
    }
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v93 = 67109120;
      LODWORD(v94) = v7;
      long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - sCIspCmdChVioInputConfigGet failed: 0x%08X\n\n";
      uint64_t v11 = v93;
      int v12 = v15;
      goto LABEL_22;
    }
    return v7;
  }
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
  {
    unint64_t v15 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v15;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v99;
    _os_log_impl(&dword_24680F000, v15, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - cmdChVioInputConfigGet.width: %d\n\n", v93, 8u);
    unint64_t v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (v15 == v3)
  {
    unint64_t v15 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v15;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v101;
    _os_log_impl(&dword_24680F000, v15, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - cmdChVioInputConfigGet.height: %d\n\n", v93, 8u);
    unint64_t v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (v15 == v3)
  {
    unint64_t v15 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v15;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v100;
    _os_log_impl(&dword_24680F000, v15, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - cmdChVioInputConfigGet.bufferStride: %d\n\n", v93, 8u);
    unint64_t v15 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (v15 == v3)
  {
    unint64_t v15 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v15;
  }
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = *((_DWORD *)this + 67);
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v16;
    _os_log_impl(&dword_24680F000, v15, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - vioParams.keypointDetectionFlow: %d\n\n", v93, 8u);
  }
  if (H16ISP::H16ISPGetCFPreferenceNumber(@"EnableVIODebug", @"com.apple.coremedia", 0)) {
    int v17 = v100 * v101;
  }
  else {
    int v17 = 0;
  }
  int v18 = CVHWAFeatureExtractionConfigCreate();
  if (v18)
  {
    int v19 = v18;
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return v7;
    }
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v19;
    long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - CVHWAFeatureExtractionConfigCreate failed: %d\n\n";
    goto LABEL_95;
  }
  CVHWAFeatureExtractionConfigSetImageSize();
  CVHWAFeatureExtractionConfigSetMaxImageSize();
  CVHWAFeatureExtractionConfigSetNumberOfOctaves();
  CVHWAFeatureExtractionConfigSetTargetNumberOfKeypoints();
  CVHWAFeatureExtractionConfigSetMaxNumberOfKeypoints();
  CVHWAFeatureExtractionConfigSetResponseThreshold();
  CVHWAFeatureExtractionConfigSetEnableParedGrid();
  CVHWAFeatureExtractionConfigSetEnableOrientationAssignment();
  CVHWAFeatureExtractionConfigSetEnableDynamicThresholding();
  CVHWAFeatureExtractionConfigSetDetectionFlow();
  CVHWAFeatureExtractionConfigSetDisablePostProcessing();
  CVHWAFeatureExtractionConfigSetSigmaDistanceThreshold();
  CVHWAFeatureExtractionConfigSetSquareDistanceDisparityFraction();
  CVHWAFeatureExtractionConfigSetHammingDistanceThreshold();
  CVHWAFeatureExtractionConfigSetOrientationDistanceThreshold();
  CVHWAFeatureExtractionConfigSetFeatureMatchingDescriptorSize();
  CVHWAFeatureExtractionConfigSetEnableFeatureMatching();
  CVHWAFeatureExtractionConfigSetExtraTestThreshold();
  int inited = CVHWAFeatureExtractionInitDirectWithLacc();
  if (inited)
  {
    int v21 = inited;
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return v7;
    }
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v21;
    long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - CVHWAFeatureExtractionInitDirect failed: %d\n\n";
    goto LABEL_95;
  }
  *((void *)this + 16) = CVHWAFeatureExtractionGetActionBuffer();
  *((void *)this + 17) = CVHWAFeatureExtractionGetOperationBuffer();
  *((_DWORD *)this + 38) = CVHWAFeatureExtractionGetActionSizeInBytes();
  *((_DWORD *)this + 39) = CVHWAFeatureExtractionGetOperationSizeInBytes();
  *((_DWORD *)this + 40) = CVHWAFeatureExtractionGetOutputSizeInBytes();
  *((_DWORD *)this + 41) = CVHWAFeatureExtractionGetOutputReserveSizeInBytes();
  *((unsigned char *)this + 172) = CVHWAFeatureExtractionGetDynamicThresholdingEnable();
  *((_DWORD *)this + 44) = CVHWAFeatureExtractionGetDynamicThresholdingTargetKeypointsConfigCount();
  *((void *)this + 18) = CVHWAFeatureExtractionGetLaccBuffer();
  uint64_t v22 = 0;
  *((_DWORD *)this + 42) = CVHWAFeatureExtractionGetLaccSizeInBytes();
  do
    *((_DWORD *)this + v22++ + 45) = CVHWAFeatureExtractionGetDynamicThresholdingTargetKeypointsAtIndex();
  while (v22 != 9);
  double v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
  {
    double v23 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v23;
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (*((void *)this + 16)) {
      double v24 = "Yes";
    }
    else {
      double v24 = "No";
    }
    int v25 = *((_DWORD *)this + 38);
    *(_DWORD *)int v93 = 136315394;
    int v94 = v24;
    LOWORD(v95) = 1024;
    *(_DWORD *)((char *)&v95 + 2) = v25;
    _os_log_impl(&dword_24680F000, v23, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - action buffer: %s, actionSizeInBytes: %d\n\n", v93, 0x12u);
    double v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (v23 == v3)
  {
    double v23 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v23;
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (*((void *)this + 17)) {
      unsigned int v26 = "Yes";
    }
    else {
      unsigned int v26 = "No";
    }
    int v27 = *((_DWORD *)this + 39);
    *(_DWORD *)int v93 = 136315394;
    int v94 = v26;
    LOWORD(v95) = 1024;
    *(_DWORD *)((char *)&v95 + 2) = v27;
    _os_log_impl(&dword_24680F000, v23, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - operation buffer: %s, operationSizeInBytes: %d\n\n", v93, 0x12u);
    double v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (v23 == v3)
  {
    double v23 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v23;
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v28 = *((_DWORD *)this + 40);
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v28;
    _os_log_impl(&dword_24680F000, v23, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - outputSizeInBytes: %d\n\n", v93, 8u);
    double v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (v23 == v3)
  {
    double v23 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v23;
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = *((_DWORD *)this + 41);
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v29;
    _os_log_impl(&dword_24680F000, v23, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - keypointAndDescriptorSizeInBytes: %d\n\n", v93, 8u);
    double v23 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (v23 == v3)
  {
    double v23 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v23;
  }
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    if (*((void *)this + 18)) {
      long long v30 = "Yes";
    }
    else {
      long long v30 = "No";
    }
    int v31 = *((_DWORD *)this + 42);
    *(_DWORD *)int v93 = 136315394;
    int v94 = v30;
    LOWORD(v95) = 1024;
    *(_DWORD *)((char *)&v95 + 2) = v31;
    _os_log_impl(&dword_24680F000, v23, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - lacc buffer: %s, laccSizeInBytes: %d\n\n", v93, 0x12u);
  }
  bzero(v73, 0x10uLL);
  __int16 v74 = 12545;
  int v32 = *((_DWORD *)this + 40);
  int v75 = *((_DWORD *)this + 24);
  int v76 = v32;
  uint64_t v33 = H16ISP::H16ISPDevice::ISP_SendCommand(*((H16ISP::H16ISPDevice **)this + 10), v73, 0x10u, 0, 0xFFFFFFFF);
  if (v33)
  {
    uint64_t v7 = v33;
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      return v7;
    }
    *(_DWORD *)int v93 = 67109120;
    LODWORD(v94) = v7;
    long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - sCIspCmdChVioBlobSize failed: 0x%08X\n\n";
LABEL_95:
    uint64_t v11 = v93;
    goto LABEL_21;
  }
  bzero(v93, 0x14uLL);
  LOWORD(v94) = 12546;
  unsigned int v34 = *((_DWORD *)this + 41);
  HIDWORD(v94) = *((_DWORD *)this + 24);
  unint64_t v95 = __PAIR64__(v17, v34);
  uint64_t v35 = H16ISP::H16ISPDevice::ISP_SendCommand(*((H16ISP::H16ISPDevice **)this + 10), v93, 0x14u, 0, 0xFFFFFFFF);
  if (!v35)
  {
    unsigned int v36 = (__CVBuffer *)*((void *)this + 16);
    if (v36 && *((_DWORD *)this + 38))
    {
      CVPixelBufferLockBaseAddress(v36, 0);
      if (CVPixelBufferGetBaseAddress(*((CVPixelBufferRef *)this + 16))) {
        operator new[]();
      }
      double v37 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
      {
        double v37 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v37;
      }
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v89 = 0;
        _os_log_impl(&dword_24680F000, v37, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - CVPixelBufferGetBaseAddress for action buffer returned NULL\n\n", v89, 2u);
      }
      CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)this + 16), 0);
    }
    __int16 v38 = (__CVBuffer *)*((void *)this + 17);
    if (v38 && *((_DWORD *)this + 39))
    {
      CVPixelBufferLockBaseAddress(v38, 0);
      if (CVPixelBufferGetBaseAddress(*((CVPixelBufferRef *)this + 17))) {
        operator new[]();
      }
      uint64_t v39 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
      {
        uint64_t v39 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v39;
      }
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v89 = 0;
        _os_log_impl(&dword_24680F000, v39, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - CVPixelBufferGetBaseAddress for operation buffer returned NULL\n\n", v89, 2u);
      }
      CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)this + 17), 0);
    }
    uint64_t v40 = (__CVBuffer *)*((void *)this + 18);
    if (v40)
    {
      CVPixelBufferLockBaseAddress(v40, 0);
      if (CVPixelBufferGetBaseAddress(*((CVPixelBufferRef *)this + 18))) {
        operator new[]();
      }
      IOSurfaceID v41 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
      {
        IOSurfaceID v41 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v41;
      }
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v89 = 0;
        _os_log_impl(&dword_24680F000, v41, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - CVPixelBufferGetBaseAddress for lacc buffer returned NULL\n\n", v89, 2u);
      }
      CVPixelBufferUnlockBaseAddress(*((CVPixelBufferRef *)this + 18), 0);
    }
    uint64_t v42 = (__CVBuffer *)*((void *)this + 16);
    if (v42)
    {
      CVPixelBufferRelease(v42);
      *((void *)this + 16) = 0;
    }
    IOSurfaceID v43 = (__CVBuffer *)*((void *)this + 17);
    if (v43)
    {
      CVPixelBufferRelease(v43);
      *((void *)this + 17) = 0;
    }
    int v44 = (__CVBuffer *)*((void *)this + 37);
    if (v44)
    {
      CVPixelBufferRelease(v44);
      *((void *)this + 37) = 0;
    }
    uint64_t v45 = (__CVBuffer *)*((void *)this + 18);
    if (v45)
    {
      CVPixelBufferRelease(v45);
      *((void *)this + 18) = 0;
    }
    bzero(v89, 0x10uLL);
    LOWORD(v90) = 12547;
    int v91 = *((_DWORD *)this + 24);
    uint64_t v46 = H16ISP::H16ISPDevice::ISP_SendCommand(*((H16ISP::H16ISPDevice **)this + 10), v89, 0x10u, 0, 0xFFFFFFFF);
    if (v46)
    {
      uint64_t v7 = v46;
      uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
      {
        uint64_t v6 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
      }
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
        return v7;
      }
      *(_DWORD *)BOOL v87 = 67109120;
      *(_DWORD *)char v88 = v7;
      long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - sCIspCmdChVioOutputBufferSize failed: 0x%08X\n\n";
    }
    else
    {
      float v48 = *((float *)this + 55);
      if (v48 <= 0.0)
      {
        *((_DWORD *)this + 55) = 1114636288;
        float v48 = 60.0;
      }
      v49.i32[0] = *((_DWORD *)this + 56);
      if (v49.f32[0] <= 0.0)
      {
        *((float *)this + 56) = v48;
        v49.f32[0] = v48;
      }
      float v50 = *((float *)this + 57);
      if (v50 <= 0.0)
      {
        *((float *)this + 57) = v48;
        float v50 = v48;
      }
      *(float *)v47.i32 = (float)v48;
      v49.f32[1] = v50;
      *((uint32x2_t *)this + 40) = vmax_u32(vcvt_u32_f32(vdiv_f32((float32x2_t)vdup_lane_s32(v47, 0), v49)), (uint32x2_t)0x100000001);
      HIDWORD(v51) = 1083129856;
      float v52 = 1.0 / v48 * 1000.0;
      LODWORD(v51) = *((_DWORD *)this + 58);
      unsigned int v53 = ((double)v51 / v52);
      *((_DWORD *)this + 82) = v53;
      *((_DWORD *)this + 83) = v53;
      long long v54 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
      {
        long long v54 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v54;
      }
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        double v55 = *((float *)this + 55);
        *(_DWORD *)BOOL v87 = 134217984;
        *(double *)char v88 = v55;
        _os_log_impl(&dword_24680F000, v54, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - vioParams.streamFrameRate=%.3f\n\n", v87, 0xCu);
        long long v54 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      }
      if (v54 == v3)
      {
        long long v54 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v54;
      }
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        double v56 = *((float *)this + 56);
        *(_DWORD *)BOOL v87 = 134217984;
        *(double *)char v88 = v56;
        _os_log_impl(&dword_24680F000, v54, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - vioParams.vioFrameRate=%.3f\n\n", v87, 0xCu);
        long long v54 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      }
      if (v54 == v3)
      {
        long long v54 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v54;
      }
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        double v57 = *((float *)this + 57);
        *(_DWORD *)BOOL v87 = 134217984;
        *(double *)char v88 = v57;
        _os_log_impl(&dword_24680F000, v54, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - vioParams.vioBurstFrameRate=%.3f\n\n", v87, 0xCu);
        long long v54 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      }
      if (v54 == v3)
      {
        long long v54 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v54;
      }
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        int v58 = *((_DWORD *)this + 80);
        *(_DWORD *)BOOL v87 = 67109120;
        *(_DWORD *)char v88 = v58;
        _os_log_impl(&dword_24680F000, v54, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - decimationFactorForVIOFrameRate=%d\n\n", v87, 8u);
        long long v54 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      }
      if (v54 == v3)
      {
        long long v54 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v54;
      }
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        int v59 = *((_DWORD *)this + 81);
        *(_DWORD *)BOOL v87 = 67109120;
        *(_DWORD *)char v88 = v59;
        _os_log_impl(&dword_24680F000, v54, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - decimationFactorForBurstFrameRate=%d\n\n", v87, 8u);
        long long v54 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      }
      if (v54 == v3)
      {
        long long v54 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v54;
      }
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        int v60 = *((_DWORD *)this + 82);
        *(_DWORD *)BOOL v87 = 67109120;
        *(_DWORD *)char v88 = v60;
        _os_log_impl(&dword_24680F000, v54, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - numFramesForBurstMode=%d\n\n", v87, 8u);
        long long v54 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      }
      if (v54 == v3)
      {
        long long v54 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v54;
      }
      BOOL v61 = os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT);
      int v62 = *((_DWORD *)this + 83);
      if (v61)
      {
        *(_DWORD *)BOOL v87 = 67109120;
        *(_DWORD *)char v88 = v62;
        _os_log_impl(&dword_24680F000, v54, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::InitVIO - remainingBurstModeFrames=%d\n\n", v87, 8u);
        int v62 = *((_DWORD *)this + 83);
      }
      BOOL v63 = v62 == 0;
      uint64_t v64 = 324;
      if (v63) {
        uint64_t v64 = 320;
      }
      uint64_t v65 = H16ISP::H16ISPGraphVIOCameraControlNode::SetVIORunTimeParameters(this, *(_DWORD *)((char *)this + v64), *((_DWORD *)this + 62), *((unsigned __int8 *)this + 172), (unsigned int *)this + 45);
      if (v65)
      {
        uint64_t v7 = v65;
        uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
        {
          uint64_t v6 = os_log_create("com.apple.isp", "general");
          GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
        }
        if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
          return v7;
        }
        *(_DWORD *)BOOL v87 = 67109120;
        *(_DWORD *)char v88 = v7;
        long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - SetVIORunTimeParameters failed: 0x%08X\n\n";
      }
      else
      {
        uint64_t v66 = H16ISP::H16ISPDevice::SuspendVio(*((H16ISP::H16ISPDevice **)this + 10), *((_DWORD *)this + 24), *((unsigned __int8 *)this + 217));
        if (v66)
        {
          uint64_t v7 = v66;
          int v67 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
          {
            int v67 = os_log_create("com.apple.isp", "general");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v67;
          }
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
          {
            int v68 = *((unsigned __int8 *)this + 217);
            *(_DWORD *)BOOL v87 = 67109376;
            *(_DWORD *)char v88 = v68;
            *(_WORD *)&v88[4] = 1024;
            *(_DWORD *)&v88[6] = v7;
            long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - SuspendVio(%d) failed: 0x%08X\n\n";
            uint64_t v11 = v87;
            int v12 = v67;
            uint32_t v13 = 14;
            goto LABEL_23;
          }
          return v7;
        }
        H16ISP::H16ISPDevice::GetPoolInfo(*((H16ISP::H16ISPDevice **)this + 10), *((_DWORD *)this + 24), 24, (_DWORD *)this + 25, 0);
        if (v69)
        {
          uint64_t v7 = v69;
          uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
          {
            uint64_t v6 = os_log_create("com.apple.isp", "general");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
          }
          if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
            return v7;
          }
          *(_DWORD *)BOOL v87 = 67109120;
          *(_DWORD *)char v88 = v7;
          long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - GetPoolInfo failed: 0x%08X\n\n";
        }
        else
        {
          unsigned int v71 = 0;
          unsigned int v72 = 0;
          H16ISP::H16ISPGetYUVSBufferParamsForDataBufferSize(v92, &v72, &v71, v70);
          if (!*((_DWORD *)this + 63)) {
            *((_DWORD *)this + 63) = 1;
          }
          uint64_t v7 = H16ISP::H16ISPFrameReceiver::addBufferPoolToFrameReceiver(*((void *)this + 11), 24, *((_DWORD *)this + 25));
          if (!v7) {
            return v7;
          }
          uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
          if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
          {
            uint64_t v6 = os_log_create("com.apple.isp", "general");
            GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
          }
          if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
            return v7;
          }
          *(_DWORD *)BOOL v87 = 67109120;
          *(_DWORD *)char v88 = v7;
          long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - addBufferPoolToFrameReceiver failed: 0x%08X\n\n";
        }
      }
    }
    uint64_t v11 = v87;
    goto LABEL_21;
  }
  uint64_t v7 = v35;
  uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
  {
    uint64_t v6 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)unsigned int v89 = 67109120;
    int v90 = v7;
    long long v8 = "H16ISPGraphVIOCameraControlNode::InitVIO - sCIspCmdChVioMetaReserve failed: 0x%08X\n\n";
    uint64_t v11 = v89;
    goto LABEL_21;
  }
  return v7;
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::onDeactivate(H16ISP::H16ISPGraphVIOCameraControlNode *this)
{
  unint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    unint64_t v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::onDeactivate\n\n", v4, 2u);
  }
  H16ISP::H16ISPGraphVIOCameraControlNode::DeInitVIO(this);
  return 0;
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::DeInitVIO(H16ISP::H16ISPGraphVIOCameraControlNode *this)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  unint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v3 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    unint64_t v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 0;
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::DeInitVIO\n\n", (uint8_t *)v8, 2u);
  }
  bzero(v8, 0x14uLL);
  v8[2] = 12549;
  int v9 = *((_DWORD *)this + 24);
  int v10 = 0;
  int v4 = H16ISP::H16ISPDevice::ISP_SendCommand(*((H16ISP::H16ISPDevice **)this + 10), (unsigned __int8 *)v8, 0x14u, 0, 0xFFFFFFFF);
  if (v4)
  {
    int v5 = v4;
    uint64_t v6 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v3)
    {
      uint64_t v6 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v6;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v12 = v5;
      _os_log_impl(&dword_24680F000, v6, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::DeInitVIO - sCIspCmdChVioEnable (false) failed: 0x%08X\n\n", buf, 8u);
    }
  }
  if (*((void *)this + 14)) {
    CVHWAFeatureExtractionRelease();
  }
  if (*((void *)this + 15)) {
    CVHWAFeatureExtractionConfigRelease();
  }
  return 0;
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::onMessageProcessing(H16ISP::H16ISPGraphVIOCameraControlNode *this, H16ISP::H16ISPFilterGraphMessage *a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  int v4 = (pthread_mutex_t *)((char *)a2 + 8);
  pthread_mutex_lock((pthread_mutex_t *)((char *)a2 + 8));
  uint64_t v5 = *((unsigned int *)a2 + 25);
  if (v5)
  {
    uint64_t v6 = (_DWORD *)((char *)a2 + 112);
    while (*v6 != 24)
    {
      v6 += 4;
      if (!--v5) {
        goto LABEL_5;
      }
    }
    uint64_t v7 = (__CVBuffer *)*((void *)v6 - 1);
    CVPixelBufferRetain(v7);
  }
  else
  {
LABEL_5:
    uint64_t v7 = 0;
  }
  pthread_mutex_unlock(v4);
  int v8 = *((_DWORD *)this + 83);
  if (v8
    && (int v9 = v8 - 1, (*((_DWORD *)this + 83) = v9) == 0)
    && (int v14 = H16ISP::H16ISPGraphVIOCameraControlNode::SetVIORunTimeParameters(this, *((_DWORD *)this + 80), -1, *((unsigned __int8 *)this + 172), (unsigned int *)this + 45)) != 0)
  {
    int v15 = v14;
    int v16 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      int v16 = os_log_create("com.apple.isp", "general");
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v16;
    }
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 136315394;
      int v18 = "onMessageProcessing";
      __int16 v19 = 1024;
      int v20 = v15;
      _os_log_impl(&dword_24680F000, v16, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::%s - SetVIORunTimeParameters failed: 0x%08X\n\n", (uint8_t *)&v17, 0x12u);
    }
  }
  else if (v7)
  {
    int v10 = CVHWAFeatureExtractionProcessHwOutputs();
    if (v10)
    {
      int v11 = v10;
      int v12 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
      {
        int v12 = os_log_create("com.apple.isp", "general");
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v12;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v17 = 67109120;
        LODWORD(v18) = v11;
        _os_log_impl(&dword_24680F000, v12, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::onMessageProcessing - CVHWAFeatureExtractionProcessHwOutputs failed: %d\n\n", (uint8_t *)&v17, 8u);
      }
    }
    CVPixelBufferRelease(v7);
  }
  return 0;
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::SetVIORunTimeParameters(H16ISP::H16ISPGraphVIOCameraControlNode *this, int a2, int a3, int a4, unsigned int *a5)
{
  *((_DWORD *)this + 62) = a3;
  bzero(v12, 0x3CuLL);
  __int16 v13 = 12548;
  int v14 = *((_DWORD *)this + 24);
  int v15 = a2;
  int v16 = a3;
  int v17 = a4;
  if (a5)
  {
    long long v10 = *((_OWORD *)a5 + 1);
    long long v18 = *(_OWORD *)a5;
    long long v19 = v10;
    unsigned int v20 = a5[8];
  }
  return H16ISP::H16ISPDevice::ISP_SendCommand(*((H16ISP::H16ISPDevice **)this + 10), v12, 0x3Cu, 0, 0xFFFFFFFF);
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::TriggerBurstMode(H16ISP::H16ISPGraphVIOCameraControlNode *this)
{
  int v1 = *((_DWORD *)this + 82);
  *((_DWORD *)this + 83) = v1;
  if (v1) {
    return H16ISP::H16ISPGraphVIOCameraControlNode::SetVIORunTimeParameters(this, *((_DWORD *)this + 81), -1, *((unsigned __int8 *)this + 172), (unsigned int *)this + 45);
  }
  else {
    return 0;
  }
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::UpdateKeypointDetectionThreshold(H16ISP::H16ISPGraphVIOCameraControlNode *this, int a2)
{
  *((_DWORD *)this + 62) = a2;
  return H16ISP::H16ISPGraphVIOCameraControlNode::SetVIORunTimeParameters(this, -1, a2, *((unsigned __int8 *)this + 172), (unsigned int *)this + 45);
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::Suspend(uint64_t this)
{
  *(unsigned char *)(this + 217) = 1;
  if (*(unsigned char *)(this + 16)) {
    return H16ISP::H16ISPDevice::SuspendVio(*(H16ISP::H16ISPDevice **)(this + 80), *(_DWORD *)(this + 96), 1);
  }
  return this;
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::Resume(uint64_t this)
{
  *(unsigned char *)(this + 217) = 0;
  if (*(unsigned char *)(this + 16)) {
    return H16ISP::H16ISPDevice::SuspendVio(*(H16ISP::H16ISPDevice **)(this + 80), *(_DWORD *)(this + 96), 0);
  }
  return this;
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::AdjustStreamFrameRate(H16ISP::H16ISPGraphVIOCameraControlNode *this, float a2, double a3)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  *((float *)this + 55) = a2;
  if (!*((unsigned char *)this + 16)) {
    goto LABEL_9;
  }
  *(float *)&a3 = a2;
  if (a2 <= 0.0)
  {
    *((_DWORD *)this + 55) = 1114636288;
    LODWORD(a3) = 1114636288;
  }
  v5.i32[0] = *((_DWORD *)this + 56);
  if (v5.f32[0] <= 0.0)
  {
    *((_DWORD *)this + 56) = LODWORD(a3);
    v5.i32[0] = LODWORD(a3);
  }
  float v6 = *((float *)this + 57);
  if (v6 <= 0.0)
  {
    *((_DWORD *)this + 57) = LODWORD(a3);
    float v6 = *(float *)&a3;
  }
  *(float *)&a3 = (float)*(float *)&a3;
  v5.f32[1] = v6;
  uint32x2_t v7 = vmax_u32(vcvt_u32_f32(vdiv_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0), v5)), (uint32x2_t)0x100000001);
  *((uint32x2_t *)this + 40) = v7;
  if (!*((_DWORD *)this + 83)) {
    uint64_t v8 = H16ISP::H16ISPGraphVIOCameraControlNode::SetVIORunTimeParameters(this, v7.i32[0], -1, *((unsigned __int8 *)this + 172), (unsigned int *)this + 45);
  }
  else {
LABEL_9:
  }
    uint64_t v8 = 0;
  int v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    int v9 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v9;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *((_DWORD *)this + 80);
    int v12 = 134218496;
    double v13 = a2;
    __int16 v14 = 1024;
    int v15 = v10;
    __int16 v16 = 1024;
    int v17 = v8;
    _os_log_impl(&dword_24680F000, v9, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode::AdjustStreamFrameRate - newStreamFrameRate=%.3f, decimationFactorForVIOFrameRate=%d, res=0x%08X\n\n", (uint8_t *)&v12, 0x18u);
  }
  return v8;
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::SetFrameReceiver(uint64_t this, H16ISP::H16ISPFrameReceiver *a2)
{
  *(void *)(this + 88) = a2;
  return this;
}

uint64_t H16ISP::H16ISPGraphVIOCameraControlNode::H16ISPGraphVIOCameraControlNode(uint64_t a1, uint64_t a2, int a3, const void *a4)
{
  H16ISP::H16ISPFilterGraphNode::H16ISPFilterGraphNode(a1, 9);
  void *v8 = &unk_26FAECD70;
  int v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    int v9 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v9;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v11 = 0;
    _os_log_impl(&dword_24680F000, v9, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode Constructor\n\n", v11, 2u);
  }
  mach_timebase_info((mach_timebase_info_t)(a1 + 104));
  *(void *)(a1 + 80) = a2;
  *(_DWORD *)(a1 + 96) = a3;
  memmove((void *)(a1 + 216), a4, 0x68uLL);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  return a1;
}

void sub_246984F78(_Unwind_Exception *a1)
{
  H16ISP::H16ISPFilterGraphNode::~H16ISPFilterGraphNode(v1);
  _Unwind_Resume(a1);
}

void H16ISP::H16ISPGraphVIOCameraControlNode::~H16ISPGraphVIOCameraControlNode(H16ISP::H16ISPGraphVIOCameraControlNode *this)
{
  *(void *)this = &unk_26FAECD70;
  unint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    unint64_t v2 = os_log_create("com.apple.isp", "general");
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v2;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "H16ISPGraphVIOCameraControlNode Destructor\n\n", v3, 2u);
  }
  H16ISP::H16ISPFilterGraphNode::~H16ISPFilterGraphNode(this);
}

{
  uint64_t vars8;

  H16ISP::H16ISPGraphVIOCameraControlNode::~H16ISPGraphVIOCameraControlNode(this);

  JUMPOUT(0x24C53D6E0);
}

uint64_t ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 48) >= 9u) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(*(_DWORD *)(a2 + 48));
  }
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 52) >= 4u) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(*(_DWORD *)(a2 + 52));
  }
  tb_message_encode_u32();

  return tb_message_encode_BOOL();
}

uint64_t ispirexclavekitmodule_ispexclavecorechrunkitaerslt__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 48) = 0;
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 52) = 0;
  return tb_message_decode_BOOL();
}

uint64_t ispirexclavekitmodule_ispexclavecorechrunkitaersltv2__encode(uint64_t a1, unsigned int *a2)
{
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (a2[13] >= 9) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(a2[13]);
  }
  tb_message_encode_u32();
  if (a2[14] >= 4) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(a2[14]);
  }
  tb_message_encode_u32();
  if (a2[15] >= 3) {
    ispirexclavekitmodule_ispexclavecorechrunkitaersltv2__encode_cold_1(a2[15]);
  }

  return tb_message_encode_u32();
}

uint64_t ispirexclavekitmodule_ispexclavecorechrunkitaersltv2__decode(uint64_t a1, _DWORD *a2)
{
  tb_message_decode_u32();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  a2[13] = 0;
  tb_message_decode_u32();
  a2[14] = 0;
  tb_message_decode_u32();
  uint64_t result = 0;
  a2[15] = 0;
  return result;
}

uint64_t ispirexclavekitmodule_ispexclavecorechsensormetadata__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s16();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 72) >= 9u) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(*(_DWORD *)(a2 + 72));
  }
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 76) >= 4u) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(*(_DWORD *)(a2 + 76));
  }
  tb_message_encode_u32();
  tb_message_encode_u32();

  return tb_message_encode_u32();
}

uint64_t ispirexclavekitmodule_ispexclavecorechsensormetadata__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 72) = 0;
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 76) = 0;
  tb_message_decode_u32();
  return tb_message_decode_u32();
}

uint64_t ispirexclavekitmodule_ispexclavecorechsensormetadata2__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s16();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 72) >= 9u) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(*(_DWORD *)(a2 + 72));
  }
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 76) >= 4u) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(*(_DWORD *)(a2 + 76));
  }
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_BOOL();
  for (uint64_t i = 0; i != 36; i += 4)
    uint64_t result = tb_message_encode_f32();
  return result;
}

uint64_t ispirexclavekitmodule_ispexclavecorechsensormetadata2__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s16();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 72) = 0;
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 76) = 0;
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_BOOL();
  for (uint64_t i = 0; i != 36; i += 4)
    uint64_t result = tb_message_decode_f32();
  return result;
}

uint64_t ispirexclavekitmodule_ispexclavecorechsensormetadatav3__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s16();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 80) >= 9u) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(*(_DWORD *)(a2 + 80));
  }
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 84) >= 4u) {
    ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(*(_DWORD *)(a2 + 84));
  }
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_BOOL();
  for (uint64_t i = 0; i != 36; i += 4)
    tb_message_encode_f32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();

  return tb_message_encode_u32();
}

uint64_t ispirexclavekitmodule_ispexclavecorechsensormetadatav3__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u64();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s16();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 80) = 0;
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 84) = 0;
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_BOOL();
  for (uint64_t i = 0; i != 36; i += 4)
    tb_message_decode_f32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  return tb_message_decode_u32();
}

uint64_t ispirexclavekitmodule_ispexclavecoreexclavechcameraconfigset__encode()
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u16();
  tb_message_encode_u32();
  tb_message_encode_u8();
  tb_message_encode_u16();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u32();

  return tb_message_encode_u32();
}

uint64_t ispirexclavekitmodule_ispexclavecorechinfoset__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_BOOL();
  if (*(_DWORD *)(a2 + 12) >= 4u) {
    ispirexclavekitmodule_ispexclavecorechinfoset__encode_cold_1(*(_DWORD *)(a2 + 12));
  }
  tb_message_encode_u32();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s8();
  for (uint64_t i = 0; i != 12; i += 4)
    uint64_t result = tb_message_encode_f32();
  return result;
}

uint64_t ispirexclavekitmodule_ispexclavecorechinfoset__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_BOOL();
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 12) = 0;
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s8();
  for (uint64_t i = 0; i != 12; i += 4)
    uint64_t result = tb_message_decode_f32();
  return result;
}

uint64_t ispirexclavekitmodule_ispexclavecorechinfoset2__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_BOOL();
  if (*(_DWORD *)(a2 + 12) >= 4u) {
    ispirexclavekitmodule_ispexclavecorechinfoset__encode_cold_1(*(_DWORD *)(a2 + 12));
  }
  tb_message_encode_u32();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s8();
  for (uint64_t i = 0; i != 12; i += 4)
    tb_message_encode_f32();
  for (uint64_t j = 0; j != 12; j += 4)
    tb_message_encode_f32();
  for (uint64_t k = 0; k != 36; k += 4)
    tb_message_encode_f32();
  for (uint64_t m = 0; m != 12; m += 4)
    tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 116) >= 0x11u) {
    ispirexclavekitmodule_ispexclavecorechinfoset2__encode_cold_1(*(_DWORD *)(a2 + 116));
  }

  return tb_message_encode_u32();
}

uint64_t ispirexclavekitmodule_ispexclavecorechinfoset2__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_BOOL();
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 12) = 0;
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s8();
  for (uint64_t i = 0; i != 12; i += 4)
    tb_message_decode_f32();
  for (uint64_t j = 0; j != 12; j += 4)
    tb_message_decode_f32();
  for (uint64_t k = 0; k != 36; k += 4)
    tb_message_decode_f32();
  for (uint64_t m = 0; m != 12; m += 4)
    tb_message_decode_f32();
  tb_message_decode_u32();
  uint64_t result = 0;
  *(_DWORD *)(a2 + 116) = 0;
  return result;
}

uint64_t ispirexclavekitmodule_sepipelscconfig__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  uint64_t v3 = a2 + 24;
  uint64_t v4 = 11328;
  do
  {
    v3 += 2;
    uint64_t result = tb_message_encode_u16();
    --v4;
  }
  while (v4);
  return result;
}

uint64_t ispirexclavekitmodule_sepipelscconfig__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  uint64_t v3 = a2 + 24;
  uint64_t v4 = 11328;
  do
  {
    uint64_t result = tb_message_decode_u16();
    v3 += 2;
    --v4;
  }
  while (v4);
  return result;
}

uint64_t ispirexclavekitmodule_sepipepdpconfig__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u8();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  for (uint64_t i = 5; i != 1161; ++i)
    tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u16();
  tb_message_encode_u16();
  uint64_t v4 = a2 + 4656;
  uint64_t v5 = 16;
  do
  {
    tb_message_encode_BOOL();
    tb_message_encode_u8();
    tb_message_encode_u16();
    v4 += 6;
    tb_message_encode_u16();
    --v5;
  }
  while (v5);
  uint64_t v6 = -64;
  do
  {
    tb_message_encode_u16();
    tb_message_encode_u16();
    v6 += 4;
  }
  while (v6);
  uint64_t v7 = -64;
  do
  {
    tb_message_encode_u16();
    tb_message_encode_u16();
    v7 += 4;
  }
  while (v7);
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u16();

  return tb_message_encode_u16();
}

uint64_t ispirexclavekitmodule_sepipepdpconfig__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u8();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  uint64_t v3 = a2 + 20;
  uint64_t v4 = 1156;
  do
  {
    tb_message_decode_u32();
    v3 += 4;
    --v4;
  }
  while (v4);
  tb_message_decode_u32();
  tb_message_decode_u16();
  tb_message_decode_u16();
  uint64_t v5 = a2 + 4652;
  uint64_t v6 = 16;
  do
  {
    tb_message_decode_BOOL();
    tb_message_decode_u8();
    tb_message_decode_u16();
    tb_message_decode_u16();
    v5 += 6;
    --v6;
  }
  while (v6);
  uint64_t v7 = a2 + 4748;
  uint64_t v8 = 16;
  do
  {
    tb_message_decode_u16();
    tb_message_decode_u16();
    v7 += 4;
    --v8;
  }
  while (v8);
  uint64_t v9 = a2 + 4812;
  uint64_t v10 = 16;
  do
  {
    tb_message_decode_u16();
    tb_message_decode_u16();
    v9 += 4;
    --v10;
  }
  while (v10);
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u16();

  return tb_message_decode_u16();
}

uint64_t ispirexclavekitmodule_ispexclavecorechdpcset__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  for (uint64_t i = 0; i != 36; i += 12)
  {
    tb_message_encode_u32();
    tb_message_encode_u32();
    if (*(_DWORD *)(a2 + i + 16) >= 4u) {
      ispirexclavekitmodule_ispexclavecorechdpcset__encode_cold_1(*(_DWORD *)(a2 + i + 16));
    }
    tb_message_encode_u32();
  }
  for (uint64_t j = 0; j != 4096; j += 4)
    uint64_t result = tb_message_encode_u32();
  return result;
}

uint64_t ispirexclavekitmodule_ispexclavecorechdpcset__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  for (uint64_t i = 0; i != 36; i += 12)
  {
    tb_message_decode_u32();
    tb_message_decode_u32();
    tb_message_decode_u32();
    *(_DWORD *)(a2 + i + 16) = 0;
  }
  for (uint64_t j = 0; j != 4096; j += 4)
    uint64_t result = tb_message_decode_u32();
  return result;
}

uint64_t ispirexclavekitmodule_attentioninfo__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_BOOL();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 44) >= 5u) {
    ispirexclavekitmodule_attentioninfo__encode_cold_1(*(_DWORD *)(a2 + 44));
  }

  return tb_message_encode_u32();
}

uint64_t ispirexclavekitmodule_attentioninfo__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_BOOL();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  uint64_t result = 0;
  *(_DWORD *)(a2 + 44) = 0;
  return result;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdon()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdoff()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchstart()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchstop()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchinfoset(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    ispirexclavekitmodule_ispexclavecorechinfoset__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchisconcurrent()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_BOOL();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchinfoset2(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    ispirexclavekitmodule_ispexclavecorechinfoset2__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 8) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 8));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchalgoenable()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitae(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchsensormetadata(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    ispirexclavekitmodule_ispexclavecorechsensormetadata__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdexclavechcameraconfigset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    ispirexclavekitmodule_ispexclavecoreexclavechcameraconfigset__encode();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeframeratemaxset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeframerateminset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaegaincapset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeintegrationtimemaxset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeupdateresume()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeupdatesuspend()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeintegrationgainset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeinitsettingget()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdaeflickerfreqset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u64();
    tb_message_encode_u8();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_f32();
    tb_message_encode_u8();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchlscset(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    ispirexclavekitmodule_sepipelscconfig__encode((uint64_t)v5, a2 + 4);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchpdpset(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    ispirexclavekitmodule_sepipepdpconfig__encode((uint64_t)v5, a2 + 4);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeframeratemaxget()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeframerateminget()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchdpcset(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    ispirexclavekitmodule_ispexclavecorechdpcset__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchsensormetadata2(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    ispirexclavekitmodule_ispexclavecorechsensormetadata2__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchsensormetadatav3(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    ispirexclavekitmodule_ispexclavecorechsensormetadatav3__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitaev2(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeintegrationgainsetv2()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchaeinitsettinggetv2()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkiter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchconfigurationstatusread(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if (*(_DWORD *)(a2 + 4) >= 8u) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchconfigurationstatusread_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitfd(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitad(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitmd(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitmdv2(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitanst(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdexclavebootarg(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    if (*a2 >= 3) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdexclavebootarg_cold_1(*a2);
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdexclavechpropertywrite(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    unsigned int v4 = *(_DWORD *)(a2 + 4);
    if (v4 - 16 >= 0x30 && v4 >= 0xF) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdexclavechpropertywrite_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdexclavechpropertyread(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    unsigned int v4 = *(_DWORD *)(a2 + 4);
    if (v4 - 16 >= 0x30 && v4 >= 0xF) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdexclavechpropertywrite_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmddebugcapability()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdadsettings(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    if (*a2 >= 2) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdadsettings_cold_1(*a2);
    }
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitattn(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    if ((*(_DWORD *)(a2 + 4) - 1) >= 7) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdexclaveisphwirq()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdinfiltration(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    if (*a2 >= 2) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdinfiltration_cold_1(*a2);
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_sendcmdexfiltration(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    if (*a2 >= 2) {
      ispirexclavekitmodule_ispirexclavekit_sendcmdinfiltration_cold_1(*a2);
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_init(uint64_t *a1)
{
  tb_endpoint_set_interface_identifier();
  uint64_t v2 = tb_client_connection_create_with_endpoint();
  uint64_t result = tb_client_connection_activate();
  if (!result) {
    *a1 = v2;
  }
  return result;
}

uint64_t ispirexclavekitmodule_ispirexclavekit_init_static(void *a1, uint64_t a2, uint64_t a3)
{
  tb_endpoint_set_interface_identifier();
  uint64_t result = tb_client_connection_create_with_endpoint_static();
  if (!result)
  {
    uint64_t result = tb_client_connection_activate();
    if (!result) {
      *a1 = a3;
    }
  }
  return result;
}

void *ispirexclavekitmodule_ispirexclavekit__copy(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

void ispirexclavekitmodule_ispirexclavekit__destruct()
{
}

uint64_t ispirexclavekitmodule_ispirexclavekit_server_start(uint64_t a1)
{
  return ispirexclavekitmodule_ispirexclavekit__server_start_owned(a1, &v2);
}

uint64_t ispirexclavekitmodule_ispirexclavekit__server_start_owned(uint64_t a1, uint64_t *a2)
{
  *a2 = tb_service_connection_create_with_endpoint();
  return tb_service_connection_activate();
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke(uint64_t a1, uint64_t a2)
{
}

void ispirexclavekitmodule_ispirexclavekit__server_stop()
{
}

uint64_t ispirexclavekitmodule_ispexclaveproperty__decode(uint64_t a1, _DWORD *a2)
{
  tb_message_decode_u32();
  uint64_t result = 0;
  *a2 = 0;
  return result;
}

uint64_t isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 48) >= 9u) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(*(_DWORD *)(a2 + 48));
  }
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 52) >= 4u) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(*(_DWORD *)(a2 + 52));
  }
  tb_message_encode_u32();

  return tb_message_encode_BOOL();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 48) = 0;
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 52) = 0;
  return tb_message_decode_BOOL();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechrunkitaersltv2__encode(uint64_t a1, unsigned int *a2)
{
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (a2[13] >= 9) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(a2[13]);
  }
  tb_message_encode_u32();
  if (a2[14] >= 4) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(a2[14]);
  }
  tb_message_encode_u32();
  if (a2[15] >= 3) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaersltv2__encode_cold_1(a2[15]);
  }

  return tb_message_encode_u32();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechrunkitaersltv2__decode(uint64_t a1, _DWORD *a2)
{
  tb_message_decode_u32();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  a2[13] = 0;
  tb_message_decode_u32();
  a2[14] = 0;
  tb_message_decode_u32();
  uint64_t result = 0;
  a2[15] = 0;
  return result;
}

uint64_t isprgbexclavekitmodule_ispexclavecorechsensormetadata__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s16();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 72) >= 9u) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(*(_DWORD *)(a2 + 72));
  }
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 76) >= 4u) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(*(_DWORD *)(a2 + 76));
  }
  tb_message_encode_u32();
  tb_message_encode_u32();

  return tb_message_encode_u32();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechsensormetadata__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 72) = 0;
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 76) = 0;
  tb_message_decode_u32();
  return tb_message_decode_u32();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechsensormetadata2__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s16();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 72) >= 9u) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(*(_DWORD *)(a2 + 72));
  }
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 76) >= 4u) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(*(_DWORD *)(a2 + 76));
  }
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_BOOL();
  for (uint64_t i = 0; i != 36; i += 4)
    uint64_t result = tb_message_encode_f32();
  return result;
}

uint64_t isprgbexclavekitmodule_ispexclavecorechsensormetadata2__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s16();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 72) = 0;
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 76) = 0;
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_BOOL();
  for (uint64_t i = 0; i != 36; i += 4)
    uint64_t result = tb_message_decode_f32();
  return result;
}

uint64_t isprgbexclavekitmodule_ispexclavecorechsensormetadatav3__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u64();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s16();
  tb_message_encode_u64();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 80) >= 9u) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(*(_DWORD *)(a2 + 80));
  }
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 84) >= 4u) {
    isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(*(_DWORD *)(a2 + 84));
  }
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_BOOL();
  for (uint64_t i = 0; i != 36; i += 4)
    tb_message_encode_f32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_u32();

  return tb_message_encode_u32();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechsensormetadatav3__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u64();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s16();
  tb_message_decode_u64();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 80) = 0;
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 84) = 0;
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_BOOL();
  for (uint64_t i = 0; i != 36; i += 4)
    tb_message_decode_f32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_u32();
  return tb_message_decode_u32();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechinfoset__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_BOOL();
  if (*(_DWORD *)(a2 + 12) >= 4u) {
    isprgbexclavekitmodule_ispexclavecorechinfoset__encode_cold_1(*(_DWORD *)(a2 + 12));
  }
  tb_message_encode_u32();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s32();

  return tb_message_encode_s8();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechinfoset__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 12) = 0;
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  return tb_message_decode_s8();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechinfoset2__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_BOOL();
  if (*(_DWORD *)(a2 + 12) >= 4u) {
    isprgbexclavekitmodule_ispexclavecorechinfoset__encode_cold_1(*(_DWORD *)(a2 + 12));
  }
  tb_message_encode_u32();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u16();
  tb_message_encode_u32();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s8();
  for (uint64_t i = 0; i != 12; i += 4)
    tb_message_encode_f32();
  for (uint64_t j = 0; j != 12; j += 4)
    tb_message_encode_f32();
  for (uint64_t k = 0; k != 36; k += 4)
    tb_message_encode_f32();
  for (uint64_t m = 0; m != 12; m += 4)
    tb_message_encode_f32();
  if (*(_DWORD *)(a2 + 116) >= 0x11u) {
    isprgbexclavekitmodule_ispexclavecorechinfoset2__encode_cold_1(*(_DWORD *)(a2 + 116));
  }

  return tb_message_encode_u32();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechinfoset2__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_BOOL();
  tb_message_decode_u32();
  *(_DWORD *)(a2 + 12) = 0;
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u16();
  tb_message_decode_u32();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s8();
  for (uint64_t i = 0; i != 12; i += 4)
    tb_message_decode_f32();
  for (uint64_t j = 0; j != 12; j += 4)
    tb_message_decode_f32();
  for (uint64_t k = 0; k != 36; k += 4)
    tb_message_decode_f32();
  for (uint64_t m = 0; m != 12; m += 4)
    tb_message_decode_f32();
  tb_message_decode_u32();
  uint64_t result = 0;
  *(_DWORD *)(a2 + 116) = 0;
  return result;
}

uint64_t isprgbexclavekitmodule_ispexclavecorechdpcset__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  for (uint64_t i = 0; i != 36; i += 12)
  {
    tb_message_encode_u32();
    tb_message_encode_u32();
    if (*(_DWORD *)(a2 + i + 16) >= 4u) {
      isprgbexclavekitmodule_ispexclavecorechdpcset__encode_cold_1(*(_DWORD *)(a2 + i + 16));
    }
    tb_message_encode_u32();
  }
  for (uint64_t j = 0; j != 4096; j += 4)
    uint64_t result = tb_message_encode_u32();
  return result;
}

uint64_t isprgbexclavekitmodule_ispexclavecorechdpcset__decode(uint64_t a1, uint64_t a2)
{
  tb_message_decode_u32();
  tb_message_decode_u32();
  for (uint64_t i = 0; i != 36; i += 12)
  {
    tb_message_decode_u32();
    tb_message_decode_u32();
    tb_message_decode_u32();
    *(_DWORD *)(a2 + i + 16) = 0;
  }
  for (uint64_t j = 0; j != 4096; j += 4)
    uint64_t result = tb_message_decode_u32();
  return result;
}

uint64_t isprgbexclavekitmodule_anstobject__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 4) >= 0xAu) {
    isprgbexclavekitmodule_anstobject__encode_cold_1(*(_DWORD *)(a2 + 4));
  }
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();

  return tb_message_encode_u32();
}

uint64_t isprgbexclavekitmodule_anstobject__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 4) = 0;
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  return tb_message_decode_u32();
}

uint64_t isprgbexclavekitmodule_anstface__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 4) >= 0xAu) {
    isprgbexclavekitmodule_anstobject__encode_cold_1(*(_DWORD *)(a2 + 4));
  }
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_u8();
  tb_message_encode_f32();

  return tb_message_encode_u8();
}

uint64_t isprgbexclavekitmodule_anstface__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 4) = 0;
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_u8();
  tb_message_decode_f32();
  return tb_message_decode_u8();
}

uint64_t isprgbexclavekitmodule_anstobjectv150__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 8) >= 0xAu) {
    isprgbexclavekitmodule_anstobject__encode_cold_1(*(_DWORD *)(a2 + 8));
  }
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_u32();

  return tb_message_encode_f32();
}

uint64_t isprgbexclavekitmodule_anstobjectv150__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 8) = 0;
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  return tb_message_decode_f32();
}

uint64_t isprgbexclavekitmodule_anstfacev150__encode(uint64_t a1, uint64_t a2)
{
  tb_message_encode_u32();
  tb_message_encode_u32();
  if (*(_DWORD *)(a2 + 8) >= 0xAu) {
    isprgbexclavekitmodule_anstobject__encode_cold_1(*(_DWORD *)(a2 + 8));
  }
  tb_message_encode_u32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_u32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_s32();
  tb_message_encode_u8();
  tb_message_encode_f32();

  return tb_message_encode_u8();
}

uint64_t isprgbexclavekitmodule_anstfacev150__decode(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 8) = 0;
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_u32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_s32();
  tb_message_decode_u8();
  tb_message_decode_f32();
  return tb_message_decode_u8();
}

uint64_t isprgbexclavekitmodule_runkitfaceprocessanimation__encode()
{
  for (uint64_t i = 0; i != 204; i += 4)
    tb_message_encode_f32();
  for (uint64_t j = 0; j != 12; j += 4)
    tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();
  tb_message_encode_f32();

  return tb_message_encode_f32();
}

uint64_t isprgbexclavekitmodule_runkitfaceprocessanimation__decode()
{
  for (uint64_t i = 0; i != 204; i += 4)
    tb_message_decode_f32();
  for (uint64_t j = 0; j != 12; j += 4)
    tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();
  tb_message_decode_f32();

  return tb_message_decode_f32();
}

uint64_t isprgbexclavekitmodule_runkitfaceprocesstrackedface__encode()
{
  tb_message_encode_f32();
  tb_message_encode_f64();
  tb_message_encode_f64();
  tb_message_encode_f64();
  tb_message_encode_f64();
  tb_message_encode_f32();
  for (uint64_t i = 0; i != 16; ++i)
    tb_message_encode_u8();
  tb_message_encode_s32();
  isprgbexclavekitmodule_runkitfaceprocessanimation__encode();
  for (uint64_t j = 0; j != 36; j += 4)
    tb_message_encode_f32();
  for (uint64_t k = 0; k != 12; k += 4)
    tb_message_encode_f32();
  isprgbexclavekitmodule_runkitfaceprocessanimation__encode();
  for (uint64_t m = 0; m != 36; m += 4)
    tb_message_encode_f32();
  for (uint64_t n = 0; n != 12; n += 4)
    tb_message_encode_f32();
  for (iuint64_t i = 0; ii != 528; ii += 4)
    tb_message_encode_f32();
  for (juint64_t j = 0; jj != 12; jj += 4)
    tb_message_encode_f32();
  for (kuint64_t k = 0; kk != 12; kk += 4)
    uint64_t result = tb_message_encode_f32();
  return result;
}

uint64_t isprgbexclavekitmodule_runkitfaceprocesstrackedface__decode()
{
  tb_message_decode_f32();
  tb_message_decode_f64();
  tb_message_decode_f64();
  tb_message_decode_f64();
  tb_message_decode_f64();
  tb_message_decode_f32();
  for (uint64_t i = 0; i != 16; ++i)
    tb_message_decode_u8();
  tb_message_decode_s32();
  isprgbexclavekitmodule_runkitfaceprocessanimation__decode();
  for (uint64_t j = 0; j != 36; j += 4)
    tb_message_decode_f32();
  for (uint64_t k = 0; k != 12; k += 4)
    tb_message_decode_f32();
  isprgbexclavekitmodule_runkitfaceprocessanimation__decode();
  for (uint64_t m = 0; m != 36; m += 4)
    tb_message_decode_f32();
  for (uint64_t n = 0; n != 12; n += 4)
    tb_message_decode_f32();
  for (iuint64_t i = 0; ii != 528; ii += 4)
    tb_message_decode_f32();
  for (juint64_t j = 0; jj != 12; jj += 4)
    tb_message_decode_f32();
  for (kuint64_t k = 0; kk != 12; kk += 4)
    uint64_t result = tb_message_decode_f32();
  return result;
}

uint64_t isprgbexclavekitmodule_ispexclavecorechrunkitfaceprocessrslt__encode()
{
  tb_message_encode_BOOL();
  tb_message_encode_BOOL();
  for (uint64_t i = 4; i != 16; i += 4)
    tb_message_encode_u32();
  tb_message_encode_f64();
  for (uint64_t j = 24; j != 60; j += 4)
    tb_message_encode_f32();
  for (uint64_t k = 0; k != 12; k += 4)
    tb_message_encode_f32();
  for (uint64_t m = 0; m != 36; m += 4)
    tb_message_encode_f32();
  for (uint64_t n = 0; n != 200; n += 40)
  {
    tb_message_encode_f32();
    tb_message_encode_f64();
    tb_message_encode_f64();
    tb_message_encode_f64();
    tb_message_encode_f64();
  }
  for (iuint64_t i = 312; ii != 3960; ii += 1216)
    isprgbexclavekitmodule_runkitfaceprocesstrackedface__encode();
  tb_message_encode_BOOL();

  return tb_message_encode_BOOL();
}

uint64_t isprgbexclavekitmodule_ispexclavecorechrunkitfaceprocessrslt__decode()
{
  tb_message_decode_BOOL();
  tb_message_decode_BOOL();
  for (uint64_t i = 4; i != 16; i += 4)
    tb_message_decode_u32();
  tb_message_decode_f64();
  for (uint64_t j = 24; j != 60; j += 4)
    tb_message_decode_f32();
  for (uint64_t k = 0; k != 12; k += 4)
    tb_message_decode_f32();
  for (uint64_t m = 0; m != 36; m += 4)
    tb_message_decode_f32();
  uint64_t v4 = -200;
  do
  {
    tb_message_decode_f32();
    tb_message_decode_f64();
    tb_message_decode_f64();
    tb_message_decode_f64();
    tb_message_decode_f64();
    v4 += 40;
  }
  while (v4);
  for (uint64_t n = 312; n != 3960; n += 1216)
    isprgbexclavekitmodule_runkitfaceprocesstrackedface__decode();
  tb_message_decode_BOOL();

  return tb_message_decode_BOOL();
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdon()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdoff()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchstart()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchstop()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchinfoset(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    isprgbexclavekitmodule_ispexclavecorechinfoset__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchisconcurrent()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_BOOL();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchinfoset2(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    isprgbexclavekitmodule_ispexclavecorechinfoset2__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 8);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 8));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchalgoenable()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitae(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchsensormetadata(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    isprgbexclavekitmodule_ispexclavecorechsensormetadata__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavechcameraconfigset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_u32();
    tb_message_encode_u8();
    tb_message_encode_u16();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeframeratemaxset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeframerateminset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaegaincapset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeintegrationtimemaxset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeupdateresume()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeupdatesuspend()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeintegrationgainset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeinitsettingget()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdaeflickerfreqset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u64();
    tb_message_encode_u8();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_f32();
    tb_message_encode_u8();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchlscset(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    ispirexclavekitmodule_sepipelscconfig__encode((uint64_t)v5, a2 + 4);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchpdpset(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    ispirexclavekitmodule_sepipepdpconfig__encode((uint64_t)v5, a2 + 4);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeframeratemaxget()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeframerateminget()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchdpcset(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    isprgbexclavekitmodule_ispexclavecorechdpcset__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchsensormetadata2(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    isprgbexclavekitmodule_ispexclavecorechsensormetadata2__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchsensormetadatav3(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  uint64_t v6 = 0;
  memset(v5, 0, sizeof(v5));
  uint64_t v13 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v7 = 0u;
  long long v8 = 0u;
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    isprgbexclavekitmodule_ispexclavecorechsensormetadatav3__encode((uint64_t)v5, a2);
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitaev2(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeintegrationgainsetv2()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_encode_u16();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchaeinitsettinggetv2()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitanst(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitanstv150(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchfaceconfigset()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_BOOL();
    tb_message_encode_BOOL();
    tb_message_encode_BOOL();
    tb_message_encode_u32();
    tb_message_encode_BOOL();
    tb_message_encode_f32();
    tb_message_encode_f32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitfaceprocess(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitfacesecondaryprocess(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitperception(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchsetperceptionframerate()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitmd(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitmdv2(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitandk(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    int v4 = *(_DWORD *)(a2 + 4);
    if ((v4 - 1) >= 7 && v4 != 9) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavebootarg(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    if (*a2 >= 3) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavebootarg_cold_1(*a2);
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavechpropertywrite(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    unsigned int v4 = *(_DWORD *)(a2 + 4);
    if (v4 - 16 >= 0x30 && v4 >= 0xF) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavechpropertywrite_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavechpropertyread(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    unsigned int v4 = *(_DWORD *)(a2 + 4);
    if (v4 - 16 >= 0x30 && v4 >= 0xF) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavechpropertywrite_cold_1(*(_DWORD *)(a2 + 4));
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmddebugcapability()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclaveisphwirq()
{
  uint64_t v0 = tb_client_connection_message_construct();
  if (!v0)
  {
    tb_message_encode_u64();
    tb_message_encode_u32();
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v0 = tb_connection_send_query();
    if ((v0 & 0xFFFFFFF7) == 0) {
      uint64_t v0 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v0;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdinfiltration(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    if (*a2 >= 2) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdinfiltration_cold_1(*a2);
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_sendcmdexfiltration(uint64_t a1, unsigned int *a2)
{
  uint64_t v3 = tb_client_connection_message_construct();
  if (!v3)
  {
    tb_message_encode_u64();
    if (*a2 >= 2) {
      isprgbexclavekitmodule_isprgbexclavekit_sendcmdinfiltration_cold_1(*a2);
    }
    tb_message_encode_u32();
    tb_message_complete();
    uint64_t v3 = tb_connection_send_query();
    if ((v3 & 0xFFFFFFF7) == 0) {
      uint64_t v3 = 4;
    }
    tb_client_connection_message_destruct();
  }
  return v3;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_init(uint64_t *a1)
{
  tb_endpoint_set_interface_identifier();
  uint64_t v2 = tb_client_connection_create_with_endpoint();
  uint64_t result = tb_client_connection_activate();
  if (!result) {
    *a1 = v2;
  }
  return result;
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_init_static(void *a1, uint64_t a2, uint64_t a3)
{
  tb_endpoint_set_interface_identifier();
  uint64_t result = tb_client_connection_create_with_endpoint_static();
  if (!result)
  {
    uint64_t result = tb_client_connection_activate();
    if (!result) {
      *a1 = a3;
    }
  }
  return result;
}

void *isprgbexclavekitmodule_isprgbexclavekit__copy(void *result, void *a2)
{
  *a2 = *result;
  return result;
}

void isprgbexclavekitmodule_isprgbexclavekit__destruct()
{
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit_server_start(uint64_t a1)
{
  return isprgbexclavekitmodule_isprgbexclavekit__server_start_owned(a1, &v2);
}

uint64_t isprgbexclavekitmodule_isprgbexclavekit__server_start_owned(uint64_t a1, uint64_t *a2)
{
  *a2 = tb_service_connection_create_with_endpoint();
  return tb_service_connection_activate();
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke(uint64_t a1, uint64_t a2)
{
}

void isprgbexclavekitmodule_isprgbexclavekit__server_stop()
{
}

uint64_t isprgbexclavekitmodule_ispexclaveproperty__decode(uint64_t a1, _DWORD *a2)
{
  tb_message_decode_u32();
  uint64_t result = 0;
  *a2 = 0;
  return result;
}

uint64_t H16ISP::savePeridotCalib(H16ISP *this, H16ISP::H16ISPDevice *a2, H16ISP::H16ISPServicesRemote *a3, void *a4, const void *a5)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  long long v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  uint64_t v10 = &_os_log_internal;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    os_log_t v11 = os_log_create("com.apple.isp", "general");
    long long v12 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v11;

    long long v9 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v30 = 136315138;
    int v31 = "savePeridotCalib";
    _os_log_impl(&dword_24680F000, v9, OS_LOG_TYPE_DEFAULT, "%s - saving calibration\n", (uint8_t *)&v30, 0xCu);
  }
  if (!a4) {
    return 0;
  }
  uint64_t v13 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v10)
  {
    os_log_t v14 = os_log_create("com.apple.isp", "general");
    int v15 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v14;

    uint64_t v13 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v30 = 136315138;
    int v31 = "savePeridotCalib";
    _os_log_impl(&dword_24680F000, v13, OS_LOG_TYPE_DEFAULT, "%s - updating firmware\n", (uint8_t *)&v30, 0xCu);
  }
  if (H16ISP::savePeridotCalibToFW(this, a3, (unsigned __int16)a4, v16))
  {
    int v17 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (a2)
    {
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v10)
      {
        os_log_t v18 = os_log_create("com.apple.isp", "general");
        long long v19 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v18;

        int v17 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      }
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        int v30 = 136315138;
        int v31 = "savePeridotCalib";
        _os_log_impl(&dword_24680F000, v17, OS_LOG_TYPE_DEFAULT, "%s - sending to daemon to store\n", (uint8_t *)&v30, 0xCu);
      }
      CFDataRef v20 = (const __CFData *)CFRetain(a4);
      if (v20)
      {
        CFDataRef v21 = v20;
        H16ISP::H16ISPServicesRemote::SaveJasperCalibData(a2, v20);
        CFRelease(v21);
      }
    }
    else
    {
      if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v10)
      {
        os_log_t v27 = os_log_create("com.apple.isp", "general");
        int v28 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
        GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v27;

        int v17 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      }
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        int v30 = 136315138;
        int v31 = "savePeridotCalib";
        _os_log_impl(&dword_24680F000, v17, OS_LOG_TYPE_DEFAULT, "%s - storing locally\n", (uint8_t *)&v30, 0xCu);
      }
      JasperCalibration::save((JasperCalibration *)a4, v29);
    }
    return 1;
  }
  uint64_t v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == v10)
  {
    os_log_t v23 = os_log_create("com.apple.isp", "general");
    double v24 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v23;

    uint64_t v22 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  BOOL v25 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v25)
  {
    int v30 = 136315138;
    int v31 = "savePeridotCalib";
    _os_log_impl(&dword_24680F000, v22, OS_LOG_TYPE_DEFAULT, "%s - failed to update calibration in firmware\n", (uint8_t *)&v30, 0xCu);
    return 0;
  }
  return result;
}

void sub_246994D38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void H16ISP::H16ISPJasperDepthNode::~H16ISPJasperDepthNode(H16ISP::H16ISPJasperDepthNode *this)
{
  *(void *)this = &unk_26FAECDE8;
  *((unsigned char *)this + 236) = 1;
  uint64_t v2 = (void *)MEMORY[0x24C53DF70]();
  uint64_t v3 = (OS_os_workgroup *)*((void *)this + 27);
  if (v3)
  {
    os_workgroup_cancel(v3);
    unsigned int v4 = (void *)*((void *)this + 27);
    *((void *)this + 27) = 0;
  }
  uint64_t v5 = *((void *)this + 28);
  if (v5)
  {
    dispatch_async_and_wait(v5, &__block_literal_global_10);
    uint64_t v6 = (void *)*((void *)this + 28);
    *((void *)this + 28) = 0;
  }
  long long v7 = (H16ISP::JasperDepthNodeInternal *)*((void *)this + 13);
  if (v7)
  {
    H16ISP::JasperDepthNodeInternal::~JasperDepthNodeInternal(v7);
    MEMORY[0x24C53D6E0]();
  }
  *((void *)this + 13) = 0;
  long long v8 = (const void *)*((void *)this + 18);
  if (v8) {
    CFRelease(v8);
  }

  H16ISP::H16ISPFilterGraphNode::~H16ISPFilterGraphNode(this);
}

{
  uint64_t vars8;

  H16ISP::H16ISPJasperDepthNode::~H16ISPJasperDepthNode(this);

  JUMPOUT(0x24C53D6E0);
}

void ___ZN6H16ISP21H16ISPJasperDepthNode13setBufferPoolEP18__CVDataBufferPool_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 236))
  {
    uint64_t v3 = *(id **)(v2 + 104);
    if (v3)
    {
      if (*v3) {
        [*v3 setDataBufferPool:*(void *)(a1 + 40)];
      }
    }
  }
  unsigned int v4 = *(const void **)(a1 + 40);
  if (v4)
  {
    CFRelease(v4);
  }
}

uint64_t H16ISP::H16ISPJasperDepthNode::onDeactivate(H16ISP::H16ISPJasperDepthNode *this)
{
  *((_WORD *)this + 76) = 0;
  uint64_t v2 = *((void *)this + 20);
  if (v2)
  {
    dispatch_sync(v2, &__block_literal_global_100);
    uint64_t v3 = (void *)*((void *)this + 20);
    *((void *)this + 20) = 0;
  }
  unsigned int v4 = (H16ISP::H16ISPTimeOfFlightColorSynchronizer *)*((void *)this + 12);
  if (v4) {
    H16ISP::H16ISPTimeOfFlightColorSynchronizer::deactivate(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 25);
  if (!v5) {
    uint64_t v5 = objc_opt_new();
  }
  uint64_t v6 = (void *)**((void **)this + 13);
  if (v6)
  {
    [v6 reportSessionStatistics];
    long long v7 = [**((id **)this + 13) getInternalState];
    if (v7) {
      [v5 setObject:v7 forKey:@"DepthProcessor"];
    }
  }
  uint64_t v8 = *((void *)this + 10);
  uint64_t v9 = *((void *)this + 24);
  id v10 = v5;
  os_log_t v11 = [v10 objectForKeyedSubscript:@"JasperTotalFrameCount"];
  uint64_t v12 = [v11 longLongValue];

  uint64_t v13 = [v10 objectForKeyedSubscript:@"JasperFramesSinceLastTransition"];
  uint64_t v14 = [v13 longLongValue];

  int v15 = [v10 objectForKeyedSubscript:@"JasperCurrentState"];
  __int16 v16 = v15;
  if (v15) {
    int v17 = [v15 intValue];
  }
  else {
    int v17 = 1;
  }
  os_log_t v18 = [v10 objectForKeyedSubscript:@"JasperStateTransitionCount"];
  uint64_t v19 = [v18 intValue];

  int JasperStatistics = H16ISP::H16ISPDevice::ISP_GetJasperStatistics(v8, &outputStruct);
  uint64_t v21 = v12 + v9;
  uint64_t v22 = v14 + v9;
  if (!JasperStatistics)
  {
    if (v17 != outputStruct)
    {
      uint64_t v19 = (v19 + 1);
      reportJasperStateAnalytics();
      uint64_t v22 = 0;
    }
    if (v34)
    {
      unint64_t v23 = 0;
      double v24 = &v33;
      do
      {
        reportPeridotCoexRetries();
        ++v24;
        ++v23;
      }
      while (v23 < v34);
    }
  }
  BOOL v25 = [NSNumber numberWithUnsignedLongLong:v22];
  [v10 setObject:v25 forKeyedSubscript:@"JasperFramesSinceLastTransition"];

  unsigned int v26 = [NSNumber numberWithUnsignedInt:outputStruct];
  [v10 setObject:v26 forKeyedSubscript:@"JasperCurrentState"];

  os_log_t v27 = [NSNumber numberWithInt:v19];
  [v10 setObject:v27 forKeyedSubscript:@"JasperStateTransitionCount"];

  int v28 = [NSNumber numberWithUnsignedLongLong:v21];
  [v10 setObject:v28 forKeyedSubscript:@"JasperTotalFrameCount"];

  int v29 = (H16ISP::H16ISPServicesRemote *)*((void *)this + 11);
  if (v29) {
    H16ISP::H16ISPServicesRemote::WriteDictionary(v29, @"/var/mobile/Library/ISP/JasperL/session_persistency.plist", (const __CFDictionary *)v10);
  }
  else {
    [v10 writeToFile:@"/var/mobile/Library/ISP/JasperL/session_persistency.plist" atomically:1];
  }
  int v30 = (const void *)*((void *)this + 26);
  if (v30) {
    CFRelease(v30);
  }

  return 0;
}

void sub_2469951D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void H16ISP::AppendDictionary(H16ISP *this, const void *value, CFMutableDictionaryRef theDict, void *a4)
{
}

void H16ISP::JasperDepthNodeInternal::~JasperDepthNodeInternal(H16ISP::JasperDepthNodeInternal *this)
{
  uint64_t v2 = *(void **)this;
  *(void *)this = 0;

  uint64_t v3 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;

  *((unsigned char *)this + 16) = 0;
}

void H16ISP::H16ISPJasperDepthNode::onActivate(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "JasperDepthNode: Failed to create a workgroup\n", v1, 2u);
}

void H16ISP::H16ISPJasperDepthNode::onActivate()
{
  __assert_rtn("onActivate", "H16ISPJasperDepthNode.mm", 530, "rc == 0");
}

void H16ISP::H16ISPJasperColorNode::~H16ISPJasperColorNode(H16ISP::H16ISPJasperColorNode *this)
{
  H16ISP::H16ISPFilterGraphNode::~H16ISPFilterGraphNode(this);

  JUMPOUT(0x24C53D6E0);
}

void H16ISP::H16ISPTimeOfFlightColorSynchronizer::~H16ISPTimeOfFlightColorSynchronizer(H16ISP::H16ISPTimeOfFlightColorSynchronizer *this)
{
  uint64_t v2 = *((void *)this + 2);
  if (v2)
  {
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = ___ZN6H16ISP35H16ISPTimeOfFlightColorSynchronizerD2Ev_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_sync(v2, block);
    uint64_t v3 = (void *)*((void *)this + 2);
  }
  else
  {
    uint64_t v3 = 0;
  }
  *((void *)this + 2) = 0;

  unsigned int v4 = (H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal *)*((void *)this + 3);
  if (v4)
  {
    H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal::~TimeOfFlightColorSynchronizerInternal(v4);
    MEMORY[0x24C53D6E0]();
  }
}

uint64_t ___ZN6H16ISP35H16ISPTimeOfFlightColorSynchronizerD2Ev_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 8) = 0;
  return result;
}

void H16ISP::H16ISPTimeOfFlightColorSynchronizer::deactivate(H16ISP::H16ISPTimeOfFlightColorSynchronizer *this)
{
  if (*((unsigned char *)this + 8))
  {
    int v1 = *((void *)this + 2);
    block[0] = MEMORY[0x263EF8330];
    block[1] = 3221225472;
    block[2] = ___ZN6H16ISP35H16ISPTimeOfFlightColorSynchronizer10deactivateEv_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_async(v1, block);
  }
}

void ___ZN6H16ISP35H16ISPTimeOfFlightColorSynchronizer10deactivateEv_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 8)) {
    H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal::deactivate(*(H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal **)(v1 + 24));
  }
  *(unsigned char *)(v1 + 8) = 0;
}

void H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal::deactivate(H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal *this)
{
  uint64_t v2 = (H16ISP::TimeOfFlightAutoFocusAssistant *)*((void *)this + 1);
  if (v2) {
    H16ISP::TimeOfFlightAutoFocusAssistant::deactivate(v2);
  }
  if (*(void *)this) {
    H16ISP::TimeOfFlightColorInfieldCalibrationManager::deactivate(*(H16ISP::TimeOfFlightColorInfieldCalibrationManager **)this);
  }
  uint64_t v3 = (__CVBuffer *)*((void *)this + 34);
  if (v3) {
    CVPixelBufferRelease(v3);
  }
  unsigned int v4 = (const void *)*((void *)this + 35);
  if (v4) {
    CFRelease(v4);
  }
  *((void *)this + 34) = 0;
  *((void *)this + 35) = 0;
  uint64_t v5 = (void *)*((void *)this + 25);
  *((void *)this + 25) = 0;

  uint64_t v6 = (void *)*((void *)this + 24);
  *((void *)this + 24) = 0;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::setDilutionRate(uint64_t this, int a2)
{
  uint64_t v2 = **(void **)(this + 24);
  *(_DWORD *)(v2 + 64) = a2;
  *(_DWORD *)(v2 + 84) = a2;
  *(_DWORD *)(v2 + 88) = a2;
  *(unsigned char *)(v2 + 80) = 0;
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::setFeatureVectorSize(uint64_t this, int a2)
{
  *(_DWORD *)(**(void **)(this + 24) + 68) = a2;
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::setLowFrameInterval(uint64_t this, int a2)
{
  uint64_t v2 = **(void **)(this + 24);
  *(_DWORD *)(v2 + 84) = a2;
  *(unsigned char *)(v2 + 80) = *(_DWORD *)(v2 + 88) != a2;
  *(_DWORD *)(v2 + 64) = a2;
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::setHighFrameInterval(uint64_t this, int a2)
{
  uint64_t v2 = **(void **)(this + 24);
  *(_DWORD *)(v2 + 88) = a2;
  int v3 = *(_DWORD *)(v2 + 84);
  *(unsigned char *)(v2 + 80) = v3 != a2;
  *(_DWORD *)(v2 + 64) = v3;
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::setMinFrameNumAtLowInterval(uint64_t this, int a2)
{
  *(_DWORD *)(**(void **)(this + 24) + 104) = a2;
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::setLowFrameIntervalThresholdX(uint64_t this, int a2)
{
  *(_DWORD *)(**(void **)(this + 24) + 92) = a2;
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::setLowFrameIntervalThresholdY(uint64_t this, int a2)
{
  *(_DWORD *)(**(void **)(this + 24) + 96) = a2;
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::setLowFrameIntervalThresholdZ(uint64_t this, int a2)
{
  *(_DWORD *)(**(void **)(this + 24) + 100) = a2;
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::getColorControllerStats(uint64_t this, int *a2)
{
  *a2 = *(_DWORD *)(**(void **)(this + 24) + 76);
  return this;
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::disableTofAssistance(H16ISP::H16ISPTimeOfFlightColorSynchronizer *this)
{
  return H16ISP::TimeOfFlightAutoFocusAssistant::deactivate(*(H16ISP::TimeOfFlightAutoFocusAssistant **)(*((void *)this + 3) + 8));
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::isFWAFOwner(H16ISP::H16ISPTimeOfFlightColorSynchronizer *this)
{
  return *(unsigned __int8 *)(*(void *)(*((void *)this + 3) + 8) + 24);
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::getFWProjectorMode(H16ISP::H16ISPTimeOfFlightColorSynchronizer *this)
{
  return *(unsigned int *)(*(void *)(*((void *)this + 3) + 8) + 28);
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::isAutoFocusAssistanceActive(H16ISP::H16ISPTimeOfFlightColorSynchronizer *this)
{
  return *(unsigned __int8 *)(*(void *)(*((void *)this + 3) + 8) + 25);
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::isVerbose(H16ISP::H16ISPTimeOfFlightColorSynchronizer *this)
{
  return *(unsigned __int8 *)(*(void *)(*((void *)this + 3) + 8) + 80);
}

uint64_t H16ISP::H16ISPTimeOfFlightColorSynchronizer::isTeleDensificationEnabled(H16ISP::H16ISPTimeOfFlightColorSynchronizer *this)
{
  return *(unsigned __int8 *)(*(void *)(*((void *)this + 3) + 8) + 224);
}

void __destroy_helper_block_ea8_32c66_ZTSNSt3__112basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEE(uint64_t a1)
{
  if (*(char *)(a1 + 55) < 0) {
    operator delete(*(void **)(a1 + 32));
  }
}

id *H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal::{unnamed type#3}::~TimeOfFlightColorSynchronizerInternal(id *a1)
{
  return a1;
}

void H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal::~TimeOfFlightColorSynchronizerInternal(H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal *this)
{
  uint64_t v2 = (id *)*((void *)this + 1);
  if (v2)
  {
    H16ISP::TimeOfFlightAutoFocusAssistant::~TimeOfFlightAutoFocusAssistant(v2);
    MEMORY[0x24C53D6E0]();
  }
  if (*(void *)this)
  {
    H16ISP::TimeOfFlightColorInfieldCalibrationManager::~TimeOfFlightColorInfieldCalibrationManager(*(H16ISP::TimeOfFlightColorInfieldCalibrationManager **)this);
    MEMORY[0x24C53D6E0]();
  }
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    MEMORY[0x24C53D6E0](v3, 0x1020C405CE9ABE8);
  }
  unsigned int v4 = (const void *)*((void *)this + 4);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (__CVBuffer *)*((void *)this + 34);
  if (v5) {
    CVPixelBufferRelease(v5);
  }
  uint64_t v6 = (const void *)*((void *)this + 35);
  if (v6) {
    CFRelease(v6);
  }
  long long v7 = (void *)*((void *)this + 25);
  *((void *)this + 25) = 0;

  uint64_t v8 = (void *)*((void *)this + 24);
  *((void *)this + 24) = 0;

  pthread_mutex_destroy((pthread_mutex_t *)this + 2);
}

void H16ISP::TimeOfFlightAutoFocusAssistant::~TimeOfFlightAutoFocusAssistant(id *this)
{
}

uint64_t H16ISP::TimeOfFlightAutoFocusAssistant::deactivate(H16ISP::TimeOfFlightAutoFocusAssistant *this)
{
  uint64_t result = H16ISP::H16ISPDevice::getSensorChannel(*(void *)this, 1785950322);
  *((_DWORD *)this + 2) = result;
  *((unsigned char *)this + 25) = 0;
  if (result != -1)
  {
    LOWORD(v3) = result;
    if (*((unsigned char *)this + 80))
    {
      NSLog(&cfstr_Timeofflightau_1.isa, result, *((unsigned __int8 *)this + 24), 0, *((unsigned int *)this + 7), 0);
      int v3 = *((_DWORD *)this + 2);
      char v4 = *((unsigned char *)this + 25) != 0;
    }
    else
    {
      char v4 = 0;
    }
    H16ISP::H16ISPDevice::SetTOFControlMode(*(H16ISP::H16ISPDevice **)this, v3, *((unsigned char *)this + 24), v4, *((_DWORD *)this + 7), 0);
    uint64_t result = H16ISP::H16ISPServicesRemote::UpdateFlickerIRSignalRateHint(*((H16ISP::H16ISPServicesRemote **)this + 2), 0.0, v5);
  }
  *((void *)this + 4) = 0;
  return result;
}

void H16ISP::TimeOfFlightColorInfieldCalibrationManager::~TimeOfFlightColorInfieldCalibrationManager(H16ISP::TimeOfFlightColorInfieldCalibrationManager *this)
{
  uint64_t v2 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;
}

void H16ISP::TimeOfFlightAutoFocusAssistant::enableTeleDensification(uint64_t a1, int a2, void *a3)
{
  id v10 = a3;
  *(unsigned char *)(a1 + 224) = a2;
  if (a2)
  {
    objc_storeStrong((id *)(a1 + 256), a3);
    id v6 = objc_alloc_init(MEMORY[0x263F26BE0]);
    long long v7 = *(void **)(a1 + 248);
    *(void *)(a1 + 248) = v6;

    [*(id *)(a1 + 248) prepare];
  }
  else
  {
    uint64_t v8 = *(void **)(a1 + 256);
    *(void *)(a1 + 256) = 0;

    uint64_t v9 = *(void **)(a1 + 248);
    *(void *)(a1 + 248) = 0;
  }
}

void sub_246995A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

id GetCameraUserspaceLogStream()
{
  uint64_t v0 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
  {
    os_log_t v1 = os_log_create("com.apple.isp", "general");
    uint64_t v2 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v1;

    uint64_t v0 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
  }
  id v3 = v0;

  return v3;
}

void H16ISP::TimeOfFlightColorInfieldCalibrationManager::deactivate(H16ISP::TimeOfFlightColorInfieldCalibrationManager *this)
{
  if (*((unsigned char *)this + 108))
  {
    uint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      os_log_t v3 = os_log_create("com.apple.isp", "general");
      char v4 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v3;

      uint64_t v2 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    }
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl(&dword_24680F000, v2, OS_LOG_TYPE_DEFAULT, "RGBJ-TofManager-Verbose: deactivate\n", v5, 2u);
    }
  }
  *((unsigned char *)this + 20) = 0;
}

void H16ISP::NearEventComplianceHandler::handleEvent(uint64_t a1, void *a2, int a3, int a4)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  id v7 = a2;
  if (a3 / a4 < 16 || H16ISP::NearEventComplianceHandler::isDepthDetectedInPointCloud((double *)a1, v7))
  {
    *(_WORD *)(a1 + 48) = H16ISP::H16ISPDevice::getSensorChannel(*(void *)(a1 + 40), 1785950322);
    if (!*(unsigned char *)(a1 + 50))
    {
      *(unsigned char *)(a1 + 50) = 1;
      NSLog(&cfstr_PeridotNearEve.isa, 0x101010101010101, v9);
      H16ISP::JasperConfigManager::setJasperProjectorBanksStatus(*(H16ISP::JasperConfigManager **)(a1 + 40), (H16ISP::H16ISPDevice *)&v8, (const BOOL *)*(unsigned __int16 *)(a1 + 48));
    }
    *(void *)(a1 + 32) = mach_absolute_time();
  }
  else
  {
    *(_WORD *)(a1 + 48) = H16ISP::H16ISPDevice::getSensorChannel(*(void *)(a1 + 40), 1785950322);
    if (*(_DWORD *)(a1 + 16) <= (int)((mach_absolute_time() - *(void *)(a1 + 32))
                                     * *(unsigned int *)(a1 + 24)
                                     / *(unsigned int *)(a1 + 28)
                                     / 0x3B9ACA00)
      && *(unsigned char *)(a1 + 50))
    {
      *(unsigned char *)(a1 + 50) = 0;
      NSLog(&cfstr_PeridotNearEve_0.isa, 0x101010100000000, v9);
      H16ISP::JasperConfigManager::setJasperProjectorBanksStatus(*(H16ISP::JasperConfigManager **)(a1 + 40), (H16ISP::H16ISPDevice *)&v8, (const BOOL *)*(unsigned __int16 *)(a1 + 48));
    }
  }
}

void sub_246995CA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t H16ISP::NearEventComplianceHandler::isDepthDetectedInPointCloud(double *a1, void *a2)
{
  id v3 = a2;
  char v4 = (float *)[v3 confidences];
  int v5 = [v3 length];
  double v6 = *a1;
  int v7 = [v3 length];
  if (v5 >= 1)
  {
    int v8 = 0;
    uint64_t v9 = &v4[v5];
    do
    {
      if (a1[1] < *v4)
      {
        if (v8 >= (int)((1.0 - v6) * (double)v7))
        {
          uint64_t v10 = 1;
          goto LABEL_9;
        }
        ++v8;
      }
      ++v4;
    }
    while (v4 < v9);
  }
  uint64_t v10 = 0;
LABEL_9:

  return v10;
}

void sub_246995D88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void H16ISP::TimeOfFlightAutoFocusAssistant::handleMatch(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  int v6 = *(_DWORD *)(a1 + 72);
  if (v6 && (int v7 = *(_DWORD *)(a1 + 64) + 1, *(_DWORD *)(a1 + 64) = v7, v7 >= v6))
  {
    *(unsigned char *)(a1 + 76) = 1;
    *(_DWORD *)(a1 + 64) = 0;
    H16ISP::TimeOfFlightAutoFocusAssistant::sendCloud(a1, (uint64_t)v8);
  }
  else
  {
    *(unsigned char *)(a1 + 76) = 0;
  }
}

void sub_246995E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t H16ISP::TimeOfFlightAutoFocusAssistant::getPreviewMasterType(H16ISP::TimeOfFlightAutoFocusAssistant *this)
{
  os_log_t v1 = (uint64_t (*)(void))*((void *)this + 29);
  if (!v1) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v3 = v1(*((void *)this + 30));
  if (v3 == 0xFFFF) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v4 = v3;
  id v5 = *(H16ISP::H16ISPDevice **)this;

  return H16ISP::H16ISPDevice::getSensorType(v5, v4);
}

uint64_t H16ISP::TimeOfFlightAutoFocusAssistant::sendCloud(uint64_t a1, uint64_t a2)
{
  MEMORY[0x270FA5388](a1, a2);
  unsigned int v3 = v2;
  id v5 = v4;
  id v6 = v3;
  [v6 count];
  if ((unsigned __int16)[v5 length]) {
    operator new[]();
  }
  NSLog(&cfstr_Timeofflightau_2.isa);

  return 3758097084;
}

void sub_246996988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void ___ZN6H16ISP30TimeOfFlightAutoFocusAssistant9sendCloudEP18ADJasperPointCloudP7NSArrayIP29ADStreamSyncTimestampedObjectEP10__CVBufferPK14__CFDictionary_block_invoke(uint64_t a1, void *a2, uint64_t a3)
{
  id v6 = a2;
  [v6 timestamp];
  *(void *)(*(void *)(a1 + 32) + 8 * a3) = v5;
}

void sub_246996B08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

double H16ISP::TimeOfFlightAutoFocusAssistant::calcX2cropRect(H16ISP::TimeOfFlightAutoFocusAssistant *this, NSDictionary *a2, CGSize a3)
{
  double height = a3.height;
  double width = a3.width;
  uint64_t v5 = a2;
  id v6 = [(NSDictionary *)v5 objectForKeyedSubscript:*MEMORY[0x263F2D4D8]];

  CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)v6, &rect);
  int v7 = [(NSDictionary *)v5 objectForKeyedSubscript:*MEMORY[0x263F2D420]];
  LODWORD(v6) = [v7 intValue];

  id v8 = [(NSDictionary *)v5 objectForKeyedSubscript:*MEMORY[0x263F2D418]];
  LODWORD(v7) = [v8 intValue];

  uint64_t v9 = [(NSDictionary *)v5 objectForKeyedSubscript:*MEMORY[0x263F2D630]];

  CGRectMakeWithDictionaryRepresentation((CFDictionaryRef)v9, &v16);
  double v10 = rect.size.width + rect.origin.x * 2.0;
  double v11 = (double)(int)v6 / rect.size.width;
  double v12 = v11 * (v10 * 0.5) * (width / v16.size.width)
      + (double)(int)v7
      / rect.size.height
      * ((rect.size.height + rect.origin.y * 2.0)
       * 0.5)
      * (height
       / v16.size.height)
      * -4.0
      / 3.0;
  double v13 = v12 * 0.5;
  if (v12 <= 0.0) {
    double v13 = -0.0;
  }
  double v14 = (v11 * (v10 * 0.25 - rect.origin.x) - v16.origin.x) * (width / v16.size.width) + v13;

  return v14;
}

void sub_246996CD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GridArea::PrepareGrid(_DWORD *a1, float *a2, uint64_t a3, float *a4, int a5)
{
  unsigned int v5 = (float)((float)(a4[1] - *a4) / a4[2]);
  unsigned int v6 = (float)((float)((float)((float)(a2[1] - *a2) / a2[2]) + 1.0) + (float)(2 * a5));
  a1[2] = v6;
  a1[3] = v5;
  a1[4] = v6 * v6;
  a1[5] = v6 * v6 + v6 * v6 * v5;
  operator new[]();
}

void GridArea::GridArea(GridArea *this, const GridArea *a2)
{
  long long v2 = *((_OWORD *)a2 + 2);
  long long v3 = *(_OWORD *)a2;
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = v2;
  *(_OWORD *)this = v3;
  operator new[]();
}

{
  long long v2;
  long long v3;

  long long v2 = *((_OWORD *)a2 + 2);
  long long v3 = *(_OWORD *)a2;
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = v2;
  *(_OWORD *)this = v3;
  operator new[]();
}

{
  long long v2;
  long long v3;

  long long v2 = *(_OWORD *)a2;
  long long v3 = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = v3;
  *(_OWORD *)this = v2;
  operator new[]();
}

{
  long long v2;
  long long v3;

  long long v2 = *(_OWORD *)a2;
  long long v3 = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 1) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 2) = v3;
  *(_OWORD *)this = v2;
  operator new[]();
}

void GridArea::~GridArea(GridArea *this)
{
  uint64_t v1 = *(void *)this;
  if (v1) {
    MEMORY[0x24C53D6C0](v1, 0x1000C80F913DBA1);
  }
}

{
  uint64_t v1;

  uint64_t v1 = *(void *)this;
  if (v1) {
    MEMORY[0x24C53D6C0](v1, 0x1000C80F913DBA1);
  }
}

uint64_t GridArea::GetMinimalCostEntryIdx(uint64_t this, int a2)
{
  uint64_t v2 = *(unsigned int *)(this + 20);
  if (!v2) {
    return 0;
  }
  long long v3 = (void *)this;
  uint64_t v4 = 0;
  LODWORD(this) = 0;
  uint64_t v5 = *v3 + 16;
  double v6 = 1.79769313e308;
  do
  {
    int v7 = (double *)(v5 + 8);
    if (!a2) {
      int v7 = (double *)v5;
    }
    if (*v7 >= v6) {
      this = this;
    }
    else {
      this = v4;
    }
    if (*v7 < v6) {
      double v6 = *v7;
    }
    ++v4;
    v5 += 32;
  }
  while (v2 != v4);
  return this;
}

uint64_t GridArea::ExtendCostGrid(GridArea *this, unsigned int a2, int a3, unsigned int a4)
{
  int v5 = *((_DWORD *)this + 2);
  unsigned int v6 = v5 - a4;
  uint64_t v7 = *(void *)this;
  uint64_t v8 = *(void *)this + 32 * a2;
  float v9 = *(float *)(v8 + 4);
  if (v9 == *((float *)this + 7))
  {
    BOOL v10 = 1;
    unsigned int v11 = a4;
    unsigned int v12 = *((_DWORD *)this + 2);
  }
  else
  {
    float v13 = *((float *)this + 6);
    BOOL v10 = v9 == v13;
    if (v9 == v13) {
      unsigned int v11 = 0;
    }
    else {
      unsigned int v11 = a4;
    }
    unsigned int v12 = v5 - a4;
  }
  float v14 = *(float *)(v8 + 8);
  if (v14 == *((float *)this + 9))
  {
    unsigned int v6 = *((_DWORD *)this + 2);
LABEL_15:
    uint64_t result = 1;
    if (a4 < v6)
    {
      unsigned int v18 = v11 + a4 * v5;
      do
      {
        unint64_t v19 = v12 - (unint64_t)v11;
        unsigned int v20 = v18;
        if (v11 < v12)
        {
          do
          {
            if (a3) {
              *(unsigned char *)(v7 + 32 * v20) = 1;
            }
            else {
              *(unsigned char *)(v7 + 32 * v20 + 1) = 1;
            }
            ++v20;
            --v19;
          }
          while (v19);
        }
        ++a4;
        v18 += v5;
      }
      while (a4 != v6);
      return 1;
    }
    return result;
  }
  uint64_t result = 0;
  float v16 = *((float *)this + 8);
  int v17 = v14 == v16 || v10;
  if (v14 == v16) {
    a4 = 0;
  }
  if (v17 == 1) {
    goto LABEL_15;
  }
  return result;
}

uint64_t *GridArea::NormalizeGrid(uint64_t *result, int a2, int a3, _DWORD *a4)
{
  unsigned int v4 = a4[4];
  unsigned int v5 = a4[5];
  if (v4 > v5) {
    return result;
  }
  unsigned int v6 = a4[3];
  double v7 = 2.22507386e-308;
  double v8 = 1.79769313e308;
  unsigned int v9 = a4[4];
  do
  {
    if (a4[2] <= v6)
    {
      uint64_t v10 = *result;
      unsigned int v11 = a4[2];
      double v12 = v8;
      do
      {
        uint64_t v13 = a2 + *((_DWORD *)result + 2) * v9 + v11;
        if (a3)
        {
          if (*(unsigned char *)(v10 + 32 * v13))
          {
            double v8 = *(double *)(v10 + 32 * v13 + 24);
            goto LABEL_10;
          }
        }
        else
        {
          uint64_t v14 = v10 + 32 * v13;
          if (*(unsigned char *)(v14 + 1))
          {
            double v8 = *(double *)(v14 + 16);
LABEL_10:
            if (v8 > v7) {
              double v7 = v8;
            }
            if (v8 < v12) {
              goto LABEL_14;
            }
          }
        }
        double v8 = v12;
LABEL_14:
        ++v11;
        double v12 = v8;
      }
      while (v11 <= v6);
    }
    ++v9;
  }
  while (v9 <= v5);
  double v15 = v7 - v8;
  unsigned int v16 = a4[2];
  unsigned int v17 = a4[3];
  do
  {
    if (v16 <= v17)
    {
      uint64_t v18 = *result;
      int v19 = a2 + *((_DWORD *)result + 2) * v4;
      unsigned int v20 = v16;
      do
      {
        if (a3) {
          uint64_t v21 = 24;
        }
        else {
          uint64_t v21 = 16;
        }
        *(double *)(v18 + 32 * (v19 + v20) + v21) = (*(double *)(v18 + 32 * (v19 + v20) + v21) - v8) / v15;
        ++v20;
      }
      while (v20 <= v17);
    }
    ++v4;
  }
  while (v4 <= v5);
  return result;
}

void GridArea::CalcNewConfidence(uint64_t a1, int a2, int a3, int *a4)
{
  uint64_t v4 = *(unsigned int *)(a1 + 20);
  int v5 = *(_DWORD *)(a1 + 16) * a2;
  if (v4)
  {
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    uint64_t v8 = *(void *)a1 + 16;
    double v9 = 1.79769313e308;
    do
    {
      uint64_t v10 = (double *)(v8 + 8);
      if (!a3) {
        uint64_t v10 = (double *)v8;
      }
      if (*v10 < v9)
      {
        unsigned int v7 = v6;
        double v9 = *v10;
      }
      ++v6;
      v8 += 32;
    }
    while (v4 != v6);
  }
  else
  {
    unsigned int v7 = 0;
  }
  unsigned int v11 = *(_DWORD *)(a1 + 8);
  int v12 = v7 / v11;
  int v13 = v7 % v11;
  *a4 = v13;
  a4[1] = v12;
  unsigned int v14 = v11 - 1;
  int v15 = (v14 >> 1) - 1;
  int v16 = (v13 - v15) & ~((v13 - v15) >> 31);
  unsigned int v17 = v13 + v15;
  if (v17 >= v14) {
    unsigned int v17 = v14;
  }
  a4[2] = v16;
  a4[3] = v17;
  unsigned int v18 = v15 + v12;
  if (v15 + v12 >= v14) {
    unsigned int v18 = v14;
  }
  a4[4] = (v12 - v15) & ~((v12 - v15) >> 31);
  a4[5] = v18;
  GridArea::NormalizeGrid((uint64_t *)a1, v5, a3, a4);
  operator new[]();
}

void GridArea::FitParabolaModel(GridArea *this, double *a2, double *a3)
{
  int v3 = (int)a3;
  Matrix<double>::Matrix((uint64_t)v15, (int)a3, 3);
  if (v3)
  {
    unsigned int v6 = 0;
    unint64_t v7 = 0;
    unint64_t v8 = v17;
    unsigned int v9 = v18;
    do
    {
      if (v7 >= v8
        || !v9
        || (*(double *)(v16 + 8 * v6) = a2[v7] * a2[v7], v9 == 1)
        || (*(double *)(v16 + 8 * v6 + 8) = a2[v7], v9 <= 2))
      {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      *(void *)(v16 + 8 * v6 + 16) = 0x3FF0000000000000;
      ++v7;
      v6 += v9;
    }
    while (v3 != v7);
  }
  uint64_t v10 = &unk_26FAEAF18;
  unsigned int v11 = this;
  int v12 = v3;
  int v13 = 1;
  char v14 = 0;
  Matrix<double>::Transpose((uint64_t)v15);
}

void sub_246997910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
  Matrix<double>::~Matrix((uint64_t)&a25);
  Matrix<double>::~Matrix((uint64_t)&a9);
  Matrix<double>::~Matrix((uint64_t)&a21);
  Matrix<double>::~Matrix((uint64_t)&a17);
  Matrix<double>::~Matrix((uint64_t)&a13);
  Matrix<double>::~Matrix(v25 - 112);
  Matrix<double>::~Matrix(v25 - 80);
  _Unwind_Resume(a1);
}

void Matrix<double>::Inverse(uint64_t a1@<X0>, unsigned char *a2@<X1>, uint64_t a3@<X8>)
{
  int v6 = *(_DWORD *)(a1 + 16);
  if (v6 == 2)
  {
    if (*(_DWORD *)(a1 + 20) == 2) {
      goto LABEL_4;
    }
LABEL_8:
    Matrix<double>::Inverse();
  }
  if (v6 != 3 || *(_DWORD *)(a1 + 20) != 3) {
    goto LABEL_8;
  }
LABEL_4:
  Matrix<double>::Matrix(a3, v6, v6);
  double v7 = Matrix<double>::Det(a1);
  if (v7 == 0.0)
  {
    if (a2) {
      *a2 = 0;
    }
  }
  else
  {
    if (a2) {
      *a2 = 1;
    }
    if (*(_DWORD *)(a1 + 16) == 2)
    {
      **(double **)(a3 + 8) = *(double *)(*(void *)(a1 + 8) + 24) / v7;
      *(double *)(*(void *)(a3 + 8) + 8) = -*(double *)(*(void *)(a1 + 8) + 8) / v7;
      *(double *)(*(void *)(a3 + 8) + 16) = -*(double *)(*(void *)(a1 + 8) + 16) / v7;
      *(double *)(*(void *)(a3 + 8) + 24) = **(double **)(a1 + 8) / v7;
    }
    else
    {
      uint64_t v8 = *(unsigned int *)(a1 + 20);
      if (v8)
      {
        unint64_t v9 = 0;
        unint64_t v10 = *(unsigned int *)(a3 + 16);
        int v11 = 5;
        unsigned int v12 = 1;
        int v13 = 8;
        unsigned int v14 = 2;
        int v15 = 7;
        int v16 = 4;
        do
        {
          unsigned int v17 = 0;
          unint64_t v18 = 0;
          unsigned int v19 = 9 * (v12 / 3);
          unsigned int v20 = 9 * (v14 / 3);
          unint64_t v21 = v9 + 1;
          unint64_t v22 = *(unsigned int *)(a3 + 20);
          unsigned int v23 = v11 - v19;
          unsigned int v24 = v13 - v20;
          unsigned int v25 = v15 - v20;
          unsigned int v26 = v16 - v19;
          unsigned int v27 = 2;
          unsigned int v28 = 1;
          do
          {
            if (v18 >= v10 || v9 >= v22) {
              __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
            }
            uint64_t v29 = *(void *)(a1 + 8);
            *(double *)(*(void *)(a3 + 8) + 8 * v9 + 8 * v17) = (*(double *)(v29
                                                                               + 8
                                                                               * (v18 + v26 - 3 * (v28 / 3)))
                                                                   * *(double *)(v29
                                                                               + 8
                                                                               * (v18 + v24 - 3 * (v27 / 3)))
                                                                   - *(double *)(v29
                                                                               + 8
                                                                               * (v18 + v23 - 3 * (v27 / 3)))
                                                                   * *(double *)(v29
                                                                               + 8
                                                                               * (v18 + v25 - 3 * (v28 / 3))))
                                                                  / v7;
            v17 += v22;
            ++v27;
            ++v28;
            ++v18;
          }
          while (v8 != v18);
          v11 += 3;
          ++v12;
          v13 += 3;
          ++v14;
          v15 += 3;
          v16 += 3;
          ++v9;
        }
        while (v21 != v8);
      }
    }
  }
}

void sub_246997BF0(_Unwind_Exception *a1)
{
  Matrix<double>::~Matrix(v1);
  _Unwind_Resume(a1);
}

void GridArea::SaveToDictionary()
{
  if (gDbgLvl) {
    operator new[]();
  }
}

void sub_246997E68(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v21 < 0) {
    operator delete(v20);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

BOOL GridArea::isMinimumOnBorder(float *a1, int a2, void *a3)
{
  uint64_t v3 = *(void *)a1;
  uint64_t v4 = *((unsigned int *)a1 + 5);
  if (v4)
  {
    uint64_t v5 = 0;
    LODWORD(v6) = 0;
    double v7 = (double *)(v3 + 16);
    double v8 = 1.79769313e308;
    do
    {
      unint64_t v9 = v7 + 1;
      if (!a2) {
        unint64_t v9 = v7;
      }
      if (*v9 >= v8) {
        uint64_t v6 = v6;
      }
      else {
        uint64_t v6 = v5;
      }
      if (*v9 < v8) {
        double v8 = *v9;
      }
      ++v5;
      v7 += 4;
    }
    while (v4 != v5);
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v10 = v3 + 32 * v6;
  *a3 = v10;
  float v11 = *(float *)(v10 + 4);
  BOOL result = 1;
  if (v11 != a1[6] && v11 != a1[7])
  {
    float v12 = *(float *)(v3 + 32 * v6 + 8);
    if (v12 != a1[8] && v12 != a1[9]) {
      return 0;
    }
  }
  return result;
}

double Matrix<double>::Det(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 16);
  if (v1 != 2)
  {
    if (v1 == 3 && *(_DWORD *)(a1 + 20) == 3)
    {
      uint64_t v2 = *(double **)(a1 + 8);
      return *v2 * (v2[4] * v2[8] - v2[5] * v2[7])
           - v2[1] * (v2[3] * v2[8] - v2[5] * v2[6])
           + v2[2] * (v2[3] * v2[7] - v2[4] * v2[6]);
    }
LABEL_8:
    Matrix<double>::Det();
  }
  if (*(_DWORD *)(a1 + 20) != 2) {
    goto LABEL_8;
  }
  return **(double **)(a1 + 8) * *(double *)(*(void *)(a1 + 8) + 24)
       - *(double *)(*(void *)(a1 + 8) + 8) * *(double *)(*(void *)(a1 + 8) + 16);
}

void Matrix<double>::Inverse()
{
  __assert_rtn("Inverse", "Matrix.hpp", 1209, "(m_rows == 3 && m_cols == 3) || (m_rows == 2 && m_cols == 2)");
}

void Matrix<double>::Det()
{
  __assert_rtn("Det", "Matrix.hpp", 1196, "(m_rows == 3 && m_cols == 3) || (m_rows == 2 && m_cols == 2)");
}

void PearlInternalIRIsf::PearlInternalIRIsf(PearlInternalIRIsf *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 11) = 0x7FF8000000000000;
  *(_OWORD *)((char *)this + 72) = xmmword_2469EE788;
  *((_WORD *)this + 80) = 0;
  *((unsigned char *)this + 162) = 0;
  *((_DWORD *)this + 41) = 0;
  *(void *)this = &unk_26FAECF48;
  *(_OWORD *)((char *)this + 120) = xmmword_2469EE700;
  *((_DWORD *)this + 34) = 1;
  *(void *)((char *)this + 148) = 4;
  *((_DWORD *)this + 39) = 2;
  operator new[]();
}

void sub_246998150(_Unwind_Exception *a1)
{
  IsfInternal::~IsfInternal(v1);
  _Unwind_Resume(a1);
}

void PearlInternalIRIsf::~PearlInternalIRIsf(PearlInternalIRIsf *this)
{
  *(void *)this = &unk_26FAECF48;
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    MEMORY[0x24C53D6C0](v2, 0x1000C8000313F17);
  }
  uint64_t v3 = *((void *)this + 13);
  if (v3) {
    MEMORY[0x24C53D6C0](v3, 0x1000C8000313F17);
  }

  IsfInternal::~IsfInternal(this);
}

{
  uint64_t vars8;

  PearlInternalIRIsf::~PearlInternalIRIsf(this);

  JUMPOUT(0x24C53D6E0);
}

uint64_t PearlInternalIRIsf::updatePCECalib(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = IsfInternal::CalcNewRotation(a1, a2);
  if (!v5)
  {
    uint64_t v15 = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = *(_OWORD *)(a1 + 72);
    uint64_t v10 = *(void *)(a1 + 88);
    GeomUtils::CalcRotationMatrix<double>((double *)&v9, (uint64_t)&v11);
    long long v6 = v14;
    *(_OWORD *)(a3 + 32) = v13;
    *(_OWORD *)(a3 + 48) = v6;
    *(void *)(a3 + 64) = v15;
    long long v7 = v12;
    *(_OWORD *)a3 = v11;
    *(_OWORD *)(a3 + 16) = v7;
  }
  return v5;
}

uint64_t GeomUtils::CalcRotationMatrix<double>(double *a1, uint64_t a2)
{
  v4[0] = &unk_26FAEAF18;
  v4[1] = a2;
  uint64_t v4[2] = 0x300000003;
  char v5 = 0;
  uint64_t v2 = GeomUtils::CalcRotationMatrix<double>((uint64_t)v4, *a1 / 1000.0, a1[1] / 1000.0, a1[2] / 1000.0);
  Matrix<double>::~Matrix((uint64_t)v4);
  return v2;
}

void sub_24699833C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t PearlInternalIRIsf::StepDetection(PearlInternalIRIsf *this)
{
  return 256;
}

void PearlInternalIsf::PearlInternalIsf(PearlInternalIsf *this)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 11) = 0x7FF8000000000000;
  *(_OWORD *)((char *)this + 72) = xmmword_2469EE800;
  *((_WORD *)this + 80) = 0;
  *((unsigned char *)this + 162) = 0;
  *((_DWORD *)this + 41) = 0;
  *(void *)this = &unk_26FAECF98;
  *(_OWORD *)((char *)this + 120) = xmmword_2469EE7B0;
  *(_OWORD *)((char *)this + 136) = xmmword_2469EE7C0;
  *((void *)this + 19) = 0xF00000007;
  operator new[]();
}

void sub_246998440(_Unwind_Exception *a1)
{
  IsfInternal::~IsfInternal(v1);
  _Unwind_Resume(a1);
}

void PearlInternalIsf::~PearlInternalIsf(PearlInternalIsf *this)
{
  *(void *)this = &unk_26FAECF98;
  uint64_t v2 = *((void *)this + 12);
  if (v2) {
    MEMORY[0x24C53D6C0](v2, 0x1000C8000313F17);
  }
  uint64_t v3 = *((void *)this + 13);
  if (v3) {
    MEMORY[0x24C53D6C0](v3, 0x1000C8000313F17);
  }

  IsfInternal::~IsfInternal(this);
}

{
  uint64_t vars8;

  PearlInternalIsf::~PearlInternalIsf(this);

  JUMPOUT(0x24C53D6E0);
}

uint64_t PearlInternalIsf::updatePCECalib(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = IsfInternal::CalcNewRotation(a1, a2);
  if (!v5)
  {
    uint64_t v15 = 0;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v9 = *(_OWORD *)(a1 + 72);
    uint64_t v10 = *(void *)(a1 + 88);
    GeomUtils::CalcRotationMatrix<double>((double *)&v9, (uint64_t)&v11);
    long long v6 = v14;
    *(_OWORD *)(a3 + 32) = v13;
    *(_OWORD *)(a3 + 48) = v6;
    *(void *)(a3 + 64) = v15;
    long long v7 = v12;
    *(_OWORD *)a3 = v11;
    *(_OWORD *)(a3 + 16) = v7;
  }
  return v5;
}

uint64_t PearlInternalIsf::StepDetection(PearlInternalIsf *this)
{
  return 256;
}

void PearlIsf::PearlIsf(PearlIsf *this)
{
  *(void *)this = &unk_26FAECFD8;
  operator new();
}

void sub_246998664(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x10A1C4036002B25);
  _Unwind_Resume(a1);
}

void PearlIsf::~PearlIsf(PearlIsf *this)
{
  *(void *)this = &unk_26FAECFD8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;

  *(void *)this = &unk_26FAECFD8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_26FAECFD8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x24C53D6E0);
}

uint64_t PearlIsf::RunFromGmc(uint64_t a1, _DWORD *a2, int64x2_t *a3, double a4, double a5, double a6)
{
  return Isf::RunIsf(a4, a5, a6, NAN, a1, *(void **)(a1 + 8), a2, 2, a3);
}

uint64_t PearlIsf::RunFromLmv(uint64_t a1, _DWORD *a2, int64x2_t *a3, double a4, double a5, double a6)
{
  return Isf::RunIsf(a4, a5, a6, NAN, a1, *(void **)(a1 + 8), a2, 0, a3);
}

uint64_t PearlIsf::RunFromMiFullGrid(uint64_t a1, _DWORD *a2, int64x2_t *a3, double a4, double a5, double a6, double a7)
{
  return Isf::RunIsf(a4, a5, a6, a7, a1, *(void **)(a1 + 8), a2, 1, a3);
}

uint64_t PearlIsf::updatePCECalib(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return PearlInternalIsf::updatePCECalib(*(void *)(a1 + 8), a2, a3 + 8552);
}

void MetalMgt::MetalMgt(MetalMgt *this)
{
  *((void *)this + 3) = 850045863;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *((void *)this + 13) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  id v2 = MTLCreateSystemDefaultDevice();
  uint64_t v3 = *(void **)this;
  *(void *)this = v2;

  uint64_t v4 = [*(id *)this newCommandQueue];
  uint64_t v5 = (void *)*((void *)this + 1);
  *((void *)this + 1) = v4;

  uint64_t v6 = [*(id *)this newDefaultLibrary];
  long long v7 = (void *)*((void *)this + 2);
  *((void *)this + 2) = v6;

  *((void *)this + 12) = 0;
  double v8 = [NSURL fileURLWithPath:@"/System/Library/PrivateFrameworks/H16ISPServices.framework/CalibrateRgbIr.metallib"];
  long long v9 = *(void **)this;
  id v21 = 0;
  uint64_t v10 = [v9 newLibraryWithURL:v8 error:&v21];
  id v11 = v21;
  long long v12 = (void *)*((void *)this + 2);
  *((void *)this + 2) = v10;

  uint64_t v13 = [*((id *)this + 2) newFunctionWithName:@"Algo_DistortRadialLiteInternal"];
  long long v14 = (void *)*((void *)this + 11);
  *((void *)this + 11) = v13;

  uint64_t v15 = *((void *)this + 11);
  if (!v15) {
    __assert_rtn("MetalMgt", "MetalObjects.mm", 42, "m_algo_DistortRadialLiteInternal_func != 0");
  }
  int v16 = *(void **)this;
  id v20 = 0;
  uint64_t v17 = [v16 newComputePipelineStateWithFunction:v15 error:&v20];
  id v18 = v20;
  unsigned int v19 = (void *)*((void *)this + 13);
  *((void *)this + 13) = v17;
}

void sub_2469989BC(_Unwind_Exception *a1)
{
  std::mutex::~mutex(v2);
  _Unwind_Resume(a1);
}

uint64_t MetalObjects::init(MetalObjects *this)
{
  *(void *)this = objc_opt_new();

  return MEMORY[0x270F9A758]();
}

void MetalObjects::createTexture(void *a1, void *a2, int a3, int a4)
{
  std::mutex::lock((std::mutex *)(a1[2] + 24));
  id v8 = (id)[*(id *)a1[2] newBufferWithLength:4 * a4 * a3 options:0];
  std::mutex::unlock((std::mutex *)(a1[2] + 24));
  [(id)*a1 setPixelFormat:55];
  [(id)*a1 setTextureType:2];
  [(id)*a1 setHeight:a3];
  [(id)*a1 setWidth:a4];
  *a2 = (id)[v8 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:4 * a4];
}

void sub_246998B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void MetalObjects::createTextureMedian(void *a1, void *a2, int *a3, int a4, int a5, int a6, int a7)
{
  [(id)*a1 setTextureType:2];
  [(id)*a1 setHeight:a4];
  [(id)*a1 setWidth:a5];
  if (a7)
  {
    id v17 = 0;
    MetalObjects::createBuffer((uint64_t)a1, &v17, a4, a6);
    id v15 = v17;
    [(id)*a1 setPixelFormat:10];
    [(id)*a1 setUsage:3];
    long long v14 = (void *)[v15 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:a6];
  }
  else
  {
    id v16 = 0;
    MetalObjects::createBuffer((uint64_t)a1, &v16, a3, a6 * a4);
    id v15 = v16;
    [(id)*a1 setPixelFormat:10];
    [(id)*a1 setUsage:1];
    [(id)*a1 setResourceOptions:*(void *)(a1[2] + 96)];
    long long v14 = (void *)[v15 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:a6];
  }
  *a2 = v14;
}

void sub_246998C98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void MetalObjects::createBuffer(uint64_t a1, void *a2, int a3, int a4)
{
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  *a2 = (id)[**(id **)(a1 + 16) newBufferWithLength:4 * a4 * a3 options:*(void *)(*(void *)(a1 + 16) + 96)];
  id v8 = (std::mutex *)(*(void *)(a1 + 16) + 24);

  std::mutex::unlock(v8);
}

void MetalObjects::createBuffer(uint64_t a1, void *a2, int *a3, unint64_t a4)
{
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  uint64_t v8 = *(void *)(a1 + 16);
  long long v9 = *(void **)v8;
  if (a4 < 0x14)
  {
    id v10 = (id)[v9 newBufferWithLength:20 options:*(void *)(v8 + 96)];
    *a2 = v10;
    id v11 = (_DWORD *)[v10 contents];
    if (a4 >= 4)
    {
      unint64_t v12 = a4 >> 2;
      do
      {
        int v13 = *a3++;
        *v11++ = v13;
        --v12;
      }
      while (v12);
    }
  }
  else
  {
    *a2 = (id)[v9 newBufferWithBytes:a3 length:a4 options:*(void *)(v8 + 96)];
  }
  long long v14 = (std::mutex *)(*(void *)(a1 + 16) + 24);

  std::mutex::unlock(v14);
}

void MetalObjects::createTexture(id *a1, void *a2, int *a3, int a4, int a5)
{
  uint64_t v24 = *MEMORY[0x263EF8340];
  id v15 = 0;
  MetalObjects::createBuffer((uint64_t)a1, &v15, a3, 4 * a5 * a4);
  id v10 = v15;
  [*a1 setPixelFormat:55];
  [*a1 setTextureType:2];
  [*a1 setHeight:a4];
  [*a1 setWidth:a5];
  if (*a1 && [*a1 width] && (uint64_t v11 = objc_msgSend(*a1, "height"), a3) && v11)
  {
    *a2 = (id)[v10 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:4 * a5];
  }
  else
  {
    unint64_t v12 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      os_log_t v13 = os_log_create("com.apple.isp", "general");
      long long v14 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v13;

      unint64_t v12 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136315906;
      id v17 = "createTexture";
      __int16 v18 = 1024;
      int v19 = a4;
      __int16 v20 = 1024;
      int v21 = a5;
      __int16 v22 = 2048;
      unsigned int v23 = a3;
      _os_log_error_impl(&dword_24680F000, v12, OS_LOG_TYPE_ERROR, "RGB-IR: %s: rdar://112006283 Aborting texture creation rows: %d, cols: %d, buffer: %p\n", buf, 0x22u);
    }
  }
}

{
  id v9;
  id v10;
  uint64_t vars8;

  id v10 = 0;
  MetalObjects::createBuffer((uint64_t)a1, &v10, a3, 2 * a5 * a4);
  long long v9 = v10;
  [*a1 setPixelFormat:23];
  [*a1 setTextureType:2];
  [*a1 setHeight:a4];
  [*a1 setWidth:a5];
  [*a1 setResourceOptions:0];
  *a2 = (id)[v9 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:2 * a5];
}

void sub_246998FA8(_Unwind_Exception *exception_object)
{
}

void sub_24699908C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9)
{
  _Unwind_Resume(a1);
}

void MetalObjects::Algo_DistortRadialLiteInternal(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, char a15)
{
  id v30 = a2;
  id v29 = a3;
  id v38 = a4;
  id v36 = a5;
  id v35 = a6;
  id v34 = a7;
  id v33 = a8;
  id v37 = a9;
  id v32 = a10;
  id v31 = a11;
  id v22 = a12;
  id v23 = a13;
  id v24 = a14;
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  unsigned int v25 = [*(id *)(*(void *)(a1 + 16) + 8) commandBuffer];
  std::mutex::unlock((std::mutex *)(*(void *)(a1 + 16) + 24));
  unsigned int v26 = [v25 computeCommandEncoder];
  [v26 setComputePipelineState:*(void *)(*(void *)(a1 + 16) + 104)];
  [v26 setTexture:v30 atIndex:0];
  [v26 setTexture:v29 atIndex:1];
  [v26 setTexture:v38 atIndex:2];
  [v26 setTexture:v37 atIndex:3];
  [v26 setTexture:v24 atIndex:4];
  [v26 setBuffer:v36 offset:0 atIndex:0];
  [v26 setBuffer:v35 offset:0 atIndex:1];
  [v26 setBuffer:v34 offset:0 atIndex:2];
  [v26 setBuffer:v33 offset:0 atIndex:3];
  [v26 setBuffer:v32 offset:0 atIndex:4];
  [v26 setBuffer:v31 offset:0 atIndex:5];
  [v26 setBuffer:v22 offset:0 atIndex:6];
  [v26 setBuffer:v23 offset:0 atIndex:7];
  unint64_t v27 = [*(id *)(*(void *)(a1 + 16) + 104) threadExecutionWidth];
  unint64_t v28 = [*(id *)(*(void *)(a1 + 16) + 104) maxTotalThreadsPerThreadgroup];
  v40[0] = (v27 + [v30 width] - 1) / v27;
  v40[1] = (v28 / v27 + [v30 height] - 1) / (v28 / v27);
  v40[2] = 1;
  v39[0] = v27;
  v39[1] = v28 / v27;
  v39[2] = 1;
  [v26 dispatchThreadgroups:v40 threadsPerThreadgroup:v39];
  [v26 endEncoding];
  [v25 commit];
  if (a15) {
    [v25 waitUntilCompleted];
  }
}

void sub_2469993C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

void MetalObjects::convultionFilter(uint64_t a1, void *a2, uint64_t a3, void *a4, int a5)
{
  id v12 = a2;
  id v9 = a4;
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  id v10 = (void *)[objc_alloc(MEMORY[0x263F13268]) initWithDevice:**(void **)(a1 + 16) kernelWidth:*(unsigned int *)(a3 + 20) kernelHeight:*(unsigned int *)(a3 + 16) weights:*(void *)(a3 + 8)];
  uint64_t v11 = [*(id *)(*(void *)(a1 + 16) + 8) commandBuffer];
  std::mutex::unlock((std::mutex *)(*(void *)(a1 + 16) + 24));
  [v10 encodeToCommandBuffer:v11 sourceTexture:v12 destinationTexture:v9];
  [v11 commit];
  if (a5) {
    [v11 waitUntilCompleted];
  }
}

void sub_246999540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void MetalObjects::medianFilter(uint64_t a1, void *a2, void *a3, unsigned int a4, int a5)
{
  id v12 = a2;
  id v9 = a3;
  std::mutex::lock((std::mutex *)(*(void *)(a1 + 16) + 24));
  id v10 = (void *)[objc_alloc(MEMORY[0x263F132A8]) initWithDevice:**(void **)(a1 + 16) kernelDiameter:a4];
  uint64_t v11 = [*(id *)(*(void *)(a1 + 16) + 8) commandBuffer];
  std::mutex::unlock((std::mutex *)(*(void *)(a1 + 16) + 24));
  [v10 encodeToCommandBuffer:v11 sourceTexture:v12 destinationTexture:v9];
  [v11 commit];
  if (a5) {
    [v11 waitUntilCompleted];
  }
}

void sub_24699965C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void IsfInternal::~IsfInternal(IsfInternal *this)
{
  *(void *)this = &unk_26FAED020;
  id v2 = (void *)*((void *)this + 1);
  if (v2)
  {
    *((void *)this + 2) = v2;
    operator delete(v2);
  }
}

uint64_t IsfInternal::ConvertSavedToInternalHistory(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1 + 8;
  *(void *)(a1 + 16) = *(void *)(a1 + 8);
  if (*(_DWORD *)a2 != *(_DWORD *)(a1 + 120)) {
    return 259;
  }
  if (*(unsigned char *)(a2 + 4) || (unsigned int v6 = *(_DWORD *)(a2 + 8), v6 == -1))
  {
    uint64_t result = 0;
    *(void *)(a1 + 32) = 0xFFFFFFFFLL;
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 40) = -1;
    *(void *)(a1 + 48) = -1;
    *(void *)(a1 + 56) = -1;
    return result;
  }
  if ((v6 & 0x80000000) != 0 || (unsigned int v7 = *(_DWORD *)(a1 + 124), v6 >= v7))
  {
    NSLog(&cfstr_IsfHistoryOlde.isa, *(unsigned int *)(a2 + 8));
    return 257;
  }
  unsigned int v8 = *(_DWORD *)(a2 + 12);
  if ((v8 & 0x80000000) != 0 || v8 >= v7)
  {
    NSLog(&cfstr_IsfHistoryNext.isa, *(unsigned int *)(a2 + 12));
    return 257;
  }
  BOOL v9 = __OFSUB__(v8, v6);
  int v10 = v8 - v6;
  if (!((v10 < 0) ^ v9 | (v10 == 0))) {
    unsigned int v7 = 0;
  }
  unsigned int v11 = v10 + v7;
  *(_DWORD *)(a1 + 64) = v11;
  std::vector<Isf::ReferenceRecord>::reserve((void **)(a1 + 8), (int)(v11 + 1));
  std::vector<Isf::ReferenceRecord>::__insert_with_size[abi:ne180100]<Isf::ReferenceRecord const*,Isf::ReferenceRecord const*>(v2, *(void *)(a1 + 16), (char *)(a2 + 40), (char *)(a2 + 40 + 72 * *(int *)(a1 + 64)), *(int *)(a1 + 64));
  uint64_t v12 = *(void *)(a1 + 8);
  if (v12 != *(void *)(a1 + 16))
  {
    os_log_t v13 = (unsigned int *)(v12 + 48);
    do
    {
      uint64_t v14 = 0;
      id v15 = v13;
      do
      {
        uint64_t v16 = v15[3];
        if ((v16 & 0x80000000) != 0)
        {
          if (v16 != -1)
          {
LABEL_39:
            NSLog(&cfstr_IsfElementPrev.isa, v14, v16);
            return 257;
          }
        }
        else if ((int)v16 >= *(_DWORD *)(a1 + 64))
        {
          goto LABEL_39;
        }
        uint64_t v17 = *v15;
        if ((v17 & 0x80000000) != 0)
        {
          if (v17 != -1)
          {
LABEL_40:
            NSLog(&cfstr_IsfElementNext.isa, v14, v17);
            return 257;
          }
        }
        else if ((int)v17 >= *(_DWORD *)(a1 + 64))
        {
          goto LABEL_40;
        }
        *(unsigned char *)(v12 + v14++ + 45) = 1;
        ++v15;
      }
      while (v14 != 3);
      *(unsigned char *)(v12 + 44) = 1;
      *(double *)(v12 + 32) = IsfInternal::GetInitialWeightForRecord(a1, v12);
      v12 += 72;
      v13 += 18;
    }
    while (v12 != *(void *)(a1 + 16));
  }
  uint64_t v18 = 0;
  *(void *)(a1 + 32) = *(void *)(a2 + 8);
  int v19 = (unsigned int *)(a2 + 28);
  for (uint64_t i = (_DWORD *)(a1 + 52); ; ++i)
  {
    unsigned int v21 = *(v19 - 3);
    if ((v21 & 0x80000000) != 0)
    {
      if (v21 != -1)
      {
LABEL_41:
        uint64_t v24 = *(v19 - 3);
        goto LABEL_43;
      }
    }
    else if (v21 >= *(_DWORD *)(a1 + 124))
    {
      goto LABEL_41;
    }
    unsigned int v22 = *v19;
    if ((*v19 & 0x80000000) != 0) {
      break;
    }
    if (v22 >= *(_DWORD *)(a1 + 124)) {
      goto LABEL_42;
    }
LABEL_34:
    uint64_t result = 0;
    *(i - 3) = v21;
    int v23 = *v19++;
    *uint64_t i = v23;
    if (++v18 == 3) {
      return result;
    }
  }
  if (v22 == -1) {
    goto LABEL_34;
  }
LABEL_42:
  uint64_t v24 = *v19;
LABEL_43:
  NSLog(&cfstr_IsfHistoryHead.isa, v18, v24);
  return 257;
}

void std::vector<Isf::ReferenceRecord>::reserve(void **a1, unint64_t a2)
{
  uint64_t v4 = a1[2];
  uint64_t v3 = (uint64_t)(a1 + 2);
  if (0x8E38E38E38E38E39 * ((v4 - (unsigned char *)*a1) >> 3) < a2)
  {
    if (a2 >= 0x38E38E38E38E38FLL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v5 = ((unsigned char *)a1[1] - (unsigned char *)*a1) / 72;
    unsigned int v6 = (char *)std::allocator<Isf::ReferenceRecord>::allocate_at_least[abi:ne180100](v3, a2);
    unsigned int v7 = &v6[72 * v5];
    BOOL v9 = &v6[72 * v8];
    unsigned int v11 = (char *)*a1;
    int v10 = (char *)a1[1];
    uint64_t v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *(_OWORD *)(v12 - 72) = *(_OWORD *)(v10 - 72);
        long long v13 = *(_OWORD *)(v10 - 56);
        long long v14 = *(_OWORD *)(v10 - 40);
        long long v15 = *(_OWORD *)(v10 - 24);
        *((void *)v12 - 1) = *((void *)v10 - 1);
        *(_OWORD *)(v12 - 24) = v15;
        *(_OWORD *)(v12 - 40) = v14;
        *(_OWORD *)(v12 - 56) = v13;
        v12 -= 72;
        v10 -= 72;
      }
      while (v10 != v11);
      int v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
    {
      operator delete(v10);
    }
  }
}

double IsfInternal::GetInitialWeightForRecord(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 148);
  if (v2)
  {
    uint64_t v3 = 0;
    while (*(double *)(a2 + 24) >= *(double *)(*(void *)(a1 + 96) + 8 * v3))
    {
      if (v2 == ++v3)
      {
        uint64_t v3 = *(unsigned int *)(a1 + 148);
        return *(double *)(*(void *)(a1 + 104) + 8 * v3);
      }
    }
  }
  else
  {
    uint64_t v3 = 0;
  }
  return *(double *)(*(void *)(a1 + 104) + 8 * v3);
}

uint64_t IsfInternal::RemoveOldestRecord(IsfInternal *this)
{
  unsigned int v1 = *((_DWORD *)this + 8);
  if ((v1 & 0x80000000) != 0 || v1 >= *((_DWORD *)this + 31))
  {
    NSLog(&cfstr_IsfS.isa, "Error: oldest index record is out of range.");
    return 257;
  }
  else
  {
    uint64_t v2 = 0;
    uint64_t v3 = 0;
    uint64_t v4 = *((void *)this + 1);
    unint64_t v5 = 0x8E38E38E38E38E39 * ((*((void *)this + 2) - v4) >> 3);
    unsigned int v6 = (char *)this + 52;
    do
    {
      unint64_t v7 = *((int *)this + 8);
      if (v5 <= v7) {
LABEL_21:
      }
        std::vector<ImageUtils::Blob>::__throw_out_of_range[abi:ne180100]();
      uint64_t v8 = v4 + 72 * (int)v7 + v2;
      int v9 = *(_DWORD *)(v8 + 60);
      int v10 = *(_DWORD *)(v8 + 48);
      if (v10 == -1)
      {
        if (*(_DWORD *)&v6[v2] != v7) {
          IsfInternal::RemoveOldestRecord();
        }
        unsigned int v11 = (_DWORD *)((char *)this + 4 * v3 + 52);
      }
      else
      {
        if (v5 <= v10) {
          goto LABEL_21;
        }
        unsigned int v11 = (_DWORD *)(v4 + v2 + 72 * v10 + 60);
      }
      *unsigned int v11 = v9;
      if (v9 == -1)
      {
        if (*(_DWORD *)&v6[v2 - 12] != *((_DWORD *)this + 8)) {
          IsfInternal::RemoveOldestRecord();
        }
        uint64_t v12 = (_DWORD *)((char *)this + 4 * v3 + 40);
      }
      else
      {
        if (v5 <= v9) {
          goto LABEL_21;
        }
        uint64_t v12 = (_DWORD *)(v4 + v2 + 72 * v9 + 48);
      }
      *uint64_t v12 = v10;
      ++v3;
      v2 += 4;
    }
    while (v2 != 12);
    uint64_t v13 = 0;
    *((_DWORD *)this + 8) = (*((_DWORD *)this + 8) + 1) % *((_DWORD *)this + 31);
    --*((_DWORD *)this + 16);
  }
  return v13;
}

uint64_t IsfInternal::GetElementIdx(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(int *)(a2 + 60);
  if (v2 == -1)
  {
    uint64_t v4 = (unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 8);
    if (0x8E38E38E38E38E39 * ((*(void *)(a1 + 16) - v3) >> 3) <= v2) {
      std::vector<ImageUtils::Blob>::__throw_out_of_range[abi:ne180100]();
    }
    uint64_t v4 = (unsigned int *)(v3 + 72 * (int)v2 + 48);
  }
  return *v4;
}

uint64_t IsfInternal::InsertRecordInSortedList(IsfInternal *this, int a2, int a3)
{
  unsigned int v3 = *((_DWORD *)this + 16);
  if (v3 >= *((_DWORD *)this + 31)) {
    IsfInternal::InsertRecordInSortedList();
  }
  uint64_t v4 = *((void *)this + 1);
  unint64_t v5 = 0x8E38E38E38E38E39 * ((*((void *)this + 2) - v4) >> 3);
  if (v5 <= a3) {
    goto LABEL_11;
  }
  uint64_t v6 = a2;
  unint64_t v7 = (int *)((char *)this + 4 * a2 + 40);
  if (!v3)
  {
    int *v7 = a3;
    *((_DWORD *)this + a2 + 13) = a3;
    uint64_t v18 = v4 + 72 * a3 + 4 * a2;
    *(_DWORD *)(v18 + 48) = -1;
    *(_DWORD *)(v18 + 60) = -1;
    return 0;
  }
  int v8 = *v7;
  if (*v7 == -1) {
    IsfInternal::InsertRecordInSortedList();
  }
  int v9 = (char *)this + 4 * a2;
  int v11 = *((_DWORD *)v9 + 13);
  int v10 = (int *)(v9 + 52);
  if (v11 == -1) {
    IsfInternal::InsertRecordInSortedList();
  }
  uint64_t v12 = v8;
  if (v5 <= v8) {
LABEL_11:
  }
    std::vector<ImageUtils::Blob>::__throw_out_of_range[abi:ne180100]();
  double v13 = *(double *)(v4 + 72 * a3 + 8 * a2);
  while (1)
  {
    if (*(double *)(v4 + 8 * v6 + 72 * v12) >= v13)
    {
      uint64_t v19 = v4 + 72 * v12 + 4 * v6;
      uint64_t v20 = v4 + 72 * a3 + 4 * v6;
      *(_DWORD *)(v20 + 60) = *(_DWORD *)(v19 + 60);
      unsigned int v21 = (int *)(v20 + 60);
      *(_DWORD *)(v19 + 60) = a3;
      *(v21 - 3) = v8;
      if (*v7 == v8)
      {
        int *v7 = a3;
        return 0;
      }
      unint64_t v22 = *v21;
      if (v5 > v22)
      {
        *(_DWORD *)(v4 + 72 * (int)v22 + 4 * v6 + 48) = a3;
        return 0;
      }
      goto LABEL_11;
    }
    uint64_t v14 = v4 + 72 * v12 + 4 * v6;
    int v17 = *(_DWORD *)(v14 + 48);
    uint64_t v16 = (int *)(v14 + 48);
    int v15 = v17;
    if (v17 == -1) {
      break;
    }
    uint64_t v12 = v15;
    int v8 = v15;
    if (v5 <= v15) {
      goto LABEL_11;
    }
  }
  int *v16 = a3;
  *(_DWORD *)(v4 + 72 * a3 + 4 * v6 + 60) = v8;
  if (*v10 != v8) {
    IsfInternal::InsertRecordInSortedList();
  }
  *(_DWORD *)(v4 + 72 * a3 + 4 * v6 + 48) = -1;
  *int v10 = a3;
  return 0;
}

uint64_t IsfInternal::InsertNewRecord(uint64_t a1, int a2, double a3, double a4, double a5, double a6)
{
  if (*(_DWORD *)(a1 + 64) == *(_DWORD *)(a1 + 124))
  {
    if (IsfInternal::RemoveOldestRecord((IsfInternal *)a1)) {
      return 256;
    }
    int v25 = *(_DWORD *)(a1 + 36);
    uint64_t v26 = *(void *)(a1 + 8);
    unint64_t v27 = v25;
    unint64_t v28 = 0x8E38E38E38E38E39 * ((*(void *)(a1 + 16) - v26) >> 3);
  }
  else
  {
    unint64_t v15 = *(void *)(a1 + 24);
    uint64_t v13 = a1 + 24;
    unint64_t v14 = v15;
    unint64_t v16 = *(void *)(v13 - 8);
    if (v16 >= v15)
    {
      uint64_t v18 = (void **)(v13 - 16);
      uint64_t v19 = *(void *)(v13 - 16);
      unint64_t v20 = 0x8E38E38E38E38E39 * ((uint64_t)(v16 - v19) >> 3);
      unint64_t v21 = v20 + 1;
      if (v20 + 1 > 0x38E38E38E38E38ELL) {
        std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
      }
      unint64_t v22 = 0x8E38E38E38E38E39 * ((uint64_t)(v14 - v19) >> 3);
      if (2 * v22 > v21) {
        unint64_t v21 = 2 * v22;
      }
      if (v22 >= 0x1C71C71C71C71C7) {
        unint64_t v23 = 0x38E38E38E38E38ELL;
      }
      else {
        unint64_t v23 = v21;
      }
      if (v23) {
        uint64_t v24 = (char *)std::allocator<Isf::ReferenceRecord>::allocate_at_least[abi:ne180100](v13, v23);
      }
      else {
        uint64_t v24 = 0;
      }
      id v29 = &v24[72 * v20];
      id v30 = &v24[72 * v23];
      int v17 = v29 + 72;
      id v32 = *(char **)(a1 + 8);
      id v31 = *(char **)(a1 + 16);
      if (v31 != v32)
      {
        do
        {
          *(_OWORD *)(v29 - 72) = *(_OWORD *)(v31 - 72);
          long long v33 = *(_OWORD *)(v31 - 56);
          long long v34 = *(_OWORD *)(v31 - 40);
          long long v35 = *(_OWORD *)(v31 - 24);
          *((void *)v29 - 1) = *((void *)v31 - 1);
          *(_OWORD *)(v29 - 24) = v35;
          *(_OWORD *)(v29 - 40) = v34;
          *(_OWORD *)(v29 - 56) = v33;
          v29 -= 72;
          v31 -= 72;
        }
        while (v31 != v32);
        id v31 = (char *)*v18;
      }
      *(void *)(a1 + 8) = v29;
      *(void *)(a1 + 16) = v17;
      *(void *)(a1 + 24) = v30;
      if (v31) {
        operator delete(v31);
      }
    }
    else
    {
      int v17 = (char *)(v16 + 72);
    }
    *(void *)(a1 + 16) = v17;
    uint64_t v26 = *(void *)(a1 + 8);
    unint64_t v28 = 0x8E38E38E38E38E39 * ((uint64_t)&v17[-v26] >> 3);
    int v25 = *(_DWORD *)(a1 + 36);
    unint64_t v27 = v25;
    if (v28 != v25 + 1) {
      IsfInternal::InsertNewRecord();
    }
  }
  if (v28 <= v27) {
    std::vector<ImageUtils::Blob>::__throw_out_of_range[abi:ne180100]();
  }
  if (*(_DWORD *)(a1 + 32) == v25) {
    IsfInternal::InsertNewRecord();
  }
  id v36 = (double *)(v26 + 72 * (int)v27);
  if (!*(_DWORD *)(a1 + 64)) {
    *(_DWORD *)(a1 + 32) = v25;
  }
  *id v36 = a3;
  v36[1] = a4;
  v36[2] = a5;
  uint64_t v37 = v26 + 72 * (int)v27;
  *(_DWORD *)(v37 + 40) = a2;
  *(double *)(v37 + 24) = a6;
  NSLog(&cfstr_IsfNewCalibrat.isa, *(void *)&a6);
  int v38 = 0;
  *(double *)(v37 + 32) = IsfInternal::GetInitialWeightForRecord(a1, (uint64_t)v36);
  do
    IsfInternal::InsertRecordInSortedList((IsfInternal *)a1, v38++, *(_DWORD *)(a1 + 36));
  while (v38 != 3);
  uint64_t result = 0;
  *(_DWORD *)(a1 + 36) = (*(_DWORD *)(a1 + 36) + 1) % *(_DWORD *)(a1 + 124);
  ++*(_DWORD *)(a1 + 64);
  return result;
}

uint64_t IsfInternal::OutlierDetectAndWeight(IsfInternal *this)
{
  unsigned int v1 = *((_DWORD *)this + 31);
  int v2 = *((_DWORD *)this + 32);
  if (v1 == v2)
  {
    signed int v3 = *((_DWORD *)this + 39);
    if (*((unsigned char *)this + 162)) {
      signed int v3 = vcvtps_s32_f32((float)((float)v3 * (float)(v1 - *((_DWORD *)this + 41))) / (float)v1);
    }
  }
  else
  {
    signed int v3 = (*((_DWORD *)this + 16) - v2) * (*((_DWORD *)this + 39) - *((_DWORD *)this + 38)) / (v1 - v2)
       + *((_DWORD *)this + 38);
  }
  uint64_t v4 = *((void *)this + 1);
  unint64_t v5 = *((int *)this + 10);
  uint64_t v6 = *((void *)this + 2);
  unint64_t v7 = 0x8E38E38E38E38E39 * ((v6 - v4) >> 3);
  if (v7 <= v5) {
    goto LABEL_33;
  }
  unint64_t v8 = 0;
  while (1)
  {
    unint64_t v9 = *(_DWORD *)(v4 + 72 * v5 + 40) == 4 ? 3 : 2;
    if (v8 >= v9) {
      return 0;
    }
    int v10 = (char *)this + 4 * v8;
    unint64_t v13 = *((int *)v10 + 10);
    uint64_t v12 = (int *)(v10 + 40);
    int v11 = v13;
    if (v7 <= v13) {
      goto LABEL_33;
    }
    if (v3 >= 1)
    {
      signed int v14 = 0;
      uint64_t v15 = v4 + 72 * v11;
      unint64_t v16 = (int *)((char *)this + 4 * v8 + 52);
      do
      {
        unint64_t v17 = *v16;
        if (0x8E38E38E38E38E39 * ((v6 - v4) >> 3) <= v17) {
          goto LABEL_33;
        }
        if (v15 == v4 + 72 * (int)v17) {
          break;
        }
        if (*(unsigned char *)(v15 + 44))
        {
          *(unsigned char *)(v15 + v8 + 45) = 0;
          *(void *)(v15 + 32) = *((void *)this + 14);
          ++v14;
        }
        unint64_t v18 = *(int *)(v15 + 4 * v8 + 48);
        if (v18 == -1) {
          IsfInternal::OutlierDetectAndWeight();
        }
        uint64_t v4 = *((void *)this + 1);
        uint64_t v6 = *((void *)this + 2);
        if (0x8E38E38E38E38E39 * ((v6 - v4) >> 3) <= v18) {
          goto LABEL_33;
        }
        uint64_t v15 = v4 + 72 * (int)v18;
      }
      while (v14 < v3);
      unint64_t v19 = *v16;
      if (0x8E38E38E38E38E39 * ((v6 - v4) >> 3) > v19)
      {
        signed int v20 = 0;
        uint64_t v21 = v4 + 72 * (int)v19;
        while (1)
        {
          unint64_t v22 = *v12;
          unint64_t v7 = 0x8E38E38E38E38E39 * ((v6 - v4) >> 3);
          if (v7 <= v22) {
            break;
          }
          if (v21 == v4 + 72 * (int)v22) {
            goto LABEL_32;
          }
          if (*(unsigned char *)(v21 + 44))
          {
            *(unsigned char *)(v21 + v8 + 45) = 0;
            *(void *)(v21 + 32) = *((void *)this + 14);
            ++v20;
          }
          unint64_t v23 = *(int *)(v21 + 4 * v8 + 60);
          if (v23 == -1) {
            IsfInternal::OutlierDetectAndWeight();
          }
          uint64_t v4 = *((void *)this + 1);
          uint64_t v6 = *((void *)this + 2);
          unint64_t v7 = 0x8E38E38E38E38E39 * ((v6 - v4) >> 3);
          if (v7 <= v23) {
            break;
          }
          uint64_t v21 = v4 + 72 * (int)v23;
          if (v20 >= v3) {
            goto LABEL_32;
          }
        }
      }
LABEL_33:
      std::vector<ImageUtils::Blob>::__throw_out_of_range[abi:ne180100]();
    }
    unint64_t v7 = 0x8E38E38E38E38E39 * ((v6 - v4) >> 3);
    if (v7 <= *((int *)this + v8 + 13)) {
      goto LABEL_33;
    }
LABEL_32:
    ++v8;
    unint64_t v5 = *((int *)this + 10);
    if (v7 <= v5) {
      goto LABEL_33;
    }
  }
}

void IsfInternal::CleanHistory(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 120);
  *((unsigned char *)a2 + 4) = 1;
  a2[2] = -1;
  *((void *)a2 + 2) = -1;
  *((void *)a2 + 3) = -1;
  *((void *)a2 + 4) = -1;
}

double IsfInternal::ConvertInternalHistoryToBufferToSave(uint64_t a1, uint64_t a2)
{
  signed int v3 = *(unsigned char **)(a1 + 8);
  uint64_t v4 = *(unsigned char **)(a1 + 16);
  if (0x8E38E38E38E38E39 * ((v4 - v3) >> 3) <= *(unsigned int *)(a1 + 124))
  {
    if (*(int *)(a1 + 64) >= 1) {
      *(unsigned char *)(a2 + 4) = 0;
    }
    if (v4 != v3) {
      memmove((void *)(a2 + 40), v3, v4 - v3);
    }
    double result = *(double *)(a1 + 32);
    *(double *)(a2 + 8) = result;
    uint64_t v7 = *(void *)(a1 + 40);
    *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 48);
    *(void *)(a2 + 16) = v7;
    uint64_t v8 = *(void *)(a1 + 52);
    *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 60);
    *(void *)(a2 + 28) = v8;
  }
  else
  {
    NSLog(&cfstr_IsfErrorExisti.isa, 0x8E38E38E38E38E39 * ((v4 - v3) >> 3));
  }
  return result;
}

uint64_t IsfInternal::StepDetection(IsfInternal *this)
{
  return 256;
}

uint64_t IsfInternal::CalculateWeightedAvgAngleValue(IsfInternal *this, double *a2)
{
  v11[3] = *MEMORY[0x263EF8340];
  memset(v11, 0, 24);
  memset(v10, 0, sizeof(v10));
  uint64_t v2 = *((void *)this + 1);
  uint64_t v3 = *((void *)this + 2);
  if (v2 == v3) {
    goto LABEL_10;
  }
  do
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      if (!*(unsigned char *)(v2 + i + 45) || !*(unsigned char *)(v2 + 44)) {
        continue;
      }
      if (i == 2 && (*(_DWORD *)(v2 + 40) - 2) > 2) {
        break;
      }
      double v5 = *(double *)(v2 + 32);
      *(double *)&v10[i] = v5 + *(double *)&v10[i];
      *(double *)&v11[i] = *(double *)&v11[i] + v5 * *(double *)(v2 + 8 * i);
    }
    v2 += 72;
  }
  while (v2 != v3);
LABEL_10:
  for (uint64_t j = 0; j != 3; ++j)
  {
    double v7 = *(double *)&v10[j];
    if (v7 == 0.0) {
      double v8 = NAN;
    }
    else {
      double v8 = *(double *)&v11[j] / v7;
    }
    a2[j] = v8;
  }
  return 0;
}

uint64_t IsfInternal::Run(uint64_t a1, _DWORD *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  *(unsigned char *)(a1 + 160) = 0;
  if (a3 != 2)
  {
    double v9 = a7;
    *(int64x2_t *)(a1 + 72) = vdupq_n_s64(0x7FF8000000000000uLL);
    *(void *)(a1 + 88) = 0x7FF8000000000000;
    NSLog(&cfstr_IsfVDDDNewCali.isa, 1, 3, 1, *(void *)&a4, *(void *)&a5, *(void *)&a6, *(void *)&a7, a3);
    if (IsfInternal::ConvertSavedToInternalHistory(a1, (uint64_t)a2))
    {
      bzero(a2, 0xE38uLL);
      *a2 = *(_DWORD *)(a1 + 120);
      *((unsigned char *)a2 + 4) = 1;
      a2[2] = -1;
      *((void *)a2 + 2) = -1;
      *((void *)a2 + 3) = -1;
      *((void *)a2 + 4) = -1;
      return 257;
    }
    switch((int)a3)
    {
      case 0:
        LODWORD(v15) = *(_DWORD *)(a1 + 144);
        double v9 = (double)v15;
        break;
      case 1:
      case 3:
      case 4:
        break;
      default:
        NSLog(&cfstr_IsfErrorCalibr.isa, a3);
        return 258;
    }
    uint64_t v16 = *(unsigned int *)(a1 + 136);
    if (v9 < (double)*(unsigned int *)(a1 + 132) || v9 > (double)v16)
    {
      NSLog(&cfstr_IsfConfidenceI.isa, *(void *)&v9, *(unsigned int *)(a1 + 132), v16);
      return 260;
    }
    bzero(a2, 0xE38uLL);
    *a2 = *(_DWORD *)(a1 + 120);
    *((unsigned char *)a2 + 4) = 1;
    a2[2] = -1;
    *((void *)a2 + 2) = -1;
    *((void *)a2 + 3) = -1;
    *((void *)a2 + 4) = -1;
    if (!IsfInternal::InsertNewRecord(a1, a3, a4, a5, a6, v9))
    {
      uint64_t v18 = *(unsigned int *)(a1 + 128);
      if (*(_DWORD *)(a1 + 64) < (int)v18)
      {
        NSLog(&cfstr_IsfHistoryDoes.isa, *(unsigned int *)(a1 + 64), v18);
        IsfInternal::ConvertInternalHistoryToBufferToSave(a1, (uint64_t)a2);
        if (v19) {
          return 256;
        }
        else {
          return 1;
        }
      }
      IsfInternal::ConvertInternalHistoryToBufferToSave(a1, (uint64_t)a2);
      if (!v20)
      {
        IsfInternal::CalcNewRotation(a1, (uint64_t)a2);
        return 0;
      }
    }
    return 256;
  }
  NSLog(&cfstr_IsfS.isa, "Error: Calibration result cannot be originated from GMC-RGB-IR.");
  return 258;
}

uint64_t IsfInternal::CalcNewRotation(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 160)) {
    return 0;
  }
  if (IsfInternal::ConvertSavedToInternalHistory(a1, a2)) {
    return 257;
  }
  uint64_t v4 = *(unsigned int *)(a1 + 128);
  if (*(_DWORD *)(a1 + 64) < (int)v4)
  {
    NSLog(&cfstr_IsfHistoryDoes.isa, *(unsigned int *)(a1 + 64), v4);
    return 1;
  }
  if (*(unsigned char *)(a1 + 161))
  {
    *(unsigned char *)(a1 + 162) = 0;
    *(_DWORD *)(a1 + 164) = 0;
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 16))(a1) == 261)
    {
      uint64_t v5 = *(void *)(a1 + 8);
      *(unsigned char *)(a1 + 162) = 1;
      unint64_t v6 = *(int *)(a1 + 32);
      unint64_t v7 = 0x8E38E38E38E38E39 * ((*(void *)(a1 + 16) - v5) >> 3);
      if (v7 <= v6) {
        goto LABEL_18;
      }
      uint64_t v8 = *(unsigned int *)(a1 + 164);
      if (v8)
      {
        int v9 = 0;
        unsigned int v10 = *(_DWORD *)(a1 + 124);
        while (1)
        {
          unint64_t v11 = ((int)v6 + v9) % v10;
          if (v7 <= v11) {
            break;
          }
          *(unsigned char *)(v5 + 72 * v11 + 44) = 0;
          if (v8 == ++v9) {
            goto LABEL_14;
          }
        }
LABEL_18:
        std::vector<ImageUtils::Blob>::__throw_out_of_range[abi:ne180100]();
      }
LABEL_14:
      uint64_t v12 = 1;
    }
    else
    {
      uint64_t v12 = *(unsigned __int8 *)(a1 + 162);
      uint64_t v8 = *(unsigned int *)(a1 + 164);
    }
    NSLog(&cfstr_IsfIsfStepDete.isa, v12, v8);
  }
  IsfInternal::OutlierDetectAndWeight((IsfInternal *)a1);
  IsfInternal::CalculateWeightedAvgAngleValue((IsfInternal *)a1, (double *)(a1 + 72));
  NSLog(&cfstr_IsfNewCalculat.isa, *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88));
  uint64_t result = 0;
  *(unsigned char *)(a1 + 160) = 1;
  return result;
}

uint64_t IsfInternal::setStepDetectionMode(uint64_t this, char a2)
{
  *(unsigned char *)(this + 161) = a2;
  return this;
}

void *std::allocator<Isf::ReferenceRecord>::allocate_at_least[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x38E38E38E38E38FLL) {
    std::__throw_bad_array_new_length[abi:ne180100]();
  }
  return operator new(72 * a2);
}

char *std::vector<Isf::ReferenceRecord>::__insert_with_size[abi:ne180100]<Isf::ReferenceRecord const*,Isf::ReferenceRecord const*>(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  uint64_t v5 = (char *)__dst;
  if (a5 < 1) {
    return v5;
  }
  unint64_t v7 = __src;
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v9 = a1 + 16;
  uint64_t v10 = v11;
  unint64_t v12 = *(void *)(v9 - 8);
  if ((uint64_t)(0x8E38E38E38E38E39 * ((uint64_t)(v11 - v12) >> 3)) < a5)
  {
    unint64_t v13 = *(void **)a1;
    unint64_t v14 = a5 - 0x71C71C71C71C71C7 * ((uint64_t)(v12 - *(void *)a1) >> 3);
    if (v14 > 0x38E38E38E38E38ELL) {
      std::vector<unsigned int>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v15 = 0x8E38E38E38E38E39 * ((__dst - (uint64_t)v13) >> 3);
    unint64_t v16 = 0x8E38E38E38E38E39 * ((v10 - (uint64_t)v13) >> 3);
    uint64_t v17 = 2 * v16;
    if (2 * v16 <= v14) {
      uint64_t v17 = v14;
    }
    if (v16 >= 0x1C71C71C71C71C7) {
      unint64_t v18 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v18 = v17;
    }
    uint64_t v41 = v9;
    if (v18) {
      int v19 = (char *)std::allocator<Isf::ReferenceRecord>::allocate_at_least[abi:ne180100](v9, v18);
    }
    else {
      int v19 = 0;
    }
    id v30 = &v19[72 * v15];
    __p = v19;
    int v38 = v30;
    uint64_t v40 = &v19[72 * v18];
    id v31 = &v30[72 * a5];
    uint64_t v32 = 72 * a5;
    do
    {
      *(_OWORD *)id v30 = *(_OWORD *)v7;
      long long v33 = *((_OWORD *)v7 + 1);
      long long v34 = *((_OWORD *)v7 + 2);
      long long v35 = *((_OWORD *)v7 + 3);
      *((void *)v30 + 8) = *((void *)v7 + 8);
      *((_OWORD *)v30 + 2) = v34;
      *((_OWORD *)v30 + 3) = v35;
      *((_OWORD *)v30 + 1) = v33;
      v30 += 72;
      v7 += 72;
      v32 -= 72;
    }
    while (v32);
    uint64_t v39 = v31;
    uint64_t v5 = (char *)std::vector<Isf::ReferenceRecord>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v5);
    if (v39 != v38) {
      uint64_t v39 = &v38[(v39 - v38 - 72) % 0x48uLL];
    }
    if (__p) {
      operator delete(__p);
    }
    return v5;
  }
  uint64_t v20 = v12 - __dst;
  if ((uint64_t)(0x8E38E38E38E38E39 * ((uint64_t)(v12 - __dst) >> 3)) >= a5)
  {
    uint64_t v21 = &__src[72 * a5];
    unint64_t v23 = *(char **)(v9 - 8);
LABEL_17:
    uint64_t v24 = &v5[72 * a5];
    int v25 = &v23[-72 * a5];
    uint64_t v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      uint64_t v26 = v23;
      do
      {
        *(_OWORD *)uint64_t v26 = *(_OWORD *)v25;
        long long v27 = *((_OWORD *)v25 + 1);
        long long v28 = *((_OWORD *)v25 + 2);
        long long v29 = *((_OWORD *)v25 + 3);
        *((void *)v26 + 8) = *((void *)v25 + 8);
        *((_OWORD *)v26 + 2) = v28;
        *((_OWORD *)v26 + 3) = v29;
        *((_OWORD *)v26 + 1) = v27;
        v25 += 72;
        v26 += 72;
      }
      while ((unint64_t)v25 < v12);
    }
    *(void *)(a1 + 8) = v26;
    if (v23 != v24) {
      memmove(&v5[72 * a5], v5, v23 - v24);
    }
    if (v21 != v7) {
      memmove(v5, v7, v21 - v7);
    }
    return v5;
  }
  uint64_t v21 = &__src[8 * ((uint64_t)(v12 - __dst) >> 3)];
  int64_t v22 = a4 - v21;
  if (a4 != v21) {
    memmove(*(void **)(v9 - 8), &__src[8 * ((uint64_t)(v12 - __dst) >> 3)], a4 - v21);
  }
  unint64_t v23 = (char *)(v12 + v22);
  *(void *)(a1 + 8) = v12 + v22;
  if (v20 >= 1) {
    goto LABEL_17;
  }
  return v5;
}

void sub_24699AC34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *std::vector<Isf::ReferenceRecord>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  uint64_t v5 = *(void **)(a2 + 8);
  unint64_t v6 = (char *)*a1;
  unint64_t v7 = v5;
  if (*a1 != __src)
  {
    uint64_t v8 = __src;
    uint64_t v9 = *(void *)(a2 + 8);
    do
    {
      *(_OWORD *)(v9 - 72) = *(_OWORD *)(v8 - 72);
      long long v10 = *(_OWORD *)(v8 - 56);
      long long v11 = *(_OWORD *)(v8 - 40);
      long long v12 = *(_OWORD *)(v8 - 24);
      unint64_t v7 = (void *)(v9 - 72);
      *(void *)(v9 - 8) = *((void *)v8 - 1);
      *(_OWORD *)(v9 - 24) = v12;
      *(_OWORD *)(v9 - 40) = v11;
      *(_OWORD *)(v9 - 56) = v10;
      v8 -= 72;
      v9 -= 72;
    }
    while (v8 != v6);
  }
  *(void *)(a2 + 8) = v7;
  unint64_t v13 = a1[1];
  uint64_t v14 = *(void *)(a2 + 16);
  int64_t v15 = v13 - __src;
  if (v13 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v13 - __src);
    unint64_t v7 = *(void **)(a2 + 8);
  }
  *(void *)(a2 + 16) = v14 + v15;
  unint64_t v16 = (char *)*a1;
  *a1 = v7;
  *(void *)(a2 + 8) = v16;
  uint64_t v17 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v17;
  unint64_t v18 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v18;
  *(void *)a2 = *(void *)(a2 + 8);
  return v5;
}

void IsfInternal::GetInitialWeightForRecord()
{
}

void IsfInternal::RemoveOldestRecord()
{
  __assert_rtn("RemoveOldestRecord", "IsfInternal.mm", 119, "m_head[i] == m_oldestIdx");
}

{
  __assert_rtn("RemoveOldestRecord", "IsfInternal.mm", 109, "m_tail[i] == m_oldestIdx");
}

void IsfInternal::InsertRecordInSortedList()
{
  __assert_rtn("InsertRecordInSortedList", "IsfInternal.mm", 169, "m_head[angleIdx] != -1");
}

{
  __assert_rtn("InsertRecordInSortedList", "IsfInternal.mm", 170, "m_tail[angleIdx] != -1");
}

{
  __assert_rtn("InsertRecordInSortedList", "IsfInternal.mm", 187, "m_tail[angleIdx] == newRecord.prevInSorted[angleIdx]");
}

{
  __assert_rtn("InsertRecordInSortedList", "IsfInternal.mm", 157, "m_numberOfRecords < getHistoryWindowSize()");
}

void IsfInternal::InsertNewRecord()
{
  __assert_rtn("InsertNewRecord", "IsfInternal.mm", 237, "m_oldestIdx != m_nextIdx");
}

{
  __assert_rtn("InsertNewRecord", "IsfInternal.mm", 233, "m_records.size() == (size_t)m_nextIdx + 1");
}

void IsfInternal::OutlierDetectAndWeight()
{
  __assert_rtn("OutlierDetectAndWeight", "IsfInternal.mm", 310, "currentRecord->prevInSorted[angleIdx] != -1");
}

{
  __assert_rtn("OutlierDetectAndWeight", "IsfInternal.mm", 296, "currentRecord->nextInSorted[angleIdx] != -1");
}

void RgbIrCalibration::RgbIrCalibration(RgbIrCalibration *this, int a2)
{
  *(_WORD *)this = 0;
  gDbgLvl = a2;
  operator new();
}

void sub_24699AFBC(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x10A0C408DADC83ELL);
  _Unwind_Resume(a1);
}

void RgbIrCalibration::~RgbIrCalibration(RgbIrCalibration *this)
{
  if (*(unsigned char *)this)
  {
    *((unsigned char *)this + 1) = 1;
    CalibrateRgbIr::abort(*((void *)this + 1));
  }
  else
  {
    uint64_t v1 = (CalibrateRgbIr *)*((void *)this + 1);
    if (v1)
    {
      CalibrateRgbIr::~CalibrateRgbIr(v1);
      MEMORY[0x24C53D6E0]();
    }
  }
}

uint64_t RgbIrCalibration::abort(RgbIrCalibration *this)
{
  *((unsigned char *)this + 1) = 1;
  return CalibrateRgbIr::abort(*((void *)this + 1));
}

uint64_t RgbIrCalibration::Calibrate(uint64_t a1, int a2, const __CFDictionary *a3, int a4, int a5, int a6, unsigned int a7, const __CFBoolean *a8, double *a9, const __CFArray *a10, __int16 a11, uint64_t a12, unsigned int *a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  CFRunLoopTimerContext context = (void *)MEMORY[0x24C53DF70]();
  *(unsigned char *)a1 = 1;
  uint64_t v20 = CalibrateRgbIr::Calibrate(*(void *)(a1 + 8), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a14, a15);
  *(unsigned char *)a1 = 0;
  if (*(unsigned char *)(a1 + 1))
  {
    uint64_t v21 = 4102;
    int64_t v22 = context;
  }
  else
  {
    uint64_t v21 = v20;
    uint64_t v23 = *(void *)(a1 + 8);
    *(void *)a16 = *(void *)(v23 + 984);
    *(_DWORD *)(a16 + 8) = *(_DWORD *)(v23 + 992);
    *(_DWORD *)(a16 + 12) = *(_DWORD *)(v23 + 996);
    *(_DWORD *)(a16 + 16) = *(_DWORD *)(v23 + 1000);
    unsigned int v24 = *(_DWORD *)(v23 + 1004);
    *a13 = v24;
    int64_t v22 = context;
    if (v24 <= 2) {
      *(_DWORD *)(a16 + 20) = v24;
    }
  }
  return v21;
}

uint64_t RgbIrCalibration::IgnoreMetadata(uint64_t this, char a2)
{
  *(unsigned char *)(*(void *)(this + 8) + 492) = a2;
  return this;
}

uint64_t RgbIrCalibration::GetDebugInfo(RgbIrCalibration *this)
{
  return *(void *)(*((void *)this + 1) + 1008);
}

void CalibrateRgbIr::CalibrateRgbIr(CalibrateRgbIr *this)
{
  *((_DWORD *)this + 6) = 0;
  *((void *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *((void *)this + 21) = 0;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((_DWORD *)this + 64) = 0;
  *((void *)this + 33) = 0;
  *((void *)this + 34) = 0;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((_OWORD *)this + 20) = 0u;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = 0u;
  *((void *)this + 50) = 0;
  *((_DWORD *)this + 122) = 0;
  *((unsigned char *)this + 492) = 0;
  *((_OWORD *)this + 27) = 0u;
  *((_OWORD *)this + 28) = 0u;
  *((unsigned char *)this + 464) = 0;
  MetalMgt::MetalMgt((CalibrateRgbIr *)((char *)this + 496));
  for (uint64_t i = 0; i != 144; i += 24)
    MetalObjects::MetalObjects((CalibrateRgbIr *)((char *)this + i + 608));
  *((_OWORD *)this + 57) = 0u;
  *((_OWORD *)this + 58) = 0u;
  *((_OWORD *)this + 56) = 0u;
  *((_OWORD *)this + 47) = 0u;
  *((_OWORD *)this + 48) = 0u;
  *((_OWORD *)this + 60) = 0u;
  *((unsigned char *)this + 976) = 0;
  *((void *)this + 123) = 0x7FF8000000000000;
  *((_OWORD *)this + 62) = 0u;
  CalibrateRgbIr::Init(this);
}

void sub_24699B274(_Unwind_Exception *a1)
{
  CalibrateRgbIr::MTLBufferParams::~MTLBufferParams(v3);
  uint64_t v5 = 0;
  unint64_t v6 = v2 + 91;
  do
  {
    H16ISP::H16ISPTimeOfFlightColorSynchronizer::TimeOfFlightColorSynchronizerInternal::{unnamed type#3}::~TimeOfFlightColorSynchronizerInternal(&v6[v5]);
    v5 -= 3;
  }
  while (v5 != -18);
  MetalMgt::~MetalMgt(v1);
  _Unwind_Resume(a1);
}

void CalibrateRgbIr::MTLBufferParams::~MTLBufferParams(id *this)
{
}

void MetalMgt::~MetalMgt(MetalMgt *this)
{
  std::mutex::~mutex((std::mutex *)((char *)this + 24));
}

void MetalObjects::MetalObjects(MetalObjects *this)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  MetalObjects::init(this);
}

void sub_24699B3D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CalibrateRgbIr::~CalibrateRgbIr(CalibrateRgbIr *this)
{
  if (gDbgLvl) {
    CFRelease(*((CFTypeRef *)this + 126));
  }

  for (uint64_t i = 0; i != -144; i -= 24)
  {
  }
  std::mutex::~mutex((std::mutex *)((char *)this + 520));
}

uint64_t PBCreateDirForFile(uint64_t *a1)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = (uint64_t *)*a1;
  }
  uint64_t v2 = objc_msgSend(NSString, "stringWithCString:encoding:", v1, objc_msgSend(NSString, "defaultCStringEncoding"));
  uint64_t v3 = [MEMORY[0x263F08850] defaultManager];
  char v11 = 0;
  if ([v3 fileExistsAtPath:v2 isDirectory:&v11]) {
    goto LABEL_13;
  }
  uint64_t v4 = [v2 pathExtension];
  char v5 = [v4 isEqualToString:&stru_26FAF64D8];

  if (v5)
  {
LABEL_12:
    if (![v3 createDirectoryAtPath:v2 withIntermediateDirectories:1 attributes:0 error:0])
    {
      uint64_t v9 = 0;
      goto LABEL_15;
    }
LABEL_13:
    uint64_t v9 = 1;
LABEL_15:
    unint64_t v6 = v2;
    goto LABEL_16;
  }
  unint64_t v6 = [v2 stringByDeletingLastPathComponent];

  char v7 = [v3 fileExistsAtPath:v6 isDirectory:&v11];
  if (v11) {
    char v8 = v7;
  }
  else {
    char v8 = 0;
  }
  if ((v8 & 1) == 0)
  {
    uint64_t v2 = v6;
    goto LABEL_12;
  }
  uint64_t v9 = 1;
LABEL_16:

  return v9;
}

void sub_24699B618(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t PortableBuffer::SaveBufferInternal()
{
  return 0;
}

uint64_t PortableBuffer::GetBytePerPixelFromPixelFormat(uint64_t result)
{
  return (unsigned __int16)result;
}

uint64_t PortableBuffer::GetPixelFormatFromBytePerPixel(PortableBuffer *this)
{
  if ((unint64_t)this - 1 > 7) {
    return 4294901760;
  }
  else {
    return dword_2469EE838[(void)this - 1];
  }
}

BOOL PortableBuffer::CheckMagic(PortableBuffer *this, const unsigned __int8 *a2)
{
  return *(void *)this == 0xE010B0A07070009 && *((void *)this + 1) == 0x70E0F0F020BLL;
}

uint64_t PortableBuffer::ReadHeader(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  v47[2] = *MEMORY[0x263EF8340];
  std::string::basic_string[abi:ne180100]<0>(&v46, "");
  if (a2)
  {
    std::string::operator=(&v46, (const std::string *)a1);
  }
  else
  {
    if (byte_26B11C1AF >= 0) {
      size_t v8 = byte_26B11C1AF;
    }
    else {
      size_t v8 = qword_26B11C1A0;
    }
    p_p = &__p;
    std::string::basic_string[abi:ne180100]((uint64_t)&__p, v8 + 1);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    if (v8)
    {
      if (byte_26B11C1AF >= 0) {
        long long v10 = &PortableBuffer::m_outputDir;
      }
      else {
        long long v10 = (uint64_t *)PortableBuffer::m_outputDir;
      }
      memmove(p_p, v10, v8);
    }
    *(_WORD *)((char *)&p_p->__r_.__value_.__l.__data_ + v8) = 47;
    int v11 = *(char *)(a1 + 23);
    if (v11 >= 0) {
      long long v12 = (const std::string::value_type *)a1;
    }
    else {
      long long v12 = *(const std::string::value_type **)a1;
    }
    if (v11 >= 0) {
      std::string::size_type v13 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      std::string::size_type v13 = *(void *)(a1 + 8);
    }
    uint64_t v14 = std::string::append(&__p, v12, v13);
    std::string::size_type v15 = v14->__r_.__value_.__r.__words[0];
    v47[0] = v14->__r_.__value_.__l.__size_;
    *(void *)((char *)v47 + 7) = *(std::string::size_type *)((char *)&v14->__r_.__value_.__r.__words[1] + 7);
    char v16 = HIBYTE(v14->__r_.__value_.__r.__words[2]);
    v14->__r_.__value_.__l.__size_ = 0;
    v14->__r_.__value_.__r.__words[2] = 0;
    v14->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v46.__r_.__value_.__l.__data_);
    }
    v46.__r_.__value_.__r.__words[0] = v15;
    v46.__r_.__value_.__l.__size_ = v47[0];
    *(std::string::size_type *)((char *)&v46.__r_.__value_.__r.__words[1] + 7) = *(void *)((char *)v47 + 7);
    *((unsigned char *)&v46.__r_.__value_.__s + 23) = v16;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"Loads file ", 11);
  if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    unint64_t v18 = &v46;
  }
  else {
    unint64_t v18 = (std::string *)v46.__r_.__value_.__r.__words[0];
  }
  if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(v46.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = v46.__r_.__value_.__l.__size_;
  }
  uint64_t v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)v18, size);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)".\n", 2);
  std::ifstream::open();
  if (*(void *)(a4 + 136))
  {
    std::istream::read();
    if (*(void *)a3 == 0xE010B0A07070009 && *(void *)(a3 + 8) == 0x70E0F0F020BLL)
    {
      if (*(_DWORD *)(a3 + 20) == 1)
      {
        id v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"Loaded header of file ", 22);
        if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          id v31 = &v46;
        }
        else {
          id v31 = (std::string *)v46.__r_.__value_.__r.__words[0];
        }
        if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          std::string::size_type v32 = HIBYTE(v46.__r_.__value_.__r.__words[2]);
        }
        else {
          std::string::size_type v32 = v46.__r_.__value_.__l.__size_;
        }
        long long v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)v31, v32);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)".\n", 2);
        long long v34 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"\t descr: ", 9);
        size_t v35 = strlen((const char *)(a3 + 24));
        id v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, a3 + 24, v35);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)".\n", 2);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"\t width: ", 9);
        uint64_t v37 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)".\n", 2);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"\t height: ", 10);
        int v38 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)".\n", 2);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"\t stride: ", 10);
        uint64_t v39 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)".\n", 2);
        uint64_t v40 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"\t pixel format: 0x", 18);
        *(_DWORD *)((char *)v40 + *(void *)(*v40 - 24) + 8) = *(_DWORD *)((unsigned char *)v40 + *(void *)(*v40 - 24)
                                                                                           + 8) & 0xFFFFFFB5 | 8;
        uint64_t v41 = (void *)std::ostream::operator<<();
        *(_DWORD *)((char *)v41 + *(void *)(*v41 - 24) + 8) = *(_DWORD *)((unsigned char *)v41 + *(void *)(*v41 - 24)
                                                                                           + 8) & 0xFFFFFFB5 | 2;
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)".\n", 2);
        uint64_t v42 = 1;
        goto LABEL_53;
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"PortableBuffer version (v", 25);
      IOSurfaceID v43 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)") is not the same as the one supported by this software (v", 58);
      uint64_t v23 = (void *)std::ostream::operator<<();
      int64_t v22 = ").\n";
      uint64_t v24 = 3;
    }
    else
    {
      int64_t v22 = "Magic number of buffer does not match. File may not be a PortableBuffer or may be corrupted.\n";
      uint64_t v23 = (void *)MEMORY[0x263F8C100];
      uint64_t v24 = 93;
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)v22, v24);
  }
  else
  {
    int v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"Unable to read from ", 20);
    if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint64_t v26 = &v46;
    }
    else {
      uint64_t v26 = (std::string *)v46.__r_.__value_.__r.__words[0];
    }
    if ((v46.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      std::string::size_type v27 = HIBYTE(v46.__r_.__value_.__r.__words[2]);
    }
    else {
      std::string::size_type v27 = v46.__r_.__value_.__l.__size_;
    }
    long long v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)v26, v27);
    std::ios_base::getloc((const std::ios_base *)((char *)v28 + *(void *)(*v28 - 24)));
    long long v29 = std::locale::use_facet((const std::locale *)&__p, MEMORY[0x263F8C108]);
    ((void (*)(const std::locale::facet *, uint64_t))v29->__vftable[2].~facet_0)(v29, 10);
    std::locale::~locale((std::locale *)&__p);
    std::ostream::put();
    std::ostream::flush();
  }
  uint64_t v42 = 0;
LABEL_53:
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v46.__r_.__value_.__l.__data_);
  }
  return v42;
}

void sub_24699BBA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (a20 < 0) {
    operator delete(a15);
  }
  _Unwind_Resume(exception_object);
}

void *GrayScaleImage::save(int a1, CVPixelBufferRef pixelBuffer)
{
  size_t PlaneCount = CVPixelBufferGetPlaneCount(pixelBuffer);
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  if (PlaneCount)
  {
    CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
    CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
    if (PixelFormatType == 2037741158)
    {
      CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
LABEL_8:
      CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL);
      CVPixelBufferGetBaseAddress(pixelBuffer);
      return (void *)CVPixelBufferUnlockBaseAddress(pixelBuffer, 1uLL);
    }
  }
  else
  {
    CVPixelBufferGetWidth(pixelBuffer);
    CVPixelBufferGetHeight(pixelBuffer);
    if (PixelFormatType == 825306677 || PixelFormatType == 1278226742 || PixelFormatType == 825437747)
    {
      CVPixelBufferGetBytesPerRow(pixelBuffer);
      goto LABEL_8;
    }
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"Unsupported CVPixelBuffer pixel format: ", 40);
  unint64_t v6 = (void *)std::ostream::operator<<();

  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" (see CVPixelBufferPrivate.h). Please contact PortableBuffer support.\n", 70);
}

uint64_t Isf::RunIsf(double a1, double a2, double a3, double a4, uint64_t a5, void *a6, _DWORD *a7, uint64_t a8, int64x2_t *a9)
{
  uint64_t result = IsfInternal::Run((uint64_t)a6, a7, a8, a1, a2, a3, a4);
  if (result)
  {
    *a9 = vdupq_n_s64(0x7FF8000000000000uLL);
    uint64_t v12 = 0x7FF8000000000000;
  }
  else
  {
    a9->i64[0] = a6[9];
    a9->i64[1] = a6[10];
    uint64_t v12 = a6[11];
  }
  a9[1].i64[0] = v12;
  return result;
}

uint64_t Isf::setStepDetectionMode(Isf *this, char a2)
{
  return IsfInternal::setStepDetectionMode(*((void *)this + 1), a2);
}

uint64_t CalibrateRgbIr::Init(CalibrateRgbIr *this)
{
  if (gDbgLvl) {
    *((void *)this + 126) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x263EFFB08], 0, MEMORY[0x263EFFF88], MEMORY[0x263EFFF90]);
  }
  long long v2 = *((_OWORD *)this + 1);
  v37[0] = *(_OWORD *)this;
  v37[1] = v2;
  v37[2] = *((_OWORD *)this + 2);
  uint64_t v3 = *((void *)this + 6);
  long long v39 = *(_OWORD *)((char *)this + 56);
  uint64_t v4 = *((void *)this + 9);
  uint64_t v38 = v3;
  uint64_t v40 = v4;
  long long v41 = *((_OWORD *)this + 5);
  uint64_t v5 = *((void *)this + 12);
  long long v43 = *(_OWORD *)((char *)this + 104);
  long long v6 = *(_OWORD *)((char *)this + 120);
  long long v7 = *(_OWORD *)((char *)this + 136);
  long long v8 = *(_OWORD *)((char *)this + 152);
  uint64_t v9 = *((void *)this + 21);
  uint64_t v42 = v5;
  uint64_t v47 = v9;
  long long v46 = v8;
  long long v45 = v7;
  long long v44 = v6;
  long long v10 = *((_OWORD *)this + 11);
  long long v11 = *((_OWORD *)this + 12);
  long long v12 = *((_OWORD *)this + 13);
  uint64_t v51 = *((void *)this + 28);
  long long v49 = v11;
  long long v50 = v12;
  long long v48 = v10;
  InitCamParams((uint64_t)v37);
  long long v13 = *(_OWORD *)((char *)this + 248);
  v22[0] = *(_OWORD *)((char *)this + 232);
  v22[1] = v13;
  uint64_t v22[2] = *(_OWORD *)((char *)this + 264);
  uint64_t v23 = *((void *)this + 35);
  long long v24 = *((_OWORD *)this + 18);
  uint64_t v25 = *((void *)this + 38);
  long long v26 = *(_OWORD *)((char *)this + 312);
  uint64_t v27 = *((void *)this + 41);
  long long v14 = *((_OWORD *)this + 22);
  long long v28 = *((_OWORD *)this + 21);
  long long v15 = *((_OWORD *)this + 23);
  long long v16 = *((_OWORD *)this + 24);
  uint64_t v32 = *((void *)this + 50);
  long long v31 = v16;
  long long v30 = v15;
  long long v29 = v14;
  long long v17 = *(_OWORD *)((char *)this + 408);
  long long v18 = *(_OWORD *)((char *)this + 424);
  long long v19 = *(_OWORD *)((char *)this + 440);
  uint64_t v36 = *((void *)this + 57);
  long long v34 = v18;
  long long v35 = v19;
  long long v33 = v17;
  uint64_t result = InitCamParams((uint64_t)v22);
  for (uint64_t i = 0; i != 144; i += 24)
    *(void *)((char *)this + i + 624) = (char *)this + 496;
  return result;
}

void CalibrateRgbIr::CalcMutualInfoSamples()
{
  uint64_t v0 = &unk_26FAEAFE0;
  operator new[]();
}

void sub_24699C1D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  Matrix<float>::~Matrix((uint64_t)va);
  Matrix<float>::~Matrix((uint64_t)va1);
  _Unwind_Resume(a1);
}

void OneDimensionHorizontalFilterWithPadding(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_DWORD *)(a2 + 16) != 1) {
    OneDimensionHorizontalFilterWithPadding();
  }
  unint64_t v4 = *(unsigned int *)(a2 + 20);
  if ((v4 & 1) == 0) {
    OneDimensionHorizontalFilterWithPadding();
  }
  ImageUtils::Filter2<float>(a1, a2, a3);
  int v7 = *(_DWORD *)(a1 + 16);
  if (v7)
  {
    unsigned int v8 = 0;
    unint64_t v9 = v4 >> 1;
    do
    {
      if (v4 >= 2)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        uint64_t v12 = *(unsigned int *)(a1 + 20);
        int v13 = *(_DWORD *)(a2 + 16);
        uint64_t v14 = *(int *)(a2 + 20);
        unsigned int v15 = *(_DWORD *)(a3 + 16);
        unsigned int v16 = v12 - 1;
        unsigned int v17 = ~(v4 >> 1) + v4;
        unint64_t v18 = v4 >> 1;
        do
        {
          if (v15 <= v8 || (unint64_t v19 = *(unsigned int *)(a3 + 20), v11 >= v19)) {
            GMC_Homography();
          }
          unsigned int v20 = v12 + ~v11;
          if (v19 <= v20) {
            GMC_Homography();
          }
          if (v11 == v12) {
            GMC_Homography();
          }
          if (v12 <= v20) {
            GMC_Homography();
          }
          uint64_t v21 = *(void *)(a3 + 8);
          uint64_t v22 = v21 + 4 * v11;
          uint64_t v23 = v19 * v8;
          uint64_t v24 = v21 + 4 * v20;
          uint64_t v25 = *(void *)(a1 + 8);
          *(_DWORD *)(v22 + 4 * v23) = 0;
          *(_DWORD *)(v24 + 4 * v23) = 0;
          if ((uint64_t)v11 > (uint64_t)(v9 - v14))
          {
            if (v13)
            {
              uint64_t v26 = 0;
              uint64_t v27 = v10 + 4 * v16;
              uint64_t v28 = v25 + 4 * v12 * v8;
              unsigned int v29 = v17;
              while (v14 > (int)v18 + (int)v26)
              {
                *(float *)(v22 + 4 * v23) = *(float *)(v22 + 4 * v23)
                                          + (float)(*(float *)(v28 + 4 * v26)
                                                  * *(float *)(*(void *)(a2 + 8) + 4 * v18 + 4 * v26));
                if (v14 <= v29) {
                  GMC_Homography();
                }
                *(float *)(v24 + 4 * v23) = *(float *)(v24 + 4 * v23)
                                          + (float)(*(float *)(v28 + v27) * *(float *)(*(void *)(a2 + 8) + 4 * v29));
                v27 -= 4;
                ++v26;
                --v29;
                if ((uint64_t)(v18 + v26) >= v14) {
                  goto LABEL_18;
                }
              }
            }
            GMC_Homography();
          }
LABEL_18:
          ++v11;
          --v18;
          v10 += 4;
          --v16;
          ++v17;
        }
        while (v11 != v9);
      }
      ++v8;
    }
    while (v8 != v7);
  }
}

void OneDimensionVerticalFilterWithPadding(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 16) == 1)
  {
    if (*(_DWORD *)(a2 + 20)) {
      Matrix<float>::Transpose(a2);
    }
    OneDimensionVerticalFilterWithPadding();
  }
  OneDimensionVerticalFilterWithPadding();
}

void sub_24699C5DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t CalibrateRgbIr::SampleWorldPointsOnCam(uint64_t a1, int *a2, void *a3, uint64_t a4)
{
  id v13 = 0;
  MetalObjects::createBuffer(a4, &v13, (int *)(a1 + 784), 0x6CuLL);
  id v8 = v13;
  id v12 = 0;
  MetalObjects::createBuffer(a4, &v12, a2, 0x6CuLL);
  id v9 = v12;
  id v10 = *(id *)(a4 + 8);
  *a3 = v10;
  MetalObjects::Algo_DistortRadialLiteInternal(a4, *(void **)(a1 + 752), *(void **)(a1 + 760), *(void **)(a1 + 768), *(void **)(a1 + 920), *(void **)(a1 + 912), *(void **)(a1 + 904), *(void **)(a1 + 896), *(void **)(a1 + 776), *(void **)(a1 + 928), v8, v9, *(void **)(a1 + 936), v10, 1);

  return 0;
}

void sub_24699C6DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void CalibrateRgbIr::CostFmi(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  MEMORY[0x24C53DF70]();
  long long v7 = *(_OWORD *)(a1 + 16);
  float64x2_t v32 = *(float64x2_t *)a1;
  long long v33 = v7;
  long long v34 = *(_OWORD *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 48);
  *(_OWORD *)&v35[8] = *(_OWORD *)(a1 + 56);
  uint64_t v9 = *(void *)(a1 + 72);
  *(void *)long long v35 = v8;
  *(void *)&v35[24] = v9;
  float64x2_t v36 = *(float64x2_t *)(a1 + 80);
  double v10 = *(double *)(a1 + 96);
  *(_OWORD *)&v37[8] = *(_OWORD *)(a1 + 104);
  long long v11 = *(_OWORD *)(a1 + 120);
  long long v12 = *(_OWORD *)(a1 + 136);
  long long v13 = *(_OWORD *)(a1 + 152);
  uint64_t v14 = *(void *)(a1 + 168);
  *(double *)uint64_t v37 = v10;
  *(void *)&v37[72] = v14;
  *(_OWORD *)&v37[56] = v13;
  *(_OWORD *)&v37[40] = v12;
  *(_OWORD *)&v37[24] = v11;
  long long v15 = *(_OWORD *)(a1 + 192);
  v38[0] = *(_OWORD *)(a1 + 176);
  v38[1] = v15;
  v38[2] = *(_OWORD *)(a1 + 208);
  uint64_t v39 = *(void *)(a1 + 224);
  float64x2_t v36 = vaddq_f64(v36, vcvtq_f64_f32(*(float32x2_t *)(a2 + 4)));
  *(double *)uint64_t v37 = v10 + *(float *)(a2 + 12);
  GeomUtils::CalcRotationMatrix<double>(v36.f64, (uint64_t)&v37[8]);
  float32x2_t v21 = vcvt_f32_f64(v32);
  float v16 = *(double *)&v33;
  float v22 = v16;
  int v23 = DWORD2(v33);
  float32x4_t v24 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v35), *(float64x2_t *)&v35[16]);
  float32x4_t v25 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v36), *(float64x2_t *)v37);
  float32x4_t v26 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v37[16]), *(float64x2_t *)&v37[32]);
  float32x4_t v27 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v37[48]), *(float64x2_t *)&v37[64]);
  float v17 = *(double *)v38;
  float v28 = v17;
  long long v29 = *(_OWORD *)((char *)v38 + 8);
  int v30 = 0;
  int v31 = 0;
  id v20 = 0;
  CalibrateRgbIr::SampleWorldPointsOnCam(a1, (int *)&v21, &v20, a4);
  id v18 = v20;
  [v18 width];
  [v18 height];
  id v19 = [v18 buffer];
  [v19 contents];

  operator new[]();
}

void sub_24699CAA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  Matrix<float>::~Matrix((uint64_t)va);

  _Unwind_Resume(a1);
}

void CalibrateRgbIr::ReleaseMetalObjects(CalibrateRgbIr *this)
{
  long long v2 = (void *)*((void *)this + 94);
  *((void *)this + 94) = 0;

  uint64_t v3 = (void *)*((void *)this + 95);
  *((void *)this + 95) = 0;

  unint64_t v4 = (void *)*((void *)this + 94);
  *((void *)this + 94) = 0;

  uint64_t v5 = (void *)*((void *)this + 115);
  *((void *)this + 115) = 0;

  uint64_t v6 = (void *)*((void *)this + 114);
  *((void *)this + 114) = 0;

  long long v7 = (void *)*((void *)this + 116);
  *((void *)this + 116) = 0;

  uint64_t v8 = (void *)*((void *)this + 117);
  *((void *)this + 117) = 0;

  uint64_t v9 = (void *)*((void *)this + 113);
  *((void *)this + 113) = 0;

  double v10 = (void *)*((void *)this + 112);
  *((void *)this + 112) = 0;

  long long v11 = (void *)*((void *)this + 97);
  *((void *)this + 97) = 0;

  long long v12 = (void *)*((void *)this + 120);
  *((void *)this + 120) = 0;

  long long v13 = (void *)*((void *)this + 121);
  *((void *)this + 121) = 0;
}

void CalibrateRgbIr::CalculateGrid(uint64_t a1, uint64_t a2, int a3, int a4)
{
  if (a3 <= a4)
  {
    int v5 = a3;
    unsigned int v6 = *(_DWORD *)(a2 + 8);
    unsigned int v7 = v6;
    do
    {
      if (v7)
      {
        unsigned int v8 = 0;
        do
        {
          if (v6)
          {
            for (unint64_t i = 0; i < v6; ++i)
            {
              if (*(unsigned char *)(a1 + 976)) {
                break;
              }
            }
          }
          ++v8;
          unsigned int v7 = *(_DWORD *)(a2 + 8);
        }
        while (v8 < v6);
      }
    }
    while (v5++ != a4);
  }
  for (uint64_t j = 0; j != 6; ++j)
  {
    long long v12 = [*(id *)(a1 + 968) objectAtIndexedSubscript:j];
    dispatch_group_wait(v12, 0xFFFFFFFFFFFFFFFFLL);
  }
}

void sub_24699CDD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void ___ZN14CalibrateRgbIr13CalculateGridER8GridAreaiiR11MatrixNxPtsILj1EfEPj_block_invoke(uint64_t *a1)
{
}

uint64_t CalibrateRgbIr::PrepareGridCalculation(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  double v10 = (id *)(a1 + 608);
  v99[0] = 0;
  MetalObjects::createTexture((id *)(a1 + 608), v99, *(int **)(a2 + 8), a5, a4);
  id v11 = v99[0];
  id v12 = v99[0];
  objc_storeStrong((id *)(a1 + 752), v11);
  id v98 = 0;
  BOOL v73 = v12;
  MetalObjects::createTexture(v10, &v98, (int *)(*(void *)(a2 + 8) + 4 * *(unsigned int *)(a2 + 20)), a5, a4);
  id v13 = v98;
  id v14 = v98;
  objc_storeStrong((id *)(a1 + 760), v13);
  id v97 = 0;
  MetalObjects::createTexture(v10, &v97, (int *)(*(void *)(a2 + 8) + 4 * (2 * *(_DWORD *)(a2 + 20))), a5, a4);
  id v15 = v97;
  id v16 = v97;
  objc_storeStrong((id *)(a1 + 768), v15);
  if (*(void *)(a1 + 752) && *(void *)(a1 + 760) && a4 && a5 && *(void *)(a1 + 768))
  {
    *(float32x2_t *)(a1 + 784) = vcvt_f32_f64(*(float64x2_t *)(a1 + 232));
    float v17 = *(double *)(a1 + 248);
    *(float *)(a1 + 792) = v17;
    float32x4_t v18 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 312)), *(float64x2_t *)(a1 + 328));
    *(float32x4_t *)(a1 + 800) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 280)), *(float64x2_t *)(a1 + 296));
    *(float32x4_t *)(a1 + 816) = v18;
    float32x4_t v19 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 344)), *(float64x2_t *)(a1 + 360));
    float32x4_t v20 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 376)), *(float64x2_t *)(a1 + 392));
    *(_DWORD *)(a1 + 796) = *(_DWORD *)(a1 + 256);
    *(float32x4_t *)(a1 + 832) = v19;
    *(float32x4_t *)(a1 + 848) = v20;
    float v21 = *(double *)(a1 + 408);
    *(float *)(a1 + 864) = v21;
    *(_OWORD *)(a1 + 868) = *(_OWORD *)(a1 + 416);
    *(_DWORD *)(a1 + 884) = a4;
    *(_DWORD *)(a1 + 888) = a5;
    id v96 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v96, *(int **)(a1 + 272), 4 * *(unsigned int *)(a1 + 256));
    id v22 = v96;
    id v23 = v96;
    id v95 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v95, *(int **)(a1 + 264), 4 * *(unsigned int *)(a1 + 256));
    int v70 = v23;
    id v24 = v95;
    id v69 = v95;
    objc_storeStrong((id *)(a1 + 912), v22);
    objc_storeStrong((id *)(a1 + 920), v24);
    Matrix<float>::Matrix((uint64_t)v93, 1, *(_DWORD *)(a1 + 420));
    int v25 = *(_DWORD *)(a1 + 420);
    if (v25)
    {
      unint64_t v26 = 0;
      float32x4_t v27 = v94;
      if ((v25 + 1) > 2) {
        int v28 = v25 + 1;
      }
      else {
        int v28 = 2;
      }
      uint64_t v29 = (v28 - 1);
      uint64_t v30 = v28 & 0xFFFFFFFE;
      uint64x2_t v31 = (uint64x2_t)vdupq_n_s64(v29 - 1);
      do
      {
        int32x2_t v32 = vmovn_s64((int64x2_t)vcgeq_u64(v31, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v26), (int8x16_t)xmmword_2469EE030)));
        if (v32.i8[0]) {
          *(float *)&v27[v26] = (float)(v26 + 1) + -0.5;
        }
        if (v32.i8[4]) {
          *(float *)&v27[v26 + 1] = (float)(v26 + 2) + -0.5;
        }
        v26 += 2;
      }
      while (v30 != v26);
    }
    Matrix<float>::Matrix((uint64_t)v91, 1, *(_DWORD *)(a1 + 416));
    int v33 = *(_DWORD *)(a1 + 416);
    if (v33)
    {
      unint64_t v34 = 0;
      long long v35 = v92;
      if ((v33 + 1) > 2) {
        int v36 = v33 + 1;
      }
      else {
        int v36 = 2;
      }
      uint64_t v37 = (v36 - 1);
      uint64_t v38 = v36 & 0xFFFFFFFE;
      uint64x2_t v39 = (uint64x2_t)vdupq_n_s64(v37 - 1);
      do
      {
        int32x2_t v40 = vmovn_s64((int64x2_t)vcgeq_u64(v39, (uint64x2_t)vorrq_s8((int8x16_t)vdupq_n_s64(v34), (int8x16_t)xmmword_2469EE030)));
        if (v40.i8[0]) {
          *(float *)&v35[v34] = (float)(v34 + 1) + -0.5;
        }
        if (v40.i8[4]) {
          *(float *)&v35[v34 + 1] = (float)(v34 + 2) + -0.5;
        }
        v34 += 2;
      }
      while (v38 != v34);
    }
    id v90 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v90, v94, 4 * *(unsigned int *)(a1 + 420));
    id v41 = v90;
    id v72 = v90;
    id v89 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v89, v92, 4 * *(unsigned int *)(a1 + 416));
    id v42 = v89;
    id v71 = v89;
    objc_storeStrong((id *)(a1 + 904), v42);
    objc_storeStrong((id *)(a1 + 896), v41);
    *(void *)(a1 + 944) = v91;
    *(void *)(a1 + 952) = v93;
    uint64_t v43 = -144;
    do
    {
      obuint64_t j = 0;
      MetalObjects::createTextureSharedBuffer((void *)(a1 + v43 + 752), &obj, a5, a4);
      objc_storeStrong((id *)(a1 + v43 + 760), obj);
      v43 += 24;
    }
    while (v43);
    id v44 = objc_alloc_init(MEMORY[0x263EFF980]);
    long long v45 = *(void **)(a1 + 960);
    *(void *)(a1 + 960) = v44;

    id v46 = objc_alloc_init(MEMORY[0x263EFF980]);
    uint64_t v47 = *(void **)(a1 + 968);
    *(void *)(a1 + 968) = v46;

    long long v48 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, 0);
    int v49 = 6;
    do
    {
      long long v50 = *(void **)(a1 + 960);
      dispatch_queue_t v51 = dispatch_queue_create("com.gmcRgbIr.CPU_GPU", v48);
      [v50 addObject:v51];

      float v52 = *(void **)(a1 + 968);
      dispatch_group_t v53 = dispatch_group_create();
      [v52 addObject:v53];

      --v49;
    }
    while (v49);
    int v87 = *(_DWORD *)(a1 + 256);
    long long v54 = *(float **)(a1 + 264);
    float v86 = *v54;
    float v85 = v54[1] - v86;
    id v84 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v84, (int *)&v85, 0x1CuLL);
    id v55 = v84;
    id v56 = v84;
    int v57 = *(_DWORD *)(a1 + 420);
    int v81 = *(_DWORD *)(a1 + 416);
    int v82 = v57;
    int v83 = 2143289344;
    int v58 = *(float **)(*(void *)(a1 + 952) + 8);
    float v79 = *v58;
    float v80 = v58[v57 - 1];
    int v59 = *(float **)(*(void *)(a1 + 944) + 8);
    float v77 = *v59;
    float v78 = v59[v81 - 1];
    *(float *)&v76[1] = v77;
    float v60 = v59[1] - v77;
    *(float *)&v76[3] = v79;
    float v61 = v58[1];
    *(float *)int v76 = v60;
    *(float *)&v76[2] = v61 - v79;
    id v75 = 0;
    MetalObjects::createBuffer((uint64_t)v10, &v75, v76, 0x2CuLL);
    id v62 = v75;
    id v63 = v75;
    objc_storeStrong((id *)(a1 + 928), v55);
    objc_storeStrong((id *)(a1 + 936), v62);
    id v74 = 0;
    MetalObjects::createTexture(v10, &v74, *(int **)(a3 + 8), *(_DWORD *)(a3 + 16), *(_DWORD *)(a3 + 20));
    objc_storeStrong((id *)(a1 + 776), v74);

    Matrix<float>::~Matrix((uint64_t)v91);
    Matrix<float>::~Matrix((uint64_t)v93);

    uint64_t v64 = 1;
  }
  else
  {
    uint64_t v65 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    if (GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog == &_os_log_internal)
    {
      os_log_t v66 = os_log_create("com.apple.isp", "general");
      int v67 = (void *)GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
      GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog = (uint64_t)v66;

      uint64_t v65 = GetCameraUserspaceLogStream(CameraUserspaceLoggingCategory)::_generalLog;
    }
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR)) {
      CalibrateRgbIr::PrepareGridCalculation(v65);
    }
    uint64_t v64 = 0;
  }

  return v64;
}

void sub_24699D474(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  Matrix<float>::~Matrix((uint64_t)&a31);
  Matrix<float>::~Matrix(v36 - 160);

  _Unwind_Resume(a1);
}

void MetalObjects::createTextureSharedBuffer(void *a1, void *a2, int a3, int a4)
{
  std::mutex::lock((std::mutex *)(a1[2] + 24));
  id v8 = (id)[*(id *)a1[2] newBufferWithLength:4 * a4 * a3 options:*(void *)(a1[2] + 96)];
  std::mutex::unlock((std::mutex *)(a1[2] + 24));
  [(id)*a1 setResourceOptions:*(void *)(a1[2] + 96)];
  [(id)*a1 setPixelFormat:55];
  [(id)*a1 setTextureType:2];
  [(id)*a1 setUsage:3];
  [(id)*a1 setHeight:a3];
  [(id)*a1 setWidth:a4];
  *a2 = (id)[v8 newTextureWithDescriptor:*a1 offset:0 bytesPerRow:4 * a4];
}

void sub_24699D618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t CalibrateRgbIr::LocalValidationSelect(uint64_t a1, float *a2, uint64_t *a3)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  BOOL isMinimumOnBorder = GridArea::isMinimumOnBorder(a2, 1, &v11);
  BOOL v6 = GridArea::isMinimumOnBorder(a2, 0, &v10);
  if (!isMinimumOnBorder || (BOOL v7 = v6, result = 0, !v7))
  {
    if (isMinimumOnBorder) {
      uint64_t result = 2;
    }
    else {
      uint64_t result = 1;
    }
    if (isMinimumOnBorder) {
      uint64_t v9 = &v10;
    }
    else {
      uint64_t v9 = &v11;
    }
    *a3 = *v9;
  }
  return result;
}

void CalibrateRgbIr::ChooseResult2(CalibrateRgbIr *this, GridArea *a2, GridArea *a3, int a4)
{
  uint64_t v5 = *MEMORY[0x263EF8340];
  GridArea::CalcNewConfidence((uint64_t)a2, a4, 1, &v4);
}

void sub_24699DC10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void addValueToDictionary(__CFDictionary *a1, const __CFString *a2, double a3)
{
  double valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberDoubleType, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

uint64_t CalibrateRgbIr::ScanCostGrid(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = (void *)MEMORY[0x24C53DF70]();
  float v11 = sqrtf((float)*(unsigned int *)(a2 + 20));
  if (CalibrateRgbIr::PrepareGridCalculation(a1, a2, a3, v11 & 0xFFFFFFF0, v11 * v11 / (v11 & 0xFFFFFFF0)))
  {
    float v12 = *(float *)(a6 + 4);
    v24[1] = v12 + 6.0;
    v24[2] = 3.0;
    v23[0] = v12 + -6.0;
    v23[1] = v12 + 6.0;
    v23[2] = 3.0;
    v24[0] = -6.0;
    int v22 = 1065353216;
    uint64_t v21 = 0;
    v19[6] = -1061158912;
    *(float *)&v19[7] = v12 + 6.0;
    *(float *)&v19[8] = v12 + -6.0;
    *(float *)&v19[9] = v12 + 6.0;
    __asm { FMOV            V0.2S, #3.0 }
    uint64_t v20 = _D0;
    GridArea::PrepareGrid(v19, v24, (uint64_t)v23, (float *)&v21, 0);
  }
  NSLog(&cfstr_RgbIrCalibS.isa, "PrepareGridCalculation failed.");
  return 4097;
}

void sub_24699E7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a24 < 0) {
    operator delete(__p);
  }
  GridArea::~GridArea((GridArea *)&a26);
  GridArea::~GridArea((GridArea *)&a53);
  GridArea::~GridArea((GridArea *)(v53 - 176));
  _Unwind_Resume(a1);
}

void GridArea::GridArea(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, int a5)
{
  *(_OWORD *)(a1 + 24) = *(_OWORD *)a2;
  int v5 = *(_DWORD *)(a3 + 8);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 8);
  *(_DWORD *)(a1 + 44) = v5;
  GridArea::PrepareGrid((_DWORD *)a1, (float *)a2, a3, a4, a5);
}

uint64_t CalibrateRgbIr::GetCamParamsFromMetaData(int a1, CFDictionaryRef theDict, uint64_t a3)
{
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x263F2D0A0]);
  BytePtr = (float32x2_t *)CFDataGetBytePtr(Value);
  *(float64x2_t *)(a3 + 104) = vcvtq_f64_f32(*BytePtr);
  *(double *)(a3 + 120) = BytePtr[1].f32[0];
  *(double *)(a3 + 56) = BytePtr[1].f32[1];
  *(float64x2_t *)(a3 + 128) = vcvtq_f64_f32(BytePtr[2]);
  *(double *)(a3 + 144) = BytePtr[3].f32[0];
  *(double *)(a3 + 64) = BytePtr[3].f32[1];
  *(float64x2_t *)(a3 + 152) = vcvtq_f64_f32(BytePtr[4]);
  *(double *)(a3 + 168) = BytePtr[5].f32[0];
  *(double *)(a3 + 72) = BytePtr[5].f32[1];
  CFDictionaryRef v7 = (const __CFDictionary *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x263F2DF68]);
  CGPointMakeWithDictionaryRepresentation(v7, &v10);
  *(CGPoint *)(a3 + 8) = v10;
  CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x263F2D3E0]);
  return CFNumberGetValue(v8, kCFNumberFloatType, (void *)a3);
}

uint64_t CalibrateRgbIr::CheckPceCalibValid(int a1, CFDictionaryRef theDict, uint64_t a3)
{
  if (theDict)
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x263F2D3E0]);
    if (Value)
    {
      float valuePtr = 0.0;
      CFNumberGetValue(Value, kCFNumberFloatType, &valuePtr);
      if (vabdd_f64(valuePtr, *(double *)(a3 + 8792)) < 0.00001)
      {
        CFDataRef v6 = (const __CFData *)CFDictionaryGetValue(theDict, (const void *)*MEMORY[0x263F2D0A0]);
        if (v6)
        {
          CFDataGetBytePtr(v6);
          operator new[]();
        }
      }
    }
  }
  return 0;
}

void CalibrateRgbIr::GetCommonCamParams(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = *(void *)(a1 + 8);
  *(void *)(a2 + 8) = *(void *)(a1 + 16);
  *(void *)(a2 + 16) = *(void *)(a1 + 24);
  int v2 = *(unsigned __int16 *)(a1 + 4258);
  *(_DWORD *)(a2 + 184) = *(unsigned __int16 *)(a1 + 4256);
  *(_DWORD *)(a2 + 188) = v2;
  operator new[]();
}

void CalibrateRgbIr::GetCamParams(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void CalibrateRgbIr::GetTargetCam(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  *(_DWORD *)(a5 + 184) = a2;
  *(_DWORD *)(a5 + 188) = a3;
  LOWORD(a6) = *(_WORD *)(a4 + 12);
  LOWORD(a7) = *(_WORD *)(a4 + 14);
  long long v19 = xmmword_2469EE620;
  uint64_t v18 = 0;
  unint64_t v20 = 0xBFF0000000000000;
  long long v21 = 0u;
  long long v22 = 0u;
  uint64_t v23 = 0x3FF0000000000000;
  double v13 = *(double *)(a1 + 4288);
  double v14 = (double)*(unint64_t *)&a6;
  double v15 = v13 * v14 / (double)a3;
  *(double *)(a5 + 48) = v15;
  LOWORD(a12) = *(_WORD *)(a1 + 8544);
  LOWORD(v12) = *(_WORD *)(a1 + 8546);
  double v16 = *(double *)(a1 + 4304)
      + (double)*(unint64_t *)&a12 * -0.5 * v13
      + v14 * 0.5 * v13
      + (double)a3 * -0.5 * v15;
  double v17 = *(double *)(a1 + 4312)
      + (double)v12 * -0.5 * v13
      + (double)*(unint64_t *)&a7 * 0.5 * v13
      + (double)a2 * -0.5 * v15;
  *(double *)(a5 + 8) = (double)a2 * 0.5 * v15 - (v17 - v16 * 0.0);
  *(double *)(a5 + 16) = v16 + v17 * 0.0 + (double)a3 * 0.5 * v15;
  *(void *)a5 = *(void *)(a1 + 4296);
  *(_DWORD *)(a5 + 24) = 256;
  operator new[]();
}

void CalibrateRgbIr::PrepareColorImage(int a1, __CVBuffer *a2)
{
  memset(&src, 0, sizeof(src));
  PrepareVImgBuffersFromCVPixBuffer(a2, &src);
  operator new[]();
}

void sub_24699F4B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,int a44,__int16 a45,char a46,char a47)
{
}

void SaveToFileWithPrefix<float,float>(_DWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, int a6, int a7, unint64_t a8)
{
  if (byte_2691BF747 >= 0) {
    size_t v15 = byte_2691BF747;
  }
  else {
    size_t v15 = *((void *)&gCurrFrameId + 1);
  }
  double v16 = &v24;
  std::string::basic_string[abi:ne180100]((uint64_t)&v24, v15 + 1);
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    double v16 = (std::string *)v24.__r_.__value_.__r.__words[0];
  }
  if (v15)
  {
    if (byte_2691BF747 >= 0) {
      double v17 = &gCurrFrameId;
    }
    else {
      double v17 = (long long *)gCurrFrameId;
    }
    memmove(v16, v17, v15);
  }
  *(_WORD *)((char *)&v16->__r_.__value_.__l.__data_ + v15) = 95;
  int v18 = *(char *)(a5 + 23);
  if (v18 >= 0) {
    long long v19 = (const std::string::value_type *)a5;
  }
  else {
    long long v19 = *(const std::string::value_type **)a5;
  }
  if (v18 >= 0) {
    std::string::size_type v20 = *(unsigned __int8 *)(a5 + 23);
  }
  else {
    std::string::size_type v20 = *(void *)(a5 + 8);
  }
  long long v21 = std::string::append(&v24, v19, v20);
  long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  std::string::size_type v26 = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  SaveToFile<float,float>(a1, a2, a3, a4, (uint64_t)__p, a6, a7, a8);
  if (SHIBYTE(v26) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v24.__r_.__value_.__l.__data_);
  }
}

void sub_24699F6A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

void HistogramEqualize<float,float>(float *a1, uint64_t a2, uint64_t a3, unsigned int a4, float *a5)
{
  CFDictionaryRef v7 = a1;
  v20[1] = *MEMORY[0x263EF8340];
  CFNumberRef v8 = (float *)MEMORY[0x270FA5388](a1, a2);
  CGPoint v10 = (char *)v20 - v9;
  uint64_t v13 = (v12 * v11);
  BuildHistogram<float,float>(v8, (void *)((char *)v20 - v9), v14, v13);
  if (v13)
  {
    double v15 = (double)v13;
    do
    {
      float v16 = *v7++;
      double v17 = v16 / (1.0 / (double)a4);
      unsigned int v18 = vcvtmd_u64_f64(v17);
      if (v18 >= a4) {
        unsigned int v18 = a4 - 1;
      }
      LODWORD(v17) = *(_DWORD *)&v10[4 * v18];
      float v19 = (double)*(unint64_t *)&v17 / v15;
      *a5++ = v19;
      --v13;
    }
    while (v13);
  }
}

uint64_t CalibrateRgbIr::ApplyGaussian2DFilter(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  uint64_t v32 = *MEMORY[0x263EF8340];
  unsigned int v4 = *(_DWORD *)(a2 + 20);
  if (v4 != *(_DWORD *)(a3 + 20) || (int v7 = *(_DWORD *)(a2 + 16), v7 != *(_DWORD *)(a3 + 16))) {
    CalibrateRgbIr::ApplyGaussian2DFilter();
  }
  unsigned int v8 = a4;
  if (a4)
  {
    if (v4 < a4) {
      CalibrateRgbIr::ApplyGaussian2DFilter();
    }
  }
  else
  {
    unsigned int v8 = *(_DWORD *)(a2 + 20);
  }
  Matrix<float>::Matrix((uint64_t)v26, v7 + 4, v8 + 4);
  unsigned int v9 = v7 + 2;
  if ((v7 + 2) >= 3)
  {
    unsigned int v10 = 0;
    do
    {
      if (v28 <= v10 + 2 || v29 < 3 || (unsigned int v11 = v10, *(_DWORD *)(a2 + 16) <= v10) || (v12 = *(_DWORD *)(a2 + 20)) == 0) {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      memcpy((void *)(v27 + 4 * v29 * (v10 + 2) + 8), (const void *)(*(void *)(a2 + 8) + 4 * v12 * v10), 4 * v8);
      ++v10;
    }
    while (v11 + 3 != v9);
  }
  Matrix<float>::Matrix((uint64_t)v22, v7 + 4, v8 + 4);
  int v31 = 1019113512;
  v30[2] = xmmword_2469EE8E0;
  v30[3] = unk_2469EE8F0;
  unsigned __int8 v30[4] = xmmword_2469EE900;
  v30[5] = unk_2469EE910;
  v30[0] = xmmword_2469EE8C0;
  v30[1] = unk_2469EE8D0;
  v20[0] = &unk_26FAEAFE0;
  v20[1] = v30;
  void v20[2] = 0x500000005;
  char v21 = 0;
  ImageUtils::Filter2<float>((uint64_t)v26, (uint64_t)v20, (uint64_t)v22);
  int v13 = *(_DWORD *)(a3 + 20) * *(_DWORD *)(a3 + 16);
  if (v13 >= 1)
  {
    unint64_t v14 = *(void *)(a3 + 8);
    unint64_t v15 = v14 + 4 * v13;
    if (v15 <= v14 + 4) {
      unint64_t v15 = v14 + 4;
    }
    bzero((void *)v14, ((v15 + ~v14) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
  if (v9 >= 3)
  {
    unsigned int v16 = 0;
    size_t v17 = 4 * v8;
    do
    {
      if (*(_DWORD *)(a3 + 16) <= v16 || (int v18 = *(_DWORD *)(a3 + 20)) == 0 || v24 <= v16 + 2 || v25 <= 2) {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      memcpy((void *)(*(void *)(a3 + 8) + 4 * v18 * v16), (const void *)(v23 + 4 * v25 * (v16 + 2) + 8), v17);
      ++v16;
    }
    while (v7 != v16);
  }
  Matrix<float>::~Matrix((uint64_t)v20);
  Matrix<float>::~Matrix((uint64_t)v22);
  Matrix<float>::~Matrix((uint64_t)v26);
  return 0;
}

void sub_24699FAA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
}

uint64_t CalibrateRgbIr::InitDebugDictionary(CFMutableDictionaryRef *this)
{
  CFDictionaryRemoveAllValues(this[126]);
  CFDictionarySetValue(this[126], @"choice", @"None");
  CFDictionarySetValue(this[126], @"resultValid", (const void *)*MEMORY[0x263EFFB38]);
  CFStringRef v2 = CFStringCreateWithFormat(0, 0, @"%d.%d.%d", 1, 12, 0);
  CFDictionarySetValue(this[126], @"AlgoVersion", v2);
  CFRelease(v2);
  return 0;
}

void CalibrateRgbIr::ScaleImage(uint64_t a1, void *a2, vImagePixelCount a3, vImagePixelCount a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t *a8)
{
  src.data = a2;
  src.double height = a4;
  src.double width = a3;
  src.rowBytes = 4 * a3;
  unint64_t v8 = 4 * a5;
  if ((a5 & 0xF) != 0) {
    unint64_t v8 = ((4 * a5) & 0xFFFFFFFFFFFFFFC0) + 64;
  }
  *a8 = v8 >> 2;
  operator new[]();
}

uint64_t CalibrateRgbIr::MedianFilter(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unint64_t v10 = (a3 + 63) & 0xFFFFFFFFFFFFFFC0;
  Matrix<unsigned char>::Matrix((uint64_t)v36, *(_DWORD *)(a2 + 16), (a3 + 63) & 0xFFFFFFC0);
  Matrix<float>::Resize(a5, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20));
  if (*(_DWORD *)(a2 + 16))
  {
    unsigned int v11 = 0;
    do
    {
      LODWORD(v12) = *(_DWORD *)(a2 + 20);
      if (v12)
      {
        unint64_t v13 = 0;
        do
        {
          if (*(_DWORD *)(a2 + 16) <= v11 || v38 <= v11 || v13 >= v39) {
            __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
          }
          float v14 = *(float *)(*(void *)(a2 + 8) + 4 * v11 * v12 + 4 * v13);
          if (v14 <= 1.0) {
            float v15 = v14 * 255.0;
          }
          else {
            float v15 = 255.0;
          }
          *((unsigned char *)v37 + v11 * v39 + v13++) = llroundf(v15);
          unint64_t v12 = *(unsigned int *)(a2 + 20);
        }
        while (v13 < v12);
      }
      if (v38 <= v11 || v39 <= a3) {
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      bzero((char *)v37 + a3 + v39 * v11++, v10 - a3);
    }
    while (v11 < *(_DWORD *)(a2 + 16));
  }
  std::string::basic_string[abi:ne180100]<0>(v34, "irSamplesBeforeMedianU8.pb");
  std::string::basic_string[abi:ne180100]<0>(__p, "IR samples before Median Filter");
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  unsigned int v16 = (void *)(a1 + 608);
  id v31 = 0;
  MetalObjects::createTextureMedian((void *)(a1 + 608), &v31, v37, v38, v39, v10, 0);
  id v17 = v31;
  id v30 = 0;
  MetalObjects::createTextureMedian(v16, &v30, 0, v38, v39, v10, 1);
  id v18 = v30;
  MetalObjects::medianFilter((uint64_t)v16, v17, v18, a4, 1);
  id v19 = [v18 buffer];
  std::string::size_type v20 = (unsigned __int8 *)[v19 contents];

  std::string::basic_string[abi:ne180100]<0>(v34, "irSamplesAfterMedianU8.pb");
  std::string::basic_string[abi:ne180100]<0>(__p, "IR samples after Median Filter (uint8)");
  if (v33 < 0) {
    operator delete(__p[0]);
  }
  if (v35 < 0) {
    operator delete(v34[0]);
  }
  int v21 = *(_DWORD *)(a5 + 16);
  if (v21)
  {
    int v22 = 0;
    unint64_t v23 = v10 - *(unsigned int *)(a2 + 20);
    unsigned int v24 = *(float **)(a5 + 8);
    int v25 = *(_DWORD *)(a5 + 20);
    do
    {
      for (int i = v25; i; --i)
      {
        unsigned int v27 = *v20++;
        float v28 = (double)v27 / 255.0;
        *v24++ = v28;
      }
      ++v22;
      v20 += v23;
    }
    while (v22 != v21);
  }

  Matrix<unsigned char>::~Matrix((uint64_t)v36);
  return 0;
}

void sub_24699FF90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  if (a19 < 0) {
    operator delete(__p);
  }

  Matrix<unsigned char>::~Matrix((uint64_t)&a20);
  _Unwind_Resume(a1);
}

uint64_t CalibrateRgbIr::PrepareIrImage(uint64_t a1, CVPixelBufferRef pixelBuffer, uint64_t a3, size_t *a4, size_t *a5)
{
  *a4 = CVPixelBufferGetWidth(pixelBuffer);
  size_t Height = CVPixelBufferGetHeight(pixelBuffer);
  *a5 = Height;
  if (gDbgLvl)
  {
    unint64_t v10 = *(__CFDictionary **)(a1 + 1008);
    v15.double width = (double)*a4;
    v15.double height = (double)Height;
    addValueToDictionary(v10, @"IrResolution", &v15);
  }
  std::string::basic_string[abi:ne180100]<0>(&v15, "OrigIrFromCVPixB.pb");
  std::string::basic_string[abi:ne180100]<0>(&__p, "Original IR frame from CVPixelBuffer");
  GrayScaleImage::save((int)&v15, pixelBuffer);
  if (v14 < 0) {
    operator delete(__p);
  }
  if (v16 < 0) {
    operator delete(*(void **)&v15.width);
  }
  if (CVPixelBufferGetPixelFormatType(pixelBuffer) == 1278226742)
  {
    CVPixelBufferGetBytesPerRow(pixelBuffer);
    if (!CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL))
    {
      CVPixelBufferGetBaseAddress(pixelBuffer);
      if (*a5 == 1315) {
        *a5 = 1312;
      }
      operator new[]();
    }
    return 4098;
  }
  else
  {
    NSLog(&cfstr_RgbIrCalibS.isa, "IR buffer is not in a supported format.");
    return 12290;
  }
}

void sub_2469A04F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,void *a27,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,void *a34,uint64_t a35,int a36,__int16 a37,char a38,char a39)
{
  if (a26 < 0) {
    operator delete(__p);
  }
  Matrix<float>::~Matrix((uint64_t)&a14);
  Matrix<float>::~Matrix((uint64_t)&a27);
  Matrix<float>::~Matrix((uint64_t)&a34);
  if (v40) {
    MEMORY[0x24C53D6C0](v40, 0x1000C8052888210);
  }
  MEMORY[0x24C53D6C0](v39, 0x1000C8052888210);
  _Unwind_Resume(a1);
}

void addValueToDictionary(__CFDictionary *a1, const __CFString *a2, const CGSize *a3)
{
  DictionaryRepresentatiouint64_t n = CGSizeCreateDictionaryRepresentation(*a3);
  CFDictionarySetValue(a1, a2, DictionaryRepresentation);

  CFRelease(DictionaryRepresentation);
}

double CalibrateRgbIr::SetParamsForShiftMaps(uint64_t a1, double *a2)
{
  double v2 = a2[1640];
  BOOL v3 = v2 > 0.0;
  double v4 = 10.0;
  if (v2 > 0.0) {
    double v4 = 0.0;
  }
  double v5 = a2[1098] / 0.8;
  double v6 = v2 * a2[1099];
  double v7 = 1.0 / a2[1084];
  double v8 = ceil(v6 / v5 * (dbl_2469EE8A0[v3] - v7));
  double v9 = -v5 / v6;
  double v10 = v7 - v9 * (v4 + v8);
  double result = v9 * 0.03125;
  *(double *)(a1 + 472) = result;
  *(double *)(a1 + 480) = v10;
  return result;
}

uint64_t CalibrateRgbIr::PrepareDepthImage(uint64_t a1, CVPixelBufferRef pixelBuffer)
{
  OSType PixelFormatType = CVPixelBufferGetPixelFormatType(pixelBuffer);
  if (*(unsigned char *)(a1 + 464)) {
    BOOL v5 = PixelFormatType == 825306677;
  }
  else {
    BOOL v5 = 1;
  }
  if (!v5)
  {
    double v9 = "Depth pixel buffer format should be kCVPixelFormatType_FixedPointUnsigned11_5 if it is normalized dx";
LABEL_18:
    NSLog(&cfstr_RgbIrCalibS.isa, v9);
    return 12291;
  }
  if (*(unsigned char *)(a1 + 464)) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = PixelFormatType == 825437747;
  }
  if (!v6)
  {
    double v9 = "Depth pixel buffer format should be kCVPixelFormatType_FixedPointUnsigned13_3 if they are absolute values (not normalized dx)";
    goto LABEL_18;
  }
  if (gDbgLvl)
  {
    if (*(unsigned char *)(a1 + 464)) {
      double v7 = (const void **)MEMORY[0x263EFFB40];
    }
    else {
      double v7 = (const void **)MEMORY[0x263EFFB38];
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"isNormalizedDx", *v7);
  }
  CVPixelBufferGetBytesPerRow(pixelBuffer);
  if (!CVPixelBufferLockBaseAddress(pixelBuffer, 1uLL)) {
    operator new[]();
  }
  return 4099;
}

void sub_2469A097C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CalibrateRgbIr::RetrieveRoiInfo(uint64_t a1, CFArrayRef theArray, unint64_t a3, unint64_t a4, CGRect *a5)
{
  if (theArray && CFArrayGetCount(theArray) >= 1)
  {
    CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, 0);
    if (ValueAtIndex)
    {
      CFDictionaryRef Value = (const __CFDictionary *)CFDictionaryGetValue(ValueAtIndex, (const void *)*MEMORY[0x263F2D440]);
      if (Value)
      {
        if (CGRectMakeWithDictionaryRepresentation(Value, &rect))
        {
          CGFloat x = rect.origin.x;
          CGFloat y = rect.origin.y;
          a5->origin.CGFloat x = rect.origin.x;
          a5->origin.CGFloat y = y;
          CGFloat width = rect.size.width;
          CGFloat height = rect.size.height;
          a5->size.CGFloat width = rect.size.width;
          a5->size.CGFloat height = height;
          NSLog(&cfstr_RgbIrCalibRoiI.isa, *(void *)&x, *(void *)&y, *(void *)&height, *(void *)&width);
          if (gDbgLvl)
          {
            char v16 = *(__CFDictionary **)(a1 + 1008);
            DictionaryRepresentatiouint64_t n = CGRectCreateDictionaryRepresentation(*a5);
            CFDictionarySetValue(v16, @"faceRoi", DictionaryRepresentation);
            CFRelease(DictionaryRepresentation);
          }
          uint64_t result = 0;
          double v20 = a5->size.width;
          double v19 = a5->size.height;
          CGFloat v21 = round(a5->origin.x * (double)a4);
          a5->origin.CGFloat x = round((1.0 - a5->origin.y - v19) * (double)a3);
          a5->origin.CGFloat y = v21;
          a5->size.CGFloat width = round(v19 * (double)a3);
          a5->size.CGFloat height = round(v20 * (double)a4);
          return result;
        }
        int v22 = "Could not retrieve ROI information from detected faces array.";
      }
      else
      {
        int v22 = "Could not find ROI element in detected faces array.";
      }
    }
    else
    {
      int v22 = "Could not retrieve any element from detected faces array.";
    }
    NSLog(&cfstr_RgbIrCalibS.isa, v22);
    if (gDbgLvl) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"failureReason", @"Could not retrieve face ROI information. Check detectedFaces argument.");
    }
    return 8193;
  }
  else
  {
    if (gDbgLvl) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"failureReason", @"No face ROI specified.");
    }
    NSLog(&cfstr_RgbIrCalibS.isa, "No detected faces provided. Calibration will not be performed.");
    return 16386;
  }
}

uint64_t CalibrateRgbIr::SelectRefineResult(uint64_t a1, uint64_t a2, uint64_t a3, double a4, float a5, float a6)
{
  if (*(float *)&a4 < -6.0) {
    float v9 = -6.0;
  }
  else {
    float v9 = *(float *)&a4;
  }
  BOOL v10 = *(float *)&a4 >= -6.0;
  if (*(float *)&a4 <= 6.0) {
    float v11 = v9;
  }
  else {
    float v11 = 6.0;
  }
  if (*(float *)&a4 > 6.0) {
    BOOL v10 = 0;
  }
  if (a5 < -6.0) {
    *(float *)&a4 = -6.0;
  }
  else {
    *(float *)&a4 = a5;
  }
  if (a5 < -6.0) {
    BOOL v10 = 0;
  }
  if (a5 <= 6.0) {
    float v12 = *(float *)&a4;
  }
  else {
    float v12 = 6.0;
  }
  BOOL v13 = a5 <= 6.0 && v10;
  double v14 = a6;
  NSLog(&cfstr_RgbIrCalibAppl.isa, a4, v11, v12, a6);
  long long v40 = xmmword_2469EDEF0;
  uint64_t v41 = 0x3FF0000000000000;
  float64x2_t v37 = *(float64x2_t *)(a1 + 80);
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t v44 = 0x3FF0000000000000;
  double v38 = *(double *)(a1 + 96);
  uint64_t v39 = 0;
  v37.f64[0] = v37.f64[0] + v11;
  v37.f64[1] = v37.f64[1] + v12;
  double v38 = v38 + v14;
  uint64_t v36 = 0;
  memset(v35, 0, sizeof(v35));
  CGSize v15 = v35;
  GeomUtils::CalcRotationMatrix<double>(v37.f64, (uint64_t)v35);
  uint64_t v16 = 0;
  uint64_t v34 = 0;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  do
  {
    uint64_t v17 = 0;
    id v18 = (double *)&v39;
    do
    {
      uint64_t v19 = 0;
      double v20 = 0.0;
      CGFloat v21 = v18;
      do
      {
        double v22 = *v21;
        v21 += 3;
        double v20 = v20 + *(double *)((char *)v15 + v19) * v22;
        v19 += 8;
      }
      while (v19 != 24);
      *((double *)&v30 + 3 * v16 + v17++) = v20;
      ++v18;
    }
    while (v17 != 3);
    ++v16;
    CGSize v15 = (_OWORD *)((char *)v15 + 24);
  }
  while (v16 != 3);
  memcpy((void *)a3, (const void *)a2, 0x3370uLL);
  long long v23 = v33;
  *(_OWORD *)(a3 + 8584) = v32;
  *(_OWORD *)(a3 + 8600) = v23;
  *(void *)(a3 + 8616) = v34;
  long long v24 = v31;
  *(_OWORD *)(a3 + 8552) = v30;
  *(_OWORD *)(a3 + 8568) = v24;
  if (v13)
  {
    uint64_t v29 = *(void *)(a2 + 13112);
    long long v25 = *(_OWORD *)(a2 + 13096);
    v28[2] = *(_OWORD *)(a2 + 13080);
    v28[3] = v25;
    long long v26 = *(_OWORD *)(a2 + 13064);
    v28[0] = *(_OWORD *)(a2 + 13048);
    v28[1] = v26;
    GeomUtils::CalcRotationAngleFromMatrix<double>((uint64_t)v28, (long double *)v37.f64);
    *(float64x2_t *)(a3 + 13144) = vdivq_f64(v37, (float64x2_t)vdupq_n_s64(0x408F400000000000uLL));
    *(double *)(a3 + 13160) = v38 / 1000.0;
  }
  else
  {
    NSLog(&cfstr_RgbIrCalibS.isa, "Rotation was clipped. Will not mark Pearl as calibrated.");
  }
  if (gDbgLvl)
  {
    setValueCFDict<float>(*(__CFDictionary **)(a1 + 1008), @"appliedXAngleCorrection", v11);
    setValueCFDict<float>(*(__CFDictionary **)(a1 + 1008), @"appliedYAngleCorrection", v12);
  }
  return 0;
}

uint64_t CalibrateRgbIr::CalculateFinalResult(float64x2_t *a1, uint64_t a2, float32x2_t a3, float32_t a4, float a5)
{
  float64x2_t v28 = a1[5];
  double v6 = a1[6].f64[0];
  a3.f32[1] = a4;
  float64x2_t v28 = vaddq_f64(v28, vcvtq_f64_f32(a3));
  double v29 = v6 + a5;
  uint64_t v27 = 0;
  memset(v26, 0, sizeof(v26));
  double v7 = v26;
  GeomUtils::CalcRotationMatrix<double>(v28.f64, (uint64_t)v26);
  uint64_t v8 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  long long v21 = xmmword_2469EDEF0;
  long long v23 = 0u;
  long long v24 = 0u;
  uint64_t v22 = 0x3FF0000000000000;
  uint64_t v25 = 0x3FF0000000000000;
  memset(v18, 0, sizeof(v18));
  do
  {
    uint64_t v9 = 0;
    BOOL v10 = (double *)&v20;
    do
    {
      uint64_t v11 = 0;
      double v12 = 0.0;
      BOOL v13 = v10;
      do
      {
        double v14 = *v13;
        v13 += 3;
        double v12 = v12 + *(double *)((char *)v7 + v11) * v14;
        v11 += 8;
      }
      while (v11 != 24);
      *((double *)v18 + 3 * v8 + v9++) = v12;
      ++v10;
    }
    while (v9 != 3);
    ++v8;
    double v7 = (_OWORD *)((char *)v7 + 24);
  }
  while (v8 != 3);
  long long v16 = 0uLL;
  uint64_t v17 = 0;
  GeomUtils::CalcRotationAngleFromMatrix<double>((uint64_t)v18, (long double *)&v16);
  *(_OWORD *)a2 = v16;
  *(void *)(a2 + 16) = v17;
  return 0;
}

uint64_t CalibrateRgbIr::Calibrate(uint64_t a1, int a2, const __CFDictionary *a3, int a4, int a5, int a6, unsigned int a7, const __CFBoolean *a8, double *a9, CFArrayRef theArray, __int16 a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v52 = *MEMORY[0x263EF8340];
  *(unsigned char *)(a1 + 976) = 0;
  NSLog(&cfstr_RgbIrCalibStar.isa, 1, 12, 0, a7, a8, a11);
  long long v16 = std::string::basic_string[abi:ne180100]<0>(&valuePtr, "PCECalib.bin");
  SaveToFileWithPrefix((uint64_t)v16);
  if (v42 < 0) {
    operator delete(valuePtr);
  }
  if (gDbgLvl)
  {
    CalibrateRgbIr::InitDebugDictionary((CFMutableDictionaryRef *)a1);
    uint64_t v39 = [NSNumber numberWithDouble:a9[1069]];
    long long v43 = v39;
    uint64_t v44 = [NSNumber numberWithDouble:a9[1070]];
    float64x2_t v37 = (void *)v44;
    uint64_t v36 = [NSNumber numberWithDouble:a9[1071]];
    long long v45 = v36;
    uint64_t v17 = [NSNumber numberWithDouble:a9[1072]];
    id v46 = v17;
    id v18 = [NSNumber numberWithDouble:a9[1073]];
    uint64_t v47 = v18;
    uint64_t v19 = [NSNumber numberWithDouble:a9[1074]];
    long long v48 = v19;
    uint64_t v20 = [NSNumber numberWithDouble:a9[1075]];
    int v49 = v20;
    long long v21 = [NSNumber numberWithDouble:a9[1076]];
    long long v50 = v21;
    uint64_t v22 = [NSNumber numberWithDouble:a9[1077]];
    dispatch_queue_t v51 = v22;
    long long v23 = [MEMORY[0x263EFF8C0] arrayWithObjects:&v43 count:9];

    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"colorRotationMatrix", v23);
  }
  uint64_t Value = CFBooleanGetValue(a8);
  if (Value)
  {
    uint64_t v25 = a1;
    *(unsigned char *)(a1 + 464) = a7;
    if (a7)
    {
      double v26 = a9[1640];
      BOOL v27 = v26 > 0.0;
      double v28 = 10.0;
      if (v26 > 0.0) {
        double v28 = 0.0;
      }
      double v29 = a9[1098] / 0.8;
      double v30 = v26 * a9[1099];
      double v31 = 1.0 / a9[1084];
      double v32 = ceil(v30 / v29 * (dbl_2469EE8A0[v27] - v31));
      double v33 = -v29 / v30;
      *(double *)(a1 + 472) = v33 * 0.03125;
      *(double *)(a1 + 480) = v31 - v33 * (v28 + v32);
    }
    if (*(unsigned char *)(a1 + 492)
      || (Value = CalibrateRgbIr::CheckPceCalibValid(Value, a3, (uint64_t)a9), uint64_t v25 = a1, (Value & 1) != 0))
    {
      CalibrateRgbIr::GetCamParams(Value, (uint64_t)a9, v25 + 232);
    }
    NSLog(&cfstr_RgbIrCalibS.isa, "PCECalib and IR metadata do not match. PCECalib is probably not valid anymore");
    if (gDbgLvl) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"failureReason", @"Calibration data not consistent.");
    }
    CalibrateRgbIr::SaveDebugPlist((id *)a1);
    return 16385;
  }
  else
  {
    NSLog(&cfstr_RgbIrCalibS.isa, "depthPerspectiveCorrected is false. Currently, only perspective corrected depth is supported");
    if (gDbgLvl) {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 1008), @"failureReason", @"Depth perspective not corrected.");
    }
    CalibrateRgbIr::SaveDebugPlist((id *)a1);
    return 12289;
  }
}

void sub_2469A1B9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,void *__p,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  Matrix<float>::~Matrix((uint64_t)&a51);
  uint64_t v55 = *(void *)(v53 - 256);
  if (v55) {
    MEMORY[0x24C53D6C0](v55, 0x1000C8052888210);
  }
  Matrix<float>::~Matrix(v53 - 248);
  _Unwind_Resume(a1);
}

void CalibrateRgbIr::SaveDebugPlist(id *this)
{
  if ((~gDbgLvl & 0x11) == 0)
  {
    id v1 = this[126];
    if (byte_2691BF72F >= 0) {
      size_t v2 = byte_2691BF72F;
    }
    else {
      size_t v2 = qword_2691BF720;
    }
    BOOL v3 = &v17;
    std::string::basic_string[abi:ne180100]((uint64_t)&v17, v2 + 1);
    if ((v17.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      BOOL v3 = (std::string *)v17.__r_.__value_.__r.__words[0];
    }
    if (v2)
    {
      if (byte_2691BF72F >= 0) {
        double v4 = &gOutputDirName;
      }
      else {
        double v4 = (uint64_t *)gOutputDirName;
      }
      memmove(v3, v4, v2);
    }
    *(_WORD *)((char *)&v3->__r_.__value_.__l.__data_ + v2) = 47;
    if (byte_2691BF747 >= 0) {
      BOOL v5 = (const std::string::value_type *)&gCurrFrameId;
    }
    else {
      BOOL v5 = (const std::string::value_type *)gCurrFrameId;
    }
    if (byte_2691BF747 >= 0) {
      std::string::size_type v6 = byte_2691BF747;
    }
    else {
      std::string::size_type v6 = *((void *)&gCurrFrameId + 1);
    }
    double v7 = std::string::append(&v17, v5, v6);
    long long v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v18.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v18.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    uint64_t v9 = std::string::append(&v18, "_Debug.plist", 0xCuLL);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    std::string::size_type v20 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v18.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v18.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v17.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v17.__r_.__value_.__l.__data_);
    }
    CreateDirForFile((uint64_t *)__p);
    uint64_t v11 = NSString;
    int v12 = SHIBYTE(v20);
    BOOL v13 = (void **)__p[0];
    uint64_t v14 = [NSString defaultCStringEncoding];
    if (v12 >= 0) {
      CGSize v15 = __p;
    }
    else {
      CGSize v15 = v13;
    }
    long long v16 = [v11 stringWithCString:v15 encoding:v14];
    [v1 writeToFile:v16 atomically:1];

    if (SHIBYTE(v20) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_2469A1F14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  double v30 = v29;

  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t CalibrateRgbIr::ReleaseLocalResources(CalibrateRgbIr *this)
{
  long long v2 = *(_OWORD *)((char *)this + 248);
  v36[0] = *(_OWORD *)((char *)this + 232);
  v36[1] = v2;
  uint64_t v3 = *((void *)this + 35);
  v36[2] = *(_OWORD *)((char *)this + 264);
  long long v38 = *((_OWORD *)this + 18);
  uint64_t v4 = *((void *)this + 38);
  uint64_t v37 = v3;
  uint64_t v39 = v4;
  uint64_t v5 = *((void *)this + 41);
  long long v40 = *(_OWORD *)((char *)this + 312);
  long long v6 = *((_OWORD *)this + 22);
  long long v42 = *((_OWORD *)this + 21);
  long long v7 = *((_OWORD *)this + 23);
  long long v8 = *((_OWORD *)this + 24);
  uint64_t v9 = *((void *)this + 50);
  uint64_t v41 = v5;
  uint64_t v46 = v9;
  long long v45 = v8;
  long long v44 = v7;
  long long v43 = v6;
  long long v10 = *(_OWORD *)((char *)this + 408);
  long long v11 = *(_OWORD *)((char *)this + 424);
  long long v12 = *(_OWORD *)((char *)this + 440);
  uint64_t v50 = *((void *)this + 57);
  long long v48 = v11;
  long long v49 = v12;
  long long v47 = v10;
  ReleaseCamParams((uint64_t)v36);
  long long v13 = *((_OWORD *)this + 1);
  v21[0] = *(_OWORD *)this;
  v21[1] = v13;
  v21[2] = *((_OWORD *)this + 2);
  uint64_t v22 = *((void *)this + 6);
  long long v23 = *(_OWORD *)((char *)this + 56);
  uint64_t v24 = *((void *)this + 9);
  long long v25 = *((_OWORD *)this + 5);
  uint64_t v26 = *((void *)this + 12);
  long long v27 = *(_OWORD *)((char *)this + 104);
  long long v14 = *(_OWORD *)((char *)this + 120);
  long long v15 = *(_OWORD *)((char *)this + 136);
  long long v16 = *(_OWORD *)((char *)this + 152);
  uint64_t v31 = *((void *)this + 21);
  long long v30 = v16;
  long long v29 = v15;
  long long v28 = v14;
  long long v17 = *((_OWORD *)this + 11);
  long long v18 = *((_OWORD *)this + 12);
  long long v19 = *((_OWORD *)this + 13);
  uint64_t v35 = *((void *)this + 28);
  long long v33 = v18;
  long long v34 = v19;
  long long v32 = v17;
  return ReleaseCamParams((uint64_t)v21);
}

void addValueToDictionary(__CFDictionary *a1, const __CFString *a2, int a3)
{
  int valuePtr = a3;
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x263EFFB08], kCFNumberSInt32Type, &valuePtr);
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v5);
}

void CalibrateRgbIr::PrepareXyzWorld(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a6)
  {
    if (a7)
    {
      int v8 = *(_DWORD *)(a2 + 188) * *(_DWORD *)(a2 + 184);
      Matrix<float>::Matrix((uint64_t)v44, 2, v8);
      if (v46 && v47)
      {
        if (v46 > 1)
        {
          int v9 = *(_DWORD *)(a2 + 184);
          if (v9)
          {
            unsigned int v10 = 0;
            long long v11 = (float *)__src;
            long long v12 = (float *)((char *)__src + 4 * v47);
            double v13 = *(double *)(a2 + 48);
            double v14 = *(double *)(a2 + 8) / v13;
            int v15 = *(_DWORD *)(a2 + 188);
            double v16 = *(double *)(a2 + 16) / v13;
            do
            {
              if (v15)
              {
                for (unsigned int i = 0; i != v15; ++i)
                {
                  float v18 = v13 * ((float)v10 + 0.5 - v14);
                  *v11++ = v18;
                  float v19 = v13 * ((float)i + 0.5 - v16);
                  *v12++ = v19;
                }
              }
              ++v10;
            }
            while (v10 != v9);
          }
          Matrix<float>::Matrix((uint64_t)&v40, 2, v8);
          long long v40 = &unk_26FAED0B0;
          memcpy(__dst, __src, 4 * v47 * (unint64_t)v46);
          Matrix<float>::Matrix((uint64_t)v36, *(_DWORD *)(a2 + 188), *(_DWORD *)(a2 + 184));
          Matrix<float>::Matrix((uint64_t)v32, *(_DWORD *)(a2 + 188), *(_DWORD *)(a2 + 184));
          if (v42 && v43)
          {
            if (v42 > 1)
            {
              uint64_t v20 = v39;
              if (v39)
              {
                unint64_t v21 = 0;
                uint64_t v22 = v38;
                long long v23 = (float *)__dst;
                uint64_t v24 = (float *)((char *)__dst + 4 * v43);
                float v25 = *(double *)(a2 + 48);
                unint64_t v26 = v34;
                do
                {
                  if (v22)
                  {
                    unsigned int v27 = 0;
                    unsigned int v28 = 0;
                    unint64_t v29 = 0;
                    unint64_t v30 = v35;
                    do
                    {
                      *(float *)(v37 + 4 * v21 + 4 * v27) = *v23 / v25;
                      if (v29 >= v26 || v21 >= v30) {
                        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
                      }
                      float v31 = *v24++;
                      ++v23;
                      *(float *)(v33 + 4 * v21 + 4 * v28) = v31 / v25;
                      ++v29;
                      v28 += v30;
                      v27 += v20;
                    }
                    while (v22 != v29);
                  }
                  ++v21;
                }
                while (v21 != v20);
              }
              operator new[]();
            }
            __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
          }
          __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
        }
        __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
      }
      __assert_rtn("operator()", "Matrix.hpp", 119, "row < m_rows && col < m_cols");
    }
    CalibrateRgbIr::PrepareXyzWorld();
  }
  CalibrateRgbIr::PrepareXyzWorld();
}

void sub_2469A27AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va2, a8);
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v16 = va_arg(va2, void);
  uint64_t v17 = va_arg(va2, void);
  uint64_t v18 = va_arg(va2, void);
  Matrix<float>::~Matrix((uint64_t)va);
  Matrix<float>::~Matrix((uint64_t)va1);
  Matrix<float>::~Matrix((uint64_t)va2);
  _Unwind_Resume(a1);
}

BOOL isPixelInRoi(_DWORD *a1, double *a2, double a3)
{
  LODWORD(a3) = *a1;
  double v3 = (double)*(unint64_t *)&a3;
  BOOL result = 0;
  if (*a2 <= v3 && *a2 + a2[2] > v3)
  {
    LODWORD(v3) = a1[1];
    double v4 = (double)*(unint64_t *)&v3;
    double v5 = a2[1];
    if (v5 <= v4 && v5 + a2[3] > v4) {
      return 1;
    }
  }
  return result;
}

uint64_t CalibrateRgbIr::ValidateResults(CalibrateRgbIr *this, float a2, float a3)
{
  BOOL v3 = a2 == -30.0;
  if (a2 == 30.0) {
    BOOL v3 = 1;
  }
  if (a3 == -30.0) {
    BOOL v3 = 1;
  }
  int v4 = a3 == 30.0 || v3;
  if (v4 == 1) {
    NSLog(&cfstr_RgbIrCalibErro.isa, a2, a3);
  }
  return v4 ^ 1u;
}

uint64_t CalibrateRgbIr::abort(uint64_t this)
{
  *(unsigned char *)(this + 976) = 1;
  return this;
}

void SaveToFile<float,float>(_DWORD *a1, unint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, int a6, int a7, unint64_t a8)
{
  v50[19] = *MEMORY[0x263EF8340];
  if ((gDbgLvl & 4) != 0)
  {
    if (a8) {
      unint64_t v14 = a8;
    }
    else {
      unint64_t v14 = a3 * a2;
    }
    if (byte_2691BF72F >= 0) {
      size_t v15 = byte_2691BF72F;
    }
    else {
      size_t v15 = qword_2691BF720;
    }
    uint64_t v16 = &v48;
    std::string::basic_string[abi:ne180100]((uint64_t)&v48, v15 + 1);
    if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v16 = (std::string *)v48.__r_.__value_.__r.__words[0];
    }
    if (v15)
    {
      if (byte_2691BF72F >= 0) {
        uint64_t v17 = &gOutputDirName;
      }
      else {
        uint64_t v17 = (uint64_t *)gOutputDirName;
      }
      memmove(v16, v17, v15);
    }
    *(_WORD *)((char *)&v16->__r_.__value_.__l.__data_ + v15) = 47;
    int v18 = *(char *)(a5 + 23);
    if (v18 >= 0) {
      float v19 = (const std::string::value_type *)a5;
    }
    else {
      float v19 = *(const std::string::value_type **)a5;
    }
    if (v18 >= 0) {
      std::string::size_type v20 = *(unsigned __int8 *)(a5 + 23);
    }
    else {
      std::string::size_type v20 = *(void *)(a5 + 8);
    }
    unint64_t v21 = std::string::append(&v48, v19, v20);
    long long v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
    std::string::size_type v46 = v21->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v22;
    v21->__r_.__value_.__l.__size_ = 0;
    v21->__r_.__value_.__r.__words[2] = 0;
    v21->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v48.__r_.__value_.__l.__data_);
    }
    if (CreateDirForFile((uint64_t *)__p)) {
      goto LABEL_59;
    }
    uint64_t v23 = MEMORY[0x263F8C310] + 64;
    v50[0] = MEMORY[0x263F8C310] + 64;
    std::string::size_type v24 = *(void *)(MEMORY[0x263F8C2B0] + 16);
    v48.__r_.__value_.__r.__words[0] = *(void *)(MEMORY[0x263F8C2B0] + 8);
    *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words
                              + *(void *)(v48.__r_.__value_.__r.__words[0] - 24)) = v24;
    float v25 = (std::ios_base *)((char *)&v48 + *(void *)(v48.__r_.__value_.__r.__words[0] - 24));
    std::ios_base::init(v25, &v48.__r_.__value_.__r.__words[1]);
    uint64_t v26 = MEMORY[0x263F8C310] + 24;
    v25[1].__vftable = 0;
    v25[1].__fmtflags_ = -1;
    v48.__r_.__value_.__r.__words[0] = v26;
    v50[0] = v23;
    MEMORY[0x24C53D420](&v48.__r_.__value_.__r.__words[1]);
    if (a6)
    {
      std::ofstream::open();
      if (!v49) {
        goto LABEL_58;
      }
      if (a2 && v14)
      {
        LODWORD(v27) = 0;
        unint64_t v28 = 0;
        do
        {
          if (a3)
          {
            unint64_t v29 = 1;
            do
            {
              LODWORD(v47.__locale_) = 0;
              LODWORD(v47.__locale_) = *a1;
              std::ostream::write();
              ++a1;
              unint64_t v30 = v29 + 1;
              if (v29 >= a3) {
                break;
              }
              unint64_t v31 = v28 + v29++;
            }
            while (v31 < v14);
            unint64_t v28 = v28 + v30 - 1;
          }
          unint64_t v27 = (v27 + 1);
          a1 += (a4 >> 2) - a3;
        }
        while (v27 < a2 && v28 < v14);
      }
    }
    else
    {
      std::ofstream::open();
      if (!v49) {
        goto LABEL_58;
      }
      *(void *)(MEMORY[0x263F8C100] + *(void *)(*MEMORY[0x263F8C100] - 24) + 16) = 10;
      if (a2)
      {
        uint64_t v33 = 0;
        LODWORD(v34) = 0;
        unint64_t v42 = 0;
        unint64_t v44 = a4 >> 2;
        unint64_t v35 = a3 - 1;
        while (!v35)
        {
LABEL_53:
          unsigned int v39 = (void *)std::ostream::operator<<();
          std::ios_base::getloc((const std::ios_base *)((char *)v39 + *(void *)(*v39 - 24)));
          long long v40 = std::locale::use_facet(&v47, MEMORY[0x263F8C108]);
          ((void (*)(const std::locale::facet *, uint64_t))v40->__vftable[2].~facet_0)(v40, 10);
          std::locale::~locale(&v47);
          std::ostream::put();
          std::ostream::flush();
          ++v42;
          unint64_t v34 = (v34 + 1);
          v33 += v44;
          if (v34 >= a2) {
            goto LABEL_54;
          }
        }
        int v41 = v34;
        unint64_t v34 = 0;
        if (v14 >= v42) {
          uint64_t v36 = v14 - v42;
        }
        else {
          uint64_t v36 = 0;
        }
        while (v36 != v34)
        {
          uint64_t v37 = (void *)std::ostream::operator<<();
          if (a7)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)v37 + *(void *)(*v37 - 24)));
            unsigned int v38 = std::locale::use_facet(&v47, MEMORY[0x263F8C108]);
            ((void (*)(const std::locale::facet *, uint64_t))v38->__vftable[2].~facet_0)(v38, 10);
            std::locale::~locale(&v47);
            std::ostream::put();
            std::ostream::flush();
          }
          else
          {
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)",", 1);
          }
          if (v35 <= ++v34)
          {
            v42 += v34;
            LODWORD(v34) = v41;
            goto LABEL_53;
          }
        }
        if (std::filebuf::close()) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
    }
LABEL_54:
    if (!std::filebuf::close()) {
LABEL_57:
    }
      std::ios_base::clear((std::ios_base *)((char *)&v48 + *(void *)(v48.__r_.__value_.__r.__words[0] - 24)), *(_DWORD *)((char *)&v48 + *(void *)(v48.__r_.__value_.__r.__words[0] - 24) + 32) | 4);
LABEL_58:
    v48.__r_.__value_.__r.__words[0] = *MEMORY[0x263F8C2B0];
    *(std::string::size_type *)((char *)v48.__r_.__value_.__r.__words
                              + *(void *)(v48.__r_.__value_.__r.__words[0] - 24)) = *(void *)(MEMORY[0x263F8C2B0]
                                                                                                + 24);
    MEMORY[0x24C53D430](&v48.__r_.__value_.__r.__words[1]);
    std::ostream::~ostream();
    MEMORY[0x24C53D6A0](v50);
LABEL_59:
    if (SHIBYTE(v46) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_2469A2F28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,std::locale a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void *std::ofstream::~ofstream(void *a1)
{
  uint64_t v2 = MEMORY[0x263F8C2B0];
  uint64_t v3 = *MEMORY[0x263F8C2B0];
  *a1 = *MEMORY[0x263F8C2B0];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x24C53D430](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x24C53D6A0](a1 + 52);
  return a1;
}

void BuildHistogram<float,float>(float *a1, _DWORD *a2, unsigned int a3, unsigned int a4)
{
  long long v6 = a2;
  if (a3) {
    bzero(a2, 4 * a3);
  }
  if (a4)
  {
    uint64_t v8 = a4;
    do
    {
      float v9 = *a1++;
      unsigned int v10 = vcvtmd_u64_f64(v9 / (1.0 / (double)(a3 - 1)));
      if (v10 >= a3) {
        unsigned int v10 = a3 - 1;
      }
      ++v6[v10];
      --v8;
    }
    while (v8);
  }
  if (a3)
  {
    int v11 = 0;
    uint64_t v12 = a3;
    do
    {
      v11 += *v6;
      *v6++ = v11;
      --v12;
    }
    while (v12);
  }
}

uint64_t Matrix<unsigned char>::Matrix(uint64_t result, int a2, int a3)
{
  *(void *)BOOL result = &unk_26FAED080;
  if (a3 * a2) {
    operator new[]();
  }
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = a2;
  *(_DWORD *)(result + 20) = a3;
  *(unsigned char *)(result + 24) = 0;
  return result;
}

void Matrix<unsigned char>::~Matrix(uint64_t a1)
{
  Matrix<unsigned char>::~Matrix(a1);

  JUMPOUT(0x24C53D6E0);
}

uint64_t Matrix<unsigned char>::~Matrix(uint64_t a1)
{
  *(void *)a1 = &unk_26FAED080;
  if (*(void *)(a1 + 8) && *(unsigned char *)(a1 + 24))
  {
    MEMORY[0x24C53D6C0]();
    *(void *)(a1 + 8) = 0;
  }
  *(void *)(a1 + 16) = 0;
  return a1;
}

void OneDimensionHorizontalFilterWithPadding()
{
  __assert_rtn("OneDimensionHorizontalFilterWithPadding", "CalibrateRgbIr.mm", 2464, "(filterSize % 2) == 1");
}

{
  __assert_rtn("OneDimensionHorizontalFilterWithPadding", "CalibrateRgbIr.mm", 2462, "filter.Rows() == 1");
}

void OneDimensionVerticalFilterWithPadding()
{
  __assert_rtn("OneDimensionVerticalFilterWithPadding", "CalibrateRgbIr.mm", 2489, "(filterSize % 2) == 1");
}

{
  __assert_rtn("OneDimensionVerticalFilterWithPadding", "CalibrateRgbIr.mm", 2487, "filter.Rows() == 1");
}

void CalibrateRgbIr::PrepareGridCalculation(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "PrepareGridCalculation";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "RGB-IR: %s: rdar://112006283 Error creating textures => Aborting Rgb-Ir run\n", (uint8_t *)&v1, 0xCu);
}

void CalibrateRgbIr::ApplyGaussian2DFilter()
{
  __assert_rtn("ApplyGaussian2DFilter", "CalibrateRgbIr.mm", 1202, "input.Cols() >= relevantWidth");
}

{
  __assert_rtn("ApplyGaussian2DFilter", "CalibrateRgbIr.mm", 1200, "input.Cols() == output.Cols() && input.Rows() == output.Rows()");
}

void CalibrateRgbIr::PrepareXyzWorld()
{
}

{
  __assert_rtn("PrepareXyzWorld", "CalibrateRgbIr.mm", 2156, "goodIdxRoiMask");
}

void CalibrateRgbIr::PrepareXyzWorld(int a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = 136315394;
  uint64_t v3 = "PrepareXyzWorld";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "RGB-IR: %s: rdar://112006283 numOfGoodPts is %d < 256 => Aborting Rgb-Ir run\n", (uint8_t *)&v2, 0x12u);
}

uint64_t SaveToFile(uint64_t result)
{
  v24[19] = *MEMORY[0x263EF8340];
  if ((gDbgLvl & 4) != 0)
  {
    uint64_t v1 = result;
    uint64_t v2 = MEMORY[0x263F8C310] + 64;
    v24[0] = MEMORY[0x263F8C310] + 64;
    uint64_t v3 = (uint64_t *)MEMORY[0x263F8C2B0];
    uint64_t v4 = *(void *)(MEMORY[0x263F8C2B0] + 16);
    uint64_t v22 = *(void *)(MEMORY[0x263F8C2B0] + 8);
    *(void *)((char *)&v23[-1] + *(void *)(v22 - 24)) = v4;
    int v5 = (std::ios_base *)((char *)&v23[-1] + *(void *)(v22 - 24));
    std::ios_base::init(v5, v23);
    uint64_t v6 = MEMORY[0x263F8C310] + 24;
    v5[1].__vftable = 0;
    v5[1].__fmtflags_ = -1;
    uint64_t v22 = v6;
    v24[0] = v2;
    MEMORY[0x24C53D420](v23);
    if (byte_2691BF72F >= 0) {
      size_t v7 = byte_2691BF72F;
    }
    else {
      size_t v7 = qword_2691BF720;
    }
    uint64_t v8 = &v19;
    std::string::basic_string[abi:ne180100]((uint64_t)&v19, v7 + 1);
    if ((v19.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      uint64_t v8 = (std::string *)v19.__r_.__value_.__r.__words[0];
    }
    if (v7)
    {
      if (byte_2691BF72F >= 0) {
        float v9 = &gOutputDirName;
      }
      else {
        float v9 = (uint64_t *)gOutputDirName;
      }
      memmove(v8, v9, v7);
    }
    *(_WORD *)((char *)&v8->__r_.__value_.__l.__data_ + v7) = 47;
    int v10 = *(char *)(v1 + 23);
    if (v10 >= 0) {
      int v11 = (const std::string::value_type *)v1;
    }
    else {
      int v11 = *(const std::string::value_type **)v1;
    }
    if (v10 >= 0) {
      std::string::size_type v12 = *(unsigned __int8 *)(v1 + 23);
    }
    else {
      std::string::size_type v12 = *(void *)(v1 + 8);
    }
    uint64_t v13 = std::string::append(&v19, v11, v12);
    long long v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    int64_t v21 = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v19.__r_.__value_.__l.__data_);
    }
    if (!CreateDirForFile((uint64_t *)__p))
    {
      std::ofstream::open();
      if (v23[15])
      {
        std::ostream::write();
        if (!std::filebuf::close()) {
          std::ios_base::clear((std::ios_base *)((char *)&v23[-1] + *(void *)(v22 - 24)), *(_DWORD *)((char *)&v23[3] + *(void *)(v22 - 24)) | 4);
        }
      }
      else
      {
        size_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"Could not open file [", 21);
        if (v21 >= 0) {
          uint64_t v16 = __p;
        }
        else {
          uint64_t v16 = (void **)__p[0];
        }
        if (v21 >= 0) {
          uint64_t v17 = HIBYTE(v21);
        }
        else {
          uint64_t v17 = (uint64_t)__p[1];
        }
        int v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)v16, v17);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"] for writing.\n", 15);
      }
    }
    if (SHIBYTE(v21) < 0) {
      operator delete(__p[0]);
    }
    uint64_t v22 = *v3;
    *(void *)((char *)&v23[-1] + *(void *)(v22 - 24)) = v3[3];
    MEMORY[0x24C53D430](v23);
    std::ostream::~ostream();
    return MEMORY[0x24C53D6A0](v24);
  }
  return result;
}

void sub_2469A3948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  std::ofstream::~ofstream(&a23);
  _Unwind_Resume(a1);
}

uint64_t CreateDirForFile(uint64_t *a1)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = (uint64_t *)*a1;
  }
  uint64_t v2 = objc_msgSend(NSString, "stringWithCString:encoding:", v1, objc_msgSend(NSString, "defaultCStringEncoding"));
  uint64_t v3 = [MEMORY[0x263F08850] defaultManager];
  char v11 = 0;
  if ([v3 fileExistsAtPath:v2 isDirectory:&v11]) {
    goto LABEL_13;
  }
  uint64_t v4 = [v2 pathExtension];
  char v5 = [v4 isEqualToString:&stru_26FAF64D8];

  if (v5)
  {
LABEL_12:
    if (![v3 createDirectoryAtPath:v2 withIntermediateDirectories:1 attributes:0 error:0])
    {
      uint64_t v9 = 0xFFFFFFFFLL;
      goto LABEL_15;
    }
LABEL_13:
    uint64_t v9 = 0;
LABEL_15:
    uint64_t v6 = v2;
    goto LABEL_16;
  }
  uint64_t v6 = [v2 stringByDeletingLastPathComponent];

  char v7 = [v3 fileExistsAtPath:v6 isDirectory:&v11];
  if (v11) {
    char v8 = v7;
  }
  else {
    char v8 = 0;
  }
  if ((v8 & 1) == 0)
  {
    uint64_t v2 = v6;
    goto LABEL_12;
  }
  uint64_t v9 = 0;
LABEL_16:

  return v9;
}

void sub_2469A3ADC(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void SaveToFileWithPrefix(uint64_t a1)
{
  if (byte_2691BF747 >= 0) {
    size_t v2 = byte_2691BF747;
  }
  else {
    size_t v2 = *((void *)&gCurrFrameId + 1);
  }
  uint64_t v3 = &v10;
  std::string::basic_string[abi:ne180100]((uint64_t)&v10, v2 + 1);
  if ((v10.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    uint64_t v3 = (std::string *)v10.__r_.__value_.__r.__words[0];
  }
  if (v2)
  {
    if (byte_2691BF747 >= 0) {
      uint64_t v4 = &gCurrFrameId;
    }
    else {
      uint64_t v4 = (long long *)gCurrFrameId;
    }
    memmove(v3, v4, v2);
  }
  *(_WORD *)((char *)&v3->__r_.__value_.__l.__data_ + v2) = 95;
  int v5 = *(char *)(a1 + 23);
  if (v5 >= 0) {
    uint64_t v6 = (const std::string::value_type *)a1;
  }
  else {
    uint64_t v6 = *(const std::string::value_type **)a1;
  }
  if (v5 >= 0) {
    std::string::size_type v7 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    std::string::size_type v7 = *(void *)(a1 + 8);
  }
  char v8 = std::string::append(&v10, v6, v7);
  long long v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  std::string::size_type v12 = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  SaveToFile((uint64_t)__p);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v10.__r_.__value_.__l.__data_);
  }
}

void sub_2469A3C18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  if (a15 < 0) {
    operator delete(a10);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CreateDir(uint64_t *a1)
{
  if (*((char *)a1 + 23) >= 0) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = (uint64_t *)*a1;
  }
  size_t v2 = objc_msgSend(NSString, "stringWithCString:encoding:", v1, objc_msgSend(NSString, "defaultCStringEncoding"));
  uint64_t v3 = [MEMORY[0x263F08850] defaultManager];
  char v8 = 0;
  char v4 = [v3 fileExistsAtPath:v2 isDirectory:&v8];
  if (v8) {
    char v5 = v4;
  }
  else {
    char v5 = 0;
  }
  if ((v5 & 1) != 0
    || ([v3 createDirectoryAtPath:v2 withIntermediateDirectories:1 attributes:0 error:0] & 1) != 0)
  {
    uint64_t v6 = 0;
  }
  else
  {
    uint64_t v6 = 0xFFFFFFFFLL;
  }

  return v6;
}

void sub_2469A3D18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t InitCamParams(uint64_t result)
{
  *(void *)(result + 32) = 0;
  *(void *)(result + 40) = 0;
  return result;
}

uint64_t ReleaseCamParams(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (v2)
  {
    MEMORY[0x24C53D6E0](v2, 0x1000C4052888210);
    *(void *)(a1 + 40) = 0;
  }
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    uint64_t result = MEMORY[0x24C53D6E0](result, 0x1000C4052888210);
    *(void *)(a1 + 32) = 0;
  }
  return result;
}

uint64_t GetFileSize(uint64_t a1)
{
  v12[19] = *MEMORY[0x263EF8340];
  std::ifstream::basic_ifstream(v10);
  if (v11[15])
  {
    std::istream::tellg();
    uint64_t v2 = v9;
  }
  else
  {
    uint64_t v3 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x263F8C100], (uint64_t)"Unable to open file ", 20);
    int v4 = *(char *)(a1 + 23);
    if (v4 >= 0) {
      uint64_t v5 = a1;
    }
    else {
      uint64_t v5 = *(void *)a1;
    }
    if (v4 >= 0) {
      uint64_t v6 = *(unsigned __int8 *)(a1 + 23);
    }
    else {
      uint64_t v6 = *(void *)(a1 + 8);
    }
    std::string::size_type v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v3, v5, v6);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v7, (uint64_t)".\n", 2);
    uint64_t v2 = 0;
  }
  v10[0] = *MEMORY[0x263F8C2A8];
  *(uint64_t *)((char *)v10 + *(void *)(v10[0] - 24)) = *(void *)(MEMORY[0x263F8C2A8] + 24);
  MEMORY[0x24C53D430](v11);
  std::istream::~istream();
  MEMORY[0x24C53D6A0](v12);
  return v2;
}

void sub_2469A3F1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
}

uint64_t *std::ifstream::basic_ifstream(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x263F8C308] + 64;
  a1[53] = MEMORY[0x263F8C308] + 64;
  uint64_t v3 = a1 + 2;
  uint64_t v4 = *(void *)(MEMORY[0x263F8C2A8] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x263F8C2A8] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  a1[1] = 0;
  uint64_t v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 2);
  uint64_t v7 = MEMORY[0x263F8C308] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[53] = v2;
  MEMORY[0x24C53D420](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_2469A40D4(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x24C53D6A0](v1);
  _Unwind_Resume(a1);
}

void *std::ifstream::~ifstream(void *a1)
{
  uint64_t v2 = MEMORY[0x263F8C2A8];
  uint64_t v3 = *MEMORY[0x263F8C2A8];
  *a1 = *MEMORY[0x263F8C2A8];
  *(void *)((char *)a1 + *(void *)(v3 - 24)) = *(void *)(v2 + 24);
  MEMORY[0x24C53D430](a1 + 2);
  std::istream::~istream();
  MEMORY[0x24C53D6A0](a1 + 53);
  return a1;
}

uint64_t SavePixelBufferWithMetadataToFile(__CVBuffer *a1, const void **a2)
{
  v36[19] = *MEMORY[0x263EF8340];
  if (*((char *)a2 + 23) >= 0) {
    size_t v4 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v4 = (size_t)a2[1];
  }
  uint64_t v5 = v32;
  std::string::basic_string[abi:ne180100]((uint64_t)v32, v4 + 4);
  if (v33 < 0) {
    uint64_t v5 = (void **)v32[0];
  }
  if (v4)
  {
    if (*((char *)a2 + 23) >= 0) {
      uint64_t v6 = a2;
    }
    else {
      uint64_t v6 = *a2;
    }
    memmove(v5, v6, v4);
  }
  strcpy((char *)v5 + v4, ".raw");
  size_t PlaneCount = CVPixelBufferGetPlaneCount(a1);
  std::ofstream::basic_ofstream(&v34);
  if (v35[15])
  {
    if (CVPixelBufferLockBaseAddress(a1, 1uLL))
    {
      NSLog(&cfstr_RgbIrCalibS.isa, "Could not lock pixel buffer.");
      uint64_t v8 = 4294967294;
    }
    else
    {
      if (PlaneCount)
      {
        for (size_t i = 0; i != PlaneCount; ++i)
        {
          size_t HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, i);
          CVPixelBufferGetWidthOfPlane(a1, i);
          size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, i);
          BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(a1, i);
          if (HeightOfPlane)
          {
            long long v14 = BaseAddressOfPlane;
            do
            {
              std::ostream::write();
              v14 += BytesPerRowOfPlane;
              --HeightOfPlane;
            }
            while (HeightOfPlane);
          }
        }
      }
      else
      {
        size_t Height = CVPixelBufferGetHeight(a1);
        CVPixelBufferGetWidth(a1);
        size_t BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
        BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
        if (Height)
        {
          int v18 = BaseAddress;
          do
          {
            std::ostream::write();
            v18 += BytesPerRow;
            --Height;
          }
          while (Height);
        }
      }
      if (!std::filebuf::close()) {
        std::ios_base::clear((std::ios_base *)((char *)&v35[-1] + *(void *)(v34 - 24)), *(_DWORD *)((char *)&v35[3] + *(void *)(v34 - 24)) | 4);
      }
      CVPixelBufferUnlockBaseAddress(a1, 1uLL);
      std::string v19 = CVBufferGetAttachments(a1, kCVAttachmentMode_ShouldPropagate);
      std::string::size_type v20 = NSString;
      if (*((char *)a2 + 23) >= 0) {
        size_t v21 = *((unsigned __int8 *)a2 + 23);
      }
      else {
        size_t v21 = (size_t)a2[1];
      }
      uint64_t v22 = __p;
      std::string::basic_string[abi:ne180100]((uint64_t)__p, v21 + 6);
      if (v31 < 0) {
        uint64_t v22 = (void **)__p[0];
      }
      if (v21)
      {
        if (*((char *)a2 + 23) >= 0) {
          uint64_t v23 = a2;
        }
        else {
          uint64_t v23 = *a2;
        }
        memmove(v22, v23, v21);
      }
      strcpy((char *)v22 + v21, ".plist");
      int v24 = v31;
      float v25 = (void **)__p[0];
      uint64_t v26 = [NSString defaultCStringEncoding];
      if (v24 >= 0) {
        unint64_t v27 = __p;
      }
      else {
        unint64_t v27 = v25;
      }
      unint64_t v28 = [v20 stringWithCString:v27 encoding:v26];
      if (v31 < 0) {
        operator delete(__p[0]);
      }
      [v19 writeToFile:v28 atomically:1];

      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v9 = v32;
    if (v33 < 0) {
      uint64_t v9 = (void **)v32[0];
    }
    NSLog(&cfstr_RgbIrCalibCoul.isa, v9);
    uint64_t v8 = 0xFFFFFFFFLL;
  }
  uint64_t v34 = *MEMORY[0x263F8C2B0];
  *(void *)((char *)&v35[-1] + *(void *)(v34 - 24)) = *(void *)(MEMORY[0x263F8C2B0] + 24);
  MEMORY[0x24C53D430](v35);
  std::ostream::~ostream();
  MEMORY[0x24C53D6A0](v36);
  if (v33 < 0) {
    operator delete(v32[0]);
  }
  return v8;
}

void sub_2469A4604(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

uint64_t *std::ofstream::basic_ofstream(uint64_t *a1)
{
  uint64_t v2 = MEMORY[0x263F8C310] + 64;
  a1[52] = MEMORY[0x263F8C310] + 64;
  uint64_t v3 = a1 + 1;
  uint64_t v4 = *(void *)(MEMORY[0x263F8C2B0] + 16);
  uint64_t v5 = *(void *)(MEMORY[0x263F8C2B0] + 8);
  *a1 = v5;
  *(uint64_t *)((char *)a1 + *(void *)(v5 - 24)) = v4;
  uint64_t v6 = (std::ios_base *)((char *)a1 + *(void *)(*a1 - 24));
  std::ios_base::init(v6, a1 + 1);
  uint64_t v7 = MEMORY[0x263F8C310] + 24;
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *a1 = v7;
  a1[52] = v2;
  MEMORY[0x24C53D420](v3);
  if (!std::filebuf::open()) {
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 4);
  }
  return a1;
}

void sub_2469A482C(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x24C53D6A0](v1);
  _Unwind_Resume(a1);
}

uint64_t PrepareVImgBuffersFromCVPixBuffer(__CVBuffer *a1, vImage_Buffer *a2)
{
  vImagePixelCount Width = CVPixelBufferGetWidth(a1);
  vImagePixelCount Height = CVPixelBufferGetHeight(a1);
  if (CVPixelBufferLockBaseAddress(a1, 1uLL)) {
    return 0xFFFFFFFFLL;
  }
  a2->data = CVPixelBufferGetBaseAddressOfPlane(a1, 0);
  a2->CGFloat height = Height;
  a2->CGFloat width = Width;
  size_t BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, 0);
  uint64_t result = 0;
  a2->rowBytes = BytesPerRowOfPlane;
  return result;
}

void PearlIRIsf::PearlIRIsf(PearlIRIsf *this)
{
  *(void *)this = &unk_26FAED0E8;
  operator new();
}

void sub_2469A494C(_Unwind_Exception *a1)
{
  MEMORY[0x24C53D6E0](v1, 0x10A1C4036002B25);
  _Unwind_Resume(a1);
}

void PearlIRIsf::~PearlIRIsf(PearlIRIsf *this)
{
  *(void *)this = &unk_26FAED0E8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;

  *(void *)this = &unk_26FAED0E8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }
}

{
  uint64_t v1;
  uint64_t vars8;

  *(void *)this = &unk_26FAED0E8;
  uint64_t v1 = *((void *)this + 1);
  if (v1) {
    (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  }

  JUMPOUT(0x24C53D6E0);
}

uint64_t PearlIRIsf::Run(uint64_t a1, _DWORD *a2, int64x2_t *a3, double a4, double a5, double a6, double a7)
{
  return Isf::RunIsf(a4, a5, a6, a7, a1, *(void **)(a1 + 8), a2, 3, a3);
}

uint64_t PearlIRIsf::updatePCECalib(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return PearlInternalIRIsf::updatePCECalib(*(void *)(a1 + 8), a2, a3 + 13048);
}

uint64_t Img4DecodeSecureBootRsa4kSha384IM4C(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return Img4DecodeVerifyChainIM4C((uint64_t)&SecureBoot_root_rsa4k_pub, 526, a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t Img4DecodeLocalRsa4kSha384IM4C(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return Img4DecodeVerifyChainIM4C((uint64_t)&Local_root_rsa4k_pub, 526, a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t Img4DecodeShamRsa4kSha384IM4C(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, uint64_t a8)
{
  return Img4DecodeVerifyChainIM4C((uint64_t)&Sham_root_rsa4k_pub, 526, a1, a2, a3, a4, a5, a6, a7, a8);
}

void Img4DecodeEvaluateTrust(unsigned int a1, uint64_t a2, uint64_t (*a3)(unint64_t, uint64_t *, uint64_t, uint64_t), uint64_t a4)
{
}

double Img4DecodeCopyPayloadHash(uint64_t a1, uint64_t a2, int a3)
{
  return Img4DecodeCopyPayloadHashWithCallback(a1, (void (*)(void, void, long long *))sha1_digest, a2, a3);
}

double Img4DecodeCopyManifestHash(uint64_t a1, uint64_t a2, int a3)
{
  return Img4DecodeCopyManifestHashWithCallback(a1, (void (*)(void))sha1_digest, a2, a3);
}

double DERImg4DecodeFindInSequence(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  unint64_t v7 = 0;
  long long v8 = 0uLL;
  while (!DERDecodeSeqNext(a1, &v7))
  {
    if (v7 == a2)
    {
      double result = *(double *)&v8;
      *a3 = v8;
      return result;
    }
  }
  return result;
}

double DERImg4DecodeContentFindItemWithTag(unint64_t *a1, uint64_t a2, _OWORD *a3)
{
  v6[0] = 0;
  v6[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v6)) {
    return DERImg4DecodeFindInSequence(v6, a2, a3);
  }
  return result;
}

uint64_t DERImg4DecodeTagCompare(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 8);
  if (v2 < 4) {
    return 0xFFFFFFFFLL;
  }
  if (v2 != 4) {
    return 1;
  }
  unsigned int v5 = 0;
  if (DERParseInteger((char **)a1, &v5)) {
    return 4294967294;
  }
  if (v5 < a2) {
    return 0xFFFFFFFFLL;
  }
  return v5 > a2;
}

uint64_t DERImg4Decode(void *a1, unint64_t a2)
{
  uint64_t result = 6;
  if (a1)
  {
    if (a2)
    {
      unint64_t v6 = 0;
      unint64_t v7 = 0;
      uint64_t v8 = 0;
      uint64_t result = DERDecodeItem((uint64_t)a1, &v6);
      if (!result)
      {
        if (v6 == 0x2000000000000010)
        {
          uint64_t v5 = a1[1];
          if (__CFADD__(*a1, v5) || __CFADD__(v7, v8))
          {
            __break(0x5513u);
          }
          else if (*a1 + v5 == v7 + v8)
          {
            uint64_t result = DERParseSequenceContentToObject(&v7, 4u, (uint64_t)&DERImg4ItemSpecs, a2, 0x40uLL, 0);
            if (!result) {
              return 2 * (DERImg4DecodeTagCompare(a2, 0x494D4734u) != 0);
            }
          }
          else
          {
            return 7;
          }
        }
        else
        {
          return 2;
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePayloadCompression(unint64_t *a1, char **a2)
{
  unsigned int v5 = 2;
  uint64_t result = 6;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = DERParseSequenceContentToObject(a1, 2u, (uint64_t)&DERImg4CompressionItemSpecs, (unint64_t)a2, 0x20uLL, 0);
      if (!result)
      {
        uint64_t result = DERParseInteger(a2, &v5);
        if (!result)
        {
          if (v5 <= 1) {
            return 0;
          }
          else {
            return 6;
          }
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePayloadWithProperties(uint64_t a1, unint64_t a2)
{
  uint64_t result = 6;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = DERParseSequenceToObject(a1, 7u, (uint64_t)&DERImg4PayloadWithPropertiesItemSpecs, a2, 0xA0uLL, 0);
      if (!result)
      {
        if (DERImg4DecodeTagCompare(a2, 0x494D3450u))
        {
          return 2;
        }
        else if (!*(void *)(a2 + 80) {
               || (long long v7 = 0u,
        }
                   long long v8 = 0u,
                   uint64_t result = DERImg4DecodePayloadCompression((unint64_t *)(a2 + 80), (char **)&v7),
                   !result))
        {
          uint64_t v6 = *(void *)(a2 + 96);
          uint64_t v5 = a2 + 96;
          if (!v6) {
            return 0;
          }
          long long v7 = 0u;
          long long v8 = 0u;
          uint64_t result = DERImg4DecodePayloadProperties(v5, (unint64_t)&v7);
          if (!result) {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePayloadProperties(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (!a2) {
      return 6;
    }
    if (*(void *)result && *(void *)(result + 8))
    {
      uint64_t result = DERParseSequenceToObject(result, 2u, (uint64_t)&DERImg4PayloadPropertiesItemSpecs, a2, 0x20uLL, 0);
      if (result) {
        return result;
      }
      if (DERImg4DecodeTagCompare(a2, 0x50415950u)) {
        return 2;
      }
    }
    return 0;
  }
  return result;
}

uint64_t DERImg4DecodePayload(uint64_t a1, unint64_t a2)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  uint64_t result = 6;
  if (a1 && a2)
  {
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    uint64_t result = DERImg4DecodePayloadWithProperties(a1, (unint64_t)&v11);
    if (result)
    {
      uint64_t result = DERParseSequenceToObject(a1, 6u, (uint64_t)&DERImg4PayloadItemSpecs, a2, 0x90uLL, 0);
      if (!result)
      {
        if (DERImg4DecodeTagCompare(a2, 0x494D3450u))
        {
          return 2;
        }
        else
        {
          uint64_t v6 = *(void *)(a2 + 80);
          uint64_t v5 = (unint64_t *)(a2 + 80);
          if (!v6) {
            return 0;
          }
          memset(v10, 0, sizeof(v10));
          uint64_t result = DERImg4DecodePayloadCompression(v5, (char **)v10);
          if (!result) {
            return 0;
          }
        }
      }
    }
    else
    {
      long long v7 = v12;
      *(_OWORD *)a2 = v11;
      *(_OWORD *)(a2 + 16) = v7;
      long long v8 = v14;
      *(_OWORD *)(a2 + 32) = v13;
      *(_OWORD *)(a2 + 48) = v8;
      long long v9 = v16;
      *(_OWORD *)(a2 + 64) = v15;
      *(_OWORD *)(a2 + 80) = v9;
    }
  }
  return result;
}

uint64_t DERImg4DecodeManifest(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 5uLL, (uint64_t)&DERImg4ManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t DERImg4DecodeManifestCommon(void *a1, unint64_t a2, uint64_t a3, unint64_t a4, unsigned int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    if (!*a1 || !a1[1]) {
      return 0;
    }
    if (a2 >= 0x10000)
    {
      __break(0x5507u);
      return result;
    }
    uint64_t result = DERParseSequenceToObject((uint64_t)a1, (unsigned __int16)a2, a3, a4, 0xC0uLL, 0);
    if (!result)
    {
      if (DERImg4DecodeTagCompare(a4, a5)) {
        return 2;
      }
      unsigned int v9 = 0;
      uint64_t result = DERParseInteger((char **)(a4 + 16), &v9);
      if (result) {
        return result;
      }
      if (v9 > 2) {
        return 2;
      }
      return 0;
    }
  }
  return result;
}

uint64_t DERImg4DecodeUnsignedManifest(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D344Du);
}

uint64_t DERImg4DecodeCertificate(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 4uLL, (uint64_t)&DERImg4CertificateItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodeUnsignedCertificate(void *a1, unint64_t a2)
{
  return DERImg4DecodeManifestCommon(a1, 3uLL, (uint64_t)&DERImg4UnsignedManifestItemSpecs, a2, 0x494D3443u);
}

uint64_t DERImg4DecodeCertificatePropertiesAndPubKey(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  unint64_t v18 = 0;
  unint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t result = 6;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            if (a6)
            {
              v21[0] = a1;
              v21[1] = a2;
              long long v16 = 0u;
              long long v17 = 0u;
              long long v14 = 0u;
              long long v15 = 0u;
              uint64_t result = DERDecodeItem((uint64_t)v21, &v18);
              if (!result)
              {
                if (v18 != 0x2000000000000011) {
                  return 2;
                }
                if (!DERParseSequenceContentToObject(&v19, 2u, (uint64_t)&DERIM4CItemSpecs, (unint64_t)&v16, 0x20uLL, 0))
                {
                  uint64_t result = DERDecodeItem((uint64_t)&v16, &v18);
                  if (result) {
                    return result;
                  }
                  if (v18 != 0x2000000000000010) {
                    return 2;
                  }
                  if (!DERParseSequenceContentToObject(&v19, 2u, (uint64_t)&DERCRTPSequenceItemSpecs, (unint64_t)&v14, 0x20uLL, 0))
                  {
                    uint64_t v12 = *((void *)&v15 + 1);
                    *a3 = v15;
                    *a4 = v12;
                    uint64_t result = DERDecodeItem((uint64_t)&v17, &v18);
                    if (result) {
                      return result;
                    }
                    if (v18 == 4)
                    {
                      uint64_t result = 0;
                      uint64_t v13 = v20;
                      *a5 = v19;
                      *a6 = v13;
                      return result;
                    }
                    return 2;
                  }
                }
                return 0xFFFFFFFFLL;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodeRestoreInfo(uint64_t result, unint64_t a2)
{
  if (result)
  {
    if (!a2) {
      return 6;
    }
    if (*(void *)result && *(void *)(result + 8))
    {
      uint64_t result = DERParseSequenceToObject(result, 2u, (uint64_t)&DERImg4RestoreInfoItemSpecs, a2, 0x20uLL, 0);
      if (result) {
        return result;
      }
      if (DERImg4DecodeTagCompare(a2, 0x494D3452u)) {
        return 2;
      }
    }
    return 0;
  }
  return result;
}

uint64_t DERImg4DecodeProperty(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 6;
  if (a1)
  {
    if (a3)
    {
      unint64_t v14 = 0;
      long long v15 = 0uLL;
      long long v13 = 0uLL;
      uint64_t v11 = 0;
      unint64_t v12 = 0;
      uint64_t v9 = 0;
      unint64_t v10 = 0;
      unsigned int v8 = 0;
      uint64_t result = DERDecodeSeqInit((uint64_t)a1, &v9, &v10);
      if (!result)
      {
        if (v9 != 0x2000000000000010) {
          return 2;
        }
        uint64_t result = DERDecodeSeqNext(&v10, &v14);
        if (result) {
          return result;
        }
        if (v14 != 22) {
          return 2;
        }
        uint64_t result = DERParseInteger((char **)&v15, &v8);
        if (result) {
          return result;
        }
        if ((v8 | 0xE000000000000000) != a2) {
          return 2;
        }
        *(_OWORD *)a3 = v15;
        uint64_t result = DERDecodeSeqNext(&v10, &v12);
        if (result) {
          return result;
        }
        *(void *)(a3 + 40) = v12;
        *(_OWORD *)(a3 + 24) = v13;
        uint64_t result = DERDecodeSeqNext(&v10, &v12);
        if (result != 1) {
          return 2;
        }
        uint64_t v7 = a1[1];
        if (__CFADD__(*a1, v7))
        {
          __break(0x5513u);
        }
        else if (v11 == *a1 + v7)
        {
          return 0;
        }
        else
        {
          return 7;
        }
      }
    }
  }
  return result;
}

uint64_t DERImg4DecodePropertyWithItem(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  unsigned int v8 = 0;
  v9[0] = 0;
  v9[2] = 0;
  v9[1] = 22;
  v9[3] = 24;
  long long v10 = a3;
  uint64_t result = DERParseSequenceToObject(a1, 2u, (uint64_t)v9, a4, 0x30uLL, 0);
  if (!result)
  {
    uint64_t result = DERParseInteger((char **)a4, &v8);
    if (!result)
    {
      if ((v8 | 0xE000000000000000) == a2)
      {
        uint64_t result = 0;
        *(void *)(a4 + 16) = a2 | 0xE000000000000000;
        *(void *)(a4 + 40) = a3;
      }
      else
      {
        return 2;
      }
    }
  }
  return result;
}

void DERImg4DecodeFindPropertyInSequence(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  long long v8 = 0uLL;
  DERImg4DecodeFindInSequence(a1, a2, &v8);
  if (!v7) {
    DERImg4DecodePropertyWithItem((uint64_t)&v8, a2, a3, a4);
  }
}

void DERImg4DecodeFindProperty(unint64_t *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  v7[0] = 0;
  v7[1] = 0;
  if (!DERDecodeSeqContentInit(a1, v7)) {
    DERImg4DecodeFindPropertyInSequence(v7, a2, a3, a4);
  }
}

void DERImg4DecodeParseManifestProperties(uint64_t a1, unint64_t a2, unint64_t a3)
{
}

void DERImg4DecodeParseManifestPropertiesInternal(uint64_t a1, unint64_t a2, unint64_t a3, unsigned int a4)
{
  int v11 = 0;
  if (a1)
  {
    if (a2 | a3)
    {
      unint64_t v14 = 0;
      v15[0] = 0;
      v15[1] = 0;
      memset(v13, 0, sizeof(v13));
      memset(v12, 0, sizeof(v12));
      if (!DERDecodeItem(a1 + 264, &v14)
        && v14 == 0x2000000000000011
        && !DERParseInteger((char **)(a1 + 248), &v11))
      {
        unint64_t v8 = v11 == 2 ? 0x2000000000000010 : 0x2000000000000011;
        DERImg4DecodeFindProperty(v15, a4 | 0xE000000000000000, v8, (unint64_t)v13);
        if (!v9)
        {
          if (a2) {
            *(_OWORD *)a2 = *(_OWORD *)((char *)&v13[1] + 8);
          }
          DERImg4DecodeFindProperty((unint64_t *)&v13[1] + 1, 0xE00000004D414E50, 0x2000000000000011uLL, (unint64_t)v12);
          if (a3)
          {
            if (!v10) {
              *(_OWORD *)a3 = *(_OWORD *)((char *)&v12[1] + 8);
            }
          }
        }
      }
    }
  }
}

void DERImg4DecodeParseCertificateProperties(uint64_t a1, unint64_t a2, unint64_t a3)
{
}

uint64_t Img4DecodeParseLengthFromBufferWithTag(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  unint64_t v11 = 0;
  unint64_t v12 = 0;
  v16[0] = 0;
  v16[1] = 0;
  v14[1] = 0;
  unint64_t v15 = 0;
  uint64_t result = 0xFFFFFFFFLL;
  unint64_t v13 = 0;
  v14[0] = 0;
  if (a1)
  {
    if (a4)
    {
      v17[0] = a1;
      v17[1] = a2;
      uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v17, &v15, &v12);
      if (!result)
      {
        if (v12)
        {
          if (v15 != 0x2000000000000010) {
            return 2;
          }
          uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v16, &v13, &v11);
          if (result) {
            return result;
          }
          if (v11)
          {
            uint64_t result = DERImg4DecodeTagCompare((uint64_t)v14, a3);
            if (!result)
            {
              uint64_t v8 = v16[0] - a1;
              if (v12 >= ~(v16[0] - a1)) {
                return 7;
              }
              BOOL v9 = __CFADD__(v12, v8);
              uint64_t v10 = v12 + v8;
              if (v9)
              {
                __break(0x5500u);
              }
              else
              {
                uint64_t result = 0;
                *a4 = v10;
              }
              return result;
            }
            return 2;
          }
        }
        return 3;
      }
    }
  }
  return result;
}

uint64_t Img4DecodeParseLengthFromBuffer(uint64_t a1, uint64_t a2, void *a3)
{
  return Img4DecodeParseLengthFromBufferWithTag(a1, a2, 0x494D4734u, a3);
}

uint64_t Img4DecodePayloadExists(uint64_t a1, BOOL *a2)
{
  uint64_t result = 6;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 136)) {
      BOOL v4 = *(void *)(a1 + 144) != 0;
    }
    else {
      BOOL v4 = 0;
    }
    uint64_t result = 0;
    *a2 = v4;
  }
  return result;
}

uint64_t Img4DecodeGetPayload(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    BOOL v5 = 0;
    uint64_t result = Img4DecodePayloadExists(a1, &v5);
    if (!result)
    {
      if (v5)
      {
        uint64_t result = 0;
        *(_OWORD *)a2 = *(_OWORD *)(a1 + 136);
        return result;
      }
      uint64_t result = 1;
    }
    goto LABEL_9;
  }
  uint64_t result = 6;
  if (a2)
  {
LABEL_9:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  return result;
}

uint64_t Img4DecodeGetPayloadType(uint64_t a1, _DWORD *a2)
{
  BOOL v5 = 0;
  uint64_t result = 6;
  if (!a1 || !a2 || (uint64_t result = Img4DecodePayloadExists(a1, &v5), result))
  {
LABEL_6:
    if (!a2) {
      return result;
    }
    goto LABEL_7;
  }
  if (v5)
  {
    uint64_t result = DERParseInteger((char **)(a1 + 104), a2);
    goto LABEL_6;
  }
  uint64_t result = 1;
  if (!a2) {
    return result;
  }
LABEL_7:
  if (result) {
    *a2 = 0;
  }
  return result;
}

uint64_t Img4DecodeGetPayloadVersion(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    BOOL v5 = 0;
    uint64_t result = Img4DecodePayloadExists(a1, &v5);
    if (!result)
    {
      if (v5)
      {
        uint64_t result = 0;
        *(_OWORD *)a2 = *(_OWORD *)(a1 + 120);
        return result;
      }
      uint64_t result = 1;
    }
    goto LABEL_9;
  }
  uint64_t result = 6;
  if (a2)
  {
LABEL_9:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  return result;
}

uint64_t Img4DecodePayloadKeybagExists(uint64_t a1, BOOL *a2)
{
  uint64_t result = 6;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 152)) {
      BOOL v4 = *(void *)(a1 + 160) != 0;
    }
    else {
      BOOL v4 = 0;
    }
    uint64_t result = 0;
    *a2 = v4;
  }
  return result;
}

uint64_t Img4DecodeGetPayloadKeybag(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    BOOL v5 = 0;
    uint64_t result = Img4DecodePayloadExists(a1, &v5);
    if (!result)
    {
      if (v5)
      {
        uint64_t result = 0;
        *(_OWORD *)a2 = *(_OWORD *)(a1 + 152);
        return result;
      }
      uint64_t result = 1;
    }
    goto LABEL_9;
  }
  uint64_t result = 6;
  if (a2)
  {
LABEL_9:
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
  }
  return result;
}

uint64_t Img4DecodePayloadCompressionInfoExists(uint64_t a1, BOOL *a2)
{
  uint64_t result = 6;
  if (a1 && a2)
  {
    if (*(void *)(a1 + 168)) {
      BOOL v4 = *(void *)(a1 + 176) != 0;
    }
    else {
      BOOL v4 = 0;
    }
    uint64_t result = 0;
    *a2 = v4;
  }
  return result;
}

uint64_t Img4DecodeGetPayloadCompressionInfo(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  BOOL v11 = 0;
  uint64_t result = 6;
  if (!a1) {
    goto LABEL_14;
  }
  if (!a2) {
    goto LABEL_14;
  }
  if (!a3) {
    goto LABEL_14;
  }
  uint64_t result = Img4DecodePayloadExists(a1, &v11);
  if (result) {
    goto LABEL_14;
  }
  if (!v11) {
    goto LABEL_13;
  }
  uint64_t result = Img4DecodePayloadCompressionInfoExists(a1, &v11);
  if (result) {
    goto LABEL_14;
  }
  if (!v11)
  {
LABEL_13:
    uint64_t result = 1;
    goto LABEL_14;
  }
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v8 = *(void *)(a1 + 168);
  int v7 = (unint64_t *)(a1 + 168);
  if (!v8)
  {
    uint64_t result = 0xFFFFFFFFLL;
    if (!a2) {
      return result;
    }
LABEL_15:
    if (a3)
    {
      *a2 = -1;
      *a3 = -1;
    }
    return result;
  }
  uint64_t result = DERParseSequenceContentToObject(v7, 2u, (uint64_t)&DERImg4CompressionItemSpecs, (unint64_t)&v9, 0x20uLL, 0);
  if (result
    || (uint64_t result = DERParseInteger((char **)&v9, a2), result)
    || (uint64_t result = DERParseInteger((char **)&v10, a3), result))
  {
LABEL_14:
    if (!a2) {
      return result;
    }
    goto LABEL_15;
  }
  return result;
}

double Img4DecodeCopyPayloadHashWithCallback(uint64_t a1, void (*a2)(void, void, long long *), uint64_t a3, int a4)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1 || a4 != 20 || !a3)
  {
    if (!a3) {
      return *(double *)&v7;
    }
LABEL_9:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    return *(double *)&v7;
  }
  BOOL v9 = 0;
  if (Img4DecodePayloadExists(a1, &v9) || !v9) {
    goto LABEL_9;
  }
  if (*(unsigned char *)a1)
  {
    long long v7 = *(_OWORD *)(a1 + 184);
    *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 200);
    *(_OWORD *)a3 = v7;
  }
  else
  {
    long long v10 = 0uLL;
    int v11 = 0;
    a2(*(void *)(a1 + 8), *(void *)(a1 + 16), &v10);
    *(void *)&long long v7 = v10;
    *(_OWORD *)a3 = v10;
    *(_DWORD *)(a3 + 16) = v11;
  }
  return *(double *)&v7;
}

uint64_t Img4DecodeCopyPayloadDigest(uint64_t a1, void *a2, size_t a3, uint64_t (**a4)(void, void, _OWORD *, size_t, void))
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v4 = 6;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          BOOL v10 = 0;
          if (*a4)
          {
            if (!Img4DecodePayloadExists(a1, &v10))
            {
              if (v10)
              {
                if (a3 > 0x30)
                {
                  return 7;
                }
                else if (*(unsigned char *)a1)
                {
                  memcpy(a2, (const void *)(a1 + 184), a3);
                  return 0;
                }
                else
                {
                  memset(__src, 0, sizeof(__src));
                  uint64_t v4 = (*a4)(*(void *)(a1 + 8), *(void *)(a1 + 16), __src, a3, a4);
                  if (!v4) {
                    memcpy(a2, __src, a3);
                  }
                }
              }
              else
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return v4;
}

uint64_t Img4DecodeManifestExists(uint64_t a1, BOOL *a2)
{
  uint64_t result = 6;
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      *a2 = *(void *)(a1 + 24) != 0;
    }
  }
  return result;
}

double Img4DecodeCopyManifestHashWithCallback(uint64_t a1, void (*a2)(void), uint64_t a3, int a4)
{
  if (!a1 || a4 != 20 || !a3)
  {
    if (!a3) {
      return *(double *)&v5;
    }
LABEL_8:
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    return *(double *)&v5;
  }
  if (!*(void *)(a1 + 24)) {
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 1))
  {
    long long v5 = *(_OWORD *)(a1 + 328);
    *(_DWORD *)(a3 + 16) = *(_DWORD *)(a1 + 344);
    *(_OWORD *)a3 = v5;
  }
  else
  {
    a2();
    *(void *)&long long v5 = 0;
    *(_OWORD *)a3 = 0uLL;
    *(_DWORD *)(a3 + 16) = 0;
  }
  return *(double *)&v5;
}

uint64_t Img4DecodeCopyManifestDigest(uint64_t a1, void *__dst, size_t __n, uint64_t (**a4)(uint64_t, void, _OWORD *, size_t, void))
{
  uint64_t v11 = *MEMORY[0x263EF8340];
  uint64_t v4 = 6;
  if (a1)
  {
    if (__dst)
    {
      if (__n)
      {
        if (a4)
        {
          long long v7 = *a4;
          if (*a4)
          {
            uint64_t v8 = *(void *)(a1 + 24);
            if (v8)
            {
              if (__n > 0x30)
              {
                return 7;
              }
              else if (*(unsigned char *)(a1 + 1))
              {
                memcpy(__dst, (const void *)(a1 + 328), __n);
                return 0;
              }
              else
              {
                memset(v10, 0, sizeof(v10));
                uint64_t v4 = v7(v8, *(void *)(a1 + 32), v10, __n, a4);
                if (!v4) {
                  memcpy(__dst, v10, __n);
                }
              }
            }
            else
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return v4;
}

uint64_t Img4DecodeGetManifest(uint64_t a1, void *a2, _DWORD *a3)
{
  uint64_t result = 6;
  if (a1 && a2 && a3)
  {
    uint64_t v5 = *(void *)(a1 + 24);
    *a2 = v5;
    int v6 = *(_DWORD *)(a1 + 32);
    *a3 = v6;
    if (v5) {
      BOOL v7 = v6 == 0;
    }
    else {
      BOOL v7 = 1;
    }
    int v8 = v7;
    return (v8 << 31 >> 31);
  }
  return result;
}

uint64_t Img4DecodeSectionExists(void *a1, unsigned int a2, char *a3)
{
  uint64_t v3 = 6;
  if (a2 <= 1 && a1 && a3)
  {
    if (a2 == 1)
    {
      if (!a1[55] || !a1[56]) {
        goto LABEL_11;
      }
    }
    else if (!a1[33] || !a1[34])
    {
LABEL_11:
      char v4 = 0;
      goto LABEL_12;
    }
    char v4 = 1;
LABEL_12:
    uint64_t v3 = 0;
    *a3 = v4;
  }
  return v3;
}

uint64_t Img4DecodeRestoreInfoExists(void *a1, char *a2)
{
  return Img4DecodeSectionExists(a1, 1u, a2);
}

uint64_t Img4DecodeGetRestoreInfoBoolean(uint64_t a1, uint64_t a2, BOOL *a3)
{
  return Img4DecodeGetBooleanFromSection(a1, 1u, a2, a3);
}

uint64_t Img4DecodeGetBooleanFromSection(uint64_t a1, unsigned int a2, uint64_t a3, BOOL *a4)
{
  memset(v8, 0, sizeof(v8));
  uint64_t v4 = 6;
  if (a1)
  {
    if (a4)
    {
      Img4DecodeGetPropertyFromSection(a1, a2, a3 | 0xE000000000000000, 1uLL, v8);
      uint64_t v4 = v6;
      if (!v6) {
        return DERParseBoolean((unsigned __int8 **)&v8[1] + 1, a4);
      }
    }
  }
  return v4;
}

void Img4DecodeGetRestoreInfoInteger(uint64_t a1, uint64_t a2, _DWORD *a3)
{
}

void Img4DecodeGetIntegerFromSection(uint64_t a1, unsigned int a2, uint64_t a3, _DWORD *a4)
{
  memset(v6, 0, sizeof(v6));
  if (a1)
  {
    if (a4)
    {
      Img4DecodeGetPropertyFromSection(a1, a2, a3 | 0xE000000000000000, 2uLL, v6);
      if (!v5)
      {
        if (DERParseInteger((char **)&v6[1] + 1, a4)) {
          *a4 = 0;
        }
      }
    }
  }
}

void Img4DecodeGetRestoreInfoInteger64(uint64_t a1, uint64_t a2, unint64_t *a3)
{
}

void Img4DecodeGetInteger64FromSection(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t *a4)
{
  memset(v6, 0, sizeof(v6));
  if (a1)
  {
    if (a4)
    {
      Img4DecodeGetPropertyFromSection(a1, a2, a3 | 0xE000000000000000, 2uLL, v6);
      if (!v5)
      {
        if (DERParseInteger64((char **)&v6[1] + 1, a4)) {
          *a4 = 0;
        }
      }
    }
  }
}

void Img4DecodeGetRestoreInfoData(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
}

void Img4DecodeGetDataFromSection(uint64_t a1, unsigned int a2, uint64_t a3, void *a4, void *a5)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  if (a1 && a4 && a5)
  {
    Img4DecodeGetPropertyFromSection(a1, a2, a3 | 0xE000000000000000, 4uLL, &v9);
    if (v7)
    {
      *a5 = 0;
      *a4 = 0;
    }
    else
    {
      uint64_t v8 = v11;
      *a4 = *((void *)&v10 + 1);
      *a5 = v8;
    }
  }
}

uint64_t Img4DecodePayloadPropertiesExists(uint64_t a1, BOOL *a2)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 6;
  }
  long long v10 = 0u;
  long long v11 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t result = 6;
  memset(v7, 0, sizeof(v7));
  if (a2)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v5 = a1 + 8;
    if (v6)
    {
      uint64_t result = DERImg4DecodePayloadWithProperties(v5, (unint64_t)v7);
      if (!result) {
        *a2 = (void)v8 != 0;
      }
    }
  }
  return result;
}

void Img4DecodePayloadProperty(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (a1)
  {
    if (a4)
    {
      if (*(void *)(a1 + 8))
      {
        long long v10 = 0uLL;
        long long v9 = 0uLL;
        memset(v11, 0, sizeof(v11));
        memset(v12, 0, sizeof(v12));
        if (!DERImg4DecodePayloadWithProperties(a1 + 8, (unint64_t)v11))
        {
          if (*(void *)&v12[0])
          {
            DERImg4DecodeContentFindItemWithTag((unint64_t *)v12, 0x2000000000000010, &v10);
            if (!v7)
            {
              DERImg4DecodeContentFindItemWithTag((unint64_t *)&v10, 0x2000000000000011, &v9);
              if (!v8) {
                DERImg4DecodeFindProperty((unint64_t *)&v9, a2, a3, a4);
              }
            }
          }
        }
      }
    }
  }
}

void Img4DecodePayloadPropertyExistsByTag(uint64_t a1, uint64_t a2, BOOL *a3)
{
  uint64_t v21 = *MEMORY[0x263EF8340];
  if (a1)
  {
    long long v19 = 0u;
    long long v20 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    long long v13 = 0u;
    long long v14 = 0u;
    long long v11 = 0u;
    long long v12 = 0u;
    long long v10 = 0uLL;
    long long v9 = 0uLL;
    long long v8 = 0uLL;
    if (a3)
    {
      if (*(void *)(a1 + 8))
      {
        long long v19 = 0uLL;
        long long v20 = 0uLL;
        long long v17 = 0uLL;
        long long v18 = 0uLL;
        long long v15 = 0uLL;
        long long v16 = 0uLL;
        long long v13 = 0uLL;
        long long v14 = 0uLL;
        long long v11 = 0uLL;
        long long v12 = 0uLL;
        if (!DERImg4DecodePayloadWithProperties(a1 + 8, (unint64_t)&v11))
        {
          if ((void)v17)
          {
            DERImg4DecodeContentFindItemWithTag((unint64_t *)&v17, 0x2000000000000010, &v10);
            if (!v5)
            {
              DERImg4DecodeContentFindItemWithTag((unint64_t *)&v10, 0x2000000000000011, &v9);
              if (!v6)
              {
                DERImg4DecodeContentFindItemWithTag((unint64_t *)&v9, a2, &v8);
                if (!v7) {
                  *a3 = (void)v8 != 0;
                }
              }
            }
          }
        }
      }
    }
  }
}

uint64_t Img4DecodeGetPayloadProperties(uint64_t a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 6;
  }
  long long v11 = 0u;
  long long v12 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t result = 6;
  memset(v8, 0, sizeof(v8));
  if (a2)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    uint64_t v5 = a1 + 8;
    if (v6)
    {
      uint64_t result = DERImg4DecodePayloadWithProperties(v5, (unint64_t)v8);
      if (!result)
      {
        if ((void)v9)
        {
          uint64_t result = 0;
          uint64_t v7 = *((void *)&v9 + 1);
          *a2 = v9;
          a2[1] = v7;
          return result;
        }
        return 6;
      }
    }
  }
  return result;
}

uint64_t Img4DecodeCopyPayloadPropertiesDigest(void *a1, void *a2, size_t a3, uint64_t (**a4)(void, void, _OWORD *, size_t, void))
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  uint64_t result = 6;
  if (a1 && a2 && a3)
  {
    if (a3 > 0x30)
    {
      return 7;
    }
    else if (a4)
    {
      long long v8 = *a4;
      if (*a4)
      {
        memset(v9, 0, sizeof(v9));
        uint64_t result = v8(*a1, a1[1], v9, a3, a4);
        if (!result)
        {
          memcpy(a2, v9, a3);
          return 0;
        }
      }
    }
  }
  return result;
}

void Img4DecodePayloadPropertiesFindItemWithTag(unint64_t *a1, unsigned int a2, void *a3)
{
  if (a1)
  {
    v23[0] = 0;
    v23[1] = 0;
    v22[0] = 0;
    v22[1] = 0;
    v21[0] = 0;
    v21[1] = 0;
    unint64_t v20 = 0;
    v19[0] = 0;
    v19[1] = 0;
    unint64_t v18 = 0;
    memset(v17, 0, sizeof(v17));
    uint64_t v15 = 0;
    uint64_t v16 = 0;
    unint64_t v14 = 0;
    long long v13 = 0uLL;
    long long v12 = 0uLL;
    long long v11 = 0uLL;
    if (a3)
    {
      if (*a1)
      {
        DERImg4DecodeContentFindItemWithTag(a1, 0x2000000000000010, &v11);
        if (!v5)
        {
          if ((void)v11)
          {
            DERImg4DecodeContentFindItemWithTag((unint64_t *)&v11, 22, &v13);
            if (!v6 && !DERImg4DecodeTagCompare((uint64_t)&v13, 0x50415950u))
            {
              DERImg4DecodeContentFindItemWithTag((unint64_t *)&v11, 0x2000000000000011, &v12);
              if (!v7 && !DERDecodeSeqContentInit((unint64_t *)&v12, v23))
              {
                while (1)
                {
                  do
                  {
                    while (1)
                    {
                      int v8 = DERDecodeSeqNext(v23, &v20);
                      if (!v8) {
                        break;
                      }
                      if (v8 == 1) {
                        return;
                      }
                    }
                  }
                  while (DERDecodeItem((uint64_t)v21, &v18));
                  DERImg4DecodeContentFindItemWithTag(v19, 22, &v13);
                  if (v9) {
                    break;
                  }
                  if (!DERImg4DecodeTagCompare((uint64_t)&v13, a2)
                    && !DERDecodeSeqContentInit(v19, v22)
                    && !DERDecodeSeqNext(v22, v17)
                    && v17[0] == 22
                    && !DERDecodeSeqNext(v22, &v14))
                  {
                    if (v15)
                    {
                      uint64_t v10 = v16;
                      *a3 = v15;
                      a3[1] = v10;
                    }
                    return;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void Img4DecodeGetPayloadPropertiesBoolean(uint64_t a1, uint64_t a2, BOOL *a3)
{
  memset(v5, 0, sizeof(v5));
  Img4DecodePayloadProperty(a1, a2, 1uLL, (unint64_t)v5);
  if (!v4) {
    DERParseBoolean((unsigned __int8 **)&v5[1] + 1, a3);
  }
}

void Img4DecodeGetPayloadPropertiesInteger(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  memset(v5, 0, sizeof(v5));
  Img4DecodePayloadProperty(a1, a2, 2uLL, (unint64_t)v5);
  if (!v4) {
    DERParseInteger((char **)&v5[1] + 1, a3);
  }
}

void Img4DecodeGetPayloadPropertiesInteger64(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  memset(v5, 0, sizeof(v5));
  Img4DecodePayloadProperty(a1, a2, 2uLL, (unint64_t)v5);
  if (!v4) {
    DERParseInteger64((char **)&v5[1] + 1, a3);
  }
}

void Img4DecodeGetPayloadPropertiesData(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  long long v9 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  Img4DecodePayloadProperty(a1, a2, 4uLL, (unint64_t)&v8);
  if (!v6)
  {
    uint64_t v7 = v10;
    *a3 = *((void *)&v9 + 1);
    *a4 = v7;
  }
}

double Img4DecodeGetObjectProperty(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _OWORD *a5)
{
  v14[0] = 0;
  v14[1] = 0;
  double result = 0.0;
  memset(v13, 0, sizeof(v13));
  if (a1)
  {
    if (a5)
    {
      DERImg4DecodeParseManifestProperties(a1, (unint64_t)v14, 0);
      if (v10
        || (DERImg4DecodeFindProperty(v14, a2 | 0xE000000000000000, 0x2000000000000011uLL, (unint64_t)v13), v11)
        || (DERImg4DecodeFindProperty((unint64_t *)&v13[1] + 1, a3, a4, (unint64_t)a5), v12))
      {
        double result = 0.0;
        a5[1] = 0u;
        a5[2] = 0u;
        *a5 = 0u;
      }
    }
  }
  return result;
}

uint64_t Img4DecodeGetObjectPropertyBoolean(uint64_t a1, uint64_t a2, uint64_t a3, BOOL *a4)
{
  memset(v8, 0, sizeof(v8));
  uint64_t v4 = 6;
  if (a1 && a4)
  {
    Img4DecodeGetObjectProperty(a1, a2, a3 | 0xE000000000000000, 1uLL, v8);
    if (!v6) {
      return DERParseBoolean((unsigned __int8 **)&v8[1] + 1, a4);
    }
    return v6;
  }
  return v4;
}

void Img4DecodeGetObjectPropertyInteger(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  memset(v6, 0, sizeof(v6));
  if (a1)
  {
    if (a4)
    {
      Img4DecodeGetObjectProperty(a1, a2, a3 | 0xE000000000000000, 2uLL, v6);
      if (v5 || DERParseInteger((char **)&v6[1] + 1, a4)) {
        *a4 = 0;
      }
    }
  }
}

void Img4DecodeGetObjectPropertyInteger64(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  memset(v6, 0, sizeof(v6));
  if (a1)
  {
    if (a4)
    {
      Img4DecodeGetObjectProperty(a1, a2, a3 | 0xE000000000000000, 2uLL, v6);
      if (v5 || DERParseInteger64((char **)&v6[1] + 1, a4)) {
        *a4 = 0;
      }
    }
  }
}

void Img4DecodeGetObjectPropertyData(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  if (a1 && a4 && a5)
  {
    Img4DecodeGetObjectProperty(a1, a2, a3 | 0xE000000000000000, 4uLL, &v9);
    if (v7)
    {
      uint64_t v8 = 0;
      *a4 = 0;
    }
    else
    {
      uint64_t v8 = v11;
      *a4 = *((void *)&v10 + 1);
    }
    *a5 = v8;
  }
}

void Img4DecodeGetObjectPropertyString(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, void *a5)
{
  long long v10 = 0u;
  long long v11 = 0u;
  long long v9 = 0u;
  if (a1 && a4 && a5)
  {
    Img4DecodeGetObjectProperty(a1, a2, a3 | 0xE000000000000000, 0x16uLL, &v9);
    if (v7)
    {
      uint64_t v8 = 0;
      *a4 = 0;
    }
    else
    {
      uint64_t v8 = v11;
      *a4 = *((void *)&v10 + 1);
    }
    *a5 = v8;
  }
}

void Img4DecodeGetPayloadVersionPropertyString(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a3 && a4)
  {
    uint64_t v14 = 0;
    v15[0] = 0;
    v15[1] = 0;
    memset(v13, 0, sizeof(v13));
    long long v12 = 0uLL;
    long long v9 = 0u;
    long long v10 = 0u;
    long long v11 = 0u;
    if (DERDecodeItem(a1, (unint64_t *)&v14)
      || DERImg4DecodeProperty(v15, v14, (uint64_t)v13)
      || (DERImg4DecodeContentFindItemWithTag((unint64_t *)&v13[1] + 1, a2, &v12), v7)
      || DERImg4DecodeProperty(&v12, a2, (uint64_t)&v9))
    {
      uint64_t v8 = 0;
      *a3 = 0;
    }
    else
    {
      uint64_t v8 = v11;
      *a3 = *((void *)&v10 + 1);
    }
    *a4 = v8;
  }
}

double Img4DecodeGetPropertyFromSection(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, _OWORD *a5)
{
  *(_OWORD *)long long v13 = 0uLL;
  if (a2 <= 1 && a1 && a5)
  {
    char v14 = 0;
    if (!Img4DecodeSectionExists((void *)a1, a2, &v14) && v14)
    {
      if (a2)
      {
        *(_OWORD *)long long v13 = *(_OWORD *)(a1 + 440);
        goto LABEL_9;
      }
      DERImg4DecodeParseManifestProperties(a1, 0, (unint64_t)v13);
      if (!v10)
      {
LABEL_9:
        DERImg4DecodeFindProperty(v13, a3, a4, (unint64_t)a5);
        if (!v12) {
          return result;
        }
      }
    }
    double result = 0.0;
    a5[1] = 0u;
    a5[2] = 0u;
    *a5 = 0u;
  }
  return result;
}

uint64_t Img4DecodeGetPropertyInteger(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  long long v8 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  v6[0] = *(void *)a1;
  v6[1] = v4;
  uint64_t result = DERImg4DecodeProperty(v6, a2 | 0xE000000000000000, (uint64_t)&v7);
  if (!result)
  {
    if (*((void *)&v9 + 1) != 2)
    {
      uint64_t result = 2;
      if (!a3) {
        return result;
      }
      goto LABEL_6;
    }
    if (!a3) {
      return 6;
    }
    uint64_t result = DERParseInteger((char **)&v8 + 1, a3);
  }
  if (!a3) {
    return result;
  }
LABEL_6:
  if (result) {
    *a3 = 0;
  }
  return result;
}

uint64_t Img4DecodeGetPropertyInteger64(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  long long v8 = 0u;
  long long v9 = 0u;
  long long v7 = 0u;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  v6[0] = *(void *)a1;
  v6[1] = v4;
  uint64_t result = DERImg4DecodeProperty(v6, a2 | 0xE000000000000000, (uint64_t)&v7);
  if (!result)
  {
    if (*((void *)&v9 + 1) != 2)
    {
      uint64_t result = 2;
      if (!a3) {
        return result;
      }
      goto LABEL_6;
    }
    if (!a3) {
      return 6;
    }
    uint64_t result = DERParseInteger64((char **)&v8 + 1, a3);
  }
  if (!a3) {
    return result;
  }
LABEL_6:
  if (result) {
    *a3 = 0;
  }
  return result;
}

uint64_t Img4DecodeGetPropertyBoolean(uint64_t a1, uint64_t a2, BOOL *a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  v6[0] = *(void *)a1;
  v6[1] = v4;
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  uint64_t result = DERImg4DecodeProperty(v6, a2 | 0xE000000000000000, (uint64_t)&v7);
  if (!result)
  {
    if (*((void *)&v9 + 1) == 1)
    {
      if (a3) {
        return DERParseBoolean((unsigned __int8 **)&v8 + 1, a3);
      }
      else {
        return 6;
      }
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t Img4DecodeGetPropertyData(uint64_t *a1, uint64_t a2, void *a3, _DWORD *a4)
{
  long long v13 = 0u;
  long long v14 = 0u;
  long long v12 = 0u;
  uint64_t result = 6;
  if (a3 && a4)
  {
    uint64_t v8 = *a1;
    uint64_t v9 = *((unsigned int *)a1 + 2);
    v11[0] = v8;
    v11[1] = v9;
    uint64_t result = DERImg4DecodeProperty(v11, a2 | 0xE000000000000000, (uint64_t)&v12);
    if (!result)
    {
      if (*((void *)&v14 + 1) == 4)
      {
        uint64_t result = 0;
        *a3 = *((void *)&v13 + 1);
        int v10 = v14;
LABEL_6:
        *a4 = v10;
        return result;
      }
      uint64_t result = 2;
    }
    int v10 = 0;
    *a3 = 0;
    goto LABEL_6;
  }
  return result;
}

void Img4DecodeEvaluateCertificateProperties(void *a1)
{
}

void Img4DecodeEvaluateCertificatePropertiesInternal(void *a1, _OWORD *a2)
{
  v21[0] = 0;
  v21[1] = 0;
  v20[0] = 0;
  v20[1] = 0;
  uint64_t v19 = 0;
  long long v18 = 0uLL;
  size_t __n = 0;
  uint64_t v17 = 0;
  uint64_t v14 = 0;
  __s1 = 0;
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  memset(v9, 0, sizeof(v9));
  long long __s2 = 0uLL;
  long long v7 = 0uLL;
  if (a1 && a1[40] && !DERDecodeSeqInit((uint64_t)(a1 + 39), &v19, v21) && v19 == 0x2000000000000011)
  {
    while (1)
    {
      if (DERDecodeSeqNext(v21, (unint64_t *)&v17)) {
        return;
      }
      uint64_t v4 = (long long *)(a1 + 7);
      switch(v17)
      {
        case 0xE00000004D414E50:
LABEL_11:
          long long v7 = *v4;
          if (DERImg4DecodeProperty(&v18, v17, (uint64_t)&v11)
            || *((void *)&v13 + 1) != 0x2000000000000011
            || DERDecodeSeqContentInit((unint64_t *)&v12 + 1, v20))
          {
            return;
          }
          while (1)
          {
            int v5 = DERDecodeSeqNext(v20, (unint64_t *)&v14);
            if (v5) {
              break;
            }
            if (DERImg4DecodeProperty(&__s1, v14, (uint64_t)v9)) {
              return;
            }
            DERImg4DecodeContentFindItemWithTag((unint64_t *)&v7, v14, &__s2);
            if (*((void *)&v10 + 1) <= 4uLL && ((1 << SBYTE8(v10)) & 0x16) != 0)
            {
              if (v6) {
                return;
              }
              if (__n != *((void *)&__s2 + 1)) {
                return;
              }
              int v6 = memcmp(__s1, (const void *)__s2, __n);
              if (v6) {
                return;
              }
            }
            else if (*((void *)&v10 + 1) != 0xA000000000000000)
            {
              if (*((void *)&v10 + 1) != 0xA000000000000001 || v6 != 1) {
                return;
              }
              int v6 = 0;
            }
            if (v6) {
              return;
            }
          }
          if (v5 != 1) {
            return;
          }
          break;
        case 0xE00000006D616E78:
          if (a2) {
            *a2 = v18;
          }
          break;
        case 0xE00000004F424A50:
          uint64_t v4 = (long long *)(a1 + 9);
          if (a1[9]) {
            goto LABEL_11;
          }
          uint64_t v4 = (long long *)(a1 + 9);
          if (a1[10]) {
            goto LABEL_11;
          }
          break;
        default:
          return;
      }
    }
  }
}

void Img4DecodeCopyManifestTrustedBootPolicyMeasurement(void *a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  uint64_t v18 = *MEMORY[0x263EF8340];
  if (a4)
  {
    if (a5)
    {
      if (a5 <= 0x30)
      {
        memset(v17, 0, sizeof(v17));
        memset(v16, 0, sizeof(v16));
        v10[0] = Img4DecodeDigestInit;
        v10[1] = Img4DecodeDigestUpdate;
        _OWORD v10[2] = Img4DecodeDigestReturnHash;
        *(void *)&long long v13 = &default_manifest_property_exclude;
        *((void *)&v13 + 1) = 156;
        uint64_t v14 = a3;
        uint64_t v15 = v10;
        Img4DecodeEvaluateCertificatePropertiesInternal(a1, &v13);
        if (!v9)
        {
          if (a1)
          {
            if (a2)
            {
              v11[0] = &v13;
              v11[1] = a2;
              void v11[2] = a1;
              long long v12 = v17;
              if (!((unsigned int (*)(void, unsigned char **))*v15)(*(void *)(v14 + 32), &v12)
                && !Img4DecodeEvaluateDictionaryProperties(a1 + 7, 0, (uint64_t (*)(unint64_t, uint64_t *, uint64_t, uint64_t))_Img4DecodeValidateManifestPropertyInterposer, (uint64_t)v11)&& !((unsigned int (*)(void, unsigned char **, uint64_t, unsigned char *))v15[2])(*(void *)(v14 + 32), &v12, 48, v16))
              {
                memcpy(a4, v16, a5);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t Img4DecodeEvaluateManifestProperties(uint64_t a1, uint64_t (*a2)(unint64_t, uint64_t *, uint64_t, uint64_t), uint64_t a3)
{
  return Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a1 + 56), 0, a2, a3);
}

uint64_t Img4DecodeEvaluateDictionaryProperties(unint64_t *a1, uint64_t a2, uint64_t (*a3)(unint64_t, uint64_t *, uint64_t, uint64_t), uint64_t a4)
{
  uint64_t v15 = 0;
  unint64_t v16 = 0;
  unint64_t v14 = 0;
  v13[0] = 0;
  v13[1] = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v10 = 0;
  memset(v8, 0, sizeof(v8));
  long long v9 = 0u;
  if (!a3) {
    return 6;
  }
  uint64_t result = (uint64_t)DERDecodeSeqContentInit(a1, v13);
  if (!result)
  {
    while (1)
    {
      uint64_t result = DERDecodeSeqNext(v13, &v14);
      if (result == 1) {
        return 0;
      }
      if (result) {
        return result;
      }
      uint64_t result = DERImg4DecodeProperty(&v15, v14, (uint64_t)v8);
      if (result) {
        return result;
      }
      uint64_t result = 2;
      if (*((void *)&v9 + 1) > 0x16uLL
        || ((1 << SBYTE8(v9)) & 0x400016) == 0
        || !(v14 >> 62)
        || (v14 & 0x2000000000000000) == 0)
      {
        return result;
      }
      if (HIDWORD(v16)) {
        break;
      }
      uint64_t v10 = v15;
      LODWORD(v11) = v16;
      uint64_t v12 = *((void *)&v9 + 1);
      uint64_t result = a3(v14, &v10, a2, a4);
      if (result) {
        return result;
      }
    }
    return 7;
  }
  return result;
}

uint64_t Img4DecodeEvaluateObjectProperties(uint64_t a1, uint64_t (*a2)(unint64_t, uint64_t *, uint64_t, uint64_t), uint64_t a3)
{
  return Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a1 + 72), 1, a2, a3);
}

double Img4DecodeInit(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    if (a3)
    {
      v9[0] = a1;
      v9[1] = a2;
      long long v7 = 0u;
      long long v8 = 0u;
      long long v5 = 0u;
      long long v6 = 0u;
      *(_OWORD *)a3 = 0u;
      *(_OWORD *)(a3 + 16) = 0u;
      *(_OWORD *)(a3 + 32) = 0u;
      *(_OWORD *)(a3 + 48) = 0u;
      *(_OWORD *)(a3 + 64) = 0u;
      *(_OWORD *)(a3 + 80) = 0u;
      *(_OWORD *)(a3 + 96) = 0u;
      *(_OWORD *)(a3 + 112) = 0u;
      *(_OWORD *)(a3 + 128) = 0u;
      *(_OWORD *)(a3 + 144) = 0u;
      *(_OWORD *)(a3 + 160) = 0u;
      *(_OWORD *)(a3 + 176) = 0u;
      *(_OWORD *)(a3 + 192) = 0u;
      *(_OWORD *)(a3 + 208) = 0u;
      *(_OWORD *)(a3 + 224) = 0u;
      *(_OWORD *)(a3 + 240) = 0u;
      *(_OWORD *)(a3 + 256) = 0u;
      *(_OWORD *)(a3 + 272) = 0u;
      *(_OWORD *)(a3 + 288) = 0u;
      *(_OWORD *)(a3 + 304) = 0u;
      *(_OWORD *)(a3 + 320) = 0u;
      *(_OWORD *)(a3 + 336) = 0u;
      *(_OWORD *)(a3 + 352) = 0u;
      *(_OWORD *)(a3 + 368) = 0u;
      *(_OWORD *)(a3 + 384) = 0u;
      *(_OWORD *)(a3 + 400) = 0u;
      *(_OWORD *)(a3 + 416) = 0u;
      *(_OWORD *)(a3 + 432) = 0u;
      *(void *)(a3 + 448) = 0;
      if (!DERImg4Decode(v9, (unint64_t)&v5)
        && !DERImg4DecodePayload((uint64_t)&v6, a3 + 88)
        && !DERImg4DecodeManifest(&v7, a3 + 232)
        && !DERImg4DecodeRestoreInfo((uint64_t)&v8, a3 + 424))
      {
        *(_OWORD *)(a3 + 8) = v6;
        double result = *(double *)&v7;
        *(_OWORD *)(a3 + 24) = v7;
      }
    }
  }
  return result;
}

double Img4DecodeInitPayload(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 && a3)
  {
    *(void *)&long long v5 = a1;
    *((void *)&v5 + 1) = a2;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 80) = 0u;
    *(_OWORD *)(a3 + 96) = 0u;
    *(_OWORD *)(a3 + 112) = 0u;
    *(_OWORD *)(a3 + 128) = 0u;
    *(_OWORD *)(a3 + 144) = 0u;
    *(_OWORD *)(a3 + 160) = 0u;
    *(_OWORD *)(a3 + 176) = 0u;
    *(_OWORD *)(a3 + 192) = 0u;
    *(_OWORD *)(a3 + 208) = 0u;
    *(_OWORD *)(a3 + 224) = 0u;
    *(_OWORD *)(a3 + 240) = 0u;
    *(_OWORD *)(a3 + 256) = 0u;
    *(_OWORD *)(a3 + 272) = 0u;
    *(_OWORD *)(a3 + 288) = 0u;
    *(_OWORD *)(a3 + 304) = 0u;
    *(_OWORD *)(a3 + 320) = 0u;
    *(_OWORD *)(a3 + 336) = 0u;
    *(_OWORD *)(a3 + 352) = 0u;
    *(_OWORD *)(a3 + 368) = 0u;
    *(_OWORD *)(a3 + 384) = 0u;
    *(_OWORD *)(a3 + 400) = 0u;
    *(_OWORD *)(a3 + 416) = 0u;
    *(_OWORD *)(a3 + 432) = 0u;
    *(void *)(a3 + 448) = 0;
    if (!DERImg4DecodePayload((uint64_t)&v5, a3 + 88))
    {
      double result = *(double *)&v5;
      *(_OWORD *)(a3 + 8) = v5;
    }
  }
  return result;
}

uint64_t Img4DecodeInitManifest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Img4DecodeInitManifestCommon(a1, a2, 1, a3, 1229796429);
}

uint64_t Img4DecodeInitManifestCommon(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5)
{
  uint64_t result = 6;
  if (a1 && a4)
  {
    uint64_t v15 = a1;
    uint64_t v16 = a2;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
    *(_OWORD *)(a4 + 80) = 0u;
    *(_OWORD *)(a4 + 96) = 0u;
    *(_OWORD *)(a4 + 112) = 0u;
    *(_OWORD *)(a4 + 128) = 0u;
    *(_OWORD *)(a4 + 144) = 0u;
    *(_OWORD *)(a4 + 160) = 0u;
    *(_OWORD *)(a4 + 176) = 0u;
    *(_OWORD *)(a4 + 192) = 0u;
    *(_OWORD *)(a4 + 208) = 0u;
    *(_OWORD *)(a4 + 224) = 0u;
    *(_OWORD *)(a4 + 240) = 0u;
    *(_OWORD *)(a4 + 256) = 0u;
    *(_OWORD *)(a4 + 272) = 0u;
    *(_OWORD *)(a4 + 288) = 0u;
    *(_OWORD *)(a4 + 304) = 0u;
    *(_OWORD *)(a4 + 320) = 0u;
    *(_OWORD *)(a4 + 336) = 0u;
    *(_OWORD *)(a4 + 352) = 0u;
    *(_OWORD *)(a4 + 368) = 0u;
    *(_OWORD *)(a4 + 384) = 0u;
    *(_OWORD *)(a4 + 400) = 0u;
    *(_OWORD *)(a4 + 416) = 0u;
    *(_OWORD *)(a4 + 432) = 0u;
    *(void *)(a4 + 448) = 0;
    if (a5 == 1229796419)
    {
      unint64_t v10 = a4 + 232;
      if (a3) {
        uint64_t result = DERImg4DecodeCertificate(&v15, v10);
      }
      else {
        uint64_t result = DERImg4DecodeUnsignedCertificate(&v15, v10);
      }
    }
    else
    {
      if (a5 != 1229796429) {
        return 2;
      }
      unint64_t v9 = a4 + 232;
      if (a3) {
        uint64_t result = DERImg4DecodeManifest(&v15, v9);
      }
      else {
        uint64_t result = DERImg4DecodeUnsignedManifest(&v15, v9);
      }
    }
    if (!result)
    {
      if (*(void *)(a4 + 264))
      {
        unint64_t v12 = 0;
        uint64_t v13 = 0;
        uint64_t v14 = 0;
        uint64_t v15 = a1;
        uint64_t v16 = a2;
        uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)&v15, &v12, 0);
        if (!result)
        {
          *(void *)(a4 + 24) = a1;
          uint64_t v11 = v14 + v13 - a1;
          if (__CFADD__(v14, v13 - a1))
          {
            __break(0x5500u);
          }
          else
          {
            *(void *)(a4 + 32) = v11;
            if (v11 == a2) {
              return 0;
            }
            else {
              return 7;
            }
          }
        }
      }
      else
      {
        return 3;
      }
    }
  }
  return result;
}

uint64_t Img4DecodeInitUnsignedManifest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Img4DecodeInitManifestCommon(a1, a2, 0, a3, 1229796429);
}

uint64_t Img4DecodeInitCertificate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Img4DecodeInitManifestCommon(a1, a2, 1, a3, 1229796419);
}

uint64_t Img4DecodeInitUnsignedCertificate(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return Img4DecodeInitManifestCommon(a1, a2, 0, a3, 1229796419);
}

uint64_t Img4DecodeEvaluateCertificateChain(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t result = 6;
  if (a1 && a2 && a3 && a4 && a7 && a6)
  {
    unint64_t v9 = *(void (**)(uint64_t))(a4 + 8);
    if (v9)
    {
      v9(a1);
      return 3;
    }
  }
  return result;
}

void Img4DecodeEvaluateTrustWithCallbacks(unsigned int a1, uint64_t a2, uint64_t (*a3)(unint64_t, uint64_t *, uint64_t, uint64_t), unsigned int (*a4)(void, void, void, void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), unsigned int (*a5)(uint64_t, uint64_t), void (*a6)(void, void, uint64_t), uint64_t a7)
{
  memset(v17, 0, sizeof(v17));
  if (a2)
  {
    if (a3)
    {
      if (*(void *)(a2 + 24))
      {
        BOOL v16 = 0;
        a6(*(void *)(a2 + 264), *(void *)(a2 + 272), a2 + 376);
        if (!a4(*(void *)(a2 + 296), *(unsigned int *)(a2 + 304), *(void *)(a2 + 280), *(unsigned int *)(a2 + 288), a2 + 376, 20, a2 + 312, a2 + 320, a7))
        {
          DERImg4DecodeParseManifestProperties(a2, a2 + 40, a2 + 56);
          if (!v14)
          {
            DERImg4DecodeFindProperty((unint64_t *)(a2 + 40), a1 | 0xE000000000000000, 0x2000000000000011uLL, (unint64_t)v17);
            if (!v15)
            {
              *(_OWORD *)(a2 + 72) = *(_OWORD *)((char *)&v17[1] + 8);
              if (!a5(a2, a7) && !Img4DecodePayloadExists(a2, &v16))
              {
                if (v16)
                {
                  a6(*(void *)(a2 + 8), *(void *)(a2 + 16), a2 + 184);
                  *(unsigned char *)a2 = 1;
                }
                if (!Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a2 + 56), 0, a3, a7)
                  && !Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a2 + 72), 1, a3, a7))
                {
                  a6(*(void *)(a2 + 24), *(void *)(a2 + 32), a2 + 328);
                  *(unsigned char *)(a2 + 1) = 1;
                }
              }
            }
          }
        }
      }
    }
  }
}

void Img4DecodePerformTrustEvaluation(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[1] = 0;
  v5[2] = 0;
  v5[0] = a3;
  _Img4DecodePerformTrustEvaluationWithCallbacksInternal(a1, a2, (uint64_t)v5, a4, 0, a5);
}

void Img4DecodePerformTrustEvaluatationWithCallbacks(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void Img4DecodePerformTrustEvaluatation(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v5[1] = 0;
  v5[2] = 0;
  v5[0] = a3;
  _Img4DecodePerformTrustEvaluationWithCallbacksInternal(a1, a2, (uint64_t)v5, a4, 0, a5);
}

uint64_t Img4DecodeVerifyChainIM4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6, void *a7, void *a8, uint64_t a9, uint64_t a10)
{
  uint64_t v42 = *MEMORY[0x263EF8340];
  uint64_t v41 = 0;
  long long v39 = 0u;
  memset(v40, 0, sizeof(v40));
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  uint64_t result = 6;
  long long v17 = 0u;
  long long v18 = 0u;
  if (a3 && a4 && a5 && a6 && a7 && a8 && a9)
  {
    if (Img4DecodeInitManifestCommon(a3, a4, 1, (uint64_t)&v17, 1229796419)
      || (*(unsigned int (**)(void, void, char *, void, uint64_t))a9)(*((void *)&v33 + 1), v34, (char *)v40 + 8, **(void **)(a9 + 32), a9)|| (*(unsigned int (**)(uint64_t, uint64_t, void, void, char *, void, uint64_t, uint64_t, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void, void))(a9 + 16))(a1, a2, *((void *)&v34 + 1), v35, (char *)v40 + 8, **(void **)(a9 + 32), a9, a10, v17, *((void *)&v17 + 1), v18, *((void *)&v18 + 1), v19,
           *((void *)&v19 + 1),
           v20,
           *((void *)&v20 + 1),
           v21,
           *((void *)&v21 + 1),
           v22,
           *((void *)&v22 + 1),
           v23,
           *((void *)&v23 + 1),
           v24,
           *((void *)&v24 + 1),
           v25,
           *((void *)&v25 + 1),
           v26,
           *((void *)&v26 + 1),
           v27,
           *((void *)&v27 + 1),
           v28,
           *((void *)&v28 + 1),
           v29,
           *((void *)&v29 + 1),
           v30,
           *((void *)&v30 + 1),
           v31,
           *((void *)&v31 + 1),
           v32,
           *((void *)&v32 + 1),
           v33))
    {
      return 0xFFFFFFFFLL;
    }
    else if (DERImg4DecodeCertificatePropertiesAndPubKey(*((uint64_t *)&v33 + 1), v34, a7, a8, a5, a6))
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void Img4DecodePerformTrustEvaluationWithCallbacks(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
}

void _Img4DecodePerformTrustEvaluationWithCallbacksInternal(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  memset(v24, 0, sizeof(v24));
  if (a2)
  {
    if (a3)
    {
      BOOL v21 = 0;
      if (a4)
      {
        if (*(void *)a3)
        {
          if (*(void *)a4)
          {
            if (*(void *)(a4 + 24))
            {
              if (*(void *)(a4 + 8))
              {
                if (*(void *)(a4 + 16))
                {
                  unint64_t v9 = *(void **)(a4 + 32);
                  if (v9)
                  {
                    if (*(void *)(a2 + 24) && *v9 <= 0x30uLL && !(*(unsigned int (**)(void))a4)())
                    {
                      *(unsigned char *)(a2 + 1) = 1;
                      uint64_t v13 = *(uint64_t (**)(uint64_t, uint64_t))(a3 + 8);
                      if (v13
                        && (int v14 = (const void *)v13(a2, a6)) != 0
                        && !memcmp((const void *)(a2 + 328), v14, **(void **)(a4 + 32)))
                      {
                        int v15 = 0;
                      }
                      else
                      {
                        if ((*(unsigned int (**)(void, void, uint64_t *, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t))(a4 + 8))(*(void *)(a2 + 296), *(void *)(a2 + 304), &v22, &v23, a2 + 312, a2 + 320, a4, a6)|| **(void **)(a4 + 32) > 0x30uLL|| (*(unsigned int (**)(void, void, uint64_t))a4)(*(void *)(a2 + 264), *(void *)(a2 + 272), a2 + 376)|| (*(unsigned int (**)(uint64_t, uint64_t, void, void, uint64_t, void, uint64_t, uint64_t))(a4 + 16))(v22, v23, *(void *)(a2 + 280), *(void *)(a2 + 288), a2 + 376,
                               **(void **)(a4 + 32),
                               a4,
                               a6))
                        {
                          return;
                        }
                        int v15 = 1;
                      }
                      DERImg4DecodeParseManifestProperties(a2, a2 + 40, a2 + 56);
                      if (v16) {
                        return;
                      }
                      if ((a5 & 1) == 0)
                      {
                        long long v17 = *(unsigned int (**)(unint64_t *, unint64_t, uint64_t, _OWORD *, uint64_t))(a3 + 16);
                        unint64_t v18 = a1 | 0xE000000000000000;
                        long long v19 = (unint64_t *)(a2 + 40);
                        if (v17)
                        {
                          if (v17(v19, v18, 0x2000000000000011, v24, a6)) {
                            return;
                          }
                        }
                        else
                        {
                          DERImg4DecodeFindProperty(v19, v18, 0x2000000000000011uLL, (unint64_t)v24);
                          if (v20) {
                            return;
                          }
                        }
                        *(_OWORD *)(a2 + 72) = *(_OWORD *)((char *)&v24[1] + 8);
                      }
                      if ((!v15 || !(*(unsigned int (**)(uint64_t, uint64_t))(a4 + 24))(a2, a6))
                        && **(void **)(a4 + 32) <= 0x30uLL
                        && !Img4DecodePayloadExists(a2, &v21))
                      {
                        if (v21)
                        {
                          if ((*(unsigned int (**)(void, void, uint64_t, void, uint64_t))a4)(*(void *)(a2 + 8), *(void *)(a2 + 16), a2 + 184, **(void **)(a4 + 32), a4))
                          {
                            return;
                          }
                          *(unsigned char *)a2 = 1;
                        }
                        if (!Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a2 + 56), 0, *(uint64_t (**)(unint64_t, uint64_t *, uint64_t, uint64_t))a3, a6)&& (a5 & 1) == 0)
                        {
                          Img4DecodeEvaluateDictionaryProperties((unint64_t *)(a2 + 72), 1, *(uint64_t (**)(unint64_t, uint64_t *, uint64_t, uint64_t))a3, a6);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void Img4DecodePerformManifestTrustEvaluationWithCallbacks(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
}

uint64_t _Img4DecodeValidateManifestPropertyInterposer(unsigned int a1, uint64_t a2, int a3, uint64_t a4)
{
  unsigned int v10 = a1;
  if (a3) {
    return 0xFFFFFFFFLL;
  }
  long long v8 = *(void **)a4;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v13 = 0u;
  v12[0] = 0;
  v12[1] = 0;
  memset(v11, 0, sizeof(v11));
  if (v8
    && !DERImg4DecodeProperty(v8, 0xE00000006D616E78, (uint64_t)&v13)
    && *((void *)&v15 + 1) == 0x2000000000000011
    && !DERDecodeSeqContentInit((unint64_t *)&v14 + 1, v12))
  {
    unint64_t v9 = a1 | 0xE000000000000000;
    while (!DERDecodeSeqNext(v12, v11))
    {
      if (v11[0] == v9)
      {
        (*(void (**)(void, uint64_t, uint64_t, unsigned int *))(*(void *)(*(void *)a4 + 24) + 8))(*(void *)(*(void *)(*(void *)a4 + 16) + 32), a4 + 24, 4, &v10);
        return 0;
      }
    }
  }
  (*(void (**)(void, uint64_t, void, void))(*(void *)(*(void *)a4 + 24) + 8))(*(void *)(*(void *)(*(void *)a4 + 16) + 32), a4 + 24, *(unsigned int *)(a2 + 8), *(void *)a2);
  return 0;
}

uint64_t sha1_digest()
{
  return ccdigest();
}

uint64_t verify_signature_rsa3k(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v13[0] = a1;
  v13[1] = a2;
  v12[0] = a3;
  v12[1] = a4;
  v11[0] = a5;
  v11[1] = a6;
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  if (!a4) {
    return 0xFFFFFFFFLL;
  }
  if (!a5) {
    return 0xFFFFFFFFLL;
  }
  if (!a6) {
    return 0xFFFFFFFFLL;
  }
  if (!a7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *(void *)(a7 + 32);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  long long v8 = *(void ***)(v7 + 16);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v9 = *v8;
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  if (*v9 != a6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = verify_pkcs1_sig((uint64_t)v13, v9[4], (uint64_t)v11, (uint64_t)v12, 3072);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t verify_pkcs1_sig(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  _OWORD v18[4] = *MEMORY[0x263EF8340];
  if (a5 != 4096 && a5 != 3072) {
    return 0xFFFFFFFFLL;
  }
  v18[2] = 0;
  v18[3] = 0;
  unint64_t v6 = (unint64_t)(a5 + 63) >> 6;
  MEMORY[0x270FA5388](a1, (24 * v6 + 71) & 0x7FFFFFFFFFFFFFE0);
  long long v8 = (unint64_t *)((char *)v17 - v7);
  bzero((char *)v17 - v7, v7);
  unint64_t *v8 = v6;
  uint64_t v9 = *(unsigned int *)(a1 + 8);
  v18[0] = *(void *)a1;
  v18[1] = v9;
  memset(v17, 0, sizeof(v17));
  uint64_t result = DERParseSequenceToObject((uint64_t)v18, (unsigned __int16)DERNumRSAPubKeyPKCS1ItemSpecs, (uint64_t)&DERRSAPubKeyPKCS1ItemSpecs, (unint64_t)v17, 0x20uLL, 0x20uLL);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v11 = *((void *)&v17[0] + 1);
  for (size_t i = *(unsigned char **)&v17[0]; v11; --v11)
  {
    if (*i) {
      break;
    }
    if (i == (unsigned char *)-1) {
      __break(0x5513u);
    }
    ++i;
  }
  if (v11 >= 0xFFFFFFFFFFFFFFF8)
  {
    __break(0x5500u);
    return result;
  }
  unint64_t v13 = (v11 + 7) >> 3;
  if (v13 > *v8) {
    return 0xFFFFFFFFLL;
  }
  unint64_t *v8 = v13;
  if (ccrsa_make_pub()) {
    return 0xFFFFFFFFLL;
  }
  if (MEMORY[0x263EF87F8]) {
    BOOL v14 = MEMORY[0x263EF8010] == 0;
  }
  else {
    BOOL v14 = 1;
  }
  if (!v14)
  {
    int v16 = ccrsa_verify_pkcs1v15_digest();
    if (!v16 && !cc_cmp_safe()) {
      return 0;
    }
    return 0xFFFFFFFFLL;
  }
  LOBYTE(v17[0]) = 0;
  int v15 = ccrsa_verify_pkcs1v15();
  uint64_t result = 0xFFFFFFFFLL;
  if (!v15 && LOBYTE(v17[0])) {
    return 0;
  }
  return result;
}

uint64_t verify_signature_rsa(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v13[0] = a1;
  v13[1] = a2;
  v12[0] = a3;
  v12[1] = a4;
  v11[0] = a5;
  v11[1] = a6;
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  if (!a4) {
    return 0xFFFFFFFFLL;
  }
  if (!a5) {
    return 0xFFFFFFFFLL;
  }
  if (!a6) {
    return 0xFFFFFFFFLL;
  }
  if (!a7) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v7 = *(void *)(a7 + 32);
  if (!v7) {
    return 0xFFFFFFFFLL;
  }
  long long v8 = *(void ***)(v7 + 16);
  if (!v8) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v9 = *v8;
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  if (*v9 != a6) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = verify_pkcs1_sig((uint64_t)v13, v9[4], (uint64_t)v11, (uint64_t)v12, 4096);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

void verify_signature_ecdsa(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        if (a4)
        {
          if (a5)
          {
            if (a6)
            {
              if (a7)
              {
                uint64_t v7 = *(void **)(a7 + 32);
                if (v7)
                {
                  if (v7[2] && *(void *)(a7 + 48) && *v7 == a6)
                  {
                    v8[0] = a1;
                    v8[1] = a2;
                    verify_ecdsa_sig(v8);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

void verify_ecdsa_sig(void *a1)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  v12[7] = 0;
  ccec_x963_import_pub_size();
  if (ccec_keysize_is_supported())
  {
    cp = (void *)ccec_get_cp();
    uint64_t v3 = *cp;
    if (*cp >> 61 || !is_mul_ok(8 * v3, 3uLL))
    {
      __break(0x550Cu);
    }
    else
    {
      uint64_t v4 = 24 * v3;
      BOOL v5 = __CFADD__(v4, 16);
      uint64_t v6 = v4 + 16;
      if (!v5)
      {
        BOOL v5 = __CFADD__(v6, 16);
        uint64_t v7 = v6 + 16;
        if (!v5)
        {
          long long v8 = cp;
          unint64_t v9 = v7 - 1;
          MEMORY[0x270FA5388](cp, (v7 - 1) & 0xFFFFFFFFFFFFFFF0);
          unint64_t v11 = &v12[-v10];
          bzero(&v12[-v10], v10);
          if (v9 < 0x10)
          {
            __break(1u);
          }
          else
          {
            *unint64_t v11 = v8;
            if (!MEMORY[0x24C53D920](v8, a1[1], *a1, v11)) {
              ccec_verify();
            }
          }
          return;
        }
      }
    }
    __break(0x5500u);
  }
}

uint64_t verify_chain_img4_v1(unint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    unsigned int v9 = a2;
    if (a2)
    {
      if (a3 && a4)
      {
        bzero(&v28, 0x2F0uLL);
        v26[0] = a1;
        v26[1] = v9;
        v27[0] = &ROOT_CA_CERTIFICATE;
        v27[1] = 1215;
        if (!_crack_chain_with_anchor(v26, (uint64_t)v27, 3u)
          && !parse_chain((uint64_t)v27, 3u, (uint64_t)&v29, (uint64_t)v31, (uint64_t)v34, (uint64_t)v37))
        {
          long long v24 = a6;
          uint64_t v15 = 0;
          int v16 = (const void **)v32;
          long long v17 = &v30;
          unint64_t v18 = (const void **)v32;
          while (1)
          {
            long long v19 = &v26[20 * v15];
            size_t v20 = v19[37];
            BOOL v21 = *v18;
            v18 += 20;
            if ((const void *)v20 != v21) {
              break;
            }
            if (memcmp((const void *)v19[36], *(v16 - 1), v20)) {
              break;
            }
            uint64_t result = verify_chain_signatures(&v34[v15], v17, a7);
            if (result) {
              break;
            }
            v17 += 6;
            ++v15;
            int v16 = v18;
            if (v15 == 2)
            {
              long long v25 = 0uLL;
              if ((unint64_t)v31 > 0xFFFFFFFFFFFFFF5FLL)
              {
LABEL_34:
                __break(0x5513u);
                return result;
              }
              v42[0] = 0;
              v42[1] = 0;
              unint64_t v40 = 0;
              v41[0] = 0;
              v41[1] = 0;
              if (DERDecodeSeqContentInit(v33, v42)) {
                return 0xFFFFFFFFLL;
              }
LABEL_14:
              if (!DERDecodeSeqNext(v42, &v40) && v40 == 0x2000000000000011)
              {
                v47[0] = 0;
                v47[1] = 0;
                unint64_t v45 = 0;
                v46[0] = 0;
                v46[1] = 0;
                long long v43 = 0u;
                long long v44 = 0u;
                if (!DERDecodeSeqContentInit(v41, v47))
                {
                  do
                  {
                    int v22 = DERDecodeSeqNext(v47, &v45);
                    if (v22)
                    {
                      if (v22 == 1) {
                        goto LABEL_14;
                      }
                      return 0xFFFFFFFFLL;
                    }
                    if (v45 != 0x2000000000000010
                      || DERParseSequenceContentToObject(v46, (unsigned __int16)DERNumAttributeTypeAndValueItemSpecs, (uint64_t)&DERAttributeTypeAndValueItemSpecs, (unint64_t)&v43, 0x20uLL, 0x20uLL))
                    {
                      return 0xFFFFFFFFLL;
                    }
                  }
                  while (!DEROidCompare((uint64_t)&oidCommonName, (uint64_t)&v43));
                  long long v25 = v44;
                  uint64_t result = DEROidCompare((uint64_t)&verify_chain_img4_v1_sboot_item, (uint64_t)&v25);
                  if (!result) {
                    return 0xFFFFFFFFLL;
                  }
                  if ((unint64_t)v34 > 0xFFFFFFFFFFFFFFDFLL) {
                    goto LABEL_34;
                  }
                  *a3 = v35;
                  *a4 = v36;
                  if ((unint64_t)v37 > 0xFFFFFFFFFFFFFFDFLL) {
                    goto LABEL_34;
                  }
                  if (!v38) {
                    return 0;
                  }
                  uint64_t v23 = v39;
                  if (!v39) {
                    return 0;
                  }
                  uint64_t result = 0;
                  if (a5)
                  {
                    if (v24)
                    {
                      uint64_t result = 0;
                      *a5 = v38;
                      *long long v24 = v23;
                    }
                  }
                  return result;
                }
              }
              return 0xFFFFFFFFLL;
            }
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

uint64_t parse_chain(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (!a2) {
    return 0;
  }
  uint64_t v8 = 0;
  uint64_t v15 = result;
  unint64_t v18 = ~result;
  unint64_t v17 = ~a3;
  unint64_t v14 = ~a4;
  unint64_t v13 = ~a5;
  unint64_t v11 = ~a6;
  uint64_t v10 = a2;
  while (1)
  {
    unint64_t v9 = 16 * v8;
    if (16 * v8 > v18 || 48 * v8 > v17) {
      break;
    }
    uint64_t result = DERParseSequenceToObject(v15 + 16 * v8, (unsigned __int16)DERNumSignedCertCrlItemSpecs, (uint64_t)&DERSignedCertCrlItemSpecs, a3 + 48 * v8, 0x30uLL, 0x30uLL);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (160 * v8 > v14) {
      break;
    }
    uint64_t result = DERParseSequenceToObject(a3 + 48 * v8, (unsigned __int16)DERNumTBSCertItemSpecs, (uint64_t)&DERTBSCertItemSpecs, a4 + 160 * v8, 0xA0uLL, 0xA0uLL);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (v9 > v13) {
      break;
    }
    long long v22 = 0u;
    long long v23 = 0u;
    char v21 = 0;
    long long v19 = 0u;
    long long v20 = 0u;
    if (DERParseSequenceContentToObject((unint64_t *)(a4 + 160 * v8 + 96), (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs, (unint64_t)&v22, 0x20uLL, 0x20uLL))return 0xFFFFFFFFLL; {
    if (DERParseSequenceContentToObject((unint64_t *)&v22, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v19, 0x20uLL, 0x20uLL))return 0xFFFFFFFFLL;
    }
    uint64_t result = DEROidCompare((uint64_t)&v19, (uint64_t)&oidRsa);
    if (!result) {
      return 0xFFFFFFFFLL;
    }
    if (*((void *)&v20 + 1))
    {
      if (*((void *)&v20 + 1) != 2 || *(unsigned char *)v20 != 5) {
        return 0xFFFFFFFFLL;
      }
      if ((void)v20 == -1) {
        break;
      }
      if (*(unsigned char *)(v20 + 1)) {
        return 0xFFFFFFFFLL;
      }
    }
    uint64_t result = DERParseBitString((uint64_t)&v23, (unint64_t *)(a5 + 16 * v8), &v21);
    if (result || v21) {
      return 0xFFFFFFFFLL;
    }
    if (v9 > v11) {
      break;
    }
    uint64_t result = parse_extensions(a4 + 160 * v8, (void *)(a6 + 16 * v8));
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (++v8 == v10) {
      return 0;
    }
  }
  __break(0x5513u);
  return result;
}

uint64_t verify_chain_signatures(void *a1, void *a2, uint64_t a3)
{
  uint64_t v14 = *MEMORY[0x263EF8340];
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!a2) {
    return 0xFFFFFFFFLL;
  }
  if (!a3) {
    return 0xFFFFFFFFLL;
  }
  long long v11 = 0u;
  long long v12 = 0u;
  char v10 = 0;
  memset(v13, 0, sizeof(v13));
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  BOOL v5 = *(void **)(a3 + 32);
  if (!v5
    || !v5[2]
    || !*(void *)a3
    || !*(void *)(a3 + 40)
    || *v5 > 0x30uLL
    || DERParseSequenceContentToObject(a2 + 2, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v11, 0x20uLL, 0x20uLL))
  {
    return 0xFFFFFFFFLL;
  }
  if (*((void *)&v12 + 1))
  {
    uint64_t result = DEROidCompare((uint64_t)&v11, (uint64_t)&oidEcPubKey);
    if ((result & 1) == 0)
    {
      if (*((void *)&v12 + 1) != 2 || *(unsigned char *)v12 != 5) {
        return 0xFFFFFFFFLL;
      }
      if ((void)v12 == -1)
      {
        __break(0x5513u);
        return result;
      }
      if (*(unsigned char *)(v12 + 1)) {
        return 0xFFFFFFFFLL;
      }
    }
  }
  if (!DEROidCompare((uint64_t)&v11, *(void *)(a3 + 40))) {
    return 0xFFFFFFFFLL;
  }
  if ((*(unsigned int (**)(void, void, _OWORD *, void, uint64_t))a3)(*a2, a2[1], v13, **(void **)(a3 + 32), a3))
  {
    return 0xFFFFFFFFLL;
  }
  if (DERParseBitString((uint64_t)(a2 + 4), &v8, &v10)) {
    return 0xFFFFFFFFLL;
  }
  if (v10) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = (*(uint64_t (**)(void, void, unint64_t, uint64_t, _OWORD *, void, uint64_t, void))(a3 + 16))(*a1, a1[1], v8, v9, v13, **(void **)(a3 + 32), a3, 0);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t verify_chain_img4_x86(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_x86);
}

uint64_t verify_chain_img4_v2_with_crack_callback(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, unsigned int (*a8)(void *, unsigned char *, uint64_t))
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    unsigned int v10 = a2;
    if (a2)
    {
      if (a3 && a4)
      {
        bzero(v22, 0x300uLL);
        v21[0] = a1;
        v21[1] = v10;
        if (a8(v21, v22, 2)) {
          return 0xFFFFFFFFLL;
        }
        uint64_t result = parse_chain((uint64_t)v22, 2u, (uint64_t)v23, (uint64_t)&v24, (uint64_t)v27, (uint64_t)v28);
        if (result)
        {
          return 0xFFFFFFFFLL;
        }
        else
        {
          char v16 = 1;
          uint64_t v17 = 1;
          while ((v16 & 1) != 0)
          {
            unint64_t v18 = &v21[20 * v17];
            if (__n == v18[33] && !memcmp(__s1, (const void *)v18[32], __n))
            {
              uint64_t result = verify_chain_signatures(v27, &v23[3 * v17], a7);
              char v16 = 0;
              uint64_t v17 = 2;
              if (!result) {
                continue;
              }
            }
            return 0xFFFFFFFFLL;
          }
          if ((unint64_t)v27 > 0xFFFFFFFFFFFFFFEFLL
            || (*a3 = v27[2], *a4 = v27[3], (unint64_t)v28 > 0xFFFFFFFFFFFFFFEFLL))
          {
            __break(0x5513u);
          }
          else if (v29 && (uint64_t v19 = v30) != 0)
          {
            uint64_t result = 0;
            if (a5 && a6)
            {
              uint64_t result = 0;
              *a5 = v29;
              *a6 = v19;
            }
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t crack_chain_rsa4k_sha384_x86(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_X86_ROOT_CA_CERTIFICATE;
  a2[1] = 1382;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_ddi(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_ddi);
}

uint64_t crack_chain_rsa4k_sha384_ddi(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_DDI_ROOT_CA_CERTIFICATE;
  a2[1] = 1394;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_ddi_global(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_ddi_global);
}

uint64_t crack_chain_rsa4k_sha384_ddi_global(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_DDI_GLOBAL_ROOT_CA_CERTIFICATE;
  a2[1] = 1404;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_ddi_fake(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_ddi_fake);
}

uint64_t crack_chain_rsa4k_sha384_ddi_fake(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_DDI_FAKE_ROOT_CA_CERTIFICATE;
  a2[1] = 1425;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_ddi_fake_global(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_ddi_fake_global);
}

uint64_t crack_chain_rsa4k_sha384_ddi_fake_global(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_DDI_FAKE_GLOBAL_ROOT_CA_CERTIFICATE;
  a2[1] = 1435;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_avp(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_avp);
}

uint64_t crack_chain_rsa4k_sha384_avp(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_AVP_ROOT_CA_CERTIFICATE;
  a2[1] = 1431;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_tatsu_local_policy(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_tatsu_local_policy);
}

uint64_t crack_chain_rsa4k_sha384_tatsu_local_policy(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_LP_ROOT_CA_CERTIFICATE;
  a2[1] = 1382;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_tatsu_local_policy_hacktivate(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_tatsu_local_policy_hacktivate);
}

uint64_t crack_chain_rsa4k_sha384_tatsu_local_policy_hacktivate(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &LOCAL_RSA4K_SHA384_LP_ROOT_CA_CERTIFICATE;
  a2[1] = 1442;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_v2_rsa3k(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa3k_sha384);
}

uint64_t crack_chain_rsa3k_sha384(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA3K_SHA384_ROOT_CA_CERTIFICATE;
  a2[1] = 1118;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_v2(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384);
}

uint64_t crack_chain_rsa4k_sha384(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_ROOT_CA_CERTIFICATE;
  a2[1] = 1374;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_v2_AWG1(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_AWG1);
}

uint64_t crack_chain_rsa4k_sha384_AWG1(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_ROOT_CA_CERTIFICATE_AWG1;
  a2[1] = 1404;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_v2_PED(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_v2_with_crack_callback(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_rsa4k_sha384_PED);
}

uint64_t crack_chain_rsa4k_sha384_PED(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &RSA4K_SHA384_PED_ROOT_CA_CERTIFICATE;
  a2[1] = 1400;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_ec_v1(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, unsigned int (*a8)(void *, unsigned char *, uint64_t))
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1)
  {
    unsigned int v10 = a2;
    if (a2)
    {
      if (a3 && a4)
      {
        bzero(v27, 0x330uLL);
        v26[0] = a1;
        v26[1] = v10;
        if (!a8(v26, v27, 3)
          && !parse_ec_chain((uint64_t)v27, 3u, (uint64_t)&v28, (uint64_t)&v30, (unint64_t)v32, (unint64_t)&v35, (uint64_t)v36))
        {
          long long v25 = a4;
          uint64_t v15 = 0;
          char v16 = (const void **)v31;
          uint64_t v17 = &v29;
          unint64_t v18 = (const void **)v31;
          while (1)
          {
            uint64_t v19 = &v26[20 * v15];
            size_t v20 = v19[37];
            char v21 = *v18;
            v18 += 20;
            if ((const void *)v20 != v21) {
              break;
            }
            if (memcmp((const void *)v19[36], *(v16 - 1), v20)) {
              break;
            }
            uint64_t result = verify_chain_signatures(&v32[v15], v17, a7);
            if (result) {
              break;
            }
            v17 += 6;
            ++v15;
            char v16 = v18;
            if (v15 == 2)
            {
              if ((unint64_t)v32 > 0xFFFFFFFFFFFFFFDFLL
                || (*a3 = v33, *long long v25 = v34, (unint64_t)v36 > 0xFFFFFFFFFFFFFFDFLL))
              {
                __break(0x5513u);
              }
              else if (v37 && (uint64_t v22 = v38) != 0)
              {
                uint64_t result = 0;
                if (a5)
                {
                  if (a6)
                  {
                    uint64_t result = 0;
                    *a5 = v37;
                    *a6 = v22;
                  }
                }
              }
              else
              {
                return 0;
              }
              return result;
            }
          }
        }
        return 0xFFFFFFFFLL;
      }
    }
  }
  return result;
}

uint64_t parse_ec_chain(uint64_t result, unsigned int a2, uint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6, uint64_t a7)
{
  if (!a2) {
    return 0;
  }
  unint64_t v9 = 0;
  unint64_t v10 = 0;
  unint64_t v11 = 0;
  uint64_t v21 = result;
  unint64_t v24 = ~result;
  unint64_t v23 = ~a3;
  unint64_t v20 = ~a4;
  if (a5 <= a6) {
    unint64_t v12 = a6;
  }
  else {
    unint64_t v12 = a5;
  }
  unint64_t v19 = ~v12;
  unint64_t v16 = ~a7;
  uint64_t v15 = 16 * a2;
  while (v11 <= v24 && v10 <= v23)
  {
    uint64_t result = DERParseSequenceToObject(v21 + v11, (unsigned __int16)DERNumSignedCertCrlItemSpecs, (uint64_t)&DERSignedCertCrlItemSpecs, a3 + v10, 0x30uLL, 0x30uLL);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (v9 > v20) {
      break;
    }
    uint64_t result = DERParseSequenceToObject(a3 + v10, (unsigned __int16)DERNumTBSCertItemSpecs, (uint64_t)&DERTBSCertItemSpecs, a4 + v9, 0xA0uLL, 0xA0uLL);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (v11 > v19) {
      break;
    }
    long long v31 = 0u;
    long long v32 = 0u;
    char v30 = 0;
    long long v28 = 0u;
    long long v29 = 0u;
    if (DERParseSequenceContentToObject((unint64_t *)(a4 + v9 + 96), (unsigned __int16)DERNumSubjPubKeyInfoItemSpecs, (uint64_t)&DERSubjPubKeyInfoItemSpecs, (unint64_t)&v31, 0x20uLL, 0x20uLL))return 0xFFFFFFFFLL; {
    if (DERParseSequenceContentToObject((unint64_t *)&v31, (unsigned __int16)DERNumAlgorithmIdItemSpecs, (uint64_t)&DERAlgorithmIdItemSpecs, (unint64_t)&v28, 0x20uLL, 0x20uLL))return 0xFFFFFFFFLL;
    }
    if (!DEROidCompare((uint64_t)&v28, (uint64_t)&oidEcPubKey)) {
      return 0xFFFFFFFFLL;
    }
    if (DERParseBitString((uint64_t)&v32, (unint64_t *)(a5 + v11), &v30)) {
      return 0xFFFFFFFFLL;
    }
    if (v30) {
      return 0xFFFFFFFFLL;
    }
    unint64_t v25 = 0;
    uint64_t v26 = 0;
    uint64_t v27 = 0;
    uint64_t result = DERDecodeItem((uint64_t)&v29, &v25);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    unint64_t v13 = (void *)(a6 + v11);
    uint64_t v14 = v27;
    void *v13 = v26;
    v13[1] = v14;
    if (v11 > v16) {
      break;
    }
    uint64_t result = parse_extensions(a4 + v9, (void *)(a7 + v11));
    if (result) {
      return 0xFFFFFFFFLL;
    }
    v11 += 16;
    v10 += 48;
    v9 += 160;
    if (v15 == v11) {
      return 0;
    }
  }
  __break(0x5513u);
  return result;
}

uint64_t verify_chain_img4_ecdsa256(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_ec_v2(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_ecdsa256_sha256);
}

uint64_t verify_chain_img4_ec_v2(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, unsigned int (*a8)(void *, unsigned char *, uint64_t))
{
  uint64_t result = 0xFFFFFFFFLL;
  if (!a1) {
    return result;
  }
  unsigned int v10 = a2;
  if (!a2 || !a3 || !a4) {
    return result;
  }
  bzero(v20, 0x220uLL);
  v19[0] = a1;
  v19[1] = v10;
  if (a8(v19, v20, 2)) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = parse_ec_chain((uint64_t)v20, 2u, (uint64_t)v21, (uint64_t)v23, (unint64_t)v28, (unint64_t)&v29, (uint64_t)v30);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  if ((unint64_t)v23 > 0xFFFFFFFFFFFFFF5FLL) {
    goto LABEL_22;
  }
  if (__n != v27) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = memcmp(__s1, __s2, __n);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  if ((unint64_t)v21 > 0xFFFFFFFFFFFFFFCFLL)
  {
LABEL_22:
    __break(0x5513u);
    return result;
  }
  uint64_t result = verify_chain_signatures(v28, v22, a7);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  if ((unint64_t)v28 > 0xFFFFFFFFFFFFFFEFLL) {
    goto LABEL_22;
  }
  uint64_t v16 = v28[3];
  *a3 = v28[2];
  *a4 = v16;
  if ((unint64_t)v30 > 0xFFFFFFFFFFFFFFEFLL) {
    goto LABEL_22;
  }
  if (!v31) {
    return 0;
  }
  uint64_t v17 = v32;
  if (!v32) {
    return 0;
  }
  uint64_t result = 0;
  if (a5)
  {
    if (a6)
    {
      uint64_t result = 0;
      *a5 = v31;
      *a6 = v17;
    }
  }
  return result;
}

uint64_t crack_chain_ecdsa256_sha256(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &LOCAL_EC256_SHA256_ROOT_CA_CERTIFICATE;
  a2[1] = 551;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_ecdsa384(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_ec_v2(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_ecdsa384_sha384_hacktivate);
}

uint64_t crack_chain_ecdsa384_sha384_hacktivate(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &LOCAL_EC384_SHA384_ROOT_CA_CERTIFICATE;
  a2[1] = 610;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_ecdsa384_local_policy(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_ec_v1(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_ecdsa384_sha384);
}

uint64_t crack_chain_ecdsa384_sha384(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &EC384_SHA384_LP_ROOT_CA_CERTIFICATE;
  a2[1] = 542;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t verify_chain_img4_ecdsa384_hacktivate(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_ec_v1(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_ecdsa384_sha384_hacktivate);
}

uint64_t verify_chain_img4_ecdsa384_qa(uint64_t a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7)
{
  return verify_chain_img4_ec_v1(a1, a2, a3, a4, a5, a6, a7, (unsigned int (*)(void *, unsigned char *, uint64_t))crack_chain_ecdsa384_sha384_qa);
}

uint64_t crack_chain_ecdsa384_sha384_qa(unint64_t *a1, void *a2, unsigned int a3)
{
  *a2 = &QA_EC384_SHA384_ROOT_CA_CERTIFICATE;
  a2[1] = 540;
  if (_crack_chain_with_anchor(a1, (uint64_t)a2, a3)) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t Img4DecodeDigestInit(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v1 = *(void **)(a1 + 16);
  if (!v1 || !*v1) {
    return 0xFFFFFFFFLL;
  }
  ccdigest_init();
  return 0;
}

uint64_t Img4DecodeDigestUpdate(uint64_t a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!**(void **)(a1 + 16)) {
    return 0xFFFFFFFFLL;
  }
  ccdigest_update();
  return 0;
}

uint64_t Img4DecodeDigestReturnHash(uint64_t a1, void *a2, unint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v4 = **(void **)(a1 + 16);
  if (!v4 || *(void *)v4 > a3) {
    return 0xFFFFFFFFLL;
  }
  (*(void (**)(uint64_t, void, uint64_t))(v4 + 56))(v4, *a2, a4);
  return 0;
}

uint64_t Img4DecodeDigestFinal(uint64_t a1, void *a2, uint64_t a3)
{
  if (a1 && (uint64_t v3 = **(unint64_t ***)(a1 + 16)) != 0) {
    return Img4DecodeDigestReturnHash(a1, a2, *v3, a3);
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t Img4DecodeComputeDigest(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a5)
  {
    unint64_t v8 = *(void **)(a5 + 32);
    if (v8 && (unint64_t v9 = (void *)v8[2]) != 0 && *v8 == a4 && *v9 && *(void *)*v9 == a4)
    {
      ccdigest();
      return 0;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t img4_verify_signature_with_chain(unint64_t a1, unsigned int a2, uint64_t a3, unsigned int a4, uint64_t a5, unsigned int a6, void *a7, void *a8)
{
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  if (verify_chain_img4_v1(a1, a2, &v17, &v18, &v15, &v16, (uint64_t)kImg4DecodeSecureBootRsa1kSha1)) {
    return 0xFFFFFFFFLL;
  }
  *a7 = v15;
  *a8 = v16;
  uint64_t result = verify_signature_rsa(v17, v18, a3, a4, a5, a6, (uint64_t)kImg4DecodeSecureBootRsa1kSha1);
  if (result) {
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t _crack_chain_with_anchor(unint64_t *a1, uint64_t a2, unsigned int a3)
{
  unint64_t v18 = 0;
  unint64_t v19 = 0;
  unint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v17 = 0;
  unint64_t v5 = ~a2;
  unsigned int v6 = 1;
  unint64_t v7 = *a1;
  unint64_t v8 = a1[1];
  while (1)
  {
    unint64_t v18 = v7;
    unint64_t v19 = v8;
    uint64_t result = DERDecodeItem((uint64_t)&v18, &v15);
    if (result) {
      return 0xFFFFFFFFLL;
    }
    if (__CFADD__(v16, v17)) {
      break;
    }
    unint64_t v10 = v16 + v17;
    unint64_t v11 = v16 + v17 - v7;
    BOOL v12 = !(v11 >> 17) && v8 >= v11;
    if (!v12 || v6 >= a3) {
      return 0xFFFFFFFFLL;
    }
    if (v5 < 16 * (unint64_t)v6) {
      break;
    }
    uint64_t v14 = (unint64_t *)(a2 + 16 * v6);
    *uint64_t v14 = v7;
    v14[1] = v11;
    if (v10 < v7) {
      break;
    }
    BOOL v12 = v8 >= v11;
    v8 -= v11;
    if (!v12) {
      goto LABEL_21;
    }
    ++v6;
    unint64_t v7 = v10;
    if (!v8)
    {
      if (v6 == a3) {
        return 0;
      }
      return 0xFFFFFFFFLL;
    }
  }
  __break(0x5513u);
LABEL_21:
  __break(0x5515u);
  return result;
}

uint64_t parse_extensions(uint64_t a1, void *a2)
{
  v11[0] = 0;
  v11[1] = 0;
  v9[1] = 0;
  uint64_t v10 = 0;
  unint64_t v8 = 0;
  v9[0] = 0;
  long long v7 = 0u;
  memset(v6, 0, sizeof(v6));
  *a2 = 0;
  a2[1] = 0;
  if (!*(void *)(a1 + 152)) {
    return 0;
  }
  if (DERDecodeSeqInit(a1 + 144, &v10, v11) || v10 != 0x2000000000000010) {
    return 0xFFFFFFFFLL;
  }
  char v3 = 1;
  while (1)
  {
    int v4 = DERDecodeSeqNext(v11, &v8);
    if (v4) {
      break;
    }
    if (v8 != 0x2000000000000010
      || DERParseSequenceContentToObject(v9, (unsigned __int16)DERNumExtensionItemSpecs, (uint64_t)&DERExtensionItemSpecs, (unint64_t)v6, 0x30uLL, 0x30uLL))
    {
      return 0xFFFFFFFFLL;
    }
    char v3 = 0;
    if (DEROidCompare((uint64_t)&oidAppleImg4ManifestCertSpec, (uint64_t)v6))
    {
      memset(v12, 0, sizeof(v12));
      if (DERDecodeItem((uint64_t)&v7, v12) || v12[0] != 0x2000000000000011) {
        return 0xFFFFFFFFLL;
      }
      char v3 = 0;
      *(_OWORD *)a2 = v7;
    }
  }
  if (v4 != 1 || (v3 & 1) != 0) {
    return 0xFFFFFFFFLL;
  }
  else {
    return 0;
  }
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3;
  }
  int v4 = *(unsigned char **)result;
  if (*(void *)result == -1) {
    goto LABEL_68;
  }
  unint64_t v5 = &v4[v3];
  unsigned int v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    BOOL v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_69;
      }
      uint64_t v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15) {
            unint64_t v17 = *v12;
          }
          else {
            unint64_t v17 = v7 - 1;
          }
          BOOL v10 = v5 >= v14;
          unint64_t v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3) {
              return 0;
            }
LABEL_34:
            uint64_t result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3;
      }
      if (v14 >= v5 || v14 < v4) {
        goto LABEL_69;
      }
      if (!*v14) {
        return 3;
      }
      unint64_t v15 = 0;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (unsigned char *)-1)
      {
        if (v14 >= v5) {
          goto LABEL_69;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_70;
        }
        unsigned int v24 = *v14++;
        unint64_t v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!v19)
        {
          if (a3) {
            BOOL v25 = 0;
          }
          else {
            BOOL v25 = v15 > v22;
          }
          char v26 = v25;
          uint64_t result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0) {
            return result;
          }
          if (v15 >= v22) {
            unint64_t v27 = v22;
          }
          else {
            unint64_t v27 = v15;
          }
          BOOL v10 = (unint64_t)v5 >= v23;
          long long v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28) {
            goto LABEL_69;
          }
          a2[1] = v23;
          a2[2] = v27;
          if (a3) {
            goto LABEL_34;
          }
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3;
  }
  unint64_t v8 = 0;
  uint64_t result = 3;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 == (unsigned __int8 *)-1) {
      goto LABEL_68;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_69;
    }
    BOOL v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3;
      }
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERDecodeItemPartialBuffer(uint64_t result, unint64_t *a2, int a3)
{
  unint64_t v3 = *(void *)(result + 8);
  if (v3 < 2) {
    return 3;
  }
  int v4 = *(unsigned char **)result;
  if (*(void *)result == -1) {
    goto LABEL_54;
  }
  unint64_t v5 = &v4[v3];
  unsigned int v6 = v4 + 1;
  unint64_t v7 = v3 - 1;
  unint64_t v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    BOOL v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4) {
        goto LABEL_55;
      }
      uint64_t v14 = v12 + 1;
      unint64_t v15 = *v12;
      unint64_t v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        BOOL v17 = v16 < v15 && a3 == 0;
        unint64_t v18 = (unint64_t)(v12 + 1);
        if (v17) {
          return 3;
        }
LABEL_28:
        if (v15 > (~v18 & 0x7FFFFFFFFFFFFFFFLL)) {
          return 7;
        }
        if (v18 <= v18 + v15)
        {
          uint64_t result = 0;
          a2[1] = v18;
          a2[2] = v15;
          return result;
        }
        goto LABEL_55;
      }
      unint64_t v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8) {
        return 3;
      }
      if ((v15 & 0x7F) == 0 || v16 < v19) {
        return 3;
      }
      if (v14 >= v5 || v14 < v4)
      {
LABEL_55:
        __break(0x5519u);
LABEL_56:
        __break(0x5515u);
        return result;
      }
      if (!*v14) {
        return 3;
      }
      unint64_t v15 = 0;
      uint64_t v21 = (v19 - 1);
      unint64_t v22 = v7 - v21 - 2;
      unint64_t v18 = (unint64_t)&v12[v21 + 2];
      while (v14 != (unsigned char *)-1)
      {
        if (v14 >= v5) {
          goto LABEL_55;
        }
        BOOL v10 = v16-- != 0;
        if (!v10) {
          goto LABEL_56;
        }
        unsigned int v23 = *v14++;
        unint64_t v15 = (v15 << 8) | v23;
        LODWORD(v19) = v19 - 1;
        if (!v19)
        {
          if (v15 <= v22) {
            char v24 = 1;
          }
          else {
            char v24 = a3;
          }
          uint64_t result = 3;
          if (v15 >= 0x80 && (v24 & 1) != 0) {
            goto LABEL_28;
          }
          return result;
        }
      }
    }
LABEL_54:
    __break(0x5513u);
    goto LABEL_55;
  }
  unsigned int v9 = *v6;
  BOOL v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10) {
    return 3;
  }
  unint64_t v8 = 0;
  uint64_t result = 3;
  while (v7 >= 2)
  {
    unint64_t v11 = v8;
    if (v8 >> 57) {
      break;
    }
    if (v6 == (unsigned __int8 *)-1) {
      goto LABEL_54;
    }
    if (v6 >= v5 || v6 < v4) {
      goto LABEL_55;
    }
    BOOL v12 = (char *)(v6 + 1);
    --v7;
    unsigned __int8 v13 = *v6;
    unint64_t v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54) {
        return 3;
      }
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERParseBitString(uint64_t result, unint64_t *a2, unsigned char *a3)
{
  *a3 = 0;
  *a2 = 0;
  a2[1] = 0;
  if (!*(void *)(result + 8)) {
    return 3;
  }
  unsigned int v3 = **(unsigned __int8 **)result;
  *a3 = v3;
  uint64_t v4 = *(void *)(result + 8);
  if (v4 != 1)
  {
    if (v3 <= 7)
    {
      unint64_t v5 = v4 - 1;
      if (!v4)
      {
LABEL_20:
        __break(0x5515u);
        goto LABEL_21;
      }
      unint64_t v6 = *(void *)result;
      unint64_t v7 = *(void *)result + v4;
      unint64_t v8 = (unsigned __int8 *)(*(void *)result + v5);
      if ((unint64_t)v8 >= v7 || (unint64_t)v8 < v6)
      {
LABEL_19:
        __break(0x5519u);
        goto LABEL_20;
      }
      if (((0xFFu >> (8 - v3)) & *v8) == 0)
      {
        if (v6 == -1)
        {
LABEL_21:
          __break(0x5513u);
          return result;
        }
        unint64_t v10 = v6 + 1;
        if (v6 + 1 <= v7 && v6 <= v10)
        {
          uint64_t result = 0;
          *a2 = v10;
          a2[1] = v5;
          return result;
        }
        goto LABEL_19;
      }
    }
    return 3;
  }
  if (v3) {
    return 3;
  }
  else {
    return 0;
  }
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  if (a1[1] != (unsigned __int8 *)1) {
    return 3;
  }
  int v2 = **a1;
  if (v2 != 255 && v2 != 0) {
    return 3;
  }
  uint64_t result = 0;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERParseBooleanWithDefault(unsigned __int8 **a1, BOOL a2, BOOL *a3)
{
  unsigned int v3 = a1[1];
  if (!v3) {
    goto LABEL_9;
  }
  if (v3 == (unsigned __int8 *)1)
  {
    int v4 = **a1;
    if (v4 == 255 || v4 == 0)
    {
      a2 = v4 != 0;
LABEL_9:
      uint64_t result = 0;
      *a3 = a2;
      return result;
    }
  }
  return 3;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  v4[1] = *MEMORY[0x263EF8340];
  v4[0] = 0xAAAAAAAAAAAAAAAALL;
  uint64_t result = DERParseInteger64(a1, v4);
  if (!result)
  {
    if (HIDWORD(v4[0]))
    {
      return 7;
    }
    else
    {
      uint64_t result = 0;
      *a2 = v4[0];
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a1[1];
  if (!v2) {
    return 3;
  }
  unsigned int v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0) {
    return 3;
  }
  if (**a1)
  {
    if (v2 > 8) {
      return 7;
    }
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0) {
      return 3;
    }
    if (v2 > 9) {
      return 7;
    }
  }
LABEL_10:
  unint64_t v5 = 0;
  do
  {
    unsigned int v6 = *v3++;
    unint64_t v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  uint64_t result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERDecodeSeqInit(uint64_t a1, void *a2, void *a3)
{
  _OWORD v8[3] = *MEMORY[0x263EF8340];
  memset(v8, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!result)
  {
    unint64_t v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        unint64_t v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          uint64_t result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2 = *result;
  unint64_t v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    unint64_t v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  _OWORD v10[2] = *MEMORY[0x263EF8340];
  v10[0] = 0;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (*a1 >= v3) {
    return 1;
  }
  v10[0] = *a1;
  v10[1] = v3 - v2;
  uint64_t result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!result)
  {
    unint64_t v8 = a2[1];
    unint64_t v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      unint64_t v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        uint64_t result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v12[3] = *MEMORY[0x263EF8340];
  memset(v12, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!result)
  {
    if (v12[0] == 0x2000000000000010) {
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    }
    else {
      return 2;
    }
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t v34 = *MEMORY[0x263EF8340];
  unint64_t v32 = 0;
  if (a6)
  {
    if (a6 > a5) {
      goto LABEL_59;
    }
    bzero((void *)a4, a6);
  }
  unint64_t v10 = *a1;
  unint64_t v11 = a1[1];
  if (__CFADD__(*a1, v11)) {
    goto LABEL_58;
  }
  unint64_t v12 = v10 + v11;
  if (v10 > v12) {
LABEL_59:
  }
    __break(0x5519u);
  unint64_t v32 = *a1;
  unint64_t v33 = v12;
  if (a2)
  {
    unsigned __int16 v13 = 0;
    uint64_t v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      unint64_t v15 = v32;
      unint64_t v14 = v33;
      uint64_t result = DERDecodeSeqNext(&v32, v31);
      if (result) {
        break;
      }
      if (a2 <= v13) {
        return 2;
      }
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3) {
          goto LABEL_58;
        }
        unsigned __int16 v17 = v13;
        __int16 v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(void *)(a3 + 24 * v13 + 8)) {
          break;
        }
        uint64_t result = 2;
        if (v18)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1)) {
            continue;
          }
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        unint64_t v19 = *(void *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5) {
          return 7;
        }
        if (v19 > ~a4) {
          goto LABEL_58;
        }
        uint64_t v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4) {
          goto LABEL_59;
        }
        *(_OWORD *)uint64_t v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((void *)v21 + 1) <= v14 - v15)
            {
              *(void *)uint64_t v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29) {
            goto LABEL_59;
          }
          uint64_t v23 = *((void *)v21 + 1);
          unint64_t v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15) {
            goto LABEL_59;
          }
          *(void *)uint64_t v21 = v15;
          *((void *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          unint64_t v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            unint64_t v10 = v31[1] + v31[2];
            unint64_t v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        unint64_t v10 = v32;
        unint64_t v12 = v33;
        goto LABEL_47;
      }
    }
    if (result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        BOOL v25 = (__int16 *)(a3 + 24 * v13 + 16);
        unint64_t v26 = a2 - (unint64_t)v13;
        uint64_t result = 0;
        while (1)
        {
          __int16 v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0) {
            break;
          }
          if (!--v26) {
            return result;
          }
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12) {
      return 0;
    }
    else {
      return 3;
    }
  }
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

unint64_t *DERParseSequenceContent(unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4) {
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSequenceWithBlock(uint64_t a1, uint64_t a2)
{
  void v4[3] = *MEMORY[0x263EF8340];
  memset(v4, 170, 24);
  uint64_t result = DERDecodeItemPartialBufferGetLength(a1, v4, 0);
  if (!result)
  {
    if (v4[0] - 0x2000000000000012 >= 0xFFFFFFFFFFFFFFFELL) {
      return DERDecodeSequenceContentWithBlock(&v4[1], a2);
    }
    else {
      return 2;
    }
  }
  return result;
}

uint64_t DERDecodeSequenceContentWithBlock(unint64_t *a1, uint64_t a2)
{
  unint64_t v9[2] = *MEMORY[0x263EF8340];
  v9[0] = 0;
  unint64_t v2 = *a1;
  unint64_t v3 = a1[1];
  if (__CFADD__(*a1, v3))
  {
    __break(0x5513u);
LABEL_13:
    __break(0x5519u);
  }
  unint64_t v4 = v2 + v3;
  if (v2 > v4) {
    goto LABEL_13;
  }
  v9[0] = *a1;
  v9[1] = v4;
  memset(v8, 170, sizeof(v8));
  char v7 = 0;
  while (1)
  {
    LODWORD(result) = DERDecodeSeqNext(v9, v8);
    if (result) {
      break;
    }
    LODWORD(result) = (*(uint64_t (**)(uint64_t, unint64_t *, char *))(a2 + 16))(a2, v8, &v7);
    if (result) {
      break;
    }
    if (v7) {
      return 0;
    }
  }
  if (result <= 1) {
    return 0;
  }
  else {
    return result;
  }
}

BOOL DEROidCompare(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1 && a2)
  {
    size_t v4 = *(void *)(a1 + 8);
    return v4 == *(void *)(a2 + 8) && memcmp(*(const void **)a1, *(const void **)a2, v4) == 0;
  }
  return result;
}

void H16ISPGraphExclaveANDKNode::onMessageProcessing(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  unint64_t v2 = "onMessageProcessing";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - ANDK Graph Node Message invalid\n", (uint8_t *)&v1, 0xCu);
}

void H16ISPGraphExclaveANDKNode::onMessageProcessing(int a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = 136315394;
  uint64_t v3 = "onMessageProcessing";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - Failed to run ANDK algorithm, ret=0x%X\n", (uint8_t *)&v2, 0x12u);
}

void H16ISPGraphExclaveRGBANDKNode::runANDKAlgorithm(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "Invalid RGB Conclave Handle\n", v1, 2u);
}

{
  uint8_t v1[16];

  *(_WORD *)int v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "Failed ANDK runkit IDL\n", v1, 2u);
}

void MatrixNxPts<1u,double>::MultATagxB<1u,void>()
{
  __assert_rtn("MultATagxB", "MatrixNxPts.hpp", 161, "GetNumOfPoints() == rhs.GetNumOfPoints()");
}

void AdaptiveThreshold<double,true>()
{
}

void ImageUtils::ErodeRect2x2()
{
}

void ErodeOrDilateRect3x3<false>()
{
}

void ErodeOrDilateRect2x2<true>()
{
}

void ImageUtils::Filter2<double>()
{
  __assert_rtn("Filter2", "ImageUtils.hpp", 196, "&im1 != res");
}

void DisjointSet::SetRoot()
{
  __assert_rtn("SetRoot", "DisjointSet.hpp", 105, "nRoot <= i");
}

{
  __assert_rtn("SetRoot", "DisjointSet.hpp", 109, "nRoot <= i");
}

void H16ISP::H16ISPGraphExclaveEyeReliefNode::onMessageProcessing(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  int v2 = "onMessageProcessing";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "[Exclaves] H16ISPGraphExclaveEyeReliefNode::%s Invalid IR Client Handle\n", (uint8_t *)&v1, 0xCu);
}

void H16ISP::H16ISPGraphExclaveEyeReliefNode::onMessageProcessing(unsigned __int8 *a1, int a2, os_log_t log)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  int v4 = 136315650;
  int v5 = "onMessageProcessing";
  __int16 v6 = 1024;
  int v7 = a2;
  __int16 v8 = 1024;
  int v9 = v3;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "[Exclaves] H16ISPGraphExclaveEyeReliefNode::%s EK Runkit ER Runkit failed for reqid 0x%08X ipcRet %d\n", (uint8_t *)&v4, 0x18u);
}

void H16ISP::H16ISPFusionNode::fuseDXBuffers(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "H16ISPFusionNode: Warning: min threshold set, but metadata unavailable. Will not be used.\n", v1, 2u);
}

void GMC_Homography()
{
}

void H16ISP::H16ISPFrameReceiverBufferPool::PreMapClientSurface()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - ISP_PreMapClientSurface failed: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiverBufferPool::allocateBuffer()
{
  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Pixel buffer reference is null, res=0x%08x\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Cannot allocate buffer, buffer pool is uninitialized and automatic allocation mode is enabled, res=0x%08x\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to allocate buffer, res=0x%08x\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to create pixel buffer, res=0x%08x\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiverSharedBufferPool::AllocateAndSendBuffers()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pH16ISPDevice->ISP_SendBuffers failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to set buffer configuration, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to allocate buffer, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiverSharedBufferPool::setBufferConfig()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetSharedBufferPoolInfo error: res=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiverSharedBufferPool::SendStillImageBuffers()
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v3[0] = 136315650;
  OUTLINED_FUNCTION_0();
  __int16 v4 = v0;
  int v5 = v1;
  _os_log_error_impl(&dword_24680F000, v2, OS_LOG_TYPE_ERROR, "%s - failed to send %u buffers ret=0x%08x\n", (uint8_t *)v3, 0x18u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set buffer configuration ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to allocate buffer ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiverSharedBufferPool::InitiateShutdown()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - ReturnAllSharedBuffersInPool failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiverSharedBufferPool::SendBuffer()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pH16ISPDevice->ISP_SendBuffers failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiverDataBufferPool::IOSurfaceAllocSize(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - data buffer pool is missing buffer attributes\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IOSurface properties not found\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IOSurface alloc size property not found\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPFrameReceiverDataBufferPool::SendInitialFirmwareBuffers(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - data buffer allocation failed\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPGraphExclaveObjectDetectionNode::H16ISPGraphExclaveObjectDetectionNode(int *a1, NSObject *a2, uint64_t a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  int v4 = 136315650;
  uint64_t v5 = "H16ISPGraphExclaveObjectDetectionNode";
  __int16 v6 = 1024;
  int v7 = v3;
  __int16 v8 = 1024;
  int v9 = 20;
  OUTLINED_FUNCTION_3_0(&dword_24680F000, a2, a3, "%s - [Exclaves]: Number of Hand Detections requested is %u, Secure ANST maximum support is %u, truncating output!\n", (uint8_t *)&v4);
}

void H16ISP::H16ISPGraphExclaveObjectDetectionNode::H16ISPGraphExclaveObjectDetectionNode()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315650;
  OUTLINED_FUNCTION_1_0();
  OUTLINED_FUNCTION_3_0(&dword_24680F000, v0, v1, "%s - [Exclaves]: Number of Head Detections requested is %u, Secure ANST maximum support is %u, truncating output!\n", (uint8_t *)v2);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315650;
  OUTLINED_FUNCTION_1_0();
  OUTLINED_FUNCTION_3_0(&dword_24680F000, v0, v1, "%s - [Exclaves]: Number of Face Detections requested is %u, Secure ANST maximum support is %u, truncating output!\n", (uint8_t *)v2);
}

void H16ISP::H16ISPGraphExclaveIRObjectDetectionNode::InvokeEKRunKit(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPGraphExclaveIRObjectDetectionNode::InvokeEKRunKit()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_3_0(&dword_24680F000, v0, (uint64_t)v0, "%s - [Exclaves]: IR EK Object Detection RunKit failed, tberr=%d EK result=%{BOOL}d\n", (uint8_t *)v1);
}

void H16ISP::H16ISPGraphExclaveRGBObjectDetectionNode::InvokeEKRunKit(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPGraphExclaveRGBObjectDetectionNode::InvokeEKRunKit()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_3_0(&dword_24680F000, v0, (uint64_t)v0, "%s - [Exclaves]: RGB EK Object Detection RunKit failed, tberr=%d EK result=%{BOOL}d\n", (uint8_t *)v1);
}

void H16ISP::GenerateRGBObjectDictionary(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Could not allocate human body dictionary! Skipping!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Could not allocate human body dictionary! Skipping!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Could not allocate human body dictionary! Skipping!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Could not allocate human body dictionary! Skipping!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Could not allocate human full body dictionary! Skipping!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Could not allocate hand dictionary! Skipping!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Could not allocate head dictionary! Skipping!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Could not allocate face dictionary! Skipping!\n", a5, a6, a7, a8, 2u);
}

void H16ISP::ProjectorManager::applyUserDefinedType()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "User defined projector mode: frame rate missing\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "User defined projector mode: modes array missing\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "User defined projector mode: sequence missing\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "User defined projector mode: Failed to set sequence \n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "User defined projector mode: sequence value %d is not a number\n", v2, v3, v4, v5, v6);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  OUTLINED_FUNCTION_2();
  LOWORD(v3) = 1024;
  HIWORD(v3) = v0;
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "User defined projector mode: mode %d - pulse %d is not a number\n", v2, v3);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "User defined projector mode: mode %d - pulse is not a number\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "User defined projector mode: mode %d isn't an array\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "User defined projector mode: trying to add too many modes (%d)\n", v2, v3, v4, v5, v6);
}

void H16ISP::ProjectorManager::applyUserDefinedType(const __CFArray *a1, NSObject *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v3 = 134218240;
  CFIndex Count = CFArrayGetCount(a1);
  __int16 v5 = 1024;
  int v6 = 64;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "User defined projector mode: sequence length (%ld) over maximum (%d)\n", (uint8_t *)&v3, 0x12u);
}

void H16ISP::ProjectorManager::applyUserDefinedType(_WORD *a1, uint64_t a2, NSObject *a3)
{
  LOWORD(v3) = 1024;
  HIWORD(v3) = *a1;
  OUTLINED_FUNCTION_4(&dword_24680F000, a2, a3, "User defined projector mode: Failed to add LUT entry for user-defined mode %d - actually mode %d\n", 67109376, v3);
}

void H16ISP::ProjectorManager::applyUserDefinedType(const __CFArray *a1, int a2, NSObject *a3)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  v4[0] = 67109632;
  v4[1] = a2;
  __int16 v5 = 2048;
  CFIndex Count = CFArrayGetCount(a1);
  __int16 v7 = 1024;
  int v8 = 6;
  _os_log_error_impl(&dword_24680F000, a3, OS_LOG_TYPE_ERROR, "User defined projector mode: mode %d has %ld parameters. Expecting %d\n", (uint8_t *)v4, 0x18u);
}

void H16ISP::H16ISPGraphExclaveAttentionDetectionNode::onMessageProcessing(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "onMessageProcessing";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "[Exclaves] H16ISPGraphAttentionDetectionNode::%s Invalid IR Client Handle\n", (uint8_t *)&v1, 0xCu);
}

void H16ISP::H16ISPGraphExclaveAttentionDetectionNode::onMessageProcessing(unsigned __int8 *a1, int a2, os_log_t log)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  int v4 = 136315650;
  __int16 v5 = "onMessageProcessing";
  __int16 v6 = 1024;
  int v7 = a2;
  __int16 v8 = 1024;
  int v9 = v3;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "[Exclaves] H16ISPGraphAttentionDetectionNode::%s AD RunKit failed, tberr=%d ipcret=%d\n", (uint8_t *)&v4, 0x18u);
}

void AppleH16PhotonDetectorDevice::ReadCalibrationData(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "ReadCalibrationData";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - Invalid buffer passed to read photon detector calibration data\n", (uint8_t *)&v1, 0xCu);
}

void CopySupportedFormatsArray(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136315138;
  *a2 = "ANSTThumbnailFeatureAnnounceSupport";
  OUTLINED_FUNCTION_4_0(&dword_24680F000, a3, (uint64_t)a3, "%s - Could not initialize ANST Thumbnail configuration!\n", a1);
}

{
  *(_DWORD *)a1 = 136315138;
  *a2 = "HITHFeatureAnnounceSupport";
  OUTLINED_FUNCTION_4_0(&dword_24680F000, a3, (uint64_t)a3, "%s - Could not initialize Hi-Res Thumbnail configuration!\n", a1);
}

{
  *(_DWORD *)a1 = 136315138;
  *a2 = "ANSTFeatureAnnounceSupport";
  OUTLINED_FUNCTION_4_0(&dword_24680F000, a3, (uint64_t)a3, "%s - Could not initialize [] semantic mask configuration!\n", a1);
}

void SetMaximumAllowedFrameRate(float *a1, NSObject *a2, float a3)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  double v3 = *a1;
  int v4 = 136315650;
  __int16 v5 = "SetMaximumAllowedFrameRate";
  __int16 v6 = 2048;
  double v7 = v3;
  __int16 v8 = 2048;
  double v9 = a3;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - Given MaximumAllowedFrameRate %.3f exceeds sensor MaximumFrameRate %.3f\n", (uint8_t *)&v4, 0x20u);
}

void SetMaximumAllowedFrameRate()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetMaximumAllowedFrameRate error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Calling GetCameraConfig() returns error %d\n", v2, v3, v4, v5, 2u);
}

void SetMaximumAllowedFrameRate(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetFormatIndex()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetMaximumAllowedFrameRate error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableFESAutoAdjust error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableSBS error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void StillImageCaptureNow()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to send still image buffer from hires raw pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - AddCntxSwRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_37();
  OUTLINED_FUNCTION_38();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: kFigCaptureStreamStillImageCaptureNowKey_AutoFocusTimeout 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetTemporalNoiseReductionConfiguration()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetBand0StrengthModThreshold failed: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableBand0Modulation failed: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableHighStrengthTNR failed: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void SetTemporalNoiseReductionConfiguration(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetFaceDetectionEnabled()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Unable to activate face Detection while streaming, error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetAFWindowParams(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - property must be one of { CFDictionary, CFArray(CFDictionary) }\n", a5, a6, a7, a8, 2u);
}

void SetAFWindowParams()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - SetCombinedAFWindow failed on channel=%u ret=0x%08x\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_24();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - missing FaceTrackingScale value for AF window=%ld\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_24();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - failed to extract rect parameters from AF window=%ld\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_24();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - AF window=%ld parameters must be specified as CFDictionary\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_24();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - unexpected number of AF window parameters: count = %ld\n", v2, v3, v4, v5, 2u);
}

void RawImageProcessGo()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "FigBufferQueueEnqueue error: %d\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "FigSampleBufferCreateForImageBuffer error: %d\n\n", v2, v3, v4, v5, v6);
}

void SetDeviceOrientation()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: Set Device Orientation: did not succeed: 0x%08x\n\n", v2, v3, v4, v5, v6);
}

void SetAWB1stGainManual()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: Missing entries in dictionary passed for kFigCaptureStreamProperty_AWB1stGainManual property\n\n", v2, v3, v4, v5, v6);
}

void SetVideoOutputHandlers(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - not supported when StillImageIntermediateTap output is enabled\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - not supported when StillCapture output is enabled\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - not supported when SecondaryScaler output is enabled\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - not supported when PrimaryScaler output is enabled\n", a5, a6, a7, a8, 2u);
}

double SetVideoOutputsEnabled(uint64_t a1)
{
  double v1 = OUTLINED_FUNCTION_26(a1, *MEMORY[0x263EF8340]);
  double v3 = *v2;
  int v6 = 136315650;
  double v7 = "SetVideoOutputsEnabled";
  __int16 v8 = 2048;
  double v9 = v1;
  __int16 v10 = 2048;
  double v11 = v3;
  _os_log_error_impl(&dword_24680F000, v4, OS_LOG_TYPE_ERROR, "%s - maxFrameRate %.3f is larger than maxAllowedFrameRate %.3f\n\n", (uint8_t *)&v6, 0x20u);
  return result;
}

void SetVideoOutputsEnabled()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not enable ProRes, res=0x%08X \n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Error configuring stream selection: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetVideoOutputConfigurations()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - AddFocusPixelDataToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - removeBufferPoolFromFrameReceiver error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - AddSashimiRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - AddSushiRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - error configuring YCC crop: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  double v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_34();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - intermediate tap output does not support height scaling %d != %.0f\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_20(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - new intermediate tap output height=%d exceeds current buffer height=%u\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  double v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_34();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - intermediate tap output does not support width scaling %d != %.0f\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_20(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - new intermediate tap output width=%d exceeds current buffer width=%u\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_20(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - new secondary scaler output height=%d exceeds current buffer height=%u\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_20(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - new secondary scaler output width=%d exceeds current buffer width=%u\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_20(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - new primary scaler output height=%d exceeds current buffer height=%u\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_20(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - new primary scaler output width=%d exceeds current buffer width=%u\n", v2, v3, v4);
}

void SetVideoOutputConfigurations(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - StillImageIntermediateTap ClientBufferPool Attribute is not available\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - StillImage ClientBufferPool Attribute is not available\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid height alignment for still image\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid width alignment for still image\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IntermediateTap ClientBufferPool Attribute is not available\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer attributes not found for intermediate tap output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer height not found for intermediate tap output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer width not found for intermediate tap output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - SecondaryScaler ClientBufferPool Attribute is not available\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer attributes not found for secondary scaler output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer height not found for secondary scaler output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid height alignment for secondary scaler\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer width not found for secondary scaler output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid width alignment for secondary scaler\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - PrimaryScaler ClientBufferPool Attribute is not available\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer attributes not found for primary scaler output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer height not found for primary scaler output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid height alignment for primary scaler\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer width not found for primary scaler output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid width alignment for primary scaler\n", a5, a6, a7, a8, 2u);
}

uint64_t SetVideoOutputConfigurations(uint64_t a1, uint64_t a2, char a3)
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v4, v5, "%s - Error configuring TimeMachine depth: res=0x%08X\n\n", v6, v7, v8, v9, 2u);
  return a3 & 1;
}

void SetVideoOutputConfigurations(uint64_t a1, uint64_t a2)
{
  OUTLINED_FUNCTION_18(a2, *MEMORY[0x263EF8340]);
  LODWORD(v4) = 136315906;
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_16(&dword_24680F000, v2, v3, "%s - still image height=%d must be in range [%d, %d]\n", v4, v5, v6, v7);
}

{
  uint64_t v2;
  os_log_t v3;
  const char *v4;
  int v5;
  int v6;
  int v7;

  OUTLINED_FUNCTION_18(a2, *MEMORY[0x263EF8340]);
  LODWORD(v4) = 136315906;
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_16(&dword_24680F000, v2, v3, "%s - still image width=%d must be in range [%d, %d]\n", v4, v5, v6, v7);
}

{
  uint64_t v2;
  os_log_t v3;
  const char *v4;
  int v5;
  int v6;
  int v7;

  OUTLINED_FUNCTION_18(a2, *MEMORY[0x263EF8340]);
  LODWORD(v4) = 136315906;
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_16(&dword_24680F000, v2, v3, "%s - secondary scaler width=%d must be in range [%d, %d]\n", v4, v5, v6, v7);
}

{
  uint64_t v2;
  os_log_t v3;
  const char *v4;
  int v5;
  int v6;
  int v7;

  OUTLINED_FUNCTION_18(a2, *MEMORY[0x263EF8340]);
  LODWORD(v4) = 136315906;
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_16(&dword_24680F000, v2, v3, "%s - secondary scaler height=%d must be in range [%d, %d]\n", v4, v5, v6, v7);
}

{
  uint64_t v2;
  os_log_t v3;
  const char *v4;
  int v5;
  int v6;
  int v7;

  OUTLINED_FUNCTION_18(a2, *MEMORY[0x263EF8340]);
  LODWORD(v4) = 136315906;
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_16(&dword_24680F000, v2, v3, "%s - primary scaler width=%d must be in range [%d, %d]\n", v4, v5, v6, v7);
}

{
  uint64_t v2;
  os_log_t v3;
  const char *v4;
  int v5;
  int v6;
  int v7;

  OUTLINED_FUNCTION_18(a2, *MEMORY[0x263EF8340]);
  LODWORD(v4) = 136315906;
  OUTLINED_FUNCTION_15();
  OUTLINED_FUNCTION_16(&dword_24680F000, v2, v3, "%s - primary scaler height=%d must be in range [%d, %d]\n", v4, v5, v6, v7);
}

void CopyVideoOutputConfigurations(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to allocate memory for pool info\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - no valid light source mask configuration dictionary\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to allocate memory for pool info\n", a5, a6, a7, a8, 2u);
}

void CopyVideoOutputConfigurations()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to fetch pool info ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to fetch pool info ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to fetch pool info ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to fetch pool info ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;
  int v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315906;
  OUTLINED_FUNCTION_33();
  LOWORD(v4) = 0;
  OUTLINED_FUNCTION_27();
  OUTLINED_FUNCTION_16(&dword_24680F000, v0, v1, "%s - %d - Error retrieving max GDC strength on still output ch=%d res=0x%08X\n\n", v2, v3, v4, v5);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;
  int v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315906;
  OUTLINED_FUNCTION_33();
  LOWORD(v4) = 0;
  OUTLINED_FUNCTION_27();
  OUTLINED_FUNCTION_16(&dword_24680F000, v0, v1, "%s - %d - Error retrieving CameraConfig for still output ch=%d res=0x%08X\n\n", v2, v3, v4, v5);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;
  int v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315906;
  OUTLINED_FUNCTION_33();
  LOWORD(v4) = 0;
  OUTLINED_FUNCTION_27();
  OUTLINED_FUNCTION_16(&dword_24680F000, v0, v1, "%s - %d - Error retrieving max GDC strength on primary output ch=%d res=0x%08X\n", v2, v3, v4, v5);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;
  int v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315906;
  OUTLINED_FUNCTION_33();
  LOWORD(v4) = 0;
  OUTLINED_FUNCTION_27();
  OUTLINED_FUNCTION_16(&dword_24680F000, v0, v1, "%s - %d - Error retrieving CameraConfig for primary output ch=%d res=0x%08X\n", v2, v3, v4, v5);
}

void CopyGeometricDistortionCorrectedRects(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CopyGeometricDistortionCorrectedRects()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Channel %d doesn't support GDC\n", v2, v3, v4, v5, 2u);
}

void SetVibeMitigationEnabled()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableVibeMitigation error: 0x%08X\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "camera is streaming, vibe mitigation cannot be performed\n", v2, v3, v4, v5, v6);
}

void SetSynchronizedStreamsSlaveConfiguration()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Invalid parameter (propertyValue) - specify a dictionary for slave configuration\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Invalid parameter (kFigCaptureStreamSynchronizedStreamsSlaveConfigurationKey_StreamingOutputsEnabled)\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Invalid parameter (kFigCaptureStreamSynchronizedStreamsSlaveConfigurationKey_FrameSkippingEnabled)\n\n", v2, v3, v4, v5, v6);
}

void SetColorSpace()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set HDRC while streaming is active\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set ltm mode while streaming is active\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set gamma curve while streaming is active\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set color space while streaming is active\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Invalid color-space specified. Defaulting to rec709\n\n", v2, v3, v4, v5, v6);
}

void SetAPSMode()
{
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: SetAPSMode failed: %d, result=0x%08X\n\n", 67109376, v2);
}

void CopyAPSMode()
{
  OUTLINED_FUNCTION_39();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: Invalid APS mode: result=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: GetAPSMode failed: result=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetHighCurrentTorchEnabled()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to enable HighCurrentTorchEnabled while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void SetAFCalibrationData()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetAFIdentificationCalibration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "CFDataRef size does not match FigCaptureStreamAutoFocusCalibrationData\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set AF calibration data while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void CopyAFCalibrationData()
{
  OUTLINED_FUNCTION_36();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Failed to create CFDataRef for AF calibration: result=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "RunAFIdentificationCalibration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to run AF calibration while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void SetSphereCalibrationData()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetOISIdentificationCalibration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "CFDataRef size does not match FigCaptureStreamSphereCalibrationData\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set sphere calibration data while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void CopySphereCalibrationData()
{
  OUTLINED_FUNCTION_36();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Failed to create CFDataRef for sphere calibration: result=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "RunOISIdentificationCalibration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to run sphere calibration while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void SetSphereEndStopCalibrationData()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetOISEndStopCalibration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "CFDataRef size does not match FigCaptureStreamSphereEndStopCalibrationData\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set sphere endstop calibration data while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void CopySphereEndStopCalibrationData()
{
  OUTLINED_FUNCTION_36();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Failed to create CFDataRef for sphere end stop calibration: result=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "RunOISEndStopCalibration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to run sphere end stop calibration while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void SetAPSSphereInterCalibrationData()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetAPSOISInteractionCalibration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "CFDataRef size does not match FigCaptureStreamAutoFocusPositionSensorSphereInteractionCalibrationData\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set APS/sphere interaction calibration data while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void CopyAPSSphereInterCalibrationData()
{
  OUTLINED_FUNCTION_36();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Failed to create CFDataRef for APS/sphere interaction calibration: result=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "RunAPSOISInteractionCalibration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to run APS/sphere interaction calibration while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void SetKeypointDetectionConfiguration()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableKeypointDetection error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetKeypointConfiguration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set keypoint configuration while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void SetSceneClassifierVersion()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set scene classifier version while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void SetLumaHistogramEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetLumaHistogramEnabled()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to enable luma histogram metadata (res=0x%08X)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to enable luma histogram (res=0x%08X)\n", v2, v3, v4, v5, 2u);
}

void SetAutoExposureTables()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "CISP_CMD_CH_AE_INTEGRATION_TABLE_SET error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void TimeMachineSuspendNow()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SuspendTimeMachine error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void CopyTimeMachinePTSRange()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ISP_GetCameraTime failed, res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "GetTimeMachinePTSRange failed, res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetContentAwareEnhancement()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableNRSemanticVideo error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void SetContentAwareAWBEnabled()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableAWBSemanticVideo error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void CopyNRSharpeningConfiguration()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "GetMBNRConfiguration failed, res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "GetLCEStrength failed, res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "GetSharpness failed, res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "GetRNFStrength failed, res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void CopyAPSOffsetEstimatorInfo()
{
  OUTLINED_FUNCTION_39();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "CopyAPSOffsetEstimatorInfo - Unexpected APS mode from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "CopyAPSOffsetEstimatorInfo - Error getting APS stats (CISP_CMD_CH_APS_STARTUP_CAL_STATS_GET): res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetStreamingTuningProfile()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unable to set the ISP tuning profile (result=0x%08x)\n", v2, v3, v4, v5, 2u);
}

void SetLTMCurve()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "CISP_CMD_CH_LTM_PROCESSING_MODE_SET error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetLSCStrength()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Couldn't set LSC strength, error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetTimeLapseCaptureConfiguration()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableTimeLapseConfiguration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableTimeLapseSmoothing error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetTimeLapseSamplingRate error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetHDRImageStatisticsEnabled()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableDolbyVisionMetadata error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void CopyTOFAutoFocusEstimatorResults(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CopyTOFAutoFocusEstimatorResults()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - CISP_CMD_CH_AFASSIST_APE_TRAINING_STATS_GET error: res=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - CISP_CMD_CH_AFASSIST_APE_TESTING_STATS_GET error: res=0x%08X\n", v2, v3, v4, v5, 2u);
}

void CopyAutoFocusDriverShortStats(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CopyAutoFocusDriverShortStats()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - CISP_CMD_CH_SESSION_STATS_GET error: res=0x%08X\n", v2, v3, v4, v5, 2u);
}

void SetLocalHistogramsEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetLocalHistogramsEnabled()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to enable local histogram metadata (res=0x%08X)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to enable local histogram (res=0x%08X)\n", v2, v3, v4, v5, 2u);
}

void SetDynamicVoltageEnable()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetDynamicVoltageEnable error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void EnableIRFramesToPDE()
{
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: EnableIRFramesToPDE failed: %d, result=0x%08X\n\n", 67109376, v2);
}

void SetSIFROverrideMode()
{
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: SetSIFROverrideMode failed to set: %d, result=0x%08X\n\n", 67109376, v2);
}

void SetSplitPDOverrideMode()
{
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: SetSplitPDOverrideMode failed to set: %d, result=0x%08X\n\n", 67109376, v2);
}

void SetAPSActuator()
{
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: SetAPSActuator failed to set: %d, result=0x%08X\n\n", 67109376, v2);
}

void SetMasterSlaveAPSFocus()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetMasterSlaveAPSFocus error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to set master/slave focus while streaming is active\n\n", v2, v3, v4, v5, v6);
}

void SetMasterSlaveContrastFocus()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetMasterSlaveContrastFocus error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetLPDPFilterEnable()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetCameraControl error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetHighSpeedOutputLevel()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetHighSpeedOutputLevel error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetLinkFrequencyIndex()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetMIPIFrequencyIndex error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetTestPattern()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetTestPattern error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetLPDPEqualization(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetRawImageProcessStillFlowEnabled()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "CISP_CMD_CH_RAW_FRAME_PROCESS_STILL_FLOW error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetReplayFrame(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - GetPlatformInfo returns NULL\n\n", a5, a6, a7, a8, 2u);
}

void SetReplayFrame()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "CISP_CMD_CH_REPLAY error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void SetJasperBuiltInSequence()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: SetJaperBuiltInSequence %d failed: 0x%08X\n\n", 67109376, v2);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: SetPeridotBuiltInSequence %d failed: 0x%08X\n\n", 67109376, v2);
}

void SetTimeOfFlightConfiguration()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Got unsupported projector mode (%d), turning projector off.\n", v2, v3, v4, v5, 2u);
}

void SetHDRFusionEnable()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - FormatIndex %d doesn't support SIFR mode\n", v2, v3, v4, v5, 2u);
}

void SetHDRFusionEnable(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetSwitchingFormatIndex()
{
  OUTLINED_FUNCTION_32(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - No context switch list available for channel (%d)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetContextSwitch() failed. CFErrorRef err = 0x%x\n", v2, v3, v4, v5, 2u);
}

void SetSwitchingFormatIndex(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - context switch not available\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to parse switching format index\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Param Err\n", a5, a6, a7, a8, 2u);
}

void SetSwitchingFormatIndex(uint64_t a1)
{
  OUTLINED_FUNCTION_26(a1, *MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_31();
  OUTLINED_FUNCTION_2_0(&dword_24680F000, v1, v2, "Min frame rate for context switch out of range (%f)\n", v3, v4, v5, v6, v7);
}

{
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  OUTLINED_FUNCTION_26(a1, *MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_31();
  OUTLINED_FUNCTION_2_0(&dword_24680F000, v1, v2, "Max frame rate for context switch out of range (%f)\n", v3, v4, v5, v6, v7);
}

{
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  OUTLINED_FUNCTION_26(a1, *MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_31();
  OUTLINED_FUNCTION_2_0(&dword_24680F000, v1, v2, "Max allowed frame rate for context switch out of range (%f)\n", v3, v4, v5, v6, v7);
}

void SetActiveNondisruptiveSwitchingFormats()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetActiveContextSwitchMode() call fail. Err = 0x%x\n", v2, v3, v4, v5, 2u);
}

void CopyFocusPixelMap(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CopyAbsoluteColorCalibrations(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CopyFlashCalibrationData()
{
  OUTLINED_FUNCTION_36();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Failed to create the calibration data for the flash strobe: result=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "GetStrobeLEDCalibrationValues error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetUnsynchronizedSensorRawOutputBufferPool(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetFocusBehavior()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetFocusMultiCamBehavior error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetExclaveTestSuite()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Invalid channel is trying to test Exclave (camChannel:%u)\n", v2, v3, v4, v5, 2u);
}

void SetMainToSIFRFrameRateRatio()
{
  OUTLINED_FUNCTION_37();
  OUTLINED_FUNCTION_38();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Invalid SIFR frame skip ratio (%d)\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Couldn't set SIFR skip interval, error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetAWBTemporalStabilizationEnabled()
{
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "Couldn't set AWB temporal stabilization (enabled=%d), error: 0x%08X\n\n", 67109376, v2);
}

void CopyDCNUCVPixelBuffer(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - DCNU pixel buffer not available\n", a5, a6, a7, a8, 2u);
}

void SetExternalSyncModeEnabled()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableExternalSyncMode error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "EnableExternalSyncMode not available while streaming\n", v2, v3, v4, v5, v6);
}

void SetMLVNRConfiguration()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Missing enter criteria for auto mode\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Missing enter total gain threshold for auto mode\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Missing enter frame rate threshold for auto mode\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Missing exit criteria for auto mode\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Missing exit total gain threshold for auto mode\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Missing exit frame rate threshold for auto mode\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Missing ramp down count for auto mode\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Couldn't set MLVNR controls, error: 0x%08X\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unrecognized mode selected\n", v2, v3, v4, v5, v6);
}

void SetPrimaryFrameSkip()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Invalid primary frame skip value received, ratio=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Couldn't set primary skip ratio, error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void SetPrimaryFrameSkip(uint64_t a1, CFArrayRef *a2, NSObject *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  int v4 = *(_DWORD *)(a1 + 132);
  int Count = CFArrayGetCount(*a2);
  int v6 = 136315650;
  uint8_t v7 = "SetPrimaryFrameSkip";
  __int16 v8 = 1024;
  int v9 = v4;
  __int16 v10 = 1024;
  int v11 = Count;
  _os_log_error_impl(&dword_24680F000, a3, OS_LOG_TYPE_ERROR, "%s - Couldn't set primary frame skip on channel=%u, Stream is synchronized! ActiveSyncArraySize:%u\n", (uint8_t *)&v6, 0x18u);
}

void SetActiveNondisruptiveStreamingFormats(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid context switch list\n", a5, a6, a7, a8, 2u);
}

void SetActiveNondisruptiveStreamingFormats()
{
  OUTLINED_FUNCTION_32(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - no list found for ch=%u formatIndex=%u\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - failed to enable context switching ch=%u ret=0x%08x\n", v2, v3, v4);
}

void CopyStreamSensorRawOutputBufferPoolRequirements()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - failed to get sensor raw pool info ch=%u ret=0x%08x\n", v2, v3, v4);
}

void SetStreamSensorRawOutputBufferPools()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to enable SIFR raw common pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void SetStreamSensorRawOutputRetainedBufferCounts(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to resize hires raw pool\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to resize raw pool\n", a5, a6, a7, a8, 2u);
}

void SetStreamSensorRawOutputRetainedBufferCounts()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - failed to resize thumbnail raw pool, CFErrorRef err = %d, clientRetainCount=%d\n", v2, v3, v4);
}

void CopyCalibratedRotationAngle()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Couldn't get rotation correction calibration, error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetTorchBeamWidth(float *a1)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_28(*a1);
  OUTLINED_FUNCTION_7(&dword_24680F000, v1, (uint64_t)v1, "Couldn't set torch beam width (width=%f), error: 0x%08X\n\n", v2);
}

void SetMultiIlluminantWhiteBalanceEnabled()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableAWBMultiIlluminant error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void SetMaximumFrameRateForBufferAllocation(uint64_t a1)
{
  OUTLINED_FUNCTION_26(a1, *MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_31();
  OUTLINED_FUNCTION_2_0(&dword_24680F000, v1, v2, "Maximum frame rate for buffer allocation is out of range (%f)\n", v3, v4, v5, v6, v7);
}

void SetMaximumFrameRateForBufferAllocation(float *a1)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_28(*a1);
  OUTLINED_FUNCTION_7(&dword_24680F000, v1, (uint64_t)v1, "Couldn't set max frame rate for buffer allocation (%f), error: 0x%08X\n\n", v2);
}

void SetSIFRControlMode()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "FormatIndex %d doesn't support SIFR mode\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPDevice::GetCameraConfig()\n", v2, v3, v4, v5, v6);
}

void SetCameraControlsCacheExpiryDuration(uint64_t a1)
{
  OUTLINED_FUNCTION_26(a1, *MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_31();
  OUTLINED_FUNCTION_2_0(&dword_24680F000, v1, v2, "Expiry duration cannot be negative (%f)\n", v3, v4, v5, v6, v7);
}

void SetCameraControlsCacheExpiryDuration()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetCameraControlsCacheExpiryDuration error: 0x%08X\n", v2, v3, v4, v5, v6);
}

void SetDeskViewEnabled()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void StartJasperForInternalStreaming()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Could not start internal Jasper streaming (channel=%d): err=%d\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not set multiple output mode (internal jasper mode): err=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not set TOF preset index(internal jasper mode): err=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not set defer addition of attachments: err=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not reserve channel(internal jasper mode): res=%x\n", v2, v3, v4, v5, 2u);
}

void StartJasperForInternalStreaming(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPCaptureStreamStartInternal()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to start streaming on channel %d.\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to inform assistant. (res=0x%08X)\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Could not start H16ISPFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Failed to activate graph: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - SetAPSMode error. res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableAEStageDetect error. res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableDPMAssistedAE error. res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableDPM error. res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Could not SetGainCap = 0x%08X: res=0x%08X\n\n", 67109376, v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to change the output scaler. (res=%08x) \n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to sets up ISP active region. (res=%08x) \n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Error configuring edge-map coefficients: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Error configuring edge-map: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Failed to configure jasper frames\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not enable ProRes, res=0x%08X \n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - addBufferPoolToFrameReceiver (RAW) error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - SetScalerChromaSampleOffset: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - addBufferPoolToFrameReceiver (YUV) error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Could not set multi camera zoom factor: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Error configuring stream selection: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109376;
  OUTLINED_FUNCTION_23();
  OUTLINED_FUNCTION_22(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - SetCameraControl(%d) error: res=0x%08X\n\n", (uint8_t *)v2);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109376;
  OUTLINED_FUNCTION_23();
  OUTLINED_FUNCTION_22(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - SetCameraControl(%d) error: res=0x%08X\n\n", (uint8_t *)v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - ConfigSensorFormat error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableFullResCapture error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableLocalThumbnailRawBufferMode error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableLocalRawBufferMode error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, " Unable to stop vibe mitigation\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Could not create H16ISPFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not read the SIF error count res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Could not enable ALS2: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableHighFrameRateAF error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - SetPrimaryBESConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Error configuring raw preview config: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Error configuring TimeMachine depth: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - UpdateChannelConfigCache error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to enable STATFE thumbnail metadata on channel=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109376;
  OUTLINED_FUNCTION_23();
  OUTLINED_FUNCTION_22(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - WritePropertyValue(capstream->camChannel, 0x114, %d) error: 0x%08X\n\n", (uint8_t *)v2);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;

  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - WritePropertyValue(capstream->camChannel, 0x55A, %u) error: 0x%08X\n\n", 67109376, v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - SetAPSManualOffset error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableDACClamp error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableAPSModeSwitch error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;

  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - WritePropertyValue(capstream->camChannel, 0x52A, %u) error: 0x%08X\n\n", 67109376, v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - CISP_CMD_CH_OIS_ACTIVE_PREVIEW_LIMIT error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109376;
  OUTLINED_FUNCTION_23();
  OUTLINED_FUNCTION_22(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableStaticLUTForLTM(capstream->camChannel, %d) error: 0x%08X\n\n", (uint8_t *)v2);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109376;
  OUTLINED_FUNCTION_23();
  OUTLINED_FUNCTION_22(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - WritePropertyValue(capstream->camChannel, 0x202, %d) error: 0x%08X\n\n", (uint8_t *)v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - WritePropertyValue(capstream->camChannel, 0x902, 0) error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableSlowSyncFlash error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableFirmwareFocusHint error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableNewCBAFStats error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - EnableFESAutoAdjust error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Stream was not included in multi camera session\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - HW sync master must be started first\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Failed to configure exclave graph: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart - Graph manager already exists\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureStreamStartInternal(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Warning - unable to locate Jasper stream, but AF assistance is enabled\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid first frame timer\n", a5, a6, a7, a8, 2u);
}

void H16ISPCaptureStreamStartInternal(float *a1)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_28(*a1);
  OUTLINED_FUNCTION_7(&dword_24680F000, v1, (uint64_t)v1, "H16ISPCaptureStreamStart - Could not Initial ZoomFactor = %10.5f: res=0x%08X\n\n", v2);
}

void StopJasperForInternalStreaming()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not release channel(internal jasper mode): res=%x\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_32(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Could not stop internal Jasper streaming (channel=%d): err=%d\n", v2, v3, v4);
}

void StopJasperForInternalStreaming(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPCaptureStreamStopInternal()
{
  OUTLINED_FUNCTION_20(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - StillImageCaptureFailure (CH%d, pending count=%d)\n\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Failed to send general fault readings to the remote service assistant (channel=%d): 0x%08X\n\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Failed to send SIF Info to the  remote service assistant (channel=%d): 0x%08X\n\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - [Exclaves]: Unable to stop exclave streams, ret=0x%08X, channel=%d \n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStop - HW sync master must be stopped last\n\n", v2, v3, v4, v5, v6);
}

void SetDefaultFormatIndexConfiguration()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetCameraConfig error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void CopyGroupExtrinsics(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *long long buf = 0;
  *a2 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "H16ISPCaptureCopyGroupExtrinsics: Failed to get Jasper Extrinsics\n", buf, 2u);
}

void SetGroupActiveStreams(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetGroupMinSkippingRatio()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetMinSkippingRatio - SetMinimumFrameSkippingRatio error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Cannot change minimum skipping ratio after stream has started\n", v2, v3, v4, v5, v6);
}

void SetGroupMaxSlaveStreams()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetGroupMaxSlaveStreams - SetMultiCamSlaveProperties error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetGroupMaxSlaveTimeMachines()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetGroupMaxSlaveTimeMachines - SetMultiCamTimeMachineProperties error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetMidFrameSynchronizationEnabled()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetMidFrameSynchronizationEnabled - SetMultiCamSyncOffset error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetSensorRawOutputBufferPool(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetGroupNondisruptiveSwitchingFormatIndices()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - channel %d format switching is not available without current format setting\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - No context switch list available for channel (%d)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetContextSwitch() call fail. res = 0x%x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - channel %d failed to parse switching format index\n", v2, v3, v4, v5, 2u);
}

void SetAEMatchIntegrationTimes(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetAEMatchIntegrationTimes()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set multiCamera exposure matching, double result = 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void SetSynchronizedStreamsSensorRawOutputBufferPools()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to initialize shared pools ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void SetSynchronizedStreamsSensorRawOutputRetainedBufferCounts(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetSynchronizedStreamsSensorRawOutputRetainedBufferCounts()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - failed to resize thumbnail raw pool, CFErrorRef err = %d, clientRetainCount=%d\n", v2, v3, v4);
}

void SetGroupAEWindowParams()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetMultiCamAEWindowParams failed, result=0x%08x\n\n", v2, v3, v4, v5, 2u);
}

void SetGroupAFWindowParams()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetMultiCamAFWindowParams failed, result=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_24();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - unexpected number of AF window parameters: count = %ld\n", v2, v3, v4, v5, 2u);
}

void SetGroupAFWindowParams(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetGroupROIForCameraControls()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetMultiCamROIForCameraControls failed, result=0x%08x\n\n", v2, v3, v4, v5, 2u);
}

void SetGroupLumaHistogramROI()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetMultiCamLumaHistogramROI failed, result=0x%08x\n\n", v2, v3, v4, v5, 2u);
}

void GroupStillImageCaptureNow(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void GroupStillImageCaptureNow()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - command 0x%x error by 0x%x\n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - sCIspCmdChBracketingTuningSet error 0x%x\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - AllocateAndSendOneShotBuffers error 0x%x\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to send still image buffer from hires raw pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetAEBracketingMode error by 0x%x\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - sending sCIspCmdChCaptureConfig error by 0x%x\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - AddCntxSwRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetMultiCamConfiguration(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Unable to prioritize channel registration.\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Unable to set MultiCam configuration while streaming is active.\n", a5, a6, a7, a8, 2u);
}

void SetTOFAutoFocusEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Unexpected problems with Jasper stream. Uncalibrated jasper?\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Failed to start Jasper stream for internal streaming\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Bypassing jasper start because its already running\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Failed to stop Jasper stream for internal streaming\n", a5, a6, a7, a8, 2u);
}

void SetDARTCacheParameters()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: Missing entries in dictionary passed for kFigCaptureDeviceProperty_DARTCacheParameters property\n\n", v2, v3, v4, v5, v6);
}

void SetSensorAgileClockingEnable()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ISP_EnableMIPIClockAdjustments error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetProcessingSessionDefaultProcessingParameters()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Vision parameters size exceeded maximum supported\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Warp matrix size exceeded maximum supported\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Mesh size exceeded maximum supported\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "MeshLTM size exceeded maximum supported\n\n", v2, v3, v4, v5, v6);
}

void CopyProcessingSessionDefaultProcessingParameters(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void CopyProcessingSessionSupportedOutputs(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPProcessingSessionCreate()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Invalid session type %d \n\n", v2, v3, v4, v5, 2u);
}

void H16ISPProcessingSessionCreate(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void LogCaptureDeviceEvent(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void LogCaptureDeviceEvent()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "failed, event-logging array is not set up correctly.\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_1()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Error creating H16ISPDeviceController object: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_2()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Error getting device array object\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_3()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "No H16ISP Capture Device Available\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_4()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Error: Could not power on camera: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_5()
{
  OUTLINED_FUNCTION_37();
  OUTLINED_FUNCTION_38();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate verbose logging may affect timing (flags=0x%08x)\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_6()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Failed to start work processor: %x\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_7()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - Property write 1 1 3 for bringup - error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_8()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - Property write 1 0x1426 0 for bringup - error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_9()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - Property write 1 0x1425 0 for bringup - error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_10()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - Property write 0 1 3 for bringup - error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_11()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - Property write 0 0x1426 0 for bringup - error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_12()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - Property write 0 0x1425 0 for bringup - error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_13()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Warning: no valid streams detected\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_14()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109376;
  OUTLINED_FUNCTION_23();
  OUTLINED_FUNCTION_22(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - WritePropertyValue(0, 0x1b03, %d) error: 0x%08X\n\n", (uint8_t *)v2);
}

void H16ISPCaptureDeviceCreate_cold_15()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109376;
  OUTLINED_FUNCTION_23();
  OUTLINED_FUNCTION_22(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - WritePropertyValue(0, 0x1b02, %d) error: 0x%08X\n\n", (uint8_t *)v2);
}

void H16ISPCaptureDeviceCreate_cold_16()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Error: Could not get module params - chan: %d, res: 0x%08X\n", v2, v3, v4);
}

void H16ISPCaptureDeviceCreate_cold_17()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Error: InitSupportedFormatsForCaptureStream found no supported formats for channel %d\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_18()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - EnableAPSOffsetCalculation error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_19()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109376;
  OUTLINED_FUNCTION_23();
  OUTLINED_FUNCTION_22(&dword_24680F000, v0, v1, "H16ISPCaptureDeviceCreate - WritePropertyValue(capstream->camChannel, 0x140D, %d) error: 0x%08X\n\n", (uint8_t *)v2);
}

void H16ISPCaptureDeviceCreate_cold_20()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Error: GetRelativeZoomFactor error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_21()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "Error: GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_22()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Error: Could not query the number of cameras\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_23(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPCaptureDeviceCreate_cold_24()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - unable to get kext exclave status ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void H16ISPCaptureDeviceCreate_cold_25()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Error: CFWriteStreamOpen failed.\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_26()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Error: Could not open firmware logging output file. Routing firmware logs to info logger\n\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceCreate_cold_27()
{
  int v2 = 136315650;
  OUTLINED_FUNCTION_30();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - Failed to register device ID '%s' with remote assistant err=0x%08x\n", v2, v3, v4);
}

void H16ISPCaptureDeviceCreate_cold_28(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPCaptureDeviceCreate_cold_29()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Unable to connect to assistant\n\n", v2, v3, v4, v5, v6);
}

void InitSupportedFormatsForCaptureStream(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136315138;
  *a2 = "InitSupportedFormatsForCaptureStream";
  OUTLINED_FUNCTION_4_0(&dword_24680F000, a3, (uint64_t)a3, "%s - context switch list creation error\n", a1);
}

void DCNUInit(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPCaptureDeviceInvalidate(const __CFString *a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v4 = 136315138;
  CStringPtr = CFStringGetCStringPtr(a1, 0);
  OUTLINED_FUNCTION_4_0(&dword_24680F000, a2, v3, "H16ISPCaptureDevice: LogCaptureDeviceEvent error: %s\n\n", (uint8_t *)&v4);
}

void H16ISPCaptureDeviceInvalidate()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: LogCaptureDeviceEvent CFPropertyListWrite failed.\n\n", v2, v3, v4, v5, v6);
}

void MyH16ISPDeviceMessageNotification()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "MyH16ISPDeviceMessageNotification: Bypassing notification on invalid device\n", v2, v3, v4, v5, v6);
}

void LockStreamMutexes(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void UnlockStreamMutexes(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void MyH16ISPServicesRemoteNotification()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Connection interrupted with remote server\n", v2, v3, v4, v5, v6);
}

void MyH16ISPFrameReceivedProc()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "FigBufferQueueEnqueue error: %d\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "FigBufferQueueEnqueue (still image buffer queue) error: %d\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to lock base address cvret=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "FigSampleBufferCreateForImageBuffer error: %d\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "MyH16ISPFrameReceivedProc - Didn't get YUV+META buffers\n\n", v2, v3, v4, v5, v6);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Invalid thumbnail downsample values! X=%hu, Y=%hu\n", v2, v3, v4);
}

void MyH16ISPFrameReceivedProc(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - metadata output copy allocation failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Semantic Mask dictionary allocation failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Failed to grab anfd results from FD buffer\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Cannot send semantic masks because FD buffer doesn't have valid sensorCropRect!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to create semantic mask info attachment dictionary!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to get current ISP camera time for semantic buffer timestamp\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid first frame timer\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - metadata dictionary allocation failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - could not create sensor crop rect dictionary!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - could not create valid buffer rect dictionary!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - received an ANST thumbnail buffer without associated metadata!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - received an HITH buffer without associated metadata!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - metadata dictionary allocation failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - format number allocation failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - could not create sensor crop rect dictionary!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - could not create valid buffer rect dictionary!\n", a5, a6, a7, a8, 2u);
}

void LightSourceMaskInfoAttach(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - metadata dictionary allocation failed\n", a5, a6, a7, a8, 2u);
}

void LightSourceMaskVersatileBayerPatternAttach()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - invalid first pixel value = %u... assuming GR\n", v2, v3, v4, v5, 2u);
}

void ImageRegistrationInfoAttach(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - metadata dictionary allocation failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - image registration info dictionary allocation failed\n", a5, a6, a7, a8, 2u);
}

void ApplyNoiseReductionConfiguration()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetMBNRConfiguration error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableMBNR error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - CH%d: preset %d disabled SubBandSplit. MBNR is not supported\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetLCEStrength error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetSharpness error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "SetRNFStrength error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void AllocateAndSendOneShotBuffers()
{
  OUTLINED_FUNCTION_32(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "AllocateAndSendOneShotBuffers (channel %d): Allocation failed (res=%08x)\n", 67109376, v2);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_32(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Error from AllocateAndSendOneShotBuffers(), CH %d 0x%x\n", v2, v3, v4);
}

void LaunchStillImageCapture()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to send the capture command to firmware  error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void ConfigureExternalStrobeParameters()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: failed to set external strobe parameters - result=0x%X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "H16ISPCaptureDevice: failed to get external strobe parameters - result=0x%X\n\n", v2, v3, v4, v5, v6);
}

void AddCntxSwRawPoolToFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - addBufferPoolToFrameReceiver return error 0x%X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - GetPoolInfoExtended return error 0x%X\n", v2, v3, v4, v5, 2u);
}

void AddCntxSwRawPoolToFrameReceiver(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void GetFormatForHiResRaw()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "AddCntxSwRawPoolToFrameReceiver - Unsupported companding type %u\n", v2, v3, v4, v5, v6);
}

void ActivateFaceDetectionOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateFaceDetectionOutputInFrameReceiver - pFrameReceiver->StartFaceDetect: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateFaceDetectionOutputInFrameReceiver - pFrameReceiver->addBufferPoolToFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateFaceDetectionOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void SetMetadataSectionEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ActivatePrimaryScalerOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivatePrimaryScalerOutputInFrameReceiver - SetScalerChromaSampleOffset: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SendFWInitialBuffers res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivatePrimaryScalerOutputInFrameReceiver - SetSensorInterfacePixelFormat error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivatePrimaryScalerOutputInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivatePrimaryScalerOutputInFrameReceiver - SetPrimaryBESConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pFrameReceiver->addBufferPoolToFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "ActivatePrimaryScalerOutputInFrameReceiver - Failed to get pool attributes\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unknown PixelFormat 0x%x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivatePrimaryScalerOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ActivateSecondaryScalerOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateSecondaryScalerOutputInFrameReceiver - Error configuring output rate: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateSecondaryScalerOutputInFrameReceiver - SetScalerChromaSampleOffset: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateSecondaryScalerOutputInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SendFWInitialBuffers res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetSecondaryBESConfig error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pFrameReceiver->addBufferPoolToFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateSecondaryScalerOutputInFrameReceiver - SetAuxiliaryScalerSource error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "ActivateSecondaryScalerOutputInFrameReceiver - Failed to get pool attributes\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unknown PixelFormat 0x%x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateSecondaryScalerOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ActivateIntermediateTapOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateIntermediateTapOutputInFrameReceiver - Error configuring output rate: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SendFWInitialBuffers res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateIntermediateTapOutputInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateIntermediateTapOutputInFrameReceiver - Error configuring YCC output: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateIntermediateTapOutputInFrameReceiver - Error configuring YCC crop: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pFrameReceiver->addBufferPoolToFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "ActivateIntermediateTapOutputInFrameReceiver - Failed to get pool attributes\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unknown PixelFormat 0x%x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateIntermediateTapOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ActivateStillImageOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - SetScalerChromaSampleOffset: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - AddSplitPixelDataToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - AddFocusPixelDataToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - AddSashimiRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - AddSushiRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - SetBufferPoolConfiguration(poolType:%d) error: 0x%08X\n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - SetSensorInterfacePixelFormat error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - AddThumbnailRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - Error configuring Capture output: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pFrameReceiver->addBufferPoolToFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - Failed to get pool attributes\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unknown PixelFormat 0x%x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - Error configuring Capture output crop: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ActivateStillImageIntermediateTapOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_36();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - CISP_CMD_CH_BUFFER_POOL_CONFIG_GET error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - AddFocusPixelDataToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - AddSashimiRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - AddSushiRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - pFrameReceiver->addBufferPoolToFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - ConfigureStillImageIntermediateTapDMA Error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "ConfigureStillImageIntermediateTapDMA - Failed to get pool attributes\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unknown PixelFormat 0x%x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - CISP_CMD_CH_BUFFER_POOL_CONFIG_GET error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageIntermediateTapOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ActivateStillImageRawOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - AddSplitPixelDataToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - AddFocusPixelDataToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - AddSashimiRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - AddSushiRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - SetSensorInterfacePixelFormat error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - Error configuring Capture output: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - Error configuring Capture output crop: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageRawOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ActivateVisPipeOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateVisPipeOutputInFrameReceiver - pFrameReceiver->addBufferPoolToFrameReceiver: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateVisPipeOutputInFrameReceiver - EnableVisPipeOutput error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_37();
  OUTLINED_FUNCTION_38();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateVisPipeOutputInFrameReceiver - VisRawBitDepth  error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateVisPipeOutputInFrameReceiver - EnableDPM error (trying to disable): 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateVisPipeOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ActivatePointCloudOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateRawInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateRawInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ConfigureExclaveGraph(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Exclave algos are enabled but no Conclaves are running! (treat as fatal)\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves] Skipping configuring Exclave graph, Exclave Algorithms are not enabled!\n", a5, a6, a7, a8, 2u);
}

void ConfigureExclaveGraph()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: Failed to create exclave graph manager, res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - [Exclaves]: unable to start exclave streams, res=0x%08X, channel=%d \n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: failed to configure exclave streams, treat as fatal 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: Failed to get Exclave camera config for channel %d\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - [Exclaves]: Failed to get camera config for channel %d, res=0x%08X\n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to activate exclave graph (FRONT_IR): 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to activate exclave graph (FRONT_RGB): 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Invalid channel is trying to config Exclave Graph (camChannel:%u)\n", v2, v3, v4, v5, 2u);
}

void ActivateMetadataOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableANSTThumbnail failed with ret=0x%08x\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "unable to add ANST Thumbnail buffer pool ret=0x%08x\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableHITH failed with ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - unable to add HITH buffer pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableDesGenFlow2Features failed with ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - unable to add Keypoint Descriptor Data pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableStatsFEThumbnailMask failed with ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - unable to add Light Source Mask pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void DeactivatePrimaryScalerOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivatePrimaryScalerOutputInFrameReceiver: Error retrieving buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivatePrimaryScalerOutputInFrameReceiver: EnableScalerOutput: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void DeactivateSecondaryScalerOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateSecondaryScalerOutputInFrameReceiver: Error retrieving buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateSecondaryScalerOutputInFrameReceiver: EnableScalerOutput: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void DeactivateIntermediateTapOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateIntermediateTapOutputInFrameReceiver: Error retrieving buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void DeactivateStillImageOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageOutputInFrameReceiver: Error retrieving focus pixel buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageOutputInFrameReceiver: Error retrieving sashimi raw buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageOutputInFrameReceiver: Error retrieving sushi raw buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageOutputInFrameReceiver: Error retrieving still buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void DeactivateStillImageIntermediateTapOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageIntermediateTapOutputInFrameReceiver: Error retrieving focus pixel buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageIntermediateTapOutputInFrameReceiver: Error retrieving sashimi raw buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageIntermediateTapOutputInFrameReceiver: Error retrieving sushi raw buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageIntermediateTapOutputInFrameReceiver: Error retrieving still buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void DeactivateStillImageRawOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageRawOutputInFrameReceiver: Error retrieving focus pixel buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageRawOutputInFrameReceiver: Error retrieving sashimi raw buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageRawOutputInFrameReceiver: Error retrieving sushi raw buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "DeactivateStillImageRawOutputInFrameReceiver: Error retrieving still buffers from firmware: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void DeactivateMetadataOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "EnableANSTThumbnail failed with ret=0x%08x\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableSemanticMasks failed with ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableHITH failed with ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableDesGenFlow2Features failed with ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableStatsFEThumbnailMask failed with ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void GenerateBufferTagsForOutput(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ColorRangeForOutput()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v3) = 136315906;
  OUTLINED_FUNCTION_2_1();
  LOWORD(v6) = v0;
  HIWORD(v6) = v1;
  OUTLINED_FUNCTION_16(&dword_24680F000, v1, v2, "%s - Unknown YCbCrMatrix (%d), pixel format=0x%x matrix %d\n", v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Log gamma is not supported for full range color\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "YCbCrMatrix_ITU_R_709_2 is not supported for full range color\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unknown pixel format=0x%x\n", v2, v3, v4, v5, 2u);
}

void AddRawPoolToFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "AddRawPoolToFrameReceiver - addBufferPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_37();
  OUTLINED_FUNCTION_38();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "AddRawPoolToFrameReceiver - Unsupported companding type %d\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "AddRawPoolToFrameReceiver - GetRawBufferConfig error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "AddRawPoolToFrameReceiver - addSharedBufferPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

void AddThumbnailRawPoolToFrameReceiver(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void AddThumbnailRawPoolToFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - addBufferPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unknown raw thumbnail format type %d: \n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - GetPoolInfoExtended error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void AddSplitPixelDataToFrameReceiver(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void AddSplitPixelDataToFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - GetPoolInfoExtended error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Error retrieving CameraConfig for ch=%d res=0x%08X\n\n", v2, v3, v4);
}

void resizeStillMetaPool()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - unable to modify still meta pool buffer count %d, res = %d\n", v2, v3, v4);
}

void resizeThumbnailRawPool()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - unable to modify thumbnail pool buffer count %d, res = %d\n", v2, v3, v4);
}

void StartExclaveStreams(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Cannot set FaceID AttentionDetection attention requirement to true\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: failed to get pearl camera calibration info!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: failed to configure exclave PDP\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: failed to configure exclave AE\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: sending algo enable cmd to EK failed!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: RGB concurrent cmd Failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: RGB ISP Mgr Algo Enable Failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: failed to get channel distortion info! Extrinsics info for this channel will not be correct!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: cannot configure face kit\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: failed to get sensor info!\n", a5, a6, a7, a8, 2u);
}

void StartExclaveStreams()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - channel=%u failed to register for preference notifications\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_35(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: ISP Mgr IR CH Start Failed, result=%d \n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_35(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: Cannot set FaceID AttentionDetection Periocular support to %{BOOL}d\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - [Exclaves]: Cannot send channel info! channel=%u, result=%d\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Cannot configure Exclave PDP tberr=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_35(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: ISP Mgr RGB CH Start Failed, result %d\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_35(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - [Exclaves]: Send RGB Perception Framerate failed!, result=%d, channel=%d\n", v2, v3, v4);
}

void ConfigureExclaveAutoExposure(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ConfigureExclaveAutoExposure()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: Cannot get initial AE settings, ipcRet %d\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - [Exclaves]: failure in setting initial AE setting for channel %d, res=0x%08X\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_35(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: Camera Config Set Failed, result %d \n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: Failed to get Exclave camera config for channel %d\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - [Exclaves]: Failed to get camera config for channel %d, res=0x%08X\n", v2, v3, v4);
}

void ExclavePreferenceApplyValues()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - channel=%u failed to set replay control\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - channel=%u failed to set yuv dump control\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - channel=%u failed to enable skip frame dump\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - channel=%u failed to enable filtration\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - invalid preference key for channel=%u\n", v2, v3, v4, v5, 2u);
}

void ExclavePreferenceApplyValues(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void AddMetadataOutputBufferPoolToFrameReceiver(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - missing buffer pool attributes\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to add buffer pool to frame receiver\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - missing client buffer pool\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to add buffer pool to frame receiver\n", a5, a6, a7, a8, 2u);
}

void RemoveMetadataOutputBufferPoolFromFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to remove buffer pool %d\n", v2, v3, v4, v5, 2u);
}

void HandleSecureStreamOutputConfig()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to stop exclave streams, res=0x%08x\n", v2, v3, v4, v5, 2u);
}

void HandleSecureStreamOutputConfig(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void HandleSecureStreamOutputConfig(uint8_t *a1, void *a2, NSObject *a3)
{
  *(_DWORD *)a1 = 136315138;
  *a2 = "HandleSecureStreamOutputConfig";
  OUTLINED_FUNCTION_4_0(&dword_24680F000, a3, (uint64_t)a3, "%s - Got an unsupported perception object string! Skipping.\n", a1);
}

void SetMetadataOutputConfiguration(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to send firmware the light source mask configuration\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to set keypoint descriptor data configuration\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to enable keypoint descriptor data output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to set light source mask configuration\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to set light source mask tunable configuration\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid downscale factor x property\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid downscale factor y property\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid generation mode property\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid bit bin mode property\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to set light source mask buffer pool configuration\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid pixel thresholds property\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - light source mask configuration cannot be set while output is enabled\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - failed to enable light source mask output\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - cannot change metadata output configuration while output is enabled\n", a5, a6, a7, a8, 2u);
}

void SetMetadataOutputConfiguration()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set ANST thumbnail buffer configuration, result: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set Hi-Res thumbnail buffer configuration, result: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set ANST semantic buffer configuration, result: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set semantic mask configuration, result=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to enable semantic mask output, result=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set deghosting configuration, result: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void SetMetadataOutputConfiguration(CFArrayRef *a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  CFArrayGetCount(*a1);
  v3[0] = 136315650;
  OUTLINED_FUNCTION_24();
  __int16 v4 = 1024;
  int v5 = 4;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - pixel thresholds array has too many elements: received %ld expected %d\n", (uint8_t *)v3, 0x1Cu);
}

void PrimaryAndSecondaryScalerConfigUpdateAtomically(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void PrimaryAndSecondaryScalerConfigUpdateAtomically()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - buffer pool of type=%d not found\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to update configuration ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void SetPrimaryScalerCrop()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set scaler crop ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void StopExclaveStreams(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void StopExclaveStreams()
{
  OUTLINED_FUNCTION_35(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: EK IR Channel stop failed %d \n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: Unable to stop EK RGB Channel, tberr=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: Streaming Channel not supported on exclaves, ch=%d\n", v2, v3, v4, v5, 2u);
}

void SetHITHFeatureConfiguration()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set Hi-Res Thumbnail configuration, result=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to enable Hi-Res Thumbnail output, result=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void SetANSTThumbnailFeatureConfiguration()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set ANST Thumbnail configuration, result=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to enable ANST Thumbnail output, result=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void LightSourceMaskTunableConfigurationSendToFirmware()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315650;
  OUTLINED_FUNCTION_12();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - downscale factor must be in range [0, 64]: downscaleFactorX=%u downscaleFactorY=%u\n", (uint8_t *)v1, 0x18u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - invalid bit bin mode value = %u\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - invalid generation mode value = %u\n", v2, v3, v4, v5, 2u);
}

void SetMetadataOutputFeatureEnabled(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SetMetadataOutputBufferPoolConfiguration(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid buffer pool attribute: width\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid buffer pool attribute: height\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - buffer pool does not meet minimum width/height requirements\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - invalid buffer pool type! must be pixel or data buffer pool\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - cannot change buffer pool configuration while output is enabled\n", a5, a6, a7, a8, 2u);
}

void IntermediateTapAndScalerConfigUpdateAtomically(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_1(&dword_24680F000, a1, a3, "%s - buffer pool of type=%d not found\n", a5, a6, a7, a8, 2u);
}

void IntermediateTapAndScalerConfigUpdateAtomically()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - buffer pool of type=%d not found\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - error configuring YCC/SCL config: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to get frame format info for pixelFormat=%u\n", v2, v3, v4, v5, 2u);
}

void ScalerOutputConfigUpdateAtomically(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ScalerOutputConfigUpdateAtomically()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - buffer pool of type=%d not found\n", v2, v3, v4, v5, 2u);
}

void ScalerOutputConfigUpdateAtomically(char a1, uint64_t a2, NSObject *a3)
{
  uint64_t v3 = "secondary";
  *(void *)((char *)&v4 + 4) = "ScalerOutputConfigUpdateAtomically";
  LODWORD(v4) = 136315650;
  if (a1) {
    uint64_t v3 = "primary";
  }
  WORD6(v4) = 2080;
  HIWORD(v4) = (_WORD)v3;
  OUTLINED_FUNCTION_29(&dword_24680F000, a2, a3, "%s - failed to update %s scaler configuration ret=0x%08x\n", (const char *)v4, *((const char **)&v4 + 1), (unint64_t)v3 >> 16);
}

void CopyMetadataOutputFeatureConfiguration(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ApplySlaveConfiguration()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ISP_SendCommand for CISP_CMD_CH_SLAVE_CAMERA_PROCESSING_CONFIG error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ISP_SendCommand for CISP_CMD_CH_FRAME_SKIPPING_RATIO error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ApplyColorSpaceConfiguration()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetAWBRGBColorspace Error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableHDRC Error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - LTMModeSet Error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - LTMGammaSet Error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void ConfigSensorFormat()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetSensorInterfacePixelFormat error: res=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void SetMetadataSectionRequired(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - parent property not enabled\n", a5, a6, a7, a8, 2u);
}

void ___ZL21CopyDCNUCVPixelBufferPK13__CFAllocatorPvP19H16ISPCaptureStreamP18H16ISPCaptureGroupP19H16ISPCaptureDevice_block_invoke_cold_1()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "failed to create metadata dictionary\n", v2, v3, v4, v5, v6);
}

void SetSIFRCommonPool()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to set SIFR raw common pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void H16ISPSensorRawPoolConfigurationGetBufferWidthAndHeight(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer width not found\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - pixel buffer height not found\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - width/height must not be zero\n", a5, a6, a7, a8, 2u);
}

void AddHiResRawPoolToFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to add hires buffer pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to add hires shared buffer pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void AddRawPlusPoolToFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to add raw plus shared buffer pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

void ActivateStillImageQuadraOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageQuadraOutputInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateStillImageQuadraOutputInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ActivateRawOutputInFrameReceiver()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateRawOutputInFrameReceiver - SetSensorInterfacePixelFormat error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateRawInFrameReceiver - AddRawPoolToFrameReceiver error: res=0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ActivateRawInFrameReceiver - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void Matrix<float>::operator-()
{
}

void Matrix<float>::MultAxBToC()
{
  __assert_rtn("MultAxBToC", "Matrix.hpp", 1562, "m_rows == C->Rows() && B.Cols() == C->Cols() && \"Output dimensions not legal\"");
}

{
  __assert_rtn("MultAxBToC", "Matrix.hpp", 1561, "m_cols == B.Rows() && \"Input dimensions not legal\"");
}

void ResetGroupSynchronization()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ResetGroupSynchronization - SetMinimumFrameSkippingRatio error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ResetGroupSynchronization - SetStatsMaster error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ResetGroupSynchronization - SetMaster error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "ResetGroupSynchronization - SetMasterSlaveSync error: 0x%08X\n\n", v2, v3, v4, v5, v6);
}

void ChannelMaskForSharedRawPool()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - invalid channel: wide=%d\n", v2, v3, v4, v5, 2u);
}

void ChannelMaskForSharedHiResRawPool()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - invalid channel(s): wide=%d swide=%d\n", v2, v3, v4);
}

void ChannelMaskForSharedRawPlusPool()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - invalid channel(s): tele=%d swide=%d\n", v2, v3, v4);
}

void SetSharedBufferPoolConfigurations()
{
  OUTLINED_FUNCTION_30();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - failed to %sable shared raw plus pool!\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_30();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - failed to %sable shared hires raw pool!\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_30();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - failed to %sable shared raw pool!\n", v2, v3, v4, v5, 2u);
}

void H16ISPProcessingSessionInvalidate()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "ISP Processing session ref passed is NULL\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "ISP Processing Session is invalid\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPProcessingSessionDestroy failed: no general processing session active\n", v2, v3, v4, v5, v6);
}

void H16ISPProcessingSessionCopyProperty(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Processing session is invalid\n", a5, a6, a7, a8, 2u);
}

void H16ISPProcessingSessionCopyProperty(const __CFString *a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v4 = 136315138;
  CStringPtr = CFStringGetCStringPtr(a1, 0);
  OUTLINED_FUNCTION_4_0(&dword_24680F000, a2, v3, "Unsupported property passed to ISP processing session :%s\n\n", (uint8_t *)&v4);
}

void H16ISPProcessingSessionSetProperty(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Processing session is invalid\n", a5, a6, a7, a8, 2u);
}

void FigSignalError(uint64_t a1, int a2, NSObject *a3)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  v3[0] = 67109378;
  v3[1] = a2;
  __int16 v4 = 2080;
  uint64_t v5 = a1;
  OUTLINED_FUNCTION_7(&dword_24680F000, a3, (uint64_t)a3, "FigSignalError: %d, %s\n\n", (uint8_t *)v3);
}

void H16ISPProcessingSessionPrepare(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not create GP frame receiver\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not start general processing frame receiver\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not activate the general processing params pool\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - general processing session type is not supported\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - general processing for camera channel already in progress\n", a5, a6, a7, a8, 2u);
}

void H16ISPProcessingSessionPrepare()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not start general processing 0x%x\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not activate the output metadata buffer pool 0x%x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not activate the StripVis output metadata buffer pool 0x%x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not create the general process frame receiver 0x%x\n", v2, v3, v4, v5, 2u);
}

void H16ISPProcessingSessionProcessBuffer(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Invalid parameters\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Invalid output descriptor array\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Invalid output params\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Session default type specific parameters NULL\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not create session specific type parameters\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Vision parameters exceed maximum supported size\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Warp matrix parameters exceed maximum supported size\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Processing session is invalid\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Primary scaler low resolution buffer provided without primary scaler buffer\n", a5, a6, a7, a8, 2u);
}

void H16ISPProcessingSessionProcessBuffer()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Mesh size exceeded maximum supported\n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "MeshLTM size exceeded maximum supported\n\n", v2, v3, v4, v5, v6);
}

void H16ISPProcessingSessionCompleteBuffers(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - ISP Processing Session is not prepared\n", a5, a6, a7, a8, 2u);
}

void H16ISPProcessingSessionCompleteBuffers()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - completeAllRequests failed 0x%x\n", v2, v3, v4, v5, 2u);
}

void MyH16ISPGeneralProcessFrameReceivedProc(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ISPProcessingSessionProcessBuffer()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "generalProcess failed: no general processing session active\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "generalProcess failed: input buffer is NULL\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "generalProcess failed: outputDescriptor is NULL\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "generalProcess failed: perFrameConfig is NULL\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "generalProcess failed: inputMetadataBuffer is not available for Bayer processing\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "inputParamsBufferPool is unavailable!\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "generalProcess failed:  kernel request failed 0x%08X\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "outputMetadataBufferPool is unavailable!\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Could not allocate output metadata buffer\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "StripVis outputMetadataBufferPool is unavailable!\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Could not allocate StripVis output metadata buffer\n", v2, v3, v4, v5, v6);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_20(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_12();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Buffer formats(in:0x%x out:0x%x) are not supported tileCount more than 1\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unexpected mesh VIS version (%d)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Could not allocate input params buffer\n", v2, v3, v4, v5, v6);
}

void ISPProcessingSessionProcessBufferGeneric()
{
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_0_0(&dword_24680F000, v0, v1, "generalProcess failed: 0x%08X\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "generalProcess failed: invalid params\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureDeviceRequestStreams()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - GetCameraConfig error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableSBS error: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_32(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Capture stream reserved for internal use (channel=%d)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_32(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Invalid capture stream (channel=%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISPCaptureDeviceRequestStreams(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPCaptureDeviceRelinquishStreams(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void SavePFLFile()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_19();
  OUTLINED_FUNCTION_4(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStop - Failed to save PFL state (channel=%d): 0x%08X\n\n", 67109376, v2);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Failed to retrieve PFL state (channel=%d): res=0x%08X\n\n", v2, v3, v4);
}

void ___ZL25H16ISPCaptureStreamCreatePK13__CFAllocatorP22OpaqueFigCaptureDevicePN6H16ISP12H16ISPDeviceEPP22OpaqueFigCaptureStream_block_invoke_cold_1(uint64_t a1, NSObject *a2, uint64_t a3)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  uint64_t v3 = *(void *)(a1 + 32);
  int v4 = *(_DWORD *)(v3 + 132);
  LODWORD(v3) = *(_DWORD *)(v3 + 76);
  v5[0] = 67109376;
  v5[1] = v4;
  __int16 v6 = 1024;
  int v7 = v3;
  OUTLINED_FUNCTION_22(&dword_24680F000, a2, a3, "StillImageCaptureFailure: (channel=%d, pending count=%d)\n\n", (uint8_t *)v5);
}

void H16ISPCaptureStreamInvalidate()
{
  OUTLINED_FUNCTION_32(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - [Exclaves]: Unable to stop exclave streams, ret=0x%08X, channel=%d \n\n", v2, v3, v4);
}

void H16ISPCaptureStreamStart()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureStreamStart: invalid device \n\n", v2, v3, v4, v5, v6);
}

void ___ZL8DCNUInitP19H16ISPCaptureDeviceP19H16ISPCaptureStream_block_invoke_cold_1()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "failed to read DCNU metadata\n", v2, v3, v4, v5, v6);
}

void ___ZL8DCNUInitP19H16ISPCaptureDeviceP19H16ISPCaptureStream_block_invoke_cold_2(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ___ZL8DCNUInitP19H16ISPCaptureDeviceP19H16ISPCaptureStream_block_invoke_cold_3()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "invalid DCNU image height\n", v2, v3, v4, v5, v6);
}

void ___ZL8DCNUInitP19H16ISPCaptureDeviceP19H16ISPCaptureStream_block_invoke_cold_4()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "failed to create DCNU pixel buffer\n", v2, v3, v4, v5, v6);
}

void ___ZL8DCNUInitP19H16ISPCaptureDeviceP19H16ISPCaptureStream_block_invoke_cold_5()
{
  OUTLINED_FUNCTION_24();
  OUTLINED_FUNCTION_25(&dword_24680F000, v0, v1, "%s - unexpected number of objects read from DCNU metadata file! expected=1 actual=%zu\n", v2, v3, v4, v5, 2u);
}

void ___ZL8DCNUInitP19H16ISPCaptureDeviceP19H16ISPCaptureStream_block_invoke_cold_6(uint64_t *a1, NSObject *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  uint64_t v2 = *a1;
  int v3 = 136315650;
  uint64_t v4 = "ReadDCNUMetadata";
  __int16 v5 = 2048;
  uint64_t v6 = 53176;
  __int16 v7 = 2048;
  uint64_t v8 = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - file size mismatch! expected=%lld actual=%lld\n", (uint8_t *)&v3, 0x20u);
}

void ___ZL8DCNUInitP19H16ISPCaptureDeviceP19H16ISPCaptureStream_block_invoke_cold_7(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPCaptureGroupCopyProperty()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureGroupCopyProperty: Invalid sync group\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureGroupSetProperty()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "H16ISPCaptureGroupSetProperty: Invalid sync group\n", v2, v3, v4, v5, v6);
}

void H16ISPCaptureGroupStop(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Unable to stop group with no streams currently running\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Invalid sync group\n", a5, a6, a7, a8, 2u);
}

void LightSourceMaskInfoCreateArray(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ImageRegistrationInfoCreateArray(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPMetadataDictCreatorGraphNode::onMessageProcessing(uint8_t *buf, uint64_t a2, _DWORD *a3, os_log_t log)
{
  int v4 = *(_DWORD *)(*(void *)a2 + 340);
  *(_DWORD *)long long buf = 67109120;
  *a3 = v4;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "Unexpected binning mode 0x%08X\n", buf, 8u);
}

void H16ISP::H16ISPMetadataDictCreatorGraphNode::H16ISPMetadataDictCreatorGraphNode(uint8_t *buf, void *a2, os_log_t log)
{
  *(_DWORD *)long long buf = 136315138;
  *a2 = "H16ISPMetadataDictCreatorGraphNode";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - pixelSize_um is zero!\n", buf, 0xCu);
}

void H16ISP::H16ISPGraphExclaveExitNode::onMessageProcessing(int a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = 136315394;
  uint64_t v3 = "onMessageProcessing";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - [Exclaves]: Reqid: 0x%08X No valid secure metadata available\n", (uint8_t *)&v2, 0x12u);
}

void H16ISP::H16ISPGraphFaceTrackingNode::onActivate(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "Error activating FaceTracking processing node\n", v1, 2u);
}

void H16ISP::H16ISPGraphFaceTrackingNode::onActivate(int *a1, NSObject *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *a1;
  int v3 = 136315394;
  __int16 v4 = "onActivate";
  __int16 v5 = 1024;
  int v6 = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - Unknown projector version=%d\n", (uint8_t *)&v3, 0x12u);
}

void H16ISP::H16ISPDeviceController::SetupDeviceController()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  int v0 = 136315138;
  uint64_t v1 = "SetupDeviceController";
  _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s - IONotificationPortCreate returned NULL\n", (uint8_t *)&v0, 0xCu);
}

{
  int v0;
  const char *v1;
  uint64_t v2;

  uint64_t v2 = *MEMORY[0x263EF8340];
  int v0 = 136315138;
  uint64_t v1 = "SetupDeviceController";
  _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s - IONotificationPortGetRunLoopSource returned NULL\n", (uint8_t *)&v0, 0xCu);
}

void H16ISP::H16ISPDeviceController::SetupDeviceController(unsigned __int8 *a1)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v1 = *a1;
  int v2 = 136315394;
  int v3 = "SetupDeviceController";
  __int16 v4 = 1024;
  int v5 = v1;
  _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s - Timed out waiting for the driver to register service, deviceArrived = %d\n", (uint8_t *)&v2, 0x12u);
}

void reportIsfResults()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void reportProjectorGmcResults()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void reportPeridotCoexRetries(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void reportIsfThreshold()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void reportGmcThreshold()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void reportGmcEflTolerance()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "Failed to send the %s event into the diagnostics system %08X\n\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPGraphExclavePerceptionNode::updateObjectDicts(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPGraphExclavePerceptionNode::onMessageProcessing(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Perception - Frame was unable to be queued!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - [Exclaves]: Perception - Frame was skipped!\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPGraphExclavePerceptionNode::onMessageProcessing(unsigned __int8 *a1, int a2, os_log_t log)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  int v4 = 136315650;
  uint64_t v5 = "onMessageProcessing";
  __int16 v6 = 1024;
  int v7 = a2;
  __int16 v8 = 1024;
  int v9 = v3;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - [Exclaves]: send to perception IDL failed, tberr=%u ipcret=%{BOOL}d\n", (uint8_t *)&v4, 0x18u);
}

void AppleH16PhotonDetectorServicesAssistant::SetupDevice(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IONotificationPortCreate returned NULL\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IONotificationPortGetRunLoopSource returned NULL\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPGraphExclaveRGBMotionDetectionNode::runMotionDetection(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "invalid rgb conclave client handle\n", v1, 2u);
}

void H16ISP::H16ISPGraphExclaveRGBMotionDetectionNode::runMotionDetection(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPGraphExclaveIRMotionDetectionNode::runMotionDetection(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "invalid ir conclave client handle\n", v1, 2u);
}

void H16ISP::H16ISPGraphExclaveIRMotionDetectionNode::runMotionDetection(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void MotionDetectionResultCreateDictionaryRepresentation(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void MatrixNxPts<3u,double>::CloneColumn()
{
}

void H16ISP::H16ISPGraphNodeMCTF::onActivate(int a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  int v2 = 136315394;
  int v3 = "onActivate";
  __int16 v4 = 1024;
  int v5 = a1;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - Could not create VT Temporal Filter Session! err=%d\n", (uint8_t *)&v2, 0x12u);
}

void H16ISP::VTOutputFrameCallback(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  int v2 = "VTOutputFrameCallback";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - No valid context info!\n", (uint8_t *)&v1, 0xCu);
}

void H16ISP::VTOutputFrameCallback(CMTime *a1, uint64_t a2, NSObject *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  uint64_t v4 = H16ISP::VTOutputFrameCallback(void *,int,unsigned int,CMTime,__CVBuffer *)::frameNumber;
  CMTimeEpoch v5 = *(void *)(a2 + 16);
  *(_OWORD *)&a1->value = *(_OWORD *)a2;
  a1->epoch = v5;
  int v6 = 136315650;
  int v7 = "VTOutputFrameCallback";
  __int16 v8 = 2048;
  uint64_t v9 = v4;
  __int16 v10 = 2048;
  Float64 Seconds = CMTimeGetSeconds(a1);
  _os_log_error_impl(&dword_24680F000, a3, OS_LOG_TYPE_ERROR, "%s - Expected frame: %llu, got: %lf\n", (uint8_t *)&v6, 0x20u);
}

void H16ISP::H16ISPGraphNodeMCTF::onMessageProcessing(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  int v2 = "onMessageProcessing";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - Graph message did not contain an image buffer!\n", (uint8_t *)&v1, 0xCu);
}

void H16ISP::H16ISPGraphNodeMCTF::onMessageProcessing(int a1, NSObject *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v2 = 136315650;
  uint64_t v3 = "onMessageProcessing";
  __int16 v4 = 2048;
  uint64_t v5 = H16ISP::H16ISPGraphNodeMCTF::onMessageProcessing(H16ISP::H16ISPFilterGraphMessage *)::frameNumber;
  __int16 v6 = 1024;
  int v7 = a1;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - VT Temporal Filter failed to Process Frame #%llu! err=%d\n", (uint8_t *)&v2, 0x1Cu);
}

void StopAudioCaptureSession()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "StopAudioCaptureSession: invalid context \n\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_4_1();
  OUTLINED_FUNCTION_2_0(&dword_24680F000, v0, v1, "AudioOutputUnitStop returned 0x%08lx\n\n", v2, v3, v4, v5, v6);
}

void H16ISPFlickerDetectorStartDataCollection(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "H16ISPFlickerDetectorStartDataCollection";
  _os_log_debug_impl(&dword_24680F000, log, OS_LOG_TYPE_DEBUG, "%s - Success\n", (uint8_t *)&v1, 0xCu);
}

void H16ISPFlickerDetectorStopDataCollection(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "H16ISPFlickerDetectorStopDataCollection";
  _os_log_debug_impl(&dword_24680F000, log, OS_LOG_TYPE_DEBUG, "%s - Success\n", (uint8_t *)&v1, 0xCu);
}

void H16ISPFlickerDetectorSetGain()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_14();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - Set Volume Scalar returned 0x%08lx\n \n", (uint8_t *)v1, 0x16u);
}

void H16ISPFlickerDetectorGetGain()
{
  OUTLINED_FUNCTION_4_1();
  OUTLINED_FUNCTION_2_0(&dword_24680F000, v0, v1, "Get Volume Scalar returned 0x%08lx\n \n", v2, v3, v4, v5, v6);
}

void inputCallbackForHawking(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void inputCallbackForHawking()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7(&dword_24680F000, v0, v1, "%s - wrong resampling factor: %d\n\n", (uint8_t *)v2);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  uint64_t v3;
  int v4;

  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  uint64_t v2 = 136315650;
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7(&dword_24680F000, v0, v1, "%s - AudioUnitRender - status 0x%08x \n\n", (uint8_t *)v2);
}

void inputCallbackForPenrose(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void inputCallbackForPenrose()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7(&dword_24680F000, v0, v1, "%s - wrong resampling factor: %d\n\n", (uint8_t *)v2);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;
  uint64_t v3;
  int v4;

  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  uint64_t v2 = 136315650;
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7(&dword_24680F000, v0, v1, "%s - AudioUnitRender - status 0x%08x \n\n", (uint8_t *)v2);
}

void inputCallbackForPenrose2(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void inputCallbackForPenrose2()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  int v2 = 136315650;
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7(&dword_24680F000, v0, v1, "%s - AudioUnitRender - status 0x%08x \n\n", (uint8_t *)v2);
}

void inputCallbackForGrimaldi(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void inputCallbackForGrimaldi()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  int v2 = 136315650;
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7(&dword_24680F000, v0, v1, "%s - AudioUnitRender - status 0x%08x \n\n", (uint8_t *)v2);
}

void inputCallbackForGrimaldi_iPad(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void inputCallbackForGrimaldi_iPad()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  int v2 = 136315650;
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7(&dword_24680F000, v0, v1, "%s - AudioUnitRender - status 0x%08x\n", (uint8_t *)v2);
}

void inputCallbackForGrimaldiHighFreq(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void inputCallbackForGrimaldiHighFreq()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  int v2 = 136315650;
  OUTLINED_FUNCTION_1_2();
  OUTLINED_FUNCTION_29(&dword_24680F000, v0, v1, "%s - AudioUnit Input Callback: accumulatedSize=%zd inputBufferByteSize=%d\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[6];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 136315394;
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_7(&dword_24680F000, v0, v1, "%s - AudioUnitRender - status 0x%08x\n", (uint8_t *)v2);
}

void H16ISP::H16ISPServicesRemote::sendMessageSync(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPServicesRemote::sendMessageSync(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  int v2 = "sendMessageSync";
  _os_log_debug_impl(&dword_24680F000, log, OS_LOG_TYPE_DEBUG, "%s - received reply\n", (uint8_t *)&v1, 0xCu);
}

void H16ISP::H16ISPServicesRemote::sendMessageSync()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_30();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - received error reply: %s\n", (uint8_t *)v1, 0x16u);
}

void ___ZN6H16ISP20H16ISPServicesRemote16sendMessageAsyncEPv28H16ISPServicesRemoteProperty_block_invoke_cold_1()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_30();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - received async error reply: %s\n", (uint8_t *)v1, 0x16u);
}

void H16ISP::H16ISPServicesRemote::Connect(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - remote connection already exists\n", a5, a6, a7, a8, 2u);
}

void ___ZN6H16ISP20H16ISPServicesRemote7ConnectEPFv25H16ISPServicesRemoteEventPvES2_b_block_invoke_cold_1(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void DistortRadialLiteInternal<double>()
{
  __assert_rtn("DistortRadialLiteInternal", "GeomUtils.hpp", 378, "pts.Rows() == 2");
}

void Matrix<double>::DotMult<double>()
{
  __assert_rtn("DotMult", "Matrix.hpp", 507, "rhs.Cols() == m_cols && rhs.Rows() == m_rows");
}

void Algo::Interp1WithExtrap<double>()
{
}

{
  __assert_rtn("Interp1WithExtrap", "Algo.hpp", 1281, "xq.GetNumOfPoints() > 0");
}

{
  __assert_rtn("Interp1WithExtrap", "Algo.hpp", 1285, "xq.GetNumOfPoints() > 1");
}

{
  __assert_rtn("Interp1WithExtrap", "Algo.hpp", 1289, "xq.GetNumOfPoints() > 1");
}

void Interp1SortedWithExtrap<double,LinearInterpolator<double>>()
{
}

{
  __assert_rtn("Interp1SortedWithExtrap", "Algo.hpp", 1376, "x.GetNumOfPoints() == v.GetNumOfPoints()");
}

void Interp1WithExtrap<double,LinearInterpolator<double>>()
{
  __assert_rtn("Interp1WithExtrap", "Algo.hpp", 1192, "x.GetNumOfPoints() == v.GetNumOfPoints()");
}

void H16ISP::H16ISPGraphExclaveISPManagerNode::onMessageProcessing(uint64_t a1, NSObject *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a1 + 96);
  int v3 = 136315394;
  int v4 = "onMessageProcessing";
  __int16 v5 = 1024;
  int v6 = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "[Exclaves]: H16ISPGraphExclaveISPManagerNode::%s Cannot allocate CFDictionary channel=%d\n", (uint8_t *)&v3, 0x12u);
}

void H16ISP::H16ISPGraphExclaveISPManagerNode::onMessageProcessing(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  int v2 = "onMessageProcessing";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "[Exclaves]: H16ISPGraphExclaveISPManagerNode::%s Invalid IR Client Handle\n", (uint8_t *)&v1, 0xCu);
}

{
  int v1;
  const char *v2;
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  int v2 = "onMessageProcessing";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "[Exclaves]: H16ISPGraphExclaveISPManagerNode::%s Invalid RGB Client Handle\n", (uint8_t *)&v1, 0xCu);
}

void H16ISP::H16ISPGraphExclaveISPManagerNode::onMessageProcessing()
{
  int v2 = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "[Exclaves]: H16ISPGraphExclaveISPManagerNode::%s EK IR ISP Manager RunKit failed, tberr=%d ipcret=%{BOOL}d\n", v2);
}

{
  uint64_t v0;
  os_log_t v1;
  int v2;

  int v2 = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "[Exclaves]: H16ISPGraphExclaveISPManagerNode::%s EK RGB ISP Manager RunKit failed, tberr=%d ipcret=%{BOOL}d\n", v2);
}

void BlurM::Prepare()
{
  __assert_rtn("Prepare", "BlurM.cpp", 1402, "pContext != 0");
}

void BlurM::Process()
{
  __assert_rtn("Process", "BlurM.cpp", 1763, "pContext != 0");
}

void H16ISP::dictionaryValueEnumerator(uint64_t a1)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = a1;
  _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "createXpcFromType got a dictionary with null value (for key %s)", (uint8_t *)&v1, 0xCu);
}

void H16ISP::DCSAudioAccelManager::StopStreaming(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::DCSAudioAccelManager::DestroyStreamSession(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_1_3(&dword_24680F000, a1, a3, "%s - AudioAccel stream session destroyed\n", a5, a6, a7, a8, 2u);
}

void H16ISP::DCSAudioAccelManager::DestroyStreamSession()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not destroy H16ISBufferReceiver: result=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - removeBufferPoolToBufferReceiver failed: result=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Error stopping the audioBufferReceiver: result=0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void H16ISP::DCSAudioAccelManager::SetTestMode(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_1_3(&dword_24680F000, a1, a3, "%s - AudioAccel streaming enabled, stop streaming with previous testMode\n", a5, a6, a7, a8, 2u);
}

void H16ISP::DCSAudioAccelManager::StartStreaming(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::DCSAudioAccelManager::CreateStreamSession(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_1_3(&dword_24680F000, a1, a3, "%s - audioBufferReceiver already exists\n", a5, a6, a7, a8, 2u);
}

void H16ISP::DCSAudioAccelManager::CreateStreamSession()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - addBufferPoolToBufferReceiver failed: result=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Error starting the audioBufferReceiver: result=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not create H16ISBufferReceiver: result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::DCSAudioAccelManager::CreateStreamSession(unsigned __int16 *a1, NSObject *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v2 = *a1;
  int v3 = 136315650;
  uint64_t v4 = "CreateStreamSession";
  __int16 v5 = 1024;
  int v6 = 43;
  __int16 v7 = 1024;
  int v8 = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - pool type not CISP_POOL_AUDIO_ACCEL_DATA = 0x%08X is 0x%08X\n", (uint8_t *)&v3, 0x18u);
}

void GMC_ExtractTestSamples()
{
  __assert_rtn("GMC_ExtractTestSamples", "GMC_ExtractTestSamples.cpp", 93, "pts1.GetNumOfPoints() - testSetSize == newPts1->GetNumOfPoints()");
}

{
  __assert_rtn("GMC_ExtractTestSamples", "GMC_ExtractTestSamples.cpp", 92, "testSetSize == tsPtsIdx+1");
}

{
  __assert_rtn("operator()", "Matrix.hpp", 131, "index < m_rows * m_cols");
}

{
  __assert_rtn("operator()", "Matrix.hpp", 137, "index < m_rows * m_cols");
}

void DisjointSet::UnCompact()
{
}

void SPD::Init()
{
  __assert_rtn("Init", "SPD.cpp", 26, "pContext != 0");
}

void SPD::Prepare()
{
  __assert_rtn("Prepare", "SPD.cpp", 38, "pContext != 0");
}

void SPD::Process()
{
  __assert_rtn("Process", "SPD.cpp", 394, "pContext != nullptr");
}

{
  __assert_rtn("Process", "SPD.cpp", 395, "pSpd != nullptr");
}

void H16ISP::MOVReader::fileAccessCheck(id *a1)
{
  objc_msgSend((id)objc_msgSend(*a1, "description"), "UTF8String");
  OUTLINED_FUNCTION_0_1(&dword_24680F000, v1, v2, "%s - Error accessing MOV file: %s\n", v3, v4, v5, v6, 2u);
}

void H16ISP::MOVReader::getNextFrame(__CVBuffer *a1, __CVBuffer *a2, NSObject *a3)
{
  uint64_t v16 = *MEMORY[0x263EF8340];
  int v6 = 136316162;
  __int16 v7 = "getNextFrame";
  __int16 v8 = 2048;
  size_t Height = CVPixelBufferGetHeight(a1);
  __int16 v10 = 2048;
  size_t v11 = CVPixelBufferGetHeight(a2);
  __int16 v12 = 2048;
  size_t Width = CVPixelBufferGetWidth(a1);
  __int16 v14 = 2048;
  size_t v15 = CVPixelBufferGetWidth(a2);
  _os_log_error_impl(&dword_24680F000, a3, OS_LOG_TYPE_ERROR, "%s - Height or width of stream and video file do not match %lu!=%lu %lu!=%lu\n", (uint8_t *)&v6, 0x34u);
}

void H16ISP::MOVReader::getNextFrame()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - Input file pixel format is not YUV420, 0x%08X\n", (uint8_t *)v1, 0x12u);
}

{
  os_log_t v0;
  int v1[6];
  uint64_t v2;

  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - Streaming pixel format is not YUV420: 0x%08X\n", (uint8_t *)v1, 0x12u);
}

void H16ISP::MOVReader::getNextFrame(id *a1)
{
  [*a1 description];
  OUTLINED_FUNCTION_0_1(&dword_24680F000, v1, v2, "%s - Read Error: %@\n", v3, v4, v5, v6, 2u);
}

void H16ISP::H16ISPGraphFrameSyncNode::onMessageProcessing(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "H16ISPGraphFrameSyncNode::onMessageProcessing - fail to create the meta data parser.\n\n", v1, 2u);
}

void H16ISP::H16ISPGraphFrameSyncNode::EnableChannel(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "H16ISPGraphFrameSyncNode::EnableChannel - Error: Too many channels already enabled.\n\n", v1, 2u);
}

void H16ISP::H16ISPGraphFrameSyncNode::DisableChannel(int a1, NSObject *a2)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "H16ISPGraphFrameSyncNode::DisableChannel - Error: Channel %d wasn't disabled.\n\n", (uint8_t *)v2, 8u);
}

void H16ISP::H16ISPPearlCalibrationNodeBase::H16ISPPearlCalibrationNodeBase()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI) setup: can't find all channels\n", v2, v3, v4, v5, v6);
}

void H16ISP::H16ISPPearlCalibrationNodeBase::shouldProcessByPearlMetadata(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  int v2 = *(unsigned __int16 *)(*(void *)a1 + 12);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "Pearl Calibration (MI): Won't run on unsupported reg type %d\n", (uint8_t *)v3, 8u);
}

void H16ISP::H16ISPPearlCalibrationNodeBase::shouldProcessByPearlMetadata()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Projector GMC hasn't completed yet - dropping depth/dx buffers\n", v2, v3, v4, v5, v6);
}

void H16ISP::H16ISPPearlCalibrationNode::onDeactivate()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI) finalization: Failed to get PCE Calib\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI) finalization: Timeout insufficient, algorithm state undetermined\n", v2, v3, v4, v5, v6);
}

void H16ISP::H16ISPPearlCalibrationNode::isSessionOK()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Current session isn't suitable for algorithm (depth persepective not corrected)\n", v2, v3, v4, v5, v6);
}

void H16ISP::H16ISPPearlCalibrationNode::onMessageProcessing()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Failed to get PCECalib\n", v2, v3, v4, v5, v6);
}

void H16ISP::H16ISPPearlCalibrationNode::run()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): already aborted. Never mind.\n", v2, v3, v4, v5, v6);
}

void H16ISP::H16ISPPearlCalibrationNode_Remote::onMessageProcessing()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Input error: no color buffer\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Input error: no IR metadata\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Input error: no color metadata\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Input error: no depth buffer\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Input error: no IR buffer\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): algorithm has completed unsuccessfully in daemon\n", v2, v3, v4, v5, v6);
}

void H16ISP::H16ISPPearlCalibrationNode_RGBP::algorithmPreconditions()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Validation failed\n", v2, v3, v4, v5, v6);
}

void H16ISP::H16ISPFrameReceiver::stopReceive()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed enabling exclave streaming mode res=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to unregister epipe done callback in kernel , error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Stop TNR error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - DisableALS(channel %d) error: 0x%08X\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - StopFaceDetect error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - ReturnAllUnusedBuffers error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  long long v2;
  int v3;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  *(void *)((char *)&v2 + 4) = "stopReceive";
  LOWORD(v3) = WORD1(v0);
  HIWORD(v3) = 1024;
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Calling ISP_CILRequestPerChannel error: 0x%08X (%u/false)\n", (const char *)v2, (unint64_t)"stopReceive" >> 32, v3);
}

void H16ISP::H16ISPFrameReceiver::stopReceive(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Did not get all shared pool frames back from kernel\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPFrameReceiver::stopReceive(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPFrameReceiver::ConfigurePDEBufferPool()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Couldn't find matching pool for type %d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - CISP_CMD_CH_PDE_OUTPUT_CONFIG error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::addBufferPoolToFrameReceiver()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - StartReceive SetBufferPoolConfiguration(poolType:%d) error: 0x%08X\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pNewBufferPool->activatePool() failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::EnablePDEStreaming()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to get camera info: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - CISP_CMD_CH_OUT_OF_BOUND_DEPTH_ENABLE error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - CISP_CMD_CH_BUFFER_POOL_CONFIG_GET error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::EnablePDEStreaming(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Firmware PDE_NORM_DX pool not supported for this channel\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Firmware PDE_GMS pool not supported for this channel\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Firmware PDE_DY pool not supported for this channel\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Firmware PDE_DX pool not supported for this channel\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPFrameReceiver::removeBufferPoolFromFrameReceiver(_DWORD *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)uint64_t v3 = 136315650;
  *(void *)&int v3[4] = "removeBufferPoolFromFrameReceiver";
  *(_DWORD *)&v3[14] = *a1;
  *(_WORD *)&v3[18] = 1024;
  OUTLINED_FUNCTION_8(&dword_24680F000, a2, a3, "%s - Did not get all pending frames back from firmware. poolID: %d remaining: %d.\n", *(const char **)v3, (unint64_t)"removeBufferPoolFromFrameReceiver" >> 32, *(_DWORD *)&v3[16]);
}

void H16ISP::H16ISPFrameReceiver::sendInitialBuffersToFirmware()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pH16ISPDevice->ISP_SendBuffers failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Failed to config pool (poolID=%d)\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Failed to allocate buffer (poolID=%d, numAllocated=%d)\n", v2, v3, v4);
}

void H16ISP::H16ISPFrameReceiver::addSharedBufferPoolToFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pPool->activatePool() failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::sendInitialDataBuffersToFirmware(int *a1, int *a2, os_log_t log)
{
  uint64_t v13 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  int v4 = *a2;
  int v5 = 136315906;
  uint8_t v6 = "sendInitialDataBuffersToFirmware";
  __int16 v7 = 1024;
  int v8 = 39;
  __int16 v9 = 1024;
  int v10 = v3;
  __int16 v11 = 1024;
  int v12 = v4;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - failed to set buffer pool configuration poolType=%u raster.size=%u raster.stride=%u\n", (uint8_t *)&v5, 0x1Eu);
}

void H16ISP::H16ISPFrameReceiver::addDataBufferPoolToFrameReceiver(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPFrameReceiver::addDataBufferPoolToFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - data buffer pool not supported for pool type %d\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::removeDataBufferPoolFromFrameReceiver(H16ISP::H16ISPFrameReceiverDataBufferPool **a1, int a2, NSObject *a3)
{
  uint64_t v12 = *MEMORY[0x263EF8340];
  int v5 = H16ISP::H16ISPFrameReceiverDataBufferPool::NumBuffersSent(*a1);
  int v6 = 136315650;
  __int16 v7 = "removeDataBufferPoolFromFrameReceiver";
  __int16 v8 = 1024;
  int v9 = a2;
  __int16 v10 = 1024;
  int v11 = v5;
  _os_log_error_impl(&dword_24680F000, a3, OS_LOG_TYPE_ERROR, "%s - not all buffers returned! poolID: %d remaining: %d.\n\n", (uint8_t *)&v6, 0x18u);
}

void H16ISP::H16ISPFrameReceiver::removeDataBufferPoolFromFrameReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to return buffers in pool ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - data buffer pool not supported for pool type %d\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::startReceive()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - StartCamera error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - StartReceive SetBufferPoolConfiguration(poolType:%d) error: 0x%08X\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - StartReceive failed to send initial data buffers error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - EnableTNR error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not get Camera config error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - StartFaceDetect error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Unable to register epipe done callback, res=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::EPipeDone(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPFrameReceiver::StopChannels()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - ReturnAllUnusedBuffers error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - StopCamera error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::stopProjectorWatchdogTimer()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Error sending sCIspCmdChProjectorWDTSet command: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::ProcessFrameMetadata()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pH16ISPDevice->ISP_GetCameraTime failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void ___ZN6H16ISP19H16ISPFrameReceiver27startProjectorWatchdogTimerEv_block_invoke_cold_1()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Error sending sCIspCmdChProjectorWDTSet command: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::setBufferConfig()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetBufferPoolConfiguration(CISP_POOL_META_CAPTURE_FULL_RES) error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetBufferPoolConfiguration(CISP_POOL_META) error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetBufferPoolConfiguration error: res=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - SetBufferPoolConfiguration(poolType:%d) error: 0x%08X\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - SetBufferPoolConfiguration for exclave meta pool error: res=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::setBufferConfig(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPFrameReceiver::AllocateAndSendStillImageBuffers()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - failed to send ISP buffers ret=0x%08x\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - failed to set buffer config for pool type=%d ret=0x%08x\n", v2, v3, v4);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_17();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - failed to allocate buffer from pool type=%d ret=0x%08x\n", v2, v3, v4);
}

void H16ISP::H16ISPFrameReceiver::AllocateAndSendOneShotBuffers()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pH16ISPDevice->ISP_SendBuffers failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPFrameReceiver::SendOneShotBuffer()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pH16ISPDevice->ISP_SendBuffers failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void AppendMotionMetadata(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "Can not append metadata file to the writer thread - OOM\n", v1, 2u);
}

void MetadataFileWriterThread(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "Error creating metadata file writing thread\n", v1, 2u);
}

void H16ISP::H16ISPFilterGraphNode::EnqueueMessage(uint64_t a1, int a2, os_log_t log)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v3 = *(_DWORD *)(a1 + 76);
  v4[0] = 67109376;
  v4[1] = v3;
  __int16 v5 = 1024;
  int v6 = a2;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "Dropping message from filter graph node with type %d (queue size limit is %d)\n", (uint8_t *)v4, 0xEu);
}

void H16ISP::H16ISPExclaveGraphNode::GetModuleParams(int *a1, NSObject *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v2 = *a1;
  int v3 = 136315394;
  uint64_t v4 = "GetModuleParams";
  __int16 v5 = 1024;
  int v6 = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - Could not access module parameters for channel=%u!\n", (uint8_t *)&v3, 0x12u);
}

void Matrix<double>::ConcatCols()
{
  __assert_rtn("ConcatCols", "Matrix.hpp", 2379, "m_rows == mat.Rows()");
}

void H16ISP::H16ISPGraphExclaveFaceTrackingSecondaryNode::onMessageProcessing(unsigned __int8 *a1, int a2, os_log_t log)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v3 = *a1;
  v4[0] = 67109376;
  v4[1] = a2;
  __int16 v5 = 1024;
  int v6 = v3;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "[Exclaves]: face tracking secondary process failed: tberr=%u result=%{BOOL}d\n", (uint8_t *)v4, 0xEu);
}

void H16ISPRgbIrRunner::run()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Failed to allocate work buffers\n", v2, v3, v4, v5, v6);
}

void H16ISPRgbIrRunner::validateFrame()
{
  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Current frame isn't suitable for algorithm (no color metadata)\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Don't know if AE is stable\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Current frame isn't suitable for algorithm (unstable AE)\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Current frame isn't suitable for algorithm (no detected faces array)\n", v2, v3, v4, v5, v6);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  OUTLINED_FUNCTION_3_1();
  OUTLINED_FUNCTION_1_1(&dword_24680F000, v0, v1, "Pearl Calibration (MI): Current frame isn't suitable for algorithm (zero detected faces)\n", v2, v3, v4, v5, v6);
}

void GeomUtils::DistortRadialLiteInternal()
{
  __assert_rtn("DistortRadialLiteInternal", "GeomUtils.cpp", 537, "pts.Rows() == 2");
}

void GeomUtils::check3of4SpotsOnSameLine()
{
  __assert_rtn("check3of4SpotsOnSameLine", "GeomUtils.cpp", 1114, "x2.Cols()==4 && x2.Rows()==3");
}

{
  __assert_rtn("check3of4SpotsOnSameLine", "GeomUtils.cpp", 1113, "x1.Cols()==4 && x1.Rows()==3");
}

void (***std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<Matrix<double>>,std::reverse_iterator<Matrix<double>*>,std::reverse_iterator<Matrix<double>*>,std::reverse_iterator<Matrix<double>*>>(void (***a1)(void), void (***a2)(void)))(void)
{
  uint64_t v3 = a1;
  uint64_t v4 = a1;
  do
  {
    uint64_t v5 = *v4;
    v4 += 4;
    (*v5)();
    v3 += 4;
    double result = v4;
  }
  while (v4 != a2);
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<Matrix<double>>,Matrix<double>*,Matrix<double>*,Matrix<double>*>(uint64_t a1, uint64_t (***a2)(void))
{
  uint64_t v3 = a1 - 32;
  uint64_t v4 = (uint64_t (***)(void))(a1 - 32);
  uint64_t v5 = (uint64_t (***)(void))(a1 - 32);
  do
  {
    uint8_t v6 = *v5;
    v5 -= 4;
    uint64_t result = (*v6)(v4);
    v3 -= 32;
    BOOL v8 = v4 == a2;
    uint64_t v4 = v5;
  }
  while (!v8);
  return result;
}

void Interp2<double,CubicInterpolator<double>>()
{
  __assert_rtn("Interp2", "Algo.hpp", 683, "v.Cols() >= 2");
}

{
  __assert_rtn("Interp2", "Algo.hpp", 684, "v.Rows() >= 2");
}

{
  __assert_rtn("Interp2", "Algo.hpp", 685, "xq.GetNumOfPoints() == yq.GetNumOfPoints()");
}

{
  __assert_rtn("Interp2", "Algo.hpp", 682, "y.GetNumOfPoints() == v.Rows()");
}

{
  __assert_rtn("Interp2", "Algo.hpp", 681, "x.GetNumOfPoints() == v.Cols()");
}

void Interp1<double,LinearInterpolator<double>>()
{
}

{
  __assert_rtn("Interp1", "Algo.hpp", 1068, "xLen == v.GetNumOfPoints()");
}

void Matrix<double>::DotRepeatSubFromRightInPlace()
{
}

void MyIOHIDEventCallback(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ___ZN6H16ISP23H16ISPPhotometerManagerC2EPFiP28H16ISPFlickerDetectorContextPvP25photometer_flicker_resultES3_PNS_22H16ISPDeviceControllerEPNS_12H16ISPDeviceE_block_invoke_cold_1(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void ___ZN6H16ISP23H16ISPPhotometerManagerC2EPFiP28H16ISPFlickerDetectorContextPvP25photometer_flicker_resultES3_PNS_22H16ISPDeviceControllerEPNS_12H16ISPDeviceE_block_invoke_cold_2(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPPhotometerManager::InitializeHIDEventSystemClientForALS(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not create a matching dictionary\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not create device matching dictionary\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not create device matching array\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not create device usage references\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Could not create primary usage references\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPPhotometerManager::GetLuxInfo(uint64_t a1, NSObject *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(*(void *)a1 + 24);
  int v3 = 136315650;
  uint64_t v4 = "GetLuxInfo";
  __int16 v5 = 2080;
  uint8_t v6 = "GetLuxInfo";
  __int16 v7 = 1024;
  int v8 = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - %s: Sending lux, ret = 0x%x\n", (uint8_t *)&v3, 0x1Cu);
}

void H16ISP::H16ISPPhotometerManager::GetLuxInfo()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_1_4();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - %s: Scheduling the lux query on the serial queue\n", (uint8_t *)v1, 0x16u);
}

void ___ZN6H16ISP23H16ISPPhotometerManager10GetLuxInfoEP7luxInfo_block_invoke_cold_1()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_1_4();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - %s: Waiting for lux\n", (uint8_t *)v1, 0x16u);
}

void H16ISP::LoadFrontIRHPRFile(const __CFString *a1, NSObject *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  int v3 = 136315394;
  uint64_t v4 = "LoadFrontIRHPRFile";
  __int16 v5 = 2080;
  CStringPtr = CFStringGetCStringPtr(a1, 0);
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - [error]: %s\n", (uint8_t *)&v3, 0x16u);
}

void H16ISP::LoadFrontIRHPRFile(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "LoadFrontIRHPRFile";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - noHPR boot-arg set\n", (uint8_t *)&v1, 0xCu);
}

void flicker_data_processing(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  int v2 = *(_DWORD *)(a1 + 12);
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "input/ouput buffer or parameter setting incorrect. win size %d \n\n", (uint8_t *)v3, 8u);
}

void Algo::StdFilter()
{
}

void Algo::Mean()
{
}

void SparseMatrix::Expand()
{
  __assert_rtn("Expand", "SparseMatrix.cpp", 121, "newNZPerCol <= (size_t)m_extraSpacePerCol");
}

void SparseMatrix::operator()()
{
}

void SparseMatrix::SolveLTInPlace()
{
  __assert_rtn("SolveLTInPlace", "SparseMatrix.cpp", 248, "m_width == m_height");
}

void SparseVector::operator=()
{
  __assert_rtn("operator=", "SparseMatrix.cpp", 374, "m_ownsData");
}

void SparseVector::AddWithFactor()
{
}

{
  __assert_rtn("AddValueToHelper", "SparseMatrix.hpp", 156, "pos<m_size && m_helperNNZ<m_maxNNZ");
}

void PDAF::PixelEngine::SetupBuffers()
{
  __assert_rtn("SetupBuffers", "PDAFPixelEngine.cpp", 4303, "pContext != nullptr");
}

{
  __assert_rtn("SetupBuffers", "PDAFPixelEngine.cpp", 4307, "offset <= sizeof(pContext->mem)");
}

void PDAF::PixelEngine::Process_x1()
{
  __assert_rtn("Process_x1", "PDAFPixelEngine.cpp", 4312, "pIn0 != nullptr");
}

{
  __assert_rtn("Process_x1", "PDAFPixelEngine.cpp", 4313, "pContext != nullptr");
}

{
  __assert_rtn("Process_x1", "PDAFPixelEngine.cpp", 4339, "false");
}

{
  __assert_rtn("Process_x1", "PDAFPixelEngine.cpp", 4323, "false");
}

{
  __assert_rtn("Process_x1", "PDAFPixelEngine.cpp", 4330, "pContext->geometry.tile.countX * pContext->geometry.tile.countY <= NTILES");
}

void PDAF::PixelEngine::anonymous namespace'::Process()
{
  __assert_rtn("Process", "PDAFPixelEngine.cpp", 4248, "pContext->geometry.tile.countX * pContext->geometry.tile.countY <= NTILES");
}

{
  __assert_rtn("Process", "PDAFPixelEngine.cpp", 4288, "false");
}

{
  __assert_rtn("FlowOutputLevel", "PDAFPixelEngine.cpp", 2455, "level == 0");
}

{
  __assert_rtn("FlowOutputLevel", "PDAFPixelEngine.cpp", 2467, "level > 0");
}

{
  __assert_rtn("FlowOutputLevel", "PDAFPixelEngine.cpp", 2490, "false");
}

{
  __assert_rtn("FlareEstimate", "PDAFPixelEngine.cpp", 2339, "flare.intensity <= Params::Flare::NINTENSITIES");
}

{
  __assert_rtn("GetFocusPixelTypeCount", "PDAFPixelEngine.cpp", 246, "false");
}

{
  __assert_rtn("FlowPostProcess", "PDAFPixelEngine.cpp", 2604, "pContext->params.flow.levels[0] == 1");
}

{
  __assert_rtn("CorrAccumulate", "PDAFPixelEngine.cpp", 3618, "false");
}

{
  __assert_rtn("CorrPostProcess", "PDAFPixelEngine.cpp", 3886, "false");
}

{
  __assert_rtn("CorrPostProcess", "PDAFPixelEngine.cpp", 3881, "SamplingH == SamplingV");
}

{
  __assert_rtn("GetFocusPixelSamplingRateH", "PDAFPixelEngine.cpp", 270, "false");
}

{
  __assert_rtn("CorrProfile", "PDAFPixelEngine.cpp", 3450, "pContext->geometry.roi.cellCountX == geometryCorr.profileSize");
}

{
  __assert_rtn("CorrProfile", "PDAFPixelEngine.cpp", 3455, "pContext->geometry.roi.cellCountY == geometryCorr.profileSize");
}

{
  __assert_rtn("Process", "PDAFPixelEngine.cpp", 4284, "false");
}

{
  __assert_rtn("Process", "PDAFPixelEngine.cpp", 4264, "false");
}

void PDAF::PixelEngine::Process_x2()
{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4347, "pIn0 != nullptr");
}

{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4348, "pIn1 != nullptr");
}

{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4349, "pContext != nullptr");
}

{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4367, "false");
}

{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4354, "false");
}

{
  __assert_rtn("Process_x2", "PDAFPixelEngine.cpp", 4363, "false");
}

void PDAF::PixelEngine::anonymous namespace'::AFEGetInputs()
{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 608, "afe != nullptr");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 639, "false");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 614, "afeGeom.initH == 0 || afeGeom.initH == 1");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 679, "false");
}

{
  __assert_rtn("GetAFEAddress", "PDAFPixelEngine.cpp", 491, "false");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 724, "false");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 728, "input.afeStride > 0");
}

{
  __assert_rtn("AFEGetInputs", "PDAFPixelEngine.cpp", 747, "(cellCountXH == 0) || (cellCountXH == (signed)geometry.roi.cellCountX)");
}

{
  __assert_rtn("AFEGetInputs", "PDAFPixelEngine.cpp", 748, "(cellCountXV == 0) || (cellCountXV == (signed)geometry.roi.cellCountX)");
}

{
  __assert_rtn("AFEGetInputs", "PDAFPixelEngine.cpp", 745, "inputs[k].cellCountY == (signed)geometry.roi.cellCountY");
}

{
  __assert_rtn("GetAFEAddress", "PDAFPixelEngine.cpp", 461, "false");
}

{
  __assert_rtn("GetAFEAddress", "PDAFPixelEngine.cpp", 445, "afeGeom.cellStartY < afeGeom.cellCountY");
}

{
  __assert_rtn("GetAFEAddress", "PDAFPixelEngine.cpp", 444, "afeGeom.cellCountY >= delayV + 1");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 615, "afeGeom.initV == -1");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 622, "afeGeom.initH == 0 || afeGeom.initH == 1");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 623, "afeGeom.initV == 2 || afeGeom.initV == 3");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 628, "afeGeom.initV == -1");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 627, "afeGeom.initH == 0");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 634, "afeGeom.initV == 2");
}

{
  __assert_rtn("GetInputAFE", "PDAFPixelEngine.cpp", 633, "afeGeom.initH == 0");
}

void PDAF::PixelEngine::anonymous namespace'::FlowAccumulate()
{
}

{
  __assert_rtn("GetFocusRowInCell", "PDAFPixelEngine.cpp", 192, "false");
}

{
  __assert_rtn("FlowAccumulateScalar", "PDAFPixelEngine.cpp", 1564, "false");
}

{
  __assert_rtn("nextH", "PDAFPixelEngine.cpp", 545, "false");
}

{
  __assert_rtn("FlowAccumulateRow1x1Scalar", "PDAFPixelEngine.cpp", 845, "pixelInBuffer == 0");
}

{
  __assert_rtn("nextV", "PDAFPixelEngine.cpp", 590, "false");
}

{
  __assert_rtn("nextV", "PDAFPixelEngine.cpp", 558, "false");
}

{
  __assert_rtn("FlowAccumulateRow2x1Scalar", "PDAFPixelEngine.cpp", 1114, "pixelInBuffer == 0");
}

{
  __assert_rtn("FlowAccumulateNeon64", "PDAFPixelEngine.cpp", 1823, "false");
}

{
  __assert_rtn("FlowAccumulateRow1x1Neon64", "PDAFPixelEngine.cpp", 1012, "pixelInBuffer == 0");
}

{
  __assert_rtn("FlowAccumulateRow1x1Neon64", "PDAFPixelEngine.cpp", 927, "false");
}

{
  __assert_rtn("FlowAccumulateRow2x1Neon64", "PDAFPixelEngine.cpp", 1175, "pixelInBuffer > 0");
}

void PDAF::PixelEngine::anonymous namespace'::GetAFEDelayV()
{
}

{
  __assert_rtn("GetAFEDelayV", "PDAFPixelEngine.cpp", 330, "false");
}

{
  __assert_rtn("GetAFEDelayV", "PDAFPixelEngine.cpp", 347, "false");
}

{
  __assert_rtn("GetAFEDelayV", "PDAFPixelEngine.cpp", 365, "false");
}

{
  __assert_rtn("GetAFEDelayV", "PDAFPixelEngine.cpp", 382, "false");
}

{
  __assert_rtn("GetAFEDelayV", "PDAFPixelEngine.cpp", 399, "false");
}

void PDAF::PixelEngine::anonymous namespace'::CorrProfileSumRows1x1H()
{
  __assert_rtn("CorrProfileSumRows1x1H", "PDAFPixelEngine.cpp", 3214, "pixelInCol != 0");
}

{
  __assert_rtn("CorrProfileSumRows1x1H", "PDAFPixelEngine.cpp", 3246, "cellInBuffer == 0");
}

void PDAF::PixelEngine::anonymous namespace'::CorrProfileProcess()
{
}

{
  __assert_rtn("CorrProfileProcess", "PDAFPixelEngine.cpp", 3431, "false");
}

{
  __assert_rtn("CorrProfileAccumScalar", "PDAFPixelEngine.cpp", 2777, "params.shiftMin < 0");
}

{
  __assert_rtn("CorrProfileAccumScalar", "PDAFPixelEngine.cpp", 2778, "params.shiftMax > 0");
}

{
  __assert_rtn("CorrProfileAccumNeon64", "PDAFPixelEngine.cpp", 3127, "params.shiftMin < 0");
}

{
  __assert_rtn("CorrProfileAccumNeon64", "PDAFPixelEngine.cpp", 3128, "params.shiftMax > 0");
}

void PDAF::PixelEngine::anonymous namespace'::CorrProfileSumCols1x1V()
{
  __assert_rtn("CorrProfileSumCols1x1V", "PDAFPixelEngine.cpp", 3272, "pixelInRow != 0");
}

void PDAF::PixelEngine::anonymous namespace'::CorrProfileSumRows2x1H()
{
  __assert_rtn("CorrProfileSumRows2x1H", "PDAFPixelEngine.cpp", 3317, "pixelInCol != 0");
}

{
  __assert_rtn("CorrProfileSumRows2x1H", "PDAFPixelEngine.cpp", 3336, "cellInBuffer == 0");
}

void PDAF::PixelEngine::anonymous namespace'::CorrProfileSumCols2x1V()
{
  __assert_rtn("CorrProfileSumCols2x1V", "PDAFPixelEngine.cpp", 3358, "pixelInRow != 0");
}

void PDAF::PixelEngine::anonymous namespace'::FlowEstimateGainError()
{
}

void H16ISP::H16ISPGraphExclaveAutoExposureNode::onMessageProcessing()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "[Exclaves]: H16ISPGraphExclaveAutoExposureNode::%s EK RunKit AE Failed for reqID 0x%08X ipcret %d\n", v2, v3, v4);
}

{
  os_log_t v0;
  int v1[6];
  uint64_t v2;

  int v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "[Exclaves]: H16ISPGraphAutoExposureNode::%s cannot set exclave AE configurations to firmware, res=0x%08X\n", (uint8_t *)v1, 0x12u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "[Exclaves]: H16ISPGraphExclaveAutoExposureNode::%s EK AE RunKit Failed for reqID 0x%08X ipcret %d\n", v2, v3, v4);
}

void H16ISPFirmwareWork::RPCFileInfo()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_30();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - Failed to stat file: %s\n", (uint8_t *)v1, 0x16u);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[10];

  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  v2[0] = 136315650;
  OUTLINED_FUNCTION_4_2();
  OUTLINED_FUNCTION_8_0(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %ld, recv %lld)\n", (uint8_t *)v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Number of buffers is not 1 (%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISPFirmwareWork::RPCFileInfo(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPFirmwareWork::RPCFileRead()
{
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Invalid read length (%d)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[10];

  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  v2[0] = 136315650;
  OUTLINED_FUNCTION_4_2();
  OUTLINED_FUNCTION_8_0(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %ld, recv %lld)\n", (uint8_t *)v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Number of buffers is not 2 (%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISPFirmwareWork::RPCFileRead(uint64_t a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t v3 = __error();
  strerror(*v3);
  v5[0] = 136315650;
  OUTLINED_FUNCTION_7_0();
  OUTLINED_FUNCTION_8_0(&dword_24680F000, a2, v4, "%s - Failed to open file: %s %s\n", (uint8_t *)v5);
}

void H16ISPFirmwareWork::RPCFileRead(uint64_t a1, int *a2, os_log_t log)
{
  uint64_t v10 = *MEMORY[0x263EF8340];
  int v3 = *a2;
  int v4 = 136315650;
  uint64_t v5 = "RPCFileRead";
  __int16 v6 = 2080;
  uint64_t v7 = a1;
  __int16 v8 = 1024;
  int v9 = v3;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - Failed to seek file %s: offset %d\n", (uint8_t *)&v4, 0x1Cu);
}

void H16ISPFirmwareWork::RPCFileRead(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPFirmwareWork::RPCFileWrite()
{
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Invalid write length (%d)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  int v2[10];

  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  v2[0] = 136315650;
  OUTLINED_FUNCTION_4_2();
  OUTLINED_FUNCTION_8_0(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %ld, recv %lld)\n", (uint8_t *)v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Number of buffers is not 2 (%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISPFirmwareWork::RPCFileWrite(char *a1, NSObject *a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  dirname(a1);
  v3[0] = 136315394;
  OUTLINED_FUNCTION_30();
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - Failed to create directory: %s\n", (uint8_t *)v3, 0x16u);
}

void H16ISPFirmwareWork::RPCFileWrite(uint64_t a1, NSObject *a2)
{
  uint64_t v6 = *MEMORY[0x263EF8340];
  uint64_t v3 = __error();
  strerror(*v3);
  v5[0] = 136315650;
  OUTLINED_FUNCTION_7_0();
  OUTLINED_FUNCTION_8_0(&dword_24680F000, a2, v4, "%s - Failed to open file: %s %s\n", (uint8_t *)v5);
}

void H16ISPFirmwareWork::RPCFileWrite(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISPFirmwareWork::PDAFProcessX1Wrapper()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_0_2();
  OUTLINED_FUNCTION_5(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Number of buffers is not 2 (%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISPFirmwareWork::PDAFProcessX2Wrapper()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_0_2();
  OUTLINED_FUNCTION_5(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Number of buffers is not 3 (%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISPFirmwareWork::PDAFProcessX3Wrapper()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_0_2();
  OUTLINED_FUNCTION_5(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Number of buffers is not 4 (%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISPFirmwareWork::PDAFProcessX4Wrapper()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_0_2();
  OUTLINED_FUNCTION_5(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Number of buffers is not 5 (%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISPFirmwareWork::BlurMProcessWrapper()
{
  OUTLINED_FUNCTION_11_0(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_3_3();
  OUTLINED_FUNCTION_5(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

void H16ISPFirmwareWork::BlurMProcessWrapper(int a1, NSObject *a2)
{
  uint64_t v8 = *MEMORY[0x263EF8340];
  int v2 = 136315650;
  uint64_t v3 = "BlurMProcessWrapper";
  __int16 v4 = 1024;
  int v5 = 4;
  __int16 v6 = 1024;
  int v7 = a1;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - Number of buffers is not %d (%d)\n", (uint8_t *)&v2, 0x18u);
}

void H16ISPFirmwareWork::SPDProcessWrapper()
{
  OUTLINED_FUNCTION_3_3();
  OUTLINED_FUNCTION_5(&dword_24680F000, v0, v1, "%s - Buffer size does not match expected value (expected %d, recv %lld)\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Number of buffers is not 2 (%d)\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPBufferReceiver::stopReceive()
{
  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Did not get all pending frames back from firmware on PoolID:0x%x. remaining: %d\n", v2, v3, v4);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - ReturnAllBuffersInPool error: 0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPBufferReceiver::removeBufferPoolFromBufferReceiver(_DWORD *a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)int v3 = 136315650;
  *(void *)&int v3[4] = "removeBufferPoolFromBufferReceiver";
  *(_DWORD *)&v3[14] = *a1;
  *(_WORD *)&v3[18] = 1024;
  OUTLINED_FUNCTION_8(&dword_24680F000, a2, a3, "%s - Did not get all pending frames back from firmware. PoolID:0x%x remaining: %d\n", *(const char **)v3, (unint64_t)"removeBufferPoolFromBufferReceiver" >> 32, *(_DWORD *)&v3[16]);
}

void H16ISP::H16ISPBufferReceiver::addBufferPoolToBufferReceiver()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pNewBufferPool->activatePool() failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPBufferReceiver::sendInitialBuffersToFirmware()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - pH16ISPDevice->ISP_SendBuffers failed, result=0x%08X\n", v2, v3, v4, v5, 2u);
}

{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;

  LODWORD(v2) = 136315650;
  OUTLINED_FUNCTION_11();
  OUTLINED_FUNCTION_8(&dword_24680F000, v0, v1, "%s - Failed to allocate buffer (PoolID:0x%x, numAllocated=%d)\n", v2, v3, v4);
}

void H16ISP::H16ISPBufferReceiver::BufferDone()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - ISP_SendBuffers failed: 0x%08X\n\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPBufferReceiver::startNoBufferAvailableTimer(os_log_t log)
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "startNoBufferAvailableTimer";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - \n", (uint8_t *)&v1, 0xCu);
}

void H16ISP::H16ISPGraphExclaveSensorMetadataNode::onMessageProcessing(H16ISP::H16ISPExclaveGraphNode *a1, NSObject *a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  v3[0] = 67109120;
  v3[1] = H16ISP::H16ISPExclaveGraphNode::Channel(a1);
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "ch%u: invalid sensor metadata\n", (uint8_t *)v3, 8u);
}

void H16ISP::H16ISPGraphExclaveSensorMetadataNode::computePTS()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - failed to get isp counter frequency ret=0x%08x\n", (uint8_t *)v1, 0x12u);
}

{
  os_log_t v0;
  int v1[6];
  uint64_t v2;

  uint64_t v2 = *MEMORY[0x263EF8340];
  v1[0] = 136315394;
  OUTLINED_FUNCTION_0();
  _os_log_error_impl(&dword_24680F000, v0, OS_LOG_TYPE_ERROR, "%s - failed to get camera time ret=0x%08x\n", (uint8_t *)v1, 0x12u);
}

void H16ISP::H16ISPGraphExclaveRGBSensorMetadataNode::sendSensorMetadata(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "invalid RGB conclave client handle\n", v1, 2u);
}

{
  int v1;
  const char *v2;
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  int v1 = 136315138;
  uint64_t v2 = "sendSensorMetadata";
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "%s - Invalid Focal Length received from FW! Falling back to 1.0 for focalLength\n", (uint8_t *)&v1, 0xCu);
}

void H16ISP::H16ISPGraphExclaveIRSensorMetadataNode::sendSensorMetadata(os_log_t log)
{
  *(_WORD *)int v1 = 0;
  _os_log_error_impl(&dword_24680F000, log, OS_LOG_TYPE_ERROR, "invalid IR conclave client handle\n", v1, 2u);
}

void H16ISP::H16ISPDevice::GetNumCameraConfigs()
{
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_14_0(&dword_24680F000, &_os_log_internal, v0, "%s - exiting - camChannel: %d, valid: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::GetUnitInfoPropertyDict(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "Failure loading override ISPUnitInfo property list : CFPropertyListCreateWithStream failed\n", v3);
}

void H16ISP::H16ISPDevice::GetSensorNVMBytes()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::ISP_CopySetfile()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - returned 0x%08x\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::GetCameraConfig()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::GetLSCCoefficients()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::GetISPCounterFrequency(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::SetCameraConfig()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::StartCamera()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: 0x%08X\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::StopCamera()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: 0x%08X\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::ReturnAllUnusedBuffers()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::ISP_SetExclaveMaximumFrameRate(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IR Max Frame Rate call failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Conclave RGB Client Handle Invalid!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - RGB Max Frame Rate call failed\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::ISP_SetExclaveMaximumFrameRate()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315906;
  OUTLINED_FUNCTION_33();
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_16(&dword_24680F000, v0, v1, "[%s:%d] Invalid camChannel (%u / max:%u)\n\n", v2, v3, v4, v5);
}

void H16ISP::H16ISPDevice::ISP_SetExclaveMinimumFrameRate(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IR Min Frame Rate call failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Conclave RGB Client Handle Invalid!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - RGB Min Frame Rate call failed\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::ISP_SetExclaveMinimumFrameRate()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315906;
  OUTLINED_FUNCTION_33();
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_16(&dword_24680F000, v0, v1, "[%s:%d] Invalid camChannel (%u / max:%u)\n\n", v2, v3, v4, v5);
}

void H16ISP::H16ISPDevice::ReloadNVMBytes()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::CacheDeviceConfigs(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::CacheDeviceConfigs()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - Error: resetting device config cache - res: 0x%08X\n", v1, v2, v3, v4, 2u);
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_14_0(&dword_24680F000, &_os_log_internal, v0, "%s - Error getting channel info - chan: %d, res: 0x%08X\n", v1, v2, v3, v4, 2u);
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - Error getting config - res: 0x%08X\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::WritePropertyValue()
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_2();
  __int16 v2 = 1024;
  int v3 = v0;
  _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "UpdateChannelConfigCache channel %d error: 0x%08X\n", v1, 0xEu);
}

void H16ISP::H16ISPDevice::SendFirmwareObjectSpecialFunc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, a3, "Failed to fetch handle for %s with return code = 0x%08x\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::GetLSC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::ISP_GetGDCBesOutputValidRect()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - EnableFESAutoAdjust error: 0x%08X\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::SetFlickerFrequency(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::ISP_GetExclaveEnablementStatus()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - IOConnect Failed, status = 0x%08x\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::EnableMetadataSection()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::EnableTNR()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - SetBand0StrengthModThreshold failed: 0x%08X\n", v1, v2, v3, v4, 2u);
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - EnableBand0Modulation failed: 0x%08X\n", v1, v2, v3, v4, 2u);
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - EnableHighStrengthTNR failed: 0x%08X\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::GetMaxResolutionSensorConfigIndex()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - invalid cache - exiting, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::ValidateProjectorToken()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - ISP_GetCameraStatus error (0x%08x)\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::H16ISPDevice()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - Did not find platform-info for platform:%d. Defaulting to 0\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::ISP_PowerOnCamera(uint8_t *a1, int a2, _DWORD *a3)
{
  *(_DWORD *)a1 = 67109120;
  *a3 = a2;
  OUTLINED_FUNCTION_9_0(&dword_24680F000, &_os_log_internal, (uint64_t)a3, "Error: SetSensorCustomSettings returned an error: 0x%08X\n", a1);
}

{
  *(_DWORD *)a1 = 67109120;
  *a3 = a2;
  OUTLINED_FUNCTION_9_0(&dword_24680F000, &_os_log_internal, (uint64_t)a3, "Error setting FW property: 0x%08x\n", a1);
}

void H16ISP::H16ISPDevice::ISP_PowerOnCamera(unsigned char *a1, unsigned char *a2)
{
  OUTLINED_FUNCTION_4_3(a1, a2);
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, v2, "Error parsing camera clock override file\n", v3);
}

{
  uint64_t v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_4_3(a1, a2);
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, v2, "Error: too many camera sensor register over-rides in file\n", v3);
}

{
  uint64_t v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_4_3(a1, a2);
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, v2, "No ALS2 profile found in Setfile\n", v3);
}

{
  uint64_t v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_4_3(a1, a2);
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, v2, "could not read sensor SetFile\n", v3);
}

void H16ISP::H16ISPDevice::ISP_PowerOnCamera(uint8_t *a1, _DWORD *a2, uint64_t a3)
{
  *(_DWORD *)a1 = 67109120;
  *a2 = -536870165;
  OUTLINED_FUNCTION_9_0(&dword_24680F000, &_os_log_internal, a3, "LoadSetFile returned 0x%08x - ignoring error\n", a1);
}

void H16ISP::H16ISPDevice::ISP_PowerOnCamera(uint8_t *buf, void *a2)
{
  *(_DWORD *)long long buf = 136315138;
  *a2 = "ISP_PowerOnCamera";
  _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s - FTC gain buffer allocation failed\n", buf, 0xCu);
}

void H16ISP::H16ISPDevice::ISP_PowerOnCamera()
{
  __assert_rtn("ISP_PowerOnCamera", "H16ISPDevice.cpp", 10921, "kCICMaxPerModuleX >= numXCIC");
}

{
  __assert_rtn("ISP_PowerOnCamera", "H16ISPDevice.cpp", 10922, "kCICMaxPerModuleY >= numYCIC");
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - ISP_GetNumChannels failed with 0x%08x\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::ISP_ColdBootPowerCycle()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - Error %x loading FW\n", v1, v2, v3, v4, 2u);
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - Could not forget firmware, res = %x\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::ISP_LoadFirmware(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - SoC generation from the device tree is invalid!\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::ISP_LoadFirmware()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_9_0(&dword_24680F000, &_os_log_internal, v0, "Failed to load Bin-format firmware binary: 0x%08x\n", v1);
}

void H16ISP::H16ISPDevice::GetFrontCameraOffsetFromDisplayCenter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - Failed to copy kMGQFrontCameraOffsetFromDisplayCenter answer from MobileGestalt!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - Front Camera Offset X is unavailable!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - Front Camera Offset Y is unavailable!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - Front Camera Offset Z is unavailable!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - Front Camera Offset data is corrupted!\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::ISP_SetFrontCameraOffsetFromDisplayCenter()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - ret=%#x\n", v1, v2, v3, v4, 2u);
}

{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - Failed to copy kMGQFrontCameraOffsetFromDisplayCenter answer from MobileGestalt! err=%d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::LoadFirmwareBinary(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "could not read ISPCPU Firmware file\n", v3);
}

{
  uint8_t v3[16];

  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "(Bin) Using ISPCPU firmware override file\n", v3);
}

void H16ISP::H16ISPDevice::LoadFirmwareBinary(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::LoadFDRCalDataFile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "Couldn't read back camera module serial number. Sensor is hosed/disconnected. Skip loading FDR CmCl calibration data\n", v3);
}

void H16ISP::H16ISPDevice::LoadFDRCalDataFile()
{
  OUTLINED_FUNCTION_6();
  OUTLINED_FUNCTION_5(&dword_24680F000, &_os_log_internal, v0, "%s - No module or Unauthorized swap (cmclStatus = 0x%x) or No CmCL data (perhaps cuz the device does not support CmCL) [error]: %s\n", v1, v2, v3, v4, v5);
}

void H16ISP::H16ISPDevice::LoadFDRFCClDataFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::LoadFDRFCClDataFile()
{
  OUTLINED_FUNCTION_6();
  OUTLINED_FUNCTION_5(&dword_24680F000, &_os_log_internal, v0, "%s - No module or Unauthorized swap (fcclStatus = %#x) or No FCCL data (perhaps cuz the device does not support FCCL) [error]: %s\n", v1, v2, v3, v4, v5);
}

void H16ISP::H16ISPDevice::LoadFDRDataFileCMPM(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "Couldn't read BackCameraSNUM and BackSuperWideCameraSNUM. Sensor is hosed/disconnected. Skip loading FDR CmPM calibration data\n", v3);
}

void H16ISP::H16ISPDevice::LoadFDRDataFileCMPM()
{
  OUTLINED_FUNCTION_6();
  OUTLINED_FUNCTION_5(&dword_24680F000, &_os_log_internal, v0, "%s - No module or Unauthorized swap (cmpmStatus = 0x%x) or No CmPM data (perhaps cuz the device does not support CmPM) [error]: %s\n", v1, v2, v3, v4, v5);
}

void H16ISP::H16ISPDevice::LoadFDRDataFileCMPM(unsigned char *a1, unsigned char *a2)
{
  OUTLINED_FUNCTION_4_3(a1, a2);
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, v2, "Pixel format mismatch\n", v3);
}

{
  uint64_t v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_4_3(a1, a2);
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, v2, "Pixel buffer has invalid size\n", v3);
}

{
  uint64_t v2;
  uint8_t *v3;

  OUTLINED_FUNCTION_4_3(a1, a2);
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, v2, "Failed to lock pixel buffer\n", v3);
}

void H16ISP::H16ISPDevice::LoadFDRDataFileCMPM(uint8_t *buf, void *a2)
{
  *(_DWORD *)long long buf = 136315138;
  *a2 = "LoadFDRDataFileCMPM";
  _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s - Can't create /var/mobile/Library/ISP/CalData\n", buf, 0xCu);
}

{
  *(_DWORD *)long long buf = 136315138;
  *a2 = "LoadFDRDataFileCMPM";
  _os_log_error_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_ERROR, "%s - Can't create /var/mobile/Library/ISP\n", buf, 0xCu);
}

void H16ISP::H16ISPDevice::LoadOCClCalDataFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::LoadOCClCalDataFile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "Couldn't read back camera module serial number. Sensor is hosed/disconnected. Skip loading OCCl calibration data\n", v3);
}

void H16ISP::H16ISPDevice::LoadIspAneNetworkFile(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "Failed to copy model string from MobileGestalt\n", v3);
}

{
  uint8_t v3[16];

  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "Error opening ISP-ANE networks file\n", v3);
}

void H16ISP::H16ISPDevice::LoadIspAneNetworkFile(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OUTLINED_FUNCTION_5(&dword_24680F000, &_os_log_internal, a3, "Error sending ISP-ANE networks file to kernel: Size = %ld (== %ld ?); Status = %08x\n\n",
    a5,
    a6,
    a7,
    a8,
    0);
}

uint64_t H16ISP::H16ISPDevice::ISP_YonkersFusing(char a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint8_t v5 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "No valid Yonkers key provisioning file to send\n", v5);
  return a1 & 1;
}

void H16ISP::H16ISPDevice::ISP_YonkersFusing(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "could not read Yonkers key provisioning file entirely\n", v3);
}

uint64_t H16ISP::H16ISPDevice::ISP_SavageFusing(char a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint8_t v5 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "No valid Savage firmware file to send\n", v5);
  return a1 & 1;
}

void H16ISP::H16ISPDevice::ISP_SavageFusing(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_WORD *)uint64_t v3 = 0;
  OUTLINED_FUNCTION_3_4(&dword_24680F000, &_os_log_internal, a3, "could not read Savage firmware file entirely\n", v3);
}

void H16ISP::H16ISPDevice::getANSTVersion(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::isConclaveRunning()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves] Conclave not running for EKType: %d\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPDevice::SetupConclave()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_9_0(&dword_24680F000, v0, v1, "[Conclave] failed to set up ExclaveKit error: 0x%08x\n\n", v2);
}

{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];
  uint64_t v3;

  uint64_t v3 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_9_0(&dword_24680F000, v0, v1, "[Conclave] failed to set up end point error: 0x%08x\n\n", v2);
}

void H16ISP::H16ISPDevice::NotifySystemStatusForCIL(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - CIL on request\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - CIL off request\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::NotifySystemStatusForCIL()
{
  uint64_t v2 = *MEMORY[0x263EF8340];
  int v0 = 136315138;
  uint64_t v1 = "NotifySystemStatusForCIL";
  _os_log_debug_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEBUG, "%s - process name is mediaserverd or cameracaptured, so skip calling SystemsStatus\n", (uint8_t *)&v0, 0xCu);
}

void H16ISP::H16ISPDevice::PowerOnExclaveKit(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Conclave IR Client Handle Invalid!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Conclave RGB Client Handle Invalid!\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::PowerOnExclaveKit()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: EK IR CMD on failed, tberr=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: EK RGB CMD on failed, tberr=%d\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPDevice::PowerOffExclaveKit(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Conclave IR Client Handle Invalid!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Conclave RGB Client Handle Invalid!\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::PowerOffExclaveKit()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: EK IR CMD off failed, tberr=%d\n", v2, v3, v4, v5, 2u);
}

{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  OUTLINED_FUNCTION_9();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - [Exclaves]: EK RGB CMD off failed %d\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPDevice::ISP_UnregisterEPipeDoneCallback()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  OUTLINED_FUNCTION_2_1();
  OUTLINED_FUNCTION_14_0(&dword_24680F000, &_os_log_internal, v0, "%s - Cannot unregister epipedone callback, invalid channel = %d numChannels = %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::GetExclaveCameraConfig(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void H16ISP::H16ISPDevice::ReadPropertyValueExclave(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IR read IDL call failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Invalid RGB EK Client Handle\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - RGB read IDL call failed\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::ReadPropertyValueExclave()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315906;
  OUTLINED_FUNCTION_33();
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_16(&dword_24680F000, v0, v1, "[Exclaves][%s:%d] Invalid camChannel (%u / max:%u)\n\n", v2, v3, v4, v5);
}

void H16ISP::H16ISPDevice::WritePropertyValueExclave(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - IR write IDL call failed\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - Conclave RGB Client Handle Invalid!\n", a5, a6, a7, a8, 2u);
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, a1, a3, "%s - RGB write IDL call failed\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::WritePropertyValueExclave()
{
  OUTLINED_FUNCTION_13(*MEMORY[0x263EF8340]);
  LODWORD(v2) = 136315906;
  OUTLINED_FUNCTION_33();
  OUTLINED_FUNCTION_5_0();
  OUTLINED_FUNCTION_16(&dword_24680F000, v0, v1, "[%s:%d] Invalid camChannel (%u / max:%u)\n\n", v2, v3, v4, v5);
}

void H16ISP::H16ISPDevice::ISP_GetExclavePlatformStatus()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - IOConnect Failed, status = 0x%08x\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::ISP_IsSafeToStartConclave()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, v0, v1, "%s - Could not get info required to safely start conclave, ret = 0x%x\n", v2, v3, v4, v5, 2u);
}

void H16ISP::H16ISPDevice::ISP_GetPDPConfig()
{
  uint64_t v3 = *MEMORY[0x263EF8340];
  OUTLINED_FUNCTION_2();
  OUTLINED_FUNCTION_9_0(&dword_24680F000, v0, v1, "failed to get PDP Configs - status=0x%X\n\n", v2);
}

void H16ISP::H16ISPDevice::GetChannelSensorID()
{
  OUTLINED_FUNCTION_0();
  OUTLINED_FUNCTION_1(&dword_24680F000, &_os_log_internal, v0, "%s - Error: invalid cache, chan: %d\n", v1, v2, v3, v4, 2u);
}

void H16ISP::H16ISPDevice::GetProcNameAndAuditToken(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

{
  OUTLINED_FUNCTION_2_0(&dword_24680F000, &_os_log_internal, a3, "%s - Unknown error from task_info\n", a5, a6, a7, a8, 2u);
}

void H16ISP::H16ISPDevice::GetProcNameAndAuditToken(uint64_t a1, int *a2, _DWORD *a3)
{
  uint64_t v31 = *MEMORY[0x263EF8340];
  int v3 = *a2;
  int v4 = a3[1082];
  int v5 = a3[1083];
  int v6 = a3[1084];
  int v7 = a3[1085];
  int v8 = a3[1086];
  int v9 = a3[1087];
  int v10 = a3[1088];
  int v11 = 136317442;
  uint64_t v12 = "GetProcNameAndAuditToken";
  __int16 v13 = 2080;
  uint64_t v14 = a1;
  __int16 v15 = 1024;
  int v16 = v3;
  __int16 v17 = 1024;
  int v18 = v4;
  __int16 v19 = 1024;
  int v20 = v5;
  __int16 v21 = 1024;
  int v22 = v6;
  __int16 v23 = 1024;
  int v24 = v7;
  __int16 v25 = 1024;
  int v26 = v8;
  __int16 v27 = 1024;
  int v28 = v9;
  __int16 v29 = 1024;
  int v30 = v10;
  _os_log_debug_impl(&dword_24680F000, &_os_log_internal, OS_LOG_TYPE_DEBUG, "%s - procNameForCIL:%s / audit_token:0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x/0x%08x\n", (uint8_t *)&v11, 0x46u);
}

void LSCAverageGreenApple()
{
  __assert_rtn("LSCAverageGreenApple", "LSCComputeFromNVM.cpp", 1308, "pLSCConfig->channelGR.gridCountY == pLSCConfig->channelGB.gridCountY");
}

{
  __assert_rtn("LSCAverageGreenApple", "LSCComputeFromNVM.cpp", 1307, "pLSCConfig->channelGR.gridCountX == pLSCConfig->channelGB.gridCountX");
}

void ScanPointsOnLine()
{
  __assert_rtn("ScanPointsOnLine", "Markers.cpp", 419, "maxPt.GetNumOfPoints()==1");
}

{
  __assert_rtn("ScanPointsOnLine", "Markers.cpp", 418, "direction.GetNumOfPoints()==1");
}

{
  __assert_rtn("ScanPointsOnLine", "Markers.cpp", 417, "startPt.GetNumOfPoints()==1");
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,unsigned int>>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>,std::reverse_iterator<MatrixNxPts<2u,unsigned int>*>>()
{
  OUTLINED_FUNCTION_0_3();
  do
  {
    OUTLINED_FUNCTION_2_3();
    (*v0)();
    uint64_t result = OUTLINED_FUNCTION_1_5();
  }
  while (!v2);
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<MatrixNxPts<2u,double>>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>,std::reverse_iterator<MatrixNxPts<2u,double>*>>()
{
  OUTLINED_FUNCTION_0_3();
  do
  {
    OUTLINED_FUNCTION_2_3();
    (*v0)();
    uint64_t result = OUTLINED_FUNCTION_1_5();
  }
  while (!v2);
  return result;
}

void dumpTailspinOnDispatchQueue_cold_1(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = *MEMORY[0x263EF8340];
  int v2 = 136315138;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "[TAILSPIN]Failed to create CFString for reason: %s\n", (uint8_t *)&v2, 0xCu);
}

void dumpTailspinOnDispatchQueue_cold_2(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void dumpTailspinOnDispatchQueue_cold_3(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void dumpTailspinOnDispatchQueue_cold_4()
{
  uint64_t v0 = __error();
  strerror(*v0);
  OUTLINED_FUNCTION_0_1(&dword_24680F000, v1, v2, "[TAILSPIN]Failed to open(\"%s\", O_RDWR | O_CREAT, 0644): %s!\n", v3, v4, v5, v6, 2u);
}

void dumpTailspinOnDispatchQueue_cold_5(uint64_t a1, NSObject *a2)
{
  uint64_t v9 = *MEMORY[0x263EF8340];
  int v4 = *__error();
  int v5 = 136315394;
  uint64_t v6 = a1;
  __int16 v7 = 1024;
  int v8 = v4;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "[TAILSPIN]Failed to create directory %s: %d!\n", (uint8_t *)&v5, 0x12u);
}

void dumpTailspinOnDispatchQueue_cold_6(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void __dumpTailspinWithOptionsOnQueue_block_invoke_cold_1(uint64_t a1)
{
  [*(id *)(a1 + 32) objectForKeyedSubscript:*MEMORY[0x263F8C838]];
  OUTLINED_FUNCTION_0_1(&dword_24680F000, v1, v2, "Unable to store tailspin with reason '%@' at path %s\n", v3, v4, v5, v6, 2u);
}

void H16ISP::H16ISPGeneralProcessFrameReceiver::completeAllRequests(uint64_t *a1, NSObject *a2)
{
  uint64_t v7 = *MEMORY[0x263EF8340];
  uint64_t v2 = *a1;
  int v3 = 136315394;
  uint64_t v4 = "completeAllRequests";
  __int16 v5 = 1024;
  int v6 = v2;
  _os_log_error_impl(&dword_24680F000, a2, OS_LOG_TYPE_ERROR, "%s - H16ISPGeneralProcessFrameReceiver: Did not get all pending requests back from kernel. remaining: %d.\n\n", (uint8_t *)&v3, 0x12u);
}

void ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechrunkitaerslt__decode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechrunkitaerslt__decode_cold_2(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechrunkitaersltv2__encode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechrunkitaersltv2__decode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechinfoset__encode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechinfoset__decode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechinfoset2__encode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechinfoset2__decode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechdpcset__encode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispexclavecorechdpcset__decode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_attentioninfo__encode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_attentioninfo__decode_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitisp_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispirexclavekit_sendcmdchconfigurationstatusread_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispirexclavekit_sendcmdchrunkitmdv2_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispirexclavekit_sendcmdexclavebootarg_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispirexclavekit_sendcmdexclavechpropertywrite_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispirexclavekit_sendcmdadsettings_cold_1(unsigned int a1)
{
}

void ispirexclavekitmodule_ispirexclavekit_sendcmdinfiltration_cold_1(unsigned int a1)
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_1(uint64_t a1)
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_2()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_3()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_4()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_6()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_8()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_10()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_12()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_14()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_16()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_18(unsigned int a1)
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_19()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_21()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_24()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_26()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_28()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_30()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_32()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_34()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_36()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_38()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_40()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_42()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_44()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_46()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_48()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_50()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_52()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_54()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_56()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_58()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_60()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_63()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_65()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_67()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_70()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_72(unsigned int a1)
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_73()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_76()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_79()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_82()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_83(unsigned int a1)
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_86()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_89()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_91(unsigned int a1)
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_92()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_94()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_97()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_99()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_101(unsigned int a1)
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_102()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_105()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_107()
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_109(unsigned int a1)
{
}

void __ispirexclavekitmodule_ispirexclavekit__server_start_owned_block_invoke_cold_110()
{
}

void ispirexclavekitmodule_ispexclaveproperty__decode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__encode_cold_2(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__decode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechrunkitaerslt__decode_cold_2(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechrunkitaersltv2__encode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechrunkitaersltv2__decode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechinfoset__encode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechinfoset__decode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechinfoset2__encode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechinfoset2__decode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechdpcset__encode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_ispexclavecorechdpcset__decode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_anstobject__encode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_anstobject__decode_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitisp_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitperception_cold_2(unsigned int a1)
{
}

void isprgbexclavekitmodule_isprgbexclavekit_sendcmdchrunkitmdv2_cold_2(unsigned int a1)
{
}

void isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavebootarg_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_isprgbexclavekit_sendcmdexclavechpropertywrite_cold_1(unsigned int a1)
{
}

void isprgbexclavekitmodule_isprgbexclavekit_sendcmdinfiltration_cold_1(unsigned int a1)
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_1(uint64_t a1)
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_4()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_6()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_8()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_10()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_12()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_14()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_16(unsigned int a1)
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_17()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_19()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_22()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_24()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_26()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_28()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_30()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_32()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_34()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_36()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_38()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_40()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_42()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_44()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_46()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_48()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_50()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_52()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_54()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_56()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_58()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_61()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_63()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_65()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_68()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_71()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_73()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_76()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_79()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_82()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_83(unsigned int a1)
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_85()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_88()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_91()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_92(unsigned int a1)
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_95()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_97()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_99(unsigned int a1)
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_100()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_102()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_105()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_107()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_109()
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_111(unsigned int a1)
{
}

void __isprgbexclavekitmodule_isprgbexclavekit__server_start_owned_block_invoke_cold_112()
{
}

void isprgbexclavekitmodule_ispexclaveproperty__decode_cold_1(unsigned int a1)
{
}

uint64_t AMFDRCreateInstanceString()
{
  return MEMORY[0x270F91D88]();
}

uint64_t AMFDRLogSetHandler()
{
  return MEMORY[0x270F91E80]();
}

uint64_t AMFDRSealingManifestCopyLocalDataForClass()
{
  return MEMORY[0x270F91F28]();
}

uint64_t AMFDRSealingMapCopyLocalDataForClass()
{
  return MEMORY[0x270F91F80]();
}

uint64_t AMFDRSealingMapCopyLocalDictForClass()
{
  return MEMORY[0x270F91F90]();
}

uint64_t AMFDRSealingMapCopyLocalMinimalManifestForInstance()
{
  return MEMORY[0x270F91F98]();
}

uint64_t AMSupportDigestSha384()
{
  return MEMORY[0x270F97A58]();
}

AudioComponent AudioComponentFindNext(AudioComponent inComponent, const AudioComponentDescription *inDesc)
{
  return (AudioComponent)MEMORY[0x270EE2048](inComponent, inDesc);
}

OSStatus AudioComponentInstanceDispose(AudioComponentInstance inInstance)
{
  return MEMORY[0x270EE2058](inInstance);
}

OSStatus AudioComponentInstanceNew(AudioComponent inComponent, AudioComponentInstance *outInstance)
{
  return MEMORY[0x270EE2068](inComponent, outInstance);
}

OSStatus AudioOutputUnitStart(AudioUnit ci)
{
  return MEMORY[0x270EE2158](ci);
}

OSStatus AudioOutputUnitStop(AudioUnit ci)
{
  return MEMORY[0x270EE2160](ci);
}

OSStatus AudioUnitGetProperty(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, void *outData, UInt32 *ioDataSize)
{
  return MEMORY[0x270EE22A8](inUnit, *(void *)&inID, *(void *)&inScope, *(void *)&inElement, outData, ioDataSize);
}

OSStatus AudioUnitInitialize(AudioUnit inUnit)
{
  return MEMORY[0x270EE22B8](inUnit);
}

OSStatus AudioUnitRender(AudioUnit inUnit, AudioUnitRenderActionFlags *ioActionFlags, const AudioTimeStamp *inTimeStamp, UInt32 inOutputBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData)
{
  return MEMORY[0x270EE22D0](inUnit, ioActionFlags, inTimeStamp, *(void *)&inOutputBusNumber, *(void *)&inNumberFrames, ioData);
}

OSStatus AudioUnitSetProperty(AudioUnit inUnit, AudioUnitPropertyID inID, AudioUnitScope inScope, AudioUnitElement inElement, const void *inData, UInt32 inDataSize)
{
  return MEMORY[0x270EE22E8](inUnit, *(void *)&inID, *(void *)&inScope, *(void *)&inElement, inData, *(void *)&inDataSize);
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B30](md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return MEMORY[0x270ED7B38](c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return MEMORY[0x270ED7B40](c, data, *(void *)&len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  MEMORY[0x270EE4278]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return MEMORY[0x270EE42E8](theArray, range.location, range.length, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return (CFArrayRef)MEMORY[0x270EE42F0](allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return (CFArrayRef)MEMORY[0x270EE42F8](allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x270EE4300](allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return (CFMutableArrayRef)MEMORY[0x270EE4310](allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x270EE4320](theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return MEMORY[0x270EE4348]();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x270EE4360](theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return MEMORY[0x270EE4528]();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return MEMORY[0x270EE4530](BOOLean);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x270EE4788](cf);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return (CFDataRef)MEMORY[0x270EE47C8](allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return (CFDataRef)MEMORY[0x270EE47D0](allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return (CFMutableDataRef)MEMORY[0x270EE47E0](allocator, capacity);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return (CFDataRef)MEMORY[0x270EE47F0](allocator, bytes, length, bytesDeallocator);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x270EE4808](theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x270EE4820](theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return (UInt8 *)MEMORY[0x270EE4830](theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return MEMORY[0x270EE4838]();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return MEMORY[0x270EE48F0](theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x270EE4908](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return (CFDictionaryRef)MEMORY[0x270EE4910](allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4920](allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EE4928](allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return MEMORY[0x270EE4930](theDict);
}

void CFDictionaryGetKeysAndValues(CFDictionaryRef theDict, const void **keys, const void **values)
{
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return MEMORY[0x270EE4948]();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x270EE4958](theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return MEMORY[0x270EE4968](theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return MEMORY[0x270EE4998](cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x270EE49A0](err);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return (CFAllocatorRef)MEMORY[0x270EE4A18](cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x270EE4A30](cf);
}

CFRunLoopSourceRef CFMachPortCreateRunLoopSource(CFAllocatorRef allocator, CFMachPortRef port, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x270EE4AE8](allocator, port, order);
}

CFMachPortRef CFMachPortCreateWithPort(CFAllocatorRef allocator, mach_port_t portNum, CFMachPortCallBack callout, CFMachPortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMachPortRef)MEMORY[0x270EE4AF0](allocator, *(void *)&portNum, callout, context, shouldFreeInfo);
}

void CFMachPortInvalidate(CFMachPortRef port)
{
}

CFMessagePortRef CFMessagePortCreateLocal(CFAllocatorRef allocator, CFStringRef name, CFMessagePortCallBack callout, CFMessagePortContext *context, Boolean *shouldFreeInfo)
{
  return (CFMessagePortRef)MEMORY[0x270EE4B28](allocator, name, callout, context, shouldFreeInfo);
}

CFMessagePortRef CFMessagePortCreateRemote(CFAllocatorRef allocator, CFStringRef name)
{
  return (CFMessagePortRef)MEMORY[0x270EE4B30](allocator, name);
}

CFRunLoopSourceRef CFMessagePortCreateRunLoopSource(CFAllocatorRef allocator, CFMessagePortRef local, CFIndex order)
{
  return (CFRunLoopSourceRef)MEMORY[0x270EE4B38](allocator, local, order);
}

void CFMessagePortInvalidate(CFMessagePortRef ms)
{
}

void CFMessagePortSetDispatchQueue(CFMessagePortRef ms, dispatch_queue_t queue)
{
}

void CFMessagePortSetInvalidationCallBack(CFMessagePortRef ms, CFMessagePortInvalidationCallBack callout)
{
}

CFTypeID CFNullGetTypeID(void)
{
  return MEMORY[0x270EE4BD0]();
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x270EE4BE8](allocator, theType, valuePtr);
}

CFNumberType CFNumberGetType(CFNumberRef number)
{
  return MEMORY[0x270EE4C50](number);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x270EE4C58]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x270EE4C70](number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return MEMORY[0x270EE4C78](number);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return (CFPropertyListRef)MEMORY[0x270EE4CC0](key, applicationID, userName, hostName);
}

CFPropertyListRef CFPropertyListCreateDeepCopy(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFOptionFlags mutabilityOption)
{
  return (CFPropertyListRef)MEMORY[0x270EE4D20](allocator, propertyList, mutabilityOption);
}

CFPropertyListRef CFPropertyListCreateWithStream(CFAllocatorRef allocator, CFReadStreamRef stream, CFIndex streamLength, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return (CFPropertyListRef)MEMORY[0x270EE4D48](allocator, stream, streamLength, options, format, error);
}

CFIndex CFPropertyListWrite(CFPropertyListRef propertyList, CFWriteStreamRef stream, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return MEMORY[0x270EE4D60](propertyList, stream, format, options, error);
}

void CFReadStreamClose(CFReadStreamRef stream)
{
}

CFReadStreamRef CFReadStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFReadStreamRef)MEMORY[0x270EE4D90](alloc, fileURL);
}

Boolean CFReadStreamOpen(CFReadStreamRef stream)
{
  return MEMORY[0x270EE4DB8](stream);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x270EE4E10](cf);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x270EE4E58]();
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

void CFRunLoopRun(void)
{
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x270EE4EE0](allocator, order, context);
}

void CFRunLoopSourceSignal(CFRunLoopSourceRef source)
{
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

CFRunLoopTimerRef CFRunLoopTimerCreate(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context)
{
  return (CFRunLoopTimerRef)MEMORY[0x270EE4F00](allocator, flags, order, callout, context, fireDate, interval);
}

void CFRunLoopTimerInvalidate(CFRunLoopTimerRef timer)
{
}

void CFRunLoopTimerSetNextFireDate(CFRunLoopTimerRef timer, CFAbsoluteTime fireDate)
{
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
}

void CFShow(CFTypeRef obj)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return MEMORY[0x270EE5048](theString1, theString2, compareOptions);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return (CFStringRef)MEMORY[0x270EE5098](alloc, theString);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return (CFMutableStringRef)MEMORY[0x270EE50B0](alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return (CFMutableStringRef)MEMORY[0x270EE50B8](alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x270EE50E0](alloc, cStr, *(void *)&encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return (CFStringRef)MEMORY[0x270EE5110](alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return (CFStringRef)MEMORY[0x270EE5128](alloc, str, range.location, range.length);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return MEMORY[0x270EE5178](theString, buffer, bufferSize, *(void *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x270EE5180](theString, *(void *)&encoding);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return MEMORY[0x270EE51C8](str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return MEMORY[0x270EE51D8](theString);
}

CFStringEncoding CFStringGetSystemEncoding(void)
{
  return MEMORY[0x270EE5210]();
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x270EE5218]();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return MEMORY[0x270EE5228](theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return MEMORY[0x270EE5230](theString, suffix);
}

void CFStringLowercase(CFMutableStringRef theString, CFLocaleRef locale)
{
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x270EE53F0](allocator, filePath, pathStyle, isDirectory);
}

void CFWriteStreamClose(CFWriteStreamRef stream)
{
}

CFWriteStreamRef CFWriteStreamCreateWithFile(CFAllocatorRef alloc, CFURLRef fileURL)
{
  return (CFWriteStreamRef)MEMORY[0x270EE5538](alloc, fileURL);
}

Boolean CFWriteStreamOpen(CFWriteStreamRef stream)
{
  return MEMORY[0x270EE5558](stream);
}

CGColorRef CGColorCreate(CGColorSpaceRef space, const CGFloat *components)
{
  return (CGColorRef)MEMORY[0x270EE5B50](space, components);
}

CGColorRef CGColorGetConstantColor(CFStringRef colorName)
{
  return (CGColorRef)MEMORY[0x270EE5BD8](colorName);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x270EE5C68]();
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x270EF4F38](url, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x270EF4F48](idst);
}

CFDictionaryRef CGPointCreateDictionaryRepresentation(CGPoint point)
{
  return (CFDictionaryRef)MEMORY[0x270EE7150]((__n128)point, *(__n128 *)&point.y);
}

BOOL CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point)
{
  return MEMORY[0x270EE7160](dict, point);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x270EE7188]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x270EE71A0]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x270EE7260]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x270EE7278](dict, rect);
}

CFDictionaryRef CGSizeCreateDictionaryRepresentation(CGSize size)
{
  return (CFDictionaryRef)MEMORY[0x270EE7340]((__n128)size, *(__n128 *)&size.height);
}

uint64_t CMBaseObjectGetDerivedStorage()
{
  return MEMORY[0x270EE79C0]();
}

OSStatus CMBufferQueueCreate(CFAllocatorRef allocator, CMItemCount capacity, const CMBufferCallbacks *callbacks, CMBufferQueueRef *queueOut)
{
  return MEMORY[0x270EE7A50](allocator, capacity, callbacks, queueOut);
}

OSStatus CMBufferQueueEnqueue(CMBufferQueueRef queue, CMBufferRef buf)
{
  return MEMORY[0x270EE7A60](queue, buf);
}

CMItemCount CMBufferQueueGetBufferCount(CMBufferQueueRef queue)
{
  return MEMORY[0x270EE7A68](queue);
}

const CMBufferCallbacks *CMBufferQueueGetCallbacksForUnsortedSampleBuffers(void)
{
  return (const CMBufferCallbacks *)MEMORY[0x270EE7A78]();
}

CMClockRef CMClockGetHostTimeClock(void)
{
  return (CMClockRef)MEMORY[0x270EE7AA0]();
}

uint64_t CMDerivedObjectCreate()
{
  return MEMORY[0x270EE7AD0]();
}

CFTypeRef CMGetAttachment(CMAttachmentBearerRef target, CFStringRef key, CMAttachmentMode *attachmentModeOut)
{
  return (CFTypeRef)MEMORY[0x270EE7B30](target, key, attachmentModeOut);
}

uint64_t CMNotificationCenterPostNotification()
{
  return MEMORY[0x270EE7B90]();
}

OSStatus CMSampleBufferCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, Boolean dataReady, CMSampleBufferMakeDataReadyCallback makeDataReadyCallback, void *makeDataReadyRefcon, CMVideoFormatDescriptionRef formatDescription, const CMSampleTimingInfo *sampleTiming, CMSampleBufferRef *sampleBufferOut)
{
  return MEMORY[0x270EE7BE8](allocator, imageBuffer, dataReady, makeDataReadyCallback, makeDataReadyRefcon, formatDescription, sampleTiming, sampleBufferOut);
}

CMBlockBufferRef CMSampleBufferGetDataBuffer(CMSampleBufferRef sbuf)
{
  return (CMBlockBufferRef)MEMORY[0x270EE7C18](sbuf);
}

CVImageBufferRef CMSampleBufferGetImageBuffer(CMSampleBufferRef sbuf)
{
  return (CVImageBufferRef)MEMORY[0x270EE7C48](sbuf);
}

CMTime *__cdecl CMSampleBufferGetPresentationTimeStamp(CMTime *__return_ptr retstr, CMSampleBufferRef sbuf)
{
  return (CMTime *)MEMORY[0x270EE7C78](retstr, sbuf);
}

void CMSetAttachment(CMAttachmentBearerRef target, CFStringRef key, CFTypeRef value, CMAttachmentMode attachmentMode)
{
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  return MEMORY[0x270EE7DD0](time1, time2);
}

CFDictionaryRef CMTimeCopyAsDictionary(CMTime *time, CFAllocatorRef allocator)
{
  return (CFDictionaryRef)MEMORY[0x270EE7DE0](time, allocator);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  MEMORY[0x270EE7E08](time);
  return result;
}

CMTime *__cdecl CMTimeMake(CMTime *__return_ptr retstr, int64_t value, int32_t timescale)
{
  return (CMTime *)MEMORY[0x270EE7E10](retstr, value, *(void *)&timescale);
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CFDictionaryRef dictionaryRepresentation)
{
  return (CMTime *)MEMORY[0x270EE7E20](retstr, dictionaryRepresentation);
}

CFDictionaryRef CMTimeRangeCopyAsDictionary(CMTimeRange *range, CFAllocatorRef allocator)
{
  return (CFDictionaryRef)MEMORY[0x270EE7E98](range, allocator);
}

CMTimeRange *__cdecl CMTimeRangeMake(CMTimeRange *__return_ptr retstr, CMTime *start, CMTime *duration)
{
  return (CMTimeRange *)MEMORY[0x270EE7EF8](retstr, start, duration);
}

CMTime *__cdecl CMTimeSubtract(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  return (CMTime *)MEMORY[0x270EE7F08](retstr, lhs, rhs);
}

OSStatus CMVideoFormatDescriptionCreate(CFAllocatorRef allocator, CMVideoCodecType codecType, int32_t width, int32_t height, CFDictionaryRef extensions, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  return MEMORY[0x270EE7FA8](allocator, *(void *)&codecType, *(void *)&width, *(void *)&height, extensions, formatDescriptionOut);
}

OSStatus CMVideoFormatDescriptionCreateForImageBuffer(CFAllocatorRef allocator, CVImageBufferRef imageBuffer, CMVideoFormatDescriptionRef *formatDescriptionOut)
{
  return MEMORY[0x270EE7FB8](allocator, imageBuffer, formatDescriptionOut);
}

uint64_t CRGetComponentState()
{
  return MEMORY[0x270F23238]();
}

uint64_t CVAFaceTrackingCreate()
{
  return MEMORY[0x270F0CEE8]();
}

uint64_t CVAFaceTrackingProcess()
{
  return MEMORY[0x270F0CEF8]();
}

uint64_t CVASegmentationCreate()
{
  return MEMORY[0x270F0CF00]();
}

uint64_t CVASegmentationCreateOutputInfo()
{
  return MEMORY[0x270F0CF08]();
}

uint64_t CVASegmentationProcess()
{
  return MEMORY[0x270F0CF10]();
}

CFTypeRef CVBufferCopyAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x270EE9FC0](buffer, key, attachmentMode);
}

CFTypeRef CVBufferGetAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x270EE9FD0](buffer, key, attachmentMode);
}

CFDictionaryRef CVBufferGetAttachments(CVBufferRef buffer, CVAttachmentMode attachmentMode)
{
  return (CFDictionaryRef)MEMORY[0x270EE9FD8](buffer, *(void *)&attachmentMode);
}

void CVBufferPropagateAttachments(CVBufferRef sourceBuffer, CVBufferRef destinationBuffer)
{
}

void CVBufferRelease(CVBufferRef buffer)
{
}

void CVBufferRemoveAllAttachments(CVBufferRef buffer)
{
}

void CVBufferRemoveAttachment(CVBufferRef buffer, CFStringRef key)
{
}

CVBufferRef CVBufferRetain(CVBufferRef buffer)
{
  return (CVBufferRef)MEMORY[0x270EEA008](buffer);
}

void CVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
}

uint64_t CVDataBufferGetDataSize()
{
  return MEMORY[0x270EEA048]();
}

uint64_t CVDataBufferGetIOSurface()
{
  return MEMORY[0x270EEA050]();
}

uint64_t CVDataBufferPoolCreateDataBufferWithAuxAttributes()
{
  return MEMORY[0x270EEA070]();
}

uint64_t CVDataBufferPoolGetDataBufferAttributes()
{
  return MEMORY[0x270EEA080]();
}

uint64_t CVDataBufferPoolGetMinBufferCount()
{
  return MEMORY[0x270EEA088]();
}

uint64_t CVDataBufferPoolGetTypeID()
{
  return MEMORY[0x270EEA090]();
}

uint64_t CVDataBufferPoolSetMinBufferCount()
{
  return MEMORY[0x270EEA098]();
}

uint64_t CVHWAFeatureExtractionConfigCreate()
{
  return MEMORY[0x270F0CF18]();
}

uint64_t CVHWAFeatureExtractionConfigRelease()
{
  return MEMORY[0x270F0CF28]();
}

uint64_t CVHWAFeatureExtractionConfigSetDetectionFlow()
{
  return MEMORY[0x270F0CF30]();
}

uint64_t CVHWAFeatureExtractionConfigSetDisablePostProcessing()
{
  return MEMORY[0x270F0CF38]();
}

uint64_t CVHWAFeatureExtractionConfigSetEnableDynamicThresholding()
{
  return MEMORY[0x270F0CF40]();
}

uint64_t CVHWAFeatureExtractionConfigSetEnableFeatureMatching()
{
  return MEMORY[0x270F0CF48]();
}

uint64_t CVHWAFeatureExtractionConfigSetEnableOrientationAssignment()
{
  return MEMORY[0x270F0CF50]();
}

uint64_t CVHWAFeatureExtractionConfigSetEnableParedGrid()
{
  return MEMORY[0x270F0CF58]();
}

uint64_t CVHWAFeatureExtractionConfigSetExtraTestThreshold()
{
  return MEMORY[0x270F0CF60]();
}

uint64_t CVHWAFeatureExtractionConfigSetFeatureMatchingDescriptorSize()
{
  return MEMORY[0x270F0CF68]();
}

uint64_t CVHWAFeatureExtractionConfigSetHammingDistanceThreshold()
{
  return MEMORY[0x270F0CF70]();
}

uint64_t CVHWAFeatureExtractionConfigSetImageSize()
{
  return MEMORY[0x270F0CF78]();
}

uint64_t CVHWAFeatureExtractionConfigSetMaxImageSize()
{
  return MEMORY[0x270F0CF80]();
}

uint64_t CVHWAFeatureExtractionConfigSetMaxNumberOfKeypoints()
{
  return MEMORY[0x270F0CF88]();
}

uint64_t CVHWAFeatureExtractionConfigSetNumberOfOctaves()
{
  return MEMORY[0x270F0CF90]();
}

uint64_t CVHWAFeatureExtractionConfigSetOrientationDistanceThreshold()
{
  return MEMORY[0x270F0CF98]();
}

uint64_t CVHWAFeatureExtractionConfigSetResponseThreshold()
{
  return MEMORY[0x270F0CFA0]();
}

uint64_t CVHWAFeatureExtractionConfigSetSigmaDistanceThreshold()
{
  return MEMORY[0x270F0CFA8]();
}

uint64_t CVHWAFeatureExtractionConfigSetSquareDistanceDisparityFraction()
{
  return MEMORY[0x270F0CFB0]();
}

uint64_t CVHWAFeatureExtractionConfigSetTargetNumberOfKeypoints()
{
  return MEMORY[0x270F0CFB8]();
}

uint64_t CVHWAFeatureExtractionCreate()
{
  return MEMORY[0x270F0CFC0]();
}

uint64_t CVHWAFeatureExtractionGetActionBuffer()
{
  return MEMORY[0x270F0D008]();
}

uint64_t CVHWAFeatureExtractionGetActionSizeInBytes()
{
  return MEMORY[0x270F0D010]();
}

uint64_t CVHWAFeatureExtractionGetDynamicThresholdingEnable()
{
  return MEMORY[0x270F0D018]();
}

uint64_t CVHWAFeatureExtractionGetDynamicThresholdingTargetKeypointsAtIndex()
{
  return MEMORY[0x270F0D020]();
}

uint64_t CVHWAFeatureExtractionGetDynamicThresholdingTargetKeypointsConfigCount()
{
  return MEMORY[0x270F0D028]();
}

uint64_t CVHWAFeatureExtractionGetLaccBuffer()
{
  return MEMORY[0x270F0D030]();
}

uint64_t CVHWAFeatureExtractionGetLaccSizeInBytes()
{
  return MEMORY[0x270F0D038]();
}

uint64_t CVHWAFeatureExtractionGetOperationBuffer()
{
  return MEMORY[0x270F0D040]();
}

uint64_t CVHWAFeatureExtractionGetOperationSizeInBytes()
{
  return MEMORY[0x270F0D048]();
}

uint64_t CVHWAFeatureExtractionGetOutputReserveSizeInBytes()
{
  return MEMORY[0x270F0D050]();
}

uint64_t CVHWAFeatureExtractionGetOutputSizeInBytes()
{
  return MEMORY[0x270F0D058]();
}

uint64_t CVHWAFeatureExtractionInitDirectWithLacc()
{
  return MEMORY[0x270F0D060]();
}

uint64_t CVHWAFeatureExtractionProcessHwOutputs()
{
  return MEMORY[0x270F0D078]();
}

uint64_t CVHWAFeatureExtractionRelease()
{
  return MEMORY[0x270F0D080]();
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x270EEA150](allocator, width, height, *(void *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

uint64_t CVPixelBufferCreateFromCVImageBufferRef()
{
  return MEMORY[0x270EEA158]();
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x270EEA190](pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return (void *)MEMORY[0x270EEA1A0](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA1B0](pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA1C8](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetDataSize(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA1D0](pixelBuffer);
}

void CVPixelBufferGetExtendedPixels(CVPixelBufferRef pixelBuffer, size_t *extraColumnsOnLeft, size_t *extraColumnsOnRight, size_t *extraRowsOnTop, size_t *extraRowsOnBottom)
{
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA1E8](pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA1F8](pixelBuffer, planeIndex);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x270EEA200](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA218](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA220](pixelBuffer);
}

CFTypeID CVPixelBufferGetTypeID(void)
{
  return MEMORY[0x270EEA230]();
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x270EEA240](pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x270EEA250](pixelBuffer, planeIndex);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x270EEA260](pixelBuffer, lockFlags);
}

uint64_t CVPixelBufferPoolCopyIOSurfaceCreationProperties()
{
  return MEMORY[0x270EEA270]();
}

CVReturn CVPixelBufferPoolCreate(CFAllocatorRef allocator, CFDictionaryRef poolAttributes, CFDictionaryRef pixelBufferAttributes, CVPixelBufferPoolRef *poolOut)
{
  return MEMORY[0x270EEA278](allocator, poolAttributes, pixelBufferAttributes, poolOut);
}

CVReturn CVPixelBufferPoolCreatePixelBuffer(CFAllocatorRef allocator, CVPixelBufferPoolRef pixelBufferPool, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x270EEA288](allocator, pixelBufferPool, pixelBufferOut);
}

CVReturn CVPixelBufferPoolCreatePixelBufferWithAuxAttributes(CFAllocatorRef allocator, CVPixelBufferPoolRef pixelBufferPool, CFDictionaryRef auxAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x270EEA298](allocator, pixelBufferPool, auxAttributes, pixelBufferOut);
}

uint64_t CVPixelBufferPoolGetMinBufferCount()
{
  return MEMORY[0x270EEA2B8]();
}

CFDictionaryRef CVPixelBufferPoolGetPixelBufferAttributes(CVPixelBufferPoolRef pool)
{
  return (CFDictionaryRef)MEMORY[0x270EEA2C0](pool);
}

CFTypeID CVPixelBufferPoolGetTypeID(void)
{
  return MEMORY[0x270EEA2C8]();
}

void CVPixelBufferPoolRelease(CVPixelBufferPoolRef pixelBufferPool)
{
}

CVPixelBufferPoolRef CVPixelBufferPoolRetain(CVPixelBufferPoolRef pixelBufferPool)
{
  return (CVPixelBufferPoolRef)MEMORY[0x270EEA2E8](pixelBufferPool);
}

uint64_t CVPixelBufferPoolScanIOSurfaces()
{
  return MEMORY[0x270EEA2F0]();
}

uint64_t CVPixelBufferPoolSetMinBufferCount()
{
  return MEMORY[0x270EEA308]();
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return (CVPixelBufferRef)MEMORY[0x270EEA320](texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x270EEA330](pixelBuffer, unlockFlags);
}

uint64_t CreatePixelBufferFromFile()
{
  return MEMORY[0x270F12DC0]();
}

uint64_t FigCFDictionaryGetCGRectIfPresent()
{
  return MEMORY[0x270EE8038]();
}

uint64_t FigCFDictionaryGetValueIfPresent()
{
  return MEMORY[0x270EE8088]();
}

uint64_t FigCaptureDeviceGetClassID()
{
  return MEMORY[0x270F12C48]();
}

uint64_t FigCaptureDeviceGetNotificationCenter()
{
  return MEMORY[0x270F12C58]();
}

uint64_t FigCaptureISPProcessingSessionGetClassID()
{
  return MEMORY[0x270F12C70]();
}

uint64_t FigCaptureStreamGetClassID()
{
  return MEMORY[0x270F12CE8]();
}

uint64_t FigCaptureStreamGetFigBaseObject()
{
  return MEMORY[0x270F12CF0]();
}

uint64_t FigCaptureStreamGetTypeID()
{
  return MEMORY[0x270F12CF8]();
}

uint64_t FigCaptureSynchronizedStreamsGroupGetClassID()
{
  return MEMORY[0x270F12D00]();
}

uint64_t FigCaptureSynchronizedStreamsGroupGetFigBaseObject()
{
  return MEMORY[0x270F12D08]();
}

uint64_t FigCaptureSynchronizedStreamsGroupGetTypeID()
{
  return MEMORY[0x270F12D10]();
}

uint64_t FigFormatDescriptionRelease()
{
  return MEMORY[0x270EE8228]();
}

uint64_t FigHostTimeToNanoseconds()
{
  return MEMORY[0x270EE82D0]();
}

uint64_t FigMotionCalculateAdjustedLensPosition()
{
  return MEMORY[0x270F12D30]();
}

uint64_t FigMotionComputeLensPositionScalingFactor()
{
  return MEMORY[0x270F12D48]();
}

uint64_t FigMotionComputePrincipalPoint()
{
  return MEMORY[0x270F12D50]();
}

uint64_t FigMotionGetGravityZ()
{
  return MEMORY[0x270F12D58]();
}

uint64_t FigNanosecondsToHostTime()
{
  return MEMORY[0x270EE82F0]();
}

kern_return_t IOConnectCallAsyncMethod(mach_port_t connection, uint32_t selector, mach_port_t wake_port, uint64_t *reference, uint32_t referenceCnt, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x270EF3F18](*(void *)&connection, *(void *)&selector, *(void *)&wake_port, reference, *(void *)&referenceCnt, input, *(void *)&inputCnt, inputStruct);
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x270EF3F30](*(void *)&connection, *(void *)&selector, input, *(void *)&inputCnt, inputStruct, inputStructCnt, output, outputCnt);
}

kern_return_t IOConnectCallScalarMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  return MEMORY[0x270EF3F38](*(void *)&connection, *(void *)&selector, input, *(void *)&inputCnt, output, outputCnt);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return MEMORY[0x270EF3F40](*(void *)&connection, *(void *)&selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

kern_return_t IOCreateReceivePort(uint32_t msgType, mach_port_t *recvPort)
{
  return MEMORY[0x270EF3FD0](*(void *)&msgType, recvPort);
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x270EF4340]();
}

uint64_t IOHIDEventGetType()
{
  return MEMORY[0x270EF4380]();
}

uint64_t IOHIDEventSystemClientActivate()
{
  return MEMORY[0x270EF4400]();
}

uint64_t IOHIDEventSystemClientCancel()
{
  return MEMORY[0x270EF4408]();
}

uint64_t IOHIDEventSystemClientCreateWithType()
{
  return MEMORY[0x270EF4428]();
}

uint64_t IOHIDEventSystemClientRegisterEventCallback()
{
  return MEMORY[0x270EF4450]();
}

uint64_t IOHIDEventSystemClientSetCancelHandler()
{
  return MEMORY[0x270EF4480]();
}

uint64_t IOHIDEventSystemClientSetDispatchQueue()
{
  return MEMORY[0x270EF4488]();
}

uint64_t IOHIDEventSystemClientSetMatchingMultiple()
{
  return MEMORY[0x270EF4498]();
}

uint64_t IOHIDEventSystemClientUnregisterEventCallback()
{
  return MEMORY[0x270EF44B0]();
}

uint64_t IOHIDEventSystemClientUnscheduleFromDispatchQueue()
{
  return MEMORY[0x270EF44C8]();
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x270EF4658](service, key);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return MEMORY[0x270EF4790](*(void *)&iterator);
}

kern_return_t IOMasterPort(mach_port_t bootstrapPort, mach_port_t *mainPort)
{
  return MEMORY[0x270EF47B0](*(void *)&bootstrapPort, mainPort);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return (IONotificationPortRef)MEMORY[0x270EF47B8](*(void *)&mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

CFRunLoopSourceRef IONotificationPortGetRunLoopSource(IONotificationPortRef notify)
{
  return (CFRunLoopSourceRef)MEMORY[0x270EF47D0](notify);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return MEMORY[0x270EF4820](*(void *)&object);
}

kern_return_t IORegistryEntryCreateCFProperties(io_registry_entry_t entry, CFMutableDictionaryRef *properties, CFAllocatorRef allocator, IOOptionBits options)
{
  return MEMORY[0x270EF49D0](*(void *)&entry, properties, allocator, *(void *)&options);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x270EF49D8](*(void *)&entry, key, allocator, *(void *)&options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return MEMORY[0x270EF49E8](*(void *)&mainPort, path);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return (CFTypeRef)MEMORY[0x270EF4A50](*(void *)&entry, plane, key, allocator, *(void *)&options);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return MEMORY[0x270EF4A80](notifyPort, *(void *)&service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceAddMatchingNotification(IONotificationPortRef notifyPort, const io_name_t notificationType, CFDictionaryRef matching, IOServiceMatchingCallback callback, void *refCon, io_iterator_t *notification)
{
  return MEMORY[0x270EF4A88](notifyPort, notificationType, matching, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return MEMORY[0x270EF4A98](*(void *)&connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return MEMORY[0x270EF4AB0](*(void *)&mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return MEMORY[0x270EF4AB8](*(void *)&mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EF4AD0](name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return (CFMutableDictionaryRef)MEMORY[0x270EF4AD8](name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return MEMORY[0x270EF4AE0](*(void *)&service, *(void *)&owningTask, *(void *)&type, connect);
}

IOSurfaceRef IOSurfaceCreate(CFDictionaryRef properties)
{
  return (IOSurfaceRef)MEMORY[0x270EF4C28](properties);
}

xpc_object_t IOSurfaceCreateXPCObject(IOSurfaceRef aSurface)
{
  return (xpc_object_t)MEMORY[0x270EF4C38](aSurface);
}

size_t IOSurfaceGetAllocSize(IOSurfaceRef buffer)
{
  return MEMORY[0x270EF4C50](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x270EF4C58](buffer);
}

uint64_t IOSurfaceGetBaseAddressOfCompressedTileDataRegionOfPlane()
{
  return MEMORY[0x270EF4C60]();
}

uint64_t IOSurfaceGetBaseAddressOfCompressedTileHeaderRegionOfPlane()
{
  return MEMORY[0x270EF4C70]();
}

uint64_t IOSurfaceGetBytesPerRowOfTileDataOfPlane()
{
  return MEMORY[0x270EF4CC8]();
}

uint64_t IOSurfaceGetCompressionFootprintOfPlane()
{
  return MEMORY[0x270EF4CF0]();
}

size_t IOSurfaceGetHeightOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x270EF4D58](buffer, planeIndex);
}

IOSurfaceID IOSurfaceGetID(IOSurfaceRef buffer)
{
  return MEMORY[0x270EF4D68](buffer);
}

size_t IOSurfaceGetWidthOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x270EF4DF0](buffer, planeIndex);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x270EF4E18](buffer, *(void *)&options, seed);
}

uint64_t IOSurfaceSetCompressedTileDataRegionMemoryUsedOfPlane()
{
  return MEMORY[0x270EF4E48]();
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x270EF4E88](buffer, *(void *)&options, seed);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x270F95F98]();
}

uint64_t MGCopyAnswerWithError()
{
  return MEMORY[0x270F95FA8]();
}

uint64_t MGGetFloat32Answer()
{
  return MEMORY[0x270F95FD0]();
}

uint64_t MGIsQuestionValid()
{
  return MEMORY[0x270F96018]();
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x270EF5E20]();
}

void NSLog(NSString *format, ...)
{
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x270EF2C48]();
}

uint64_t PDPeridotCalibCalibrationBlobsFromNVM()
{
  return MEMORY[0x270F53590]();
}

uint64_t PDPeridotCalibCopySerialNumber()
{
  return MEMORY[0x270F53598]();
}

uint64_t PDPeridotCalibCreateBinaryRepresentation()
{
  return MEMORY[0x270F535A0]();
}

uint64_t PDPeridotCalibCreateIspFirmwareCalibWithOptions()
{
  return MEMORY[0x270F535A8]();
}

uint64_t PDPeridotCalibCreateWithBinaryRepresentation()
{
  return MEMORY[0x270F535B0]();
}

uint64_t PDPeridotCalibCreateWithCalibrationDictionary()
{
  return MEMORY[0x270F535B8]();
}

uint64_t PDPeridotCalibGetMpcUUID()
{
  return MEMORY[0x270F535C0]();
}

uint64_t PDPeridotCalibGetMpcUUIDFromCalibrationBlob()
{
  return MEMORY[0x270F535C8]();
}

uint64_t PDPeridotCalibGetOperationalWideToPeridotTransform()
{
  return MEMORY[0x270F535D0]();
}

uint64_t PDPeridotCalibResetStray()
{
  return MEMORY[0x270F535D8]();
}

OSStatus VTCreateCGImageFromCVPixelBuffer(CVPixelBufferRef pixelBuffer, CFDictionaryRef options, CGImageRef *imageOut)
{
  return MEMORY[0x270F06678](pixelBuffer, options, imageOut);
}

OSStatus VTPixelTransferSessionCreate(CFAllocatorRef allocator, VTPixelTransferSessionRef *pixelTransferSessionOut)
{
  return MEMORY[0x270F067E0](allocator, pixelTransferSessionOut);
}

void VTPixelTransferSessionInvalidate(VTPixelTransferSessionRef session)
{
}

OSStatus VTPixelTransferSessionTransferImage(VTPixelTransferSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x270F067F0](session, sourceBuffer, destinationBuffer);
}

uint64_t VTTemporalFilterSessionCompleteFrames()
{
  return MEMORY[0x270F06828]();
}

uint64_t VTTemporalFilterSessionCreate()
{
  return MEMORY[0x270F06830]();
}

uint64_t VTTemporalFilterSessionInvalidate()
{
  return MEMORY[0x270F06838]();
}

uint64_t VTTemporalFilterSessionProcessFrame()
{
  return MEMORY[0x270F06840]();
}

uint64_t _AXSClassicInvertColorsEnabled()
{
  return MEMORY[0x270F90680]();
}

uint64_t _AXSInvertColorsEnabled()
{
  return MEMORY[0x270F90880]();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return (void *)MEMORY[0x270ED7CD8](aBlock);
}

void _Block_object_assign(void *a1, const void *a2, const int a3)
{
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

char ***_NSGetEnviron(void)
{
  return (char ***)MEMORY[0x270ED7D08]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void CICComputeFromNVMApple<unsigned char>()
{
  while (1)
    ;
}

void CICComputeFromNVMApple<unsigned short>()
{
  while (1)
    ;
}

void LSCComputeFromNVMApple<unsigned char>()
{
  while (1)
    ;
}

void LSCComputeFromNVMApple<unsigned short>()
{
  while (1)
    ;
}

void ImageUtils::ExtractPatch<double>()
{
  while (1)
    ;
}

void ImageUtils::ConnectedComp<BOOL>()
{
  while (1)
    ;
}

void ImageUtils::IntegralImage<double>()
{
  while (1)
    ;
}

void ImageUtils::AdaptiveThreshold<double>()
{
  while (1)
    ;
}

void ImageUtils::Rot90<BOOL>()
{
  while (1)
    ;
}

void ImageUtils::Rot90<double>()
{
  while (1)
    ;
}

void ImageUtils::Scale<double>()
{
  while (1)
    ;
}

void ImageUtils::Fliplr<double>()
{
  while (1)
    ;
}

void ImageUtils::Flipud<double>()
{
  while (1)
    ;
}

void ImageUtils::Gradient<double>()
{
  while (1)
    ;
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x270F982E8](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x270F982F8](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x270F98330](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x270F98428](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x270F98458](__n);
}

void std::string::__grow_by_and_replace(std::string *this, std::string::size_type __old_cap, std::string::size_type __delta_cap, std::string::size_type __old_sz, std::string::size_type __n_copy, std::string::size_type __n_del, std::string::size_type __n_add, const std::string::value_type *__p_new_stuff)
{
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x270F984A0](this, __s, __n);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x270F98560](this, __str);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x270F98638]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x270F98640]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x270F98650]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x270F98658]();
}

uint64_t std::istream::read()
{
  return MEMORY[0x270F98678]();
}

uint64_t std::istream::tellg()
{
  return MEMORY[0x270F98698]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x270F986D0]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x270F98740]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x270F98748]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x270F98750]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x270F98758]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x270F98760]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x270F98770]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x270F98790]();
}

{
  return MEMORY[0x270F987A0]();
}

{
  return MEMORY[0x270F987A8]();
}

{
  return MEMORY[0x270F987B0]();
}

{
  return MEMORY[0x270F987C0]();
}

{
  return MEMORY[0x270F987C8]();
}

{
  return MEMORY[0x270F987D0]();
}

{
  return MEMORY[0x270F987E0]();
}

uint64_t std::ifstream::open()
{
  return MEMORY[0x270F98868]();
}

uint64_t std::iostream::~basic_iostream()
{
  return MEMORY[0x270F98870]();
}

uint64_t std::ofstream::open()
{
  return MEMORY[0x270F98880]();
}

std::__thread_struct *__cdecl std::__thread_struct::__thread_struct(std::__thread_struct *this)
{
  return (std::__thread_struct *)MEMORY[0x270F98898](this);
}

void std::__thread_struct::~__thread_struct(std::__thread_struct *this)
{
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x270F988A8]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x270F988B0]();
}

std::__thread_specific_ptr<std::__thread_struct> *std::__thread_local_data(void)
{
  return (std::__thread_specific_ptr<std::__thread_struct> *)MEMORY[0x270F989F8]();
}

void std::__throw_system_error(int __ev, const char *__what_arg)
{
}

void std::mutex::lock(std::mutex *this)
{
}

void std::mutex::unlock(std::mutex *this)
{
}

void std::mutex::~mutex(std::mutex *this)
{
}

std::chrono::steady_clock::time_point std::chrono::steady_clock::now(void)
{
  return (std::chrono::steady_clock::time_point)MEMORY[0x270F98C18]();
}

std::chrono::system_clock::time_point std::chrono::system_clock::now(void)
{
  return (std::chrono::system_clock::time_point)MEMORY[0x270F98C28]();
}

void std::locale::~locale(std::locale *this)
{
}

unsigned int std::thread::hardware_concurrency(void)
{
  return MEMORY[0x270F98C98]();
}

void std::thread::join(std::thread *this)
{
}

void std::thread::~thread(std::thread *this)
{
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x270F98DE8]();
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x270F98EC0](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x270ED7DA0](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x270F98ED8](a1);
}

void __cxa_end_catch(void)
{
}

void __cxa_free_exception(void *a1)
{
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x270F98F10](a1);
}

void __cxa_guard_release(__guard *a1)
{
}

void __cxa_rethrow(void)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

int *__error(void)
{
  return (int *)MEMORY[0x270ED7DC0]();
}

__double2 __sincos_stret(double a1)
{
  MEMORY[0x270ED7E88](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

uint64_t __strncpy_chk()
{
  return MEMORY[0x270ED7EF0]();
}

uint64_t _os_crash()
{
  return MEMORY[0x270ED8060]();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _os_log_unreliable_impl()
{
  return MEMORY[0x270ED80C0]();
}

long double acos(long double __x)
{
  MEMORY[0x270ED8588](__x);
  return result;
}

uint64_t analytics_send_event_lazy()
{
  return MEMORY[0x270F18A78]();
}

long double atan(long double __x)
{
  MEMORY[0x270ED86A0](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  MEMORY[0x270ED86A8](__y, __x);
  return result;
}

int bcmp(const void *a1, const void *a2, size_t a3)
{
  return MEMORY[0x270ED8750](a1, a2, a3);
}

uint64_t bfpn_correction_create_dict_from_metadata()
{
  return MEMORY[0x270F12E08]();
}

uint64_t bfpn_create_correction_model_from_fdr()
{
  return MEMORY[0x270F12E10]();
}

void bzero(void *a1, size_t a2)
{
}

uint64_t cc_cmp_safe()
{
  return MEMORY[0x270ED87D8]();
}

uint64_t ccdigest()
{
  return MEMORY[0x270ED8A40]();
}

uint64_t ccdigest_init()
{
  return MEMORY[0x270ED8A48]();
}

uint64_t ccdigest_update()
{
  return MEMORY[0x270ED8A50]();
}

uint64_t ccec_get_cp()
{
  return MEMORY[0x270ED8AD0]();
}

uint64_t ccec_import_pub()
{
  return MEMORY[0x270ED8AD8]();
}

uint64_t ccec_keysize_is_supported()
{
  return MEMORY[0x270ED8AE0]();
}

uint64_t ccec_verify()
{
  return MEMORY[0x270ED8B00]();
}

uint64_t ccec_x963_import_pub_size()
{
  return MEMORY[0x270ED8B28]();
}

uint64_t ccrsa_make_pub()
{
  return MEMORY[0x270ED8D20]();
}

uint64_t ccrsa_verify_pkcs1v15()
{
  return MEMORY[0x270ED8D38]();
}

uint64_t ccrsa_verify_pkcs1v15_digest()
{
  return MEMORY[0x270ED8D48]();
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return MEMORY[0x270ED8EF0](*(void *)&__clock_id, __tp);
}

int close(int a1)
{
  return MEMORY[0x270ED8F18](*(void *)&a1);
}

size_t compression_decode_buffer(uint8_t *dst_buffer, size_t dst_size, const uint8_t *src_buffer, size_t src_size, void *scratch_buffer, compression_algorithm algorithm)
{
  return MEMORY[0x270F98F48](dst_buffer, dst_size, src_buffer, src_size, scratch_buffer, *(void *)&algorithm);
}

long double cos(long double __x)
{
  MEMORY[0x270ED9128](__x);
  return result;
}

float cosf(float a1)
{
  MEMORY[0x270ED9130](a1);
  return result;
}

int dgels_(char *__trans, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x270EDE538](__trans, __m, __n, __nrhs, __a, __lda, __b, __ldb);
}

int dgesdd_(char *__jobz, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__iwork, __CLPK_integer *__info)
{
  return MEMORY[0x270EDE578](__jobz, __m, __n, __a, __lda, __s, __u, __ldu);
}

int dgesvd_(char *__jobu, char *__jobvt, __CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__s, __CLPK_doublereal *__u, __CLPK_integer *__ldu, __CLPK_doublereal *__vt, __CLPK_integer *__ldvt, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x270EDE590](__jobu, __jobvt, __m, __n, __a, __lda, __s, __u);
}

double difftime(time_t a1, time_t a2)
{
  MEMORY[0x270ED9180](a1, a2);
  return result;
}

char *__cdecl dirname(char *a1)
{
  return (char *)MEMORY[0x270ED9190](a1);
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x270ED9318](identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x270ED9340]();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x270ED9378](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

uint64_t dispatch_pthread_root_queue_create()
{
  return MEMORY[0x270ED9438]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x270ED9458](attr, *(void *)&qos_class, *(void *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x270ED9460](label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x270ED94B8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x270ED94C8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x270ED94D0](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x270ED9510](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x270ED95A8](when, delta);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x270ED95D0](label);
}

void dispatch_workloop_set_os_workgroup(dispatch_workloop_t workloop, os_workgroup_t workgroup)
{
}

long double exp(long double __x)
{
  MEMORY[0x270ED9858](__x);
  return result;
}

long double exp2(long double __x)
{
  MEMORY[0x270ED9860](__x);
  return result;
}

float expf(float a1)
{
  MEMORY[0x270ED9870](a1);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x270ED98C8](a1);
}

int fcntl(int a1, int a2, ...)
{
  return MEMORY[0x270ED98D0](*(void *)&a1, *(void *)&a2);
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  return (FILE *)MEMORY[0x270ED98E8](*(void *)&a1, a2);
}

int fflush(FILE *a1)
{
  return MEMORY[0x270ED9938](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x270ED9968](a1, *(void *)&a2, a3);
}

long double fmod(long double __x, long double __y)
{
  MEMORY[0x270ED99D0](__x, __y);
  return result;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x270ED99F0](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x270ED9A08](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x270ED9A18](*(void *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x270ED9A20](a1, a2);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9A28](__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  return MEMORY[0x270ED9AC8](__stream, a2, *(void *)&__whence);
}

int fsync(int a1)
{
  return MEMORY[0x270ED9B10](*(void *)&a1);
}

off_t ftello(FILE *__stream)
{
  return MEMORY[0x270ED9B20](__stream);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x270ED9B88](__ptr, __size, __nitems, __stream);
}

pid_t getpid(void)
{
  return MEMORY[0x270ED9CE0]();
}

int gettimeofday(timeval *a1, void *a2)
{
  return MEMORY[0x270ED9D98](a1, a2);
}

int inflate(z_streamp strm, int flush)
{
  return MEMORY[0x270F9C730](strm, *(void *)&flush);
}

int inflateEnd(z_streamp strm)
{
  return MEMORY[0x270F9C738](strm);
}

int inflateInit2_(z_streamp strm, int windowBits, const char *version, int stream_size)
{
  return MEMORY[0x270F9C740](strm, *(void *)&windowBits, version, *(void *)&stream_size);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x270ED9F50]();
}

long double ldexp(long double __x, int __e)
{
  MEMORY[0x270EDA028](*(void *)&__e, __x);
  return result;
}

tm *__cdecl localtime(const time_t *a1)
{
  return (tm *)MEMORY[0x270EDA098](a1);
}

long double log(long double __x)
{
  MEMORY[0x270EDA0A8](__x);
  return result;
}

long double log10(long double __x)
{
  MEMORY[0x270EDA0B0](__x);
  return result;
}

float log10f(float a1)
{
  MEMORY[0x270EDA0B8](a1);
  return result;
}

long double log2(long double __x)
{
  MEMORY[0x270EDA0D8](__x);
  return result;
}

float log2f(float a1)
{
  MEMORY[0x270EDA0E0](a1);
  return result;
}

float logf(float a1)
{
  MEMORY[0x270EDA0F8](a1);
  return result;
}

off_t lseek(int a1, off_t a2, int a3)
{
  return MEMORY[0x270EDA118](*(void *)&a1, a2, *(void *)&a3);
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x270EDA138]();
}

uint64_t mach_continuous_time(void)
{
  return MEMORY[0x270EDA158]();
}

kern_return_t mach_port_mod_refs(ipc_space_t task, mach_port_name_t name, mach_port_right_t right, mach_port_delta_t delta)
{
  return MEMORY[0x270EDA210](*(void *)&task, *(void *)&name, *(void *)&right, *(void *)&delta);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x270EDA288](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA388](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x270EDA390](size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x270EDA468](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x270EDA470](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x270EDA488](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x270EDA498](__b, *(void *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

int mkdir(const char *a1, mode_t a2)
{
  return MEMORY[0x270EDA518](a1, a2);
}

int mkpath_np(const char *path, mode_t omode)
{
  return MEMORY[0x270EDA550](path, omode);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x270EDA738](*(void *)&token);
}

BOOL notify_is_valid_token(int val)
{
  return MEMORY[0x270EDA750](*(void *)&val);
}

uint32_t notify_post(const char *name)
{
  return MEMORY[0x270EDA760](name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return MEMORY[0x270EDA768](name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x270EDA770](name, out_token, queue, handler);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return MEMORY[0x270EDA798](*(void *)&token, state64);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x270F9A528](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x270F9A540]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x270F9A568](a1);
}

{
  MEMORY[0x270F9A570](context);
}

{
  return (void *)MEMORY[0x270F9A588]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x270F9A590](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x270F9A5A8]();
}

void objc_enumerationMutation(id obj)
{
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x270F9A6E8](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x270F9A6F8]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x270F9A700]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x270F9A710]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x270F9A728]();
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x270F9A870](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x270F9A880](a1);
}

void objc_storeStrong(id *location, id obj)
{
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x270EDA828](a1, *(void *)&a2);
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return MEMORY[0x270EDA830](a1, *(void *)&a2, *(void *)&a3, *(void *)&a4);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x270EDA9A0](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x270EDA9D0](oslog, type);
}

void os_release(void *object)
{
}

uint64_t os_transaction_create()
{
  return MEMORY[0x270EDAA90]();
}

uint64_t os_variant_has_internal_diagnostics()
{
  return MEMORY[0x270EDAB40]();
}

uint64_t os_workgroup_attr_set_flags()
{
  return MEMORY[0x270EDAB68]();
}

void os_workgroup_cancel(os_workgroup_t wg)
{
}

uint64_t os_workgroup_create()
{
  return MEMORY[0x270EDAB88]();
}

void perror(const char *a1)
{
}

int posix_spawnp(pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  return MEMORY[0x270EDACF0](a1, a2, a3, a4, __argv, __envp);
}

long double pow(long double __x, long double __y)
{
  MEMORY[0x270EDACF8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  MEMORY[0x270EDAD00](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x270EDAD20](a1);
}

int proc_pidinfo(int pid, int flavor, uint64_t arg, void *buffer, int buffersize)
{
  return MEMORY[0x270EDAD78](*(void *)&pid, *(void *)&flavor, arg, buffer, *(void *)&buffersize);
}

int proc_pidpath(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x270EDAD88](*(void *)&pid, buffer, *(void *)&buffersize);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x270EDADF8](a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return MEMORY[0x270EDAE00](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x270EDAE10](a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x270EDAE20](a1, *(void *)&a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x270EDAE30](a1, a2);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return MEMORY[0x270EDAE50](a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return MEMORY[0x270EDAE58](a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return MEMORY[0x270EDAE60](a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return MEMORY[0x270EDAE68](a1);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x270EDAE78](a1, a2, a3);
}

int pthread_cond_timedwait_relative_np(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return MEMORY[0x270EDAE80](a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return MEMORY[0x270EDAE88](a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return MEMORY[0x270EDAEA0](a1, a2, a3, a4);
}

int pthread_join(pthread_t a1, void **a2)
{
  return MEMORY[0x270EDAF10](a1, a2);
}

mach_port_t pthread_mach_thread_np(pthread_t a1)
{
  return MEMORY[0x270EDAF38](a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF50](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x270EDAF58](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF60](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x270EDAF70](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x270EDAF78](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x270EDAF80](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x270EDAF98](a1, *(void *)&a2);
}

pthread_t pthread_self(void)
{
  return (pthread_t)MEMORY[0x270EDB010]();
}

int pthread_setname_np(const char *a1)
{
  return MEMORY[0x270EDB038](a1);
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return MEMORY[0x270EDB048](a1, a2);
}

int putchar(int a1)
{
  return MEMORY[0x270EDB090](*(void *)&a1);
}

int puts(const char *a1)
{
  return MEMORY[0x270EDB098](a1);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

ssize_t read(int a1, void *a2, size_t a3)
{
  return MEMORY[0x270EDB120](*(void *)&a1, a2, a3);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return MEMORY[0x270EDB1E8](__p, __ec);
}

void rename(const std::__fs::filesystem::path *__from, const std::__fs::filesystem::path *__to, std::error_code *__ec)
{
}

void rewind(FILE *a1)
{
}

char *__cdecl setlocale(int a1, const char *a2)
{
  return (char *)MEMORY[0x270EDB408](*(void *)&a1, a2);
}

long double sin(long double __x)
{
  MEMORY[0x270EDB4E8](__x);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x270EDB510](__str, __size, __format);
}

int sprintf(char *a1, const char *a2, ...)
{
  return MEMORY[0x270EDB530](a1, a2);
}

int stat(const char *a1, stat *a2)
{
  return MEMORY[0x270EDB568](a1, a2);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x270EDB5A0](__s1, __s2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x270EDB5B0](__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return (char *)MEMORY[0x270EDB5C0](__dst, __src);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x270EDB5D8](*(void *)&__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return MEMORY[0x270EDB5F0](a1, a2, a3, a4);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x270EDB5F8](__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x270EDB600](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x270EDB610](__s);
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  return (char *)MEMORY[0x270EDB630](__s1, __s2, __n);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x270EDB638](__s1, __s2, __n);
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  return (char *)MEMORY[0x270EDB648](__dst, __src, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x270EDB680](__s, *(void *)&__c);
}

char *__cdecl strstr(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x270EDB6A0](__s1, __s2);
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return (char *)MEMORY[0x270EDB6C8](__str, __sep);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB6D8](__str, __endptr, *(void *)&__base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x270EDB708](__str, __endptr, *(void *)&__base);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x270EDB7D0](a1, *(void *)&a2, a3, a4, a5, a6);
}

uint64_t tailspin_dump_output_with_options()
{
  return MEMORY[0x270F9B9B0]();
}

uint64_t tailspin_dump_output_with_options_sync()
{
  return MEMORY[0x270F9B9B8]();
}

long double tan(long double __x)
{
  MEMORY[0x270EDB810](__x);
  return result;
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x270EDB868](*(void *)&target_task, *(void *)&flavor, task_info_out, task_info_outCnt);
}

uint64_t tb_client_connection_activate()
{
  return MEMORY[0x270F7E0B0]();
}

uint64_t tb_client_connection_create_with_endpoint()
{
  return MEMORY[0x270F7E0C8]();
}

uint64_t tb_client_connection_create_with_endpoint_static()
{
  return MEMORY[0x270F7E0D0]();
}

uint64_t tb_client_connection_destruct()
{
  return MEMORY[0x270F7E0D8]();
}

uint64_t tb_client_connection_message_construct()
{
  return MEMORY[0x270F7E0E8]();
}

uint64_t tb_client_connection_message_destruct()
{
  return MEMORY[0x270F7E0F0]();
}

uint64_t tb_conclave_endpoint_for_service()
{
  return MEMORY[0x270F7E100]();
}

uint64_t tb_connection_send_query()
{
  return MEMORY[0x270F7E110]();
}

uint64_t tb_endpoint_set_interface_identifier()
{
  return MEMORY[0x270F7E128]();
}

uint64_t tb_message_complete()
{
  return MEMORY[0x270F7E140]();
}

uint64_t tb_message_decode_BOOL()
{
  return MEMORY[0x270F7E158]();
}

uint64_t tb_message_decode_f32()
{
  return MEMORY[0x270F7E170]();
}

uint64_t tb_message_decode_f64()
{
  return MEMORY[0x270F7E178]();
}

uint64_t tb_message_decode_s16()
{
  return MEMORY[0x270F7E188]();
}

uint64_t tb_message_decode_s32()
{
  return MEMORY[0x270F7E190]();
}

uint64_t tb_message_decode_s8()
{
  return MEMORY[0x270F7E198]();
}

uint64_t tb_message_decode_u16()
{
  return MEMORY[0x270F7E1A0]();
}

uint64_t tb_message_decode_u32()
{
  return MEMORY[0x270F7E1A8]();
}

uint64_t tb_message_decode_u64()
{
  return MEMORY[0x270F7E1B8]();
}

uint64_t tb_message_decode_u8()
{
  return MEMORY[0x270F7E1C8]();
}

uint64_t tb_message_encode_BOOL()
{
  return MEMORY[0x270F7E1D8]();
}

uint64_t tb_message_encode_f32()
{
  return MEMORY[0x270F7E1E0]();
}

uint64_t tb_message_encode_f64()
{
  return MEMORY[0x270F7E1F0]();
}

uint64_t tb_message_encode_s16()
{
  return MEMORY[0x270F7E1F8]();
}

uint64_t tb_message_encode_s32()
{
  return MEMORY[0x270F7E200]();
}

uint64_t tb_message_encode_s8()
{
  return MEMORY[0x270F7E208]();
}

uint64_t tb_message_encode_u16()
{
  return MEMORY[0x270F7E210]();
}

uint64_t tb_message_encode_u32()
{
  return MEMORY[0x270F7E220]();
}

uint64_t tb_message_encode_u64()
{
  return MEMORY[0x270F7E230]();
}

uint64_t tb_message_encode_u8()
{
  return MEMORY[0x270F7E238]();
}

uint64_t tb_service_connection_activate()
{
  return MEMORY[0x270F7E248]();
}

uint64_t tb_service_connection_create_with_endpoint()
{
  return MEMORY[0x270F7E250]();
}

uint64_t tb_service_connection_destruct()
{
  return MEMORY[0x270F7E258]();
}

uint64_t tb_service_connection_message_configure_reply()
{
  return MEMORY[0x270F7E260]();
}

kern_return_t thread_info(thread_inspect_t target_act, thread_flavor_t flavor, thread_info_t thread_info_out, mach_msg_type_number_t *thread_info_outCnt)
{
  return MEMORY[0x270EDB8F8](*(void *)&target_act, *(void *)&flavor, thread_info_out, thread_info_outCnt);
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return MEMORY[0x270EDB908](*(void *)&thread, *(void *)&flavor, policy_info, *(void *)&policy_infoCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x270EDB930](a1);
}

mode_t umask(mode_t a1)
{
  return MEMORY[0x270EDB988](a1);
}

int usleep(useconds_t a1)
{
  return MEMORY[0x270EDB9E8](*(void *)&a1);
}

FFTSetup vDSP_create_fftsetup(vDSP_Length __Log2n, FFTRadix __Radix)
{
  return (FFTSetup)MEMORY[0x270EDE9D0](__Log2n, *(void *)&__Radix);
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
}

void vDSP_desamp(const float *__A, vDSP_Stride __DF, const float *__F, float *__C, vDSP_Length __N, vDSP_Length __P)
{
}

void vDSP_destroy_fftsetup(FFTSetup __setup)
{
}

void vDSP_fft_zrip(FFTSetup __Setup, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __Log2N, FFTDirection __Direction)
{
}

void vDSP_imgfir(const float *__A, vDSP_Length __NR, vDSP_Length __NC, const float *__F, float *__C, vDSP_Length __P, vDSP_Length __Q)
{
}

void vDSP_imgfirD(const double *__A, vDSP_Length __NR, vDSP_Length __NC, const double *__F, double *__C, vDSP_Length __P, vDSP_Length __Q)
{
}

void vDSP_maxv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_maxvD(const double *__A, vDSP_Stride __I, double *__C, vDSP_Length __N)
{
}

void vDSP_maxvi(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length *__I, vDSP_Length __N)
{
}

void vDSP_meanv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_meanvD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Length __N)
{
}

void vDSP_minv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_minvD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Length __N)
{
}

void vDSP_mmov(const float *__A, float *__C, vDSP_Length __M, vDSP_Length __N, vDSP_Length __TA, vDSP_Length __TC)
{
}

void vDSP_mmovD(const double *__A, double *__C, vDSP_Length __M, vDSP_Length __N, vDSP_Length __TA, vDSP_Length __TC)
{
}

void vDSP_mmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P)
{
}

void vDSP_mmulD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N, vDSP_Length __P)
{
}

void vDSP_mtrans(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N)
{
}

void vDSP_mtransD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __M, vDSP_Length __N)
{
}

void vDSP_svdiv(const float *__A, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_svdivD(const double *__A, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_sve(const float *__A, vDSP_Stride __I, float *__C, vDSP_Length __N)
{
}

void vDSP_sveD(const double *__A, vDSP_Stride __I, double *__C, vDSP_Length __N)
{
}

void vDSP_svesq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_svesqD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Length __N)
{
}

void vDSP_vabs(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vabsD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vabsi(const int *__A, vDSP_Stride __IA, int *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vadd(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vaddD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vaddi(const int *__A, vDSP_Stride __IA, const int *__B, vDSP_Stride __IB, int *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vclr(float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vdiv(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vdivD(const double *__B, vDSP_Stride __IB, const double *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vdivi(const int *__B, vDSP_Stride __IB, const int *__A, vDSP_Stride __IA, int *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vfill(const float *__A, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vfillD(const double *__A, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vfilli(const int *__A, int *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vmulD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vramp(const float *__A, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vrampD(const double *__A, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsadd(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsaddD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsaddi(const int *__A, vDSP_Stride __IA, const int *__B, int *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsdiv(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsdivD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsdivi(const int *__A, vDSP_Stride __IA, const int *__B, int *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsma(const float *__A, vDSP_Stride __IA, const float *__B, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vsmaD(const double *__A, vDSP_Stride __IA, const double *__B, const double *__C, vDSP_Stride __IC, double *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsmulD(const double *__A, vDSP_Stride __IA, const double *__B, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsort(float *__C, vDSP_Length __N, int __Order)
{
}

void vDSP_vsortD(double *__C, vDSP_Length __N, int __Order)
{
}

void vDSP_vsq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsqD(const double *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsub(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsubD(const double *__B, vDSP_Stride __IB, const double *__A, vDSP_Stride __IA, double *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvabs(const DSPSplitComplex *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

vImage_Error vImageConvert_Planar8toPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, Pixel_F maxFloat, Pixel_F minFloat, vImage_Flags flags)
{
  return MEMORY[0x270EDF090](src, dest, *(void *)&flags, maxFloat, minFloat);
}

vImage_Error vImageRotate90_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_F backColor, vImage_Flags flags)
{
  return MEMORY[0x270EDF300](src, dest, rotationConstant, *(void *)&flags, backColor);
}

vImage_Error vImageScale_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x270EDF390](src, dest, tempBuffer, *(void *)&flags);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  return MEMORY[0x270EDBA58](a1, a2, a3);
}

void vvlogf(float *a1, const float *a2, const int *a3)
{
}

pid_t waitpid(pid_t a1, int *a2, int a3)
{
  return MEMORY[0x270EDBB48](*(void *)&a1, a2, *(void *)&a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x270EDBC30](*(void *)&__fd, __buf, __nbyte);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return MEMORY[0x270EDBD10](xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return (xpc_object_t)MEMORY[0x270EDBD18](objects, count);
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return (xpc_object_t)MEMORY[0x270EDBDD8](value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return MEMORY[0x270EDBDE0](xBOOL);
}

void xpc_connection_activate(xpc_connection_t connection)
{
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return (xpc_connection_t)MEMORY[0x270EDBE58](name, targetq, flags);
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return (xpc_object_t)MEMORY[0x270EDBED0](connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return (char *)MEMORY[0x270EDBF40](object);
}

xpc_object_t xpc_data_create(const void *bytes, size_t length)
{
  return (xpc_object_t)MEMORY[0x270EDBF90](bytes, length);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return (const void *)MEMORY[0x270EDBFA8](xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return MEMORY[0x270EDBFB8](xdata);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return MEMORY[0x270EDBFE8](xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return (xpc_object_t)MEMORY[0x270EDC008](keys, values, count);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return (const void *)MEMORY[0x270EDC060](xdict, key, length);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return MEMORY[0x270EDC088](xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return (xpc_object_t)MEMORY[0x270EDC0C0](xdict, key);
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_double(xpc_object_t xdict, const char *key, double value)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_object_t xpc_double_create(double value)
{
  return (xpc_object_t)MEMORY[0x270EDC168](value);
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  MEMORY[0x270EDC170](xdouble);
  return result;
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x270EDC200](object);
}

xpc_object_t xpc_int64_create(int64_t value)
{
  return (xpc_object_t)MEMORY[0x270EDC210](value);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return MEMORY[0x270EDC218](xint);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return (xpc_object_t)MEMORY[0x270EDC2B8](object);
}

xpc_object_t xpc_string_create(const char *string)
{
  return (xpc_object_t)MEMORY[0x270EDC3D0](string);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return (const char *)MEMORY[0x270EDC3F8](xstring);
}