uint64_t sub_3F94(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = sub_306F0(a1);
  *(void *)v4 = off_8CB68;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  sub_1F580((os_log_t *)(v4 + 96));
  sub_1F580((os_log_t *)(a1 + 120));
  sub_1F580((os_log_t *)(a1 + 144));
  sub_1F580((os_log_t *)(a1 + 168));
  *(unsigned char *)(a1 + 192) = 1;
  *(void *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = a2;
  *(_WORD *)(a1 + 289) = 0;
  *(unsigned char *)(a1 + 408) = 0;
  *(void *)(a1 + 416) = 0;
  *(unsigned char *)(a1 + 425) = 0;
  *(_DWORD *)(a1 + 428) = 0;
  *(_OWORD *)(a1 + 336) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(void *)(a1 + 452) = 0x3F8000003F800000;
  *(unsigned char *)(a1 + 462) = 0;
  sub_5CC80(a1 + 464, v5);
  *(void *)(a1 + 528) = 0;
  *(_WORD *)(a1 + 536) = 256;
  *(_DWORD *)(a1 + 540) = 1065353216;
  *(unsigned char *)(a1 + 544) = 0;
  sub_5CC80(a1 + 552, v6);
  *(_WORD *)(a1 + 744) = 0;
  *(_DWORD *)(a1 + 9000) = 0;
  *(void *)(a1 + 9008) = 0;
  *(_WORD *)(a1 + 9016) = 0;
  *(_DWORD *)(a1 + 9064) = 0;
  *(_DWORD *)(a1 + 432) = 0;
  *(void *)(a1 + 400) = 0;
  bzero((void *)(a1 + 768), 0x2008uLL);
  atomic_store(0, (unsigned __int8 *)(a1 + 288));
  *(_OWORD *)(a1 + 216) = 0u;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_OWORD *)(a1 + 264) = 0u;
  *(void *)(a1 + 280) = 0;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 8968) = 0u;
  *(_OWORD *)(a1 + 8984) = 0u;
  *(_OWORD *)(a1 + 9032) = 0u;
  *(_OWORD *)(a1 + 9048) = 0u;
  pthread_mutex_init((pthread_mutex_t *)(a1 + 616), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 680), 0);
  *(void *)(a1 + 736) = 0;
  *(void *)(a1 + 728) = 4;
  return a1;
}

void sub_410C(_Unwind_Exception *a1, uint64_t a2)
{
  sub_5CD00(v3, a2);
  if (*(char *)(v2 + 359) < 0) {
    operator delete(*(void **)(v2 + 336));
  }
  sub_307F8(v2);
  _Unwind_Resume(a1);
}

uint64_t sub_415C(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = off_8CB68;
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  atomic_store(0, (unsigned __int8 *)(a1 + 288));
  v4 = *(void **)(a1 + 9008);
  if (v4)
  {
    if (!dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 9008)))
    {
      dispatch_block_cancel(v4);
      v4 = *(void **)(a1 + 9008);
    }
    _Block_release(v4);
    *(void *)(a1 + 9008) = 0;
  }
  v5 = *(const void **)(a1 + 200);
  if (v5) {
    CFRelease(v5);
  }
  sub_5CD00(a1 + 552, a2);
  sub_5CD00(a1 + 464, v6);
  if (*(char *)(a1 + 359) < 0) {
    operator delete(*(void **)(a1 + 336));
  }

  return sub_307F8(a1);
}

void sub_423C(void *a1)
{
}

void sub_4258(unsigned char *a1, void *a2)
{
  if (sub_5CB00() && (xpc_object_t v4 = xpc_dictionary_get_value(a2, "kBTAudioDebugEnableAudioLogging")) != 0)
  {
    v5 = v4;
    if (xpc_get_type(v4) != (xpc_type_t)&_xpc_type_BOOL)
    {
      uint64_t v6 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_FAULT)) {
        sub_62278(v6, v7, v8, v9, v10, v11, v12, v13);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL value = xpc_BOOL_get_value(v5);
  }
  else
  {
    BOOL value = 0;
  }
  sub_456C((uint64_t)a1, value);
  string = (char *)xpc_dictionary_get_string(a2, "kBTAudioMsgPropertyDeviceAddress");
  if (string)
  {
    sub_BAF4(v43, string);
    v16 = (void **)(a1 + 336);
    if ((char)a1[359] < 0) {
      operator delete(*v16);
    }
    *(_OWORD *)v16 = *(_OWORD *)v43;
    *((void *)a1 + 44) = *(void *)&v43[16];
  }
  a1[425] = 0;
  xpc_object_t v17 = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyVolumeIsAbsolute");
  if (xpc_get_type(v17) != (xpc_type_t)&_xpc_type_BOOL)
  {
    v18 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_FAULT)) {
      sub_62200(v18, v19, v20, v21, v22, v23, v24, v25);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  BOOL v26 = xpc_BOOL_get_value(v17);
  (*(void (**)(unsigned char *, BOOL))(*(void *)a1 + 1152))(a1, v26);
  xpc_object_t v27 = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyIsAppleAudioDevice");
  if (v27)
  {
    if (xpc_get_type(v27) == (xpc_type_t)&_xpc_type_BOOL)
    {
      xpc_object_t v39 = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyVolumeScalar");
      if (v39)
      {
        if (a1[408])
        {
          float v40 = xpc_double_get_value(v39);
          v41 = qword_97500;
          if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v42 = *((void *)a1 + 25);
            *(_DWORD *)v43 = 134218242;
            *(double *)&v43[4] = v40;
            *(_WORD *)&v43[12] = 2112;
            *(void *)&v43[14] = v42;
            _os_log_impl(&dword_0, v41, OS_LOG_TYPE_DEFAULT, "Received initial absolute volume of %f from bluetoothd Device %@", v43, 0x16u);
          }
          *((float *)a1 + 108) = v40;
          *((float *)a1 + 110) = (*(float (**)(unsigned char *, float))(*(void *)a1 + 368))(a1, v40);
        }
      }
    }
  }
  xpc_object_t v28 = xpc_dictionary_get_value(a2, "kBTAudioDebugEnableAudioCaptures");
  v29 = v28;
  if (v28)
  {
    if (xpc_get_type(v28) != (xpc_type_t)&_xpc_type_BOOL)
    {
      v30 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_FAULT)) {
        sub_62188(v30, v31, v32, v33, v34, v35, v36, v37);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v38 = xpc_BOOL_get_value(v29);
  }
  else
  {
    BOOL v38 = 0;
  }
  sub_4634((uint64_t)a1, v38);
}

void sub_456C(uint64_t a1, int a2)
{
  xpc_object_t v4 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "disabled";
    if (a2) {
      v5 = "enabled";
    }
    int v6 = 136315138;
    uint64_t v7 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Set plugin audio logging to: %s", (uint8_t *)&v6, 0xCu);
  }
  *(unsigned char *)(a1 + 745) = a2;
}

void sub_4634(uint64_t a1, int a2)
{
  xpc_object_t v4 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    v5 = "disabled";
    if (a2) {
      v5 = "enabled";
    }
    int v6 = 136315138;
    uint64_t v7 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Set plugin audio capture to: %s", (uint8_t *)&v6, 0xCu);
  }
  *(unsigned char *)(a1 + 744) = a2;
}

void sub_46FC(uint64_t a1)
{
  v11[0] = 0;
  v11[1] = 0;
  sub_5CDCC((uint64_t)v11, a1 + 552);
  uint64_t v2 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
      xpc_object_t v4 = "Yes";
    }
    else {
      xpc_object_t v4 = "No";
    }
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1048))(a1);
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1544))(a1);
    if (v5) {
      uint64_t v7 = "Yes";
    }
    else {
      uint64_t v7 = "No";
    }
    *(_DWORD *)buf = 67109890;
    int v13 = v3;
    __int16 v14 = 2082;
    v15 = v4;
    __int16 v16 = 2082;
    xpc_object_t v17 = v7;
    __int16 v18 = 1024;
    int v19 = v6;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "InitializeIOStreams audioObjectID: %u hasOutput: %{public}s hasInput: %{public}s PCM Packetizaton Threshold: %u", buf, 0x22u);
  }
  uint64_t v8 = malloc_type_calloc(1uLL, 0x418uLL, 0xF9888049uLL);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 1672))(a1, v8);
  *(_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1) = 64;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1))
  {
    (*(void (**)(uint64_t, void))(*(void *)a1 + 1664))(a1, *(unsigned int *)(a1 + 380));
    size_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1648))(a1);
    uint64_t v10 = malloc_type_calloc(v9, 1uLL, 0xBBE6F598uLL);
    (*(void (**)(uint64_t, void *))(*(void *)a1 + 1656))(a1, v10);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1048))(a1))
  {
    *(void *)(a1 + 760) = 16450;
    *(void *)(a1 + 752) = malloc_type_calloc(1uLL, 0x8084uLL, 0x1000040BDFB0063uLL);
  }
  if (*(unsigned char *)(a1 + 745)) {
    mach_timebase_info((mach_timebase_info_t)(a1 + 9020));
  }
  operator new();
}

void sub_4AC4()
{
}

uint64_t sub_4B04(uint64_t a1)
{
  v3[0] = 0;
  v3[1] = 0;
  sub_5CDCC((uint64_t)v3, a1 + 552);
  sub_4B68(a1, 0);
  *(unsigned char *)(a1 + 192) = 0;
  return sub_5CF10(v3);
}

void sub_4B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_4B68(uint64_t a1, int a2)
{
  xpc_object_t v4 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = "NO";
    if (a2) {
      int v5 = "YES";
    }
    int v6 = 136446210;
    uint64_t v7 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Signaling audio start condition! %{public}s", (uint8_t *)&v6, 0xCu);
  }
  atomic_store(a2, (unsigned __int8 *)(a1 + 288));
  if (*(unsigned char *)(a1 + 460))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 616));
    pthread_cond_signal((pthread_cond_t *)(a1 + 680));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 616));
  }
}

uint64_t sub_4C58(uint64_t a1)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_5CDCC((uint64_t)v5, a1 + 552);
  atomic_store(0, (unsigned __int8 *)(a1 + 288));
  if (*(void *)(a1 + 208))
  {
    sub_139AC();
    operator delete();
  }
  v2.n128_f64[0] = sub_4E84((FILE **)a1);
  if (*(void *)(a1 + 16))
  {
    nullsub_81(v2.n128_f64[0]);
    operator delete();
  }
  if ((*(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 1632))(a1, v2)
    && *(_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1))
  {
    int v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
    free(v3);
    (*(void (**)(uint64_t, void))(*(void *)a1 + 1672))(a1, 0);
  }
  if (*(void *)(a1 + 752) && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 1048))(a1))
  {
    free(*(void **)(a1 + 752));
    *(void *)(a1 + 752) = 0;
    *(void *)(a1 + 760) = 0;
  }
  if (*(void *)(a1 + 400)) {
    operator delete();
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 616));
  pthread_cond_signal((pthread_cond_t *)(a1 + 680));
  sub_4ED4(a1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 616));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 616));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 680));
  return sub_5CF10(v5);
}

void sub_4E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

double sub_4E84(FILE **a1)
{
  __n128 v2 = a1 + 1129;
  fclose(a1[1129]);
  fclose(a1[1130]);
  fclose(a1[1131]);
  fclose(a1[1132]);
  double result = 0.0;
  *__n128 v2 = 0u;
  v2[1] = 0u;
  return result;
}

void *sub_4ED4(uint64_t a1)
{
  double result = *(void **)(a1 + 80);
  if (result)
  {
    free(result);
    double result = (void *)sub_1F74C(a1 + 168);
    *(void *)(a1 + 80) = 0;
  }
  return result;
}

uint64_t sub_4F0C(uint64_t a1, double a2)
{
  xpc_object_t v4 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = *(double *)(a1 + 296);
    int v9 = 67109120;
    unsigned int v10 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BT Audio jitter: Update sample rate to %d", (uint8_t *)&v9, 8u);
  }
  double v6 = *(double *)(a1 + 296);
  if (v6 != a2)
  {
    uint64_t v7 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 67109376;
      unsigned int v10 = v6;
      __int16 v11 = 1024;
      unsigned int v12 = a2;
      _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "BT Audio mPhysicalFormat.mSampleRate %d, sampleRate %d", (uint8_t *)&v9, 0xEu);
    }
    *(double *)(a1 + 296) = a2;
  }
  return 0;
}

void sub_5038(uint64_t a1, int a2, const void *a3, size_t a4)
{
  if (*(unsigned char *)(a1 + 744))
  {
    int v18 = 0;
    memset(__filename, 0, sizeof(__filename));
    __int16 v16 = 0;
    long long v14 = 0u;
    long long v15 = 0u;
    *(_OWORD *)int v13 = 0u;
    memset(&v12, 0, sizeof(v12));
    time_t v11 = time(0);
    localtime_r(&v11, &v12);
    sprintf(v13, "%d_%d_%d_%d_%d_%d", v12.tm_year + 1900, v12.tm_mon + 1, v12.tm_mday, v12.tm_hour, v12.tm_min, v12.tm_sec);
    int v8 = sub_395B4();
    int v9 = "/private/var/mobile/tmp/com.apple.audiomxd";
    if (v8) {
      int v9 = "/Library/Preferences/Audio";
    }
    switch(a2)
    {
      case 0:
        unsigned int v10 = *(FILE **)(a1 + 9032);
        if (v10) {
          goto LABEL_14;
        }
        sprintf((char *)__filename, "%s/inputEncodedCapture-%s.enc", v9, v13);
        unsigned int v10 = fopen((const char *)__filename, "wb");
        *(void *)(a1 + 9032) = v10;
        break;
      case 1:
        unsigned int v10 = *(FILE **)(a1 + 9040);
        if (v10) {
          goto LABEL_14;
        }
        sprintf((char *)__filename, "%s/inputRawCapture-%s.pcm", v9, v13);
        unsigned int v10 = fopen((const char *)__filename, "wb");
        *(void *)(a1 + 9040) = v10;
        break;
      case 2:
        unsigned int v10 = *(FILE **)(a1 + 9048);
        if (v10) {
          goto LABEL_14;
        }
        sprintf((char *)__filename, "%s/outputEncodedCapture-%s.enc", v9, v13);
        unsigned int v10 = fopen((const char *)__filename, "wb");
        *(void *)(a1 + 9048) = v10;
        break;
      case 3:
        unsigned int v10 = *(FILE **)(a1 + 9056);
        if (v10) {
          goto LABEL_14;
        }
        sprintf((char *)__filename, "%s/outputRawCapture-%s.pcm", v9, v13);
        unsigned int v10 = fopen((const char *)__filename, "wb");
        *(void *)(a1 + 9056) = v10;
        break;
      default:
        if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
          sub_622F0();
        }
        return;
    }
    if (v10) {
LABEL_14:
    }
      fwrite(a3, 1uLL, a4, v10);
  }
}

void sub_52A8(uint64_t a1, uint64_t a2, void *a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1288))(a1) && *(unsigned char *)(a1 + 424))
  {
    (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(v9, a1, 0);
    bzero(a3, (v10 * a2));
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)a1 + 1576))(a1, a2, a3);
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1))
    {
      uint64_t v6 = *(void *)(a1 + 400);
      if (v6)
      {
        unsigned __int8 v7 = atomic_load((unsigned __int8 *)(v6 + 24));
        if (v7)
        {
          int v8 = *(_DWORD **)(a1 + 400);
          (*(void (**)(void *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(v9, a1, 0);
          sub_18210(v8, (float *)a3, a2, v9);
        }
      }
    }
  }
}

void sub_5440(uint64_t a1, unsigned int a2, const float *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    sub_1E060(v4, a2, a3, a4);
  }
}

void sub_5450(uint64_t a1, uint64_t a2, const float *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  if (v4) {
    sub_1DC78(v4, a2, a3, a4);
  }
}

uint64_t sub_5460(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  v27[0] = 0;
  v27[1] = 0;
  sub_5CDCC((uint64_t)v27, (uint64_t)(a1 + 69));
  if (a1[27])
  {
    uint64_t v6 = sub_17878(a1[3]);
    uint64_t v7 = a1[27];
    uint64_t v8 = (*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1);
    (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v7 + 24))(v7, a3, a2, v8, 64);
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      if (v9 >= *(unsigned int *)(*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1))
      {
        int v22 = sub_5CB00();
        if (v10 < 0xC) {
          int v23 = v22;
        }
        else {
          int v23 = 0;
        }
        if (v23 == 1 && v10 && *(_DWORD *)(a1[27] + 52) == 33023) {
          sub_5CA94(36, v6, 0, 0, 0);
        }
        return sub_5CF10(v27);
      }
      size_t v11 = *(unsigned int *)((*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1) + 16 * v9 + 12);
      if (v11) {
        break;
      }
LABEL_31:
      ++v9;
    }
    if (v11 > (*(unsigned int (**)(uint64_t *))(*a1 + 776))(a1))
    {
      tm v12 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_FAULT)) {
        sub_623B0(v30, &v31, v12);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    if (v11 > (*(unsigned int (**)(uint64_t *))(*a1 + 776))(a1))
    {
      uint64_t v24 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR))
      {
        int v25 = (*(uint64_t (**)(uint64_t *))(*a1 + 776))(a1);
        sub_62358(buf, v11, v25, v24);
      }
      return sub_5CF10(v27);
    }
    uint64_t v13 = a1[27];
    if (v6)
    {
      if (!v13)
      {
LABEL_29:
        uint64_t v18 = *(unsigned int *)((*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1) + 16 * v9 + 12);
        uint64_t v19 = a1[3];
        uint64_t v20 = (*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1);
        sub_175B4(v19, *(const void **)(v20 + 16 * v9 + 16), v11);
        v6 += v11;
        ++*((_DWORD *)a1 + 2250);
        v10 += v18;
        if ((*(unsigned int (**)(uint64_t *))(*a1 + 1680))(a1))
        {
          *((_DWORD *)a1 + 2250) = 0;
          sub_17798(a1[3]);
          uint64_t v6 = sub_17878(a1[3]);
        }
        goto LABEL_31;
      }
    }
    else
    {
      if (!v13)
      {
        uint64_t v6 = 0;
        goto LABEL_29;
      }
      if (*(_DWORD *)(v13 + 52) == 2)
      {
        if (*(double *)(v13 + 104) == 48000.0) {
          long long v14 = &unk_71000;
        }
        else {
          long long v14 = &unk_71009;
        }
        sub_175B4(a1[3], v14, 9uLL);
        unint64_t v15 = *(unsigned int *)((*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1) + 16 * v9 + 12);
        if (v15 >= 0xFF)
        {
          do
          {
            buf[0] = -1;
            sub_175B4(a1[3], buf, 1uLL);
            v15 -= 255;
          }
          while (v15 > 0xFE);
        }
        buf[0] = v15;
        sub_175B4(a1[3], buf, 1uLL);
        uint64_t v13 = a1[27];
        uint64_t v6 = 9;
        if (!v13) {
          goto LABEL_29;
        }
      }
      else
      {
        uint64_t v6 = 0;
      }
    }
    if (*(_DWORD *)(v13 + 52) == 33023)
    {
      if (*(_DWORD *)((*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1) + 16 * v9 + 12) >= 0x800u)
      {
        __int16 v16 = qword_97500;
        if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR))
        {
          int v21 = *(_DWORD *)((*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1) + 16 * v9 + 12);
          *(_DWORD *)buf = 67109120;
          int v29 = v21;
          _os_log_error_impl(&dword_0, v16, OS_LOG_TYPE_ERROR, "FATAL: Unable to correctly create AAC-ELD Size Header for %d bytes of encoded audio (max: 0x7FF = 2047)", buf, 8u);
        }
      }
      uint64_t v17 = (*(uint64_t (**)(uint64_t *))(*a1 + 1632))(a1);
      v6 += (*(uint64_t (**)(uint64_t *, void))(*a1 + 1528))(a1, *(unsigned int *)(v17 + 16 * v9 + 12));
    }
    goto LABEL_29;
  }
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
    sub_62324();
  }
  return sub_5CF10(v27);
}

void sub_5A88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

void sub_5AC8(uint64_t a1)
{
  __n128 v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_140F0(v2);
  }
  *(unsigned char *)(a1 + 462) = 0;
}

uint64_t sub_5AF8(uint64_t a1, uint64_t a2, char *a3)
{
  v41[0] = 0;
  v41[1] = 0;
  sub_5CDCC((uint64_t)v41, a1 + 552);
  uint64_t v40 = 0;
  long long v38 = 0u;
  long long v39 = 0u;
  (*(void (**)(long long *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(&v38, a1, 0);
  uint64_t v6 = *(void *)(a1 + 216);
  if (v6)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
    (*(void (**)(uint64_t, char *, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 24))(v6, a3, a2, v7, 64);
    uint64_t v8 = 0;
    unint64_t v9 = 0;
    for (unsigned int i = 0; i < *(_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1); ++i)
    {
      if (*(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1) + 16 * (int)i + 12))
      {
        unsigned int v11 = i;
        if ((*(unsigned int (**)(void))(**(void **)(a1 + 216) + 32))(*(void *)(a1 + 216)))
        {
          if ((*(unsigned int (**)(void))(**(void **)(a1 + 216) + 40))(*(void *)(a1 + 216))) {
            BOOL v12 = 1;
          }
          else {
            BOOL v12 = HIDWORD(v39) == 1;
          }
          if (v12 || *(_DWORD *)(*(void *)(a1 + 216) + 132) == 1)
          {
            if (_os_feature_enabled_impl()
              && *(_DWORD *)(*(void *)(a1 + 216) + 52) == 508
              && sub_2A8C0(*(void *)(*(void *)(a1 + 416) + 9248)))
            {
              uint64_t v13 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
              (*(void (**)(uint64_t, char *, void))(*(void *)a1 + 1536))(a1, byte_97508, *(unsigned int *)(v13 + 16 * (int)i + 12));
              long long v14 = *(const void **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1)
                                   + 16 * (int)i
                                   + 16);
              uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
              memcpy(&unk_97512, v14, *(unsigned int *)(v15 + 16 * (int)i + 12));
              uint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
              unint64_t v9 = sub_1FEE0(a1 + 96, byte_97508, (*(_DWORD *)(v16 + 16 * (int)i + 12) + 10));
              uint64_t v17 = *(const void **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1)
                                   + 16 * (int)i
                                   + 16);
              uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
              sub_5038(a1, 2, v17, *(unsigned int *)(v18 + 16 * (int)i + 12));
              if (*(unsigned char *)(a1 + 745))
              {
                uint64_t v19 = qword_97500;
                if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
                {
                  int v20 = *(_DWORD *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1)
                                  + 16 * (int)i
                                  + 12);
                  *(_DWORD *)buf = 67109376;
                  int v43 = v20;
                  __int16 v44 = 1024;
                  int v45 = v9;
                  _os_log_impl(&dword_0, v19, OS_LOG_TYPE_DEFAULT, "Number of bytes to write: %d; number of bytes written: %d;",
                    buf,
                    0xEu);
                }
              }
            }
            else
            {
              int v21 = *(char **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1) + 16 * (int)i + 16);
              uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
              unint64_t v9 = sub_1FEE0(a1 + 96, v21, *(unsigned int *)(v22 + 16 * (int)i + 12));
              uint64_t v23 = *(unsigned int *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1)
                                    + 16 * (int)i
                                    + 12);
              uint64_t v24 = *(const void **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1)
                                   + 16 * (int)i
                                   + 16);
              uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
              sub_5038(a1, 2, v24, *(unsigned int *)(v25 + 16 * (int)i + 12));
              v8 += v23;
            }
          }
          else
          {
            xpc_object_t v28 = *(char **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1) + 16 * (int)i + 16);
            size_t v29 = *(unsigned int *)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1)
                                  + 16 * (int)i
                                  + 12);
            uint64_t v30 = (int)i + 1;
            uint64_t v31 = *(char **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1) + 16 * v30 + 16);
            uint64_t v32 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
            unint64_t v9 = sub_1FFF8(a1 + 96, v28, v29, v31, *(unsigned int *)(v32 + 16 * v30 + 12));
            unsigned int i = v11 + 1;
          }
        }
        else
        {
          BOOL v26 = *(char **)((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1) + 16 * (int)i + 16);
          uint64_t v27 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1632))(a1);
          unint64_t v9 = sub_1FE6C(a1 + 96, v26, *(unsigned int *)(v27 + 16 * (int)i + 12));
        }
        ++*(_DWORD *)(a1 + 9000);
      }
    }
    int v33 = sub_5CB00();
    if (v9 < 0xC) {
      int v34 = v33;
    }
    else {
      int v34 = 0;
    }
    if (v34 == 1)
    {
      if (v9)
      {
        int v35 = *(_DWORD *)(*(void *)(a1 + 216) + 52);
        if (v35 == 510 || v35 == 260) {
          sub_5CA94(36, v9, 0, 0, 0);
        }
      }
    }
  }
  else
  {
    sub_1FE6C(a1 + 96, a3, (v39 * a2));
    uint64_t v8 = 0;
    unint64_t v9 = 0;
  }
  sub_5CEA4((uint64_t)v41);
  (*(void (**)(uint64_t))(*(void *)a1 + 1592))(a1);
  if (!*(void *)(a1 + 216))
  {
    uint64_t v36 = *(id **)(a1 + 208);
LABEL_37:
    *(_DWORD *)(a1 + 9000) = 0;
    *(unsigned char *)(a1 + 9004) = 1;
    sub_141B0(v36);
    goto LABEL_38;
  }
  if ((*(unsigned int (**)(uint64_t, void, unint64_t))(*(void *)a1 + 1680))(a1, *(unsigned int *)(a1 + 9000), v9))
  {
    if (!*(unsigned char *)(a1 + 9004))
    {
      uint64_t v36 = *(id **)(a1 + 208);
      if (v36) {
        goto LABEL_37;
      }
    }
  }
LABEL_38:
  sub_5CF10(v41);
  return v8;
}

void sub_63E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

unint64_t sub_6404(uint64_t a1, uint64_t a2, unint64_t a3, void *a4)
{
  size_t v23 = 0;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a2 + 40))(a2))
  {
    if (a3)
    {
      unint64_t v8 = 0;
      uint64_t v22 = a1 + 144;
      while (1)
      {
        if (!sub_1F784(a1 + 120)) {
          return v8;
        }
        unint64_t v9 = sub_1FA80(a1 + 120, (char *)&unk_97908, 0x2021uLL);
        unint64_t v10 = v9;
        if (v9 <= 1)
        {
          unsigned int v11 = qword_97500;
          if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134217984;
            unint64_t v25 = v10;
            _os_log_error_impl(&dword_0, v11, OS_LOG_TYPE_ERROR, "Input Decode: Bytes read too small: bytesRead %lu", buf, 0xCu);
          }
          goto LABEL_18;
        }
        size_t v12 = byte_97909;
        *a4 += v9;
        if (v12)
        {
          *(unsigned char *)(a1 + 544) = 1;
          sub_5038(a1, 0, &unk_9790A, v12);
          if (!*(unsigned char *)(a1 + 544)) {
            goto LABEL_20;
          }
        }
        else
        {
          sub_5038(a1, 0, &unk_9790A, 0);
          if (!*(unsigned char *)(a1 + 544))
          {
LABEL_20:
            uint64_t v15 = qword_97500;
            if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, "Input Decode: This may be an invalid packet. Not decoding", buf, 2u);
            }
            unint64_t v14 = v23;
            if (!v23) {
              goto LABEL_18;
            }
            goto LABEL_17;
          }
          unint64_t v13 = sub_1F768(v22);
          sub_5CA94(35, v13, 0, 0, 0);
        }
        (*(void (**)(uint64_t, void *, size_t, char *, uint64_t, size_t *))(*(void *)a2 + 32))(a2, &unk_9790A, v12, byte_9992A, 16450, &v23);
        unint64_t v14 = v23;
        if (*(unsigned char *)(a1 + 536) && !v23)
        {
          (*(void (**)(uint64_t, void *, void, char *, uint64_t, size_t *))(*(void *)a2 + 32))(a2, &unk_9790A, 0, byte_9992A, 16450, &v23);
          unint64_t v14 = v23;
        }
        v8 += v14;
        if (!v14) {
          goto LABEL_18;
        }
LABEL_17:
        sub_1FE6C(v22, byte_9992A, v14);
        sub_5038(a1, 1, byte_9992A, v23);
        size_t v23 = 0;
LABEL_18:
        if (v8 >= a3) {
          return v8;
        }
      }
    }
    return 0;
  }
  if (!a3) {
    return 0;
  }
  unint64_t v8 = 0;
  do
  {
    if (!sub_1F784(a1 + 120)) {
      break;
    }
    unint64_t v16 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 64))(a2);
    if (!v16)
    {
      uint64_t v17 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
        sub_62400(buf, &buf[1], v17);
      }
    }
    if (v16 >= 0x2021) {
      size_t v18 = 8225;
    }
    else {
      size_t v18 = v16;
    }
    size_t v19 = sub_1FA14(a1 + 120, (char *)&unk_97908, v18);
    sub_5038(a1, 0, &unk_97908, v19);
    (*(void (**)(uint64_t, void *, size_t, char *, uint64_t, size_t *))(*(void *)a2 + 32))(a2, &unk_97908, v19, byte_9992A, 16450, &v23);
    size_t v20 = v23;
    if (v23)
    {
      sub_1FE6C(a1 + 144, byte_9992A, v23);
      sub_5038(a1, 1, byte_9992A, v23);
      size_t v23 = 0;
    }
    v8 += v20;
  }
  while (v8 < a3);
  return v8;
}

uint64_t sub_682C(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, void, float))(*(void *)a1 + 688))(a1, 0, 1.0);
}

uint64_t sub_6860(unsigned __int8 *a1)
{
  unsigned __int8 v2 = atomic_load(a1 + 545);
  if (v2) {
    (*(void (**)(unsigned __int8 *))(*(void *)a1 + 1552))(a1);
  }
  int v3 = *(uint64_t (**)(unsigned __int8 *))(*(void *)a1 + 640);

  return v3(a1);
}

uint64_t sub_6904(uint64_t a1, int a2, BOOL *a3, unsigned char *a4)
{
  if (a3)
  {
    BOOL v5 = a2 == 1919246692 || a2 == 1919513701;
    *a3 = v5;
  }
  if (a4) {
    *a4 = 1;
  }
  return 0;
}

uint64_t sub_693C(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v6 = 1852797029;
  unsigned __int8 v7 = atomic_load((unsigned __int8 *)(a1 + 288));
  if (v7)
  {
    if (a3 == 1919246692)
    {
      uint64_t v38 = 0;
      long long v36 = 0u;
      long long v37 = 0u;
      (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 800))(&v36, a1, 1);
      uint64_t v24 = *(void *)(a1 + 224);
      if (v24) {
        unint64_t v25 = (long long *)(v24 + 80);
      }
      else {
        unint64_t v25 = &v37;
      }
      size_t v26 = *(_DWORD *)v25 * a4;
      if (v26)
      {
        bzero(a6, v26);
        uint64_t v27 = *(void *)(a1 + 224);
        uint64_t v35 = 0;
        if (v27)
        {
          uint64_t v28 = (*(uint64_t (**)(uint64_t, uint64_t, size_t, uint64_t *))(*(void *)a1 + 1584))(a1, v27, v26, &v35);
          uint64_t v29 = v35;
          size_t v30 = sub_1FA14(a1 + 144, (char *)a6, v26);
          unint64_t v31 = sub_1F768(a1 + 144);
        }
        else
        {
          size_t v30 = sub_1FA14(a1 + 120, (char *)a6, v26);
          unint64_t v31 = sub_1F768(a1 + 120);
          sub_5038(a1, 1, a6, v30);
          uint64_t v29 = 0;
          uint64_t v28 = 0;
        }
        sub_5CA94(30, v26, v30, v31, v26);
        uint64_t v32 = *(void *)(a1 + 16);
        if (v32) {
          sub_1DC78(v32, v30, (const float *)a6, v29);
        }
        if (v30 != v26)
        {
          int v33 = qword_97500;
          if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 134218496;
            size_t v40 = v26;
            __int16 v41 = 2048;
            size_t v42 = v30;
            __int16 v43 = 2048;
            uint64_t v44 = v28;
            _os_log_error_impl(&dword_0, v33, OS_LOG_TYPE_ERROR, "Input Decode: Requested %lu bytes, but only read %lu bytes instead. Decoded a total of %lu bytes", buf, 0x20u);
          }
        }
        return 0;
      }
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
        sub_62440();
      }
    }
    else
    {
      if (a3 != 1919513701) {
        return 0;
      }
      if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1))
      {
        if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 872))(a1))
        {
          mach_absolute_time();
          sub_6860((unsigned __int8 *)a1);
        }
        uint64_t v38 = 0;
        long long v36 = 0u;
        long long v37 = 0u;
        (*(void (**)(long long *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(&v36, a1, 0);
        unint64_t v11 = v37 * a4;
        unsigned int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1544))(a1);
        unsigned int v13 = v12;
        unint64_t v14 = v37 * v12;
        if (v12) {
          uint64_t v15 = v12;
        }
        else {
          uint64_t v15 = a4;
        }
        if (v14) {
          unint64_t v16 = v37 * v12;
        }
        else {
          unint64_t v16 = v11;
        }
        sub_1FE6C(a1 + 168, (char *)a6, v11);
        sub_5CA94(31, v16, 0, 0, 0);
        uint64_t v17 = 0;
        do
        {
          if (v13 && sub_1F768(a1 + 168) < v16) {
            break;
          }
          size_t v18 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1);
          sub_1FA14(a1 + 168, v18, v16);
          size_t v19 = (const void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1);
          sub_5038(a1, 3, v19, v16);
          size_t v20 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1);
          sub_52A8(a1, v15, v20);
          int v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 376))(a1);
          uint64_t v22 = (char *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1);
          if (v21) {
            sub_5460((uint64_t *)a1, v15, (uint64_t)v22);
          }
          else {
            v17 += sub_5AF8(a1, v15, v22);
          }
        }
        while (v14 && sub_1F768(a1 + 168) >= v14);
        uint64_t v23 = *(void *)(a1 + 16);
        if (v23) {
          sub_1E060(v23, a4, (const float *)a6, v17);
        }
        return 0;
      }
    }
  }
  return v6;
}

void *sub_6EE8(uint64_t a1, uint64_t a2, double *a3, void *a4, void *a5)
{
  uint64_t v9 = mach_absolute_time();
  unsigned int v10 = *(_DWORD *)(a1 + 376);
  if (!*(void *)(a1 + 8976))
  {
    double v11 = *(double *)&qword_A19B0;
    if (*(double *)&qword_A19B0 == 0.0)
    {
      *(double *)&mach_timebase_info info = 0.0;
      if (mach_timebase_info(&info))
      {
        qword_A19B0 = 0x41CDCD6500000000;
        double v11 = 1000000000.0;
      }
      else if (info.numer && info.denom)
      {
        double v11 = (double)info.denom / (double)info.numer * 1000000000.0;
        *(double *)&qword_A19B0 = v11;
      }
      else
      {
        double v11 = *(double *)&qword_A19B0;
      }
    }
    double v12 = v11 * (double)v10;
    (*(void (**)(mach_timebase_info *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(&info, a1, 0);
    double v13 = v12 / *(double *)&info * *(float *)(a1 + 540);
    *(void *)(a1 + 8984) = (unint64_t)v13;
    *(void *)(a1 + 8968) = v9;
    *(void *)(a1 + 8976) = v9 + (unint64_t)v13;
    *(void *)(a1 + 8992) = 0;
  }
  mach_timebase_info v19 = 0;
  double result = (void *)mach_timebase_info(&v19);
  if (v9 >= *(void *)(a1 + 8976))
  {
    double v17 = *(double *)&qword_A19B0 * (double)v10;
    double result = (*(void *(**)(mach_timebase_info *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(&info, a1, 0);
    unint64_t v18 = (unint64_t)(v17 / *(double *)&info * *(float *)(a1 + 540));
    *(void *)(a1 + 8984) = v18;
    uint64_t v16 = *(void *)(a1 + 8976);
    *(void *)(a1 + 8968) = v16;
    *(void *)(a1 + 8976) = v16 + v18;
    double v15 = *(double *)(a1 + 8992) + (double)v10;
    *(double *)(a1 + 8992) = v15;
  }
  else
  {
    double v15 = *(double *)(a1 + 8992);
    uint64_t v16 = *(void *)(a1 + 8968);
  }
  *a3 = v15;
  *a4 = v16;
  *a5 = 0;
  return result;
}

uint64_t sub_70D8(uint64_t a1)
{
  unsigned __int8 v2 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 416) + 9256);
    v47[0] = BYTE3(v3);
    v47[1] = BYTE2(v3);
    v47[2] = BYTE1(v3);
    v47[3] = v3;
    v47[4] = 0;
    uint64_t v4 = *(void *)(a1 + 8960);
    uint64_t v5 = *(void *)(a1 + 200);
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 400))(a1);
    *(_DWORD *)buf = 136447234;
    *(void *)v49 = v47;
    *(_WORD *)&v49[8] = 2048;
    *(void *)&v49[10] = v4;
    __int16 v50 = 2114;
    uint64_t v51 = v5;
    __int16 v52 = 1024;
    int v53 = v6;
    __int16 v54 = 1024;
    int v55 = v7;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Starting IO on profile %{public}s, activeIO:%llu to %{public}@ mAudioObjectID: %u Wait IO Start %d", buf, 0x2Cu);
  }
  int v8 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 328);
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1312))(a1) & 1) == 0)
  {
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 848))(a1);
    BOOL v10 = v8 || v9 == 0;
    if (!v10 && os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
      sub_624DC();
    }
  }
  uint64_t v11 = *(void *)(a1 + 8960);
  if (v11 == -1)
  {
    uint64_t v12 = 1852797029;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
      sub_62474();
    }
    goto LABEL_47;
  }
  uint64_t v12 = 0;
  *(void *)(a1 + 8960) = v11 + 1;
  *(unsigned char *)(a1 + 544) = 0;
  if (v11)
  {
LABEL_47:
    uint64_t v35 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v36 = *(void *)(a1 + 8960);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v49 = v12;
      *(_WORD *)&v49[4] = 2048;
      *(void *)&v49[6] = v36;
      _os_log_impl(&dword_0, v35, OS_LOG_TYPE_DEFAULT, "StartIO returns %x (%llu)", buf, 0x12u);
    }
    return v12;
  }
  if (!*(void *)(a1 + 208))
  {
LABEL_44:
    uint64_t v12 = 0;
    *(unsigned char *)(a1 + 9004) = 0;
    goto LABEL_47;
  }
  double v13 = (pthread_mutex_t *)(a1 + 616);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 616));
  uint64_t v15 = *(void *)(a1 + 16);
  if (v15) {
    v14.n128_f64[0] = sub_1D848(v15);
  }
  if (((*(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 376))(a1, v14) & 1) == 0) {
    sub_790C((void *)a1);
  }
  if (*(unsigned char *)(a1 + 9017) && *(unsigned char *)(a1 + 9016))
  {
    (*(void (**)(void))(**(void **)(a1 + 416) + 1456))(*(void *)(a1 + 416));
    uint64_t v16 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = *(void *)(a1 + 200);
      *(_DWORD *)buf = 138543362;
      *(void *)v49 = v17;
      _os_log_impl(&dword_0, v16, OS_LOG_TYPE_DEFAULT, "%{public}@ : Injecting silent Audio started", buf, 0xCu);
    }
    unsigned int v18 = (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 16))(*(void *)(a1 + 416));
    v45[0] = _NSConcreteStackBlock;
    v45[1] = 3221225472;
    v45[2] = sub_7AF0;
    v45[3] = &unk_8D200;
    unsigned int v46 = v18;
    sub_44BA4(qword_A2350, v18, v45);
  }
  sub_7BCC((void *)a1);
  sub_13D74(*(id **)(a1 + 208), *(void **)(a1 + 32), *(void *)(a1 + 40), *(void **)(a1 + 48), *(void *)(a1 + 56));
  uint64_t v19 = *(void *)(a1 + 216);
  if (v19 && *(_DWORD *)(v19 + 52) == 33023) {
    (*(void (**)(uint64_t))(*(void *)a1 + 1616))(a1);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 296))(a1))
  {
    uint64_t v20 = qword_A2350;
    int v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    if (sub_444E0(v20, v21))
    {
      uint64_t v22 = qword_A2350;
      int v23 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      sub_44828(v22, v23);
    }
  }
  if (!*(unsigned char *)(a1 + 460) || !(*(unsigned int (**)(uint64_t))(*(void *)a1 + 400))(a1))
  {
LABEL_42:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 616));
    if (sub_395B4()) {
      (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 416) + 600))(*(void *)(a1 + 416), 0, 200);
    }
    goto LABEL_44;
  }
  uint64_t v24 = mach_absolute_time();
  if (*(unsigned char *)(a1 + 745))
  {
    unint64_t v25 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = mach_absolute_time() * *(unsigned int *)(a1 + 9020) / *(unsigned int *)(a1 + 9024) / 0x3E8;
      *(_DWORD *)buf = 134217984;
      *(void *)v49 = v26;
      _os_log_impl(&dword_0, v25, OS_LOG_TYPE_DEFAULT, "start time %llus", buf, 0xCu);
    }
  }
  int v27 = pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 680), (pthread_mutex_t *)(a1 + 616), (const timespec *)(a1 + 728));
  if (v27 == 60)
  {
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
      sub_624A8();
    }
    dispatch_async(*(dispatch_queue_t *)(qword_A2350 + 192), &stru_8D240);
  }
  if (*(unsigned char *)(a1 + 192))
  {
    if (*(unsigned char *)(a1 + 745))
    {
      uint64_t v28 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v29 = mach_absolute_time() * *(unsigned int *)(a1 + 9020) / *(unsigned int *)(a1 + 9024) / 0x3E8;
        *(_DWORD *)buf = 134217984;
        *(void *)v49 = v29;
        _os_log_impl(&dword_0, v28, OS_LOG_TYPE_DEFAULT, "response time %llus", buf, 0xCu);
      }
    }
    uint64_t v30 = mach_absolute_time();
    float v31 = sub_2CC7C(*(void *)(*(void *)(a1 + 416) + 9248), v30 - v24, 1);
    int v32 = *(_DWORD *)(a1 + 368);
    int v33 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 824))(a1);
    int v34 = *(NSObject **)(qword_A2350 + 192);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_7CA0;
    block[3] = &unk_8D260;
    int v40 = 0;
    int v41 = v27;
    int v42 = v32;
    int v43 = v33;
    float v44 = v31;
    dispatch_async(v34, block);
    goto LABEL_42;
  }
  uint64_t v38 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_0, v38, OS_LOG_TYPE_DEFAULT, "device No longer valid, StartIO return immediately", buf, 2u);
  }
  pthread_mutex_unlock(v13);
  return 560227702;
}

uint64_t sub_7904(uint64_t a1)
{
  return *(void *)(a1 + 200);
}

BOOL sub_790C(void *a1)
{
  if (!a1[4])
  {
    if ((*(unsigned int (**)(void *))(*a1 + 1040))(a1))
    {
      unsigned __int8 v2 = (unint64_t *)mmap(0, a1[5], 3, 4097, -1, 0);
      a1[4] = v2;
      if ((sub_1F5C0((uint64_t)(a1 + 12), v2, a1[5]) & 1) == 0)
      {
        BOOL result = os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        sub_62578();
        return 0;
      }
    }
  }
  if (!a1[6])
  {
    if ((*(unsigned int (**)(void *))(*a1 + 1048))(a1))
    {
      uint64_t v3 = (unint64_t *)mmap(0, a1[7], 3, 4097, -1, 0);
      a1[6] = v3;
      if ((sub_1F5C0((uint64_t)(a1 + 15), v3, a1[7]) & 1) == 0)
      {
        BOOL result = os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        sub_62544();
        return 0;
      }
    }
  }
  if (a1[8]) {
    return 1;
  }
  if (!(*(unsigned int (**)(void *))(*a1 + 1048))(a1)) {
    return 1;
  }
  uint64_t v4 = (unint64_t *)mmap(0, a1[9], 3, 4097, -1, 0);
  a1[8] = v4;
  if (sub_1F5C0((uint64_t)(a1 + 18), v4, a1[9])) {
    return 1;
  }
  BOOL result = os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_62510();
    return 0;
  }
  return result;
}

void *sub_7AF0(uint64_t a1)
{
  BOOL result = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 32));
  if (result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (unsigned char *)result[1137];
    if (v4 && v4[192]) {
      (*(void (**)(unsigned char *, void, void))(*(void *)v4 + 1448))(v4, 0, *(unsigned int *)(a1 + 32));
    }
    BOOL result = (void *)v3[1139];
    if (result && *((unsigned char *)result + 192))
    {
      uint64_t v5 = *(uint64_t (**)(void))(*result + 1448);
      return (void *)v5();
    }
  }
  return result;
}

BOOL sub_7BCC(void *a1)
{
  if (a1[11]) {
    size_t v1 = a1[11];
  }
  else {
    size_t v1 = 16450;
  }
  if (a1[10]) {
    return 1;
  }
  if (!(*(unsigned int (**)(void *))(*a1 + 1040))(a1)) {
    return 1;
  }
  uint64_t v3 = (unint64_t *)malloc_type_calloc(1uLL, v1, 0x5501DC61uLL);
  a1[10] = v3;
  if (v3)
  {
    if (sub_1F5C0((uint64_t)(a1 + 21), v3, v1)) {
      return 1;
    }
  }
  BOOL result = os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR);
  if (result)
  {
    sub_625AC();
    return 0;
  }
  return result;
}

void sub_7C8C(id a1)
{
}

uint64_t sub_7C98(uint64_t a1)
{
  return *(unsigned int *)(a1 + 368);
}

void sub_7CA0(uint64_t a1)
{
  uint64_t v2 = *(unsigned int *)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 36);
  sub_437A0(*(_DWORD *)(a1 + 40), &__p);
  sub_435B8(v2, v3, (uint64_t *)&__p, *(unsigned int *)(a1 + 44), (unint64_t)*(float *)(a1 + 48));
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

void sub_7D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_7D28(uint64_t a1)
{
  uint64_t v2 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(*(void *)(a1 + 416) + 9256);
    v13[0] = BYTE3(v3);
    v13[1] = BYTE2(v3);
    v13[2] = BYTE1(v3);
    v13[3] = v3;
    v13[4] = 0;
    uint64_t v4 = *(void *)(a1 + 8960);
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v4;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "StopIO on profile %{public}s, activeIO:%llu", buf, 0x16u);
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = 0;
  sub_5CDCC((uint64_t)buf, a1 + 552);
  uint64_t v5 = *(void *)(a1 + 8960);
  if (v5)
  {
    *(unsigned char *)(a1 + 544) = 0;
    uint64_t v6 = v5 - 1;
    *(void *)(a1 + 8960) = v6;
    if (!v6)
    {
      if (*(unsigned char *)(a1 + 9017) && *(unsigned char *)(a1 + 9016)) {
        (*(void (**)(void))(**(void **)(a1 + 416) + 1456))(*(void *)(a1 + 416));
      }
      uint64_t v7 = *(void *)(a1 + 216);
      if (v7 && *(_DWORD *)(a1 + 9000) && *(_DWORD *)(v7 + 52) == 33023)
      {
        sub_17798(*(void *)(a1 + 24));
        *(_DWORD *)(a1 + 9000) = 0;
      }
      *(_OWORD *)(a1 + 8968) = 0u;
      *(_OWORD *)(a1 + 8984) = 0u;
      (*(void (**)(uint64_t, void, float))(*(void *)a1 + 688))(a1, 0, 1.0);
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 648))(a1)) {
        (*(void (**)(uint64_t, void, void))(*(void *)a1 + 568))(a1, 0, 0);
      }
      if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 664))(a1)) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 656))(a1, 150);
      }
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 230))
      {
        if (sub_395B4())
        {
          sub_24270(*(void *)(*(void *)(a1 + 416) + 9248));
          sub_21EB8(*(void **)(*(void *)(a1 + 416) + 9248), 1);
        }
        *(_DWORD *)(*(void *)(*(void *)(a1 + 416) + 9248) + 232) = 0;
        (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 568))(a1, 0, 6);
        if (sub_395B4()) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 416) + 600))(*(void *)(a1 + 416), 1, 200);
        }
        else {
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)a1 + 568))(a1, 0, 7);
        }
      }
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1384))(a1, 1);
      uint64_t v9 = *(void *)(a1 + 216);
      if (v9)
      {
        AudioConverterReset(*(AudioConverterRef *)(v9 + 56));
        if (*(unsigned char *)(a1 + 744)) {
          sub_13610(*(void *)(a1 + 216));
        }
      }
      uint64_t v10 = *(void *)(a1 + 224);
      if (v10)
      {
        AudioConverterReset(*(AudioConverterRef *)(v10 + 16));
        if (sub_1F784(a1 + 144)) {
          sub_1FB94(a1 + 144);
        }
      }
      sub_4E84((FILE **)a1);
      sub_8204(a1);
      sub_4ED4(a1);
      sub_8278((_DWORD *)a1);
      *(unsigned char *)(a1 + 537) = 1;
      pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 416) + 9480));
      pthread_cond_broadcast((pthread_cond_t *)(*(void *)(a1 + 416) + 9544));
      pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 416) + 9480));
    }
    uint64_t v11 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEBUG)) {
      sub_62614((uint64_t *)(a1 + 8960), v11);
    }
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 1852797029;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
      sub_625E0();
    }
  }
  sub_5CF10(buf);
  return v8;
}

void sub_81E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_8204(uint64_t result)
{
  uint64_t v1 = result;
  if (*(void *)(result + 32))
  {
    sub_1F74C(result + 96);
    BOOL result = munmap(*(void **)(v1 + 32), *(void *)(v1 + 40));
    *(void *)(v1 + 32) = 0;
  }
  if (*(void *)(v1 + 48))
  {
    sub_1F74C(v1 + 120);
    BOOL result = munmap(*(void **)(v1 + 48), *(void *)(v1 + 56));
    *(void *)(v1 + 48) = 0;
  }
  if (*(void *)(v1 + 64))
  {
    sub_1F74C(v1 + 144);
    BOOL result = munmap(*(void **)(v1 + 64), *(void *)(v1 + 72));
    *(void *)(v1 + 64) = 0;
  }
  return result;
}

uint64_t sub_8278(_DWORD *a1)
{
  uint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 664))(a1);
  if ((result & 1) == 0)
  {
    unsigned int v3 = a1[99];
    int v4 = a1[97];
    if (v3 != v4)
    {
      uint64_t v5 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = a1[96];
        v7[0] = 67109632;
        v7[1] = v4;
        __int16 v8 = 1024;
        unsigned int v9 = v3;
        __int16 v10 = 1024;
        int v11 = v6;
        _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "LatencyUpdate Request config change mLinkLatency %u -> %u, mPluginLatency %u to HAL", (uint8_t *)v7, 0x14u);
        unsigned int v3 = a1[99];
      }
      return (*(uint64_t (**)(_DWORD *, uint64_t, void))(*(void *)a1 + 240))(a1, 1819569763, v3);
    }
  }
  return result;
}

uint64_t sub_83B0(uint64_t a1)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_5CDCC((uint64_t)v10, a1 + 552);
  if (*(void *)(a1 + 216)) {
    *(void *)(a1 + 216) = 0;
  }
  if (*(void *)(a1 + 224)) {
    *(void *)(a1 + 224) = 0;
  }
  uint64_t v2 = *(void *)(a1 + 232);
  if (v2)
  {
    if (!*(unsigned char *)(a1 + 744) || (sub_13610(v2), (uint64_t v2 = *(void *)(a1 + 232)) != 0)) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    *(void *)(a1 + 232) = 0;
  }
  uint64_t v3 = *(void *)(a1 + 240);
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    *(void *)(a1 + 240) = 0;
  }
  uint64_t v4 = *(void *)(a1 + 248);
  if (v4)
  {
    if (*(unsigned char *)(a1 + 744))
    {
      sub_13610(v4);
      uint64_t v4 = *(void *)(a1 + 248);
    }
    if (v4 == *(void *)(a1 + 272)) {
      *(void *)(a1 + 272) = 0;
    }
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    *(void *)(a1 + 248) = 0;
  }
  uint64_t v5 = *(void *)(a1 + 272);
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    *(void *)(a1 + 272) = 0;
  }
  uint64_t v6 = *(void *)(a1 + 256);
  if (v6)
  {
    if (v6 == *(void *)(a1 + 280)) {
      *(void *)(a1 + 280) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    *(void *)(a1 + 256) = 0;
  }
  uint64_t v7 = *(void *)(a1 + 280);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    *(void *)(a1 + 280) = 0;
  }
  uint64_t v8 = *(void *)(a1 + 264);
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
    *(void *)(a1 + 264) = 0;
  }
  return sub_5CF10(v10);
}

void sub_85A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

float sub_85B4(uint64_t a1, float a2)
{
  float v2 = *(float *)(a1 + 444);
  if (v2 > a2) {
    a2 = *(float *)(a1 + 444);
  }
  float v3 = *(float *)(a1 + 448);
  if (a2 > v3) {
    a2 = *(float *)(a1 + 448);
  }
  return (float)((float)(v3 - a2) / v2) + 1.0;
}

float sub_85E0(uint64_t a1, float a2)
{
  return *(float *)(a1 + 448) - (float)((float)(a2 + -1.0) * *(float *)(a1 + 444));
}

uint64_t sub_85F8(uint64_t a1, int a2)
{
  return sub_4BB04(*(uint64_t **)(a1 + 416), a2, a1);
}

float *sub_8604(float *result, float a2)
{
  float v3 = result[108];
  float v4 = result[2266];
  float v5 = v4 * a2;
  if (v3 != (float)(v4 * a2))
  {
    uint64_t v6 = result;
    result[108] = v5;
    (*(void (**)(float *, float))(*(void *)result + 328))(result, v4 * a2);
    uint64_t v7 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *((void *)v6 + 25);
      v11[0] = 134218754;
      *(double *)&v11[1] = v3;
      __int16 v12 = 2048;
      double v13 = v5;
      __int16 v14 = 2048;
      double v15 = a2;
      __int16 v16 = 2114;
      uint64_t v17 = v8;
      _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Wireless Splitter Updating individual volume from MV [%f -> %f] MV = %f device %{public}@", (uint8_t *)v11, 0x2Au);
    }
    uint64_t result = (float *)(*(uint64_t (**)(float *))(*(void *)v6 + 1280))(v6);
    if (result)
    {
      if (!*((unsigned char *)v6 + 408))
      {
        uint64_t v9 = *((void *)v6 + 50);
        if (v9)
        {
          unsigned __int8 v10 = atomic_load((unsigned __int8 *)(v9 + 24));
          if (v10) {
            sub_181A4(*((void *)v6 + 50), v6[110]);
          }
        }
      }
      strcpy((char *)v11, "dlovptuo");
      BYTE1(v11[2]) = 0;
      HIWORD(v11[2]) = 0;
      return (float *)(*(uint64_t (**)(float *, _DWORD *))(*(void *)v6 + 248))(v6, v11);
    }
  }
  return result;
}

void sub_87CC(void *a1, int a2)
{
  uint64_t v3 = *(void *)(a1[52] + 9248);
  if ((*(unsigned char *)(v3 + 328) != 0) != a2)
  {
    sub_2D5E8(v3, a2);
    float v5 = (id *)a1[26];
    if (v5)
    {
      uint64_t v6 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
      {
        if (a2) {
          uint64_t v7 = "enabled";
        }
        else {
          uint64_t v7 = "disabled";
        }
        int v8 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
        int v9 = 136315394;
        unsigned __int8 v10 = v7;
        __int16 v11 = 1024;
        int v12 = v8;
        _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Wireless Splitter from CA is %s for device %d", (uint8_t *)&v9, 0x12u);
        float v5 = (id *)a1[26];
      }
      sub_14EAC(v5, a2);
    }
  }
}

uint64_t sub_88FC(uint64_t a1, char a2)
{
  return sub_2D5E8(*(void *)(*(void *)(a1 + 416) + 9248), a2);
}

uint64_t sub_8908(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 328);
}

uint64_t sub_8918(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 232);
  if (v1) {
    return *(unsigned int *)(v1 + 52);
  }
  else {
    return 0xFFFFLL;
  }
}

void sub_8930(uint64_t a1, void **a2, BOOL a3)
{
  uint64_t v6 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 200);
    int v8 = a2;
    if (*((char *)a2 + 23) < 0) {
      int v8 = *a2;
    }
    int v9 = "Relinquished";
    *(_DWORD *)buf = 138543874;
    uint64_t v14 = v7;
    __int16 v15 = 2082;
    if (a3) {
      int v9 = "Owned";
    }
    __int16 v16 = v8;
    __int16 v17 = 2082;
    unsigned int v18 = v9;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "[%{public}@] Update ownership state notification for %{public}s Bluetoothd as %{public}s", buf, 0x20u);
  }
  unsigned __int8 v10 = *(id **)(a1 + 208);
  if (v10)
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_B9AC(__p, *a2, (unint64_t)a2[1]);
    }
    else
    {
      *(_OWORD *)std::string __p = *(_OWORD *)a2;
      int v12 = a2[2];
    }
    sub_161D8(v10, (const char *)__p, a3);
    if (SHIBYTE(v12) < 0) {
      operator delete(__p[0]);
    }
  }
}

void sub_8A70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_8A94(uint64_t a1, float a2)
{
  float v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_164EC(v2, a2);
  }
}

void sub_8AA4(uint64_t a1)
{
  uint64_t v1 = *(id **)(a1 + 208);
  if (v1) {
    sub_165E4(v1);
  }
}

BOOL sub_8AB4(uint64_t a1)
{
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 416) + 9248) + 320) == 0;
}

float sub_8ACC()
{
  TranslateValue();
  return v0;
}

void *sub_8B04@<X0>(int a1@<W1>, void *a2@<X8>)
{
  uint64_t v3 = "unknown";
  if (a1 == 2) {
    uint64_t v3 = "right";
  }
  if (a1 == 1) {
    float v4 = "left";
  }
  else {
    float v4 = (char *)v3;
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_BAF4(a2, v4);
}

void *sub_8B3C@<X0>(int a1@<W1>, void *a2@<X8>)
{
  switch(a1)
  {
    case 2:
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      float v4 = "FiedLeft";
      goto LABEL_7;
    case 1:
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      float v4 = "FixedRight";
      goto LABEL_7;
    case 0:
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      float v4 = "Auto";
LABEL_7:
      return sub_BAF4(a2, v4);
  }
  uint64_t v6 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
    sub_62690(a1, v6);
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_BAF4(a2, "Unknown");
}

uint64_t sub_8C18(uint64_t a1, __int32 *a2)
{
  if (!a2) {
    return 1852797029;
  }
  uint64_t v3 = *(uint64_t (***)(void, uint64_t, uint64_t, __int32 *))(qword_A2350 + 144);
  float v4 = *v3;
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v6 = v4(v3, v5, 1, a2);
  if (v6)
  {
    uint64_t v7 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
      sub_62708(a2, v7, v8);
    }
  }
  return v6;
}

uint64_t sub_8CCC(uint64_t a1)
{
  uint64_t v2 = 0x676C6F6262616366;
  int v3 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 248))(a1, &v2);
}

BOOL sub_8D20(uint64_t a1)
{
  return *(void *)(a1 + 8960) != 0;
}

void sub_8D30(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 289);
  BOOL v2 = v1 != 0;
  unsigned __int8 v3 = v1 - 1;
  if (v2) {
    unsigned __int8 v4 = v3;
  }
  else {
    unsigned __int8 v4 = 0;
  }
  *(unsigned char *)(a1 + 289) = v4;
  uint64_t v5 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v4;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Decerement StartIO block counters pending Config Change %d", (uint8_t *)v6, 8u);
  }
}

void sub_8DE0(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 289) = a2;
  unsigned __int8 v3 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = a2;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Increment StartIO block counters pending Config Change %d", (uint8_t *)v4, 8u);
  }
}

uint64_t sub_8E84(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 289);
}

void sub_8E8C(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 290);
  BOOL v2 = v1 != 0;
  unsigned __int8 v3 = v1 - 1;
  if (v2) {
    unsigned __int8 v4 = v3;
  }
  else {
    unsigned __int8 v4 = 0;
  }
  *(unsigned char *)(a1 + 290) = v4;
  uint64_t v5 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v4;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Decrement bypass StartIO counter %d", (uint8_t *)v6, 8u);
  }
}

void sub_8F3C(uint64_t a1)
{
  *(unsigned char *)(a1 + 290) = 0;
  int v1 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 67109120;
    v2[1] = 0;
    _os_log_impl(&dword_0, v1, OS_LOG_TYPE_DEFAULT, "Clear bypass StartIO counter %d", (uint8_t *)v2, 8u);
  }
}

void sub_8FDC(uint64_t a1)
{
  unsigned __int8 v1 = *(unsigned char *)(a1 + 290) + 1;
  *(unsigned char *)(a1 + 290) = v1;
  BOOL v2 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    v3[0] = 67109120;
    v3[1] = v1;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Increment bypass StartIO counter %d", (uint8_t *)v3, 8u);
  }
}

uint64_t sub_9088(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 290);
}

uint64_t sub_9090(uint64_t a1, uint64_t a2)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_5CDCC((uint64_t)v5, a1 + 552);
  *(void *)(a1 + 208) = a2;
  return sub_5CF10(v5);
}

uint64_t sub_90D8(uint64_t a1)
{
  return *(void *)(a1 + 208);
}

uint64_t sub_90E0()
{
  double v0 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_FAULT)) {
    sub_6279C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t result = sub_5CB00();
  if (result) {
    abort();
  }
  return result;
}

uint64_t sub_912C()
{
  return 0;
}

uint64_t sub_9134(_DWORD *a1, int a2)
{
  uint64_t v4 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 664))(a1);
    v7[0] = 67109376;
    v7[1] = a2;
    __int16 v8 = 1024;
    int v9 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "LatencyUpdate Set link latency to %u, dynamic %d", (uint8_t *)v7, 0xEu);
  }
  uint64_t result = (*(uint64_t (**)(_DWORD *))(*(void *)a1 + 664))(a1);
  if ((result & 1) == 0)
  {
    a1[97] = a2;
    a1[98] = a2;
  }
  return result;
}

void sub_9264(uint64_t a1, int a2)
{
  int v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 664))(a1);
  int v5 = *(void **)(a1 + 416);
  if (v5)
  {
    uint64_t v6 = v5[1156];
    if (v6) {
      LODWORD(v6) = *(unsigned __int8 *)(v6 + 328);
    }
  }
  else
  {
    LODWORD(v6) = 0;
  }
  if (v6 | v4)
  {
    *(_DWORD *)(a1 + 388) = a2;
    *(_DWORD *)(a1 + 396) = a2;
    uint64_t v7 = qword_97500;
    if (!os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v8 = *(_DWORD *)(a1 + 384);
    int v16 = 67109376;
    int v17 = a2;
    __int16 v18 = 1024;
    int v19 = v8;
    int v9 = "LatencyUpdate dynamic, mLinkLatency %u, mPluginLatency %u";
    unsigned __int8 v10 = v7;
    uint32_t v11 = 14;
    goto LABEL_12;
  }
  *(_DWORD *)(a1 + 396) = a2;
  if (((*(uint64_t (**)(void *))(*v5 + 992))(v5) & 1) == 0) {
    sub_8278((_DWORD *)a1);
  }
  uint64_t v12 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *(_DWORD *)(a1 + 388);
    int v14 = *(_DWORD *)(a1 + 384);
    int v15 = (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 992))(*(void *)(a1 + 416));
    int v16 = 67109632;
    int v17 = v13;
    __int16 v18 = 1024;
    int v19 = v14;
    __int16 v20 = 1024;
    int v21 = v15;
    int v9 = "LatencyUpdate static, mLinkLatency %u, mPluginLatency %u, IO %d";
    unsigned __int8 v10 = v12;
    uint32_t v11 = 20;
LABEL_12:
    _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, v9, (uint8_t *)&v16, v11);
  }
}

uint64_t sub_9450()
{
  double v0 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_FAULT)) {
    sub_6279C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t result = sub_5CB00();
  if (result) {
    abort();
  }
  return result;
}

uint64_t sub_949C()
{
  return 0;
}

uint64_t sub_94A4()
{
  return 0;
}

uint64_t sub_94AC()
{
  return 0;
}

uint64_t sub_94B4()
{
  return 0;
}

uint64_t sub_94BC()
{
  return 0;
}

uint64_t sub_94C4()
{
  return 0;
}

uint64_t sub_94CC()
{
  return 0;
}

uint64_t sub_94D4()
{
  return 0;
}

uint64_t sub_94DC()
{
  return 0;
}

uint64_t sub_94E4()
{
  return 0;
}

uint64_t sub_94EC()
{
  return 0;
}

uint64_t sub_94F4()
{
  return 0;
}

uint64_t sub_94FC(uint64_t a1, int a2, uint64_t a3)
{
  if (!a2) {
    return 1852797029;
  }
  int v3 = *(_DWORD *)(a1 + 8);
  uint64_t v4 = *(NSObject **)(qword_A2350 + 168);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_959C;
  block[3] = &unk_8D280;
  int v7 = a2;
  int v8 = v3;
  void block[4] = a1;
  block[5] = a3;
  dispatch_async(v4, block);
  return 0;
}

void sub_959C(uint64_t a1)
{
  uint64_t v2 = (int *)(a1 + 48);
  if (*(_DWORD *)(a1 + 48) && *(void *)(qword_A2350 + 144) && (uint64_t v3 = *(void *)(a1 + 32), sub_41A14()))
  {
    uint64_t v4 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      v5.i32[0] = *v2;
      int16x8_t v6 = (int16x8_t)vmovl_u8(v5);
      *(int16x4_t *)v6.i8 = vrev64_s16(*(int16x4_t *)v6.i8);
      unsigned __int32 v9 = vmovn_s16(v6).u32[0];
      char v10 = 0;
      int v7 = *(_DWORD *)(v3 + 8);
      *(_DWORD *)buf = 136446466;
      uint64_t v12 = &v9;
      __int16 v13 = 1024;
      int v14 = v7;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Sending device config change for %{public}s on %d", buf, 0x12u);
    }
    (*(void (**)(void))(*(void *)(qword_A2350 + 144) + 32))();
  }
  else
  {
    int v8 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_ERROR)) {
      sub_62814(v2, a1, v8);
    }
  }
}

uint64_t sub_96F0()
{
  return 0;
}

uint64_t sub_96F8()
{
  return 0;
}

uint64_t sub_9700()
{
  return 0;
}

uint64_t sub_9708()
{
  double v0 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_FAULT)) {
    sub_6279C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t result = sub_5CB00();
  if (result) {
    abort();
  }
  return result;
}

BOOL sub_9754(uint64_t a1)
{
  return *(unsigned char *)(a1 + 409) != 0;
}

BOOL sub_9764(uint64_t a1)
{
  return *(unsigned char *)(a1 + 410) != 0;
}

uint64_t sub_9774()
{
  double v0 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_FAULT)) {
    sub_6279C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t result = sub_5CB00();
  if (result) {
    abort();
  }
  return result;
}

void sub_97C0(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v4 = *(void *)(a1 + 400);
    if (v4) {
      atomic_store(0, (unsigned __int8 *)(v4 + 24));
    }
  }
  *(unsigned char *)(a1 + 408) = a2;
  uint64_t v5 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      uint64_t v6 = "";
    }
    else {
      uint64_t v6 = "not";
    }
    int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v8 = 136446466;
    unsigned __int32 v9 = v6;
    __int16 v10 = 1024;
    int v11 = v7;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Set absolute volume to %{public}s supported for device mAudioObjectID %d", (uint8_t *)&v8, 0x12u);
  }
}

uint64_t sub_98D0(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 416) + 9248) + 180);
}

uint64_t sub_98E0(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 157);
}

uint64_t sub_98F0(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 200);
}

uint64_t sub_9900(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 329);
}

uint64_t sub_9910(void *a1, float a2)
{
  int v4 = sub_395B4();
  if (a2 != 0.0 && v4 != 0)
  {
    uint64_t v6 = a1[52];
    uint64_t v7 = *(void *)(v6 + 9248);
    if (*(_DWORD *)(v7 + 152))
    {
      *(_DWORD *)(v7 + 152) = 0;
      sub_55BB4(v6, 1836414053);
    }
  }
  int v8 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void **)(a1[52] + 9120) == a1) {
      unsigned __int32 v9 = "Routed";
    }
    else {
      unsigned __int32 v9 = "Not Routed";
    }
    int v11 = 136446466;
    uint64_t v12 = v9;
    __int16 v13 = 2048;
    double v14 = a2;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Volume Update received from bluetoothd, for %{public}s Audio device volume %f", (uint8_t *)&v11, 0x16u);
  }
  return (*(uint64_t (**)(void *, BOOL, float))(*a1 + 480))(a1, *(void *)(a1[52] + 9120) == (void)a1, a2);
}

void *sub_9A60(void *result, float a2)
{
  uint64_t v2 = result[52];
  if (v2)
  {
    uint64_t v3 = result;
    uint64_t result = *(void **)(v2 + 9120);
    if (result)
    {
      uint64_t v5 = (int)(float)((*(float (**)(void *))(*result + 920))(result) * 100.0);
      uint64_t v6 = *(uint64_t (**)(void *, uint64_t, void, void))(*v3 + 360);
      return (void *)v6(v3, v5, (int)(float)(a2 * 100.0), 0);
    }
  }
  return result;
}

void sub_9B30(uint64_t *a1, char *__s1, void *a3)
{
  if (!strcmp(__s1, "kBTAudioMsgPropertyVolumeScalar"))
  {
    float value = xpc_double_get_value(a3);
    (*(void (**)(uint64_t *, float))(*a1 + 352))(a1, value);
    __int16 v10 = *(void (**)(uint64_t *, __n128))(*a1 + 344);
    int v11 = a1;
    v12.n128_f32[0] = value;
    goto LABEL_36;
  }
  if (!strcmp(__s1, "kBTAudioMsgPropertyInputVolumeScalar"))
  {
    v12.n128_f64[0] = xpc_double_get_value(a3);
    __int16 v10 = *(void (**)(uint64_t *, __n128))(*a1 + 504);
    v12.n128_f32[0] = v12.n128_f64[0];
    int v11 = a1;
LABEL_36:
    v10(v11, v12);
    return;
  }
  if (!strcmp(__s1, "kBTAudioMsgPropertyLatency"))
  {
    int64_t v13 = xpc_int64_get_value(a3);
    double v14 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEBUG)) {
      sub_628A4(v13, v14);
    }
    (*(void (**)(uint64_t *, int64_t))(*a1 + 280))(a1, v13);
  }
  else if (!strcmp(__s1, "kBTAudioMsgPropertyVolumeIsAbsolute"))
  {
    BOOL v15 = xpc_BOOL_get_value(a3);
    int v16 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEBUG)) {
      sub_6291C(v15, v16);
    }
    (*(void (**)(uint64_t *, BOOL))(*a1 + 1152))(a1, v15);
    if (v15) {
      (*(void (**)(uint64_t *))(*a1 + 512))(a1);
    }
  }
  else if (!strcmp(__s1, "kBTAudioMsgPropertyScoIsEnabled"))
  {
    xpc_object_t v17 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyScoStatus");
    xpc_object_t v18 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyScoIsEnabled");
    if (v18 && v17)
    {
      int v19 = v18;
      int64_t v20 = xpc_int64_get_value(v17);
      BOOL v21 = xpc_BOOL_get_value(v19);
      uint64_t v22 = *(void (**)(uint64_t *, int64_t, BOOL))(*a1 + 384);
      v22(a1, v20, v21);
    }
  }
  else
  {
    if (!strcmp(__s1, "kBTAudioMsgPropertyECNRIsEnabled"))
    {
      BOOL v23 = xpc_BOOL_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 416);
      int64_t v25 = v23;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyNBSSupport"))
    {
      BOOL v27 = xpc_BOOL_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 424);
      int64_t v25 = v27;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyWBSSupport"))
    {
      BOOL v28 = xpc_BOOL_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 432);
      int64_t v25 = v28;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyUWBSSupport"))
    {
      BOOL v29 = xpc_BOOL_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 440);
      int64_t v25 = v29;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyUWBSStereoSupport"))
    {
      BOOL v30 = xpc_BOOL_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 448);
      int64_t v25 = v30;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertySWBStereoSupport"))
    {
      BOOL v31 = xpc_BOOL_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 456);
      int64_t v25 = v31;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyCategory"))
    {
      int64_t v32 = xpc_int64_get_value(a3);
      (*(void (**)(uint64_t *, int64_t))(*a1 + 464))(a1, v32);
      sub_49F68(a1[52], 1684234612);
      uint64_t v33 = qword_97500;
      if (!os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v34 = (*(uint64_t (**)(uint64_t *))(*a1 + 824))(a1);
      int v60 = 67109120;
      LODWORD(v61) = v34;
      uint64_t v35 = "kBTAudioMsgPropertyCategory : Updated as %u";
      uint64_t v36 = v33;
      goto LABEL_72;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyDSPOffload"))
    {
      BOOL v37 = xpc_BOOL_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 472);
      int64_t v25 = v37;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyBitpool"))
    {
      int64_t v38 = xpc_int64_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 736);
      int64_t v25 = v38;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyCodec"))
    {
      int64_t v39 = xpc_int64_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 752);
      int64_t v25 = v39;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyFrameCount"))
    {
      int64_t v40 = xpc_int64_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 744);
      int64_t v25 = v40;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyRtpInterval"))
    {
      int64_t v41 = xpc_int64_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 760);
      int64_t v25 = v41;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyFrameLen"))
    {
      int64_t v42 = xpc_int64_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 768);
      int64_t v25 = v42;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertyLinkAdaptEncoderBitrate"))
    {
      int64_t v43 = xpc_int64_get_value(a3);
      uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 880);
      int64_t v25 = v43;
      uint64_t v26 = a1;
      goto LABEL_110;
    }
    if (!strcasecmp(__s1, "kBTAudioMsgPropertySamplingSpeedParams"))
    {
      (*(void (**)(uint64_t *))(*a1 + 864))(a1);
      (*(void (**)(uint64_t *))(*a1 + 856))(a1);
      xpc_object_t v44 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyLatencyChangeMsec");
      xpc_object_t v45 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySamplingIntervalMultiplier");
      if (v45 && v44)
      {
        unsigned int v46 = v45;
        int64_t v47 = xpc_int64_get_value(v44);
        v49.n128_f64[0] = xpc_double_get_value(v46);
        v48 = *(void (**)(uint64_t *, int64_t, __n128))(*a1 + 688);
        v49.n128_f32[0] = v49.n128_f64[0];
        v48(a1, v47, v49);
      }
    }
    else
    {
      if (!strcasecmp(__s1, "kBTAudioMsgPropertyDynamicClock"))
      {
        BOOL v50 = xpc_BOOL_get_value(a3);
        uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 696);
        int64_t v25 = v50;
        uint64_t v26 = a1;
        goto LABEL_110;
      }
      if (strcasecmp(__s1, "kBTAudioMsgPropertyLowLatencyMode"))
      {
        if (strcasecmp(__s1, "kBTAudioMsgPropertyDynamicLatencyDelayMicroSec"))
        {
          if (strcasecmp(__s1, "kBTAudioMsgPropertyInputAudio"))
          {
            if (!strcasecmp(__s1, "kBTAudioMsgPropertySupportedCodecs"))
            {
              v56 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
              (*(void (**)(uint64_t *, const void *))(*a1 + 904))(a1, v56);
              CFRelease(v56);
            }
            else if (!strcasecmp(__s1, "kBTAudioMsgPropertyInputSWPLCSupport"))
            {
              BOOL v57 = xpc_BOOL_get_value(a3);
              sub_ACB4((uint64_t)a1, v57);
            }
            else if (!strcasecmp(__s1, "kBTAudioMsgPropertyWSModeEnabled"))
            {
              BOOL v58 = xpc_BOOL_get_value(a3);
              sub_4BB04((uint64_t *)a1[52], v58, (uint64_t)a1);
              uint64_t v59 = qword_A2350;
              sub_44840(v59);
            }
            else if (!strcasecmp(__s1, "kBTAudioMsgPropertyDynamicLatencySupported"))
            {
              BOOL v6 = xpc_BOOL_get_value(a3);
              uint64_t v7 = qword_97500;
              if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
              {
                int v8 = "not supported";
                if (v6) {
                  int v8 = "supported";
                }
                int v60 = 136315138;
                v61 = v8;
                _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Dynamic Latency is %s", (uint8_t *)&v60, 0xCu);
              }
              (*(void (**)(uint64_t *, BOOL))(*a1 + 672))(a1, v6);
            }
            return;
          }
          BOOL v55 = xpc_BOOL_get_value(a3);
          uint64_t v24 = *(void (**)(uint64_t *, int64_t))(*a1 + 888);
          int64_t v25 = v55;
          uint64_t v26 = a1;
LABEL_110:
          v24(v26, v25);
          return;
        }
        unint64_t v53 = xpc_int64_get_value(a3) / 0x3E8uLL;
        (*(void (**)(uint64_t *, unint64_t))(*a1 + 656))(a1, v53);
        uint64_t v54 = qword_97500;
        if (!os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v60 = 67109120;
        LODWORD(v61) = v53;
        uint64_t v35 = "In ear-Latency change received from BTServer, latency %uMSec";
        uint64_t v36 = v54;
LABEL_72:
        _os_log_impl(&dword_0, v36, OS_LOG_TYPE_DEFAULT, v35, (uint8_t *)&v60, 8u);
        return;
      }
      unsigned __int8 v51 = xpc_int64_get_value(a3);
      __int16 v52 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
      {
        int v60 = 67109120;
        LODWORD(v61) = v51;
        _os_log_impl(&dword_0, v52, OS_LOG_TYPE_DEFAULT, "latencyMode received from bluetoothd: %d", (uint8_t *)&v60, 8u);
      }
      (*(void (**)(uint64_t *, void))(*a1 + 624))(a1, v51);
    }
  }
}

void sub_ACB4(uint64_t a1, int a2)
{
  int v4 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "not supported";
    if (a2) {
      uint64_t v5 = "supported";
    }
    int v6 = 136315138;
    uint64_t v7 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Set SupportInputSwPlc %s", (uint8_t *)&v6, 0xCu);
  }
  *(unsigned char *)(a1 + 536) = a2;
}

uint64_t sub_AD7C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 416) = a2;
  return result;
}

uint64_t sub_AD84(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 168);
}

uint64_t sub_AD94(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 416) + 9248) + 152);
}

uint64_t sub_ADA4(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 145);
}

uint64_t sub_ADB4(uint64_t a1, char a2, int a3)
{
  uint64_t result = *(void *)(a1 + 416);
  *(unsigned char *)(*(void *)(result + 9248) + 145) = a2;
  if (a3) {
    return sub_49F68(result, 1651466595);
  }
  return result;
}

uint64_t sub_ADD4(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 144);
}

uint64_t sub_ADE4(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 416) + 9248) + 144) = a2;
  return result;
}

uint64_t sub_ADF4(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 416) + 9248) + 172);
}

uint64_t sub_AE04(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 416) + 9248) + 176);
}

uint64_t sub_AE14(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 416) + 9248) + 60);
}

void sub_AE24(uint64_t a1, int a2)
{
  uint64_t v2 = *(void **)(a1 + 416);
  uint64_t v3 = v2[1156];
  if (*(_DWORD *)(v3 + 60) != a2)
  {
    *(_DWORD *)(v3 + 60) = a2;
    uint64_t v5 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = (*(uint64_t (**)(void *))(*v2 + 16))(v2);
      int v7 = *(_DWORD *)(*(void *)(*(void *)(a1 + 416) + 9248) + 60);
      v8[0] = 67109376;
      v8[1] = v6;
      __int16 v9 = 1024;
      int v10 = v7;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Local stream state of mAudioObjectID %d changed to %d", (uint8_t *)v8, 0xEu);
    }
  }
}

void sub_AF24(uint64_t a1, unsigned int a2)
{
  int v4 = qword_97500;
  if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Setting listen mode  %d", (uint8_t *)v6, 8u);
  }
  uint64_t v5 = *(id **)(a1 + 208);
  if (v5) {
    sub_163C8(v5, a2);
  }
}

void sub_AFE0(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v21 = 0;
  long long v19 = 0u;
  long long v20 = 0u;
  int v6 = sub_44C8C(qword_A2350, a3);
  if (!v6) {
    goto LABEL_11;
  }
  uint64_t v7 = v6[1137];
  if (v7) {
    LOBYTE(v7) = *(unsigned char *)(v7 + 192) != 0;
  }
  uint64_t v8 = v6[1139];
  if (v8 && *(unsigned char *)(v8 + 192)) {
    LOBYTE(v7) = 1;
  }
  if (v7)
  {
    if (*(unsigned char *)(a1 + 9017))
    {
      if (*(void *)(a1 + 416))
      {
        (*(void (**)(long long *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(&v19, a1, 0);
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_B1E8;
        v13[3] = &unk_8D2A0;
        unsigned int v17 = a3;
        v13[4] = a1;
        unsigned char v13[5] = a2;
        long long v14 = v19;
        long long v15 = v20;
        uint64_t v16 = v21;
        dispatch_block_t v9 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v13);
        *(void *)(a1 + 9008) = v9;
        sub_456B0(qword_A2350, 10, a3, v9);
      }
    }
    else
    {
      int v11 = qword_97500;
      if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Injecting silent Audio Stopped", buf, 2u);
      }
      __n128 v12 = *(void **)(a1 + 9008);
      if (v12 && !dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 9008)))
      {
        dispatch_block_cancel(v12);
        __n128 v12 = *(void **)(a1 + 9008);
      }
      _Block_release(v12);
      *(void *)(a1 + 9008) = 0;
    }
  }
  else
  {
LABEL_11:
    int v10 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Injecting silent Audio Stopped : Input device not available", buf, 2u);
    }
  }
}

uint64_t sub_B1E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  v22[0] = 0;
  v22[1] = 0;
  sub_5CDCC((uint64_t)v22, qword_A2350 + 200);
  _Block_release(*(const void **)(v2 + 9008));
  *(void *)(v2 + 9008) = 0;
  sub_5CEA4((uint64_t)v22);
  uint64_t v3 = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 88));
  if (!v3) {
    goto LABEL_17;
  }
  uint64_t v4 = v3[1137];
  if (v4) {
    LOBYTE(v4) = *(unsigned char *)(v4 + 192) != 0;
  }
  uint64_t v5 = v3[1139];
  if (v5 && *(unsigned char *)(v5 + 192)) {
    LOBYTE(v4) = 1;
  }
  if ((v4 & 1) == 0)
  {
LABEL_17:
    uint64_t v13 = qword_97500;
    if (!os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT)) {
      return sub_5CF10(v22);
    }
    *(_WORD *)mach_timebase_info info = 0;
    long long v14 = "Injecting silent Audio Stopped : Input device not available";
    goto LABEL_19;
  }
  if (!*(unsigned char *)(v2 + 9017))
  {
    uint64_t v13 = qword_97500;
    if (!os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT)) {
      return sub_5CF10(v22);
    }
    *(_WORD *)mach_timebase_info info = 0;
    long long v14 = "Injecting silent Audio Stopped";
LABEL_19:
    long long v15 = v13;
    uint32_t v16 = 2;
LABEL_20:
    _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, v14, info, v16);
    return sub_5CF10(v22);
  }
  uint64_t v6 = mach_absolute_time();
  if (*(void *)(a1 + 40) && !*(unsigned char *)(*(void *)(v2 + 416) + 9440))
  {
    *(void *)mach_timebase_info info = 0;
    mach_timebase_info((mach_timebase_info_t)info);
    float v7 = *(double *)(a1 + 48) / 1000.0;
    float v8 = (float)((float)((v6 - *(void *)(a1 + 40)) * *(unsigned int *)info / *(unsigned int *)&info[4] / 0x3E8)
               / 1000.0)
       * v7;
    unsigned int v9 = *(_DWORD *)(a1 + 64);
    if ((float)(v8 * (float)v9) > 8192.0) {
      float v8 = (float)(0x1000 / v9);
    }
    unsigned int v10 = v8;
    uint64_t v11 = sub_5AF8(v2, v8, (char *)(v2 + 768));
    uint64_t v12 = *(void *)(v2 + 16);
    if (v12) {
      sub_1E060(v12, v10, (const float *)(v2 + 768), v11);
    }
  }
  if (!(*(unsigned int (**)(uint64_t))(*(void *)v2 + 992))(v2))
  {
    uint64_t v18 = qword_97500;
    if (!os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT)) {
      return sub_5CF10(v22);
    }
    uint64_t v19 = *(void *)(v2 + 200);
    uint64_t v20 = *(void *)(a1 + 40);
    int v21 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 992))(v2);
    *(_DWORD *)mach_timebase_info info = 138543874;
    *(void *)&info[4] = v19;
    __int16 v24 = 2048;
    uint64_t v25 = v20;
    __int16 v26 = 1024;
    int v27 = v21;
    long long v14 = " %{public}@ : Injecting silent Audio allowed to stop [%llu  %d]";
    long long v15 = v18;
    uint32_t v16 = 28;
    goto LABEL_20;
  }
  (*(void (**)(uint64_t, uint64_t, void))(*(void *)v2 + 1448))(v2, v6, *(unsigned int *)(a1 + 88));
  return sub_5CF10(v22);
}

void sub_B524(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_B554(uint64_t a1)
{
  unsigned int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 16))(*(void *)(a1 + 416));
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_B604;
  v4[3] = &unk_8D2C0;
  v4[4] = a1;
  return sub_44BA4(qword_A2350, v2, v4);
}

void sub_B604(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  unsigned int v2 = *(void **)(v1 + 9008);
  if (v2 && !dispatch_block_testcancel(*(dispatch_block_t *)(v1 + 9008)))
  {
    uint64_t v3 = qword_97500;
    if (os_log_type_enabled((os_log_t)qword_97500, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Injecting silent Audio Stopped", v4, 2u);
      unsigned int v2 = *(void **)(v1 + 9008);
    }
    dispatch_block_cancel(v2);
    _Block_release(*(const void **)(v1 + 9008));
    *(void *)(v1 + 9008) = 0;
  }
}

float sub_B6A0(float *a1, int a2)
{
  if (a2 == 1)
  {
    float v2 = a1[108];
    float v3 = a1[114];
    return v2 * v3;
  }
  if (!a2)
  {
    float v2 = a1[108];
    float v3 = a1[113];
    return v2 * v3;
  }
  return a1[108];
}

void *sub_B6D0@<X0>(unsigned int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 3) {
    float v2 = "Unknown";
  }
  else {
    float v2 = off_8D2F8[a1];
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_BAF4(a2, v2);
}

void *sub_B700@<X0>(unsigned int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 0xC) {
    float v2 = "unknown";
  }
  else {
    float v2 = off_8D318[a1];
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_BAF4(a2, v2);
}

BOOL sub_B754(uint64_t a1)
{
  return *(unsigned char *)(a1 + 460) != 0;
}

uint64_t sub_B7D0()
{
  return 0;
}

uint64_t sub_B7DC()
{
  return 0;
}

uint64_t sub_B818()
{
  return 0;
}

uint64_t sub_B820()
{
  return 0;
}

float sub_B828()
{
  return 1.0;
}

uint64_t sub_B830()
{
  return 0;
}

float sub_B84C(uint64_t a1)
{
  return *(float *)(a1 + 432);
}

float sub_B854(uint64_t a1)
{
  return *(float *)(a1 + 440);
}

uint64_t sub_B85C(uint64_t result, float a2)
{
  *(float *)(result + 440) = a2;
  return result;
}

float sub_B864(uint64_t a1)
{
  return *(float *)(a1 + 444);
}

float sub_B86C(uint64_t a1)
{
  return *(float *)(a1 + 448);
}

BOOL sub_B880(uint64_t a1)
{
  return *(void *)(a1 + 8960) != 0;
}

uint64_t sub_B890(uint64_t a1)
{
  return *(void *)(a1 + 8960);
}

uint64_t sub_B898(uint64_t result)
{
  return result;
}

uint64_t sub_B8A8(uint64_t result)
{
  return result;
}

uint64_t sub_B8B8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8968) = a2;
  return result;
}

uint64_t sub_B8C0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8976) = a2;
  return result;
}

uint64_t sub_B8C8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8984) = a2;
  return result;
}

double sub_B8D0(uint64_t a1, unint64_t a2)
{
  double result = (double)a2;
  *(double *)(a1 + 8992) = (double)a2;
  return result;
}

uint64_t sub_B8DC(uint64_t a1)
{
  return *(void *)(a1 + 8968);
}

uint64_t sub_B8E4(uint64_t a1)
{
  return *(void *)(a1 + 8976);
}

uint64_t sub_B8EC(uint64_t a1)
{
  return *(void *)(a1 + 8984);
}

unint64_t sub_B8F4(uint64_t a1)
{
  return (unint64_t)*(double *)(a1 + 8992);
}

uint64_t sub_B908()
{
  return 0;
}

uint64_t sub_B910()
{
  return 0;
}

uint64_t sub_B918()
{
  return 0;
}

uint64_t sub_B920()
{
  return 0;
}

uint64_t sub_B950()
{
  return 1;
}

uint64_t sub_B964()
{
  return 0;
}

uint64_t sub_B96C()
{
  return 0xFFFFFFFFLL;
}

uint64_t sub_B974()
{
  return 0;
}

uint64_t sub_B97C()
{
  return 0;
}

uint64_t sub_B984()
{
  return 0;
}

uint64_t sub_B994()
{
  return 0;
}

uint64_t sub_B9A4()
{
  return 0;
}

void *sub_B9AC(unsigned char *__dst, void *__src, unint64_t a3)
{
  uint64_t v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8) {
      sub_BA4C();
    }
    uint64_t v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v6 = a3 | 7;
    }
    uint64_t v7 = v6 + 1;
    float v8 = operator new(v6 + 1);
    v5[1] = a3;
    void v5[2] = v7 | 0x8000000000000000;
    void *v5 = v8;
    uint64_t v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }

  return memmove(v5, __src, a3 + 1);
}

void sub_BA4C()
{
}

void sub_BA64(const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_BAC0(exception, a1);
}

void sub_BAAC(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_BAC0(std::logic_error *a1, const char *a2)
{
  double result = std::logic_error::logic_error(a1, a2);
  return result;
}

void *sub_BAF4(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    sub_BA4C();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    uint64_t v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    uint64_t v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

void sub_BBA8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_BBC4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

os_log_t sub_BBEC()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_97500 = (uint64_t)result;
  return result;
}

uint64_t sub_BC1C(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  *(_DWORD *)(a1 + 24) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  sub_BE64((void *)a1);
  uint64_t v6 = qword_A19B8;
  if (os_log_type_enabled((os_log_t)qword_A19B8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = sub_7904(*(void *)a1);
    uint64_t v7 = "Guest";
    if (sub_9900(*(void *)a1)) {
      uint64_t v8 = "Guest";
    }
    else {
      uint64_t v8 = "Owner";
    }
    unsigned int v17 = v8;
    if (sub_98E0(*(void *)a1)) {
      uint64_t v9 = "enabled";
    }
    else {
      uint64_t v9 = "disabled";
    }
    if ((*(unsigned int (**)(void))(**(void **)a1 + 1312))()) {
      unsigned int v10 = "enabled";
    }
    else {
      unsigned int v10 = "disabled";
    }
    uint64_t v11 = sub_7904(*(void *)(a1 + 8));
    if (!sub_9900(*(void *)(a1 + 8))) {
      uint64_t v7 = "Owner";
    }
    if (sub_98E0(*(void *)(a1 + 8))) {
      uint64_t v12 = "enabled";
    }
    else {
      uint64_t v12 = "disabled";
    }
    int v13 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 1312))();
    *(_DWORD *)buf = 138414338;
    if (v13) {
      long long v14 = "enabled";
    }
    else {
      long long v14 = "disabled";
    }
    uint64_t v20 = v18;
    long long v15 = "mediaexperience";
    __int16 v21 = 2080;
    uint64_t v22 = v17;
    if (a4) {
      long long v15 = "bluetooth";
    }
    __int16 v23 = 2080;
    __int16 v24 = v9;
    __int16 v25 = 2080;
    __int16 v26 = v10;
    __int16 v27 = 2112;
    uint64_t v28 = v11;
    __int16 v29 = 2080;
    BOOL v30 = v7;
    __int16 v31 = 2080;
    int64_t v32 = v12;
    __int16 v33 = 2080;
    int v34 = v14;
    __int16 v35 = 2080;
    uint64_t v36 = v15;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Wireless Splitter session started aggregating user1 %@ is %s = [InEar=%s, Onwership=%s] and user2 %@ is %s = [InEar=%s, Onwership=%s] aggregated from %s", buf, 0x5Cu);
  }
  if ((a4 & 1) == 0) {
    sub_BF3C(a1);
  }
  return a1;
}

uint64_t sub_BE64(void *a1)
{
  float v2 = qword_A19B8;
  if (os_log_type_enabled((os_log_t)qword_A19B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)size_t v4 = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Wireless Splitter start all aggregates from BTAudioHALPlugin", v4, 2u);
  }
  if (*a1) {
    (*(void (**)(void, uint64_t))(*(void *)*a1 + 312))(*a1, 1);
  }
  uint64_t result = a1[1];
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 312))(result, 1);
  }
  return result;
}

void sub_BF3C(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  if (v2)
  {
    if (*(void *)(a1 + 8))
    {
      *(_DWORD *)(a1 + 16) = sub_8918(v2);
      *(_DWORD *)(a1 + 20) = sub_8918(*(void *)(a1 + 8));
      float v3 = qword_A19B8;
      if (os_log_type_enabled((os_log_t)qword_A19B8, OS_LOG_TYPE_DEFAULT))
      {
        sub_C684(*(_DWORD *)(a1 + 16), v10);
        int v4 = v11;
        size_t v5 = (void **)v10[0];
        sub_C684(*(_DWORD *)(a1 + 20), __p);
        uint64_t v6 = v10;
        if (v4 < 0) {
          uint64_t v6 = v5;
        }
        if (v9 >= 0) {
          uint64_t v7 = __p;
        }
        else {
          uint64_t v7 = (void **)__p[0];
        }
        *(_DWORD *)buf = 136446466;
        int v13 = v6;
        __int16 v14 = 2082;
        long long v15 = v7;
        _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Wireless Splitter Codec Configuration User1 = %{public}s , User2 = %{public}s", buf, 0x16u);
        if (v9 < 0) {
          operator delete(__p[0]);
        }
        if (v11 < 0) {
          operator delete(v10[0]);
        }
      }
    }
  }
}

void sub_C074(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_C09C(void *a1)
{
  uint64_t v2 = qword_A19B8;
  if (os_log_type_enabled((os_log_t)qword_A19B8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Wireless Splitter stop all aggregates from BTAudioHALPlugin", v4, 2u);
  }
  if (*a1) {
    (*(void (**)(void, void))(*(void *)*a1 + 312))(*a1, 0);
  }
  uint64_t result = a1[1];
  if (result) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)result + 312))(result, 0);
  }
  return result;
}

void sub_C174(void *a1, uint64_t a2)
{
  int v4 = qword_A19B8;
  if (os_log_type_enabled((os_log_t)qword_A19B8, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 138543362;
    uint64_t v7 = sub_7904(a2);
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Wireless Splitter stop for Audio Device %{public}@", (uint8_t *)&v6, 0xCu);
  }
  sub_C09C(a1);
  if (*a1 == a2)
  {
    *a1 = 0;
  }
  else if (a1[1] == a2)
  {
    a1[1] = 0;
  }
  else
  {
    size_t v5 = qword_A19B8;
    if (os_log_type_enabled((os_log_t)qword_A19B8, OS_LOG_TYPE_ERROR)) {
      sub_62998(v5);
    }
  }
}

void sub_C274(float *a1)
{
  uint64_t v2 = *(float **)a1;
  if (v2)
  {
    uint64_t v3 = *((void *)a1 + 1);
    if (v3)
    {
      float v4 = a1[6];
      float v5 = v2[108];
      if (v5 <= *(float *)(v3 + 432)) {
        float v5 = *(float *)(v3 + 432);
      }
      a1[6] = v5;
      (*(void (**)(float *))(*(void *)v2 + 320))(v2);
      v6.n128_f32[0] = a1[6];
      (*(void (**)(__n128))(**((void **)a1 + 1) + 320))(v6);
      uint64_t v7 = qword_A19B8;
      if (os_log_type_enabled((os_log_t)qword_A19B8, OS_LOG_TYPE_DEFAULT))
      {
        double v8 = *(float *)(*(void *)a1 + 9064);
        double v9 = *(float *)(*((void *)a1 + 1) + 9064);
        int v10 = 134218240;
        double v11 = v8;
        __int16 v12 = 2048;
        double v13 = v9;
        _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Wireless Splitter aggregated scale factor user1=%f user2=%f", (uint8_t *)&v10, 0x16u);
      }
      if (v4 != a1[6]) {
        (*(void (**)(void))(**(void **)a1 + 336))(*(void *)a1);
      }
    }
  }
}

float *sub_C40C(float **a1, float a2)
{
  uint64_t result = *a1;
  if (result && a1[1])
  {
    sub_8604(result, a2);
    sub_8604(a1[1], a2);
    *((float *)a1 + 6) = a2;
    v5.n128_f32[0] = (*a1)[110];
    (*(void (**)(__n128))(*(void *)*a1 + 488))(v5);
    __n128 v6 = a1[1];
    v7.n128_f32[0] = v6[110];
    double v8 = *(uint64_t (**)(__n128))(*(void *)v6 + 488);
    return (float *)v8(v7);
  }
  return result;
}

CFArrayRef sub_C4F8(uint64_t *a1)
{
  if (!*a1) {
    return 0;
  }
  uint64_t v2 = a1[1];
  if (!v2) {
    return 0;
  }
  CFStringRef v3 = *(const __CFString **)(*(void *)(*a1 + 416) + 9080);
  CFStringRef v4 = *(const __CFString **)(*(void *)(v2 + 416) + 9080);
  CFRetain(v3);
  CFRetain(v4);
  int v5 = sub_9900(*a1);
  if (v5) {
    CFStringRef v6 = v4;
  }
  else {
    CFStringRef v6 = v3;
  }
  if (v5) {
    CFStringRef v7 = v3;
  }
  else {
    CFStringRef v7 = v4;
  }
  values[0] = (void *)v6;
  values[1] = (void *)v7;
  CFArrayRef v8 = CFArrayCreate(kCFAllocatorDefault, (const void **)values, 2, &kCFTypeArrayCallBacks);
  double v9 = qword_A19B8;
  if (os_log_type_enabled((os_log_t)qword_A19B8, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136315394;
    CStringPtr = CFStringGetCStringPtr(v3, 0x8000100u);
    __int16 v13 = 2080;
    __int16 v14 = CFStringGetCStringPtr(v4, 0x8000100u);
    _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "Wireless Splitter kBluetoothAudioDeviceWirelessSplitterAggregation called aggregating with %s and %s", (uint8_t *)&v11, 0x16u);
  }
  CFRelease(v3);
  CFRelease(v4);
  return v8;
}

BOOL sub_C660(void *a1, uint64_t a2)
{
  return *a1 == a2 || a1[1] == a2;
}

void *sub_C684@<X0>(int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 33022)
  {
    if (a1 == 33023)
    {
      uint64_t v2 = "AAC-ELD";
      goto LABEL_11;
    }
    if (a1 == 0xFFFF)
    {
      uint64_t v2 = "Undefined";
      goto LABEL_11;
    }
LABEL_8:
    uint64_t v2 = "Unknown";
    goto LABEL_11;
  }
  if (!a1)
  {
    uint64_t v2 = "SBC";
    goto LABEL_11;
  }
  if (a1 != 2) {
    goto LABEL_8;
  }
  uint64_t v2 = "AAC-LC";
LABEL_11:
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_BAF4(a2, v2);
}

uint64_t sub_C6FC(void *a1, int a2)
{
  CFStringRef v3 = a1;
  uint64_t v4 = *a1;
  if (v4 && (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4), result == a2))
  {
    CFStringRef v6 = (int *)(v3 + 2);
  }
  else
  {
    uint64_t result = v3[1];
    if (!result) {
      return result;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
    if (result != a2) {
      return result;
    }
    CFStringRef v6 = (int *)v3++ + 5;
  }
  uint64_t v7 = *v3;
  if (v7)
  {
    int v8 = *v6;
    if (v8 != 0xFFFF)
    {
      if (v8 == 33023)
      {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 744))(v7, 3);
        uint64_t v9 = 174;
      }
      else if (v8 == 2)
      {
        if (sub_5CAF8()) {
          uint64_t v9 = 192;
        }
        else {
          uint64_t v9 = 244;
        }
      }
      else
      {
        uint64_t v9 = 256;
      }
      int v10 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 880);
      return v10(v7, v9);
    }
  }
  return result;
}

os_log_t sub_C874()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A19B8 = (uint64_t)result;
  return result;
}

void sub_C8A4(uint64_t a1, int a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  v5[0] = *(_OWORD *)a3;
  v5[1] = v3;
  uint64_t v6 = *(void *)(a3 + 32);
  sub_48758(a1, a2, (uint64_t)v5);
  *(void *)uint64_t v4 = off_8D390;
  *(unsigned char *)(v4 + 152) = 1;
  *(void *)(v4 + 16) = 0;
}

void *sub_C900(void *a1)
{
  *a1 = off_8D390;
  uint64_t v2 = (OpaqueAudioConverter *)a1[2];
  if (v2)
  {
    AudioConverterDispose(v2);
  }
  else
  {
    long long v3 = qword_A19C0;
    if (os_log_type_enabled((os_log_t)qword_A19C0, OS_LOG_TYPE_ERROR)) {
      sub_629DC(v3);
    }
  }
  return sub_4879C(a1);
}

void sub_C980(void *a1)
{
  sub_C900(a1);

  operator delete();
}

void sub_C9B8(uint64_t a1, int a2)
{
  *(void *)(a1 + 24) = 0x40D7700000000000;
  uint64_t v2 = (const AudioStreamBasicDescription *)(a1 + 24);
  *(_DWORD *)(a1 + 116) = a2;
  *(_OWORD *)(a1 + 32) = xmmword_71030;
  *(_OWORD *)(a1 + 48) = xmmword_71040;
  UInt32 ioPropertyDataSize = 40;
  long long v3 = (const AudioStreamBasicDescription *)(a1 + 64);
  OSStatus Property = AudioFormatGetProperty(0x666D7469u, 0, 0, &ioPropertyDataSize, (void *)(a1 + 64));
  sub_1B8C0(Property, (uint64_t)"couldn't get output data format");
  OSStatus v5 = AudioConverterNew(v2, v3, (AudioConverterRef *)&v2[-1].mBitsPerChannel);
  sub_1B8C0(v5, (uint64_t)"Could not create new audio converter");
  v2[2].mBytesPerPacket = 1;
  operator new[]();
}

void sub_CAF8(uint64_t a1, unsigned __int8 *a2, BOOL a3, void *a4, unint64_t a5, void *a6)
{
  if (a3) {
    a3 = *a2 != 255;
  }
  sub_48844(a1, (uint64_t)a2, a3, a4, a5, a6);
}

uint64_t sub_CB10()
{
  return 0;
}

uint64_t sub_CB18()
{
  return 1;
}

uint64_t sub_CB20()
{
  return 0;
}

uint64_t sub_CB28()
{
  return 0;
}

uint64_t sub_CB30()
{
  return 0;
}

os_log_t sub_CB38()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A19C0 = (uint64_t)result;
  return result;
}

uint64_t sub_CB68(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = sub_3F94(a1, a3);
  *(void *)uint64_t v7 = off_8D400;
  *(_DWORD *)(v7 + 9212) = 0;
  *(void *)(v7 + 9080) = 0;
  *(void *)(v7 + 9096) = 0;
  *(void *)(v7 + 9088) = 0;
  sub_AD7C(v7, a2);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 1560))(a1, a4);
  sub_4258((unsigned char *)a1, a4);
  sub_D04C(a1, a4);
  *(_DWORD *)(a1 + 368) = 1953260897;
  if (sub_395B4()) {
    *(unsigned char *)(a1 + 9017) = 1;
  }
  *(unsigned char *)(a1 + 9016) = 1;
  atomic_store(1u, (unsigned __int8 *)(a1 + 288));
  *(_DWORD *)(a1 + 292) = 1;
  *(void *)(a1 + 296) = 0x40D7700000000000;
  *(void *)(a1 + 304) = 0xC6C70636DLL;
  int v8 = *(_DWORD *)(a1 + 9160);
  *(_DWORD *)(a1 + 312) = 2 * v8;
  *(_DWORD *)(a1 + 316) = 1;
  *(_DWORD *)(a1 + 320) = 2 * v8;
  *(_DWORD *)(a1 + 324) = v8;
  *(void *)(a1 + 328) = 16;
  *(_DWORD *)(a1 + 372) = 10240;
  *(void *)(a1 + 376) = 0xA00000002800;
  *(void *)(a1 + 88) = 0;
  *(void *)(a1 + 40) = sub_1F670() + *(unsigned int *)(a1 + 372);
  uint64_t v9 = (double *)(a1 + 296);
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1048))(a1))
  {
    *(void *)(a1 + 56) = sub_1F670() + *(unsigned int *)(a1 + 372);
    *(void *)(a1 + 72) = sub_1F670() + *(unsigned int *)(a1 + 372);
    long long v10 = *(_OWORD *)v9;
    *(_OWORD *)(a1 + 9184) = *(_OWORD *)(a1 + 312);
    *(_OWORD *)(a1 + 9168) = v10;
    *(void *)(a1 + 9200) = *(void *)(a1 + 328);
    *(_DWORD *)(a1 + 9184) = 2;
    *(void *)(a1 + 9192) = 0x100000002;
  }
  int v11 = *(_DWORD *)(a1 + 9108);
  if (v11 <= 59)
  {
    if (v11 == 40)
    {
      int v12 = 10;
      __int16 v13 = &unk_710EC;
      goto LABEL_18;
    }
    if (v11 == 56)
    {
      int v12 = 3;
      __int16 v13 = &unk_71114;
      goto LABEL_18;
    }
  }
  else
  {
    if (v11 == 60)
    {
      int v12 = 13;
      __int16 v13 = &unk_71120;
      goto LABEL_18;
    }
    if (v11 == 90 || v11 == 120)
    {
      int v12 = 4;
      __int16 v13 = &unk_71154;
      goto LABEL_18;
    }
  }
  __int16 v14 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
    sub_62A20(v11, v14);
  }
  __int16 v13 = 0;
  int v12 = 0;
LABEL_18:
  *(void *)(a1 + 9144) = v13;
  *(_DWORD *)(a1 + 9152) = v12;
  *(void *)(a1 + 9120) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9128) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9136) = CFArrayCreateMutable(0, 0, 0);
  if (*(void *)(a1 + 9144))
  {
    long long v15 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *(_DWORD *)(a1 + 9108);
      v20[0] = 67109120;
      v20[1] = v16;
      _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, "Using CodecPriorityTable%u", (uint8_t *)v20, 8u);
    }
    sub_D4F8(a1, *(CFArrayRef *)(a1 + 9112));
  }
  *(void *)(a1 + 384) = 10000;
  *(_DWORD *)(a1 + 396) = 0;
  *(unsigned char *)(a1 + 424) = sub_395B4();
  *(_DWORD *)(a1 + 432) = 1056964608;
  *(_DWORD *)(a1 + 448) = 0;
  *(void *)(a1 + 440) = 0xC2C80000C2480000;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1)) {
    operator new();
  }
  (*(void (**)(uint64_t, float))(*(void *)a1 + 488))(a1, *(float *)(a1 + 440));
  *(unsigned char *)(a1 + 460) = sub_395B4() ^ 1;
  *(unsigned char *)(a1 + 461) = 0;
  if (sub_395B4() || sub_395B4()) {
    int v17 = 1;
  }
  else {
    int v17 = -1;
  }
  *(_DWORD *)(a1 + 9104) = v17;
  uint64_t v18 = *(void *)(a1 + 216);
  if (v18) {
    sub_1E580(*(void *)(qword_A2350 + 328), *(_DWORD *)(v18 + 52), 3, *v9);
  }
  return a1;
}

void sub_D010(_Unwind_Exception *exception_object)
{
}

uint64_t sub_D04C(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyDirection");
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
  {
    OSStatus v5 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_62D68(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    if (sub_5CB00()) {
      goto LABEL_40;
    }
  }
  unint64_t v13 = xpc_int64_get_value(value);
  xpc_object_t v14 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyInputAudio");
  if (xpc_get_type(v14) != (xpc_type_t)&_xpc_type_BOOL)
  {
    long long v15 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_62CF0(v15, v16, v17, v18, v19, v20, v21, v22);
    }
    if (sub_5CB00()) {
      goto LABEL_40;
    }
  }
  *(unsigned char *)(a1 + 9208) = xpc_BOOL_get_value(v14);
  (*(void (**)(uint64_t, unint64_t))(*(void *)a1 + 1024))(a1, (v13 >> 1) & 1);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 1032))(a1, (*(unsigned char *)(a1 + 9208) != 0) & v13);
  __int16 v23 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 9208)) {
      __int16 v24 = "Yes";
    }
    else {
      __int16 v24 = "No";
    }
    int v25 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1040))(a1);
    int v26 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1048))(a1);
    v74[0] = 67109890;
    v74[1] = v13;
    __int16 v75 = 2082;
    v76 = v24;
    __int16 v77 = 1024;
    int v78 = v25;
    __int16 v79 = 1024;
    int v80 = v26;
    _os_log_impl(&dword_0, v23, OS_LOG_TYPE_DEFAULT, "LEA: Direction %x Stream state Input Audio = %{public}s output = %d input = %d", (uint8_t *)v74, 0x1Eu);
  }
  xpc_object_t v27 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyIsStereo");
  if (xpc_get_type(v27) != (xpc_type_t)&_xpc_type_BOOL)
  {
    uint64_t v28 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_62C78(v28, v29, v30, v31, v32, v33, v34, v35);
    }
    if (sub_5CB00()) {
      goto LABEL_40;
    }
  }
  int v36 = xpc_BOOL_get_value(v27) ? 2 : 1;
  *(_DWORD *)(a1 + 9160) = v36;
  xpc_object_t v37 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertySupportsAudioMixing");
  if (xpc_get_type(v37) != (xpc_type_t)&_xpc_type_BOOL)
  {
    int64_t v38 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_62C00(v38, v39, v40, v41, v42, v43, v44, v45);
    }
    if (sub_5CB00()) {
      goto LABEL_40;
    }
  }
  *(unsigned char *)(a1 + 9156) = xpc_BOOL_get_value(v37);
  xpc_object_t v46 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertySupportedCodecs");
  if (xpc_get_type(v46) != (xpc_type_t)&_xpc_type_array)
  {
    int64_t v47 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_62B88(v47, v48, v49, v50, v51, v52, v53, v54);
    }
    if (sub_5CB00()) {
      goto LABEL_40;
    }
  }
  *(void *)(a1 + 9112) = _CFXPCCreateCFObjectFromXPCObject();
  xpc_object_t v55 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyMaxPacketSize");
  if (xpc_get_type(v55) != (xpc_type_t)&_xpc_type_int64)
  {
    v56 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_62B10(v56, v57, v58, v59, v60, v61, v62, v63);
    }
    if (sub_5CB00()) {
      goto LABEL_40;
    }
  }
  *(_DWORD *)(a1 + 9108) = xpc_int64_get_value(v55);
  xpc_object_t v64 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyECNRIsEnabled");
  if (xpc_get_type(v64) != (xpc_type_t)&_xpc_type_BOOL)
  {
    v65 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_62A98(v65, v66, v67, v68, v69, v70, v71, v72);
    }
    if (sub_5CB00()) {
LABEL_40:
    }
      abort();
  }
  uint64_t result = xpc_BOOL_get_value(v64);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 416))(a1, 1);
  }
  return result;
}

void sub_D4F8(uint64_t a1, CFArrayRef theArray)
{
  if (CFArrayGetCount(theArray) > 0)
  {
    for (CFIndex i = 0; i < CFArrayGetCount(theArray); ++i)
    {
      int valuePtr = 0;
      long long v5 = *(_OWORD *)(a1 + 320);
      *(_OWORD *)uint64_t v52 = *(_OWORD *)(a1 + 304);
      *(_OWORD *)&v52[16] = v5;
      long long v6 = *(_OWORD *)(a1 + 9192);
      *(_OWORD *)std::string __p = *(_OWORD *)(a1 + 9176);
      long long v45 = v6;
      CFNumberRef ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(theArray, i);
      CFNumberGetValue(ValueAtIndex, kCFNumberSInt32Type, &valuePtr);
      uint64_t v8 = *(unsigned int *)(a1 + 9152);
      if (v8)
      {
        uint64_t v9 = *(int **)(a1 + 9144);
        while (1)
        {
          int v10 = *v9++;
          if (valuePtr == v10) {
            break;
          }
          if (!--v8) {
            goto LABEL_7;
          }
        }
        switch(valuePtr)
        {
          case 1:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
            int v13 = 64000;
            goto LABEL_99;
          case 2:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
            goto LABEL_68;
          case 3:
          case 17:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
            int v13 = 64000;
            goto LABEL_99;
          case 4:
          case 16:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
            goto LABEL_66;
          case 5:
            int v12 = *(_DWORD *)(a1 + 9108);
            switch(v12)
            {
              case '(':
                int v13 = 42666;
                goto LABEL_84;
              case '<':
                int v13 = 48000;
LABEL_84:
                if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
                  operator new();
                }
                goto LABEL_99;
              case '8':
                int v13 = 44800;
                goto LABEL_84;
            }
            if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
              sub_62E10(&v38, v39);
            }
LABEL_89:
            int v13 = 0;
LABEL_99:
            uint64_t v16 = qword_A19C8;
            if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
            {
              sub_F1B0(valuePtr, &buf);
              uint64_t v17 = (buf.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
                  ? &buf
                  : (std::string *)buf.__r_.__value_.__r.__words[0];
              *(_DWORD *)uint64_t v48 = 136315394;
              uint64_t v49 = v17;
              __int16 v50 = 1024;
              int v51 = v13;
              _os_log_impl(&dword_0, v16, OS_LOG_TYPE_DEFAULT, "Adding codec %s at bitrate %d", v48, 0x12u);
              if (SHIBYTE(buf.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(buf.__r_.__value_.__l.__data_);
              }
            }
            break;
          case 6:
            int v14 = *(_DWORD *)(a1 + 9108);
            if (v14 == 40)
            {
              int v13 = 64000;
LABEL_78:
              if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
                operator new();
              }
              goto LABEL_99;
            }
            if (v14 == 60)
            {
              int v13 = 96000;
              goto LABEL_78;
            }
            if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
              sub_62E10(&v42, v43);
            }
LABEL_97:
            int v13 = 0;
            goto LABEL_99;
          case 7:
            int v15 = *(_DWORD *)(a1 + 9108);
            switch(v15)
            {
              case '(':
                int v13 = 32000;
                goto LABEL_92;
              case '<':
                int v13 = 48000;
LABEL_92:
                if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
                  operator new();
                }
                goto LABEL_99;
              case '8':
                int v13 = 44800;
                goto LABEL_92;
            }
            if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
              sub_62E10(&v40, v41);
            }
            goto LABEL_97;
          case 9:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
            int v13 = 32000;
            goto LABEL_99;
          case 10:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
            int v13 = 42667;
            goto LABEL_99;
          case 11:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
LABEL_66:
            int v13 = 48000;
            goto LABEL_99;
          case 12:
          case 18:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
            int v13 = 64000;
            goto LABEL_99;
          case 13:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
LABEL_68:
            int v13 = 32000;
            goto LABEL_99;
          case 14:
            if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
              operator new();
            }
            if (((valuePtr - 14) & 0xFFFFFFFD) == 0) {
              operator new();
            }
            int v13 = 32000;
            goto LABEL_99;
          case 15:
            if (*(_DWORD *)(a1 + 9108) == 60)
            {
              if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
                operator new();
              }
              int v13 = 24000;
              goto LABEL_99;
            }
            if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
              sub_62E10(&v36, v37);
            }
            goto LABEL_89;
          default:
            if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
              sub_62DE0(&v34, v35);
            }
            int v13 = 0;
            goto LABEL_99;
        }
      }
      else
      {
LABEL_7:
        uint64_t v11 = qword_A19C8;
        if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf.__r_.__value_.__l.__data_) = 67109120;
          HIDWORD(buf.__r_.__value_.__r.__words[0]) = valuePtr;
          _os_log_error_impl(&dword_0, v11, OS_LOG_TYPE_ERROR, "Could not find codec %d matching codec priority table, skipping codec", (uint8_t *)&buf, 8u);
        }
      }
    }
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1) && *(_DWORD *)(a1 + 9152))
  {
    uint64_t v18 = 0;
    while (1)
    {
      uint64_t v19 = sub_F4B8(a1, *(_DWORD *)(*(void *)(a1 + 9144) + 4 * v18));
      if (v19) {
        break;
      }
      if (++v18 >= (unint64_t)*(unsigned int *)(a1 + 9152)) {
        goto LABEL_114;
      }
    }
    *(void *)(a1 + 216) = v19;
  }
LABEL_114:
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1048))(a1))
  {
    uint64_t v20 = 0;
    char v21 = 1;
    while (1)
    {
      char v22 = v21;
      uint64_t v23 = sub_F5FC(a1, dword_71164[v20]);
      if (v23) {
        break;
      }
      char v21 = 0;
      uint64_t v20 = 1;
      if ((v22 & 1) == 0) {
        goto LABEL_120;
      }
    }
    *(void *)(a1 + 224) = v23;
  }
LABEL_120:
  uint64_t v24 = *(void *)(a1 + 224);
  if (v24)
  {
    if (*(_DWORD *)(a1 + 9104) == 2)
    {
      uint64_t v25 = sub_F4B8(a1, *(_DWORD *)(v24 + 8));
      if (v25) {
        *(void *)(a1 + 216) = v25;
      }
    }
  }
  uint64_t v26 = *(void *)(a1 + 216);
  if (v26)
  {
    sub_1425C(*(id **)(a1 + 208), *(_DWORD *)(v26 + 52));
    uint64_t v27 = *(void *)(a1 + 216);
    uint64_t v28 = *(void *)(v27 + 96);
    long long v29 = *(_OWORD *)(v27 + 80);
    *(_OWORD *)(a1 + 296) = *(_OWORD *)(v27 + 64);
    *(_OWORD *)(a1 + 312) = v29;
    *(void *)(a1 + 328) = v28;
    uint64_t v30 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
    {
      sub_F1B0(*(_DWORD *)(v27 + 52), (std::string *)__p);
      if ((SBYTE7(v45) & 0x80u) == 0) {
        uint64_t v31 = __p;
      }
      else {
        uint64_t v31 = (void **)__p[0];
      }
      uint64_t v32 = *(void *)(a1 + 296);
      int v33 = *(_DWORD *)(a1 + 9104);
      *(_DWORD *)uint64_t v52 = 136315650;
      *(void *)&v52[4] = v31;
      *(_WORD *)&v52[12] = 2048;
      *(void *)&v52[14] = v32;
      *(_WORD *)&v52[22] = 1024;
      *(_DWORD *)&v52[24] = v33;
      _os_log_impl(&dword_0, v30, OS_LOG_TYPE_DEFAULT, "Update physical format based %s at bitrate %f mAudioContentType = %d", v52, 0x1Cu);
      if (SBYTE7(v45) < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_EBEC()
{
}

uint64_t sub_ED48(uint64_t a1)
{
  *(void *)a1 = off_8D400;
  if (sub_395B4()) {
    *(unsigned char *)(a1 + 9017) = 0;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 848))(a1))
  {
    uint64_t v2 = qword_A2350;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 832))(__p, a1);
    sub_41D30(v2, (uint64_t)__p);
    if (v7 < 0) {
      operator delete(__p[0]);
    }
  }
  CFRelease(*(CFTypeRef *)(a1 + 9112));
  sub_EF48(a1);
  sub_83B0(a1);
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1)
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1))
  {
    long long v3 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1);
    free(v3);
    (*(void (**)(uint64_t, void))(*(void *)a1 + 1656))(a1, 0);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  return sub_415C(a1, v4);
}

void sub_EF48(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9120));
  if (Count >= 1)
  {
    CFIndex v3 = Count;
    for (CFIndex i = 0; i != v3; ++i)
    {
      CFNumberRef ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9120), i);
      if (ValueAtIndex)
      {
        long long v6 = ValueAtIndex;
        uint64_t v7 = *ValueAtIndex;
        if (*ValueAtIndex)
        {
          uint64_t v8 = qword_A19C8;
          if (!os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG)
            || (*(_DWORD *)std::string buf = 134217984,
                uint64_t v12 = v7,
                _os_log_debug_impl(&dword_0, v8, OS_LOG_TYPE_DEBUG, "Deleting BTAudioEncoder 0x%p from mCodecList", buf, 0xCu), (uint64_t v7 = *v6) != 0))
          {
            (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
          }
          *long long v6 = 0;
        }
        uint64_t v9 = v6[1];
        if (v9)
        {
          int v10 = qword_A19C8;
          if (!os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG)
            || (*(_DWORD *)std::string buf = 134217984,
                uint64_t v12 = v9,
                _os_log_debug_impl(&dword_0, v10, OS_LOG_TYPE_DEBUG, "Deleting BTAudioDecoder 0x%p from mCodecList", buf, 0xCu), (uint64_t v9 = v6[1]) != 0))
          {
            (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
          }
        }
        free(v6);
      }
    }
  }
  if (*(void *)(a1 + 216)) {
    *(void *)(a1 + 216) = 0;
  }
  if (*(void *)(a1 + 224)) {
    *(void *)(a1 + 224) = 0;
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9120));
  CFRelease(*(CFTypeRef *)(a1 + 9120));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9128));
  CFRelease(*(CFTypeRef *)(a1 + 9128));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9136));
  CFRelease(*(CFTypeRef *)(a1 + 9136));
}

void sub_F168(uint64_t a1)
{
  sub_ED48(a1);

  operator delete();
}

BOOL sub_F1A0(uint64_t a1, int a2)
{
  return ((a2 - 14) & 0xFFFFFFFD) == 0;
}

std::string *sub_F1B0@<X0>(int a1@<W1>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  sub_BAF4(a2, "Unknown");
  if ((a1 - 1) >= 0x12) {
    uint64_t v4 = "Unknown Codec";
  }
  else {
    uint64_t v4 = off_8DAB0[a1 - 1];
  }
  return std::string::assign(a2, v4);
}

void sub_F218(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_F234(CFArrayRef *a1, uint64_t a2)
{
  if (a2)
  {
    CFIndex Count = CFArrayGetCount(a1[1140]);
    long long v5 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
    {
      long long v6 = "Yes";
      int v7 = *(_DWORD *)(a2 + 16);
      if (*(void *)a2) {
        uint64_t v8 = "Yes";
      }
      else {
        uint64_t v8 = "NO";
      }
      if (!*(void *)(a2 + 8)) {
        long long v6 = "NO";
      }
      int v17 = 134219010;
      uint64_t v18 = a2;
      __int16 v19 = 1024;
      *(_DWORD *)uint64_t v20 = v7;
      *(_WORD *)&v20[4] = 2048;
      *(void *)&v20[6] = Count;
      __int16 v21 = 2080;
      char v22 = v8;
      __int16 v23 = 2080;
      uint64_t v24 = v6;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Adding BTAudioEncoder %p type %d, to mCodecArray at index %ld Encode %s decode %s", (uint8_t *)&v17, 0x30u);
    }
    CFArrayInsertValueAtIndex(a1[1140], Count, (const void *)a2);
    CFIndex v9 = CFArrayGetCount(a1[1141]);
    if (!sub_F744(v9, a1[1141], *(double *)(a2 + 24)))
    {
      int v10 = qword_A19C8;
      if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a2 + 24);
        int v12 = *(_DWORD *)(a2 + 16);
        int v17 = 134218496;
        uint64_t v18 = v11;
        __int16 v19 = 2048;
        *(void *)uint64_t v20 = v9;
        *(_WORD *)&v20[8] = 1024;
        *(_DWORD *)&v20[10] = v12;
        _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Adding sampleRate %f to mSampleRateArray at index %ld via Codec %d ", (uint8_t *)&v17, 0x1Cu);
      }
      CFArrayInsertValueAtIndex(a1[1141], v9, (const void *)(a2 + 24));
    }
    if (*(void *)(a2 + 8))
    {
      CFIndex v13 = CFArrayGetCount(a1[1142]);
      if (!sub_F744(v13, a1[1142], *(double *)(a2 + 24)))
      {
        int v14 = qword_A19C8;
        if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v15 = *(void *)(a2 + 24);
          int v16 = *(_DWORD *)(a2 + 16);
          int v17 = 134218496;
          uint64_t v18 = v15;
          __int16 v19 = 2048;
          *(void *)uint64_t v20 = v13;
          *(_WORD *)&v20[8] = 1024;
          *(_DWORD *)&v20[10] = v16;
          _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "Adding sampleRate %f to mSampleRateInputArray at index %ld via Codec %d ", (uint8_t *)&v17, 0x1Cu);
        }
        CFArrayInsertValueAtIndex(a1[1142], v13, (const void *)(a2 + 24));
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR))
  {
    sub_62E40();
  }
}

uint64_t sub_F4B8(uint64_t a1, int a2)
{
  uint64_t v4 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG)) {
    sub_62E78(a2, v4);
  }
  if ((a2 - 1) > 0x11 || CFArrayGetCount(*(CFArrayRef *)(a1 + 9120)) < 1) {
    return 0;
  }
  CFIndex v5 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9120), v5);
    if (ValueAtIndex)
    {
      int v7 = ValueAtIndex;
      uint64_t v8 = *ValueAtIndex;
      if (*ValueAtIndex)
      {
        if (*(_DWORD *)(v8 + 52) == a2) {
          break;
        }
      }
    }
    if (++v5 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 9120))) {
      return 0;
    }
  }
  int v10 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG))
  {
    int v11 = 134217984;
    uint64_t v12 = v8;
    _os_log_debug_impl(&dword_0, v10, OS_LOG_TYPE_DEBUG, "GetEncoder returned encoder at addr %p", (uint8_t *)&v11, 0xCu);
    return *v7;
  }
  return v8;
}

uint64_t sub_F5FC(uint64_t a1, int a2)
{
  uint64_t v4 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG)) {
    sub_62EF0(a2, v4);
  }
  if ((a2 - 1) > 0x11 || CFArrayGetCount(*(CFArrayRef *)(a1 + 9120)) < 1) {
    return 0;
  }
  CFIndex v5 = 0;
  while (1)
  {
    CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9120), v5);
    if (ValueAtIndex)
    {
      int v7 = ValueAtIndex;
      uint64_t v8 = ValueAtIndex[1];
      if (v8)
      {
        if (*(_DWORD *)(v8 + 8) == a2) {
          break;
        }
      }
    }
    if (++v5 >= CFArrayGetCount(*(CFArrayRef *)(a1 + 9120))) {
      return 0;
    }
  }
  int v10 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG))
  {
    int v11 = 134217984;
    uint64_t v12 = v8;
    _os_log_debug_impl(&dword_0, v10, OS_LOG_TYPE_DEBUG, "GetDecoder returned decoder at addr %p", (uint8_t *)&v11, 0xCu);
    return v7[1];
  }
  return v8;
}

BOOL sub_F744(int a1, CFArrayRef theArray, double a3)
{
  if (!theArray) {
    return 0;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  CFIndex v6 = Count - 1;
  if (Count < 1) {
    return 0;
  }
  CFIndex v7 = 0;
  do
  {
    BOOL v9 = *(double *)CFArrayGetValueAtIndex(theArray, v7) == a3;
    BOOL result = v9;
    BOOL v9 = v9 || v6 == v7++;
  }
  while (!v9);
  return result;
}

uint64_t sub_F7C8(uint64_t a1, int a2, float *a3)
{
  float v6 = *(double *)(a1 + 296);
  *a3 = v6;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1048))(a1) && a2 == 2 && *(void *)(a1 + 224))
  {
    unsigned int v7 = 2;
    uint64_t v8 = dword_71164;
  }
  else
  {
    unsigned int v7 = *(_DWORD *)(a1 + 9152);
    if (!v7)
    {
      uint64_t v9 = 0;
LABEL_19:
      char v14 = 1;
LABEL_20:
      uint64_t v16 = 1;
      goto LABEL_21;
    }
    uint64_t v8 = *(int **)(a1 + 9144);
  }
  uint64_t v9 = 0;
  uint64_t v10 = v7;
  do
  {
    int v11 = *v8++;
    uint64_t v12 = sub_F4B8(a1, v11);
    if (!v12) {
      goto LABEL_14;
    }
    if (!v9)
    {
      double v13 = *(double *)(v12 + 64);
LABEL_13:
      float v6 = v13;
      uint64_t v9 = v12;
      goto LABEL_14;
    }
    double v13 = *(double *)(v12 + 64);
    if (v13 > v6) {
      goto LABEL_13;
    }
LABEL_14:
    --v10;
  }
  while (v10);
  if (!v9) {
    goto LABEL_19;
  }
  if (v9 != *(void *)(a1 + 216))
  {
    char v14 = 0;
    float v15 = *(double *)(v9 + 64);
    *a3 = v15;
    goto LABEL_20;
  }
  __int16 v21 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = *(_DWORD *)(v9 + 52);
    int v23 = 67109376;
    *(_DWORD *)uint64_t v24 = v22;
    *(_WORD *)&v24[4] = 1024;
    *(_DWORD *)&v24[6] = v22;
    _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, "Preferred encoded is same as current encoder = %d : %d", (uint8_t *)&v23, 0xEu);
  }
  char v14 = 0;
  uint64_t v16 = 0;
LABEL_21:
  int v17 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    double v18 = *a3;
    if (v14) {
      int v19 = 0;
    }
    else {
      int v19 = *(_DWORD *)(v9 + 52);
    }
    int v23 = 134218240;
    *(double *)uint64_t v24 = v18;
    *(_WORD *)&v24[8] = 1024;
    int v25 = v19;
    _os_log_impl(&dword_0, v17, OS_LOG_TYPE_DEFAULT, "New suggested sampling rate %f preferredEncoder = %d", (uint8_t *)&v23, 0x12u);
  }
  return v16;
}

id *sub_F9F0(uint64_t a1, unsigned int a2)
{
  float v8 = 0.0;
  sub_F7C8(a1, a2, &v8);
  uint64_t v4 = *(void *)(a1 + 216);
  if (v4 && *(double *)(v4 + 64) == v8)
  {
    *(_DWORD *)(a1 + 9104) = a2;
    (*(void (**)(uint64_t, double))(*(void *)a1 + 520))(a1, *(double *)(a1 + 296));
    CFIndex v5 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(*(void *)(a1 + 216) + 52);
      *(_DWORD *)std::string buf = 67109120;
      int v10 = v6;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Updating Content Type immediately as we are already using the requested codec: %d", buf, 8u);
    }
    BOOL result = *(id **)(a1 + 208);
    if (result)
    {
      sub_144B8(result, *(_DWORD *)(a1 + 9104));
      return 0;
    }
  }
  else
  {
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)a1 + 240))(a1, 1650549620, a2);
    return (id *)(&dword_0 + 1);
  }
  return result;
}

void sub_FB4C(uint64_t a1, int a2)
{
  uint64_t v4 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    float v5 = *(float *)(a1 + 9104);
    v8[0] = 1.5047e-36;
    v8[1] = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Update content type via config change, new content type =%d", (uint8_t *)v8, 8u);
  }
  v8[0] = 0.0;
  sub_F7C8(a1, a2, v8);
  *(_DWORD *)(a1 + 9104) = a2;
  v6.n128_f64[0] = v8[0];
  (*(void (**)(uint64_t, __n128))(*(void *)a1 + 520))(a1, v6);
  unsigned int v7 = *(id **)(a1 + 208);
  if (v7) {
    sub_144B8(v7, *(_DWORD *)(a1 + 9104));
  }
}

uint64_t sub_FC68(uint64_t a1, double a2)
{
  uint64_t v4 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    double v5 = *(double *)(a1 + 296);
    int v22 = 134218240;
    double v23 = v5;
    __int16 v24 = 2048;
    double v25 = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Updating sample rate %f -> %f", (uint8_t *)&v22, 0x16u);
  }
  if (*(void *)(a1 + 224) && (unsigned int v6 = *(_DWORD *)(a1 + 9104), v6 == 2))
  {
    unsigned int v7 = dword_71164;
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(a1 + 9152);
    if (!v6)
    {
LABEL_12:
      uint64_t v12 = 560227702;
      if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
        sub_62F68();
      }
      return v12;
    }
    unsigned int v7 = *(int **)(a1 + 9144);
  }
  uint64_t v8 = v6;
  while (1)
  {
    uint64_t v9 = sub_F4B8(a1, *v7);
    int v10 = *v7++;
    uint64_t v11 = sub_F5FC(a1, v10);
    if (v9)
    {
      if (*(double *)(v9 + 64) == a2) {
        break;
      }
    }
    if (!--v8) {
      goto LABEL_12;
    }
  }
  if (v9 == *(void *)(a1 + 216))
  {
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
      sub_62FA0();
    }
  }
  else
  {
    long long v13 = *(_OWORD *)(v9 + 64);
    long long v14 = *(_OWORD *)(v9 + 80);
    *(void *)(a1 + 328) = *(void *)(v9 + 96);
    *(_OWORD *)(a1 + 296) = v13;
    *(_OWORD *)(a1 + 312) = v14;
    *(void *)(a1 + 216) = v9;
    if (v11) {
      *(void *)(a1 + 224) = v11;
    }
    float v15 = *(id **)(a1 + 208);
    if (v15) {
      sub_1425C(v15, *(_DWORD *)(v9 + 52));
    }
  }
  *(double *)(a1 + 296) = a2;
  uint64_t v16 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v18 = *(void *)(a1 + 216);
    if (v18) {
      int v19 = *(_DWORD *)(v18 + 52);
    }
    else {
      int v19 = 255;
    }
    uint64_t v20 = *(void *)(a1 + 224);
    if (v20) {
      int v21 = *(_DWORD *)(v20 + 8);
    }
    else {
      int v21 = 255;
    }
    int v22 = 134218752;
    double v23 = a2;
    __int16 v24 = 2048;
    double v25 = a2;
    __int16 v26 = 1024;
    int v27 = v19;
    __int16 v28 = 1024;
    int v29 = v21;
    _os_log_error_impl(&dword_0, v16, OS_LOG_TYPE_ERROR, "Device sample rate changed for LEA %f -> %f [encoder = %d, decoder = %d]", (uint8_t *)&v22, 0x22u);
  }
  return 0;
}

void *sub_FEC4@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(result[52] + 9248);
  if (*(char *)(v2 + 31) < 0) {
    return sub_B9AC((unsigned char *)a2, *(void **)(v2 + 8), *(void *)(v2 + 16));
  }
  long long v3 = *(_OWORD *)(v2 + 8);
  *(void *)(a2 + 16) = *(void *)(v2 + 24);
  *(_OWORD *)a2 = v3;
  return result;
}

uint64_t sub_FEF4(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 277);
}

uint64_t sub_FF04(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 248))();
}

uint64_t sub_FF2C(uint64_t a1, char a2, float a3)
{
  *(float *)(a1 + 432) = a3;
  *(float *)(a1 + 440) = (float)((float)(a3 + -1.0) * 100.0) + 0.0;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG)) {
    sub_62FD8(a3);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1280))(a1);
  if (result)
  {
    if (!*(unsigned char *)(a1 + 408))
    {
      uint64_t v7 = *(void *)(a1 + 400);
      if (v7)
      {
        unsigned __int8 v8 = atomic_load((unsigned __int8 *)(v7 + 24));
        if (v8) {
          sub_181A4(*(void *)(a1 + 400), *(float *)(a1 + 440));
        }
      }
    }
    if ((a2 & 1) != 0 || (uint64_t result = sub_395B4(), result))
    {
      uint64_t v9 = 0x6F757470766F6C64;
      int v10 = 0;
      return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)a1 + 248))(a1, &v9);
    }
  }
  return result;
}

uint64_t sub_10060(uint64_t a1)
{
  return (*(double *)(a1 + 296)
                      * ((double)(*(_DWORD *)(a1 + 384) + *(_DWORD *)(a1 + 388))
                       / 1000000.0));
}

void sub_1008C(uint64_t a1, float a2)
{
  *(float *)(a1 + 440) = a2;
  *(float *)(a1 + 432) = (float)((float)(0.0 - a2) / -100.0) + 1.0;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG)) {
    sub_6305C(a2);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1))
  {
    if (*(unsigned char *)(a1 + 408))
    {
      uint64_t v4 = *(id **)(a1 + 208);
      if (v4) {
        sub_146B4(v4, *(float *)(a1 + 432));
      }
    }
    else
    {
      uint64_t v5 = *(void *)(a1 + 400);
      if (v5)
      {
        unsigned __int8 v6 = atomic_load((unsigned __int8 *)(v5 + 24));
        if (v6) {
          sub_181A4(*(void *)(a1 + 400), *(float *)(a1 + 440));
        }
      }
    }
  }
}

uint64_t sub_10178(_DWORD *a1, int a2)
{
  uint64_t v4 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "disabled";
    if (a2) {
      uint64_t v5 = "enabled";
    }
    unsigned __int8 v6 = "enable";
    if (a2) {
      unsigned __int8 v6 = "disable";
    }
    v8[0] = 136446466;
    *(void *)&v8[1] = v5;
    __int16 v9 = 2082;
    int v10 = v6;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BT LEA device set ecnr is %{public}s. AG will %{public}s EC/NR.", (uint8_t *)v8, 0x16u);
  }
  a1[2303] = a2;
  strcpy((char *)v8, "rncebolg");
  BYTE1(v8[2]) = 0;
  HIWORD(v8[2]) = 0;
  return (*(uint64_t (**)(_DWORD *, _DWORD *))(*(void *)a1 + 248))(a1, v8);
}

uint64_t sub_1029C(uint64_t result, uint64_t a2)
{
  if (*(unsigned __int8 *)(result + 9208) != a2)
  {
    *(unsigned char *)(result + 9208) = a2;
    uint64_t v3 = *(void *)(result + 416);
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)result + 1040))(result);
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 1240);
    return v5(v3, a2, v4);
  }
  return result;
}

uint64_t sub_10360(CFTypeRef *a1, const __CFArray *a2)
{
  uint64_t v4 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned __int8 v6 = 0;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "LEA: Setting Supported Codecs", v6, 2u);
  }
  CFRelease(a1[1139]);
  a1[1139] = CFArrayCreateCopy(kCFAllocatorDefault, a2);
  return (*((uint64_t (**)(CFTypeRef *, uint64_t, const __CFArray *))*a1 + 30))(a1, 1885762657, a2);
}

uint64_t sub_10428(uint64_t a1)
{
  sub_EF48(a1);
  sub_83B0(a1);
  *(void *)(a1 + 9120) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9128) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9136) = CFArrayCreateMutable(0, 0, 0);
  sub_D4F8(a1, *(CFArrayRef *)(a1 + 9112));
  float v5 = 0.0;
  sub_F7C8(a1, *(_DWORD *)(a1 + 9104), &v5);
  v2.n128_f64[0] = v5;
  uint64_t v3 = *(uint64_t (**)(uint64_t, __n128))(*(void *)a1 + 520);

  return v3(a1, v2);
}

void sub_10508(uint64_t a1, int a2, int a3)
{
  unsigned __int8 v6 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      uint64_t v7 = "Yes";
    }
    else {
      uint64_t v7 = "No";
    }
    uint64_t v8 = *(void *)(a1 + 224);
    if (v8) {
      int v9 = *(_DWORD *)(v8 + 8);
    }
    else {
      int v9 = 255;
    }
    if (a3) {
      int v10 = "Yes";
    }
    else {
      int v10 = "No";
    }
    uint64_t v11 = *(void *)(a1 + 216);
    if (v11) {
      int v12 = *(_DWORD *)(v11 + 52);
    }
    else {
      int v12 = 255;
    }
    int v26 = 136446978;
    int v27 = v7;
    __int16 v28 = 1024;
    int v29 = v9;
    __int16 v30 = 2082;
    uint64_t v31 = v10;
    __int16 v32 = 1024;
    int v33 = v12;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "LEA: Updating Codecs Input = %{public}s Decoder = %d , Output = %{public}s Encoder = %d", (uint8_t *)&v26, 0x22u);
  }
  if (a3 && !*(void *)(a1 + 216) && *(_DWORD *)(a1 + 9152))
  {
    uint64_t v21 = 0;
    while (1)
    {
      uint64_t v22 = sub_F4B8(a1, *(_DWORD *)(*(void *)(a1 + 9144) + 4 * v21));
      if (v22) {
        break;
      }
      if (++v21 >= (unint64_t)*(unsigned int *)(a1 + 9152)) {
        goto LABEL_17;
      }
    }
    *(void *)(a1 + 216) = v22;
  }
LABEL_17:
  if (a2)
  {
    uint64_t v13 = *(void *)(a1 + 224);
    if (v13) {
      goto LABEL_25;
    }
    char v14 = 1;
    while (1)
    {
      char v15 = v14;
      uint64_t v16 = sub_F5FC(a1, dword_71164[v13]);
      if (v16) {
        break;
      }
      char v14 = 0;
      uint64_t v13 = 1;
      if ((v15 & 1) == 0) {
        goto LABEL_25;
      }
    }
  }
  else
  {
    uint64_t v16 = 0;
  }
  *(void *)(a1 + 224) = v16;
LABEL_25:
  int v17 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      uint64_t v18 = "Yes";
    }
    else {
      uint64_t v18 = "No";
    }
    uint64_t v19 = *(void *)(a1 + 224);
    if (v19) {
      int v20 = *(_DWORD *)(v19 + 8);
    }
    else {
      int v20 = 255;
    }
    if (a3) {
      double v23 = "Yes";
    }
    else {
      double v23 = "No";
    }
    uint64_t v24 = *(void *)(a1 + 216);
    if (v24) {
      int v25 = *(_DWORD *)(v24 + 52);
    }
    else {
      int v25 = 255;
    }
    int v26 = 136446978;
    int v27 = v18;
    __int16 v28 = 1024;
    int v29 = v20;
    __int16 v30 = 2082;
    uint64_t v31 = v23;
    __int16 v32 = 1024;
    int v33 = v25;
    _os_log_impl(&dword_0, v17, OS_LOG_TYPE_DEFAULT, "LEA: Codec Update completed Input = %{public}s Decoder = %d , Output = %{public}s Encoder = %d", (uint8_t *)&v26, 0x22u);
  }
}

uint64_t sub_10760(unsigned char *a1, int *a2)
{
  int v4 = *a2;
  uint64_t result = 1;
  if (*a2 <= 1701015153)
  {
    if (v4 == 1650549620 || v4 == 1651728749) {
      return result;
    }
    if (v4 == 1684234612)
    {
      if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEBUG)) {
        sub_630E0();
      }
      return 1;
    }
    goto LABEL_24;
  }
  if (v4 == 1701015154) {
    return result;
  }
  if (v4 != 1870098020 && v4 != 1937009955)
  {
LABEL_24:
    return sub_949C();
  }
  if (((*(unsigned int (**)(unsigned char *))(*(void *)a1 + 1048))(a1) && a1[9208] || a2[1] != 1768845428)
    && ((char v7 = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 1040))(a1), v8 = a2[1], (v7 & 1) != 0)
     || v8 != 1869968496)
    && (v8 == 1735159650 || v8 == 1869968496 || v8 == 1768845428))
  {
    return a2[2] == 0;
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10928(uint64_t a1, int *a2, unsigned char *a3)
{
  int v4 = *a2;
  if (*a2 <= 1684234611)
  {
    if (v4 == 1650549620)
    {
      *a3 = 1;
      return 0;
    }
    if (v4 != 1651728749) {
      goto LABEL_10;
    }
LABEL_9:
    *a3 = 0;
    return 0;
  }
  if (v4 == 1701015154) {
    goto LABEL_9;
  }
  if (v4 == 1684234612)
  {
    float v5 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)char v7 = 0;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "kBluetoothAudioDeviceCategory", v7, 2u);
    }
    goto LABEL_9;
  }
LABEL_10:

  return sub_94A4();
}

uint64_t sub_10A20(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int *a5)
{
  int v6 = *a2;
  if (*a2 > 1668641651)
  {
    if (v6 != 1701015154 && v6 != 1684234612)
    {
      if (v6 == 1668641652)
      {
        uint64_t result = sub_94AC();
        *a5 += 48;
        return result;
      }
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if (v6 == 1650549620)
  {
LABEL_9:
    int v8 = 4;
    goto LABEL_10;
  }
  if (v6 == 1651728749)
  {
    int v8 = 1;
LABEL_10:
    *a5 = v8;
    return 0;
  }
LABEL_11:

  return sub_94AC();
}

uint64_t sub_10AF0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 240))();
}

uint64_t sub_10B18(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int *a7, double *a8)
{
  int v12 = *a2;
  if (*a2 > 1684234611)
  {
    switch(v12)
    {
      case 1684234612:
        uint64_t result = 0;
        int v22 = *(_DWORD *)(a1 + 9216);
        break;
      case 1701015154:
        uint64_t result = 0;
        int v22 = *(_DWORD *)(a1 + 9212);
        break;
      case 1853059619:
        if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9128)))
        {
          double v18 = *(double *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9128), 0);
          if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9128)) < 2)
          {
            double v20 = v18;
          }
          else
          {
            CFIndex v19 = 1;
            double v20 = v18;
            do
            {
              CFNumberRef ValueAtIndex = (double *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9128), v19);
              if (*ValueAtIndex < v20) {
                double v20 = *ValueAtIndex;
              }
              if (*ValueAtIndex > v18) {
                double v18 = *ValueAtIndex;
              }
              ++v19;
            }
            while (v19 < CFArrayGetCount(*(CFArrayRef *)(a1 + 9128)));
          }
        }
        else
        {
          double v20 = 8000.0;
          double v18 = 8000.0;
        }
        uint64_t result = 0;
        *a8 = v20;
        a8[1] = v18;
        int v17 = 16;
LABEL_36:
        *a7 = v17;
        return result;
      default:
        goto LABEL_30;
    }
LABEL_29:
    *(_DWORD *)a8 = v22;
    int v17 = 4;
    goto LABEL_36;
  }
  switch(v12)
  {
    case 1650549620:
      uint64_t result = 0;
      int v22 = *(_DWORD *)(a1 + 9104);
      goto LABEL_29;
    case 1651728749:
      uint64_t result = 0;
      *(unsigned char *)a8 = *(unsigned char *)(a1 + 9156);
      int v17 = 1;
      goto LABEL_36;
    case 1668641652:
      uint64_t result = sub_94B4();
      if (result) {
        return result;
      }
      uint64_t v14 = *a7;
      unsigned int v15 = (a6 - (int)v14) / 0xCu;
      if (v15 >= 2) {
        unsigned int v15 = 2;
      }
      if (v15)
      {
        uint64_t v16 = (char *)a8 + v14;
        *(void *)uint64_t v16 = 0x7261777764636174;
        *((_DWORD *)v16 + 2) = 0;
        if (v15 != 1)
        {
          strcpy(v16 + 12, "tcabwwar");
          v16[21] = 0;
          *((_WORD *)v16 + 11) = 0;
        }
        LODWORD(v14) = *a7;
      }
      uint64_t result = 0;
      int v17 = v14 + 12 * v15;
      goto LABEL_36;
  }
LABEL_30:

  return sub_94B4();
}

uint64_t sub_10D60(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, int a5, unsigned int *a6)
{
  uint64_t v6 = 561211770;
  if (!a6) {
    return v6;
  }
  if (*a2 == 1853059700)
  {
    if (a5 != 8)
    {
      if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_ERROR)) {
        sub_63120();
      }
      return v6;
    }
    double v8 = *(double *)(a1 + 296);
    double v9 = *(double *)a6;
    int v10 = qword_A19C8;
    BOOL v11 = os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT);
    if (v11)
    {
      int v17 = 67109376;
      unsigned int v18 = v8;
      __int16 v19 = 1024;
      unsigned int v20 = v9;
      _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "setPropertyData: sample rate (%d->%d)\n", (uint8_t *)&v17, 0xEu);
    }
    if (v9 != v8)
    {
      if (*(void *)(a1 + 224) && *(_DWORD *)(a1 + 9104) == 2) {
        uint64_t v12 = 9136;
      }
      else {
        uint64_t v12 = 9128;
      }
      BOOL v14 = sub_F744(v11, *(CFArrayRef *)(a1 + v12), v9);
      unsigned int v15 = qword_A19C8;
      BOOL v16 = os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT);
      if (!v14)
      {
        uint64_t v6 = 560226676;
        if (v16)
        {
          int v17 = 67109376;
          unsigned int v18 = v8;
          __int16 v19 = 1024;
          unsigned int v20 = v9;
          _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, "setPropertyData unsupported: sample rate (%d->%d)\n", (uint8_t *)&v17, 0xEu);
        }
        return v6;
      }
      if (v16)
      {
        int v17 = 67109376;
        unsigned int v18 = v8;
        __int16 v19 = 1024;
        unsigned int v20 = v9;
        _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, "Request device configuration change: sample rate (%d->%d)\n", (uint8_t *)&v17, 0xEu);
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059700, (uint64_t)v9);
    }
    return 0;
  }
  if (*a2 == 1650549620)
  {
    if (*a6 != *(_DWORD *)(a1 + 9104)) {
      sub_F9F0(a1, *a6);
    }
    return 0;
  }

  return sub_94BC();
}

uint64_t sub_11018()
{
  double v0 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
    sub_6279C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t result = sub_5CB00();
  if (result) {
    abort();
  }
  return result;
}

uint64_t sub_11064()
{
  double v0 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
    sub_6279C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t result = sub_5CB00();
  if (result) {
    abort();
  }
  return result;
}

uint64_t sub_110B0()
{
  double v0 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
    sub_6279C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t result = sub_5CB00();
  if (result) {
    abort();
  }
  return result;
}

void sub_110FC()
{
  double v0 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_log_impl(&dword_0, v0, OS_LOG_TYPE_DEFAULT, "LEA NotifyPostProfileUpdateProperty", v1, 2u);
  }
}

uint64_t sub_11160()
{
  double v0 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
    sub_6279C(v0, v1, v2, v3, v4, v5, v6, v7);
  }
  uint64_t result = sub_5CB00();
  if (result) {
    abort();
  }
  return result;
}

double sub_111AC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 224);
  if (v1) {
    return *(double *)(v1 + 64);
  }
  else {
    return 0.0;
  }
}

__n128 sub_111C4@<Q0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2) {
    uint64_t v3 = *(void *)(a1 + 224);
  }
  else {
    uint64_t v3 = *(void *)(a1 + 216);
  }
  __n128 result = *(__n128 *)(v3 + 64);
  long long v5 = *(_OWORD *)(v3 + 80);
  *(__n128 *)a3 = result;
  *(_OWORD *)(a3 + 16) = v5;
  *(void *)(a3 + 32) = *(void *)(v3 + 96);
  return result;
}

void sub_111E8(uint64_t a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, "kBTAudioMsgPropertyDeviceUID");
  if (!string)
  {
    uint64_t v4 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_63158(v4, v5, v6, v7, v8, v9, v10, v11);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  CFStringRef v12 = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
  *(void *)(a1 + 200) = v12;
  uint64_t v13 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v15 = 138412546;
    CFStringRef v16 = v12;
    __int16 v17 = 1024;
    int v18 = v14;
    _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "LEA Device XPC connection for UID %@ connected to[ %d ] ", (uint8_t *)&v15, 0x12u);
    CFStringRef v12 = *(CFStringRef *)(a1 + 200);
  }
  **(void **)(a1 + 208) = v12;
}

CFIndex sub_1133C(uint64_t a1, uint64_t a2, CFIndex Count, int a4)
{
  if (a4)
  {
    uint64_t v7 = *(void *)(a1 + 224);
    *(_OWORD *)int v18 = *(_OWORD *)(v7 + 64);
    *(_OWORD *)&v18[16] = *(_OWORD *)(v7 + 80);
    *(void *)&v18[32] = *(void *)(v7 + 96);
    long long v20 = *(_OWORD *)&v18[8];
    long long v21 = *(_OWORD *)&v18[24];
LABEL_3:
    uint64_t v8 = 9136;
    goto LABEL_8;
  }
  uint64_t v9 = *(void *)(a1 + 216);
  *(_OWORD *)__int16 v19 = *(_OWORD *)(v9 + 64);
  *(_OWORD *)&v19[16] = *(_OWORD *)(v9 + 80);
  *(void *)&v19[32] = *(void *)(v9 + 96);
  long long v20 = *(_OWORD *)&v19[8];
  long long v21 = *(_OWORD *)&v19[24];
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1048))(a1)
    && *(void *)(a1 + 224)
    && *(_DWORD *)(a1 + 9104) == 2)
  {
    goto LABEL_3;
  }
  uint64_t v8 = 9128;
LABEL_8:
  CFArrayRef v10 = *(const __CFArray **)(a1 + v8);
  if (CFArrayGetCount(v10) < Count) {
    CFIndex Count = CFArrayGetCount(v10);
  }
  if (CFArrayGetCount(v10) >= 1)
  {
    CFIndex v11 = 0;
    unsigned int v12 = 1;
    do
    {
      CFNumberRef ValueAtIndex = (uint64_t *)CFArrayGetValueAtIndex(v10, v11);
      uint64_t v14 = *ValueAtIndex;
      CFIndex v15 = a2 + 56 * v11;
      *(void *)CFIndex v15 = *ValueAtIndex;
      *(_OWORD *)(v15 + 24) = v21;
      *(_OWORD *)(v15 + 8) = v20;
      *(int64x2_t *)(v15 + 40) = vdupq_lane_s64(v14, 0);
      CFIndex v11 = v12;
    }
    while (CFArrayGetCount(v10) > v12++);
  }
  return Count;
}

uint64_t sub_114A8(uint64_t a1, double *a2, uint64_t a3)
{
  if (a3 != 1)
  {
    uint64_t v6 = qword_A19C8;
    if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_FAULT)) {
      sub_631D0(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9128)))
  {
    double v14 = *(double *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9128), 0);
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9128)) < 2)
    {
      double v16 = v14;
    }
    else
    {
      CFIndex v15 = 1;
      double v16 = v14;
      do
      {
        CFNumberRef ValueAtIndex = (double *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9128), v15);
        if (*ValueAtIndex < v16) {
          double v16 = *ValueAtIndex;
        }
        if (*ValueAtIndex > v14) {
          double v14 = *ValueAtIndex;
        }
        ++v15;
      }
      while (v15 < CFArrayGetCount(*(CFArrayRef *)(a1 + 9128)));
    }
  }
  else
  {
    double v16 = 8000.0;
    double v14 = 8000.0;
  }
  int v18 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = 134218240;
    double v21 = v16;
    __int16 v22 = 2048;
    double v23 = v14;
    _os_log_impl(&dword_0, v18, OS_LOG_TYPE_DEFAULT, "LEA: UpdateSamplingRate minRate %f, maxRate %f", (uint8_t *)&v20, 0x16u);
  }
  *a2 = v16;
  a2[1] = v14;
  return a3;
}

uint64_t sub_11630(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 1240))();
}

uint64_t sub_11660(uint64_t a1, uint64_t a2, uint64_t a3)
{
  (*(void (**)(uint64_t))(*(void *)a1 + 1032))(a1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1024))(a1, a3);
  uint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 1480);

  return v6(a1, a2, a3);
}

CFIndex sub_1174C(uint64_t a1, int a2)
{
  if (a2
    || (*(unsigned int (**)(uint64_t))(*(void *)a1 + 1048))(a1)
    && *(void *)(a1 + 224)
    && *(_DWORD *)(a1 + 9104) == 2)
  {
    uint64_t v3 = 9136;
  }
  else
  {
    uint64_t v3 = 9128;
  }
  return CFArrayGetCount(*(CFArrayRef *)(a1 + v3));
}

uint64_t sub_117D0()
{
  return 1;
}

BOOL sub_117D8(uint64_t a1, char a2, double a3, double a4)
{
  if (a4 == a3)
  {
    BOOL v7 = 0;
  }
  else
  {
    if ((a2 & 1) != 0 || *(void *)(a1 + 224) && *(_DWORD *)(a1 + 9104) == 2) {
      uint64_t v6 = 9136;
    }
    else {
      uint64_t v6 = 9128;
    }
    BOOL v7 = sub_F744(a1, *(CFArrayRef *)(a1 + v6), a4);
  }
  uint64_t v8 = qword_A19C8;
  if (os_log_type_enabled((os_log_t)qword_A19C8, OS_LOG_TYPE_DEFAULT))
  {
    v10[0] = 67109632;
    v10[1] = a3;
    __int16 v11 = 1024;
    unsigned int v12 = a4;
    __int16 v13 = 1024;
    BOOL v14 = v7;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "FormatChangeSupported: sample rate (%d->%d) Supported = %d\n", (uint8_t *)v10, 0x14u);
  }
  return v7;
}

uint64_t sub_118EC(unsigned char *a1, int a2, int a3)
{
  if (!(*(unsigned int (**)(unsigned char *))(*(void *)a1 + 1048))(a1))
  {
    if (a2 != 1768845428) {
      goto LABEL_6;
    }
    return 0;
  }
  if (a2 == 1768845428 && !a1[9208]) {
    return 0;
  }
LABEL_6:
  uint64_t result = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 1040))(a1);
  if (a2 != 1869968496 || result)
  {
    if (a2 == 1735159650 || a2 == 1869968496 || a2 == 1768845428) {
      return a3 == 0;
    }
    return 0;
  }
  return result;
}

uint64_t sub_119F4()
{
  return 0;
}

uint64_t sub_119FC()
{
  return 0;
}

uint64_t sub_11A04(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9216) = a2;
  return result;
}

double sub_11A0C(uint64_t a1)
{
  return *(double *)(a1 + 296);
}

uint64_t sub_11A14(uint64_t a1)
{
  return *(unsigned int *)(a1 + 376);
}

uint64_t sub_11A1C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 9216);
}

uint64_t sub_11A24()
{
  return 0;
}

uint64_t sub_11A2C()
{
  return 0;
}

uint64_t sub_11A34(uint64_t result, char a2)
{
  *(unsigned char *)(result + 409) = a2;
  return result;
}

uint64_t sub_11A3C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 410) = a2;
  return result;
}

BOOL sub_11A44(uint64_t a1)
{
  return *(unsigned char *)(a1 + 409) != 0;
}

BOOL sub_11A54(uint64_t a1)
{
  return *(unsigned char *)(a1 + 410) != 0;
}

uint64_t sub_11A64()
{
  return 0;
}

uint64_t sub_11A6C()
{
  return 1;
}

uint64_t sub_11A74()
{
  return 0;
}

uint64_t sub_11A7C()
{
  return 0;
}

uint64_t sub_11A84(uint64_t a1)
{
  return *(unsigned int *)(a1 + 9104);
}

uint64_t sub_11A94(uint64_t a1)
{
  return *(void *)(a1 + 9080);
}

uint64_t sub_11A9C(uint64_t a1)
{
  return *(void *)(a1 + 9088);
}

uint64_t sub_11AA4(uint64_t a1)
{
  return *(void *)(a1 + 9096);
}

uint64_t sub_11AAC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9088) = a2;
  return result;
}

uint64_t sub_11AB4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9096) = a2;
  return result;
}

uint64_t sub_11ABC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9080) = a2;
  return result;
}

unsigned char *sub_11AC4(unsigned char *result, unsigned char *a2)
{
  *uint64_t result = 0;
  *a2 = 0;
  return result;
}

void sub_11AD4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

double sub_11AEC(float a1)
{
  return a1;
}

os_log_t sub_11B08()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A19C8 = (uint64_t)result;
  return result;
}

uint64_t sub_11B38(uint64_t a1, uint64_t a2, int a3)
{
  *(void *)sub_306F0(a1) = &off_8DB50;
  uint64_t v6 = qword_A19D0;
  if (os_log_type_enabled((os_log_t)qword_A19D0, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = sub_308A8(a1);
    uint64_t v8 = "output";
    if (a3) {
      uint64_t v8 = "input";
    }
    int v10 = 136446466;
    __int16 v11 = v8;
    __int16 v12 = 1024;
    int v13 = v7;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Creating %{public}s audio stream with audioObjectID: %u", (uint8_t *)&v10, 0x12u);
  }
  *(void *)(a1 + 16) = a2;
  *(unsigned char *)(a1 + 13) = a3;
  return a1;
}

void sub_11C40(_Unwind_Exception *a1)
{
  sub_307F8(v1);
  _Unwind_Resume(a1);
}

void sub_11C60(uint64_t a1)
{
  sub_307F8(a1);

  operator delete();
}

uint64_t sub_11C98(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 13);
}

uint64_t sub_11CA0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 80))(*(void *)(a1 + 16), a1, a2);
}

uint64_t sub_11CD0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 88))(*(void *)(a1 + 16), a1, a2, a3);
}

uint64_t sub_11D04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 96))(*(void *)(a1 + 16), a1, a2, a3, a4, a5);
}

uint64_t sub_11D40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 104))(*(void *)(a1 + 16), a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_11DA8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 16) + 112))(*(void *)(a1 + 16), a1, a2, a3, a4, a5, a6, a7);
}

os_log_t sub_11DEC()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A19D0 = (uint64_t)result;
  return result;
}

uint64_t sub_12984(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

void sub_1298C(uint64_t a1)
{
  uint64_t v1 = sub_44C8C(qword_A2350, *(_DWORD *)(*(void *)(a1 + 32) + 24));
  if (v1)
  {
    uint64_t v2 = *(void (**)(void))(*v1 + 1128);
    v2();
  }
  else
  {
    uint64_t v3 = qword_A19D8;
    if (os_log_type_enabled((os_log_t)qword_A19D8, OS_LOG_TYPE_ERROR)) {
      sub_632C0(v3);
    }
  }
}

BTAudioAVNotificationMonitor *sub_12B04(uint64_t a1)
{
  _Block_release(*(const void **)(*(void *)(a1 + 32) + 16));
  *(void *)(*(void *)(a1 + 32) + 16) = 0;
  uint64_t v2 = qword_A19D8;
  if (os_log_type_enabled((os_log_t)qword_A19D8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice::startManualVolumeUpdateTimer: reached the time limit", v6, 2u);
  }
  os_log_t result = +[BTAudioAVNotificationMonitor sharedInstance];
  if (result)
  {
    uint64_t v4 = result;
    id v5 = *(id *)(*(void *)(a1 + 32) + 32);
    os_log_t result = [(BTAudioAVNotificationMonitor *)v4 getPersonalizedVolumeDevice:*(void *)(*(void *)(a1 + 32) + 32)];
    if (result) {
      *(unsigned char *)(*(void *)(a1 + 32) + 8) = 1;
    }
  }
  return result;
}

os_log_t sub_12C04()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A19D8 = (uint64_t)result;
  return result;
}

double sub_12C34(uint64_t a1, int a2, long long *a3)
{
  *(void *)a1 = off_8DC30;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 168) = 0;
  *(_WORD *)(a1 + 177) = 0;
  *(_DWORD *)(a1 + 52) = a2;
  long long v3 = *a3;
  long long v4 = a3[1];
  *(void *)(a1 + 96) = *((void *)a3 + 4);
  *(_OWORD *)(a1 + 64) = v3;
  *(_OWORD *)(a1 + 80) = v4;
  double result = 0.0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 33) = 0u;
  return result;
}

void *sub_12C84(void *a1)
{
  *a1 = off_8DC30;
  uint64_t v2 = a1[18];
  a1[18] = 0;
  if (v2) {
    operator delete[]();
  }
  uint64_t v3 = a1[21];
  a1[21] = 0;
  if (v3) {
    operator delete[]();
  }
  uint64_t v4 = a1[18];
  a1[18] = 0;
  if (v4) {
    operator delete[]();
  }
  return a1;
}

uint64_t sub_12D2C(uint64_t a1, int a2, unsigned char *a3, int a4, int a5)
{
  if (a4)
  {
    unint64_t v5 = 0;
    uint64_t v6 = a4;
    char v7 = ~(-1 << a2);
    char v8 = 8 - a2;
    uint64_t v9 = a3;
    do
    {
      unint64_t v10 = v5 / a2;
      if (a5)
      {
        unsigned int v11 = (a3[v10] & v7);
        LOBYTE(v12) = a3[v10] & v7;
      }
      else
      {
        int v12 = a3[v10] >> v8;
        unsigned int v11 = a3[v10 + 1] >> v8;
      }
      *v9++ = (v11 >> (a2 - 8 + a2 + v10 * a2 - v5)) | ((_BYTE)v12 << (8 - (a2 + v10 * a2 - v5)));
      v5 += 8;
      --v6;
    }
    while (v6);
  }
  return (uint64_t)(a4 * a2 + (a4 * a2 < 0 ? 7 : 0)) >> 3;
}

uint64_t sub_12DD0(int a1, AudioConverterRef inAudioConverter)
{
  UInt32 outSize = 0;
  uint64_t result = AudioConverterGetPropertyInfo(inAudioConverter, 0x636D6763u, &outSize, 0);
  if (!result)
  {
    uint64_t result = outSize;
    if (outSize) {
      operator new[]();
    }
  }
  return result;
}

uint64_t sub_12EF4(int a1, AudioConverterRef inAudioConverter)
{
  UInt32 outSize = 0;
  uint64_t result = AudioConverterGetPropertyInfo(inAudioConverter, 0x6F636C20u, &outSize, 0);
  if (!result)
  {
    uint64_t result = outSize;
    if (outSize) {
      operator new[]();
    }
  }
  return result;
}

void sub_13018(int a1, OpaqueAudioConverter *a2, AudioFileID inAudioFile)
{
  *(void *)isWritable = 0;
  OSStatus PropertyInfo = AudioFileGetPropertyInfo(inAudioFile, 0x706E666Fu, isWritable, &isWritable[1]);
  int v6 = isWritable[1];
  if (PropertyInfo || !isWritable[1])
  {
    char v7 = qword_A19E0;
    if (os_log_type_enabled((os_log_t)qword_A19E0, OS_LOG_TYPE_ERROR)) {
      sub_63670(PropertyInfo, v6, v7);
    }
  }
  else
  {
    uint64_t outPropertyData = 0;
    isWritable[0] = 8;
    if (AudioConverterGetProperty(a2, 0x7072696Du, isWritable, &outPropertyData))
    {
      if (os_log_type_enabled((os_log_t)qword_A19E0, OS_LOG_TYPE_ERROR)) {
        sub_6363C();
      }
    }
    else
    {
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      isWritable[0] = 16;
      uint64_t Property = AudioFileGetProperty(inAudioFile, 0x706E666Fu, isWritable, &v28);
      if (Property)
      {
        uint64_t v9 = Property;
        unint64_t v10 = qword_A19E0;
        if (os_log_type_enabled((os_log_t)qword_A19E0, OS_LOG_TYPE_ERROR)) {
          sub_635D0(v9, v10, v11, v12, v13, v14, v15, v16);
        }
      }
      else
      {
        uint64_t v17 = v28 + (int)v29 + SHIDWORD(v29);
        int v18 = qword_A19E0;
        if (os_log_type_enabled((os_log_t)qword_A19E0, OS_LOG_TYPE_ERROR)) {
          sub_63558(v17, v18);
        }
        uint64_t v29 = outPropertyData;
        uint64_t v28 = v17 - ((int)outPropertyData + (uint64_t)SHIDWORD(outPropertyData));
        OSStatus v19 = AudioFileSetProperty(inAudioFile, 0x706E666Fu, 0x10u, &v28);
        int v20 = qword_A19E0;
        BOOL v21 = os_log_type_enabled((os_log_t)qword_A19E0, OS_LOG_TYPE_ERROR);
        if (v19)
        {
          if (v21) {
            sub_63524();
          }
        }
        else
        {
          if (v21)
          {
            *(_DWORD *)std::string buf = 134217984;
            uint64_t v33 = 16;
            _os_log_error_impl(&dword_0, v20, OS_LOG_TYPE_ERROR, "Writing packet table information to destination file: %ld\n", buf, 0xCu);
            int v20 = qword_A19E0;
          }
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 134217984;
            uint64_t v33 = v28;
            _os_log_error_impl(&dword_0, v20, OS_LOG_TYPE_ERROR, "     Total valid frames: %lld\n", buf, 0xCu);
            int v20 = qword_A19E0;
          }
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)std::string buf = 67109120;
            LODWORD(v33) = v29;
            _os_log_error_impl(&dword_0, v20, OS_LOG_TYPE_ERROR, "         Priming frames: %d\n", buf, 8u);
            int v20 = qword_A19E0;
          }
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
            sub_634B4((uint64_t)&v29 + 4, v20, v22, v23, v24, v25, v26, v27);
          }
        }
      }
    }
  }
}

void sub_1330C(uint64_t a1, UInt32 a2, UInt32 a3)
{
  UInt32 ioNumPackets = a3;
  __int16 v30 = 0;
  memset(v29, 0, sizeof(v29));
  memset(&v23, 0, sizeof(v23));
  time_t v22 = time(0);
  localtime_r(&v22, &v23);
  sprintf((char *)v29, "%d_%d_%d_%d_%d_%d", v23.tm_year + 1900, v23.tm_mon + 1, v23.tm_mday, v23.tm_hour, v23.tm_min, v23.tm_sec);
  int v5 = sub_395B4();
  int v6 = "/var/tmp";
  if (v5) {
    int v6 = "/Library/Preferences/Audio";
  }
  if (*(unsigned char *)(a1 + 176))
  {
    if (!*(void *)(a1 + 16))
    {
      __int16 v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      *(_OWORD *)cStr = 0u;
      sprintf(cStr, "%s/encode-capture-%s.caf", v6, (const char *)v29);
      CFStringRef v7 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
      CFURLRef v8 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, v7, kCFURLPOSIXPathStyle, 0);
      *(void *)(a1 + 16) = v8;
      BOOL v9 = os_log_type_enabled((os_log_t)qword_A19E0, OS_LOG_TYPE_ERROR);
      if (v8)
      {
        if (v9) {
          sub_63760();
        }
      }
      else if (v9)
      {
        sub_6372C();
      }
      CFRelease(v7);
    }
    uint64_t v12 = (OpaqueAudioFileID **)(a1 + 8);
    uint64_t v11 = *(OpaqueAudioFileID **)(a1 + 8);
    if (v11) {
      goto LABEL_15;
    }
    CFURLRef v16 = *(const __CFURL **)(a1 + 16);
    if (v16)
    {
      int v17 = AudioFileCreateWithURL(v16, 0x63616666u, (const AudioStreamBasicDescription *)(a1 + 104), 1u, (AudioFileID *)(a1 + 8));
      if (v17)
      {
        int v17 = os_log_type_enabled((os_log_t)qword_A19E0, OS_LOG_TYPE_ERROR);
        if (v17) {
          sub_636F8();
        }
      }
      int v18 = sub_12DD0(v17, *(AudioConverterRef *)(a1 + 56));
      if (*(_DWORD *)(a1 + 92) >= 3u) {
        sub_12EF4(v18, *(AudioConverterRef *)(a1 + 56));
      }
      uint64_t v11 = *v12;
      if (*v12)
      {
LABEL_15:
        OSStatus v13 = AudioFileWritePackets(v11, 0, a2, *(const AudioStreamPacketDescription **)(a1 + 168), *(void *)(a1 + 32), &ioNumPackets, *(const void **)(a1 + 144));
        sub_1B8C0(v13, (uint64_t)"AudioFileWritePackets failed!");
        uint64_t v14 = ioNumPackets;
        *(void *)(a1 + 32) += ioNumPackets;
        int v15 = *(_DWORD *)(a1 + 124);
        if (v15)
        {
          *(void *)(a1 + 24) += (v15 * v14);
        }
        else if (v14)
        {
          uint64_t v19 = *(void *)(a1 + 24);
          int v20 = (unsigned int *)(*(void *)(a1 + 168) + 8);
          do
          {
            unsigned int v21 = *v20;
            v20 += 4;
            v19 += v21;
            --v14;
          }
          while (v14);
          *(void *)(a1 + 24) = v19;
        }
      }
    }
  }
  else
  {
    unint64_t v10 = *(FILE **)(a1 + 40);
    if (v10
      || (__int16 v28 = 0,
          long long v26 = 0u,
          long long v27 = 0u,
          *(_OWORD *)cStr = 0u,
          sprintf(cStr, "%s/encode-capture-%s.enc", v6, (const char *)v29),
          unint64_t v10 = fopen(cStr, "wb"),
          (*(void *)(a1 + 40) = v10) != 0))
    {
      fwrite(*(const void **)(a1 + 144), 1uLL, a2, v10);
    }
  }
}

void sub_13610(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176))
  {
    uint64_t v2 = *(OpaqueAudioFileID **)(a1 + 8);
    if (v2)
    {
      if (!*(_DWORD *)(a1 + 136))
      {
        uint64_t v3 = qword_A19E0;
        BOOL v4 = os_log_type_enabled((os_log_t)qword_A19E0, OS_LOG_TYPE_ERROR);
        if (v4)
        {
          uint64_t v5 = *(void *)(a1 + 24);
          int v6 = 134217984;
          uint64_t v7 = v5;
          _os_log_error_impl(&dword_0, v3, OS_LOG_TYPE_ERROR, "Total number of output frames counted: %lld\n", (uint8_t *)&v6, 0xCu);
          uint64_t v2 = *(OpaqueAudioFileID **)(a1 + 8);
        }
        sub_13018(v4, *(OpaqueAudioConverter **)(a1 + 56), v2);
      }
      sub_12DD0(a1, *(AudioConverterRef *)(a1 + 56));
      AudioFileClose(*(AudioFileID *)(a1 + 8));
      *(void *)(a1 + 8) = 0;
      CFRelease(*(CFTypeRef *)(a1 + 16));
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 32) = 0;
    }
  }
  else
  {
    fclose(*(FILE **)(a1 + 40));
    *(void *)(a1 + 40) = 0;
  }
}

void sub_13724(uint64_t a1, char *a2, char *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v5 = (unsigned char *)(a5 + 1);
    do
    {
      char v6 = *a2++;
      *(v5 - 1) = v6;
      char v7 = *a3++;
      unsigned char *v5 = v7;
      v5 += 2;
      --a4;
    }
    while (a4);
  }
}

uint64_t sub_13748()
{
  return 0;
}

uint64_t sub_13750()
{
  return 0;
}

void sub_13758(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

os_log_t sub_13774()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A19E0 = (uint64_t)result;
  return result;
}

void *sub_137A4(uint64_t a1, xpc_object_t xdict)
{
  int64_t int64 = xpc_dictionary_get_int64(xdict, "kBTAudioMsgArgDeviceType");
  uint64_t v5 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_63794(int64, v5);
  }
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kBTAudioMsgArgDeviceProperties");
  return sub_40A64(qword_A2350, int64, a1, value);
}

BOOL sub_13838(uint64_t a1, xpc_object_t xdict)
{
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 3221225472;
  applier[2] = sub_13D54;
  applier[3] = &unk_8DDB8;
  applier[4] = a1;
  return xpc_dictionary_apply(xdict, applier);
}

void sub_138B0(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t v2 = sub_41A14();
  if (v2)
  {
    sub_4B68(v2, 1);
  }
  else
  {
    uint64_t v3 = qword_A19E8;
    if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR)) {
      sub_63830(v1, v3, v4, v5, v6, v7, v8, v9);
    }
  }
}

uint64_t sub_13930(uint64_t result)
{
  *(void *)os_log_t result = 0;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

uint64_t sub_1393C(uint64_t a1)
{
  uint64_t v2 = sub_41A14();
  if (v2) {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 1120))(v2, 0);
  }
  return a1;
}

uint64_t sub_139B0(uint64_t result)
{
  if (result)
  {
    sub_1393C(result);
    operator delete();
  }
  return result;
}

void sub_139F0(uint64_t a1)
{
  uint64_t v2 = sub_41A14();
  if (v2)
  {
    uint64_t v3 = (void *)v2;
    uint64_t v4 = qword_A19E8;
    if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(a1 + 8);
      v6[0] = 67109120;
      v6[1] = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTAudioDevice %d disconnected, marking invalid", (uint8_t *)v6, 8u);
    }
    sub_4118C(qword_A2350, v3);
  }
}

void sub_13AC4(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_13BE4(a1, object);
  }
  else if (type == (xpc_type_t)&_xpc_type_error)
  {
    if (object == &_xpc_error_connection_invalid)
    {
      sub_139F0(a1);
    }
    else
    {
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      uint64_t v8 = qword_A19E8;
      if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR)) {
        sub_638A0((uint64_t)string, v8);
      }
    }
  }
  else
  {
    int v5 = xpc_copy_description(object);
    uint64_t v6 = qword_A19E8;
    if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR)) {
      sub_63918((uint64_t)v5, v6);
    }
    free(v5);
  }
}

void sub_13BE4(uint64_t a1, xpc_object_t xdict)
{
  unsigned int int64 = xpc_dictionary_get_int64(xdict, "kBTAudioMsgId");
  if (int64 - 1 > 0x14)
  {
    if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR)) {
      sub_639F8();
    }
  }
  else if (qword_8DD28[2 * int64])
  {
    uint64_t v6 = (void (*)(uint64_t, xpc_object_t))qword_8DD28[2 * int64];
    xpc_object_t value = xpc_dictionary_get_value(xdict, "kBTAudioMsgArgs");
    v6(a1, value);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63990();
  }
}

void sub_13CE8(uint64_t a1, char *a2, void *a3)
{
  uint64_t v5 = sub_41A14();
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(v5 + 416);
    sub_505DC(v7, v6, a2, a3);
  }
}

uint64_t sub_13D54(uint64_t a1, char *a2, void *a3)
{
  return 1;
}

void sub_13D74(id *a1, void *a2, size_t a3, void *a4, size_t a5)
{
  unint64_t v10 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134218752;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = a3;
    __int16 v18 = 2048;
    uint64_t v19 = a4;
    __int16 v20 = 2048;
    size_t v21 = a5;
    _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "XPC START MESSAGE SENT, Shared Memory output 0x%p of size %lu. Shared Memory Input 0x%p of size %lu", buf, 0x2Au);
  }
  xpc_object_t v11 = 0;
  *(_OWORD *)std::string buf = *(_OWORD *)off_8DDD8;
  if (a2 && a3) {
    xpc_object_t v11 = xpc_shmem_create(a2, a3);
  }
  xpc_object_t v12 = 0;
  xpc_object_t object = v11;
  if (a4 && a5) {
    xpc_object_t v12 = xpc_shmem_create(a4, a5);
  }
  xpc_object_t v16 = v12;
  xpc_object_t v13 = xpc_dictionary_create((const char *const *)buf, &object, 2uLL);
  if (v13)
  {
    uint64_t v14 = v13;
    sub_13F58(a1, 5u, (uint64_t)v13);
    xpc_release(v14);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63AC8();
  }
  if (object)
  {
    xpc_release(object);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63A94();
  }
  if (v16)
  {
    xpc_release(v16);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63A60();
  }
}

void sub_13F58(id *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = sub_40664(qword_A2350);
  if (v6)
  {
    uint64_t v7 = (_xpc_connection_s *)v6;
    *(_OWORD *)keys = *(_OWORD *)off_8DE00;
    int v15 = "kBTAudioMsgArgs";
    xpc_object_t values = xpc_int64_create(a2);
    xpc_object_t object = xpc_string_create((const char *)[*a1 UTF8String]);
    uint64_t v13 = a3;
    if (a3) {
      size_t v8 = 3;
    }
    else {
      size_t v8 = 2;
    }
    xpc_object_t v9 = xpc_dictionary_create((const char *const *)keys, &values, v8);
    if (v9)
    {
      unint64_t v10 = v9;
      xpc_connection_send_message(v7, v9);
      xpc_release(v10);
    }
    else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
    {
      sub_63B98();
    }
    if (object)
    {
      xpc_release(object);
    }
    else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
    {
      sub_63B64();
    }
    if (values)
    {
      xpc_release(values);
    }
    else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
    {
      sub_63B30();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63AFC();
  }
}

void sub_140F0(id *a1)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_63BCC();
  }
  sub_13F58(a1, 7u, 0);
}

void sub_14144(id *a1, int a2)
{
  if (a2 == 2)
  {
    unsigned int v2 = 21;
  }
  else
  {
    if (a2 != 3) {
      goto LABEL_6;
    }
    unsigned int v2 = 20;
  }
  sub_13F58(a1, v2, 0);
LABEL_6:
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_63C00();
  }
}

void sub_141B0(id *a1)
{
}

void sub_141BC(id *a1, BOOL a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_63C9C();
  }
  xpc_object_t v4 = xpc_BOOL_create(a2);
  if (v4)
  {
    uint64_t v5 = v4;
    sub_13F58(a1, 0xEu, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63C68();
  }
}

void sub_1425C(id *a1, unsigned int a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_63D38();
  }
  xpc_object_t v4 = xpc_int64_create(a2);
  if (v4)
  {
    uint64_t v5 = v4;
    sub_13F58(a1, 9u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63D04();
  }
}

void sub_142FC(id *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_63E70();
  }
  *(_OWORD *)keys = *(_OWORD *)off_8DDE8;
  uint64_t v14 = "kBTAudioMsgPropertyScoSampleRate";
  xpc_object_t values = xpc_int64_create(a2);
  xpc_object_t object = xpc_int64_create(a3);
  xpc_object_t v12 = xpc_int64_create(a4);
  xpc_object_t v8 = xpc_dictionary_create((const char *const *)keys, &values, 3uLL);
  if (v8)
  {
    xpc_object_t v9 = v8;
    sub_13F58(a1, 0xBu, (uint64_t)v8);
    xpc_release(v9);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63E3C();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63E08();
  }
  if (object)
  {
    xpc_release(object);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63DD4();
  }
  if (v12)
  {
    xpc_release(v12);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63DA0();
  }
}

void sub_144B8(id *a1, unsigned int a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_63F28();
  }
  xpc_object_t v4 = xpc_int64_create(a2);
  if (v4)
  {
    uint64_t v5 = v4;
    sub_13F58(a1, 0xAu, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63EF4();
  }
}

void sub_14558(id *a1, float a2)
{
  uint64_t v3 = qword_A19E8;
  double v4 = a2;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)keys = 134217984;
    *(double *)&keys[4] = v4;
    _os_log_debug_impl(&dword_0, v3, OS_LOG_TYPE_DEBUG, "Send XPC Input volume changed to %f", keys, 0xCu);
  }
  *(void *)keys = "kBTAudioMsgPropertyInputVolumeScalar";
  xpc_object_t values = xpc_double_create(v4);
  xpc_object_t v5 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  if (v5)
  {
    uint64_t v6 = v5;
    sub_13F58(a1, 3u, (uint64_t)v5);
    xpc_release(v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63FC4();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63F90();
  }
}

void sub_146B4(id *a1, float a2)
{
  uint64_t v3 = qword_A19E8;
  double v4 = a2;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)keys = 134217984;
    *(double *)&keys[4] = v4;
    _os_log_debug_impl(&dword_0, v3, OS_LOG_TYPE_DEBUG, "Send XPC volume changed to %f", keys, 0xCu);
  }
  *(void *)keys = "kBTAudioMsgPropertyVolumeScalar";
  xpc_object_t values = xpc_double_create(v4);
  xpc_object_t v5 = xpc_dictionary_create((const char *const *)keys, &values, 1uLL);
  if (v5)
  {
    uint64_t v6 = v5;
    sub_13F58(a1, 3u, (uint64_t)v5);
    xpc_release(v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_6402C();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_63FF8();
  }
}

void sub_14810(id *a1, BOOL value)
{
  keys = "kBTAudioMsgPropertyDynamicLatencyAudioAndInputAggregationOn";
  xpc_object_t values = xpc_BOOL_create(value);
  xpc_object_t v3 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v3)
  {
    double v4 = v3;
    sub_13F58(a1, 3u, (uint64_t)v3);
    xpc_release(v4);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64094();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64060();
  }
}

void sub_14908(id *a1, BOOL value)
{
  keys = "kBTAudioMsgPropertyExpanseOn";
  xpc_object_t values = xpc_BOOL_create(value);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_640FC();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_640C8();
  }
  uint64_t v6 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = value;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "SendExpanseStatePropertyChanged expanseOn:%d", (uint8_t *)v7, 8u);
  }
}

void sub_14A50(id *a1, BOOL value)
{
  keys = "kBTAudioMsgPropertyExpanseInA2DP";
  xpc_object_t values = xpc_BOOL_create(value);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64164();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64130();
  }
  uint64_t v6 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = value;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "SendExpanseInA2DPChanged expanseOn:%d", (uint8_t *)v7, 8u);
  }
}

void sub_14B98(id *a1, BOOL value)
{
  keys = "kBTAudioMsgPropertyCallScreening";
  xpc_object_t values = xpc_BOOL_create(value);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64198();
  }
  if (values) {
    xpc_release(values);
  }
  uint64_t v6 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67109120;
    v7[1] = value;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "SendCallScreeningState enabled:%d", (uint8_t *)v7, 8u);
  }
}

void sub_14CBC(id *a1, BOOL value)
{
  keys = "kBTAudioMsgPropertyGameOn";
  xpc_object_t values = xpc_BOOL_create(value);
  xpc_object_t v3 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v3)
  {
    xpc_object_t v4 = v3;
    sub_13F58(a1, 3u, (uint64_t)v3);
    xpc_release(v4);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64200();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_641CC();
  }
}

void sub_14DB4(id *a1, BOOL value)
{
  keys = "kBTAudioMsgPropertyVoiceOverOn";
  xpc_object_t values = xpc_BOOL_create(value);
  xpc_object_t v3 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v3)
  {
    xpc_object_t v4 = v3;
    sub_13F58(a1, 3u, (uint64_t)v3);
    xpc_release(v4);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64268();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64234();
  }
}

void sub_14EAC(id *a1, BOOL value)
{
  keys = "kBTAudioMsgPropertyWSModeEnabled";
  xpc_object_t values = xpc_BOOL_create(value);
  xpc_object_t v3 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v3)
  {
    xpc_object_t v4 = v3;
    sub_13F58(a1, 3u, (uint64_t)v3);
    xpc_release(v4);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_642D0();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_6429C();
  }
}

void sub_14FA4(id *a1, BOOL value)
{
  keys = "kBTAudioMsgPropertySpatialAudioActive";
  xpc_object_t values = xpc_BOOL_create(value);
  xpc_object_t v3 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v3)
  {
    xpc_object_t v4 = v3;
    sub_13F58(a1, 3u, (uint64_t)v3);
    xpc_release(v4);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64338();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64304();
  }
}

void sub_1509C(id *a1, unsigned int a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_643D4();
  }
  keys = "kBTAudioMsgPropertyFrameCount";
  xpc_object_t values = xpc_int64_create(a2);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_643A0();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_6436C();
  }
}

void sub_151C0(id *a1, unsigned int a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_644A4();
  }
  keys = "kBTAudioMsgPropertySpatialOn";
  xpc_object_t values = xpc_int64_create(a2);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64470();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_6443C();
  }
}

void sub_152E4(id *a1, const __CFString *a2, int a3, float a4)
{
  __int16 valuePtr = a3;
  unsigned int v15 = (float)(a4 * 100.0);
  xpc_object_t v8 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109634;
    *(_DWORD *)&uint8_t buf[4] = a4;
    __int16 v19 = 2112;
    CFStringRef v20 = a2;
    __int16 v21 = 1024;
    int v22 = a3;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Send adaptive volume ramp end config CurrentVolume %d audioCategory %@ rampEndReason %d", buf, 0x18u);
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v15);
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
  CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertyAdaptiveVolumeCurrentVolume", v10);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertyAdaptiveVolumeAudioCategory", Copy);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertyAdaptiveVolumeRampEndReason", v12);
  *(void *)std::string buf = "kBTAudioMsgPropertyAdaptiveVolumeRampEnd";
  xpc_object_t values = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
  xpc_object_t v13 = xpc_dictionary_create((const char *const *)buf, &values, 1uLL);
  if (v13)
  {
    uint64_t v14 = v13;
    sub_13F58(a1, 3u, (uint64_t)v13);
    xpc_release(v14);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64540();
  }
  if (values)
  {
    xpc_release(values);
    if (!Mutable) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (!os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    if (!Mutable) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  sub_6450C();
  if (Mutable) {
LABEL_12:
  }
    CFRelease(Mutable);
LABEL_13:
  if (v10) {
    CFRelease(v10);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  if (v12) {
    CFRelease(v12);
  }
}

void sub_15558(id *a1, const __CFString *a2, void *a3, void *a4, void *a5)
{
  unsigned int v9 = [a3 intValue];
  unsigned int v22 = v9;
  unsigned int v10 = [a4 intValue];
  unsigned int valuePtr = v10;
  unsigned int v11 = [a5 intValue];
  unsigned int v20 = v11;
  CFNumberRef v12 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138413058;
    *(void *)&uint8_t buf[4] = a2;
    __int16 v25 = 1024;
    unsigned int v26 = v9;
    __int16 v27 = 1024;
    unsigned int v28 = v10;
    __int16 v29 = 1024;
    unsigned int v30 = v11;
    _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "Send manual volume update currentAudioCategory %@ currentVolume %d manualVolumeUpdate %d isRampInProgress %d", buf, 0x1Eu);
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFNumberRef v14 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFNumberRef v15 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v22);
  CFNumberRef v16 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v20);
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertyManualVolumeUpdateNewVolume", v14);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertyManualVolumeUpdateCurrentVolume", v15);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertyManualVolumeUpdateRampInProgress", v16);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertyManualVolumeUpdateCurrentAudioCategory", Copy);
  *(void *)std::string buf = "kBTAudioMsgPropertyManualVolumeUpdate";
  xpc_object_t values = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
  xpc_object_t v18 = xpc_dictionary_create((const char *const *)buf, &values, 1uLL);
  if (v18)
  {
    __int16 v19 = v18;
    sub_13F58(a1, 3u, (uint64_t)v18);
    xpc_release(v19);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_645A8();
  }
  if (values)
  {
    xpc_release(values);
    if (!v14) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (!os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    if (!v14) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  sub_64574();
  if (v14) {
LABEL_12:
  }
    CFRelease(v14);
LABEL_13:
  if (v15) {
    CFRelease(v15);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  if (v16) {
    CFRelease(v16);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void sub_15810(id *a1, BOOL a2)
{
  xpc_object_t v4 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Send PME On bud status%d", buf, 8u);
  }
  *(void *)std::string buf = "kBTAudioMsgPropertyPMEOnBuds";
  xpc_object_t values = xpc_BOOL_create(a2);
  xpc_object_t v5 = xpc_dictionary_create((const char *const *)buf, &values, 1uLL);
  if (v5)
  {
    uint64_t v6 = v5;
    sub_13F58(a1, 3u, (uint64_t)v5);
    xpc_release(v6);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64610();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_645DC();
  }
}

void sub_15958(id *a1, const __CFString *a2, int a3, int a4)
{
  int valuePtr = a3;
  xpc_object_t v8 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412546;
    *(void *)&uint8_t buf[4] = a2;
    __int16 v19 = 1024;
    int v20 = a3;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Send SpatialAudio App Based Mode %@ Mode%d", buf, 0x12u);
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
  CFNumberRef v12 = &kCFBooleanTrue;
  if (!a4) {
    CFNumberRef v12 = &kCFBooleanFalse;
  }
  CFBooleanRef v13 = *v12;
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertySpatialMode", v10);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertySpatialBundleID", Copy);
  CFDictionaryAddValue(Mutable, @"kBTAudioMsgPropertyHeadTrack", v13);
  *(void *)std::string buf = "kBTAudioMsgPropertySpatialAudioAppBasedMode";
  xpc_object_t values = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
  xpc_object_t v14 = xpc_dictionary_create((const char *const *)buf, &values, 1uLL);
  if (v14)
  {
    CFNumberRef v15 = v14;
    sub_13F58(a1, 3u, (uint64_t)v14);
    xpc_release(v15);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64678();
  }
  if (values)
  {
    xpc_release(values);
    if (!Copy) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if (!os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    if (!Copy) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  sub_64644();
  if (Copy) {
LABEL_14:
  }
    CFRelease(Copy);
LABEL_15:
  if (v10) {
    CFRelease(v10);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void sub_15B9C(id *a1, BOOL a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_64714();
  }
  keys = "kBTAudioMsgPropertyAllowSpatialAudio";
  xpc_object_t values = xpc_BOOL_create(a2);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_646E0();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_646AC();
  }
}

void sub_15CC0(id *a1, BOOL a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_647E4();
  }
  keys = "kBTAudioMsgPropertyEnableSoftwareVolume";
  xpc_object_t values = xpc_BOOL_create(a2);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_647B0();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_6477C();
  }
}

void sub_15DE4(id *a1, BOOL a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_648B4();
  }
  keys = "kBTAudioMsgPropertyAllowSCOForTBT";
  xpc_object_t values = xpc_BOOL_create(a2);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64880();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_6484C();
  }
}

void sub_15F08(id *a1, unsigned int a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_64984();
  }
  keys = "kBTAudioMsgPropertyScoSampleRate";
  xpc_object_t values = xpc_int64_create(a2);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64950();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_6491C();
  }
}

void sub_1602C(id *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  xpc_object_t v8 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    v11[0] = 67109376;
    v11[1] = a3;
    __int16 v12 = 1024;
    unsigned int v13 = a2;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "XPC Send HFP Codec Type: %u, %u!", (uint8_t *)v11, 0xEu);
  }
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v9, "kBTAudioMsgPropertyScoChannelFormat", a2);
  xpc_dictionary_set_int64(v9, "kBTAudioMsgPropertyScoSampleRate", a3);
  xpc_dictionary_set_int64(v9, "kBTAudioMsgPropertyTransportType", a4);
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_value(v10, "kBTAudioMsgPropertyScoCodecTypeChanged", v9);
  if (!v10)
  {
    if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
    {
      sub_64A20();
      if (!v9) {
        goto LABEL_10;
      }
    }
    else if (!v9)
    {
      goto LABEL_10;
    }
LABEL_8:
    xpc_release(v9);
    return;
  }
  sub_13F58(a1, 3u, (uint64_t)v10);
  xpc_release(v10);
  if (v9) {
    goto LABEL_8;
  }
LABEL_10:
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR)) {
    sub_649EC();
  }
}

void sub_161D8(id *a1, const char *a2, BOOL a3)
{
  uint64_t v6 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = a3;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Send ownership state for has changed to %d", buf, 8u);
  }
  *(_OWORD *)std::string buf = *(_OWORD *)off_8DE18;
  xpc_object_t values = xpc_BOOL_create(a3);
  if (a2[23] < 0) {
    a2 = *(const char **)a2;
  }
  xpc_object_t v12 = xpc_string_create(a2);
  keys = "kBTAudioMsgPropertyOwnershipStateChanged";
  xpc_object_t object = xpc_dictionary_create((const char *const *)buf, &values, 2uLL);
  xpc_object_t v7 = xpc_dictionary_create((const char *const *)&keys, &object, 1uLL);
  if (v7)
  {
    xpc_object_t v8 = v7;
    sub_13F58(a1, 3u, (uint64_t)v7);
    xpc_release(v8);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64AF0();
  }
  if (object)
  {
    xpc_release(object);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64ABC();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64A88();
  }
  if (v12)
  {
    xpc_release(v12);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64A54();
  }
}

void sub_163C8(id *a1, unsigned int a2)
{
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG)) {
    sub_64B8C();
  }
  keys = "kBTAudioMsgPropertyListenMode";
  xpc_object_t values = xpc_int64_create(a2);
  xpc_object_t v4 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v4)
  {
    xpc_object_t v5 = v4;
    sub_13F58(a1, 3u, (uint64_t)v4);
    xpc_release(v5);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64B58();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64B24();
  }
}

void sub_164EC(id *a1, float a2)
{
  keys = "kBTAudioMsgPropertyDosimetrySensitivity";
  xpc_object_t values = xpc_double_create(a2);
  xpc_object_t v3 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v3)
  {
    xpc_object_t v4 = v3;
    sub_13F58(a1, 3u, (uint64_t)v3);
    xpc_release(v4);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64C28();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64BF4();
  }
}

void sub_165E4(id *a1)
{
  keys = "kBTAudioMsgPropertyDosimetryVolumeCurve";
  xpc_object_t values = (xpc_object_t)_CFXPCCreateXPCObjectFromCFObject();
  xpc_object_t v2 = xpc_dictionary_create((const char *const *)&keys, &values, 1uLL);
  if (v2)
  {
    xpc_object_t v3 = v2;
    sub_13F58(a1, 3u, (uint64_t)v2);
    xpc_release(v3);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64C90();
  }
  if (values)
  {
    xpc_release(values);
  }
  else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
  {
    sub_64C5C();
  }
}

void sub_166DC(uint64_t a1, void *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v4 = sub_41A14();
  xpc_object_t v5 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG))
  {
    sub_64D60(v3, v5, v6, v7, v8, v9, v10, v11);
    if (v4)
    {
LABEL_3:
      xpc_object_t value = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyInEarDetection");
      if (value)
      {
        unsigned int v13 = value;
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_BOOL)
        {
          BOOL v14 = xpc_BOOL_get_value(v13);
          sub_235B8(*(unsigned char **)(*(void *)(v4 + 416) + 9248), v14);
          if (v14)
          {
            xpc_object_t v15 = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyInEarEnabled");
            BOOL v16 = xpc_BOOL_get_value(v15);
            sub_23818(*(void *)(*(void *)(v4 + 416) + 9248), v16);
            xpc_object_t v17 = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyInEarStatus");
            if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_int64)
            {
              __int16 v20 = xpc_int64_get_value(v17);
              int v18 = v20;
              int v19 = HIBYTE(v20);
            }
            else
            {
              int v18 = 0;
              int v19 = 0;
            }
            xpc_object_t v21 = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyPrimaryBudSide");
            if (xpc_get_type(v21) == (xpc_type_t)&_xpc_type_int64) {
              int v22 = xpc_int64_get_value(v21);
            }
            else {
              int v22 = 0;
            }
            xpc_object_t v23 = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyFixedMicRole");
            if (xpc_get_type(v23) == (xpc_type_t)&_xpc_type_int64) {
              int v24 = xpc_int64_get_value(v23);
            }
            else {
              int v24 = 0;
            }
            sub_24864(*(void *)(*(void *)(v4 + 416) + 9248), v22);
            sub_24A64(*(void *)(*(void *)(v4 + 416) + 9248), v24);
            sub_24610(*(void *)(*(void *)(v4 + 416) + 9248), v18, v19);
          }
        }
        else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
        {
          sub_64D2C();
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG))
      {
        sub_64CF8();
      }
      return;
    }
  }
  else if (v4)
  {
    goto LABEL_3;
  }
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR)) {
    sub_64CC4();
  }
}

void sub_16908(uint64_t a1, void *a2)
{
  uint64_t v3 = a1 + 8;
  uint64_t v4 = sub_41A14();
  xpc_object_t v5 = qword_A19E8;
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG))
  {
    sub_64E38(v3, v5, v6, v7, v8, v9, v10, v11);
    if (v4)
    {
LABEL_3:
      xpc_object_t value = xpc_dictionary_get_value(a2, "kBTAudioMsgPropertyIsGenuineAirPods");
      if (value)
      {
        unsigned int v13 = value;
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_BOOL)
        {
          BOOL v14 = xpc_BOOL_get_value(v13);
          sub_28174(*(void *)(*(void *)(v4 + 416) + 9248), v14);
        }
        else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR))
        {
          sub_64E04();
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_DEBUG))
      {
        sub_64DD0();
      }
      return;
    }
  }
  else if (v4)
  {
    goto LABEL_3;
  }
  if (os_log_type_enabled((os_log_t)qword_A19E8, OS_LOG_TYPE_ERROR)) {
    sub_64CC4();
  }
}

void sub_16A28(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 8u);
}

void sub_16A60(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

os_log_t sub_16A7C()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A19E8 = (uint64_t)result;
  return result;
}

os_log_t *sub_16AAC(os_log_t *a1)
{
  *a1 = 0;
  a1[1] = (os_log_t)os_nexus_controller_create();
  os_log_t v2 = os_log_create("com.apple.bluetooth", "BTAudioSkywalk");
  uint64_t v3 = *a1;
  *a1 = v2;

  uint64_t v4 = *a1;
  xpc_object_t v5 = *a1;
  if (a1[1])
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v7[0]) = 134219008;
      *(void *)((char *)v7 + 4) = 2048;
      WORD2(v7[1]) = 2048;
      *(void *)((char *)&v7[1] + 6) = 1;
      HIWORD(v7[2]) = 2048;
      v7[3] = 1;
      LOWORD(v7[4]) = 2048;
      *(void *)((char *)&v7[4] + 2) = 8;
      WORD1(v7[5]) = 2048;
      *(void *)((char *)&v7[5] + 4) = 8;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Creating skywalk nexus with NEXUS_ATTR_SLOT_BUF_SIZE: %llu, NEXUS_ATTR_RX_RINGS: %llu, NEXUS_ATTR_TX_RINGS: %llu, NEXUS_ATTR_TX_SLOTS: %llu, NEXUS_ATTR_RX_SLOTS: %llu", (uint8_t *)v7, 0x34u);
    }
    os_nexus_attr_create();
    os_nexus_attr_set();
    os_nexus_attr_set();
    os_nexus_attr_set();
    os_nexus_attr_set();
    os_nexus_attr_set();
    os_nexus_attr_set();
    strcpy((char *)v7, "com.apple.bluetooth.AudioPipe");
    HIWORD(v7[3]) = 0;
    memset(&v7[4], 0, 32);
    os_nexus_controller_register_provider();
    os_nexus_attr_destroy();
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    sub_64EA8();
  }
  return a1;
}

void sub_16C5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_16C84(uint64_t a1)
{
  if (*(void *)(a1 + 8))
  {
    os_nexus_controller_deregister_provider();
    os_nexus_controller_destroy();
  }

  return a1;
}

uint64_t sub_16CD0(uint64_t a1)
{
  return *(void *)(a1 + 8);
}

id sub_16CD8(uint64_t a1)
{
  id v1 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:a1 + 16];

  return v1;
}

uint64_t sub_16D1C(uint64_t a1, uint64_t a2, char a3)
{
  *(void *)a1 = off_8DE38;
  *(void *)(a1 + 8) = -1;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  *(unsigned char *)(a1 + 208) = a3;
  mach_timebase_info((mach_timebase_info_t)(a1 + 192));
  *(void *)(a1 + 200) = a2;
  os_log_t v5 = os_log_create("com.apple.bluetooth", "BTAudioSkywalk");
  uint64_t v6 = *(void **)(a1 + 16);
  *(void *)(a1 + 16) = v5;

  return a1;
}

void sub_16DB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_16DE0(uint64_t a1)
{
  *(void *)a1 = off_8DE38;
  os_log_t v2 = *(NSObject **)(a1 + 16);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9.ident) = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Tearing down AudioSkywalkPipe", (uint8_t *)&v9, 2u);
  }
  atomic_store(1u, (unsigned __int8 *)(a1 + 144));
  int v3 = *(_DWORD *)(a1 + 12);
  if (v3 != -1 || *(_DWORD *)(a1 + 8) != -1)
  {
    v9.ident = a1 + 144;
    *(void *)&v9.filter = 0x10000000000FFF6;
    v9.data = 0;
    v9.udata = 0;
    kevent(v3, &v9, 1, 0, 0, 0);
    kevent(*(_DWORD *)(a1 + 8), &v9, 1, 0, 0, 0);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
    while (!atomic_load((unsigned __int8 *)(a1 + 145)))
      pthread_cond_wait((pthread_cond_t *)(a1 + 96), (pthread_mutex_t *)(a1 + 32));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
    pthread_cond_destroy((pthread_cond_t *)(a1 + 96));
    pthread_mutex_destroy((pthread_mutex_t *)(a1 + 32));
    int v5 = *(_DWORD *)(a1 + 8);
    if (v5 != -1) {
      close(v5);
    }
  }
  int v6 = *(_DWORD *)(a1 + 12);
  if (v6 != -1) {
    close(v6);
  }
  if (*(void *)(a1 + 176)) {
    os_channel_destroy();
  }
  uint64_t v7 = *(NSObject **)(a1 + 16);
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9.ident) = 0;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "AudioSkywalkPipe torn down", (uint8_t *)&v9, 2u);
  }

  return a1;
}

void sub_16FAC(uint64_t a1)
{
  sub_16DE0(a1);

  operator delete();
}

void sub_16FE4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a4;
  id v8 = a3;
  id v9 = objc_retainBlock(a2);
  uint64_t v10 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = v9;

  id v11 = objc_retainBlock(v8);
  xpc_object_t v12 = *(void **)(a1 + 160);
  *(void *)(a1 + 160) = v11;

  id v13 = objc_retainBlock(v7);
  BOOL v14 = *(void **)(a1 + 168);
  *(void *)(a1 + 168) = v13;

  atomic_store(0, (unsigned __int8 *)(a1 + 144));
  atomic_store(0, (unsigned __int8 *)(a1 + 145));
  if (*(void *)(a1 + 152)) {
    *(_DWORD *)(a1 + 12) = kqueue();
  }
  if (*(void *)(a1 + 160)) {
    *(_DWORD *)(a1 + 8) = kqueue();
  }
  uint64_t fd = os_channel_get_fd();
  v16.ident = (int)__chkstk_darwin(fd);
  *(_DWORD *)&v16.filter = 393215;
  memset(&v16.fflags, 0, 20);
  uint64_t v17 = a1 + 144;
  int v18 = 393206;
  uint64_t v20 = 0;
  uint64_t v19 = 0;
  int v21 = 0;
  if (kevent(*(_DWORD *)(a1 + 12), &v16, 2, 0, 0, 0) == -1)
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR)) {
      sub_64EDC();
    }
  }
  else if (*(void *)(a1 + 152))
  {
    pthread_mutex_init((pthread_mutex_t *)(a1 + 32), 0);
    pthread_cond_init((pthread_cond_t *)(a1 + 96), 0);
    memset(&v22, 0, sizeof(v22));
    pthread_attr_init(&v22);
    pthread_attr_setdetachstate(&v22, 2);
    pthread_create((pthread_t *)(a1 + 24), &v22, (void *(__cdecl *)(void *))sub_171D8, (void *)a1);
  }
}

uint64_t sub_171D8(uint64_t a1)
{
  pthread_setname_np("AudioSkywalkPipeReadLoop");
  os_log_t v2 = os_log_create("com.apple.bluetooth", "BTAudioSkywalk");
  int v3 = v2;
  uint64_t v4 = *(void *)(a1 + 200);
  if (!v4)
  {
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR)) {
      sub_64F10((uint64_t *)(a1 + 200), v3);
    }
    uint64_t v4 = 22000;
    *(void *)(a1 + 200) = 22000;
  }
  unint64_t v5 = 1000 * v4 * (unint64_t)*(unsigned int *)(a1 + 196) / *(unsigned int *)(a1 + 192);
  policy_mach_timebase_info info = v5;
  int v16 = v5 >> 2;
  int v17 = v16;
  int v18 = 0;
  thread_act_t v6 = mach_thread_self();
  thread_policy_set(v6, 2u, &policy_info, 4u);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14.ident) = 0;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Starting AudioSkywalk read loop", (uint8_t *)&v14, 2u);
  }
  mach_absolute_time();
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 224) = 0;
  id v7 = (void *)(a1 + 216);
  if (!atomic_load((unsigned __int8 *)(a1 + 144)))
  {
    unint64_t v9 = 20000000 * (unint64_t)*(unsigned int *)(a1 + 196) / *(unsigned int *)(a1 + 192);
    do
    {
      memset(&v14, 0, sizeof(v14));
      kevent(*(_DWORD *)(a1 + 12), 0, 0, &v14, 1, 0);
      if (v14.filter != -1) {
        break;
      }
      uint64_t v10 = mach_absolute_time();
      uint64_t v11 = v10;
      if (*v7 && *(void *)(a1 + 224) && v10 > *v7 + v9) {
        (*(void (**)(void))(*(void *)(a1 + 168) + 16))();
      }
      sub_174B0(a1);
      *(void *)(a1 + 216) = v11 + v5;
      *(void *)(a1 + 224) = v11;
    }
    while (!atomic_load((unsigned __int8 *)(a1 + 144)));
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14.ident) = 0;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Stopping AudioSkywalk read loop", (uint8_t *)&v14, 2u);
  }
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 32));
  atomic_store(1u, (unsigned __int8 *)(a1 + 145));
  pthread_cond_signal((pthread_cond_t *)(a1 + 96));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 32));
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14.ident) = 0;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "AudioSkywalk read loop stopped", (uint8_t *)&v14, 2u);
  }

  return 0;
}

void sub_17450(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t sub_17470(uint64_t a1, uint64_t a2)
{
  return 1000 * a2 * (unint64_t)*(unsigned int *)(a1 + 196) / *(unsigned int *)(a1 + 192);
}

unint64_t sub_17488(uint64_t a1, uint64_t a2)
{
  return (unint64_t)*(unsigned int *)(a1 + 192) * a2 / *(unsigned int *)(a1 + 196) / 0xF4240;
}

void sub_174B0(uint64_t a1)
{
  if (*(void *)(a1 + 176))
  {
    os_channel_ring_id();
    os_channel_rx_ring();
    if (os_channel_get_next_slot())
    {
      if (*(unsigned char *)(a1 + 208))
      {
        if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_DEBUG)) {
          sub_64FC0();
        }
      }
      (*(void (**)(void, void))(*(void *)(a1 + 152) + 16))(*(void *)(a1 + 152), 0);
      os_channel_get_next_slot();
      os_channel_advance_slot();
    }
    os_channel_sync();
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR))
  {
    sub_64F8C();
  }
}

void sub_175B4(uint64_t a1, const void *a2, size_t a3)
{
  if (*(void *)(a1 + 176))
  {
    os_channel_ring_id();
    os_channel_tx_ring();
    if (os_channel_get_next_slot())
    {
      uint64_t v6 = *(void *)(a1 + 184);
      uint64_t v7 = -v6;
      if (-v6 >= a3)
      {
        if (*(unsigned char *)(a1 + 208))
        {
          unint64_t v9 = *(NSObject **)(a1 + 16);
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v10 = *(void *)(a1 + 184);
            *(_DWORD *)std::string buf = 134218752;
            size_t v12 = a3;
            __int16 v13 = 1024;
            int v14 = 0;
            __int16 v15 = 1024;
            int v16 = 0;
            __int16 v17 = 2048;
            uint64_t v18 = v10;
            _os_log_debug_impl(&dword_0, v9, OS_LOG_TYPE_DEBUG, "Writing total of %lu bytes into pipe, slot %d of length %hu starting at offset %lu", buf, 0x22u);
          }
          uint64_t v6 = *(void *)(a1 + 184);
        }
        memcpy((void *)v6, a2, a3);
        *(void *)(a1 + 184) += a3;
        os_channel_set_slot_properties();
      }
      else
      {
        id v8 = *(NSObject **)(a1 + 16);
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
          sub_65070(a3, v7, v8);
        }
      }
    }
    else if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR))
    {
      sub_6503C();
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR))
  {
    sub_64F8C();
  }
}

void sub_17798(uint64_t a1)
{
  if (*(void *)(a1 + 176))
  {
    os_channel_ring_id();
    os_channel_tx_ring();
    os_channel_get_next_slot();
    if (*(unsigned char *)(a1 + 208))
    {
      if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_DEBUG)) {
        sub_650F8();
      }
    }
    os_channel_advance_slot();
    os_channel_sync();
    *(void *)(a1 + 184) = 0;
  }
  else if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR))
  {
    sub_64F8C();
  }
}

uint64_t sub_17878(uint64_t a1)
{
  return *(void *)(a1 + 184);
}

uint64_t sub_17880(uint64_t result, uint64_t a2)
{
  *(void *)(result + 176) = a2;
  return result;
}

uint64_t sub_17888(uint64_t a1)
{
  return *(void *)(a1 + 176);
}

uint64_t sub_17890(uint64_t result)
{
  *(void *)(result + 216) = 0;
  return result;
}

uint64_t sub_17898(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  uint64_t v6 = (void *)sub_16D1C(a1, a3, a4);
  *uint64_t v6 = off_8DE58;
  v6[30] = 0;
  uint64_t v7 = v6 + 30;
  v6[31] = 0;
  v6[32] = 0;
  v6[29] = *(void *)(a2 + 8);
  id v8 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:a2 + 16];
  unint64_t v9 = *(void **)(a1 + 248);
  *(void *)(a1 + 248) = v8;

  v21[0] = 0;
  v21[1] = 0;
  [*(id *)(a1 + 248) getUUIDBytes:v21];
  v20[0] = 0;
  v20[1] = 0;
  if (os_nexus_controller_alloc_provider_instance())
  {
    if (os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR)) {
      sub_651BC();
    }
  }
  else
  {
    id v10 = objc_alloc_init((Class)NSUUID);
    uint64_t v11 = *(void **)(a1 + 256);
    *(void *)(a1 + 256) = v10;

    v19[0] = 0;
    v19[1] = 0;
    [*(id *)(a1 + 256) getUUIDBytes:v19];
    os_nexus_controller_bind_provider_instance();
    os_nexus_controller_bind_provider_instance();
    id v12 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:v20];
    __int16 v13 = *(void **)(a1 + 240);
    *(void *)(a1 + 240) = v12;

    int v14 = *(NSObject **)(a1 + 16);
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *v7;
      int v17 = 138412290;
      uint64_t v18 = v15;
      _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "Registering Audio skywalk server channel to %@", (uint8_t *)&v17, 0xCu);
    }
    os_channel_attr_create();
    os_channel_attr_set();
    os_channel_attr_set_key();
    *(void *)(a1 + 176) = os_channel_create_extended();
    os_channel_attr_destroy();
    if (!*(void *)(a1 + 176) && os_log_type_enabled(*(os_log_t *)(a1 + 16), OS_LOG_TYPE_ERROR)) {
      sub_65188();
    }
  }
  return a1;
}

void sub_17AE4(_Unwind_Exception *a1)
{
  sub_16DE0((uint64_t)v1);
  _Unwind_Resume(a1);
}

uint64_t sub_17B30(uint64_t a1)
{
  *(void *)a1 = off_8DE58;
  v3[0] = 0;
  v3[1] = 0;
  [*(id *)(a1 + 240) getUUIDBytes:v3];
  os_nexus_controller_free_provider_instance();

  sub_16DE0(a1);
  return a1;
}

void sub_17BE0(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    sub_423C(a1);
  }
  _Unwind_Resume(a1);
}

void sub_17BF0(uint64_t a1)
{
  sub_17B30(a1);

  operator delete();
}

id sub_17C28(uint64_t a1)
{
  return *(id *)(a1 + 240);
}

id sub_17C30(uint64_t a1)
{
  return *(id *)(a1 + 256);
}

void *sub_17C38(void *a1, void *a2, void *a3, uint64_t a4, char a5)
{
  id v9 = a2;
  id v10 = a3;
  sub_16D1C((uint64_t)a1, a4, a5);
  *a1 = &off_8DE78;
  v14[0] = 0;
  v14[1] = 0;
  [v9 getUUIDBytes:v14];
  uint64_t v11 = a1[2];
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v13) = 138412290;
    *(void *)((char *)&v13 + 4) = v9;
    _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Registering Audio skywalk client channel to %@", (uint8_t *)&v13, 0xCu);
  }
  os_channel_attr_create();
  long long v13 = 0uLL;
  [v10 getUUIDBytes:&v13];
  os_channel_attr_set_key();
  os_channel_attr_set();
  a1[22] = os_channel_create_extended();
  os_channel_attr_destroy();

  return a1;
}

void sub_17DA4(_Unwind_Exception *a1)
{
  sub_16DE0(v2);

  _Unwind_Resume(a1);
}

void sub_17DE4(uint64_t a1)
{
  sub_16DE0(a1);

  operator delete();
}

uint64_t sub_17E34(uint64_t a1)
{
  return a1;
}

uint64_t sub_17E60(uint64_t a1)
{
  return a1;
}

float sub_17E8C(float a1)
{
  if (a1 >= 0.0) {
    return 1.0;
  }
  else {
    return __exp10f(a1 / 20.0);
  }
}

uint64_t sub_17EA8(float a1)
{
  if (a1 >= 0.0) {
    float v1 = 32768.0;
  }
  else {
    float v1 = __exp10f(a1 / 20.0) * 32768.0;
  }
  int v2 = llroundf(v1);
  if (v2 >= 0x8000) {
    return 0x8000;
  }
  else {
    return v2;
  }
}

uint64_t sub_17EF4(uint64_t a1, int a2, float a3, float a4, float a5)
{
  *(float *)a1 = a3;
  if (a3 >= 0.0) {
    float v10 = 32768.0;
  }
  else {
    float v10 = __exp10f(a3 / 20.0) * 32768.0;
  }
  int v11 = llroundf(v10);
  if (v11 >= 0x8000) {
    int v11 = 0x8000;
  }
  *(_DWORD *)(a1 + 4) = v11;
  *(_DWORD *)(a1 + 8) = v11;
  *(_DWORD *)(a1 + 12) = 0;
  *(float *)(a1 + 16) = a5;
  *(float *)(a1 + 20) = a4;
  sub_1804C(a1);
  id v12 = qword_A19F0;
  if (os_log_type_enabled((os_log_t)qword_A19F0, OS_LOG_TYPE_DEFAULT))
  {
    long long v13 = "NO";
    int v15 = 134218498;
    double v16 = a3;
    if (a2) {
      long long v13 = "YES";
    }
    __int16 v17 = 2048;
    double v18 = a4;
    __int16 v19 = 2080;
    uint64_t v20 = v13;
    _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "BT Audio Volume initialized with Volume %f Sample Rate %f Valid %s", (uint8_t *)&v15, 0x20u);
  }
  atomic_store(a2, (unsigned __int8 *)(a1 + 24));
  return a1;
}

void sub_1804C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 4);
  int v2 = *(_DWORD *)(a1 + 8);
  float v3 = *(float *)(a1 + 16);
  float v4 = *(float *)(a1 + 20);
  int v5 = (int)(float)((float)(v2 - v1) / (float)(v3 * v4));
  *(_DWORD *)(a1 + 12) = v5;
  if (v2 <= v1)
  {
    if (v2 >= v1)
    {
      int v5 = 0;
    }
    else
    {
      if (v5) {
        goto LABEL_9;
      }
      int v5 = -1;
    }
  }
  else
  {
    if (v5) {
      goto LABEL_9;
    }
    int v5 = 1;
  }
  *(_DWORD *)(a1 + 12) = v5;
LABEL_9:
  uint64_t v6 = qword_A19F0;
  if (os_log_type_enabled((os_log_t)qword_A19F0, OS_LOG_TYPE_DEFAULT))
  {
    v7[0] = 67110144;
    v7[1] = v5;
    __int16 v8 = 1024;
    int v9 = v2;
    __int16 v10 = 1024;
    int v11 = v1;
    __int16 v12 = 2048;
    double v13 = v3;
    __int16 v14 = 2048;
    double v15 = v4;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "UpdateVolume mVolumeStep1dot15 %d mTargetVolume1dot15 %d mCurrentVolume1dot15 %d mRampTimeMs %f mSampleRate %f", (uint8_t *)v7, 0x28u);
  }
}

void sub_18178(uint64_t a1, float a2)
{
  *(float *)(a1 + 20) = a2;
  sub_1804C(a1);
}

uint64_t sub_18180(uint64_t result)
{
  int v1 = llroundf(32768.0);
  if (v1 >= 0x8000) {
    int v1 = 0x8000;
  }
  *(_DWORD *)os_log_t result = 0;
  *(_DWORD *)(result + 4) = v1;
  *(_DWORD *)(result + 8) = v1;
  *(void *)(result + 12) = 0;
  return result;
}

void sub_181A4(uint64_t a1, float a2)
{
  if (a2 >= 0.0) {
    float v3 = 32768.0;
  }
  else {
    float v3 = __exp10f(a2 / 20.0) * 32768.0;
  }
  int v4 = llroundf(v3);
  if (v4 >= 0x8000) {
    int v4 = 0x8000;
  }
  *(_DWORD *)(a1 + 8) = v4;

  sub_1804C(a1);
}

void sub_18210(_DWORD *a1, float *__A, unsigned int a3, _DWORD *a4)
{
  unsigned int v5 = a3;
  uint64_t v6 = __A;
  int v8 = a1[1];
  unsigned int v9 = a1[2];
  if (__PAIR64__(v9, v8) != 0x800000008000)
  {
    int v10 = v9 - v8;
    if (v10 && (int v11 = a1[3]) != 0)
    {
      int v12 = v10 / v11;
      if (v12 < 0) {
        int v12 = -v12;
      }
      if (v12 >= a3) {
        unsigned int v13 = a3;
      }
      else {
        unsigned int v13 = v12;
      }
    }
    else
    {
      unsigned int v13 = 0;
    }
    int v14 = a4[3];
    if (v14 == 9)
    {
      if (v13)
      {
        float __Step = (float)(int)a1[3] * 0.000030518;
        float __Start = (float)v8 * 0.000030518;
        int v15 = a4[7];
        if (v15 == 1)
        {
          vDSP_vrampmul(__A, 1, &__Start, &__Step, __A, 1, v13);
        }
        else if (v15 == 2)
        {
          vDSP_vrampmul2(__A, __A + 1, 2, &__Start, &__Step, __A, __A + 1, 2, v13);
        }
        v6 += a4[7] * v13;
        if (v5 == v13) {
          int v18 = a1[1] + a1[3] * v5;
        }
        else {
          int v18 = a1[2];
        }
        a1[1] = v18;
        v5 -= v13;
      }
      if (v5)
      {
        float __Start = (float)(int)a1[2] * 0.000030518;
        vDSP_vsmul(v6, 1, &__Start, v6, 1, a4[7] * v5);
      }
    }
    else if ((v14 & 0xC) != 0 && a4[8] == 16)
    {
      if (v13)
      {
        LOWORD(__Start) = a1[1];
        LOWORD(__Step) = a1[3];
        int v17 = a4[7];
        if (v17 == 1)
        {
          vDSP_vrampmul_s1_15((const __int16 *)__A, 1, (__int16 *)&__Start, (const __int16 *)&__Step, (__int16 *)__A, 1, v13);
        }
        else if (v17 == 2)
        {
          vDSP_vrampmul2_s1_15((const __int16 *)__A, (const __int16 *)__A + 1, 2, (__int16 *)&__Start, (const __int16 *)&__Step, (__int16 *)__A, (__int16 *)__A + 1, 2, v13);
        }
        uint64_t v6 = (float *)((char *)v6 + 2 * a4[7] * v13);
        if (v5 == v13) {
          int v8 = a1[1] + a1[3] * v5;
        }
        else {
          int v8 = a1[2];
        }
        a1[1] = v8;
        v5 -= v13;
      }
      if (v5)
      {
        LOWORD(__Start) = v8;
        LOWORD(__Step) = 0;
        vDSP_vrampmul_s1_15((const __int16 *)v6, 1, (__int16 *)&__Start, (const __int16 *)&__Step, (__int16 *)v6, 1, a4[7] * v5);
      }
    }
  }
}

double sub_18478(void *a1, double a2)
{
  int v2 = a1 + 1;
  uint64_t v3 = a1[1];
  if (v3)
  {
    do
    {
      int v4 = (uint64_t *)(v3 + 8);
      if (*(double *)(v3 + 32) >= a2)
      {
        int v4 = (uint64_t *)v3;
        int v2 = (void *)v3;
      }
      uint64_t v3 = *v4;
    }
    while (*v4);
  }
  double v5 = *((double *)v2 + 4);
  int v6 = *((_DWORD *)v2 + 10);
  if (v2 == (void *)*a1)
  {
    int v10 = (void *)v2[1];
    if (v10)
    {
      do
      {
        int v8 = v10;
        int v10 = (void *)*v10;
      }
      while (v10);
    }
    else
    {
      do
      {
        int v8 = (void *)v2[2];
        BOOL v9 = *v8 == (void)v2;
        int v2 = v8;
      }
      while (!v9);
    }
  }
  else
  {
    uint64_t v7 = (void *)*v2;
    if (*v2)
    {
      do
      {
        int v8 = v7;
        uint64_t v7 = (void *)v7[1];
      }
      while (v7);
    }
    else
    {
      do
      {
        int v8 = (void *)v2[2];
        BOOL v9 = *v8 == (void)v2;
        int v2 = v8;
      }
      while (v9);
    }
  }
  float v11 = 1.0 / (double)(unint64_t)(a1[2] - 1);
  float v12 = v5;
  float v13 = *((double *)v8 + 4);
  return (a2 - v12) * (float)((float)(v11 * (float)*((int *)v8 + 10)) - (float)((float)v6 * v11)) / (float)(v13 - v12)
       + (float)((float)v6 * v11);
}

float sub_18574(float a1)
{
  int v1 = &qword_A1A00;
  uint64_t v2 = qword_A1A00;
  float v3 = 1.0 / (double)(unint64_t)(qword_A1A08 - 1);
  if (qword_A1A00)
  {
    signed int v4 = llroundf(a1 / v3);
    do
    {
      signed int v5 = *(_DWORD *)(v2 + 32);
      BOOL v6 = v5 < v4;
      if (v5 >= v4) {
        uint64_t v7 = (uint64_t *)v2;
      }
      else {
        uint64_t v7 = (uint64_t *)(v2 + 8);
      }
      if (!v6) {
        int v1 = (uint64_t *)v2;
      }
      uint64_t v2 = *v7;
    }
    while (*v7);
  }
  int v8 = *((_DWORD *)v1 + 8);
  double v9 = *((double *)v1 + 5);
  if (v1 == (uint64_t *)qword_A19F8)
  {
    float v13 = (uint64_t *)v1[1];
    if (v13)
    {
      do
      {
        float v11 = v13;
        float v13 = (uint64_t *)*v13;
      }
      while (v13);
    }
    else
    {
      do
      {
        float v11 = (uint64_t *)v1[2];
        BOOL v12 = *v11 == (void)v1;
        int v1 = v11;
      }
      while (!v12);
    }
  }
  else
  {
    uint64_t v10 = *v1;
    if (*v1)
    {
      do
      {
        float v11 = (uint64_t *)v10;
        uint64_t v10 = *(void *)(v10 + 8);
      }
      while (v10);
    }
    else
    {
      do
      {
        float v11 = (uint64_t *)v1[2];
        BOOL v12 = *v11 == (void)v1;
        int v1 = v11;
      }
      while (v12);
    }
  }
  float v14 = v9;
  float v15 = *((double *)v11 + 5);
  return (float)((float)((float)(a1 - (float)(v3 * (float)v8)) * (float)(v15 - v14))
               / (float)((float)(v3 * (float)*((int *)v11 + 8)) - (float)(v3 * (float)v8)))
       + v14;
}

float sub_1866C(float a1)
{
  double v1 = a1;
  sub_18F78(v3, (uint64_t)&qword_A1A10);
  *(float *)&double v1 = sub_18478(v3, v1);
  sub_18C7C((uint64_t)v3, (void *)v3[1]);
  return *(float *)&v1;
}

double sub_186C4(double a1, float a2)
{
  sub_18F78(v7, (uint64_t)&qword_A1A10);
  float v4 = sub_18478(v7, a1);
  sub_18C7C((uint64_t)v7, (void *)v7[1]);
  signed int v5 = qword_A19F0;
  if (os_log_type_enabled((os_log_t)qword_A19F0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134218752;
    double v9 = (float)(v4 / a2);
    __int16 v10 = 2048;
    double v11 = a1;
    __int16 v12 = 2048;
    double v13 = v4;
    __int16 v14 = 2048;
    double v15 = a2;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Calculated a volScalarFactor = %f given destVolDb = %f, destVolScalar = %f, currentVolScalar = %f", buf, 0x2Au);
  }
  return (float)(v4 / a2);
}

uint64_t sub_187D8(uint64_t a1, int *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  float v4 = (uint64_t *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 16 * a3;
    do
    {
      sub_18858((uint64_t **)a1, v4, a2, a2);
      a2 += 4;
      v6 -= 16;
    }
    while (v6);
  }
  return a1;
}

void sub_18840(_Unwind_Exception *a1)
{
  sub_18C7C(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_18858(uint64_t **a1, uint64_t *a2, int *a3, _OWORD *a4)
{
  uint64_t v10 = 0;
  double v11 = 0;
  uint64_t v6 = sub_188E4(a1, a2, &v11, &v10, a3);
  uint64_t v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    int v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_18A8C(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_188E4(void *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  signed int v5 = a1 + 1;
  if (a1 + 1 == a2 || (int v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    int v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      double v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        double v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      double v13 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v13[2];
        BOOL v14 = *v10 == (void)v13;
        double v13 = v10;
      }
      while (v14);
    }
    int v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          int v17 = (uint64_t *)v16;
          int v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *v17;
          signed int v5 = v17;
          if (!*v17) {
            goto LABEL_29;
          }
        }
        if (v18 >= v15) {
          break;
        }
        signed int v5 = v17 + 1;
        uint64_t v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      int v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  uint64_t v11 = a2[1];
  if (v11)
  {
    __int16 v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      __int16 v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    __int16 v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      BOOL v14 = *a4 == (void)v19;
      __int16 v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    uint64_t v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          int v21 = (uint64_t *)v20;
          int v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22) {
            break;
          }
          uint64_t v20 = *v21;
          signed int v5 = v21;
          if (!*v21) {
            goto LABEL_48;
          }
        }
        if (v22 >= v6) {
          break;
        }
        signed int v5 = v21 + 1;
        uint64_t v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      int v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t *sub_18A8C(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  signed int v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  os_log_t result = sub_18AE4(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_18AE4(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = (uint64_t *)a2[2];
      if (*((unsigned char *)v2 + 24)) {
        return result;
      }
      float v3 = (uint64_t *)v2[2];
      float v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (int v8 = *(unsigned __int8 *)(v7 + 24), v5 = (unsigned char *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            double v9 = (uint64_t **)a2[2];
          }
          else
          {
            double v9 = (uint64_t **)v2[1];
            uint64_t v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              _DWORD v10[2] = (uint64_t)v2;
              float v3 = (uint64_t *)v2[2];
            }
            void v9[2] = v3;
            *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = v9;
            *double v9 = v2;
            _DWORD v2[2] = (uint64_t)v9;
            float v3 = v9[2];
            uint64_t v2 = (uint64_t *)*v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v13 = v2[1];
          *float v3 = v13;
          if (v13) {
            *(void *)(v13 + 16) = v3;
          }
          _DWORD v2[2] = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (int v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          uint64_t v11 = a2[1];
          *uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            float v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(void *)(v2[2] + 8 * (*(void *)v2[2] != (void)v2)) = a2;
          a2[1] = (uint64_t)v2;
          _DWORD v2[2] = (uint64_t)a2;
          float v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        uint64_t v2 = (uint64_t *)v3[1];
        uint64_t v12 = *v2;
        v3[1] = *v2;
        if (v12) {
          *(void *)(v12 + 16) = v3;
        }
        _DWORD v2[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
        *uint64_t v2 = (uint64_t)v3;
LABEL_27:
        void v3[2] = (uint64_t)v2;
        return result;
      }
      *((unsigned char *)v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void sub_18C7C(uint64_t a1, void *a2)
{
  if (a2)
  {
    sub_18C7C(a1, *a2);
    sub_18C7C(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t sub_18CD0(uint64_t a1, double *a2, uint64_t a3)
{
  *(void *)(a1 + 8) = 0;
  float v4 = (double *)(a1 + 8);
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = a1 + 8;
  if (a3)
  {
    uint64_t v6 = 16 * a3;
    do
    {
      sub_18D50((uint64_t **)a1, v4, a2, a2);
      a2 += 2;
      v6 -= 16;
    }
    while (v6);
  }
  return a1;
}

void sub_18D38(_Unwind_Exception *a1)
{
  sub_18C7C(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_18D50(uint64_t **a1, double *a2, double *a3, _OWORD *a4)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v6 = sub_18DDC(a1, a2, &v11, (double *)&v10, a3);
  uint64_t v7 = *(uint64_t **)v6;
  if (!*(void *)v6)
  {
    int v8 = (uint64_t **)v6;
    uint64_t v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_18A8C(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

double *sub_18DDC(void *a1, double *a2, double **a3, double *a4, double *a5)
{
  signed int v5 = (double *)(a1 + 1);
  if (a1 + 1 == (void *)a2 || (double v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    int v8 = *(uint64_t **)a2;
    if ((double *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      double v9 = *(uint64_t **)a2;
      do
      {
        uint64_t v10 = (double *)v9;
        double v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v10 = (double *)*((void *)v13 + 2);
        BOOL v14 = *(void *)v10 == (void)v13;
        uint64_t v13 = v10;
      }
      while (v14);
    }
    double v15 = *a5;
    if (v10[4] < *a5) {
      goto LABEL_17;
    }
    uint64_t v16 = *(double **)v5;
    if (*(void *)v5)
    {
      do
      {
        while (1)
        {
          int v17 = v16;
          double v18 = v16[4];
          if (v15 >= v18) {
            break;
          }
          uint64_t v16 = *(double **)v16;
          signed int v5 = v17;
          if (!*(void *)v17) {
            goto LABEL_43;
          }
        }
        if (v18 >= v15) {
          break;
        }
        signed int v5 = v16 + 1;
        uint64_t v16 = (double *)*((void *)v16 + 1);
      }
      while (v16);
      goto LABEL_43;
    }
LABEL_42:
    int v17 = (double *)(a1 + 1);
LABEL_43:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *(void *)a4 = a2;
    return a4;
  }
  uint64_t v11 = *((void *)a2 + 1);
  if (v11)
  {
    uint64_t v12 = (double *)*((void *)a2 + 1);
    do
    {
      a4 = v12;
      uint64_t v12 = *(double **)v12;
    }
    while (v12);
  }
  else
  {
    __int16 v19 = a2;
    do
    {
      a4 = (double *)*((void *)v19 + 2);
      BOOL v14 = *(void *)a4 == (void)v19;
      __int16 v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    uint64_t v20 = *(double **)v5;
    if (*(void *)v5)
    {
      do
      {
        while (1)
        {
          int v17 = v20;
          double v21 = v20[4];
          if (v6 >= v21) {
            break;
          }
          uint64_t v20 = *(double **)v20;
          signed int v5 = v17;
          if (!*(void *)v17) {
            goto LABEL_43;
          }
        }
        if (v21 >= v6) {
          break;
        }
        signed int v5 = v20 + 1;
        uint64_t v20 = (double *)*((void *)v20 + 1);
      }
      while (v20);
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t *sub_18F78(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_18FD0(a1, *(double **)a2, (double *)(a2 + 8));
  return a1;
}

void sub_18FB8(_Unwind_Exception *a1)
{
  sub_18C7C(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_18FD0(uint64_t *result, double *a2, double *a3)
{
  if (a2 != a3)
  {
    float v4 = a2;
    signed int v5 = (uint64_t **)result;
    double v6 = (double *)(result + 1);
    do
    {
      os_log_t result = sub_18D50(v5, v6, v4 + 4, (_OWORD *)v4 + 2);
      double v7 = (double *)*((void *)v4 + 1);
      if (v7)
      {
        do
        {
          int v8 = v7;
          double v7 = *(double **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          int v8 = (double *)*((void *)v4 + 2);
          BOOL v9 = *(void *)v8 == (void)v4;
          float v4 = v8;
        }
        while (!v9);
      }
      float v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t sub_1905C()
{
  qword_A19F0 = (uint64_t)os_log_create("com.apple.bluetooth", "BTAudio");
  memcpy(__dst, &unk_71268, sizeof(__dst));
  sub_187D8((uint64_t)&qword_A19F8, (int *)__dst, 17);
  __cxa_atexit((void (*)(void *))sub_17E34, &qword_A19F8, &dword_0);
  memcpy(__dst, &unk_71378, sizeof(__dst));
  sub_18CD0((uint64_t)&qword_A1A10, __dst, 17);
  return __cxa_atexit((void (*)(void *))sub_17E60, &qword_A1A10, &dword_0);
}

void sub_191D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_192D4(uint64_t a1)
{
  v12[0] = kMXSystemControllerNotification_NowPlayingAppDidChange;
  v12[1] = kMXSystemControllerNotification_ActiveAudioRouteDidChange;
  v12[2] = kMXSystemControllerNotification_SystemVolumeDidChange;
  v12[3] = kMXSystemControllerNotification_PickableRoutesDidChange;
  uint64_t v2 = +[NSArray arrayWithObjects:v12 count:4];
  *(void *)(*(void *)(a1 + 32) + 96) = 0;
  *(void *)(*(void *)(a1 + 32) + 152) = 0;
  *(unsigned char *)(*(void *)(a1 + 32) + 88) = 0;
  *(void *)(*(void *)(a1 + 32) + 80) = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:2];
  *(void *)(*(void *)(a1 + 32) + 112) = [objc_alloc((Class)NSMutableSet) initWithCapacity:2];
  unsigned int v3 = [*(id *)(*(void *)(a1 + 32) + 104) setAttributeForKey:kMXSystemControllerProperty_SubscribeToNotifications andValue:v2];
  if (v3)
  {
    float v4 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 67109120;
      unsigned int v9 = v3;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: Subscribe to notification failed code: %d", (uint8_t *)&v8, 8u);
    }

    *(void *)(*(void *)(a1 + 32) + 104) = 0;
  }
  if (*(void *)(*(void *)(a1 + 32) + 104))
  {
    signed int v5 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
    {
      pid_t v6 = getpid();
      int v8 = 67109376;
      unsigned int v9 = v3;
      __int16 v10 = 1024;
      pid_t v11 = v6;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: Initialization via  %d PID %d", (uint8_t *)&v8, 0xEu);
    }
    CMSessionGetNotificationCenter();
    FigNotificationCenterAddWeakListener();
    CMSessionGetNotificationCenter();
    FigNotificationCenterAddWeakListener();
    double v7 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: Add listener (kMXSystemControllerNotification_SystemVolumeDidChange)", (uint8_t *)&v8, 2u);
    }
    CMSessionGetNotificationCenter();
    FigNotificationCenterAddWeakListener();
    if (_os_feature_enabled_impl())
    {
      CMSessionGetNotificationCenter();
      FigNotificationCenterAddWeakListener();
    }
  }
}

void sub_195C4(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  if ([a3 isEqualToString:kMXSystemControllerNotification_NowPlayingAppDidChange])
  {
    id v8 = [a5 objectForKey:kMXSystemControllerNotificationKey_NowPlayingAppDidChange_DisplayID];
    [a2 nowPlayingAppChanged:v8];
    return;
  }
  if ([a3 isEqualToString:kMXSystemControllerNotification_ActiveAudioRouteDidChange])
  {
    if ([a2 isRouteAvailable])
    {
      if (![a2 nowPlayingBundleID])
      {
        [a2 refreshNowPlayingAppBundleID];
        if ([a2 nowPlayingBundleID])
        {
          [a2 unregisterRouteChangeListener];
        }
      }
    }
    return;
  }
  if ([a3 isEqualToString:kMXSystemControllerNotification_PickableRoutesDidChange])
  {
    if ([a2 isRouteAvailable])
    {
      [a2 choosePickableRoute];
    }
    return;
  }
  if (![a3 isEqualToString:kMXSystemControllerNotification_SystemVolumeDidChange]) {
    return;
  }
  id v9 = [a5 objectForKey:kMXSystemControllerNotificationKey_SystemVolumeDidChange_Volume];
  id v10 = [a5 objectForKey:kMXSystemControllerNotificationKey_SystemVolumeDidChange_AudioCategory];
  id v11 = [a5 objectForKey:kMXSystemControllerNotificationKey_SystemVolumeDidChange_ActiveAudioCategory];
  [a2 setCurrentActiveVolumeAudioCategory:v11];
  id v12 = [a5 objectForKey:kMXSystemControllerNotificationKey_SystemVolumeDidChange_SequenceNumber];
  uint64_t v13 = kMXSystemControllerNotificationKey_SystemVolumeDidChange_SilenceVolumeHUD;
  id v14 = [a5 objectForKey:kMXSystemControllerNotificationKey_SystemVolumeDidChange_SilenceVolumeHUD];
  [a2 setIsPersonalizedVolumeUpdate:v14];
  double v15 = qword_A1A28;
  if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = 138413314;
    id v23 = v9;
    __int16 v24 = 2112;
    id v25 = v10;
    __int16 v26 = 2112;
    id v27 = v12;
    __int16 v28 = 2112;
    id v29 = v14;
    __int16 v30 = 2112;
    id v31 = v11;
    _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: kMXSystemControllerNotification_SystemVolumeDidChange : volume %@, audio category %@, sequenceNumber %@, isPersonalizedVolumeUpdate %@ activeAudioCategory: %@", (uint8_t *)&v22, 0x34u);
  }
  id v16 = [a5 objectForKey:kMXSystemControllerNotificationKey_SystemVolumeDidChange_Reason];
  id v17 = [a5 objectForKey:v13];
  if (!_os_feature_enabled_impl())
  {
    uint64_t v20 = qword_A1A28;
    if (!os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v22) = 0;
    double v21 = "Error: PersonalizedVolumeV2 feature flag is not enabled";
    goto LABEL_35;
  }
  if (![v16 isEqualToString:@"ExplicitVolumeChange"]
    || !objc_msgSend(v17, "isEqualToNumber:", +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 0))|| (objc_msgSend(v11, "isEqualToString:", kMXSessionAudioCategory_PhoneCall) & 1) == 0&& (objc_msgSend(v11, "isEqualToString:", kMXSessionAudioCategory_AudioVideo) & 1) == 0&& !objc_msgSend(v11, "isEqualToString:", kMXSessionAudioCategory_VoiceCommand)|| !objc_msgSend(a2, "isBluetoothRoute"))
  {
    return;
  }
  if (!objc_msgSend(objc_msgSend(a2, "processManualVolumeUpdates"), "BOOLValue"))
  {
    uint64_t v20 = qword_A1A28;
    if (!os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    LOWORD(v22) = 0;
    double v21 = "Error: PersonalizedVolumeV2 processManualVolumeUpdates is disabled";
LABEL_35:
    _os_log_impl(&dword_0, v20, OS_LOG_TYPE_DEFAULT, v21, (uint8_t *)&v22, 2u);
    return;
  }
  if (([v14 BOOLValue] & 1) == 0)
  {
    if ([a2 isVolumeUpdateToAccessoryRequired:v12]) {
      CFStringRef v18 = @"Top-Down";
    }
    else {
      CFStringRef v18 = @"Bottom-Up";
    }
    [a2 setReasonForManualVolumeUpdate:v18];
    [v9 floatValue];
    [a2 sendManualVolumeUpdate:(int)(float)(v19 * 100.0)];
  }
}

void sub_19C2C(uint64_t a1)
{
  id v2 = [objc_alloc((Class)NSNumber) initWithUnsignedInt:*(unsigned int *)(a1 + 40)];
  if (v2)
  {
    unsigned int v3 = v2;
    float v4 = *(void **)(*(void *)(a1 + 32) + 112);
    if (!v4)
    {
      *(void *)(*(void *)(a1 + 32) + 112) = [objc_alloc((Class)NSMutableSet) initWithCapacity:2];
      float v4 = *(void **)(*(void *)(a1 + 32) + 112);
    }
    [v4 addObject:v3];
  }
  signed int v5 = qword_A1A28;
  if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 40);
    v7[0] = 67109120;
    v7[1] = v6;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: Registering for volume change Device %d", (uint8_t *)v7, 8u);
  }
}

void sub_19DA0(uint64_t a1)
{
  id v2 = [objc_alloc((Class)NSNumber) initWithUnsignedInt:*(unsigned int *)(a1 + 40)];
  if (v2)
  {
    unsigned int v3 = v2;
    [*(id *)(*(void *)(a1 + 32) + 112) removeObject:v2];
  }
  float v4 = qword_A1A28;
  if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 40);
    v6[0] = 67109120;
    v6[1] = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: Unregistering for volume change Device %d", (uint8_t *)v6, 8u);
  }
}

void sub_19F2C(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(a1 + 40));
  if (Weak)
  {
    id v16 = 0;
    [Weak copyAttributeForKey:kMXSystemControllerProperty_PickedRoute withValueOut:&v16];
    unsigned int v3 = qword_A1A28;
    BOOL v4 = os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT);
    uint64_t v5 = kMXSession_RouteDescriptionKey_AVAudioRouteName;
    if (v4)
    {
      id v6 = [v16 objectForKeyedSubscript:kMXSession_RouteDescriptionKey_AVAudioRouteName];
      *(_DWORD *)std::string buf = 138412290;
      id v18 = v6;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor:Av audio route name %@", buf, 0xCu);
    }
    if ((objc_msgSend(@"HeadphonesBT", "isEqualToString:", objc_msgSend(v16, "objectForKeyedSubscript:", v5)) & 1) != 0|| objc_msgSend(@"HeadsetBT", "isEqualToString:", objc_msgSend(v16, "objectForKeyedSubscript:", v5)))
    {
      id v7 = [v16 objectForKeyedSubscript:kMXSession_RouteDescriptionKey_RouteUID];
      id v8 = v7;
      if (v7)
      {
        id v9 = [v7 componentsSeparatedByString:@"-"];
        id v10 = *(void **)(*(void *)(a1 + 32) + 152);
        if (v10)
        {

          *(void *)(*(void *)(a1 + 32) + 152) = 0;
        }
        *(void *)(*(void *)(a1 + 32) + 152) = objc_msgSend(objc_msgSend(v9, "firstObject"), "copy");
      }
    }
    else
    {
      id v11 = *(void **)(*(void *)(a1 + 32) + 152);
      if (v11)
      {

        id v8 = 0;
        *(void *)(*(void *)(a1 + 32) + 152) = 0;
      }
      else
      {
        id v8 = 0;
      }
    }
    id v12 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(a1 + 32);
      uint64_t v14 = *(void *)(v13 + 152);
      uint64_t v15 = *(void *)(v13 + 120);
      *(_DWORD *)std::string buf = 138413058;
      id v18 = v8;
      __int16 v19 = 2112;
      uint64_t v20 = v14;
      __int16 v21 = 2112;
      uint64_t v22 = v15;
      __int16 v23 = 2112;
      id v24 = v16;
      _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "Pickable routes for routeUid %@ _currentDeviceUID %@ _currentActiveVolumeAudioCategory %@ (current category is <%@>):", buf, 0x2Au);
    }
  }
}

void sub_1A1C8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    id v3 = objc_msgSend(objc_msgSend(v2, "componentsSeparatedByString:", @"-"), "firstObject");
    if (![*(id *)(*(void *)(a1 + 40) + 80) objectForKey:v3])
    {
      BOOL v4 = qword_A1A28;
      if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
      {
        int v5 = *(_DWORD *)(a1 + 48);
        int v15 = 138412546;
        id v16 = v3;
        __int16 v17 = 1024;
        int v18 = v5;
        _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Creating _btAudioDeviceDict entry for %@ Device ID %u: ", (uint8_t *)&v15, 0x12u);
      }
      id v6 = [[BTAudioPersonalizedVolumeDevice alloc] initWithBluetoothInfo:*(unsigned int *)(a1 + 48) deviceAddr:v3];
      [(BTAudioPersonalizedVolumeDevice *)v6 setAvNotificationMonitorQueue:*(void *)(*(void *)(a1 + 40) + 168)];
      [*(id *)(*(void *)(a1 + 40) + 80) setObject:v6 forKey:v3];
    }
  }
  else
  {
    id v7 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_ERROR)) {
      sub_651F0(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
}

void sub_1A408(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    id v3 = objc_msgSend(objc_msgSend(v2, "componentsSeparatedByString:", @"-"), "firstObject");
    id v4 = [*(id *)(*(void *)(a1 + 40) + 80) objectForKey:v3];
    if (v4)
    {
      int v5 = v4;
      [*(id *)(*(void *)(a1 + 40) + 80) removeObjectForKey:v3];
      id v6 = qword_A1A28;
      if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = 138412546;
        id v16 = v3;
        __int16 v17 = 1024;
        unsigned int v18 = [v5 retainCount];
        _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "unRegisterPersonalizedVolumeListener %@ lookupDevice retainCount %d", (uint8_t *)&v15, 0x12u);
      }
      [v5 invalidate];
    }
  }
  else
  {
    id v7 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_ERROR)) {
      sub_651F0(v7, v8, v9, v10, v11, v12, v13, v14);
    }
  }
}

NSNumber *sub_1A5FC(uint64_t a1)
{
  if (_os_feature_enabled_impl())
  {
    uint64_t v2 = *(unsigned __int8 *)(a1 + 40);
  }
  else
  {
    id v3 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v5 = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Error: PersonalizedVolumeV2 feature flag is not enabled", v5, 2u);
    }
    uint64_t v2 = 0;
  }
  os_log_t result = +[NSNumber numberWithBool:v2];
  *(void *)(*(void *)(a1 + 32) + 128) = result;
  return result;
}

id sub_1A814(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) getPersonalizedVolumeDevice:*(void *)(a1 + 40)];
  if (result)
  {
    id v3 = result;
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = [*(id *)(a1 + 56) BOOLValue] ^ 1;
    return [v3 NotifyManualVolumeChanged:v4 shouldUpdateBuds:v5];
  }
  return result;
}

void sub_1A8FC(uint64_t a1)
{
  id v2 = [objc_alloc((Class)NSNumber) initWithUnsignedInt:*(unsigned int *)(a1 + 40)];
  if (v2)
  {
    id v3 = v2;
    uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 112);
    if (!v4)
    {
      *(void *)(*(void *)(a1 + 32) + 112) = [objc_alloc((Class)NSMutableSet) initWithCapacity:2];
      uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 112);
    }
    [v4 addObject:v3];
  }
  uint64_t v5 = qword_A1A28;
  if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)(a1 + 40);
    unsigned int v7 = [*(id *)(*(void *)(a1 + 32) + 112) count];
    v8[0] = 67109376;
    v8[1] = v6;
    __int16 v9 = 1024;
    unsigned int v10 = v7;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: Registering Device %d List %d", (uint8_t *)v8, 0xEu);
  }
}

void sub_1AAE8(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(a1 + 40));
  if (Weak)
  {
    float v9 = 0.0;
    uint64_t v8 = 0;
    LODWORD(v3) = *(_DWORD *)(a1 + 56);
    [Weak performVolumeOperation:4 volume:0 category:0 mode:@"HeadphonesBT" routeName:*(void *)(a1 + 48) routeDeviceIdentifier:0 routeSubtype:v3 outVolume:&v9 outSequenceNumber:&v8 outMuted:0 outCategoryCopy:0 outModeCopy:0];
    if (!*(void *)(*(void *)(a1 + 32) + 72)) {
      *(void *)(*(void *)(a1 + 32) + 72) = objc_alloc_init((Class)NSMutableArray);
    }
    uint64_t v4 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
    {
      *(double *)&uint64_t v5 = COERCE_DOUBLE(+[NSNumber numberWithLongLong:v8]);
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 72);
      *(_DWORD *)std::string buf = 138412546;
      double v11 = *(double *)&v5;
      __int16 v12 = 2112;
      uint64_t v13 = v6;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: adding sequence num: %@ sequeneArray %@", buf, 0x16u);
    }
    objc_msgSend(*(id *)(*(void *)(a1 + 32) + 72), "addObject:", +[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", v8));
    CFRelease(*(CFTypeRef *)(a1 + 48));
    unsigned int v7 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      double v11 = v9;
      _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "software volume: CM Volume: %f", buf, 0xCu);
    }
  }
}

void sub_1AD8C(uint64_t a1)
{
  id Weak = objc_loadWeak((id *)(a1 + 32));
  if (Weak)
  {
    double v3 = Weak;
    uint64_t v4 = qword_A1A28;
    if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
    {
      double v8 = *(float *)(a1 + 48);
      double v9 = *(float *)(a1 + 52);
      double v10 = *(float *)(a1 + 56);
      double v11 = *(float *)(a1 + 60);
      double v12 = *(float *)(a1 + 64);
      *(_DWORD *)std::string buf = 138414082;
      CFStringRef v20 = @"Audio/Video";
      __int16 v21 = 2048;
      double v22 = v8;
      __int16 v23 = 2112;
      CFStringRef v24 = @"PhoneCall";
      __int16 v25 = 2048;
      double v26 = v9;
      __int16 v27 = 2112;
      CFStringRef v28 = @"VoiceCommand";
      __int16 v29 = 2048;
      double v30 = v10;
      __int16 v31 = 2048;
      double v32 = v11;
      __int16 v33 = 2048;
      double v34 = v12;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Adaptive Volume: Category %@ mediaVolume %f, Category %@ telephoneVolume %f, Category %@ voiceCommandVolume %f, rampUpDuration %f, rampDownDuration %f", buf, 0x52u);
    }
    LODWORD(v5) = *(_DWORD *)(a1 + 48);
    LODWORD(v6) = *(_DWORD *)(a1 + 60);
    LODWORD(v7) = *(_DWORD *)(a1 + 64);
    [v3 performVolumeOperation:12 volume:@"Audio/Video" category:0 mode:@"HeadphonesBT" routeName:*(void *)(a1 + 40) routeDeviceIdentifier:0 routeSubtype:v5 rampUpDuration:v6 rampDownDuration:v7 outVolume:0 outSequenceNumber:0 outMuted:0 outCategoryCopy:0 outModeCopy:0];
    LODWORD(v13) = *(_DWORD *)(a1 + 52);
    LODWORD(v14) = *(_DWORD *)(a1 + 60);
    LODWORD(v15) = *(_DWORD *)(a1 + 64);
    [v3 performVolumeOperation:12 volume:@"PhoneCall" category:0 mode:@"HeadphonesBT" routeName:*(void *)(a1 + 40) routeDeviceIdentifier:0 routeSubtype:v13 rampUpDuration:v14 rampDownDuration:v15 outVolume:0 outSequenceNumber:0 outMuted:0 outCategoryCopy:0 outModeCopy:0];
    LODWORD(v16) = *(_DWORD *)(a1 + 56);
    LODWORD(v17) = *(_DWORD *)(a1 + 60);
    LODWORD(v18) = *(_DWORD *)(a1 + 64);
    [v3 performVolumeOperation:12 volume:@"VoiceCommand" category:0 mode:@"HeadphonesBT" routeName:*(void *)(a1 + 40) routeDeviceIdentifier:0 routeSubtype:v16 rampUpDuration:v17 rampDownDuration:v18 outVolume:0 outSequenceNumber:0 outMuted:0 outCategoryCopy:0 outModeCopy:0];
    CFRelease(*(CFTypeRef *)(a1 + 40));
  }
}

void sub_1AFEC(uint64_t a1)
{
  id v2 = [objc_alloc((Class)NSNumber) initWithUnsignedInt:*(unsigned int *)(a1 + 40)];
  if (v2)
  {
    double v3 = v2;
    [*(id *)(*(void *)(a1 + 32) + 112) removeObject:v2];
  }
  uint64_t v4 = qword_A1A28;
  if (os_log_type_enabled((os_log_t)qword_A1A28, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 40);
    unsigned int v6 = [*(id *)(*(void *)(a1 + 32) + 112) count];
    v7[0] = 67109376;
    v7[1] = v5;
    __int16 v8 = 1024;
    unsigned int v9 = v6;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTAudioAVNotificationMonitor: Un-Registering Device %d List %d", (uint8_t *)v7, 0xEu);
  }
}

uint64_t sub_1B718()
{
  qword_A1A28 = (uint64_t)os_log_create("com.apple.bluetooth", "BTAudio");
  sub_5CC80(&unk_A1A30, v0);

  return __cxa_atexit((void (*)(void *))sub_5CD00, &unk_A1A30, &dword_0);
}

uint64_t sub_1B78C(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  unint64_t v5 = a5[1];
  unint64_t v6 = *((unsigned int *)a5 + 8);
  unint64_t v7 = v5 / v6;
  if (*a2 < (v5 / v6)) {
    LODWORD(v7) = *a2;
  }
  if (v7)
  {
    uint64_t result = 0;
    uint64_t v9 = (v7 * v6);
    *a2 = v7;
    uint64_t v10 = *a5;
    int v11 = *((_DWORD *)a5 + 11);
    *a5 += v9;
    a5[1] = v5 - v9;
  }
  else
  {
    uint64_t v10 = 0;
    LODWORD(v9) = 0;
    *a2 = 0;
    int v11 = *((_DWORD *)a5 + 11);
    uint64_t result = 1684368995;
  }
  *(void *)(a3 + 16) = v10;
  *(_DWORD *)(a3 + 8) = v11;
  *(_DWORD *)(a3 + 12) = v9;
  return result;
}

uint64_t sub_1B7F0(uint64_t a1, _DWORD *a2, uint64_t a3, void *a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a5 + 8);
  if (v5
    || ((int v6 = *(_DWORD *)(a5 + 32), (v6 - 1633772389) >= 3) ? (v7 = v6 == 1818440480) : (v7 = 1), v7))
  {
    *a2 = 1;
    *(void *)(a3 + 16) = *(void *)a5;
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a5 + 52);
    *(_DWORD *)(a3 + 12) = v5;
    if (a4) {
      *a4 = *(void *)(a5 + 64);
    }
    uint64_t v9 = 0;
    *(void *)(a5 + 8) = 0;
  }
  else
  {
    uint64_t v9 = 1684303459;
    *a2 = 0;
    uint64_t v10 = qword_A1A78;
    if (os_log_type_enabled((os_log_t)qword_A1A78, OS_LOG_TYPE_ERROR)) {
      sub_65228(v10);
    }
  }
  return v9;
}

BOOL sub_1B898(int a1)
{
  return (a1 - 1633772389) < 3 || a1 == 1818440480;
}

void sub_1B8C0(unsigned int a1, uint64_t a2)
{
  if (a1 && a1 != 1684303459 && a1 != 1684368995)
  {
    *(void *)uint64_t v9 = 0;
    uint64_t v10 = 0;
    int v11 = 0;
    int v4 = bswap32(a1);
    *(_DWORD *)&v9[1] = v4;
    if ((v4 & 0x80) != 0)
    {
      if (!__maskrune((char)v4, 0x40000uLL)) {
        goto LABEL_20;
      }
    }
    else if ((_DefaultRuneLocale.__runetype[(char)v4] & 0x40000) == 0)
    {
      goto LABEL_20;
    }
    __darwin_ct_rune_t v5 = (__int16)v4 >> 8;
    if ((v4 & 0x8000) != 0)
    {
      if (!__maskrune(v5, 0x40000uLL)) {
        goto LABEL_20;
      }
    }
    else if ((_DefaultRuneLocale.__runetype[v5] & 0x40000) == 0)
    {
      goto LABEL_20;
    }
    __darwin_ct_rune_t v6 = v4 << 8 >> 24;
    if ((v4 & 0x800000) != 0)
    {
      if (!__maskrune(v6, 0x40000uLL)) {
        goto LABEL_20;
      }
    }
    else if ((_DefaultRuneLocale.__runetype[v6] & 0x40000) == 0)
    {
      goto LABEL_20;
    }
    __darwin_ct_rune_t v7 = v4 >> 24;
    if (v4 < 0)
    {
      if (__maskrune(v7, 0x40000uLL)) {
        goto LABEL_18;
      }
    }
    else if ((_DefaultRuneLocale.__runetype[v7] & 0x40000) != 0)
    {
LABEL_18:
      strcpy(&v9[5], "'");
      v9[0] = 39;
      goto LABEL_21;
    }
LABEL_20:
    sprintf(v9, "%d", a1);
LABEL_21:
    __int16 v8 = qword_A1A78;
    if (os_log_type_enabled((os_log_t)qword_A1A78, OS_LOG_TYPE_ERROR)) {
      sub_6526C(a2, (uint64_t)v9, v8);
    }
  }
}

os_log_t sub_1BA60()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1A78 = (uint64_t)result;
  return result;
}

id sub_1BB38(uint64_t a1)
{
  DMIsMigrationNeeded();
  *(void *)(*(void *)(a1 + 32) + 16) = [objc_alloc((Class)IDSService) initWithService:@"com.apple.private.alloy.bluetooth.audio"];
  [*(id *)(*(void *)(a1 + 32) + 16) addDelegate:*(void *)(a1 + 32) queue:*(void *)(qword_A2350 + 160)];
  id v2 = &byte_9992A[30422];
  double v3 = qword_A1A80;
  if (os_log_type_enabled((os_log_t)qword_A1A80, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Initializing BTAudioIDSConnection", buf, 2u);
  }
  id v4 = [*(id *)(*(void *)(a1 + 32) + 16) devices];
  __darwin_ct_rune_t v5 = qword_A1A80;
  if (os_log_type_enabled((os_log_t)qword_A1A80, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [v4 count];
    *(_DWORD *)std::string buf = 134218242;
    id v34 = v6;
    __int16 v35 = 2112;
    id v36 = v4;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Current registered devices %lu. %@", buf, 0x16u);
  }
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id result = [v4 countByEnumeratingWithState:&v29 objects:v47 count:16];
  if (result)
  {
    id v9 = result;
    uint64_t v10 = *(void *)v30;
    *(void *)&long long v8 = 136316674;
    long long v24 = v8;
    uint64_t v25 = *(void *)v30;
    do
    {
      int v11 = 0;
      do
      {
        if (*(void *)v30 != v10) {
          objc_enumerationMutation(v4);
        }
        double v12 = *(void **)(*((void *)&v29 + 1) + 8 * (void)v11);
        double v13 = *((void *)v2 + 336);
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          id v28 = objc_msgSend(objc_msgSend(v12, "productName"), "UTF8String");
          id v27 = [v12 productBuildVersion];
          id v26 = objc_msgSend(objc_msgSend(v12, "service"), "UTF8String");
          double v14 = "false";
          if ([v12 isNearby]) {
            double v15 = "true";
          }
          else {
            double v15 = "false";
          }
          if (objc_msgSend(v12, "isConnected", v24)) {
            double v14 = "true";
          }
          double v16 = v2;
          id v17 = [v12 serviceMinCompatibilityVersion];
          unsigned int v18 = [*(id *)(a1 + 32) deviceIsCompatible:v12];
          *(_DWORD *)std::string buf = v24;
          __int16 v19 = "will not";
          if (v18) {
            __int16 v19 = "will";
          }
          id v34 = v28;
          __int16 v35 = 2112;
          id v36 = v27;
          __int16 v37 = 2080;
          id v38 = v26;
          __int16 v39 = 2080;
          char v40 = v15;
          __int16 v41 = 2080;
          char v42 = v14;
          __int16 v43 = 2048;
          id v44 = v17;
          id v2 = v16;
          uint64_t v10 = v25;
          __int16 v45 = 2080;
          xpc_object_t v46 = v19;
          _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "Device %s %@ is registered on service %s. Nearby: %s Connected: %s. ServiceMincompatibilityVersion: %lu. Device %s arbitrate", buf, 0x48u);
        }
        CFStringRef v20 = *(void **)(a1 + 32);
        if (objc_msgSend(v20, "compatibleAndNearby", v24))
        {
          id v21 = &dword_0 + 1;
        }
        else if ([*(id *)(a1 + 32) deviceIsCompatible:v12] {
               && [v12 isNearby])
        }
        {
          id v21 = [v12 isConnected];
        }
        else
        {
          id v21 = 0;
        }
        [v20 setCompatibleAndNearby:v21];
        double v22 = *(void **)(a1 + 32);
        if ([v22 compatibleAndConnected])
        {
          id v23 = &dword_0 + 1;
        }
        else if ([*(id *)(a1 + 32) deviceIsCompatible:v12] {
               && [v12 isNearby])
        }
        {
          id v23 = [v12 isConnected];
        }
        else
        {
          id v23 = 0;
        }
        [v22 setCompatibleAndConnected:v23];
        int v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id result = [v4 countByEnumeratingWithState:&v29 objects:v47 count:16];
      id v9 = result;
    }
    while (result);
  }
  return result;
}

void sub_1C600(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  if (a43 < 0) {
    operator delete(a38);
  }
  _Unwind_Resume(exception_object);
}

void sub_1C7BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1C8B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1C98C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_1CAB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_1CBE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
}

void sub_1D100(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,int a46,__int16 a47,char a48,char a49)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (*(char *)(v49 - 89) < 0) {
    operator delete(*(void **)(v49 - 112));
  }
  _Unwind_Resume(exception_object);
}

void sub_1D754(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

os_log_t sub_1D774()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1A80 = (uint64_t)result;
  return result;
}

uint64_t sub_1D7A4(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(_DWORD *)(a1 + 16) = -1024458752;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_DWORD *)(a1 + 56) = -1024458752;
  *(void *)(a1 + 64) = 0;
  id v4 = qword_A1A88;
  if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Creating audio level", v6, 2u);
  }
  *(void *)(a1 + 72) = a2;
  return a1;
}

double sub_1D848(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2 && (*(unsigned int (**)(uint64_t))(*(void *)v2 + 1296))(v2))
  {
    if (*(void *)(*(void *)(a1 + 72) + 216))
    {
      *(void *)(a1 + 64) = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(_DWORD *)(a1 + 16) = -1024458752;
      double result = 0.0;
      *(_OWORD *)(a1 + 24) = 0u;
      *(_OWORD *)(a1 + 40) = 0u;
      *(_DWORD *)(a1 + 56) = -1024458752;
    }
  }
  return result;
}

void sub_1D8CC(uint64_t a1, unsigned int a2, const float *a3)
{
  float __C = 0.0;
  uint64_t v4 = *(void *)(a1 + 72);
  if (v4 && (*(unsigned int (**)(uint64_t))(*(void *)v4 + 1296))(v4))
  {
    if (a2 - 1921 > 0xFFFFF87F)
    {
      if (a3)
      {
        if (sub_7C98(*(void *)(a1 + 72)) == 1952539500)
        {
          (*(void (**)(double *__return_ptr))(**(void **)(a1 + 72) + 800))(&v28);
          double v7 = v28;
          long long v33 = v29;
          vDSP_Stride v8 = v31;
          int v34 = v30;
          uint64_t v9 = v32;
          unsigned int v10 = (v28 / (double)a2);
          if (v10 >= 4) {
            unsigned int v11 = v10 >> 2;
          }
          else {
            unsigned int v11 = 2;
          }
          unsigned int v12 = *(_DWORD *)(a1 + 4) + a2;
          unsigned int v13 = *(_DWORD *)a1 + 1;
          *(_DWORD *)a1 = v13;
          *(_DWORD *)(a1 + 4) = v12;
          if (!(v13 % v11))
          {
            vDSP_svesq(a3, v8, &__C, a2);
            float v14 = (float)(__C / (float)a2) + 1.0e-12;
            float v15 = log10f(v14) * 10.0;
            *(float *)(a1 + 12) = *(float *)(a1 + 12) + v15;
            *(_DWORD *)(a1 + 8) += a2;
            if (v15 <= -119.9) {
              *(void *)(a1 + 64) += v11 * a2;
            }
            else {
              *(void *)(a1 + 64) = 0;
            }
          }
          uint64_t v16 = *(unsigned int *)(a1 + 4);
          if (v7 * 0.25 <= (double)v16)
          {
            float v17 = *(float *)(a1 + 12) / (float)(*(_DWORD *)a1 / v11);
            *(float *)(a1 + 16) = v17;
            uint64_t v18 = *(unsigned int *)(a1 + 8);
            __int16 v19 = *(NSObject **)(qword_A2350 + 184);
            v20[0] = _NSConcreteStackBlock;
            v20[1] = 3221225472;
            void v20[2] = sub_1DB94;
            v20[3] = &unk_8DFE0;
            float v25 = v17;
            unsigned int v26 = v11;
            unsigned int v27 = v10;
            v20[4] = v18;
            v20[5] = v16;
            *(double *)&v20[6] = v7;
            long long v21 = v33;
            int v22 = v34;
            int v23 = v8;
            uint64_t v24 = v9;
            dispatch_async(v19, v20);
            *(void *)a1 = 0;
            *(void *)(a1 + 8) = 0;
            *(_DWORD *)(a1 + 16) = -1024458752;
            *(void *)(a1 + 24) = 0;
          }
        }
      }
      else if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_ERROR))
      {
        sub_65478();
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_ERROR))
    {
      sub_65444();
    }
  }
}

double sub_1DB94(uint64_t a1)
{
  uint64_t v2 = qword_A1A88;
  if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_DEFAULT))
  {
    double v4 = *(float *)(a1 + 88);
    int v5 = *(_DWORD *)(a1 + 92);
    int v6 = *(_DWORD *)(a1 + 96);
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    int v10 = 134219264;
    double v11 = v4;
    __int16 v12 = 1024;
    int v13 = v5;
    __int16 v14 = 1024;
    int v15 = v6;
    __int16 v16 = 2048;
    uint64_t v17 = v7;
    __int16 v18 = 2048;
    uint64_t v19 = v8;
    __int16 v20 = 2048;
    uint64_t v21 = v9;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BTAudioDetect virtual avgPwr %fdB,intv %u/%u,processed %llu,delivered %llu,rate %f", (uint8_t *)&v10, 0x36u);
  }
  return result;
}

void sub_1DC78(uint64_t a1, uint64_t a2, const float *a3, uint64_t a4)
{
  __C[0] = 0.0;
  if (sub_5CB00())
  {
    uint64_t v8 = *(void *)(a1 + 72);
    if (v8)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 1296))(v8))
      {
        if (a3)
        {
          uint64_t v9 = *(void *)(a1 + 72);
          if (*(void *)(v9 + 224))
          {
            if ((unint64_t)(a2 - 7681) > 0xFFFFFFFFFFFFE1FFLL)
            {
              if (a4 && sub_7C98(v9) == 1953719151)
              {
                (*(void (**)(double *__return_ptr))(**(void **)(a1 + 72) + 800))(&v34);
                double v11 = v34;
                long long v38 = v35;
                int v39 = v36;
                unsigned int v12 = *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 224) + 80);
                if (v12)
                {
                  vDSP_Stride v13 = __IA[0];
                  vDSP_Length v14 = a2 / v12;
                  unsigned int v15 = (v34 / (double)v14);
                  uint64_t v16 = *(void *)&__IA[1];
                  if (v15 >= 4) {
                    unsigned int v17 = v15 >> 2;
                  }
                  else {
                    unsigned int v17 = 2;
                  }
                  unsigned int v18 = *(_DWORD *)(a1 + 44) + v14;
                  unsigned int v19 = *(_DWORD *)(a1 + 40) + 1;
                  *(_DWORD *)(a1 + 40) = v19;
                  *(_DWORD *)(a1 + 44) = v18;
                  *(void *)(a1 + 32) += a4;
                  if (!(v19 % v17))
                  {
                    vDSP_svesq(a3, v13, __C, v14);
                    float v20 = (float)(__C[0] / (float)v14) + 1.0e-12;
                    *(float *)(a1 + 52) = *(float *)(a1 + 52) + (float)(log10f(v20) * 10.0);
                    unsigned int v18 = *(_DWORD *)(a1 + 44);
                    *(_DWORD *)(a1 + 48) += v14;
                  }
                  if (v11 + v11 <= (double)v18)
                  {
                    float v21 = *(float *)(a1 + 52) / (float)(*(_DWORD *)(a1 + 40) / v17);
                    *(float *)(a1 + 56) = v21;
                    uint64_t v22 = *(unsigned int *)(a1 + 48);
                    uint64_t v23 = *(void *)(a1 + 32);
                    uint64_t v24 = *(NSObject **)(qword_A2350 + 184);
                    block[0] = _NSConcreteStackBlock;
                    block[1] = 3221225472;
                    block[2] = sub_1DF70;
                    block[3] = &unk_8E000;
                    float v31 = v21;
                    unsigned int v32 = v17;
                    unsigned int v33 = (v11 / (double)v14);
                    void block[4] = v22;
                    block[5] = v18;
                    *(double *)&void block[6] = v11;
                    long long v26 = v38;
                    int v27 = v39;
                    int v28 = v13;
                    uint64_t v29 = v16;
                    uint64_t v30 = v23;
                    dispatch_async(v24, block);
                    *(void *)(a1 + 40) = 0;
                    *(void *)(a1 + 48) = 0;
                    *(_DWORD *)(a1 + 56) = -1024458752;
                    *(void *)(a1 + 32) = 0;
                  }
                }
                else if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_ERROR))
                {
                  sub_65524();
                }
              }
            }
            else
            {
              int v10 = qword_A1A88;
              if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_ERROR)) {
                sub_654AC(a2, v10);
              }
            }
          }
        }
      }
    }
  }
}

double sub_1DF70(uint64_t a1)
{
  uint64_t v2 = qword_A1A88;
  if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_DEFAULT))
  {
    double v4 = *(float *)(a1 + 96);
    int v5 = *(_DWORD *)(a1 + 100);
    int v6 = *(_DWORD *)(a1 + 104);
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    uint64_t v10 = *(void *)(a1 + 88);
    int v11 = 134219520;
    double v12 = v4;
    __int16 v13 = 1024;
    int v14 = v5;
    __int16 v15 = 1024;
    int v16 = v6;
    __int16 v17 = 2048;
    uint64_t v18 = v7;
    __int16 v19 = 2048;
    uint64_t v20 = v8;
    __int16 v21 = 2048;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = v10;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BTAudioDetect Input avgPwr %fdB,intv %u/%u,processed %llu,delivered %llu,rate %f,encoded %zu", (uint8_t *)&v11, 0x40u);
  }
  return result;
}

void sub_1E060(uint64_t a1, unsigned int a2, const float *a3, uint64_t a4)
{
  float __C = 0.0;
  if (sub_5CB00())
  {
    uint64_t v8 = *(void *)(a1 + 72);
    if (v8)
    {
      if ((*(unsigned int (**)(uint64_t))(*(void *)v8 + 1296))(v8))
      {
        if (a2 - 1921 > 0xFFFFF87F)
        {
          if (a3)
          {
            if (sub_7C98(*(void *)(a1 + 72)) == 1953719151)
            {
              (*(void (**)(double *__return_ptr))(**(void **)(a1 + 72) + 800))(&v32);
              double v9 = v32;
              long long v37 = v33;
              vDSP_Stride v10 = v35;
              int v38 = v34;
              uint64_t v11 = v36;
              unsigned int v12 = (v32 / (double)a2);
              if (v12 >= 4) {
                unsigned int v13 = v12 >> 2;
              }
              else {
                unsigned int v13 = 2;
              }
              unsigned int v14 = *(_DWORD *)(a1 + 4) + a2;
              unsigned int v15 = *(_DWORD *)a1 + 1;
              *(_DWORD *)a1 = v15;
              *(_DWORD *)(a1 + 4) = v14;
              *(void *)(a1 + 24) += a4;
              if (!(v15 % v13))
              {
                vDSP_svesq(a3, v10, &__C, a2);
                float v16 = (float)(__C / (float)a2) + 1.0e-12;
                float v17 = log10f(v16) * 10.0;
                *(float *)(a1 + 12) = *(float *)(a1 + 12) + v17;
                *(_DWORD *)(a1 + 8) += a2;
                if (v17 <= -119.9) {
                  *(void *)(a1 + 64) += v13 * a2;
                }
                else {
                  *(void *)(a1 + 64) = 0;
                }
              }
              uint64_t v18 = *(unsigned int *)(a1 + 4);
              if (v9 * 0.25 <= (double)v18)
              {
                float v19 = *(float *)(a1 + 12) / (float)(*(_DWORD *)a1 / v13);
                *(float *)(a1 + 16) = v19;
                uint64_t v20 = *(unsigned int *)(a1 + 8);
                uint64_t v21 = *(void *)(a1 + 24);
                uint64_t v22 = *(NSObject **)(qword_A2350 + 184);
                block[0] = _NSConcreteStackBlock;
                block[1] = 3221225472;
                block[2] = sub_1E350;
                block[3] = &unk_8E000;
                float v29 = v19;
                unsigned int v30 = v13;
                unsigned int v31 = v12;
                void block[4] = v20;
                block[5] = v18;
                *(double *)&void block[6] = v9;
                long long v24 = v37;
                int v25 = v38;
                int v26 = v10;
                uint64_t v27 = v11;
                uint64_t v28 = v21;
                dispatch_async(v22, block);
                *(void *)a1 = 0;
                *(void *)(a1 + 8) = 0;
                *(_DWORD *)(a1 + 16) = -1024458752;
                *(void *)(a1 + 24) = 0;
              }
            }
          }
          else if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_ERROR))
          {
            sub_6558C();
          }
        }
        else if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_ERROR))
        {
          sub_65558();
        }
      }
    }
  }
}

double sub_1E350(uint64_t a1)
{
  uint64_t v2 = qword_A1A88;
  if (os_log_type_enabled((os_log_t)qword_A1A88, OS_LOG_TYPE_DEFAULT))
  {
    double v4 = *(float *)(a1 + 96);
    int v5 = *(_DWORD *)(a1 + 100);
    int v6 = *(_DWORD *)(a1 + 104);
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    uint64_t v10 = *(void *)(a1 + 88);
    int v11 = 134219520;
    double v12 = v4;
    __int16 v13 = 1024;
    int v14 = v5;
    __int16 v15 = 1024;
    int v16 = v6;
    __int16 v17 = 2048;
    uint64_t v18 = v7;
    __int16 v19 = 2048;
    uint64_t v20 = v8;
    __int16 v21 = 2048;
    uint64_t v22 = v9;
    __int16 v23 = 2048;
    uint64_t v24 = v10;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BTAudioDetect Output avgPwr %fdB,intv %u/%u,processed %llu,delivered %llu,rate %f,encoded %zu", (uint8_t *)&v11, 0x40u);
  }
  return result;
}

os_log_t sub_1E440()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1A88 = (uint64_t)result;
  return result;
}

void sub_1E470(uint64_t a1, int a2, int a3, int a4, uint64_t a5, uint64_t *a6, int a7)
{
  __int16 v13 = qword_A1A90;
  if (os_log_type_enabled((os_log_t)qword_A1A90, OS_LOG_TYPE_DEBUG))
  {
    if (*((char *)a6 + 23) < 0) {
      a6 = (uint64_t *)*a6;
    }
    v14[0] = 67110402;
    v14[1] = a2;
    __int16 v15 = 1024;
    int v16 = a3;
    __int16 v17 = 1024;
    int v18 = a4;
    __int16 v19 = 2048;
    uint64_t v20 = a5;
    __int16 v21 = 2080;
    uint64_t v22 = a6;
    __int16 v23 = 1024;
    int v24 = a7;
    _os_log_debug_impl(&dword_0, v13, OS_LOG_TYPE_DEBUG, "Sending arbitration metric - version: %d, productId: %d, action: %d, epoch: %llu, responseId: %s, type: %d", (uint8_t *)v14, 0x2Eu);
  }
}

void sub_1E580(uint64_t a1, int a2, int a3, int a4)
{
  uint64_t v7 = qword_A1A90;
  if (os_log_type_enabled((os_log_t)qword_A1A90, OS_LOG_TYPE_DEBUG))
  {
    v8[0] = 67109632;
    v8[1] = a2;
    __int16 v9 = 1024;
    int v10 = a3;
    __int16 v11 = 1024;
    int v12 = a4;
    _os_log_debug_impl(&dword_0, v7, OS_LOG_TYPE_DEBUG, "Sending codec metric - codecType: %d, mediaType: %d, [sampleRate: %d]", (uint8_t *)v8, 0x14u);
  }
}

void sub_1E648()
{
  uint64_t v0 = qword_A1A90;
  if (os_log_type_enabled((os_log_t)qword_A1A90, OS_LOG_TYPE_DEBUG)) {
    sub_655C0(v0);
  }
}

uint64_t sub_1E688()
{
  return 0;
}

os_log_t sub_1E690()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1A90 = (uint64_t)result;
  return result;
}

uint64_t sub_1E6C0(uint64_t a1, uint64_t a2, int a3, int a4)
{
  *(void *)sub_306F0(a1) = &off_8E030;
  uint64_t v8 = qword_A1A98;
  if (os_log_type_enabled((os_log_t)qword_A1A98, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = sub_308A8(a1);
    int v10 = "output";
    if (a3 == 1768845428) {
      int v10 = "input";
    }
    int v12 = 136446466;
    __int16 v13 = v10;
    __int16 v14 = 1024;
    int v15 = v9;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Creating %{public}s audio control with audioObjectID: %u", (uint8_t *)&v12, 0x12u);
  }
  *(void *)(a1 + 24) = a2;
  *(_DWORD *)(a1 + 12) = a3;
  *(_DWORD *)(a1 + 16) = a4;
  return a1;
}

void sub_1E7DC(_Unwind_Exception *a1)
{
  sub_307F8(v1);
  _Unwind_Resume(a1);
}

void sub_1E7F8(uint64_t a1)
{
  sub_307F8(a1);

  operator delete();
}

uint64_t sub_1E830(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 120))(*(void *)(a1 + 24), a1, a2);
}

uint64_t sub_1E860(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 24) + 128))(*(void *)(a1 + 24), a1, a2, a3);
}

uint64_t sub_1E894(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 24) + 136))(*(void *)(a1 + 24), a1, a2, a3, a4, a5);
}

uint64_t sub_1E8D0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 144))(*(void *)(a1 + 24), a1, a2);
}

uint64_t sub_1E900(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(a1 + 24) + 152))(*(void *)(a1 + 24), a1, a2, a3, a4, a5, a6, a7);
}

uint64_t sub_1E944(uint64_t a1, __int32 *a2)
{
  if (!a2) {
    return 1852797029;
  }
  uint64_t v3 = (**(uint64_t (***)(void, void, uint64_t, __int32 *))(qword_A2350 + 144))(*(void *)(qword_A2350 + 144), *(unsigned int *)(a1 + 8), 1, a2);
  if (v3)
  {
    double v4 = qword_A1A98;
    if (os_log_type_enabled((os_log_t)qword_A1A98, OS_LOG_TYPE_ERROR)) {
      sub_62708(a2, v4, v5);
    }
  }
  return v3;
}

os_log_t sub_1E9D4()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1A98 = (uint64_t)result;
  return result;
}

void sub_1EA04(uint64_t a1, int a2, uint64_t a3, char a4)
{
  long long v5 = *(_OWORD *)(a3 + 16);
  v7[0] = *(_OWORD *)a3;
  v7[1] = v5;
  uint64_t v8 = *(void *)(a3 + 32);
  sub_48758(a1, a2, (uint64_t)v7);
  *(void *)uint64_t v6 = off_8E098;
  *(unsigned char *)(v6 + 152) = 1;
  *(unsigned char *)(v6 + 161) = a4;
  *(void *)(v6 + 16) = 0;
}

void *sub_1EA70(void *a1)
{
  *a1 = off_8E098;
  uint64_t v2 = (OpaqueAudioConverter *)a1[2];
  if (v2)
  {
    AudioConverterDispose(v2);
  }
  else
  {
    uint64_t v3 = qword_A1AA0;
    if (os_log_type_enabled((os_log_t)qword_A1AA0, OS_LOG_TYPE_ERROR)) {
      sub_65604(v3);
    }
  }
  return sub_4879C(a1);
}

void sub_1EAF0(void *a1)
{
  sub_1EA70(a1);

  operator delete();
}

void sub_1EB28(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 116) = a2;
  if (*(unsigned char *)(a1 + 161))
  {
    uint64_t v3 = qword_A1AA0;
    if (os_log_type_enabled((os_log_t)qword_A1AA0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "LC3 decoder init to AACELD 48K", buf, 2u);
    }
    int v4 = 1633772389;
  }
  else
  {
    int v4 = 1818440480;
  }
  *(void *)(a1 + 24) = *(void *)(a1 + 64);
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 32) = v4;
  int v5 = *(_DWORD *)(a1 + 8) - 258;
  if (v5 <= 2) {
    *(_DWORD *)(a1 + 44) = dword_71500[v5];
  }
  int v6 = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = v6;
  *(void *)(a1 + 56) = 0;
  UInt32 ioPropertyDataSize = 40;
  OSStatus Property = AudioFormatGetProperty(0x666D7469u, 0, 0, &ioPropertyDataSize, (void *)(a1 + 64));
  sub_1B8C0(Property, (uint64_t)"couldn't get output data format");
  uint64_t v8 = qword_A1AA0;
  if (os_log_type_enabled((os_log_t)qword_A1AA0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = *(void *)(a1 + 24);
    int v10 = *(_DWORD *)(a1 + 32);
    int v11 = *(_DWORD *)(a1 + 36);
    int v12 = *(_DWORD *)(a1 + 40);
    int v13 = *(_DWORD *)(a1 + 44);
    int v14 = *(_DWORD *)(a1 + 48);
    int v15 = *(_DWORD *)(a1 + 52);
    int v16 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)std::string buf = 134219776;
    uint64_t v28 = v9;
    __int16 v29 = 1024;
    int v30 = v10;
    __int16 v31 = 1024;
    int v32 = v11;
    __int16 v33 = 1024;
    int v34 = v12;
    __int16 v35 = 1024;
    int v36 = v13;
    __int16 v37 = 1024;
    int v38 = v14;
    __int16 v39 = 1024;
    int v40 = v15;
    __int16 v41 = 1024;
    int v42 = v16;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Decoder intput format:  mSampleRate = %f, mFormatID = %u, mFormatFlags:%u, mBytesPerPacket:%u, mFramesPerPacket = %u, mBytesPerFrame:%u, mChannelsPerFrame = %u, mBitsPerChannel:%u, format = float PCM\n", buf, 0x36u);
    uint64_t v8 = qword_A1AA0;
  }
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = *(void *)(a1 + 64);
    int v18 = *(_DWORD *)(a1 + 72);
    int v19 = *(_DWORD *)(a1 + 76);
    int v20 = *(_DWORD *)(a1 + 80);
    int v21 = *(_DWORD *)(a1 + 84);
    int v22 = *(_DWORD *)(a1 + 88);
    int v23 = *(_DWORD *)(a1 + 92);
    int v24 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)std::string buf = 134219776;
    uint64_t v28 = v17;
    __int16 v29 = 1024;
    int v30 = v18;
    __int16 v31 = 1024;
    int v32 = v19;
    __int16 v33 = 1024;
    int v34 = v20;
    __int16 v35 = 1024;
    int v36 = v21;
    __int16 v37 = 1024;
    int v38 = v22;
    __int16 v39 = 1024;
    int v40 = v23;
    __int16 v41 = 1024;
    int v42 = v24;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Decoder output format:  mSampleRate = %f, mFormatID = %u, mFormatFlags:%u, mBytesPerPacket:%u, mFramesPerPacket = %u, mBytesPerFrame:%u, mChannelsPerFrame = %u, mBitsPerChannel:%u, format = float PCM\n", buf, 0x36u);
  }
  OSStatus v25 = AudioConverterNew((const AudioStreamBasicDescription *)(a1 + 24), (const AudioStreamBasicDescription *)(a1 + 64), (AudioConverterRef *)(a1 + 16));
  sub_1B8C0(v25, (uint64_t)"Could not create new audio converter");
  *(_DWORD *)(a1 + 120) = 1;
  operator new[]();
}

void sub_1EE38(uint64_t a1, int a2, double a3)
{
  *(double *)(a1 + 24) = a3;
  int v5 = (const AudioStreamBasicDescription *)(a1 + 24);
  *(_DWORD *)(a1 + 116) = a2;
  if (*(unsigned char *)(a1 + 161))
  {
    int v6 = qword_A1AA0;
    if (os_log_type_enabled((os_log_t)qword_A1AA0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "LC3 decoderasym init to AACELD 48K", buf, 2u);
    }
    int v7 = 1633772389;
  }
  else
  {
    int v7 = 1818440480;
  }
  *(_DWORD *)(a1 + 32) = v7;
  if (a3 == 24000.0)
  {
    int v8 = 180;
  }
  else
  {
    if (a3 != 32000.0) {
      goto LABEL_11;
    }
    int v8 = 240;
  }
  *(_DWORD *)(a1 + 44) = v8;
LABEL_11:
  *(_DWORD *)(a1 + 156) = 360;
  *(_DWORD *)(a1 + 36) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_OWORD *)(a1 + 48) = xmmword_71040;
  UInt32 ioPropertyDataSize = 40;
  OSStatus Property = AudioFormatGetProperty(0x666D7469u, 0, 0, &ioPropertyDataSize, (void *)(a1 + 64));
  sub_1B8C0(Property, (uint64_t)"couldn't get output data format");
  int v10 = qword_A1AA0;
  if (os_log_type_enabled((os_log_t)qword_A1AA0, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a1 + 24);
    int v12 = *(_DWORD *)(a1 + 32);
    int v13 = *(_DWORD *)(a1 + 36);
    int v14 = *(_DWORD *)(a1 + 40);
    int v15 = *(_DWORD *)(a1 + 44);
    int v16 = *(_DWORD *)(a1 + 48);
    int v17 = *(_DWORD *)(a1 + 52);
    int v18 = *(_DWORD *)(a1 + 56);
    *(_DWORD *)std::string buf = 134219776;
    uint64_t v32 = v11;
    __int16 v33 = 1024;
    int v34 = v12;
    __int16 v35 = 1024;
    int v36 = v13;
    __int16 v37 = 1024;
    int v38 = v14;
    __int16 v39 = 1024;
    int v40 = v15;
    __int16 v41 = 1024;
    int v42 = v16;
    __int16 v43 = 1024;
    int v44 = v17;
    __int16 v45 = 1024;
    int v46 = v18;
    _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Decoder input format:  mSampleRate = %f, mFormatID = %u, mFormatFlags:%u, mBytesPerPacket:%u, mFramesPerPacket = %u, mBytesPerFrame:%u, mChannelsPerFrame = %u, mBitsPerChannel:%u, format = float PCM\n", buf, 0x36u);
    int v10 = qword_A1AA0;
  }
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = *(void *)(a1 + 64);
    int v20 = *(_DWORD *)(a1 + 72);
    int v21 = *(_DWORD *)(a1 + 76);
    int v22 = *(_DWORD *)(a1 + 80);
    int v23 = *(_DWORD *)(a1 + 84);
    int v24 = *(_DWORD *)(a1 + 88);
    int v25 = *(_DWORD *)(a1 + 92);
    int v26 = *(_DWORD *)(a1 + 96);
    *(_DWORD *)std::string buf = 134219776;
    uint64_t v32 = v19;
    __int16 v33 = 1024;
    int v34 = v20;
    __int16 v35 = 1024;
    int v36 = v21;
    __int16 v37 = 1024;
    int v38 = v22;
    __int16 v39 = 1024;
    int v40 = v23;
    __int16 v41 = 1024;
    int v42 = v24;
    __int16 v43 = 1024;
    int v44 = v25;
    __int16 v45 = 1024;
    int v46 = v26;
    _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Decoder output format:  mSampleRate = %f, mFormatID = %u, mFormatFlags:%u, mBytesPerPacket:%u, mFramesPerPacket = %u, mBytesPerFrame:%u, mChannelsPerFrame = %u, mBitsPerChannel:%u, format = float PCM\n", buf, 0x36u);
  }
  OSStatus v27 = AudioConverterNew(v5, (const AudioStreamBasicDescription *)(a1 + 64), (AudioConverterRef *)(a1 + 16));
  sub_1B8C0(v27, (uint64_t)"Could not create new audio converter");
  *(_DWORD *)std::string buf = 1835626096;
  OSStatus v28 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 16), 0x73726361u, 4u, buf);
  sub_1B8C0(v28, (uint64_t)"Failed to set kAudioConverterSampleRateConverterComplexity");
  *(_DWORD *)std::string buf = 33;
  OSStatus v29 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 16), 0x73726371u, 4u, buf);
  sub_1B8C0(v29, (uint64_t)"Failed to set kAudioConverterSampleRateConverterQuality");
  *(_DWORD *)(a1 + 120) = 1;
  operator new[]();
}

void sub_1F1C8(uint64_t a1, unsigned __int8 *a2, BOOL a3, void *a4, unint64_t a5, void *a6)
{
  if (a3) {
    a3 = *a2 != 255;
  }
  sub_48844(a1, (uint64_t)a2, a3, a4, a5, a6);
}

uint64_t sub_1F1E0()
{
  return 1;
}

os_log_t sub_1F1E8()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AA0 = (uint64_t)result;
  return result;
}

uint64_t sub_1F218(uint64_t a1, unsigned int a2, uint64_t a3)
{
  long long v5 = *(_OWORD *)(a3 + 16);
  v9[0] = *(_OWORD *)a3;
  v9[1] = v5;
  uint64_t v10 = *(void *)(a3 + 32);
  sub_12C34(a1, a2, v9);
  *(void *)uint64_t v6 = off_8E108;
  *(unsigned char *)(v6 + 176) = 0;
  if (a2 > 0x11 || ((1 << a2) & 0x30018) == 0)
  {
    int v8 = qword_A1AA8;
    if (os_log_type_enabled((os_log_t)qword_A1AA8, OS_LOG_TYPE_ERROR)) {
      sub_65648(a2, v8);
    }
  }
  return a1;
}

void sub_1F2DC(void *a1)
{
  sub_12C84(a1);

  operator delete();
}

void sub_1F314(_DWORD *a1, int a2)
{
  a1[39] = a2;
  if (a2 == 64000)
  {
    int v2 = 8;
  }
  else
  {
    if (a2 != 48000) {
      goto LABEL_6;
    }
    int v2 = 6;
  }
  a1[7825] = v2;
LABEL_6:
  a1[38] = 10240;
  operator new[]();
}

void sub_1F3EC(uint64_t a1, __int16 *a2, unsigned int a3, uint64_t a4)
{
  __int16 v14 = 0;
  int v6 = *(_DWORD *)(a1 + 92);
  if (v6 == 2)
  {
    if (a3)
    {
      uint64_t v7 = a3;
      uint64_t v8 = a1;
      do
      {
        *(_WORD *)(v8 + 580) = *a2;
        *(_WORD *)(v8 + 10820) = a2[1];
        v8 += 2;
        a2 += 2;
        --v7;
      }
      while (v7);
    }
    int v9 = (__int16)a3;
    g722_encode_frame((int16x4_t *)(a1 + 180), (__int16 *)(a1 + 580), (__int16)a3, (unsigned char *)(a1 + 21060), &v14);
    g722_encode_frame((int16x4_t *)(a1 + 380), (__int16 *)(a1 + 10820), v9, (unsigned char *)(a1 + 26180), &v14);
    __int16 v10 = v14;
    if (v14 >= 1)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      do
      {
        *(unsigned char *)(*(void *)(a1 + 144) + v12) = *(unsigned char *)(a1 + 21060 + v11);
        uint64_t v13 = *(void *)(a1 + 144) + v12;
        v12 += 2;
        *(unsigned char *)(v13 + 1) = *(unsigned char *)(a1 + 26180 + v11++);
      }
      while (v11 < v14);
      __int16 v10 = v14;
    }
  }
  else
  {
    g722_encode_frame((int16x4_t *)(a1 + 180), a2, (__int16)a3, *(unsigned char **)(a1 + 144), &v14);
    __int16 v10 = v14;
  }
  if (*(unsigned char *)(a1 + 177))
  {
    sub_1330C(a1, v10, 0);
    __int16 v10 = v14;
  }
  *(_DWORD *)a4 = 1;
  *(void *)(a4 + 16) = *(void *)(a1 + 144);
  *(_DWORD *)(a4 + 8) = 1;
  *(_DWORD *)(a4 + 12) = v6 * v10;
}

os_log_t sub_1F550()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AA8 = (uint64_t)result;
  return result;
}

os_log_t *sub_1F580(os_log_t *a1)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = os_log_create("com.apple.bluetooth", "BTAudio");
  return a1;
}

uint64_t sub_1F5C0(uint64_t a1, unint64_t *a2, unint64_t a3)
{
  size_t v6 = (strlen(off_96AB8) & 0xFFFFFFFFFFFFFFF8) + 56;
  unint64_t v7 = a3 - v6;
  if (a3 < v6 || v7 < 2) {
    return 0;
  }
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = (char *)a2 + v6;
  *a2 = v7;
  a2[1] = 0;
  a2[2] = 0;
  unint64_t v8 = atomic_load(a2 + 3);
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), -(uint64_t)v8);
  uint64_t v9 = *(void *)(a1 + 8);
  *(unsigned char *)(v9 + 40) = 0;
  atomic_store(0, (unint64_t *)(v9 + 32));
  strlcpy((char *)(*(void *)(a1 + 8) + 41), off_96AB8, a3 - 41);
  return 1;
}

size_t sub_1F670()
{
  return (strlen(off_96AB8) & 0xFFFFFFFFFFFFFFF8) + 56;
}

uint64_t sub_1F698(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a2 + a3;
}

uint64_t sub_1F6A0(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 8);
  v1[1] = 0;
  v1[2] = 0;
  unint64_t v2 = atomic_load(v1 + 3);
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(result + 8) + 24), -(uint64_t)v2);
  uint64_t v3 = *(void *)(result + 8);
  *(unsigned char *)(v3 + 40) = 0;
  atomic_store(0, (unint64_t *)(v3 + 32));
  return result;
}

BOOL sub_1F6D8(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  uint64_t v3 = off_96AB8;
  *(void *)(a1 + 16) = a2 + (strlen(off_96AB8) & 0xFFFFFFFFFFFFFFF8) + 56;
  size_t v4 = strlen(v3);
  return strncmp((const char *)(a2 + 41), v3, v4) == 0;
}

uint64_t sub_1F74C(uint64_t result)
{
  *(void *)(result + 8) = 0;
  *(void *)(result + 16) = 0;
  return result;
}

uint64_t sub_1F754(uint64_t result, uint64_t a2)
{
  return result;
}

unint64_t sub_1F768(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return atomic_load((unint64_t *)(v1 + 24));
  }
  else {
    return 0;
  }
}

unint64_t sub_1F784(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1)
  {
    if (!*(unsigned char *)(v1 + 40)) {
      return atomic_load((unint64_t *)(v1 + 24));
    }
    *(void *)(v1 + 8) = 0;
    *(void *)(v1 + 16) = 0;
    unint64_t v2 = atomic_load((unint64_t *)(v1 + 24));
    atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), -(uint64_t)v2);
    uint64_t v3 = *(void *)(a1 + 8);
    *(unsigned char *)(v3 + 40) = 0;
    atomic_store(0, (unint64_t *)(v3 + 32));
    uint64_t v1 = *(void *)(a1 + 8);
    if (v1) {
      return atomic_load((unint64_t *)(v1 + 24));
    }
  }
  else if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
  {
    sub_656C0();
  }
  return 0;
}

void *sub_1F818(uint64_t a1, char *__dst, size_t a3)
{
  long long v5 = *(size_t **)(a1 + 8);
  size_t v6 = v5[1];
  size_t v7 = *v5;
  size_t v8 = v6 + a3;
  size_t v9 = *v5 - v6;
  if (a3 - v9 >= v6) {
    size_t v10 = v6;
  }
  else {
    size_t v10 = a3 - v9;
  }
  if (v8 >= v7) {
    size_t v11 = v9;
  }
  else {
    size_t v11 = a3;
  }
  os_log_t result = memcpy(__dst, (const void *)(v6 + *(void *)(a1 + 16)), v11);
  if (v8 >= v7 && v10 != 0) {
    os_log_t result = memcpy(&__dst[v11], *(const void **)(a1 + 16), v10);
  }
  if (v8 >= v7) {
    size_t v14 = v10;
  }
  else {
    size_t v14 = v8;
  }
  *(void *)(*(void *)(a1 + 8) + 8) = v14;
  return result;
}

uint64_t sub_1F8B4(uint64_t result, uint64_t a2)
{
  *(void *)(*(void *)(result + 8) + 8) = (unint64_t)(*(void *)(*(void *)(result + 8) + 8) + a2)
                                             % **(void **)(result + 8);
  return result;
}

unint64_t sub_1F8D4(uint64_t a1, char *a2, size_t *a3, size_t a4)
{
  uint64_t v6 = a1 + 8;
  long long v5 = *(void **)(a1 + 8);
  if ((unint64_t)(v5[1] + 2) > *v5)
  {
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
      sub_656F4();
    }
    return 0;
  }
  uint64_t v7 = v5[1];
  size_t v8 = *(unsigned __int16 *)(v7 + *(void *)(a1 + 16));
  if (!*(_WORD *)(v7 + *(void *)(a1 + 16))) {
    return 0;
  }
  if (v8 >= a4) {
    size_t v8 = a4;
  }
  *a3 = v8;
  size_t v10 = v8 & 1;
  unint64_t v11 = v8 + v10 + 2;
  unint64_t v12 = atomic_load(v5 + 3);
  if (v11 > v12)
  {
    if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
      sub_65728((uint64_t)a3, v6);
    }
    return 0;
  }
  size_t v14 = *(void **)(a1 + 8);
  v14[1] += 2;
  v14[1] %= *v14;
  sub_1F818(a1, a2, *a3);
  int v15 = *(void **)(a1 + 8);
  if (v10) {
    v15[1] = (unint64_t)(v15[1] + 1) % *v15;
  }
  atomic_fetch_add(v15 + 4, 0xFFFFFFFFFFFFFFFFLL);
  return v11;
}

uint64_t sub_1FA0C(uint64_t a1, char a2)
{
  return a2 & 1;
}

size_t sub_1FA14(uint64_t a1, char *a2, size_t a3)
{
  unint64_t v6 = sub_1F784(a1);
  if (!v6) {
    return 0;
  }
  if (v6 < a3) {
    a3 = v6;
  }
  sub_1F818(a1, a2, a3);
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), -(uint64_t)a3);
  return a3;
}

unint64_t sub_1FA80(uint64_t a1, char *a2, size_t a3)
{
  unint64_t result = sub_1F784(a1);
  if (result)
  {
    size_t v7 = 0;
    unint64_t result = sub_1F8D4(a1, a2, &v7, a3);
    if (result)
    {
      atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), -(uint64_t)result);
      return v7;
    }
  }
  return result;
}

BOOL sub_1FAF0(uint64_t a1, char *a2, size_t *a3, size_t a4, char *a5, size_t *a6, size_t a7)
{
  unint64_t v14 = sub_1F784(a1);
  if (v14)
  {
    unint64_t v15 = sub_1F8D4(a1, a2, a3, a4);
    atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), -(uint64_t)(sub_1F8D4(a1, a5, a6, a7) + v15));
  }
  return v14 != 0;
}

void sub_1FB94(uint64_t a1)
{
  uint64_t v1 = *(unint64_t **)(a1 + 8);
  unint64_t v2 = v1[1];
  unint64_t v3 = *v1;
  unint64_t v4 = atomic_load(v1 + 3);
  uint64_t v5 = *(void *)(a1 + 8);
  *(void *)(v5 + 8) = (v4 + v2) % v3;
  atomic_fetch_add((atomic_ullong *volatile)(v5 + 24), -(uint64_t)v4);
  atomic_store(0, (unint64_t *)(*(void *)(a1 + 8) + 32));
}

BOOL sub_1FBD4(uint64_t a1, unint64_t a2)
{
  uint64_t v3 = a1 + 8;
  unint64_t v2 = *(uint64_t **)(a1 + 8);
  if (v2)
  {
    if (*((unsigned char *)v2 + 40)) {
      return 0;
    }
    uint64_t v5 = *v2;
    unint64_t v6 = atomic_load((unint64_t *)v2 + 3);
    if (v5 + ~v6 >= a2)
    {
      return 1;
    }
    else
    {
      if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR)) {
        sub_657DC(v3);
      }
      BOOL result = 0;
      *(unsigned char *)(*(void *)v3 + 40) = 1;
    }
  }
  else
  {
    BOOL result = os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR);
    if (result)
    {
      sub_657A8();
      return 0;
    }
  }
  return result;
}

uint64_t sub_1FC90(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 8);
  uint64_t v2 = *v1;
  unint64_t v3 = atomic_load(v1 + 3);
  return v2 + ~v3;
}

void sub_1FCA8(uint64_t a1, __int16 a2)
{
  uint64_t v2 = *(unint64_t **)(a1 + 8);
  unint64_t v3 = v2[2];
  unint64_t v4 = *v2;
  if (v3 + 2 <= *v2)
  {
    *(_WORD *)(v3 + *(void *)(a1 + 16)) = a2;
    _DWORD v2[2] = (v3 + 2) % v4;
  }
  else if (os_log_type_enabled(*(os_log_t *)a1, OS_LOG_TYPE_ERROR))
  {
    sub_6585C();
  }
}

void *sub_1FD10(uint64_t a1, char *a2, size_t a3)
{
  unint64_t v6 = *(size_t **)(a1 + 8);
  size_t v7 = v6[2];
  size_t v8 = *v6;
  size_t v9 = v7 + a3;
  size_t v10 = *v6 - v7;
  size_t v11 = a3 - v10;
  if (v7 + a3 >= *v6) {
    size_t v12 = *v6 - v7;
  }
  else {
    size_t v12 = a3;
  }
  BOOL result = memcpy((void *)(v7 + *(void *)(a1 + 16)), a2, v12);
  if (v9 >= v8 && a3 != v10) {
    BOOL result = memcpy(*(void **)(a1 + 16), &a2[v12], v11);
  }
  if (v9 >= v8) {
    size_t v15 = v11;
  }
  else {
    size_t v15 = v9;
  }
  *(void *)(*(void *)(a1 + 8) + 16) = v15;
  return result;
}

uint64_t sub_1FDAC(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void **)(result + 8);
  v2[2] += a2;
  v2[2] %= *v2;
  return result;
}

void sub_1FDD4(uint64_t a1, char **a2, size_t *a3, uint64_t a4, __int16 a5, uint64_t a6)
{
  sub_1FCA8(a1, a5);
  for (; a4; --a4)
  {
    size_t v12 = *a2++;
    size_t v11 = v12;
    size_t v13 = *a3++;
    sub_1FD10(a1, v11, v13);
  }
  unint64_t v14 = *(void **)(a1 + 8);
  if (a6)
  {
    v14[2] += a6;
    v14[2] %= *v14;
  }
  atomic_fetch_add(v14 + 4, 1uLL);
}

size_t sub_1FE6C(uint64_t a1, char *a2, unint64_t a3)
{
  size_t v3 = a3;
  if (!sub_1FBD4(a1, a3)) {
    return 0;
  }
  sub_1FD10(a1, a2, v3);
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), v3);
  return v3;
}

uint64_t sub_1FED0(uint64_t result, unint64_t a2)
{
  return result;
}

unint64_t sub_1FEE0(uint64_t a1, char *a2, size_t a3)
{
  __int16 v3 = a3;
  size_t v8 = a3;
  size_t v9 = a2;
  uint64_t v5 = a3 & 1;
  unint64_t v6 = a3 + v5 + 2;
  if (!sub_1FBD4(a1, v6)) {
    return 0;
  }
  sub_1FDD4(a1, &v9, &v8, 1, v3, v5);
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), v6);
  return v6;
}

unint64_t sub_1FF64(uint64_t a1, char **a2, size_t *a3, uint64_t a4, uint64_t a5)
{
  __int16 v5 = a5;
  uint64_t v10 = a5 & 1;
  unint64_t v11 = a5 + v10 + 2;
  if (!sub_1FBD4(a1, v11)) {
    return 0;
  }
  sub_1FDD4(a1, a2, a3, a4, v5, v10);
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), v11);
  return v11;
}

BOOL sub_1FFF8(uint64_t a1, char *a2, size_t a3, char *a4, size_t a5)
{
  __int16 v5 = a5;
  __int16 v6 = a3;
  size_t v15 = a3;
  int v16 = a2;
  size_t v13 = a5;
  unint64_t v14 = a4;
  uint64_t v8 = a3 & 1;
  uint64_t v9 = a5 & 1;
  unint64_t v10 = a3 + a5 + v8 + v9 + 4;
  BOOL v11 = sub_1FBD4(a1, v10);
  if (v11)
  {
    sub_1FDD4(a1, &v16, &v15, 1, v6, v8);
    sub_1FDD4(a1, &v14, &v13, 1, v5, v9);
    atomic_fetch_add((atomic_ullong *volatile)(*(void *)(a1 + 8) + 24), v10);
  }
  return v11;
}

unint64_t sub_200B8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1) {
    return atomic_load((unint64_t *)(v1 + 32));
  }
  else {
    return 0;
  }
}

void sub_200E8(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void sub_20108(uint64_t a1, int a2, uint64_t a3, char a4)
{
  long long v5 = *(_OWORD *)(a3 + 16);
  v7[0] = *(_OWORD *)a3;
  v7[1] = v5;
  uint64_t v8 = *(void *)(a3 + 32);
  sub_12C34(a1, a2, v7);
  *(void *)uint64_t v6 = off_8E160;
  *(unsigned char *)(v6 + 209) = 0;
  *(unsigned char *)(v6 + 176) = 1;
  *(unsigned char *)(v6 + 208) = a4;
  *(void *)(v6 + 56) = 0;
}

void *sub_20178(void *a1)
{
  *a1 = off_8E160;
  uint64_t v2 = (OpaqueAudioConverter *)a1[7];
  if (v2)
  {
    AudioConverterDispose(v2);
  }
  else
  {
    __int16 v3 = qword_A1AB0;
    if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_ERROR)) {
      sub_65890(v3);
    }
  }
  return sub_12C84(a1);
}

void sub_201F8(void *a1)
{
  sub_20178(a1);

  operator delete();
}

void sub_20230(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v4 = (const AudioStreamBasicDescription *)(a1 + 64);
  int v5 = *(_DWORD *)(a1 + 92);
  int v36 = 96;
  *(_DWORD *)(a1 + 156) = a2;
  int v6 = *(_DWORD *)(a1 + 52);
  if (v6 > 14)
  {
    switch(v6)
    {
      case 15:
        int v7 = 1633772389;
        *(void *)(a1 + 184) = 88;
        uint64_t v9 = 180;
        goto LABEL_25;
      case 510:
        int v7 = 1633772389;
        *(void *)(a1 + 184) = a3;
        *(void *)(a1 + 200) = 0;
        int v8 = 180;
        break;
      case 33023:
        int v7 = 1633772389;
        int v36 = 64;
        *(void *)(a1 + 184) = a3;
        *(void *)(a1 + 200) = 0;
LABEL_30:
        int v8 = 480;
        break;
      default:
LABEL_20:
        BOOL v11 = qword_A1AB0;
        if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_ERROR)) {
          sub_65B10(v11);
        }
        int v7 = 0;
        int v8 = 0;
        break;
    }
LABEL_31:
    *(void *)(a1 + 104) = *(void *)(a1 + 64);
    *(void *)(a1 + 192) = 8 * *(void *)(a1 + 184);
    *(_DWORD *)(a1 + 112) = v7;
    *(void *)(a1 + 116) = 0;
    *(_DWORD *)(a1 + 124) = v8;
    *(_DWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 132) = v5;
    *(void *)(a1 + 136) = 0;
    UInt32 ioPropertyDataSize = 40;
    OSStatus Property = AudioFormatGetProperty(0x666D7469u, 0, 0, &ioPropertyDataSize, (void *)(a1 + 104));
    sub_1B8C0(Property, (uint64_t)"couldn't create output data format");
    if (*(unsigned char *)(a1 + 48) && os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_DEBUG)) {
      sub_65AA4();
    }
    size_t v13 = (AudioConverterRef *)(a1 + 56);
    OSStatus v14 = AudioConverterNew(v4, (const AudioStreamBasicDescription *)(a1 + 104), (AudioConverterRef *)(a1 + 56));
    sub_1B8C0(v14, (uint64_t)"Could not create new audio converter");
    if (*(_DWORD *)(a1 + 120))
    {
      *(_DWORD *)(a1 + 160) = 6;
      *(_DWORD *)(a1 + 152) = 10240;
      operator new[]();
    }
    unsigned int outPropertyData = 0;
    UInt32 ioPropertyDataSize = 4;
    int v33 = 3;
    if (*(unsigned char *)(a1 + 208))
    {
      uint64_t v15 = *(unsigned int *)(a1 + 156);
      int inPropertyData = *(_DWORD *)(a1 + 156);
      int v33 = 0;
      if (*(unsigned char *)(a1 + 48))
      {
        int v16 = qword_A1AB0;
        if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_DEBUG)) {
          sub_65A38(v15, v16, v17, v18, v19, v20, v21, v22);
        }
      }
      OSStatus v23 = AudioConverterSetProperty(*v13, 0x62726174u, 4u, &inPropertyData);
      sub_1B8C0(v23, (uint64_t)"Failed to set target data rate");
      OSStatus v24 = AudioConverterGetProperty(*v13, 0x62726174u, &ioPropertyDataSize, &inPropertyData);
      sub_1B8C0(v24, (uint64_t)"Failed to set target data rate");
      if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_DEBUG)) {
        sub_659CC();
      }
      OSStatus v25 = AudioConverterGetProperty(*v13, 0x70616B62u, &ioPropertyDataSize, &outPropertyData);
      sub_1B8C0(v25, (uint64_t)"Failed to get kAudioCodecPropertyMaximumPacketByteSize");
    }
    else
    {
      OSStatus v26 = AudioConverterGetProperty(*(AudioConverterRef *)(a1 + 56), 0x70616B62u, &ioPropertyDataSize, &outPropertyData);
      sub_1B8C0(v26, (uint64_t)"Failed to get kAudioCodecPropertyMaximumPacketByteSize");
      if (*(unsigned char *)(a1 + 48) && os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_DEBUG)) {
        sub_65960();
      }
    }
    OSStatus v27 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 56), 0x63647175u, 4u, &v36);
    sub_1B8C0(v27, (uint64_t)"Failed to set kAudioConverterCodecQuality");
    OSStatus v28 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 56), 0x61636266u, 4u, &v33);
    sub_1B8C0(v28, (uint64_t)"Failed to set kAudioCodecPropertyBitRateControlMode");
    int inPropertyData = 256;
    OSStatus v29 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 56), 0x70616B6Du, 4u, &inPropertyData);
    sub_1B8C0(v29, (uint64_t)"Failed to set kAudioCodecPrivatePropertyMinimumPacketBitSize");
    unsigned int v30 = outPropertyData;
    unsigned int v31 = vcvtps_u32_f32((float)(20480 * v5 * *(_DWORD *)(a1 + 88)) / (float)outPropertyData);
    *(_DWORD *)(a1 + 160) = v31;
    *(_DWORD *)(a1 + 152) = v30 * v31;
    operator new[]();
  }
  switch(v6)
  {
    case 2:
      int v36 = 32;
      *(void *)(a1 + 184) = a3;
      *(void *)(a1 + 200) = 0;
      int v7 = 1633772320;
      int v8 = 1024;
      goto LABEL_31;
    case 5:
      int v7 = 1633772389;
      if (a3 == 60)
      {
        *(void *)(a1 + 184) = 177;
        uint64_t v9 = 90;
        goto LABEL_25;
      }
      if (a3 == 56)
      {
        *(void *)(a1 + 184) = 165;
        uint64_t v9 = 168;
LABEL_25:
        *(void *)(a1 + 200) = v9;
        goto LABEL_30;
      }
LABEL_12:
      if (a3 == 40)
      {
        *(void *)(a1 + 184) = 156;
        uint64_t v9 = 160;
        goto LABEL_25;
      }
      goto LABEL_30;
    case 6:
      int v7 = 1633772389;
      if (a3 != 60) {
        goto LABEL_12;
      }
      *(void *)(a1 + 184) = 236;
      uint64_t v9 = 240;
      goto LABEL_25;
    case 7:
      int v7 = 1633772389;
      switch(a3)
      {
        case '<':
          *(void *)(a1 + 184) = 118;
          uint64_t v10 = 120;
          break;
        case '8':
          *(void *)(a1 + 184) = 110;
          uint64_t v10 = 112;
          break;
        case '(':
          *(void *)(a1 + 184) = 78;
          uint64_t v10 = 80;
          break;
        default:
LABEL_29:
          int v5 = 1;
          goto LABEL_30;
      }
      *(void *)(a1 + 200) = v10;
      goto LABEL_29;
    default:
      goto LABEL_20;
  }
}

void sub_20894(uint64_t a1, uint64_t a2, unsigned int a3, _DWORD *a4, UInt32 a5)
{
  uint64_t v5 = a1;
  int v6 = 0;
  uint64_t v7 = 0;
  int v36 = 0;
  long long v44 = 0u;
  long long v45 = 0u;
  long long v43 = 0u;
  memset(&outOutputData, 0, sizeof(outOutputData));
  inInputDataProcUserData[0] = a2;
  UInt32 ioOutputDataPacketSize = *(_DWORD *)(a1 + 160);
  inInputDataProcUserData[1] = *(unsigned int *)(a1 + 80) * (unint64_t)a3;
  long long v8 = *(_OWORD *)(a1 + 80);
  long long v40 = *(_OWORD *)(a1 + 64);
  long long v41 = v8;
  uint64_t v42 = *(void *)(a1 + 96);
  *a4 = 0;
  while (1)
  {
    unsigned int v9 = *(_DWORD *)(v5 + 152);
    if (v9 <= v7) {
      break;
    }
    UInt32 v10 = *(_DWORD *)(v5 + 132);
    outOutputData.mNumberBuffers = 1;
    outOutputData.mBuffers[0].mNumberChannels = v10;
    outOutputData.mBuffers[0].mDataByteSize = v9 - v7;
    outOutputData.mBuffers[0].mData = (void *)(*(void *)(v5 + 144) + v7);
    if (*(unsigned char *)(v5 + 209))
    {
      BOOL v11 = qword_A1AB0;
      if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109376;
        *(_DWORD *)int64_t v47 = ioOutputDataPacketSize;
        *(_WORD *)&v47[4] = 2048;
        *(void *)&v47[6] = v7;
        _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "AACEncoder ->c io:%u, offset %llu", buf, 0x12u);
      }
    }
    OSStatus v12 = AudioConverterFillComplexBuffer(*(AudioConverterRef *)(v5 + 56), (AudioConverterComplexInputDataProc)sub_1B78C, inInputDataProcUserData, &ioOutputDataPacketSize, &outOutputData, *(AudioStreamPacketDescription **)(v5 + 168));
    sub_1B8C0(v12, (uint64_t)"Encoder AudioConverterFillComplexBuffer failed");
    if (*(unsigned char *)(v5 + 209))
    {
      size_t v13 = qword_A1AB0;
      if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)int64_t v47 = ioOutputDataPacketSize;
        _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "AACEncoder c-> io:%u", buf, 8u);
      }
    }
    UInt32 v14 = ioOutputDataPacketSize;
    if (!ioOutputDataPacketSize) {
      return;
    }
    if (ioOutputDataPacketSize > a5)
    {
      if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_ERROR)) {
        sub_65B54();
      }
      *a4 = 0;
      return;
    }
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    int v33 = v6 + 1;
    uint64_t v17 = *(void *)(v5 + 144) + v7;
    do
    {
      uint64_t v18 = (unsigned __int8 *)(v17 + *(void *)(*(void *)(a1 + 168) + v15));
      uint64_t v19 = &a4[4 * (v36 + v16)];
      *((void *)v19 + 2) = v18;
      uint64_t v20 = (uint64_t *)(*(void *)(a1 + 168) + v15);
      uint64_t v21 = *((unsigned int *)v20 + 3);
      void v19[2] = 1;
      v19[3] = v21;
      ++*a4;
      if (*(unsigned char *)(a1 + 209))
      {
        uint64_t v22 = qword_A1AB0;
        if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v23 = *v20;
          int v24 = *v18;
          int v25 = v18[1];
          int v26 = v18[2];
          int v27 = v18[3];
          *(_DWORD *)std::string buf = 134220032;
          *(void *)int64_t v47 = v17;
          *(_WORD *)&v47[8] = 1024;
          *(_DWORD *)&v47[10] = v16;
          __int16 v48 = 1024;
          int v49 = v36 + v16;
          __int16 v50 = 2048;
          uint64_t v51 = v23;
          __int16 v52 = 1024;
          int v53 = v21;
          __int16 v54 = 1024;
          int v55 = v24;
          __int16 v56 = 1024;
          int v57 = v25;
          __int16 v58 = 1024;
          int v59 = v26;
          __int16 v60 = 1024;
          int v61 = v27;
          _os_log_impl(&dword_0, v22, OS_LOG_TYPE_DEFAULT, "AACEncoder c->%p,%d,%u,%lld,%u,%02x,%02x,%02x,%02x", buf, 0x40u);
          UInt32 v14 = ioOutputDataPacketSize;
        }
      }
      v7 += v21;
      ++v16;
      v15 += 16;
    }
    while (v16 < v14);
    uint64_t v5 = a1;
    int v6 = v33;
    if (v14 && *(unsigned char *)(a1 + 177))
    {
      UInt32 v28 = 0;
      OSStatus v29 = (int *)(*(void *)(a1 + 168) + 12);
      uint64_t v30 = v14;
      do
      {
        int v31 = *v29;
        v29 += 4;
        v28 += v31;
        --v30;
      }
      while (v30);
      sub_1330C(a1, v28, v14);
    }
    v36 += v16;
    if (v33 == 10) {
      return;
    }
  }
  if (os_log_type_enabled((os_log_t)qword_A1AB0, OS_LOG_TYPE_ERROR)) {
    sub_65BC4();
  }
}

uint64_t sub_20C88()
{
  return 1;
}

uint64_t sub_20C90()
{
  return 1;
}

void sub_20CB4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0xEu);
}

os_log_t sub_20CD4()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AB0 = (uint64_t)result;
  return result;
}

void sub_20D04(uint64_t a1, int a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  v5[0] = *(_OWORD *)a3;
  v5[1] = v3;
  uint64_t v6 = *(void *)(a3 + 32);
  sub_12C34(a1, a2, v5);
  *(void *)uint64_t v4 = off_8E1B8;
  *(unsigned char *)(v4 + 176) = 1;
}

void sub_20D60(void *a1)
{
  sub_12C84(a1);

  operator delete();
}

void sub_20D98(uint64_t a1, int a2)
{
  *(void *)(a1 + 104) = 0x40BF400000000000;
  uint64_t v2 = (const AudioStreamBasicDescription *)(a1 + 104);
  *(_DWORD *)(a1 + 156) = a2;
  *(void *)(a1 + 112) = 1634492791;
  long long v3 = (const AudioStreamBasicDescription *)(a1 + 64);
  int v4 = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 120) = v4;
  *(_DWORD *)(a1 + 124) = 1;
  *(_DWORD *)(a1 + 128) = v4;
  *(_DWORD *)(a1 + 132) = v4;
  *(void *)(a1 + 136) = 8;
  UInt32 ioPropertyDataSize = 40;
  OSStatus Property = AudioFormatGetProperty(0x666D7469u, 0, 0, &ioPropertyDataSize, (void *)(a1 + 104));
  sub_1B8C0(Property, (uint64_t)"couldn't create output data format");
  OSStatus v6 = AudioConverterNew(v3, v2, (AudioConverterRef *)&v2[-2].mBitsPerChannel);
  sub_1B8C0(v6, (uint64_t)"Could not create new audio converter");
  v2[1].mFormatID = 4096;
  operator new[]();
}

void sub_20ECC(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  *(void *)&outOutputData.mNumberBuffers = 0;
  UInt32 v6 = *(_DWORD *)(a1 + 152);
  outOutputData.mBuffers[0].mNumberChannels = *(_DWORD *)(a1 + 92);
  outOutputData.mBuffers[0].UInt32 mDataByteSize = v6;
  outOutputData.mBuffers[0].mData = *(void **)(a1 + 144);
  inInputDataProcUserData[0] = a2;
  UInt32 ioOutputDataPacketSize = *(_DWORD *)(a1 + 160);
  outOutputData.mNumberBuffers = 1;
  inInputDataProcUserData[1] = (*(_DWORD *)(a1 + 80) * a3);
  long long v7 = *(_OWORD *)(a1 + 64);
  long long v8 = *(_OWORD *)(a1 + 80);
  uint64_t v18 = *(void *)(a1 + 96);
  long long v17 = v8;
  long long v16 = v7;
  OSStatus v9 = AudioConverterFillComplexBuffer(*(AudioConverterRef *)(a1 + 56), (AudioConverterComplexInputDataProc)sub_1B78C, inInputDataProcUserData, &ioOutputDataPacketSize, &outOutputData, 0);
  sub_1B8C0(v9, (uint64_t)"AudioConverterFillComplexBuffer failed");
  UInt32 v10 = ioOutputDataPacketSize;
  if (*(unsigned char *)(a1 + 177) && ioOutputDataPacketSize)
  {
    sub_1330C(a1, *(_DWORD *)(a4 + 12), ioOutputDataPacketSize);
    UInt32 v10 = ioOutputDataPacketSize;
  }
  int v11 = 0;
  if (v10)
  {
    UInt32 mDataByteSize = outOutputData.mBuffers[0].mDataByteSize;
    if (outOutputData.mBuffers[0].mDataByteSize)
    {
      *(void *)(a4 + 16) = *(void *)(a1 + 144);
      *(_DWORD *)(a4 + 8) = outOutputData.mBuffers[0].mNumberChannels;
      *(_DWORD *)(a4 + 12) = mDataByteSize;
      int v11 = 1;
    }
  }
  *(_DWORD *)a4 = v11;
}

os_log_t sub_20FC4()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AB8 = (uint64_t)result;
  return result;
}

os_log_t sub_214DC()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AC0 = (uint64_t)result;
  return result;
}

void sub_21C4C(_Unwind_Exception *a1)
{
  sub_5CF10(v1 - 80);
  _Unwind_Resume(a1);
}

void sub_21C68(uint64_t a1)
{
  uint64_t v2 = sub_44C8C(qword_A2350, *(_DWORD *)(*(void *)(a1 + 32) + 20));
  if (v2)
  {
    long long v3 = v2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Spatial Client, Proc Exit handler Fired", v5, 2u);
    }
    sub_21D18(v3[1156], *(_DWORD *)(a1 + 48));
    sub_21EB8((void *)v3[1156], 1);
  }
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
}

uint64_t sub_21D18(uint64_t a1, int a2)
{
  int v13 = a2;
  v12[0] = 0;
  v12[1] = 0;
  sub_5CDCC((uint64_t)v12, a1 + 408);
  uint64_t v4 = *(void *)(a1 + 392);
  if (v4)
  {
    uint64_t v5 = a1 + 392;
    do
    {
      int v6 = *(_DWORD *)(v4 + 32);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        long long v8 = (uint64_t *)v4;
      }
      else {
        long long v8 = (uint64_t *)(v4 + 8);
      }
      if (!v7) {
        uint64_t v5 = v4;
      }
      uint64_t v4 = *v8;
    }
    while (*v8);
    if (v5 != a1 + 392 && *(_DWORD *)(v5 + 32) <= a2)
    {
      *(void *)std::string buf = &v13;
      objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v13, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "cancelExitHandler");
      *(void *)std::string buf = &v13;

      sub_2D764(a1 + 384, &v13);
      OSStatus v9 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v10 = *(void *)(a1 + 400);
        *(_DWORD *)std::string buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v13;
        __int16 v15 = 1024;
        int v16 = v10;
        _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "Released client info for PID %d Pending Clients %d", buf, 0xEu);
      }
    }
  }
  return sub_5CF10(v12);
}

void sub_21E9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_21EB8(void *a1, uint64_t a2)
{
  v22[0] = 0;
  v22[1] = 0;
  sub_5CDCC((uint64_t)v22, (uint64_t)(a1 + 51));
  uint64_t v4 = (void *)a1[48];
  if (v4 == a1 + 49)
  {
    int v6 = 0;
    id v5 = 0;
  }
  else
  {
    id v5 = 0;
    int v6 = 0;
    do
    {
      id v7 = [(id)v4[5] HighestQualityFormat];
      int v9 = BYTE1(v6);
      if (v8 == 4) {
        int v10 = v8;
      }
      else {
        int v10 = v6;
      }
      if (v8 == 4) {
        id v11 = v7;
      }
      else {
        id v11 = v5;
      }
      if (v8 == 2) {
        int v12 = v8;
      }
      else {
        int v12 = v6;
      }
      if (v8 == 2) {
        id v13 = v7;
      }
      else {
        id v13 = v5;
      }
      if (v8 - 1 <= 1)
      {
        id v14 = v13;
      }
      else
      {
        int v12 = v10;
        id v14 = v11;
      }
      if (BYTE1(v6) == BYTE1(v8)) {
        int v15 = v12;
      }
      else {
        int v15 = v6;
      }
      if (BYTE1(v6) == BYTE1(v8)) {
        id v16 = v14;
      }
      else {
        id v16 = v5;
      }
      if (BYTE1(v6) < BYTE1(v8))
      {
        int v15 = v8;
        id v16 = v7;
      }
      if (BYTE1(v6)) {
        int v6 = v15;
      }
      else {
        int v6 = v8;
      }
      if (v9) {
        id v5 = v16;
      }
      else {
        id v5 = v7;
      }
      long long v17 = (void *)v4[1];
      if (v17)
      {
        do
        {
          uint64_t v18 = v17;
          long long v17 = (void *)*v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          uint64_t v18 = (void *)v4[2];
          BOOL v19 = *v18 == (void)v4;
          uint64_t v4 = v18;
        }
        while (!v19);
      }
      uint64_t v4 = v18;
    }
    while (v18 != a1 + 49);
  }
  sub_5CEA4((uint64_t)v22);
  a1[44] = v5;
  *((_DWORD *)a1 + 90) = v6;
  long long v20 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67110144;
    int v24 = BYTE1(v6);
    __int16 v25 = 1024;
    int v26 = v6;
    __int16 v27 = 1024;
    int v28 = 1;
    __int16 v29 = 1024;
    int v30 = 1;
    __int16 v31 = 1024;
    int v32 = a2;
    _os_log_impl(&dword_0, v20, OS_LOG_TYPE_DEFAULT, "Updated Best Possible Stream info, Channels = %d Spatial Status = %d Mode = %d Head Tracking = %d delaySpatialUIUpdate = %d", buf, 0x20u);
  }
  (*(void (**)(void, uint64_t, uint64_t))(*(void *)*a1 + 600))(*a1, a2, 200);
  return sub_5CF10(v22);
}

void sub_220B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_220D8(uint64_t a1)
{
  uint64_t v2 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Spatial Enable: Cancel Proc Exit handler", v4, 2u);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  os_log_t result = sub_44C8C(qword_A2350, *(_DWORD *)(*(void *)(a1 + 40) + 20));
  if (result) {
    return (void *)sub_22170(result[1156], *(_DWORD *)(a1 + 48));
  }
  return result;
}

uint64_t sub_22170(uint64_t a1, int a2)
{
  int v11 = a2;
  v10[0] = 0;
  v10[1] = 0;
  sub_5CDCC((uint64_t)v10, a1 + 408);
  uint64_t v4 = *(void *)(a1 + 392);
  if (v4)
  {
    uint64_t v5 = a1 + 392;
    do
    {
      int v6 = *(_DWORD *)(v4 + 32);
      BOOL v7 = v6 < a2;
      if (v6 >= a2) {
        int v8 = (uint64_t *)v4;
      }
      else {
        int v8 = (uint64_t *)(v4 + 8);
      }
      if (!v7) {
        uint64_t v5 = v4;
      }
      uint64_t v4 = *v8;
    }
    while (*v8);
    if (v5 != a1 + 392 && *(_DWORD *)(v5 + 32) <= a2)
    {
      int v12 = &v11;
      objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v11, (uint64_t)&unk_71834, &v12)[5], "SpatialAudioClientProcExitHandler");
    }
  }
  return sub_5CF10(v10);
}

void sub_22224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_226E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

void sub_228A4(_Unwind_Exception *exception_object)
{
}

void sub_22D94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_23298(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  sub_5CC80(a1 + 64, a2);
  *(_WORD *)(a1 + 128) = 1;
  *(void *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 164) = 0;
  *(void *)(a1 + 192) = 0;
  *(_WORD *)(a1 + 216) = 0;
  *(unsigned char *)(a1 + 218) = 1;
  *(unsigned char *)(a1 + 324) = 0;
  *(_DWORD *)(a1 + 219) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 227) = 0;
  *(void *)(a1 + 232) = 0;
  *(unsigned char *)(a1 + 240) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 250) = 0;
  *(unsigned char *)(a1 + 276) = 0;
  *(_DWORD *)(a1 + 272) = 0;
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = 0;
  *(_WORD *)(a1 + 325) = 1;
  *(_WORD *)(a1 + 331) = 0;
  *(_DWORD *)(a1 + 336) = 0;
  *(unsigned char *)(a1 + 340) = 1;
  *(unsigned char *)(a1 + 348) = 0;
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 384) = a1 + 392;
  sub_5CC80(a1 + 408, v8);
  *(unsigned char *)(a1 + 472) = 0;
  *(void *)(a1 + 480) = 0;
  *(unsigned char *)(a1 + 488) = 0;
  *(void *)(a1 + 504) = 0;
  *(void *)(a1 + 512) = 0;
  *(void *)(a1 + 496) = 0;
  sub_5CC80(a1 + 520, v9);
  *(unsigned char *)(a1 + 584) = 1;
  *(void *)(a1 + 592) = 0;
  *(void *)a1 = a2;
  *(void *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  mach_timebase_info((mach_timebase_info_t)(a1 + 600));
  *(unsigned char *)(a1 + 144) = 0;
  sub_235B8((unsigned char *)a1, 0);
  sub_236C8((unsigned char *)a1, 0);
  sub_23818(a1, 0);
  sub_23938(a1, 0);
  *(unsigned char *)(a1 + 168) = 1;
  *(_DWORD *)(a1 + 196) = 0;
  *(void *)(a1 + 172) = 0x300000003;
  *(_DWORD *)(a1 + 180) = 3;
  *(_DWORD *)(a1 + 188) = 0;
  *(unsigned char *)(a1 + 145) = 0;
  *(unsigned char *)(a1 + 277) = 0;
  *(unsigned char *)(a1 + 200) = 0;
  *(void *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 148) = 0;
  *(_DWORD *)(a1 + 152) = 0;
  *(_WORD *)(a1 + 278) = 512;
  *(_DWORD *)(a1 + 280) = -1082130432;
  *(void *)(a1 + 288) = 0;
  *(unsigned char *)(a1 + 296) = 0;
  *(_DWORD *)(a1 + 320) = 3;
  v11[0] = 0;
  v11[1] = 0;
  sub_5CDCC((uint64_t)v11, a1 + 520);
  *(void *)(a1 + 496) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_5CEA4((uint64_t)v11);
  *(_DWORD *)(a1 + 360) = 0;
  *(void *)(a1 + 352) = 0;
  *(_DWORD *)(a1 + 327) = 0;
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  keys = @"airpods noise suppression";
  xpc_object_t values = CFDictionaryCreateMutable(0, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFRetain(values);
  *(void *)(a1 + 264) = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  sub_23A38(a1, a3, a4);
  sub_23E4C(a1);
  *(_WORD *)(a1 + 608) = -1;
  sub_5CF10(v11);
  return a1;
}

void sub_23548(_Unwind_Exception *a1, uint64_t a2)
{
  sub_5CD00(v5, a2);
  sub_5CD00(v4, v8);
  sub_18C7C(v2 + 384, *v6);
  sub_5CD00(v3, v9);
  if (*(char *)(v2 + 31) < 0) {
    operator delete(*(void **)(v2 + 8));
  }
  _Unwind_Resume(a1);
}

void sub_235B8(unsigned char *a1, int a2)
{
  if ((a1[156] != 0) != a2)
  {
    a1[156] = a2;
    uint64_t v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (a2) {
        uint64_t v5 = "enabled";
      }
      else {
        uint64_t v5 = "disabled";
      }
      int v6 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      int v7 = 136446466;
      uint64_t v8 = v5;
      __int16 v9 = 1024;
      int v10 = v6;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "AccessoryInEarDetectionSupported set to %{public}s for mAudioObjectID %d", (uint8_t *)&v7, 0x12u);
    }
  }
}

void sub_236C8(unsigned char *a1, int a2)
{
  if ((a1[488] != 0) != a2)
  {
    a1[488] = a2;
    uint64_t v3 = *(unsigned char **)(*(void *)a1 + 9096);
    if (v3 && v3[192]) {
      (*(void (**)(unsigned char *))(*(void *)v3 + 968))(v3);
    }
    uint64_t v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (a1[488]) {
        uint64_t v5 = "enabled";
      }
      else {
        uint64_t v5 = "disabled";
      }
      int v6 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      int v7 = 136446466;
      uint64_t v8 = v5;
      __int16 v9 = 1024;
      int v10 = v6;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Accessory SetHfpExtendedVolumeRange set to %{public}s for mAudioObjectID %d", (uint8_t *)&v7, 0x12u);
    }
  }
}

void sub_23818(uint64_t a1, int a2)
{
  if ((*(unsigned char *)(a1 + 157) != 0) != a2)
  {
    *(unsigned char *)(a1 + 157) = a2;
    sub_49F68(*(void *)a1, 1768252517);
    uint64_t v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 156)) {
        uint64_t v4 = "enabled";
      }
      else {
        uint64_t v4 = "disabled";
      }
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      int v6 = 136446466;
      int v7 = v4;
      __int16 v8 = 1024;
      int v9 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory SetInEarDetectionEnabled set to %{public}s for mAudioObjectID %d", (uint8_t *)&v6, 0x12u);
    }
  }
}

void sub_23938(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 160) != a2)
  {
    *(_DWORD *)(a1 + 160) = a2;
    sub_49F68(*(void *)a1, 1819503987);
    uint64_t v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 160);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory mListenModeSupported set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void *sub_23A38(uint64_t a1, uint64_t a2, void *a3)
{
  int v5 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v71) = 0;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "InitializeCommonAccessoryFeatureFromDevice", (uint8_t *)&v71, 2u);
  }
  string = xpc_dictionary_get_string(a3, "kBTAudioMsgPropertyName");
  if (string)
  {
    long long v71 = 0uLL;
    sub_5CDCC((uint64_t)&v71, a1 + 64);
    __int16 v7 = *(const void **)(a1 + 32);
    if (v7)
    {
      CFRelease(v7);
      *(void *)(a1 + 32) = 0;
    }
    CFStringRef v8 = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
    *(void *)(a1 + 32) = v8;
    int v9 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412290;
      CFStringRef v74 = v8;
    }
    sub_5CF10(&v71);
  }
  else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
  {
    sub_65EC0();
  }
  int v10 = (char *)xpc_dictionary_get_string(a3, "kBTAudioMsgPropertyDeviceAddress");
  if (!v10)
  {
    int v11 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
      sub_65E48(v11, v12, v13, v14, v15, v16, v17, v18);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  sub_BAF4(&v71, v10);
  BOOL v19 = (void **)(a1 + 8);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*v19);
  }
  *(_OWORD *)BOOL v19 = v71;
  *(void *)(a1 + 24) = v72;
  if (!xpc_dictionary_get_string(a3, "kBTAudioMsgPropertyDeviceUID"))
  {
    long long v20 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
      sub_63158(v20, v21, v22, v23, v24, v25, v26, v27);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  xpc_object_t value = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyProductID");
  __int16 v29 = value;
  if (value)
  {
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
    {
      int v30 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_65DD0(v30, v31, v32, v33, v34, v35, v36, v37);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    *(_DWORD *)(a1 + 48) = xpc_int64_get_value(v29);
  }
  xpc_object_t v38 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyVersion");
  __int16 v39 = v38;
  if (v38)
  {
    if (xpc_get_type(v38) != (xpc_type_t)&_xpc_type_int64)
    {
      long long v40 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_65D58(v40, v41, v42, v43, v44, v45, v46, v47);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    *(_DWORD *)(a1 + 52) = xpc_int64_get_value(v39);
  }
  xpc_object_t v48 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyVendorID");
  int v49 = v48;
  if (v48)
  {
    if (xpc_get_type(v48) != (xpc_type_t)&_xpc_type_int64)
    {
      __int16 v50 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_65CE0(v50, v51, v52, v53, v54, v55, v56, v57);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    *(_DWORD *)(a1 + 56) = xpc_int64_get_value(v49);
  }
  xpc_object_t v58 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySupportedServices");
  __int16 v60 = v58;
  if (v58)
  {
    if (xpc_get_type(v58) != (xpc_type_t)&_xpc_type_int64)
    {
      int v61 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_65C68(v61, v62, v63, v64, v65, v66, v67, v68);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    *(_DWORD *)(a1 + 192) = xpc_int64_get_value(v60);
  }
  sub_265C8(a1, v59, a3);
  os_log_t result = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyIsAppleAudioDevice");
  uint64_t v70 = result;
  if (result)
  {
    os_log_t result = xpc_get_type(result);
    if (result == &_xpc_type_BOOL)
    {
      os_log_t result = (void *)xpc_BOOL_get_value(v70);
      *(unsigned char *)(a1 + 144) = (_BYTE)result;
    }
  }
  return result;
}

void sub_23E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_23E4C(uint64_t a1)
{
  uint64_t v2 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    *(void *)uint64_t v17 = 0;
    *(void *)&v17[8] = 0;
    sub_5CDCC((uint64_t)v17, a1 + 64);
    uint64_t v3 = *(void *)(a1 + 32);
    sub_5CF10(v17);
    int v4 = *(_DWORD *)(a1 + 48);
    int v5 = *(_DWORD *)(a1 + 52);
    int v6 = *(_DWORD *)(a1 + 56);
    int v7 = *(_DWORD *)(a1 + 192);
    *(_DWORD *)uint64_t v17 = 138413314;
    *(void *)&v17[4] = v3;
    *(_WORD *)&v17[12] = 1024;
    *(_DWORD *)&v17[14] = v4;
    *(_WORD *)&v17[18] = 1024;
    *(_DWORD *)&v17[20] = v5;
    LOWORD(v18) = 1024;
    *(_DWORD *)((char *)&v18 + 2) = v6;
    HIWORD(v18) = 1024;
    LODWORD(v19[0]) = v7;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BTAudioAccessoryDevice : deviceName=%@ ID=%d Version=%d VendorID=%d ServiceMask=%x", v17, 0x24u);
    uint64_t v2 = qword_A1AD0;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 144)) {
      CFStringRef v8 = "Yes";
    }
    else {
      CFStringRef v8 = "No";
    }
    int v9 = *(unsigned __int8 *)(a1 + 156);
    int v10 = *(unsigned __int8 *)(a1 + 157);
    int v11 = *(unsigned __int8 *)(a1 + 200);
    if (*(unsigned char *)(a1 + 274)) {
      uint64_t v12 = "Yes";
    }
    else {
      uint64_t v12 = "No";
    }
    *(_DWORD *)uint64_t v17 = 136316162;
    *(void *)&v17[4] = v8;
    *(_WORD *)&v17[12] = 1024;
    *(_DWORD *)&v17[14] = v9;
    *(_WORD *)&v17[18] = 1024;
    *(_DWORD *)&v17[20] = v10;
    LOWORD(v18) = 1024;
    *(_DWORD *)((char *)&v18 + 2) = v11;
    HIWORD(v18) = 2080;
    v19[0] = v12;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BTAudioAccessoryDevice : Apple Device=%s IED=%d IED En=%d DoAP=%d Software Volume=%s", v17, 0x28u);
    uint64_t v2 = qword_A1AD0;
  }
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 279)) {
      uint64_t v13 = "Yes";
    }
    else {
      uint64_t v13 = "No";
    }
    if (*(unsigned char *)(a1 + 278)) {
      uint64_t v14 = "Yes";
    }
    else {
      uint64_t v14 = "No";
    }
    if (*(unsigned char *)(a1 + 230)) {
      uint64_t v15 = "Yes";
    }
    else {
      uint64_t v15 = "No";
    }
    if (*(unsigned char *)(a1 + 348)) {
      uint64_t v16 = "Yes";
    }
    else {
      uint64_t v16 = "No";
    }
    *(_DWORD *)uint64_t v17 = 136315906;
    *(void *)&v17[4] = v13;
    *(_WORD *)&v17[12] = 2080;
    *(void *)&v17[14] = v14;
    *(_WORD *)&v17[22] = 2080;
    uint64_t v18 = v15;
    LOWORD(v19[0]) = 2080;
    *(void *)((char *)v19 + 2) = v16;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BTAudioAccessoryDevice : mOneBudANCMode=%s mLiveListenSupported=%s mSpatialAudioSupported=%s mTipiConnected=%s", v17, 0x2Au);
  }
}

uint64_t sub_24084(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 368);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 376);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(a1 + 376) = 0;
  }
  int v4 = *(void **)(a1 + 208);
  if (v4) {

  }
  int v5 = *(void **)(a1 + 304);
  if (v5)
  {

    *(void *)(a1 + 304) = 0;
  }
  v25[0] = 0;
  v25[1] = 0;
  sub_5CDCC((uint64_t)v25, a1 + 64);
  int v6 = *(const void **)(a1 + 288);
  if (v6) {
    CFRelease(v6);
  }
  sub_5CEA4((uint64_t)v25);
  int v7 = *(void **)(a1 + 312);
  if (v7) {

  }
  v24[0] = 0;
  v24[1] = 0;
  sub_5CDCC((uint64_t)v24, a1 + 64);
  CFStringRef v8 = *(const void **)(a1 + 32);
  if (v8) {
    CFRelease(v8);
  }
  sub_5CEA4((uint64_t)v24);
  int v9 = *(const void **)(a1 + 136);
  if (v9) {
    CFRelease(v9);
  }
  int v10 = *(const void **)(a1 + 496);
  if (v10) {
    CFRelease(v10);
  }
  v23[0] = 0;
  v23[1] = 0;
  sub_5CDCC((uint64_t)v23, a1 + 64);
  int v11 = *(const void **)(a1 + 264);
  if (v11) {
    CFRelease(v11);
  }
  sub_5CEA4((uint64_t)v23);
  v22[0] = 0;
  v22[1] = 0;
  sub_5CDCC((uint64_t)v22, a1 + 408);
  uint64_t v12 = *(void **)(a1 + 384);
  uint64_t v13 = (void *)(a1 + 392);
  if (v12 != (void *)(a1 + 392))
  {
    do
    {
      uint64_t v14 = (void *)v12[5];
      [v14 cancelExitHandler];

      uint64_t v15 = (void *)v12[1];
      if (v15)
      {
        do
        {
          uint64_t v16 = v15;
          uint64_t v15 = (void *)*v15;
        }
        while (v15);
      }
      else
      {
        do
        {
          uint64_t v16 = (void *)v12[2];
          BOOL v17 = *v16 == (void)v12;
          uint64_t v12 = v16;
        }
        while (!v17);
      }
      uint64_t v12 = v16;
    }
    while (v16 != v13);
  }
  sub_18C7C(a1 + 384, *(void **)(a1 + 392));
  *(void *)(a1 + 392) = 0;
  *(void *)(a1 + 400) = 0;
  *(void *)(a1 + 384) = v13;
  sub_5CF10(v22);
  sub_5CF10(v23);
  sub_5CF10(v24);
  sub_5CF10(v25);
  sub_5CD00(a1 + 520, v18);
  sub_5CD00(a1 + 408, v19);
  sub_18C7C(a1 + 384, *(void **)(a1 + 392));
  sub_5CD00(a1 + 64, v20);
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

uint64_t sub_24270(uint64_t a1)
{
  v18[0] = 0;
  v18[1] = 0;
  sub_5CDCC((uint64_t)v18, a1 + 408);
  uint64_t v2 = *(void **)(a1 + 384);
  if (v2 != (void *)(a1 + 392))
  {
    do
    {
      int v3 = *((_DWORD *)v2 + 8);
      int v4 = (void *)v2[5];
      int v5 = (unint64_t)[v4 HighestQualityFormat] >> 32;
      int v6 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v7 = [v4 spatialRefCount];
        [v4 HighestQualityFormat];
        unsigned __int8 v9 = v8;
        [v4 HighestQualityFormat];
        v17[0] = HIBYTE(v5);
        v17[1] = BYTE2(v5);
        v17[2] = BYTE1(v5);
        v17[3] = v5;
        v17[4] = 0;
        *(_DWORD *)std::string buf = 67110146;
        int v20 = v3;
        __int16 v21 = 1024;
        unsigned int v22 = v7;
        __int16 v23 = 1024;
        int v24 = v9;
        __int16 v25 = 1024;
        int v26 = v10;
        __int16 v27 = 2080;
        int v28 = v17;
        _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Spatial Audio Client PID = %d Ref CFIndex Count = %d [%d %d %s]", buf, 0x24u);
      }
      int v11 = (void *)v2[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          int v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v2[2];
          BOOL v13 = *v12 == (void)v2;
          uint64_t v2 = v12;
        }
        while (!v13);
      }
      uint64_t v2 = v12;
    }
    while (v12 != (void *)(a1 + 392));
  }
  uint64_t v14 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(_DWORD *)(a1 + 232);
    *(_DWORD *)std::string buf = 67109120;
    int v20 = v15;
    _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "Updated Spatial Enable %d", buf, 8u);
  }
  return sub_5CF10(v18);
}

void sub_2447C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

BOOL sub_244A4(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 192);
  int v2 = *(_DWORD *)(a1 + 196);
  int v3 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109888;
    v5[1] = v1 & 0x10011;
    __int16 v6 = 1024;
    int v7 = v1;
    __int16 v8 = 1024;
    int v9 = v2 & 0x10011;
    __int16 v10 = 1024;
    int v11 = v2;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "BTAudioAccessoryDevice : AllProfilesConnected service Mask=%x [%x] Connect Mask=%x[%x]", (uint8_t *)v5, 0x1Au);
  }
  return (v2 & 0x10011 & v1) == (v1 & 0x10011);
}

BOOL sub_24588(uint64_t a1, int a2)
{
  return (*(_DWORD *)(a1 + 192) & a2) != 0;
}

uint64_t sub_24598(uint64_t result, int a2)
{
  *(_DWORD *)(result + 192) |= a2;
  return result;
}

uint64_t sub_245A8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 196) |= a2;
  return result;
}

uint64_t sub_245B8(uint64_t result, int a2)
{
  *(_DWORD *)(result + 196) &= ~a2;
  return result;
}

uint64_t sub_245C8(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, a1 + 64);
  uint64_t v2 = *(void *)(a1 + 32);
  sub_5CF10(v4);
  return v2;
}

void sub_24610(uint64_t a1, int a2, int a3)
{
  if (*(_DWORD *)(a1 + 172) == a2)
  {
    if (*(_DWORD *)(a1 + 176) == a3) {
      return;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 172) = a2;
    sub_49F68(*(void *)a1, 1768256368);
    int v5 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(a1 + 172);
      int v7 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      int v15 = 67109376;
      int v16 = v6;
      __int16 v17 = 1024;
      int v18 = v7;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Accessory mInEarStatusPrimary set to %d for mAudioObjectID %d", (uint8_t *)&v15, 0xEu);
    }
    if (*(_DWORD *)(a1 + 176) == a3) {
      goto LABEL_9;
    }
  }
  *(_DWORD *)(a1 + 176) = a3;
  sub_49F68(*(void *)a1, 1768256371);
  __int16 v8 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *(_DWORD *)(a1 + 176);
    int v10 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
    int v15 = 67109376;
    int v16 = v9;
    __int16 v17 = 1024;
    int v18 = v10;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Accessory mInEarStatusSecondary set to %u for mAudioObjectID %u", (uint8_t *)&v15, 0xEu);
  }
LABEL_9:
  sub_49F68(*(void *)a1, 1768256354);
  int v11 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
    int v13 = *(_DWORD *)(a1 + 172);
    int v14 = *(_DWORD *)(a1 + 176);
    int v15 = 67109632;
    int v16 = v12;
    __int16 v17 = 1024;
    int v18 = v13;
    __int16 v19 = 1024;
    int v20 = v14;
    _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Accessory mInEarStatus set for mAudioObjectID %u. Primary: %u, Secondary: %u", (uint8_t *)&v15, 0x14u);
  }
}

void sub_24864(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 180) != a2)
  {
    *(_DWORD *)(a1 + 180) = a2;
    sub_49F68(*(void *)a1, 1886546291);
    int v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 180);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory PrimaryBudSide set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void sub_24964(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 164) != a2)
  {
    *(_DWORD *)(a1 + 164) = a2;
    sub_49F68(*(void *)a1, 1819505773);
    int v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 164);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory mListenMode set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void sub_24A64(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 184) != a2)
  {
    *(_DWORD *)(a1 + 184) = a2;
    sub_49F68(*(void *)a1, 1684434285);
    int v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 184);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory MicMode set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

uint64_t sub_24B64(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 278) != a2)
  {
    int v3 = (uint64_t *)result;
    *(unsigned char *)(result + 278) = a2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (a2) {
        int v5 = "enabled";
      }
      else {
        int v5 = "disabled";
      }
      int v6 = (*(uint64_t (**)(void))(*(void *)*v3 + 16))();
      int v7 = 136446466;
      int v8 = v5;
      __int16 v9 = 1024;
      int v10 = v6;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "mLiveListenSupported set to %{public}s for mAudioObjectID %d", (uint8_t *)&v7, 0x12u);
    }
    return sub_49F68(*v3, 1819046768);
  }
  return result;
}

uint64_t sub_24C7C(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 325) != a2)
  {
    int v3 = (uint64_t *)result;
    *(unsigned char *)(result + 325) = a2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void))(*(void *)*v3 + 16))();
      v6[0] = 67109376;
      v6[1] = a2;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "mAllowAutoRoute set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
    os_log_t result = sub_395B4();
    if (result) {
      return sub_49F68(*v3, 1635087471);
    }
  }
  return result;
}

uint64_t sub_24D84(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 257) != a2)
  {
    int v3 = (uint64_t *)result;
    *(unsigned char *)(result + 257) = a2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void))(*(void *)*v3 + 16))();
      v6[0] = 67109376;
      v6[1] = a2;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "mHostedDSPOffloadSupported set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
    return sub_49F68(*v3, 1685278578);
  }
  return result;
}

uint64_t sub_24E84(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 249) != a2)
  {
    int v3 = (uint64_t *)result;
    *(unsigned char *)(result + 249) = a2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = a2;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "mPVDRCEnable set to %d", (uint8_t *)v5, 8u);
    }
    return sub_49F68(*v3, 1886807154);
  }
  return result;
}

uint64_t sub_24F50(uint64_t a1)
{
  return *(void *)(a1 + 264);
}

uint64_t sub_24F7C(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 326) != a2)
  {
    int v3 = (uint64_t *)result;
    *(unsigned char *)(result + 326) = a2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void))(*(void *)*v3 + 16))();
      v6[0] = 67109376;
      v6[1] = a2;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "mAudioRouteHidden set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
    return sub_49F68(*v3, 1751737454);
  }
  return result;
}

uint64_t sub_2507C(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 324) != a2)
  {
    int v3 = (uint64_t *)result;
    *(unsigned char *)(result + 324) = a2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void))(*(void *)*v3 + 16))();
      v6[0] = 67109376;
      v6[1] = a2;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "mUserSelectedDeviceType set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
    return sub_49F68(*v3, 1970496630);
  }
  return result;
}

void sub_2517C(uint64_t a1, int a2)
{
  if ((*(unsigned char *)(a1 + 200) != 0) != a2)
  {
    *(unsigned char *)(a1 + 200) = a2;
    sub_49F68(*(void *)a1, 1685021040);
    int v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(unsigned __int8 *)(a1 + 200);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory mDoAPSupported set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

uint64_t sub_25284(uint64_t result, void *a2)
{
  if (a2)
  {
    int v3 = (uint64_t *)result;
    int v4 = *(void **)(result + 208);
    if (v4 != a2)
    {

      v3[26] = (uint64_t)a2;
      id v5 = a2;
      int v6 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = v3[26];
        int v8 = (*(uint64_t (**)(void))(*(void *)*v3 + 16))();
        int v9 = 138412546;
        uint64_t v10 = v7;
        __int16 v11 = 1024;
        int v12 = v8;
        _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "DoAP UUID %@ for mAudioObjectID %d", (uint8_t *)&v9, 0x12u);
      }
      return sub_49F68(*v3, 1685088612);
    }
  }
  return result;
}

void sub_25394(unsigned char *a1, int a2)
{
  if ((a1[240] != 0) != a2)
  {
    a1[240] = a2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = a2;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Accessory mCustomHRTFSupported set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void sub_2548C(uint64_t a1, int a2)
{
  int v2 = a2;
  if (!*(unsigned char *)(a1 + 144) || ((int v4 = *(_DWORD *)(a1 + 48), v4 != 8229) ? (v5 = v4 == 8215) : (v5 = 1), !v5))
  {
    int v9 = (unsigned char *)(a1 + 230);
    if ((*(unsigned char *)(a1 + 230) != 0) == a2) {
      return;
    }
    goto LABEL_12;
  }
  int v6 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(unsigned __int8 *)(a1 + 230);
    int v8 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
    int v12 = 67109376;
    int v13 = v7;
    __int16 v14 = 1024;
    int v15 = v8;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Accessory mSpatialAudioSupported Overwritten %d for mAudioObjectID %d", (uint8_t *)&v12, 0xEu);
  }
  int v9 = (unsigned char *)(a1 + 230);
  if (!*(unsigned char *)(a1 + 230))
  {
    int v2 = 1;
LABEL_12:
    *int v9 = v2;
    uint64_t v10 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      int v12 = 67109376;
      int v13 = v2;
      __int16 v14 = 1024;
      int v15 = v11;
      _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Accessory mSpatialAudioSupported set to %d for mAudioObjectID %d", (uint8_t *)&v12, 0xEu);
    }
  }
}

BOOL sub_25640(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 144)) {
    return 0;
  }
  int v1 = *(_DWORD *)(a1 + 48);
  return v1 == 8215 || v1 == 8229;
}

uint64_t sub_2566C(uint64_t a1, char a2)
{
  uint64_t result = _os_feature_enabled_impl();
  *(unsigned char *)(a1 + 228) = result & a2;
  return result;
}

void sub_256AC(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 238) != a2)
  {
    *(unsigned char *)(a1 + 238) = a2;
    sub_49F68(*(void *)a1, 1752327777);
    int v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(unsigned __int8 *)(a1 + 238);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory mSoundProfileAllowed set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void sub_257AC(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 239) != a2)
  {
    *(unsigned char *)(a1 + 239) = a2;
    sub_49F68(*(void *)a1, 1752327777);
    int v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(unsigned __int8 *)(a1 + 239);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory mSoundProfileEnhancedTuning set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void sub_258AC(uint64_t a1, int a2)
{
  if ((*(unsigned char *)(a1 + 236) != 0) != a2)
  {
    *(unsigned char *)(a1 + 236) = a2;
    sub_49F68(*(void *)a1, 1936746611);
    int v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(unsigned __int8 *)(a1 + 236);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory mSpatialAudioUserEnableFeature set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void sub_259B4(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 244) != a2)
  {
    *(_DWORD *)(a1 + 244) = a2;
    sub_49F68(*(void *)a1, 1936225136);
    int v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 244);
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = v4;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Accessory mStereoHfpCodecIDSupported set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void sub_25AB4(unsigned char *a1, int a2)
{
  if (*((_DWORD *)a1 + 61))
  {
    uint64_t v3 = *(void *)(*(void *)a1 + 9096);
    if (v3 && *(unsigned char *)(v3 + 192))
    {
      if ((a1[248] != 0) != a2)
      {
        a1[248] = a2;
        char v12 = 0;
        if (sub_395B4())
        {
          if (a2)
          {
            sub_59E8C(*(void *)a1, &v12, 1);
            if (*(unsigned char *)(*(void *)(*(void *)a1 + 9096) + 192)) {
              uint64_t v5 = *(void *)(*(void *)a1 + 9096);
            }
            else {
              uint64_t v5 = 0;
            }
            (*(void (**)(void))(*(void *)v5 + 528))();
          }
        }
        else
        {
          if (*(unsigned char *)(*(void *)(*(void *)a1 + 9096) + 192)) {
            uint64_t v6 = *(void *)(*(void *)a1 + 9096);
          }
          else {
            uint64_t v6 = 0;
          }
          (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 528))(v6, 3);
        }
        sub_49F68(*(void *)a1, 1936221550);
        __int16 v7 = qword_A1AD0;
        if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = a1[248];
          int v9 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
          if (*(unsigned char *)(*(void *)(*(void *)a1 + 9096) + 192)) {
            uint64_t v10 = *(void *)(*(void *)a1 + 9096);
          }
          else {
            uint64_t v10 = 0;
          }
          (*(void (**)(void *__return_ptr))(*(void *)v10 + 800))(v11);
          *(_DWORD *)std::string buf = 67109632;
          int v14 = v8;
          __int16 v15 = 1024;
          int v16 = v9;
          __int16 v17 = 2048;
          uint64_t v18 = v11[0];
          _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "HFPstereo publish, Accessory mStereoHfpEnabled set to %d for mAudioObjectID %d, samplerate: %f", buf, 0x18u);
        }
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
    {
      sub_65F28();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
  {
    sub_65EF4();
  }
}

void sub_25D48(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 320) != a2)
  {
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (a2 > 2) {
        uint64_t v5 = "Unknown";
      }
      else {
        uint64_t v5 = off_8E210[a2];
      }
      memset(__p, 0, 24);
      sub_BAF4(__p, v5);
      if (SHIBYTE(__p[2]) >= 0) {
        uint64_t v6 = __p;
      }
      else {
        uint64_t v6 = (void **)__p[0];
      }
      __int16 v7 = "YES";
      if (!*(unsigned char *)(a1 + 256)) {
        __int16 v7 = "NO";
      }
      *(_DWORD *)std::string buf = 136446466;
      *(void *)&uint8_t buf[4] = v6;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v7;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "RemoteStreamState set to %{public}s Spatial Busy %{public}s", buf, 0x16u);
      if (SHIBYTE(__p[2]) < 0) {
        operator delete(__p[0]);
      }
    }
    *(_DWORD *)(a1 + 320) = a2;
    int v8 = *(_DWORD *)(a1 + 60);
    memset(buf, 0, sizeof(buf));
    if (*(char *)(a1 + 31) < 0)
    {
      sub_B9AC(buf, *(void **)(a1 + 8), *(void *)(a1 + 16));
    }
    else
    {
      *(_OWORD *)std::string buf = *(_OWORD *)(a1 + 8);
      *(void *)&uint8_t buf[16] = *(void *)(a1 + 24);
    }
    uint64_t v9 = qword_A2350;
    if ((char)buf[23] < 0)
    {
      sub_B9AC(v27, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)__int16 v27 = *(_OWORD *)buf;
      uint64_t v28 = *(void *)&buf[16];
    }
    int v10 = sub_41A44(v9, (uint64_t)v27);
    if (SHIBYTE(v28) < 0) {
      operator delete(v27[0]);
    }
    int v11 = *(unsigned __int8 *)(a1 + 145);
    char v12 = *(unsigned char **)(*(void *)a1 + 9088);
    if (v12 && v12[192])
    {
      uint64_t v13 = qword_A2350;
      int v14 = (*(uint64_t (**)(unsigned char *))(*(void *)v12 + 16))(v12);
      int v15 = sub_444E0(v13, v14);
    }
    else
    {
      int v15 = 0;
    }
    unsigned __int8 v16 = sub_429C4(qword_A2350);
    unsigned int v17 = a2 - 3;
    unsigned int v18 = v8 - 1;
    __int16 v19 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 348)) {
        int v20 = "TiPi";
      }
      else {
        int v20 = "Triangle";
      }
      __int16 v21 = buf;
      if ((buf[23] & 0x80u) != 0) {
        __int16 v21 = *(uint8_t **)buf;
      }
      LODWORD(__p[0]) = 136446722;
      *(void **)((char *)__p + 4) = (void *)v20;
      WORD2(__p[1]) = 2082;
      *(void **)((char *)&__p[1] + 6) = v21;
      if (v10) {
        unsigned int v22 = "Yes";
      }
      else {
        unsigned int v22 = "No";
      }
      HIWORD(__p[2]) = 2082;
      __p[3] = (void *)v22;
      _os_log_impl(&dword_0, v19, OS_LOG_TYPE_DEFAULT, "%{public}s Ownership Status : device %{public}s. Device Stream Status %{public}s", (uint8_t *)__p, 0x20u);
    }
    if (v18 < 2) {
      int v23 = 1;
    }
    else {
      int v23 = v10;
    }
    if (v17 < 0xFFFFFFFE) {
      int v23 = 1;
    }
    if (!v11) {
      int v23 = 1;
    }
    if (((v23 | v15) & 1) == 0 && ((v16 & 1) != 0 || *(unsigned char *)(a1 + 348)))
    {
      int v24 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        if (*(unsigned char *)(a1 + 348)) {
          __int16 v25 = "TiPi";
        }
        else {
          __int16 v25 = "Triangle";
        }
        int v26 = buf;
        if ((buf[23] & 0x80u) != 0) {
          int v26 = *(uint8_t **)buf;
        }
        LODWORD(__p[0]) = 136446466;
        *(void **)((char *)__p + 4) = (void *)v25;
        WORD2(__p[1]) = 2082;
        *(void **)((char *)&__p[1] + 6) = v26;
        _os_log_impl(&dword_0, v24, OS_LOG_TYPE_DEFAULT, "%{public}s sync mismatch warning:device %{public}s", (uint8_t *)__p, 0x16u);
      }
    }
    if ((char)buf[23] < 0) {
      operator delete(*(void **)buf);
    }
  }
}

void sub_260F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void *sub_26134@<X0>(unsigned int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 2) {
    int v2 = "Unknown";
  }
  else {
    int v2 = off_8E210[a1];
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_BAF4(a2, v2);
}

uint64_t sub_26164(uint64_t *a1, const char *a2)
{
  v6[0] = 0;
  v6[1] = 0;
  sub_5CDCC((uint64_t)v6, (uint64_t)(a1 + 8));
  int v4 = (const void *)a1[4];
  if (v4) {
    CFRelease(v4);
  }
  a1[4] = (uint64_t)CFStringCreateWithCString(kCFAllocatorDefault, a2, 0x8000100u);
  sub_5CEA4((uint64_t)v6);
  sub_49F68(*a1, 1819173229);
  return sub_5CF10(v6);
}

void sub_261EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_26200(float *a1, float a2)
{
  if (a2 != -1.0 && a1[70] != a2)
  {
    a1[70] = a2;
    uint64_t v5 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      int v7 = 134218240;
      double v8 = a2;
      __int16 v9 = 1024;
      int v10 = v6;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "mDosimetrySensitivity set to %f for mAudioObjectID %d", (uint8_t *)&v7, 0x12u);
    }
    sub_49F68(*(void *)a1, 1685025637);
    if (*(void *)a1) {
      sub_58450(*(void *)a1);
    }
  }
}

CFIndex sub_26318(CFIndex result, const void *a2)
{
  if (a2)
  {
    uint64_t v3 = (uint64_t *)result;
    int v4 = *(void **)(result + 288);
    if (!v4
      || (uint64_t result = (CFIndex)[v4 isEqualToArray:a2], (result & 1) == 0)
      && (!v3[36] || (uint64_t result = CFArrayGetCount((CFArrayRef)a2)) != 0))
    {
      uint64_t v5 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = (*(uint64_t (**)(void))(*(void *)*v3 + 16))();
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v6;
        _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "mDosimetryVolumeCurve set for mAudioObjectID %d", buf, 8u);
      }
      *(void *)std::string buf = 0;
      uint64_t v10 = 0;
      sub_5CDCC((uint64_t)buf, (uint64_t)(v3 + 8));
      int v7 = (const void *)v3[36];
      if (v7) {
        CFRelease(v7);
      }
      sub_5CEA4((uint64_t)buf);
      v3[36] = (uint64_t)a2;
      CFRetain(a2);
      sub_49F68(*v3, 1685026403);
      v8[0] = 0;
      v8[1] = 0;
      sub_5CDCC((uint64_t)v8, (uint64_t)(v3 + 8));
      if (*v3) {
        sub_5847C(*v3);
      }
      sub_5CEA4((uint64_t)v8);
      sub_5CF10(v8);
      return sub_5CF10(buf);
    }
  }
  return result;
}

void sub_26490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

void *sub_264C0(void *result, uint64_t a2)
{
  if (*((unsigned __int8 *)result + 296) != a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    *((unsigned char *)result + 296) = a2;
    int v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void))(*(void *)*v3 + 16))();
      v6[0] = 67109376;
      v6[1] = v2;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "mEURegionBit set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
      uint64_t v2 = *((unsigned __int8 *)v3 + 296);
    }
    return [(id)v3[38] updateRegionalDosimetryVolumeCurve:v2 productID:*((unsigned int *)v3 + 12) audioDevice:*v3];
  }
  return result;
}

void sub_265C8(uint64_t a1, uint64_t a2, void *a3)
{
  int v5 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "UpdateAccessoryFeatureFromDevice", buf, 2u);
  }
  xpc_object_t value = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySupportedServices");
  __int16 v7 = value;
  if (value)
  {
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
    {
      int v8 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_66A58(v8, v9, v10, v11, v12, v13, v14, v15);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    *(_DWORD *)(a1 + 192) = xpc_int64_get_value(v7);
  }
  xpc_object_t v16 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyIsAppleAudioDevice");
  unsigned int v17 = v16;
  if (v16 && xpc_get_type(v16) == (xpc_type_t)&_xpc_type_BOOL) {
    *(unsigned char *)(a1 + 144) = xpc_BOOL_get_value(v17);
  }
  xpc_object_t v18 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyLocalStreamState");
  __int16 v19 = v18;
  if (v18)
  {
    if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_int64)
    {
      int v20 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_669E0(v20, v21, v22, v23, v24, v25, v26, v27);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    *(_DWORD *)(a1 + 60) = xpc_int64_get_value(v19);
  }
  xpc_object_t v28 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyInEarDetection");
  __int16 v29 = v28;
  if (v28)
  {
    if (xpc_get_type(v28) != (xpc_type_t)&_xpc_type_BOOL)
    {
      int v30 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_66968(v30, v31, v32, v33, v34, v35, v36, v37);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v38 = xpc_BOOL_get_value(v29);
    sub_235B8((unsigned char *)a1, v38);
  }
  xpc_object_t v39 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyExtentedHfpVolumeRange");
  long long v40 = v39;
  if (v39 && xpc_get_type(v39) == (xpc_type_t)&_xpc_type_BOOL)
  {
    BOOL v41 = xpc_BOOL_get_value(v40);
    sub_236C8((unsigned char *)a1, v41);
  }
  if (*(unsigned char *)(a1 + 156))
  {
    xpc_object_t v42 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyInEarEnabled");
    if (xpc_get_type(v42) != (xpc_type_t)&_xpc_type_BOOL)
    {
      uint64_t v43 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_668F0(v43, v44, v45, v46, v47, v48, v49, v50);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v51 = xpc_BOOL_get_value(v42);
    sub_23818(a1, v51);
    xpc_object_t v52 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyInEarStatus");
    uint64_t v53 = v52;
    if (v52)
    {
      if (xpc_get_type(v52) != (xpc_type_t)&_xpc_type_int64)
      {
        uint64_t v54 = qword_A1AD0;
        if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
          sub_66878(v54, v55, v56, v57, v58, v59, v60, v61);
        }
        if (sub_5CB00()) {
          abort();
        }
      }
      __int16 v62 = xpc_int64_get_value(v53);
      sub_24610(a1, v62, HIBYTE(v62));
    }
    else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
    {
      sub_66844();
    }
    xpc_object_t v63 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyPrimaryBudSide");
    if (xpc_get_type(v63) != (xpc_type_t)&_xpc_type_int64)
    {
      uint64_t v64 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_667CC(v64, v65, v66, v67, v68, v69, v70, v71);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    int v72 = xpc_int64_get_value(v63);
    sub_24864(a1, v72);
    xpc_object_t v73 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyFixedMicRole");
    if (xpc_get_type(v73) != (xpc_type_t)&_xpc_type_int64)
    {
      CFStringRef v74 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_66754(v74, v75, v76, v77, v78, v79, v80, v81);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    int v82 = xpc_int64_get_value(v73);
    sub_24A64(a1, v82);
  }
  xpc_object_t v83 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyDOAPUuid");
  if (v83)
  {
    id v84 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_uuid_get_bytes(v83)];
    sub_25284(a1, v84);
  }
  xpc_object_t v85 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyListenModeSupported");
  v86 = v85;
  if (v85)
  {
    if (xpc_get_type(v85) != (xpc_type_t)&_xpc_type_int64)
    {
      v87 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_666DC(v87, v88, v89, v90, v91, v92, v93, v94);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    int v95 = xpc_int64_get_value(v86);
    sub_23938(a1, v95);
    if (xpc_int64_get_value(v86))
    {
      xpc_object_t v96 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyListenMode");
      v97 = v96;
      if (v96)
      {
        if (xpc_get_type(v96) != (xpc_type_t)&_xpc_type_int64)
        {
          v98 = qword_A1AD0;
          if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
            sub_66664(v98, v99, v100, v101, v102, v103, v104, v105);
          }
          if (sub_5CB00()) {
            abort();
          }
        }
        int v106 = xpc_int64_get_value(v97);
        sub_24964(a1, v106);
      }
    }
  }
  uint64_t v107 = qword_A2350;
  v108 = (_OWORD *)(a1 + 8);
  if (*(char *)(a1 + 31) < 0)
  {
    sub_B9AC(__p, *(void **)(a1 + 8), *(void *)(a1 + 16));
  }
  else
  {
    *(_OWORD *)std::string __p = *v108;
    uint64_t v367 = *(void *)(a1 + 24);
  }
  int v109 = sub_4295C(v107, (unsigned __int8 **)__p);
  *(unsigned char *)(a1 + 145) = v109;
  if (SHIBYTE(v367) < 0)
  {
    operator delete(__p[0]);
    int v109 = *(unsigned __int8 *)(a1 + 145);
  }
  v110 = qword_A1AD0;
  if (v109 && os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_0, v110, OS_LOG_TYPE_DEFAULT, "Corresponding A2DP device was owned already, initializing to owned", buf, 2u);
    v110 = qword_A1AD0;
  }
  int v111 = *(unsigned __int8 *)(a1 + 144);
  *(unsigned char *)(a1 + 277) = v111;
  if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
  {
    v112 = "supported.";
    if (!v111) {
      v112 = "not supported";
    }
    *(_DWORD *)std::string buf = 136315138;
    v369 = v112;
    _os_log_impl(&dword_0, v110, OS_LOG_TYPE_DEFAULT, "Ownership is %s", buf, 0xCu);
    int v111 = *(unsigned __int8 *)(a1 + 277);
  }
  if (v111)
  {
    uint64_t v113 = qword_A2350;
    if (*(char *)(a1 + 31) < 0)
    {
      sub_B9AC(v364, *(void **)(a1 + 8), *(void *)(a1 + 16));
    }
    else
    {
      *(_OWORD *)v364 = *v108;
      uint64_t v365 = *(void *)(a1 + 24);
    }
    int v114 = sub_4295C(v113, (unsigned __int8 **)v364);
    *(unsigned char *)(a1 + 145) = v114;
    if (SHIBYTE(v365) < 0)
    {
      operator delete(v364[0]);
      int v114 = *(unsigned __int8 *)(a1 + 145);
    }
    if (v114)
    {
      v115 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v115, OS_LOG_TYPE_DEFAULT, "Corresponding A2DP device was owned already, initializing to owned", buf, 2u);
      }
    }
  }
  xpc_object_t v116 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyDOAPSupported");
  v117 = v116;
  if (v116)
  {
    if (xpc_get_type(v116) != (xpc_type_t)&_xpc_type_BOOL)
    {
      v118 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_665EC(v118, v119, v120, v121, v122, v123, v124, v125);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v126 = xpc_BOOL_get_value(v117);
    sub_2517C(a1, v126);
  }
  xpc_object_t v127 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyLiveListenSupported");
  v128 = v127;
  if (v127)
  {
    if (xpc_get_type(v127) != (xpc_type_t)&_xpc_type_BOOL)
    {
      v129 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_66574(v129, v130, v131, v132, v133, v134, v135, v136);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v137 = xpc_BOOL_get_value(v128);
    sub_24B64(a1, v137);
  }
  xpc_object_t v138 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyOneBudANCMode");
  v139 = v138;
  if (v138)
  {
    if (xpc_get_type(v138) != (xpc_type_t)&_xpc_type_int64)
    {
      v140 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_664FC(v140, v141, v142, v143, v144, v145, v146, v147);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    *(unsigned char *)(a1 + 279) = xpc_int64_get_value(v139);
  }
  xpc_object_t v148 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyRemoteStreamState");
  v149 = v148;
  if (v148)
  {
    if (xpc_get_type(v148) != (xpc_type_t)&_xpc_type_int64)
    {
      v150 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_66484(v150, v151, v152, v153, v154, v155, v156, v157);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    unsigned int v158 = xpc_int64_get_value(v149);
    sub_25D48(a1, v158);
  }
  xpc_object_t v159 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyWSModeSupported");
  if (v159) {
    *(unsigned char *)(a1 + 327) = xpc_BOOL_get_value(v159);
  }
  xpc_object_t v160 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyWSIsGuestDevice");
  if (v160)
  {
    BOOL v161 = xpc_BOOL_get_value(v160);
    *(unsigned char *)(a1 + 329) = v161;
    if (v161)
    {
      *(unsigned char *)(a1 + 277) = 0;
      v162 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 136315138;
        v369 = "not supported";
        _os_log_impl(&dword_0, v162, OS_LOG_TYPE_DEFAULT, "Wireless Splitter guest device ownership is being set to  %s", buf, 0xCu);
      }
    }
  }
  if (*(unsigned char *)(a1 + 327))
  {
    xpc_object_t v163 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyWSIsGuestNotInContactsDevice");
    if (v163)
    {
      BOOL v164 = xpc_BOOL_get_value(v163);
      *(unsigned char *)(a1 + 330) = v164;
      if (*(unsigned char *)(a1 + 329))
      {
        v165 = qword_A1AD0;
        if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
        {
          v166 = "In Contacts";
          if (v164) {
            v166 = "Not In Contacts.";
          }
          *(_DWORD *)std::string buf = 136315138;
          v369 = v166;
          _os_log_impl(&dword_0, v165, OS_LOG_TYPE_DEFAULT, "Wireless Splitter guest device %s", buf, 0xCu);
        }
      }
    }
    xpc_object_t v167 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyWSModeEnabled");
    if (v167) {
      *(unsigned char *)(a1 + 328) = xpc_BOOL_get_value(v167);
    }
  }
  v168 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 327)) {
      v169 = "supported";
    }
    else {
      v169 = "not supported ";
    }
    v170 = "enabled";
    if (!*(unsigned char *)(a1 + 328)) {
      v170 = "not enabled ";
    }
    *(_DWORD *)std::string buf = 136315394;
    v369 = v169;
    __int16 v370 = 2080;
    v371 = v170;
    _os_log_impl(&dword_0, v168, OS_LOG_TYPE_DEFAULT, "Wireless Splitter is %s and %s", buf, 0x16u);
  }
  xpc_object_t v171 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyDigitalCrownSupported");
  v172 = v171;
  if (v171)
  {
    BOOL v173 = xpc_BOOL_get_value(v171);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureDigitalCrown", v173);
    *(unsigned char *)(a1 + 217) = xpc_BOOL_get_value(v172);
  }
  xpc_object_t v174 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyBudSideLoudnessEqControlSupported");
  if (v174)
  {
    v175 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v176 = xpc_BOOL_get_value(v174);
      v177 = "not supported";
      if (v176) {
        v177 = "supported";
      }
      *(_DWORD *)std::string buf = 136315138;
      v369 = v177;
      _os_log_impl(&dword_0, v175, OS_LOG_TYPE_DEFAULT, "Bud side loudness EQ control is %s", buf, 0xCu);
    }
    BOOL v178 = xpc_BOOL_get_value(v174);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureBudSideLoudnessEqControlSupport", v178);
  }
  xpc_object_t v179 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyBudSideLoudnessEqEnabled");
  if (v179)
  {
    v180 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v181 = xpc_BOOL_get_value(v179);
      v182 = "disabled";
      if (v181) {
        v182 = "enabled";
      }
      *(_DWORD *)std::string buf = 136315138;
      v369 = v182;
      _os_log_impl(&dword_0, v180, OS_LOG_TYPE_DEFAULT, "Bud side loudness EQ is %s", buf, 0xCu);
    }
    *(unsigned char *)(a1 + 218) = xpc_BOOL_get_value(v179);
  }
  xpc_object_t v183 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyUWBSStereoSupport");
  if (v183)
  {
    BOOL v184 = xpc_BOOL_get_value(v183);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureStereoHfpSupport", v184);
  }
  xpc_object_t v185 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySupportSpatialAudio");
  v186 = v185;
  if (v185)
  {
    BOOL v187 = xpc_BOOL_get_value(v185);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureHeadTrackedSpatialAudio", v187);
    BOOL v188 = xpc_BOOL_get_value(v186);
    sub_2548C(a1, v188);
  }
  xpc_object_t v189 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyAllowSoundProfile");
  if (v189)
  {
    BOOL v190 = xpc_BOOL_get_value(v189);
    sub_256AC(a1, v190);
  }
  xpc_object_t v191 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySoundProfileEnhancedTuning");
  if (v191)
  {
    BOOL v192 = xpc_BOOL_get_value(v191);
    sub_257AC(a1, v192);
  }
  xpc_object_t v193 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyAdaptiveVolume");
  if (v193)
  {
    BOOL v194 = xpc_BOOL_get_value(v193);
    *(unsigned char *)(a1 + 228) = v194 & _os_feature_enabled_impl();
    v195 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      v196 = "not supported";
      if (v194) {
        v196 = "supported";
      }
      *(_DWORD *)std::string buf = 136315138;
      v369 = v196;
      _os_log_impl(&dword_0, v195, OS_LOG_TYPE_DEFAULT, "Adaptive Volume: feature %s", buf, 0xCu);
    }
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureAdaptiveVolume", v194);
  }
  xpc_object_t v197 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyAdaptiveVolumeMode");
  if (v197)
  {
    char v198 = xpc_int64_get_value(v197);
    *(unsigned char *)(a1 + 229) = v198;
    v199 = +[BTAudioAVNotificationMonitor sharedInstance];
    if (v199) {
      [(BTAudioAVNotificationMonitor *)v199 personalizedVolumeEnabled:v198 == 1];
    }
    v200 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (v198 == 1) {
        v201 = "enabled";
      }
      else {
        v201 = "disabled";
      }
      *(_DWORD *)std::string buf = 136315138;
      v369 = v201;
      _os_log_impl(&dword_0, v200, OS_LOG_TYPE_DEFAULT, "Adaptive Volume: Configration %s", buf, 0xCu);
    }
  }
  xpc_object_t v202 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyMuteControl");
  if (v202)
  {
    BOOL v203 = xpc_BOOL_get_value(v202);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureMuteControl", v203);
  }
  xpc_object_t v204 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyConversationDetect");
  if (v204)
  {
    BOOL v205 = xpc_BOOL_get_value(v204);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureConversationDetect", v205);
  }
  xpc_object_t v206 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySupportSoundProfile");
  v207 = v206;
  if (v206)
  {
    BOOL v208 = xpc_BOOL_get_value(v206);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureCustomHRTF", v208);
    BOOL v209 = xpc_BOOL_get_value(v207);
    sub_25394((unsigned char *)a1, v209);
  }
  if (xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySoundProfile"))
  {
    v210 = (IR::IRData *)_CFXPCCreateCFObjectFromXPCObject();
    v211 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412290;
      v369 = (const char *)v210;
      _os_log_impl(&dword_0, v211, OS_LOG_TYPE_DEFAULT, "BTAudioCloudSyncMonitor: received %@", buf, 0xCu);
    }
    sub_45914(qword_A2350, v210);
    if (v210) {
      CFRelease(v210);
    }
  }
  xpc_object_t v212 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySupportHighQualityBiDirectionalAudio");
  if (v212)
  {
    v213 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v214 = xpc_BOOL_get_value(v212);
      *(_DWORD *)std::string buf = 67109120;
      LODWORD(v369) = v214;
      _os_log_impl(&dword_0, v213, OS_LOG_TYPE_DEFAULT, "BTAudiohighQuality BiDirectional Audio: received %d", buf, 8u);
    }
    *(unsigned char *)(a1 + 237) = xpc_BOOL_get_value(v212);
    BOOL v215 = xpc_BOOL_get_value(v212);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureHighQualityBiDirectionalAudio", v215);
  }
  xpc_object_t v216 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyTipiSupported");
  v217 = v216;
  if (v216)
  {
    if (xpc_get_type(v216) == (xpc_type_t)&_xpc_type_BOOL)
    {
      BOOL v218 = xpc_BOOL_get_value(v217);
      *(unsigned char *)(a1 + 250) = v218;
      v219 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        v220 = "not support";
        if (v218) {
          v220 = "support";
        }
        *(_DWORD *)std::string buf = 136315138;
        v369 = v220;
        _os_log_impl(&dword_0, v219, OS_LOG_TYPE_DEFAULT, "TiPi is %s", buf, 0xCu);
      }
    }
  }
  if (*(unsigned char *)(a1 + 230))
  {
    xpc_object_t v221 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyAllowSpatialAudio");
    if (v221)
    {
      BOOL v222 = xpc_BOOL_get_value(v221);
      sub_258AC(a1, v222);
    }
    xpc_object_t v223 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySpatialPerAppModeMap");
    if (v223)
    {
      if (xpc_get_type(v223) != (xpc_type_t)&_xpc_type_dictionary)
      {
        v224 = qword_A1AD0;
        if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
          sub_6640C(v224, v225, v226, v227, v228, v229, v230, v231);
        }
        if (sub_5CB00()) {
          abort();
        }
      }
      CFDictionaryRef v232 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
      v233 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        int Count = CFDictionaryGetCount(v232);
        *(_DWORD *)std::string buf = 67109120;
        LODWORD(v369) = Count;
        _os_log_impl(&dword_0, v233, OS_LOG_TYPE_DEFAULT, "Per App Spatial information : %d", buf, 8u);
      }
      sub_27E84(a1, v232);
      sub_27EFC(a1);
      if (v232) {
        CFRelease(v232);
      }
    }
  }
  xpc_object_t v235 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyAdaptiveVolumeMap");
  if (v235)
  {
    if (xpc_get_type(v235) != (xpc_type_t)&_xpc_type_dictionary)
    {
      v236 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_66394(v236, v237, v238, v239, v240, v241, v242, v243);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    CFDictionaryRef v244 = (const __CFDictionary *)_CFXPCCreateCFObjectFromXPCObject();
    v245 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v246 = CFDictionaryGetCount(v244);
      *(_DWORD *)std::string buf = 67109120;
      LODWORD(v369) = v246;
      _os_log_impl(&dword_0, v245, OS_LOG_TYPE_DEFAULT, "Adaptive Volume information: %d", buf, 8u);
    }
    sub_27F6C((CFDictionaryRef *)a1, v244);
    if (v244) {
      CFRelease(v244);
    }
  }
  xpc_object_t v247 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySoftwareVolumeSupported");
  if (v247) {
    *(unsigned char *)(a1 + 274) = xpc_BOOL_get_value(v247);
  }
  xpc_object_t v248 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySupportRemoteVolumeChange");
  if (v248) {
    *(unsigned char *)(a1 + 276) = xpc_BOOL_get_value(v248);
  }
  xpc_object_t v249 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyTipiConnected");
  if (v249) {
    *(unsigned char *)(a1 + 348) = xpc_BOOL_get_value(v249);
  }
  xpc_object_t v250 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyDeviceUUID");
  v251 = v250;
  if (v250)
  {
    if (xpc_get_type(v250) != (xpc_type_t)&_xpc_type_uuid)
    {
      v252 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_6631C(v252, v253, v254, v255, v256, v257, v258, v259);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    v260 = *(void **)(a1 + 312);
    if (v260) {

    }
    *(void *)(a1 + 312) = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_uuid_get_bytes(v251)];
  }
  xpc_object_t v261 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyDosimetrySensitivity");
  v262 = v261;
  if (v261)
  {
    if (xpc_get_type(v261) != (xpc_type_t)&_xpc_type_double)
    {
      v263 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_662A4(v263, v264, v265, v266, v267, v268, v269, v270);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    float v271 = xpc_double_get_value(v262);
    sub_26200((float *)a1, v271);
  }
  xpc_object_t v272 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyDosimetryVolumeCurve");
  if (v272)
  {
    if (xpc_get_type(v272) != (xpc_type_t)&_xpc_type_array)
    {
      v273 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_6622C(v273, v274, v275, v276, v277, v278, v279, v280);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    v281 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
    v282 = qword_A1AD0;
    BOOL v283 = os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT);
    if (v281)
    {
      if (v283)
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v282, OS_LOG_TYPE_DEFAULT, "Set VolumeCurve", buf, 2u);
      }
      sub_26318(a1, v281);
      CFRelease(v281);
    }
    else if (v283)
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v282, OS_LOG_TYPE_DEFAULT, "Set VolumeCurve with NULL", buf, 2u);
    }
  }
  xpc_object_t v284 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyEURegionBit");
  v285 = v284;
  if (v284)
  {
    if (xpc_get_type(v284) != (xpc_type_t)&_xpc_type_int64)
    {
      v286 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_661B4(v286, v287, v288, v289, v290, v291, v292, v293);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    *(unsigned char *)(a1 + 296) = xpc_int64_get_value(v285);
  }
  xpc_object_t v294 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyAllowSCOForTBT");
  v295 = v294;
  if (v294)
  {
    if (xpc_get_type(v294) != (xpc_type_t)&_xpc_type_BOOL)
    {
      v296 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_6613C(v296, v297, v298, v299, v300, v301, v302, v303);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v304 = xpc_BOOL_get_value(v295);
    sub_280B0(a1, v304);
  }
  xpc_object_t v305 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyAllowAutoRoute");
  v306 = v305;
  if (v305)
  {
    if (xpc_get_type(v305) != (xpc_type_t)&_xpc_type_BOOL)
    {
      v307 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_660C4(v307, v308, v309, v310, v311, v312, v313, v314);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v315 = xpc_BOOL_get_value(v306);
    sub_24C7C(a1, v315);
  }
  xpc_object_t v316 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyIsHidden");
  v317 = v316;
  if (v316)
  {
    if (xpc_get_type(v316) != (xpc_type_t)&_xpc_type_BOOL)
    {
      v318 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_6604C(v318, v319, v320, v321, v322, v323, v324, v325);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v326 = xpc_BOOL_get_value(v317);
    sub_24F7C(a1, v326);
  }
  xpc_object_t v327 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyUserSelectedDeviceType");
  v328 = v327;
  if (v327)
  {
    if (xpc_get_type(v327) != (xpc_type_t)&_xpc_type_int64)
    {
      v329 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_65FD4(v329, v330, v331, v332, v333, v334, v335, v336);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    unsigned __int8 v337 = xpc_int64_get_value(v328);
    sub_2507C(a1, v337);
  }
  xpc_object_t v338 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertySiriUseDeviceMic");
  if (v338)
  {
    BOOL v339 = xpc_BOOL_get_value(v338);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureSiriUseDeviceMic", v339);
  }
  xpc_object_t v340 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyFindMyPlayBack");
  if (v340)
  {
    BOOL v341 = xpc_BOOL_get_value(v340);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureFindMyPlayBack", v341);
  }
  xpc_object_t v342 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyUntrackedSpatial");
  if (v342)
  {
    BOOL v343 = xpc_BOOL_get_value(v342);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureAutomaticNonHeadTrackedSpatialAudio", v343);
  }
  xpc_object_t v344 = xpc_dictionary_get_value(a3, "kBTHostedDSPOffloadSupport");
  v345 = v344;
  if (v344)
  {
    BOOL v346 = xpc_BOOL_get_value(v344);
    sub_27DF8(a1, @"kBluetoothAudioDeviceFeatureHostedDSPOffload", v346);
    BOOL v347 = xpc_BOOL_get_value(v345);
    sub_24D84(a1, v347);
  }
  xpc_object_t v348 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyPersonalizedVolumeDRCInfo");
  if (v348)
  {
    BOOL v349 = xpc_BOOL_get_value(v348);
    sub_24E84(a1, v349);
  }
  xpc_object_t v350 = xpc_dictionary_get_value(a3, "kBTAudioMsgPropertyIsGenuineAirPods");
  v351 = v350;
  if (v350)
  {
    if (xpc_get_type(v350) != (xpc_type_t)&_xpc_type_BOOL)
    {
      v352 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_65F5C(v352, v353, v354, v355, v356, v357, v358, v359);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v360 = xpc_BOOL_get_value(v351);
    sub_28174(a1, v360);
  }
  string = (char *)xpc_dictionary_get_string(a3, "kBTAudioMsgPropertyGenericName");
  if (string)
  {
    sub_2828C((uint64_t *)a1, string);
    v362 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      v363 = *(const char **)(a1 + 592);
      *(_DWORD *)std::string buf = 138412290;
      v369 = v363;
    }
  }
  sub_23E4C(a1);
  sub_49F68(*(void *)a1, 1651798886);
  CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 496), (CFDictionaryApplierFunction)sub_2830C, 0);
}

void sub_27DBC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_27DF8(uint64_t a1, const void *a2, int a3)
{
  v8[0] = 0;
  v8[1] = 0;
  sub_5CDCC((uint64_t)v8, a1 + 520);
  int v6 = (const void **)&kCFBooleanTrue;
  if (!a3) {
    int v6 = (const void **)&kCFBooleanFalse;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 496), a2, *v6);
  return sub_5CF10(v8);
}

void sub_27E70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_27E84(uint64_t a1, CFDictionaryRef theDict)
{
  if (theDict)
  {
    int v4 = *(const void **)(a1 + 368);
    if (v4) {
      CFRelease(v4);
    }
    MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
    *(void *)(a1 + 368) = MutableCopy;
    CFDictionaryApplyFunction(MutableCopy, (CFDictionaryApplierFunction)sub_2B044, 0);
  }
}

uint64_t sub_27EFC(uint64_t a1)
{
  int v5 = 0;
  uint64_t result = _os_feature_enabled_impl();
  BOOL v3 = 0;
  if ((result & 1) == 0)
  {
    uint64_t result = (uint64_t)sub_2B3A0(a1, @"global", &v5, &v4);
    BOOL v3 = v5 != 0;
  }
  *(unsigned char *)(a1 + 255) = v3;
  return result;
}

void sub_27F6C(CFDictionaryRef *a1, const __CFDictionary *a2)
{
  if (a2)
  {
    CFDictionaryRef v4 = a1[47];
    if (v4)
    {
      CFRelease(v4);
      a1[47] = 0;
    }
    if (_os_feature_enabled_impl())
    {
      a1[47] = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, a2);
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      int v16 = 0;
      sub_2A8E0((uint64_t)a1, (_DWORD *)&v18 + 1, &v18, (_DWORD *)&v17 + 1, &v17, &v16);
      int v5 = +[BTAudioAVNotificationMonitor sharedInstance];
      uint64_t v6 = *((void *)*a1 + 1157);
      if (v6 == 1953719151 || v6 == 1952539500)
      {
        int v8 = v5;
        uint64_t v9 = (const void *)sub_7904(*((void *)*a1 + 1140));
        CFRetain(v9);
        LODWORD(v10) = HIDWORD(v18);
        LODWORD(v11) = v18;
        LODWORD(v12) = HIDWORD(v17);
        LODWORD(v13) = v17;
        LODWORD(v14) = v16;
        [(BTAudioAVNotificationMonitor *)v8 updateVolumeForCategories:v9 telephoneVolume:v10 voiceCommandVolume:v11 uid:v12 rampUpDuration:v13 rampDownDuration:v14];
      }
      else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
      {
        sub_66AD0();
      }
      CFDictionaryApplyFunction(a1[47], (CFDictionaryApplierFunction)sub_2AB5C, 0);
    }
  }
}

void sub_280B0(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 344) != a2)
  {
    *(_DWORD *)(a1 + 344) = a2;
    sub_49F68(*(void *)a1, 1635017332);
    BOOL v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 344);
      v5[0] = 67109120;
      v5[1] = v4;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Allow SCO for Turn by Turn %d", (uint8_t *)v5, 8u);
    }
  }
}

void sub_28174(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 584) != a2)
  {
    *(unsigned char *)(a1 + 584) = a2;
    sub_49F68(*(void *)a1, 1768382832);
    BOOL v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(a1 + 584)) {
        int v4 = "genuine";
      }
      else {
        int v4 = "non-genuine";
      }
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      int v6 = 136446466;
      __int16 v7 = v4;
      __int16 v8 = 1024;
      int v9 = v5;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "AccessoryIsGenuineAirPods set to %{public}s for mAudioObjectID %d", (uint8_t *)&v6, 0x12u);
    }
  }
}

uint64_t sub_2828C(uint64_t *a1, char *cStr)
{
  int v4 = (const void *)a1[74];
  if (v4)
  {
    CFRelease(v4);
    a1[74] = 0;
  }
  a1[74] = (uint64_t)CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  uint64_t v5 = *a1;

  return sub_49F68(v5, 1651795822);
}

uint64_t sub_282FC(uint64_t *a1)
{
  return sub_49F68(*a1, 1651798886);
}

void sub_2830C(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFBooleanGetTypeID())
  {
    uint64_t v5 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int Value = CFBooleanGetValue((CFBooleanRef)cf);
      __int16 v7 = "YES";
      if (!Value) {
        __int16 v7 = "NO";
      }
      int v8 = 138412546;
      uint64_t v9 = a1;
      __int16 v10 = 2080;
      double v11 = v7;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Feature: %@ : Support %s", (uint8_t *)&v8, 0x16u);
    }
  }
}

uint64_t sub_283FC(uint64_t result, char a2)
{
  *(unsigned char *)(result + 128) = a2;
  return result;
}

uint64_t sub_28404(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 128);
}

uint64_t sub_2840C(uint64_t a1)
{
  return *(void *)(a1 + 136);
}

void sub_28414(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableArray);
  if (*(float *)(a1 + 280) == -1.0 || !CFArrayGetCount(*(CFArrayRef *)(a1 + 288)))
  {
    objc_msgSend(v2, "addObject:", +[CBUUID UUIDWithString:](CBUUID, "UUIDWithString:", CBUUIDDosimetrySensitivityCharacteristicString));
    objc_msgSend(v2, "addObject:", +[CBUUID UUIDWithString:](CBUUID, "UUIDWithString:", CBUUIDDosimetryVolumeCurveCharacteristicString));
    *(void *)(a1 + 304) = [[BTHearingHealthObject alloc] initWithUUID:*(void *)(a1 + 312) productID:*(unsigned int *)(a1 + 48) vendorID:*(unsigned int *)(a1 + 56) EURegionBit:*(unsigned __int8 *)(a1 + 296) audioDevice:*(void *)a1 readCharacteristics:v2];
  }
}

void sub_284EC(void *a1, uint64_t a2, char *a3, void *a4)
{
  if (!strcasecmp(a3, "kBTAudioMsgPropertySoundProfile"))
  {
    uint64_t v9 = qword_A2350;
    sub_45830(v9, a2, a3);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySupportedServices"))
  {
    BOOL v10 = xpc_int64_get_value(a4) != 0;
    double v11 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v10;
      _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Supported  Mask is %x", (uint8_t *)&v170, 8u);
    }
    *((_DWORD *)a1 + 48) = v10;
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyIncompatibleHidConnected"))
  {
    int value = xpc_BOOL_get_value(a4);
    double v13 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *((unsigned __int8 *)a1 + 216);
      int v170 = 67109376;
      *(_DWORD *)xpc_object_t v171 = v15;
      *(_WORD *)&v171[4] = 1024;
      *(_DWORD *)&v171[6] = value;
      _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "HAL received kBTAudioMsgPropertyIncompatibleHidConnected:%u -> %u", (uint8_t *)&v170, 0xEu);
    }
    if (*((unsigned __int8 *)a1 + 216) != value)
    {
      *((unsigned char *)a1 + 216) = value;
      if (*a1)
      {
        uint64_t v16 = *(void *)(*a1 + 9096);
        if (v16)
        {
          if (*(unsigned char *)(v16 + 192)) {
            nullsub_81(v14);
          }
        }
      }
    }
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyName"))
  {
    string_ptr = xpc_string_get_string_ptr(a4);
    sub_26164(a1, string_ptr);
    return;
  }
  if (!strcmp(a3, "kBTAudioMsgPropertyLocalStreamState"))
  {
    *((_DWORD *)a1 + 15) = xpc_int64_get_value(a4);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyListenModeSupported"))
  {
    int v18 = xpc_int64_get_value(a4);
    sub_23938((uint64_t)a1, v18);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyInEarStatus"))
  {
    __int16 v19 = xpc_int64_get_value(a4);
    int v20 = v19;
    int v21 = HIBYTE(v19);
    uint64_t v22 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109376;
      *(_DWORD *)xpc_object_t v171 = v20;
      *(_WORD *)&v171[4] = 1024;
      *(_DWORD *)&v171[6] = v21;
      _os_log_impl(&dword_0, v22, OS_LOG_TYPE_DEFAULT, "In Ear status change received from BTServer: primaryStatus %u, secondaryStatus %u", (uint8_t *)&v170, 0xEu);
    }
    sub_24610((uint64_t)a1, v20, v21);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyFixedMicRole"))
  {
    int v23 = xpc_int64_get_value(a4);
    uint64_t v24 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v23;
      _os_log_impl(&dword_0, v24, OS_LOG_TYPE_DEFAULT, "Fixed mic role received from BTServer, role %u", (uint8_t *)&v170, 8u);
    }
    sub_24A64((uint64_t)a1, v23);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyDOAPSupported"))
  {
    BOOL v25 = xpc_BOOL_get_value(a4);
    sub_2517C((uint64_t)a1, v25);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyPrimaryBudSide"))
  {
    int v26 = xpc_int64_get_value(a4);
    uint64_t v27 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v26;
      _os_log_impl(&dword_0, v27, OS_LOG_TYPE_DEFAULT, "Primary bud side received from BTServer, budside %u", (uint8_t *)&v170, 8u);
    }
    sub_24864((uint64_t)a1, v26);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyInEarDetection"))
  {
    BOOL v28 = xpc_BOOL_get_value(a4);
    __int16 v29 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = "not supported";
      if (v28) {
        int v30 = "supported";
      }
      int v170 = 136446210;
      *(void *)xpc_object_t v171 = v30;
      _os_log_impl(&dword_0, v29, OS_LOG_TYPE_DEFAULT, "In Ear detection  %{public}s", (uint8_t *)&v170, 0xCu);
    }
    sub_235B8(a1, v28);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyExtentedHfpVolumeRange"))
  {
    BOOL v31 = xpc_BOOL_get_value(a4);
    sub_236C8(a1, v31);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyInEarEnabled"))
  {
    BOOL v32 = xpc_BOOL_get_value(a4);
    uint64_t v33 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = "disabled";
      if (v32) {
        uint64_t v34 = "enabled";
      }
      int v170 = 136446210;
      *(void *)xpc_object_t v171 = v34;
      _os_log_impl(&dword_0, v33, OS_LOG_TYPE_DEFAULT, "In Ear enabled %{public}s", (uint8_t *)&v170, 0xCu);
    }
    sub_23818((uint64_t)a1, v32);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyListenMode"))
  {
    int v35 = xpc_int64_get_value(a4);
    sub_24964((uint64_t)a1, v35);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyOwnershipHijack"))
  {
    BOOL v36 = xpc_BOOL_get_value(a4);
    uint64_t v37 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v38 = "true";
      if (v36) {
        BOOL v38 = "false";
      }
      int v170 = 136446210;
      *(void *)xpc_object_t v171 = v38;
      _os_log_impl(&dword_0, v37, OS_LOG_TYPE_DEFAULT, "Received hijack audio route request ownership will be set to %{public}s", (uint8_t *)&v170, 0xCu);
    }
    (*(void (**)(void, BOOL, uint64_t))(*(void *)*a1 + 1320))(*a1, !v36, 1);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySoftwareVolumeSupported"))
  {
    *((unsigned char *)a1 + 274) = xpc_BOOL_get_value(a4);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySupportRemoteVolumeChange"))
  {
    *((unsigned char *)a1 + 276) = xpc_BOOL_get_value(a4);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyLiveListenSupported"))
  {
    BOOL v39 = xpc_BOOL_get_value(a4);
    sub_24B64((uint64_t)a1, v39);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyOneBudANCMode"))
  {
    int v40 = xpc_int64_get_value(a4);
    sub_2A4A4(a1, v40);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyDosimetrySensitivity"))
  {
    float v41 = (float)xpc_int64_get_value(a4);
    sub_26200((float *)a1, v41);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyDosimetryVolumeCurve"))
  {
    xpc_object_t v42 = (const void *)_CFXPCCreateCFObjectFromXPCObject();
    uint64_t v43 = qword_A1AD0;
    BOOL v44 = os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT);
    if (!v42)
    {
      if (!v44) {
        return;
      }
      LOWORD(v170) = 0;
      uint64_t v49 = "Update VolumeCurve with NULL";
      uint64_t v50 = v43;
      uint32_t v51 = 2;
      goto LABEL_141;
    }
    if (v44)
    {
      LOWORD(v170) = 0;
      _os_log_impl(&dword_0, v43, OS_LOG_TYPE_DEFAULT, "Update VolumeCurve", (uint8_t *)&v170, 2u);
    }
    sub_26318((CFIndex)a1, v42);
    CFDictionaryRef v45 = (const __CFDictionary *)v42;
LABEL_132:
    CFRelease(v45);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyEURegionBit"))
  {
    uint64_t v46 = xpc_int64_get_value(a4);
    sub_264C0(a1, v46);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyRemoteStreamState"))
  {
    unsigned int v47 = xpc_int64_get_value(a4);
    uint64_t v48 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v47;
      _os_log_impl(&dword_0, v48, OS_LOG_TYPE_DEFAULT, "Stream state change received from BTServer, state %u", (uint8_t *)&v170, 8u);
    }
    sub_25D48((uint64_t)a1, v47);
    return;
  }
  if (!strcmp(a3, "kBTAudioMsgPropertyAllowSCOForTBT"))
  {
    BOOL v52 = xpc_BOOL_get_value(a4);
    sub_280B0((uint64_t)a1, v52);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyTipiConnected"))
  {
    BOOL v53 = xpc_BOOL_get_value(a4);
    uint64_t v54 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v55 = "Disconnected";
      if (v53) {
        uint64_t v55 = "Connected";
      }
      int v170 = 136446210;
      *(void *)xpc_object_t v171 = v55;
      _os_log_impl(&dword_0, v54, OS_LOG_TYPE_DEFAULT, "Smart Route: Tipi Connection Changed to %{public}s", (uint8_t *)&v170, 0xCu);
    }
    *((unsigned char *)a1 + 348) = v53;
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyWSIsGuestDevice"))
  {
    BOOL v56 = xpc_BOOL_get_value(a4);
    sub_2A594((uint64_t)a1, v56);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySupportSpatialAudio"))
  {
    BOOL v57 = xpc_BOOL_get_value(a4);
    uint64_t v58 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v59 = "not supported";
      if (v57) {
        uint64_t v59 = "supported";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v59;
      _os_log_impl(&dword_0, v58, OS_LOG_TYPE_DEFAULT, "Spatial Audio is %s", (uint8_t *)&v170, 0xCu);
    }
    sub_27DF8((uint64_t)a1, @"kBluetoothAudioDeviceFeatureHeadTrackedSpatialAudio", v57);
    sub_2548C((uint64_t)a1, v57);
    goto LABEL_174;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyAllowSoundProfile"))
  {
    BOOL v60 = xpc_BOOL_get_value(a4);
    uint64_t v61 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v62 = "not allowed";
      if (v60) {
        __int16 v62 = "allowed";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v62;
      _os_log_impl(&dword_0, v61, OS_LOG_TYPE_DEFAULT, "Spatial Profile is %s", (uint8_t *)&v170, 0xCu);
    }
    sub_256AC((uint64_t)a1, v60);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySoundProfileEnhancedTuning"))
  {
    BOOL v63 = xpc_BOOL_get_value(a4);
    uint64_t v64 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v65 = "not Set";
      if (v63) {
        uint64_t v65 = "Set";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v65;
      _os_log_impl(&dword_0, v64, OS_LOG_TYPE_DEFAULT, "Spatial Profile Enhanced Tuning  %s", (uint8_t *)&v170, 0xCu);
    }
    sub_257AC((uint64_t)a1, v63);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySupportHighQualityBiDirectionalAudio"))
  {
    BOOL v66 = xpc_BOOL_get_value(a4);
    uint64_t v67 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v68 = "not supported";
      if (v66) {
        uint64_t v68 = "supported";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v68;
      _os_log_impl(&dword_0, v67, OS_LOG_TYPE_DEFAULT, "BT High Quality BiDirectional Audio is %s", (uint8_t *)&v170, 0xCu);
    }
    *((unsigned char *)a1 + 237) = v66;
    CFStringRef v69 = @"kBluetoothAudioDeviceFeatureHighQualityBiDirectionalAudio";
    goto LABEL_173;
  }
  if (!strcmp(a3, "kBTAudioMsgPropertyTipiSupported"))
  {
    BOOL v72 = xpc_BOOL_get_value(a4);
    *((unsigned char *)a1 + 250) = v72;
    uint64_t v73 = qword_A1AD0;
    if (!os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    CFStringRef v74 = "not Supported";
    if (v72) {
      CFStringRef v74 = "Supported";
    }
    int v170 = 136315138;
    *(void *)xpc_object_t v171 = v74;
    uint64_t v49 = "TiPi Capable update to %s";
    goto LABEL_180;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySupportSoundProfile"))
  {
    BOOL v75 = xpc_BOOL_get_value(a4);
    sub_27DF8((uint64_t)a1, @"kBluetoothAudioDeviceFeatureCustomHRTF", v75);
    sub_25394(a1, v75);
LABEL_198:
    uint64_t v84 = *a1;
    sub_49F68(v84, 1651798886);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyAdaptiveVolume"))
  {
    BOOL v66 = xpc_BOOL_get_value(a4);
    uint64_t v76 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v77 = "not supported";
      if (v66) {
        uint64_t v77 = "supported";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v77;
      _os_log_impl(&dword_0, v76, OS_LOG_TYPE_DEFAULT, "Adaptive Volume: feature %s", (uint8_t *)&v170, 0xCu);
    }
    *((unsigned char *)a1 + 228) = v66 & _os_feature_enabled_impl();
    CFStringRef v69 = @"kBluetoothAudioDeviceFeatureAdaptiveVolume";
    goto LABEL_173;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyAdaptiveVolumeMode"))
  {
    char v78 = xpc_int64_get_value(a4);
    uint64_t v79 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      if (v78 == 1) {
        uint64_t v80 = "enabled";
      }
      else {
        uint64_t v80 = "disabled";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v80;
      _os_log_impl(&dword_0, v79, OS_LOG_TYPE_DEFAULT, "Adaptive Volume: Configuration %s", (uint8_t *)&v170, 0xCu);
    }
    *((unsigned char *)a1 + 229) = v78;
    uint64_t v81 = +[BTAudioAVNotificationMonitor sharedInstance];
    if (v81) {
      [(BTAudioAVNotificationMonitor *)v81 personalizedVolumeEnabled:v78 == 1];
    }
    uint64_t v70 = *a1;
    int v71 = 1633973868;
    goto LABEL_175;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyMuteControl"))
  {
    BOOL v82 = xpc_BOOL_get_value(a4);
    CFStringRef v83 = @"kBluetoothAudioDeviceFeatureMuteControl";
LABEL_197:
    sub_27DF8((uint64_t)a1, v83, v82);
    goto LABEL_198;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyConversationDetect"))
  {
    BOOL v82 = xpc_BOOL_get_value(a4);
    CFStringRef v83 = @"kBluetoothAudioDeviceFeatureConversationDetect";
    goto LABEL_197;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyAllowSpatialAudio"))
  {
    BOOL v85 = xpc_BOOL_get_value(a4);
    v86 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      v87 = "not Allowed";
      if (v85) {
        v87 = "Allowed";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v87;
      _os_log_impl(&dword_0, v86, OS_LOG_TYPE_DEFAULT, "Spatial Audio is %s", (uint8_t *)&v170, 0xCu);
    }
    sub_258AC((uint64_t)a1, v85);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyForegroundApp"))
  {
    if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string) {
      goto LABEL_210;
    }
    uint64_t v88 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
      sub_66B38(v88, v89, v90, v91, v92, v93, v94, v95);
    }
    if (!sub_5CB00())
    {
LABEL_210:
      xpc_object_t v96 = (const void *)a1[17];
      if (v96) {
        CFRelease(v96);
      }
      uint64_t v97 = _CFXPCCreateCFObjectFromXPCObject();
      a1[17] = v97;
      uint64_t v73 = qword_A1AD0;
      if (v97)
      {
        uint64_t v98 = v97;
        if (!os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v170 = 138412290;
        *(void *)xpc_object_t v171 = v98;
        uint64_t v49 = "BTHAL got kBTAudioMsgPropertyForegroundApp: %@";
        goto LABEL_180;
      }
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR)) {
        sub_66B04();
      }
      return;
    }
    goto LABEL_318;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySpatialPerAppModeMap"))
  {
    if (xpc_get_type(a4) != (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v99 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_66BB0(v99, v100, v101, v102, v103, v104, v105, v106);
      }
      if (sub_5CB00()) {
        goto LABEL_318;
      }
    }
    uint64_t v107 = _CFXPCCreateCFObjectFromXPCObject();
    if (!v107) {
      return;
    }
    CFDictionaryRef v108 = (const __CFDictionary *)v107;
    int v109 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = CFDictionaryGetCount(v108);
      _os_log_impl(&dword_0, v109, OS_LOG_TYPE_DEFAULT, "Per App Spatial information : %d", (uint8_t *)&v170, 8u);
    }
    sub_27E84((uint64_t)a1, v108);
LABEL_231:
    CFDictionaryRef v45 = v108;
    goto LABEL_132;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyAdaptiveVolumeMap"))
  {
    if (xpc_get_type(a4) != (xpc_type_t)&_xpc_type_dictionary)
    {
      v110 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
        sub_66BB0(v110, v111, v112, v113, v114, v115, v116, v117);
      }
      if (sub_5CB00()) {
        goto LABEL_318;
      }
    }
    uint64_t v118 = _CFXPCCreateCFObjectFromXPCObject();
    if (!v118) {
      return;
    }
    CFDictionaryRef v108 = (const __CFDictionary *)v118;
    uint64_t v119 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = CFDictionaryGetCount(v108);
      _os_log_impl(&dword_0, v119, OS_LOG_TYPE_DEFAULT, "Adaptive Volume information: %d", (uint8_t *)&v170, 8u);
    }
    sub_27F6C((CFDictionaryRef *)a1, v108);
    goto LABEL_231;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyDigitalCrownSupported"))
  {
    BOOL v66 = xpc_BOOL_get_value(a4);
    uint64_t v120 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v121 = "not supported";
      if (v66) {
        uint64_t v121 = "supported";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v121;
      _os_log_impl(&dword_0, v120, OS_LOG_TYPE_DEFAULT, "Digital Crown is %s", (uint8_t *)&v170, 0xCu);
    }
    *((unsigned char *)a1 + 217) = v66;
    CFStringRef v69 = @"kBluetoothAudioDeviceFeatureDigitalCrown";
    goto LABEL_173;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyBudSideLoudnessEqControlSupported"))
  {
    BOOL v66 = xpc_BOOL_get_value(a4);
    uint64_t v122 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v123 = "not supported";
      if (v66) {
        uint64_t v123 = "supported";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v123;
      _os_log_impl(&dword_0, v122, OS_LOG_TYPE_DEFAULT, "Bud side loudness EQ control is %s", (uint8_t *)&v170, 0xCu);
    }
    CFStringRef v69 = @"kBluetoothAudioDeviceFeatureBudSideLoudnessEqControlSupport";
    goto LABEL_173;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyBudSideLoudnessEqEnabled"))
  {
    BOOL v124 = xpc_BOOL_get_value(a4);
    uint64_t v125 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v126 = "disabled";
      if (v124) {
        BOOL v126 = "enabled";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v126;
      _os_log_impl(&dword_0, v125, OS_LOG_TYPE_DEFAULT, "Bud Side Loudness EQ is %s", (uint8_t *)&v170, 0xCu);
    }
    *((unsigned char *)a1 + 218) = v124;
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyUWBSStereoSupport"))
  {
    BOOL v66 = xpc_BOOL_get_value(a4);
    xpc_object_t v127 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      v128 = "not supported";
      if (v66) {
        v128 = "supported";
      }
      int v170 = 136315138;
      *(void *)xpc_object_t v171 = v128;
      _os_log_impl(&dword_0, v127, OS_LOG_TYPE_DEFAULT, "Stereo HFP is %s", (uint8_t *)&v170, 0xCu);
    }
    CFStringRef v69 = @"kBluetoothAudioDeviceFeatureStereoHfpSupport";
    goto LABEL_173;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyUserSelectedDeviceType"))
  {
    int v129 = xpc_int64_get_value(a4);
    uint64_t v130 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v129;
      _os_log_impl(&dword_0, v130, OS_LOG_TYPE_DEFAULT, "User Device Type Update: %d", (uint8_t *)&v170, 8u);
    }
    sub_2507C((uint64_t)a1, v129);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyAccessHeadTrack"))
  {
    BOOL v131 = xpc_BOOL_get_value(a4);
    *((unsigned char *)a1 + 128) = v131;
    uint64_t v132 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v131;
      _os_log_impl(&dword_0, v132, OS_LOG_TYPE_DEFAULT, "BTHAL got kBTAudioMsgPropertyAccessHeadTrack:%u", (uint8_t *)&v170, 8u);
    }
    sub_49F68(*a1, 1752457571);
    sub_49F68(*a1, 1752462196);
    sub_49F68(*a1, 1752457590);
    sub_49F68(*a1, 1936747876);
    sub_49F68(*a1, 1936745318);
    sub_49F68(*a1, 1936744822);
    sub_49F68(*a1, 1936749430);
    uint64_t v70 = *a1;
    int v71 = 1936746095;
    goto LABEL_175;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySpatialAudioAppBasedMode"))
  {
    if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_dictionary) {
      goto LABEL_264;
    }
    uint64_t v133 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_FAULT)) {
      sub_66BB0(v133, v134, v135, v136, v137, v138, v139, v140);
    }
    if (!sub_5CB00())
    {
LABEL_264:
      uint64_t v141 = _CFXPCCreateCFObjectFromXPCObject();
      uint64_t v142 = qword_A1AD0;
      if (!v141)
      {
        if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR)) {
          sub_66C28();
        }
        return;
      }
      CFDictionaryRef v108 = (const __CFDictionary *)v141;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v170) = 0;
        _os_log_impl(&dword_0, v142, OS_LOG_TYPE_DEFAULT, "kBTAudioMsgPropertySpatialAudioAppBasedMode get Dict", (uint8_t *)&v170, 2u);
      }
      CFNumberRef v143 = (const __CFNumber *)CFDictionaryGetValue(v108, @"kBTAudioMsgPropertySpatialMode");
      CFStringRef v144 = (const __CFString *)CFDictionaryGetValue(v108, @"kBTAudioMsgPropertySpatialBundleID");
      CFBooleanRef v145 = (CFBooleanRef)CFDictionaryGetValue(v108, @"kBTAudioMsgPropertyHeadTrack");
      if (v144 && v143 && v145)
      {
        int v170 = 0;
        BOOL v146 = v145 == kCFBooleanTrue;
        CFNumberGetValue(v143, kCFNumberIntType, &v170);
        sub_590D4((uint64_t *)*a1, v144, v170, v146);
        sub_27EFC((uint64_t)a1);
      }
      goto LABEL_231;
    }
LABEL_318:
    abort();
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyAllowAutoRoute"))
  {
    BOOL v147 = xpc_BOOL_get_value(a4);
    xpc_object_t v148 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v147;
      _os_log_impl(&dword_0, v148, OS_LOG_TYPE_DEFAULT, "Updated Auto Route Support : %d", (uint8_t *)&v170, 8u);
    }
    sub_24C7C((uint64_t)a1, v147);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyIsHidden"))
  {
    BOOL v149 = xpc_BOOL_get_value(a4);
    v150 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v149;
      _os_log_impl(&dword_0, v150, OS_LOG_TYPE_DEFAULT, "Updated AudioRouteHidden : %d", (uint8_t *)&v170, 8u);
    }
    sub_24F7C((uint64_t)a1, v149);
    return;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertySiriUseDeviceMic"))
  {
    BOOL v66 = xpc_BOOL_get_value(a4);
    uint64_t v151 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v66;
      _os_log_impl(&dword_0, v151, OS_LOG_TYPE_DEFAULT, "Updated Siri Use device Mic : %d", (uint8_t *)&v170, 8u);
    }
    CFStringRef v69 = @"kBluetoothAudioDeviceFeatureSiriUseDeviceMic";
    goto LABEL_173;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyFindMyPlayBack"))
  {
    BOOL v66 = xpc_BOOL_get_value(a4);
    uint64_t v152 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v66;
      _os_log_impl(&dword_0, v152, OS_LOG_TYPE_DEFAULT, "Updated Find My Playback : %d", (uint8_t *)&v170, 8u);
    }
    CFStringRef v69 = @"kBluetoothAudioDeviceFeatureFindMyPlayBack";
    goto LABEL_173;
  }
  if (!strcasecmp(a3, "kBTAudioMsgPropertyUntrackedSpatial"))
  {
    BOOL v66 = xpc_BOOL_get_value(a4);
    uint64_t v153 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v66;
      _os_log_impl(&dword_0, v153, OS_LOG_TYPE_DEFAULT, "Updated Automatic Non HeadTracked Spatial : %d", (uint8_t *)&v170, 8u);
    }
    CFStringRef v69 = @"kBluetoothAudioDeviceFeatureAutomaticNonHeadTrackedSpatialAudio";
LABEL_173:
    sub_27DF8((uint64_t)a1, v69, v66);
LABEL_174:
    uint64_t v70 = *a1;
    int v71 = 1651798886;
LABEL_175:
    sub_49F68(v70, v71);
    return;
  }
  if (!strcasecmp(a3, "kBTHostedDSPOffloadSupport"))
  {
    BOOL v154 = xpc_BOOL_get_value(a4);
    uint64_t v155 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v170 = 67109120;
      *(_DWORD *)xpc_object_t v171 = v154;
      _os_log_impl(&dword_0, v155, OS_LOG_TYPE_DEFAULT, "Updated Hosted DSP Offload Support Property: %d", (uint8_t *)&v170, 8u);
    }
    sub_27DF8((uint64_t)a1, @"kBluetoothAudioDeviceFeatureHostedDSPOffload", v154);
    sub_49F68(*a1, 1651798886);
    sub_24D84((uint64_t)a1, v154);
  }
  else
  {
    if (strcasecmp(a3, "kBTAudioMsgPropertyIsGenuineAirPods"))
    {
      if (strcasecmp(a3, "kBTAudioMsgPropertyGenericName"))
      {
        if (strcasecmp(a3, "kBTAudioMsgPropertyTransportType"))
        {
          if (!strcasecmp(a3, "kBTAudioMsgPropertyLowLatencyGameMode"))
          {
            if (_os_feature_enabled_impl())
            {
              BOOL v163 = xpc_BOOL_get_value(a4);
              BOOL v164 = qword_A1AD0;
              if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
              {
                if (*((unsigned char *)a1 + 221)) {
                  v165 = "running";
                }
                else {
                  v165 = "not running";
                }
                if (v163) {
                  v166 = "running";
                }
                else {
                  v166 = "not running";
                }
                xpc_object_t v167 = *(unsigned char **)(*a1 + 9096);
                if (v167)
                {
                  if (v167[192]) {
                    LODWORD(v167) = (*(uint64_t (**)(unsigned char *))(*(void *)v167 + 992))(v167);
                  }
                  else {
                    LODWORD(v167) = 0;
                  }
                }
                int v170 = 136315650;
                *(void *)xpc_object_t v171 = v165;
                *(_WORD *)&v171[8] = 2080;
                v172 = v166;
                __int16 v173 = 1024;
                int v174 = (int)v167;
                _os_log_impl(&dword_0, v164, OS_LOG_TYPE_DEFAULT, "Low Latency Game state: %s->%s, HFP IO: %d", (uint8_t *)&v170, 0x1Cu);
              }
              sub_59C90(*a1, v163);
            }
          }
          else if (!strcasecmp(a3, "kBTAudioMsgPropertyPersonalizedVolumeDRCInfo"))
          {
            BOOL v168 = xpc_BOOL_get_value(a4);
            v169 = qword_A1AD0;
            if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
            {
              int v170 = 67109120;
              *(_DWORD *)xpc_object_t v171 = v168;
              _os_log_impl(&dword_0, v169, OS_LOG_TYPE_DEFAULT, "Updated Personalized Volume DRC enablement to: %d", (uint8_t *)&v170, 8u);
            }
            sub_24E84((uint64_t)a1, v168);
          }
          else if (a2)
          {
            int v8 = *(void (**)(uint64_t, char *, void *))(*(void *)a2 + 264);
            v8(a2, a3, a4);
          }
          return;
        }
        unsigned __int8 v161 = xpc_int64_get_value(a4);
        *((unsigned char *)a1 + 219) = v161;
        uint64_t v162 = qword_A1AD0;
        if (!os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v170 = 67109120;
        *(_DWORD *)xpc_object_t v171 = v161;
        uint64_t v49 = "Transport type update: %d";
        uint64_t v50 = v162;
        uint32_t v51 = 8;
LABEL_141:
        _os_log_impl(&dword_0, v50, OS_LOG_TYPE_DEFAULT, v49, (uint8_t *)&v170, v51);
        return;
      }
      xpc_object_t v159 = (char *)xpc_string_get_string_ptr(a4);
      if (!v159) {
        return;
      }
      xpc_object_t v160 = v159;
      sub_2828C(a1, v159);
      uint64_t v73 = qword_A1AD0;
      if (!os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v170 = 136446210;
      *(void *)xpc_object_t v171 = v160;
      uint64_t v49 = "Device Generic Name : %{public}s";
LABEL_180:
      uint64_t v50 = v73;
      uint32_t v51 = 12;
      goto LABEL_141;
    }
    BOOL v156 = xpc_BOOL_get_value(a4);
    uint64_t v157 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v158 = "non-genuine";
      if (v156) {
        unsigned int v158 = "genuine";
      }
      int v170 = 136446210;
      *(void *)xpc_object_t v171 = v158;
      _os_log_impl(&dword_0, v157, OS_LOG_TYPE_DEFAULT, "Is Genuine AirPods : %{public}s", (uint8_t *)&v170, 0xCu);
    }
    sub_28174((uint64_t)a1, v156);
  }
}

void sub_2A4A4(unsigned char *a1, int a2)
{
  if (a1[279] != a2)
  {
    a1[279] = a2;
    CFTypeID v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void))(**(void **)a1 + 16))();
      v6[0] = 67109376;
      v6[1] = a2;
      __int16 v7 = 1024;
      int v8 = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "mOneBudANCMode set to %d for mAudioObjectID %d", (uint8_t *)v6, 0xEu);
    }
  }
}

void sub_2A594(uint64_t a1, int a2)
{
  if (*(unsigned __int8 *)(a1 + 329) != a2)
  {
    *(unsigned char *)(a1 + 329) = a2;
    BOOL v3 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeID v4 = "is not guest";
      if (a2) {
        CFTypeID v4 = "is guest";
      }
      int v5 = 136315138;
      int v6 = v4;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Wireless Splitter From BT device %s", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t sub_2A65C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2) {
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2 + 264))(a2, a3, a4);
  }
  return result;
}

void sub_2A69C(uint64_t a1, char a2)
{
  if (a2)
  {
    if (_os_feature_enabled_impl())
    {
      uint64_t v3 = 2;
LABEL_6:
      *(_DWORD *)(a1 + 224) = v3;
      goto LABEL_8;
    }
    if (_os_feature_enabled_impl())
    {
      uint64_t v3 = 1;
      goto LABEL_6;
    }
  }
  uint64_t v3 = 0;
  *(_DWORD *)(a1 + 224) = 0;
LABEL_8:
  CFTypeID v4 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = off_8E228[v3];
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v8 = 0;
    sub_BAF4(__p, v5);
    if (v8 >= 0) {
      int v6 = __p;
    }
    else {
      int v6 = (void **)__p[0];
    }
    *(_DWORD *)std::string buf = 136315138;
    BOOL v10 = v6;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Advanced Handsfree Audio Support : %s", buf, 0xCu);
    if (SHIBYTE(v8) < 0) {
      operator delete(__p[0]);
    }
  }
}

void *sub_2A7D0@<X0>(unsigned int a1@<W1>, void *a2@<X8>)
{
  if (a1 > 2) {
    id v2 = "Unknown";
  }
  else {
    id v2 = off_8E228[a1];
  }
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_BAF4(a2, v2);
}

void sub_2A800(uint64_t a1, int a2)
{
  if (_os_feature_enabled_impl())
  {
    *(unsigned char *)(a1 + 220) = a2;
    CFTypeID v4 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      v5[0] = 67109120;
      v5[1] = a2;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Low Latency Game Support set to %d", (uint8_t *)v5, 8u);
    }
  }
}

BOOL sub_2A8C0(uint64_t a1)
{
  return *(unsigned char *)(a1 + 220) && *(_DWORD *)(a1 + 224) != 0;
}

void sub_2A8E0(uint64_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6)
{
  int v6 = *(void **)(a1 + 376);
  if (v6)
  {
    uint64_t v8 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109120;
      LODWORD(v29) = [v6 count];
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Adaptive Volume: dict count %u", buf, 8u);
    }
    id v9 = objc_alloc_init((Class)NSMutableString);
    long long v24 = 0u;
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id obj = [v6 allKeys];
    id v10 = [obj countByEnumeratingWithState:&v24 objects:v30 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v25;
      do
      {
        for (CFIndex i = 0; i != v11; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v25 != v12) {
            objc_enumerationMutation(obj);
          }
          double v14 = *(void **)(*((void *)&v24 + 1) + 8 * i);
          objc_msgSend(objc_msgSend(v6, "valueForKey:", v14), "floatValue");
          [v9 appendFormat:@"%@ : %f\n", v14, v15];
          uint64_t v16 = a2;
          if (([v14 isEqualToString:@"kCBMsgArgParamAutoVolumeMediaTarget"] & 1) == 0)
          {
            uint64_t v16 = a3;
            if (([v14 isEqualToString:@"kCBMsgArgParamAutoVolumeTelephonyTarget"] & 1) == 0)
            {
              uint64_t v16 = a4;
              if (([v14 isEqualToString:@"kCBMsgArgParamAutoVolumeVoiceTarget"] & 1) == 0)
              {
                uint64_t v16 = a5;
                if (([v14 isEqualToString:@"kCBMsgArgParamAutoVolumeRampUpRate"] & 1) == 0)
                {
                  uint64_t v16 = a6;
                  if (![v14 isEqualToString:@"kCBMsgArgParamAutoVolumeRampDownRate"])continue; {
                }
                  }
              }
            }
          }
          objc_msgSend(objc_msgSend(v6, "valueForKey:", v14), "floatValue");
          *uint64_t v16 = v17;
        }
        id v11 = [obj countByEnumeratingWithState:&v24 objects:v30 count:16];
      }
      while (v11);
    }
    int v18 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412290;
      id v29 = v9;
      _os_log_impl(&dword_0, v18, OS_LOG_TYPE_DEFAULT, "GetAutoVolumeTargets: %@", buf, 0xCu);
    }
  }
}

void sub_2AB5C(int a1, CFTypeRef cf)
{
  int v11 = 0;
  int valuePtr = 0;
  unsigned __int16 v10 = 0;
  CFTypeID v3 = CFGetTypeID(cf);
  if (v3 == CFDictionaryGetTypeID())
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"kCBMsgArgParamAutoVolumeMediaTarget");
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberSInt32Type, (char *)&valuePtr + 2);
    }
    else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
    {
      sub_66D2C();
    }
    CFNumberRef v5 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"kCBMsgArgParamAutoVolumeTelephonyTarget");
    if (v5)
    {
      CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
    }
    else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
    {
      sub_66CF8();
    }
    CFNumberRef v6 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"kCBMsgArgParamAutoVolumeVoiceTarget");
    if (v6)
    {
      CFNumberGetValue(v6, kCFNumberSInt32Type, (char *)&v11 + 2);
    }
    else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
    {
      sub_66CC4();
    }
    CFNumberRef v7 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"kCBMsgArgParamAutoVolumeRampUpRate");
    if (v7)
    {
      CFNumberGetValue(v7, kCFNumberSInt32Type, &v11);
    }
    else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
    {
      sub_66C90();
    }
    CFNumberRef v8 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"kCBMsgArgParamAutoVolumeRampDownRate");
    if (v8)
    {
      CFNumberGetValue(v8, kCFNumberSInt32Type, &v10);
    }
    else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
    {
      sub_66C5C();
    }
    id v9 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67110144;
      int v14 = HIWORD(valuePtr);
      __int16 v15 = 1024;
      int v16 = (unsigned __int16)valuePtr;
      __int16 v17 = 1024;
      int v18 = HIWORD(v11);
      __int16 v19 = 1024;
      int v20 = (unsigned __int16)v11;
      __int16 v21 = 1024;
      int v22 = v10;
      _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "Auto Volume mode: mediaTarget %u, telephonyTarget %u, voiceTarget %u, rampUpRate %u, rampDownRate %u", buf, 0x20u);
    }
  }
}

uint64_t sub_2ADB0(uint64_t *a1, float a2, float a3)
{
  uint64_t v6 = *a1;
  CFNumberRef v7 = *(unsigned char **)(*a1 + 9088);
  float v8 = 0.0;
  if (v7
    && v7[192]
    && (v9 = (*(float (**)(unsigned char *))(*(void *)v7 + 920))(v7), v8 = v9, uint64_t v6 = *a1, v9 != a2))
  {
    BOOL v10 = a2 == 0.0;
    BOOL v11 = a2 != 0.0;
    if (v9 == 0.0) {
      BOOL v10 = 0;
    }
    else {
      BOOL v11 = 0;
    }
    int v12 = v11 || v10;
    uint64_t v13 = *(void *)(v6 + 9088);
    if (*(unsigned char *)(v13 + 192)) {
      uint64_t v14 = v13;
    }
    else {
      uint64_t v14 = 0;
    }
    (*(void (**)(uint64_t, void, float))(*(void *)v14 + 480))(v14, 0, a2);
    uint64_t v6 = *a1;
  }
  else
  {
    int v12 = 0;
  }
  __int16 v15 = *(unsigned char **)(v6 + 9096);
  if (v15 && v15[192])
  {
    float v16 = (*(float (**)(unsigned char *))(*(void *)v15 + 920))(v15);
    if (v16 == a3)
    {
      sub_395B4();
      goto LABEL_28;
    }
    float v8 = v16;
    BOOL v17 = a3 == 0.0;
    BOOL v18 = a3 != 0.0;
    if (v16 == 0.0) {
      BOOL v17 = 0;
    }
    else {
      BOOL v18 = 0;
    }
    int v12 = v18 || v17;
    if (*(unsigned char *)(*(void *)(*a1 + 9096) + 192)) {
      uint64_t v19 = *(void *)(*a1 + 9096);
    }
    else {
      uint64_t v19 = 0;
    }
    (*(void (**)(uint64_t, void, float))(*(void *)v19 + 480))(v19, 0, a3);
  }
  int v20 = sub_395B4();
  if (v12 && v20)
  {
    __int16 v21 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = 134218240;
      double v24 = v8;
      __int16 v25 = 2048;
      double v26 = a2;
      _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, "Updating Mute changed %f->%f", (uint8_t *)&v23, 0x16u);
    }
    sub_55BB4(*a1, 1836414053);
  }
LABEL_28:
  uint64_t result = *(void *)(*a1 + 9120);
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 1136))(result);
  }
  return result;
}

void sub_2B044(uint64_t a1, CFTypeRef cf)
{
  int valuePtr = 1;
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFDictionaryGetTypeID())
  {
    CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)cf, @"kCBMsgArgParamSpatialMode");
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberSInt32Type, &valuePtr);
    }
    else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
    {
      sub_66D94();
    }
    CFBooleanRef v6 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, @"kCBMsgArgParamSpatialHeadTracking");
    if (v6)
    {
      BOOL v7 = CFBooleanGetValue(v6) != 0;
    }
    else
    {
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR)) {
        sub_66D60();
      }
      BOOL v7 = 1;
    }
    float v8 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412802;
      uint64_t v11 = a1;
      __int16 v12 = 1024;
      int v13 = valuePtr;
      __int16 v14 = 1024;
      BOOL v15 = v7;
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Spatial Audio Mode :BundleID %@, spatialMode %u, headTrack %u", buf, 0x18u);
    }
  }
}

void sub_2B1B4(uint64_t a1, const __CFString *a2, int a3, int a4)
{
  int valuePtr = a3;
  CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
  float v9 = &kCFBooleanTrue;
  if (!a4) {
    float v9 = &kCFBooleanFalse;
  }
  CFBooleanRef v10 = *v9;
  uint64_t v11 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412802;
    *(void *)&uint8_t buf[4] = a2;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = valuePtr;
    __int16 v17 = 1024;
    int v18 = a4;
    _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Update Per App Config BundleID = %@  Mode = %d Head Track = %d", buf, 0x18u);
  }
  *(_OWORD *)std::string buf = off_8E200;
  values[0] = v7;
  values[1] = v10;
  CFDictionaryRef v12 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)values, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v13 = *(__CFDictionary **)(a1 + 368);
  if (v13)
  {
    CFDictionarySetValue(v13, Copy, v12);
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(a1 + 368), (CFDictionaryApplierFunction)sub_2B044, 0);
    if (!v7) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  if (!os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
  {
    if (!v7) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  sub_66DC8();
  if (v7) {
LABEL_10:
  }
    CFRelease(v7);
LABEL_11:
  if (v12) {
    CFRelease(v12);
  }
  if (Copy) {
    CFRelease(Copy);
  }
}

unsigned char *sub_2B3A0(uint64_t a1, void *a2, _DWORD *a3, BOOL *a4)
{
  *a3 = 1;
  *a4 = 1;
  *a4 = *(unsigned char *)(a1 + 128);
  if (![a2 caseInsensitiveCompare:@"com.apple.facetime"])
  {
    *a3 = 2;
    *a4 = 0;
    *a4 = _os_feature_enabled_impl();
  }
  CFDictionaryRef v8 = *(const __CFDictionary **)(a1 + 368);
  if (v8)
  {
    if (CFDictionaryContainsKey(v8, a2))
    {
      CFNumberRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 368), a2);
      CFTypeID v10 = CFGetTypeID(Value);
      if (v10 == CFDictionaryGetTypeID())
      {
        CFNumberRef v11 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)Value, @"kCBMsgArgParamSpatialMode");
        if (v11)
        {
          CFNumberGetValue(v11, kCFNumberSInt32Type, a3);
        }
        else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
        {
          sub_66E30();
        }
        CFBooleanRef v12 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)Value, @"kCBMsgArgParamSpatialHeadTracking");
        if (v12)
        {
          BOOL v13 = CFBooleanGetValue(v12) != 0;
          *a4 = v13;
          if (!*(unsigned char *)(a1 + 128)) {
            BOOL v13 = 0;
          }
          *a4 = v13;
        }
        else if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR))
        {
          sub_66DFC();
        }
      }
    }
  }
  return sub_2B518((unsigned char *)a1, a2, a3, a4);
}

unsigned char *sub_2B518(unsigned char *result, void *a2, _DWORD *a3, unsigned char *a4)
{
  CFNumberRef v7 = result;
  if ((result[237] || (uint64_t result = (unsigned char *)_os_feature_enabled_impl(), result)) && v7[230])
  {
    uint64_t v8 = *(void *)(*(void *)v7 + 9256);
  }
  else
  {
    uint64_t v8 = *(void *)(*(void *)v7 + 9256);
    if (v8 == 1953719151)
    {
LABEL_8:
      *a4 = 0;
      goto LABEL_9;
    }
  }
  if (v8 == 1952539500 && v7[272]) {
    goto LABEL_8;
  }
LABEL_9:
  if (!v7[129]) {
    goto LABEL_13;
  }
  if (!a2 || (uint64_t result = [a2 caseInsensitiveCompare:@"com.apple.facetime"]) != 0)
  {
    *a3 = 0;
    *a4 = 0;
LABEL_13:
    if (v7[328]) {
      *a4 = 0;
    }
  }
  return result;
}

uint64_t sub_2B5E8(uint64_t a1)
{
  v2[0] = 0;
  v2[1] = 0;
  sub_5CDCC((uint64_t)v2, a1 + 408);
  sub_5CEA4((uint64_t)v2);
  return sub_5CF10(v2);
}

void sub_2B62C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_2B640(uint64_t **a1, uint64_t a2, unsigned int a3)
{
  v19[1] = 0;
  uint64_t v20 = a2;
  unsigned int v21 = a3;
  v19[0] = 0;
  sub_5CDCC((uint64_t)v19, (uint64_t)(a1 + 51));
  CFBooleanRef v6 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    v18[0] = HIBYTE(a2);
    v18[1] = BYTE6(a2);
    void v18[2] = BYTE5(a2);
    v18[3] = BYTE4(a2);
    v18[4] = 0;
    *(_DWORD *)std::string buf = 67110402;
    *(_DWORD *)&uint8_t buf[4] = a2;
    __int16 v23 = 1024;
    int v24 = a3;
    __int16 v25 = 1024;
    int v26 = BYTE1(a3);
    __int16 v27 = 2082;
    BOOL v28 = v18;
    __int16 v29 = 1024;
    int v30 = BYTE2(a3);
    __int16 v31 = 1024;
    unsigned int v32 = HIBYTE(a3);
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "[ %d ]Update Spatial Audio Stream, Status = %d Channels = %d Format ID = %{public}s Available Content Type %d Is Spatializable = %d", buf, 0x2Au);
  }
  CFNumberRef v7 = a1[49];
  if (v7)
  {
    uint64_t v8 = a1 + 49;
    do
    {
      int v9 = *((_DWORD *)v7 + 8);
      BOOL v10 = v9 < (int)a2;
      if (v9 >= (int)a2) {
        CFNumberRef v11 = (uint64_t **)v7;
      }
      else {
        CFNumberRef v11 = (uint64_t **)(v7 + 1);
      }
      if (!v10) {
        uint64_t v8 = (uint64_t **)v7;
      }
      CFNumberRef v7 = *v11;
    }
    while (*v11);
    if (v8 != a1 + 49 && *((_DWORD *)v8 + 8) <= (int)a2) {
      goto LABEL_17;
    }
  }
  CFBooleanRef v12 = qword_A1AD0;
  BOOL v13 = os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT);
  if ((_BYTE)a3)
  {
    if (v13)
    {
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = a2;
      __int16 v23 = 1024;
      int v24 = a3;
      _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "[ %d ] Create Audio Client with State = %d", buf, 0xEu);
    }
    __int16 v14 = [SpatialAudioClient alloc];
    BOOL v15 = [(SpatialAudioClient *)v14 initWithPid:v20 deviceID:(*(uint64_t (**)(void))(**a1 + 16))()];
    *(void *)std::string buf = &v20;
    sub_2D6A0(a1 + 48, (int *)&v20, (uint64_t)&unk_71834, (_DWORD **)buf)[5] = v15;
LABEL_17:
    *(void *)std::string buf = &v20;
    float v16 = sub_2D6A0(a1 + 48, (int *)&v20, (uint64_t)&unk_71834, (_DWORD **)buf);
    objc_msgSend(v16[5], "UpdateSpatialAudioQueueInfo:", v20, v21);
    *(void *)std::string buf = &v20;
    if (objc_msgSend(sub_2D6A0(a1 + 48, (int *)&v20, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "isActiveAudioQueue"))sub_21D18((uint64_t)a1, v20); {
    sub_5CEA4((uint64_t)v19);
    }
    sub_21EB8(a1, 1);
    return sub_5CF10(v19);
  }
  if (v13)
  {
    *(_DWORD *)std::string buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    __int16 v23 = 1024;
    int v24 = 0;
    _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "[ %d ] Audio Client already released new State = %d", buf, 0xEu);
  }
  return sub_5CF10(v19);
}

void sub_2B968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
}

uint64_t sub_2B984(uint64_t a1, int a2, int a3)
{
  int v47 = a2;
  v46[0] = 0;
  v46[1] = 0;
  sub_5CDCC((uint64_t)v46, a1 + 408);
  CFBooleanRef v6 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    __int16 v49 = 1024;
    int v50 = a3;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "[ %d ] Update Spatial client From Spatial Enable, State = %d", buf, 0xEu);
  }
  if (a3)
  {
    uint64_t v16 = *(void *)(a1 + 392);
    if (!v16) {
      goto LABEL_28;
    }
    uint64_t v17 = a1 + 392;
    do
    {
      int v18 = *(_DWORD *)(v16 + 32);
      BOOL v19 = v18 < v47;
      if (v18 >= v47) {
        uint64_t v20 = (uint64_t *)v16;
      }
      else {
        uint64_t v20 = (uint64_t *)(v16 + 8);
      }
      if (!v19) {
        uint64_t v17 = v16;
      }
      uint64_t v16 = *v20;
    }
    while (*v20);
    if (v17 == a1 + 392 || v47 < *(_DWORD *)(v17 + 32))
    {
LABEL_28:
      unsigned int v21 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v47;
        __int16 v49 = 1024;
        int v50 = a3;
        _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, "[ %d ] Create Stream info to List, State = %d", buf, 0xEu);
      }
      int v22 = [SpatialAudioClient alloc];
      __int16 v23 = [(SpatialAudioClient *)v22 initWithPid:v47 deviceID:(*(uint64_t (**)(void))(**(void **)a1 + 16))()];
      *(void *)std::string buf = &v47;
      sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5] = v23;
    }
    *(void *)std::string buf = &v47;
    objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "incrementRefCount");
    *(void *)std::string buf = &v47;
    unsigned int v13 = objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "spatialRefCount");
    __int16 v14 = qword_A1AD0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v47;
      __int16 v49 = 1024;
      int v50 = a3;
      BOOL v15 = "[ %d ] Update State information State = %d";
LABEL_33:
      _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 0xEu);
    }
  }
  else
  {
    uint64_t v7 = a1 + 392;
    uint64_t v8 = *(void *)(a1 + 392);
    if ((a3 & 4) == 0)
    {
      if (v8)
      {
        uint64_t v9 = a1 + 392;
        do
        {
          int v10 = *(_DWORD *)(v8 + 32);
          BOOL v11 = v10 < v47;
          if (v10 >= v47) {
            CFBooleanRef v12 = (uint64_t *)v8;
          }
          else {
            CFBooleanRef v12 = (uint64_t *)(v8 + 8);
          }
          if (!v11) {
            uint64_t v9 = v8;
          }
          uint64_t v8 = *v12;
        }
        while (*v12);
        if (v9 != v7 && v47 >= *(_DWORD *)(v9 + 32))
        {
          *(void *)std::string buf = &v47;
          objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "dercrementRefCount");
          *(void *)std::string buf = &v47;
          unsigned int v13 = objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "spatialRefCount");
          *(void *)std::string buf = &v47;
          if (!objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "spatialNonUIRefCount"))goto LABEL_50; {
          *(void *)std::string buf = &v47;
          }
          objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "resetNonUIRefCount");
          sub_21D18(a1, v47);
          __int16 v14 = qword_A1AD0;
          if (!os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_50;
          }
          *(_DWORD *)std::string buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v47;
          __int16 v49 = 1024;
          int v50 = a3;
          BOOL v15 = "[ %d ] Clear [ Non - UI] information State = %d";
          goto LABEL_33;
        }
      }
LABEL_49:
      unsigned int v13 = 0;
      goto LABEL_50;
    }
    if (!v8) {
      goto LABEL_44;
    }
    uint64_t v24 = a1 + 392;
    do
    {
      int v25 = *(_DWORD *)(v8 + 32);
      BOOL v26 = v25 < v47;
      if (v25 >= v47) {
        __int16 v27 = (uint64_t *)v8;
      }
      else {
        __int16 v27 = (uint64_t *)(v8 + 8);
      }
      if (!v26) {
        uint64_t v24 = v8;
      }
      uint64_t v8 = *v27;
    }
    while (*v27);
    if (v24 == v7 || v47 < *(_DWORD *)(v24 + 32))
    {
LABEL_44:
      BOOL v28 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v47;
        __int16 v49 = 1024;
        int v50 = a3;
        _os_log_impl(&dword_0, v28, OS_LOG_TYPE_DEFAULT, "[ %d ] Create Stream Non UI info to List, State = %d", buf, 0xEu);
      }
      __int16 v29 = [SpatialAudioClient alloc];
      int v30 = [(SpatialAudioClient *)v29 initWithPid:v47 deviceID:(*(uint64_t (**)(void))(**(void **)a1 + 16))()];
      *(void *)std::string buf = &v47;
      sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5] = v30;
    }
    *(void *)std::string buf = &v47;
    objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "setNonUIRefCount");
    __int16 v31 = qword_A1AD0;
    unsigned int v13 = 0;
    if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v47;
      __int16 v49 = 1024;
      int v50 = a3;
      _os_log_impl(&dword_0, v31, OS_LOG_TYPE_DEFAULT, "[ %d ] Update State [ Non - UI] information State = %d", buf, 0xEu);
      goto LABEL_49;
    }
  }
LABEL_50:
  unsigned int v32 = (void *)(a1 + 384);
  uint64_t v33 = (void *)(a1 + 392);
  uint64_t v34 = *(void *)(a1 + 392);
  if (v34)
  {
    uint64_t v35 = a1 + 392;
    do
    {
      int v36 = *(_DWORD *)(v34 + 32);
      BOOL v37 = v36 < v47;
      if (v36 >= v47) {
        BOOL v38 = (uint64_t *)v34;
      }
      else {
        BOOL v38 = (uint64_t *)(v34 + 8);
      }
      if (!v37) {
        uint64_t v35 = v34;
      }
      uint64_t v34 = *v38;
    }
    while (*v38);
    if ((void *)v35 != v33 && v47 >= *(_DWORD *)(v35 + 32))
    {
      *(void *)std::string buf = &v47;
      if (objc_msgSend(sub_2D6A0((uint64_t **)(a1 + 384), &v47, (uint64_t)&unk_71834, (_DWORD **)buf)[5], "spatialNonUIRefCount"))
      {
LABEL_61:
        int v39 = 1;
        goto LABEL_73;
      }
    }
  }
  int v40 = (void *)*v32;
  if ((void *)*v32 != v33)
  {
    int v39 = 0;
    while (![(id)v40[5] spatialRefCount])
    {
      float v41 = (void *)v40[1];
      if (v41)
      {
        do
        {
          xpc_object_t v42 = v41;
          float v41 = (void *)*v41;
        }
        while (v41);
      }
      else
      {
        do
        {
          xpc_object_t v42 = (void *)v40[2];
          BOOL v43 = *v42 == (void)v40;
          int v40 = v42;
        }
        while (!v43);
      }
      int v40 = v42;
      if (v42 == v33) {
        goto LABEL_73;
      }
    }
    goto LABEL_61;
  }
  int v39 = 0;
LABEL_73:
  sub_5CEA4((uint64_t)v46);
  *(_DWORD *)(a1 + 232) = v39;
  BOOL v44 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v47;
    __int16 v49 = 1024;
    int v50 = v39;
    __int16 v51 = 1024;
    unsigned int v52 = v13;
    _os_log_impl(&dword_0, v44, OS_LOG_TYPE_DEFAULT, "[ %d ]Spatial Enable: Updated Spatial Enable %d Ref Count %d ", buf, 0x14u);
  }
  return sub_5CF10(v46);
}

void sub_2C078(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

void sub_2C0A0(uint64_t a1, int a2)
{
  if (sub_395B4())
  {
    *(_DWORD *)(a1 + 251) = 0;
    if (a2 && *(unsigned char *)(a1 + 361) && *(unsigned char *)(a1 + 360))
    {
      int v27 = 0;
      BOOL v26 = 0;
      if (_os_feature_enabled_impl()) {
        CFTypeID v4 = 0;
      }
      else {
        CFTypeID v4 = @"global";
      }
      sub_2B3A0(a1, v4, &v27, &v26);
      CFNumberRef v5 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = *(unsigned __int8 *)(a1 + 129);
        int v7 = *(unsigned __int8 *)(a1 + 361);
        int v8 = *(unsigned __int8 *)(a1 + 362);
        int v9 = *(unsigned __int8 *)(a1 + 360);
        *(_DWORD *)std::string buf = 138414082;
        *(void *)__int16 v29 = v4;
        *(_WORD *)&v29[8] = 1024;
        *(_DWORD *)int v30 = 1;
        *(_WORD *)&uint8_t v30[4] = 1024;
        *(_DWORD *)&v30[6] = v6;
        *(_WORD *)&v30[10] = 1024;
        *(_DWORD *)&v30[12] = v7;
        *(_WORD *)&v30[16] = 1024;
        *(_DWORD *)&v30[18] = v8;
        *(_WORD *)&v30[22] = 1024;
        *(_DWORD *)&v30[24] = v9;
        *(_WORD *)&v30[28] = 1024;
        *(_DWORD *)&v30[30] = v27;
        *(_WORD *)&v30[34] = 1024;
        *(_DWORD *)&v30[36] = v26;
        _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "[ %@ ] UpdateSpatialAudioCCStates Streaming = %d screensharingState %d Channels = %d BestAvailableContentType = %d Spatial Status = %d Mode = %d Head Tracking = %d", buf, 0x36u);
      }
      BOOL v10 = 1;
      *(unsigned char *)(a1 + 251) = 1;
      int v11 = *(unsigned __int8 *)(a1 + 360);
      switch(*(unsigned char *)(a1 + 360))
      {
        case 2:
          goto LABEL_21;
        case 3:
        case 6:
          BOOL v10 = v11 == 5;
          goto LABEL_12;
        case 4:
LABEL_12:
          sub_27EFC(a1);
          int v12 = 1;
          *(unsigned char *)(a1 + 254) = 1;
          break;
        default:
          BOOL v10 = v11 == 5;
LABEL_21:
          sub_27EFC(a1);
          int v12 = 0;
          break;
      }
      switch(v27)
      {
        case 0:
          goto LABEL_43;
        case 1:
          goto LABEL_32;
        case 2:
          if (v10 || !os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR)) {
            goto LABEL_25;
          }
          sub_66E98();
          if (!v12) {
            goto LABEL_32;
          }
          goto LABEL_26;
        case 3:
LABEL_25:
          if (v12)
          {
LABEL_26:
            BOOL v16 = v27 == 3 && v10;
            if (v16 && os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_ERROR)) {
              sub_66E64();
            }
          }
LABEL_32:
          char v17 = !v10;
          if ((v11 - 1) > 1) {
            char v17 = 1;
          }
          if ((v17 & 1) == 0) {
            *(unsigned char *)(a1 + 252) = 1;
          }
          if (*(unsigned char *)(a1 + 360) == 5) {
            *(unsigned char *)(a1 + 252) = 1;
          }
          if (v12)
          {
            if (v10)
            {
              *(unsigned char *)(a1 + 253) = 1;
            }
            else
            {
              int v18 = qword_A1AD0;
              if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
              {
                int v19 = *(unsigned __int8 *)(a1 + 362);
                *(_DWORD *)std::string buf = 67109120;
                *(_DWORD *)__int16 v29 = v19;
                _os_log_impl(&dword_0, v18, OS_LOG_TYPE_DEFAULT, "Spatial Audio: Not spatializing BestAvailableContentType = %d", buf, 8u);
              }
LABEL_43:
              unsigned int v20 = *(unsigned __int8 *)(a1 + 362);
              if (v20 <= 3 && v20 != 1) {
                *(unsigned char *)(a1 + 254) = 0;
              }
            }
          }
          break;
        default:
          break;
      }
      sub_2C634(a1, 0);
      unsigned int v21 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = "YES";
        if (*(unsigned char *)(a1 + 251)) {
          __int16 v23 = "YES";
        }
        else {
          __int16 v23 = "NO";
        }
        if (*(unsigned char *)(a1 + 252)) {
          uint64_t v24 = "YES";
        }
        else {
          uint64_t v24 = "NO";
        }
        if (*(unsigned char *)(a1 + 254)) {
          int v25 = "YES";
        }
        else {
          int v25 = "NO";
        }
        if (!*(unsigned char *)(a1 + 253)) {
          int v22 = "NO";
        }
        *(_DWORD *)std::string buf = 138413570;
        *(void *)__int16 v29 = v4;
        *(_WORD *)&v29[8] = 1024;
        *(_DWORD *)int v30 = v27;
        *(_WORD *)&uint8_t v30[4] = 2082;
        *(void *)&v30[6] = v23;
        *(_WORD *)&v30[14] = 2082;
        *(void *)&v30[16] = v24;
        *(_WORD *)&v30[24] = 2082;
        *(void *)&v30[26] = v25;
        *(_WORD *)&v30[34] = 2082;
        *(void *)&v30[36] = v22;
        _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, "[ %@ ] Spatial Audio: [%d] Control Center State mSpatialAudioCCIsAvailable = %{public}s mSpatialAudioCCState = %{public}s mSpatializeStereoCCIsAvailable = %{public}s mSpatializeStereoCCState = %{public}s", buf, 0x3Au);
      }
      sub_49F68(*(void *)a1, 1752457571);
      sub_49F68(*(void *)a1, 1752462196);
      sub_49F68(*(void *)a1, 1752457590);
      sub_49F68(*(void *)a1, 1936744822);
      sub_49F68(*(void *)a1, 1936749430);
      sub_49F68(*(void *)a1, 1936746095);
      sub_49F68(*(void *)a1, 1633907555);
    }
    else
    {
      unsigned int v13 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = *(unsigned __int8 *)(a1 + 129);
        if (*(unsigned char *)(a1 + 255)) {
          BOOL v15 = "YES";
        }
        else {
          BOOL v15 = "NO";
        }
        *(_DWORD *)std::string buf = 67110658;
        *(_DWORD *)__int16 v29 = a2;
        *(_WORD *)&v29[4] = 1024;
        *(_DWORD *)&v29[6] = v14;
        *(_WORD *)int v30 = 2082;
        *(void *)&v30[2] = "NO";
        *(_WORD *)&v30[10] = 2082;
        *(void *)&v30[12] = "NO";
        *(_WORD *)&v30[20] = 2082;
        *(void *)&v30[22] = "NO";
        *(_WORD *)&v30[30] = 2082;
        *(void *)&v30[32] = "NO";
        *(_WORD *)&v30[40] = 2082;
        *(void *)&v30[42] = v15;
        _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "Spatial Audio: Control Center State isStreaming %d screensharingState %d mSpatialAudioCCIsAvailable = %{public}s mSpatialAudioCCState = %{public}s mSpatializeStereoCCIsAvailable = %{public}s mSpatializeStereoCCState = %{public}s mIsLastSessionSpatial = %{public}s", buf, 0x40u);
      }
      sub_49F68(*(void *)a1, 1752457571);
      sub_49F68(*(void *)a1, 1752462196);
      sub_49F68(*(void *)a1, 1752457590);
      sub_49F68(*(void *)a1, 1936744822);
      sub_49F68(*(void *)a1, 1936749430);
      sub_49F68(*(void *)a1, 1936746095);
      sub_49F68(*(void *)a1, 1633907555);
      sub_2C634(a1, 0);
    }
  }
}

void sub_2C634(uint64_t a1, int a2)
{
  *(unsigned char *)(a1 + 256) = a2;
  if (a2) {
    uint64_t v4 = mach_absolute_time();
  }
  else {
    uint64_t v4 = 0;
  }
  *(void *)(a1 + 480) = v4;
  CFNumberRef v5 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = "NO";
    if (a2) {
      int v6 = "YES";
    }
    int v7 = 136446210;
    int v8 = v6;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Spatial UI busy %{public}s", (uint8_t *)&v7, 0xCu);
  }
}

void sub_2C708(void *a1, int a2, int a3)
{
  if (_os_feature_enabled_impl()) {
    int v6 = 0;
  }
  else {
    int v6 = @"global";
  }
  unsigned int v7 = *((unsigned __int8 *)a1 + 360);
  int v31 = 0;
  BOOL v30 = 0;
  sub_2B3A0((uint64_t)a1, v6, &v31, &v30);
  unsigned int v8 = (v7 < 6) & (0x34u >> v7);
  int v9 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v10 = "Disable";
    int v11 = *((unsigned __int8 *)a1 + 360);
    if (a2) {
      BOOL v10 = "Enable";
    }
    int v12 = *((unsigned __int8 *)a1 + 362);
    unsigned int v13 = "NO";
    *(_DWORD *)std::string buf = 136447746;
    if ((a2 & v8) != 0) {
      unsigned int v13 = "YES";
    }
    uint64_t v33 = (void *)v10;
    __int16 v34 = 1024;
    *(_DWORD *)uint64_t v35 = v31;
    *(_WORD *)&v35[4] = 1024;
    *(_DWORD *)&v35[6] = v30;
    *(_WORD *)int v36 = 1024;
    *(_DWORD *)&v36[2] = a3;
    *(_WORD *)BOOL v37 = 1024;
    *(_DWORD *)&v37[2] = v11;
    *(_WORD *)BOOL v38 = 1024;
    *(_DWORD *)&v38[2] = v12;
    *(_WORD *)int v39 = 2082;
    *(void *)&v39[2] = v13;
    _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "Spatial Control Centre Request to %{public}s Spatial Audio Current Mode = %d HT [%d -> %d] Spatialization Status = %d Best Available Content %d Only HeadTracking changed %{public}s", buf, 0x34u);
  }
  if (*((unsigned char *)a1 + 256))
  {
    if ((float)((float)((mach_absolute_time() - a1[60])
                       * *((unsigned int *)a1 + 150)
                       / *((unsigned int *)a1 + 151)
                       / 0x3E8)
               / 1000000.0) < 5.0)
    {
      int v14 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        if (a2) {
          BOOL v15 = "YES";
        }
        else {
          BOOL v15 = "NO";
        }
        double v16 = (float)((float)((mach_absolute_time() - a1[60])
                            * *((unsigned int *)a1 + 150)
                            / *((unsigned int *)a1 + 151)
                            / 0x3E8)
                    / 1000000.0);
        *(_DWORD *)std::string buf = 136446466;
        uint64_t v33 = (void *)v15;
        __int16 v34 = 2048;
        *(double *)uint64_t v35 = v16;
        _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "Received Spatial Control Centre Update [ %{public}s ] while previous process is ongoing time from the last update %f ", buf, 0x16u);
      }
      return;
    }
    sub_2C634((uint64_t)a1, 0);
  }
  if (a2)
  {
    if (*((unsigned __int8 *)a1 + 362) > 1u && (v31 != 1 ? (char v17 = 1) : (char v17 = v8), (v17 & 1) != 0))
    {
      if (v31) {
        sub_2B1B4((uint64_t)a1, v6, v31, a3);
      }
      else {
        sub_2B1B4((uint64_t)a1, v6, 1, a3);
      }
    }
    else
    {
      sub_2B1B4((uint64_t)a1, v6, 2, a3);
    }
  }
  else
  {
    sub_2B1B4((uint64_t)a1, v6, 0, v30);
  }
  unsigned int v29 = 0;
  BOOL v28 = 0;
  sub_2B3A0((uint64_t)a1, v6, &v29, &v28);
  if (v31 != v29) {
    sub_2C634((uint64_t)a1, 1);
  }
  int v18 = *(unsigned char **)(*a1 + 9088);
  if (v18 && v18[192]) {
    (*(void (**)(unsigned char *, __CFString *, void, BOOL))(*(void *)v18 + 608))(v18, v6, v29, v28);
  }
  *((unsigned char *)a1 + 472) = 0;
  v27[0] = 0;
  v27[1] = 0;
  sub_5CDCC((uint64_t)v27, (uint64_t)(a1 + 51));
  int v19 = (void *)a1[48];
  if (v19 == a1 + 49)
  {
    unsigned int v20 = 0;
  }
  else
  {
    unsigned int v20 = 0;
    do
    {
      unsigned int v21 = [(id)v19[5] numActiveQueue];
      int v22 = (void *)v19[1];
      if (v22)
      {
        do
        {
          __int16 v23 = v22;
          int v22 = (void *)*v22;
        }
        while (v22);
      }
      else
      {
        do
        {
          __int16 v23 = (void *)v19[2];
          BOOL v24 = *v23 == (void)v19;
          int v19 = v23;
        }
        while (!v24);
      }
      v20 += v21;
      int v19 = v23;
    }
    while (v23 != a1 + 49);
  }
  sub_5CEA4((uint64_t)v27);
  if (v20 >= 2) {
    *((unsigned char *)a1 + 472) = 1;
  }
  if (v31 == v29 && v30 != a3) {
    (*(void (**)(void))(*(void *)*a1 + 704))(*a1);
  }
  int v25 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v26 = "Disabled";
    if (a2) {
      BOOL v26 = "Enabled ";
    }
    *(_DWORD *)std::string buf = 138413826;
    uint64_t v33 = v6;
    __int16 v34 = 2082;
    *(void *)uint64_t v35 = v26;
    *(_WORD *)&v35[8] = 1024;
    *(_DWORD *)int v36 = v31;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)BOOL v37 = v30;
    *(_WORD *)&v37[4] = 1024;
    *(_DWORD *)BOOL v38 = v29;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)int v39 = v28;
    *(_WORD *)&v39[4] = 1024;
    *(_DWORD *)&v39[6] = v20;
    _os_log_impl(&dword_0, v25, OS_LOG_TYPE_DEFAULT, "[ %@ ] Spatial Control Centre Request update: SetSpatialAudioCCState %{public}s Current Mode %d [%d] -> %d [%d] Number of Queues %d", buf, 0x34u);
  }
  sub_5CF10(v27);
}

void sub_2CC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

float sub_2CC7C(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3 = (unint64_t)*(unsigned int *)(a1 + 600) * a2 / *(unsigned int *)(a1 + 604) / 0x3E8;
  if (!a3)
  {
    float v5 = (float)v3;
    float v6 = 1000000.0;
    return v5 / v6;
  }
  if (a3 == 1)
  {
    float v5 = (float)v3;
    float v6 = 1000.0;
    return v5 / v6;
  }
  float result = 0.0;
  if (a3 == 2) {
    return (float)v3;
  }
  return result;
}

void *sub_2CCEC(void *result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (a2)
  {
    float v6 = (char *)result[49];
    if (v6)
    {
      int v9 = (char *)(result + 49);
      BOOL v10 = (char *)(result + 49);
      int v11 = (char *)result[49];
      do
      {
        int v12 = *((_DWORD *)v11 + 8);
        BOOL v13 = v12 < a2;
        if (v12 >= a2) {
          int v14 = (char **)v11;
        }
        else {
          int v14 = (char **)(v11 + 8);
        }
        if (!v13) {
          BOOL v10 = v11;
        }
        int v11 = *v14;
      }
      while (*v14);
      if (v10 != v9 && *((_DWORD *)v10 + 8) <= a2)
      {
        BOOL v15 = (char *)(result + 49);
        do
        {
          int v16 = *((_DWORD *)v6 + 8);
          BOOL v17 = v16 < a2;
          if (v16 >= a2) {
            int v18 = (char **)v6;
          }
          else {
            int v18 = (char **)(v6 + 8);
          }
          if (!v17) {
            BOOL v15 = v6;
          }
          float v6 = *v18;
        }
        while (*v18);
        if (v15 == v9 || *((_DWORD *)v15 + 8) > a2) {
          BOOL v15 = (char *)(result + 49);
        }
        if (a3) {
          float result = [*((id *)v15 + 5) setSpatialAudioUserSelection:a5];
        }
        if (a4)
        {
          int v19 = (void *)*((void *)v15 + 5);
          return [v19 setSpatialAudioHeadTrackingUserSelection:a6];
        }
      }
    }
  }
  return result;
}

void sub_2CDD4(void *a1, int a2, int a3)
{
  int v6 = _os_feature_enabled_impl();
  unsigned int v7 = *((unsigned __int8 *)a1 + 360);
  if (v6) {
    unsigned int v8 = 0;
  }
  else {
    unsigned int v8 = @"global";
  }
  int v32 = 0;
  BOOL v31 = 0;
  sub_2B3A0((uint64_t)a1, v8, &v32, &v31);
  int v9 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *((unsigned __int8 *)a1 + 360);
    int v11 = "Disable";
    unsigned int v12 = *((unsigned __int8 *)a1 + 362);
    *(_DWORD *)std::string buf = 136447746;
    if (a2) {
      int v11 = "Enable";
    }
    __int16 v34 = v11;
    __int16 v35 = 1024;
    *(_DWORD *)int v36 = v32;
    if (((v7 < 6) & (0x34u >> v7) & a2) != 0) {
      BOOL v13 = "YES";
    }
    else {
      BOOL v13 = "NO";
    }
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&unsigned char v36[6] = v31;
    __int16 v37 = 1024;
    int v38 = a3;
    __int16 v39 = 1024;
    BOOL v40 = v10;
    __int16 v41 = 1024;
    unsigned int v42 = v12;
    __int16 v43 = 2082;
    BOOL v44 = v13;
    _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "Spatial Control Centre Request to %{public}s Stereo Upmix Current Mode = %d [ %d --> %d] Spatialization Status = %d Best Available Content %d Head Tracking only Changed %{public}s", buf, 0x34u);
  }
  if (*((unsigned char *)a1 + 256))
  {
    if (!a1[60]) {
      a1[60] = mach_absolute_time();
    }
    if ((float)((float)((mach_absolute_time() - a1[60])
                       * *((unsigned int *)a1 + 150)
                       / *((unsigned int *)a1 + 151)
                       / 0x3E8)
               / 1000.0) < 3.0)
    {
      int v14 = qword_A1AD0;
      if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
      {
        if (a2) {
          BOOL v15 = "YES";
        }
        else {
          BOOL v15 = "NO";
        }
        double v16 = (float)((float)((mach_absolute_time() - a1[60])
                            * *((unsigned int *)a1 + 150)
                            / *((unsigned int *)a1 + 151)
                            / 0x3E8)
                    / 1000.0);
        *(_DWORD *)std::string buf = 136446466;
        __int16 v34 = v15;
        __int16 v35 = 2048;
        *(double *)int v36 = v16;
        _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "Received Stereo Upmix Control Centre Update [ %{public}s ] while previous process is ongoing time from the last update %f ", buf, 0x16u);
      }
      return;
    }
    a1[60] = 0;
    sub_2C634((uint64_t)a1, 0);
  }
  if (a2)
  {
    unsigned int v17 = *((unsigned __int8 *)a1 + 360);
    if (v17 <= 5 && ((1 << v17) & 0x34) != 0) {
      sub_2B1B4((uint64_t)a1, v8, v32, a3);
    }
    else {
      sub_2B1B4((uint64_t)a1, v8, 2, a3);
    }
    goto LABEL_35;
  }
  if (v32 != 3)
  {
    int v18 = *((unsigned __int8 *)a1 + 360);
    if (v18 == 2)
    {
      sub_2B1B4((uint64_t)a1, v8, 3, v31);
      goto LABEL_35;
    }
    if (v18 == 4)
    {
      if (*((unsigned __int8 *)a1 + 362) < 2u) {
        sub_2B1B4((uint64_t)a1, v8, 3, v31);
      }
      else {
        sub_2B1B4((uint64_t)a1, v8, 0, v31);
      }
      goto LABEL_35;
    }
  }
  sub_2B1B4((uint64_t)a1, v8, 0, v31);
LABEL_35:
  unsigned int v30 = 0;
  BOOL v29 = 0;
  sub_2B3A0((uint64_t)a1, v8, &v30, &v29);
  if (v32 != v30) {
    sub_2C634((uint64_t)a1, 1);
  }
  int v19 = *(unsigned char **)(*a1 + 9088);
  if (v19 && v19[192]) {
    (*(void (**)(unsigned char *, __CFString *, void, BOOL))(*(void *)v19 + 608))(v19, v8, v30, v29);
  }
  *((unsigned char *)a1 + 472) = 0;
  v28[0] = 0;
  v28[1] = 0;
  sub_5CDCC((uint64_t)v28, (uint64_t)(a1 + 51));
  unsigned int v20 = (void *)a1[48];
  if (v20 == a1 + 49)
  {
    unsigned int v21 = 0;
  }
  else
  {
    unsigned int v21 = 0;
    do
    {
      unsigned int v22 = [(id)v20[5] numActiveQueue];
      __int16 v23 = (void *)v20[1];
      if (v23)
      {
        do
        {
          BOOL v24 = v23;
          __int16 v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          BOOL v24 = (void *)v20[2];
          BOOL v25 = *v24 == (void)v20;
          unsigned int v20 = v24;
        }
        while (!v25);
      }
      v21 += v22;
      unsigned int v20 = v24;
    }
    while (v24 != a1 + 49);
  }
  sub_5CEA4((uint64_t)v28);
  if (v21 >= 2) {
    *((unsigned char *)a1 + 472) = 1;
  }
  if (v32 == v30 && v31 != a3) {
    (*(void (**)(void))(*(void *)*a1 + 704))(*a1);
  }
  BOOL v26 = qword_A1AD0;
  if (os_log_type_enabled((os_log_t)qword_A1AD0, OS_LOG_TYPE_DEFAULT))
  {
    int v27 = "Disabled";
    if (a2) {
      int v27 = "Enabled ";
    }
    *(_DWORD *)std::string buf = 136447490;
    __int16 v34 = v27;
    __int16 v35 = 1024;
    *(_DWORD *)int v36 = v32;
    *(_WORD *)&v36[4] = 1024;
    *(_DWORD *)&unsigned char v36[6] = v31;
    __int16 v37 = 1024;
    int v38 = v30;
    __int16 v39 = 1024;
    BOOL v40 = v29;
    __int16 v41 = 1024;
    unsigned int v42 = v21;
    _os_log_impl(&dword_0, v26, OS_LOG_TYPE_DEFAULT, "Spatial Control Centre update, SetSpatializeStereoCCState %{public}s Current Mode %d [ %d ] -> %d [ %d ] Num Queues %d", buf, 0x2Au);
  }
  sub_5CF10(v28);
}

void sub_2D39C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_2D3BC(uint64_t a1, int a2, unsigned int *a3, _DWORD *a4, _DWORD *a5)
{
  v18[0] = 0;
  v18[1] = 0;
  sub_5CDCC((uint64_t)v18, a1 + 408);
  int v10 = *(void **)(a1 + 384);
  int v11 = (void *)(a1 + 392);
  if (v10 != (void *)(a1 + 392))
  {
    while (1)
    {
      unsigned int v12 = (void *)v10[5];
      if ([v12 hostProcess] == a2) {
        break;
      }
      BOOL v13 = (void *)v10[1];
      if (v13)
      {
        do
        {
          int v14 = v13;
          BOOL v13 = (void *)*v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          int v14 = (void *)v10[2];
          BOOL v15 = *v14 == (void)v10;
          int v10 = v14;
        }
        while (!v15);
      }
      int v10 = v14;
      if (v14 == v11) {
        goto LABEL_16;
      }
    }
    unsigned int v16 = [v12 HighestQualityFormat];
    if (a4) {
      *a4 = [v12 spatialAudioUserSelection];
    }
    if (a5) {
      *a5 = [v12 spatialAudioHeadTrackingUserSelection];
    }
    if (v16) {
      *a3 = v16;
    }
  }
LABEL_16:
  sub_5CEA4((uint64_t)v18);
  sub_5CF10(v18);
  return 0;
}

void sub_2D4C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_2D4E0(unsigned __int8 *a1)
{
  unsigned int v1 = a1[360];
  BOOL v2 = v1 > 5;
  int v3 = (1 << v1) & 0x34;
  if (!v2 && v3 != 0) {
    return a1[361];
  }
  if ((a1[362] & 0xFE) == 2) {
    return 6;
  }
  return 2;
}

uint64_t sub_2D524(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 356);
  unsigned int v3 = *(unsigned __int8 *)(a1 + 360);
  BOOL v4 = v3 > 5;
  int v5 = (1 << v3) & 0x34;
  if (v4 || v5 == 0)
  {
    if (*(unsigned char *)(a1 + 362) == 3) {
      return 1902324531;
    }
    else {
      return result;
    }
  }
  return result;
}

uint64_t sub_2D568(uint64_t result, int a2)
{
  *(unsigned char *)(result + 255) = a2 != 0;
  return result;
}

CFDictionaryRef sub_2D578(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, a1 + 520);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, *(CFDictionaryRef *)(a1 + 496));
  sub_5CF10(v4);
  return Copy;
}

void sub_2D5D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_2D5E8(uint64_t a1, char a2)
{
  *(unsigned char *)(a1 + 328) = a2;
  return sub_2D5F0(a1);
}

uint64_t sub_2D5F0(uint64_t a1)
{
  *(unsigned char *)(a1 + 340) = 0;
  int v2 = *(_DWORD *)(a1 + 336);
  if ((v2 & 2) != 0 && *(unsigned char *)(a1 + 328))
  {
    int v3 = 1;
    *(unsigned char *)(a1 + 340) = 1;
  }
  else
  {
    int v3 = 0;
  }
  *(_DWORD *)(a1 + 336) = v2 & 0xFFFFFFFE | v3;
  uint64_t v4 = *(void *)a1;
  int v5 = *(unsigned char **)(*(void *)a1 + 9088);
  if (v5 && v5[192])
  {
    (*(void (**)(void))(*(void *)v5 + 584))(*(void *)(*(void *)a1 + 9088));
    uint64_t v4 = *(void *)a1;
  }

  return sub_49F68(v4, 1936747877);
}

uint64_t **sub_2D6A0(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unsigned int v7 = a1 + 1;
  int v6 = a1[1];
  if (v6)
  {
    int v8 = *a2;
    while (1)
    {
      while (1)
      {
        int v9 = (uint64_t **)v6;
        int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        int v6 = *v9;
        unsigned int v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      int v6 = v9[1];
      if (!v6)
      {
        unsigned int v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    int v9 = a1 + 1;
LABEL_10:
    int v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0;
    sub_18A8C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_2D764(uint64_t a1, int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 < v3;
    if (v5 >= v3) {
      unsigned int v7 = (uint64_t *)v2;
    }
    else {
      unsigned int v7 = (uint64_t *)(v2 + 8);
    }
    if (!v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0;
  }
  sub_2D7E0((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

uint64_t *sub_2D7E0(uint64_t **a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      int v3 = v2;
      uint64_t v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    uint64_t v4 = a2;
    do
    {
      int v3 = (uint64_t *)v4[2];
      BOOL v5 = *v3 == (void)v4;
      uint64_t v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2) {
    *a1 = v3;
  }
  BOOL v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_2D854(v6, a2);
  return v3;
}

uint64_t *sub_2D854(uint64_t *result, uint64_t *a2)
{
  uint64_t v2 = *a2;
  int v3 = a2;
  if (*a2)
  {
    uint64_t v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      int v3 = a2;
      goto LABEL_7;
    }
    do
    {
      int v3 = v4;
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  uint64_t v2 = v3[1];
  if (v2)
  {
LABEL_7:
    int v5 = 0;
    *(void *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  int v5 = 1;
LABEL_8:
  BOOL v6 = (uint64_t **)v3[2];
  unsigned int v7 = *v6;
  if (*v6 == v3)
  {
    *BOOL v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      unsigned int v7 = 0;
      uint64_t result = (uint64_t *)v2;
    }
    else
    {
      unsigned int v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  int v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    uint64_t v9 = a2[2];
    void v3[2] = v9;
    *(void *)(v9 + 8 * (*(void *)a2[2] != (void)a2)) = v3;
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    *(void *)(v11 + 16) = v3;
    *int v3 = v11;
    v3[1] = v10;
    if (v10) {
      *(void *)(v10 + 16) = v3;
    }
    *((unsigned char *)v3 + 24) = *((unsigned char *)a2 + 24);
    if (result == a2) {
      uint64_t result = v3;
    }
  }
  if (!v8 || !result) {
    return result;
  }
  if (!v5)
  {
    *(unsigned char *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    uint64_t v12 = v7[2];
    if (*(uint64_t **)v12 == v7) {
      break;
    }
    if (!*((unsigned char *)v7 + 24))
    {
      *((unsigned char *)v7 + 24) = 1;
      *(unsigned char *)(v12 + 24) = 0;
      BOOL v13 = *(uint64_t **)(v12 + 8);
      uint64_t v14 = *v13;
      *(void *)(v12 + 8) = *v13;
      if (v14) {
        *(void *)(v14 + 16) = v12;
      }
      v13[2] = *(void *)(v12 + 16);
      *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v13;
      *BOOL v13 = v12;
      *(void *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7) {
        uint64_t result = v7;
      }
      unsigned int v7 = *(uint64_t **)(*v7 + 8);
    }
    BOOL v15 = (void *)*v7;
    if (*v7 && !*((unsigned char *)v15 + 24))
    {
      unsigned int v16 = (uint64_t *)v7[1];
      if (!v16) {
        goto LABEL_56;
      }
LABEL_55:
      if (*((unsigned char *)v16 + 24))
      {
LABEL_56:
        *((unsigned char *)v15 + 24) = 1;
        *((unsigned char *)v7 + 24) = 0;
        uint64_t v22 = v15[1];
        *unsigned int v7 = v22;
        if (v22) {
          *(void *)(v22 + 16) = v7;
        }
        v15[2] = v7[2];
        *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v15;
        v15[1] = v7;
        long long v7[2] = (uint64_t)v15;
        unsigned int v16 = v7;
      }
      else
      {
        BOOL v15 = v7;
      }
      uint64_t v23 = v15[2];
      *((unsigned char *)v15 + 24) = *(unsigned char *)(v23 + 24);
      *(unsigned char *)(v23 + 24) = 1;
      *((unsigned char *)v16 + 24) = 1;
      BOOL v24 = *(uint64_t **)(v23 + 8);
      uint64_t v25 = *v24;
      *(void *)(v23 + 8) = *v24;
      if (v25) {
        *(void *)(v25 + 16) = v23;
      }
      void v24[2] = *(void *)(v23 + 16);
      *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
      *BOOL v24 = v23;
      goto LABEL_72;
    }
    unsigned int v16 = (uint64_t *)v7[1];
    if (v16 && !*((unsigned char *)v16 + 24)) {
      goto LABEL_55;
    }
    *((unsigned char *)v7 + 24) = 0;
    unsigned int v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      unsigned int v17 = result;
LABEL_53:
      *((unsigned char *)v17 + 24) = 1;
      return result;
    }
    if (!*((unsigned char *)v17 + 24)) {
      goto LABEL_53;
    }
LABEL_49:
    unsigned int v7 = *(uint64_t **)(v17[2] + 8 * (*(void *)v17[2] == (void)v17));
  }
  if (!*((unsigned char *)v7 + 24))
  {
    *((unsigned char *)v7 + 24) = 1;
    *(unsigned char *)(v12 + 24) = 0;
    uint64_t v18 = v7[1];
    *(void *)uint64_t v12 = v18;
    if (v18) {
      *(void *)(v18 + 16) = v12;
    }
    long long v7[2] = *(void *)(v12 + 16);
    *(void *)(*(void *)(v12 + 16) + 8 * (**(void **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(void *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12) {
      uint64_t result = v7;
    }
    unsigned int v7 = *(uint64_t **)v12;
  }
  int v19 = (void *)*v7;
  if (*v7 && !*((unsigned char *)v19 + 24)) {
    goto LABEL_68;
  }
  unsigned int v20 = (uint64_t *)v7[1];
  if (!v20 || *((unsigned char *)v20 + 24))
  {
    *((unsigned char *)v7 + 24) = 0;
    unsigned int v17 = (uint64_t *)v7[2];
    if (*((unsigned char *)v17 + 24)) {
      BOOL v21 = v17 == result;
    }
    else {
      BOOL v21 = 1;
    }
    if (v21) {
      goto LABEL_53;
    }
    goto LABEL_49;
  }
  if (v19 && !*((unsigned char *)v19 + 24))
  {
LABEL_68:
    unsigned int v20 = v7;
  }
  else
  {
    *((unsigned char *)v20 + 24) = 1;
    *((unsigned char *)v7 + 24) = 0;
    uint64_t v26 = *v20;
    v7[1] = *v20;
    if (v26) {
      *(void *)(v26 + 16) = v7;
    }
    void v20[2] = v7[2];
    *(void *)(v7[2] + 8 * (*(void *)v7[2] != (void)v7)) = v20;
    *unsigned int v20 = (uint64_t)v7;
    long long v7[2] = (uint64_t)v20;
    int v19 = v7;
  }
  uint64_t v23 = v20[2];
  *((unsigned char *)v20 + 24) = *(unsigned char *)(v23 + 24);
  *(unsigned char *)(v23 + 24) = 1;
  *((unsigned char *)v19 + 24) = 1;
  BOOL v24 = *(uint64_t **)v23;
  uint64_t v27 = *(void *)(*(void *)v23 + 8);
  *(void *)uint64_t v23 = v27;
  if (v27) {
    *(void *)(v27 + 16) = v23;
  }
  void v24[2] = *(void *)(v23 + 16);
  *(void *)(*(void *)(v23 + 16) + 8 * (**(void **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(void *)(v23 + 16) = v24;
  return result;
}

os_log_t sub_2DBD8()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AD0 = (uint64_t)result;
  return result;
}

void sub_2F248(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

os_log_t sub_2F268()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AD8 = (uint64_t)result;
  return result;
}

void sub_2F298(uint64_t a1, int a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  v5[0] = *(_OWORD *)a3;
  v5[1] = v3;
  uint64_t v6 = *(void *)(a3 + 32);
  sub_12C34(a1, a2, v5);
  *(void *)uint64_t v4 = &off_8E2A0;
  *(_DWORD *)(v4 + 152) = 10240;
  operator new[]();
}

void sub_2F340(_Unwind_Exception *a1)
{
  sub_12C84(v1);
  _Unwind_Resume(a1);
}

void sub_2F35C(void *a1)
{
  sub_12C84(a1);

  operator delete();
}

uint64_t sub_2F394(uint64_t a1, int a2)
{
  uint64_t v2 = *(unsigned int *)(a1 + 92);
  *(_DWORD *)(a1 + 156) = a2;
  if ((int)v2 >= 1)
  {
    uint64_t v4 = a1 + 180;
    do
    {
      g726_init(v4, a2, 2);
      v4 += 64;
      --v2;
    }
    while (v2);
  }
  return 0;
}

uint64_t sub_2F3F0(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 92);
  if ((int)v1 >= 1)
  {
    uint64_t v2 = result;
    uint64_t v3 = result + 180;
    do
    {
      os_log_t result = g726_init(v3, *(_DWORD *)(v2 + 156), 2);
      v3 += 64;
      --v1;
    }
    while (v1);
  }
  return result;
}

void sub_2F444(uint64_t a1, _WORD *a2, unsigned int a3, uint64_t a4)
{
  if (*(_DWORD *)(a1 + 92) == 2)
  {
    uint64_t v6 = (char *)(a1 + 20788);
    if (a3)
    {
      uint64_t v7 = a3;
      uint64_t v8 = a3;
      uint64_t v9 = a1;
      do
      {
        *(_WORD *)(v9 + 308) = *a2;
        *(_WORD *)(v9 + 10548) = a2[1];
        v9 += 2;
        a2 += 2;
        --v8;
      }
      while (v8);
    }
    else
    {
      uint64_t v7 = 0;
    }
    __int16 v11 = g726_encode_frame(a1 + 180, a1 + 308, v7, a1 + 20788);
    unsigned __int16 v12 = g726_encode_frame(a1 + 244, a1 + 10548, v7, a1 + 25908) + v11;
    __int16 v10 = v12;
    if ((__int16)v12 >= 2)
    {
      uint64_t v13 = 0;
      uint64_t v14 = (char *)(a1 + 25908);
      uint64_t v15 = v12 >> 1;
      do
      {
        char v16 = *v6++;
        *(unsigned char *)(*(void *)(a1 + 144) + v13) = v16;
        char v17 = *v14++;
        uint64_t v18 = *(void *)(a1 + 144) + v13;
        v13 += 2;
        *(unsigned char *)(v18 + 1) = v17;
        --v15;
      }
      while (v15);
    }
  }
  else
  {
    __int16 v10 = g726_encode_frame(a1 + 180, (uint64_t)a2, a3, *(void *)(a1 + 144));
  }
  int v19 = v10;
  if (*(unsigned char *)(a1 + 177)) {
    sub_1330C(a1, v10, 0);
  }
  *(_DWORD *)a4 = 1;
  *(void *)(a4 + 16) = *(void *)(a1 + 144);
  *(_DWORD *)(a4 + 8) = 1;
  *(_DWORD *)(a4 + 12) = v19;
}

os_log_t sub_2F588()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AE0 = (uint64_t)result;
  return result;
}

void sub_2FBAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_2FBCC(uint64_t a1, uint64_t a2, void *a3)
{
  id result = [a3 intValue];
  if (result == 1) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return result;
}

void sub_2FD78(uint64_t a1)
{
  uint64_t v2 = sub_44C8C(qword_A2350, *(_DWORD *)(*(void *)(a1 + 32) + 72));
  uint64_t v3 = qword_A1AE8;
  if (v2)
  {
    uint64_t v4 = v2;
    if (os_log_type_enabled((os_log_t)qword_A1AE8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 80);
      int v6 = *(unsigned __int8 *)(a1 + 40);
      int v14 = 138412546;
      uint64_t v15 = v5;
      __int16 v16 = 1024;
      int v17 = v6;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Mac SmartRouting Update Ownership on  %@ -> %d", (uint8_t *)&v14, 0x12u);
    }
    sub_497C8(v4, v4[1157], *(unsigned __int8 *)(a1 + 40), 1);
  }
  else if (os_log_type_enabled((os_log_t)qword_A1AE8, OS_LOG_TYPE_ERROR))
  {
    sub_6716C(v3, v7, v8, v9, v10, v11, v12, v13);
  }
}

os_log_t sub_303D8()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AE8 = (uint64_t)result;
  return result;
}

uint64_t sub_30408(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = off_8E320;
  *(void *)(a1 + 16) = a1 + 24;
  *(void *)(a1 + 32) = 0;
  sub_5CC80(a1 + 40, a2);
  atomic_store(1u, (unsigned int *)(a1 + 8));
  return a1;
}

void sub_30478(_Unwind_Exception *a1)
{
  sub_18C7C(v1, *v2);
  _Unwind_Resume(a1);
}

uint64_t sub_30494(uint64_t a1)
{
  *(void *)a1 = off_8E320;
  uint64_t v2 = a1 + 40;
  v5[0] = 0;
  v5[1] = 0;
  sub_5CDCC((uint64_t)v5, a1 + 40);
  sub_18C7C(a1 + 16, *(void **)(a1 + 24));
  *(void *)(a1 + 16) = a1 + 24;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 24) = 0;
  sub_5CF10(v5);
  sub_5CD00(v2, v3);
  sub_18C7C(a1 + 16, *(void **)(a1 + 24));
  return a1;
}

void sub_3053C(uint64_t a1)
{
  sub_30494(a1);

  operator delete();
}

uint64_t sub_30574(uint64_t a1, uint64_t a2)
{
  v7[0] = 0;
  v7[1] = 0;
  sub_5CDCC((uint64_t)v7, a1 + 40);
  uint64_t add = atomic_fetch_add((atomic_uint *volatile)(a1 + 8), 1u);
  LODWORD(v6) = add;
  *((void *)&v6 + 1) = a2;
  sub_308E8((uint64_t **)(a1 + 16), (unsigned int *)&v6, &v6);
  sub_5CF10(v7);
  return add;
}

void sub_305E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_305FC(uint64_t a1, unsigned int a2)
{
  v13[0] = 0;
  v13[1] = 0;
  sub_5CDCC((uint64_t)v13, a1 + 40);
  uint64_t v6 = *(void *)(a1 + 24);
  uint64_t v5 = a1 + 24;
  uint64_t v4 = v6;
  if (!v6) {
    goto LABEL_12;
  }
  uint64_t v7 = v5;
  do
  {
    unsigned int v8 = *(_DWORD *)(v4 + 32);
    BOOL v9 = v8 >= a2;
    if (v8 >= a2) {
      uint64_t v10 = (uint64_t *)v4;
    }
    else {
      uint64_t v10 = (uint64_t *)(v4 + 8);
    }
    if (v9) {
      uint64_t v7 = v4;
    }
    uint64_t v4 = *v10;
  }
  while (*v10);
  if (v7 != v5 && *(_DWORD *)(v7 + 32) <= a2) {
    uint64_t v11 = *(void *)(v7 + 40);
  }
  else {
LABEL_12:
  }
    uint64_t v11 = 0;
  sub_5CF10(v13);
  return v11;
}

uint64_t sub_3068C(uint64_t a1, unsigned int a2)
{
  unsigned int v5 = a2;
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, a1 + 40);
  sub_309A4(a1 + 16, &v5);
  return sub_5CF10(v4);
}

void sub_306DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_306F0(uint64_t a1)
{
  *(void *)a1 = &off_8E358;
  if (qword_A1AF8 != -1) {
    dispatch_once(&qword_A1AF8, &stru_8E398);
  }
  *(_DWORD *)(a1 + 8) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 16))(qword_A2348, a1);
  return a1;
}

void sub_3078C(id a1)
{
}

void sub_307D0()
{
}

uint64_t sub_307F8(uint64_t a1)
{
  *(void *)a1 = &off_8E358;
  (*(void (**)(uint64_t, void))(*(void *)qword_A2348 + 32))(qword_A2348, *(unsigned int *)(a1 + 8));
  return a1;
}

void sub_30870(uint64_t a1)
{
  sub_307F8(a1);

  operator delete();
}

uint64_t sub_308A8(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_308B0()
{
  return 0;
}

uint64_t sub_308B8()
{
  return 2003329396;
}

uint64_t sub_308C4()
{
  return 2003329396;
}

uint64_t sub_308D0()
{
  return 2003329396;
}

uint64_t sub_308DC()
{
  return 2003329396;
}

uint64_t **sub_308E8(uint64_t **a1, unsigned int *a2, _OWORD *a3)
{
  uint64_t v6 = a1 + 1;
  unsigned int v5 = a1[1];
  if (v5)
  {
    unsigned int v7 = *a2;
    while (1)
    {
      while (1)
      {
        unsigned int v8 = (uint64_t **)v5;
        unsigned int v9 = *((_DWORD *)v5 + 8);
        if (v7 >= v9) {
          break;
        }
        unsigned int v5 = *v8;
        uint64_t v6 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (v9 >= v7) {
        break;
      }
      unsigned int v5 = v8[1];
      if (!v5)
      {
        uint64_t v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    unsigned int v8 = a1 + 1;
LABEL_10:
    uint64_t v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *a3;
    sub_18A8C(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t sub_309A4(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 8;
  do
  {
    unsigned int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      unsigned int v7 = (uint64_t *)v2;
    }
    else {
      unsigned int v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 8 || v3 < *(_DWORD *)(v4 + 32)) {
    return 0;
  }
  sub_2D7E0((uint64_t **)a1, (uint64_t *)v4);
  operator delete((void *)v4);
  return 1;
}

os_log_t sub_30A20()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1AF0 = (uint64_t)result;
  return result;
}

uint64_t sub_30A50(uint64_t a1, int a2, uint64_t a3)
{
  long long v5 = *(_OWORD *)(a3 + 16);
  v10[0] = *(_OWORD *)a3;
  v10[1] = v5;
  uint64_t v11 = *(void *)(a3 + 32);
  sub_12C34(a1, a2, v10);
  *(void *)uint64_t v6 = off_8E3E8;
  *(_OWORD *)(v6 + 184) = 0u;
  *(_OWORD *)(v6 + 200) = 0u;
  *(_OWORD *)(v6 + 216) = 0u;
  *(_OWORD *)(v6 + 232) = 0u;
  switch(a2)
  {
    case 9:
      int v7 = 1;
      goto LABEL_8;
    case 10:
      int v7 = 2;
      goto LABEL_8;
    case 11:
      int v7 = 3;
      goto LABEL_8;
    case 12:
    case 18:
      int v7 = 4;
      goto LABEL_8;
    case 13:
      *(_DWORD *)(a1 + 256) = 0;
      break;
    case 14:
      int v7 = 6;
LABEL_8:
      *(_DWORD *)(a1 + 256) = v7;
      break;
    default:
      unsigned int v9 = qword_A1B00;
      if (os_log_type_enabled((os_log_t)qword_A1B00, OS_LOG_TYPE_ERROR)) {
        sub_671A4(a2, v9);
      }
      break;
  }
  *(unsigned char *)(a1 + 176) = 0;
  return a1;
}

void *sub_30B84(uint64_t a1)
{
  *(void *)a1 = off_8E3E8;
  if (*(_DWORD *)(a1 + 92))
  {
    unint64_t v2 = 0;
    do
    {
      uint64_t v3 = a1 + 8 * v2;
      encoder_destroy(*(int **)(v3 + 184));
      free(*(void **)(v3 + 216));
      free(*(void **)(v3 + 232));
      ++v2;
    }
    while (v2 < *(unsigned int *)(a1 + 92));
  }

  return sub_12C84((void *)a1);
}

void sub_30C1C(uint64_t a1)
{
  sub_30B84(a1);

  operator delete();
}

void sub_30C54(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 156) = a2;
  if (*(_DWORD *)(a1 + 92))
  {
    unint64_t v3 = 0;
    do
    {
      uint64_t v4 = encoder_create(*(_DWORD *)(a1 + 256));
      uint64_t v5 = a1 + 8 * v3;
      *(void *)(v5 + 184) = v4;
      *(void *)(v5 + 200) = v4;
      ++v3;
      unint64_t v6 = *(unsigned int *)(a1 + 92);
    }
    while (v3 < v6);
    BOOL v7 = v6 == 0;
  }
  else
  {
    BOOL v7 = 1;
  }
  unint64_t v9 = *(int *)(*(void *)(a1 + 200) + 4);
  unint64_t v8 = *(int *)(*(void *)(a1 + 200) + 8);
  *(void *)(a1 + 264) = v8;
  *(void *)(a1 + 272) = v9;
  *(void *)(a1 + 280) = 2 * v8;
  *(void *)(a1 + 288) = 2 * v9;
  if (!v7)
  {
    unint64_t v10 = 0;
    do
    {
      uint64_t v11 = a1 + 8 * v10;
      *(void *)(v11 + 216) = malloc_type_calloc(*(void *)(a1 + 264), 2uLL, 0x1000040BDFB0063uLL);
      *(void *)(v11 + 232) = malloc_type_calloc(*(void *)(a1 + 264), 4uLL, 0x100004052888210uLL);
      ++v10;
    }
    while (v10 < *(unsigned int *)(a1 + 92));
    unint64_t v8 = *(void *)(a1 + 264);
    unint64_t v9 = *(void *)(a1 + 272);
  }
  *(void *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 152) = (float)(ceilf((float)(20480 * *(_DWORD *)(a1 + 88)) / (float)v8)
                                              * (float)v9);
  operator new[]();
}

void sub_30DB0(uint64_t a1, __int16 *a2, int a3, _DWORD *a4)
{
  LODWORD(v5) = a3;
  unint64_t v8 = *(_OWORD **)(a1 + 144);
  if (*(_DWORD *)(a1 + 92) >= 3u)
  {
    unint64_t v9 = qword_A1B00;
    if (os_log_type_enabled((os_log_t)qword_A1B00, OS_LOG_TYPE_FAULT)) {
      sub_6721C(v9);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  unint64_t v10 = 0;
  if (v5)
  {
    uint64_t v5 = v5;
    uint64_t v11 = *(void *)(a1 + 248);
    unint64_t v12 = *(void *)(a1 + 264);
    while (v11 + v5 >= v12)
    {
      uint64_t v13 = *(unsigned int *)(a1 + 92);
      if (v12 != v11)
      {
        uint64_t v14 = 0;
        do
        {
          if (v13)
          {
            uint64_t v15 = v13;
            __int16 v16 = (uint64_t *)(a1 + 232);
            do
            {
              int v17 = *a2++;
              float v18 = *(float *)(a1 + 296) * (float)v17;
              uint64_t v19 = *v16++;
              *(float *)(v19 + 4 * (v14 + v11)) = v18;
              --v15;
            }
            while (v15);
          }
          ++v14;
        }
        while (v14 != v12 - v11);
      }
      if (v13)
      {
        unint64_t v20 = 0;
        do
        {
          encode(*(void *)(a1 + 8 * v20 + 184), *(const float **)(a1 + 8 * v20 + 232), v8);
          unint64_t v8 = (_OWORD *)((char *)v8 + 2 * *(void *)(a1 + 272));
          ++v20;
        }
        while (v20 < *(unsigned int *)(a1 + 92));
        unint64_t v12 = *(void *)(a1 + 264);
        uint64_t v11 = *(void *)(a1 + 248);
        v10 += v20;
      }
      *(void *)(a1 + 248) = 0;
      uint64_t v5 = v5 - v12 + v11;
      uint64_t v11 = 0;
      if (!v5) {
        goto LABEL_26;
      }
    }
    uint64_t v21 = 0;
    uint64_t v22 = *(unsigned int *)(a1 + 92);
    do
    {
      if (v22)
      {
        uint64_t v23 = v22;
        BOOL v24 = (uint64_t *)(a1 + 232);
        do
        {
          int v25 = *a2++;
          float v26 = *(float *)(a1 + 296) * (float)v25;
          uint64_t v27 = *v24++;
          *(float *)(v27 + 4 * (v21 + v11)) = v26;
          --v23;
        }
        while (v23);
      }
      ++v21;
    }
    while (v21 != v5);
    *(void *)(a1 + 248) = v11 + v5;
  }
LABEL_26:
  if (*(unsigned char *)(a1 + 177)) {
    sub_1330C(a1, *(_DWORD *)(a1 + 288) * v10, 0);
  }
  if (*(unsigned char *)(a1 + 178))
  {
    if (!v10)
    {
      *a4 = 0;
      return;
    }
    int v28 = 0;
    int v29 = byte_A1B08;
    LODWORD(v30) = *(_DWORD *)(a1 + 92);
    do
    {
      if (v30)
      {
        unint64_t v31 = 0;
        do
        {
          memset((void *)(*(void *)(a1 + 144) + *(void *)(a1 + 288) * (v28 + v31++)), v29, *(void *)(a1 + 288));
          unint64_t v30 = *(unsigned int *)(a1 + 92);
        }
        while (v31 < v30);
      }
      else
      {
        LODWORD(v31) = 0;
      }
      ++v29;
      v28 += v31;
    }
    while (v10 > v28);
    byte_A1B08 = v29;
  }
  *a4 = v10;
  if (v10)
  {
    uint64_t v32 = 0;
    uint64_t v33 = *(void *)(a1 + 288);
    uint64_t v34 = v10;
    __int16 v35 = a4 + 4;
    do
    {
      *__int16 v35 = *(void *)(a1 + 144) + v32;
      *((_DWORD *)v35 - 2) = 1;
      *((_DWORD *)v35 - 1) = v33;
      v32 += v33;
      v35 += 2;
      --v34;
    }
    while (v34);
  }
}

uint64_t sub_31018(uint64_t result)
{
  *(void *)(result + 248) = 0;
  return result;
}

uint64_t sub_31020()
{
  return 1;
}

os_log_t sub_31028()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1B00 = (uint64_t)result;
  return result;
}

void sub_31058(uint64_t a1, int a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  v5[0] = *(_OWORD *)a3;
  v5[1] = v3;
  uint64_t v6 = *(void *)(a3 + 32);
  sub_12C34(a1, a2, v5);
  *(void *)uint64_t v4 = &off_8E440;
  *(unsigned char *)(v4 + 176) = 1;
}

void sub_310B0(uint64_t a1, int a2, int a3)
{
  UInt32 ioPropertyDataSize = 0;
  int v18 = a2;
  *(void *)(a1 + 104) = *(void *)(a1 + 64);
  *(_DWORD *)(a1 + 184) = a2;
  *(_OWORD *)(a1 + 128) = xmmword_71620;
  *(_OWORD *)(a1 + 112) = xmmword_71630;
  OSStatus v5 = AudioConverterNew((const AudioStreamBasicDescription *)(a1 + 64), (const AudioStreamBasicDescription *)(a1 + 104), (AudioConverterRef *)(a1 + 56));
  sub_1B8C0(v5, (uint64_t)"Could not create new audio converter");
  int v15 = 8;
  int inPropertyData = 3;
  int v14 = 0;
  if (*(_DWORD *)(a1 + 132) == 2)
  {
    OSStatus v6 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 56), 0x73746D64u, 4u, &inPropertyData);
    sub_1B8C0(v6, (uint64_t)"Failed to set SBC stereo mode");
  }
  OSStatus v7 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 56), 0x6E737562u, 4u, &v15);
  sub_1B8C0(v7, (uint64_t)"Failed to set SBC subband number");
  OSStatus v8 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 56), 0x616C6C63u, 4u, &v14);
  sub_1B8C0(v8, (uint64_t)"Failed to set SBC allocation method");
  OSStatus v9 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 56), 0x62697470u, 4u, &v18);
  sub_1B8C0(v9, (uint64_t)"Failed to set SBC bitpool");
  UInt32 ioPropertyDataSize = 40;
  OSStatus Property = AudioConverterGetProperty(*(AudioConverterRef *)(a1 + 56), 0x61636F64u, &ioPropertyDataSize, (void *)(a1 + 104));
  sub_1B8C0(Property, (uint64_t)"Failed to create SBC output data format");
  int outPropertyData = *(_DWORD *)(a1 + 120);
  UInt32 ioPropertyDataSize = 4;
  OSStatus v11 = AudioConverterGetProperty(*(AudioConverterRef *)(a1 + 56), 0x786F7073u, &ioPropertyDataSize, &outPropertyData);
  sub_1B8C0(v11, (uint64_t)"Could not get kAudioConverterPropertyMaximumOutputPacketSize");
  if (*(unsigned char *)(a1 + 48))
  {
    unint64_t v12 = qword_A1B10;
    if (os_log_type_enabled((os_log_t)qword_A1B10, OS_LOG_TYPE_DEBUG)) {
      sub_672A0(&outPropertyData, v12);
    }
  }
  *(_DWORD *)(a1 + 160) = a3;
  *(_DWORD *)(a1 + 152) = outPropertyData * a3;
  operator new[]();
}

void sub_312F4(uint64_t a1, uint64_t a2, int a3, UInt32 *a4)
{
  *(void *)&outOutputData.mNumberBuffers = 0;
  UInt32 v6 = *(_DWORD *)(a1 + 132);
  outOutputData.mNumberBuffers = 1;
  UInt32 v7 = *(_DWORD *)(a1 + 152);
  outOutputData.mBuffers[0].mNumberChannels = v6;
  outOutputData.mBuffers[0].UInt32 mDataByteSize = v7;
  uint64_t v8 = *(void *)(a1 + 136);
  outOutputData.mBuffers[0].mData = *(void **)(a1 + 144);
  inInputDataProcUserData[0] = a2;
  inInputDataProcUserData[1] = (*(_DWORD *)(a1 + 80) * a3);
  long long v9 = *(_OWORD *)(a1 + 80);
  long long v25 = *(_OWORD *)(a1 + 64);
  long long v26 = v9;
  uint64_t v27 = *(void *)(a1 + 96);
  long long v10 = *(_OWORD *)(a1 + 120);
  long long v28 = *(_OWORD *)(a1 + 104);
  long long v29 = v10;
  OSStatus v11 = *(AudioStreamPacketDescription **)(a1 + 168);
  uint64_t v30 = v8;
  unint64_t v31 = v11;
  UInt32 ioOutputDataPacketSize = *(_DWORD *)(a1 + 160);
  OSStatus v12 = AudioConverterFillComplexBuffer(*(AudioConverterRef *)(a1 + 56), (AudioConverterComplexInputDataProc)sub_1B78C, inInputDataProcUserData, &ioOutputDataPacketSize, &outOutputData, v11);
  sub_1B8C0(v12, (uint64_t)"AudioConverterFillComplexBuffer Failed");
  uint64_t v13 = ioOutputDataPacketSize;
  if (ioOutputDataPacketSize && outOutputData.mBuffers[0].mDataByteSize)
  {
    uint64_t v14 = 0;
    *a4 = ioOutputDataPacketSize;
    uint64_t v15 = *(void *)(a1 + 168);
    do
    {
      __int16 v16 = &a4[v14];
      *((void *)v16 + 2) = *(void *)(a1 + 144) + *(void *)(v15 + v14 * 4);
      uint64_t v15 = *(void *)(a1 + 168);
      UInt32 v17 = *(_DWORD *)(v15 + v14 * 4 + 12);
      v16[2] = 1;
      v16[3] = v17;
      v14 += 4;
    }
    while (4 * v13 != v14);
    if (!v13) {
      return;
    }
  }
  else
  {
    *a4 = 0;
    if (!v13) {
      return;
    }
  }
  if (*(unsigned char *)(a1 + 177))
  {
    UInt32 v18 = 0;
    uint64_t v19 = (int *)(*(void *)(a1 + 168) + 12);
    uint64_t v20 = v13;
    do
    {
      int v21 = *v19;
      v19 += 4;
      v18 += v21;
      --v20;
    }
    while (v20);
    sub_1330C(a1, v18, v13);
  }
}

AudioComponent sub_31440()
{
  AudioComponent result = (AudioComponent)dlopen("/System/Library/Components/AudioCodecs.component/Contents/MacOS/AudioCodecs", 5);
  if (result)
  {
    uint64_t v1 = (AudioComponentPlugInInterface *(__cdecl *)(const AudioComponentDescription *))dlsym(result, "ACSBCEncoderFactory");
    *(_OWORD *)&v2.componentType = xmmword_71640;
    v2.componentFlagsMask = 0;
    return AudioComponentRegister(&v2, &stru_90900, 0, v1);
  }
  return result;
}

void sub_314AC(void *a1)
{
  sub_12C84(a1);

  operator delete();
}

uint64_t sub_314E4()
{
  return 1;
}

uint64_t sub_314EC()
{
  return 1;
}

os_log_t sub_314F4()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1B10 = (uint64_t)result;
  return result;
}

uint64_t sub_31524(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = a1 + 9156;
  uint64_t v8 = sub_3F94(a1, a3);
  *(void *)uint64_t v8 = off_8E498;
  *(_WORD *)(v7 + 8) = 0;
  *(_OWORD *)(v8 + 9236) = 0u;
  *(_OWORD *)(v8 + 9252) = 0u;
  *(void *)(v8 + 9080) = 0;
  *(void *)(v8 + 9096) = 0;
  *(void *)(v8 + 9088) = 0;
  sub_AD7C(v8, a2);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 1560))(a1, a4);
  *(_DWORD *)(a1 + 432) = 0;
  *(void *)(a1 + 388) = 0;
  sub_4258((unsigned char *)a1, a4);
  *(_WORD *)(v7 + 28) = 0;
  *(_DWORD *)(a1 + 9188) = 150;
  *(unsigned char *)uint64_t v7 = 0;
  *(_DWORD *)(a1 + 368) = 1952539500;
  sub_31B20(a1, a4);
  *(_DWORD *)(a1 + 9232) = 0;
  atomic_store(1u, (unsigned __int8 *)(a1 + 288));
  *(_DWORD *)(a1 + 292) = 1;
  *(void *)(a1 + 296) = *(void *)(a1 + 9112);
  *(_DWORD *)(a1 + 380) = 21856;
  *(_OWORD *)(a1 + 304) = xmmword_71670;
  *(_OWORD *)(a1 + 320) = xmmword_71680;
  *(_DWORD *)(a1 + 372) = 2732;
  if (*(_DWORD *)(a1 + 9160) == 33023) {
    int v9 = 1280;
  }
  else {
    int v9 = 2732;
  }
  *(_DWORD *)(a1 + 376) = v9;
  long long v10 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
    sub_67430(v9, v10);
  }
  *(_DWORD *)(a1 + 384) = 10000;
  *(unsigned char *)(a1 + 424) = 1;
  *(_DWORD *)(a1 + 436) = -1082130432;
  if (sub_98F0(a1) && (sub_395B4() & 1) == 0)
  {
    *(_DWORD *)(a1 + 444) = -1027080192;
    uint64_t v13 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 134217984;
      unint64_t v17 = 0xC059000000000000;
      _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "Adjusting volume floor to %f", buf, 0xCu);
      int v11 = *(_DWORD *)(a1 + 444);
    }
    else
    {
      int v11 = -1027080192;
    }
  }
  else
  {
    *(_DWORD *)(a1 + 444) = -1038090240;
    int v11 = -1038090240;
  }
  *(_DWORD *)(a1 + 448) = 0;
  *(_DWORD *)(a1 + 440) = v11;
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1)) {
    operator new();
  }
  *(_WORD *)(a1 + 460) = 1;
  *(void *)(a1 + 736) = 0;
  *(void *)(a1 + 728) = 4;
  (*(void (**)(uint64_t, void))(*(void *)a1 + 1032))(a1, 0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1024))(a1, 1);
  *(void *)(a1 + 40) = sub_1F670() + (10 * *(_DWORD *)(a1 + 372));
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 88) = sub_1F670() + 109280;
  int v12 = *(_DWORD *)(a1 + 9160);
  switch(v12)
  {
    case 33023:
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
        sub_673FC();
      }
      operator new();
    case 2:
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
        sub_673C8();
      }
      operator new();
    case 0:
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
        sub_67394();
      }
      operator new();
  }
  uint64_t v14 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_ERROR)) {
    sub_6731C(v12, v14);
  }
  return a1;
}

void sub_31AAC()
{
}

void sub_31B20(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyNexusUuid");
  if (value)
  {
    OSStatus v5 = value;
    xpc_object_t v6 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertySkywalkKey");
    [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_uuid_get_bytes(v6)];
    id v7 = [objc_alloc((Class)NSUUID) initWithUUIDBytes:xpc_uuid_get_bytes(v5)];
    uint64_t v8 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      int v154 = 67109378;
      LODWORD(v155[0]) = v9;
      WORD2(v155[0]) = 2112;
      *(void *)((char *)v155 + 6) = v7;
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "device [%d] Received skywalk nexus provider NSUUID: %@", (uint8_t *)&v154, 0x12u);
    }
    operator new();
  }
  xpc_object_t v10 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertySampleRate");
  if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_double)
  {
    int v11 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67A48(v11, v12, v13, v14, v15, v16, v17, v18);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(double *)(a1 + 9112) = xpc_double_get_value(v10);
  xpc_object_t v19 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyCategory");
  if (xpc_get_type(v19) != (xpc_type_t)&_xpc_type_int64)
  {
    uint64_t v20 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_679D0(v20, v21, v22, v23, v24, v25, v26, v27);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(_DWORD *)(a1 + 9104) = xpc_int64_get_value(v19);
  xpc_object_t v28 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyLatency");
  if (xpc_get_type(v28) != (xpc_type_t)&_xpc_type_int64)
  {
    long long v29 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67958(v29, v30, v31, v32, v33, v34, v35, v36);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  int v37 = xpc_int64_get_value(v28);
  *(_DWORD *)(a1 + 388) = v37;
  *(_DWORD *)(a1 + 396) = v37;
  *(_DWORD *)(a1 + 392) = v37;
  int v38 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    int v154 = 67109120;
    LODWORD(v155[0]) = v37;
    _os_log_impl(&dword_0, v38, OS_LOG_TYPE_DEFAULT, "A2DP Received initial latency %u from bluetoothd", (uint8_t *)&v154, 8u);
  }
  xpc_object_t v39 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyCodec");
  if (xpc_get_type(v39) != (xpc_type_t)&_xpc_type_int64)
  {
    BOOL v40 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_678E0(v40, v41, v42, v43, v44, v45, v46, v47);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(_DWORD *)(a1 + 9160) = xpc_int64_get_value(v39);
  xpc_object_t v48 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyBitpool");
  if (xpc_get_type(v48) != (xpc_type_t)&_xpc_type_int64)
  {
    __int16 v49 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67868(v49, v50, v51, v52, v53, v54, v55, v56);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(_DWORD *)(a1 + 9108) = xpc_int64_get_value(v48);
  xpc_object_t v57 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyFrameLen");
  if (xpc_get_type(v57) != (xpc_type_t)&_xpc_type_int64)
  {
    uint64_t v58 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_677F0(v58, v59, v60, v61, v62, v63, v64, v65);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(_DWORD *)(a1 + 9120) = xpc_int64_get_value(v57);
  xpc_object_t v66 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyFrameCount");
  if (xpc_get_type(v66) != (xpc_type_t)&_xpc_type_int64)
  {
    uint64_t v67 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67778(v67, v68, v69, v70, v71, v72, v73, v74);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(_DWORD *)(a1 + 9124) = xpc_int64_get_value(v66);
  xpc_object_t v75 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyRtpInterval");
  if (xpc_get_type(v75) != (xpc_type_t)&_xpc_type_int64)
  {
    uint64_t v76 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67688(v76, v77, v78, v79, v80, v81, v82, v83);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(_DWORD *)(a1 + 9148) = xpc_int64_get_value(v75);
  xpc_object_t v84 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyDynamicClock");
  if (xpc_get_type(v84) != (xpc_type_t)&_xpc_type_BOOL)
  {
    BOOL v85 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67700(v85, v86, v87, v88, v89, v90, v91, v92);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(unsigned char *)(a1 + 9164) = xpc_BOOL_get_value(v84);
  xpc_object_t v93 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertySamplingSpeed");
  if (v93) {
    *(unsigned char *)(a1 + 9184) = xpc_BOOL_get_value(v93);
  }
  xpc_object_t v94 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertySamplingSpeedParams");
  xpc_object_t v95 = xpc_dictionary_get_value(v94, "kBTAudioMsgPropertyLatencyChangeMsec");
  if (xpc_get_type(v75) != (xpc_type_t)&_xpc_type_int64)
  {
    xpc_object_t v96 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67688(v96, v97, v98, v99, v100, v101, v102, v103);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  int64_t v104 = xpc_int64_get_value(v95);
  xpc_object_t v105 = xpc_dictionary_get_value(v94, "kBTAudioMsgPropertySamplingIntervalMultiplier");
  if (xpc_get_type(v105) != (xpc_type_t)&_xpc_type_double)
  {
    uint64_t v106 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67610(v106, v107, v108, v109, v110, v111, v112, v113);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  float v114 = xpc_double_get_value(v105);
  (*(void (**)(uint64_t, int64_t, float))(*(void *)a1 + 688))(a1, v104, v114);
  xpc_object_t v115 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyDynamicLatencySupported");
  if (xpc_get_type(v115) != (xpc_type_t)&_xpc_type_BOOL)
  {
    uint64_t v116 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67598(v116, v117, v118, v119, v120, v121, v122, v123);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *(unsigned char *)(a1 + 9185) = xpc_BOOL_get_value(v115);
  xpc_object_t v124 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyLowLatencyGameSupport");
  uint64_t v125 = v124;
  if (v124)
  {
    if (xpc_get_type(v124) != (xpc_type_t)&_xpc_type_BOOL)
    {
      BOOL v126 = qword_A1B18;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
        sub_67520(v126, v127, v128, v129, v130, v131, v132, v133);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    uint64_t v134 = *(void *)(*(void *)(a1 + 416) + 9248);
    BOOL v135 = xpc_BOOL_get_value(v125);
    sub_2A800(v134, v135);
  }
  xpc_object_t v136 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyDynamicLatencyDelayMicroSec");
  uint64_t v137 = v136;
  if (v136)
  {
    if (xpc_get_type(v136) != (xpc_type_t)&_xpc_type_int64)
    {
      uint64_t v138 = qword_A1B18;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
        sub_674A8(v138, v139, v140, v141, v142, v143, v144, v145);
      }
      if (sub_5CB00()) {
        abort();
      }
    }
    BOOL v146 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      int v147 = xpc_int64_get_value(v137);
      int v154 = 67109120;
      LODWORD(v155[0]) = v147 / 1000;
      _os_log_impl(&dword_0, v146, OS_LOG_TYPE_DEFAULT, "Device In ear delay %uMsec", (uint8_t *)&v154, 8u);
    }
    unsigned int v148 = xpc_int64_get_value(v137);
    (*(void (**)(uint64_t, unint64_t))(*(void *)a1 + 656))(a1, v148 / 0x3E8uLL);
  }
  if (!*(_DWORD *)(a1 + 9104)
    && (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1296))(a1) & 1) != 0 || sub_395B4()))
  {
    BOOL v149 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v154) = 0;
      _os_log_impl(&dword_0, v149, OS_LOG_TYPE_DEFAULT, "Device category was unknown, defaulting to headphone", (uint8_t *)&v154, 2u);
    }
    *(_DWORD *)(a1 + 9104) = 1;
  }
  xpc_object_t v150 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyVolumeScalar");
  if (v150 && *(unsigned char *)(a1 + 408))
  {
    float v151 = xpc_double_get_value(v150);
    uint64_t v152 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      int v154 = 134217984;
      v155[0] = v151;
      _os_log_impl(&dword_0, v152, OS_LOG_TYPE_DEFAULT, "A2DP Received initial absolute volume of %f from bluetoothd", (uint8_t *)&v154, 0xCu);
    }
    *(float *)(a1 + 432) = v151;
    *(float *)(a1 + 440) = (*(float (**)(uint64_t, float))(*(void *)a1 + 368))(a1, v151);
  }
  uint64_t v153 = *(void *)(a1 + 416);
  if (v153 && *(unsigned char *)(*(void *)(v153 + 9248) + 328) && sub_7C98(a1) == 1952539500) {
    sub_85F8(a1, *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 328));
  }
}

void sub_324C0()
{
}

uint64_t sub_324F0(void *a1)
{
  *a1 = off_8E498;
  uint64_t v2 = *(void *)(a1[52] + 9248);
  if (*(unsigned char *)(v2 + 277))
  {
    uint64_t v3 = qword_A2350;
    if (*(char *)(v2 + 31) < 0)
    {
      sub_B9AC(__p, *(void **)(v2 + 8), *(void *)(v2 + 16));
    }
    else
    {
      long long v4 = *(_OWORD *)(v2 + 8);
      uint64_t v9 = *(void *)(v2 + 24);
      *(_OWORD *)std::string __p = v4;
    }
    sub_41D30(v3, (uint64_t)__p);
    if (SHIBYTE(v9) < 0) {
      operator delete(__p[0]);
    }
  }
  (*(void (**)(void *))(*a1 + 1408))(a1);
  sub_83B0((uint64_t)a1);
  if ((*(uint64_t (**)(void *))(*a1 + 1640))(a1)
    && (*(unsigned int (**)(void *))(*a1 + 1040))(a1))
  {
    OSStatus v5 = (void *)(*(uint64_t (**)(void *))(*a1 + 1640))(a1);
    free(v5);
    (*(void (**)(void *, void))(*a1 + 1656))(a1, 0);
  }
  (*(void (**)(void *))(*a1 + 72))(a1);
  return sub_415C((uint64_t)a1, v6);
}

void sub_326D4(void *a1)
{
  sub_324F0(a1);

  operator delete();
}

void sub_3270C(uint64_t a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, "kBTAudioMsgPropertyDeviceUID");
  if (!string)
  {
    long long v4 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_63158(v4, v5, v6, v7, v8, v9, v10, v11);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  CFStringRef v12 = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
  *(void *)(a1 + 200) = v12;
  uint64_t v13 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v15 = 138412546;
    CFStringRef v16 = v12;
    __int16 v17 = 1024;
    int v18 = v14;
    _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "A2DP Device XPC connection for UID %@ connected to[ %d ] ", (uint8_t *)&v15, 0x12u);
    CFStringRef v12 = *(CFStringRef *)(a1 + 200);
  }
  **(void **)(a1 + 208) = v12;
}

uint64_t sub_32860(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a3 != 1)
  {
    uint64_t v8 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67AC0(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  (*(void (**)(_OWORD *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 800))(v18, a1, a4);
  long long v16 = v18[1];
  *(_OWORD *)a2 = v18[0];
  *(_OWORD *)(a2 + 16) = v16;
  *(void *)(a2 + 32) = v19;
  *(double *)(a2 + 40) = (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1);
  *(double *)(a2 + 48) = (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1);
  return a3;
}

uint64_t sub_329AC(uint64_t a1, double *a2, uint64_t a3)
{
  if (a3 != 1)
  {
    uint64_t v6 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_FAULT)) {
      sub_67AC0(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *a2 = (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1);
  a2[1] = (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1);
  return a3;
}

BOOL sub_32A8C(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (a4) {
    return 0;
  }
  if (*(double *)a2 == *(double *)a3) {
    return *(_DWORD *)(a2 + 28) != *(_DWORD *)(a3 + 28);
  }
  return 1;
}

BOOL sub_32AC4(uint64_t a1, char a2, double a3, double a4)
{
  return (a2 & 1) == 0 && (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1) == a4;
}

uint64_t sub_32B28(uint64_t a1, int a2, int a3)
{
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1048))(a1);
  if (a2 == 1768845428 && v6 == 0) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1040))(a1);
  if (a2 != 1869968496 || result)
  {
    if (a2 == 1735159650 || a2 == 1869968496 || a2 == 1768845428) {
      return a3 == 0;
    }
    return 0;
  }
  return result;
}

uint64_t sub_32C1C(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 275);
}

uint64_t sub_32C2C(_DWORD *a1)
{
  if (a1[99] != a1[97]) {
    (*(void (**)(_DWORD *))(*(void *)a1 + 272))(a1);
  }
  return 0;
}

uint64_t sub_32C80(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 416);
  if (*(unsigned char *)(*(void *)(v1 + 9248) + 230))
  {
    uint64_t v2 = result;
    uint64_t v3 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long v4 = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "A2DP notify kBluetoothAudioDevicePropertySpatialMode change", v4, 2u);
      uint64_t v1 = *(void *)(v2 + 416);
    }
    return sub_49F68(v1, 1936747876);
  }
  return result;
}

void sub_32D14(uint64_t a1, BOOL a2)
{
  uint64_t v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_14FA4(v2, a2);
  }
}

void sub_32D24(uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_1509C(v2, *(_DWORD *)(a1 + 9124));
  }
}

uint64_t sub_32D3C(void *a1, __int16 a2)
{
  if (_os_feature_enabled_impl() && sub_2A8C0(*(void *)(a1[52] + 9248)))
  {
    char v23 = 0;
    __int16 v22 = 0;
    uint64_t v4 = sub_459EC(qword_A2350);
    uint64_t v5 = *(void *)(a1[52] + 9248);
    __int16 v6 = *(_WORD *)(v5 + 608);
    __int16 v7 = v6 + 1;
    *(_WORD *)(v5 + 608) = v6 + 1;
    v21[0] = ((unsigned __int16)(v6 + 1) >> 8) & 7 | 0xB0;
    v21[1] = v6 + 1;
    void v21[2] = (v4 >> 15) & 7 | 0xE8;
    v21[3] = v4 >> 7;
    v21[4] = v4 & 0x7F;
    if (*((unsigned char *)a1 + 745))
    {
      uint64_t v8 = qword_A1B18;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = 134218496;
        uint64_t v16 = v4;
        __int16 v17 = 1024;
        int v18 = v4 & 0x3FFFF;
        __int16 v19 = 1024;
        int v20 = v7 & 0x7FF;
        _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Current Host Time: %llu; Current Host Time: (converted to 18 bits) %d; A2DP Frame number: %d",
          (uint8_t *)&v15,
          0x18u);
      }
    }
    v21[5] = HIBYTE(a2) & 7 | 0x10;
    v21[6] = a2;
    uint64_t v9 = a1[3];
    uint64_t v10 = 10;
    uint64_t v11 = (int *)v21;
    size_t v12 = 10;
  }
  else
  {
    (*(void (**)(void *))(*a1 + 1624))(a1);
    __int16 v13 = (*(uint64_t (**)(void *))(*a1 + 1608))(a1);
    LOBYTE(v15) = HIBYTE(v13) & 0xF | 0xB0;
    BYTE1(v15) = v13;
    BYTE2(v15) = HIBYTE(a2) & 7 | 0x10;
    HIBYTE(v15) = a2;
    uint64_t v9 = a1[3];
    uint64_t v10 = 4;
    uint64_t v11 = &v15;
    size_t v12 = 4;
  }
  sub_175B4(v9, v11, v12);
  return v10;
}

uint64_t sub_32F54(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v3 = *(unsigned char **)(*(void *)(a1 + 416) + 9096);
    if (v3)
    {
      if (v3[192] && (*(unsigned int (**)(unsigned char *))(*(void *)v3 + 1168))(v3))
      {
        uint64_t v4 = qword_A1B18;
        if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)uint64_t v8 = 0;
          _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "A2DP TriggerAudioStream Start while eSCO ongoing: Disconnect eSCO immediately", v8, 2u);
        }
        if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9096) + 192)) {
          uint64_t v5 = *(void *)(*(void *)(a1 + 416) + 9096);
        }
        else {
          uint64_t v5 = 0;
        }
        (*(void (**)(uint64_t))(*(void *)v5 + 1496))(v5);
        if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9096) + 192)) {
          uint64_t v6 = *(void *)(*(void *)(a1 + 416) + 9096);
        }
        else {
          uint64_t v6 = 0;
        }
        (*(void (**)(void))(*(void *)v6 + 256))();
      }
    }
  }
  return 0;
}

uint64_t sub_330A8(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 248))();
}

uint64_t sub_330D0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 240))();
}

void *sub_330F8@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(result[52] + 9248);
  if (*(char *)(v2 + 31) < 0) {
    return sub_B9AC((unsigned char *)a2, *(void **)(v2 + 8), *(void *)(v2 + 16));
  }
  long long v3 = *(_OWORD *)(v2 + 8);
  *(void *)(a2 + 16) = *(void *)(v2 + 24);
  *(_OWORD *)a2 = v3;
  return result;
}

uint64_t sub_33128(uint64_t a1, int a2, float a3)
{
  *(float *)(a1 + 432) = a3;
  *(float *)(a1 + 436) = a3;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 275)) {
    float v6 = sub_18574(a3);
  }
  else {
    float v6 = *(float *)(a1 + 448) - (float)((float)(a3 + -1.0) * *(float *)(a1 + 444));
  }
  *(float *)(a1 + 440) = v6;
  __int16 v7 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    float v8 = *(float *)(a1 + 432);
    double v9 = a3;
    double v10 = v6;
    if (a2) {
      uint64_t v11 = "Yes";
    }
    else {
      uint64_t v11 = "No";
    }
    v15[0] = 134219266;
    *(double *)&v15[1] = v9;
    __int16 v16 = 2048;
    double v17 = v8;
    __int16 v18 = 1024;
    int v19 = (int)(float)(v8 * 127.0);
    __int16 v20 = 2048;
    double v21 = v10;
    __int16 v22 = 2082;
    char v23 = v11;
    __int16 v24 = 2114;
    uint64_t v25 = sub_7904(a1);
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Remote device set volume %f, mScalarVolume %f steps = [ %d ] , mDBVolume %f Notify Up : %{public}s Device %{public}@", (uint8_t *)v15, 0x3Au);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1280))(a1);
  if (result)
  {
    if (!*(unsigned char *)(a1 + 408))
    {
      uint64_t v13 = *(void *)(a1 + 400);
      if (v13)
      {
        unsigned __int8 v14 = atomic_load((unsigned __int8 *)(v13 + 24));
        if (v14) {
          sub_181A4(*(void *)(a1 + 400), *(float *)(a1 + 440));
        }
      }
    }
    if ((a2 & 1) != 0 || (uint64_t result = sub_395B4(), result))
    {
      strcpy((char *)v15, "dlovptuo");
      BYTE1(v15[2]) = 0;
      HIWORD(v15[2]) = 0;
      return (*(uint64_t (**)(uint64_t, _DWORD *))(*(void *)a1 + 248))(a1, v15);
    }
  }
  return result;
}

float sub_33350(uint64_t a1, float a2)
{
  float v2 = *(float *)(a1 + 444);
  if (v2 > a2) {
    a2 = *(float *)(a1 + 444);
  }
  float v3 = *(float *)(a1 + 448);
  if (a2 > v3) {
    a2 = *(float *)(a1 + 448);
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 275)) {
    return sub_1866C(a2);
  }
  else {
    return (float)((float)(v3 - a2) / v2) + 1.0;
  }
}

float sub_33390(uint64_t a1, float a2)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 275)) {
    return sub_18574(a2);
  }
  else {
    return *(float *)(a1 + 448) - (float)((float)(a2 + -1.0) * *(float *)(a1 + 444));
  }
}

void sub_333BC(uint64_t a1, float a2)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 275)) {
    float v3 = sub_18574(a2);
  }
  else {
    float v3 = *(float *)(a1 + 448) - (float)((float)(a2 + -1.0) * *(float *)(a1 + 444));
  }
  *(float *)(a1 + 440) = v3;
}

uint64_t sub_3340C(void *a1)
{
  int v2 = *(unsigned __int8 *)(*(void *)(a1[52] + 9248) + 327);
  uint64_t result = (*(uint64_t (**)(void *))(*a1 + 1280))(a1);
  if (v2) {
    BOOL v4 = result == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    long long v8 = xmmword_71690;
    uint64_t v9 = 1735159650;
    uint64_t v5 = *(uint64_t (***)(void, uint64_t, uint64_t, long long *))(qword_A2350 + 144);
    float v6 = *v5;
    uint64_t v7 = (*(uint64_t (**)(void))(*(void *)a1[52] + 16))(a1[52]);
    return v6(v5, v7, 2, &v8);
  }
  return result;
}

void sub_33514(uint64_t a1, float a2)
{
  BOOL v4 = qword_A1B18;
  float v5 = fabsf(a2);
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    float v6 = *(float *)(a1 + 432);
    double v7 = 1.0;
    if (v5 >= 0.00000011921) {
      double v7 = (float)(v6 / a2);
    }
    int v9 = 134218496;
    double v10 = v7;
    __int16 v11 = 2048;
    double v12 = a2;
    __int16 v13 = 2048;
    double v14 = v6;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Wireless Splitter Main Volume Scale Factor = %f [MV=%f Vol=%f]", (uint8_t *)&v9, 0x20u);
  }
  float v8 = 1.0;
  if (v5 >= 0.00000011921) {
    float v8 = *(float *)(a1 + 432) / a2;
  }
  *(float *)(a1 + 9064) = v8;
}

uint64_t sub_33618(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 277);
}

void sub_33628(uint64_t a1, void *a2)
{
  int v2 = *(id **)(a1 + 208);
  if (v2)
  {
    CFStringRef v4 = (const __CFString *)[a2 objectForKeyedSubscript:@"CurrentAudioCategory"];
    id v5 = [a2 objectForKeyedSubscript:@"CurrentVolume"];
    id v6 = [a2 objectForKeyedSubscript:@"ManualVolumeUpdate"];
    id v7 = [a2 objectForKeyedSubscript:@"RampInProgress"];
    sub_15558(v2, v4, v5, v6, v7);
  }
}

void sub_336E4(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1))
  {
    if (*(unsigned char *)(a1 + 408))
    {
      int v2 = *(id **)(a1 + 208);
      if (v2)
      {
        float v3 = qword_A1B18;
        if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
        {
          double v4 = *(float *)(a1 + 432);
          int v5 = 134217984;
          double v6 = v4;
          _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "A2DPAudioDevice: volume update back to headphone %f", (uint8_t *)&v5, 0xCu);
          int v2 = *(id **)(a1 + 208);
        }
        sub_146B4(v2, *(float *)(a1 + 432));
      }
    }
  }
}

void sub_337E4(uint64_t a1, float a2)
{
  double v4 = *(unsigned char **)(*(void *)(a1 + 416) + 9248);
  if (v4[274])
  {
    if (v4[275])
    {
      int v5 = v4[276];
      float v6 = sub_1866C(a2);
      if (v5 && (sub_33A54(*(float *)(a1 + 432), v6) & 1) != 0) {
        return;
      }
      goto LABEL_8;
    }
LABEL_9:
    float v6 = (float)((float)(*(float *)(a1 + 448) - a2) / *(float *)(a1 + 444)) + 1.0;
    *(float *)(a1 + 432) = v6;
    goto LABEL_10;
  }
  if (!v4[275]) {
    goto LABEL_9;
  }
  float v6 = sub_1866C(a2);
LABEL_8:
  *(float *)(a1 + 432) = v6;
  *(float *)(a1 + 436) = v6;
LABEL_10:
  *(float *)(a1 + 440) = a2;
  id v7 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    double v8 = *(float *)(a1 + 436);
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1280))(a1);
    int v10 = *(unsigned __int8 *)(a1 + 408);
    double v11 = *(float *)(a1 + 452);
    double v12 = *(float *)(a1 + 456);
    int v16 = 134219778;
    double v17 = a2;
    __int16 v18 = 2048;
    double v19 = v6;
    __int16 v20 = 2048;
    double v21 = v8;
    __int16 v22 = 1024;
    int v23 = v9;
    __int16 v24 = 1024;
    int v25 = v10;
    __int16 v26 = 2048;
    double v27 = v11;
    __int16 v28 = 2048;
    double v29 = v12;
    __int16 v30 = 2114;
    uint64_t v31 = sub_7904(a1);
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Audio layer set volume %f, mScalarVolume %f, mScalarRemoteVolume %f, IsVolumeSupported %d, mIsAbsoluteVolume %d L/R : %f/%f Device %{public}@", (uint8_t *)&v16, 0x4Au);
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1))
  {
    if (*(unsigned char *)(a1 + 408))
    {
      __int16 v13 = *(id **)(a1 + 208);
      if (v13) {
        sub_146B4(v13, *(float *)(a1 + 432));
      }
    }
    else
    {
      uint64_t v14 = *(void *)(a1 + 400);
      if (v14)
      {
        unsigned __int8 v15 = atomic_load((unsigned __int8 *)(v14 + 24));
        if (v15)
        {
          sub_181A4(*(void *)(a1 + 400), *(float *)(a1 + 440));
          *(unsigned char *)(a1 + 425) = 1;
        }
      }
    }
  }
}

uint64_t sub_33A54(float a1, float a2)
{
  if (a1 == 0.0) {
    return 0;
  }
  float v4 = vabds_f32(a2, a1);
  if (v4 >= 0.025) {
    return 0;
  }
  int v5 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG))
  {
    int v7 = 134218496;
    double v8 = a1;
    __int16 v9 = 2048;
    double v10 = a2;
    __int16 v11 = 2048;
    double v12 = v4;
    _os_log_debug_impl(&dword_0, v5, OS_LOG_TYPE_DEBUG, "software volume: Ignore low threashold volume delta: [%f - %f] => %f", (uint8_t *)&v7, 0x20u);
  }
  return 1;
}

void sub_33B54(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 425))
  {
    if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1))
    {
      if (*(unsigned char *)(a1 + 408))
      {
        int v2 = *(id **)(a1 + 208);
        if (v2)
        {
          float v3 = qword_A1B18;
          if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
          {
            double v4 = *(float *)(a1 + 440);
            double v5 = *(float *)(a1 + 432);
            int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1280))(a1);
            int v7 = *(unsigned __int8 *)(a1 + 408);
            int v8 = 134219010;
            double v9 = v4;
            __int16 v10 = 2048;
            double v11 = v5;
            __int16 v12 = 1024;
            int v13 = v6;
            __int16 v14 = 1024;
            int v15 = v7;
            __int16 v16 = 2114;
            uint64_t v17 = sub_7904(a1);
            _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Audio layer set volume Update %f, mScalarVolume %f, IsVolumeSupported %d, mIsAbsoluteVolume %d Device %{public}@", (uint8_t *)&v8, 0x2Cu);
            int v2 = *(id **)(a1 + 208);
          }
          sub_146B4(v2, *(float *)(a1 + 432));
        }
      }
    }
  }
}

uint64_t sub_33CD8(uint64_t a1, int a2, int a3)
{
  if (a2) {
    unsigned int v3 = 1024;
  }
  else {
    unsigned int v3 = a3 << 7;
  }
  if (a2 == 33023) {
    return 480;
  }
  else {
    return v3;
  }
}

void sub_33CFC(uint64_t a1, BOOL a2)
{
  int v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_14810(v2, a2);
  }
}

void sub_33D0C(uint64_t a1, BOOL a2)
{
  int v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_15B9C(v2, a2);
  }
}

void sub_33D1C(uint64_t a1, const __CFString *a2, int a3, int a4)
{
  if (a2)
  {
    double v4 = *(id **)(a1 + 208);
    if (v4)
    {
      sub_15958(v4, a2, a3, a4);
    }
  }
  else
  {
    double v5 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v6 = 0;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Spatial Audio: Feature updated with no active Now playing App: Dropping", v6, 2u);
    }
  }
}

void sub_33DA8(uint64_t a1, BOOL a2)
{
  int v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_15810(v2, a2);
  }
}

void sub_33DB8(uint64_t a1, const __CFString *a2, int a3, float a4)
{
  double v4 = *(id **)(a1 + 208);
  if (v4) {
    sub_152E4(v4, a2, a3, a4);
  }
}

void sub_33DC8(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 9185))
  {
    int v2 = *(id **)(a1 + 208);
    if (v2)
    {
      sub_14DB4(v2, 0);
      sub_14CBC(*(id **)(a1 + 208), 0);
      sub_151C0(*(id **)(a1 + 208), 0);
      sub_14FA4(*(id **)(a1 + 208), 0);
      sub_14810(*(id **)(a1 + 208), 0);
    }
    *(_DWORD *)(a1 + 9232) = 0;
  }
}

void sub_33E38(uint64_t a1, int value, int a3)
{
  double v5 = *(id **)(a1 + 208);
  if (v5)
  {
    char v6 = value;
    if (a3 == 3 || *(_DWORD *)(a1 + 9232) == 3)
    {
      sub_14DB4(v5, value);
      goto LABEL_5;
    }
    if (a3 != 8)
    {
      if (a3 == 7)
      {
        if (value)
        {
          unsigned int v7 = 2;
          goto LABEL_15;
        }
LABEL_14:
        unsigned int v7 = 0;
        goto LABEL_15;
      }
      if (a3 == 6)
      {
        if (value)
        {
          unsigned int v7 = 1;
LABEL_15:
          sub_151C0(v5, v7);
          goto LABEL_5;
        }
        goto LABEL_14;
      }
      sub_14CBC(v5, value);
      if (v6) {
        goto LABEL_5;
      }
      double v5 = *(id **)(a1 + 208);
      xpc_object_t value = 0;
    }
    sub_14908(v5, value);
  }
LABEL_5:
  *(_DWORD *)(a1 + 9232) = a3;
}

uint64_t sub_33EF0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 9232);
}

uint64_t sub_33EF8(uint64_t a1)
{
  if (sub_395B4()
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 1296))(a1)
    && !*(_DWORD *)(a1 + 428))
  {
    double v2 = 0.08;
  }
  else
  {
    double v2 = (double)(*(_DWORD *)(a1 + 384) + *(_DWORD *)(a1 + 392)) / 1000000.0;
  }
  uint64_t v3 = (*(double *)(a1 + 296) * v2);
  double v4 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 392);
    int v6 = *(_DWORD *)(a1 + 384);
    int v7 = *(_DWORD *)(a1 + 388);
    v9[0] = 67109888;
    v9[1] = v3;
    __int16 v10 = 1024;
    int v11 = v5;
    __int16 v12 = 1024;
    int v13 = v6;
    __int16 v14 = 1024;
    int v15 = v7;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "A2DP Returning latency of %d from %d, %d, %d\n", (uint8_t *)v9, 0x1Au);
  }
  return v3;
}

void sub_34040(uint64_t a1, unsigned int a2, float a3)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 872))(a1))
  {
    *(void *)(a1 + 9136) = 0;
    atomic_store(a2, (unsigned int *)(a1 + 548));
    if (*(float *)(a1 + 540) != a3) {
      *(float *)(a1 + 540) = a3;
    }
    atomic_store(a2 != 0, (unsigned __int8 *)(a1 + 545));
    int v6 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = "Not Running";
      if (a2) {
        int v7 = "Running";
      }
      v8[0] = 67109634;
      v8[1] = a2;
      __int16 v9 = 2082;
      __int16 v10 = v7;
      __int16 v11 = 2048;
      double v12 = a3;
      _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "audio delivery speed Latency Target %u, Currently running %{public}s, multiplier %f ", (uint8_t *)v8, 0x1Cu);
    }
  }
}

uint64_t sub_34180(uint64_t result, int a2)
{
  double v2 = (unsigned char *)(result + 9164);
  if (*(unsigned __int8 *)(result + 9164) != a2)
  {
    int v3 = a2;
    double v4 = (_DWORD *)result;
    *double v2 = a2;
    uint64_t v11 = 0x676C6F6263737462;
    int v12 = 0;
    uint64_t v9 = 0x676C6F62636C6F6BLL;
    int v10 = 0;
    int v5 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      if (v3) {
        int v6 = "enabled";
      }
      else {
        int v6 = "disabled";
      }
      int v7 = (*(uint64_t (**)(_DWORD *))(*(void *)v4 + 16))(v4);
      *(_DWORD *)std::string buf = 136446466;
      __int16 v14 = v6;
      __int16 v15 = 1024;
      int v16 = v7;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "mA2dpDynamicClock set to %{public}s for mAudioObjectID %d", buf, 0x12u);
      int v3 = *v2;
    }
    if (v3) {
      int v8 = 1918990199;
    }
    else {
      int v8 = 1768518246;
    }
    v4[2288] = v8;
    (*(void (**)(_DWORD *, uint64_t *))(*(void *)v4 + 248))(v4, &v9);
    return (*(uint64_t (**)(_DWORD *, uint64_t *))(*(void *)v4 + 248))(v4, &v11);
  }
  return result;
}

void sub_34328(uint64_t a1, BOOL a2)
{
  double v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_15CC0(v2, a2);
  }
}

float sub_34338(float a1, float a2, float a3)
{
  float v3 = a1 * 127.0;
  float v4 = a2 * 127.0;
  if ((float)(a1 * 127.0) != v4) {
    goto LABEL_5;
  }
  if (a1 != 1.0)
  {
    if (a1 == 0.0) {
      return -a3;
    }
LABEL_5:
    if (v3 == 0.0)
    {
      float v5 = v4 - v3;
      float v6 = 1.0;
    }
    else
    {
      float v5 = v4 - v3;
      if (v4 != 0.0) {
        return v5 * 0.0078125;
      }
      float v6 = -1.0;
    }
    float v5 = v5 + v6;
    return v5 * 0.0078125;
  }
  return a3;
}

void sub_343A4(uint64_t a1, float a2)
{
  float v4 = *(float *)(a1 + 436);
  if (v4 == -1.0)
  {
    *(float *)(a1 + 436) = a2;
    float v4 = a2;
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 217)) {
    float v5 = 0.0078125;
  }
  else {
    float v5 = 0.0625;
  }
  float v6 = sub_34338(v4, a2, v5);
  int v7 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 134218496;
    double v13 = v4;
    __int16 v14 = 2048;
    double v15 = a2;
    __int16 v16 = 2048;
    double v17 = v6;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "software volume: Volume Change: %f -> %f, Delta: %f", (uint8_t *)&v12, 0x20u);
  }
  *(float *)(a1 + 436) = a2;
  *(float *)(a1 + 432) = a2;
  if (*(unsigned char *)(a1 + 408))
  {
    int v8 = (const void *)sub_7904(a1);
    CFRetain(v8);
    uint64_t v9 = +[BTAudioAVNotificationMonitor sharedInstance];
    if (v9)
    {
      *(float *)&double v10 = v6;
      [(BTAudioAVNotificationMonitor *)v9 updateVolumeDelta:v8 uid:v10];
    }
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 275)) {
    float v11 = sub_18574(*(float *)(a1 + 432));
  }
  else {
    float v11 = *(float *)(a1 + 448) - (float)((float)(*(float *)(a1 + 432) + -1.0) * *(float *)(a1 + 444));
  }
  *(float *)(a1 + 440) = v11;
}

void sub_34534(uint64_t a1, BOOL a2)
{
  double v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_141BC(v2, a2);
  }
}

uint64_t sub_34544(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9108) = a2;
  return result;
}

uint64_t sub_3454C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9160) = a2;
  return result;
}

uint64_t sub_34554(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9124) = a2;
  return result;
}

uint64_t sub_3455C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9188) = a2;
  return result;
}

uint64_t sub_34564(_DWORD *a1, uint64_t a2)
{
  if ((a2 & 0xFE) == 2 && !a1[2308]) {
    ++a1[2316];
  }
  BOOL v4 = sub_8D20((uint64_t)a1);
  float v5 = a1 + 2310;
  if (v4) {
    float v5 = a1 + 2312;
  }
  ++*v5;
  float v6 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109120;
    v8[1] = a2;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Dynamic Latency : Latency Mode %d", (uint8_t *)v8, 8u);
  }
  return (*(uint64_t (**)(_DWORD *, uint64_t))(*(void *)a1 + 632))(a1, a2);
}

BOOL sub_34690(_DWORD *a1, int a2)
{
  BOOL result = 0;
  switch(a2)
  {
    case 0:
      BOOL result = sub_8D20((uint64_t)a1);
      if (result)
      {
        BOOL result = 0;
        ++a1[2312];
      }
      else
      {
        ++a1[2310];
      }
      return result;
    case 1:
      ++a1[2313];
      goto LABEL_7;
    case 2:
      ++a1[2314];
LABEL_7:
      if (sub_8D20((uint64_t)a1)) {
        ++a1[2311];
      }
      else {
        ++a1[2309];
      }
      goto LABEL_14;
    case 3:
      ++a1[2315];
      goto LABEL_11;
    case 4:
      ++a1[2316];
LABEL_11:
      if (sub_8D20((uint64_t)a1)) {
        ++a1[2312];
      }
      else {
        ++a1[2310];
      }
      goto LABEL_14;
    case 8:
LABEL_14:
      BOOL result = 1;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t sub_347C4(uint64_t result, char a2)
{
  *(unsigned char *)(result + 9185) = a2;
  return result;
}

void sub_347D0(uint64_t a1, int a2)
{
  if (*(_DWORD *)(a1 + 9160) == 33023)
  {
    float v3 = (unsigned __int8 *)(a1 + 9165);
    *(unsigned char *)(a1 + 9165) = 0;
    if (a2 == 3)
    {
      a2 = 1;
    }
    else if (a2 != 2)
    {
      a2 = 3;
      *(_DWORD *)(a1 + 9168) = 3;
      if ((*(_DWORD *)(a1 + 9124) - 1) < 2)
      {
        if (sub_8D20(a1))
        {
          *(void *)(a1 + 9176) = mach_absolute_time();
          *float v3 = 1;
          goto LABEL_10;
        }
        int v5 = *v3;
        *(_DWORD *)(a1 + 9124) = 3;
        *(_DWORD *)(a1 + 9168) = 3;
        if (v5)
        {
LABEL_10:
          BOOL v4 = qword_A1B18;
          if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
            sub_67B38(v3, a1, v4);
          }
          return;
        }
LABEL_9:
        (*(void (**)(uint64_t))(*(void *)a1 + 728))(a1);
        goto LABEL_10;
      }
    }
    *(_DWORD *)(a1 + 9124) = a2;
    *(_DWORD *)(a1 + 9168) = a2;
    goto LABEL_9;
  }
}

uint64_t sub_348DC(uint64_t result)
{
  uint64_t v1 = (unsigned char *)(result + 9165);
  if (*(unsigned char *)(result + 9165))
  {
    uint64_t v2 = result;
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    BOOL result = mach_absolute_time();
    if ((float)((float)((result - *(void *)(v2 + 9176)) * info.numer / info.denom / 0x3E8) / 1000.0) >= 100.0)
    {
      *(void *)(v2 + 9176) = 0;
      *uint64_t v1 = 0;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
        sub_67BEC();
      }
      *(_DWORD *)(v2 + 9124) = *(_DWORD *)(v2 + 9168);
      return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 728))(v2);
    }
  }
  return result;
}

uint64_t sub_349DC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9148) = a2;
  return result;
}

uint64_t sub_349E4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9120) = a2;
  return result;
}

uint64_t sub_349EC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 9120);
}

BOOL sub_349F4(_DWORD *a1, unsigned int a2, unint64_t a3)
{
  if (!a1[2290]) {
    return (a1[2281] * a1[2280]) < a3;
  }
  unsigned int v5 = a1[2282];
  if (v5 < a2)
  {
    float v6 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_ERROR))
    {
      v8[0] = 67109376;
      v8[1] = a2;
      __int16 v9 = 1024;
      unsigned int v10 = v5;
      _os_log_error_impl(&dword_0, v6, OS_LOG_TYPE_ERROR, "Higher than expected frameCount: Sending (%d > %d) A2DP frames in BT packet", (uint8_t *)v8, 0xEu);
      unsigned int v5 = a1[2282];
    }
  }
  return v5 <= a2;
}

uint64_t sub_34AE8(uint64_t a1, int *a2)
{
  int v2 = *a2;
  uint64_t v3 = 1;
  if (*a2 <= 1684234611)
  {
    if (v2 > 1668050794)
    {
      if (v2 == 1668050795 || v2 == 1668510818) {
        return v3;
      }
    }
    else if (v2 == 1633972065 || v2 == 1651798132)
    {
      return *(unsigned __int8 *)(a1 + 9185);
    }
  }
  else
  {
    if (v2 <= 1685484389)
    {
      if (v2 == 1684234612)
      {
        if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
          sub_67C68();
        }
        return 1;
      }
      int v4 = 1684826732;
    }
    else
    {
      if (v2 == 1685484390) {
        return v3;
      }
      if (v2 == 1818326127) {
        return sub_395B4();
      }
      int v4 = 1819241569;
    }
    if (v2 == v4) {
      return *(unsigned __int8 *)(a1 + 9185);
    }
  }

  return sub_949C();
}

uint64_t sub_34C24(uint64_t a1, int *a2, unsigned char *a3)
{
  int v4 = *a2;
  if (*a2 <= 1684234611)
  {
    if (v4 > 1668050794)
    {
      if (v4 != 1668050795 && v4 != 1668510818) {
        goto LABEL_19;
      }
      goto LABEL_24;
    }
    if (v4 == 1633972065)
    {
LABEL_10:
      *a3 = 1;
      return 0;
    }
    int v5 = 1651798132;
    goto LABEL_18;
  }
  if (v4 <= 1685484389)
  {
    if (v4 == 1684234612)
    {
      int v8 = qword_A1B18;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)__int16 v9 = 0;
        _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "kBluetoothAudioDeviceCategory", v9, 2u);
      }
      goto LABEL_24;
    }
    int v5 = 1684826732;
LABEL_18:
    if (v4 != v5) {
      goto LABEL_19;
    }
    goto LABEL_24;
  }
  if (v4 == 1685484390)
  {
LABEL_24:
    *a3 = 0;
    return 0;
  }
  if (v4 == 1818326127 || v4 == 1819241569) {
    goto LABEL_10;
  }
LABEL_19:

  return sub_94A4();
}

uint64_t sub_34D88(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int *a5)
{
  int v6 = *a2;
  if (*a2 > 1668641651)
  {
    if (v6 <= 1684826731)
    {
      if (v6 == 1668641652)
      {
        uint64_t result = sub_94AC();
        *a5 += 72;
        return result;
      }
      int v7 = 1684234612;
      goto LABEL_14;
    }
    if (v6 != 1684826732)
    {
      if (v6 == 1685484390)
      {
        int v8 = 8;
        goto LABEL_16;
      }
      int v7 = 1819241569;
LABEL_14:
      if (v6 == v7) {
        goto LABEL_15;
      }
      goto LABEL_19;
    }
    goto LABEL_15;
  }
  if (v6 > 1668050794)
  {
    if (v6 != 1668050795)
    {
      int v7 = 1668510818;
      goto LABEL_14;
    }
LABEL_15:
    int v8 = 4;
    goto LABEL_16;
  }
  if (v6 == 1633972065) {
    goto LABEL_15;
  }
  if (v6 == 1651798132)
  {
    int v8 = 40;
LABEL_16:
    *a5 = v8;
    return 0;
  }
LABEL_19:

  return sub_94AC();
}

uint64_t sub_34EB8(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, double *a5, int a6, int *a7, uint64_t a8)
{
  int v12 = (unsigned char *)(a1 + 9164);
  int v13 = *a2;
  if (*a2 > 1684234611)
  {
    if (v13 > 1818326126)
    {
      switch(v13)
      {
        case 1818326127:
          uint64_t result = 0;
          int v23 = *(_DWORD *)(a1 + 428);
          break;
        case 1819241569:
          uint64_t result = 0;
          int v23 = v12[21];
          break;
        case 1819569763:
          int v23 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 816))(a1);
          uint64_t result = 0;
          break;
        default:
          goto LABEL_47;
      }
    }
    else
    {
      switch(v13)
      {
        case 1684234612:
          uint64_t result = 0;
          int v23 = *(_DWORD *)(a1 + 9104);
          break;
        case 1684826732:
          uint64_t result = 0;
          int v23 = *(_DWORD *)(a1 + 9188);
          break;
        case 1685484390:
          double v14 = sub_186C4(*a5, *(float *)(a1 + 432));
          uint64_t result = 0;
          *(double *)a8 = fmin(v14, 1.0);
          int v16 = 8;
LABEL_45:
          *a7 = v16;
          return result;
        default:
          goto LABEL_47;
      }
    }
LABEL_44:
    *(_DWORD *)a8 = v23;
    int v16 = 4;
    goto LABEL_45;
  }
  if (v13 > 1668050794)
  {
    switch(v13)
    {
      case 1668050795:
        uint64_t result = 0;
        int v23 = *(_DWORD *)(a1 + 9152);
        break;
      case 1668510818:
        uint64_t result = 0;
        int v23 = *v12 == 0;
        break;
      case 1668641652:
        uint64_t result = sub_94B4();
        if (result) {
          return result;
        }
        uint64_t v17 = *a7;
        if ((a6 - v17) <= 0x53) {
          unsigned int v18 = (a6 - (int)v17) / 0xCu;
        }
        else {
          unsigned int v18 = 6;
        }
        if (!v12[21]) {
          v18 -= 4;
        }
        if (v18)
        {
          int v19 = 0;
          __int16 v20 = (_DWORD *)(a8 + v17);
          do
          {
            switch(v19)
            {
              case 0:
                *__int16 v20 = 1684234612;
                double v21 = v20 + 1;
                __int16 v22 = v20 + 2;
                goto LABEL_26;
              case 1:
                v20[3] = 1685484390;
                double v21 = v20 + 4;
                __int16 v22 = v20 + 5;
                goto LABEL_26;
              case 2:
                v20[6] = 1633972065;
                double v21 = v20 + 7;
                __int16 v22 = v20 + 8;
                goto LABEL_26;
              case 3:
                v20[9] = 1651798132;
                double v21 = v20 + 10;
                __int16 v22 = v20 + 11;
                goto LABEL_26;
              case 4:
                v20[12] = 1819241569;
                double v21 = v20 + 13;
                __int16 v22 = v20 + 14;
                goto LABEL_26;
              case 5:
                v20[15] = 1684826732;
                double v21 = v20 + 16;
                __int16 v22 = v20 + 17;
LABEL_26:
                *double v21 = 1918990199;
                *__int16 v22 = 0;
                break;
              default:
                break;
            }
            ++v19;
          }
          while (v18 != v19);
          LODWORD(v17) = *a7;
        }
        uint64_t result = 0;
        int v16 = v17 + 12 * v18;
        goto LABEL_45;
      default:
        goto LABEL_47;
    }
    goto LABEL_44;
  }
  if (v13 == 1633972065)
  {
    uint64_t result = 0;
    int v23 = v12[104];
    goto LABEL_44;
  }
  if (v13 == 1651798132)
  {
    __int16 v24 = (_OWORD *)(a1 + 9192);
    __asm { FMOV            V0.2D, #1.0 }
    *(_OWORD *)(a1 + 9216) = _Q0;
    *(double *)(a1 + 9200) = (double)(unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1112))(a1);
    *(void *)(a1 + 9192) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1088))(a1);
    double v30 = (double)(unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1112))(a1);
    unsigned int v31 = sub_3537C(a1);
    uint64_t result = 0;
    *(double *)(a1 + 9208) = v30 - (double)v31;
    long long v32 = *(_OWORD *)(a1 + 9208);
    uint64_t v33 = *(void *)(a1 + 9224);
    *(_OWORD *)a8 = *v24;
    *(_OWORD *)(a8 + 16) = v32;
    *(void *)(a8 + 32) = v33;
    int v16 = 40;
    goto LABEL_45;
  }
LABEL_47:

  return sub_94B4();
}

uint64_t sub_3537C(uint64_t a1)
{
  uint64_t v2 = a1 + 9156;
  int v3 = *(_DWORD *)(a1 + 9188);
  if (*(unsigned char *)(a1 + 9156))
  {
    float v5 = *(float *)(a1 + 540);
    float v6 = (float)v3;
    int v4 = *(unsigned __int8 *)(a1 + 9156);
    float v7 = (float)((*(unint64_t (**)(uint64_t))(*(void *)a1 + 856))(a1) * v4) / 100.0;
    if (v5 <= 1.0) {
      float v8 = v7 + v6;
    }
    else {
      float v8 = v6 - v7;
    }
    int v3 = (int)v8;
  }
  if (sub_395B4() && *(unsigned char *)(v2 + 29) && !*(_DWORD *)(a1 + 428)) {
    v3 -= 80;
  }
  return (*(double *)(a1 + 296) * (double)(v3 & ~(v3 >> 31)) / 1000.0);
}

uint64_t sub_35468(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, unsigned int a5, int *a6)
{
  float v7 = (unsigned char *)(a1 + 9185);
  int v8 = *a2;
  if (*a2 == 1819241569)
  {
    if (a5 <= 3)
    {
      uint64_t v9 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_ERROR)) {
        sub_67CD0();
      }
      return v9;
    }
    uint64_t v18 = *a6;
    BOOL v19 = sub_34690((_DWORD *)a1, *a6);
    if (*v7)
    {
      BOOL v20 = v19;
      double v21 = qword_A1B18;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v22 = "disabled";
        if (v20) {
          __int16 v22 = "enabled";
        }
        int v23 = 136315394;
        *(void *)__int16 v24 = v22;
        *(_WORD *)&v24[8] = 1024;
        int v25 = v18;
        _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, "A2DP Low Latency Mode %s, Latency Category:%d", (uint8_t *)&v23, 0x12u);
      }
      (*(void (**)(uint64_t, BOOL, uint64_t))(*(void *)a1 + 568))(a1, v20, v18);
    }
    return 0;
  }
  if (v8 == 1818326127)
  {
    if (a5 > 3)
    {
      int v11 = *a6;
      int v12 = qword_A1B18;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *(_DWORD *)(a1 + 428);
        int v23 = 67109376;
        *(_DWORD *)__int16 v24 = v13;
        *(_WORD *)&v24[4] = 1024;
        *(_DWORD *)&v24[6] = v11;
        _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "Setting Audio Latency Override, from %u to %u", (uint8_t *)&v23, 0xEu);
      }
      uint64_t v9 = 0;
      *(_DWORD *)(a1 + 428) = v11;
    }
    else
    {
      uint64_t v9 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_ERROR)) {
        sub_67D04();
      }
    }
    return v9;
  }
  if (v8 == 1633972065)
  {
    if (a5 <= 3)
    {
      uint64_t v9 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_ERROR)) {
        sub_67C9C();
      }
      return v9;
    }
    int v14 = *a6;
    BOOL v15 = *a6 != 0;
    *(unsigned char *)(a1 + 9268) = v15;
    if (*v7)
    {
      int v16 = qword_A1B18;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = "disabled";
        if (v14) {
          uint64_t v17 = "enabled";
        }
        int v23 = 136315138;
        *(void *)__int16 v24 = v17;
        _os_log_impl(&dword_0, v16, OS_LOG_TYPE_DEFAULT, "A2DP Bluetooth and Output aggregation Mode %s", (uint8_t *)&v23, 0xCu);
        BOOL v15 = v7[83] != 0;
      }
      (*(void (**)(uint64_t, BOOL))(*(void *)a1 + 680))(a1, v15);
    }
    return 0;
  }

  return sub_94BC();
}

void sub_357E0(uint64_t a1)
{
  uint64_t v1 = *(id **)(a1 + 208);
  if (v1) {
    sub_141B0(v1);
  }
}

std::string *sub_357F0@<X0>(int a1@<W1>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  sub_BAF4(a2, "Unknown");
  int v4 = "AAC-LC";
  float v5 = "Unknown Codec";
  if (!a1) {
    float v5 = "SBC";
  }
  if (a1 != 2) {
    int v4 = v5;
  }
  if (a1 == 33023) {
    float v6 = "AAC-ELD";
  }
  else {
    float v6 = v4;
  }
  return std::string::assign(a2, v6);
}

void sub_35870(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_3588C(uint64_t a1, unsigned int a2)
{
  int v4 = *(_DWORD *)(a1 + 9160);
  if (v4 == 33023) {
    int v5 = 480;
  }
  else {
    int v5 = 1024;
  }
  if (v4) {
    int v6 = v5;
  }
  else {
    int v6 = 128;
  }
  unsigned int v7 = ((double)(1000 * a2 * v6) / *(double *)(a1 + 9112)) & 0xFFFFFFF8;
  unsigned int inPropertyData = v7;
  if (a2 > 0x80)
  {
    if (a2 > 0xA0)
    {
      int v14 = 20000;
      double v8 = 20.0;
    }
    else
    {
      int v14 = 17500;
      double v8 = 17.5;
    }
  }
  else
  {
    int v14 = 15500;
    double v8 = 15.5;
  }
  uint64_t v9 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = *(_DWORD *)(a1 + 9124);
    *(_DWORD *)std::string buf = 67110144;
    unsigned int v16 = a2;
    __int16 v17 = 2048;
    double v18 = v8;
    __int16 v19 = 1024;
    unsigned int v20 = v7;
    __int16 v21 = 1024;
    int v22 = v6;
    __int16 v23 = 1024;
    int v24 = v10;
    _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "SetLinkAdaptiveEncoderRateFromBT Updating AAC Encoder to %d kbps, bandwidth = %2.1f KHz, frame size = %d bits, samples per frame = %d, frames per packet = %d", buf, 0x24u);
  }
  OSStatus v11 = AudioConverterSetProperty(*(AudioConverterRef *)(*(void *)(a1 + 232) + 56), 0x5E70736Cu, 4u, &inPropertyData);
  sub_1B8C0(v11, (uint64_t)"Failed to set kAudioCodecPropertyAdjustPacketSizeLimitForVBR");
  OSStatus v12 = AudioConverterSetProperty(*(AudioConverterRef *)(*(void *)(a1 + 232) + 56), 0x5E62776Cu, 4u, &v14);
  sub_1B8C0(v12, (uint64_t)"Failed to set kAudioCodecPrivatePropertyBandwidthLimit");
}

uint64_t sub_35A4C(_DWORD *a1)
{
  int v1 = a1[2281];
  a1[2282] = v1;
  int v2 = a1[2290];
  unsigned int v3 = v1 << 7;
  if (v2) {
    unsigned int v3 = 1024;
  }
  if (v2 == 33023) {
    return 480;
  }
  else {
    return v3;
  }
}

void sub_35A7C(uint64_t a1, int a2, uint64_t a3)
{
  int v5 = (unsigned char *)(a1 + 9156);
  if (*(void *)(a1 + 9136))
  {
    mach_timebase_info info = 0;
    mach_timebase_info(&info);
    float v7 = *(double *)(a1 + 296) / 1000.0;
    float v8 = v7 * (float)(*(unsigned int (**)(uint64_t))(*(void *)a1 + 856))(a1);
    float v9 = (float)((a3 - *(void *)(a1 + 9136)) * (unint64_t)info.numer / info.denom / 0x3E8) / 1000.0;
    float v10 = v9 * v7;
    unsigned int v11 = *(_DWORD *)(a1 + 9144) + a2;
    *(_DWORD *)(a1 + 9144) = v11;
    float v12 = *(float *)(a1 + 540);
    if (v12 <= 1.0)
    {
      float v13 = 0.0;
      if (v12 < 1.0) {
        float v13 = (float)v11 - v10;
      }
    }
    else
    {
      float v13 = v10 - (float)v11;
    }
    if (v13 < 0.0) {
      float v13 = 0.0;
    }
    if (v13 >= v8)
    {
      unsigned char *v5 = 100;
      if (v9 <= 10000.0)
      {
LABEL_15:
        unsigned int v16 = qword_A1B18;
        if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG))
        {
          if (v12 <= 1.0) {
            __int16 v19 = "Speed Up";
          }
          else {
            __int16 v19 = "Slow Down";
          }
          int v20 = *(_DWORD *)(a1 + 9144);
          int v21 = sub_3537C(a1);
          *(_DWORD *)std::string buf = 136447490;
          __int16 v26 = v19;
          __int16 v27 = 2048;
          double v28 = v10;
          __int16 v29 = 1024;
          int v30 = v20;
          __int16 v31 = 2048;
          double v32 = v8;
          __int16 v33 = 2048;
          double v34 = v9;
          __int16 v35 = 1024;
          int v36 = v21;
          _os_log_debug_impl(&dword_0, v16, OS_LOG_TYPE_DEBUG, "Dynamic Latency : %{public}s Complete : Target Samples=%f, actual samples=%u Target Drift=%f Duration = %f Final in-ear-delay=%u", buf, 0x36u);
          float v12 = *(float *)(a1 + 540);
        }
        unsigned char *v5 = 0;
        int v17 = atomic_load((unsigned int *)(a1 + 548));
        if (v12 > 1.0) {
          int v17 = -v17;
        }
        *(_DWORD *)(a1 + 9188) += v17;
        if (v5[9])
        {
          *(void *)(a1 + 9176) = 0;
          v5[9] = 0;
          if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
            sub_67DF0();
          }
          *(_DWORD *)(a1 + 9124) = *(_DWORD *)(a1 + 9168);
          (*(void (**)(uint64_t))(*(void *)a1 + 728))(a1);
        }
        atomic_store(0, (unsigned int *)(a1 + 548));
        atomic_store(0, (unsigned __int8 *)(a1 + 545));
        double v18 = *(NSObject **)(qword_A2350 + 160);
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 3221225472;
        void v23[2] = sub_35EA0;
        v23[3] = &unk_8D2C0;
        v23[4] = a1;
        dispatch_async(v18, v23);
        *(void *)(a1 + 9136) = 0;
        *(_DWORD *)(a1 + 9144) = 0;
        return;
      }
    }
    else
    {
      unsigned char *v5 = (int)(float)((float)(v13 / v8) * 100.0);
      if (v9 <= 10000.0) {
        return;
      }
    }
    BOOL v15 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_ERROR))
    {
      int v22 = "Speed Up";
      if (v12 > 1.0) {
        int v22 = "Slow Down";
      }
      *(_DWORD *)std::string buf = 136446466;
      __int16 v26 = v22;
      __int16 v27 = 2048;
      double v28 = v9;
      _os_log_error_impl(&dword_0, v15, OS_LOG_TYPE_ERROR, "Dynamic Latency : %{public}s took too long to complete Duration=%f", buf, 0x16u);
      float v12 = *(float *)(a1 + 540);
    }
    goto LABEL_15;
  }
  *(_DWORD *)(a1 + 9144) = 0;
  *(void *)(a1 + 9136) = a3;
  unsigned char *v5 = 0;
  int v14 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEBUG)) {
    sub_67D38(a1, v14);
  }
}

uint64_t sub_35EA0(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 32) + 1600))(*(void *)(a1 + 32), 1);
}

void sub_35ED4(void *a1, float a2)
{
  int v4 = *(unsigned char **)(a1[52] + 9248);
  BOOL v5 = v4[274] && v4[275] && v4[276] != 0;
  int v6 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 134218242;
    double v13 = a2;
    __int16 v14 = 2114;
    uint64_t v15 = sub_7904((uint64_t)a1);
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "A2DP : Volume received from bluetoothd: volume %f Device %{public}@", (uint8_t *)&v12, 0x16u);
  }
  if (v5)
  {
    (*(void (**)(void *, float))(*a1 + 1192))(a1, a2);
  }
  else
  {
    int v7 = sub_395B4();
    if (a2 != 0.0)
    {
      if (v7)
      {
        uint64_t v8 = a1[52];
        uint64_t v9 = *(void *)(v8 + 9248);
        if (*(_DWORD *)(v9 + 152))
        {
          *(_DWORD *)(v9 + 152) = 0;
          sub_55BB4(v8, 1836414053);
        }
      }
    }
    (*(void (**)(void *, uint64_t, float))(*a1 + 480))(a1, 1, a2);
  }
  if ((*(unsigned int (**)(void *))(*a1 + 296))(a1))
  {
    uint64_t v10 = qword_A2350;
    int v11 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
    if (sub_444E0(v10, v11)) {
      sub_44380(qword_A2350);
    }
  }
}

BOOL sub_360F0(void *a1)
{
  return ((*(uint64_t (**)(void *))(*a1 + 1296))(a1) & 1) == 0
      && *(unsigned char *)(*(void *)(a1[52] + 9248) + 274) == 0;
}

float sub_3615C(uint64_t a1, int a2, uint64_t a3)
{
  float result = *(float *)(a1 + 456);
  if (result != *(float *)(a1 + 452) && *(_DWORD *)(a1 + 324) == 2)
  {
    unint64_t v4 = (2 * a2);
    if (*(_DWORD *)(a1 + 308) == 9 && v4 != 0)
    {
      unint64_t v6 = 0;
      do
      {
        int v7 = (float *)(a3 + 4 * v6);
        float v8 = v7[1];
        *int v7 = *v7 * *(float *)(a1 + 452);
        float result = v8 * *(float *)(a1 + 456);
        v7[1] = result;
        v6 += 2;
      }
      while (v6 < v4);
    }
  }
  return result;
}

float sub_361C0(float *a1, int a2, float a3)
{
  float v4 = a3;
  float v6 = a1[113];
  float v7 = a1[108];
  if (a2)
  {
    if (a2 != 1) {
      return v4;
    }
    float v8 = v6 * v7;
    float v9 = a3;
  }
  else
  {
    float v9 = v7 * a1[114];
    float v8 = a3;
  }
  uint64_t v10 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    float v11 = a1[114];
    int v12 = "Right";
    int v19 = 136447490;
    if (!a2) {
      int v12 = "Left";
    }
    int v20 = v12;
    __int16 v21 = 2048;
    double v22 = v4;
    __int16 v23 = 2048;
    double v24 = v6;
    __int16 v25 = 2048;
    double v26 = v11;
    __int16 v27 = 2048;
    double v28 = v8;
    __int16 v29 = 2048;
    double v30 = v9;
    _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Update Volume Balance : [ %{public}s ] volume %f Current Scale [ %f  %f ]   Current balance [ %f - %f ]", (uint8_t *)&v19, 0x3Eu);
    float v7 = a1[108];
  }
  if (v7 != 0.0)
  {
    if (v8 > v9)
    {
      a1[113] = 1.0;
      a1[114] = v9 / v8;
      return v8;
    }
    if (v8 < v9)
    {
      a1[114] = 1.0;
      a1[113] = v8 / v9;
      return v9;
    }
  }
  __asm { FMOV            V0.2S, #1.0 }
  *(void *)(a1 + 113) = _D0;
  return v4;
}

void sub_36368(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 416) + 9248);
  int v5 = *(unsigned __int8 *)(v4 + 222);
  if (*(unsigned char *)(v4 + 222)) {
    int v6 = a2;
  }
  else {
    int v6 = 0;
  }
  float v7 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v8 = @"Send";
    if (v6) {
      CFStringRef v8 = @"Not Send";
    }
    if (a2) {
      CFStringRef v9 = @"IO Stop";
    }
    else {
      CFStringRef v9 = @"Route Change/Timer";
    }
    int v12 = 138412802;
    CFStringRef v13 = v8;
    __int16 v14 = 2112;
    CFStringRef v15 = v9;
    if (v5) {
      CFStringRef v10 = @"Enabled";
    }
    else {
      CFStringRef v10 = @"Disabled";
    }
    __int16 v16 = 2112;
    CFStringRef v17 = v10;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Evaluate Transport Transition,  %@ A2DP Stop Message to bluetoothd:, Trigger Type: %@ Route transition: %@", (uint8_t *)&v12, 0x20u);
  }
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 1400))(a1);
  }
  else
  {
    float v11 = *(id **)(a1 + 208);
    if (v11) {
      sub_140F0(v11);
    }
  }
  *(unsigned char *)(a1 + 462) = v6;
}

uint64_t sub_364D4(uint64_t a1)
{
  int v2 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Start A2DP Transition timer", buf, 2u);
  }
  unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 16))(*(void *)(a1 + 416));
  *(void *)std::string buf = 0;
  uint64_t v10 = 0;
  sub_5CDCC((uint64_t)buf, a1 + 464);
  uint64_t v4 = *(void **)(a1 + 528);
  if (v4)
  {
    if (!dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 528)))
    {
      dispatch_block_cancel(v4);
      uint64_t v4 = *(void **)(a1 + 528);
    }
    _Block_release(v4);
    *(void *)(a1 + 528) = 0;
  }
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_36648;
  uint64_t v7[3] = &unk_8EB30;
  v7[4] = a1;
  unsigned int v8 = v3;
  dispatch_block_t v5 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v7);
  *(void *)(a1 + 528) = v5;
  sub_456B0(qword_A2350, 200, v3, v5);
  sub_5CEA4((uint64_t)buf);
  return sub_5CF10(buf);
}

void sub_36634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_36648(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 40));
  if (v2)
  {
    unsigned int v3 = v2;
    uint64_t v4 = (unsigned char *)v2[1136];
    if (v4)
    {
      if (v4[192] && v4[462])
      {
        dispatch_block_t v5 = qword_A1B18;
        if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(v7[0]) = 0;
          _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "A2DP - HFP Transiton timer fired", (uint8_t *)v7, 2u);
          if (*(unsigned char *)(v3[1136] + 192)) {
            uint64_t v4 = (unsigned char *)v3[1136];
          }
          else {
            uint64_t v4 = 0;
          }
        }
        (*(void (**)(unsigned char *, void))(*(void *)v4 + 1384))(v4, 0);
      }
    }
  }
  v7[0] = 0;
  v7[1] = 0;
  sub_5CDCC((uint64_t)v7, v1 + 464);
  _Block_release(*(const void **)(v1 + 528));
  *(void *)(v1 + 528) = 0;
  sub_5CEA4((uint64_t)v7);
  return sub_5CF10(v7);
}

void sub_36760(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_36774(uint64_t a1)
{
  int v2 = qword_A1B18;
  if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, " A2DP ResetTransitionTimer", buf, 2u);
  }
  *(void *)std::string buf = 0;
  uint64_t v8 = 0;
  sub_5CDCC((uint64_t)buf, a1 + 464);
  unsigned int v3 = *(void **)(a1 + 528);
  if (v3)
  {
    if (!dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 528)))
    {
      uint64_t v4 = qword_A1B18;
      if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v6 = 0;
        _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Cancel: Transition Timer", v6, 2u);
        unsigned int v3 = *(void **)(a1 + 528);
      }
      dispatch_block_cancel(v3);
    }
    *(void *)(a1 + 528) = 0;
  }
  sub_5CEA4((uint64_t)buf);
  return sub_5CF10(buf);
}

void sub_36864(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_36878(unsigned char *a1)
{
  if (a1[462]) {
    (*(void (**)(unsigned char *, void))(*(void *)a1 + 1384))(a1, 0);
  }
  int v2 = *(uint64_t (**)(unsigned char *))(*(void *)a1 + 1408);

  return v2(a1);
}

void sub_3691C(uint64_t a1, int a2)
{
  if (a2 == 1953719151)
  {
    unsigned int v3 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      sub_B6D0(3u, __p);
      if (v7 >= 0) {
        uint64_t v4 = __p;
      }
      else {
        uint64_t v4 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136446210;
      CFStringRef v9 = v4;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Send Transiton Message %{public}s ", buf, 0xCu);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
    dispatch_block_t v5 = *(id **)(a1 + 208);
    if (v5) {
      sub_14144(v5, 3);
    }
  }
}

uint64_t sub_36A1C(uint64_t result, int a2, int a3, unsigned int a4)
{
  if (*(unsigned char *)(result + 462))
  {
    uint64_t v7 = result;
    uint64_t v8 = qword_A1B18;
    if (os_log_type_enabled((os_log_t)qword_A1B18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(*(void *)(v7 + 416) + 9264);
      v14[0] = BYTE3(v9);
      v14[1] = BYTE2(v9);
      _DWORD v14[2] = BYTE1(v9);
      v14[3] = v9;
      v14[4] = 0;
      v13[0] = HIBYTE(a3);
      v13[1] = BYTE2(a3);
      void v13[2] = BYTE1(a3);
      v13[3] = a3;
      v13[4] = 0;
      sub_B6D0(a4, __p);
      uint64_t v10 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136315650;
      __int16 v16 = v14;
      __int16 v17 = 2080;
      double v18 = v13;
      __int16 v19 = 2080;
      int v20 = v10;
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "A2DP Profile HandleTransportOnRouteChange %s => %s Recommended Transtion: %s", buf, 0x20u);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
    if (a3 == 1919183219 || a2 != 1953719151) {
      (*(void (**)(uint64_t, void))(*(void *)v7 + 1384))(v7, 0);
    }
    else {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 1424))(v7, 1953719151);
    }
    *(unsigned char *)(v7 + 462) = 0;
    return (*(uint64_t (**)(uint64_t))(*(void *)v7 + 1408))(v7);
  }
  return result;
}

uint64_t sub_36C90()
{
  return 1;
}

uint64_t sub_36C98(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9104) = a2;
  return result;
}

uint64_t sub_36CA0(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 9185);
}

double sub_36CAC(uint64_t a1)
{
  return *(double *)(a1 + 296);
}

double sub_36CB4()
{
  return 0.0;
}

__n128 sub_36CBC@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(void *)(a2 + 32) = *(void *)(a1 + 328);
  __n128 result = *(__n128 *)(a1 + 296);
  long long v3 = *(_OWORD *)(a1 + 312);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t sub_36CD4(uint64_t a1)
{
  return *(unsigned int *)(a1 + 376);
}

uint64_t sub_36CDC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 9104);
}

uint64_t sub_36CE4()
{
  return 0;
}

uint64_t sub_36CEC(uint64_t a1)
{
  return atomic_load((unsigned int *)(a1 + 548));
}

float sub_36CF8(uint64_t a1)
{
  return *(float *)(a1 + 540);
}

uint64_t sub_36D00(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 9184);
}

uint64_t sub_36D0C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 409) = a2;
  return result;
}

uint64_t sub_36D14(uint64_t result, char a2)
{
  *(unsigned char *)(result + 410) = a2;
  return result;
}

BOOL sub_36D1C(uint64_t a1)
{
  return *(unsigned char *)(a1 + 409) != 0;
}

BOOL sub_36D2C(uint64_t a1)
{
  return *(unsigned char *)(a1 + 410) != 0;
}

uint64_t sub_36D3C()
{
  return 0;
}

uint64_t sub_36D44()
{
  return 1;
}

uint64_t sub_36D4C()
{
  return 1;
}

uint64_t sub_36D5C()
{
  return 0;
}

uint64_t sub_36D64(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 9270);
}

uint64_t sub_36D70(uint64_t result)
{
  *(_WORD *)(result + 9270) = 0;
  return result;
}

uint64_t sub_36D7C(uint64_t result)
{
  return result;
}

uint64_t sub_36D90(uint64_t a1)
{
  return *(void *)(a1 + 9080);
}

uint64_t sub_36D98(uint64_t a1)
{
  return *(void *)(a1 + 9088);
}

uint64_t sub_36DA0(uint64_t a1)
{
  return *(void *)(a1 + 9096);
}

uint64_t sub_36DA8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9088) = a2;
  return result;
}

uint64_t sub_36DB0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9096) = a2;
  return result;
}

uint64_t sub_36DB8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9080) = a2;
  return result;
}

os_log_t sub_36DC0()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1B18 = (uint64_t)result;
  return result;
}

uint64_t sub_36DF0(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v7 = sub_3F94(a1, a3);
  *(void *)uint64_t v7 = off_8EB78;
  *(_DWORD *)(v7 + 9308) = 0;
  *(_WORD *)(v7 + 9353) = 0;
  *(void *)(v7 + 9080) = 0;
  *(_OWORD *)(v7 + 9088) = 0u;
  *(_OWORD *)(v7 + 9328) = 0u;
  sub_5CC80(v7 + 9360, v8);
  *(void *)(a1 + 9424) = 0;
  *(_DWORD *)(a1 + 9432) = 0;
  *(unsigned char *)(a1 + 9436) = 0;
  *(_DWORD *)(a1 + 9440) = 512;
  sub_AD7C(a1, a2);
  (*(void (**)(uint64_t, void *))(*(void *)a1 + 1560))(a1, a4);
  if (sub_395B4()) {
    *(unsigned char *)(a1 + 9017) = 1;
  }
  sub_4258((unsigned char *)a1, a4);
  sub_37244(a1, a4);
  *(_DWORD *)(a1 + 368) = 1953719151;
  atomic_store(0, (unsigned __int8 *)(a1 + 288));
  *(_DWORD *)(a1 + 292) = 1;
  strcpy((char *)(a1 + 9348), "ichs");
  *(_OWORD *)(a1 + 372) = xmmword_71700;
  *(_DWORD *)(a1 + 388) = 0;
  *(_DWORD *)(a1 + 396) = 0;
  *(unsigned char *)(a1 + 424) = 1;
  *(_DWORD *)(a1 + 432) = 0;
  *(_DWORD *)(a1 + 448) = 0;
  *(void *)(a1 + 440) = 0xC2000000C2000000;
  sub_37B4C(a1);
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1))
  {
    uint64_t v9 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      double v10 = *(float *)(a1 + 440);
      uint64_t v11 = *(void *)(a1 + 296);
      int v16 = 134218496;
      double v17 = v10;
      __int16 v18 = 2048;
      uint64_t v19 = v11;
      __int16 v20 = 2048;
      uint64_t v21 = 0x3F947AE147AE147BLL;
      _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "Create Volume Obj mDBVolume %f, mPhysicalFormat.mSampleRate %f, kHFPAudioRampTime %f", (uint8_t *)&v16, 0x20u);
    }
    operator new();
  }
  *(unsigned char *)(a1 + 9345) = 0;
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1032))(a1, 1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1024))(a1, 1);
  *(unsigned char *)(a1 + 9016) = 1;
  if (sub_395B4())
  {
    *(_WORD *)(a1 + 460) = 0;
  }
  else
  {
    *(unsigned char *)(a1 + 460) = 1;
    int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1296))(a1);
    if (v12) {
      LOBYTE(v12) = _os_feature_enabled_impl();
    }
    *(unsigned char *)(a1 + 461) = v12;
  }
  CFStringRef v13 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 460)) {
      __int16 v14 = "YES";
    }
    else {
      __int16 v14 = "NO";
    }
    int v16 = 136315138;
    double v17 = *(double *)&v14;
    _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "HFP : Need Transport Ready %s", (uint8_t *)&v16, 0xCu);
  }
  *(_WORD *)(a1 + 9346) = 0;
  *(void *)(a1 + 40) = sub_1F670() + 4000;
  *(void *)(a1 + 56) = sub_1F670() + 4000;
  *(void *)(a1 + 72) = sub_1F670() + 0x4000;
  *(void *)(a1 + 88) = 0;
  return a1;
}

void sub_37200()
{
}

void sub_37244(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyCategory");
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
  {
    dispatch_block_t v5 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_684FC(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  *(_DWORD *)(a1 + 9304) = xpc_int64_get_value(value);
  xpc_object_t v13 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyLatency");
  if (xpc_get_type(v13) != (xpc_type_t)&_xpc_type_int64)
  {
    __int16 v14 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_68484(v14, v15, v16, v17, v18, v19, v20, v21);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  *(_DWORD *)(a1 + 9320) = xpc_int64_get_value(v13);
  xpc_object_t v22 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyEQSettingID");
  if (xpc_get_type(v22) != (xpc_type_t)&_xpc_type_int64)
  {
    __int16 v23 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_6840C(v23, v24, v25, v26, v27, v28, v29, v30);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  *(_DWORD *)(a1 + 9312) = xpc_int64_get_value(v22);
  xpc_object_t v31 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyNBSSupport");
  if (xpc_get_type(v31) != (xpc_type_t)&_xpc_type_BOOL)
  {
    double v32 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_68394(v32, v33, v34, v35, v36, v37, v38, v39);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  *(unsigned char *)(a1 + 9324) = xpc_BOOL_get_value(v31);
  xpc_object_t v40 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyInputSWPLCSupport");
  if (v40)
  {
    uint64_t v41 = v40;
    if (xpc_get_type(v40) != (xpc_type_t)&_xpc_type_BOOL)
    {
      uint64_t v42 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_6831C(v42, v43, v44, v45, v46, v47, v48, v49);
      }
      if (sub_5CB00()) {
        goto LABEL_108;
      }
    }
    BOOL v50 = xpc_BOOL_get_value(v41);
    sub_ACB4(a1, v50);
  }
  xpc_object_t v51 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyWBSSupport");
  if (xpc_get_type(v51) != (xpc_type_t)&_xpc_type_BOOL)
  {
    uint64_t v52 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_682A4(v52, v53, v54, v55, v56, v57, v58, v59);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  *(unsigned char *)(a1 + 9325) = xpc_BOOL_get_value(v51);
  (*(void (**)(uint64_t, xpc_object_t))(*(void *)a1 + 912))(a1, xdict);
  xpc_object_t v60 = xpc_dictionary_get_value(xdict, "kBTAudioDebugEnableUWBSStereoTest");
  *(unsigned char *)(a1 + 9344) = 0;
  if (v60)
  {
    uint64_t v61 = v60;
    if (xpc_get_type(v60) != (xpc_type_t)&_xpc_type_BOOL)
    {
      uint64_t v62 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_6822C(v62, v63, v64, v65, v66, v67, v68, v69);
      }
      if (sub_5CB00()) {
        goto LABEL_108;
      }
    }
    BOOL v70 = xpc_BOOL_get_value(v61);
    *(unsigned char *)(a1 + 9344) = v70;
  }
  else
  {
    BOOL v70 = 0;
  }
  uint64_t v71 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v72 = "On";
    if (*(unsigned char *)(a1 + 9326)) {
      uint64_t v73 = "On";
    }
    else {
      uint64_t v73 = "Off";
    }
    int v74 = *(_DWORD *)(a1 + 9328);
    if (*(unsigned char *)(a1 + 9327)) {
      xpc_object_t v75 = "On";
    }
    else {
      xpc_object_t v75 = "Off";
    }
    int v169 = 136315906;
    if (v74) {
      uint64_t v76 = "On";
    }
    else {
      uint64_t v76 = "Off";
    }
    int v170 = v73;
    __int16 v171 = 2080;
    if (!v70) {
      uint64_t v72 = "Off";
    }
    v172 = v75;
    __int16 v173 = 2080;
    int v174 = v76;
    __int16 v175 = 2080;
    BOOL v176 = v72;
    _os_log_impl(&dword_0, v71, OS_LOG_TYPE_DEFAULT, "InitializePublishedProperties mUWBS %s, mSWB %s, mStereoSupported %s, mUWBSStereoTest %s", (uint8_t *)&v169, 0x2Au);
  }
  xpc_object_t v77 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyIncompatibleHidConnected");
  if (v77 && *(void *)(*(void *)(a1 + 416) + 9248))
  {
    uint64_t v78 = v77;
    if (xpc_get_type(v77) != (xpc_type_t)&_xpc_type_BOOL)
    {
      uint64_t v79 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_681B4(v79, v80, v81, v82, v83, v84, v85, v86);
      }
      if (sub_5CB00()) {
        goto LABEL_108;
      }
    }
    uint64_t v87 = *(void *)(*(void *)(a1 + 416) + 9248);
    *(unsigned char *)(v87 + 216) = xpc_BOOL_get_value(v78);
    uint64_t v88 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v89 = xpc_BOOL_get_value(v78);
      int v169 = 67109120;
      LODWORD(v170) = v89;
      uint64_t v90 = "HFPAudioDevice InitializePublishedProperties, mIncompatibleHidUpdateNeeded:%u";
      uint64_t v91 = v88;
      uint32_t v92 = 8;
LABEL_57:
      _os_log_impl(&dword_0, v91, OS_LOG_TYPE_DEFAULT, v90, (uint8_t *)&v169, v92);
    }
  }
  else
  {
    uint64_t v93 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v169) = 0;
      uint64_t v90 = "HFPAudioDevice InitializePublishedProperties no hid connect property, publish stereo";
      uint64_t v91 = v93;
      uint32_t v92 = 2;
      goto LABEL_57;
    }
  }
  xpc_object_t v94 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyNRLevel");
  if (xpc_get_type(v94) != (xpc_type_t)&_xpc_type_int64)
  {
    xpc_object_t v95 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_6813C(v95, v96, v97, v98, v99, v100, v101, v102);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  *(_DWORD *)(a1 + 9316) = xpc_int64_get_value(v94);
  xpc_object_t v103 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyECNRIsEnabled");
  if (xpc_get_type(v103) != (xpc_type_t)&_xpc_type_BOOL)
  {
    int64_t v104 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_680C4(v104, v105, v106, v107, v108, v109, v110, v111);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  BOOL v112 = xpc_BOOL_get_value(v103);
  (*(void (**)(uint64_t, BOOL))(*(void *)a1 + 416))(a1, v112);
  xpc_object_t v113 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyVolumeScalar");
  if (xpc_get_type(v113) != (xpc_type_t)&_xpc_type_double)
  {
    float v114 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_6804C(v114, v115, v116, v117, v118, v119, v120, v121);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  float v122 = xpc_double_get_value(v113);
  (*(void (**)(uint64_t, void, float))(*(void *)a1 + 480))(a1, 0, v122);
  xpc_object_t v123 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyInputVolumeScalar");
  if (v123)
  {
    xpc_object_t v124 = v123;
    if (xpc_get_type(v123) != (xpc_type_t)&_xpc_type_double)
    {
      uint64_t v125 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_67FD4(v125, v126, v127, v128, v129, v130, v131, v132);
      }
      if (sub_5CB00()) {
        goto LABEL_108;
      }
    }
    float v133 = xpc_double_get_value(v124);
    (*(void (**)(uint64_t, float))(*(void *)a1 + 504))(a1, v133);
  }
  xpc_object_t v134 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyDSPOffload");
  if (xpc_get_type(v134) != (xpc_type_t)&_xpc_type_BOOL)
  {
    BOOL v135 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_67F5C(v135, v136, v137, v138, v139, v140, v141, v142);
    }
    if (sub_5CB00()) {
      goto LABEL_108;
    }
  }
  *(unsigned char *)(a1 + 9355) = xpc_BOOL_get_value(v134);
  xpc_object_t v143 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyAdvancedHandsfreeSupport");
  if (v143)
  {
    uint64_t v144 = v143;
    if (xpc_get_type(v143) != (xpc_type_t)&_xpc_type_BOOL)
    {
      uint64_t v145 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_67EE4(v145, v146, v147, v148, v149, v150, v151, v152);
      }
      if (sub_5CB00()) {
        goto LABEL_108;
      }
    }
    uint64_t v153 = *(void *)(*(void *)(a1 + 416) + 9248);
    char v154 = xpc_BOOL_get_value(v144);
    sub_2A69C(v153, v154);
  }
  xpc_object_t v155 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyLowLatencyGameMode");
  if (!v155) {
    goto LABEL_101;
  }
  BOOL v156 = v155;
  if (xpc_get_type(v155) != (xpc_type_t)&_xpc_type_BOOL)
  {
    uint64_t v157 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_67E6C(v157, v158, v159, v160, v161, v162, v163, v164);
    }
    if (sub_5CB00()) {
LABEL_108:
    }
      abort();
  }
  if (_os_feature_enabled_impl())
  {
    v165 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 221)) {
        v166 = "running";
      }
      else {
        v166 = "not running";
      }
      if (xpc_BOOL_get_value(v156)) {
        xpc_object_t v167 = "running";
      }
      else {
        xpc_object_t v167 = "not running";
      }
      int v169 = 136315394;
      int v170 = v166;
      __int16 v171 = 2080;
      v172 = v167;
      _os_log_impl(&dword_0, v165, OS_LOG_TYPE_DEFAULT, "HFPAudioDevice InitializePublishedProperties LowLatencyGameMode: %s->%s", (uint8_t *)&v169, 0x16u);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 221) = xpc_BOOL_get_value(v156);
  }
LABEL_101:
  if (!*(_DWORD *)(a1 + 9304)
    && (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1296))(a1) & 1) != 0 || sub_395B4()))
  {
    BOOL v168 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v169) = 0;
      _os_log_impl(&dword_0, v168, OS_LOG_TYPE_DEFAULT, "Device category was unknown, defaulting to headphone", (uint8_t *)&v169, 2u);
    }
    *(_DWORD *)(a1 + 9304) = 1;
  }
}

void sub_37B4C(uint64_t a1)
{
  int v2 = (unsigned char *)(a1 + 9325);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  sub_385F0(a1, &v13, (double *)&v12);
  if (v2[2])
  {
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEBUG)) {
      sub_685A8();
    }
    operator new();
  }
  if (v2[1])
  {
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEBUG)) {
      sub_68574();
    }
    operator new();
  }
  int v3 = *(_DWORD *)(a1 + 9328);
  if (v3 == 129 || v3 == 255 || *(_DWORD *)(a1 + 9336) == 130)
  {
    uint64_t v4 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109376;
      int v15 = v3;
      __int16 v16 = 1024;
      BOOL v17 = v3 == 129;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Creating HFP Codec for Stereo mStereoSupported:%d, %d", buf, 0xEu);
    }
    operator new();
  }
  if (v3 == 128)
  {
    uint64_t v8 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Creating HFP Codec for Stereo", buf, 2u);
    }
    *(_OWORD *)(a1 + 9200) = *(_OWORD *)(a1 + 9120);
    long long v9 = *(_OWORD *)(a1 + 9104);
    *(_OWORD *)(a1 + 9184) = v9;
    uint64_t v10 = *(void *)(a1 + 9136);
    *(void *)(a1 + 9216) = v10;
    *(_DWORD *)(a1 + 9212) = 1;
    *(_DWORD *)(a1 + 9200) = v10 >> 3;
    *(_DWORD *)(a1 + 9208) = v10 >> 3;
    *(void *)(a1 + 9256) = v10;
    long long v11 = *(_OWORD *)(a1 + 9200);
    *(_OWORD *)(a1 + 9224) = v9;
    *(_OWORD *)(a1 + 9240) = v11;
    operator new();
  }
  uint64_t v5 = *(void *)(a1 + 232);
  if (v5)
  {
    *(unsigned char *)(v5 + 48) = *(unsigned char *)(a1 + 745);
    *(unsigned char *)(v5 + 177) = *(unsigned char *)(a1 + 744);
  }
  uint64_t v6 = *(void *)(a1 + 248);
  if (v6)
  {
    *(unsigned char *)(v6 + 48) = *(unsigned char *)(a1 + 745);
    *(unsigned char *)(v6 + 177) = *(unsigned char *)(a1 + 744);
  }
  if (v2[1])
  {
    int v7 = 510;
  }
  else if (*v2)
  {
    int v7 = 257;
  }
  else
  {
    int v7 = 256;
  }
  sub_1E580(*(void *)(qword_A2350 + 328), v7, 1, *(double *)(a1 + 296));
}

void sub_382C4()
{
}

uint64_t sub_38354(uint64_t a1)
{
  *(void *)a1 = off_8EB78;
  *(unsigned char *)(a1 + 9017) = 0;
  v11[0] = 0;
  v11[1] = 0;
  uint64_t v2 = a1 + 9360;
  sub_5CDCC((uint64_t)v11, a1 + 9360);
  int v3 = *(const void **)(a1 + 9424);
  if (v3)
  {
    _Block_release(v3);
    *(void *)(a1 + 9424) = 0;
  }
  sub_5CEA4((uint64_t)v11);
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 848))(a1))
  {
    uint64_t v4 = qword_A2350;
    (*(void (**)(void **__return_ptr, uint64_t))(*(void *)a1 + 832))(__p, a1);
    sub_41D30(v4, (uint64_t)__p);
    if (v10 < 0) {
      operator delete(__p[0]);
    }
  }
  sub_83B0(a1);
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1)
    && (*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1))
  {
    uint64_t v5 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 1640))(a1);
    free(v5);
    (*(void (**)(uint64_t, void))(*(void *)a1 + 1656))(a1, 0);
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 72))(a1);
  sub_5CF10(v11);
  sub_5CD00(v2, v6);
  return sub_415C(a1, v7);
}

void sub_38588(uint64_t a1)
{
  sub_38354(a1);

  operator delete();
}

BOOL sub_385C0(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 9328);
  BOOL result = 1;
  if (v2 != 129 && v2 != 255) {
    return *(_DWORD *)(a1 + 9336) == 130;
  }
  return result;
}

void sub_385F0(uint64_t a1, uint64_t *a2, double *a3)
{
  uint64_t v6 = a1 + 9272;
  uint64_t v7 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = *(unsigned __int8 *)(v6 + 52);
    int v9 = *(unsigned __int8 *)(v6 + 53);
    int v10 = *(unsigned __int8 *)(v6 + 54);
    int v11 = *(unsigned __int8 *)(v6 + 55);
    int v12 = *(_DWORD *)(a1 + 9328);
    v19[0] = 67110144;
    v19[1] = v8;
    __int16 v20 = 1024;
    int v21 = v9;
    __int16 v22 = 1024;
    int v23 = v10;
    __int16 v24 = 1024;
    int v25 = v11;
    __int16 v26 = 1024;
    int v27 = v12;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Codecs available. NBS (CVSD): %d, WBS (mSBC): %d, UWBS (AAC-ELD): %d, mSWB:%d, Stereo: %d", (uint8_t *)v19, 0x20u);
  }
  int v13 = *(unsigned __int8 *)(v6 + 55);
  uint64_t v14 = 0x40D7700000000000;
  if (!*(unsigned char *)(v6 + 55) && !*(unsigned char *)(v6 + 54)) {
    uint64_t v14 = qword_71710[*(unsigned char *)(v6 + 53) == 0];
  }
  int v15 = *(_DWORD *)(a1 + 9328);
  double v16 = 48000.0;
  if (v15 != 129 && v15 != 255 && *(_DWORD *)(a1 + 9336) != 130)
  {
    double v16 = 24000.0;
    if (v15 != 128) {
      double v16 = 0.0;
    }
  }
  *(void *)(a1 + 9264) = v14;
  *(_OWORD *)uint64_t v6 = xmmword_71720;
  *(_OWORD *)(v6 + 16) = xmmword_71730;
  if (v13 || *(unsigned char *)(v6 + 54))
  {
    *(void *)(a1 + 296) = v14;
    *(_DWORD *)(a1 + 328) = 32;
    *(_OWORD *)(a1 + 304) = xmmword_71740;
    *(void *)(a1 + 320) = 0x100000004;
  }
  else
  {
    long long v18 = *(_OWORD *)(a1 + 9280);
    *(_OWORD *)(a1 + 296) = *(_OWORD *)(a1 + 9264);
    *(_OWORD *)(a1 + 312) = v18;
    *(void *)(a1 + 328) = *(void *)(a1 + 9296);
  }
  *(double *)(a1 + 9104) = v16;
  *(_DWORD *)(a1 + 9112) = 1819304813;
  *(_DWORD *)(a1 + 9124) = 1;
  *(_DWORD *)(a1 + 9140) = 0;
  *(_DWORD *)(a1 + 9132) = 2;
  if (v15 == 129 || v15 == 255 || v15 == 128 || *(_DWORD *)(a1 + 9336) == 130)
  {
    *(void *)(a1 + 9116) = 0x800000009;
    *(_DWORD *)(a1 + 9136) = 32;
    *(_DWORD *)(a1 + 9128) = 8;
    if (*(_DWORD *)(a1 + 9332))
    {
      *(void *)(a1 + 9176) = *(void *)(a1 + 9136);
      long long v17 = *(_OWORD *)(a1 + 9120);
      *(_OWORD *)(a1 + 9144) = *(_OWORD *)(a1 + 9104);
      *(_OWORD *)(a1 + 9160) = v17;
      *(void *)(a1 + 9144) = 0x40D7700000000000;
    }
  }
  if (a2) {
    *a2 = v14;
  }
  if (a3) {
    *a3 = v16;
  }
}

void sub_38868(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyUWBSSupport");
  if (value)
  {
    uint64_t v5 = value;
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL)
    {
      uint64_t v6 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_68834(v6, v7, v8, v9, v10, v11, v12, v13);
      }
      if (sub_5CB00()) {
        goto LABEL_64;
      }
    }
    BOOL v75 = xpc_BOOL_get_value(v5);
  }
  else
  {
    uint64_t v14 = qword_A1B20;
    BOOL v75 = 0;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "InitializePublishedProperties no UWBS Mono published", buf, 2u);
      BOOL v75 = 0;
    }
  }
  xpc_object_t v15 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyUWBSStereoSupport");
  if (xpc_get_type(v15) != (xpc_type_t)&_xpc_type_BOOL)
  {
    double v16 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_687BC(v16, v17, v18, v19, v20, v21, v22, v23);
    }
    if (sub_5CB00()) {
      goto LABEL_64;
    }
  }
  if (v15)
  {
    LODWORD(v15) = xpc_BOOL_get_value(v15);
  }
  else
  {
    __int16 v24 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v24, OS_LOG_TYPE_DEFAULT, "InitializePublishedProperties no UWBS Stereo published", buf, 2u);
      LODWORD(v15) = 0;
    }
  }
  xpc_object_t v25 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertySWBSupport");
  __int16 v26 = v25;
  if (v25)
  {
    if (xpc_get_type(v25) != (xpc_type_t)&_xpc_type_BOOL)
    {
      int v27 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_68744(v27, v28, v29, v30, v31, v32, v33, v34);
      }
      if (sub_5CB00()) {
        goto LABEL_64;
      }
    }
    LODWORD(v26) = xpc_BOOL_get_value(v26);
  }
  else
  {
    uint64_t v35 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v35, OS_LOG_TYPE_DEFAULT, "InitializePublishedProperties no SWB Mono published", buf, 2u);
      LODWORD(v26) = 0;
    }
  }
  uint64_t v36 = (_WORD *)(a1 + 9326);
  xpc_object_t v37 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertySWBStereoSupport");
  uint64_t v38 = v37;
  if (v37)
  {
    if (xpc_get_type(v37) != (xpc_type_t)&_xpc_type_BOOL)
    {
      uint64_t v39 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_686CC(v39, v40, v41, v42, v43, v44, v45, v46);
      }
      if (sub_5CB00()) {
        goto LABEL_64;
      }
    }
    LODWORD(v38) = xpc_BOOL_get_value(v38);
  }
  else
  {
    uint64_t v47 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      int v48 = *(unsigned __int8 *)(a1 + 9327);
      *(_DWORD *)std::string buf = 67109120;
      BOOL v77 = v48;
      _os_log_impl(&dword_0, v47, OS_LOG_TYPE_DEFAULT, "InitializePublishedProperties invalid SWB Stereo published, mSWB:%u", buf, 8u);
      LODWORD(v38) = 0;
    }
  }
  xpc_object_t v49 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyAACELDStereo48KSupport");
  BOOL v50 = v49;
  if (v49)
  {
    if (xpc_get_type(v49) != (xpc_type_t)&_xpc_type_BOOL)
    {
      xpc_object_t v51 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
        sub_68654(v51, v52, v53, v54, v55, v56, v57, v58);
      }
      if (sub_5CB00()) {
        goto LABEL_64;
      }
    }
    LODWORD(v50) = xpc_BOOL_get_value(v50);
  }
  else
  {
    uint64_t v59 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      int v60 = *(unsigned __int8 *)(a1 + 9327);
      *(_DWORD *)std::string buf = 67109120;
      BOOL v77 = v60;
      _os_log_impl(&dword_0, v59, OS_LOG_TYPE_DEFAULT, "InitializePublishedProperties invalid SWB Stereo fake published, mSWB:%u", buf, 8u);
      LODWORD(v50) = 0;
    }
  }
  xpc_object_t v61 = xpc_dictionary_get_value(xdict, "kBTAudioMsgPropertyAACELDStereo48K10msSupport");
  int v62 = _os_feature_enabled_impl();
  BOOL v63 = 0;
  if (!v62 || !v61) {
    goto LABEL_48;
  }
  if (xpc_get_type(v61) != (xpc_type_t)&_xpc_type_BOOL)
  {
    uint64_t v64 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_685DC(v64, v65, v66, v67, v68, v69, v70, v71);
    }
    if (sub_5CB00()) {
LABEL_64:
    }
      abort();
  }
  BOOL v63 = xpc_BOOL_get_value(v61);
LABEL_48:
  if (v50)
  {
    int v72 = 129;
  }
  else if (v38)
  {
    int v72 = 255;
  }
  else
  {
    int v72 = v15 << 7;
  }
  *(_DWORD *)(a1 + 9328) = v72;
  if (v63) {
    int v73 = 130;
  }
  else {
    int v73 = 0;
  }
  *(_DWORD *)(a1 + 9336) = v73;
  *(_DWORD *)(a1 + 9332) = v15 << 7;
  int v74 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67110912;
    BOOL v77 = v75;
    __int16 v78 = 1024;
    int v79 = (int)v15;
    __int16 v80 = 1024;
    int v81 = (int)v26;
    __int16 v82 = 1024;
    int v83 = (int)v38;
    __int16 v84 = 1024;
    int v85 = (int)v50;
    __int16 v86 = 1024;
    int v87 = v72;
    __int16 v88 = 1024;
    int v89 = v73;
    __int16 v90 = 1024;
    int v91 = v15 << 7;
    _os_log_impl(&dword_0, v74, OS_LOG_TYPE_DEFAULT, "HFPStereo, SupportedCodecs AACELDMono %u, AACELDStereo %u, LC3Mono %u, LC348kStereo %u, AACELD48KStereo %u, mStereoSupported %u, mStereoSupported10ms %u, mStereoSupported24K %u", buf, 0x32u);
  }
  if (v26)
  {
    *uint64_t v36 = 256;
  }
  else
  {
    *(unsigned char *)(a1 + 9327) = 0;
    *(unsigned char *)uint64_t v36 = v75;
  }
  sub_259B4(*(void *)(*(void *)(a1 + 416) + 9248), *(_DWORD *)(a1 + 9328));
}

uint64_t sub_38DAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a2 == 1650750576)
  {
    v6[0] = xmmword_71750;
    v6[1] = xmmword_71760;
    int v7 = 0;
    (**(void (***)(void, void, uint64_t, _OWORD *, uint64_t))(qword_A2350 + 144))(*(void *)(qword_A2350 + 144), *(unsigned int *)(a1 + 8), 3, v6, a5);
  }
  return sub_90E0();
}

uint64_t sub_38E74(float *a1, int a2, float a3)
{
  a1[108] = a3;
  float v6 = (*(float (**)(float *))(*(void *)a1 + 960))(a1);
  float v7 = a1[108] + -1.0;
  float v8 = v6 - (float)(v7 * (*(float (**)(float *))(*(void *)a1 + 952))(a1));
  a1[110] = v8;
  uint64_t v9 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    double v10 = a1[108];
    double v11 = v8;
    int v12 = (*(uint64_t (**)(float *))(*(void *)a1 + 1280))(a1);
    v17[0] = 134219010;
    uint64_t v13 = "No";
    *(double *)&v17[1] = a3;
    if (a2) {
      uint64_t v13 = "Yes";
    }
    __int16 v18 = 2048;
    double v19 = v10;
    __int16 v20 = 2048;
    double v21 = v11;
    __int16 v22 = 1024;
    int v23 = v12;
    __int16 v24 = 2082;
    xpc_object_t v25 = v13;
    _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "[HF] volume %f, mScalarVolume %f, mDBVolume %f, IsVolumeSupported %d Notify Mx %{public}s", (uint8_t *)v17, 0x30u);
  }
  uint64_t result = (*(uint64_t (**)(float *))(*(void *)a1 + 1280))(a1);
  if (result)
  {
    if (!*((unsigned char *)a1 + 408))
    {
      uint64_t v15 = *((void *)a1 + 50);
      if (v15)
      {
        unsigned __int8 v16 = atomic_load((unsigned __int8 *)(v15 + 24));
        if (v16) {
          sub_181A4(*((void *)a1 + 50), a1[110]);
        }
      }
    }
    if ((a2 & 1) != 0 || (uint64_t result = sub_395B4(), result))
    {
      strcpy((char *)v17, "dlovptuo");
      BYTE1(v17[2]) = 0;
      HIWORD(v17[2]) = 0;
      return (*(uint64_t (**)(float *, _DWORD *))(*(void *)a1 + 248))(a1, v17);
    }
  }
  return result;
}

void sub_390E4(void *a1, float a2)
{
  uint64_t v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = (*(uint64_t (**)(void *))(*a1 + 1280))(a1);
    int v7 = 134218240;
    double v8 = a2;
    __int16 v9 = 1024;
    int v10 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Input volume mScalarVolume %f, IsVolumeSupported %d", (uint8_t *)&v7, 0x12u);
  }
  if ((*(unsigned int (**)(void *))(*a1 + 1280))(a1))
  {
    float v6 = (id *)a1[26];
    if (v6) {
      sub_14558(v6, a2);
    }
  }
}

void sub_39228(uint64_t a1, void *a2)
{
  int v2 = *(id **)(a1 + 208);
  if (v2)
  {
    CFStringRef v4 = (const __CFString *)[a2 objectForKeyedSubscript:@"CurrentAudioCategory"];
    id v5 = [a2 objectForKeyedSubscript:@"CurrentVolume"];
    id v6 = [a2 objectForKeyedSubscript:@"ManualVolumeUpdate"];
    id v7 = [a2 objectForKeyedSubscript:@"RampInProgress"];
    sub_15558(v2, v4, v5, v6, v7);
  }
}

void sub_392E8(float *a1, float a2)
{
  a1[110] = a2;
  float v4 = (*(float (**)(float *))(*(void *)a1 + 960))(a1) - a1[110];
  float v5 = (float)(v4 / (*(float (**)(float *))(*(void *)a1 + 952))(a1)) + 1.0;
  a1[108] = v5;
  id v6 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    double v7 = a1[110];
    int v8 = (*(uint64_t (**)(float *))(*(void *)a1 + 1280))(a1);
    int v12 = 134218752;
    double v13 = a2;
    __int16 v14 = 2048;
    double v15 = v5;
    __int16 v16 = 2048;
    double v17 = v7;
    __int16 v18 = 1024;
    int v19 = v8;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "volume %f, mScalarVolume %f, mDBVolume %f, IsVolumeSupported %d", (uint8_t *)&v12, 0x26u);
  }
  if ((*(unsigned int (**)(float *))(*(void *)a1 + 1280))(a1))
  {
    if (*((unsigned char *)a1 + 408))
    {
      __int16 v9 = (id *)*((void *)a1 + 26);
      if (v9) {
        sub_146B4(v9, a1[108]);
      }
    }
    else
    {
      uint64_t v10 = *((void *)a1 + 50);
      if (v10)
      {
        unsigned __int8 v11 = atomic_load((unsigned __int8 *)(v10 + 24));
        if (v11) {
          sub_181A4(*((void *)a1 + 50), a1[110]);
        }
      }
    }
  }
}

uint64_t sub_394F0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 248))();
}

void *sub_39518@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *(void *)(result[52] + 9248);
  if (*(char *)(v2 + 31) < 0) {
    return sub_B9AC((unsigned char *)a2, *(void **)(v2 + 8), *(void *)(v2 + 16));
  }
  long long v3 = *(_OWORD *)(v2 + 8);
  *(void *)(a2 + 16) = *(void *)(v2 + 24);
  *(_OWORD *)a2 = v3;
  return result;
}

uint64_t sub_39548(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 416) + 9248) + 277);
}

size_t sub_39558(uint64_t a1, char *a2, size_t a3)
{
  return sub_1FA14(a1 + 120, a2, a3);
}

double sub_39560(uint64_t a1)
{
  (*(void (**)(double *__return_ptr))(*(void *)a1 + 800))(v2);
  return v2[0];
}

uint64_t sub_395B4()
{
  return 0;
}

void sub_395BC(uint64_t a1, int a2, __CFDictionary **a3)
{
  uint64_t valuePtr = 0;
  uint64_t v26 = 0;
  uint64_t v33 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v32 = 0;
  *(_OWORD *)xpc_object_t values = 0u;
  long long v30 = 0u;
  *(_OWORD *)keys = *(_OWORD *)off_8F210;
  long long v28 = *(_OWORD *)off_8F220;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, (char *)&valuePtr + 4);
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, &valuePtr);
  CFNumberRef v7 = v6;
  if (a3)
  {
    if (v5 && v6 != 0)
    {
      CFArrayRef v9 = 0;
      if (a2 <= 4)
      {
        if (a2 == 1)
        {
          HIDWORD(v26) = 1;
          CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v26 + 4);
          int v11 = 1163984896;
        }
        else
        {
          if (a2 != 2) {
            goto LABEL_47;
          }
          HIDWORD(v26) = 2;
          CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v26 + 4);
          int v11 = 1128792064;
        }
        LODWORD(v26) = v11;
        CFNumberRef v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, &v26);
        CFNumberRef v13 = v17;
        if (v10) {
          BOOL v18 = v17 == 0;
        }
        else {
          BOOL v18 = 1;
        }
        if (!v18)
        {
          values[0] = v10;
          values[1] = v17;
          *(void *)&long long v30 = v5;
          *((void *)&v30 + 1) = v7;
          CFTypeRef cf = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (cf)
          {
            CFAllocatorRef v19 = kCFAllocatorDefault;
            CFIndex v20 = 1;
LABEL_37:
            CFArrayRef v9 = CFArrayCreate(v19, &cf, v20, &kCFTypeArrayCallBacks);
            double v15 = *a3;
            CFStringRef v16 = @"BT_EQValuesDownlink";
            goto LABEL_38;
          }
          goto LABEL_54;
        }
LABEL_44:
        CFArrayRef v9 = 0;
        if (!v10)
        {
          if (!v13) {
            goto LABEL_47;
          }
          goto LABEL_46;
        }
LABEL_55:
        CFRelease(v10);
        if (!v13) {
          goto LABEL_47;
        }
LABEL_46:
        CFRelease(v13);
        goto LABEL_47;
      }
      if (a2 == 12)
      {
        HIDWORD(v26) = 2;
        CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v26 + 4);
        LODWORD(v26) = 1128792064;
        CFNumberRef v21 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, &v26);
        CFNumberRef v13 = v21;
        if (v10) {
          BOOL v22 = v21 == 0;
        }
        else {
          BOOL v22 = 1;
        }
        if (v22) {
          goto LABEL_44;
        }
        values[0] = v10;
        values[1] = v21;
        *(void *)&long long v30 = v5;
        *((void *)&v30 + 1) = v7;
        CFDictionaryRef v23 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        CFTypeRef cf = v23;
        if (v23)
        {
          HIDWORD(v26) = 1;
          CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v26 + 4);
          LODWORD(v26) = 1163984896;
          CFNumberRef v24 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, &v26);
          CFNumberRef v13 = v24;
          if (v10 && v24)
          {
            values[0] = v10;
            values[1] = v24;
            *(void *)&long long v30 = v5;
            *((void *)&v30 + 1) = v7;
            CFTypeRef v32 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (v32)
            {
              CFAllocatorRef v19 = kCFAllocatorDefault;
              CFIndex v20 = 2;
              goto LABEL_37;
            }
            goto LABEL_54;
          }
          goto LABEL_44;
        }
      }
      else
      {
        if (a2 != 5) {
          goto LABEL_47;
        }
        HIDWORD(v26) = 5;
        CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v26 + 4);
        CFNumberRef v12 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, &v26);
        CFNumberRef v13 = v12;
        if (v10) {
          BOOL v14 = v12 == 0;
        }
        else {
          BOOL v14 = 1;
        }
        if (v14) {
          goto LABEL_44;
        }
        values[0] = v10;
        values[1] = v12;
        *(void *)&long long v30 = v5;
        *((void *)&v30 + 1) = v7;
        uint64_t v33 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 4, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v33)
        {
          CFArrayRef v9 = CFArrayCreate(kCFAllocatorDefault, (const void **)&v33, 1, &kCFTypeArrayCallBacks);
          double v15 = *a3;
          CFStringRef v16 = @"BT_EQValuesUplink";
LABEL_38:
          CFDictionaryAddValue(v15, v16, v9);
          goto LABEL_55;
        }
      }
LABEL_54:
      CFArrayRef v9 = 0;
      goto LABEL_55;
    }
  }
  CFArrayRef v9 = 0;
  if (!v5)
  {
    if (!v6) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
LABEL_47:
  CFRelease(v5);
  if (v7) {
LABEL_12:
  }
    CFRelease(v7);
LABEL_13:
  if (v33) {
    CFRelease(v33);
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v32) {
    CFRelease(v32);
  }
  if (v9) {
    CFRelease(v9);
  }
}

void sub_399AC(uint64_t a1, unsigned int a2, CFMutableDictionaryRef *a3)
{
  int valuePtr = 1;
  unsigned int v16 = a2;
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v6 = v5;
  if (a3 && v5)
  {
    if (a2 >= 7)
    {
      unsigned int v16 = a2 - 6;
      CFDictionaryAddValue(*a3, @"BT_EQLevelUplink", v5);
      sub_395BC(v7, 5, a3);
    }
    CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v16);
    if (v8)
    {
      CFNumberRef v9 = v8;
      int v10 = v16;
      switch(v16)
      {
        case 1u:
        case 2u:
          int v11 = 2;
          goto LABEL_14;
        case 3u:
        case 4u:
          int v11 = 12;
          goto LABEL_14;
        case 5u:
        case 6u:
          int v11 = 1;
LABEL_14:
          sub_395BC((uint64_t)v8, v11, a3);
          CFDictionaryAddValue(*a3, @"BT_EQLevelDownlink", v9);
          break;
        default:
          BOOL v14 = qword_A1B20;
          if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR)) {
            sub_688E0(v10, v14);
          }
          break;
      }
      CFNumberRef v12 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
      {
        CFMutableDictionaryRef v13 = *a3;
        *(_DWORD *)std::string buf = 138543362;
        CFMutableDictionaryRef v18 = v13;
        _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "EQ settings are %{public}@", buf, 0xCu);
      }
      CFRelease(v9);
    }
    else if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR))
    {
      sub_688AC();
    }
    goto LABEL_18;
  }
  if (v5) {
LABEL_18:
  }
    CFRelease(v6);
}

CFDictionaryRef sub_39BB4(_DWORD *a1)
{
  int v2 = a1[2327];
  int v18 = 0;
  BOOL v19 = v2 == 0;
  uint64_t v17 = 0;
  BOOL valuePtr = v19;
  int v16 = 0;
  if (!v2 && ((*(uint64_t (**)(_DWORD *))(*(void *)a1 + 1296))(a1) & 1) == 0)
  {
    int v3 = a1[2326];
    if (v3 != 1)
    {
      if (v3 == 2 || v3 == 3)
      {
        uint64_t v17 = 0x141000000;
        int v16 = 0;
        goto LABEL_9;
      }
      int v3 = 1;
    }
    HIDWORD(v17) = v3;
    int v16 = 1086324736;
    LODWORD(v17) = 1077936128;
  }
LABEL_9:
  CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, &v18);
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, (char *)&v17 + 4);
  CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, &v17);
  CFNumberRef v8 = CFNumberCreate(kCFAllocatorDefault, kCFNumberFloat32Type, &v16);
  CFNumberRef v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v19);
  *(_OWORD *)keys = *(_OWORD *)off_8F230;
  long long v24 = *(_OWORD *)off_8F240;
  long long v25 = *(_OWORD *)off_8F250;
  values[0] = v4;
  values[1] = v5;
  values[2] = v6;
  values[3] = v7;
  values[4] = v8;
  values[5] = v9;
  CFDictionaryRef v10 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 6, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef theDict = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 11, v10);
  CFRelease(v10);
  sub_39E50((uint64_t)a1, a1[2328], &theDict);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, theDict);
  CFNumberRef v12 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138543362;
    CFDictionaryRef v21 = Copy;
    _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "DSP disctionary settings are %{public}@", buf, 0xCu);
  }
  CFRelease(v6);
  CFRelease(v5);
  CFRelease(v4);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(v9);
  CFRelease(theDict);
  return Copy;
}

void sub_39E50(uint64_t a1, unsigned int a2, CFMutableDictionaryRef *a3)
{
  *(_DWORD *)(a1 + 9312) = a2;
  if (a2)
  {
    unsigned int v4 = a2;
    CFNumberRef v6 = qword_A1B20;
    BOOL v7 = os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      v8[0] = 67109120;
      v8[1] = v4;
      _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Adding eq setting %d", (uint8_t *)v8, 8u);
      unsigned int v4 = *(_DWORD *)(a1 + 9312);
    }
    sub_399AC(v7, v4, a3);
  }
}

uint64_t sub_39F18(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 9340);
  unsigned int v2 = v1 - 128;
  BOOL v3 = v1 == 255;
  return v2 < 3 || v3;
}

double sub_39F38(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 9328);
  if (v2 != 129 && v2 != 255 && *(_DWORD *)(a1 + 9336) != 130) {
    goto LABEL_9;
  }
  int v3 = *(_DWORD *)(a1 + 9340);
  if ((v3 - 129) < 2)
  {
    double v5 = 48000.0;
    goto LABEL_16;
  }
  if (v3)
  {
    if (v3 == 128)
    {
      unsigned int v4 = (double *)&unk_71000;
LABEL_11:
      double v5 = v4[19];
      goto LABEL_16;
    }
    double v5 = 8000.0;
  }
  else
  {
LABEL_9:
    unsigned int v4 = (double *)&unk_71000;
    if (v2 == 128 && *(_DWORD *)(a1 + 9340)) {
      goto LABEL_11;
    }
    double v5 = 24000.0;
    if (!*(unsigned char *)(a1 + 9327) && !*(unsigned char *)(a1 + 9326)) {
      double v5 = *(double *)&qword_71710[*(unsigned char *)(a1 + 9325) == 0];
    }
  }
LABEL_16:
  CFNumberRef v6 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)(a1 + 9340);
    int v9 = 134218496;
    double v10 = v5;
    __int16 v11 = 1024;
    int v12 = v7;
    __int16 v13 = 1024;
    int v14 = v2;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "GetBestSampleRate:%f mStereoSelected:%d mStereoSupported:%d", (uint8_t *)&v9, 0x18u);
  }
  return v5;
}

uint64_t sub_3A0B0(uint64_t a1, double a2)
{
  unsigned int v4 = (unsigned char *)(a1 + 9325);
  if (*(unsigned char *)(a1 + 9326) && *(unsigned char *)(a1 + 9345)) {
    return 4294956445;
  }
  CFNumberRef v6 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int16 v13 = 134217984;
    *(double *)&v13[4] = a2;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "HFPStereo, Update Sampling Rate %f", v13, 0xCu);
  }
  if (v4[29])
  {
    if (a2 > 16000.0 && *v4 != 0)
    {
      CFNumberRef v8 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__int16 v13 = 134217984;
        *(void *)&v13[4] = 0x40CF400000000000;
        _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "HFP sample Rate Limited to %f", v13, 0xCu);
      }
      a2 = 16000.0;
    }
    long long v9 = *(_OWORD *)(a1 + 9280);
    *(_OWORD *)(a1 + 296) = *(_OWORD *)(a1 + 9264);
    *(_OWORD *)(a1 + 312) = v9;
    *(void *)(a1 + 328) = *(void *)(a1 + 9296);
  }
  else
  {
    sub_385F0(a1, 0, 0);
  }
  double v10 = *(double *)(a1 + 296);
  if (v10 != a2)
  {
    if (*(_DWORD *)(a1 + 9340))
    {
      __int16 v11 = qword_A1B20;
      if (*(_DWORD *)(a1 + 9328))
      {
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = *(void *)(a1 + 9104);
          *(_DWORD *)__int16 v13 = 134218496;
          *(double *)&v13[4] = a2;
          __int16 v14 = 2048;
          double v15 = v10;
          __int16 v16 = 2048;
          uint64_t v17 = v12;
          _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "HFPStereo, sample Rate between host codec changed to %f, %f, %f", v13, 0x20u);
        }
        (*(void (**)(unsigned char *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(v13, a1, 0);
        (*(void (**)(uint64_t, void))(*(void *)a1 + 1472))(a1, *(double *)v13);
        return 0;
      }
    }
    else
    {
      __int16 v11 = qword_A1B20;
    }
    *(double *)(a1 + 296) = a2;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int16 v13 = 134217984;
      *(double *)&v13[4] = a2;
      _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "HFPStereo, Rate changed to %f", v13, 0xCu);
      a2 = *(double *)(a1 + 296);
    }
    (*(void (**)(uint64_t, void))(*(void *)a1 + 1472))(a1, a2);
  }
  return 0;
}

void sub_3A3A8(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 416);
  if (v4 && (uint64_t v5 = *(void *)(v4 + 9248)) != 0) {
    int v6 = *(unsigned __int8 *)(v5 + 221);
  }
  else {
    int v6 = 0;
  }
  int v7 = *(_DWORD *)(a1 + 9340);
  if (sub_395B4())
  {
    unsigned int v8 = *(_DWORD *)(a1 + 9328);
    if (!v8) {
      return;
    }
    *(_DWORD *)(a1 + 9340) = v8;
    long long v9 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 67109888;
      int v17 = v7;
      __int16 v18 = 1024;
      int v19 = v8;
      __int16 v20 = 1024;
      unsigned int v21 = a2;
      __int16 v22 = 1024;
      unsigned int v23 = v8;
      _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "HFPStereo Output Device Configured to %d -> %d, desired:%d, highest:%d", (uint8_t *)&v16, 0x1Au);
      unsigned int v8 = *(_DWORD *)(a1 + 9340);
    }
    uint64_t v10 = a1;
    unsigned int v11 = v8;
    unsigned int v12 = 0;
  }
  else
  {
    if (sub_395B4()) {
      return;
    }
    if (a2 == 4)
    {
      int v13 = 130;
    }
    else if (a2 < 2 || (int v13 = *(_DWORD *)(a1 + 9328)) == 0)
    {
      int v13 = 0;
    }
    *(_DWORD *)(a1 + 9340) = v13;
    __int16 v14 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v15 = *(_DWORD *)(a1 + 9328);
      int v16 = 67110144;
      int v17 = v7;
      __int16 v18 = 1024;
      int v19 = v13;
      __int16 v20 = 1024;
      unsigned int v21 = a2;
      __int16 v22 = 1024;
      unsigned int v23 = v15;
      __int16 v24 = 1024;
      int v25 = v6;
      _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "HFPStereo Output Device Configured to %d -> %d, desired:%d, highest:%d, game:%d", (uint8_t *)&v16, 0x20u);
      int v13 = *(_DWORD *)(a1 + 9340);
    }
    unsigned int v12 = v13 == 130;
    uint64_t v10 = a1;
    unsigned int v11 = v13;
  }
  sub_3A578(v10, v11, v12);
}

void sub_3A578(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v13 = 0;
  memset(v12, 0, sizeof(v12));
  (*(void (**)(_OWORD *__return_ptr))(*(void *)a1 + 800))(v12);
  unsigned int v6 = ((*(double (**)(uint64_t))(*(void *)a1 + 784))(a1) * 20.0 / 1000.0);
  *(_DWORD *)(a1 + 9440) = v6;
  int v7 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v8 = "BT_TRANSPORT_TYPE_LEGACY";
    *(_DWORD *)std::string buf = 134218754;
    if (a3) {
      unsigned int v8 = "BT_TRANSPORT_TYPE_ADVANCED";
    }
    uint64_t v15 = *(void *)&v12[0];
    __int16 v16 = 1024;
    unsigned int v17 = a2;
    __int16 v18 = 2082;
    int v19 = v8;
    __int16 v20 = 1024;
    unsigned int v21 = v6;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "HFPStereo SendStereoEnable samplerate:%f, codec:%u Transport %{public}s, Max Supported Frame Size %d", buf, 0x22u);
  }
  uint64_t v9 = *(void *)(a1 + 400);
  if (v9)
  {
    float v10 = *(double *)v12;
    sub_18178(v9, v10);
  }
  unsigned int v11 = *(id **)(a1 + 208);
  if (v11) {
    sub_1602C(v11, a2, *(double *)v12, a3);
  }
}

uint64_t sub_3A734(uint64_t result)
{
  if (*(_DWORD *)(result + 9336) == 130)
  {
    uint64_t v1 = result;
    int v2 = qword_A1B20;
    BOOL v3 = os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT);
    unsigned int v4 = 130;
    if (v3)
    {
      int v5 = *(_DWORD *)(v1 + 9340);
      v7[0] = 67109120;
      v7[1] = v5;
      _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "HFPStereo enabled HAoS codec from currCodec%d", (uint8_t *)v7, 8u);
      unsigned int v4 = *(_DWORD *)(v1 + 9336);
    }
    *(_DWORD *)(v1 + 9340) = 130;
    sub_3A578(v1, v4, 1u);
    uint64_t v6 = *(void *)(*(void *)(v1 + 416) + 9248);
    uint64_t result = sub_5CAF8();
    if (result) {
      uint64_t result = _os_feature_enabled_impl();
    }
    *(unsigned char *)(v6 + 222) = result;
  }
  return result;
}

void sub_3A830(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6 = a1 + 9326;
  *(unsigned char *)(a1 + 9352) = a2;
  int v7 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    if (a2) {
      unsigned int v8 = "true";
    }
    else {
      unsigned int v8 = "false";
    }
    (*(void (**)(double *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(&v29, a1, 0);
    double v9 = v29;
    int v10 = *(_DWORD *)(a1 + 9432);
    int v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1312))(a1);
    *(_DWORD *)std::string buf = 136315906;
    uint64_t v35 = v8;
    __int16 v36 = 2048;
    double v37 = v9;
    __int16 v38 = 1024;
    int v39 = v10;
    __int16 v40 = 1024;
    int v41 = v11;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "HFPStereo set kBluetoothAudioDevicePropertySCOIsEnabled : %s, sample rate %f Current State %d, owned %d", buf, 0x22u);
  }
  sub_5CA94(33, a2, (unint64_t)*(double *)(a1 + 296), 0, 0);
  if (a3 == 1920364387) {
    sub_5CA2C(5);
  }
  if (*(unsigned char *)(v6 + 26))
  {
    int v12 = *(_DWORD *)(a1 + 9348);
    *(_WORD *)(v6 + 20) = 1;
    double v13 = *(double *)(a1 + 296);
    if (v12 == 1935765619)
    {
      if (v13 == 16000.0) {
        int v12 = 1935765620;
      }
      else {
        int v12 = 1935765619;
      }
    }
    if (v13 != 48000.0 && v13 != 24000.0 && v13 != 32000.0)
    {
      *(void *)(a1 + 216) = 0;
      *(void *)(a1 + 224) = 0;
      goto LABEL_39;
    }
    *(_OWORD *)(a1 + 216) = *(_OWORD *)(a1 + 232);
    __int16 v20 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = *(_DWORD *)(a1 + 9340);
      int v22 = *(_DWORD *)(a1 + 9336);
      int v23 = *(_DWORD *)(a1 + 9328);
      LODWORD(v29) = 67109632;
      HIDWORD(v29) = v21;
      __int16 v30 = 1024;
      int v31 = v22;
      __int16 v32 = 1024;
      int v33 = v23;
      _os_log_impl(&dword_0, v20, OS_LOG_TYPE_DEFAULT, "HFPStereo, check codec in trigger sco, mStereoSelected %u, mStereoSupported10ms %u, mStereoSupported %u", (uint8_t *)&v29, 0x14u);
    }
    if (*(_DWORD *)(a1 + 9328))
    {
      int v24 = *(_DWORD *)(a1 + 9340);
      if (v24)
      {
        if (v24 == 128)
        {
          *(_OWORD *)(a1 + 216) = *(_OWORD *)(a1 + 272);
          int v25 = qword_A1B20;
          if (!os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_39;
          }
          LOWORD(v29) = 0;
          uint64_t v26 = "HFPStereo install Stereo 24k encoder";
        }
        else if (v24 == 130)
        {
          *(int8x16_t *)(a1 + 216) = vextq_s8(*(int8x16_t *)(a1 + 256), *(int8x16_t *)(a1 + 256), 8uLL);
          int v25 = qword_A1B20;
          if (!os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_39;
          }
          LOWORD(v29) = 0;
          uint64_t v26 = "HFPStereo install Stereo 10ms encoder";
        }
        else
        {
          *(_OWORD *)(a1 + 216) = *(_OWORD *)(a1 + 248);
          int v25 = qword_A1B20;
          if (!os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_39;
          }
          LOWORD(v29) = 0;
          uint64_t v26 = "HFPStereo install highest stereo encoder";
        }
        _os_log_impl(&dword_0, v25, OS_LOG_TYPE_DEFAULT, v26, (uint8_t *)&v29, 2u);
      }
    }
LABEL_39:
    if (a3 == 1936090482 || a3 == 1919708275) {
      a3 = 1918989668;
    }
    if (!*(_DWORD *)(a1 + 9432)) {
      sub_3AD28(a1, 1);
    }
    long long v28 = *(id **)(a1 + 208);
    if (v28)
    {
      (*(void (**)(double *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(&v29, a1, 0);
      unsigned int v16 = v29;
      unsigned int v17 = v28;
      unsigned int v18 = v12;
      unsigned int v19 = a3;
LABEL_48:
      sub_142FC(v17, v18, v19, v16);
      return;
    }
    return;
  }
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEBUG)) {
    sub_68958();
  }
  *(_WORD *)(v6 + 20) = 256;
  if (*(unsigned char *)v6 && *(unsigned char *)(v6 + 19))
  {
    *(unsigned char *)(v6 + 19) = 0;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059619, (uint64_t)*(double *)(a1 + 296));
  }
  __int16 v14 = *(id **)(a1 + 208);
  if (v14)
  {
    if (*(_DWORD *)(a1 + 9432) == 2)
    {
      sub_3AD28(a1, 3);
      __int16 v14 = *(id **)(a1 + 208);
    }
    unsigned int v15 = *(_DWORD *)(a1 + 9348);
    (*(void (**)(double *__return_ptr, uint64_t, void))(*(void *)a1 + 800))(&v29, a1, 0);
    unsigned int v16 = v29;
    unsigned int v17 = v14;
    unsigned int v18 = v15;
    unsigned int v19 = 0;
    goto LABEL_48;
  }
}

void sub_3AD28(uint64_t a1, int a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = *(_DWORD *)(a1 + 9432);
    v6[0] = 67109376;
    v6[1] = v5;
    __int16 v7 = 1024;
    int v8 = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Set SCOStatus %d ---> %d", (uint8_t *)v6, 0xEu);
  }
  *(_DWORD *)(a1 + 9432) = a2;
}

void sub_3ADE8(uint64_t a1, char *a2, void *a3)
{
  if (!strcasecmp(a2, "kBTAudioMsgPropertyAACELDStereo48K10msSupport"))
  {
    *(_DWORD *)(a1 + 9336) = xpc_BOOL_get_value(a3);
    uint64_t v6 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v7 = 0;
      _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "HFPStereo, mStereoSupported10ms leave us", v7, 2u);
    }
  }
  else
  {
    sub_9B30((uint64_t *)a1, a2, a3);
  }
}

uint64_t sub_3AEB0(uint64_t *a1, unsigned int a2, int a3)
{
  uint64_t v6 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v7 = "tear down";
    if (a2) {
      __int16 v7 = "creation";
    }
    int v9 = 136315138;
    int v10 = v7;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "TriggerSCOAudio: Request eSCO %s ", (uint8_t *)&v9, 0xCu);
  }
  sub_3A830((uint64_t)a1, a2, a3);
  if (a2) {
    return (*(unsigned int (**)(uint64_t *))(*a1 + 1160))(a1) ^ 1;
  }
  if (sub_56B5C(a1[52])) {
    sub_56E00(a1[52]);
  }
  return (*(uint64_t (**)(uint64_t *))(*a1 + 1160))(a1);
}

void sub_3B008(uint64_t a1, int a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a1 + 9432);
  if (a3)
  {
    BOOL v7 = 1;
    if (a2 == 116) {
      int v8 = 1;
    }
    else {
      int v8 = 2;
    }
    sub_3AD28(a1, v8);
  }
  else if (a2)
  {
    if (a2 == 116)
    {
      sub_3AD28(a1, 4);
    }
    else
    {
      if (v6 == 1) {
        sub_4B68(a1, 0);
      }
      sub_3AD28(a1, 0);
      if (sub_395B4())
      {
        sub_49F68(*(void *)(a1 + 416), 1685283695);
        int v9 = qword_A1B20;
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
        {
          int v14 = 67109120;
          LODWORD(v15) = a2;
          _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "eSCO Connect/Disconnect Failed Status: %d", (uint8_t *)&v14, 8u);
        }
      }
    }
    BOOL v7 = 1;
  }
  else
  {
    sub_3AD28(a1, 0);
    BOOL v7 = v6 != 4;
  }
  int v10 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = sub_7904(a1);
    int v12 = *(_DWORD *)(a1 + 9432);
    CFStringRef v13 = @"NO";
    int v14 = 138544386;
    uint64_t v15 = v11;
    if (v7) {
      CFStringRef v13 = @"YES";
    }
    __int16 v16 = 1024;
    int v17 = a2;
    __int16 v18 = 1024;
    int v19 = v6;
    __int16 v20 = 1024;
    int v21 = v12;
    __int16 v22 = 2112;
    CFStringRef v23 = v13;
    _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "[%{public}@] Received Status update from bluetoothd Status %d %d -> %d Notify HAL %@", (uint8_t *)&v14, 0x28u);
  }
  if (v7)
  {
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 392))(a1, a3);
    sub_4AB40(*(void *)(a1 + 416), 1953719151, a3);
  }
}

BOOL sub_3B238(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 461))
  {
    int v2 = *(_DWORD *)(a1 + 9432);
  }
  else
  {
    if (sub_56B5C(*(void *)(a1 + 416))) {
      return 0;
    }
    int v2 = *(unsigned __int8 *)(a1 + 460);
  }
  return v2 != 0;
}

uint64_t sub_3B288(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 416);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 360))();
  }
  return result;
}

void sub_3B2C0(uint64_t a1, int a2)
{
  unsigned int v4 = (unsigned char *)(a1 + 9346);
  atomic_store(a2, (unsigned __int8 *)(a1 + 288));
  uint64_t v11 = 0x676C6F6273636F6ELL;
  int v12 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 248))(a1, &v11);
  if (a2)
  {
    if (!*v4)
    {
      LODWORD(v11) = 1668506479;
      int v5 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)std::string buf = 67109120;
        int v14 = v6;
        _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Taking Audio for mAudioObjectID %d", buf, 8u);
      }
      CFStringRef v7 = @"BluetoothTakeAudioNotification";
LABEL_11:
      (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 248))(a1, &v11);
      DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
      CFNotificationCenterPostNotification(DarwinNotifyCenter, v7, 0, 0, 0);
    }
  }
  else if (!v4[1] && (sub_395B4() & 1) == 0)
  {
    LODWORD(v11) = 1685283695;
    int v8 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)std::string buf = 67109120;
      int v14 = v9;
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Relinquishing Audio for mAudioObjectID %d", buf, 8u);
    }
    CFStringRef v7 = @"BluetoothRelinquishAudioNotification";
    goto LABEL_11;
  }
  *(_WORD *)unsigned int v4 = 0;
  v4[7] = a2;
}

uint64_t sub_3B49C(_DWORD *a1, int a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = "disabled";
    if (a2) {
      int v5 = "enabled";
    }
    int v6 = "enable";
    if (a2) {
      int v6 = "disable";
    }
    v8[0] = 136446466;
    *(void *)&v8[1] = v5;
    __int16 v9 = 2082;
    int v10 = v6;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BT HFP device set ecnr is %{public}s. AG will %{public}s EC/NR.", (uint8_t *)v8, 0x16u);
  }
  a1[2327] = a2;
  strcpy((char *)v8, "rncebolg");
  BYTE1(v8[2]) = 0;
  HIWORD(v8[2]) = 0;
  return (*(uint64_t (**)(_DWORD *, _DWORD *))(*(void *)a1 + 248))(a1, v8);
}

uint64_t sub_3B5C0(uint64_t a1, int a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BT set NBS (CVSD) is %d", (uint8_t *)v6, 8u);
  }
  *(unsigned char *)(a1 + 9324) = a2;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059619, (uint64_t)*(double *)(a1 + 296));
}

uint64_t sub_3B6AC(uint64_t a1)
{
  return (*(double *)(a1 + 296)
                      * ((double)(*(_DWORD *)(a1 + 384) + *(_DWORD *)(a1 + 388))
                       / 1000000.0));
}

uint64_t sub_3B6D8(uint64_t a1, int a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BT set WBS (mSBC) is %d", (uint8_t *)v6, 8u);
  }
  *(unsigned char *)(a1 + 9325) = a2;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059619, (uint64_t)*(double *)(a1 + 296));
}

uint64_t sub_3B7C4(uint64_t a1, int a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BT set UWBS (AAC-ELD) is %d", (uint8_t *)v6, 8u);
  }
  *(unsigned char *)(a1 + 9326) = a2;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059619, (uint64_t)*(double *)(a1 + 296));
}

void sub_3B8B0(int *a1, int a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *((void *)a1 + 37);
    LODWORD(v7) = 67109376;
    HIDWORD(v7) = a2;
    __int16 v8 = 2048;
    uint64_t v9 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BT set UWBSStereo: %d, sample rate:%f", (uint8_t *)&v7, 0x12u);
  }
  (*(void (**)(double *__return_ptr, int *, void))(*(void *)a1 + 800))(&v7, a1, 0);
  (*(void (**)(int *, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059619, (uint64_t)v7);
  int v6 = a1[2332];
  if (a2)
  {
    if (!v6)
    {
      int v6 = 128;
LABEL_8:
      a1[2332] = v6;
    }
  }
  else if (v6 == 128)
  {
    int v6 = 0;
    goto LABEL_8;
  }
  sub_259B4(*(void *)(*((void *)a1 + 52) + 9248), v6);
}

void sub_3BA0C(int *a1, int a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *((void *)a1 + 37);
    LODWORD(v7) = 67109376;
    HIDWORD(v7) = a2;
    __int16 v8 = 2048;
    uint64_t v9 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BT set SWBStereo: %d, sample rate:%f", (uint8_t *)&v7, 0x12u);
  }
  (*(void (**)(double *__return_ptr, int *, void))(*(void *)a1 + 800))(&v7, a1, 0);
  (*(void (**)(int *, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059619, (uint64_t)v7);
  int v6 = a1[2332];
  if (a2)
  {
    if (!v6)
    {
      int v6 = 255;
LABEL_8:
      a1[2332] = v6;
    }
  }
  else if (v6 == 255)
  {
    int v6 = 0;
    goto LABEL_8;
  }
  sub_259B4(*(void *)(*((void *)a1 + 52) + 9248), v6);
}

BOOL sub_3BB68(uint64_t a1)
{
  int v2 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(unsigned __int8 *)(a1 + 9344);
    v5[0] = 67109120;
    v5[1] = v3;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BT get UWBSStereoTest: %d", (uint8_t *)v5, 8u);
  }
  return *(unsigned char *)(a1 + 9344) != 0;
}

uint64_t sub_3BC20(unsigned char *a1, unsigned int a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = "NO";
    if (a2) {
      uint64_t v5 = "YES";
    }
    int v7 = 136446210;
    __int16 v8 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "dsp offload support =  %{public}s", (uint8_t *)&v7, 0xCu);
  }
  a1[9355] = a2;
  return (*(uint64_t (**)(unsigned char *, uint64_t, void))(*(void *)a1 + 240))(a1, 1987080038, a2);
}

void sub_3BD20(uint64_t a1)
{
  unsigned int v2 = (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 16))(*(void *)(a1 + 416));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1000))(a1))
  {
    int v3 = 0;
  }
  else
  {
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)(a1 + 288));
    int v3 = v4 & 1;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 1496))(a1);
  uint64_t v5 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1000))(a1);
    int v7 = "YES";
    if (v6) {
      __int16 v8 = "YES";
    }
    else {
      __int16 v8 = "NO";
    }
    unsigned __int8 v9 = atomic_load((unsigned __int8 *)(a1 + 288));
    if ((v9 & 1) == 0) {
      int v7 = "NO";
    }
    *(_DWORD *)std::string buf = 136446722;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v7;
    if (v3) {
      int v10 = "Create new Delayed Disconnect Timer";
    }
    else {
      int v10 = "Not disconnecting eSCO";
    }
    __int16 v14 = 2082;
    uint64_t v15 = v10;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Status : IO = %{public}s eSCO Running = %{public}s Delayed Transport Disconnect: %{public}s", buf, 0x20u);
  }
  if (v3)
  {
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_5CDCC((uint64_t)buf, a1 + 9360);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    void v11[2] = sub_3BFB8;
    _DWORD v11[3] = &unk_8EB30;
    v11[4] = a1;
    unsigned int v12 = v2;
    *(void *)(a1 + 9424) = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v11);
    sub_5CEA4((uint64_t)buf);
    sub_456B0(qword_A2350, 2000, v2, *(void **)(a1 + 9424));
    sub_5CF10(buf);
  }
}

void sub_3BF9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

void *sub_3BFB8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t result = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 40));
  if (result)
  {
    int v3 = result;
    v8[0] = 0;
    v8[1] = 0;
    sub_5CDCC((uint64_t)v8, v1 + 9360);
    unsigned __int8 v4 = *(const void **)(v1 + 9424);
    if (v4)
    {
      _Block_release(v4);
      *(void *)(v1 + 9424) = 0;
    }
    sub_5CEA4((uint64_t)v8);
    uint64_t v5 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v7 = 0;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Delayed Transport Disconnect: Disconnect Timer Fired..Disconnect eSCO", v7, 2u);
    }
    uint64_t v6 = (unsigned char *)v3[1137];
    if (v6)
    {
      if (v6[192]) {
        (*(void (**)(unsigned char *, void, uint64_t, void))(*(void *)v6 + 256))(v6, 0, 1918989668, 0);
      }
    }
    return (void *)sub_5CF10(v8);
  }
  return result;
}

void sub_3C0C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

BOOL sub_3C0D4(uint64_t a1)
{
  v9[0] = 0;
  v9[1] = 0;
  sub_5CDCC((uint64_t)v9, a1 + 9360);
  unsigned int v2 = *(void **)(a1 + 9424);
  if (v2)
  {
    intptr_t v3 = dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 9424));
    BOOL v4 = v3 == 0;
    if (!v3)
    {
      uint64_t v5 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Delayed Transport Disconnect: Cancelling current Dispatch", buf, 2u);
        unsigned int v2 = *(void **)(a1 + 9424);
      }
      dispatch_block_cancel(v2);
    }
    *(void *)(a1 + 9424) = 0;
  }
  else
  {
    BOOL v4 = 0;
  }
  uint64_t v6 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    unsigned __int8 v7 = atomic_load((unsigned __int8 *)(a1 + 288));
    *(_DWORD *)std::string buf = 67109376;
    BOOL v11 = v4;
    __int16 v12 = 1024;
    int v13 = v7 & 1;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Delayed Transport Disconnect: cancelled block = %d Transport  = %d", buf, 0xEu);
  }
  sub_5CF10(v9);
  return v4;
}

uint64_t sub_3C230(unsigned __int8 *a1)
{
  if ((*(uint64_t (**)(unsigned __int8 *))(*(void *)a1 + 992))(a1)) {
    return 1;
  }
  unsigned __int8 v2 = atomic_load(a1 + 288);
  if (v2) {
    return 1;
  }
  intptr_t v3 = *(uint64_t (**)(unsigned __int8 *))(*(void *)a1 + 1176);

  return v3(a1);
}

uint64_t sub_3C2D8(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 9352);
}

void sub_3C2E4(uint64_t a1)
{
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1280))(a1))
  {
    if (*(unsigned char *)(a1 + 408))
    {
      unsigned __int8 v2 = *(id **)(a1 + 208);
      if (v2)
      {
        intptr_t v3 = qword_A1B20;
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
        {
          double v4 = *(float *)(a1 + 432);
          int v5 = 134217984;
          double v6 = v4;
          _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "HFPAudioDevice: volume update back to headphone %f", (uint8_t *)&v5, 0xCu);
          unsigned __int8 v2 = *(id **)(a1 + 208);
        }
        sub_146B4(v2, *(float *)(a1 + 432));
      }
    }
  }
}

uint64_t sub_3C3E4(uint64_t a1, int *a2)
{
  int v2 = *a2;
  if (*a2 > 1701015153)
  {
    if (v2 <= 1935896429)
    {
      BOOL v3 = v2 == 1701015154;
      int v4 = 1852992613;
    }
    else
    {
      BOOL v3 = v2 == 1935896430 || v2 == 1935959404;
      int v4 = 1987080038;
    }
  }
  else if (v2 <= 1668510817)
  {
    BOOL v3 = v2 == 1650750320;
    int v4 = 1668506479;
  }
  else
  {
    BOOL v3 = v2 == 1668510818 || v2 == 1684234612;
    int v4 = 1685283695;
  }
  if (v3 || v2 == v4) {
    return 1;
  }
  else {
    return sub_949C();
  }
}

uint64_t sub_3C4A0(uint64_t a1, int *a2, unsigned char *a3)
{
  int v3 = *a2;
  if (*a2 > 1701015153)
  {
    if (v3 <= 1935896429)
    {
      if (v3 != 1701015154)
      {
        int v4 = 1852992613;
        goto LABEL_14;
      }
    }
    else
    {
      if (v3 == 1935896430)
      {
        *a3 = 1;
        return 0;
      }
      if (v3 != 1935959404)
      {
        int v4 = 1987080038;
        goto LABEL_14;
      }
    }
LABEL_15:
    *a3 = 0;
    return 0;
  }
  if (v3 <= 1668510817)
  {
    if (v3 != 1650750320)
    {
      int v4 = 1668506479;
      goto LABEL_14;
    }
    goto LABEL_15;
  }
  if (v3 == 1668510818 || v3 == 1684234612) {
    goto LABEL_15;
  }
  int v4 = 1685283695;
LABEL_14:
  if (v3 == v4) {
    goto LABEL_15;
  }
  return sub_94A4();
}

uint64_t sub_3C584(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, int *a5)
{
  *a5 = 0;
  int v6 = *a2;
  if (*a2 <= 1701015153)
  {
    if (v6 > 1668641651)
    {
      if (v6 == 1668641652)
      {
        uint64_t result = sub_94AC();
        *a5 += 120;
        return result;
      }
      if (v6 == 1684234612)
      {
LABEL_25:
        int v9 = 4;
        goto LABEL_26;
      }
      int v7 = 1685283695;
    }
    else
    {
      if (v6 == 1650750320)
      {
        int v9 = 8;
        goto LABEL_26;
      }
      if (v6 == 1668506479) {
        goto LABEL_25;
      }
      int v7 = 1668510818;
    }
    goto LABEL_24;
  }
  if (v6 > 1935896429)
  {
    if (v6 == 1935896430 || v6 == 1935959404) {
      goto LABEL_25;
    }
    int v7 = 1987080038;
LABEL_24:
    if (v6 == v7) {
      goto LABEL_25;
    }
    goto LABEL_30;
  }
  if (v6 == 1701015154 || v6 == 1852992613) {
    goto LABEL_25;
  }
  if (v6 == 1853059619)
  {
    int v8 = *(unsigned __int8 *)(a1 + 9324);
    if (*(unsigned char *)(a1 + 9324))
    {
      int v8 = 16;
      *a5 = 16;
    }
    if (*(unsigned char *)(a1 + 9325))
    {
      v8 += 16;
      *a5 = v8;
    }
    if (*(unsigned char *)(a1 + 9326))
    {
      v8 += 16;
      *a5 = v8;
    }
    if (!*(_DWORD *)(a1 + 9328)) {
      return 0;
    }
    int v9 = v8 + 16;
LABEL_26:
    *a5 = v9;
    return 0;
  }
LABEL_30:

  return sub_94AC();
}

uint64_t sub_3C728(uint64_t a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int *a7, CFDictionaryRef *a8)
{
  int v12 = *a2;
  if (*a2 <= 1701015153)
  {
    if (v12 <= 1668641651)
    {
      if (v12 == 1650750320)
      {
        CFDictionaryRef v19 = sub_39BB4((_DWORD *)a1);
        uint64_t result = 0;
        *a8 = v19;
        int v18 = 8;
LABEL_61:
        *a7 = v18;
        return result;
      }
      int v13 = 1668506479;
      if (v12 != 1668506479)
      {
        if (v12 == 1668510818)
        {
          uint64_t result = 0;
          int v15 = 1;
LABEL_59:
          *(_DWORD *)a8 = v15;
          goto LABEL_60;
        }
        goto LABEL_63;
      }
LABEL_27:
      uint64_t result = 0;
      *(_DWORD *)a8 = v13;
LABEL_60:
      int v18 = 4;
      goto LABEL_61;
    }
    if (v12 == 1668641652)
    {
      uint64_t result = sub_94B4();
      if (result) {
        return result;
      }
      uint64_t v21 = *a7;
      unsigned int v22 = (a6 - v21) / 0xC;
      if (v22 >= 0xA) {
        unsigned int v22 = 10;
      }
      if (v22)
      {
        int v23 = 0;
        int v24 = (CFDictionaryRef *)((char *)a8 + v21);
        do
        {
          switch(v23)
          {
            case 0:
              *int v24 = 0x7261777764636174;
              int v25 = v24 + 1;
              goto LABEL_52;
            case 1:
              *(void *)((char *)v24 + 12) = 0x7261777773636F6ELL;
              int v25 = (_DWORD *)v24 + 5;
              goto LABEL_52;
            case 2:
              v24[3] = 0x726177776373636FLL;
              int v25 = v24 + 4;
              goto LABEL_52;
            case 3:
              *(void *)((char *)v24 + 36) = 0x726177776473636FLL;
              int v25 = (_DWORD *)v24 + 11;
              goto LABEL_52;
            case 4:
              v24[6] = 0x7261777765636E72;
              int v25 = v24 + 7;
              goto LABEL_52;
            case 5:
              *(void *)((char *)v24 + 60) = 0x726177776E726C65;
              int v25 = (_DWORD *)v24 + 17;
              goto LABEL_52;
            case 6:
              v24[9] = 0x706C737462647370;
              int v25 = v24 + 10;
              goto LABEL_52;
            case 7:
              *(void *)((char *)v24 + 84) = 0x726177777364656CLL;
              int v25 = (_DWORD *)v24 + 23;
              goto LABEL_52;
            case 8:
              v24[12] = 0x7261777761746274;
              int v25 = v24 + 13;
              goto LABEL_52;
            case 9:
              *(void *)((char *)v24 + 108) = 0x7261777776706F66;
              int v25 = (_DWORD *)v24 + 29;
LABEL_52:
              *int v25 = 0;
              break;
            default:
              break;
          }
          ++v23;
        }
        while (v22 != v23);
        LODWORD(v21) = *a7;
      }
      uint64_t result = 0;
      int v18 = v21 + 12 * v22;
      goto LABEL_61;
    }
    if (v12 == 1684234612)
    {
      uint64_t result = 0;
      int v15 = *(_DWORD *)(a1 + 9304);
      goto LABEL_59;
    }
    int v13 = 1685283695;
    if (v12 == 1685283695) {
      goto LABEL_27;
    }
LABEL_63:
    return sub_94B4();
  }
  if (v12 > 1935896429)
  {
    switch(v12)
    {
      case 1935896430:
        uint64_t result = 0;
        unsigned __int8 v26 = atomic_load((unsigned __int8 *)(a1 + 288));
        int v15 = v26 & 1;
        goto LABEL_59;
      case 1935959404:
        uint64_t result = 0;
        int v15 = *(_DWORD *)(a1 + 9320);
        goto LABEL_59;
      case 1987080038:
        uint64_t result = 0;
        int v15 = *(unsigned __int8 *)(a1 + 9355);
        goto LABEL_59;
    }
    goto LABEL_63;
  }
  if (v12 == 1701015154)
  {
    uint64_t result = 0;
    int v15 = *(_DWORD *)(a1 + 9308);
    goto LABEL_59;
  }
  if (v12 != 1852992613)
  {
    if (v12 == 1853059619)
    {
      unsigned int v16 = 0;
      unsigned int v17 = a6 >> 4;
      if (a6 >> 4 >= 3) {
        unsigned int v17 = 3;
      }
      if (v17 && *(unsigned char *)(a1 + 9324))
      {
        *(int64x2_t *)a8 = vdupq_n_s64(0x40BF400000000000uLL);
        unsigned int v16 = 1;
      }
      if (v16 < v17 && *(unsigned char *)(a1 + 9325)) {
        *(int64x2_t *)&a8[2 * v16++] = vdupq_n_s64(0x40CF400000000000uLL);
      }
      if (*(unsigned char *)(a1 + 9326) && !*(unsigned char *)(a1 + 9345) && v16 < v17) {
        *(int64x2_t *)&a8[2 * v16++] = vdupq_n_s64(0x40D7700000000000uLL);
      }
      uint64_t result = 0;
      int v18 = 16 * v16;
      goto LABEL_61;
    }
    goto LABEL_63;
  }
  if (*(_DWORD *)(a1 + 9308)) {
    int v20 = *(_DWORD *)(a1 + 9316);
  }
  else {
    int v20 = 4;
  }
  uint64_t result = 0;
  *(_DWORD *)a8 = v20;
  *a7 = 4;
  return result;
}

uint64_t sub_3CB6C(uint64_t a1, _DWORD *a2, uint64_t a3, int *a4, uint64_t a5, unsigned char *a6)
{
  if (*a2 == 1935896430)
  {
    sub_3A830(a1, *a6 != 0, *a4);
    return 0;
  }
  else
  {
    return sub_94BC();
  }
}

uint64_t sub_3CBC4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 240))();
}

uint64_t sub_3CBEC(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, int *a6)
{
  *a6 = 0;
  if (*a3 != 1936092513 && *a3 != 1885762657) {
    return sub_94D4();
  }
  int v7 = *(unsigned __int8 *)(a1 + 9324);
  if (*(unsigned char *)(a1 + 9324))
  {
    int v7 = 56;
    *a6 = 56;
  }
  if (*(unsigned char *)(a1 + 9325))
  {
    v7 += 56;
    *a6 = v7;
  }
  if (*(unsigned char *)(a1 + 9326))
  {
    v7 += 56;
    *a6 = v7;
  }
  if (*(_DWORD *)(a1 + 9328)) {
    *a6 = v7 + 56;
  }
  return 0;
}

uint64_t sub_3CC64(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, _DWORD *a8, uint64_t a9)
{
  if (*a3 == 1936092513 || *a3 == 1885762657)
  {
    int v13 = (unsigned char *)(a1 + 9324);
    uint64_t v29 = 0;
    long long v27 = 0u;
    long long v28 = 0u;
    uint64_t v14 = sub_11C98(a2);
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 800))(&v27, a1, v14);
    if (a7 / 0x38 >= 4) {
      unsigned int v15 = 4;
    }
    else {
      unsigned int v15 = a7 / 0x38;
    }
    if (v15) {
      BOOL v16 = *v13 == 0;
    }
    else {
      BOOL v16 = 1;
    }
    if (v16)
    {
      unsigned int v19 = 0;
    }
    else
    {
      *(void *)&long long v27 = 0x40BF400000000000;
      *(void *)(a9 + 32) = v29;
      long long v18 = v28;
      *(_OWORD *)a9 = v27;
      *(_OWORD *)(a9 + 16) = v18;
      *(int64x2_t *)(a9 + 40) = vdupq_n_s64(0x40BF400000000000uLL);
      unsigned int v19 = 1;
    }
    if (v19 < v15 && *(unsigned char *)(a1 + 9325) != 0)
    {
      *(void *)&long long v27 = 0x40CF400000000000;
      uint64_t v21 = a9 + 56 * v19;
      *(void *)(v21 + 32) = v29;
      long long v22 = v28;
      *(_OWORD *)uint64_t v21 = v27;
      *(_OWORD *)(v21 + 16) = v22;
      *(int64x2_t *)(v21 + 40) = vdupq_n_s64(0x40CF400000000000uLL);
      ++v19;
    }
    if (*(unsigned char *)(a1 + 9326) && !*(unsigned char *)(a1 + 9345) && v19 < v15)
    {
      *(void *)&long long v27 = 0x40D7700000000000;
      uint64_t v23 = a9 + 56 * v19;
      *(void *)(v23 + 32) = v29;
      long long v24 = v28;
      *(_OWORD *)uint64_t v23 = v27;
      *(_OWORD *)(v23 + 16) = v24;
      *(int64x2_t *)(v23 + 40) = vdupq_n_s64(0x40D7700000000000uLL);
      ++v19;
    }
    if (*(_DWORD *)(a1 + 9328) && !*(unsigned char *)(a1 + 9345) && v19 < v15)
    {
      *(void *)&long long v27 = 0x40D7700000000000;
      uint64_t v25 = a9 + 56 * v19;
      *(void *)(v25 + 32) = v29;
      long long v26 = v28;
      *(_OWORD *)uint64_t v25 = v27;
      *(_OWORD *)(v25 + 16) = v26;
      *(int64x2_t *)(v25 + 40) = vdupq_n_s64(0x40D7700000000000uLL);
      ++v19;
    }
    *a8 = 56 * v19;
    return 0;
  }
  else
  {
    return sub_94DC();
  }
}

uint64_t sub_3CEA0(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  if (*a3 != 1936092532 && *a3 != 1885762592)
  {
    return sub_94E4();
  }
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEBUG))
  {
    sub_68A08();
    if (!a7) {
      return 0;
    }
  }
  else if (!a7)
  {
    return 0;
  }
  int v10 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEBUG)) {
    sub_6898C(a7, v10);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, double))(*(void *)a1 + 520))(a1, *(double *)a7);
  if (!result)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059619, (uint64_t)*(double *)a7);
    return 0;
  }
  return result;
}

uint64_t sub_3CFD8(uint64_t a1, uint64_t a2, int *a3)
{
  if (*(void *)(*(void *)(a1 + 416) + 9160))
  {
    int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    if (v5 == (*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 416) + 9160) + 16))(*(void *)(*(void *)(a1 + 416) + 9160)))
    {
      int v6 = *a3;
      BOOL v7 = *a3 == 1935892841 || v6 == 1935893353;
      if (v7 || v6 == 1935894894) {
        return 1;
      }
    }
  }

  return sub_94EC();
}

uint64_t sub_3D0D0(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 416) + 9160);
}

uint64_t sub_3D0DC(uint64_t a1, uint64_t a2, int *a3, unsigned char *a4)
{
  if (*(void *)(*(void *)(a1 + 416) + 9160))
  {
    int v7 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    if (v7 == (*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 416) + 9160) + 16))(*(void *)(*(void *)(a1 + 416) + 9160)))
    {
      int v8 = *a3;
      if (*a3 == 1935894894) {
        goto LABEL_6;
      }
      if (v8 == 1935893353)
      {
        *a4 = 1;
        return 0;
      }
      if (v8 == 1935892841)
      {
LABEL_6:
        *a4 = 0;
        return 0;
      }
    }
  }

  return sub_94F4();
}

uint64_t sub_3D200(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (*(void *)(*(void *)(a1 + 416) + 9160))
  {
    int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    if (v9 == (*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 416) + 9160) + 16))(*(void *)(*(void *)(a1 + 416) + 9160)))
    {
      int v10 = *a3;
      if (*a3 == 1935892841)
      {
        int v11 = 16;
        goto LABEL_12;
      }
      if (v10 == 1935894894)
      {
        int v11 = 8;
        goto LABEL_12;
      }
      if (v10 == 1935893353)
      {
        int v11 = 4;
LABEL_12:
        *a6 = v11;
        return 0;
      }
    }
  }

  return sub_96F0();
}

uint64_t sub_3D348(uint64_t a1, uint64_t a2, int *a3, int a4, int *a5, unsigned int a6, unsigned int *a7, int *a8)
{
  if (!*(void *)(*(void *)(a1 + 416) + 9160)) {
    goto LABEL_15;
  }
  int v15 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  if (v15 != (*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 416) + 9160) + 16))(*(void *)(*(void *)(a1 + 416) + 9160))) {
    goto LABEL_15;
  }
  int v16 = *a3;
  if (*a3 <= 1935892840)
  {
    if (v16 == 1650682995)
    {
      if (a6 <= 3)
      {
        uint64_t v17 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR)) {
          sub_68A3C();
        }
        return v17;
      }
      uint64_t v17 = 0;
      int v22 = 1936483188;
    }
    else
    {
      if (v16 != 1668047219) {
        goto LABEL_15;
      }
      if (a6 <= 3)
      {
        uint64_t v17 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR)) {
          sub_68A70();
        }
        return v17;
      }
      uint64_t v17 = 0;
      int v22 = 1685287523;
    }
LABEL_37:
    *a8 = v22;
    unsigned int v19 = 4;
LABEL_49:
    *a7 = v19;
    return v17;
  }
  switch(v16)
  {
    case 1935892841:
      unsigned int v19 = a6 >> 2;
      if (a6 >> 2 >= 4) {
        unsigned int v19 = 4;
      }
      if (v19)
      {
        *a8 = 1936221033;
        if (v19 == 1)
        {
          unsigned int v19 = 4;
        }
        else
        {
          a8[1] = 1935827571;
          if (v19 < 3)
          {
            unsigned int v19 = 8;
          }
          else
          {
            a8[2] = 1935765619;
            if (v19 == 3)
            {
              unsigned int v19 = 12;
            }
            else
            {
              a8[3] = 1935765620;
              unsigned int v19 = 16;
            }
          }
        }
      }
      uint64_t v17 = 0;
      goto LABEL_49;
    case 1935893353:
      if (a6 <= 3)
      {
        uint64_t v17 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR)) {
          sub_68AA4();
        }
        return v17;
      }
      uint64_t v17 = 0;
      int v22 = *(_DWORD *)(a1 + 9348);
      goto LABEL_37;
    case 1935894894:
      if (a6 <= 7)
      {
        uint64_t v17 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR)) {
          sub_68AD8();
        }
        return v17;
      }
      if (a4 != 4)
      {
        uint64_t v17 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR)) {
          sub_68B0C();
        }
        return v17;
      }
      int v20 = *a5;
      if (*a5 > 1935827570)
      {
        if (v20 == 1936221033)
        {
          CFStringRef v21 = @"HCI";
          goto LABEL_53;
        }
        if (v20 == 1935827571)
        {
          CFStringRef v21 = @"Baseband I2S";
          goto LABEL_53;
        }
      }
      else
      {
        if (v20 == 1935765619)
        {
          CFStringRef v21 = @"API2S";
          goto LABEL_53;
        }
        if (v20 == 1935765620)
        {
          CFStringRef v21 = @"API2S16kHz";
LABEL_53:
          uint64_t v17 = 0;
          *(void *)a8 = v21;
          unsigned int v19 = 8;
          goto LABEL_49;
        }
      }
      uint64_t v17 = 1852797029;
      uint64_t v23 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR))
      {
        v24[0] = HIBYTE(v20);
        v24[1] = BYTE2(v20);
        void v24[2] = BYTE1(v20);
        v24[3] = v20;
        v24[4] = 0;
        *(_DWORD *)std::string buf = 136446210;
        long long v26 = v24;
        _os_log_error_impl(&dword_0, v23, OS_LOG_TYPE_ERROR, "An invalid data source of %{public}s was selected", buf, 0xCu);
      }
      return v17;
  }
LABEL_15:

  return sub_96F8();
}

uint64_t sub_3D7D4(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, int a6, int *a7)
{
  if (*(void *)(*(void *)(a1 + 416) + 9160))
  {
    int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    if (v12 == (*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 416) + 9160) + 16))(*(void *)(*(void *)(a1 + 416) + 9160)))
    {
      if (*a3 != 1935893353) {
        return 2003332927;
      }
      if (a6 != 4)
      {
        uint64_t v17 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR)) {
          sub_68C10();
        }
        return v17;
      }
      int v13 = *a7;
      *(_DWORD *)(a1 + 9348) = *a7;
      if (*(void *)(a1 + 208))
      {
        uint64_t v14 = (unsigned char *)(a1 + 9326);
        switch(v13)
        {
          case 1935765619:
            if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEBUG)) {
              sub_68BDC();
            }
            break;
          case 1935827571:
            if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEBUG)) {
              sub_68BA8();
            }
            break;
          case 1936221033:
            if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEBUG)) {
              sub_68B74();
            }
            if (!*v14) {
              goto LABEL_26;
            }
            char v15 = 0;
            goto LABEL_25;
          default:
            uint64_t v17 = 1852797029;
            if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_ERROR)) {
              sub_68B40();
            }
            return v17;
        }
        if (*v14)
        {
          char v15 = 1;
LABEL_25:
          *(unsigned char *)(a1 + 9345) = v15;
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059619, (uint64_t)*(double *)(a1 + 296));
        }
      }
LABEL_26:
      uint64_t v21 = 0x676C6F6273636369;
      int v22 = 0;
      long long v18 = *(void (***)(void, uint64_t, uint64_t, uint64_t *))(qword_A2350 + 144);
      unsigned int v19 = *v18;
      uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
      v19(v18, v20, 1, &v21);
      return 0;
    }
  }

  return sub_9700();
}

void sub_3DB2C(uint64_t a1)
{
  uint64_t v1 = *(id **)(a1 + 208);
  if (v1) {
    sub_141B0(v1);
  }
}

std::string *sub_3DB3C@<X0>(int a1@<W1>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  sub_BAF4(a2, "Unknown");
  int v4 = "mSBC";
  int v5 = "Unknown Codec";
  if (a1 == 256) {
    int v5 = "CVSD";
  }
  if (a1 != 257) {
    int v4 = v5;
  }
  if (a1 == 510) {
    int v6 = "AAC-ELD";
  }
  else {
    int v6 = v4;
  }
  return std::string::assign(a2, v6);
}

void sub_3DBB8(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

void sub_3DBD4(uint64_t a1, BOOL a2)
{
  int v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_15DE4(v2, a2);
  }
}

void sub_3DBE4(uint64_t a1, unsigned int a2)
{
  int v2 = *(id **)(a1 + 208);
  if (v2) {
    sub_15F08(v2, a2);
  }
}

void sub_3DBF4(uint64_t a1, xpc_object_t xdict)
{
  string = xpc_dictionary_get_string(xdict, "kBTAudioMsgPropertyDeviceUID");
  if (!string)
  {
    int v4 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_63158(v4, v5, v6, v7, v8, v9, v10, v11);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  CFStringRef v12 = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
  *(void *)(a1 + 200) = v12;
  int v13 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    int v15 = 138412546;
    CFStringRef v16 = v12;
    __int16 v17 = 1024;
    int v18 = v14;
    _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "HFP Device XPC connection for UID %@ connected to[ %d ] ", (uint8_t *)&v15, 0x12u);
    CFStringRef v12 = *(CFStringRef *)(a1 + 200);
  }
  **(void **)(a1 + 208) = v12;
}

uint64_t sub_3DD48(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4)
{
  if (a3 != 1)
  {
    uint64_t v8 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_67AC0(v8, v9, v10, v11, v12, v13, v14, v15);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  (*(void (**)(_OWORD *__return_ptr, uint64_t, uint64_t))(*(void *)a1 + 800))(v20, a1, a4);
  long long v16 = v20[1];
  *(_OWORD *)a2 = v20[0];
  *((_OWORD *)a2 + 1) = v16;
  a2[4] = v21;
  *((double *)a2 + 5) = (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1);
  *((double *)a2 + 6) = (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1);
  __int16 v17 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v18 = *a2;
    LODWORD(v20[0]) = 134217984;
    *(void *)((char *)v20 + 4) = v18;
    _os_log_impl(&dword_0, v17, OS_LOG_TYPE_DEFAULT, "Physical Format Supported %f", (uint8_t *)v20, 0xCu);
  }
  return a3;
}

uint64_t sub_3DF08(uint64_t a1, double *a2, uint64_t a3)
{
  if (a3 != 1)
  {
    uint64_t v6 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_FAULT)) {
      sub_67AC0(v6, v7, v8, v9, v10, v11, v12, v13);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  *a2 = (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1);
  a2[1] = (*(double (**)(uint64_t))(*(void *)a1 + 784))(a1);
  return a3;
}

BOOL sub_3DFE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(double *)a2 != *(double *)a3 || *(_DWORD *)(a2 + 28) != *(_DWORD *)(a3 + 28);
}

BOOL sub_3E014(uint64_t *a1, int a2, double a3, double a4)
{
  uint64_t v5 = *a1;
  if (a2) {
    (*(void (**)(void))(v5 + 792))();
  }
  else {
    double v6 = (*(double (**)(void))(v5 + 784))();
  }
  return v6 == a4;
}

uint64_t sub_3E090(uint64_t a1, int a2, int a3)
{
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1048))(a1);
  if (a2 == 1768845428 && v6 == 0) {
    return 0;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1040))(a1);
  if (a2 != 1869968496 || result)
  {
    if (a2 == 1735159650 || a2 == 1869968496 || a2 == 1768845428) {
      return a3 == 0;
    }
    return 0;
  }
  return result;
}

uint64_t sub_3E184(unsigned char *a1, int a2, int a3, int a4)
{
  v19[0] = 0;
  v19[1] = 0;
  sub_5CDCC((uint64_t)v19, (uint64_t)(a1 + 552));
  if (a2 == a3) {
    goto LABEL_23;
  }
  uint64_t v8 = a1 + 9354;
  if (a2 != 1953719151) {
    goto LABEL_8;
  }
  if ((*(unsigned int (**)(unsigned char *))(*(void *)a1 + 992))(a1))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 616));
    pthread_cond_signal((pthread_cond_t *)(a1 + 680));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 616));
  }
  if (a4 != 1936090482)
  {
LABEL_8:
    if (a3 != 1953719151) {
      goto LABEL_23;
    }
    *uint64_t v8 = a4 == 1919708275;
    if (a4 != 1936090482)
    {
      BOOL v9 = sub_3BB68((uint64_t)a1);
      if (a4 != 1918989668 || !v9) {
        goto LABEL_21;
      }
    }
    goto LABEL_17;
  }
  a1[9436] = 0;
  sub_5283C(*((void *)a1 + 52));
  v18[0] = 0;
  if (sub_59E8C(*((void *)a1 + 52), v18, 1))
  {
    (*(void (**)(unsigned char *, void))(*(void *)a1 + 528))(a1, v18[0]);
  }
  else
  {
    uint64_t v10 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "HFPStereo facetime skip stereo disable", buf, 2u);
    }
  }
  if (a3 == 1953719151)
  {
    *uint64_t v8 = 0;
LABEL_17:
    a1[9436] = 1;
    sub_5283C(*((void *)a1 + 52));
    v18[0] = 0;
    if (sub_59E8C(*((void *)a1 + 52), v18, 1))
    {
      (*(void (**)(unsigned char *, void))(*(void *)a1 + 528))(a1, v18[0]);
    }
    else
    {
      uint64_t v11 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "HFPStereo facetime skip stereo enable", buf, 2u);
      }
    }
LABEL_21:
    double v12 = sub_39F38((uint64_t)a1);
    (*(void (**)(unsigned char *, double))(*(void *)a1 + 520))(a1, v12);
    if (a1[461]) {
      sub_3A830((uint64_t)a1, 1u, a4);
    }
  }
LABEL_23:
  uint64_t v13 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    v18[0] = HIBYTE(a2);
    v18[1] = BYTE2(a2);
    _OWORD v18[2] = BYTE1(a2);
    v18[3] = a2;
    v18[4] = 0;
    v17[0] = HIBYTE(a3);
    v17[1] = BYTE2(a3);
    v17[2] = BYTE1(a3);
    _DWORD v17[3] = a3;
    v17[4] = 0;
    v16[0] = HIBYTE(a4);
    v16[1] = BYTE2(a4);
    v16[2] = BYTE1(a4);
    v16[3] = a4;
    v16[4] = 0;
    if (a1[460]) {
      uint64_t v14 = "Yes";
    }
    else {
      uint64_t v14 = "No";
    }
    *(_DWORD *)std::string buf = 136316162;
    uint64_t v21 = v18;
    __int16 v22 = 2080;
    uint64_t v23 = v17;
    __int16 v24 = 2080;
    uint64_t v25 = v16;
    __int16 v26 = 2080;
    long long v27 = "No";
    __int16 v28 = 2080;
    uint64_t v29 = v14;
    _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "Profile Transition %s => %s , reason %s streamChangeReqd = %s Need Transport Ready %s", buf, 0x34u);
  }
  sub_5CF10(v19);
  return 0;
}

void sub_3E56C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

BOOL sub_3E590(unsigned char *a1, int a2, int a3, int a4)
{
  v25[0] = 0;
  v25[1] = 0;
  sub_5CDCC((uint64_t)v25, (uint64_t)(a1 + 552));
  double v8 = sub_39F38((uint64_t)a1);
  BOOL v9 = 0;
  if (a2 != 1953719151 || a3 == a4) {
    goto LABEL_32;
  }
  double v10 = v8;
  a1[9354] = 0;
  if (a3 == 1919708275)
  {
    (*(void (**)(unsigned char *, double))(*(void *)a1 + 520))(a1, v8);
    (*(void (**)(unsigned char *, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059700, (uint64_t)v10);
    int v11 = 1;
  }
  else
  {
    int v11 = 0;
  }
  if ((*(unsigned int (**)(unsigned char *))(*(void *)a1 + 992))(a1))
  {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 616));
    pthread_cond_signal((pthread_cond_t *)(a1 + 680));
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 616));
  }
  if (a3 == 1936090482 || (BOOL v12 = sub_3BB68((uint64_t)a1), a3 == 1918989668) && v12)
  {
    uint64_t v13 = *((void *)a1 + 52);
    if (*(_DWORD *)(*(void *)(v13 + 9248) + 244))
    {
      if (*((_DWORD *)a1 + 2332))
      {
        a1[9436] = 0;
        sub_5283C(v13);
        v24[0] = 0;
        if (sub_59E8C(*((void *)a1 + 52), v24, 1))
        {
          (*(void (**)(unsigned char *, void))(*(void *)a1 + 528))(a1, v24[0]);
        }
        else
        {
          uint64_t v14 = qword_A1B20;
          if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "HFPStereo facetime skip stereo disable", buf, 2u);
          }
        }
        (*(void (**)(unsigned char *, uint64_t, unsigned char *))(*(void *)a1 + 240))(a1, 1885762592, a1 + 296);
        int v11 = 1;
      }
    }
  }
  BOOL v9 = v11 != 0;
  if (a4 == 1918989668)
  {
    if (!sub_3BB68((uint64_t)a1)) {
      goto LABEL_32;
    }
  }
  else if (a4 != 1936090482)
  {
    if (a4 == 1919708275)
    {
      a1[9354] = 1;
      (*(void (**)(unsigned char *, double))(*(void *)a1 + 520))(a1, v10);
      (*(void (**)(unsigned char *, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1853059700, (uint64_t)v10);
      BOOL v9 = 1;
    }
    goto LABEL_32;
  }
  uint64_t v15 = *((void *)a1 + 52);
  if (*(_DWORD *)(*(void *)(v15 + 9248) + 244) && *((_DWORD *)a1 + 2332))
  {
    a1[9436] = 1;
    sub_5283C(v15);
    v24[0] = 0;
    if (sub_59E8C(*((void *)a1 + 52), v24, 1))
    {
      (*(void (**)(unsigned char *, void))(*(void *)a1 + 528))(a1, v24[0]);
    }
    else
    {
      long long v16 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v16, OS_LOG_TYPE_DEFAULT, "HFPStereo facetime skip stereo enable", buf, 2u);
      }
    }
    (*(void (**)(unsigned char *, uint64_t, unsigned char *))(*(void *)a1 + 240))(a1, 1885762592, a1 + 9104);
    int v11 = 1;
  }
  BOOL v9 = v11 != 0;
  if (a1[461]) {
    sub_3A830((uint64_t)a1, 1u, a4);
  }
LABEL_32:
  __int16 v17 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    v24[0] = HIBYTE(a3);
    v24[1] = BYTE2(a3);
    void v24[2] = BYTE1(a3);
    v24[3] = a3;
    v24[4] = 0;
    v23[0] = HIBYTE(a4);
    v23[1] = BYTE2(a4);
    void v23[2] = BYTE1(a4);
    v23[3] = a4;
    v23[4] = 0;
    int v18 = (*(uint64_t (**)(unsigned char *))(*(void *)a1 + 1160))(a1);
    unsigned int v19 = "No";
    int v20 = a1[460];
    long long v27 = v24;
    uint64_t v29 = v23;
    if (v9) {
      uint64_t v21 = "Yes";
    }
    else {
      uint64_t v21 = "No";
    }
    *(_DWORD *)std::string buf = 136316162;
    __int16 v28 = 2080;
    if (v20) {
      unsigned int v19 = "Yes";
    }
    __int16 v30 = 2080;
    int v31 = v21;
    __int16 v32 = 1024;
    int v33 = v18;
    __int16 v34 = 2080;
    uint64_t v35 = v19;
    _os_log_impl(&dword_0, v17, OS_LOG_TYPE_DEFAULT, "HFP change reason %s => %s Blocking for Stream Change : %s, current transport status %d Need Transport Ready %s", buf, 0x30u);
  }
  sub_5CF10(v25);
  return v9;
}

void sub_3EAF8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

void sub_3EB20(void *a1)
{
  uint64_t v2 = a1[52];
  if (*(unsigned char *)(*(void *)(v2 + 9248) + 230))
  {
    int v3 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6[0]) = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "HFP notify kBluetoothAudioDevicePropertySpatialMode change", (uint8_t *)v6, 2u);
      uint64_t v2 = a1[52];
    }
    sub_49F68(v2, 1936747876);
  }
  unsigned int v4 = ((*(double (**)(void *))(*a1 + 784))(a1) * 20.0 / 1000.0);
  *((_DWORD *)a1 + 2360) = v4;
  uint64_t v5 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = v4;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Update Max Supported Frame Size %d", (uint8_t *)v6, 8u);
  }
  if (*(_DWORD *)(*(void *)(a1[52] + 9248) + 224) == 1) {
    (*(void (**)(void *, uint64_t))(*a1 + 528))(a1, 4);
  }
}

BOOL sub_3ECBC(uint64_t a1)
{
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 416) + 9248) + 217) == 0;
}

uint64_t sub_3ECD4(uint64_t result, int a2)
{
  *(_DWORD *)(result + 376) = a2;
  return result;
}

uint64_t sub_3ECDC(uint64_t result)
{
  float v1 = -52.0;
  if (!*(unsigned char *)(*(void *)(*(void *)(result + 416) + 9248) + 488)) {
    float v1 = -32.0;
  }
  *(float *)(result + 444) = v1;
  return result;
}

void sub_3ED04(uint64_t a1, BOOL a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Notify Expanse in A2DP %d", (uint8_t *)v6, 8u);
  }
  uint64_t v5 = *(id **)(a1 + 208);
  if (v5) {
    sub_14A50(v5, a2);
  }
}

void sub_3EDC0(uint64_t a1, BOOL a2)
{
  unsigned int v4 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = 67109120;
    v6[1] = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Notify Call Screening State:%d", (uint8_t *)v6, 8u);
  }
  uint64_t v5 = *(id **)(a1 + 208);
  if (v5) {
    sub_14B98(v5, a2);
  }
}

__n128 sub_3EE7C@<Q0>(uint64_t a1@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  if (a2)
  {
    if ((sub_395B4() & 1) == 0 && *(_DWORD *)(a1 + 9340) && *(_DWORD *)(a1 + 9328) && !*(unsigned char *)(a1 + 9354))
    {
      uint64_t v5 = 9184;
LABEL_15:
      uint64_t v6 = a1 + v5;
      goto LABEL_9;
    }
  }
  else if (!*(unsigned char *)(a1 + 9354))
  {
    int v9 = *(_DWORD *)(a1 + 9340);
    if (v9)
    {
      if (v9 == 128)
      {
        uint64_t v5 = 9144;
        goto LABEL_15;
      }
      if (*(_DWORD *)(a1 + 9328))
      {
        uint64_t v5 = 9104;
        goto LABEL_15;
      }
    }
  }
  uint64_t v6 = a1 + 296;
LABEL_9:
  __n128 result = *(__n128 *)v6;
  long long v8 = *(_OWORD *)(v6 + 16);
  *(_OWORD *)a3 = *(_OWORD *)v6;
  *(_OWORD *)(a3 + 16) = v8;
  *(void *)(a3 + 32) = *(void *)(v6 + 32);
  return result;
}

BOOL sub_3EF1C(uint64_t a1, unsigned char *a2, __int16 a3)
{
  if (a2)
  {
    uint64_t v6 = sub_459EC(qword_A2350);
    uint64_t v7 = *(void *)(*(void *)(a1 + 416) + 9248);
    __int16 v8 = *(_WORD *)(v7 + 608);
    __int16 v9 = v8 + 1;
    *(_WORD *)(v7 + 608) = v8 + 1;
    *a2 = ((unsigned __int16)(v8 + 1) >> 8) & 7 | 0xB0;
    a2[1] = v8 + 1;
    a2[2] = (v6 >> 15) & 7 | 0xE8;
    a2[3] = v6 >> 7;
    a2[4] = v6 & 0x7F;
    if (*(unsigned char *)(a1 + 745))
    {
      double v10 = qword_A1B20;
      if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = 134218496;
        uint64_t v14 = v6;
        __int16 v15 = 1024;
        int v16 = v6 & 0x3FFFF;
        __int16 v17 = 1024;
        int v18 = v9 & 0x7FF;
        _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Current Host Time: %llu; Current Host Time: (converted to 18 bits) %d; A2DP Frame number: %d",
          (uint8_t *)&v13,
          0x18u);
      }
    }
    a2[8] = HIBYTE(a3) & 7 | 0x10;
    a2[9] = a3;
  }
  else if (*(unsigned char *)(a1 + 745))
  {
    BOOL v12 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "AACELDHeader-Header buffer size is NULL", (uint8_t *)&v13, 2u);
    }
  }
  return a2 != 0;
}

void sub_3F0B4(uint64_t a1, int a2)
{
  if (a2 == 1952539500)
  {
    int v3 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      sub_B6D0(2u, __p);
      if (v7 >= 0) {
        unsigned int v4 = __p;
      }
      else {
        unsigned int v4 = (void **)__p[0];
      }
      *(_DWORD *)std::string buf = 136446210;
      __int16 v9 = v4;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Send Transiton Message %{public}s ", buf, 0xCu);
      if (v7 < 0) {
        operator delete(__p[0]);
      }
    }
    uint64_t v5 = *(id **)(a1 + 208);
    if (v5) {
      sub_14144(v5, 2);
    }
  }
}

uint64_t sub_3F1B4(uint64_t result, int a2, int a3, unsigned int a4)
{
  if (*(unsigned char *)(result + 462))
  {
    uint64_t v7 = result;
    __int16 v8 = qword_A1B20;
    if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(*(void *)(v7 + 416) + 9264);
      v14[0] = BYTE3(v9);
      v14[1] = BYTE2(v9);
      _DWORD v14[2] = BYTE1(v9);
      v14[3] = v9;
      v14[4] = 0;
      v13[0] = HIBYTE(a3);
      v13[1] = BYTE2(a3);
      void v13[2] = BYTE1(a3);
      v13[3] = a3;
      v13[4] = 0;
      sub_B6D0(a4, __p);
      double v10 = v12 >= 0 ? __p : (void **)__p[0];
      *(_DWORD *)std::string buf = 136315650;
      int v16 = v14;
      __int16 v17 = 2080;
      int v18 = v13;
      __int16 v19 = 2080;
      int v20 = v10;
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Handsfree Profile HandleTransportOnRouteChange %s => %s Recommended Transtion : %s", buf, 0x20u);
      if (v12 < 0) {
        operator delete(__p[0]);
      }
    }
    if (a3 == 1919183219 || a2 != 1952539500) {
      (*(void (**)(uint64_t, void))(*(void *)v7 + 1384))(v7, 0);
    }
    else {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v7 + 1424))(v7, 1952539500);
    }
    *(unsigned char *)(v7 + 462) = 0;
    return (*(uint64_t (**)(uint64_t))(*(void *)v7 + 1408))(v7);
  }
  return result;
}

void sub_3F428(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 416) + 9248);
  int v5 = *(unsigned __int8 *)(v4 + 222);
  if (*(unsigned char *)(v4 + 222)) {
    int v6 = a2;
  }
  else {
    int v6 = 0;
  }
  uint64_t v7 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v8 = @"Send";
    if (v6) {
      CFStringRef v8 = @"Not Send";
    }
    if (a2) {
      CFStringRef v9 = @"IO Stop";
    }
    else {
      CFStringRef v9 = @"Route Change/Timer";
    }
    int v12 = 138412802;
    CFStringRef v13 = v8;
    __int16 v14 = 2112;
    CFStringRef v15 = v9;
    if (v5) {
      CFStringRef v10 = @"Enabled";
    }
    else {
      CFStringRef v10 = @"Disabled";
    }
    __int16 v16 = 2112;
    CFStringRef v17 = v10;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Evaluate Transport Transition,  %@ Handsfree Stop Message to bluetoothd:, Trigger Type: %@ Route transition: %@", (uint8_t *)&v12, 0x20u);
  }
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 1400))(a1);
  }
  else
  {
    int v11 = *(id **)(a1 + 208);
    if (v11) {
      sub_140F0(v11);
    }
  }
  *(unsigned char *)(a1 + 462) = v6;
}

uint64_t sub_3F594(uint64_t a1)
{
  uint64_t v2 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Start HFP-A2DP Transtion timer", buf, 2u);
  }
  unsigned int v3 = (*(uint64_t (**)(void))(**(void **)(a1 + 416) + 16))(*(void *)(a1 + 416));
  *(void *)std::string buf = 0;
  uint64_t v10 = 0;
  sub_5CDCC((uint64_t)buf, a1 + 464);
  uint64_t v4 = *(void **)(a1 + 528);
  if (v4)
  {
    if (!dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 528)))
    {
      dispatch_block_cancel(v4);
      uint64_t v4 = *(void **)(a1 + 528);
    }
    _Block_release(v4);
    *(void *)(a1 + 528) = 0;
  }
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_3F708;
  uint64_t v7[3] = &unk_8EB30;
  v7[4] = a1;
  unsigned int v8 = v3;
  dispatch_block_t v5 = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, v7);
  *(void *)(a1 + 528) = v5;
  sub_456B0(qword_A2350, 200, v3, v5);
  sub_5CEA4((uint64_t)buf);
  return sub_5CF10(buf);
}

void sub_3F6F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_3F708(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 40));
  if (v2)
  {
    unsigned int v3 = (unsigned char *)v2[1137];
    if (v3)
    {
      if (v3[192] && v3[462]) {
        (*(void (**)(unsigned char *, void))(*(void *)v3 + 1384))(v3, 0);
      }
    }
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_5CDCC((uint64_t)v5, v1 + 464);
  _Block_release(*(const void **)(v1 + 528));
  *(void *)(v1 + 528) = 0;
  sub_5CEA4((uint64_t)v5);
  return sub_5CF10(v5);
}

void sub_3F7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_3F7D4(uint64_t a1)
{
  uint64_t v2 = qword_A1B20;
  if (os_log_type_enabled((os_log_t)qword_A1B20, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5[0]) = 0;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Reset HFP-A2DP Transtion timer", (uint8_t *)v5, 2u);
  }
  v5[0] = 0;
  v5[1] = 0;
  sub_5CDCC((uint64_t)v5, a1 + 464);
  unsigned int v3 = *(void **)(a1 + 528);
  if (v3)
  {
    if (!dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 528))) {
      dispatch_block_cancel(v3);
    }
    *(void *)(a1 + 528) = 0;
  }
  sub_5CEA4((uint64_t)v5);
  return sub_5CF10(v5);
}

void sub_3F87C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_3F890(unsigned char *a1)
{
  if (a1[462]) {
    (*(void (**)(unsigned char *, void))(*(void *)a1 + 1384))(a1, 0);
  }
  uint64_t v2 = *(uint64_t (**)(unsigned char *))(*(void *)a1 + 1408);

  return v2(a1);
}

uint64_t sub_3F934()
{
  return 0;
}

uint64_t sub_3F93C(uint64_t result, int a2)
{
  *(_DWORD *)(result + 9304) = a2;
  return result;
}

double sub_3F944(uint64_t a1)
{
  return *(double *)(a1 + 296);
}

uint64_t sub_3F94C(uint64_t a1)
{
  return *(unsigned int *)(a1 + 376);
}

uint64_t sub_3F954(uint64_t a1)
{
  return *(unsigned int *)(a1 + 9304);
}

uint64_t sub_3F95C()
{
  return 0;
}

uint64_t sub_3F964(uint64_t result, char a2)
{
  *(unsigned char *)(result + 409) = a2;
  return result;
}

uint64_t sub_3F96C(uint64_t result, char a2)
{
  *(unsigned char *)(result + 410) = a2;
  return result;
}

BOOL sub_3F974(uint64_t a1)
{
  return *(unsigned char *)(a1 + 409) != 0;
}

BOOL sub_3F984(uint64_t a1)
{
  return *(unsigned char *)(a1 + 410) != 0;
}

BOOL sub_3F994(uint64_t a1)
{
  return *(unsigned char *)(a1 + 9353) != 0;
}

BOOL sub_3F9A8(uint64_t a1)
{
  return *(unsigned char *)(a1 + 9352) != 0;
}

BOOL sub_3F9BC(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 9352) != *(unsigned __int8 *)(a1 + 9353);
}

uint64_t sub_3F9D8()
{
  return 1;
}

uint64_t sub_3F9E0()
{
  return 1;
}

uint64_t sub_3F9F4(uint64_t a1)
{
  return *(void *)(a1 + 9080);
}

uint64_t sub_3F9FC(uint64_t a1)
{
  return *(void *)(a1 + 9088);
}

uint64_t sub_3FA04(uint64_t a1)
{
  return *(void *)(a1 + 9096);
}

uint64_t sub_3FA0C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9088) = a2;
  return result;
}

uint64_t sub_3FA14(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9096) = a2;
  return result;
}

uint64_t sub_3FA1C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 9080) = a2;
  return result;
}

os_log_t sub_3FA24()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1B20 = (uint64_t)result;
  return result;
}

void sub_3FA54(void *a1)
{
  uint64_t v2 = sub_306F0((uint64_t)a1);
  *(void *)uint64_t v2 = off_8F288;
  *(unsigned char *)(v2 + 12) = 0;
  sub_5CC80(v2 + 200, v3);
  sub_5CC80(a1 + 33, v4);
  a1[46] = 0;
  a1[47] = 0;
  a1[44] = 0;
  a1[45] = a1 + 46;
  a1[50] = 0;
  a1[51] = 0;
  a1[49] = 0;
  a1[53] = 0;
  a1[54] = 0;
  a1[57] = 0;
  a1[58] = 0;
  a1[55] = 0;
  a1[56] = a1 + 57;
  a1[59] = a1 + 60;
  a1[60] = 0;
  a1[61] = 0;
  a1[62] = 0;
  dispatch_block_t v5 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
    *(_DWORD *)std::string buf = 67109120;
    int v13 = v6;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Creating audio plugin with audioID: %u", buf, 8u);
  }
  uint64_t v7 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, -1);
  a1[20] = dispatch_queue_create("com.apple.BTAudioHALPlugin", v7);
  unsigned int v8 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, -1);
  a1[21] = dispatch_queue_create("com.apple.BTAudioHALPlugin.Config.Change", v8);
  CFStringRef v9 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, -1);
  a1[23] = dispatch_queue_create("com.apple.BTAudioHALPlugin.Config.Change", v9);
  uint64_t v10 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, -1);
  a1[22] = dispatch_queue_create("com.apple.BTAudioHALPlugin.Property.Change", v10);
  int v11 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_BACKGROUND, -1);
  a1[24] = dispatch_queue_create("com.apple.BTAudioHALPlugin.Telemetry", v11);
  qword_A2350 = (uint64_t)a1;
  a1[42] = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
  if ((sub_395B4() & 1) == 0) {
    a1[48] = objc_alloc_init(BTAudioIDSService);
  }
  operator new();
}

void sub_3FD48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13)
{
  sub_18C7C(v13 + 472, *v19);
  sub_47988(v13 + 448, *v18);
  a13 = (void **)(v13 + 424);
  sub_478E4(&a13);
  a13 = (void **)(v13 + 392);
  sub_4782C(&a13);
  sub_18C7C(v16, *v17);
  sub_5CD00(v15, v21);
  sub_5CD00(v14, v22);
  sub_307F8(v13);
  _Unwind_Resume(a1);
}

uint64_t **sub_3FDF4(uint64_t a1)
{
  uint64_t v2 = "frhctslp";
  os_log_t result = sub_48214((uint64_t **)(a1 + 360), (unsigned int *)"frhctslp", (uint64_t)&unk_71834, (_DWORD **)&v2);
  result[5] = (uint64_t *)"frhctslp";
  return result;
}

void *sub_3FE44(void *result)
{
  if (!result[62])
  {
    uint64_t v1 = result;
    id v2 = objc_alloc_init((Class)HMServiceClient);
    v1[62] = v2;
    [v2 setDispatchQueue:v1[20]];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    void v5[2] = sub_45A38;
    v5[3] = &unk_8F320;
    v5[4] = v1;
    [(id)v1[62] setDeviceRecordChangedHandler:v5];
    uint64_t v3 = (void *)v1[62];
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    void v4[2] = sub_45B54;
    v4[3] = &unk_8F340;
    v4[4] = v1;
    return [v3 activateWithCompletion:v4];
  }
  return result;
}

_xpc_connection_s *sub_3FF34(uint64_t a1)
{
  id v2 = [+[NSProcessInfo processInfo] processName];
  uint64_t v3 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412290;
    CFStringRef v9 = v2;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Starting BTAudioPlugin for %@", buf, 0xCu);
  }
  os_log_t result = xpc_connection_create_mach_service("com.apple.BTAudioHALPlugin.xpc", *(dispatch_queue_t *)(a1 + 160), 0);
  *(void *)(a1 + 344) = result;
  if (result)
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_40308;
    handler[3] = &unk_8F2C8;
    handler[4] = a1;
    xpc_connection_set_event_handler(result, handler);
    xpc_connection_resume(*(xpc_connection_t *)(a1 + 344));
    dispatch_block_t v5 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Register audio plugin connection with bluetoothd", buf, 2u);
    }
    xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_uint64(v6, "kBTAudioMsgMethod", 0xDuLL);
    xpc_dictionary_set_string(v6, "kBTAudioMsgProcess", [(NSString *)v2 UTF8String]);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 344), v6);
    xpc_release(v6);
    return (_xpc_connection_s *)(*(void *)(a1 + 344) != 0);
  }
  return result;
}

uint64_t sub_40104(uint64_t a1)
{
  *(void *)a1 = off_8F288;
  uint64_t v2 = a1 + 200;
  v8[0] = 0;
  v8[1] = 0;
  sub_5CDCC((uint64_t)v8, a1 + 200);
  if (_os_feature_enabled_impl())
  {
    uint64_t v3 = *(void **)(a1 + 496);
    if (v3)
    {
      [v3 invalidate];
      *(void *)(a1 + 496) = 0;
    }
  }
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 336));
  CFRelease(*(CFTypeRef *)(a1 + 160));
  CFRelease(*(CFTypeRef *)(a1 + 168));
  CFRelease(*(CFTypeRef *)(a1 + 184));
  CFRelease(*(CFTypeRef *)(a1 + 176));
  CFRelease(*(CFTypeRef *)(a1 + 336));
  CFRelease(*(CFTypeRef *)(a1 + 192));

  sub_18C7C(a1 + 360, *(void **)(a1 + 368));
  *(void *)(a1 + 368) = 0;
  *(void *)(a1 + 376) = 0;
  *(void *)(a1 + 360) = a1 + 368;
  if (*(void *)(a1 + 328))
  {
    nullsub_81(v4);
    operator delete();
  }
  [*(id *)(a1 + 496) invalidate];
  *(void *)(a1 + 496) = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 16));
  pthread_cond_destroy((pthread_cond_t *)(a1 + 80));
  sub_5CF10(v8);
  sub_18C7C(a1 + 472, *(void **)(a1 + 480));
  sub_47988(a1 + 448, *(char **)(a1 + 456));
  v8[0] = (void **)(a1 + 424);
  sub_478E4(v8);
  v8[0] = (void **)(a1 + 392);
  sub_4782C(v8);
  sub_18C7C(a1 + 360, *(void **)(a1 + 368));
  sub_5CD00(a1 + 264, v5);
  sub_5CD00(v2, v6);
  return sub_307F8(a1);
}

id sub_4029C(uint64_t a1)
{
  id result = *(id *)(a1 + 496);
  if (result)
  {
    id result = [result invalidate];
    *(void *)(a1 + 496) = 0;
  }
  return result;
}

void sub_402D0(uint64_t a1)
{
  sub_40104(a1);

  operator delete();
}

void sub_40308(uint64_t a1, void *a2)
{
}

void sub_40310(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_error)
  {
    string = xpc_dictionary_get_string(object, _xpc_error_key_description);
    uint64_t v15 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_68C44((uint64_t)string, v15, v16, v17, v18, v19, v20, v21);
    }
    xpc_release(*(xpc_object_t *)(a1 + 344));
    *(void *)(a1 + 344) = 0;
    sub_4066C(a1);
    if (!sub_5CB00())
    {
      sub_3FF34(a1);
      return;
    }
    if (object == &_xpc_error_connection_interrupted && sub_5CB0C())
    {
      int64_t v22 = 1000000000;
      uint64_t v23 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        LODWORD(v33) = 1;
        __int16 v24 = "Rate limiting BTAudio xpc connection restart to %d sec on dev boards";
LABEL_26:
        _os_log_impl(&dword_0, v23, OS_LOG_TYPE_DEFAULT, v24, buf, 8u);
      }
    }
    else if (object == &_xpc_error_connection_invalid)
    {
      int64_t v22 = 30000000000;
      uint64_t v23 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        LODWORD(v33) = 30;
        __int16 v24 = "No connection exist or bluetoothd is rejecting connection, reconnect in %d secs";
        goto LABEL_26;
      }
    }
    else
    {
      int64_t v22 = 0;
    }
    dispatch_time_t v29 = dispatch_time(0, v22);
    __int16 v30 = *(NSObject **)(a1 + 160);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_40824;
    block[3] = &unk_8D2C0;
    void block[4] = a1;
    dispatch_after(v29, v30, block);
    return;
  }
  xpc_type_t v5 = type;
  uint64_t v6 = xpc_copy_description(object);
  if (v5 == (xpc_type_t)&_xpc_type_dictionary)
  {
    int int64 = xpc_dictionary_get_int64(object, "kBTAudioMsgId");
    xpc_dictionary_get_value(object, "kBTAudioMsgArgs");
    __int16 v26 = xpc_dictionary_get_string(object, "kBTAudioMsgDeviceUid");
    if (v26)
    {
      long long v27 = +[NSString stringWithUTF8String:v26];
      __int16 v28 = qword_A1B28;
      if (int64 == 2)
      {
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 138412290;
          int v33 = v27;
          _os_log_impl(&dword_0, v28, OS_LOG_TYPE_DEFAULT, "Publish Message from Audio Device UID: %@\n", buf, 0xCu);
        }
        sub_4082C();
      }
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEBUG)) {
        sub_68CB0((uint64_t)v27, int64, v28);
      }
      sub_408E0(a1, object);
    }
  }
  else
  {
    uint64_t v7 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_68D38((uint64_t)v6, v7, v8, v9, v10, v11, v12, v13);
    }
  }
  free(v6);
}

uint64_t sub_40664(uint64_t a1)
{
  return *(void *)(a1 + 344);
}

uint64_t sub_4066C(uint64_t a1)
{
  v13[0] = 0;
  v13[1] = 0;
  sub_5CDCC((uint64_t)v13, a1 + 200);
  sub_446D4(a1);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v3 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 134217984;
    CFIndex v15 = Count;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Invalidating all (%ld) audio devices", buf, 0xCu);
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; i != Count; ++i)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), i);
      std::string __p = 0;
      uint64_t v8 = 0;
      uint64_t v9 = 0;
      sub_4859C(&__p, 0, 0, 0);
      sub_4B358(ValueAtIndex, (uint64_t)&__p);
      if (__p)
      {
        uint64_t v8 = __p;
        operator delete(__p);
      }
    }
    sub_4133C(a1, (uint64_t)&v10);
    sub_410B0(a1, 1684370979);
    if (v10)
    {
      uint64_t v11 = v10;
      operator delete(v10);
    }
  }
  return sub_5CF10(v13);
}

void sub_407D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, char a15)
{
  if (__p) {
    operator delete(__p);
  }
  sub_5CF10(&a15);
  _Unwind_Resume(a1);
}

uint64_t sub_40824(uint64_t a1)
{
  return sub_3FF34(*(void *)(a1 + 32));
}

void sub_4082C()
{
}

void sub_408BC()
{
}

void sub_408E0(uint64_t a1, xpc_object_t xdict)
{
  xpc_object_t value = xpc_dictionary_get_value(xdict, "kBTAudioMsgArgs");
  if (value) {
    xpc_dictionary_get_value(value, "kBTAudioMsgArgDeviceProperties");
  }
  string = xpc_dictionary_get_string(xdict, "kBTAudioMsgDeviceUid");
  if (string) {
    uint64_t v6 = +[NSString stringWithUTF8String:string];
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = sub_409A8(a1, v6);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    uint64_t v9 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEBUG)) {
      sub_68DA4(v6, v9);
    }
    uint64_t v10 = sub_90D8(v8);
    sub_13BE4(v10, xdict);
  }
}

const void *sub_409A8(uint64_t a1, void *a2)
{
  v9[0] = 0;
  v9[1] = 0;
  sub_5CDCC((uint64_t)v9, a1 + 200);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  if (Count < 1)
  {
LABEL_6:
    uint64_t v7 = 0;
  }
  else
  {
    CFIndex v5 = 0;
    while (1)
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v5);
      if (ValueAtIndex)
      {
        uint64_t v7 = sub_57CF8((uint64_t)ValueAtIndex, a2);
        if (v7) {
          break;
        }
      }
      if (Count == ++v5) {
        goto LABEL_6;
      }
    }
  }
  sub_5CF10(v9);
  return v7;
}

void sub_40A48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *sub_40A64(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t xdict)
{
  string = (char *)xpc_dictionary_get_string(xdict, "kBTAudioMsgPropertyDeviceAddress");
  if (!string)
  {
    uint64_t v9 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_FAULT)) {
      sub_68EC0(v9);
    }
    if (sub_5CB00()) {
      abort();
    }
  }
  v28[0] = 0;
  v28[1] = 0;
  uint64_t v29 = 0;
  sub_BAF4(v28, string);
  unsigned __int8 v10 = atomic_load((unsigned __int8 *)(a1 + 12));
  if ((v10 & 1) == 0)
  {
    uint64_t v11 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(a1 + 128);
      uint64_t v12 = *(void *)(a1 + 136);
      buf[0] = 134218240;
      *(void *)&buf[1] = v12;
      __int16 v31 = 2048;
      uint64_t v32 = v13;
      _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Publish BTDevice waiting BTAudioPlugin ready %ld, %ld", (uint8_t *)buf, 0x16u);
    }
    if (!*(void *)(a1 + 128)) {
      *(_OWORD *)(a1 + 128) = xmmword_71800;
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
    if (pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 80), (pthread_mutex_t *)(a1 + 16), (const timespec *)(a1 + 128)) == 60)
    {
      unsigned __int8 v14 = atomic_load((unsigned __int8 *)(a1 + 12));
      if ((v14 & 1) == 0)
      {
        CFIndex v15 = qword_A1B28;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
          sub_68E30(a1, (uint64_t *)(a1 + 128), v15);
        }
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  uint64_t v16 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = v28;
    if (v29 < 0) {
      uint64_t v17 = (void **)v28[0];
    }
    buf[0] = 136446210;
    *(void *)&buf[1] = v17;
    _os_log_impl(&dword_0, v16, OS_LOG_TYPE_DEFAULT, "Add BTDevice to UnifiedAudioDevice : %{public}s ", (uint8_t *)buf, 0xCu);
  }
  if (SHIBYTE(v29) < 0)
  {
    sub_B9AC(__p, v28[0], (unint64_t)v28[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)v28;
    uint64_t v27 = v29;
  }
  uint64_t v18 = sub_42590(a1, (long long *)__p);
  uint64_t v19 = (void *)v18;
  if (SHIBYTE(v27) < 0)
  {
    operator delete(__p[0]);
    if (v19) {
      goto LABEL_24;
    }
LABEL_26:
    uint64_t v20 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl(&dword_0, v20, OS_LOG_TYPE_DEFAULT, "Creating Unified Device", (uint8_t *)buf, 2u);
    }
    operator new();
  }
  if (!v18) {
    goto LABEL_26;
  }
LABEL_24:
  sub_265C8(v19[1156], a3, xdict);
  sub_4935C((uint64_t)v19, a2);
  uint64_t v21 = v19[1156];
  if (v21)
  {
    if (*(unsigned char *)(v21 + 144) || *(unsigned char *)(v21 + 274))
    {
      int64_t v22 = +[BTAudioAVNotificationMonitor sharedInstance];
      if (v22)
      {
        [(BTAudioAVNotificationMonitor *)v22 registerNowPlayingListener:(*(uint64_t (**)(void *))(*v19 + 16))(v19)];
        [(BTAudioAVNotificationMonitor *)v22 registerPersonalizedVolumeListener:(*(uint64_t (**)(void *))(*v19 + 16))(v19) deviceUID:v19[1135]];
        [(BTAudioAVNotificationMonitor *)v22 processManualVolumeUpdates:1];
      }
    }
    if (sub_45048(a1, v19))
    {
      uint64_t v23 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v24 = v19[1135];
        buf[0] = 138543362;
        *(void *)&buf[1] = v24;
        _os_log_impl(&dword_0, v23, OS_LOG_TYPE_DEFAULT, "Publish UnifiedAudioDevice : %{public}@", (uint8_t *)buf, 0xCu);
      }
      sub_410B0(a1, 1684370979);
    }
    sub_5A150(v19, a2);
    if (a2 == 1952539500 || *(unsigned char *)(v19[1156] + 328)) {
      sub_44840(a1);
    }
  }
  if (SHIBYTE(v29) < 0) {
    operator delete(v28[0]);
  }
  return v19;
}

void sub_40F90(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
}

xpc_object_t sub_40FFC(int a1, char *string, void *a3, int a4)
{
  *(_OWORD *)keys = *(_OWORD *)off_8F2E8;
  object[0] = xpc_string_create(string);
  object[1] = a3;
  if (a3) {
    size_t v6 = 2;
  }
  else {
    size_t v6 = 1;
  }
  xpc_object_t v7 = xpc_dictionary_create((const char *const *)keys, object, v6);
  xpc_release(object[0]);
  if (a3 && a4) {
    xpc_release(a3);
  }
  return v7;
}

void sub_410B0(uint64_t a1, int a2)
{
  if (*(void *)(a1 + 144))
  {
    uint64_t v2 = *(NSObject **)(a1 + 176);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_4116C;
    block[3] = &unk_8D260;
    void block[4] = a1;
    int v4 = a2;
    uint64_t v5 = 1735159650;
    dispatch_async(v2, block);
  }
  else if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR))
  {
    sub_68F44();
  }
}

uint64_t sub_4116C(uint64_t a1)
{
  return (**(uint64_t (***)(void, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 144))(*(void *)(*(void *)(a1 + 32) + 144), 1, 1, a1 + 40);
}

void sub_4118C(uint64_t a1, void *a2)
{
  uint64_t v2 = qword_A1B28;
  if (a2)
  {
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void *))(*a2 + 16))(a2);
      LODWORD(__p) = 67109120;
      HIDWORD(__p) = v5;
      _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Invalidating mAudioObjectID %d", (uint8_t *)&__p, 8u);
    }
    size_t v6 = (uint64_t *)a2[52];
    if (v6)
    {
      unsigned int v7 = sub_7C98((uint64_t)a2);
      sub_4B08C(v6, v7);
    }
    std::string __p = 0;
    int v8 = (*(uint64_t (**)(void *))(*a2 + 16))(a2);
    uint64_t v9 = operator new(4uLL);
    std::string __p = v9;
    *uint64_t v9 = v8;
    uint64_t v12 = v9 + 1;
    uint64_t v11 = v9 + 1;
    sub_4133C(a1, (uint64_t)&__p);
    sub_410B0(a1, 1684370979);
    if (__p)
    {
      uint64_t v11 = __p;
      operator delete(__p);
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR))
  {
    sub_68F78();
  }
}

void sub_41314(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_4133C(uint64_t a1, uint64_t a2)
{
  v32[0] = 0;
  v32[1] = 0;
  sub_5CDCC((uint64_t)v32, a1 + 200);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  int v5 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = (uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2;
    *(_DWORD *)std::string buf = 134218240;
    *(void *)&uint8_t buf[4] = v6;
    __int16 v34 = 2048;
    CFIndex v35 = Count;
    _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Deleting %lu invalid audio devices, Total Number of Unified device = %ld", buf, 0x16u);
  }
  if (Count >= 1)
  {
    unsigned int v7 = (uint64_t *)(a1 + 456);
    uint64_t v27 = (uint64_t **)(a1 + 448);
    __int16 v26 = v29;
    do
    {
      CFNumberRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), Count - 1);
      uint64_t v9 = ValueAtIndex;
      if (ValueAtIndex)
      {
        sub_4B718((uint64_t)ValueAtIndex, (__int32 **)a2);
        unsigned __int8 v10 = qword_A1B28;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
        {
          if (v9[1136] || v9[1137] || v9[1139]) {
            uint64_t v11 = "No";
          }
          else {
            uint64_t v11 = "Yes";
          }
          uint64_t v12 = v9[1135];
          *(_DWORD *)std::string buf = 138543618;
          *(void *)&uint8_t buf[4] = v12;
          __int16 v34 = 2082;
          CFIndex v35 = (CFIndex)v11;
          _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "[%{public}@] Can Unified Device be released : %{public}s", buf, 0x16u);
        }
        if (!v9[1136] && !v9[1137] && !v9[1139])
        {
          sub_4B04((uint64_t)v9);
          sub_45330(a1, v9);
          uint64_t v13 = *v27;
          if (*v27 != v7)
          {
            while ((void *)v13[7] != v9)
            {
              unsigned __int8 v14 = (uint64_t *)v13[1];
              if (v14)
              {
                do
                {
                  CFIndex v15 = v14;
                  unsigned __int8 v14 = (uint64_t *)*v14;
                }
                while (v14);
              }
              else
              {
                do
                {
                  CFIndex v15 = (uint64_t *)v13[2];
                  BOOL v16 = *v15 == (void)v13;
                  uint64_t v13 = v15;
                }
                while (!v16);
              }
              uint64_t v13 = v15;
              if (v15 == v7) {
                goto LABEL_26;
              }
            }
            sub_486A8(v27, (uint64_t)v13);
          }
LABEL_26:
          uint64_t v17 = qword_A2348;
          uint64_t v18 = (*(uint64_t (**)(void *, uint64_t *))(*v9 + 16))(v9, v13);
          (*(void (**)(uint64_t, uint64_t))(*(void *)v17 + 32))(v17, v18);
          sub_5CEA4((uint64_t)v32);
          unsigned int v31 = 0;
          unsigned int v31 = (*(uint64_t (**)(void *))(*v9 + 16))(v9);
          v30[0] = 0;
          v30[1] = 0;
          sub_5CDCC((uint64_t)v30, a1 + 264);
          uint64_t v19 = sub_455A8(a1, v31);
          if (v19)
          {
            uint64_t v20 = +[BTAudioSmartRouteManager sharedInstance];
            id v21 = objc_alloc((Class)NSString);
            (*(void (**)(unsigned char *__return_ptr, void *))(*v9 + 832))(buf, v9);
            if (v36 >= 0) {
              int64_t v22 = buf;
            }
            else {
              int64_t v22 = *(unsigned char **)buf;
            }
            id v23 = [v21 initWithUTF8String:v22];
            if (v36 < 0) {
              operator delete(*(void **)buf);
            }
            [(BTAudioSmartRouteManager *)v20 unRegisterDevice:v23];

            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            v29[0] = sub_4563C;
            v29[1] = &unk_8D2C0;
            v29[2] = v9;
            dispatch_async(v19, block);
            dispatch_release(v19);
          }
          sub_309A4(a1 + 472, &v31);
          sub_5CEA4((uint64_t)v30);
          sub_5CDFC((uint64_t)v32);
          sub_5CF10(v30);
        }
      }
    }
    while (Count-- > 1);
  }
  sub_5CEA4((uint64_t)v32);
  return sub_5CF10(v32);
}

void sub_4178C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }
  sub_5CF10(&a20);
  sub_5CF10(&a23);
  _Unwind_Resume(a1);
}

uint64_t sub_417F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_B9AC(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v8 = *(void *)(a2 + 16);
  }
  uint64_t v5 = sub_4188C(a1, (char *)__p, a3);
  if (SHIBYTE(v8) < 0) {
    operator delete(__p[0]);
  }
  return v5;
}

void sub_41870(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_4188C(uint64_t a1, char *a2, uint64_t a3)
{
  v24[0] = 0;
  v24[1] = 0;
  sub_5CDCC((uint64_t)v24, a1 + 200);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  if (Count < 1)
  {
    uint64_t v19 = 0;
  }
  else
  {
    uint64_t v21 = a3;
    CFIndex v7 = 0;
    BOOL v8 = 1;
    while (1)
    {
      uint64_t ValueAtIndex = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v7);
      uint64_t v10 = ValueAtIndex;
      if (ValueAtIndex)
      {
        (*(void (**)(void *__return_ptr, uint64_t))(*(void *)ValueAtIndex + 832))(v22, ValueAtIndex);
        if (a2[23] < 0)
        {
          uint64_t v12 = *(char **)a2;
          unint64_t v11 = *((void *)a2 + 1);
        }
        else
        {
          unint64_t v11 = a2[23];
          uint64_t v12 = a2;
        }
        unsigned __int8 v13 = v23;
        unsigned __int8 v14 = (void *)v22[0];
        unint64_t v15 = (v23 & 0x80u) == 0 ? v23 : v22[1];
        BOOL v16 = (v23 & 0x80u) == 0 ? v22 : (void *)v22[0];
        size_t v17 = v15 >= v11 ? v11 : v15;
        uint64_t ValueAtIndex = memcmp(v12, v16, v17);
        BOOL v18 = v15 == v11 && ValueAtIndex == 0;
        if ((v13 & 0x80) != 0) {
          operator delete(v14);
        }
        if (v18) {
          break;
        }
      }
      BOOL v8 = ++v7 < Count;
      if (Count == v7) {
        goto LABEL_26;
      }
    }
    uint64_t ValueAtIndex = (uint64_t)sub_57D7C(v10, v21);
LABEL_26:
    if (v8) {
      uint64_t v19 = ValueAtIndex;
    }
    else {
      uint64_t v19 = 0;
    }
  }
  sub_5CF10(v24);
  return v19;
}

void sub_419F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_41A14()
{
  return (*(uint64_t (**)(void))(*(void *)qword_A2348 + 24))();
}

uint64_t sub_41A44(uint64_t a1, uint64_t a2)
{
  v13[0] = 0;
  v13[1] = 0;
  sub_5CDCC((uint64_t)v13, a1 + 200);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_B9AC(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
  }
  uint64_t v4 = sub_417F0(a1, (uint64_t)__p, 1953719151);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_B9AC(v9, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
    uint64_t v10 = *(void *)(a2 + 16);
  }
  uint64_t v5 = sub_417F0(a1, (uint64_t)v9, 1952539500);
  if (SHIBYTE(v10) < 0)
  {
    operator delete(v9[0]);
    if (v4) {
      goto LABEL_11;
    }
LABEL_14:
    BOOL v7 = 0;
    goto LABEL_16;
  }
  if (!v4) {
    goto LABEL_14;
  }
LABEL_11:
  if (sub_8D20(v4))
  {
    uint64_t v6 = 1;
    goto LABEL_22;
  }
  BOOL v7 = sub_3C2D8(v4) != 0;
LABEL_16:
  if (v5) {
    uint64_t v6 = 1;
  }
  else {
    uint64_t v6 = v7;
  }
  if (v5 && !v7) {
    uint64_t v6 = sub_8D20(v5);
  }
LABEL_22:
  sub_5CF10(v13);
  return v6;
}

void sub_41B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_5CF10(v21 - 48);
  _Unwind_Resume(a1);
}

uint64_t sub_41BC8(uint64_t a1, uint64_t a2)
{
  v13[0] = 0;
  v13[1] = 0;
  sub_5CDCC((uint64_t)v13, a1 + 200);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_B9AC(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v12 = *(void *)(a2 + 16);
  }
  uint64_t v4 = sub_417F0(a1, (uint64_t)__p, 1953719151);
  if (SHIBYTE(v12) < 0) {
    operator delete(__p[0]);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_B9AC(v9, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
    uint64_t v10 = *(void *)(a2 + 16);
  }
  uint64_t v5 = sub_417F0(a1, (uint64_t)v9, 1952539500);
  if (SHIBYTE(v10) < 0)
  {
    operator delete(v9[0]);
    if (v4) {
      goto LABEL_11;
    }
  }
  else if (v4)
  {
LABEL_11:
    BOOL v6 = sub_8AB4(v4);
    goto LABEL_14;
  }
  BOOL v6 = 0;
LABEL_14:
  if (v5) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = v6;
  }
  if (v5 && !v6) {
    uint64_t v7 = sub_8AB4(v5);
  }
  sub_5CF10(v13);
  return v7;
}

void sub_41CEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  sub_5CF10(v21 - 48);
  _Unwind_Resume(a1);
}

uint64_t sub_41D30(uint64_t a1, uint64_t a2)
{
  v6[0] = 0;
  v6[1] = 0;
  sub_5CDCC((uint64_t)v6, a1 + 200);
  uint64_t v4 = sub_41E30(*(void *)(a1 + 424), *(void *)(a1 + 432), a2);
  sub_41DA8(a1 + 424, v4, *(long long **)(a1 + 432));
  return sub_5CF10(v6);
}

void sub_41D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_41DA8(uint64_t a1, uint64_t a2, long long *a3)
{
  if ((long long *)a2 != a3)
  {
    sub_47A80((uint64_t)&v9, a3, *(long long **)(a1 + 8), a2);
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)(a1 + 8);
    if (v7 != v5)
    {
      do
      {
        if (*(char *)(v7 - 1) < 0) {
          operator delete(*(void **)(v7 - 24));
        }
        v7 -= 24;
      }
      while (v7 != v6);
    }
    *(void *)(a1 + 8) = v6;
  }
  return a2;
}

uint64_t sub_41E30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_47EE8(a1, a2, (unsigned __int8 **)a3);
  if (v5 == a2) {
    return a2;
  }
  uint64_t v6 = v5;
  uint64_t v7 = v5 + 24;
  if (v5 + 24 != a2)
  {
    uint64_t v8 = v5;
    while (1)
    {
      uint64_t v9 = v6;
      uint64_t v6 = v7;
      uint64_t v10 = *(unsigned __int8 *)(v9 + 47);
      if ((v10 & 0x80u) == 0) {
        uint64_t v11 = *(unsigned __int8 *)(v9 + 47);
      }
      else {
        uint64_t v11 = *(void *)(v9 + 32);
      }
      uint64_t v12 = *(unsigned __int8 *)(a3 + 23);
      int v13 = (char)v12;
      if ((v12 & 0x80u) != 0) {
        uint64_t v12 = *(void *)(a3 + 8);
      }
      if (v11 != v12) {
        goto LABEL_20;
      }
      if (v13 >= 0) {
        unsigned __int8 v14 = (unsigned __int8 *)a3;
      }
      else {
        unsigned __int8 v14 = *(unsigned __int8 **)a3;
      }
      if ((v10 & 0x80) != 0)
      {
        if (memcmp(*(const void **)v6, v14, *(void *)(v9 + 32))) {
          goto LABEL_20;
        }
      }
      else if (*(unsigned char *)(v9 + 47))
      {
        uint64_t v15 = 0;
        while (*(unsigned __int8 *)(v6 + v15) == v14[v15])
        {
          if (v10 == ++v15) {
            goto LABEL_23;
          }
        }
LABEL_20:
        if (*(char *)(v8 + 23) < 0) {
          operator delete(*(void **)v8);
        }
        long long v16 = *(_OWORD *)v6;
        *(void *)(v8 + 16) = *(void *)(v6 + 16);
        *(_OWORD *)uint64_t v8 = v16;
        v8 += 24;
        *(unsigned char *)(v9 + 47) = 0;
        *(unsigned char *)uint64_t v6 = 0;
      }
LABEL_23:
      uint64_t v7 = v6 + 24;
      if (v6 + 24 == a2) {
        return v8;
      }
    }
  }
  return v5;
}

uint64_t sub_41F58(void *a1, uint64_t a2, uint64_t a3, int a4, __CFString *a5)
{
  v45[0] = 0;
  v45[1] = 0;
  sub_5CDCC((uint64_t)v45, (uint64_t)(a1 + 25));
  uint64_t v9 = (char *)(a2 + 23);
  if (*(char *)(a2 + 23) < 0)
  {
    sub_B9AC(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v44 = *(void *)(a2 + 16);
  }
  uint64_t v10 = (void *)sub_42590((uint64_t)a1, (long long *)__p);
  if (SHIBYTE(v44) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v11 = qword_A1B28;
  if (v10)
  {
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = (*(uint64_t (**)(void *))(*v10 + 1312))(v10);
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v12;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = a3;
      _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "SynchronizeOwnershipChangeForDeviceAddr %d -> %d", buf, 0xEu);
    }
    if ((*(unsigned int (**)(void *))(*v10 + 1312))(v10) == a3)
    {
      if (a3)
      {
        size_t v17 = qword_A1B28;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 136315138;
          *(void *)&uint8_t buf[4] = "true";
          _os_log_impl(&dword_0, v17, OS_LOG_TYPE_DEFAULT, "Ownership didn't change, it already was %s", buf, 0xCu);
        }
        return sub_5CF10(v45);
      }
    }
    else
    {
      (*(void (**)(void *, uint64_t, uint64_t))(*v10 + 1320))(v10, a3, 1);
      if (a3)
      {
        int v13 = a1 + 53;
        unint64_t v14 = a1[54];
        if (v14 >= a1[55])
        {
          uint64_t v15 = sub_47B54(v13, (long long *)a2);
        }
        else
        {
          sub_47AF4(v13, (long long *)a2);
          uint64_t v15 = v14 + 24;
        }
        a1[54] = v15;
        double Current = CFAbsoluteTimeGetCurrent();
        memset(buf, 0, sizeof(buf));
        if (a5) {
          int64_t v22 = (char *)[(__CFString *)a5 UTF8String];
        }
        else {
          int64_t v22 = "";
        }
        sub_BAF4(buf, v22);
        uint64_t v24 = *(void *)(qword_A2350 + 328);
        if ((char)buf[23] < 0)
        {
          sub_B9AC(v33, *(void **)buf, *(unint64_t *)&buf[8]);
        }
        else
        {
          *(_OWORD *)int v33 = *(_OWORD *)buf;
          uint64_t v34 = *(void *)&buf[16];
        }
        sub_1E470(v24, 2, 0, 3, (int)Current, (uint64_t *)v33, 3);
        if (SHIBYTE(v34) < 0) {
          operator delete(v33[0]);
        }
        if ((char)buf[23] < 0)
        {
          unsigned __int8 v23 = *(void **)buf;
          goto LABEL_51;
        }
        return sub_5CF10(v45);
      }
    }
    if (!*(unsigned char *)(v10[1156] + 348) && a4)
    {
      BOOL v18 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        if (*v9 < 0)
        {
          uint64_t v19 = *(void *)a2;
          sub_B9AC(v37, *(void **)a2, *(void *)(a2 + 8));
        }
        else
        {
          *(_OWORD *)double v37 = *(_OWORD *)a2;
          uint64_t v38 = *(void *)(a2 + 16);
          uint64_t v19 = a2;
        }
        int v26 = sub_41A44((uint64_t)a1, (uint64_t)v37);
        uint64_t v27 = "not";
        if (v26) {
          uint64_t v27 = "still";
        }
        *(_DWORD *)std::string buf = 136446722;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v27;
        *(_WORD *)&unsigned char buf[22] = 2082;
        uint64_t v47 = "No";
        _os_log_impl(&dword_0, v18, OS_LOG_TYPE_DEFAULT, "Sending relinquishing of ownership for %{public}s. Device is %{public}s streaming. TiPi Connection: %{public}s", buf, 0x20u);
        if (SHIBYTE(v38) < 0) {
          operator delete(v37[0]);
        }
      }
      __int16 v28 = (void *)a1[48];
      if (*v9 < 0)
      {
        sub_B9AC(v35, *(void **)a2, *(void *)(a2 + 8));
      }
      else
      {
        *(_OWORD *)CFIndex v35 = *(_OWORD *)a2;
        uint64_t v36 = *(void *)(a2 + 16);
      }
      if (a5) {
        CFStringRef v29 = a5;
      }
      else {
        CFStringRef v29 = &stru_90900;
      }
      [v28 sendArbitrationMsg:@"DidTakeOwnership" forAddress:v35 withResponseIdentifier:v29];
      if (SHIBYTE(v36) < 0) {
        operator delete(v35[0]);
      }
    }
    uint64_t v30 = sub_41E30(a1[53], a1[54], a2);
    sub_41DA8((uint64_t)(a1 + 53), v30, (long long *)a1[54]);
    return sub_5CF10(v45);
  }
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
    sub_69024((char *)(a2 + 23), (void *)a2, v11);
  }
  if (a3)
  {
    long long v16 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_68FAC((char *)(a2 + 23), (void *)a2, v16);
    }
    if (*v9 < 0)
    {
      sub_B9AC(&__dst, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      long long __dst = *(_OWORD *)a2;
      uint64_t v42 = *(void *)(a2 + 16);
    }
    sub_42648((uint64_t)a1, (uint64_t)&__dst);
    if (SHIBYTE(v42) < 0)
    {
      unsigned __int8 v23 = (void *)__dst;
LABEL_51:
      operator delete(v23);
    }
  }
  else if (a4)
  {
    uint64_t v20 = (void *)a1[48];
    if (*v9 < 0)
    {
      sub_B9AC(v39, *(void **)a2, *(void *)(a2 + 8));
    }
    else
    {
      *(_OWORD *)int v39 = *(_OWORD *)a2;
      uint64_t v40 = *(void *)(a2 + 16);
    }
    uint64_t v25 = a5 ? a5 : &stru_90900;
    [v20 sendArbitrationMsg:@"DidTakeOwnership" forAddress:v39 withResponseIdentifier:v25];
    if (SHIBYTE(v40) < 0)
    {
      unsigned __int8 v23 = v39[0];
      goto LABEL_51;
    }
  }
  return sub_5CF10(v45);
}

void sub_424C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,int a41,__int16 a42,char a43,char a44,uint64_t a45,uint64_t a46,uint64_t a47,int a48,__int16 a49,char a50,char a51)
{
  sub_5CF10(v51 - 176);
  _Unwind_Resume(a1);
}

uint64_t sub_42590(uint64_t a1, long long *a2)
{
  v6[0] = 0;
  v6[1] = 0;
  sub_5CDCC((uint64_t)v6, a1 + 200);
  if (!*(void *)(a1 + 464) || a1 + 456 == sub_48618(a1 + 448, (const void **)a2))
  {
    uint64_t v4 = 0;
  }
  else
  {
    uint64_t v7 = a2;
    uint64_t v4 = sub_482D8((uint64_t **)(a1 + 448), (const void **)a2, (uint64_t)&unk_71834, &v7)[7];
  }
  sub_5CF10(v6);
  return v4;
}

void sub_42630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_42648(uint64_t a1, uint64_t a2)
{
  if (*(char *)(a2 + 23) < 0)
  {
    sub_B9AC(__p, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v9 = *(void *)(a2 + 16);
  }
  uint64_t v4 = sub_417F0(a1, (uint64_t)__p, 1953719151);
  if (SHIBYTE(v9) < 0) {
    operator delete(__p[0]);
  }
  if (*(char *)(a2 + 23) < 0)
  {
    sub_B9AC(v6, *(void **)a2, *(void *)(a2 + 8));
  }
  else
  {
    *(_OWORD *)uint64_t v6 = *(_OWORD *)a2;
    uint64_t v7 = *(void *)(a2 + 16);
  }
  uint64_t v5 = sub_417F0(a1, (uint64_t)v6, 1952539500);
  if (SHIBYTE(v7) < 0) {
    operator delete(v6[0]);
  }
  if (v4) {
    sub_8CCC(v4);
  }
  if (v5) {
    sub_8CCC(v5);
  }
}

void sub_42734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

void sub_42768(uint64_t a1, void **a2)
{
  uint64_t v4 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a2;
    if (*((char *)a2 + 23) < 0) {
      uint64_t v5 = *a2;
    }
    *(_DWORD *)std::string buf = 136446210;
    size_t v17 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Taking ownership for %{public}s", buf, 0xCu);
  }
  if (*((char *)a2 + 23) < 0)
  {
    sub_B9AC(__p, *a2, (unint64_t)a2[1]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)a2;
    uint64_t v15 = a2[2];
  }
  BOOL v6 = sub_4295C(a1, (unsigned __int8 **)__p);
  if (SHIBYTE(v15) < 0) {
    operator delete(__p[0]);
  }
  uint64_t v7 = *(void **)(a1 + 384);
  int v8 = *((char *)a2 + 23);
  if (v6)
  {
    if (v8 < 0)
    {
      sub_B9AC(&__dst, *a2, (unint64_t)a2[1]);
    }
    else
    {
      long long __dst = *(_OWORD *)a2;
      int v13 = a2[2];
    }
    [v7 handleDidTakeOwnership:&__dst withResponseIdentifier:0];
    if (SHIBYTE(v13) < 0)
    {
      p_dst = (void **)&__dst;
LABEL_21:
      operator delete(*p_dst);
    }
  }
  else
  {
    if (v8 < 0)
    {
      sub_B9AC(&v10, *a2, (unint64_t)a2[1]);
    }
    else
    {
      long long v10 = *(_OWORD *)a2;
      uint64_t v11 = a2[2];
    }
    [v7 sendArbitrationMsg:@"RequestOwnership" forAddress:&v10 withResponseIdentifier:0];
    if (SHIBYTE(v11) < 0)
    {
      p_dst = (void **)&v10;
      goto LABEL_21;
    }
  }
}

void sub_4290C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, char a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,char a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

BOOL sub_4295C(uint64_t a1, unsigned __int8 **a2)
{
  v8[0] = 0;
  v8[1] = 0;
  sub_5CDCC((uint64_t)v8, a1 + 200);
  uint64_t v4 = *(void *)(a1 + 424);
  uint64_t v5 = *(void *)(a1 + 432);
  char v9 = 0;
  BOOL v6 = sub_47EE8(v4, v5, a2) != *(void *)(a1 + 432);
  sub_5CF10(v8);
  return v6;
}

id sub_429C4(uint64_t a1)
{
  return [*(id *)(a1 + 384) isConnected];
}

BOOL sub_429CC(uint64_t a1, unsigned int *a2)
{
  int v2 = *a2;
  if ((int)*a2 <= 1819107690)
  {
    if (v2 > 1668641651)
    {
      BOOL v3 = v2 == 1668641652;
      int v4 = 1684370979;
    }
    else
    {
      BOOL v3 = v2 == 1650682995;
      int v4 = 1668047219;
    }
  }
  else if (v2 <= 1920168546)
  {
    BOOL v3 = v2 == 1819107691;
    int v4 = 1870098020;
  }
  else
  {
    BOOL v3 = v2 == 1920168547 || v2 == 1969841252;
    int v4 = 1937007734;
  }
  if (!v3 && v2 != v4) {
    return sub_42AA0(a1, a2);
  }
  if (a2[1] == 1735159650) {
    return a2[2] == 0;
  }
  return 0;
}

BOOL sub_42AA0(uint64_t a1, unsigned int *a2)
{
  uint64_t v2 = *(void *)(a1 + 368);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *a2;
  uint64_t v4 = a1 + 368;
  do
  {
    unsigned int v5 = *(_DWORD *)(v2 + 32);
    BOOL v6 = v5 >= v3;
    if (v5 >= v3) {
      uint64_t v7 = (uint64_t *)v2;
    }
    else {
      uint64_t v7 = (uint64_t *)(v2 + 8);
    }
    if (v6) {
      uint64_t v4 = v2;
    }
    uint64_t v2 = *v7;
  }
  while (*v7);
  if (v4 == a1 + 368) {
    return 0;
  }
  BOOL result = 0;
  if (v3 == 1667789414 && *(_DWORD *)(v4 + 32) < 0x63687267u)
  {
    if (a2[1] == 1735159650) {
      return a2[2] == 0;
    }
    return 0;
  }
  return result;
}

uint64_t sub_42B28(uint64_t a1, unsigned int *a2, unsigned char *a3)
{
  int v3 = *a2;
  if ((int)*a2 <= 1819107690)
  {
    if (v3 > 1668641651)
    {
      BOOL v4 = v3 == 1668641652;
      int v5 = 1684370979;
    }
    else
    {
      BOOL v4 = v3 == 1650682995;
      int v5 = 1668047219;
    }
  }
  else if (v3 <= 1920168546)
  {
    BOOL v4 = v3 == 1819107691;
    int v5 = 1870098020;
  }
  else
  {
    BOOL v4 = v3 == 1920168547 || v3 == 1969841252;
    int v5 = 1937007734;
  }
  if (v4 || v3 == v5)
  {
    uint64_t result = 0;
    *a3 = 0;
  }
  else
  {
    sub_42BF8(a1, a2, a3);
    return 2003332927;
  }
  return result;
}

uint64_t sub_42BF8(uint64_t a1, unsigned int *a2, unsigned char *a3)
{
  uint64_t v3 = *(void *)(a1 + 368);
  if (v3)
  {
    int v5 = (uint64_t **)(a1 + 360);
    uint64_t v6 = a1 + 368;
    unsigned int v7 = *a2;
    uint64_t v8 = v6;
    do
    {
      unsigned int v9 = *(_DWORD *)(v3 + 32);
      BOOL v10 = v9 >= v7;
      if (v9 >= v7) {
        uint64_t v11 = (uint64_t *)v3;
      }
      else {
        uint64_t v11 = (uint64_t *)(v3 + 8);
      }
      if (v10) {
        uint64_t v8 = v3;
      }
      uint64_t v3 = *v11;
    }
    while (*v11);
    if (v8 != v6 && v7 >= *(_DWORD *)(v8 + 32))
    {
      int v13 = a2;
      *a3 = *((unsigned char *)sub_48214(v5, a2, (uint64_t)&unk_71834, &v13)[5] + 16);
    }
  }
  return 2003332927;
}

uint64_t sub_42C98(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int *a5)
{
  v20[0] = 0;
  v20[1] = 0;
  sub_5CDCC((uint64_t)v20, a1 + 200);
  int v10 = *a2;
  int v11 = 4;
  if ((int)*a2 <= 1819107690)
  {
    if (v10 <= 1668641651)
    {
      if (v10 != 1650682995 && v10 != 1668047219) {
        goto LABEL_28;
      }
      goto LABEL_31;
    }
    if (v10 == 1668641652)
    {
      int v11 = 12 * *(_DWORD *)(a1 + 376);
      goto LABEL_31;
    }
    int v13 = 1684370979;
  }
  else
  {
    if (v10 > 1920168546)
    {
      if (v10 != 1920168547)
      {
        if (v10 != 1937007734 && v10 != 1969841252) {
          goto LABEL_28;
        }
LABEL_31:
        uint64_t v18 = 0;
        *a5 = v11;
        goto LABEL_32;
      }
LABEL_26:
      int v11 = 8;
      goto LABEL_31;
    }
    if (v10 == 1819107691) {
      goto LABEL_26;
    }
    int v13 = 1870098020;
  }
  if (v10 == v13)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
    if (Count < 1)
    {
      int v16 = 0;
    }
    else
    {
      CFIndex v15 = 0;
      int v16 = 0;
      do
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v15);
        if (ValueAtIndex[1136] || ValueAtIndex[1137] || ValueAtIndex[1139]) {
          ++v16;
        }
        ++v15;
      }
      while (Count != v15);
    }
    int v11 = 4 * v16;
    goto LABEL_31;
  }
LABEL_28:
  uint64_t v18 = sub_42E6C(a1, a2, v8, v9, a5);
LABEL_32:
  sub_5CF10(v20);
  return v18;
}

void sub_42E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_42E6C(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result = 2003332927;
  uint64_t v7 = *(void *)(a1 + 368);
  if (v7)
  {
    uint64_t v9 = (uint64_t **)(a1 + 360);
    uint64_t v10 = a1 + 368;
    unsigned int v11 = *a2;
    uint64_t v12 = v10;
    do
    {
      unsigned int v13 = *(_DWORD *)(v7 + 32);
      BOOL v14 = v13 >= v11;
      if (v13 >= v11) {
        CFIndex v15 = (uint64_t *)v7;
      }
      else {
        CFIndex v15 = (uint64_t *)(v7 + 8);
      }
      if (v14) {
        uint64_t v12 = v7;
      }
      uint64_t v7 = *v15;
    }
    while (*v15);
    if (v12 != v10 && v11 >= *(_DWORD *)(v12 + 32))
    {
      size_t v17 = a2;
      int v16 = sub_48214(v9, a2, (uint64_t)&unk_71834, &v17);
      uint64_t result = 0;
      *a5 = *((_DWORD *)v16[5] + 3);
    }
  }
  return result;
}

uint64_t sub_42F18(uint64_t a1, int *a2, uint64_t a3, int a4, const __CFString *a5, unsigned int a6, int *a7, CFDictionaryRef *a8)
{
  v31[0] = 0;
  v31[1] = 0;
  sub_5CDCC((uint64_t)v31, a1 + 200);
  int v17 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v17 <= 1668641651)
    {
      if (v17 == 1650682995)
      {
        if (a6 <= 3)
        {
          uint64_t v18 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
            sub_6909C();
          }
          goto LABEL_56;
        }
        uint64_t v18 = 0;
        int v26 = 1634689642;
      }
      else
      {
        if (v17 != 1668047219) {
          goto LABEL_41;
        }
        if (a6 <= 3)
        {
          uint64_t v18 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
            sub_690D0();
          }
          goto LABEL_56;
        }
        uint64_t v18 = 0;
        int v26 = 1634757735;
      }
      *(_DWORD *)a8 = v26;
LABEL_52:
      int v25 = 4;
      goto LABEL_55;
    }
    if (v17 == 1668641652)
    {
      unsigned int v30 = a6 / 0xC;
      sub_4343C(a1, (uint64_t)a8, &v30);
      uint64_t v18 = 0;
      int v25 = 12 * v30;
LABEL_55:
      *a7 = v25;
      goto LABEL_56;
    }
    int v19 = 1684370979;
    goto LABEL_19;
  }
  if (v17 <= 1920168546)
  {
    if (v17 == 1819107691)
    {
      if (a6 <= 3)
      {
        uint64_t v18 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
          sub_69138();
        }
        goto LABEL_56;
      }
      CFDictionaryRef v27 = (const __CFDictionary *)CFRetain(@"Apple Inc.");
LABEL_54:
      uint64_t v18 = 0;
      *a8 = v27;
      int v25 = 8;
      goto LABEL_55;
    }
    int v19 = 1870098020;
LABEL_19:
    if (v17 == v19)
    {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
      if (Count < 1)
      {
        unsigned int v22 = 0;
      }
      else
      {
        CFIndex v21 = 0;
        unsigned int v22 = 0;
        unsigned int v23 = (a6 >> 2) + 1;
        do
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v21);
          if (ValueAtIndex[1136] || ValueAtIndex[1137] || ValueAtIndex[1139])
          {
            *((_DWORD *)a8 + v22++) = (*(uint64_t (**)(void *))(*ValueAtIndex + 16))(ValueAtIndex);
            if (v22 > v23) {
              break;
            }
          }
          ++v21;
        }
        while (Count != v21);
      }
      uint64_t v18 = 0;
      int v25 = 4 * v22;
      goto LABEL_55;
    }
LABEL_41:
    uint64_t v18 = sub_4350C(a1, a2, v15, v16, a6, a7, a8);
    goto LABEL_56;
  }
  if (v17 == 1920168547)
  {
    if (a6 <= 3)
    {
      uint64_t v18 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69208();
      }
      goto LABEL_56;
    }
    CFDictionaryRef v27 = (const __CFDictionary *)CFRetain(&stru_90900);
    goto LABEL_54;
  }
  if (v17 == 1937007734)
  {
    if (a6 <= 3)
    {
      uint64_t v18 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69104();
      }
      goto LABEL_56;
    }
    uint64_t v18 = 0;
    *(_DWORD *)a8 = 0;
    goto LABEL_52;
  }
  if (v17 != 1969841252) {
    goto LABEL_41;
  }
  if (a6 <= 3)
  {
    uint64_t v18 = 561211770;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_6916C();
    }
    goto LABEL_56;
  }
  if (a4 == 8)
  {
    uint64_t v18 = 561211770;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_691A0();
    }
    goto LABEL_56;
  }
  if (a5)
  {
    int v29 = sub_43374(a1, a5);
    uint64_t v18 = 0;
    *(_DWORD *)a8 = v29;
    goto LABEL_52;
  }
  uint64_t v18 = 561211770;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
    sub_691D4();
  }
LABEL_56:
  sub_5CF10(v31);
  return v18;
}

void sub_43354(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_43374(uint64_t a1, const __CFString *a2)
{
  if (CFArrayGetCount(*(CFArrayRef *)(a1 + 336)) < 1) {
    return 0;
  }
  CFIndex v4 = 0;
  for (unsigned int i = 1; ; ++i)
  {
    uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v4);
    CFStringRef v7 = (const __CFString *)sub_7904((uint64_t)ValueAtIndex);
    if (CFEqual(v7, a2)) {
      break;
    }
    CFIndex v4 = i;
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 336)) <= i) {
      return 0;
    }
  }
  uint64_t v10 = *(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 16);

  return v10(ValueAtIndex);
}

uint64_t sub_4343C(uint64_t result, uint64_t a2, unsigned int *a3)
{
  if (*a3)
  {
    unsigned int v3 = *(_DWORD *)(result + 376);
    if (*a3 > v3)
    {
      unsigned int v11 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_6923C(v11, v12, v13, v14, v15, v16, v17, v18);
      }
      abort();
    }
    CFIndex v4 = *(void **)(result + 360);
    if (v4 != (void *)(result + 368))
    {
      unsigned int v5 = 0;
      do
      {
        uint64_t v6 = v4[5];
        uint64_t v7 = a2 + 12 * v5;
        *(void *)uint64_t v7 = *(void *)v6;
        *(_DWORD *)(v7 + 8) = *(_DWORD *)(v6 + 8);
        if (++v5 == *a3) {
          break;
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v4[2];
            BOOL v10 = *v9 == (void)v4;
            CFIndex v4 = v9;
          }
          while (!v10);
        }
        CFIndex v4 = v9;
      }
      while (v9 != (void *)(result + 368));
    }
    *a3 = v3;
  }
  return result;
}

uint64_t sub_4350C(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, unsigned int a5, _DWORD *a6, CFDictionaryRef *a7)
{
  if (*a2 != 1667789414) {
    return 0;
  }
  if (a5 > 7)
  {
    *a7 = 0;
    *a6 = 0;
    CFDictionaryRef v10 = sub_45768(a1);
    if (v10)
    {
      uint64_t v7 = 0;
      *a7 = v10;
      *a6 = 8;
      return v7;
    }
    return 0;
  }
  uint64_t v7 = 561211770;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
    sub_692B4();
  }
  return v7;
}

uint64_t sub_435AC()
{
  return 2003332927;
}

void sub_435B8(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  v15[0] = @"Status";
  v16[0] = +[NSNumber numberWithInt:a1];
  v15[1] = @"Error";
  v16[1] = +[NSNumber numberWithUnsignedInt:a2];
  v15[2] = @"Profile";
  if (*((char *)a3 + 23) < 0) {
    a3 = (uint64_t *)*a3;
  }
  v16[2] = +[NSString stringWithUTF8String:a3];
  _DWORD v15[3] = @"DeviceType";
  v16[3] = +[NSNumber numberWithUnsignedInt:a4];
  v15[4] = @"Duration";
  v16[4] = +[NSNumber numberWithUnsignedLongLong:a5];
  +[NSDictionary dictionaryWithObjects:v16 forKeys:v15 count:5];
  int v9 = AnalyticsSendEventLazy();
  CFDictionaryRef v10 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 138412546;
    CFStringRef v12 = @"com.apple.Bluetooth.StartIOInfo";
    __int16 v13 = 1024;
    int v14 = v9;
    _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "BT Start IO Stats for metric '%@' sent to CoreAnalytics with result %u", buf, 0x12u);
  }
}

uint64_t sub_43798(uint64_t a1)
{
  return *(void *)(a1 + 32);
}

std::string *sub_437A0@<X0>(int a1@<W0>, std::string *a2@<X8>)
{
  a2->__r_.__value_.__r.__words[0] = 0;
  a2->__r_.__value_.__l.__size_ = 0;
  a2->__r_.__value_.__r.__words[2] = 0;
  sub_BAF4(a2, "");
  CFIndex v4 = "kBluetoothAudioDeviceTypeLEA";
  if (a1 == 1952539500) {
    unsigned int v5 = "kBluetoothAudioDeviceTypeA2DP";
  }
  else {
    unsigned int v5 = "unknown";
  }
  if (a1 != 1953260897) {
    CFIndex v4 = v5;
  }
  if (a1 == 1953719151) {
    uint64_t v6 = "kBluetoothAudioDeviceTypeSCO";
  }
  else {
    uint64_t v6 = v4;
  }
  return std::string::assign(a2, v6);
}

void sub_43834(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t AudioServerPlugIn_Create(uint64_t a1, const void *a2)
{
  CFUUIDRef v3 = CFUUIDGetConstantUUIDWithBytes(0, 0x44u, 0x3Au, 0xBAu, 0xB8u, 0xE7u, 0xB3u, 0x49u, 0x1Au, 0xB9u, 0x85u, 0xBEu, 0xB9u, 0x18u, 0x70u, 0x30u, 0xDBu);
  if (CFEqual(a2, v3)) {
    operator new();
  }
  return 0;
}

void sub_43900()
{
}

const void *sub_43924(uint64_t a1, int a2)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_5CDCC((uint64_t)v10, a1 + 200);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  if (Count < 1)
  {
LABEL_8:
    uint64_t v8 = 0;
  }
  else
  {
    CFIndex v5 = 0;
    while (1)
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v5);
      if (ValueAtIndex)
      {
        uint64_t v7 = sub_57D7C((uint64_t)ValueAtIndex, 1952539500);
        uint64_t v8 = v7;
        if (v7)
        {
          if ((*(unsigned int (**)(const void *))(*(void *)v7 + 296))(v7)
            && (*(unsigned int (**)(const void *))(*(void *)v8 + 16))(v8) != a2)
          {
            break;
          }
        }
      }
      if (Count == ++v5) {
        goto LABEL_8;
      }
    }
  }
  sub_5CF10(v10);
  return v8;
}

void sub_43A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_43A48(uint64_t a1, uint64_t a2)
{
  v11[0] = 0;
  v11[1] = 0;
  sub_5CDCC((uint64_t)v11, a1 + 200);
  CFIndex v4 = sub_43924(a1, a2);
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (v4) {
    BOOL v6 = v5 == 0;
  }
  else {
    BOOL v6 = 1;
  }
  uint64_t v7 = !v6;
  if (!v6) {
    operator new();
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v13 = 0;
  sub_BAF4(buf, "WS_ERROR_AGGREGATE_DEVICES_BT");
  if (SHIBYTE(v13) < 0)
  {
    sub_B9AC(__p, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v10 = v13;
  }
  if (SHIBYTE(v10) < 0) {
    operator delete(__p[0]);
  }
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
    sub_692E8();
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(*(void **)buf);
  }
  sub_5CF10(v11);
  return v7;
}

void sub_43D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0) {
    operator delete(__p);
  }
  sub_5CF10(&a13);
  _Unwind_Resume(a1);
}

void sub_43DE0()
{
}

void sub_43DE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
  {
    sub_49F68(a2, 1752327777);
    sub_49F68(a2, 1936745318);
  }
  else
  {
    uint64_t v5 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Wireless Splitter: Couldn't find device1", buf, 2u);
    }
  }
  if (a3)
  {
    sub_49F68(a3, 1752327777);
    sub_49F68(a3, 1936745318);
  }
  else
  {
    BOOL v6 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v7 = 0;
      _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Wireless Splitter: Couldn't find device2", v7, 2u);
    }
  }
}

void sub_43EE0(uint64_t a1, void *a2, void *a3)
{
  if (sub_4424C(a1, a2) && (BOOL v6 = sub_4424C(a1, a2), (v7 = v6[1136]) != 0))
  {
    if (*(unsigned char *)(v7 + 192)) {
      uint64_t v8 = v6[1136];
    }
    else {
      uint64_t v8 = 0;
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  if (sub_4424C(a1, a3))
  {
    int v9 = sub_4424C(a1, a3);
    uint64_t v10 = v9[1136];
    if (v10)
    {
      uint64_t v11 = *(unsigned char *)(v10 + 192) ? v9[1136] : 0;
      if (v8 && v11) {
        operator new();
      }
    }
  }
  memset(buf, 0, sizeof(buf));
  uint64_t v15 = 0;
  sub_BAF4(buf, "WS_ERROR_AGGREGATE_DEVICES_CA");
  if (SHIBYTE(v15) < 0)
  {
    sub_B9AC(__p, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v13 = v15;
  }
  if (SHIBYTE(v13) < 0) {
    operator delete(__p[0]);
  }
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
    sub_6931C();
  }
  if (SHIBYTE(v15) < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_441F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
}

void *sub_4424C(uint64_t a1, void *a2)
{
  v8[0] = 0;
  v8[1] = 0;
  sub_5CDCC((uint64_t)v8, a1 + 200);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  if (Count < 1)
  {
LABEL_5:
    uint64_t ValueAtIndex = 0;
  }
  else
  {
    CFIndex v5 = 0;
    while (1)
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v5);
      if (![a2 compare:ValueAtIndex[1135]]) {
        break;
      }
      if (Count == ++v5) {
        goto LABEL_5;
      }
    }
  }
  sub_5CF10(v8);
  return ValueAtIndex;
}

void sub_442EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

CFArrayRef sub_44308(uint64_t a1)
{
  v5[0] = 0;
  v5[1] = 0;
  sub_5CDCC((uint64_t)v5, a1 + 200);
  uint64_t v2 = *(void *)(a1 + 400);
  if (v2 == *(void *)(a1 + 392)) {
    CFArrayRef v3 = 0;
  }
  else {
    CFArrayRef v3 = sub_C4F8(*(uint64_t **)(v2 - 8));
  }
  sub_5CF10(v5);
  return v3;
}

void sub_4436C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_44380(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 400);
  if (v1 != *(void *)(a1 + 392)) {
    sub_C274(*(float **)(v1 - 8));
  }
}

float sub_44398(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 400);
  if (v1 != *(void *)(a1 + 392)) {
    return *(float *)(*(void *)(v1 - 8) + 24);
  }
  CFArrayRef v3 = qword_A1B28;
  float v2 = 0.5;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
    sub_69350(v3, v4, v5, v6, v7, v8, v9, v10);
  }
  return v2;
}

float *sub_44400(float *result, float a2)
{
  uint64_t v2 = *((void *)result + 50);
  if (v2 != *((void *)result + 49))
  {
    uint64_t v4 = result;
    uint64_t v5 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 134217984;
      double v7 = a2;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Wireless Splitter : setting individual device volume from main volume %f", (uint8_t *)&v6, 0xCu);
      uint64_t v2 = *((void *)v4 + 50);
    }
    uint64_t result = sub_C40C(*(float ***)(v2 - 8), a2);
    *(float *)(*(void *)(*((void *)v4 + 50) - 8) + 24) = a2;
  }
  return result;
}

uint64_t sub_444E0(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 400);
  if (v2 == *(void *)(a1 + 392)) {
    return 0;
  }
  uint64_t v5 = *(void **)(v2 - 8);
  if (*v5)
  {
    BOOL v6 = (*(unsigned int (**)(void))(*(void *)*v5 + 16))(*v5) == a2;
    uint64_t v5 = *(void **)(*(void *)(a1 + 400) - 8);
  }
  else
  {
    BOOL v6 = 0;
  }
  uint64_t v7 = v5[1];
  if (v7) {
    return (*(unsigned int (**)(uint64_t))(*(void *)v7 + 16))(v7) == a2 || v6;
  }
  return v6;
}

void sub_445A0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 400);
  if (v2 != *(void *)(a1 + 392))
  {
    sub_C174(*(void **)(v2 - 8), a2);
    uint64_t v5 = *(uint64_t **)(*(void *)(a1 + 400) - 8);
    uint64_t v6 = *v5;
    if (*v5 && (uint64_t v7 = v5[1]) != 0)
    {
      sub_43DE8(v4, *(void *)(v6 + 416), *(void *)(v7 + 416));
    }
    else
    {
      uint64_t v8 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v9 = @"valid";
        if (v6) {
          CFStringRef v10 = @"valid";
        }
        else {
          CFStringRef v10 = @"in-valid";
        }
        if (!v5[1]) {
          CFStringRef v9 = @"in-valid";
        }
        int v12 = 138412546;
        CFStringRef v13 = v10;
        __int16 v14 = 2112;
        CFStringRef v15 = v9;
        _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Wireless Splitter: user1 is %@ user2 is %@", (uint8_t *)&v12, 0x16u);
      }
    }
    uint64_t v11 = *(void **)(*(void *)(a1 + 400) - 8);
    if (!*v11 || !v11[1]) {
      sub_446D4(a1);
    }
  }
}

uint64_t sub_446D4(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 400);
  if (v1 != *(void *)(result + 392))
  {
    uint64_t v2 = result;
    CFArrayRef v3 = *(uint64_t **)(v1 - 8);
    uint64_t v4 = *v3;
    if (*v3 && (uint64_t v5 = v3[1]) != 0)
    {
      sub_43DE8(result, *(void *)(v4 + 416), *(void *)(v5 + 416));
    }
    else
    {
      uint64_t v6 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v7 = @"valid";
        if (v4) {
          CFStringRef v8 = @"valid";
        }
        else {
          CFStringRef v8 = @"in-valid";
        }
        if (!v3[1]) {
          CFStringRef v7 = @"in-valid";
        }
        int v11 = 138412546;
        CFStringRef v12 = v8;
        __int16 v13 = 2112;
        CFStringRef v14 = v7;
        _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Wireless Splitter: user1 is %@ user2 is %@", (uint8_t *)&v11, 0x16u);
      }
    }
    uint64_t v9 = *(void *)(v2 + 400);
    uint64_t v10 = *(void *)(v9 - 8);
    *(void *)(v9 - 8) = 0;
    if (v10) {
      operator delete();
    }
    return sub_47880(v2 + 392, *(void **)(v2 + 392));
  }
  return result;
}

void sub_44810(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 400);
  if (v1 != *(void *)(a1 + 392)) {
    sub_BF3C(*(void *)(v1 - 8));
  }
}

uint64_t sub_44828(uint64_t result, int a2)
{
  uint64_t v2 = *(void *)(result + 400);
  if (v2 != *(void *)(result + 392)) {
    return sub_C6FC(*(void **)(v2 - 8), a2);
  }
  return result;
}

void sub_44840(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 400);
  if (v1 == *(void *)(a1 + 392))
  {
    memset(buf, 0, sizeof(buf));
    sub_BAF4(buf, "WS_ERROR_AGGREGATE_DEVICE_COUNT_0");
    if ((char)buf[23] < 0)
    {
      sub_B9AC(v15, *(void **)buf, *(unint64_t *)&buf[8]);
    }
    else
    {
      *(_OWORD *)CFStringRef v15 = *(_OWORD *)buf;
      uint64_t v16 = *(void *)&buf[16];
    }
    if (SHIBYTE(v16) < 0) {
      operator delete(v15[0]);
    }
    __int16 v13 = qword_A1B28;
    if (!os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_31;
    }
    *(_WORD *)uint64_t v17 = 0;
    CFStringRef v14 = "Wireless Splitter: The device count in the mAggregateDevices list is 0";
    goto LABEL_30;
  }
  uint64_t v2 = *(void **)(v1 - 8);
  uint64_t v3 = *(void *)(*v2 + 416);
  if (*(void *)(v3 + 9080) && *(void *)(*(void *)(v2[1] + 416) + 9080))
  {
    uint64_t v5 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Wireless Splitter: Send aggregation notification of both users", buf, 2u);
      uint64_t v3 = *(void *)(**(void **)(*(void *)(a1 + 400) - 8) + 416);
    }
    sub_49F68(v3, 2004050279);
    uint64_t v6 = sub_49F68(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 400) - 8) + 8) + 416), 2004050279);
    CFStringRef v7 = *(uint64_t **)(*(void *)(a1 + 400) - 8);
    uint64_t v8 = *v7;
    if (*v7 && (uint64_t v9 = v7[1]) != 0)
    {
      sub_43DE8(v6, *(void *)(v8 + 416), *(void *)(v9 + 416));
    }
    else
    {
      uint64_t v10 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v11 = @"valid";
        if (v8) {
          CFStringRef v12 = @"valid";
        }
        else {
          CFStringRef v12 = @"in-valid";
        }
        if (!v7[1]) {
          CFStringRef v11 = @"in-valid";
        }
        *(_DWORD *)std::string buf = 138412546;
        *(void *)&uint8_t buf[4] = v12;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v11;
        _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Wireless Splitter: user1 is %@ user2 is %@", buf, 0x16u);
      }
    }
    return;
  }
  memset(buf, 0, sizeof(buf));
  sub_BAF4(buf, "WS_ERROR_AGGREGATE_DEVICES_NOT_READY");
  if ((char)buf[23] < 0)
  {
    sub_B9AC(__p, *(void **)buf, *(unint64_t *)&buf[8]);
  }
  else
  {
    *(_OWORD *)std::string __p = *(_OWORD *)buf;
    uint64_t v19 = *(void *)&buf[16];
  }
  if (SHIBYTE(v19) < 0) {
    operator delete(__p[0]);
  }
  __int16 v13 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v17 = 0;
    CFStringRef v14 = "Wireless Splitter: Not all devices are ready to aggregate";
LABEL_30:
    _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, v14, v17, 2u);
  }
LABEL_31:
  if ((char)buf[23] < 0) {
    operator delete(*(void **)buf);
  }
}

void sub_44B10(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 - 41) < 0) {
    operator delete(*(void **)(v1 - 64));
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_44B38(uint64_t a1, unsigned int a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  void v3[2] = sub_44C40;
  uint64_t v3[3] = &unk_8D200;
  unsigned int v4 = a2;
  return sub_44BA4(a1, a2, v3);
}

uint64_t sub_44BA4(uint64_t a1, unsigned int a2, void *a3)
{
  v12[0] = 0;
  v12[1] = 0;
  sub_5CDCC((uint64_t)v12, a1 + 264);
  uint64_t v6 = *(void *)(a1 + 480);
  if (v6)
  {
    uint64_t v7 = a1 + 480;
    do
    {
      unsigned int v8 = *(_DWORD *)(v6 + 32);
      BOOL v9 = v8 >= a2;
      if (v8 >= a2) {
        uint64_t v10 = (uint64_t *)v6;
      }
      else {
        uint64_t v10 = (uint64_t *)(v6 + 8);
      }
      if (v9) {
        uint64_t v7 = v6;
      }
      uint64_t v6 = *v10;
    }
    while (*v10);
    if (v7 != a1 + 480 && *(_DWORD *)(v7 + 32) <= a2) {
      dispatch_async(*(dispatch_queue_t *)(v7 + 40), a3);
    }
  }
  return sub_5CF10(v12);
}

void *sub_44C40(uint64_t a1)
{
  uint64_t result = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 32));
  if (result && *((unsigned char *)result + 192))
  {
    return (void *)sub_589B4((uint64_t)result);
  }
  return result;
}

void *sub_44C8C(uint64_t a1, int a2)
{
  v9[0] = 0;
  v9[1] = 0;
  sub_5CDCC((uint64_t)v9, a1 + 200);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  if (Count < 1)
  {
LABEL_8:
    uint64_t v7 = 0;
  }
  else
  {
    CFIndex v5 = 0;
    while (1)
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v5);
      uint64_t v7 = ValueAtIndex;
      if ((ValueAtIndex[1136] || ValueAtIndex[1137] || ValueAtIndex[1139])
        && (*(unsigned int (**)(void *))(*ValueAtIndex + 16))(ValueAtIndex) == a2)
      {
        break;
      }
      if (Count == ++v5) {
        goto LABEL_8;
      }
    }
  }
  sub_5CF10(v9);
  return v7;
}

void sub_44D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_44D7C(uint64_t a1, uint64_t a2, char a3, char a4, char a5, char a6, char a7)
{
  v31[0] = 0;
  v31[1] = 0;
  sub_5CDCC((uint64_t)v31, a1 + 200);
  char v21 = a3;
  char v22 = a4;
  char v23 = a5;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  if (Count >= 1)
  {
    CFIndex v15 = 0;
    while (1)
    {
      uint64_t ValueAtIndex = (id *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v15);
      id v17 = objc_msgSend(objc_msgSend(ValueAtIndex[1135], "componentsSeparatedByString:", @"-"), "firstObject");
      uint64_t v18 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 138412802;
        id v33 = v17;
        __int16 v34 = 2048;
        CFIndex v35 = v15;
        __int16 v36 = 2112;
        uint64_t v37 = a2;
        _os_log_impl(&dword_0, v18, OS_LOG_TYPE_DEFAULT, "Device Address: %@ for index: %ld, btAddr: %@", buf, 0x20u);
      }
      if ([v17 isEqualToString:a2]) {
        break;
      }
      if (Count == ++v15) {
        return sub_5CF10(v31);
      }
    }
    unsigned int v19 = (*((uint64_t (**)(id *))*ValueAtIndex + 2))(ValueAtIndex);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    void v24[2] = sub_44FD8;
    v24[3] = &unk_8F300;
    unsigned int v25 = v19;
    v24[4] = a2;
    char v26 = v21;
    char v27 = v22;
    char v28 = v23;
    char v29 = a6;
    char v30 = a7;
    sub_44BA4(a1, v19, v24);
  }
  return sub_5CF10(v31);
}

void sub_44FAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

void sub_44FD8(uint64_t a1)
{
  uint64_t v2 = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 40));
  if (v2 && *((unsigned char *)v2 + 192))
  {
    uint64_t v3 = *(void **)(a1 + 32);
    int v4 = *(unsigned __int8 *)(a1 + 44);
    int v5 = *(unsigned __int8 *)(a1 + 45);
    int v6 = *(unsigned __int8 *)(a1 + 46);
    int v7 = *(unsigned __int8 *)(a1 + 47);
    int v8 = *(unsigned __int8 *)(a1 + 48);
    sub_5B11C(v2, v3, v4, v5, v6, v7, v8);
  }
}

uint64_t sub_45048(uint64_t a1, const void *a2)
{
  v11[0] = 0;
  v11[1] = 0;
  sub_5CDCC((uint64_t)v11, a1 + 200);
  int v4 = qword_A1B28;
  if (!a2)
  {
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_693C4();
    }
    goto LABEL_13;
  }
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = (*(uint64_t (**)(const void *))(*(void *)a2 + 16))(a2);
    *(_DWORD *)std::string buf = 67109120;
    int v13 = v5;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Adding BTUnifiedAudioDevice %d", buf, 8u);
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  if (Count < 1)
  {
LABEL_8:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 336), a2);
    sub_5CEA4((uint64_t)v11);
    uint64_t v8 = 1;
  }
  else
  {
    CFIndex v7 = 0;
    while (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v7) != a2)
    {
      if (Count == ++v7) {
        goto LABEL_8;
      }
    }
    BOOL v9 = qword_A1B28;
    uint64_t v8 = 0;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v9, OS_LOG_TYPE_DEFAULT, "Unified Audio device already in list", buf, 2u);
LABEL_13:
      uint64_t v8 = 0;
    }
  }
  sub_5CF10(v11);
  return v8;
}

void sub_451F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_45218(uint64_t a1, const void *a2)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_5CDCC((uint64_t)v10, a1 + 200);
  if (!a2)
  {
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_693C4();
    }
    goto LABEL_9;
  }
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
  if (Count < 1)
  {
LABEL_9:
    uint64_t v6 = 0;
    goto LABEL_10;
  }
  CFIndex v5 = 0;
  while (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v5) != a2)
  {
    if (Count == ++v5) {
      goto LABEL_9;
    }
  }
  uint64_t v8 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v9 = 0;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "Unified Audio device already published", v9, 2u);
  }
  uint64_t v6 = 1;
LABEL_10:
  sub_5CF10(v10);
  return v6;
}

void sub_45318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

void sub_45330(uint64_t a1, void *a2)
{
  if (a2)
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
    if (Count >= 1)
    {
      CFIndex v5 = Count;
      CFIndex v6 = 0;
      while (CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 336), v6) != a2)
      {
        if (v5 == ++v6) {
          return;
        }
      }
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 336), v6);
      CFIndex v7 = qword_A1B28;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = a2[1135];
        int v9 = (*(uint64_t (**)(void *))(*a2 + 16))(a2);
        int v16 = 138543618;
        uint64_t v17 = v8;
        __int16 v18 = 1024;
        int v19 = v9;
        _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Deleting BTUnifiedAudioDevice [%{public}@] ID = %d From Unified device list", (uint8_t *)&v16, 0x12u);
      }
      CFArrayGetCount(*(CFArrayRef *)(a1 + 336));
      uint64_t v10 = a2[1156];
      if (*(unsigned char *)(v10 + 144) || *(unsigned char *)(v10 + 274))
      {
        CFStringRef v11 = +[BTAudioAVNotificationMonitor sharedInstance];
        if (v11)
        {
          CFStringRef v12 = v11;
          [(BTAudioAVNotificationMonitor *)v11 unRegisterNowPlayingListener:(*(uint64_t (**)(void *))(*a2 + 16))(a2)];
          [(BTAudioAVNotificationMonitor *)v12 unRegisterPersonalizedVolumeListener:(*(uint64_t (**)(void *))(*a2 + 16))(a2) deviceUID:a2[1135]];
          [(BTAudioAVNotificationMonitor *)v12 processManualVolumeUpdates:0];
        }
      }
      if (!CFArrayGetCount(*(CFArrayRef *)(a1 + 336)))
      {
        int v13 = *(const void **)(a1 + 352);
        if (v13)
        {
          CFStringRef v14 = qword_A1B28;
          if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
          {
            int v15 = CFGetRetainCount(v13);
            int v16 = 67109120;
            LODWORD(v17) = v15;
            _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "Spatial Profile : HRTF no longer required in plugin: Trigger Release %d", (uint8_t *)&v16, 8u);
            int v13 = *(const void **)(a1 + 352);
          }
          CFRelease(v13);
        }
        *(void *)(a1 + 352) = 0;
      }
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR))
  {
    sub_693C4();
  }
}

uint64_t sub_455A8(uint64_t a1, unsigned int a2)
{
  v11[0] = 0;
  v11[1] = 0;
  sub_5CDCC((uint64_t)v11, a1 + 264);
  uint64_t v4 = *(void *)(a1 + 480);
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = a1 + 480;
  do
  {
    unsigned int v6 = *(_DWORD *)(v4 + 32);
    BOOL v7 = v6 >= a2;
    if (v6 >= a2) {
      uint64_t v8 = (uint64_t *)v4;
    }
    else {
      uint64_t v8 = (uint64_t *)(v4 + 8);
    }
    if (v7) {
      uint64_t v5 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v5 != a1 + 480 && *(_DWORD *)(v5 + 32) <= a2) {
    uint64_t v9 = *(void *)(v5 + 40);
  }
  else {
LABEL_12:
  }
    uint64_t v9 = 0;
  sub_5CF10(v11);
  return v9;
}

uint64_t sub_4563C(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, qword_A2350 + 200);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return sub_5CF10(v4);
}

uint64_t sub_456B0(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  v17[0] = 0;
  v17[1] = 0;
  sub_5CDCC((uint64_t)v17, a1 + 264);
  uint64_t v8 = *(void *)(a1 + 480);
  if (v8)
  {
    uint64_t v9 = a1 + 480;
    uint64_t v10 = a1 + 480;
    do
    {
      unsigned int v11 = *(_DWORD *)(v8 + 32);
      BOOL v12 = v11 >= a3;
      if (v11 >= a3) {
        int v13 = (uint64_t *)v8;
      }
      else {
        int v13 = (uint64_t *)(v8 + 8);
      }
      if (v12) {
        uint64_t v10 = v8;
      }
      uint64_t v8 = *v13;
    }
    while (*v13);
    if (v10 != v9 && *(_DWORD *)(v10 + 32) <= a3 && a4 != 0)
    {
      dispatch_time_t v15 = dispatch_time(0, 1000000 * a2);
      dispatch_after(v15, *(dispatch_queue_t *)(v10 + 40), a4);
    }
  }
  return sub_5CF10(v17);
}

CFDictionaryRef sub_45768(uint64_t a1)
{
  CFDataRef v1 = *(const __CFData **)(a1 + 352);
  if (v1) {
    CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, v1);
  }
  else {
    CFDataRef Copy = (CFDataRef)objc_alloc_init((Class)NSData);
  }
  CFDataRef v3 = Copy;
  if (!Copy) {
    return 0;
  }
  xpc_object_t values = Copy;
  keys = @"kBTAudioMsgPropertySoundProfile";
  CFDictionaryRef v4 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFRelease(v3);
  return v4;
}

void sub_45830(uint64_t a1, int a2, char *a3)
{
  if (!strcasecmp(a3, "kBTAudioMsgPropertySoundProfile"))
  {
    CFDictionaryRef v4 = (IR::IRData *)CUXPCCreateCFObjectFromXPCObject();
    uint64_t v5 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      BOOL v7 = v4;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "BTAudioCloudSyncMonitor: received %@", (uint8_t *)&v6, 0xCu);
    }
    sub_45914(a1, v4);
    if (v4) {
      CFRelease(v4);
    }
  }
}

void sub_45914(uint64_t a1, IR::IRData *this)
{
  CFDictionaryRef v4 = *(const void **)(a1 + 352);
  if (v4) {
    CFRelease(v4);
  }
  uint64_t NoisySoundProfilePack = IR::IRData::createNoisySoundProfilePack(this, this);
  *(void *)(a1 + 352) = NoisySoundProfilePack;
  int v6 = qword_A1B28;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    uint64_t v8 = NoisySoundProfilePack;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "BTAudioCloudSyncMonitor: Custom HRTF File Descriptor receivd %@ ", (uint8_t *)&v7, 0xCu);
  }
  sub_410B0(a1, 1667789414);
}

uint64_t sub_459EC(uint64_t a1)
{
  return mach_absolute_time() * *(unsigned int *)(a1 + 416) / *(unsigned int *)(a1 + 420) / 0xF4240;
}

void sub_45A38(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if ([a2 bluetoothAddress])
  {
    id v4 = [a2 bluetoothAddress];
    char v5 = [a2 hearingAssistCapability];
    char v6 = [a2 hearingAssistEnrolled];
    char v7 = [a2 hearingAssistEnabled];
    char v8 = [a2 pmeMediaEnabled];
    char v9 = [a2 pmeVoiceEnabled];
    sub_44D7C(v3, (uint64_t)v4, v5, v6, v7, v8, v9);
  }
  else
  {
    uint64_t v10 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v11 = 0;
      _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Received bluetooth address is null; return", v11, 2u);
    }
  }
}

void sub_45B54(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint64_t v2 = *(void *)(a1 + 32);
    [*(id *)(v2 + 496) invalidate];
    *(void *)(v2 + 496) = 0;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_693F8();
    }
  }
  else
  {
    uint64_t v3 = qword_A1B28;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "HearingModeService Activated", v4, 2u);
    }
  }
}

uint64_t sub_45BEC(_UNKNOWN **a1, uint64_t a2, uint64_t a3, void *a4)
{
  v13[0] = 0;
  v13[1] = 0;
  sub_5CDCC((uint64_t)v13, qword_A2350 + 200);
  if (a1 == &off_96DE8)
  {
    if (a4)
    {
      *(void *)&v14.byte0 = a2;
      *(void *)&v14.byte8 = a3;
      CFUUIDRef v10 = CFUUIDCreateFromUUIDBytes(kCFAllocatorDefault, v14);
      if (v10)
      {
        CFUUIDRef v11 = CFUUIDGetConstantUUIDWithBytes(kCFAllocatorSystemDefault, 0, 0, 0, 0, 0, 0, 0, 0, 0xC0u, 0, 0, 0, 0, 0, 0, 0x46u);
        if (CFEqual(v10, v11)
          || (CFUUIDRef v12 = CFUUIDGetConstantUUIDWithBytes(0, 0xEEu, 0xA5u, 0x77u, 0x3Du, 0xCCu, 0x43u, 0x49u, 0xF1u, 0x8Eu, 0, 0x8Fu, 0x96u, 0xE7u, 0xD2u, 0x3Bu, 0x17u), CFEqual(v10, v12)))
        {
          uint64_t v8 = 0;
          atomic_fetch_add((atomic_uint *volatile)(qword_A2350 + 152), 1u);
          *a4 = &off_96DE8;
        }
        else
        {
          uint64_t v8 = 2147483652;
        }
        CFRelease(v10);
      }
      else
      {
        uint64_t v8 = 1852797029;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
          sub_69460();
        }
      }
    }
    else
    {
      uint64_t v8 = 1852797029;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_6942C();
      }
    }
  }
  else
  {
    uint64_t v8 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69494();
    }
  }
  sub_5CF10(v13);
  return v8;
}

void sub_45DD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_45DEC(_UNKNOWN **a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, qword_A2350 + 200);
  if (a1 == &off_96DE8)
  {
    atomic_fetch_add((atomic_uint *volatile)(qword_A2350 + 152), 1u);
    uint64_t v2 = atomic_load((unsigned int *)(qword_A2350 + 152));
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_694C8();
    }
    uint64_t v2 = 0;
  }
  sub_5CF10(v4);
  return v2;
}

uint64_t sub_45E90(_UNKNOWN **a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, qword_A2350 + 200);
  if (a1 == &off_96DE8)
  {
    atomic_fetch_add((atomic_uint *volatile)(qword_A2350 + 152), 0xFFFFFFFF);
    uint64_t v2 = atomic_load((unsigned int *)(qword_A2350 + 152));
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_694FC();
    }
    uint64_t v2 = 0;
  }
  sub_5CF10(v4);
  return v2;
}

uint64_t sub_45F34(_UNKNOWN **a1, uint64_t a2)
{
  v9[0] = 0;
  v9[1] = 0;
  sub_5CDCC((uint64_t)v9, qword_A2350 + 200);
  if (a1 == &off_96DE8)
  {
    uint64_t v5 = qword_A2350;
    *(void *)(qword_A2350 + 144) = a2;
    LOBYTE(v5) = atomic_load((unsigned __int8 *)(v5 + 12));
    if ((v5 & 1) == 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(qword_A2350 + 16));
      pthread_cond_signal((pthread_cond_t *)(qword_A2350 + 80));
      pthread_mutex_unlock((pthread_mutex_t *)(qword_A2350 + 16));
      atomic_store(1u, (unsigned __int8 *)(qword_A2350 + 12));
      char v6 = qword_A1B28;
      uint64_t v4 = 0;
      if (!os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_8;
      }
      *(_WORD *)uint64_t v8 = 0;
      _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "AudioServerPlugIn Initialized", v8, 2u);
    }
    uint64_t v4 = 0;
    goto LABEL_8;
  }
  uint64_t v4 = 560947818;
  if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
    sub_69530();
  }
LABEL_8:
  sub_5CF10(v9);
  return v4;
}

void sub_46058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_4606C(_UNKNOWN **a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, qword_A2350 + 200);
  if (a1 == &off_96DE8)
  {
    uint64_t v2 = 1970171760;
  }
  else
  {
    uint64_t v2 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69564();
    }
  }
  sub_5CF10(v4);
  return v2;
}

uint64_t sub_460FC(_UNKNOWN **a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, qword_A2350 + 200);
  if (a1 == &off_96DE8)
  {
    uint64_t v2 = 1970171760;
  }
  else
  {
    uint64_t v2 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69598();
    }
  }
  sub_5CF10(v4);
  return v2;
}

uint64_t sub_4618C(_UNKNOWN **a1, uint64_t a2, uint64_t a3)
{
  v9[0] = 0;
  v9[1] = 0;
  sub_5CDCC((uint64_t)v9, qword_A2350 + 200);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v6)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 216))(v6, a3);
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v7 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_695CC();
      }
    }
  }
  else
  {
    uint64_t v7 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69600();
    }
  }
  sub_5CF10(v9);
  return v7;
}

void sub_462B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_462CC(_UNKNOWN **a1, uint64_t a2, uint64_t a3)
{
  v9[0] = 0;
  v9[1] = 0;
  sub_5CDCC((uint64_t)v9, qword_A2350 + 200);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v6)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)v6 + 224))(v6, a3);
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v7 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69634();
      }
    }
  }
  else
  {
    uint64_t v7 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69668();
    }
  }
  sub_5CF10(v9);
  return v7;
}

void sub_463F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_4640C(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[0] = 0;
  v11[1] = 0;
  sub_5CDCC((uint64_t)v11, qword_A2350 + 200);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v8)
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void *))(*(void *)v8 + 160))(v8, a3, a4, v11);
    }
    else
    {
      uint64_t v9 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_6969C();
      }
    }
  }
  else
  {
    uint64_t v9 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_696D0();
    }
  }
  sub_5CF10(v11);
  return v9;
}

void sub_46544(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_46558(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v11[0] = 0;
  v11[1] = 0;
  sub_5CDCC((uint64_t)v11, qword_A2350 + 200);
  uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v8)
    {
      uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 168))(v8, a3, a4);
    }
    else
    {
      uint64_t v9 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69704();
      }
    }
  }
  else
  {
    uint64_t v9 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_696D0();
    }
  }
  sub_5CF10(v11);
  return v9;
}

void sub_4668C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_466A0(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_5CDCC((uint64_t)v10, qword_A2350 + 200);
  uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v7)
    {
      if (a4)
      {
        uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v7 + 24))(v7, a4);
        goto LABEL_5;
      }
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_697A0();
      }
    }
    else if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR))
    {
      sub_69738();
    }
  }
  else if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR))
  {
    sub_697D4();
  }
  uint64_t v8 = 0;
LABEL_5:
  sub_5CF10(v10);
  return v8;
}

void sub_467EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_46800(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  v12[0] = 0;
  v12[1] = 0;
  sub_5CDCC((uint64_t)v12, qword_A2350 + 200);
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v9)
    {
      if (a4)
      {
        if (a5)
        {
          uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 32))(v9, a4, a5);
        }
        else
        {
          uint64_t v10 = 1852797029;
          if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
            sub_698A4();
          }
        }
      }
      else
      {
        uint64_t v10 = 1852797029;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
          sub_69870();
        }
      }
    }
    else
    {
      uint64_t v10 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69808();
      }
    }
  }
  else
  {
    uint64_t v10 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_698D8();
    }
  }
  sub_5CF10(v12);
  return v10;
}

void sub_46998(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_469AC(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  v16[0] = 0;
  v16[1] = 0;
  sub_5CDCC((uint64_t)v16, qword_A2350 + 200);
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v13)
    {
      if (a4)
      {
        if (a7)
        {
          uint64_t v14 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v13 + 40))(v13, a4, a5, a6, a7);
        }
        else
        {
          uint64_t v14 = 1852797029;
          if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
            sub_69940();
          }
        }
      }
      else
      {
        uint64_t v14 = 1852797029;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
          sub_6990C();
        }
      }
    }
    else
    {
      uint64_t v14 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69808();
      }
    }
  }
  else
  {
    uint64_t v14 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69974();
    }
  }
  sub_5CF10(v16);
  return v14;
}

void sub_46B5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_46B70(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v20[0] = 0;
  v20[1] = 0;
  sub_5CDCC((uint64_t)v20, qword_A2350 + 200);
  uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v17)
    {
      if (a4)
      {
        if (a8)
        {
          if (a9)
          {
            uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v17 + 48))(v17, a4, a3, a5, a6, a7, a8);
          }
          else
          {
            uint64_t v18 = 1852797029;
            if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
              sub_69A10();
            }
          }
        }
        else
        {
          uint64_t v18 = 1852797029;
          if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
            sub_699DC();
          }
        }
      }
      else
      {
        uint64_t v18 = 1852797029;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
          sub_699A8();
        }
      }
    }
    else
    {
      uint64_t v18 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69808();
      }
    }
  }
  else
  {
    uint64_t v18 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69A44();
    }
  }
  sub_5CF10(v20);
  return v18;
}

void sub_46D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_46D80(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v19[0] = 0;
  v19[1] = 0;
  sub_5CDCC((uint64_t)v19, qword_A2350 + 200);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v16)
    {
      if (a4)
      {
        uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 56))(v16, a4, a5, a6, a7, a8, a3);
      }
      else
      {
        uint64_t v17 = 1852797029;
        if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
          sub_69A78();
        }
      }
    }
    else
    {
      uint64_t v17 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69808();
      }
    }
  }
  else
  {
    uint64_t v17 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69AAC();
    }
  }
  sub_5CF10(v19);
  return v17;
}

void sub_46F18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_46F2C(_UNKNOWN **a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348);
  if (a1 == &off_96DE8)
  {
    uint64_t v8 = v5;
    if (v5)
    {
      sub_5CA5C(9);
      uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 184))(v8, a3);
      if (v6 && os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69B14();
      }
    }
    else
    {
      uint64_t v6 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69AE0();
      }
    }
  }
  else
  {
    uint64_t v6 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69B7C();
    }
  }
  return v6;
}

uint64_t sub_47064(_UNKNOWN **a1, uint64_t a2, uint64_t a3)
{
  v10[0] = 0;
  v10[1] = 0;
  sub_5CDCC((uint64_t)v10, qword_A2350 + 200);
  uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    uint64_t v8 = v6;
    if (v6)
    {
      sub_5CA5C(10);
      uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v8 + 192))(v8, a3);
    }
    else
    {
      uint64_t v7 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69BB0();
      }
    }
  }
  else
  {
    uint64_t v7 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69BE4();
    }
  }
  sub_5CF10(v10);
  return v7;
}

void sub_471A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_471B4(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v15[0] = 0;
  v15[1] = 0;
  sub_5CDCC((uint64_t)v15, qword_A2350 + 200);
  uint64_t v12 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v12)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v12 + 176))(v12, a3, a4, a5, a6);
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69C18();
      }
    }
  }
  else
  {
    uint64_t v13 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69C4C();
    }
  }
  sub_5CF10(v15);
  return v13;
}

void sub_47300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_47314(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  v14[0] = 0;
  v14[1] = 0;
  sub_5CDCC((uint64_t)v14, qword_A2350 + 200);
  uint64_t v11 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v11)
    {
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v11 + 200))(v11, a4, a5, a6);
      uint64_t v12 = 0;
    }
    else
    {
      uint64_t v12 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69C80();
      }
    }
  }
  else
  {
    uint64_t v12 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69CB4();
    }
  }
  sub_5CF10(v14);
  return v12;
}

void sub_47458(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_4746C(_UNKNOWN **a1, uint64_t a2)
{
  v7[0] = 0;
  v7[1] = 0;
  sub_5CDCC((uint64_t)v7, qword_A2350 + 200);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v4)
    {
      uint64_t v5 = 0;
    }
    else
    {
      uint64_t v5 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69CE8();
      }
    }
  }
  else
  {
    uint64_t v5 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69D1C();
    }
  }
  sub_5CF10(v7);
  return v5;
}

void sub_47564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_47578(_UNKNOWN **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v19[0] = 0;
  v19[1] = 0;
  sub_5CDCC((uint64_t)v19, qword_A2350 + 200);
  uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v16)
    {
      uint64_t v17 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v16 + 208))(v16, a4, a5, a6, a7, a8, a9);
    }
    else
    {
      uint64_t v17 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69D50();
      }
    }
  }
  else
  {
    uint64_t v17 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69D84();
    }
  }
  sub_5CF10(v19);
  return v17;
}

void sub_476D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t sub_476EC(_UNKNOWN **a1, uint64_t a2)
{
  v7[0] = 0;
  v7[1] = 0;
  sub_5CDCC((uint64_t)v7, qword_A2350 + 200);
  uint64_t v4 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)qword_A2348 + 24))(qword_A2348, a2);
  if (a1 == &off_96DE8)
  {
    if (v4)
    {
      uint64_t v5 = 0;
    }
    else
    {
      uint64_t v5 = 560947818;
      if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
        sub_69DB8();
      }
    }
  }
  else
  {
    uint64_t v5 = 560947818;
    if (os_log_type_enabled((os_log_t)qword_A1B28, OS_LOG_TYPE_ERROR)) {
      sub_69DEC();
    }
  }
  sub_5CF10(v7);
  return v5;
}

void sub_477E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_477F8()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  CFDataRef v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void sub_4782C(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_47880((uint64_t)v2, *v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

uint64_t sub_47880(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *(void **)(result + 8);
  while (v3 != a2)
  {
    uint64_t v4 = *--v3;
    uint64_t result = v4;
    *uint64_t v3 = 0;
    if (v4) {
      operator delete();
    }
  }
  *(void *)(v2 + 8) = a2;
  return result;
}

void sub_478E4(void ***a1)
{
  uint64_t v2 = *a1;
  if (*v2)
  {
    sub_47938((uint64_t *)v2);
    uint64_t v3 = **a1;
    operator delete(v3);
  }
}

void sub_47938(uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

void sub_47988(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_47988(a1, *(void *)a2);
    sub_47988(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

char *sub_479EC(void *a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_47A30();
  }
  uint64_t result = (char *)sub_47A48((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void sub_47A30()
{
}

void *sub_47A48(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    sub_477F8();
  }
  return operator new(4 * a2);
}

long long *sub_47A80(uint64_t a1, long long *a2, long long *a3, uint64_t a4)
{
  uint64_t v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if (*(char *)(a4 + 23) < 0) {
        operator delete(*(void **)a4);
      }
      long long v7 = *v5;
      *(void *)(a4 + 16) = *((void *)v5 + 2);
      *(_OWORD *)a4 = v7;
      a4 += 24;
      *((unsigned char *)v5 + 23) = 0;
      *(unsigned char *)uint64_t v5 = 0;
      uint64_t v5 = (long long *)((char *)v5 + 24);
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void *sub_47AF4(void *result, long long *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = result[1];
  if (*((char *)a2 + 23) < 0)
  {
    uint64_t result = sub_B9AC((unsigned char *)result[1], *(void **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v4 = *a2;
    *(void *)(v3 + 16) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v3 = v4;
  }
  v2[1] = v3 + 24;
  return result;
}

void sub_47B4C(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t sub_47B54(uint64_t *a1, long long *a2)
{
  uint64_t v3 = *a1;
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    sub_47A30();
  }
  uint64_t v7 = (uint64_t)(a1 + 2);
  unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5) {
    unint64_t v5 = 2 * v8;
  }
  if (v8 >= 0x555555555555555) {
    unint64_t v9 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v9 = v5;
  }
  uint64_t v18 = a1 + 2;
  if (v9) {
    uint64_t v10 = (char *)sub_47CF0(v7, v9);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = &v10[24 * v4];
  v15[0] = v10;
  v15[1] = v11;
  uint64_t v16 = v11;
  uint64_t v17 = &v10[24 * v9];
  if (*((char *)a2 + 23) < 0)
  {
    sub_B9AC(v11, *(void **)a2, *((void *)a2 + 1));
    uint64_t v11 = v16;
  }
  else
  {
    long long v12 = *a2;
    *((void *)v11 + 2) = *((void *)a2 + 2);
    *(_OWORD *)uint64_t v11 = v12;
  }
  uint64_t v16 = v11 + 24;
  sub_47C78(a1, v15);
  uint64_t v13 = a1[1];
  sub_47E58((uint64_t)v15);
  return v13;
}

void sub_47C64(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  sub_47E58((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_47C78(uint64_t *a1, void *a2)
{
  uint64_t result = sub_47D38((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_47CF0(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    sub_477F8();
  }
  return operator new(24 * a2);
}

uint64_t sub_47D38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v15 = a6;
  *((void *)&v15 + 1) = a7;
  long long v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  void v12[2] = &v15;
  uint64_t v13 = 0;
  if (a3 != a5)
  {
    uint64_t v9 = a7;
    do
    {
      long long v10 = *(_OWORD *)(a3 - 24);
      *(void *)(v9 - 8) = *(void *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(void *)(a3 - 16) = 0;
      *(void *)(a3 - 8) = 0;
      *(void *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((void *)&v15 + 1) = v9;
  }
  LOBYTE(v13) = 1;
  sub_47DD8((uint64_t)v12);
  return a6;
}

uint64_t sub_47DD8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_47E10(a1);
  }
  return a1;
}

void sub_47E10(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 16) + 8);
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0) {
      operator delete(*(void **)v1);
    }
    v1 += 24;
  }
}

uint64_t sub_47E58(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void sub_47E90(uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t sub_47EE8(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  uint64_t v3 = a1;
  if (a1 != a2)
  {
    char v5 = *((unsigned char *)a3 + 23);
    if (v5 >= 0) {
      uint64_t v6 = (unsigned __int8 *)*((unsigned __int8 *)a3 + 23);
    }
    else {
      uint64_t v6 = a3[1];
    }
    if (v5 >= 0) {
      uint64_t v7 = (unsigned __int8 *)a3;
    }
    else {
      uint64_t v7 = *a3;
    }
    do
    {
      uint64_t v8 = *(unsigned __int8 *)(v3 + 23);
      if ((v8 & 0x80u) == 0) {
        uint64_t v9 = (unsigned __int8 *)*(unsigned __int8 *)(v3 + 23);
      }
      else {
        uint64_t v9 = *(unsigned __int8 **)(v3 + 8);
      }
      if (v9 == v6)
      {
        if ((v8 & 0x80) != 0)
        {
          if (!memcmp(*(const void **)v3, v7, *(void *)(v3 + 8))) {
            return v3;
          }
        }
        else
        {
          if (!*(unsigned char *)(v3 + 23)) {
            return v3;
          }
          uint64_t v10 = 0;
          while (*(unsigned __int8 *)(v3 + v10) == v7[v10])
          {
            if (v8 == ++v10) {
              return v3;
            }
          }
        }
      }
      v3 += 24;
    }
    while (v3 != a2);
    return a2;
  }
  return v3;
}

uint64_t sub_47FA0(uint64_t *a1, void *a2)
{
  uint64_t result = sub_48050((uint64_t)(a1 + 2), a1[1], (void *)a1[1], *a1, (void *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  uint64_t v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  uint64_t v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  uint64_t v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_48018(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    sub_477F8();
  }
  return operator new(8 * a2);
}

uint64_t sub_48050(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7 = a7;
  *(void *)&long long v16 = a6;
  *((void *)&v16 + 1) = a7;
  long long v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  void v13[2] = &v16;
  uint64_t v14 = 0;
  if (a3 == a5)
  {
    uint64_t v11 = a6;
  }
  else
  {
    uint64_t v8 = (void *)(a7 - 8);
    uint64_t v9 = (void *)(a7 - 8);
    do
    {
      uint64_t v10 = *--a3;
      *a3 = 0;
      *v9-- = v10;
      *((void *)&v16 + 1) = v8;
      v7 -= 8;
      uint64_t v8 = v9;
    }
    while (a3 != a5);
    uint64_t v11 = v16;
  }
  LOBYTE(v14) = 1;
  sub_480E8((uint64_t)v13);
  return v11;
}

uint64_t sub_480E8(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 24)) {
    sub_48120(a1);
  }
  return a1;
}

uint64_t sub_48120(uint64_t result)
{
  uint64_t v1 = *(uint64_t **)(*(void *)(result + 16) + 8);
  uint64_t v2 = *(uint64_t **)(*(void *)(result + 8) + 8);
  while (v1 != v2)
  {
    uint64_t result = *v1;
    *uint64_t v1 = 0;
    if (result) {
      operator delete();
    }
    ++v1;
  }
  return result;
}

uint64_t sub_48178(uint64_t a1)
{
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t sub_481B0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(result + 16);
  if (v2 != a2)
  {
    uint64_t v3 = result;
    do
    {
      *(void *)(v3 + 16) = v2 - 8;
      uint64_t result = *(void *)(v2 - 8);
      *(void *)(v2 - 8) = 0;
      if (result) {
        operator delete();
      }
      uint64_t v2 = *(void *)(v3 + 16);
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t **sub_48214(uint64_t **a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t v7 = a1 + 1;
  uint64_t v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v6;
        unsigned int v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10) {
          break;
        }
        uint64_t v6 = *v9;
        uint64_t v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      uint64_t v6 = v9[1];
      if (!v6)
      {
        uint64_t v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    uint64_t v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = operator new(0x30uLL);
    v11[8] = **a4;
    *((void *)v11 + 5) = 0;
    sub_18A8C(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t *sub_482D8(uint64_t **a1, const void **a2, uint64_t a3, long long **a4)
{
  uint64_t v9 = 0;
  uint64_t v6 = (uint64_t **)sub_4837C((uint64_t)a1, &v9, a2);
  uint64_t result = *v6;
  if (!*v6)
  {
    memset(v8, 0, sizeof(v8));
    sub_4841C((uint64_t)a1, a4, v8);
    sub_18A8C(a1, v9, v6, v8[0]);
    return v8[0];
  }
  return result;
}

void *sub_4837C(uint64_t a1, void *a2, const void **a3)
{
  uint64_t v5 = (void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    uint64_t v7 = a1 + 16;
    do
    {
      while (1)
      {
        unsigned int v8 = (void *)v4;
        uint64_t v9 = (const void **)(v4 + 32);
        if (!sub_484D0(v7, a3, (const void **)(v4 + 32))) {
          break;
        }
        uint64_t v4 = *v8;
        uint64_t v5 = v8;
        if (!*v8) {
          goto LABEL_10;
        }
      }
      if (!sub_484D0(v7, v9, a3)) {
        break;
      }
      uint64_t v5 = v8 + 1;
      uint64_t v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    unsigned int v8 = (void *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

unsigned char *sub_4841C@<X0>(uint64_t a1@<X0>, long long **a2@<X2>, void *a3@<X8>)
{
  uint64_t v5 = a1 + 8;
  *a3 = 0;
  a3[2] = 0;
  a3[1] = 0;
  uint64_t v6 = a3 + 1;
  uint64_t v7 = (char *)operator new(0x40uLL);
  *a3 = v7;
  *uint64_t v6 = v5;
  *((unsigned char *)a3 + 16) = 0;
  uint64_t result = v7 + 32;
  uint64_t v9 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    uint64_t result = sub_B9AC(result, *(void **)v9, *((void *)v9 + 1));
  }
  else
  {
    long long v10 = *v9;
    *((void *)v7 + 6) = *((void *)v9 + 2);
    *(_OWORD *)uint64_t result = v10;
  }
  *((void *)v7 + 7) = 0;
  *((unsigned char *)a3 + 16) = 1;
  return result;
}

void sub_484B4(_Unwind_Exception *a1)
{
  *uint64_t v1 = 0;
  sub_4853C(v3, v2);
  _Unwind_Resume(a1);
}

BOOL sub_484D0(uint64_t a1, const void **a2, const void **a3)
{
  int v3 = *((char *)a3 + 23);
  int v4 = *((char *)a2 + 23);
  if (v4 >= 0) {
    size_t v5 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v5 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = *a2;
  }
  if (v3 >= 0) {
    size_t v7 = *((unsigned __int8 *)a3 + 23);
  }
  else {
    size_t v7 = (size_t)a3[1];
  }
  if (v3 >= 0) {
    unsigned int v8 = a3;
  }
  else {
    unsigned int v8 = *a3;
  }
  if (v7 >= v5) {
    size_t v9 = v5;
  }
  else {
    size_t v9 = v7;
  }
  int v10 = memcmp(v6, v8, v9);
  if (v10) {
    return v10 < 0;
  }
  else {
    return v5 < v7;
  }
}

void sub_4853C(uint64_t a1, void **__p)
{
  if (*(unsigned char *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0) {
      operator delete(__p[4]);
    }
  }
  else if (!__p)
  {
    return;
  }

  operator delete(__p);
}

void *sub_4859C(void *result, const void *a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = sub_479EC(result, a4);
    uint64_t v7 = v6[1];
    size_t v8 = a3 - (void)a2;
    if (v8) {
      uint64_t result = memmove((void *)v6[1], a2, v8);
    }
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_485FC(_Unwind_Exception *exception_object)
{
  int v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_48618(uint64_t a1, const void **a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 16;
  uint64_t v6 = a1 + 8;
  do
  {
    BOOL v7 = sub_484D0(v5, (const void **)(v3 + 32), a2);
    size_t v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      size_t v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || sub_484D0(v5, a2, (const void **)(v6 + 32))) {
    return v2;
  }
  return v6;
}

uint64_t *sub_486A8(uint64_t **a1, uint64_t a2)
{
  uint64_t v3 = sub_2D7E0(a1, (uint64_t *)a2);
  if (*(char *)(a2 + 55) < 0) {
    operator delete(*(void **)(a2 + 32));
  }
  operator delete((void *)a2);
  return v3;
}

void sub_486EC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_48708(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0xCu);
}

os_log_t sub_48728()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1B28 = (uint64_t)result;
  return result;
}

__n128 sub_48758(uint64_t a1, int a2, uint64_t a3)
{
  *(void *)a1 = off_8F388;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 144) = 0;
  *(_DWORD *)(a1 + 156) = 0;
  *(_DWORD *)(a1 + 8) = a2;
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(void *)(a1 + 96) = *(void *)(a3 + 32);
  *(__n128 *)(a1 + 64) = result;
  *(_OWORD *)(a1 + 80) = v4;
  return result;
}

void *sub_4879C(void *a1)
{
  *a1 = off_8F388;
  uint64_t v2 = a1[18];
  a1[18] = 0;
  if (v2) {
    operator delete[]();
  }
  uint64_t v3 = a1[16];
  a1[16] = 0;
  if (v3) {
    operator delete[]();
  }
  uint64_t v4 = a1[13];
  a1[13] = 0;
  if (v4) {
    operator delete[]();
  }
  return a1;
}

void sub_48844(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unint64_t a5, void *a6)
{
  long long v24 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v21 = 0u;
  memset(&inInputDataProcUserData[2], 0, 48);
  *(void *)&outOutputData.mNumberBuffers = 0;
  UInt32 v10 = *(_DWORD *)(a1 + 92);
  outOutputData.mNumberBuffers = 1;
  UInt32 v11 = *(_DWORD *)(a1 + 112);
  outOutputData.mBuffers[0].mNumberChannels = v10;
  outOutputData.mBuffers[0].size_t mDataByteSize = v11;
  outOutputData.mBuffers[0].mData = *(void **)(a1 + 104);
  uint64_t v12 = *(void *)(a1 + 128);
  if (v12)
  {
    *(void *)uint64_t v12 = 0;
    *(_DWORD *)(v12 + 8) = 0;
    *(_DWORD *)(v12 + 12) = a3;
  }
  UInt32 v13 = *(_DWORD *)(a1 + 156);
  if (!v13) {
    UInt32 v13 = *(_DWORD *)(a1 + 44);
  }
  *(_OWORD *)&inInputDataProcUserData[3] = *(_OWORD *)(a1 + 24);
  *(_OWORD *)&inInputDataProcUserData[5] = *(_OWORD *)(a1 + 40);
  long long v14 = *(_OWORD *)(a1 + 80);
  long long v23 = *(_OWORD *)(a1 + 64);
  UInt32 ioOutputDataPacketSize = v13;
  inInputDataProcUserData[0] = a2;
  inInputDataProcUserData[1] = a3;
  uint64_t v15 = *(void *)(a1 + 56);
  LODWORD(inInputDataProcUserData[2]) = *(_DWORD *)(a1 + 120);
  inInputDataProcUserData[7] = v15;
  *(void *)&long long v21 = v12;
  long long v24 = v14;
  *(void *)&long long v25 = *(void *)(a1 + 96);
  OSStatus v16 = AudioConverterFillComplexBuffer(*(AudioConverterRef *)(a1 + 16), (AudioConverterComplexInputDataProc)sub_1B7F0, inInputDataProcUserData, &ioOutputDataPacketSize, &outOutputData, *(AudioStreamPacketDescription **)(a1 + 144));
  sub_1B8C0(v16, (uint64_t)"Decoder AudioConverterFillComplexBuffer Failed!");
  if (ioOutputDataPacketSize
    && (size_t mDataByteSize = outOutputData.mBuffers[0].mDataByteSize) != 0
    && outOutputData.mBuffers[0].mDataByteSize <= a5)
  {
    *a6 = outOutputData.mBuffers[0].mDataByteSize;
    memcpy(a4, *(const void **)(a1 + 104), mDataByteSize);
  }
  else
  {
    *a6 = 0;
  }
}

uint64_t sub_48978(uint64_t a1, int a2, uint64_t a3, unsigned char *a4, int a5)
{
  int v5 = 8 * a5 / a2;
  if (v5 << 16 >= 1)
  {
    unsigned int v6 = 0;
    unsigned int v7 = 0;
    int v8 = 0;
    int v9 = 8 - a2;
    if ((unsigned __int16)(8 * a5 / a2) <= 1u) {
      uint64_t v10 = 1;
    }
    else {
      uint64_t v10 = (unsigned __int16)(8 * a5 / a2);
    }
    do
    {
      int v11 = (v7 & ~(-1 << v8)) << (a2 - v8);
      *a4 = v11;
      unsigned int v7 = *(unsigned __int8 *)(a3 + v6);
      int v12 = 252 << v8;
      int v13 = v8 + v9;
      int v8 = ((_BYTE)v8 + (_BYTE)v9) & 7;
      if ((v13 & 7) != 0) {
        ++v6;
      }
      int v15 = -v13;
      BOOL v14 = v15 < 0;
      int v16 = v15 & 7;
      if (v14) {
        LOBYTE(v17) = v8;
      }
      else {
        int v17 = -v16;
      }
      *a4++ = (((v12 & v7) >> v17) | v11) << v9;
      --v10;
    }
    while (v10);
  }
  return (__int16)v5;
}

uint64_t sub_48A0C()
{
  return 0;
}

os_log_t sub_48A14()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1B38 = (uint64_t)result;
  return result;
}

uint64_t sub_48A44(uint64_t a1, int a2, uint64_t a3)
{
  long long v5 = *(_OWORD *)(a3 + 16);
  v10[0] = *(_OWORD *)a3;
  v10[1] = v5;
  uint64_t v11 = *(void *)(a3 + 32);
  sub_48758(a1, a2, (uint64_t)v10);
  *unsigned int v6 = off_8F3F0;
  switch(a2)
  {
    case 9:
      int v7 = 1;
      goto LABEL_10;
    case 10:
      int v7 = 2;
      goto LABEL_10;
    case 11:
      int v7 = 3;
      goto LABEL_10;
    case 12:
      int v7 = 4;
      goto LABEL_10;
    case 13:
      *(_DWORD *)(a1 + 192) = 0;
      break;
    case 14:
      int v7 = 6;
LABEL_10:
      *(_DWORD *)(a1 + 192) = v7;
      break;
    default:
      int v8 = qword_A1B40;
      if (os_log_type_enabled((os_log_t)qword_A1B40, OS_LOG_TYPE_ERROR)) {
        sub_671A4(a2, v8);
      }
      break;
  }
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 184) = 0;
  return a1;
}

void *sub_48B58(uint64_t a1)
{
  *(void *)a1 = off_8F3F0;
  uint64_t v2 = *(void **)(a1 + 168);
  if (v2) {
    decoder_destroy(v2);
  }
  free(*(void **)(a1 + 184));

  return sub_4879C((void *)a1);
}

void sub_48BC4(uint64_t a1)
{
  sub_48B58(a1);

  operator delete();
}

uint64_t sub_48BFC(uint64_t a1)
{
  uint64_t v2 = decoder_create(*(_DWORD *)(a1 + 192));
  *(void *)(a1 + 168) = v2;
  *(void *)(a1 + 176) = v2;
  *(void *)(a1 + 184) = malloc_type_calloc(v2[2], 4uLL, 0x100004052888210uLL);
  return 0;
}

void sub_48C4C(uint64_t a1, unsigned __int16 *a2, uint64_t a3, _WORD *a4, uint64_t a5, void *a6)
{
  decode(*(void *)(a1 + 168), a2, *(float **)(a1 + 184), a3 == 0);
  int v9 = *(_DWORD *)(*(void *)(a1 + 176) + 8);
  if (v9 >= 1)
  {
    uint64_t v10 = *(float **)(a1 + 184);
    uint64_t v11 = *(unsigned int *)(*(void *)(a1 + 176) + 8);
    do
    {
      float v12 = *v10++;
      *a4++ = (int)fminf(fmaxf(v12 * 32768.0, -32768.0), 32767.0);
      --v11;
    }
    while (v11);
  }
  *a6 = 2 * v9;
}

uint64_t sub_48CE8()
{
  return 1;
}

os_log_t sub_48CF0()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1B40 = (uint64_t)result;
  return result;
}

void sub_48D20(uint64_t a1, int a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  v5[0] = *(_OWORD *)a3;
  v5[1] = v3;
  uint64_t v6 = *(void *)(a3 + 32);
  sub_48758(a1, a2, (uint64_t)v5);
  *(void *)uint64_t v4 = &off_8F460;
  *(_DWORD *)(v4 + 112) = 10240;
  operator new[]();
}

void sub_48DC4(_Unwind_Exception *a1)
{
  sub_4879C(v1);
  _Unwind_Resume(a1);
}

void sub_48DE4(void *a1)
{
  sub_4879C(a1);

  operator delete();
}

uint64_t sub_48E1C(uint64_t a1)
{
  return g726_init(a1 + 164, *(_DWORD *)(a1 + 116), 2);
}

uint64_t sub_48E30()
{
  return 0;
}

uint64_t sub_48E38(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6)
{
  if (os_log_type_enabled((os_log_t)qword_A1B48, OS_LOG_TYPE_ERROR))
  {
    sub_69E9C();
    if (!a3) {
      goto LABEL_5;
    }
  }
  else if (!a3)
  {
    goto LABEL_5;
  }
  uint64_t v11 = (unsigned char *)(a1 + 229);
  uint64_t v12 = a3;
  do
  {
    *(v11 - 1) = *a2 >> 4;
    char v13 = *a2++;
    *uint64_t v11 = v13 & 0xF;
    v11 += 2;
    --v12;
  }
  while (v12);
LABEL_5:
  if (os_log_type_enabled((os_log_t)qword_A1B48, OS_LOG_TYPE_ERROR)) {
    sub_69E20();
  }
  uint64_t result = g726_decode_frame(a1 + 164, a1 + 228, a3, a4);
  *a6 = result;
  return result;
}

uint64_t sub_48F14(uint64_t a1, int a2)
{
  return (2 * a2);
}

uint64_t sub_48F1C(uint64_t a1, unsigned int a2)
{
  return a2 >> 1;
}

double sub_48F24()
{
  return 2.0542726e-289;
}

os_log_t sub_48F50()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A1B48 = (uint64_t)result;
  return result;
}

void sub_48F80(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1 + 9272;
  uint64_t v5 = sub_3F94(a1, a3);
  *(void *)uint64_t v5 = off_8F4D0;
  *(void *)(v5 + 9248) = 0;
  *(void *)(v5 + 9160) = 0;
  *(_OWORD *)(v5 + 9080) = 0u;
  *(_OWORD *)(v5 + 9096) = 0u;
  *(_OWORD *)(v5 + 9112) = 0u;
  *(_OWORD *)(v5 + 9128) = 0u;
  *(_OWORD *)(v5 + 9144) = 0u;
  *(void *)(v5 + 9256) = 1953853033;
  *(void *)(v5 + 9264) = 1919183219;
  *(_WORD *)uint64_t v4 = 0;
  *(_OWORD *)(v5 + 9288) = 0u;
  *(void *)(v5 + 9280) = v5 + 9288;
  *(_WORD *)(v4 + 32) = 0;
  *(unsigned char *)(v4 + 34) = 0;
  *(_WORD *)(v4 + 168) = 0;
  *(unsigned char *)(v4 + 170) = 1;
  *(_OWORD *)(v5 + 9448) = 0u;
  *(_DWORD *)(v5 + 9472) = 0;
  *(void *)(v5 + 9464) = 0;
  sub_5CC80(v5 + 9608, v6);
  *(void *)(a1 + 9672) = 0;
  *(void *)(a1 + 9176) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9184) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9192) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9200) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9208) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9216) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9224) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9232) = CFArrayCreateMutable(0, 0, 0);
  *(void *)(a1 + 9240) = CFArrayCreateMutable(0, 0, 0);
  pthread_mutex_init((pthread_mutex_t *)(a1 + 9312), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 9376), 0);
  *(_OWORD *)(a1 + 9424) = xmmword_71870;
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1024))(a1, 1);
  (*(void (**)(uint64_t, void))(*(void *)a1 + 1032))(a1, 0);
  *(void *)(a1 + 9168) = CFArrayCreateMutable(0, 0, 0);
  operator new();
}

void sub_492BC()
{
}

double sub_49310(uint64_t a1)
{
  pthread_mutex_init((pthread_mutex_t *)(a1 + 9312), 0);
  pthread_cond_init((pthread_cond_t *)(a1 + 9376), 0);
  *(void *)&double result = 3;
  *(_OWORD *)(a1 + 9424) = xmmword_71870;
  return result;
}

uint64_t sub_4935C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    LOBYTE(v6) = BYTE3(a2);
    BYTE1(v6) = BYTE2(a2);
    BYTE2(v6) = BYTE1(a2);
    *(_WORD *)((char *)&v6 + 3) = a2;
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = &v6;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = a2;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice, CreateBTAudioDevice %{public}s via = %lld", buf, 0x16u);
  }
  switch(a2)
  {
    case 1952539500:
      operator new();
    case 1953260897:
      sub_24598(*(void *)(a1 + 9248), 0x10000);
      operator new();
    case 1953719151:
      operator new();
  }
  *(void *)std::string buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  sub_5CDCC((uint64_t)buf, qword_A2350 + 200);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9168), 0);
  uint64_t v6 = 0x676C6F6261766170;
  int v7 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 248))(a1, &v6);
  sub_5CF10(buf);
  return 0;
}

void sub_49764()
{
}

BOOL sub_497C8(void *a1, uint64_t a2, int a3, int a4)
{
  int v8 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    LOBYTE(v20) = BYTE3(a2);
    BYTE1(v20) = BYTE2(a2);
    BYTE2(v20) = BYTE1(a2);
    HIBYTE(v20) = a2;
    char v21 = 0;
    *(_DWORD *)std::string buf = 136315650;
    *(void *)&uint8_t buf[4] = &v20;
    __int16 v23 = 1024;
    int v24 = a3;
    __int16 v25 = 1024;
    int v26 = a4;
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: UpdateCurrentBTAudioDevice %s, %d, %d", buf, 0x18u);
  }
  uint64_t v9 = a1[1157];
  if (sub_395B4())
  {
    if (v9 == 1953719151)
    {
      uint64_t v10 = (unsigned char *)a1[1137];
      if (v10)
      {
        if (v10[192] && (*(unsigned int (**)(unsigned char *))(*(void *)v10 + 1496))(v10))
        {
          uint64_t v11 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Delayed Transport Disconnect: Transitioning out of HFP: Disconnect eSCO", buf, 2u);
          }
          if (*(unsigned char *)(a1[1137] + 192)) {
            uint64_t v12 = a1[1137];
          }
          else {
            uint64_t v12 = 0;
          }
          (*(void (**)(uint64_t, void, uint64_t, void))(*(void *)v12 + 256))(v12, 0, 1918989668, 0);
        }
      }
    }
  }
  switch(a2)
  {
    case 1952539500:
      uint64_t v13 = 1136;
      goto LABEL_20;
    case 1953260897:
      uint64_t v13 = 1139;
      goto LABEL_20;
    case 1953719151:
      uint64_t v13 = 1137;
LABEL_20:
      uint64_t v14 = a1[v13];
      goto LABEL_22;
  }
  uint64_t v14 = 0;
LABEL_22:
  a1[1157] = a2;
  a1[1140] = v14;
  strcpy(buf, "pavabolg");
  buf[9] = 0;
  *(_WORD *)&buf[10] = 0;
  (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
  if (v9 != a1[1157])
  {
    strcpy(buf, "pcvabolg");
    buf[9] = 0;
    *(_WORD *)&buf[10] = 0;
    (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
    (*(void (**)(void *, uint64_t))(*a1 + 712))(a1, v9);
  }
  sub_4A810(a1);
  int v15 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    if (a1[1140])
    {
      v16.i32[0] = *((_DWORD *)a1 + 2314);
      int16x8_t v17 = (int16x8_t)vmovl_u8(v16);
      *(int16x4_t *)v17.i8 = vrev64_s16(*(int16x4_t *)v17.i8);
      unsigned __int32 v20 = vmovn_s16(v17).u32[0];
      char v21 = 0;
      uint64_t v18 = &v20;
    }
    else
    {
      uint64_t v18 = (unsigned __int32 *)"None";
    }
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v18;
    _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: UpdateCurrentBTAudioDevice : New Audio device %s ", buf, 0xCu);
  }
  return a1[1140] != 0;
}

uint64_t **sub_49B4C(uint64_t a1)
{
  uint64_t v1 = 0;
  uint64_t v2 = (uint64_t **)(a1 + 9280);
  do
  {
    uint64_t v4 = (_DWORD *)((char *)&xmmword_A1B60 + v1);
    double result = sub_48214(v2, (unsigned int *)((char *)&xmmword_A1B60 + v1), (uint64_t)&unk_71834, &v4);
    result[5] = (uint64_t *)((char *)&xmmword_A1B60 + v1);
    v1 += 20;
  }
  while (v1 != 1700);
  return result;
}

CFStringRef sub_49BCC(uint64_t a1, void *a2)
{
  if (sub_5CB00())
  {
    xpc_object_t value = xpc_dictionary_get_value(a2, "kBTAudioDebugEnableAudioLogging");
    if (value)
    {
      uint64_t v5 = value;
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL)
      {
        uint64_t v6 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_FAULT)) {
          sub_69FE8(v6, v7, v8, v9, v10, v11, v12, v13);
        }
        if (sub_5CB00()) {
LABEL_13:
        }
          abort();
      }
      xpc_BOOL_get_value(v5);
    }
  }
  string = xpc_dictionary_get_string(a2, "kBTAudioMsgPropertyDeviceUID");
  if (!string)
  {
    int v15 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_FAULT)) {
      sub_63158(v15, v16, v17, v18, v19, v20, v21, v22);
    }
    if (sub_5CB00()) {
      goto LABEL_13;
    }
  }
  CFStringRef result = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
  *(void *)(a1 + 200) = result;
  return result;
}

uint64_t sub_49CCC(uint64_t a1)
{
  uint64_t v2 = off_8F4D0;
  *(void *)a1 = off_8F4D0;
  long long v3 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice Destructor completed", buf, 2u);
    uint64_t v2 = *(uint64_t (***)())a1;
  }
  ((void (*)(uint64_t))v2[9])(a1);
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9176));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9184));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9192));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9200));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9208));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9216));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9224));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9232));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9240));
  CFArrayRemoveAllValues(*(CFMutableArrayRef *)(a1 + 9168));
  CFRelease(*(CFTypeRef *)(a1 + 9176));
  CFRelease(*(CFTypeRef *)(a1 + 9184));
  CFRelease(*(CFTypeRef *)(a1 + 9192));
  CFRelease(*(CFTypeRef *)(a1 + 9200));
  CFRelease(*(CFTypeRef *)(a1 + 9208));
  CFRelease(*(CFTypeRef *)(a1 + 9216));
  CFRelease(*(CFTypeRef *)(a1 + 9224));
  CFRelease(*(CFTypeRef *)(a1 + 9232));
  CFRelease(*(CFTypeRef *)(a1 + 9240));
  CFRelease(*(CFTypeRef *)(a1 + 9168));
  uint64_t v4 = *(void *)(a1 + 9248);
  if (v4)
  {
    sub_2426C(v4);
    operator delete();
  }
  uint64_t v5 = *(void **)(a1 + 9456);
  if (v5)
  {

    *(void *)(a1 + 9456) = 0;
  }
  *(void *)std::string buf = 0;
  uint64_t v13 = 0;
  sub_5CDCC((uint64_t)buf, a1 + 9608);
  uint64_t v6 = *(void **)(a1 + 9672);
  if (v6)
  {
    if (!dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 9672)))
    {
      uint64_t v7 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v11 = 0;
        _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Delayed Control Centre Update: Cancelling current Dispatch", v11, 2u);
        uint64_t v6 = *(void **)(a1 + 9672);
      }
      dispatch_block_cancel(v6);
    }
    *(void *)(a1 + 9672) = 0;
  }
  sub_5CEA4((uint64_t)buf);
  sub_18C7C(a1 + 9280, *(void **)(a1 + 9288));
  *(void *)(a1 + 9280) = a1 + 9288;
  *(void *)(a1 + 9296) = 0;
  *(void *)(a1 + 9288) = 0;
  sub_5CF10(buf);
  sub_5CD00(a1 + 9608, v8);
  sub_18C7C(a1 + 9280, *(void **)(a1 + 9288));
  return sub_415C(a1, v9);
}

void sub_49F30(uint64_t a1)
{
  sub_49CCC(a1);

  operator delete();
}

uint64_t sub_49F68(uint64_t a1, int a2)
{
  int v3 = a2;
  uint64_t v4 = 1735159650;
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 248))(a1, &v3);
}

uint64_t sub_49FBC(_DWORD *a1, uint64_t a2)
{
  uint64_t v4 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    __n128 v5 = ((__n128 (*)(_DWORD *))*(void *)(*(void *)a1 + 992))(a1);
    v5.n128_u32[0] = a1[2314];
    int16x8_t v6 = (int16x8_t)vmovl_u8((uint8x8_t)v5.n128_u64[0]);
    *(int16x4_t *)v6.i8 = vrev64_s16(*(int16x4_t *)v6.i8);
    unsigned __int32 v10 = vmovn_s16(v6).u32[0];
    char v11 = 0;
    v9[0] = BYTE3(a2);
    v9[1] = BYTE2(a2);
    void v9[2] = BYTE1(a2);
    v9[3] = a2;
    v9[4] = 0;
    *(_DWORD *)std::string buf = 67109634;
    int v13 = v7;
    __int16 v14 = 2080;
    int v15 = &v10;
    __int16 v16 = 2080;
    uint64_t v17 = v9;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Request profile Change, IO status %d, profile change %s => %s", buf, 0x1Cu);
  }
  return (*(uint64_t (**)(_DWORD *, uint64_t, uint64_t))(*(void *)a1 + 240))(a1, 1650750576, a2);
}

void sub_4A13C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1312))(a1);
  sub_497C8((void *)a1, a3, v6, 0);
  int v7 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    __n128 v8 = ((__n128 (*)(uint64_t))*(void *)(*(void *)a1 + 992))(a1);
    v13[0] = BYTE3(a2);
    v13[1] = BYTE2(a2);
    void v13[2] = BYTE1(a2);
    __int16 v14 = a2;
    v8.n128_u32[0] = *(_DWORD *)(a1 + 9256);
    int16x8_t v9 = (int16x8_t)vmovl_u8((uint8x8_t)v8.n128_u64[0]);
    *(int16x4_t *)v9.i8 = vrev64_s16(*(int16x4_t *)v9.i8);
    unsigned __int32 v11 = vmovn_s16(v9).u32[0];
    char v12 = 0;
    *(_DWORD *)std::string buf = 67109634;
    int v16 = v10;
    __int16 v17 = 2080;
    uint64_t v18 = v13;
    __int16 v19 = 2080;
    uint64_t v20 = &v11;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Perform ProfileUpdate, IO status %d, profile change %s => %s", buf, 0x1Cu);
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 1368))(a1, a2, a3, *(unsigned int *)(a1 + 9264));
  if (a3 == 1953260897) {
    sub_4A314(a1);
  }
}

void sub_4A314(uint64_t a1)
{
  if ((sub_395B4() & 1) == 0)
  {
    uint64_t v2 = *(void *)(a1 + 9120);
    if (v2)
    {
      int v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 1048))(v2);
      uint64_t v4 = *(void *)(a1 + 9128);
      if (v3)
      {
        if (!v4) {
          operator new();
        }
        CFArrayRef v5 = *(const __CFArray **)(a1 + 9176);
        v34.length = CFArrayGetCount(v5);
        v34.location = 0;
        if (CFArrayGetFirstIndexOfValue(v5, v34, *(const void **)(a1 + 9128)) == -1)
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9176), *(const void **)(a1 + 9128));
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9192), *(const void **)(a1 + 9128));
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9224), *(const void **)(a1 + 9128));
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9240), *(const void **)(a1 + 9128));
        }
      }
      else if (v4)
      {
        CFArrayRef v6 = *(const __CFArray **)(a1 + 9176);
        v35.length = CFArrayGetCount(v6);
        v35.location = 0;
        FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v6, v35, *(const void **)(a1 + 9128));
        CFArrayRemoveValueAtIndex(v6, FirstIndexOfValue);
        CFArrayRef v8 = *(const __CFArray **)(a1 + 9192);
        v36.length = CFArrayGetCount(v8);
        v36.location = 0;
        CFIndex v9 = CFArrayGetFirstIndexOfValue(v8, v36, *(const void **)(a1 + 9128));
        CFArrayRemoveValueAtIndex(v8, v9);
        CFArrayRef v10 = *(const __CFArray **)(a1 + 9224);
        v37.length = CFArrayGetCount(v10);
        v37.location = 0;
        CFIndex v11 = CFArrayGetFirstIndexOfValue(v10, v37, *(const void **)(a1 + 9128));
        CFArrayRemoveValueAtIndex(v10, v11);
        CFArrayRef v12 = *(const __CFArray **)(a1 + 9240);
        v38.length = CFArrayGetCount(v12);
        v38.location = 0;
        CFIndex v13 = CFArrayGetFirstIndexOfValue(v12, v38, *(const void **)(a1 + 9128));
        CFArrayRemoveValueAtIndex(v12, v13);
      }
      int v14 = (*(uint64_t (**)(void))(**(void **)(a1 + 9120) + 1040))(*(void *)(a1 + 9120));
      uint64_t v15 = *(void *)(a1 + 9136);
      if (v14)
      {
        if (!v15) {
          operator new();
        }
        CFArrayRef v16 = *(const __CFArray **)(a1 + 9200);
        v39.length = CFArrayGetCount(v16);
        v39.location = 0;
        if (CFArrayGetFirstIndexOfValue(v16, v39, *(const void **)(a1 + 9136)) == -1)
        {
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9200), *(const void **)(a1 + 9136));
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9216), *(const void **)(a1 + 9136));
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9224), *(const void **)(a1 + 9136));
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 9240), *(const void **)(a1 + 9136));
        }
      }
      else if (v15)
      {
        CFArrayRef v17 = *(const __CFArray **)(a1 + 9200);
        CFArrayRef v18 = *(const __CFArray **)(a1 + 9176);
        v40.length = CFArrayGetCount(v17);
        v40.location = 0;
        CFIndex v19 = CFArrayGetFirstIndexOfValue(v18, v40, *(const void **)(a1 + 9136));
        CFArrayRemoveValueAtIndex(v17, v19);
        CFArrayRef v20 = *(const __CFArray **)(a1 + 9216);
        CFArrayRef v21 = *(const __CFArray **)(a1 + 9192);
        v41.length = CFArrayGetCount(v20);
        v41.location = 0;
        CFIndex v22 = CFArrayGetFirstIndexOfValue(v21, v41, *(const void **)(a1 + 9136));
        CFArrayRemoveValueAtIndex(v20, v22);
        CFArrayRef v23 = *(const __CFArray **)(a1 + 9224);
        v42.length = CFArrayGetCount(v23);
        v42.location = 0;
        CFIndex v24 = CFArrayGetFirstIndexOfValue(v23, v42, *(const void **)(a1 + 9136));
        CFArrayRemoveValueAtIndex(v23, v24);
        CFArrayRef v25 = *(const __CFArray **)(a1 + 9240);
        v43.length = CFArrayGetCount(v25);
        v43.location = 0;
        CFIndex v26 = CFArrayGetFirstIndexOfValue(v25, v43, *(const void **)(a1 + 9136));
        CFArrayRemoveValueAtIndex(v25, v26);
      }
      char v27 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9176))) {
          char v28 = "Yes";
        }
        else {
          char v28 = "No";
        }
        if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9200))) {
          char v29 = "Yes";
        }
        else {
          char v29 = "No";
        }
        int v30 = 136315394;
        unsigned int v31 = v28;
        __int16 v32 = 2080;
        id v33 = v29;
        _os_log_impl(&dword_0, v27, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice : Stream info,  Input Stream = %s Output Stream = %s ", (uint8_t *)&v30, 0x16u);
      }
    }
  }
}

void sub_4A71C()
{
}

unsigned char *sub_4A744(uint64_t a1)
{
  CFStringRef result = *(unsigned char **)(a1 + 9096);
  if (result && result[192])
  {
    (*(void (**)(unsigned char *))(*(void *)result + 1496))(result);
    if (*(unsigned char *)(*(void *)(a1 + 9096) + 192)) {
      uint64_t v3 = *(void *)(a1 + 9096);
    }
    else {
      uint64_t v3 = 0;
    }
    uint64_t v4 = *(uint64_t (**)(void))(*(void *)v3 + 256);
    return (unsigned char *)v4();
  }
  return result;
}

uint64_t sub_4A810(void *a1)
{
  uint64_t v2 = (unsigned char *)a1[1137];
  if (v2 && v2[192])
  {
    BOOL v3 = a1[1157] == 1952539500 && *(unsigned char *)(a1[1156] + 272) != 0;
    (*(void (**)(unsigned char *, BOOL))(*(void *)v2 + 576))(v2, v3);
  }
  uint64_t v5 = 0x676C6F6265636E72;
  int v6 = 0;
  (*(void (**)(void *, uint64_t *))(*a1 + 248))(a1, &v5);
  uint64_t v5 = 0x676C6F6263737462;
  int v6 = 0;
  (*(void (**)(void *, uint64_t *))(*a1 + 248))(a1, &v5);
  uint64_t v5 = 0x676C6F62636C6F6BLL;
  int v6 = 0;
  return (*(uint64_t (**)(void *, uint64_t *))(*a1 + 248))(a1, &v5);
}

BOOL sub_4A954(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    v6[0] = BYTE3(a2);
    v6[1] = BYTE2(a2);
    void v6[2] = BYTE1(a2);
    v6[3] = a2;
    v6[4] = 0;
    *(_DWORD *)std::string buf = 136315138;
    *(void *)&uint8_t buf[4] = v6;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: Remove BTAudioDevice %s", buf, 0xCu);
  }
  switch(a2)
  {
    case 1952539500:
      *(void *)(a1 + 9088) = 0;
      break;
    case 1953260897:
      *(void *)(a1 + 9112) = 0;
      break;
    case 1953719151:
      *(void *)(a1 + 9096) = 0;
      sub_4AB40(a1, 1953719151, 0);
      break;
  }
  if (*(void *)(a1 + 9256) == a2
    && (*(void *)(a1 + 9120) = 0,
        *(void *)(a1 + 9256) = 1953853033,
        *(void *)(a1 + 9264) = 1919183219,
        sub_395B4()))
  {
    if (*(void *)(a1 + 9112)) {
      sub_49FBC((_DWORD *)a1, 1953260897);
    }
    if (*(void *)(a1 + 9096)) {
      sub_49FBC((_DWORD *)a1, 1953719151);
    }
    if (*(void *)(a1 + 9088)) {
      sub_49FBC((_DWORD *)a1, 1952539500);
    }
  }
  else
  {
    strcpy((char *)buf, "pavabolg");
    buf[9] = 0;
    *(_WORD *)&buf[10] = 0;
    (*(void (**)(uint64_t, uint8_t *))(*(void *)a1 + 248))(a1, buf);
  }
  return *(void *)(a1 + 9120) != 0;
}

uint64_t sub_4AB40(uint64_t a1, int a2, unsigned int a3)
{
  int v6 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 9080);
    v10[0] = HIBYTE(a2);
    v10[1] = BYTE2(a2);
    _OWORD v10[2] = BYTE1(a2);
    v10[3] = a2;
    v10[4] = 0;
    CFArrayRef v8 = "Disconnection";
    if (a3) {
      CFArrayRef v8 = "Creation";
    }
    *(_DWORD *)std::string buf = 138543874;
    uint64_t v12 = v7;
    __int16 v13 = 2082;
    int v14 = v10;
    __int16 v15 = 2082;
    CFArrayRef v16 = v8;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "[%{public}@ ]  %{public}s, Profile Transport operation completed operaton xpc_type_t type = %{public}s", buf, 0x20u);
  }
  if (sub_56B5C(a1)) {
    sub_56E00(a1);
  }
  sub_5CA94(34, a3, 0, 0, 0);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 9312));
  pthread_cond_signal((pthread_cond_t *)(a1 + 9376));
  return pthread_mutex_unlock((pthread_mutex_t *)(a1 + 9312));
}

uint64_t sub_4AC94(void *a1, double *a2, __n128 a3)
{
  uint64_t v5 = a1[1137];
  if (v5
    && ((*(void (**)(double *__return_ptr))(*(void *)v5 + 800))(v19),
        a3.n128_f64[0] = v19[0],
        double v6 = *a2,
        v19[0] == *a2))
  {
    uint64_t v7 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      (*(void (**)(double *__return_ptr))(*(void *)a1[1137] + 800))(v19);
      *(_DWORD *)std::string buf = 134218240;
      double v21 = v6;
      __int16 v22 = 2048;
      double v23 = v19[0];
      _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "UpdateCurrentBTAudioDeviceFromSampleRate HFP  %f = %f", buf, 0x16u);
    }
    int v8 = (*(uint64_t (**)(void *))(*a1 + 1312))(a1);
    sub_497C8(a1, 1953719151, v8, 0);
    uint64_t v9 = 1;
  }
  else
  {
    uint64_t v9 = 0;
  }
  uint64_t v10 = a1[1136];
  if (v10)
  {
    (*(void (**)(double *__return_ptr))(*(void *)v10 + 800))(v19);
    a3.n128_f64[0] = v19[0];
    double v11 = *a2;
    if (v19[0] == *a2)
    {
      uint64_t v12 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        (*(void (**)(double *__return_ptr))(*(void *)a1[1136] + 800))(v19);
        *(_DWORD *)std::string buf = 134218240;
        double v21 = v11;
        __int16 v22 = 2048;
        double v23 = v19[0];
        _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "UpdateCurrentBTAudioDeviceFromSampleRate A2DP  %f = %f", buf, 0x16u);
      }
      int v13 = (*(uint64_t (**)(void *))(*a1 + 1312))(a1);
      sub_497C8(a1, 1952539500, v13, 0);
      uint64_t v9 = 1;
    }
  }
  uint64_t v14 = a1[1139];
  if (v14)
  {
    (*(void (**)(double *__return_ptr, __n128))(*(void *)v14 + 800))(v19, a3);
    double v15 = *a2;
    if (v19[0] == *a2)
    {
      CFArrayRef v16 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        (*(void (**)(double *__return_ptr))(*(void *)a1[1139] + 800))(v19);
        *(_DWORD *)std::string buf = 134218240;
        double v21 = v15;
        __int16 v22 = 2048;
        double v23 = v19[0];
        _os_log_impl(&dword_0, v16, OS_LOG_TYPE_DEFAULT, "UpdateCurrentBTAudioDeviceFromSampleRate LEA  %f = %f", buf, 0x16u);
      }
      int v17 = (*(uint64_t (**)(void *))(*a1 + 1312))(a1);
      sub_497C8(a1, 1953260897, v17, 0);
      return 1;
    }
  }
  return v9;
}

void sub_4B08C(uint64_t *a1, uint64_t a2)
{
  switch(a2)
  {
    case 1952539500:
      uint64_t v4 = a1 + 1136;
      int v5 = 16;
      break;
    case 1953260897:
      uint64_t v4 = a1 + 1139;
      int v5 = 0x10000;
      break;
    case 1953719151:
      uint64_t v4 = a1 + 1137;
      int v5 = 1;
      break;
    default:
      goto LABEL_8;
  }
  sub_4B04(*v4);
  uint64_t *v4 = 0;
  sub_245B8(a1[1156], v5);
  sub_4A954((uint64_t)a1, a2);
LABEL_8:
  double v6 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    v9[0] = BYTE3(a2);
    v9[1] = BYTE2(a2);
    void v9[2] = BYTE1(a2);
    v9[3] = a2;
    v9[4] = 0;
    BOOL v7 = a1[1137] || a1[1136] || a1[1139] != 0;
    int v8 = *(_DWORD *)(a1[1156] + 196);
    *(_DWORD *)std::string buf = 136315650;
    double v11 = v9;
    __int16 v12 = 1024;
    BOOL v13 = v7;
    __int16 v14 = 1024;
    int v15 = v8;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice, InvalidateBTAudioDevice %s Empty=%d Connected Bitmap = %x", buf, 0x18u);
  }
}

uint64_t sub_4B21C(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
  if (Count < 1) {
    return 0;
  }
  CFIndex v3 = Count;
  LODWORD(v4) = 0;
  for (CFIndex i = 0; i != v3; ++i)
    uint64_t v4 = v4 + *((unsigned __int8 *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), i) + 192);
  return v4;
}

__CFArray *sub_4B28C(uint64_t a1)
{
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 2, &kCFTypeArrayCallBacks);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
  if (Count >= 1)
  {
    CFIndex v4 = Count;
    for (CFIndex i = 0; i != v4; ++i)
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), i);
      if (ValueAtIndex[192])
      {
        int valuePtr = 0;
        int valuePtr = sub_7C98((uint64_t)ValueAtIndex);
        CFNumberRef v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
        CFArrayAppendValue(Mutable, v7);
        CFRelease(v7);
      }
    }
  }
  return Mutable;
}

void sub_4B358(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[1137];
  if (v4)
  {
    sub_4B04(v4);
    int v5 = (*(uint64_t (**)(void))(*(void *)a1[1137] + 16))(a1[1137]);
    int v6 = v5;
    unint64_t v7 = *(void *)(a2 + 16);
    int v8 = *(_DWORD **)(a2 + 8);
    if ((unint64_t)v8 >= v7)
    {
      uint64_t v10 = *(_DWORD **)a2;
      uint64_t v11 = ((uint64_t)v8 - *(void *)a2) >> 2;
      unint64_t v12 = v11 + 1;
      if ((unint64_t)(v11 + 1) >> 62) {
        goto LABEL_62;
      }
      uint64_t v13 = v7 - (void)v10;
      if (v13 >> 1 > v12) {
        unint64_t v12 = v13 >> 1;
      }
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v14 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v14 = v12;
      }
      if (v14)
      {
        int v15 = (char *)sub_47A48(a2 + 16, v14);
        uint64_t v10 = *(_DWORD **)a2;
        int v8 = *(_DWORD **)(a2 + 8);
      }
      else
      {
        int v15 = 0;
      }
      CFArrayRef v16 = &v15[4 * v11];
      int v17 = &v15[4 * v14];
      *(_DWORD *)CFArrayRef v16 = v6;
      uint64_t v9 = v16 + 4;
      while (v8 != v10)
      {
        int v18 = *--v8;
        *((_DWORD *)v16 - 1) = v18;
        v16 -= 4;
      }
      *(void *)a2 = v16;
      *(void *)(a2 + 8) = v9;
      *(void *)(a2 + 16) = v17;
      if (v10) {
        operator delete(v10);
      }
    }
    else
    {
      *int v8 = v5;
      uint64_t v9 = v8 + 1;
    }
    *(void *)(a2 + 8) = v9;
    a1[1137] = 0;
    sub_4A954((uint64_t)a1, 1953719151);
  }
  uint64_t v19 = a1[1136];
  if (v19)
  {
    sub_4B04(v19);
    int v20 = (*(uint64_t (**)(void))(*(void *)a1[1136] + 16))(a1[1136]);
    int v21 = v20;
    unint64_t v22 = *(void *)(a2 + 16);
    double v23 = *(_DWORD **)(a2 + 8);
    if ((unint64_t)v23 >= v22)
    {
      CFArrayRef v25 = *(_DWORD **)a2;
      uint64_t v26 = ((uint64_t)v23 - *(void *)a2) >> 2;
      unint64_t v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 62) {
        goto LABEL_62;
      }
      uint64_t v28 = v22 - (void)v25;
      if (v28 >> 1 > v27) {
        unint64_t v27 = v28 >> 1;
      }
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v29 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v29 = v27;
      }
      if (v29)
      {
        int v30 = (char *)sub_47A48(a2 + 16, v29);
        CFArrayRef v25 = *(_DWORD **)a2;
        double v23 = *(_DWORD **)(a2 + 8);
      }
      else
      {
        int v30 = 0;
      }
      unsigned int v31 = &v30[4 * v26];
      __int16 v32 = &v30[4 * v29];
      *(_DWORD *)unsigned int v31 = v21;
      CFIndex v24 = v31 + 4;
      while (v23 != v25)
      {
        int v33 = *--v23;
        *((_DWORD *)v31 - 1) = v33;
        v31 -= 4;
      }
      *(void *)a2 = v31;
      *(void *)(a2 + 8) = v24;
      *(void *)(a2 + 16) = v32;
      if (v25) {
        operator delete(v25);
      }
    }
    else
    {
      *double v23 = v20;
      CFIndex v24 = v23 + 1;
    }
    *(void *)(a2 + 8) = v24;
    a1[1136] = 0;
    sub_4A954((uint64_t)a1, 1952539500);
  }
  uint64_t v34 = a1[1139];
  if (!v34) {
    goto LABEL_55;
  }
  sub_4B04(v34);
  int v35 = (*(uint64_t (**)(void))(*(void *)a1[1139] + 16))(a1[1139]);
  int v36 = v35;
  unint64_t v37 = *(void *)(a2 + 16);
  CFRange v38 = *(_DWORD **)(a2 + 8);
  if ((unint64_t)v38 >= v37)
  {
    CFRange v40 = *(_DWORD **)a2;
    uint64_t v41 = ((uint64_t)v38 - *(void *)a2) >> 2;
    unint64_t v42 = v41 + 1;
    if (!((unint64_t)(v41 + 1) >> 62))
    {
      uint64_t v43 = v37 - (void)v40;
      if (v43 >> 1 > v42) {
        unint64_t v42 = v43 >> 1;
      }
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v44 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v44 = v42;
      }
      if (v44)
      {
        uint64_t v45 = (char *)sub_47A48(a2 + 16, v44);
        CFRange v40 = *(_DWORD **)a2;
        CFRange v38 = *(_DWORD **)(a2 + 8);
      }
      else
      {
        uint64_t v45 = 0;
      }
      uint64_t v46 = &v45[4 * v41];
      uint64_t v47 = &v45[4 * v44];
      *(_DWORD *)uint64_t v46 = v36;
      CFRange v39 = v46 + 4;
      while (v38 != v40)
      {
        int v48 = *--v38;
        *((_DWORD *)v46 - 1) = v48;
        v46 -= 4;
      }
      *(void *)a2 = v46;
      *(void *)(a2 + 8) = v39;
      *(void *)(a2 + 16) = v47;
      if (v40) {
        operator delete(v40);
      }
      goto LABEL_54;
    }
LABEL_62:
    sub_47A30();
  }
  *CFRange v38 = v35;
  CFRange v39 = v38 + 1;
LABEL_54:
  *(void *)(a2 + 8) = v39;
  a1[1139] = 0;
  sub_4A954((uint64_t)a1, 1953260897);
LABEL_55:
  xpc_object_t v49 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v50 = a1[1137] || a1[1136] || a1[1139] != 0;
    v51[0] = 67109120;
    v51[1] = v50;
    _os_log_impl(&dword_0, v49, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: InvalidateAllBTAudioDevice Empty=%d ", (uint8_t *)v51, 8u);
  }
}

uint64_t sub_4B718(uint64_t a1, __int32 **a2)
{
  v26[0] = 0;
  v26[1] = 0;
  sub_5CDCC((uint64_t)v26, a1 + 552);
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
  if (Count >= 1)
  {
    unint64_t v5 = Count + 1;
    do
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), v5 - 2);
      unint64_t v7 = *a2;
      int v8 = a2[1];
      __int32 v9 = (*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 16))(ValueAtIndex);
      uint64_t v10 = wmemchr(v7, v9, v8 - v7);
      if (v10) {
        uint64_t v11 = v10;
      }
      else {
        uint64_t v11 = v8;
      }
      if (v11 != a2[1])
      {
        if ((*(unsigned int (**)(const void *))(*(void *)ValueAtIndex + 296))(ValueAtIndex)
          && sub_7C98((uint64_t)ValueAtIndex) == 1952539500)
        {
          uint64_t v12 = qword_A2350;
          uint64_t v13 = *(void *)(qword_A2350 + 392);
          uint64_t v14 = *(void *)(qword_A2350 + 400);
          int v15 = qword_A1B50;
          BOOL v16 = os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR);
          if (v14 == v13)
          {
            if (v16) {
              sub_6A060(&v24, v25, v15);
            }
          }
          else
          {
            if (v16)
            {
              *(_WORD *)std::string buf = 0;
              _os_log_error_impl(&dword_0, v15, OS_LOG_TYPE_ERROR, "Wireless Splitter device is an aggregate removing", buf, 2u);
              uint64_t v12 = qword_A2350;
            }
            sub_445A0(v12, (uint64_t)ValueAtIndex);
          }
        }
        int v17 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = *(void *)(a1 + 9080);
          uint64_t v19 = sub_7904((uint64_t)ValueAtIndex);
          *(_DWORD *)std::string buf = 138543618;
          uint64_t v28 = v18;
          __int16 v29 = 2114;
          uint64_t v30 = v19;
          _os_log_impl(&dword_0, v17, OS_LOG_TYPE_DEFAULT, "[%{public}@] Deleting BTAudioDevice %{public}@", buf, 0x16u);
        }
        CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 9168), v5 - 2);
        sub_5CEA4((uint64_t)v26);
        uint64_t v20 = qword_A2350;
        unsigned int v21 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 3221225472;
        void v23[2] = sub_4BA78;
        v23[3] = &unk_8D2C0;
        v23[4] = ValueAtIndex;
        sub_44BA4(v20, v21, v23);
        sub_5CDFC((uint64_t)v26);
      }
      --v5;
    }
    while (v5 > 1);
  }
  sub_5CEA4((uint64_t)v26);
  return sub_5CF10(v26);
}

void sub_4BA50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
}

uint64_t sub_4BA78(uint64_t a1)
{
  v4[0] = 0;
  v4[1] = 0;
  sub_5CDCC((uint64_t)v4, qword_A2350 + 200);
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  return sub_5CF10(v4);
}

uint64_t sub_4BAF0(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 9248) + 328);
}

uint64_t sub_4BAFC(uint64_t a1, char a2)
{
  return sub_2D5E8(*(void *)(a1 + 9248), a2);
}

uint64_t sub_4BB04(uint64_t *a1, int a2, uint64_t a3)
{
  sub_2D5E8(a1[1156], a2);
  int v6 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v7 = "disabled";
    if (a2) {
      unint64_t v7 = "enabled";
    }
    v11[0] = 136315138;
    *(void *)&v11[1] = v7;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Wireless Splitter From BT is %s", (uint8_t *)v11, 0xCu);
  }
  uint64_t v8 = qword_A2350;
  if (a2)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
    return sub_43A48(v8, v9);
  }
  else
  {
    sub_446D4(qword_A2350);
    strcpy((char *)v11, "gaswbolg");
    BYTE1(v11[2]) = 0;
    HIWORD(v11[2]) = 0;
    return (*(uint64_t (**)(uint64_t *, _DWORD *))(*a1 + 248))(a1, v11);
  }
}

void sub_4BC60(uint64_t a1)
{
  v11[0] = 0;
  v11[1] = 0;
  sub_5CDCC((uint64_t)v11, a1 + 552);
  *(_DWORD *)(a1 + 368) = 1953853033;
  uint64_t v2 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 200);
    *(_DWORD *)std::string buf = 138412290;
    uint64_t v13 = v3;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice::Initialize %@", buf, 0xCu);
  }
  if (*(void *)(a1 + 200))
  {
    if (sub_24588(*(void *)(a1 + 9248), 0x10000) || sub_24588(*(void *)(a1 + 9248), 0x20000))
    {
      *(void *)(a1 + 9080) = CFStringCreateCopy(kCFAllocatorDefault, *(CFStringRef *)(a1 + 200));
      if (sub_395B4())
      {
        CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, *(CFStringRef *)(a1 + 200), @"-tlea");
        CFArrayRef v5 = ArrayBySeparatingStrings;
        if (ArrayBySeparatingStrings)
        {
          uint64_t ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
          *(void *)(a1 + 9080) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@:output", ValueAtIndex);
          CFRelease(v5);
        }
      }
    }
    else
    {
      CFArrayRef v7 = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, *(CFStringRef *)(a1 + 200), @"-");
      if (CFArrayGetCount(v7))
      {
        uint64_t v8 = CFArrayGetValueAtIndex(v7, 0);
        int v9 = sub_395B4();
        CFStringRef v10 = @"btaudio";
        if (v9) {
          CFStringRef v10 = @"output";
        }
        *(void *)(a1 + 9080) = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-%@", v8, v10);
      }
      CFRelease(v7);
    }
  }
  sub_4C188(a1);
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1040))(a1)) {
    operator new();
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 1048))(a1)) {
    operator new();
  }
  if (*(unsigned char *)(*(void *)(a1 + 9248) + 168)) {
    operator new();
  }
  if (*(unsigned char *)(a1 + 424)) {
    operator new();
  }
  operator new();
}

void sub_4C118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

void sub_4C188(uint64_t a1)
{
  if (sub_395B4())
  {
    (*(void (**)(uint64_t, void))(*(void *)a1 + 1032))(a1, 0);
    uint64_t v2 = *(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1024);
    uint64_t v3 = a1;
    uint64_t v4 = 1;
LABEL_5:
    v2(v3, v4);
    return;
  }
  if (sub_24588(*(void *)(a1 + 9248), 0x10000))
  {
    uint64_t v5 = (*(uint64_t (**)(void))(**(void **)(a1 + 9120) + 1048))(*(void *)(a1 + 9120));
    (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1032))(a1, v5);
    uint64_t v6 = (*(uint64_t (**)(void))(**(void **)(a1 + 9120) + 1040))();
    uint64_t v2 = *(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1024);
    uint64_t v4 = v6;
    uint64_t v3 = a1;
    goto LABEL_5;
  }
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1032))(a1, 1);
  (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 1024))(a1, 1);
  CFArrayRef v7 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    v8[0] = 67109376;
    v8[1] = 1;
    __int16 v9 = 1024;
    int v10 = 1;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "Initial Streams input = %d | Output = %d ", (uint8_t *)v8, 0xEu);
  }
}

void sub_4C450(uint64_t a1)
{
  uint64_t v1 = (pthread_cond_t *)a1;
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9312);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 9312));
  uint64_t v1 = (pthread_cond_t *)((char *)v1 + 9376);
  pthread_cond_signal(v1);
  pthread_mutex_unlock(v2);
  pthread_mutex_lock(v2);
  pthread_mutex_unlock(v2);
  pthread_mutex_destroy(v2);
  pthread_cond_destroy(v1);
  uint64_t v3 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Trasnport Synchronization completed", v4, 2u);
  }
}

uint64_t sub_4C500(uint64_t a1)
{
  pthread_mutex_init((pthread_mutex_t *)(a1 + 9480), 0);
  uint64_t result = pthread_cond_init((pthread_cond_t *)(a1 + 9544), 0);
  *(void *)(a1 + 9600) = 100000;
  *(void *)(a1 + 9592) = 0;
  return result;
}

void sub_4C550(uint64_t a1)
{
  uint64_t v1 = (pthread_cond_t *)a1;
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9480);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 9480));
  uint64_t v1 = (pthread_cond_t *)((char *)v1 + 9544);
  pthread_cond_signal(v1);
  pthread_mutex_unlock(v2);
  pthread_mutex_lock(v2);
  pthread_mutex_unlock(v2);
  pthread_mutex_destroy(v2);
  pthread_cond_destroy(v1);
  uint64_t v3 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v4 = 0;
    _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Trasnport Synchronization completed", v4, 2u);
  }
}

uint64_t sub_4C600(void *a1)
{
  v12[0] = 0;
  v12[1] = 0;
  sub_5CDCC((uint64_t)v12, (uint64_t)(a1 + 69));
  sub_4C450((uint64_t)a1);
  uint64_t v2 = (const void *)a1[1135];
  if (v2)
  {
    CFRelease(v2);
    a1[1135] = 0;
  }
  uint64_t v3 = a1[1142];
  if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    a1[1142] = 0;
  }
  uint64_t v4 = a1[1141];
  if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    a1[1141] = 0;
  }
  uint64_t v5 = a1[1143];
  if (v5)
  {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    a1[1143] = 0;
  }
  uint64_t v6 = a1[1144];
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    a1[1144] = 0;
  }
  uint64_t v7 = a1[1145];
  if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    a1[1145] = 0;
  }
  if (*(unsigned char *)(a1[1156] + 277))
  {
    uint64_t v8 = qword_A2350;
    (*(void (**)(void **__return_ptr, void *))(*a1 + 832))(__p, a1);
    sub_41D30(v8, (uint64_t)__p);
    if (v11 < 0) {
      operator delete(__p[0]);
    }
  }
  return sub_5CF10(v12);
}

void sub_4C7B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  sub_5CF10(&a16);
  _Unwind_Resume(a1);
}

uint64_t sub_4C7DC(void *a1, int *a2)
{
  int v3 = *a2;
  if (*a2 <= 1819107690)
  {
    if (v3 <= 1668641651)
    {
      if (v3 > 1668049763)
      {
        if (v3 > 1668510817)
        {
          if (v3 != 1668510818)
          {
            int v4 = 1668575852;
            goto LABEL_53;
          }
        }
        else
        {
          if (v3 == 1668049764) {
            goto LABEL_54;
          }
          if (v3 != 1668050795) {
            goto LABEL_67;
          }
        }
        uint64_t result = a1[1140];
        if (result)
        {
          int v10 = *(uint64_t (**)(void))(*(void *)result + 24);
          return v10();
        }
        return result;
      }
      if (v3 == 1635087471) {
        return sub_395B4();
      }
      if (v3 == 1650682995) {
        goto LABEL_54;
      }
      int v4 = 1668047219;
    }
    else
    {
      if (v3 <= 1685278577)
      {
        if (v3 > 1684434035)
        {
          if (v3 == 1684434036) {
            goto LABEL_54;
          }
          if (v3 == 1685278561) {
            return 0;
          }
          goto LABEL_67;
        }
        if (v3 == 1668641652) {
          goto LABEL_54;
        }
        int v5 = 1684236338;
        goto LABEL_42;
      }
      if (v3 > 1751737453)
      {
        if (v3 == 1751737454) {
          goto LABEL_54;
        }
        int v4 = 1818850926;
      }
      else
      {
        if (v3 == 1685278578) {
          return *(unsigned __int8 *)(a1[1156] + 257);
        }
        int v4 = 1735354734;
      }
    }
LABEL_53:
    if (v3 == v4) {
      goto LABEL_54;
    }
    goto LABEL_67;
  }
  if (v3 > 1919512166)
  {
    if (v3 <= 1937007733)
    {
      if (v3 > 1936092275)
      {
        if (v3 == 1936092276) {
          goto LABEL_54;
        }
        int v5 = 1936879204;
      }
      else
      {
        if (v3 == 1919512167) {
          goto LABEL_54;
        }
        int v5 = 1935763060;
      }
LABEL_42:
      if (v3 == v5) {
        goto LABEL_43;
      }
LABEL_67:
      return sub_4CBC0(a1, a2);
    }
    if (v3 <= 1953653101)
    {
      if (v3 == 1937007734) {
        goto LABEL_54;
      }
      int v6 = 1937009955;
      goto LABEL_47;
    }
    if (v3 == 1969841184) {
      goto LABEL_54;
    }
    int v4 = 1953653102;
    goto LABEL_53;
  }
  if (v3 <= 1836414052)
  {
    if (v3 <= 1819569762)
    {
      if (v3 != 1819107691)
      {
        int v4 = 1819173229;
        goto LABEL_53;
      }
LABEL_54:
      int v7 = a2[1];
      int v8 = 1735159650;
      goto LABEL_55;
    }
    if (v3 != 1819569763)
    {
      int v4 = 1836411236;
      goto LABEL_53;
    }
LABEL_43:
    int v7 = a2[1];
    if (v7 == 1869968496) {
      return a2[2] == 0;
    }
    int v8 = 1768845428;
    goto LABEL_55;
  }
  if (v3 > 1853059699)
  {
    if (v3 == 1853059700) {
      goto LABEL_54;
    }
    int v6 = 1870098020;
LABEL_47:
    if (v3 == v6) {
      return (*(uint64_t (**)(void *, void, void))(*a1 + 1272))(a1, a2[1], a2[2]);
    }
    goto LABEL_67;
  }
  if (v3 != 1836414053)
  {
    int v4 = 1853059619;
    goto LABEL_53;
  }
  uint64_t result = sub_395B4();
  if (result)
  {
    int v7 = a2[1];
    int v8 = 1869968496;
LABEL_55:
    if (v7 == v8) {
      return a2[2] == 0;
    }
    return 0;
  }
  return result;
}

uint64_t sub_4CBC0(void *a1, int *a2)
{
  uint64_t v2 = a1[1161];
  if (!v2) {
    goto LABEL_12;
  }
  int v4 = *a2;
  int v5 = a1 + 1161;
  do
  {
    unsigned int v6 = *(_DWORD *)(v2 + 32);
    BOOL v7 = v6 >= v4;
    if (v6 >= v4) {
      int v8 = (uint64_t *)v2;
    }
    else {
      int v8 = (uint64_t *)(v2 + 8);
    }
    if (v7) {
      int v5 = (void *)v2;
    }
    uint64_t v2 = *v8;
  }
  while (*v8);
  if (v5 == a1 + 1161 || v4 < *((_DWORD *)v5 + 8)) {
    goto LABEL_12;
  }
  LOBYTE(result) = 0;
  if (v4 <= 1768256353)
  {
    if (v4 <= 1684434284)
    {
      if (v4 <= 1650750575)
      {
        if (v4 <= 1635148655)
        {
          if (v4 <= 1633973867)
          {
            if (v4 != 1633907555)
            {
              int v11 = 1633972065;
              goto LABEL_159;
            }
            LODWORD(result) = sub_395B4();
            if (!result) {
              return result;
            }
            if (!*(unsigned char *)(a1[1156] + 230)) {
              goto LABEL_12;
            }
LABEL_181:
            LOBYTE(result) = _os_feature_enabled_impl();
            return result;
          }
          if (v4 != 1633973868)
          {
            if (v4 == 1635017332) {
              goto LABEL_167;
            }
            int v10 = 1635148144;
            goto LABEL_166;
          }
        }
        else
        {
          if (v4 > 1650549619)
          {
            if (v4 == 1650549620) {
              goto LABEL_160;
            }
            if (v4 == 1650551140) {
              goto LABEL_167;
            }
            int v11 = 1650750320;
            goto LABEL_159;
          }
          if (v4 == 1635148656) {
            goto LABEL_167;
          }
          if (v4 != 1635149170)
          {
            if (v4 != 1650549606) {
              return result;
            }
            goto LABEL_156;
          }
        }
        if (*(unsigned char *)(a1[1156] + 228)) {
          goto LABEL_181;
        }
LABEL_12:
        LOBYTE(result) = 0;
        return result;
      }
      if (v4 <= 1651795821)
      {
        if (v4 > 1651466594)
        {
          if (v4 != 1651466595)
          {
            if (v4 == 1651466852) {
              goto LABEL_167;
            }
            int v11 = 1651728749;
            goto LABEL_159;
          }
LABEL_156:
          LOBYTE(result) = *(unsigned char *)(a1[1156] + 277);
          return result;
        }
        if (v4 != 1650750576)
        {
          int v10 = 1651271025;
          goto LABEL_166;
        }
      }
      else
      {
        if (v4 <= 1668051826)
        {
          if (v4 == 1651795822) {
            goto LABEL_167;
          }
          if (v4 != 1651798132)
          {
            int v10 = 1651798886;
            goto LABEL_166;
          }
          goto LABEL_160;
        }
        if (v4 == 1668051827 || v4 == 1668506479) {
          goto LABEL_167;
        }
        if (v4 != 1684234612) {
          return result;
        }
      }
      if (a2[1] != 1735159650) {
        goto LABEL_12;
      }
      BOOL v18 = a2[2] == 0;
LABEL_112:
      LOBYTE(result) = v18;
      return result;
    }
    if (v4 <= 1718772583)
    {
      if (v4 <= 1685088611)
      {
        if (v4 <= 1685021039)
        {
          if (v4 == 1684434285) {
            goto LABEL_142;
          }
          int v11 = 1684826732;
          goto LABEL_159;
        }
        if (v4 == 1685021040)
        {
          LOBYTE(result) = *(unsigned char *)(a1[1156] + 200);
          return result;
        }
        if (v4 == 1685025637) {
          goto LABEL_111;
        }
        int v14 = 1685026403;
      }
      else
      {
        if (v4 <= 1701015153)
        {
          if (v4 == 1685088612)
          {
            BOOL v19 = *(void *)(a1[1156] + 208) == 0;
LABEL_150:
            LOBYTE(result) = !v19;
            return result;
          }
          if (v4 == 1685283695) {
            goto LABEL_167;
          }
          int v11 = 1685484390;
          goto LABEL_159;
        }
        if (v4 == 1701015154) {
          goto LABEL_160;
        }
        if (v4 == 1701408627) {
          goto LABEL_167;
        }
        int v14 = 1702391923;
      }
      if (v4 != v14) {
        return result;
      }
LABEL_111:
      BOOL v18 = a1[1139] == 0;
      goto LABEL_112;
    }
    if (v4 <= 1752457589)
    {
      if (v4 <= 1751213426)
      {
        if (v4 == 1718772584) {
          goto LABEL_167;
        }
        int v10 = 1735221622;
        goto LABEL_166;
      }
      if (v4 == 1751213427 || v4 == 1752327777) {
        goto LABEL_167;
      }
      unsigned __int16 v13 = 24931;
    }
    else
    {
      if (v4 > 1767989615)
      {
        if (v4 == 1767989616) {
          goto LABEL_167;
        }
        if (v4 == 1767994227) {
          goto LABEL_147;
        }
        int v17 = 1768252517;
        goto LABEL_130;
      }
      if (v4 == 1752457590) {
        goto LABEL_147;
      }
      if (v4 == 1752462195) {
        goto LABEL_111;
      }
      unsigned __int16 v13 = 29556;
    }
    int v16 = v13 | 0x68740000;
    goto LABEL_146;
  }
  if (v4 <= 1936746088)
  {
    if (v4 <= 1886807153)
    {
      if (v4 > 1819046767)
      {
        if (v4 <= 1819505772)
        {
          if (v4 == 1819046768)
          {
            LOBYTE(result) = *(unsigned char *)(a1[1156] + 278);
            return result;
          }
          if (v4 != 1819241569)
          {
            int v10 = 1819503987;
            goto LABEL_166;
          }
          goto LABEL_160;
        }
        if (v4 == 1819505773)
        {
          uint64_t v23 = a1[1156];
          if (!*(_DWORD *)(v23 + 160))
          {
            LOBYTE(result) = sub_25640(v23);
            return result;
          }
          goto LABEL_167;
        }
        if (v4 == 1852992613) {
          goto LABEL_160;
        }
        int v17 = 1886546291;
LABEL_130:
        if (v4 != v17) {
          return result;
        }
        goto LABEL_142;
      }
      if ((v4 - 1768256354) > 0x11 || ((1 << (v4 - 98)) & 0x24001) == 0)
      {
        if (v4 != 1768382832)
        {
          if (v4 == 1818326127) {
            LOBYTE(result) = sub_395B4();
          }
          return result;
        }
        goto LABEL_167;
      }
LABEL_142:
      LOBYTE(result) = *(unsigned char *)(a1[1156] + 156);
      return result;
    }
    if (v4 > 1936225135)
    {
      if (v4 > 1936745317)
      {
        if (v4 == 1936745318) {
          goto LABEL_167;
        }
        if (v4 == 1936745331) {
          goto LABEL_147;
        }
        if (v4 != 1936745838) {
          return result;
        }
        goto LABEL_153;
      }
      if (v4 != 1936225136)
      {
        if (v4 == 1936744816) {
          goto LABEL_167;
        }
        unsigned __int16 v12 = 24950;
        goto LABEL_145;
      }
LABEL_92:
      int v15 = *(_DWORD *)(a1[1156] + 244);
LABEL_149:
      BOOL v19 = v15 == 0;
      goto LABEL_150;
    }
    if (v4 > 1935959403)
    {
      if (v4 == 1935959404) {
        goto LABEL_160;
      }
      if (v4 != 1936220524 && v4 != 1936221550) {
        return result;
      }
      goto LABEL_92;
    }
    if (v4 == 1886807154) {
      goto LABEL_167;
    }
    int v11 = 1935896430;
LABEL_159:
    if (v4 != v11) {
      return result;
    }
    goto LABEL_160;
  }
  if (v4 <= 1937208175)
  {
    if (v4 <= 1936748130)
    {
      if (v4 > 1936746610)
      {
        if (v4 == 1936746611 || v4 == 1936747876) {
          goto LABEL_167;
        }
        int v10 = 1936747877;
        goto LABEL_166;
      }
      if (v4 != 1936746089)
      {
        unsigned __int16 v12 = 26223;
        goto LABEL_145;
      }
LABEL_153:
      LOBYTE(result) = *(unsigned char *)(a1[1156] + 230);
      return result;
    }
    if (v4 <= 1936749429)
    {
      if (v4 != 1936748131 && v4 != 1936749417)
      {
        unsigned __int16 v12 = 29555;
LABEL_145:
        int v16 = v12 | 0x73700000;
LABEL_146:
        if (v4 != v16) {
          return result;
        }
        goto LABEL_147;
      }
      goto LABEL_153;
    }
    if (v4 != 1936749430)
    {
      if (v4 != 1937138786)
      {
        if (v4 != 1937204590) {
          return result;
        }
        goto LABEL_118;
      }
      goto LABEL_153;
    }
LABEL_147:
    LODWORD(result) = sub_395B4();
    if (!result) {
      return result;
    }
    int v15 = *(unsigned __int8 *)(a1[1156] + 230);
    goto LABEL_149;
  }
  if (v4 > 2004050278)
  {
    if (v4 > 2004051821)
    {
      if (v4 != 2004051822)
      {
        if (v4 == 2004053366)
        {
LABEL_168:
          if (a1[1140])
          {
            LODWORD(result) = (*(uint64_t (**)(void *))(*a1 + 296))(a1);
            if (result)
            {
              uint64_t v21 = qword_A2350;
              int v22 = (*(uint64_t (**)(void))(*(void *)a1[1140] + 16))(a1[1140]);
              LOBYTE(result) = sub_444E0(v21, v22);
            }
            return result;
          }
          goto LABEL_12;
        }
        if (v4 != 2004054901) {
          return result;
        }
      }
    }
    else if (v4 != 2004050279)
    {
      if (v4 != 2004050294)
      {
        if (v4 == 2004051812) {
          LOBYTE(result) = *(unsigned char *)(a1[1156] + 329);
        }
        return result;
      }
      goto LABEL_168;
    }
    LOBYTE(result) = *(unsigned char *)(a1[1156] + 327);
    return result;
  }
  if (v4 <= 1986947427)
  {
    if (v4 != 1937208176)
    {
      if (v4 == 1970496630)
      {
        LOBYTE(result) = *(unsigned char *)(a1[1156] + 144) ^ 1;
        return result;
      }
      int v10 = 1986225518;
LABEL_166:
      if (v4 != v10) {
        return result;
      }
LABEL_167:
      LOBYTE(result) = 1;
      return result;
    }
LABEL_118:
    LOBYTE(result) = *(unsigned char *)(a1[1156] + 274);
    return result;
  }
  if (v4 == 1986947428) {
    goto LABEL_167;
  }
  if (v4 != 1987080038)
  {
    int v10 = 2003394928;
    goto LABEL_166;
  }
LABEL_160:
  uint64_t result = a1[1140];
  if (!result) {
    return result;
  }
  uint64_t v20 = *(uint64_t (**)(void))(*(void *)result + 24);

  return v20();
}

uint64_t sub_4D568(uint64_t a1, int *a2, unsigned char *a3)
{
  int v3 = *a2;
  if (*a2 > 1819173228)
  {
    if (v3 > 1935763059)
    {
      if (v3 > 1937007733)
      {
        if (v3 > 1953653101)
        {
          if (v3 == 1969841184) {
            goto LABEL_52;
          }
          int v4 = 1953653102;
        }
        else
        {
          if (v3 == 1937007734) {
            goto LABEL_52;
          }
          int v4 = 1937009955;
        }
        goto LABEL_51;
      }
      BOOL v5 = v3 == 1935763060 || v3 == 1936092276;
      int v6 = 1936879204;
    }
    else
    {
      if (v3 > 1853059618)
      {
        if (v3 <= 1870098019)
        {
          if (v3 == 1853059619) {
            goto LABEL_52;
          }
          if (v3 == 1853059700)
          {
            *a3 = 1;
            return 0;
          }
LABEL_42:
          sub_4D810(a1, a2, a3);
          return 0;
        }
        if (v3 == 1870098020) {
          goto LABEL_52;
        }
        int v4 = 1919512167;
LABEL_51:
        if (v3 == v4) {
          goto LABEL_52;
        }
        goto LABEL_42;
      }
      BOOL v5 = v3 == 1819173229 || v3 == 1819569763;
      int v6 = 1836411236;
    }
LABEL_38:
    if (!v5 && v3 != v6) {
      goto LABEL_42;
    }
LABEL_52:
    *a3 = 0;
    return 0;
  }
  if (v3 > 1668641651)
  {
    if (v3 > 1735354733)
    {
      if (v3 > 1818850925)
      {
        if (v3 == 1818850926) {
          goto LABEL_52;
        }
        int v4 = 1819107691;
      }
      else
      {
        if (v3 == 1735354734) {
          goto LABEL_52;
        }
        int v4 = 1751737454;
      }
      goto LABEL_51;
    }
    BOOL v5 = v3 == 1668641652 || v3 == 1684236338;
    int v6 = 1684434036;
    goto LABEL_38;
  }
  if (v3 <= 1668049763)
  {
    BOOL v5 = v3 == 1635087471 || v3 == 1650682995;
    int v6 = 1668047219;
    goto LABEL_38;
  }
  if (v3 > 1668510817)
  {
    if (v3 == 1668510818) {
      goto LABEL_54;
    }
    int v4 = 1668575852;
    goto LABEL_51;
  }
  if (v3 == 1668049764) {
    goto LABEL_52;
  }
  if (v3 != 1668050795) {
    goto LABEL_42;
  }
LABEL_54:
  uint64_t v9 = *(void *)(a1 + 9120);
  if (!v9) {
    return 0;
  }
  int v10 = *(uint64_t (**)(void))(*(void *)v9 + 32);

  return v10();
}

uint64_t sub_4D810(uint64_t a1, int *a2, unsigned char *a3)
{
  int v3 = *a2;
  if (*a2 > 1701015153)
  {
    if (v3 <= 1852992612)
    {
      BOOL v4 = v3 == 1701015154 || v3 == 1818326127;
      int v5 = 1819241569;
    }
    else if (v3 > 1935959403)
    {
      BOOL v4 = v3 == 1987080038;
      int v5 = 1935959404;
    }
    else
    {
      BOOL v4 = v3 == 1852992613;
      int v5 = 1935896430;
    }
  }
  else if (v3 <= 1651728748)
  {
    BOOL v4 = v3 == 1633972065 || v3 == 1650549620;
    int v5 = 1650750320;
  }
  else if (v3 > 1684826731)
  {
    BOOL v4 = v3 == 1684826732;
    int v5 = 1685484390;
  }
  else
  {
    BOOL v4 = v3 == 1651728749;
    int v5 = 1651798132;
  }
  if (!v4 && v3 != v5)
  {
    uint64_t v10 = *(void *)(a1 + 9288);
    if (v10)
    {
      uint64_t v11 = a1 + 9288;
      do
      {
        unsigned int v12 = *(_DWORD *)(v10 + 32);
        BOOL v13 = v12 >= v3;
        if (v12 >= v3) {
          int v14 = (uint64_t *)v10;
        }
        else {
          int v14 = (uint64_t *)(v10 + 8);
        }
        if (v13) {
          uint64_t v11 = v10;
        }
        uint64_t v10 = *v14;
      }
      while (*v14);
      if (v11 != a1 + 9288 && v3 >= *(_DWORD *)(v11 + 32))
      {
        int v15 = a2;
        *a3 = *((unsigned char *)sub_48214((uint64_t **)(a1 + 9280), (unsigned int *)a2, (uint64_t)&unk_71834, &v15)[5] + 16);
      }
    }
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 9120);
  if (!v7) {
    return 0;
  }
  int v8 = *(uint64_t (**)(void))(*(void *)v7 + 32);

  return v8();
}

uint64_t sub_4D9FC(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, int *a5)
{
  int v6 = *a2;
  if ((int)*a2 > 1819173228)
  {
    if (v6 <= 1935763059)
    {
      if (v6 > 1853059699)
      {
        if (v6 != 1853059700)
        {
          if (v6 == 1870098020)
          {
            unsigned int v17 = a2[1];
            switch(v17)
            {
              case 0x6F757470u:
                uint64_t v16 = 9216;
                goto LABEL_69;
              case 0x696E7074u:
                uint64_t v16 = 9192;
                goto LABEL_69;
              case 0x676C6F62u:
                uint64_t v16 = 9240;
                goto LABEL_69;
            }
LABEL_64:
            int v8 = 0;
            goto LABEL_50;
          }
          int v9 = 1919512167;
          goto LABEL_41;
        }
      }
      else if (v6 != 1819173229)
      {
        if (v6 == 1819569763) {
          goto LABEL_49;
        }
        int v7 = 1836411236;
        goto LABEL_47;
      }
LABEL_48:
      int v8 = 8;
      goto LABEL_50;
    }
    if (v6 <= 1937007733)
    {
      if (v6 == 1935763060 || v6 == 1936092276) {
        goto LABEL_49;
      }
      if (v6 != 1936879204) {
        goto LABEL_61;
      }
      uint64_t v11 = *(void *)(a1 + 9120);
      if (!v11) {
        return 0;
      }
      (*(void (**)(void *__return_ptr))(*(void *)v11 + 800))(v18);
      int v8 = 20 * v19 + 12;
    }
    else
    {
      if (v6 > 1953653101)
      {
        if (v6 == 1953653102) {
          goto LABEL_49;
        }
        int v7 = 1969841184;
        goto LABEL_47;
      }
      if (v6 == 1937007734) {
        goto LABEL_49;
      }
      if (v6 != 1937009955) {
        goto LABEL_61;
      }
      int v8 = 4 * (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 1504))(a1, a2[1]);
    }
LABEL_50:
    *a5 = v8;
    return 0;
  }
  if (v6 > 1668575851)
  {
    if (v6 > 1684434035)
    {
      if (v6 <= 1751737453)
      {
        if (v6 != 1684434036)
        {
          int v7 = 1685278578;
          goto LABEL_47;
        }
LABEL_49:
        int v8 = 4;
        goto LABEL_50;
      }
      if (v6 == 1751737454) {
        goto LABEL_49;
      }
      int v7 = 1819107691;
LABEL_47:
      if (v6 == v7) {
        goto LABEL_48;
      }
      goto LABEL_61;
    }
    if (v6 != 1668575852)
    {
      if (v6 == 1668641652)
      {
        int v8 = 12 * *(_DWORD *)(a1 + 9296);
        goto LABEL_50;
      }
      int v7 = 1684236338;
      goto LABEL_47;
    }
    unsigned int v15 = a2[1];
    switch(v15)
    {
      case 0x6F757470u:
        uint64_t v16 = 9208;
        goto LABEL_69;
      case 0x696E7074u:
        uint64_t v16 = 9184;
        goto LABEL_69;
      case 0x676C6F62u:
        uint64_t v16 = 9232;
LABEL_69:
        int v8 = 4 * CFArrayGetCount(*(CFArrayRef *)(a1 + v16));
        goto LABEL_50;
    }
    goto LABEL_64;
  }
  if (v6 <= 1668049763)
  {
    if (v6 == 1635087471 || v6 == 1650682995) {
      goto LABEL_49;
    }
    int v9 = 1668047219;
LABEL_41:
    if (v6 == v9) {
      goto LABEL_49;
    }
    goto LABEL_61;
  }
  if (v6 == 1668049764) {
    goto LABEL_49;
  }
  if (v6 != 1668050795 && v6 != 1668510818)
  {
LABEL_61:
    return sub_4DF00(a1, a2, a3, a4, a5);
  }
  uint64_t v12 = *(void *)(a1 + 9120);
  if (!v12) {
    return 0;
  }
  BOOL v13 = *(uint64_t (**)(void))(*(void *)v12 + 40);

  return v13();
}

CFIndex sub_4DE20(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 1869968496:
      uint64_t v2 = 9208;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
    case 1768845428:
      uint64_t v2 = 9184;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
    case 1735159650:
      uint64_t v2 = 9232;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
  }
  return 0;
}

CFIndex sub_4DE90(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 1869968496:
      uint64_t v2 = 9216;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
    case 1768845428:
      uint64_t v2 = 9192;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
    case 1735159650:
      uint64_t v2 = 9240;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
  }
  return 0;
}

uint64_t sub_4DF00(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t result = 2003332927;
  uint64_t v7 = *(void *)(a1 + 9288);
  if (v7)
  {
    int v9 = (uint64_t **)(a1 + 9280);
    uint64_t v10 = a1 + 9288;
    unsigned int v11 = *a2;
    uint64_t v12 = v10;
    do
    {
      unsigned int v13 = *(_DWORD *)(v7 + 32);
      BOOL v14 = v13 >= v11;
      if (v13 >= v11) {
        unsigned int v15 = (uint64_t *)v7;
      }
      else {
        unsigned int v15 = (uint64_t *)(v7 + 8);
      }
      if (v14) {
        uint64_t v12 = v7;
      }
      uint64_t v7 = *v15;
    }
    while (*v15);
    if (v12 != v10 && v11 >= *(_DWORD *)(v12 + 32))
    {
      unsigned int v17 = a2;
      uint64_t v16 = sub_48214(v9, a2, (uint64_t)&unk_71834, &v17);
      uint64_t result = 0;
      *a5 = *((_DWORD *)v16[5] + 3);
    }
  }
  return result;
}

uint64_t sub_4DFB4(void *a1, int *a2, uint64_t a3, uint64_t a4, void **a5, unsigned int a6, int *a7, uint64_t a8)
{
  int v12 = *a2;
  if (*a2 > 1819173228)
  {
    if (v12 > 1935763059)
    {
      if (v12 <= 1937007733)
      {
        if (v12 > 1936747876)
        {
          if (v12 == 1936747877)
          {
            uint64_t v13 = 0;
            int v18 = *(_DWORD *)(a1[1156] + 336);
            goto LABEL_143;
          }
          if (v12 == 1936879204)
          {
            uint64_t v20 = a1[1140];
            if (v20)
            {
              uint64_t v35 = 0;
              long long v33 = 0u;
              long long v34 = 0u;
              (*(void (**)(long long *__return_ptr))(*(void *)v20 + 800))(&v33);
              uint64_t v21 = HIDWORD(v34);
              unsigned int v22 = 20 * HIDWORD(v34) + 12;
              if (v22 <= a6)
              {
                *(void *)a8 = 0;
                *(_DWORD *)(a8 + 8) = v21;
                if (v21)
                {
                  uint64_t v30 = 0;
                  unsigned int v31 = (void *)(a8 + 16);
                  do
                  {
                    ++v30;
                    if (v21 == 1) {
                      int v32 = 42;
                    }
                    else {
                      int v32 = v30;
                    }
                    *((_DWORD *)v31 - 1) = v32;
                    *unsigned int v31 = 0;
                    v31[1] = 0;
                    unsigned int v31 = (void *)((char *)v31 + 20);
                  }
                  while (v21 != v30);
                }
                uint64_t v13 = 0;
                *a7 = v22;
              }
              else
              {
                uint64_t v13 = 561211770;
                if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                  sub_6A3E0();
                }
              }
            }
            else
            {
              uint64_t v13 = 1937010544;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6A3AC();
              }
            }
            return v13;
          }
          goto LABEL_118;
        }
        if (v12 == 1935763060)
        {
          if (a6 <= 3)
          {
            uint64_t v13 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A2A8();
            }
            return v13;
          }
LABEL_117:
          uint64_t v13 = 0;
          *(_DWORD *)a8 = 0;
LABEL_144:
          unsigned int v19 = 4;
          goto LABEL_145;
        }
        int v14 = 1936092276;
        goto LABEL_26;
      }
      if (v12 <= 1953653101)
      {
        if (v12 == 1937007734)
        {
          if (a6 <= 3)
          {
            uint64_t v13 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A108();
            }
            return v13;
          }
          uint64_t v13 = 0;
          *(_DWORD *)a8 = (*(uint64_t (**)(uint64_t))(*(void *)qword_A2350 + 16))(qword_A2350);
          goto LABEL_144;
        }
        if (v12 != 1937009955) {
          goto LABEL_118;
        }
        (*(void (**)(void *, void, uint64_t, void))(*a1 + 1512))(a1, a2[1], a8, a6 >> 2);
        goto LABEL_109;
      }
      if (v12 == 1953653102)
      {
        if (a6 <= 3)
        {
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A20C();
          }
          return v13;
        }
        uint64_t v13 = 0;
        int v18 = 1651275109;
        goto LABEL_143;
      }
      if (v12 != 1969841184) {
        goto LABEL_118;
      }
      if (a6 <= 3)
      {
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A1D8();
        }
        return v13;
      }
      unint64_t v27 = (const void *)a1[1135];
      uint64_t v28 = v27;
    }
    else
    {
      if (v12 > 1853059699)
      {
        if (v12 <= 1886807153)
        {
          if (v12 != 1853059700)
          {
            if (v12 != 1870098020) {
              goto LABEL_118;
            }
            sub_4EC10((uint64_t)a1, a2[1], a8, a6 >> 2);
            goto LABEL_109;
          }
          if (a6 <= 7)
          {
            uint64_t v13 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A240();
            }
            return v13;
          }
          *(void *)a8 = 0;
          uint64_t v29 = a1[1140];
          if (v29) {
            *(double *)a8 = (*(double (**)(uint64_t))(*(void *)v29 + 784))(v29);
          }
          uint64_t v13 = 0;
          goto LABEL_138;
        }
        if (v12 == 1886807154)
        {
          uint64_t v13 = 0;
          int v18 = *(unsigned __int8 *)(a1[1156] + 249);
          goto LABEL_143;
        }
        if (v12 != 1919512167) {
          goto LABEL_118;
        }
        if (a6 <= 3)
        {
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A274();
          }
          return v13;
        }
        *(_DWORD *)a8 = 0;
        uint64_t v26 = a1[1140];
        if (v26)
        {
          int v25 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 808))(v26);
          goto LABEL_126;
        }
LABEL_127:
        uint64_t v13 = 0;
        goto LABEL_144;
      }
      if (v12 > 1836411235)
      {
        if (v12 != 1836411236)
        {
          if (v12 != 1853059619) {
            goto LABEL_118;
          }
          uint64_t v13 = 0;
          unsigned int v19 = 16 * (*(uint64_t (**)(void *, uint64_t, void))(*a1 + 1232))(a1, a8, a6 >> 4);
LABEL_145:
          *a7 = v19;
          return v13;
        }
        id v23 = [+[NSString stringWithFormat:@"%x %x", *(unsigned int *)(a1[1156] + 48), *(unsigned int *)(a1[1156] + 56)] copy];
        goto LABEL_106;
      }
      if (v12 != 1819173229)
      {
        if (v12 != 1819569763) {
          goto LABEL_118;
        }
        if (a6 <= 3)
        {
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A2DC();
          }
          return v13;
        }
        *(_DWORD *)a8 = 0;
        uint64_t v24 = a1[1140];
        if (v24)
        {
          int v25 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 816))(v24);
LABEL_126:
          *(_DWORD *)a8 = v25;
          goto LABEL_127;
        }
        goto LABEL_127;
      }
      if (a6 <= 3)
      {
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A13C();
        }
        return v13;
      }
      if (!sub_245C8(a1[1156])) {
        return 0;
      }
      uint64_t v28 = (const void *)sub_245C8(a1[1156]);
      unint64_t v27 = v28;
    }
    CFRetain(v28);
    uint64_t v13 = 0;
    *(void *)a8 = v27;
    goto LABEL_138;
  }
  if (v12 > 1684236337)
  {
    if (v12 > 1735221621)
    {
      if (v12 <= 1751737453)
      {
        if (v12 == 1735221622)
        {
          uint64_t v13 = 0;
          int v18 = *(unsigned __int8 *)(a1[1156] + 221);
          goto LABEL_143;
        }
        if (v12 == 1751213427)
        {
          uint64_t v13 = 0;
          int v18 = *(unsigned __int8 *)(a1[1156] + 332);
          goto LABEL_143;
        }
        goto LABEL_118;
      }
      if (v12 == 1751737454)
      {
        if (a6 <= 3)
        {
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A344();
          }
          return v13;
        }
        uint64_t v13 = 0;
        int v18 = *(unsigned __int8 *)(a1[1156] + 326);
        goto LABEL_143;
      }
      if (v12 != 1819107691) {
        goto LABEL_118;
      }
      if (a6 <= 7)
      {
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A1A4();
        }
        return v13;
      }
      uint64_t v13 = 0;
      *(void *)a8 = @"Apple Inc.";
      goto LABEL_138;
    }
    if (v12 <= 1685278577)
    {
      if (v12 != 1684236338)
      {
        int v14 = 1684434036;
LABEL_26:
        if (v12 != v14) {
          goto LABEL_118;
        }
        if (a6 <= 3)
        {
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A310();
          }
          return v13;
        }
LABEL_59:
        uint64_t v13 = 0;
        int v18 = 1;
        goto LABEL_143;
      }
      if (a6 <= 7)
      {
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A378();
        }
        return v13;
      }
      uint64_t v13 = 0;
      *(void *)a8 = 0x200000001;
LABEL_138:
      unsigned int v19 = 8;
      goto LABEL_145;
    }
    if (v12 != 1685278578)
    {
      if (v12 != 1718772584) {
        goto LABEL_118;
      }
      goto LABEL_59;
    }
    id v23 = (id)sub_24F50(a1[1156]);
LABEL_106:
    uint64_t v13 = 0;
    *(void *)a8 = v23;
    goto LABEL_138;
  }
  if (v12 <= 1668050794)
  {
    if (v12 <= 1668047218)
    {
      if (v12 != 1635087471)
      {
        if (v12 == 1650682995)
        {
          if (a6 <= 3)
          {
            uint64_t v13 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A0A0();
            }
            return v13;
          }
          uint64_t v13 = 0;
          int v18 = 1634689642;
          goto LABEL_143;
        }
        goto LABEL_118;
      }
      uint64_t v13 = 0;
      int v18 = *(unsigned __int8 *)(a1[1156] + 325);
LABEL_143:
      *(_DWORD *)a8 = v18;
      goto LABEL_144;
    }
    if (v12 == 1668047219)
    {
      if (a6 <= 3)
      {
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A0D4();
        }
        return v13;
      }
      uint64_t v13 = 0;
      int v18 = 1633969526;
      goto LABEL_143;
    }
    if (v12 == 1668049764)
    {
      if (a6 <= 3)
      {
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A170();
        }
        return v13;
      }
      goto LABEL_117;
    }
LABEL_118:
    return sub_4ED00((uint64_t)a1, a2, a4, a5, a6, a7, a8);
  }
  if (v12 > 1668575851)
  {
    if (v12 != 1668575852)
    {
      if (v12 != 1668641652) {
        goto LABEL_118;
      }
      LODWORD(v33) = a6 / 0xC;
      (*(void (**)(void *, uint64_t, long long *))(*a1 + 1568))(a1, a8, &v33);
      uint64_t v13 = 0;
      unsigned int v19 = 12 * v33;
      goto LABEL_145;
    }
    sub_4EB20((uint64_t)a1, a2[1], a8, a6 >> 2);
LABEL_109:
    uint64_t v13 = 0;
    unsigned int v19 = a6 & 0xFFFFFFFC;
    goto LABEL_145;
  }
  if (v12 != 1668050795 && v12 != 1668510818) {
    goto LABEL_118;
  }
  uint64_t v15 = a1[1140];
  if (!v15) {
    return 0;
  }
  uint64_t v16 = *(uint64_t (**)(void))(*(void *)v15 + 48);

  return v16();
}

CFIndex sub_4EB20(uint64_t a1, int a2, uint64_t a3, unsigned int a4)
{
  int Count = a4;
  switch(a2)
  {
    case 1869968496:
      uint64_t v6 = 9208;
      goto LABEL_7;
    case 1768845428:
      uint64_t v6 = 9184;
      goto LABEL_7;
    case 1735159650:
      uint64_t v6 = 9232;
LABEL_7:
      CFArrayRef v7 = *(const __CFArray **)(a1 + v6);
      goto LABEL_9;
  }
  CFArrayRef v7 = 0;
LABEL_9:
  if (CFArrayGetCount(v7) < a4) {
    int Count = CFArrayGetCount(v7);
  }
  if (Count)
  {
    for (CFIndex i = 0;
          i != Count;
          *(_DWORD *)(a3 + 4 * i++) = (*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 16))(ValueAtIndex))
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
    }
  }
  return CFArrayGetCount(v7);
}

CFIndex sub_4EC10(uint64_t a1, int a2, uint64_t a3, unsigned int a4)
{
  int Count = a4;
  switch(a2)
  {
    case 1869968496:
      uint64_t v6 = 9216;
      goto LABEL_7;
    case 1768845428:
      uint64_t v6 = 9192;
      goto LABEL_7;
    case 1735159650:
      uint64_t v6 = 9240;
LABEL_7:
      CFArrayRef v7 = *(const __CFArray **)(a1 + v6);
      goto LABEL_9;
  }
  CFArrayRef v7 = 0;
LABEL_9:
  if (CFArrayGetCount(v7) < a4) {
    int Count = CFArrayGetCount(v7);
  }
  if (Count)
  {
    for (CFIndex i = 0;
          i != Count;
          *(_DWORD *)(a3 + 4 * i++) = (*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 16))(ValueAtIndex))
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
    }
  }
  return CFArrayGetCount(v7);
}

uint64_t sub_4ED00(uint64_t a1, int *a2, uint64_t a3, void **a4, unsigned int a5, int *a6, uint64_t a7)
{
  uint64_t v10 = 0;
  int v11 = *a2;
  if (*a2 <= 1768382831)
  {
    if (v11 > 1684434284)
    {
      if (v11 <= 1701408626)
      {
        if (v11 <= 1685026402)
        {
          if (v11 > 1685021039)
          {
            if (v11 == 1685021040)
            {
              if (a5 <= 3)
              {
                uint64_t v10 = 561211770;
                if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                  sub_6A4B0();
                }
                return v10;
              }
              uint64_t v10 = 0;
              int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 200);
              goto LABEL_378;
            }
            if (v11 != 1685025637) {
              return v10;
            }
            if (a5 <= 3)
            {
              uint64_t v10 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6A754();
              }
              return v10;
            }
            uint64_t v10 = 0;
            float v29 = *(float *)(*(void *)(a1 + 9248) + 280);
LABEL_312:
            *(float *)a7 = v29;
            goto LABEL_379;
          }
          if (v11 == 1684434285)
          {
            if (a5 <= 3)
            {
              uint64_t v10 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6A650();
              }
              return v10;
            }
            uint64_t v10 = 0;
            int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 184);
            goto LABEL_378;
          }
          int v14 = 1684826732;
          goto LABEL_179;
        }
        if (v11 > 1685283694)
        {
          if (v11 == 1685283695 || v11 == 1685484390) {
            goto LABEL_180;
          }
          int v14 = 1701015154;
          goto LABEL_179;
        }
        if (v11 == 1685026403)
        {
          if (a5 <= 7)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A7BC();
            }
            return v10;
          }
          int v12 = *(const void **)(*(void *)(a1 + 9248) + 288);
          if (!v12) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }
        if (v11 != 1685088612) {
          return v10;
        }
        if (a5 <= 7)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A720();
          }
          return v10;
        }
        CFDictionaryRef v13 = (CFDictionaryRef)objc_msgSend(objc_msgSend(*(id *)(*(void *)(a1 + 9248) + 208), "UUIDString", a3, a3, a4), "copy");
LABEL_310:
        uint64_t v10 = 0;
        *(void *)a7 = v13;
        goto LABEL_374;
      }
      if (v11 > 1767994226)
      {
        if (v11 <= 1768256353)
        {
          if (v11 == 1767994227)
          {
            if (a5 <= 3)
            {
              uint64_t v10 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6A8C0();
              }
              return v10;
            }
            uint64_t v10 = 0;
            int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 255);
          }
          else
          {
            if (v11 != 1768252517) {
              return v10;
            }
            if (a5 <= 3)
            {
              uint64_t v10 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6A448();
              }
              return v10;
            }
            uint64_t v10 = 0;
            int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 157);
          }
          goto LABEL_378;
        }
        if (v11 != 1768256354)
        {
          if (v11 == 1768256368)
          {
            if (a5 <= 3)
            {
              uint64_t v10 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6A580();
              }
              return v10;
            }
            uint64_t v10 = 0;
            int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 172);
          }
          else
          {
            if (v11 != 1768256371) {
              return v10;
            }
            if (a5 <= 3)
            {
              uint64_t v10 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6A5E8();
              }
              return v10;
            }
            uint64_t v10 = 0;
            int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 176);
          }
          goto LABEL_378;
        }
        if (a5 <= 7)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A5B4();
          }
          return v10;
        }
        uint64_t v10 = 0;
        *(void *)a7 = *(void *)(*(void *)(a1 + 9248) + 172);
        goto LABEL_374;
      }
      if (v11 <= 1752327776)
      {
        if (v11 != 1701408627)
        {
          if (v11 != 1702391923) {
            return v10;
          }
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6AA60();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 272);
          goto LABEL_378;
        }
        uint64_t v10 = 561211770;
        if (a5 != 4) {
          return v10;
        }
        uint64_t v26 = *(void *)(a1 + 9096);
        if (!v26) {
          return v10;
        }
        uint64_t v10 = 0;
        uint64_t v27 = 9017;
        goto LABEL_338;
      }
      switch(v11)
      {
        case 1752327777:
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6AAC8();
            }
            return v10;
          }
          uint64_t v31 = *(void *)(a1 + 9248);
          if (*(unsigned char *)(v31 + 238))
          {
            if (*(unsigned char *)(v31 + 239)) {
              int v32 = 2;
            }
            else {
              int v32 = 1;
            }
          }
          else
          {
            int v32 = 0;
          }
          uint64_t v10 = 0;
          if ((*(unsigned int (**)(uint64_t))(*(void *)a1 + 296))(a1)) {
            int v15 = 0;
          }
          else {
            int v15 = v32;
          }
          break;
        case 1752462195:
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6ADD4();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 129);
          break;
        case 1767989616:
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A788();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 144);
          break;
        default:
          return v10;
      }
    }
    else
    {
      if (v11 > 1651271024)
      {
        if (v11 <= 1651798131)
        {
          if (v11 <= 1651466851)
          {
            if (v11 == 1651271025)
            {
              if (a5 <= 3)
              {
                uint64_t v10 = 561211770;
                if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                  sub_6AE3C();
                }
                return v10;
              }
              uint64_t v10 = 0;
              int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 218);
            }
            else
            {
              if (v11 != 1651466595) {
                return v10;
              }
              if (a5 <= 3)
              {
                uint64_t v10 = 561211770;
                if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                  sub_6AD38();
                }
                return v10;
              }
              uint64_t v10 = 0;
              int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 145);
            }
            goto LABEL_378;
          }
          if (v11 == 1651466852)
          {
            int v23 = *(_DWORD *)(a1 + 9472);
            *(_DWORD *)a7 = v23 == 2;
            uint64_t v24 = qword_A1B50;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
            {
              BOOL v25 = *(unsigned char *)(a1 + 9441) == 0;
              *(_DWORD *)std::string buf = 67109376;
              BOOL v42 = v25;
              __int16 v43 = 1024;
              int v44 = v23;
              _os_log_impl(&dword_0, v24, OS_LOG_TYPE_DEFAULT, "Get kBluetoothAudioDevicePropertyOutOfBandBiDirectionalAudio: Transport Update Completed %d, Out of Band Audio State %d", buf, 0xEu);
            }
            goto LABEL_305;
          }
          if (v11 == 1651728749) {
            goto LABEL_180;
          }
          if (v11 != 1651795822) {
            return v10;
          }
          int v12 = *(const void **)(*(void *)(a1 + 9248) + 592);
          if (!v12) {
            goto LABEL_21;
          }
LABEL_20:
          CFRetain(v12);
LABEL_21:
          uint64_t v10 = 0;
          *(void *)a7 = v12;
          goto LABEL_374;
        }
        if (v11 > 1668051826)
        {
          if (v11 == 1668051827)
          {
            if (a5 <= 3)
            {
              uint64_t v10 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6AA94();
              }
              return v10;
            }
            uint64_t v10 = 0;
            int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 273);
            goto LABEL_378;
          }
          if (v11 == 1668506479) {
            goto LABEL_180;
          }
          if (v11 != 1684234612) {
            return v10;
          }
          LODWORD(v16) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 824))(a1);
          goto LABEL_316;
        }
        if (v11 == 1651798132) {
          goto LABEL_180;
        }
        if (v11 != 1651798886) {
          return v10;
        }
        if (a5 <= 7)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6AE08();
          }
          return v10;
        }
        CFDictionaryRef v13 = sub_2D578(*(void *)(a1 + 9248));
        goto LABEL_310;
      }
      if (v11 <= 1635148655)
      {
        if (v11 > 1635017331)
        {
          if (v11 == 1635017332)
          {
            if (a5 <= 3)
            {
              uint64_t v10 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6ADA0();
              }
              return v10;
            }
            uint64_t v10 = 0;
            int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 344);
            goto LABEL_378;
          }
          if (v11 != 1635148144) {
            return v10;
          }
          if (a5 <= 7)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A684();
            }
            return v10;
          }
          CFDictionaryRef v13 = sub_4B28C(a1);
          goto LABEL_310;
        }
        if (v11 != 1633972065)
        {
          if (v11 != 1633973868) {
            return v10;
          }
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A990();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 229) == 1;
          goto LABEL_378;
        }
        goto LABEL_180;
      }
      if (v11 <= 1650551139)
      {
        if (v11 == 1635148656)
        {
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A6B8();
            }
            return v10;
          }
          if (sub_5758C(a1, (int *)a7)) {
            uint64_t v10 = 0;
          }
          else {
            uint64_t v10 = 2003329396;
          }
          goto LABEL_379;
        }
        int v14 = 1650549620;
        goto LABEL_179;
      }
      if (v11 == 1650551140)
      {
        if (a5 > 3)
        {
          uint64_t v10 = 0;
          int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 48);
          goto LABEL_378;
        }
        uint64_t v10 = 561211770;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          return v10;
        }
        goto LABEL_132;
      }
      if (v11 == 1650750320) {
        goto LABEL_180;
      }
      if (v11 != 1650750576) {
        return v10;
      }
      if (a5 <= 3)
      {
        uint64_t v10 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A414();
        }
        return v10;
      }
      uint64_t v10 = 0;
      int v15 = *(_DWORD *)(a1 + 368);
    }
LABEL_378:
    *(_DWORD *)a7 = v15;
    goto LABEL_379;
  }
  if (v11 <= 1936746610)
  {
    if (v11 > 1935959403)
    {
      if (v11 <= 1936744821)
      {
        if (v11 <= 1936221549)
        {
          if (v11 == 1935959404) {
            goto LABEL_180;
          }
          if (v11 != 1936220524) {
            return v10;
          }
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6ABCC();
            }
            return v10;
          }
          LODWORD(v16) = sub_576D0(a1);
        }
        else
        {
          if (v11 != 1936221550)
          {
            if (v11 == 1936225136)
            {
              if (a5 <= 3)
              {
                uint64_t v10 = 561211770;
                if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                  sub_6AB64();
                }
                return v10;
              }
              uint64_t v10 = 0;
              int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 244) != 0;
            }
            else
            {
              if (v11 != 1936744816) {
                return v10;
              }
              if (a5 <= 3)
              {
                uint64_t v10 = 561211770;
                if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                  sub_6A7F0();
                }
                return v10;
              }
              uint64_t v10 = 0;
              int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 230);
            }
            goto LABEL_378;
          }
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6AB98();
            }
            return v10;
          }
          uint64_t v16 = *(void *)(a1 + 9096);
          if (v16) {
            LODWORD(v16) = sub_39F18(v16);
          }
        }
LABEL_316:
        uint64_t v10 = 0;
        *(_DWORD *)a7 = v16;
        goto LABEL_379;
      }
      if (v11 > 1936745330)
      {
        if (v11 == 1936745331)
        {
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A8F4();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 252);
          goto LABEL_378;
        }
        if (v11 == 1936745838)
        {
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A824();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 232);
          goto LABEL_378;
        }
        if (v11 != 1936746089) {
          return v10;
        }
        if (a5 <= 3)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A9F8();
          }
          return v10;
        }
        LODWORD(v16) = sub_2D524(*(void *)(a1 + 9248));
        goto LABEL_316;
      }
      if (v11 == 1936744822)
      {
        if (a5 <= 3)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A858();
          }
          return v10;
        }
        uint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 251);
        goto LABEL_378;
      }
      if (v11 != 1936745318) {
        return v10;
      }
      if (a5 != 4 && a5 != 8)
      {
        uint64_t v10 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6AA2C();
        }
        return v10;
      }
      char v40 = 1;
      *(_DWORD *)std::string buf = 1;
      if (a4)
      {
        if (*a4) {
          sub_2B3A0(*(void *)(a1 + 9248), *a4, buf, (BOOL *)&v40);
        }
      }
      else
      {
        long long v34 = +[BTAudioAVNotificationMonitor sharedInstance];
        if (v34)
        {
          id v35 = [(NSString *)[(BTAudioAVNotificationMonitor *)v34 nowPlayingBundleID] copy];
          if (v35) {
            sub_2B3A0(*(void *)(a1 + 9248), v35, buf, (BOOL *)&v40);
          }
        }
        else
        {
          id v35 = 0;
        }
      }
      int v38 = *(_DWORD *)buf;
      char v39 = v40;
      if (v40) {
        char v39 = sub_395B4() ^ 1;
      }
      uint64_t v10 = 0;
      *(unsigned char *)(a7 + 4) = v39;
      *(_DWORD *)a7 = v38;
LABEL_374:
      int v22 = 8;
      goto LABEL_380;
    }
    if (v11 <= 1819503986)
    {
      if (v11 > 1819046767)
      {
        if (v11 == 1819046768)
        {
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6AD6C();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 278);
          goto LABEL_378;
        }
        int v14 = 1819241569;
      }
      else
      {
        if (v11 == 1768382832)
        {
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A95C();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 584);
          goto LABEL_378;
        }
        int v14 = 1818326127;
      }
    }
    else
    {
      if (v11 <= 1852992612)
      {
        if (v11 == 1819503987)
        {
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A518();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 160);
        }
        else
        {
          if (v11 != 1819505773) {
            return v10;
          }
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6A54C();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 164);
        }
        goto LABEL_378;
      }
      if (v11 == 1852992613) {
        goto LABEL_180;
      }
      if (v11 == 1886546291)
      {
        if (a5 <= 3)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A61C();
          }
          return v10;
        }
        uint64_t v10 = 0;
        int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 180);
        goto LABEL_378;
      }
      int v14 = 1935896430;
    }
LABEL_179:
    if (v11 != v14) {
      return v10;
    }
    goto LABEL_180;
  }
  if (v11 <= 1986225517)
  {
    if (v11 <= 1936749429)
    {
      if (v11 > 1936748130)
      {
        if (v11 != 1936748131)
        {
          if (v11 != 1936749417)
          {
            if (v11 == 1936749427)
            {
              if (a5 <= 3)
              {
                uint64_t v10 = 561211770;
                if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                  sub_6A928();
                }
                return v10;
              }
              uint64_t v10 = 0;
              int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 253);
              goto LABEL_378;
            }
            return v10;
          }
          uint64_t v10 = 0;
          uint64_t v20 = *(void *)(a1 + 9248);
          uint64_t v21 = *(void *)(v20 + 352);
          LODWORD(v20) = *(_DWORD *)(v20 + 360);
          *(void *)a7 = v21;
          *(_DWORD *)(a7 + 8) = v20;
          int v22 = 12;
LABEL_380:
          *a6 = v22;
          return v10;
        }
        if (a5 <= 3)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6A9C4();
          }
          return v10;
        }
        LODWORD(v16) = sub_2D4E0(*(unsigned __int8 **)(a1 + 9248));
        goto LABEL_316;
      }
      if (v11 != 1936746611)
      {
        if (v11 != 1936747876) {
          return v10;
        }
        if (a5 != 4 && a5 != 8)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6AAFC();
          }
          return v10;
        }
        *(_DWORD *)std::string buf = 1;
        char v40 = 1;
        if (*(void *)(a1 + 9256) == 1953719151)
        {
          *(_DWORD *)std::string buf = 0;
        }
        else if (a4)
        {
          if (*a4) {
            sub_2B3A0(*(void *)(a1 + 9248), *a4, buf, (BOOL *)&v40);
          }
        }
        else
        {
          int v36 = +[BTAudioAVNotificationMonitor sharedInstance];
          if (v36)
          {
            id v37 = [(NSString *)[(BTAudioAVNotificationMonitor *)v36 nowPlayingBundleID] copy];
            if (v37) {
              sub_2B3A0(*(void *)(a1 + 9248), v37, buf, (BOOL *)&v40);
            }
          }
          else
          {
            id v37 = 0;
          }
        }
        uint64_t v10 = 0;
        int v15 = *(_DWORD *)buf;
        goto LABEL_378;
      }
      if (a5 <= 3)
      {
        uint64_t v10 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6AB30();
        }
        return v10;
      }
      int v33 = sub_395B4();
      uint64_t v10 = 0;
      uint64_t v26 = *(void *)(a1 + 9248);
      uint64_t v27 = 230;
      if (v33) {
        uint64_t v27 = 236;
      }
LABEL_338:
      int v15 = *(unsigned __int8 *)(v26 + v27);
      goto LABEL_378;
    }
    if (v11 > 1937204589)
    {
      switch(v11)
      {
        case 1937204590:
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6AC34();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 275);
          break;
        case 1937208176:
          if (a5 <= 3)
          {
            uint64_t v10 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6AC00();
            }
            return v10;
          }
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 274);
          break;
        case 1970496630:
          uint64_t v10 = 0;
          int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 324);
          break;
        default:
          return v10;
      }
      goto LABEL_378;
    }
    if (v11 == 1936749430)
    {
      if (a5 <= 3)
      {
        uint64_t v10 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A88C();
        }
        return v10;
      }
      uint64_t v10 = 0;
      int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 254);
      goto LABEL_378;
    }
    if (v11 != 1937138786) {
      return v10;
    }
    if (a5 <= 3)
    {
      uint64_t v10 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6A6EC();
      }
      return v10;
    }
    uint64_t v30 = *(void *)(a1 + 9120);
    if (v30) {
      *(float *)a7 = (*(float (**)(uint64_t))(*(void *)v30 + 936))(v30);
    }
    goto LABEL_305;
  }
  if (v11 > 2004050293)
  {
    if (v11 <= 2004051821)
    {
      if (v11 != 2004050294)
      {
        if (v11 != 2004051812) {
          return v10;
        }
        if (a5 <= 3)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6AC9C();
          }
          return v10;
        }
        uint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 329);
        goto LABEL_378;
      }
    }
    else
    {
      if (v11 == 2004051822)
      {
        if (a5 <= 3)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6ACD0();
          }
          return v10;
        }
        uint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 330);
        goto LABEL_378;
      }
      if (v11 != 2004053366)
      {
        if (v11 != 2004054901) {
          return v10;
        }
        if (a5 <= 3)
        {
          uint64_t v10 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6AC68();
          }
          return v10;
        }
        uint64_t v10 = 0;
        int v15 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 327);
        goto LABEL_378;
      }
    }
    if (a5 <= 3)
    {
      uint64_t v10 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6AD04();
      }
      return v10;
    }
    float v29 = sub_44398(qword_A2350);
    uint64_t v10 = 0;
    goto LABEL_312;
  }
  if (v11 <= 1987080037)
  {
    if (v11 != 1986225518)
    {
      if (v11 != 1986947428) {
        return v10;
      }
      if (a5 > 3)
      {
        uint64_t v10 = 0;
        int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 56);
        goto LABEL_378;
      }
      uint64_t v10 = 561211770;
      if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        return v10;
      }
LABEL_132:
      sub_6A47C();
      return v10;
    }
    *(_DWORD *)a7 = 1;
    uint64_t v28 = *(void *)(a1 + 9120);
    if (v28) {
      *(_DWORD *)a7 = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 1464))(v28);
    }
LABEL_305:
    uint64_t v10 = 0;
LABEL_379:
    int v22 = 4;
    goto LABEL_380;
  }
  if (v11 != 1987080038)
  {
    if (v11 == 2003394928)
    {
      if (a5 <= 3)
      {
        uint64_t v10 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6A4E4();
        }
        return v10;
      }
      uint64_t v10 = 0;
      int v15 = *(_DWORD *)(*(void *)(a1 + 9248) + 148);
      goto LABEL_378;
    }
    if (v11 != 2004050279) {
      return v10;
    }
    CFDictionaryRef v13 = sub_44308(qword_A2350);
    goto LABEL_310;
  }
LABEL_180:
  uint64_t v17 = *(void *)(a1 + 9120);
  if (!v17) {
    return 0;
  }
  int v18 = *(uint64_t (**)(void))(*(void *)v17 + 48);

  return v18();
}

void sub_505DC(uint64_t a1, uint64_t a2, char *a3, void *a4)
{
}

uint64_t sub_505E4(uint64_t a1, int a2, uint64_t a3)
{
  if (!a2) {
    return 1852797029;
  }
  int v3 = *(_DWORD *)(a1 + 8);
  BOOL v4 = *(NSObject **)(qword_A2350 + 168);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_50680;
  v6[3] = &unk_8FB70;
  int v7 = a2;
  int v8 = v3;
  v6[4] = a3;
  dispatch_async(v4, v6);
  return 0;
}

void sub_50680(uint64_t a1)
{
  uint64_t v2 = (int *)(a1 + 40);
  if (*(_DWORD *)(a1 + 40) && *(void *)(qword_A2350 + 144) && sub_41A14())
  {
    int v3 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      v4.i32[0] = *(_DWORD *)(a1 + 40);
      int16x8_t v5 = (int16x8_t)vmovl_u8(v4);
      *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
      unsigned __int32 v8 = vmovn_s16(v5).u32[0];
      char v9 = 0;
      int v6 = *(_DWORD *)(a1 + 44);
      *(_DWORD *)std::string buf = 136446466;
      int v11 = &v8;
      __int16 v12 = 1024;
      int v13 = v6;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice : Sending device config change for %{public}s on %d", buf, 0x12u);
    }
    (*(void (**)(void))(*(void *)(qword_A2350 + 144) + 32))();
  }
  else
  {
    int v7 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      sub_6AE70(v2, a1, v7);
    }
  }
}

uint64_t sub_507C8(void *a1, int *a2, uint64_t a3, unsigned int *a4, uint64_t a5, unsigned int *a6, uint64_t a7)
{
  int v7 = a7;
  int v9 = a5;
  int v12 = *a2;
  if (*a2 <= 1818326126)
  {
    if (v12 > 1651466851)
    {
      if (v12 <= 1701408626)
      {
        switch(v12)
        {
          case 1651466852:
            uint64_t v13 = 561211770;
            if (!a4 || a3 != 8 || a5 != 4) {
              return v13;
            }
            sub_52510((uint64_t)a1, a4);
            break;
          case 1651795567:
            break;
          case 1668051827:
            if (a5 > 3)
            {
              if (a1[1140])
              {
                int v61 = *a6;
                *(unsigned char *)(a1[1156] + 273) = *a6 != 0;
                int v62 = (unsigned char *)a1[1137];
                if (v62 && v62[192]) {
                  (*(void (**)(unsigned char *, BOOL))(*(void *)v62 + 592))(v62, v61 != 0);
                }
                return 0;
              }
              uint64_t v13 = 1937010544;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6B170();
              }
            }
            else
            {
              uint64_t v13 = 561211770;
              if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
                sub_6B13C();
              }
            }
            return v13;
          default:
            goto LABEL_118;
        }
        return 0;
      }
      if (v12 == 1701408627)
      {
        if (a5 != 4) {
          return 561211770;
        }
        uint64_t v30 = a1[1137];
        if (v30)
        {
          int v31 = *a6;
          int v32 = *a6 != 0;
          *(unsigned char *)(v30 + 9017) = v32;
          int v33 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = v31 != 0;
            _os_log_impl(&dword_0, v33, OS_LOG_TYPE_DEFAULT, "Set kBluetoothAudioDevicePropertyEmptyOutputStream %d", buf, 8u);
            int v32 = *(unsigned __int8 *)(a1[1137] + 9017);
          }
          if (!v32) {
            (*(void (**)(void *))(*a1 + 1456))(a1);
          }
        }
        return 0;
      }
      if (v12 != 1702391923)
      {
        if (v12 == 1752462195)
        {
          if (a5 > 3)
          {
            int v68 = *a6;
            uint64_t v69 = a1[1156];
            int v70 = *(unsigned __int8 *)(v69 + 129);
            *(unsigned char *)(v69 + 129) = *a6 != 0;
            uint64_t v71 = qword_A1B50;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v68 != 0;
              _os_log_impl(&dword_0, v71, OS_LOG_TYPE_DEFAULT, "BTHAL got kBluetoothAudioDevicePropertyShareplayScreenSharing: %u", buf, 8u);
            }
            if ((v68 != 0) != (v70 != 0))
            {
              sub_2B5E8(a1[1156]);
              sub_21EB8((void *)a1[1156], 0);
            }
            return 0;
          }
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6ADD4();
          }
          return v13;
        }
        goto LABEL_118;
      }
      if (a5 <= 3)
      {
        uint64_t v13 = 561211770;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          return v13;
        }
LABEL_109:
        sub_6B0A0();
        return v13;
      }
      if (a1[1140])
      {
        uint64_t v76 = a1[1156];
        int v77 = *(unsigned __int8 *)(v76 + 272);
        int v78 = *a6;
        *(unsigned char *)(v76 + 272) = *a6 != 0;
        int v79 = qword_A1B50;
        uint64_t v13 = 0;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
          return v13;
        }
        __int16 v80 = "YES";
        if (v77) {
          int v81 = "YES";
        }
        else {
          int v81 = "NO";
        }
        *(_DWORD *)std::string buf = 67109634;
        *(_DWORD *)&uint8_t buf[4] = v78 != 0;
        *(_WORD *)&uint8_t buf[8] = 2080;
        *(void *)&buf[10] = v81;
        if (!v78) {
          __int16 v80 = "NO";
        }
        *(_WORD *)&unsigned char buf[18] = 2080;
        *(void *)&buf[20] = v80;
        _os_log_impl(&dword_0, v79, OS_LOG_TYPE_DEFAULT, "Expanse Session %d  %s -> %s", buf, 0x1Cu);
        return 0;
      }
      uint64_t v13 = 1937010544;
      if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        return v13;
      }
LABEL_199:
      sub_6B108();
      return v13;
    }
    if (v12 > 1635149169)
    {
      if (v12 == 1635149170)
      {
        int v25 = _os_feature_enabled_impl();
        uint64_t v13 = 0;
        if (v9 != 24 || !v25) {
          return v13;
        }
        if (*(unsigned char *)(a1[1156] + 228))
        {
          uint64_t v26 = (unsigned char *)a1[1136];
          if (v26)
          {
            if (v26[192])
            {
              float v27 = *(float *)a6;
              uint64_t v28 = *((void *)a6 + 1);
              uint64_t v29 = *((unsigned __int16 *)a6 + 8);
              (*(void (**)(unsigned char *, uint64_t, uint64_t, float))(*(void *)v26 + 616))(v26, v28, v29, v27);
              sub_52294(a1, v28, v29, v27);
            }
          }
        }
        return 0;
      }
      if (v12 != 1650549620)
      {
        if (v12 != 1651466595) {
          goto LABEL_118;
        }
        int v23 = qword_A1B50;
        if (a5 <= 3)
        {
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6AF68();
          }
          return v13;
        }
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          int v63 = *a6;
          *(_DWORD *)std::string buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v63;
          _os_log_impl(&dword_0, v23, OS_LOG_TYPE_DEFAULT, "Ownership Set as %d", buf, 8u);
        }
        if (!*a6)
        {
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6AF9C();
          }
          return 0;
        }
        if (*(unsigned char *)(a1[1156] + 348))
        {
          uint64_t v64 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_0, v64, OS_LOG_TYPE_DEFAULT, "Tipi connection posting ownership", buf, 2u);
          }
          notify_post("com.apple.BluetoothServices.AudioRoutingOwnershipTaken");
          uint64_t v65 = (void *)qword_A2350;
          (*(void (**)(void *__return_ptr, void *))(*a1 + 832))(v106, a1);
          sub_41F58(v65, (uint64_t)v106, 1, 0, 0);
          if ((v107 & 0x80000000) == 0) {
            return 0;
          }
          uint64_t v66 = (void *)v106[0];
        }
        else
        {
          uint64_t v95 = qword_A2350;
          (*(void (**)(void **__return_ptr, void *))(*a1 + 832))(__p, a1);
          sub_42768(v95, __p);
          if ((v105 & 0x80000000) == 0) {
            return 0;
          }
          uint64_t v66 = __p[0];
        }
        operator delete(v66);
        return 0;
      }
      goto LABEL_52;
    }
    if (v12 == 1633972065) {
      goto LABEL_52;
    }
    if (v12 == 1635017332)
    {
      if (a5 > 3)
      {
        if (a1[1137])
        {
          sub_280B0(a1[1156], *a6);
          uint64_t v73 = a1[1137];
          if (v73)
          {
            int v74 = qword_A1B50;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
            {
              int v75 = *(_DWORD *)(a1[1156] + 344);
              *(_DWORD *)std::string buf = 67109120;
              *(_DWORD *)&uint8_t buf[4] = v75;
              _os_log_impl(&dword_0, v74, OS_LOG_TYPE_DEFAULT, "HFP Setting allow sco for turn by turn %d", buf, 8u);
              uint64_t v73 = a1[1137];
            }
            (*(void (**)(uint64_t, BOOL))(*(void *)v73 + 1440))(v73, *(_DWORD *)(a1[1156] + 344) != 0);
          }
          return 0;
        }
        uint64_t v13 = 1937010544;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B274();
        }
      }
      else
      {
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B240();
        }
      }
      return v13;
    }
    if (v12 != 1635148656) {
      goto LABEL_118;
    }
    if (a5 <= 3)
    {
      uint64_t v13 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6B06C();
      }
      return v13;
    }
    uint64_t v56 = *a6;
    uint64_t v57 = *a4;
    if (*(unsigned char *)(a1[1156] + 222))
    {
      unsigned int v58 = 1;
      if (v57 == 1919183219 || a1[1158] == 1919183219) {
        goto LABEL_224;
      }
      uint64_t v59 = 1952539500;
      if (v56 == 1953719151)
      {
        int v60 = 3;
LABEL_221:
        if (a1[1157] == v59) {
          unsigned int v58 = v60;
        }
        else {
          unsigned int v58 = 0;
        }
        goto LABEL_224;
      }
      if (v56 == 1952539500)
      {
        int v60 = 2;
        uint64_t v59 = 1953719151;
        goto LABEL_221;
      }
    }
    unsigned int v58 = 0;
LABEL_224:
    if (sub_51D80((uint64_t)a1, v56, v57, v58)) {
      return 0;
    }
    else {
      return 2003329396;
    }
  }
  if (v12 <= 1936745837)
  {
    if (v12 > 1853059699)
    {
      if (v12 == 1853059700)
      {
        if (a5 == 8)
        {
          uint64_t v34 = a1[1140];
          if (v34)
          {
            double v35 = (*(double (**)(uint64_t))(*(void *)v34 + 784))(v34);
            double v36 = *(double *)a6;
            id v37 = qword_A1B50;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)std::string buf = 134218240;
              *(double *)&uint8_t buf[4] = v35;
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(double *)&buf[14] = v36;
              _os_log_impl(&dword_0, v37, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: Setting sample rate %f -> %f ", buf, 0x16u);
            }
            if (v35 != v36) {
              (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 240))(a1, 1853059700, (uint64_t)v36);
            }
            return 0;
          }
          uint64_t v13 = 1937010544;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6AF00();
          }
        }
        else
        {
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6AF34();
          }
        }
        return v13;
      }
      if (v12 != 1935896430)
      {
        if (v12 == 1936745331)
        {
          if (a5 > 3)
          {
            uint64_t v67 = a1[1156];
            if (*(unsigned char *)(v67 + 230)) {
              sub_2C708((void *)v67, *a6 != 0, 1);
            }
            return 0;
          }
          uint64_t v13 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B1D8();
          }
          return v13;
        }
        goto LABEL_118;
      }
    }
    else if (v12 != 1818326127)
    {
      if (v12 != 1819241569)
      {
        if (v12 == 1819505773)
        {
          uint64_t v14 = *a6;
          uint64_t v15 = a1[1156];
          BOOL v16 = *(unsigned char *)(v15 + 279) == 2 && v14 == 2;
          if (!v16
            || !*(unsigned char *)(v15 + 156)
            || !*(unsigned char *)(v15 + 157)
            || (int v17 = *(_DWORD *)(v15 + 172)) == 0 && !*(_DWORD *)(v15 + 176))
          {
            sub_24964(a1[1156], *a6);
            uint64_t v45 = a1[1140];
            if (v45) {
              (*(void (**)(uint64_t, uint64_t))(*(void *)v45 + 1432))(v45, v14);
            }
            return 0;
          }
          uint64_t v13 = 1852797029;
          uint64_t v18 = qword_A1B50;
          if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
            return v13;
          }
          int v19 = *(_DWORD *)(v15 + 176);
          *(_DWORD *)std::string buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v17;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v19;
          uint64_t v20 = "For in-ear support audio headsets, ANC mode cannot be enabled if both sides are not in-ear: primary bud "
                "= %u , secondary bud = %u";
          uint64_t v21 = v18;
          uint32_t v22 = 14;
LABEL_120:
          _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, v20, buf, v22);
          return v13;
        }
LABEL_118:
        uint64_t v13 = 2003332927;
        uint64_t v42 = qword_A1B50;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
          return v13;
        }
        v43.i32[0] = a2[1];
        int16x8_t v44 = (int16x8_t)vmovl_u8(v43);
        *(int16x4_t *)v44.i8 = vrev64_s16(*(int16x4_t *)v44.i8);
        unsigned __int32 v98 = vmovn_s16(v44).u32[0];
        char v99 = 0;
        v97[0] = HIBYTE(v12);
        v97[1] = BYTE2(v12);
        v97[2] = BYTE1(v12);
        v97[3] = v12;
        v97[4] = 0;
        *(_DWORD *)std::string buf = 136446466;
        *(void *)&uint8_t buf[4] = &v98;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v97;
        uint64_t v20 = "Unknown SetProperty for scope: %{public}s / element: %{public}s";
        uint64_t v21 = v42;
        uint32_t v22 = 22;
        goto LABEL_120;
      }
      uint64_t v24 = a1[1140];
      if (!v24)
      {
        uint64_t v13 = 1937010544;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          return v13;
        }
        goto LABEL_72;
      }
      goto LABEL_53;
    }
LABEL_52:
    uint64_t v24 = a1[1140];
    if (!v24)
    {
      uint64_t v13 = 1937010544;
      if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        return v13;
      }
LABEL_72:
      sub_6B2A8();
      return v13;
    }
LABEL_53:
    (*(void (**)(uint64_t, int *, uint64_t, unsigned int *, uint64_t, unsigned int *, uint64_t))(*(void *)v24 + 56))(v24, a2, a3, a4, a5, a6, a7);
    return 0;
  }
  if (v12 <= 1937204589)
  {
    if (v12 != 1936745838)
    {
      if (v12 == 1936749417)
      {
        if (a5 > 0xB)
        {
          *(void *)std::string buf = *(void *)a6;
          *(_DWORD *)&uint8_t buf[8] = a6[2];
          if (*(unsigned char *)(a1[1156] + 230) && sub_395B4())
          {
            unsigned int v93 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
            v100[0] = _NSConcreteStackBlock;
            v100[1] = 3221225472;
            v100[2] = sub_521E8;
            v100[3] = &unk_8FB70;
            unsigned int v101 = v93;
            uint64_t v102 = *(void *)buf;
            int v103 = *(_DWORD *)&buf[8];
            sub_44BA4(qword_A2350, v93, v100);
          }
          return 0;
        }
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B1A4();
        }
        return v13;
      }
      if (v12 == 1936749427)
      {
        if (a5 > 3)
        {
          uint64_t v72 = a1[1156];
          if (*(unsigned char *)(v72 + 230)) {
            sub_2CDD4((void *)v72, *a6 != 0, 1);
          }
          return 0;
        }
        uint64_t v13 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B20C();
        }
        return v13;
      }
      goto LABEL_118;
    }
    if (a5 <= 3)
    {
      uint64_t v13 = 561211770;
      if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        return v13;
      }
      goto LABEL_109;
    }
    if (a1[1140])
    {
      uint64_t v87 = a1[1156];
      if (*(unsigned char *)(v87 + 230))
      {
        int v88 = *a6;
        int v89 = *(_DWORD *)(v87 + 232);
        __int16 v90 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 67109632;
          *(_DWORD *)&uint8_t buf[4] = v7;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v89;
          *(_WORD *)&buf[14] = 1024;
          *(_DWORD *)&uint8_t buf[16] = v88;
          _os_log_impl(&dword_0, v90, OS_LOG_TYPE_DEFAULT, "[ %d ] SetProperty kBluetoothAudioDevicePropertySpatialAudioEnabled %u -> %u ", buf, 0x14u);
        }
        int v91 = sub_395B4();
        uint64_t v92 = a1[1156];
        if (v91)
        {
          sub_2B984(v92, v7, v88);
          int v88 = *(_DWORD *)(a1[1156] + 232);
        }
        else
        {
          *(_DWORD *)(v92 + 232) = v88;
        }
        if (v88)
        {
          (*(void (**)(void, uint64_t, uint64_t))(*(void *)a1[1140] + 568))(a1[1140], 1, 6);
        }
        else if ((v88 & 2) != 0)
        {
          (*(void (**)(void, uint64_t, uint64_t))(*(void *)a1[1140] + 568))(a1[1140], 1, 7);
        }
        else
        {
          if (v89) {
            (*(void (**)(void, void, uint64_t))(*(void *)a1[1140] + 568))(a1[1140], 0, 6);
          }
          if ((v89 & 2) != 0) {
            (*(void (**)(void, void, uint64_t))(*(void *)a1[1140] + 568))(a1[1140], 0, 7);
          }
        }
      }
      return 0;
    }
    uint64_t v13 = 1937010544;
    if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      return v13;
    }
    goto LABEL_199;
  }
  if (v12 > 2004050293)
  {
    if (v12 == 2004050294 || v12 == 2004053366)
    {
      if (a5 > 3)
      {
        float v38 = *(float *)a6;
        char v39 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          int v40 = (*(uint64_t (**)(void *))(*a1 + 296))(a1);
          uint64_t v41 = "No";
          if (v40) {
            uint64_t v41 = "Yes";
          }
          *(_DWORD *)std::string buf = 134218242;
          *(double *)&uint8_t buf[4] = v38;
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v41;
          _os_log_impl(&dword_0, v39, OS_LOG_TYPE_DEFAULT, " SetProperty Wireless Splitter Main Volume change request %f, Aggregate=%s", buf, 0x16u);
        }
        sub_44400((float *)qword_A2350, v38);
        return 0;
      }
      uint64_t v13 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6B038();
      }
      return v13;
    }
    goto LABEL_118;
  }
  if (v12 == 1937204590)
  {
    if (a5 <= 3)
    {
      uint64_t v13 = 561211770;
      if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        return v13;
      }
      goto LABEL_109;
    }
    uint64_t v13 = a1[1140];
    if (!v13)
    {
      uint64_t v13 = 1937010544;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6B0D4();
      }
      return v13;
    }
    uint64_t v82 = a1[1156];
    if (*(unsigned char *)(v82 + 274))
    {
      int v83 = *a6;
      __int16 v84 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        int v85 = " Yes";
        if (!v83) {
          int v85 = " No";
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v85;
        BOOL v86 = v83 != 0;
        _os_log_impl(&dword_0, v84, OS_LOG_TYPE_DEFAULT, " SetProperty kBluetoothAudioDevicePropertySoftwareVolumeEnabled %{public}s ", buf, 0xCu);
        uint64_t v13 = a1[1140];
        *(unsigned char *)(a1[1156] + 275) = v86;
        if (!v13) {
          return v13;
        }
      }
      else
      {
        BOOL v86 = v83 != 0;
        *(unsigned char *)(v82 + 275) = v86;
      }
      (*(void (**)(uint64_t, BOOL))(*(void *)v13 + 1200))(v13, v86);
    }
    return 0;
  }
  if (v12 != 2004050279) {
    goto LABEL_118;
  }
  if (a5 <= 7)
  {
    uint64_t v13 = 561211770;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      sub_6AFD0();
    }
    return v13;
  }
  if (a1[1140])
  {
    CFArrayRef v46 = *(const __CFArray **)a6;
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)a6);
    int v48 = qword_A1B50;
    BOOL v49 = os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT);
    if (Count)
    {
      if (v49)
      {
        uint64_t v50 = a1[1135];
        *(_DWORD *)std::string buf = 138543362;
        *(void *)&uint8_t buf[4] = v50;
        _os_log_impl(&dword_0, v48, OS_LOG_TYPE_DEFAULT, "SetProperty kBluetoothAudioDeviceWirelessSplitterAggregation creating aggregate device %{public}@", buf, 0xCu);
      }
      uint64_t v51 = qword_A2350;
      int v52 = (*(uint64_t (**)(void))(*(void *)a1[1140] + 16))(a1[1140]);
      if ((sub_444E0(v51, v52) & 1) == 0)
      {
        uint64_t v53 = qword_A2350;
        uint64_t ValueAtIndex = (void *)CFArrayGetValueAtIndex(v46, 0);
        uint64_t v55 = (void *)CFArrayGetValueAtIndex(v46, 1);
        sub_43EE0(v53, ValueAtIndex, v55);
      }
    }
    else
    {
      if (v49)
      {
        int v94 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = v94;
        _os_log_impl(&dword_0, v48, OS_LOG_TYPE_DEFAULT, "SetProperty kBluetoothAudioDeviceWirelessSplitterAggregation destroying aggregate device with ID %u", buf, 8u);
      }
      sub_445A0(qword_A2350, a1[1140]);
    }
    return 0;
  }
  uint64_t v13 = 1937010544;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
    sub_6B004();
  }
  return v13;
}

void sub_51D44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22,char a23,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a22 < 0) {
    operator delete(a17);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_51D80(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  unsigned __int32 v8 = (unsigned char *)(a1 + 9272);
  uint64_t v9 = *(void *)(a1 + 9256);
  BOOL v10 = v9 == a2 && *(void *)(a1 + 9264) == a3 && *(unsigned char *)(a1 + 9273) != 0;
  int v11 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *(void *)(a1 + 9080);
    v31[0] = BYTE3(v9);
    v31[1] = BYTE2(v9);
    void v31[2] = BYTE1(v9);
    v31[3] = v9;
    v31[4] = 0;
    v29[0] = BYTE3(a2);
    v29[1] = BYTE2(a2);
    v29[2] = BYTE1(a2);
    __int16 v30 = a2;
    v12.i32[0] = *(_DWORD *)(a1 + 9264);
    int16x8_t v14 = (int16x8_t)vmovl_u8(v12);
    *(int16x4_t *)v14.i8 = vrev64_s16(*(int16x4_t *)v14.i8);
    unsigned __int32 v27 = vmovn_s16(v14).u32[0];
    char v28 = 0;
    v26[0] = BYTE3(a3);
    v26[1] = BYTE2(a3);
    void v26[2] = BYTE1(a3);
    v26[3] = a3;
    v26[4] = 0;
    sub_B6D0(a4, __p);
    *(_DWORD *)std::string buf = 138544642;
    uint64_t v15 = v25 >= 0 ? __p : (void **)__p[0];
    *(void *)&uint8_t buf[4] = v13;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v31;
    __int16 v33 = 2082;
    uint64_t v34 = v29;
    __int16 v35 = 2082;
    double v36 = &v27;
    __int16 v37 = 2082;
    float v38 = v26;
    __int16 v39 = 2082;
    int v40 = v15;
    _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Request For route Change: [%{public}@ ] profile %{public}s => %{public}s reason %{public}s = > %{public}s Calculated Transition:  %{public}s ", buf, 0x3Eu);
    if (v25 < 0) {
      operator delete(__p[0]);
    }
  }
  BOOL v16 = a2 == 1953719151;
  if (a3 == 1936090482) {
    BOOL v16 = 0;
  }
  *(_DWORD *)(*(void *)(a1 + 9248) + 336) = *(_DWORD *)(*(void *)(a1 + 9248) + 336) & 0xFFFFFFFE | *(_DWORD *)&v16 & ((*(_DWORD *)(*(void *)(a1 + 9248) + 336) & 4u) >> 2);
  if (a2 == 1953719151)
  {
    if (*(void *)(a1 + 9096)) {
      goto LABEL_21;
    }
    return 0;
  }
  if (a2 == 1953260897)
  {
    if (*(void *)(a1 + 9112)) {
      goto LABEL_21;
    }
    return 0;
  }
  if (a2 != 1952539500 || !*(void *)(a1 + 9088)) {
    return 0;
  }
LABEL_21:
  if (v10)
  {
    uint64_t v18 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v18, OS_LOG_TYPE_DEFAULT, "ForceRouteChange step2 VA notified BT, requestConfigChange to switch format", buf, 2u);
    }
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_5CDCC((uint64_t)buf, a1 + 552);
    *unsigned __int32 v8 = 1;
    sub_5CEA4((uint64_t)buf);
    sub_598C8(a1, 1718772584, 0);
    v8[1] = 0;
  }
  else
  {
    sub_5954C((void *)a1, a2, a3);
    *(void *)std::string buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    sub_5CDCC((uint64_t)buf, a1 + 552);
    *unsigned __int32 v8 = 1;
    unsigned int v19 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    sub_5CEA4((uint64_t)buf);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    void v20[2] = sub_59824;
    v20[3] = &unk_8EB30;
    unsigned int v21 = v19;
    int v22 = a2;
    int v23 = a3;
    sub_44BA4(qword_A2350, v19, v20);
  }
  sub_5CF10(buf);
  return 1;
}

void sub_52144(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_52164(void *a1, int a2, int a3)
{
  uint64_t v3 = *(unsigned __int8 *)(a1[1156] + 222);
  if (*(unsigned char *)(a1[1156] + 222))
  {
    uint64_t v3 = 1;
    if (a3 != 1919183219 && a1[1158] != 1919183219)
    {
      uint64_t v4 = 1952539500;
      if (a2 == 1953719151)
      {
        unsigned int v5 = 3;
      }
      else
      {
        if (a2 != 1952539500) {
          return 0;
        }
        unsigned int v5 = 2;
        uint64_t v4 = 1953719151;
      }
      if (a1[1157] == v4) {
        return v5;
      }
      else {
        return 0;
      }
    }
  }
  return v3;
}

void sub_521E8(uint64_t a1)
{
  uint64_t v2 = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 32));
  if (v2)
  {
    uint64_t v3 = (uint64_t **)v2[1156];
    uint64_t v4 = *(void *)(a1 + 36);
    unsigned int v5 = *(_DWORD *)(a1 + 44);
    sub_2B640(v3, v4, v5);
  }
  else
  {
    int v6 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v7 = 0;
      _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "UpdateSpatialAudioQueueInfo update dispatched after disconnection", v7, 2u);
    }
  }
}

void sub_52294(void *a1, uint64_t a2, int a3, float a4)
{
  if (_os_feature_enabled_impl())
  {
    unsigned __int32 v8 = +[BTAudioAVNotificationMonitor sharedInstance];
    uint64_t v9 = v8;
    BOOL v10 = v8 ? [(BTAudioAVNotificationMonitor *)v8 nowPlayingBundleID] : (NSString *)&stru_90900;
    if (a3 == 5 || a3 == 3)
    {
      BOOL v12 = a3 == 3 || a3 == 5;
      v20[0] = a2;
      v19[0] = @"CurrentAudioCategory";
      v19[1] = @"CurrentVolume";
      v20[1] = +[NSNumber numberWithInt:(int)(float)(a4 * 100.0)];
      void v20[2] = &off_91680;
      void v19[2] = @"IsPersonalizedVolumeUpdate";
      void v19[3] = @"ManualVolumeUpdate";
      if (*(unsigned char *)(a1[1136] + 192)) {
        uint64_t v13 = a1[1136];
      }
      else {
        uint64_t v13 = 0;
      }
      v20[3] = +[NSNumber numberWithInt:(int)(float)((*(float (**)(void))(*(void *)v13 + 920))() * 100.0)];
      v19[4] = @"RampInProgress";
      void v20[4] = +[NSNumber numberWithBool:v12];
      double v19[5] = @"PersonalizedVolumeEnabled";
      v20[5] = +[NSNumber numberWithInt:*(unsigned __int8 *)(a1[1156] + 229) == 1];
      v20[6] = v10;
      v19[6] = @"BundleID";
      v19[7] = @"ReasonForManualUpdate";
      void v20[7] = @"PersonalizedVolume";
      int16x8_t v14 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:8];
      if (v9)
      {
        uint64_t v15 = v14;
        BOOL v16 = (void *)a1[1135];
        id v17 = v16;
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 3221225472;
        _OWORD v18[2] = sub_58B60;
        void v18[3] = &unk_8FB98;
        v18[4] = v9;
        char v18[5] = v16;
        v18[6] = v15;
        dispatch_async((dispatch_queue_t)[(BTAudioAVNotificationMonitor *)v9 manualVolumeUpdatesQueue], v18);
      }
    }
  }
}

uint64_t sub_52510(uint64_t a1, void *a2)
{
  unsigned int v4 = objc_msgSend(objc_msgSend(a2, "objectForKey:", @"profileType"), "unsignedIntValue");
  unsigned int v5 = objc_msgSend(objc_msgSend(a2, "objectForKey:", @"Reason"), "unsignedIntValue");
  int v6 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 9080);
    v16[0] = HIBYTE(v4);
    v16[1] = BYTE2(v4);
    void v16[2] = BYTE1(v4);
    v16[3] = v4;
    v16[4] = 0;
    v15[0] = HIBYTE(v5);
    v15[1] = BYTE2(v5);
    void v15[2] = BYTE1(v5);
    _DWORD v15[3] = v5;
    v15[4] = 0;
    *(_DWORD *)std::string buf = 138543874;
    uint64_t v18 = v7;
    __int16 v19 = 2082;
    uint64_t v20 = v16;
    __int16 v21 = 2082;
    int v22 = v15;
    _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Request Out of Band Audio : [%{public}@ ] profile %{public}s reason %{public}s ", buf, 0x20u);
  }
  unsigned __int32 v8 = *(unsigned char **)(a1 + 9096);
  if (!v8) {
    return 0;
  }
  BOOL v9 = v8[192] && v4 == 1953719151;
  if (!v9 || v5 == 1919183219) {
    return 0;
  }
  uint64_t v13 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)std::string buf = 0;
    _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "Out of Band Audio : request Audio in OoB", buf, 2u);
    if (*(unsigned char *)(*(void *)(a1 + 9096) + 192)) {
      unsigned __int32 v8 = *(unsigned char **)(a1 + 9096);
    }
    else {
      unsigned __int32 v8 = 0;
    }
  }
  uint64_t v11 = 1;
  *(_DWORD *)(a1 + 9472) = 1;
  if ((*(unsigned int (**)(unsigned char *, uint64_t, void, uint64_t))(*(void *)v8 + 256))(v8, 1, v5, 1)) {
    sub_56C1C(a1);
  }
  return v11;
}

BOOL sub_52728(uint64_t a1, uint64_t a2, int *a3)
{
  BOOL result = 0;
  int v4 = *a3;
  if (*a3 <= 1935762291)
  {
    if (v4 > 1870098019)
    {
      BOOL v5 = v4 == 1870098020 || v4 == 1885762592;
      int v6 = 1885762657;
    }
    else
    {
      BOOL v5 = v4 == 1650682995 || v4 == 1668047219;
      int v6 = 1819569763;
    }
  }
  else if (v4 <= 1936092512)
  {
    BOOL v5 = v4 == 1935762292 || v4 == 1935894638;
    int v6 = 1935960434;
  }
  else if (v4 > 1937007733)
  {
    BOOL v5 = v4 == 1952805485;
    int v6 = 1937007734;
  }
  else
  {
    BOOL v5 = v4 == 1936092513;
    int v6 = 1936092532;
  }
  if (v5 || v4 == v6) {
    return a3[1] == 1735159650 && a3[2] == 0;
  }
  return result;
}

void sub_5283C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 9096);
  if (v1 && *(unsigned char *)(v1 + 192) && *(_DWORD *)(v1 + 9328))
  {
    uint64_t v3 = (_WORD *)(a1 + 9305);
    uint64_t v4 = *(void *)(a1 + 9248);
    if (*(unsigned char *)(v4 + 221))
    {
      int v5 = *(_DWORD *)(v1 + 9340);
      if (v5 == 130)
      {
        *uint64_t v3 = 0;
        uint64_t v6 = qword_A1B50;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_WORD *)std::string buf = 0;
        uint64_t v7 = "HFPStereo config policy nopending for game";
        unsigned __int32 v8 = v6;
        uint32_t v9 = 2;
        goto LABEL_22;
      }
      *uint64_t v3 = 1028;
      uint64_t v12 = qword_A1B50;
      if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      v13.i32[0] = *(_DWORD *)(a1 + 9256);
      int16x8_t v14 = (int16x8_t)vmovl_u8(v13);
      *(int16x4_t *)v14.i8 = vrev64_s16(*(int16x4_t *)v14.i8);
      unsigned __int32 v24 = vmovn_s16(v14).u32[0];
      char v25 = 0;
      *(_DWORD *)std::string buf = 67109378;
      int v27 = v5;
      __int16 v28 = 2082;
      uint64_t v29 = &v24;
      uint64_t v7 = "HFPStereo config policy picked HAoS, currCodec %u, device %{public}s";
      goto LABEL_14;
    }
    if (*(unsigned char *)(v4 + 216))
    {
      int v10 = *(_DWORD *)(v1 + 9340);
      if ((v10 | 0x100) == 0x100)
      {
        *uint64_t v3 = 0;
        uint64_t v11 = qword_A1B50;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)std::string buf = 67109120;
        int v27 = v10;
        uint64_t v7 = "HFPStereo config no pending for hid, currCodec %u";
      }
      else
      {
        *uint64_t v3 = 257;
        uint64_t v11 = qword_A1B50;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)std::string buf = 67109120;
        int v27 = v10;
        uint64_t v7 = "HFPStereo config policy picked mono for hid, currCodec %u";
      }
      goto LABEL_21;
    }
    if (*(unsigned char *)(v1 + 9436))
    {
      int v15 = *(_DWORD *)(v1 + 9340);
      if ((v15 & 0xFFFFFFFE) == 0x80)
      {
        *uint64_t v3 = 0;
        uint64_t v11 = qword_A1B50;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)std::string buf = 67109120;
        int v27 = v15;
        uint64_t v7 = "HFPStereo config no pending for sfer, currCodec %u";
LABEL_21:
        unsigned __int32 v8 = v11;
        uint32_t v9 = 8;
        goto LABEL_22;
      }
      *uint64_t v3 = 771;
      uint64_t v12 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        v22.i32[0] = *(_DWORD *)(a1 + 9256);
        int16x8_t v23 = (int16x8_t)vmovl_u8(v22);
        *(int16x4_t *)v23.i8 = vrev64_s16(*(int16x4_t *)v23.i8);
        unsigned __int32 v24 = vmovn_s16(v23).u32[0];
        char v25 = 0;
        *(_DWORD *)std::string buf = 67109378;
        int v27 = v15;
        __int16 v28 = 2082;
        uint64_t v29 = &v24;
        uint64_t v7 = "HFPStereo config policy picked high stereo for sfer, currCodec %u, device %{public}s";
LABEL_14:
        unsigned __int32 v8 = v12;
        uint32_t v9 = 18;
LABEL_22:
        _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, v7, buf, v9);
      }
    }
    else if ((sub_395B4() & 1) == 0)
    {
      BOOL v16 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = *(_DWORD *)(v1 + 9340);
        v17.i32[0] = *(_DWORD *)(a1 + 9256);
        int16x8_t v19 = (int16x8_t)vmovl_u8(v17);
        *(int16x4_t *)v19.i8 = vrev64_s16(*(int16x4_t *)v19.i8);
        unsigned __int32 v24 = vmovn_s16(v19).u32[0];
        char v25 = 0;
        int v20 = *(unsigned __int8 *)(*(void *)(a1 + 9248) + 221);
        int v21 = *(unsigned __int8 *)(v1 + 9436);
        *(_DWORD *)std::string buf = 67109890;
        int v27 = v18;
        __int16 v28 = 2082;
        uint64_t v29 = &v24;
        __int16 v30 = 1024;
        int v31 = v20;
        __int16 v32 = 1024;
        int v33 = v21;
        _os_log_impl(&dword_0, v16, OS_LOG_TYPE_DEFAULT, "HFPStereo config policy picked mono, currCodec %u, device %{public}s, game %u, sfer %d", buf, 0x1Eu);
      }
      *uint64_t v3 = 257;
    }
  }
}

uint64_t sub_52BBC(uint64_t a1, uint64_t a2, int *a3, char *a4)
{
  char v4 = 0;
  int v5 = *a3;
  uint64_t result = 2003332927;
  if (*a3 > 1935762291)
  {
    if (v5 > 1936092512)
    {
      if (v5 <= 1937007733)
      {
        if (v5 != 1936092513)
        {
          if (v5 != 1936092532) {
            return result;
          }
          goto LABEL_22;
        }
LABEL_26:
        uint64_t result = 0;
        *a4 = v4;
        return result;
      }
      if (v5 == 1937007734) {
        goto LABEL_26;
      }
      int v9 = 1952805485;
LABEL_25:
      if (v5 != v9) {
        return result;
      }
      goto LABEL_26;
    }
    if (v5 != 1935762292)
    {
      if (v5 == 1935894638) {
        goto LABEL_26;
      }
      int v9 = 1935960434;
      goto LABEL_25;
    }
LABEL_22:
    char v4 = 1;
    goto LABEL_26;
  }
  if (v5 > 1870098019)
  {
    if (v5 == 1870098020) {
      goto LABEL_26;
    }
    if (v5 != 1885762592)
    {
      int v9 = 1885762657;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  if (v5 == 1650682995 || v5 == 1668047219 || v5 == 1819569763) {
    goto LABEL_26;
  }
  return result;
}

uint64_t sub_52CE8(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, int *a6)
{
  int v8 = *a3;
  int v9 = 4;
  uint64_t result = 2003332927;
  if (*a3 <= 1935762291)
  {
    if (v8 > 1853059618)
    {
      if (v8 <= 1885762591)
      {
        if (v8 == 1853059619)
        {
          int v9 = 16 * (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1224))(a1);
        }
        else
        {
          if (v8 != 1870098020) {
            return result;
          }
          int v9 = 0;
        }
        goto LABEL_33;
      }
      if (v8 != 1885762592)
      {
        if (v8 != 1885762657) {
          return result;
        }
        goto LABEL_27;
      }
      goto LABEL_31;
    }
    BOOL v11 = v8 == 1650682995 || v8 == 1668047219;
    int v12 = 1819569763;
    goto LABEL_20;
  }
  if (v8 <= 1936092512)
  {
    BOOL v11 = v8 == 1935762292 || v8 == 1935894638;
    int v12 = 1935960434;
LABEL_20:
    if (v11 || v8 == v12) {
      goto LABEL_33;
    }
    return result;
  }
  if (v8 > 1937007733)
  {
    if (v8 == 1937007734 || v8 == 1952805485) {
      goto LABEL_33;
    }
  }
  else
  {
    if (v8 == 1936092513)
    {
LABEL_27:
      uint64_t v14 = sub_11C98(a2);
      int v9 = 56 * (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a1 + 1208))(a1, v14);
LABEL_33:
      uint64_t result = 0;
      *a6 = v9;
      return result;
    }
    if (v8 == 1936092532)
    {
LABEL_31:
      int v9 = 40;
      goto LABEL_33;
    }
  }
  return result;
}

uint64_t sub_52ED8(void *a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int *a8, uint64_t a9)
{
  int v11 = *a3;
  uint64_t v12 = 2003332927;
  if (*a3 <= 1935762291)
  {
    if (v11 > 1870098019)
    {
      if (v11 == 1870098020)
      {
        uint64_t v12 = 0;
        *a8 = 0;
        return v12;
      }
      if (v11 == 1885762592) {
        goto LABEL_31;
      }
      if (v11 != 1885762657) {
        return v12;
      }
      goto LABEL_23;
    }
    switch(v11)
    {
      case 1650682995:
        if (a7 <= 3)
        {
          uint64_t v12 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B2DC();
          }
          return v12;
        }
        uint64_t v12 = 0;
        int v21 = 1634689642;
        break;
      case 1668047219:
        if (a7 <= 3)
        {
          uint64_t v12 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B310();
          }
          return v12;
        }
        uint64_t v12 = 0;
        int v21 = 1634956402;
        break;
      case 1819569763:
        if (a7 > 3)
        {
LABEL_51:
          uint64_t v12 = 0;
          *(_DWORD *)a9 = 0;
LABEL_62:
          int v16 = 4;
          goto LABEL_63;
        }
        uint64_t v12 = 561211770;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          return v12;
        }
LABEL_13:
        sub_6B414();
        return v12;
      default:
        return v12;
    }
LABEL_59:
    *(_DWORD *)a9 = v21;
    goto LABEL_62;
  }
  if (v11 <= 1936092512)
  {
    switch(v11)
    {
      case 1935762292:
        if (a7 <= 3)
        {
          uint64_t v12 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B378();
          }
          return v12;
        }
        uint64_t v12 = 0;
        int v21 = *(unsigned __int8 *)(a2 + 12);
        break;
      case 1935894638:
        if (a7 <= 3)
        {
          uint64_t v12 = 561211770;
          if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            return v12;
          }
          goto LABEL_13;
        }
        uint64_t v12 = 0;
        int v21 = 1;
        break;
      case 1935960434:
        if (a7 <= 3)
        {
          uint64_t v12 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B3AC();
          }
          return v12;
        }
        int v20 = sub_11C98(a2);
        goto LABEL_61;
      default:
        return v12;
    }
    goto LABEL_59;
  }
  if (v11 > 1937007733)
  {
    if (v11 != 1937007734)
    {
      if (v11 != 1952805485) {
        return v12;
      }
      if (a7 <= 3)
      {
        uint64_t v12 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B3E0();
        }
        return v12;
      }
      goto LABEL_51;
    }
    if (a7 <= 3)
    {
      uint64_t v12 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6B344();
      }
      return v12;
    }
    int v20 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
LABEL_61:
    uint64_t v12 = 0;
    *(_DWORD *)a9 = v20;
    goto LABEL_62;
  }
  if (v11 != 1936092513)
  {
    if (v11 != 1936092532) {
      return v12;
    }
LABEL_31:
    if (a7 <= 0x27)
    {
      uint64_t v12 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6B448();
      }
      return v12;
    }
    uint64_t v17 = a1[1140];
    if (v17)
    {
      uint64_t v18 = sub_11C98(a2);
      (*(void (**)(_OWORD *__return_ptr, uint64_t, uint64_t))(*(void *)v17 + 800))(v23, v17, v18);
      uint64_t v12 = 0;
      long long v19 = v23[1];
      *(_OWORD *)a9 = v23[0];
      *(_OWORD *)(a9 + 16) = v19;
      *(void *)(a9 + 32) = v24;
      int v16 = 40;
      goto LABEL_63;
    }
    uint64_t v12 = 1937010544;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      sub_6B47C();
    }
    return v12;
  }
LABEL_23:
  if (a7 > 0x37)
  {
    unint64_t v13 = a7 / 0x38uLL;
    uint64_t v14 = sub_11C98(a2);
    int v15 = (*(uint64_t (**)(void *, uint64_t, unint64_t, uint64_t))(*a1 + 1216))(a1, a9, v13, v14);
    uint64_t v12 = 0;
    int v16 = 56 * v15;
LABEL_63:
    *a8 = v16;
    return v12;
  }
  uint64_t v12 = 561211770;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
    sub_6B4B0();
  }
  return v12;
}

uint64_t sub_533D0(void *a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8)
{
  int v10 = *a3;
  if (*a3 == 1885762592 || v10 == 1936092532)
  {
    if (a6 != 40)
    {
      uint64_t v26 = 561211770;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6B54C();
      }
      return v26;
    }
    if (*(_DWORD *)(a7 + 8) != 1819304813)
    {
      uint64_t v26 = 560226676;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6B518();
      }
      return v26;
    }
    uint64_t v13 = a1[1140];
    if (!v13)
    {
      uint64_t v26 = 1937010544;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6B4E4();
      }
      return v26;
    }
    uint64_t v35 = 0;
    long long v33 = 0u;
    long long v34 = 0u;
    uint64_t v15 = sub_11C98(a2);
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t))(*(void *)v13 + 800))(&v33, v13, v15);
    double v16 = *(double *)&v33;
    double v17 = *(double *)a7;
    uint64_t v18 = a1[1140];
    uint64_t v19 = sub_11C98(a2);
    int v20 = (*(uint64_t (**)(uint64_t, uint64_t, double, double))(*(void *)v18 + 1256))(v18, v19, v16, v17);
    int v21 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 67109888;
      *(_DWORD *)__int16 v37 = a8;
      *(_WORD *)&v37[4] = 2048;
      *(double *)&unsigned char v37[6] = v16;
      __int16 v38 = 2048;
      double v39 = v17;
      __int16 v40 = 1024;
      int v41 = v20;
      _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, "[ %d ] Request for physical format change %f -> %f format change supported %d", buf, 0x22u);
    }
    if (v20)
    {
      v31[0] = v33;
      v31[1] = v34;
      uint64_t v32 = v35;
      long long v22 = *(_OWORD *)(a7 + 16);
      v29[0] = *(_OWORD *)a7;
      v29[1] = v22;
      uint64_t v30 = *(void *)(a7 + 32);
      uint64_t v23 = sub_11C98(a2);
      if (((*(uint64_t (**)(void *, _OWORD *, _OWORD *, uint64_t))(*a1 + 1264))(a1, v31, v29, v23) & 1) == 0)
      {
        int v27 = qword_A1B50;
        uint64_t v26 = 0;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
          return v26;
        }
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v27, OS_LOG_TYPE_DEFAULT, "Requesting For same format as current, nothing to do", buf, 2u);
        return 0;
      }
      uint64_t v24 = qword_A1B50;
      if (v17 != v16)
      {
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 134217984;
          *(double *)__int16 v37 = v17;
          _os_log_impl(&dword_0, v24, OS_LOG_TYPE_DEFAULT, "kAudioDevicePropertyNominalSampleRate %f", buf, 0xCu);
        }
        (*(void (**)(void *, uint64_t, uint64_t))(*a1 + 240))(a1, 1853059700, (uint64_t)v17);
        return 0;
      }
    }
    else
    {
      uint64_t v24 = qword_A1B50;
    }
    uint64_t v26 = 1852797029;
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v24, OS_LOG_TYPE_DEFAULT, "We do not support changing to this format at this moment", buf, 2u);
    }
    return v26;
  }
  if (v10 != 1935762292) {
    return 2003332927;
  }
  if (a6 == 4)
  {
    int v25 = *(_DWORD *)a7 != 0;
    if (*(unsigned __int8 *)(a2 + 12) != v25)
    {
      uint64_t v26 = 0;
      *(unsigned char *)(a2 + 12) = v25;
      return v26;
    }
    return 0;
  }
  uint64_t v26 = 561211770;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
    sub_6AF34();
  }
  return v26;
}

BOOL sub_53850(uint64_t a1, uint64_t a2, int *a3)
{
  if (*(void *)(a1 + 9160) && *(void *)(a1 + 9256) == 1953719151)
  {
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v7 = v6 == (*(unsigned int (**)(void))(**(void **)(a1 + 9160) + 16))(*(void *)(a1 + 9160));
  }
  else
  {
    BOOL v7 = 0;
  }
  if (*(void *)(a1 + 9144))
  {
    int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v9 = v8 == (*(uint64_t (**)(void))(**(void **)(a1 + 9144) + 16))(*(void *)(a1 + 9144));
  }
  else
  {
    BOOL v9 = 0;
  }
  if (*(void *)(a1 + 9152))
  {
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v11 = v10 == (*(uint64_t (**)(void))(**(void **)(a1 + 9152) + 16))(*(void *)(a1 + 9152));
  }
  else
  {
    BOOL v11 = 0;
  }
  int v12 = *a3;
  if (*a3 <= 1818453109)
  {
    if (v12 > 1668047218)
    {
      if (v12 != 1668047219 && v12 != 1668506480)
      {
        BOOL result = 0;
        if (v12 != 1818453106) {
          return result;
        }
LABEL_27:
        if (v9)
        {
          int v15 = a3[1];
          int v16 = 1869968496;
          goto LABEL_33;
        }
        return 0;
      }
    }
    else if (v12 != 1650682995)
    {
      if (v12 != 1650685548)
      {
        BOOL result = 0;
        int v14 = 1667591277;
        goto LABEL_31;
      }
      if (!v11) {
        return 0;
      }
    }
LABEL_32:
    int v15 = a3[1];
    int v16 = 1735159650;
LABEL_33:
    if (v15 == v16) {
      return a3[2] == 0;
    }
    return 0;
  }
  if (v12 <= 1935892840)
  {
    if (v12 != 1818453110 && v12 != 1818456950)
    {
      BOOL result = 0;
      int v14 = 1870098020;
      goto LABEL_31;
    }
    goto LABEL_27;
  }
  if (v12 > 1935894893)
  {
    BOOL result = v7;
    if (v12 == 1935894894) {
      return result;
    }
    BOOL result = 0;
    int v14 = 1937007734;
LABEL_31:
    if (v12 != v14) {
      return result;
    }
    goto LABEL_32;
  }
  if (v12 == 1935892841) {
    return v7;
  }
  BOOL result = 0;
  if (v12 == 1935893353) {
    return v7;
  }
  return result;
}

uint64_t sub_53B4C(void **a1, uint64_t a2, int *a3, char *a4)
{
  if (a1[1145])
  {
    int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v9 = v8 == (*(unsigned int (**)(void *))(*a1[1145] + 16))(a1[1145]);
  }
  else
  {
    BOOL v9 = 0;
  }
  if (a1[1143])
  {
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v11 = v10 == (*(unsigned int (**)(void *))(*a1[1143] + 16))(a1[1143]);
  }
  else
  {
    BOOL v11 = 0;
  }
  if (a1[1144])
  {
    int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v13 = v12 == (*(unsigned int (**)(void *))(*a1[1144] + 16))(a1[1144]);
  }
  else
  {
    BOOL v13 = 0;
  }
  char v14 = 0;
  uint64_t result = 2003332927;
  int v16 = *a3;
  if (*a3 > 1818456931)
  {
    if (v16 <= 1935892840)
    {
      if (v16 == 1818456932) {
        goto LABEL_29;
      }
      if (v16 == 1818456950) {
        goto LABEL_37;
      }
      int v17 = 1870098020;
    }
    else
    {
      if (v16 <= 1935894893)
      {
        if (v16 != 1935892841)
        {
          if (v16 != 1935893353) {
            return result;
          }
          char v14 = v9;
        }
        goto LABEL_39;
      }
      if (v16 == 1935894894)
      {
LABEL_39:
        uint64_t result = 0;
        *a4 = v14;
        return result;
      }
      int v17 = 1937007734;
    }
LABEL_35:
    if (v16 != v17) {
      return result;
    }
    goto LABEL_39;
  }
  if (v16 > 1668506479)
  {
    if ((v16 - 1818453106) >= 2)
    {
      if (v16 == 1668506480) {
        goto LABEL_39;
      }
      if (v16 != 1818453110) {
        return result;
      }
LABEL_37:
      if (!v11) {
        return result;
      }
      goto LABEL_38;
    }
LABEL_29:
    if (!v11) {
      return result;
    }
    char v14 = 0;
    goto LABEL_39;
  }
  if (v16 > 1667591276)
  {
    if (v16 == 1667591277) {
      goto LABEL_39;
    }
    int v17 = 1668047219;
    goto LABEL_35;
  }
  if (v16 == 1650682995) {
    goto LABEL_39;
  }
  if (v16 == 1650685548 && v13)
  {
LABEL_38:
    char v14 = 1;
    goto LABEL_39;
  }
  return result;
}

uint64_t sub_53E3C(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, int *a6)
{
  if (*(void *)(a1 + 9160) && *(void *)(a1 + 9256) == 1953719151)
  {
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v11 = v10 == (*(uint64_t (**)(void))(**(void **)(a1 + 9160) + 16))(*(void *)(a1 + 9160));
  }
  else
  {
    BOOL v11 = 0;
  }
  if (*(void *)(a1 + 9144))
  {
    int v12 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v13 = v12 == (*(unsigned int (**)(void))(**(void **)(a1 + 9144) + 16))(*(void *)(a1 + 9144));
  }
  else
  {
    BOOL v13 = 0;
  }
  if (*(void *)(a1 + 9152))
  {
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    BOOL v15 = v14 == (*(unsigned int (**)(void))(**(void **)(a1 + 9152) + 16))(*(void *)(a1 + 9152));
  }
  else
  {
    BOOL v15 = 0;
  }
  uint64_t result = 2003332927;
  int v17 = *a3;
  int v18 = 4;
  if (*a3 > 1818453109)
  {
    if (v17 <= 1935892840)
    {
      if (v17 <= 1818456949)
      {
        if (v17 != 1818453110)
        {
          unsigned __int16 v19 = 29540;
LABEL_33:
          int v20 = v19 | 0x6C630000;
          goto LABEL_36;
        }
        if (!v13) {
          return result;
        }
LABEL_37:
        uint64_t result = 0;
        *a6 = v18;
        return result;
      }
      if (v17 != 1818456950)
      {
        if (v17 != 1870098020) {
          return result;
        }
        int v18 = 0;
        goto LABEL_37;
      }
      if (!v13) {
        return result;
      }
LABEL_48:
      int v18 = 4;
      goto LABEL_37;
    }
    if (v17 > 1935894893)
    {
      if (v17 != 1935894894)
      {
        int v20 = 1937007734;
LABEL_36:
        if (v17 != v20) {
          return result;
        }
        goto LABEL_37;
      }
      if (v11)
      {
        int v18 = 8;
        goto LABEL_37;
      }
      return 0;
    }
    if (v17 != 1935892841)
    {
      if (v17 != 1935893353) {
        return result;
      }
      if (v11) {
        goto LABEL_48;
      }
      return 0;
    }
    if (!v11) {
      return 0;
    }
LABEL_46:
    int v18 = 16;
    goto LABEL_37;
  }
  if (v17 <= 1668047218)
  {
    if (v17 != 1650682995)
    {
      if (v17 != 1650685548)
      {
        int v20 = 1667591277;
        goto LABEL_36;
      }
      if (!v15) {
        return result;
      }
    }
    goto LABEL_37;
  }
  if (v17 <= 1818453105)
  {
    if (v17 != 1668047219)
    {
      int v20 = 1668506480;
      goto LABEL_36;
    }
    goto LABEL_37;
  }
  if (v17 != 1818453106)
  {
    unsigned __int16 v19 = 25715;
    goto LABEL_33;
  }
  if (v13) {
    goto LABEL_46;
  }
  return result;
}

void sub_54178(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v8 = +[BTAudioAVNotificationMonitor sharedInstance];
  BOOL v9 = v8;
  if (v8) {
    CFStringRef v10 = [(BTAudioAVNotificationMonitor *)v8 nowPlayingBundleID];
  }
  else {
    CFStringRef v10 = 0;
  }
  BOOL v11 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)std::string buf = 67109634;
    int v23 = a2;
    __int16 v24 = 1024;
    int v25 = a3;
    __int16 v26 = 2112;
    CFStringRef v27 = v10;
    _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Personalized Volume: sendManualVolumeUpdate %d, mainVolume %d bundleID %@", buf, 0x18u);
  }
  v21[0] = @"PhoneCall";
  v20[0] = @"CurrentAudioCategory";
  v20[1] = @"CurrentVolume";
  v21[1] = +[NSNumber numberWithInt:a2];
  void v21[2] = &off_91680;
  void v20[2] = @"IsPersonalizedVolumeUpdate";
  v20[3] = @"ManualVolumeUpdate";
  v21[3] = +[NSNumber numberWithInt:a3];
  v21[4] = &off_91680;
  void v20[4] = @"RampInProgress";
  v20[5] = @"PersonalizedVolumeEnabled";
  int v12 = +[NSNumber numberWithInt:*(unsigned __int8 *)(*(void *)(a1 + 9248) + 229) == 1];
  CFStringRef v13 = &stru_90900;
  if (v10) {
    CFStringRef v13 = v10;
  }
  v21[5] = v12;
  v21[6] = v13;
  v20[6] = @"BundleID";
  void v20[7] = @"ReasonForManualUpdate";
  if (a4) {
    CFStringRef v14 = @"Top-Down";
  }
  else {
    CFStringRef v14 = @"Bottom-Up";
  }
  unsigned char v21[7] = v14;
  BOOL v15 = +[NSDictionary dictionaryWithObjects:v21 forKeys:v20 count:8];
  if (v9)
  {
    int v16 = v15;
    int v17 = *(void **)(a1 + 9080);
    id v18 = v17;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    void block[2] = sub_543D0;
    block[3] = &unk_8FB98;
    void block[4] = v9;
    void block[5] = v17;
    void block[6] = v16;
    dispatch_async((dispatch_queue_t)[(BTAudioAVNotificationMonitor *)v9 manualVolumeUpdatesQueue], block);
  }
}

id sub_543D0(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) getPersonalizedVolumeDevice:*(void *)(a1 + 40)];
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    return [result NotifyManualVolumeChanged:v3 shouldUpdateBuds:1];
  }
  return result;
}

uint64_t sub_54424(uint64_t a1, _DWORD *a2, int *a3, uint64_t a4, uint64_t a5, unsigned int a6, int *a7, uint64_t a8)
{
  if (*(void *)(a1 + 9160) && *(void *)(a1 + 9256) == 1953719151)
  {
    int v13 = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 16))(a2);
    BOOL v14 = v13 == (*(uint64_t (**)(void))(**(void **)(a1 + 9160) + 16))(*(void *)(a1 + 9160));
  }
  else
  {
    BOOL v14 = 0;
  }
  if (*(void *)(a1 + 9144))
  {
    int v15 = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 16))(a2);
    BOOL v16 = v15 == (*(uint64_t (**)(void))(**(void **)(a1 + 9144) + 16))(*(void *)(a1 + 9144));
  }
  else
  {
    BOOL v16 = 0;
  }
  if (*(void *)(a1 + 9152))
  {
    int v17 = (*(uint64_t (**)(_DWORD *))(*(void *)a2 + 16))(a2);
    BOOL v18 = v17 == (*(uint64_t (**)(void))(**(void **)(a1 + 9152) + 16))(*(void *)(a1 + 9152));
  }
  else
  {
    BOOL v18 = 0;
  }
  uint64_t v19 = 2003332927;
  int v20 = *a3;
  if (*a3 <= 1818453109)
  {
    if (v20 <= 1668047218)
    {
      switch(v20)
      {
        case 1650682995:
          if (a6 <= 3)
          {
            uint64_t v19 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6B580();
            }
            return v19;
          }
          uint64_t v19 = 0;
          if (v14) {
            int v27 = 1685287523;
          }
          else {
            int v27 = 1818588780;
          }
          break;
        case 1650685548:
          if (a6 <= 3)
          {
            uint64_t v19 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6B88C();
            }
            return v19;
          }
          if (!v18) {
            return v19;
          }
          uint64_t v19 = 0;
          int v27 = *(_DWORD *)(*(void *)(a1 + 9248) + 152);
          break;
        case 1667591277:
          if (a6 <= 3)
          {
            uint64_t v19 = 561211770;
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6B650();
            }
            return v19;
          }
          uint64_t v19 = 0;
          int v27 = a2[4];
          break;
        default:
          return v19;
      }
    }
    else
    {
      if (v20 > 1818453105)
      {
        if (v20 != 1818453106)
        {
          if (v20 != 1818453107) {
            return v19;
          }
          if (a6 > 3)
          {
            uint64_t v28 = *(void *)(a1 + 9120);
            if (v28)
            {
              float v29 = sub_85B4(v28, *(float *)a8);
LABEL_89:
              uint64_t v19 = 0;
              *(float *)a8 = v29;
LABEL_104:
              int v33 = 4;
LABEL_105:
              *a7 = v33;
              return v19;
            }
            return 560227702;
          }
          uint64_t v19 = 561211770;
          if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            return v19;
          }
LABEL_43:
          sub_6B720();
          return v19;
        }
        if (a6 <= 0xF)
        {
          uint64_t v19 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B7BC();
          }
          return v19;
        }
        uint64_t v36 = *(void *)(a1 + 9120);
        if (v36)
        {
          if (!v16)
          {
            if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
              sub_6B824();
            }
            return v19;
          }
          *(double *)a8 = (*(float (**)(uint64_t))(*(void *)v36 + 952))(v36);
          uint64_t v19 = 0;
          *(double *)(a8 + 8) = (*(float (**)(void))(**(void **)(a1 + 9120) + 960))();
          int v33 = 16;
          goto LABEL_105;
        }
        uint64_t v19 = 1937010544;
        if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          return v19;
        }
LABEL_55:
        sub_6B7F0();
        return v19;
      }
      if (v20 == 1668047219)
      {
        if (a6 <= 3)
        {
          uint64_t v19 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B5B4();
          }
          return v19;
        }
        if (v14 || v16 || v18)
        {
          if (v18) {
            int v32 = 1836414053;
          }
          else {
            int v32 = 1685287523;
          }
          if (v16) {
            int v32 = 1986817381;
          }
          *(_DWORD *)a8 = v32;
        }
        uint64_t v19 = 0;
        goto LABEL_104;
      }
      if (v20 != 1668506480) {
        return v19;
      }
      if (a6 <= 3)
      {
        uint64_t v19 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B61C();
        }
        return v19;
      }
      uint64_t v19 = 0;
      int v27 = a2[3];
    }
    *(_DWORD *)a8 = v27;
    goto LABEL_104;
  }
  if (v20 <= 1935892840)
  {
    if (v20 > 1818456949)
    {
      if (v20 != 1818456950)
      {
        if (v20 == 1870098020)
        {
          uint64_t v19 = 0;
          *a7 = 0;
        }
        return v19;
      }
      if (a6 <= 3)
      {
        uint64_t v19 = 561211770;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B684();
        }
        return v19;
      }
      if (!*(void *)(a1 + 9120))
      {
        uint64_t v19 = 1937010544;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B6B8();
        }
        return v19;
      }
      if (!v16)
      {
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B6EC();
        }
        return v19;
      }
      int v34 = sub_395B4();
      uint64_t v35 = **(void **)(a1 + 9120);
      if (v34) {
        (*(void (**)(void))(v35 + 928))();
      }
      else {
        (*(void (**)(void))(v35 + 920))();
      }
      goto LABEL_89;
    }
    if (v20 != 1818453110)
    {
      if (v20 == 1818456932)
      {
        if (a6 <= 3)
        {
          uint64_t v19 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B858();
          }
          return v19;
        }
        uint64_t v24 = *(void *)(a1 + 9120);
        if (v24)
        {
          float v25 = *(float *)a8;
          float v26 = 0.0;
          if (*(float *)a8 < 0.0 || (float v26 = 1.0, v25 > 1.0))
          {
            *(float *)a8 = v26;
            float v25 = v26;
          }
LABEL_88:
          float v29 = sub_85E0(v24, v25);
          goto LABEL_89;
        }
        return 560227702;
      }
      return v19;
    }
    if (a6 > 3)
    {
      if (!*(void *)(a1 + 9120))
      {
        uint64_t v19 = 1937010544;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B754();
        }
        return v19;
      }
      if (!v16)
      {
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
          sub_6B788();
        }
        return v19;
      }
      int v30 = sub_395B4();
      uint64_t v31 = **(void **)(a1 + 9120);
      if (!v30)
      {
        (*(void (**)(void))(v31 + 936))();
        goto LABEL_89;
      }
      (*(void (**)(void))(v31 + 928))();
      uint64_t v24 = a1;
      goto LABEL_88;
    }
    uint64_t v19 = 561211770;
    if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      return v19;
    }
    goto LABEL_43;
  }
  if (v20 > 1935894893)
  {
    if (v20 != 1935894894)
    {
      if (v20 == 1937007734)
      {
        if (a6 <= 3)
        {
          uint64_t v19 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B5E8();
          }
          return v19;
        }
        uint64_t v19 = 0;
        *(_DWORD *)a8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
        goto LABEL_104;
      }
      return v19;
    }
  }
  else if (v20 != 1935892841 && v20 != 1935893353)
  {
    return v19;
  }
  uint64_t v21 = *(void *)(a1 + 9120);
  if (!v21)
  {
    uint64_t v19 = 1937010544;
    if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      return v19;
    }
    goto LABEL_55;
  }
  if (!v14) {
    return 0;
  }
  long long v22 = *(uint64_t (**)(void))(*(void *)v21 + 144);

  return v22();
}

uint64_t sub_54DD4(void *a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, int a6, float *a7, int a8)
{
  if (a1[1145] && a1[1157] == 1953719151)
  {
    (*(void (**)(uint64_t))(*(void *)a2 + 16))(a2);
    (*(void (**)(void))(*(void *)a1[1145] + 16))(a1[1145]);
  }
  if (a1[1143])
  {
    int v14 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
    int v15 = (*(uint64_t (**)(void))(*(void *)a1[1143] + 16))(a1[1143]);
    BOOL v16 = v14 == v15;
    if (!a1[1144])
    {
      if (v14 != v15) {
        return 0;
      }
LABEL_17:
      int v25 = *a3;
      if (*a3 == 1818453110)
      {
        if (a6 != 4)
        {
          uint64_t v22 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B95C();
          }
          return v22;
        }
        __int16 v38 = qword_A1B50;
        if (!a1[1140])
        {
          uint64_t v22 = 1937010544;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B928();
          }
          return v22;
        }
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          int v39 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
          double v40 = *a7;
          int v41 = a3[2];
          *(_DWORD *)std::string buf = 67109888;
          *(_DWORD *)&uint8_t buf[4] = a8;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v39;
          *(_WORD *)int v75 = 2048;
          *(double *)&v75[2] = v40;
          __int16 v76 = 1024;
          LODWORD(v77) = v41;
          _os_log_impl(&dword_0, v38, OS_LOG_TYPE_DEFAULT, "kAudioLevelControlPropertyDecibelValue update from PID = %d Control ID = %d DBM volume %f  Element = %d", buf, 0x1Eu);
        }
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        sub_5CDCC((uint64_t)&v72, (uint64_t)(a1 + 69));
        uint64_t v42 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          double v43 = *a7;
          *(_DWORD *)std::string buf = 134217984;
          *(double *)&uint8_t buf[4] = v43;
          _os_log_impl(&dword_0, v42, OS_LOG_TYPE_DEFAULT, "DB volume from CA  %f", buf, 0xCu);
        }
        (*(void (**)(void, float))(*(void *)a1[1140] + 944))(a1[1140], *a7);
        (*(void (**)(void))(*(void *)a1[1140] + 936))(a1[1140]);
        (*(void (**)(void *))(*a1 + 488))(a1);
        sub_5CEA4((uint64_t)&v72);
        if ((*(unsigned int (**)(void *))(*a1 + 296))(a1))
        {
          uint64_t v44 = qword_A2350;
          int v45 = (*(uint64_t (**)(void))(*(void *)a1[1140] + 16))(a1[1140]);
          if (sub_444E0(v44, v45))
          {
            sub_44380(qword_A2350);
            (*(void (**)(void))(*(void *)a1[1140] + 920))(a1[1140]);
            (*(void (**)(void *, uint64_t))(*a1 + 480))(a1, 1);
          }
        }
        int v46 = a3[1];
        if (v46 != 1735159650 || a3[2])
        {
          uint64_t v47 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR))
          {
            char v68 = HIBYTE(v46);
            char v69 = BYTE2(v46);
            char v70 = BYTE1(v46);
            __int16 v71 = v46;
            v48.i32[0] = a3[2];
            int16x8_t v64 = (int16x8_t)vmovl_u8(v48);
            *(int16x4_t *)v64.i8 = vrev64_s16(*(int16x4_t *)v64.i8);
            unsigned __int32 v66 = vmovn_s16(v64).u32[0];
            char v67 = 0;
            *(_DWORD *)std::string buf = 136446466;
            *(void *)&uint8_t buf[4] = &v68;
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)int v75 = &v66;
            _os_log_error_impl(&dword_0, v47, OS_LOG_TYPE_ERROR, "kAudioDevicePropertyVolumeDecibels is setting wrong scope: %{public}s / element: %{public}s", buf, 0x16u);
          }
        }
        if (sub_395B4())
        {
LABEL_75:
          strcpy(buf, "vsclbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          sub_1E944(a2, (__int32 *)buf);
          strcpy(buf, "vdclbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          sub_1E944(a2, (__int32 *)buf);
        }
      }
      else
      {
        if (v25 != 1818456950)
        {
          uint64_t v22 = 2003332927;
          BOOL v49 = qword_A1B50;
          if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
            return v22;
          }
          v50.i32[0] = a3[1];
          int16x8_t v51 = (int16x8_t)vmovl_u8(v50);
          *(int16x4_t *)v51.i8 = vrev64_s16(*(int16x4_t *)v51.i8);
          LODWORD(v72) = vmovn_s16(v51).u32[0];
          BYTE4(v72) = 0;
          char v68 = HIBYTE(v25);
          char v69 = BYTE2(v25);
          char v70 = BYTE1(v25);
          __int16 v71 = v25;
          *(_DWORD *)std::string buf = 136446466;
          *(void *)&uint8_t buf[4] = &v72;
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)int v75 = &v68;
          int v52 = "Unknown volumeControl property set for scope: %{public}s / element: %{public}s";
LABEL_51:
          _os_log_impl(&dword_0, v49, OS_LOG_TYPE_DEFAULT, v52, buf, 0x16u);
          return v22;
        }
        if (a6 != 4)
        {
          uint64_t v22 = 561211770;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B8F4();
          }
          return v22;
        }
        if (!a1[1140])
        {
          uint64_t v22 = 1937010544;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
            sub_6B8C0();
          }
          return v22;
        }
        uint64_t v72 = 0;
        uint64_t v73 = 0;
        sub_5CDCC((uint64_t)&v72, (uint64_t)(a1 + 69));
        float v26 = *a7;
        if (sub_395B4())
        {
          float v27 = (*(float (**)(void))(*(void *)a1[1140] + 920))(a1[1140]);
          uint64_t v28 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            int v29 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
            int v30 = a3[2];
            *(_DWORD *)std::string buf = 67110144;
            *(_DWORD *)&uint8_t buf[4] = a8;
            *(_WORD *)&uint8_t buf[8] = 1024;
            *(_DWORD *)&buf[10] = v29;
            *(_WORD *)int v75 = 2048;
            *(double *)&v75[2] = v27;
            __int16 v76 = 2048;
            double v77 = v26;
            __int16 v78 = 1024;
            int v79 = v30;
            _os_log_impl(&dword_0, v28, OS_LOG_TYPE_DEFAULT, "Volume update from PID = %d Control ID = %d Scalar volume %f -> %f Element = %d", buf, 0x28u);
          }
          float v31 = (*(float (**)(void, uint64_t, float))(*(void *)a1[1140] + 984))(a1[1140], 2, *a7);
          float v26 = v31;
          BOOL v32 = v31 == 0.0;
          BOOL v33 = v31 != 0.0;
          if (v27 == 0.0) {
            BOOL v32 = 0;
          }
          else {
            BOOL v33 = 0;
          }
          int v34 = v33 || v32;
          if (v27 == v31) {
            int v35 = 0;
          }
          else {
            int v35 = v34;
          }
          uint64_t v36 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            double v37 = *a7;
            *(_DWORD *)std::string buf = 136446466;
            *(void *)&uint8_t buf[4] = "Right ";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(double *)int v75 = v37;
            _os_log_impl(&dword_0, v36, OS_LOG_TYPE_DEFAULT, "%{public}s : Sclar volume from CA %f ", buf, 0x16u);
          }
        }
        else
        {
          uint64_t v55 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)std::string buf = 134217984;
            *(double *)&uint8_t buf[4] = v26;
            _os_log_impl(&dword_0, v55, OS_LOG_TYPE_DEFAULT, "Volume Sclar volume from CA %f", buf, 0xCu);
          }
          int v35 = 0;
        }
        uint64_t v56 = a1[1140];
        (*(void (**)(uint64_t, float))(*(void *)v56 + 368))(v56, v26);
        (*(void (**)(uint64_t))(*(void *)v56 + 944))(v56);
        (*(void (**)(void))(*(void *)a1[1140] + 936))(a1[1140]);
        (*(void (**)(void *))(*a1 + 488))(a1);
        if ((sub_395B4() & v35) == 1)
        {
          uint64_t v57 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_0, v57, OS_LOG_TYPE_DEFAULT, "Notify that Mute changed", buf, 2u);
          }
          strcpy(buf, "etumptuo");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
        }
        sub_5CEA4((uint64_t)&v72);
        if ((*(unsigned int (**)(void *))(*a1 + 296))(a1))
        {
          uint64_t v58 = qword_A2350;
          int v59 = (*(uint64_t (**)(void))(*(void *)a1[1140] + 16))(a1[1140]);
          if (sub_444E0(v58, v59))
          {
            sub_44380(qword_A2350);
            (*(void (**)(void))(*(void *)a1[1140] + 920))(a1[1140]);
            (*(void (**)(void *, uint64_t))(*a1 + 480))(a1, 1);
          }
        }
        int v60 = a3[1];
        if (v60 != 1735159650 || a3[2])
        {
          int v61 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR))
          {
            char v68 = HIBYTE(v60);
            char v69 = BYTE2(v60);
            char v70 = BYTE1(v60);
            __int16 v71 = v60;
            v62.i32[0] = a3[2];
            int16x8_t v65 = (int16x8_t)vmovl_u8(v62);
            *(int16x4_t *)v65.i8 = vrev64_s16(*(int16x4_t *)v65.i8);
            unsigned __int32 v66 = vmovn_s16(v65).u32[0];
            char v67 = 0;
            *(_DWORD *)std::string buf = 136446466;
            *(void *)&uint8_t buf[4] = &v68;
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)int v75 = &v66;
            _os_log_error_impl(&dword_0, v61, OS_LOG_TYPE_ERROR, "kAudioDevicePropertyVolumeScalar is setting wrong scope: %{public}s / element: %{public}s", buf, 0x16u);
          }
        }
        if (sub_395B4()) {
          goto LABEL_75;
        }
      }
      sub_5CF10(&v72);
      return 0;
    }
    int v17 = a1 + 1144;
  }
  else
  {
    if (!a1[1144]) {
      return 0;
    }
    BOOL v16 = 0;
    int v17 = a1 + 1144;
  }
  int v18 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 16))(a2);
  int v19 = (*(uint64_t (**)(void))(*(void *)*v17 + 16))();
  if (v16) {
    goto LABEL_17;
  }
  if (v18 != v19) {
    return 0;
  }
  int v20 = *a3;
  if (*a3 != 1650685548)
  {
    uint64_t v22 = 2003332927;
    BOOL v49 = qword_A1B50;
    if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
      return v22;
    }
    v53.i32[0] = a3[1];
    int16x8_t v54 = (int16x8_t)vmovl_u8(v53);
    *(int16x4_t *)v54.i8 = vrev64_s16(*(int16x4_t *)v54.i8);
    LODWORD(v72) = vmovn_s16(v54).u32[0];
    BYTE4(v72) = 0;
    char v68 = HIBYTE(v20);
    char v69 = BYTE2(v20);
    char v70 = BYTE1(v20);
    __int16 v71 = v20;
    *(_DWORD *)std::string buf = 136446466;
    *(void *)&uint8_t buf[4] = &v72;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)int v75 = &v68;
    int v52 = "Unknown muteControl property set for scope: %{public}s / element: %{public}s";
    goto LABEL_51;
  }
  *(float *)(a1[1156] + 152) = *a7;
  if (sub_395B4())
  {
    strcpy(buf, "etumptuo");
    buf[9] = 0;
    *(_WORD *)&buf[10] = 0;
    (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
  }
  uint64_t v21 = qword_A1B50;
  uint64_t v22 = 0;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = a1[25];
    int v24 = *(_DWORD *)(a1[1156] + 152);
    *(_DWORD *)std::string buf = 138412546;
    *(void *)&uint8_t buf[4] = v23;
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)int v75 = v24;
    _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, "Set muteControl for mAudioDeviceUID %@ to %d", buf, 0x12u);
    return 0;
  }
  return v22;
}

void sub_55B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  sub_5CF10(va);
  _Unwind_Resume(a1);
}

uint64_t sub_55BB4(uint64_t a1, int a2)
{
  int v3 = a2;
  uint64_t v4 = 1869968496;
  return (*(uint64_t (**)(uint64_t, int *))(*(void *)a1 + 248))(a1, &v3);
}

uint64_t sub_55C08(uint64_t a1, uint64_t a2, __int32 a3)
{
  __int32 v4 = a3;
  uint64_t v5 = 1735159650;
  return sub_1E944(a2, &v4);
}

uint64_t sub_55C40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5 = a2;
  BOOL v7 = (unsigned char *)(a1 + 9272);
  int v8 = *(unsigned __int8 *)(a1 + 9272);
  if (a2 > 1853059699)
  {
    if (a2 <= 1885762656)
    {
      if (a2 == 1853059700)
      {
        double v27 = (double)a3;
        double v36 = (double)a3;
        uint64_t v28 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)std::string buf = 134217984;
          *(double *)&uint8_t buf[4] = (double)a3;
          _os_log_impl(&dword_0, v28, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice::PerformDeviceConfigurationChange [sample rate = %f]", buf, 0xCu);
        }
        int v30 = sub_4AC94((void *)a1, &v36, v29);
        uint64_t v31 = *(void *)(a1 + 9120);
        if (v31) {
          (*(void (**)(uint64_t, double))(*(void *)v31 + 520))(v31, v27);
        }
        BOOL v32 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v33 = "NO";
          if (v30) {
            BOOL v33 = "YES";
          }
          *(_DWORD *)std::string buf = 136446210;
          *(void *)&uint8_t buf[4] = v33;
          _os_log_impl(&dword_0, v32, OS_LOG_TYPE_DEFAULT, "Perform Config change : kAudioDevicePropertyNominalSampleRate Upate pending shedule Profile Updated %{public}s", buf, 0xCu);
        }
        *BOOL v7 = 0;
        sub_564D8(a1);
      }
      else
      {
        if (a2 != 1885762592) {
          goto LABEL_33;
        }
        *BOOL v7 = 0;
        int v14 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)std::string buf = 0;
          _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "Perform Config change : kAudioStreamPropertyPhysicalFormat Upate pending shedule", buf, 2u);
        }
      }
      strcpy(buf, "pcvabolg");
      buf[9] = 0;
      *(_WORD *)&buf[10] = 0;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)a1 + 248))(a1, buf);
      goto LABEL_62;
    }
    if (a2 == 1885762657)
    {
      int v19 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v19, OS_LOG_TYPE_DEFAULT, "kAudioStreamPropertyAvailablePhysicalFormats Config change", buf, 2u);
      }
      uint64_t v20 = *(void *)(a1 + 9120);
      if (v20) {
        (*(void (**)(uint64_t))(*(void *)v20 + 552))(v20);
      }
      goto LABEL_62;
    }
    if (a2 == 1937009955)
    {
      BOOL v21 = a3 != 0;
      uint64_t v22 = (*(uint64_t (**)(void))(**(void **)(a1 + 9120) + 1040))(*(void *)(a1 + 9120));
      (*(void (**)(uint64_t, BOOL, uint64_t))(*(void *)a1 + 1248))(a1, v21, v22);
      sub_4A314(a1);
      uint64_t v23 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = (*(uint64_t (**)(void))(**(void **)(a1 + 9128) + 16))(*(void *)(a1 + 9128));
        strcpy((char *)&v36, "stm#");
        *(_DWORD *)std::string buf = 67109378;
        *(_DWORD *)&uint8_t buf[4] = v24;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = &v36;
        _os_log_impl(&dword_0, v23, OS_LOG_TYPE_DEFAULT, "Object %u:Perform ConfigurationChange on property %{public}s", buf, 0x12u);
      }
      goto LABEL_62;
    }
    if (a2 != 1969779572)
    {
LABEL_33:
      int v18 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR))
      {
        LOBYTE(v36) = HIBYTE(v5);
        BYTE1(v36) = BYTE2(v5);
        BYTE2(v36) = BYTE1(v5);
        *(_WORD *)((char *)&v36 + 3) = v5;
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = &v36;
        _os_log_error_impl(&dword_0, v18, OS_LOG_TYPE_ERROR, "PerformDeviceConfigurationChange on property %{public}s, but we're doing nothing.", buf, 0xCu);
      }
      goto LABEL_62;
    }
    if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 1000))(a1))
    {
      sub_5CEA4(a4);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 9480));
      if (pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 9544), (pthread_mutex_t *)(a1 + 9480), (const timespec *)(a1 + 9592)) == 60&& os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR))
      {
        sub_6B990();
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 9480));
      sub_5CDFC(a4);
      CFStringRef v10 = qword_A1B50;
      if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_58;
      }
      *(_WORD *)std::string buf = 0;
      BOOL v11 = "HFPStereo output performFormatChange IOs all stopped";
    }
    else
    {
      CFStringRef v10 = qword_A1B50;
      if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
LABEL_58:
        sub_56624(a1);
        uint64_t v34 = *(void *)(a1 + 9096);
        if (v34) {
          sub_8D30(v34);
        }
        *(_OWORD *)std::string buf = xmmword_71750;
        *(_OWORD *)&uint8_t buf[16] = xmmword_71760;
        long long v38 = xmmword_71880;
        long long v39 = xmmword_71890;
        long long v40 = xmmword_718A0;
        long long v41 = xmmword_718B0;
        int v13 = **(void (***)(void))(qword_A2350 + 144);
        goto LABEL_61;
      }
      *(_WORD *)std::string buf = 0;
      BOOL v11 = "HFPStereo output performFormatChange IOs already stopped";
    }
    _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, v11, buf, 2u);
    goto LABEL_58;
  }
  if (a2 <= 1702391922)
  {
    if (a2 == 1650549620)
    {
      int v25 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = a3;
        _os_log_impl(&dword_0, v25, OS_LOG_TYPE_DEFAULT, "kBluetoothAudioDevicePropertyAudioContentType Config change %d", buf, 8u);
      }
      uint64_t v26 = *(void *)(a1 + 9120);
      if (v26) {
        (*(void (**)(uint64_t, uint64_t))(*(void *)v26 + 544))(v26, a3);
      }
      goto LABEL_62;
    }
    if (a2 == 1650750576)
    {
      sub_4A13C(a1, *(void *)(a1 + 9256), a3);
      sub_56624(a1);
      uint64_t v12 = *(void *)(a1 + 9096);
      if (v12) {
        sub_8D30(v12);
      }
      *BOOL v7 = 0;
      *(_OWORD *)std::string buf = xmmword_71750;
      *(_OWORD *)&uint8_t buf[16] = xmmword_71760;
      long long v38 = xmmword_71880;
      long long v39 = xmmword_71890;
      long long v40 = xmmword_718A0;
      LODWORD(v41) = 0;
      int v13 = **(void (***)(void))(qword_A2350 + 144);
LABEL_61:
      v13();
      goto LABEL_62;
    }
    goto LABEL_33;
  }
  if (a2 != 1702391923)
  {
    if (a2 == 1718772584)
    {
      int v17 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v17, OS_LOG_TYPE_DEFAULT, "ForceRouteChange step3 PerformConfigChange to switch format", buf, 2u);
      }
      *BOOL v7 = 0;
      sub_56624(a1);
    }
    else if (a2 == 1819569763)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 272))(a1, a3);
      goto LABEL_62;
    }
    goto LABEL_33;
  }
  int v15 = *(unsigned char **)(a1 + 9096);
  if (v15 && v15[192])
  {
    BOOL v16 = *(void *)(a1 + 9256) == 1952539500 && *(unsigned char *)(*(void *)(a1 + 9248) + 272) != 0;
    (*(void (**)(unsigned char *, BOOL))(*(void *)v15 + 576))(v15, v16);
  }
LABEL_62:
  if (v8 != *v7) {
    sub_564D8(a1);
  }
  return 0;
}

unsigned char *sub_564D8(uint64_t a1)
{
  uint64_t v2 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    v3.i32[0] = *(_DWORD *)(a1 + 9256);
    int16x8_t v4 = (int16x8_t)vmovl_u8(v3);
    *(int16x4_t *)v4.i8 = vrev64_s16(*(int16x4_t *)v4.i8);
    *(int8x8_t *)v4.i8 = vmovn_s16(v4);
    __int32 v10 = v4.i32[0];
    char v11 = 0;
    v4.i32[0] = *(_DWORD *)(a1 + 9264);
    int16x8_t v5 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v4.i8);
    *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
    unsigned __int32 v8 = vmovn_s16(v5).u32[0];
    char v9 = 0;
    *(_DWORD *)std::string buf = 136446466;
    int v13 = &v10;
    __int16 v14 = 2082;
    int v15 = &v8;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Post PostRouteChange [%{public}s - %{public}s]", buf, 0x16u);
  }
  id result = *(unsigned char **)(a1 + 9096);
  if (result && result[192])
  {
    BOOL v7 = *(void *)(a1 + 9256) == 1952539500 && *(unsigned char *)(*(void *)(a1 + 9248) + 272) != 0;
    return (unsigned char *)(*(uint64_t (**)(unsigned char *, BOOL))(*(void *)result + 576))(result, v7);
  }
  return result;
}

void sub_56624(uint64_t a1)
{
  uint64_t v2 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    v3.i32[0] = *(_DWORD *)(a1 + 9256);
    int16x8_t v4 = (int16x8_t)vmovl_u8(v3);
    *(int16x4_t *)v4.i8 = vrev64_s16(*(int16x4_t *)v4.i8);
    *(int8x8_t *)v4.i8 = vmovn_s16(v4);
    __int32 v8 = v4.i32[0];
    char v9 = 0;
    v4.i32[0] = *(_DWORD *)(a1 + 9264);
    int16x8_t v5 = (int16x8_t)vmovl_u8(*(uint8x8_t *)v4.i8);
    *(int16x4_t *)v5.i8 = vrev64_s16(*(int16x4_t *)v5.i8);
    unsigned __int32 v6 = vmovn_s16(v5).u32[0];
    char v7 = 0;
    *(_DWORD *)std::string buf = 136446466;
    char v11 = &v8;
    __int16 v12 = 2082;
    int v13 = &v6;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "HFPStereo PostPerformConfigChange [%{public}s - %{public}s]", buf, 0x16u);
  }
  if (*(void *)(a1 + 9096))
  {
    buf[0] = 0;
    if (sub_59E8C(a1, (char *)buf, 1)) {
      (*(void (**)(void, void))(**(void **)(a1 + 9096) + 528))(*(void *)(a1 + 9096), buf[0]);
    }
  }
  *(unsigned char *)(a1 + 9305) = 0;
}

uint64_t sub_56764()
{
  return 0;
}

unsigned char *sub_5676C(uint64_t a1)
{
  id result = *(unsigned char **)(a1 + 9120);
  if (result)
  {
    if (result[192]) {
      return (unsigned char *)(*(uint64_t (**)(void))(*(void *)result + 176))();
    }
  }
  return result;
}

uint64_t sub_567A4(uint64_t a1, uint64_t a2)
{
  int16x8_t v4 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1000))(a1);
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v7 = *(void *)(a1 + 9120);
    if (v7) {
      CFStringRef v8 = (const __CFString *)sub_7904(v7);
    }
    else {
      CFStringRef v8 = @"None";
    }
    int v12 = 134218498;
    uint64_t v13 = v5;
    __int16 v14 = 1024;
    int v15 = v6;
    __int16 v16 = 2114;
    CFStringRef v17 = v8;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: StartIO activeIO:%llu [%d] delegate to current Device  %{public}@", (uint8_t *)&v12, 0x1Cu);
  }
  sub_56A84(a1, 0);
  if (*(void *)(a1 + 9120))
  {
    (*(void (**)(uint64_t))(*(void *)a1 + 1416))(a1);
    if (sub_395B4())
    {
      uint64_t v9 = *(void *)(a1 + 9248);
      if (*(unsigned char *)(v9 + 277) && !*(unsigned char *)(v9 + 145)) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 1320))(a1, 1, 1);
      }
      (*(void (**)(void, uint64_t, uint64_t, void))(**(void **)(a1 + 9120) + 256))(*(void *)(a1 + 9120), 1, 1918989668, 0);
    }
    else if (!sub_56B5C(a1) {
           && (*(unsigned int (**)(void, uint64_t, void, uint64_t))(**(void **)(a1 + 9120) + 256))(*(void *)(a1 + 9120), 1, *(unsigned int *)(a1 + 9264), 1))
    }
    {
      sub_56C1C(a1);
    }
    uint64_t v10 = (*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 9120) + 184))(*(void *)(a1 + 9120), a2);
    sub_56E00(a1);
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      sub_6B9C4();
    }
    uint64_t v10 = 0;
  }
  *(void *)(a1 + 9464) = mach_absolute_time();
  return v10;
}

void sub_56A84(uint64_t a1, int a2)
{
  uint64_t v2 = (unsigned char *)(a1 + 9440);
  if (*(unsigned __int8 *)(a1 + 9440) != a2)
  {
    int16x8_t v4 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = "NO";
      if (a2) {
        uint64_t v5 = "YES";
      }
      int v6 = 136446210;
      uint64_t v7 = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: Output Audio Ongoing : %{public}s", (uint8_t *)&v6, 0xCu);
    }
    *uint64_t v2 = a2;
  }
}

BOOL sub_56B5C(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 9472);
  uint64_t v2 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint8x8_t v3 = "No Follow normal Audio bringup path";
    if (v1 == 2) {
      uint8x8_t v3 = "Yes : Skipping audio Setup on IOStart";
    }
    int v5 = 136446210;
    int v6 = v3;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Out of Band Audio Trigged Status : %{public}s ", (uint8_t *)&v5, 0xCu);
  }
  return v1 == 2;
}

uint64_t sub_56C1C(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9312);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 9312));
  if (*(unsigned char *)(a1 + 9441))
  {
    uint8x8_t v3 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 9080);
      *(_DWORD *)std::string buf = 138543362;
      uint64_t v14 = v4;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "[%{public}@ ] Transport schedule already running", buf, 0xCu);
    }
    return pthread_mutex_unlock(v2);
  }
  else
  {
    pthread_mutex_unlock(v2);
    int v6 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 9080);
      *(_DWORD *)std::string buf = 138543362;
      uint64_t v14 = v7;
      _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "[%{public}@ ] Request block Scheduling transport update", buf, 0xCu);
    }
    int v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v9 = qword_A2350;
    unsigned int v10 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    void v11[2] = sub_59374;
    _DWORD v11[3] = &unk_8D200;
    int v12 = v8;
    return sub_44BA4(v9, v10, v11);
  }
}

void sub_56E00(uint64_t a1)
{
  uint64_t v2 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 9472);
    v4[0] = 67109120;
    v4[1] = v3;
    _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "reset of band audio triggered: Current state %d ", (uint8_t *)v4, 8u);
  }
  *(_DWORD *)(a1 + 9472) = 0;
}

uint64_t sub_56EA8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 1000))(a1);
    int v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v7 = *(void *)(a1 + 9120);
    if (v7) {
      CFStringRef v8 = (const __CFString *)sub_7904(v7);
    }
    else {
      CFStringRef v8 = @"None";
    }
    int v12 = 134218498;
    uint64_t v13 = v5;
    __int16 v14 = 1024;
    int v15 = v6;
    __int16 v16 = 2114;
    CFStringRef v17 = v8;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: StopIO activeIO:%llu [%d] delegate Current Device  %{public}@", (uint8_t *)&v12, 0x1Cu);
  }
  sub_56A84(a1, 0);
  uint64_t v9 = *(unsigned char **)(a1 + 9120);
  if (v9 && v9[192])
  {
    uint64_t v10 = (*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)v9 + 192))(v9, a2);
    if (sub_395B4())
    {
      if (!v10) {
        (*(void (**)(void))(**(void **)(a1 + 9120) + 1488))(*(void *)(a1 + 9120));
      }
    }
    else if ((*(unsigned int (**)(void, void, void, uint64_t))(**(void **)(a1 + 9120) + 256))(*(void *)(a1 + 9120), 0, *(unsigned int *)(a1 + 9264), 1))
    {
      sub_56C1C(a1);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      sub_6B9F8();
    }
    return 0;
  }
  return v10;
}

uint64_t sub_570E8(uint64_t a1, uint64_t a2, int a3, BOOL *a4, unsigned char *a5)
{
  return sub_6904(a1, a3, a4, a5);
}

uint64_t sub_570F8(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == 1919513701) {
    sub_56A84(a1, 1);
  }
  uint64_t v4 = *(unsigned char **)(a1 + 9120);
  if (!v4 || !v4[192]) {
    return 0;
  }
  uint64_t v5 = *(uint64_t (**)(void))(*(void *)v4 + 208);

  return v5();
}

CFIndex sub_571D8(uint64_t a1, int a2)
{
  switch(a2)
  {
    case 1869968496:
      uint64_t v2 = 9200;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
    case 1768845428:
      uint64_t v2 = 9176;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
    case 1735159650:
      uint64_t v2 = 9224;
      return CFArrayGetCount(*(CFArrayRef *)(a1 + v2));
  }
  return 0;
}

uint64_t sub_57248(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result = *(void *)(a1 + 9120);
  if (result)
  {
    long long v6 = *(_OWORD *)(a2 + 16);
    v10[0] = *(_OWORD *)a2;
    v10[1] = v6;
    uint64_t v11 = *(void *)(a2 + 32);
    long long v7 = *(_OWORD *)(a3 + 16);
    v8[0] = *(_OWORD *)a3;
    v8[1] = v7;
    uint64_t v9 = *(void *)(a3 + 32);
    return (*(uint64_t (**)(uint64_t, _OWORD *, _OWORD *, uint64_t, uint64_t))(*(void *)result + 1264))(result, v10, v8, a4, a5);
  }
  return result;
}

BOOL sub_572CC(uint64_t a1, uint64_t a2, double a3, double a4)
{
  BOOL result = 1;
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 9120) + 1256))(*(void *)(a1 + 9120)) & 1) == 0)
  {
    uint64_t v8 = *(void *)(a1 + 9096);
    if (!v8
      || ((*(uint64_t (**)(uint64_t, uint64_t, double, double))(*(void *)v8 + 1256))(v8, a2, a3, a4) & 1) == 0)
    {
      uint64_t v9 = *(void *)(a1 + 9088);
      if (!v9
        || ((*(uint64_t (**)(uint64_t, uint64_t, double, double))(*(void *)v9 + 1256))(v9, a2, a3, a4) & 1) == 0)
      {
        return 0;
      }
    }
  }
  return result;
}

CFIndex sub_573C8(uint64_t a1, int a2, uint64_t a3, unsigned int a4)
{
  int Count = a4;
  switch(a2)
  {
    case 1869968496:
      uint64_t v6 = 9200;
      goto LABEL_7;
    case 1768845428:
      uint64_t v6 = 9176;
      goto LABEL_7;
    case 1735159650:
      uint64_t v6 = 9224;
LABEL_7:
      CFArrayRef v7 = *(const __CFArray **)(a1 + v6);
      goto LABEL_9;
  }
  CFArrayRef v7 = 0;
LABEL_9:
  if (CFArrayGetCount(v7) < a4) {
    int Count = CFArrayGetCount(v7);
  }
  if (Count)
  {
    for (CFIndex i = 0;
          i != Count;
          *(_DWORD *)(a3 + 4 * i++) = (*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 16))(ValueAtIndex))
    {
      uint64_t ValueAtIndex = CFArrayGetValueAtIndex(v7, i);
    }
  }
  return CFArrayGetCount(v7);
}

uint64_t sub_574B8(uint64_t result, uint64_t a2, unsigned int *a3)
{
  if (*a3)
  {
    unsigned int v3 = *(_DWORD *)(result + 9296);
    if (*a3 > v3)
    {
      uint64_t v11 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6BA2C(v11);
      }
      abort();
    }
    uint64_t v4 = *(void **)(result + 9280);
    if (v4 != (void *)(result + 9288))
    {
      unsigned int v5 = 0;
      do
      {
        uint64_t v6 = v4[5];
        uint64_t v7 = a2 + 12 * v5;
        *(void *)uint64_t v7 = *(void *)v6;
        *(_DWORD *)(v7 + 8) = *(_DWORD *)(v6 + 8);
        if (++v5 == *a3) {
          break;
        }
        uint64_t v8 = (void *)v4[1];
        if (v8)
        {
          do
          {
            uint64_t v9 = v8;
            uint64_t v8 = (void *)*v8;
          }
          while (v8);
        }
        else
        {
          do
          {
            uint64_t v9 = (void *)v4[2];
            BOOL v10 = *v9 == (void)v4;
            uint64_t v4 = v9;
          }
          while (!v10);
        }
        uint64_t v4 = v9;
      }
      while (v9 != (void *)(result + 9288));
    }
    *a3 = v3;
  }
  return result;
}

uint64_t sub_5758C(uint64_t a1, int *a2)
{
  if (!*(void *)(a1 + 9096) && !*(void *)(a1 + 9088) && !*(void *)(a1 + 9112)) {
    return 0;
  }
  uint64_t v4 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 9080);
    BOOL v7 = *(unsigned char *)(a1 + 9272) == 0;
    v5.i32[0] = *(_DWORD *)(a1 + 9256);
    int16x8_t v8 = (int16x8_t)vmovl_u8(v5);
    *(int16x4_t *)v8.i8 = vrev64_s16(*(int16x4_t *)v8.i8);
    unsigned __int32 v12 = vmovn_s16(v8).u32[0];
    char v13 = 0;
    if (v7) {
      uint64_t v9 = "No";
    }
    else {
      uint64_t v9 = "Yes";
    }
    *(_DWORD *)std::string buf = 138543874;
    uint64_t v15 = v6;
    __int16 v16 = 2082;
    CFStringRef v17 = v9;
    __int16 v18 = 2082;
    int v19 = &v12;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: [%{public}@ ] Is route change pending ? %{public}s Current profile %{public}s ", buf, 0x20u);
  }
  if (*(unsigned char *)(a1 + 9272)) {
    int v10 = 1953853033;
  }
  else {
    int v10 = *(_DWORD *)(a1 + 9256);
  }
  *a2 = v10;
  return 1;
}

uint64_t sub_576D0(uint64_t a1)
{
  unsigned __int8 v3 = 0;
  uint64_t v1 = *(void *)(a1 + 9096);
  if (v1 && *(unsigned char *)(v1 + 192))
  {
    if (sub_59E8C(a1, (char *)&v3, 1))
    {
      if (v3 > 1u) {
        return 1;
      }
    }
    else if ((*(_DWORD *)(v1 + 9340) - 128) < 3)
    {
      return 1;
    }
  }
  return 0;
}

double sub_57740(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 9120);
  if (!v1) {
    return 0.0;
  }
  (*(void (**)(void))(*(void *)v1 + 784))();
  return result;
}

uint64_t sub_5777C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 9120);
  if (!v2)
  {
    unsigned __int8 v3 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_FAULT)) {
      sub_6BAB0(v3, v4, v5, v6, v7, v8, v9, v10);
    }
    if (sub_5CB00()) {
      abort();
    }
    uint64_t v2 = *(void *)(a1 + 9120);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 792))(v2);
}

uint64_t sub_57804(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 9120);
  if (!v2)
  {
    unsigned __int8 v3 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_FAULT)) {
      sub_6BAB0(v3, v4, v5, v6, v7, v8, v9, v10);
    }
    if (sub_5CB00()) {
      abort();
    }
    uint64_t v2 = *(void *)(a1 + 9120);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 808))(v2);
}

uint64_t sub_5788C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 9120);
  if (!v2)
  {
    unsigned __int8 v3 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_FAULT)) {
      sub_6BAB0(v3, v4, v5, v6, v7, v8, v9, v10);
    }
    if (sub_5CB00()) {
      abort();
    }
    uint64_t v2 = *(void *)(a1 + 9120);
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)v2 + 816))(v2);
}

uint64_t sub_57914(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 9120);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 824))();
  }
  return result;
}

uint64_t sub_5794C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 9120);
  if (!v4)
  {
    uint64_t v5 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_FAULT)) {
      sub_6BAB0(v5, v6, v7, v8, v9, v10, v11, v12);
    }
    if (sub_5CB00()) {
      abort();
    }
    uint64_t v4 = *(void *)(a1 + 9120);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 800))(v4, a2);
}

uint64_t sub_579EC(void *a1, uint64_t a2, float a3)
{
  uint64_t result = a1[1140];
  if (result)
  {
    float v7 = (*(float (**)(uint64_t))(*(void *)result + 920))(result);
    float v8 = v7;
    BOOL v9 = a3 == 0.0;
    BOOL v10 = a3 != 0.0;
    if (v7 == 0.0) {
      BOOL v9 = 0;
    }
    else {
      BOOL v10 = 0;
    }
    char v11 = !v10 && !v9;
    char v12 = v7 == a3 ? 1 : v11;
    (*(void (**)(void, uint64_t, float))(*(void *)a1[1140] + 480))(a1[1140], a2, a3);
    uint64_t result = sub_395B4();
    if ((v12 & 1) == 0)
    {
      if (result)
      {
        char v13 = qword_A1B50;
        if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
        {
          v14[0] = 134218240;
          *(double *)&v14[1] = v8;
          __int16 v15 = 2048;
          double v16 = a3;
          _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "Updating Mute changed %f->%f", (uint8_t *)v14, 0x16u);
        }
        strcpy((char *)v14, "etumptuo");
        BYTE1(v14[2]) = 0;
        HIWORD(v14[2]) = 0;
        return (*(uint64_t (**)(void *, _DWORD *))(*a1 + 248))(a1, v14);
      }
    }
  }
  return result;
}

uint64_t sub_57B9C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 9120);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 488))();
  }
  return result;
}

double sub_57BD4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 9120);
  if (v1)
  {
    uint64_t v2 = *(void (**)(void))(*(void *)v1 + 920);
    v2();
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      sub_6BB28();
    }
    return 0.0;
  }
  return result;
}

float sub_57C64(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 9120);
  if (v1)
  {
    uint64_t v2 = *(void (**)(void))(*(void *)v1 + 936);
    v2();
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      sub_6BB5C();
    }
    return -40.0;
  }
  return result;
}

const void *sub_57CF8(uint64_t a1, void *a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), v6);
    if (![a2 compare:sub_7904((uint64_t)ValueAtIndex)]) {
      break;
    }
    if (v5 == ++v6) {
      return 0;
    }
  }
  return ValueAtIndex;
}

const void *sub_57D7C(uint64_t a1, uint64_t a2)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
  if (Count < 1) {
    return 0;
  }
  CFIndex v5 = Count;
  CFIndex v6 = 0;
  while (1)
  {
    uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), v6);
    if (sub_7C98((uint64_t)ValueAtIndex) == a2) {
      break;
    }
    if (v5 == ++v6) {
      return 0;
    }
  }
  return ValueAtIndex;
}

uint64_t sub_57DFC(uint64_t a1, __int32 *a2)
{
  if (!a2) {
    return 1852797029;
  }
  uint64_t v2 = *(uint64_t (***)(void, void, uint64_t, __int32 *))(qword_A2350 + 144);
  if (v2)
  {
    uint64_t v4 = (*v2)(*(void *)(qword_A2350 + 144), *(unsigned int *)(a1 + 8), 1, a2);
    if (v4)
    {
      CFIndex v5 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_62708(a2, v5, v6);
      }
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_FAULT)) {
      sub_6BB90();
    }
    if (sub_5CB00()) {
      abort();
    }
    return 4294960564;
  }
  return v4;
}

uint64_t sub_57EC8(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 9120);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 712))();
  }
  return result;
}

CFIndex sub_57F00(uint64_t a1)
{
  if (sub_395B4()) {
    return CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
  }
  CFIndex result = *(void *)(a1 + 9120);
  if (result)
  {
    unsigned __int8 v3 = *(uint64_t (**)(void))(*(void *)result + 1208);
    return v3();
  }
  return result;
}

uint64_t sub_57F88(uint64_t a1, uint64_t a2, CFIndex Count)
{
  if (sub_395B4())
  {
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9168)) < Count) {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
    }
    if (Count)
    {
      CFIndex v6 = 0;
      float v7 = (double *)(a2 + 48);
      do
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), v6);
        if (ValueAtIndex)
        {
          BOOL v9 = ValueAtIndex;
          (*(void (**)(_OWORD *__return_ptr))(*(void *)ValueAtIndex + 800))(v14);
          long long v10 = v14[1];
          *((_OWORD *)v7 - 3) = v14[0];
          *((_OWORD *)v7 - 2) = v10;
          *((void *)v7 - 2) = v15;
          *(v7 - 1) = (*(double (**)(const void *))(*(void *)v9 + 784))(v9);
          *float v7 = (*(double (**)(const void *))(*(void *)v9 + 784))(v9);
        }
        ++v6;
        v7 += 7;
      }
      while (Count != v6);
    }
    return Count;
  }
  uint64_t v11 = *(void *)(a1 + 9120);
  if (!v11) {
    return 0;
  }
  char v12 = *(uint64_t (**)(void))(*(void *)v11 + 1216);

  return v12();
}

CFIndex sub_58168(uint64_t a1)
{
  if (sub_395B4()) {
    return CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
  }
  CFIndex result = *(void *)(a1 + 9120);
  if (result)
  {
    unsigned __int8 v3 = *(uint64_t (**)(void))(*(void *)result + 1224);
    return v3();
  }
  return result;
}

uint64_t sub_581E8(uint64_t a1, uint64_t a2, CFIndex Count)
{
  if (sub_395B4())
  {
    if (CFArrayGetCount(*(CFArrayRef *)(a1 + 9168)) < Count) {
      CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
    }
    if (Count)
    {
      CFIndex v6 = 0;
      float v7 = (double *)(a2 + 8);
      do
      {
        uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), v6);
        if (ValueAtIndex)
        {
          BOOL v9 = ValueAtIndex;
          *(v7 - 1) = (*(double (**)(const void *))(*(void *)ValueAtIndex + 784))(ValueAtIndex);
          *float v7 = (*(double (**)(const void *))(*(void *)v9 + 784))(v9);
        }
        ++v6;
        v7 += 2;
      }
      while (Count != v6);
    }
    return Count;
  }
  uint64_t v10 = *(void *)(a1 + 9120);
  if (!v10) {
    return 0;
  }
  uint64_t v11 = *(uint64_t (**)(void))(*(void *)v10 + 1232);

  return v11();
}

uint64_t sub_58350(uint64_t a1)
{
  return sub_245C8(*(void *)(a1 + 9248));
}

BOOL sub_58358(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 9168));
  if (Count < 1) {
    return 0;
  }
  CFIndex v3 = Count;
  uint64_t ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), 0);
  if ((*(uint64_t (**)(const void *))(*(void *)ValueAtIndex + 992))(ValueAtIndex)) {
    return 1;
  }
  CFIndex v6 = 1;
  do
  {
    CFIndex v7 = v6;
    if (v3 == v6) {
      break;
    }
    float v8 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 9168), v6);
    int v9 = (*(uint64_t (**)(const void *))(*(void *)v8 + 992))(v8);
    CFIndex v6 = v7 + 1;
  }
  while (!v9);
  return v7 < v3;
}

uint64_t sub_58438(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 9248) + 148);
}

uint64_t sub_58444(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 9248) + 152);
}

void sub_58450(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 9120);
  if (v2) {
    sub_8A94(v2, *(float *)(*(void *)(a1 + 9248) + 280));
  }
}

void sub_5846C(uint64_t a1, float a2)
{
}

CFIndex sub_58474(uint64_t a1, const void *a2)
{
  return sub_26318(*(void *)(a1 + 9248), a2);
}

void sub_5847C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 9120);
  if (v1) {
    sub_8AA4(v1);
  }
}

uint64_t sub_58498(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 9248) + 145);
}

void sub_584A4(void *a1, BOOL a2, int a3)
{
  uint64_t v3 = a1[1156];
  if (*(unsigned char *)(v3 + 277))
  {
    *(unsigned char *)(v3 + 145) = a2;
    if (a3)
    {
      strcpy((char *)buf, "caobbolg");
      buf[9] = 0;
      *(_WORD *)&buf[10] = 0;
      (*(void (**)(void *, uint8_t *))(*a1 + 248))(a1, buf);
      CFIndex v6 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex v7 = "False";
        if (a2) {
          CFIndex v7 = "True";
        }
        *(_DWORD *)std::string buf = 136446210;
        *(void *)&uint8_t buf[4] = v7;
        _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Notify Mx ownership Changed to %{public}s", buf, 0xCu);
      }
    }
    uint64_t v8 = a1[1136];
    if (v8)
    {
      if (*(unsigned char *)(v8 + 192))
      {
        (*(void (**)(void **__return_ptr, void *))(*a1 + 832))(__p, a1);
        sub_8930(v8, __p, a2);
        if (v13 < 0) {
          operator delete(__p[0]);
        }
      }
    }
    uint64_t v9 = a1[1137];
    if (v9 && *(unsigned char *)(v9 + 192))
    {
      (*(void (**)(void **__return_ptr, void *))(*a1 + 832))(v10, a1);
      sub_8930(v9, v10, a2);
      if (v11 < 0) {
        operator delete(v10[0]);
      }
    }
  }
}

void sub_58680(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a14 < 0) {
    operator delete(a9);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_586BC(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 9248) + 144);
}

uint64_t sub_586C8(uint64_t result, char a2)
{
  *(unsigned char *)(*(void *)(result + 9248) + 144) = a2;
  return result;
}

uint64_t sub_586D4(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 9248) + 156);
}

uint64_t sub_586E0(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 9248) + 172);
}

uint64_t sub_586EC(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 9248) + 176);
}

void sub_586F8(void *a1, int a2)
{
  uint64_t v3 = a1[1156];
  if (*(_DWORD *)(v3 + 184) != a2)
  {
    sub_24A64(v3, a2);
    CFIndex v5 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      sub_B700(*(_DWORD *)(a1[1156] + 184), __p);
      int v6 = v11;
      CFIndex v7 = (void **)__p[0];
      int v8 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
      uint64_t v9 = __p;
      *(_DWORD *)std::string buf = 136446722;
      if (v6 < 0) {
        uint64_t v9 = v7;
      }
      char v13 = v9;
      __int16 v14 = 1024;
      int v15 = a2;
      __int16 v16 = 1024;
      int v17 = v8;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "MicMode set to %{public}s (%d) for mAudioObjectID %d", buf, 0x18u);
      if (v11 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

void sub_58834(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_58858(uint64_t a1)
{
  return *(unsigned int *)(*(void *)(a1 + 9248) + 60);
}

void sub_58864(void *a1, int a2)
{
  uint64_t v2 = a1[1156];
  if (*(_DWORD *)(v2 + 60) != a2)
  {
    *(_DWORD *)(v2 + 60) = a2;
    uint64_t v4 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
      int v6 = *(_DWORD *)(a1[1156] + 60);
      v7[0] = 67109376;
      v7[1] = v5;
      __int16 v8 = 1024;
      int v9 = v6;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Local stream state of mAudioObjectID %d changed to %d", (uint8_t *)v7, 0xEu);
    }
  }
}

uint64_t sub_58954(unsigned char *a1)
{
  a1[9273] = 1;
  uint64_t v2 = 0x676C6F6266726368;
  int v3 = 0;
  return (*(uint64_t (**)(unsigned char *, uint64_t *))(*(void *)a1 + 248))(a1, &v2);
}

uint64_t sub_589B4(uint64_t result)
{
  if (*(unsigned char *)(*(void *)(result + 9248) + 230))
  {
    uint64_t v1 = (void *)result;
    uint64_t v2 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = v1[1135];
      v4[0] = 138543362;
      *(void *)&v4[1] = v3;
      _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "Notify Spatial Audio Mode via NowPlaying App changed: %{public}@", (uint8_t *)v4, 0xCu);
    }
    strcpy((char *)v4, "dmpsbolg");
    BYTE1(v4[2]) = 0;
    HIWORD(v4[2]) = 0;
    return (*(uint64_t (**)(void *, _DWORD *))(*v1 + 248))(v1, v4);
  }
  return result;
}

void sub_58AA0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned char **)(a1 + 9120);
  if (v4 && v4[192] && *(unsigned char *)(*(void *)(a1 + 9248) + 228))
  {
    int v5 = *(void (**)(void))(*(void *)v4 + 1128);
    v5();
  }
  else
  {
    int v6 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
      sub_6BBD0(a1, a2, v6);
    }
  }
}

id sub_58B60(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) getPersonalizedVolumeDevice:*(void *)(a1 + 40)];
  if (result)
  {
    uint64_t v3 = *(void *)(a1 + 48);
    return [result NotifyManualVolumeChanged:v3 shouldUpdateBuds:0];
  }
  return result;
}

void *sub_58BB4@<X0>(void *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = result[1156];
  if (*(char *)(v2 + 31) < 0) {
    return sub_B9AC((unsigned char *)a2, *(void **)(v2 + 8), *(void *)(v2 + 16));
  }
  long long v3 = *(_OWORD *)(v2 + 8);
  *(void *)(a2 + 16) = *(void *)(v2 + 24);
  *(_OWORD *)a2 = v3;
  return result;
}

uint64_t sub_58BE0(uint64_t a1)
{
  return *(unsigned __int8 *)(*(void *)(a1 + 9248) + 277);
}

uint64_t sub_58BEC(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 240))(a1, 1937009955, a2);
}

uint64_t sub_58C1C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 9120) + 1248))();
}

uint64_t sub_58C4C(uint64_t a1, int a2, int a3)
{
  if (sub_395B4())
  {
    return (a2 == 1735159650 || a2 == 1869968496 || a2 == 1768845428) && a3 == 0;
  }
  else
  {
    CFIndex v7 = *(uint64_t (**)(void))(**(void **)(a1 + 9120) + 1272);
    return v7();
  }
}

uint64_t sub_58D18(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v32[0] = 0;
  v32[1] = 0;
  sub_5CDCC((uint64_t)v32, a1 + 552);
  uint64_t v6 = *(void *)(a1 + 9256);
  if (v6 == a2 && (uint64_t v7 = *(void *)(a1 + 9264), v7 == a3))
  {
    *(unsigned char *)(a1 + 9272) = 0;
    __int16 v8 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 9080);
      char v27 = BYTE3(v6);
      char v28 = BYTE2(v6);
      char v29 = BYTE1(v6);
      char v30 = v6;
      char v31 = 0;
      char v23 = BYTE3(a2);
      char v24 = BYTE2(a2);
      char v25 = BYTE1(a2);
      __int16 v26 = a2;
      LOBYTE(v21) = BYTE3(v7);
      BYTE1(v21) = BYTE2(v7);
      BYTE2(v21) = BYTE1(v7);
      HIBYTE(v21) = v7;
      char v22 = 0;
      char v16 = BYTE3(a3);
      char v17 = BYTE2(a3);
      char v18 = BYTE1(a3);
      char v19 = a3;
      char v20 = 0;
      *(_DWORD *)std::string buf = 138544386;
      *(void *)&uint8_t buf[4] = v9;
      __int16 v34 = 2082;
      int v35 = &v27;
      __int16 v36 = 2082;
      double v37 = &v23;
      __int16 v38 = 2082;
      long long v39 = &v21;
      __int16 v40 = 2082;
      long long v41 = &v16;
      _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: No profile/reason change [%{public}@ ] , profile %{public}s => %{public}s reason %{public}s = > %{public}s ", buf, 0x34u);
    }
    sub_564D8(a1);
    strcpy(buf, "pcvabolg");
    buf[9] = 0;
    *(_WORD *)&buf[10] = 0;
    (*(void (**)(uint64_t, unsigned char *))(*(void *)a1 + 248))(a1, buf);
  }
  else
  {
    uint64_t v10 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 9080);
      char v27 = BYTE3(v6);
      char v28 = BYTE2(v6);
      char v29 = BYTE1(v6);
      char v30 = v6;
      char v31 = 0;
      char v23 = BYTE3(a2);
      char v24 = BYTE2(a2);
      char v25 = BYTE1(a2);
      __int16 v26 = a2;
      v11.i32[0] = *(_DWORD *)(a1 + 9264);
      int16x8_t v13 = (int16x8_t)vmovl_u8(v11);
      *(int16x4_t *)v13.i8 = vrev64_s16(*(int16x4_t *)v13.i8);
      unsigned __int32 v21 = vmovn_s16(v13).u32[0];
      char v22 = 0;
      char v16 = BYTE3(a3);
      char v17 = BYTE2(a3);
      char v18 = BYTE1(a3);
      char v19 = a3;
      char v20 = 0;
      *(_DWORD *)std::string buf = 138544386;
      *(void *)&uint8_t buf[4] = v12;
      __int16 v34 = 2082;
      int v35 = &v27;
      __int16 v36 = 2082;
      double v37 = &v23;
      __int16 v38 = 2082;
      long long v39 = &v21;
      __int16 v40 = 2082;
      long long v41 = &v16;
      _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "BTUnifiedAudioDevice: [%{public}@ ] Perform Route change, profile %{public}s => %{public}s reason %{public}s = > %{public}s ", buf, 0x34u);
    }
    if (*(void *)(a1 + 9096) || *(void *)(a1 + 9088) || *(void *)(a1 + 9112))
    {
      uint64_t v14 = *(void *)(a1 + 9256);
      if (v14 == a2)
      {
        (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)a1 + 1376))(a1, a2, *(unsigned int *)(a1 + 9264), a3);
      }
      else
      {
        (*(void (**)(uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 1368))(a1, v14, a2, *(unsigned int *)(a1 + 9264));
        *(void *)(a1 + 9264) = a3;
        sub_49FBC((_DWORD *)a1, a2);
      }
    }
  }
  return sub_5CF10(v32);
}

void sub_590B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, char a13)
{
}

uint64_t sub_590D4(uint64_t *a1, const __CFString *a2, int a3, int a4)
{
  sub_2B1B4(a1[1156], a2, a3, a4);
  uint64_t v6 = 0x676C6F6273706D64;
  int v7 = 0;
  (*(void (**)(uint64_t *, uint64_t *))(*a1 + 248))(a1, &v6);
  uint64_t v6 = 0x676C6F6273706366;
  int v7 = 0;
  return (*(uint64_t (**)(uint64_t *, uint64_t *))(*a1 + 248))(a1, &v6);
}

uint64_t sub_5917C(uint64_t a1)
{
  uint64_t v2 = (pthread_mutex_t *)(a1 + 9312);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 9312));
  uint64_t v3 = *(void *)(a1 + 9120);
  if (v3 && (*(unsigned int (**)(uint64_t))(*(void *)v3 + 1184))(v3))
  {
    *(unsigned char *)(a1 + 9441) = 1;
    uint64_t v4 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 9080);
      v10[0] = 138543362;
      *(void *)&v10[1] = v5;
      _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "[%{public}@ ] Wait for transport update", (uint8_t *)v10, 0xCu);
    }
    if (pthread_cond_timedwait_relative_np((pthread_cond_t *)(a1 + 9376), v2, (const timespec *)(a1 + 9424)) == 60)
    {
      uint64_t v6 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR)) {
        sub_6BC84(a1, v6);
      }
    }
    *(unsigned char *)(a1 + 9441) = 0;
  }
  if (*(_DWORD *)(a1 + 9472) == 1) {
    *(_DWORD *)(a1 + 9472) = 2;
  }
  strcpy((char *)v10, "dbobbolg");
  BYTE1(v10[2]) = 0;
  HIWORD(v10[2]) = 0;
  (*(void (**)(uint64_t, _DWORD *))(*(void *)a1 + 248))(a1, v10);
  int v7 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 9080);
    v10[0] = 138543362;
    *(void *)&v10[1] = v8;
    _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "[%{public}@ ] transport Update Completed", (uint8_t *)v10, 0xCu);
  }
  return pthread_mutex_unlock(v2);
}

void sub_59374(uint64_t a1)
{
  uint64_t v1 = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 32));
  if (v1)
  {
    sub_5917C((uint64_t)v1);
  }
  else
  {
    uint64_t v2 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v3 = 0;
      _os_log_impl(&dword_0, v2, OS_LOG_TYPE_DEFAULT, "transport update dispatched after disconnection", v3, 2u);
    }
  }
}

uint64_t sub_59414(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = a4;
  uint64_t v6 = *(void *)(a1 + 9120);
  if (v6)
  {
    char v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v6 + 1376))(v6, a2, a3, a4);
    *(void *)(a1 + 9264) = v4;
    if (v7) {
      return 1;
    }
  }
  else
  {
    *(void *)(a1 + 9264) = a4;
  }
  *(unsigned char *)(a1 + 9272) = 0;
  sub_564D8(a1);
  uint64_t v9 = 0x676C6F6261766370;
  int v10 = 0;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)a1 + 248))(a1, &v9);
  return 1;
}

BOOL sub_594E0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 9120);
  if (v1 && (*(unsigned int (**)(void))(*(void *)v1 + 1368))(*(void *)(a1 + 9120))) {
    sub_56C1C(a1);
  }
  return v1 != 0;
}

uint64_t sub_5954C(void *a1, uint64_t a2, uint64_t a3)
{
  int v3 = a3;
  int v4 = a2;
  if (*(unsigned char *)(a1[1156] + 222))
  {
    uint64_t v6 = a1[1140];
    if (v6) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 1392))(v6, a2, a3);
    }
    return 1;
  }
  char v7 = (unsigned char *)a1[1137];
  if (!v7 || !v7[192] || !(*(unsigned int (**)(unsigned char *))(*(void *)v7 + 1168))(v7)) {
    return 1;
  }
  if (v4 != 1953719151 && v3 != 1919183219)
  {
    uint64_t v8 = qword_A1B50;
    if (!os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    if (*(unsigned char *)(a1[1137] + 192)) {
      uint64_t v9 = a1[1137];
    }
    else {
      uint64_t v9 = 0;
    }
    int v10 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 1168))(v9);
    uint8x8_t v11 = "idle";
    if (v10) {
      uint8x8_t v11 = "active";
    }
    int v18 = 136315138;
    char v19 = v11;
    uint64_t v12 = "Route changing in while eSCO is active, transport %s";
    goto LABEL_16;
  }
  if (v4 != 1953719151 || v3 != 1936090482 || !sub_56B5C((uint64_t)a1)) {
    return 1;
  }
  uint64_t v14 = *(unsigned char *)(a1[1137] + 192) ? (_DWORD *)a1[1137] : 0;
  if (v14[2335] == v14[2332]) {
    return 1;
  }
  uint64_t v8 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    int v16 = (*(uint64_t (**)(_DWORD *))(*(void *)v14 + 1168))(v14);
    char v17 = "idle";
    if (v16) {
      char v17 = "active";
    }
    int v18 = 136315138;
    char v19 = v17;
    uint64_t v12 = "Route changing update OoB link, transport %s";
LABEL_16:
    _os_log_impl(&dword_0, v8, OS_LOG_TYPE_DEFAULT, v12, (uint8_t *)&v18, 0xCu);
  }
LABEL_17:
  if (*(unsigned char *)(a1[1137] + 192)) {
    uint64_t v13 = a1[1137];
  }
  else {
    uint64_t v13 = 0;
  }
  if ((*(unsigned int (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)v13 + 256))(v13, 0, 1918989668, 1))
  {
    sub_56C1C((uint64_t)a1);
  }
  return 1;
}

void sub_59824(uint64_t a1)
{
  uint64_t v2 = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 32));
  if (v2)
  {
    uint64_t v3 = *(unsigned int *)(a1 + 36);
    uint64_t v4 = *(unsigned int *)(a1 + 40);
    sub_58D18((uint64_t)v2, v3, v4);
  }
  else
  {
    uint64_t v5 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v6 = 0;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "transport update dispatched after disconnection", v6, 2u);
    }
  }
}

uint64_t sub_598C8(uint64_t a1, int a2, uint64_t a3)
{
  unsigned int v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  _DWORD v7[2] = sub_59BC8;
  uint64_t v7[3] = &unk_8FB70;
  unsigned int v8 = v5;
  int v9 = a2;
  v7[4] = a3;
  return sub_44BA4(qword_A2350, v5, v7);
}

uint64_t sub_5997C(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 9120);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 1160))();
  }
  return result;
}

uint64_t sub_599B4(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 9120);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 1456))();
  }
  return result;
}

uint64_t sub_599EC(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 9120);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 272))();
  }
  return result;
}

void sub_59A24(uint64_t a1, int a2, unsigned int a3, uint64_t *a4)
{
  if (*(_DWORD *)a4 == 1651795567)
  {
    uint64_t v16 = *a4;
    int v17 = *((_DWORD *)a4 + 2);
    char v7 = sub_455A8(qword_A2350, a3);
    if (v7)
    {
      unsigned int v8 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, a2, 0x80000000uLL, v7);
      if (v8)
      {
        int v9 = v8;
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_59B78;
        handler[3] = &unk_8FBC0;
        unsigned int v12 = a3;
        uint64_t v13 = v16;
        int v14 = v17;
        int v15 = a2;
        handler[4] = v8;
        void handler[5] = a1;
        dispatch_source_set_event_handler(v8, handler);
        v10[0] = _NSConcreteStackBlock;
        v10[1] = 3221225472;
        _OWORD v10[2] = sub_59BC0;
        v10[3] = &unk_8DC00;
        v10[4] = v9;
        dispatch_source_set_cancel_handler(v9, v10);
        dispatch_resume(v9);
      }
    }
  }
}

void sub_59B78(uint64_t a1)
{
  sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 48));
  uint64_t v2 = *(NSObject **)(a1 + 32);

  dispatch_source_cancel(v2);
}

void sub_59BC0(uint64_t a1)
{
}

void sub_59BC8(uint64_t a1)
{
  uint64_t v1 = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 40));
  if (v1)
  {
    uint64_t v2 = *(void (**)(void))(*v1 + 240);
    v2();
  }
  else
  {
    uint64_t v3 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v4 = 0;
      _os_log_impl(&dword_0, v3, OS_LOG_TYPE_DEFAULT, "Update dispatched after disconnection", v4, 2u);
    }
  }
}

void sub_59C90(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 9248);
  if (*(unsigned __int8 *)(v2 + 221) != a2)
  {
    *(unsigned char *)(v2 + 221) = a2;
    if (_os_feature_enabled_impl())
    {
      uint64_t v5 = *(void *)(a1 + 9096);
      if (v5)
      {
        if (*(unsigned char *)(v5 + 192) && sub_5CAF8())
        {
          uint64_t v6 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v8 = "disabled";
            v7.i32[0] = *(_DWORD *)(a1 + 9256);
            int16x8_t v9 = (int16x8_t)vmovl_u8(v7);
            *(int16x4_t *)v9.i8 = vrev64_s16(*(int16x4_t *)v9.i8);
            unsigned __int32 v13 = vmovn_s16(v9).u32[0];
            char v14 = 0;
            if (a2) {
              unsigned int v8 = "enabled";
            }
            *(_DWORD *)std::string buf = 136315394;
            *(void *)&uint8_t buf[4] = v8;
            __int16 v16 = 2080;
            int v17 = &v13;
            _os_log_impl(&dword_0, v6, OS_LOG_TYPE_DEFAULT, "Low Latency Game ForceRouteChange check, game %s, currentProfile %s", buf, 0x16u);
          }
          sub_5283C(a1);
          if (*(void *)(a1 + 9256) == 1953719151)
          {
            LOBYTE(v13) = 0;
            int v10 = sub_59E8C(a1, (char *)&v13, 1);
            if (a2)
            {
              int v11 = v13 == 4 ? v10 : 0;
              if (v11 == 1)
              {
                unsigned int v12 = qword_A1B50;
                if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)std::string buf = 0;
                  _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "ForceRouteChange step1 notify VA", buf, 2u);
                }
                *(unsigned char *)(a1 + 9273) = 1;
                strcpy(buf, "hcrfbolg");
                buf[9] = 0;
                *(_WORD *)&buf[10] = 0;
                (*(void (**)(uint64_t, unsigned char *))(*(void *)a1 + 248))(a1, buf);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t sub_59E8C(uint64_t a1, char *a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 9096);
  if (v3 && *(unsigned char *)(v3 + 192))
  {
    int v4 = *(unsigned __int8 *)(a1 + 9305);
    switch(*(unsigned char *)(a1 + 9305))
    {
      case 1:
        int v6 = *(_DWORD *)(v3 + 9340);
        if ((v6 | 0x100) == 0x100) {
          goto LABEL_17;
        }
        if (a3)
        {
          uint8x8_t v7 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            int v19 = 67109120;
            int v20 = v6;
            _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "HFPStereo need Mono, currentCodec %u", (uint8_t *)&v19, 8u);
          }
        }
        uint64_t result = 1;
        if (a2) {
          *a2 = 1;
        }
        return result;
      case 2:
        int v9 = *(_DWORD *)(v3 + 9340);
        if (v9 == 128) {
          goto LABEL_17;
        }
        if (a3)
        {
          int v10 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            int v19 = 67109120;
            int v20 = v9;
            _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "HFPStereo need Low Stereo, currentCodec %u", (uint8_t *)&v19, 8u);
          }
        }
        if (!a2) {
          return 1;
        }
        char v11 = 2;
        goto LABEL_32;
      case 3:
        int v12 = *(_DWORD *)(v3 + 9340);
        if (v12 == 129) {
          goto LABEL_17;
        }
        if (a3)
        {
          int v18 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            int v19 = 67109120;
            int v20 = v12;
            _os_log_impl(&dword_0, v18, OS_LOG_TYPE_DEFAULT, "HFPStereo need High Stereo, currentCodec %u", (uint8_t *)&v19, 8u);
          }
        }
        if (!a2) {
          return 1;
        }
        char v11 = 3;
LABEL_32:
        *a2 = v11;
        return 1;
      case 4:
        if (a3)
        {
          __int16 v16 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            int v17 = *(_DWORD *)(v3 + 9340);
            int v19 = 67109120;
            int v20 = v17;
            _os_log_impl(&dword_0, v16, OS_LOG_TYPE_DEFAULT, "HFPStereo need HAoS, currentCodec %u", (uint8_t *)&v19, 8u);
          }
        }
        if (!a2) {
          return 1;
        }
        char v11 = 4;
        goto LABEL_32;
      default:
LABEL_17:
        if (!a3) {
          return 0;
        }
        unsigned __int32 v13 = qword_A1B50;
        BOOL v14 = os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (!v14) {
          return result;
        }
        int v15 = *(_DWORD *)(v3 + 9340);
        int v19 = 67109376;
        int v20 = v4;
        __int16 v21 = 1024;
        int v22 = v15;
        _os_log_impl(&dword_0, v13, OS_LOG_TYPE_DEFAULT, "HFPStereo no HFPStereo pending, pendingConfig %u, currentCodec %u", (uint8_t *)&v19, 0xEu);
        break;
    }
  }
  return 0;
}

unsigned char *sub_5A150(void *a1, uint64_t a2)
{
  int v4 = qword_A1B50;
  if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = a1[1135];
    v20[0] = BYTE3(a2);
    v20[1] = BYTE2(a2);
    void v20[2] = BYTE1(a2);
    v20[3] = a2;
    void v20[4] = 0;
    *(_DWORD *)std::string buf = 138543618;
    *(void *)&uint8_t buf[4] = v5;
    __int16 v22 = 2080;
    char v23 = v20;
    _os_log_impl(&dword_0, v4, OS_LOG_TYPE_DEFAULT, "Post Publish UnifiedAudioDevice : %{public}@, %s", buf, 0x16u);
  }
  (*(void (**)(void *, void, void))(*a1 + 1320))(a1, *(unsigned __int8 *)(a1[1156] + 145), 0);
  uint64_t v6 = a1[1137];
  if (v6 && *(unsigned char *)(v6 + 192))
  {
    if (sub_395B4())
    {
      uint64_t v7 = a1[1137];
      if (v7)
      {
        if (*(unsigned char *)(v7 + 192))
        {
          uint64_t v8 = a1[1156];
          if (*(_DWORD *)(v8 + 244)) {
            sub_25AB4((unsigned char *)v8, 1);
          }
        }
      }
    }
    else if (sub_5CAF8())
    {
      if (a2 == 1953719151)
      {
        sub_5283C((uint64_t)a1);
        buf[0] = 0;
        if (sub_59E8C((uint64_t)a1, buf, 1))
        {
          if (*(unsigned char *)(a1[1137] + 192)) {
            uint64_t v9 = a1[1137];
          }
          else {
            uint64_t v9 = 0;
          }
          (*(void (**)(uint64_t, void))(*(void *)v9 + 528))(v9, buf[0]);
        }
        else if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_ERROR))
        {
          sub_6BD00();
        }
      }
    }
    else if (sub_395B4())
    {
      uint64_t v10 = a1[1137];
      if (v10)
      {
        if (*(unsigned char *)(v10 + 192) && *(_DWORD *)(a1[1156] + 244))
        {
          sub_5283C((uint64_t)a1);
          sub_25AB4((unsigned char *)a1[1156], 1);
        }
      }
    }
  }
  if (*(unsigned char *)(a1[1156] + 250) && !a1[1138])
  {
    char v11 = +[BTAudioSmartRouteManager sharedInstance];
    id v12 = objc_alloc((Class)NSString);
    (*(void (**)(unsigned char *__return_ptr, void *))(*a1 + 832))(buf, a1);
    if (v24 >= 0) {
      unsigned __int32 v13 = buf;
    }
    else {
      unsigned __int32 v13 = *(unsigned char **)buf;
    }
    id v14 = [v12 initWithUTF8String:v13];
    if (v24 < 0) {
      operator delete(*(void **)buf);
    }
    int v15 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)std::string buf = 138412290;
      *(void *)&uint8_t buf[4] = v14;
      _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, "Register with Smart Route Managet with BDADDR: %@", buf, 0xCu);
    }
    a1[1138] = [(BTAudioSmartRouteManager *)v11 registerDevice:(*(uint64_t (**)(void *))(*a1 + 16))(a1) deviceAddr:v14];
  }
  if (a2 == 1952539500)
  {
    int v18 = (unsigned char *)a1[1136];
    if (v18)
    {
      if (v18[192])
      {
        (*(void (**)(unsigned char *))(*(void *)v18 + 560))(v18);
        if (*(unsigned char *)(a1[1156] + 230))
        {
          strcpy(buf, "cathbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
          strcpy(buf, "tsthbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
          strcpy(buf, "vathbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
          strcpy(buf, "dmpsbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
          strcpy(buf, "shpsbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
          strcpy(buf, "vapsbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
          strcpy(buf, "ofpsbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
          strcpy(buf, "vspsbolg");
          buf[9] = 0;
          *(_WORD *)&buf[10] = 0;
          (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
        }
      }
    }
  }
  else if (a2 == 1953719151)
  {
    uint64_t result = (unsigned char *)a1[1137];
    if (!result) {
      return result;
    }
    if (result[192])
    {
      BOOL v17 = a1[1157] == 1952539500 && *(unsigned char *)(a1[1156] + 272) != 0;
      (*(void (**)(unsigned char *, BOOL))(*(void *)result + 576))(result, v17);
      if (*(unsigned char *)(a1[1137] + 192)) {
        uint64_t v19 = a1[1137];
      }
      else {
        uint64_t v19 = 0;
      }
      (*(void (**)(uint64_t))(*(void *)v19 + 968))(v19);
    }
  }
  uint64_t result = (unsigned char *)a1[1137];
  if (result && result[192] && *(_DWORD *)(a1[1156] + 224) == 1) {
    return (unsigned char *)(*(uint64_t (**)(unsigned char *, uint64_t))(*(void *)result + 528))(result, 4);
  }
  return result;
}

void sub_5A7E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

unsigned char *sub_5A80C(void *a1)
{
  unsigned int v2 = *(unsigned __int8 *)(a1[1156] + 360);
  uint64_t v3 = a1[1157];
  if (v3 != 1952539500)
  {
    if (v3 == 1953719151 && (*(unsigned int (**)(void *))(*a1 + 992))(a1) && v2 < 6) {
      return (unsigned char *)((0x34u >> v2) & 1);
    }
    return 0;
  }
  uint64_t result = (unsigned char *)a1[1136];
  if (!result) {
    return result;
  }
  if (!result[192]) {
    return 0;
  }
  int v6 = (*(uint64_t (**)(unsigned char *))(*(void *)result + 648))(result);
  uint64_t result = (unsigned char *)(*(uint64_t (**)(void *))(*a1 + 992))(a1);
  if (result)
  {
    uint64_t result = (unsigned char *)(&dword_0 + 1);
    if (v2 > 5 || ((1 << v2) & 0x34) == 0) {
      return (unsigned char *)(v6 == 6);
    }
  }
  return result;
}

uint64_t sub_5A94C(void *a1)
{
  uint64_t v2 = a1[1156];
  int v3 = (*(uint64_t (**)(void *))(*a1 + 992))(a1);
  sub_2C0A0(v2, v3);
  uint64_t v4 = a1[1136];
  if (v4 && *(unsigned char *)(v4 + 192))
  {
    uint64_t v5 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v6 = sub_5A80C(a1);
      int v7 = (*(uint64_t (**)(void *))(*a1 + 992))(a1);
      *(_DWORD *)std::string buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v6;
      *(_WORD *)&uint8_t buf[8] = 1024;
      int v17 = v7;
      _os_log_impl(&dword_0, v5, OS_LOG_TYPE_DEFAULT, "Setting Spatial Active: %d Active IO = %d", buf, 0xEu);
    }
    unsigned __int8 v8 = sub_5A80C(a1);
    unsigned int v9 = (*(uint64_t (**)(void *))(*a1 + 16))(a1);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    void v13[2] = sub_5AC18;
    unsigned char v13[3] = &unk_8FBE0;
    unsigned int v14 = v9;
    unsigned __int8 v15 = v8;
    sub_44BA4(qword_A2350, v9, v13);
  }
  else
  {
    uint64_t v10 = qword_A1B50;
    if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = (*(uint64_t (**)(void *))(*a1 + 992))(a1);
      *(_DWORD *)std::string buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v11;
      _os_log_impl(&dword_0, v10, OS_LOG_TYPE_DEFAULT, "Whether Spatial is Active couldn't be determined. Active IO = %d", buf, 8u);
    }
  }
  strcpy(buf, "cnpsbolg");
  buf[9] = 0;
  LOWORD(v17) = 0;
  (*(void (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
  strcpy(buf, "ifpsbolg");
  buf[9] = 0;
  LOWORD(v17) = 0;
  return (*(uint64_t (**)(void *, unsigned char *))(*a1 + 248))(a1, buf);
}

void *sub_5AC18(uint64_t a1)
{
  uint64_t result = sub_44C8C(qword_A2350, *(_DWORD *)(a1 + 32));
  if (result)
  {
    uint64_t result = (void *)result[1136];
    if (result)
    {
      if (*((unsigned char *)result + 192))
      {
        uint64_t v2 = *(uint64_t (**)(void))(*result + 720);
        return (void *)v2();
      }
    }
  }
  return result;
}

uint64_t sub_5ACA8(uint64_t result)
{
  if (*(unsigned char *)(*(void *)(result + 9248) + 222))
  {
    uint64_t result = *(void *)(result + 9120);
    if (result)
    {
      if (*(unsigned char *)(result + 192)) {
        return (*(uint64_t (**)(void))(*(void *)result + 1416))();
      }
    }
  }
  return result;
}

uint64_t sub_5ACF4(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t result = sub_395B4();
  if (result)
  {
    if (*(unsigned char *)(*(void *)(a1 + 9248) + 472)) {
      uint64_t v7 = 4 * a3;
    }
    else {
      uint64_t v7 = a3;
    }
    if (v7) {
      uint64_t v8 = v7;
    }
    else {
      uint64_t v8 = 500;
    }
    if (a2)
    {
      unsigned int v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      sub_5CDCC((uint64_t)&v17, a1 + 9608);
      uint64_t v10 = *(void **)(a1 + 9672);
      if (v10)
      {
        if (!dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 9672)))
        {
          int v11 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_0, v11, OS_LOG_TYPE_DEFAULT, "Delayed Control Centre Update: Cancelling current Dispatch", buf, 2u);
            uint64_t v10 = *(void **)(a1 + 9672);
          }
          dispatch_block_cancel(v10);
          uint64_t v10 = *(void **)(a1 + 9672);
        }
        _Block_release(v10);
        *(void *)(a1 + 9672) = 0;
      }
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      void block[2] = sub_5B028;
      block[3] = &unk_8D2C0;
      void block[4] = a1;
      *(void *)(a1 + 9672) = dispatch_block_create(DISPATCH_BLOCK_ENFORCE_QOS_CLASS, block);
      sub_5CEA4((uint64_t)&v17);
      id v12 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 134217984;
        uint64_t v20 = v8;
        _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "Triggering a delayed Control Centre update : %lld", buf, 0xCu);
      }
      sub_456B0(qword_A2350, v8, v9, *(void **)(a1 + 9672));
    }
    else
    {
      uint64_t v17 = 0;
      uint64_t v18 = 0;
      sub_5CDCC((uint64_t)&v17, a1 + 9608);
      unsigned __int32 v13 = *(void **)(a1 + 9672);
      if (v13)
      {
        if (!dispatch_block_testcancel(*(dispatch_block_t *)(a1 + 9672)))
        {
          unsigned int v14 = qword_A1B50;
          if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)std::string buf = 0;
            _os_log_impl(&dword_0, v14, OS_LOG_TYPE_DEFAULT, "Control Centre: Cancelling current Dispatch", buf, 2u);
            unsigned __int32 v13 = *(void **)(a1 + 9672);
          }
          dispatch_block_cancel(v13);
          unsigned __int32 v13 = *(void **)(a1 + 9672);
        }
        _Block_release(v13);
        *(void *)(a1 + 9672) = 0;
      }
      sub_5CEA4((uint64_t)&v17);
      unsigned __int8 v15 = qword_A1B50;
      if (os_log_type_enabled((os_log_t)qword_A1B50, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)std::string buf = 0;
        _os_log_impl(&dword_0, v15, OS_LOG_TYPE_DEFAULT, "Triggering a non-delayed Control Centre update", buf, 2u);
      }
      (*(void (**)(uint64_t))(*(void *)a1 + 704))(a1);
    }
    return sub_5CF10(&v17);
  }
  return result;
}

void sub_5B008(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
}

uint64_t sub_5B028(uint64_t a1)
{
  uint64_t v1 = *(const void ***)(a1 + 32);
  v3[0] = 0;
  v3[1] = 0;
  sub_5CDCC((uint64_t)v3, (uint64_t)(v1 + 1201));
  _Block_release(v1[1209]);
  v1[1209] = 0;
  sub_5CEA4((uint64_t)v3);
  (*((void (**)(const void **))*v1 + 88))(v1);
  return sub_5CF10(v3);
}

void sub_5B0B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

NSString *sub_5B0C4(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = a2;
  if (*((char *)a2 + 23) < 0) {
    uint64_t v2 = (uint64_t *)*a2;
  }
  NSStringEncoding v3 = +[NSString defaultCStringEncoding];

  return +[NSString stringWithCString:v2 encoding:v3];
}

void sub_5B11C(uint64_t *a1, void *a2, int a3, int a4, int a5, int a6, int a7)
{
  (*(void (**)(void **__return_ptr))(*a1 + 832))(__p);
  int v13 = v31;
  unsigned int v14 = (void **)__p[0];
  NSStringEncoding v15 = +[NSString defaultCStringEncoding];
  if (v13 >= 0) {
    __int16 v16 = __p;
  }
  else {
    __int16 v16 = v14;
  }
  uint64_t v17 = +[NSString stringWithCString:v16 encoding:v15];
  if (v31 < 0) {
    operator delete(__p[0]);
  }
  if (v17 && [a2 isEqualToString:v17])
  {
    BOOL v18 = a3 == 1;
    sub_27DF8(a1[1156], @"kBluetoothAudioDeviceFeatureHearingAssistCapability", v18);
    sub_282FC((uint64_t *)a1[1156]);
    uint64_t v19 = a1[1156];
    *(unsigned char *)(v19 + 331) = v18;
    BOOL v21 = a4 == 1 && a5 == 1;
    int v22 = *(_DWORD *)(v19 + 336);
    unsigned int v23 = v22 & 0xFFFFFFFD;
    if ((a6 & 0xFD) != 0) {
      unsigned int v23 = *(_DWORD *)(v19 + 336);
    }
    int v24 = ~v22 & 2;
    if (a6 != 1) {
      int v24 = 0;
    }
    int v25 = v24 | v23;
    unsigned int v26 = v25 & 0xFFFFFFFB;
    int v27 = *(_DWORD *)(v19 + 336) & 4;
    if (!v27) {
      unsigned int v26 = v25;
    }
    if ((a7 & 0xFD) == 0) {
      int v25 = v26;
    }
    int v28 = v27 ^ 4;
    if (a7 != 1) {
      int v28 = 0;
    }
    *(_DWORD *)(v19 + 336) = v25 | v28;
    *(unsigned char *)(v19 + 332) = v21;
    uint64_t v32 = 0x676C6F6268616573;
    int v33 = 0;
    (*(void (**)(uint64_t *, uint64_t *))(*a1 + 248))(a1, &v32);
    sub_2D5F0(a1[1156]);
  }
}

void sub_5B2D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t sub_5B2F4()
{
  return 0;
}

uint64_t sub_5B300()
{
  return 0;
}

uint64_t sub_5B308()
{
  return 0;
}

uint64_t sub_5B310(uint64_t result, char a2)
{
  *(unsigned char *)(result + 409) = a2;
  return result;
}

uint64_t sub_5B318(uint64_t result, char a2)
{
  *(unsigned char *)(result + 410) = a2;
  return result;
}

BOOL sub_5B320(uint64_t a1)
{
  return *(unsigned char *)(a1 + 409) != 0;
}

BOOL sub_5B330(uint64_t a1)
{
  return *(unsigned char *)(a1 + 410) != 0;
}

uint64_t sub_5B34C()
{
  return 0;
}

uint64_t sub_5B354()
{
  return 0;
}

uint64_t sub_5B35C()
{
  return 0;
}

double sub_5B370()
{
  qword_A1B50 = (uint64_t)os_log_create("com.apple.bluetooth", "BTAudio");
  xmmword_A1B60 = xmmword_718C0;
  byte_A1B70 = 0;
  unk_A1B74 = xmmword_718D0;
  byte_A1B84 = 0;
  unk_A1B88 = xmmword_718E0;
  byte_A1B98 = 0;
  unk_A1B9C = xmmword_718F0;
  byte_A1BAC = 0;
  xmmword_A1BB0 = xmmword_71900;
  byte_A1BC0 = 0;
  unk_A1BC4 = xmmword_71910;
  byte_A1BD4 = 0;
  unk_A1BD8 = xmmword_71920;
  byte_A1BE8 = 0;
  unk_A1BEC = xmmword_71930;
  byte_A1BFC = 0;
  xmmword_A1C00 = xmmword_71940;
  byte_A1C10 = 0;
  unk_A1C14 = xmmword_71950;
  byte_A1C24 = 0;
  unk_A1C28 = xmmword_71960;
  byte_A1C38 = 0;
  unk_A1C3C = xmmword_71970;
  byte_A1C4C = 0;
  xmmword_A1C50 = xmmword_71980;
  byte_A1C60 = 0;
  xmmword_A1C64 = xmmword_71990;
  byte_A1C74 = 0;
  xmmword_A1C78 = xmmword_719A0;
  byte_A1C88 = 0;
  xmmword_A1C8C = xmmword_719B0;
  byte_A1C9C = 1;
  xmmword_A1CA0 = xmmword_719C0;
  byte_A1CB0 = 0;
  xmmword_A1CB4 = xmmword_719D0;
  byte_A1CC4 = 0;
  xmmword_A1CC8 = xmmword_719E0;
  byte_A1CD8 = 1;
  xmmword_A1CDC = xmmword_719F0;
  byte_A1CEC = 1;
  xmmword_A1CF0 = xmmword_71A00;
  byte_A1D00 = 0;
  xmmword_A1D04 = xmmword_71A10;
  byte_A1D14 = 0;
  xmmword_A1D18 = xmmword_71A20;
  byte_A1D28 = 1;
  xmmword_A1D2C = xmmword_71A30;
  byte_A1D3C = 1;
  xmmword_A1D40 = xmmword_71A40;
  byte_A1D50 = 1;
  xmmword_A1D54 = xmmword_71A50;
  byte_A1D64 = 0;
  xmmword_A1D68 = xmmword_71A60;
  byte_A1D78 = 0;
  xmmword_A1D7C = xmmword_71A70;
  byte_A1D8C = 0;
  xmmword_A1D90 = xmmword_71A80;
  byte_A1DA0 = 1;
  xmmword_A1DA4 = xmmword_71A90;
  byte_A1DB4 = 0;
  xmmword_A1DB8 = xmmword_71AA0;
  byte_A1DC8 = 0;
  xmmword_A1DCC = xmmword_71AB0;
  byte_A1DDC = 1;
  xmmword_A1DE0 = xmmword_71AC0;
  byte_A1DF0 = 0;
  xmmword_A1DF4 = xmmword_71AD0;
  byte_A1E04 = 1;
  xmmword_A1E08 = xmmword_71AE0;
  byte_A1E18 = 0;
  xmmword_A1E1C = xmmword_71AF0;
  byte_A1E2C = 1;
  xmmword_A1E30 = xmmword_71B00;
  byte_A1E40 = 0;
  xmmword_A1E44 = xmmword_71B10;
  byte_A1E54 = 0;
  xmmword_A1E58 = xmmword_71B20;
  byte_A1E68 = 0;
  xmmword_A1E6C = xmmword_71B30;
  byte_A1E7C = 0;
  xmmword_A1E80 = xmmword_71B40;
  byte_A1E90 = 0;
  xmmword_A1E94 = xmmword_71B50;
  byte_A1EA4 = 0;
  xmmword_A1EA8 = xmmword_71B60;
  byte_A1EB8 = 1;
  xmmword_A1EBC = xmmword_71B70;
  byte_A1ECC = 0;
  xmmword_A1ED0 = xmmword_71B80;
  byte_A1EE0 = 1;
  xmmword_A1EE4 = xmmword_71B90;
  byte_A1EF4 = 0;
  xmmword_A1EF8 = xmmword_71BA0;
  byte_A1F08 = 0;
  xmmword_A1F0C = xmmword_71BB0;
  byte_A1F1C = 1;
  xmmword_A1F20 = xmmword_71BC0;
  byte_A1F30 = 1;
  xmmword_A1F34 = xmmword_71BD0;
  byte_A1F44 = 0;
  xmmword_A1F48 = xmmword_71BE0;
  byte_A1F58 = 0;
  xmmword_A1F5C = xmmword_71BF0;
  byte_A1F6C = 1;
  xmmword_A1F70 = xmmword_71C00;
  byte_A1F80 = 0;
  xmmword_A1F84 = xmmword_71C10;
  byte_A1F94 = sub_395B4();
  xmmword_A1F98 = xmmword_71C20;
  byte_A1FA8 = 0;
  xmmword_A1FAC = xmmword_71C30;
  byte_A1FBC = 0;
  xmmword_A1FC0 = xmmword_71C40;
  byte_A1FD0 = 0;
  xmmword_A1FD4 = xmmword_71C50;
  byte_A1FE4 = 1;
  xmmword_A1FE8 = xmmword_71C60;
  byte_A1FF8 = 0;
  xmmword_A1FFC = xmmword_71C70;
  byte_A200C = 0;
  xmmword_A2010 = xmmword_71C80;
  byte_A2020 = 0;
  xmmword_A2024 = xmmword_71C90;
  byte_A2034 = 0;
  xmmword_A2038 = xmmword_71CA0;
  byte_A2048 = 0;
  xmmword_A204C = xmmword_71CB0;
  byte_A205C = 1;
  xmmword_A2060 = xmmword_71CC0;
  byte_A2070 = 1;
  xmmword_A2074 = xmmword_71CD0;
  byte_A2084 = 0;
  xmmword_A2088 = xmmword_71CE0;
  byte_A2098 = 1;
  xmmword_A209C = xmmword_71CF0;
  byte_A20AC = 0;
  xmmword_A20B0 = xmmword_71D00;
  byte_A20C0 = 1;
  xmmword_A20C4 = xmmword_71D10;
  byte_A20D4 = 1;
  xmmword_A20D8 = xmmword_71D20;
  byte_A20E8 = 1;
  xmmword_A20EC = xmmword_71D30;
  byte_A20FC = 0;
  xmmword_A2100 = xmmword_71D40;
  byte_A2110 = 0;
  xmmword_A2114 = xmmword_71D50;
  byte_A2124 = 0;
  xmmword_A2128 = xmmword_71D60;
  byte_A2138 = 0;
  xmmword_A213C = xmmword_71D70;
  byte_A214C = 1;
  xmmword_A2150 = xmmword_71D80;
  byte_A2160 = 0;
  xmmword_A2164 = xmmword_71D90;
  byte_A2174 = 0;
  xmmword_A2178 = xmmword_71DA0;
  byte_A2188 = 1;
  xmmword_A218C = xmmword_71DB0;
  byte_A219C = 0;
  xmmword_A21A0 = xmmword_71DC0;
  byte_A21B0 = 0;
  xmmword_A21B4 = xmmword_71DD0;
  byte_A21C4 = 0;
  xmmword_A21C8 = xmmword_71DE0;
  byte_A21D8 = 0;
  xmmword_A21DC = xmmword_71DF0;
  byte_A21EC = 0;
  double result = 9.31743829e242;
  xmmword_A21F0 = xmmword_71E00;
  byte_A2200 = 0;
  return result;
}

uint64_t sub_5B9E0(uint64_t a1, unsigned int a2, uint64_t a3)
{
  long long v5 = *(_OWORD *)(a3 + 16);
  v9[0] = *(_OWORD *)a3;
  v9[1] = v5;
  uint64_t v10 = *(void *)(a3 + 32);
  sub_48758(a1, a2, (uint64_t)v9);
  *unsigned int v6 = &off_8FC28;
  if (a2 > 0x11 || ((1 << a2) & 0x30018) == 0)
  {
    uint64_t v8 = qword_A2208;
    if (os_log_type_enabled((os_log_t)qword_A2208, OS_LOG_TYPE_ERROR)) {
      sub_65648(a2, v8);
    }
  }
  return a1;
}

void sub_5BA9C(void *a1)
{
  sub_4879C(a1);

  operator delete();
}

uint64_t sub_5BAD4(uint64_t a1, int a2)
{
  if (a2 == 48000)
  {
    int v2 = 6;
  }
  else
  {
    if (a2 != 64000)
    {
      int v2 = *(_DWORD *)(a1 + 364);
      goto LABEL_7;
    }
    int v2 = 8;
  }
  *(_DWORD *)(a1 + 364) = v2;
LABEL_7:
  g722_decoder_init(a1 + 162, v2);
  return 0;
}

uint64_t sub_5BB24(uint64_t a1, char *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v8 = a3;
  unsigned int v9 = a2;
  __int16 v29 = 0;
  uint64_t v10 = (int16x4_t *)(a1 + 162);
  unint64_t v11 = *(__int16 *)(a1 + 212);
  if (v11 == 8)
  {
    uint64_t result = g722_decode_frame((int16x4_t *)(a1 + 162), a2, (__int16)a3, a4, &v29);
  }
  else
  {
    unint64_t v14 = 8 * a3 / v11;
    uint64_t v15 = (unsigned __int16)v14;
    __chkstk_darwin(a1);
    uint64_t v17 = &v28[-v16];
    bzero(&v28[-v16], (unsigned __int16)v14);
    int v18 = *(unsigned __int16 *)(a1 + 212);
    if (v18 == 6)
    {
      if ((_WORD)v14)
      {
        unsigned int v21 = 0;
        LOBYTE(v22) = 0;
        int v23 = 0;
        int v24 = v17;
        do
        {
          int v25 = v21 & ~(-1 << v22);
          unsigned int v21 = v9[v23];
          int v26 = v25 << (6 - v22);
          int v27 = 252 << v22;
          int v22 = ((_BYTE)v22 + 2) & 7;
          *v24++ = 4 * (((v27 & v21) >> v22) | v26);
          if (v22) {
            ++v23;
          }
          --v15;
        }
        while (v15);
      }
    }
    else if (v18 == 4 && v8)
    {
      uint64_t v19 = v17 + 1;
      do
      {
        char v20 = *v9++;
        *(v19 - 1) = v20 & 0xF0;
        *uint64_t v19 = 16 * v20;
        v19 += 2;
        --v8;
      }
      while (v8);
    }
    uint64_t result = g722_decode_frame(v10, v17, (__int16)v14, a4, &v29);
  }
  *a6 = 2 * v29;
  return result;
}

uint64_t sub_5BCE0(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 364);
  unsigned int v3 = 2 * a2;
  if (v2 == 8) {
    int v4 = 2 * a2;
  }
  else {
    int v4 = 0;
  }
  if (v2 != 6) {
    unsigned int v3 = v4;
  }
  if (v2 == 4) {
    return (4 * a2);
  }
  else {
    return v3;
  }
}

uint64_t sub_5BD08(uint64_t a1, int a2)
{
  int v2 = *(_DWORD *)(a1 + 364);
  unsigned int v3 = 2 * a2;
  if (v2 == 8) {
    int v4 = 2 * a2;
  }
  else {
    int v4 = 0;
  }
  if (v2 != 6) {
    unsigned int v3 = v4;
  }
  if (v2 == 4) {
    return (4 * a2);
  }
  else {
    return v3;
  }
}

uint64_t sub_5BD30()
{
  return 90;
}

os_log_t sub_5BD38()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A2208 = (uint64_t)result;
  return result;
}

void sub_5BD68(uint64_t a1, int a2, uint64_t a3)
{
  long long v3 = *(_OWORD *)(a3 + 16);
  v5[0] = *(_OWORD *)a3;
  v5[1] = v3;
  uint64_t v6 = *(void *)(a3 + 32);
  sub_48758(a1, a2, (uint64_t)v5);
  *(void *)uint64_t v4 = &off_8FC98;
  *(unsigned char *)(v4 + 152) = 1;
}

void sub_5BDC4(void *a1)
{
  sub_4879C(a1);

  operator delete();
}

void sub_5BDFC(uint64_t a1, int a2)
{
  *(void *)(a1 + 24) = 0x40BF400000000000;
  int v2 = (const AudioStreamBasicDescription *)(a1 + 24);
  *(_DWORD *)(a1 + 116) = a2;
  *(void *)(a1 + 32) = 1634492791;
  long long v3 = (const AudioStreamBasicDescription *)(a1 + 64);
  int v4 = *(_DWORD *)(a1 + 92);
  *(_DWORD *)(a1 + 40) = v4;
  *(_DWORD *)(a1 + 44) = 1;
  *(_DWORD *)(a1 + 48) = v4;
  *(_DWORD *)(a1 + 52) = v4;
  *(void *)(a1 + 56) = 8;
  UInt32 ioPropertyDataSize = 40;
  OSStatus Property = AudioFormatGetProperty(0x666D7469u, 0, 0, &ioPropertyDataSize, (void *)(a1 + 64));
  sub_1B8C0(Property, (uint64_t)"couldn't get output data format");
  OSStatus v6 = AudioConverterNew(v2, v3, (AudioConverterRef *)&v2[-1].mBitsPerChannel);
  sub_1B8C0(v6, (uint64_t)"Could not create new audio converter");
  v2[2].mBytesPerPacket = 1;
  operator new[]();
}

void sub_5BF70(uint64_t a1, unsigned __int8 *a2, uint64_t a3, _WORD *a4, uint64_t a5, uint64_t *a6)
{
  if (a3)
  {
    uint64_t v10 = a3;
    do
    {
      int v11 = *a2++;
      *a4++ = alaw_to_linear(v11);
      --v10;
    }
    while (v10);
    uint64_t v12 = 2 * a3;
  }
  else
  {
    uint64_t v12 = 0;
  }
  *a6 = v12;
}

uint64_t sub_5BFD8(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t sub_5BFE0(uint64_t a1, uint64_t a2)
{
  return a2;
}

os_log_t sub_5BFE8()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A2210 = (uint64_t)result;
  return result;
}

void sub_5C018(uint64_t a1, int a2, uint64_t a3, char a4, char a5)
{
  long long v7 = *(_OWORD *)(a3 + 16);
  v9[0] = *(_OWORD *)a3;
  v9[1] = v7;
  uint64_t v10 = *(void *)(a3 + 32);
  sub_12C34(a1, a2, v9);
  *(void *)uint64_t v8 = off_8FD08;
  *(unsigned char *)(v8 + 210) = 0;
  *(unsigned char *)(v8 + 176) = 1;
  *(unsigned char *)(v8 + 208) = a5;
  *(unsigned char *)(v8 + 209) = a4;
  *(void *)(v8 + 56) = 0;
}

void *sub_5C090(void *a1)
{
  *a1 = off_8FD08;
  int v2 = (OpaqueAudioConverter *)a1[7];
  if (v2)
  {
    AudioConverterDispose(v2);
  }
  else
  {
    long long v3 = qword_A2218;
    if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_ERROR)) {
      sub_6BD34(v3);
    }
  }
  return sub_12C84(a1);
}

void sub_5C110(void *a1)
{
  sub_5C090(a1);

  operator delete();
}

uint64_t sub_5C148(uint64_t a1, int a2, unsigned int a3)
{
  int v6 = *(_DWORD *)(a1 + 92);
  if (*(unsigned char *)(a1 + 209))
  {
    long long v7 = qword_A2218;
    if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)std::string buf = 0;
      _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "LC3 encoder init to AACELD 48K", buf, 2u);
    }
    int v8 = 1633772389;
  }
  else
  {
    int v8 = 1818440480;
  }
  int v9 = *(_DWORD *)(a1 + 52);
  *(_DWORD *)(a1 + 156) = a2;
  if (v9 <= 259)
  {
    if (v9 == 258)
    {
      int v10 = 180;
    }
    else
    {
      if (v9 != 259) {
        goto LABEL_25;
      }
      int v10 = 240;
    }
LABEL_16:
    uint64_t v11 = *(void *)(a1 + 64);
    *(void *)(a1 + 104) = v11;
    *(void *)(a1 + 184) = a3;
    *(void *)(a1 + 200) = 0;
    *(void *)(a1 + 192) = 8 * a3;
    *(_DWORD *)(a1 + 112) = v8;
    *(void *)(a1 + 116) = 0;
    *(_DWORD *)(a1 + 124) = v10;
    *(_DWORD *)(a1 + 128) = 0;
    *(_DWORD *)(a1 + 132) = v6;
    *(void *)(a1 + 136) = 0;
    UInt32 ioPropertyDataSize = 40;
    uint64_t v12 = qword_A2218;
    if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a1 + 72);
      int v14 = *(_DWORD *)(a1 + 76);
      int v15 = *(_DWORD *)(a1 + 80);
      int v16 = *(_DWORD *)(a1 + 84);
      int v17 = *(_DWORD *)(a1 + 88);
      int v18 = *(_DWORD *)(a1 + 92);
      int v19 = *(_DWORD *)(a1 + 96);
      *(_DWORD *)std::string buf = 134219776;
      uint64_t v37 = v11;
      __int16 v38 = 1024;
      int v39 = v13;
      __int16 v40 = 1024;
      int v41 = v14;
      __int16 v42 = 1024;
      int v43 = v15;
      __int16 v44 = 1024;
      int v45 = v16;
      __int16 v46 = 1024;
      int v47 = v17;
      __int16 v48 = 1024;
      int v49 = v18;
      __int16 v50 = 1024;
      int v51 = v19;
      _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "LC3 Encoder input format:  mSampleRate = %f, mFormatID = %u, mFormatFlags:%u, mBytesPerPacket:%u, mFramesPerPacket = %u, mBytesPerFrame:%u, mChannelsPerFrame = %u, mBitsPerChannel:%u, format = float PCM\n", buf, 0x36u);
      uint64_t v12 = qword_A2218;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(a1 + 104);
      int v21 = *(_DWORD *)(a1 + 112);
      int v22 = *(_DWORD *)(a1 + 116);
      int v23 = *(_DWORD *)(a1 + 120);
      int v24 = *(_DWORD *)(a1 + 124);
      int v25 = *(_DWORD *)(a1 + 128);
      int v26 = *(_DWORD *)(a1 + 132);
      int v27 = *(_DWORD *)(a1 + 136);
      *(_DWORD *)std::string buf = 134219776;
      uint64_t v37 = v20;
      __int16 v38 = 1024;
      int v39 = v21;
      __int16 v40 = 1024;
      int v41 = v22;
      __int16 v42 = 1024;
      int v43 = v23;
      __int16 v44 = 1024;
      int v45 = v24;
      __int16 v46 = 1024;
      int v47 = v25;
      __int16 v48 = 1024;
      int v49 = v26;
      __int16 v50 = 1024;
      int v51 = v27;
      _os_log_impl(&dword_0, v12, OS_LOG_TYPE_DEFAULT, "LC3 Encoder output format:  mSampleRate = %f, mFormatID = %u, mFormatFlags:%u, mBytesPerPacket:%u, mFramesPerPacket = %u, mBytesPerFrame:%u, mChannelsPerFrame = %u, mBitsPerChannel:%u, format = float PCM\n", buf, 0x36u);
    }
    OSStatus Property = AudioFormatGetProperty(0x666D7469u, 0, 0, &ioPropertyDataSize, (void *)(a1 + 104));
    sub_1B8C0(Property, (uint64_t)"couldn't create output data format");
    if (*(unsigned char *)(a1 + 48))
    {
      __int16 v29 = qword_A2218;
      if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_DEBUG)) {
        sub_6BDBC((int *)(a1 + 120), v29);
      }
    }
    OSStatus v30 = AudioConverterNew((const AudioStreamBasicDescription *)(a1 + 64), (const AudioStreamBasicDescription *)(a1 + 104), (AudioConverterRef *)(a1 + 56));
    sub_1B8C0(v30, (uint64_t)"Could not create new audio converter");
    OSStatus v31 = AudioConverterSetProperty(*(AudioConverterRef *)(a1 + 56), 0x70616B6Cu, 4u, (const void *)(a1 + 192));
    sub_1B8C0(v31, (uint64_t)"Failed to set target data rate");
    unsigned int v32 = vcvtps_u32_f32((float)(20480 * v6 * *(_DWORD *)(a1 + 88)) / (float)a3);
    *(_DWORD *)(a1 + 160) = v32;
    *(_DWORD *)(a1 + 152) = v32 * a3;
    operator new[]();
  }
  switch(v9)
  {
    case 260:
LABEL_10:
      int v10 = 360;
      goto LABEL_16;
    case 508:
      int v10 = 480;
      goto LABEL_16;
    case 1633772389:
      goto LABEL_10;
  }
LABEL_25:
  __int16 v34 = qword_A2218;
  if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_ERROR)) {
    sub_6BD78(v34);
  }
  return 560226676;
}

void sub_5C554(uint64_t a1, unsigned __int8 *a2, unsigned int a3, _DWORD *a4, UInt32 a5)
{
  long long v55 = 0u;
  long long v56 = 0u;
  long long v54 = 0u;
  *(void *)&outOutputData.mNumberBuffers = 0;
  UInt32 ioOutputDataPacketSize = *(_DWORD *)(a1 + 160);
  inInputDataProcUserData[0] = a2;
  if (*(unsigned char *)(a1 + 210))
  {
    long long v7 = qword_A2218;
    if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *a2;
      int v9 = a2[1];
      int v10 = a2[2];
      int v11 = a2[3];
      int v12 = a2[4];
      int v13 = a2[5];
      int v14 = a2[6];
      int v15 = a2[7];
      *(_DWORD *)std::string buf = 67111168;
      LODWORD(v58) = a3;
      WORD2(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 6) = v8;
      WORD5(v58) = 1024;
      HIDWORD(v58) = v9;
      *(_WORD *)int v59 = 1024;
      *(_DWORD *)&v59[2] = v10;
      LOWORD(v60) = 1024;
      *(_DWORD *)((char *)&v60 + 2) = v11;
      HIWORD(v60) = 1024;
      *(_DWORD *)int v61 = v12;
      *(_WORD *)&v61[4] = 1024;
      *(_DWORD *)uint8x8_t v62 = v13;
      *(_WORD *)&v62[4] = 1024;
      *(_DWORD *)int v63 = v14;
      *(_WORD *)&v63[4] = 1024;
      *(_DWORD *)int16x8_t v64 = v15;
      _os_log_impl(&dword_0, v7, OS_LOG_TYPE_DEFAULT, "LC3Encoder PCM len:%u, %02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x", buf, 0x38u);
    }
  }
  int v16 = 0;
  int v46 = 0;
  uint64_t v17 = 0;
  inInputDataProcUserData[1] = *(unsigned int *)(a1 + 80) * (unint64_t)a3;
  long long v18 = *(_OWORD *)(a1 + 80);
  long long v51 = *(_OWORD *)(a1 + 64);
  long long v52 = v18;
  uint64_t v53 = *(void *)(a1 + 96);
  *a4 = 0;
  do
  {
    UInt32 v19 = *(_DWORD *)(a1 + 132);
    outOutputData.mNumberBuffers = 1;
    UInt32 v20 = *(_DWORD *)(a1 + 152);
    outOutputData.mBuffers[0].mNumberChannels = v19;
    outOutputData.mBuffers[0].size_t mDataByteSize = v20;
    outOutputData.mBuffers[0].mData = (void *)(*(void *)(a1 + 144) + v17);
    if (*(unsigned char *)(a1 + 210))
    {
      int v21 = qword_A2218;
      if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109376;
        LODWORD(v58) = ioOutputDataPacketSize;
        WORD2(v58) = 2048;
        *(void *)((char *)&v58 + 6) = v17;
        _os_log_impl(&dword_0, v21, OS_LOG_TYPE_DEFAULT, "LC3Encoder ->c io:%u, offset %llu", buf, 0x12u);
      }
    }
    OSStatus v22 = AudioConverterFillComplexBuffer(*(AudioConverterRef *)(a1 + 56), (AudioConverterComplexInputDataProc)sub_1B78C, inInputDataProcUserData, &ioOutputDataPacketSize, &outOutputData, *(AudioStreamPacketDescription **)(a1 + 168));
    sub_1B8C0(v22, (uint64_t)"LC3 Encode  AudioConverterFillComplexBuffer failed");
    if (*(unsigned char *)(a1 + 210))
    {
      int v23 = qword_A2218;
      if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)std::string buf = 67109120;
        LODWORD(v58) = ioOutputDataPacketSize;
        _os_log_impl(&dword_0, v23, OS_LOG_TYPE_DEFAULT, "LC3Encoder c-> io:%u", buf, 8u);
      }
    }
    UInt32 v24 = ioOutputDataPacketSize;
    if (!ioOutputDataPacketSize) {
      break;
    }
    if (ioOutputDataPacketSize > a5)
    {
      __int16 v42 = qword_A2218;
      if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_ERROR)) {
        sub_6BE38(v24, a5, v42);
      }
      *a4 = 0;
      return;
    }
    uint64_t v25 = 0;
    unint64_t v26 = 0;
    int v44 = v16 + 1;
    uint64_t v27 = *(void *)(a1 + 144) + v17;
    do
    {
      int v28 = (unsigned __int8 *)(v27 + *(void *)(*(void *)(a1 + 168) + v25));
      __int16 v29 = &a4[4 * (v46 + v26)];
      *((void *)v29 + 2) = v28;
      OSStatus v30 = (uint64_t *)(*(void *)(a1 + 168) + v25);
      uint64_t v31 = *((unsigned int *)v30 + 3);
      _OWORD v29[2] = 1;
      unsigned char v29[3] = v31;
      ++*a4;
      if (*(unsigned char *)(a1 + 210))
      {
        unsigned int v32 = qword_A2218;
        if (os_log_type_enabled((os_log_t)qword_A2218, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v33 = *v30;
          int v34 = *v28;
          int v35 = v28[1];
          int v36 = v28[2];
          int v37 = v28[3];
          *(_DWORD *)std::string buf = 134220032;
          *(void *)&long long v58 = v27;
          WORD4(v58) = 1024;
          *(_DWORD *)((char *)&v58 + 10) = v26;
          HIWORD(v58) = 1024;
          *(_DWORD *)int v59 = v46 + v26;
          *(_WORD *)&v59[4] = 2048;
          uint64_t v60 = v33;
          *(_WORD *)int v61 = 1024;
          *(_DWORD *)&v61[2] = v31;
          *(_WORD *)uint8x8_t v62 = 1024;
          *(_DWORD *)&v62[2] = v34;
          *(_WORD *)int v63 = 1024;
          *(_DWORD *)&v63[2] = v35;
          *(_WORD *)int16x8_t v64 = 1024;
          *(_DWORD *)&v64[2] = v36;
          __int16 v65 = 1024;
          int v66 = v37;
          _os_log_impl(&dword_0, v32, OS_LOG_TYPE_DEFAULT, "LC3Encoder c->%p,%d,%u,%lld,%u,%02x,%02x,%02x,%02x", buf, 0x40u);
          UInt32 v24 = ioOutputDataPacketSize;
        }
      }
      v17 += v31;
      ++v26;
      v25 += 16;
    }
    while (v26 < v24);
    int v16 = v44;
    if (v24 && *(unsigned char *)(a1 + 177))
    {
      UInt32 v38 = 0;
      int v39 = (int *)(*(void *)(a1 + 168) + 12);
      uint64_t v40 = v24;
      do
      {
        int v41 = *v39;
        v39 += 4;
        v38 += v41;
        --v40;
      }
      while (v40);
      sub_1330C(a1, v38, v24);
    }
    v46 += v26;
  }
  while (v44 != 10);
}

uint64_t sub_5C9EC()
{
  return 1;
}

uint64_t sub_5C9F4()
{
  return 1;
}

os_log_t sub_5C9FC()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A2218 = (uint64_t)result;
  return result;
}

uint64_t sub_5CA2C(uint64_t result)
{
  if ((unint64_t)(result - 3) <= 3) {
    return _kdebug_trace((4 * (result - 3) + 730005516), 0, 0, 0, 0);
  }
  return result;
}

uint64_t sub_5CA5C(uint64_t a1)
{
  uint64_t result = 730005540;
  if (a1 != 9)
  {
    if (a1 != 10) {
      return result;
    }
    uint64_t result = 730005544;
  }
  return _kdebug_trace(result, 0, 0, 0, 0);
}

uint64_t sub_5CA94(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((unint64_t)(result - 30) <= 6) {
    return _kdebug_trace((4 * (result - 30) + 730005624), a2, a3, a4, a5);
  }
  return result;
}

uint64_t sub_5CAB4(uint64_t a1)
{
  uint64_t result = 730005556;
  if (a1 != 13)
  {
    if (a1 != 14) {
      return result;
    }
    uint64_t result = 730005560;
  }
  return _kdebug_trace(result, 0, 0, 0, 0);
}

uint64_t sub_5CAEC(uint64_t a1)
{
  return _WriteStackshotReport_stdc(a1, 3172327085);
}

uint64_t sub_5CAF8()
{
  return 1;
}

uint64_t sub_5CB00()
{
  return os_variant_has_internal_content();
}

CFStringRef sub_5CB0C()
{
  CFStringRef result = (const __CFString *)MGGetStringAnswer();
  if (result)
  {
    CFStringRef v1 = result;
    CFIndex length = CFStringFind(result, @"DEV", 4uLL).length;
    CFRelease(v1);
    return (const __CFString *)(length != 0);
  }
  return result;
}

uint64_t sub_5CB60()
{
  strlcat(byte_A2228, "/tmp/BTHALAudioPlugin", 0x100uLL);

  return mkdir(byte_A2228, 0x1EDu);
}

pthread_mutex_t *sub_5CBB0(pthread_mutex_t *a1)
{
  v4.__sig = 0;
  *(void *)v4.__opaque = 0;
  pthread_mutexattr_init(&v4);
  pthread_mutexattr_settype(&v4, 2);
  int v2 = pthread_mutex_init(a1, &v4);
  pthread_mutexattr_destroy(&v4);
  if (v2)
  {
    if (os_log_type_enabled((os_log_t)qword_A2220, OS_LOG_TYPE_FAULT)) {
      sub_6BEC0();
    }
    if (os_variant_has_internal_content()) {
      abort();
    }
  }
  return a1;
}

pthread_mutex_t *sub_5CC84(pthread_mutex_t *a1)
{
  if (pthread_mutex_destroy(a1))
  {
    if (os_log_type_enabled((os_log_t)qword_A2220, OS_LOG_TYPE_FAULT)) {
      sub_6BEC0();
    }
    if (os_variant_has_internal_content()) {
      abort();
    }
  }
  return a1;
}

uint64_t sub_5CD04(pthread_mutex_t *a1)
{
  uint64_t result = pthread_mutex_lock(a1);
  if (result)
  {
    if (os_log_type_enabled((os_log_t)qword_A2220, OS_LOG_TYPE_FAULT)) {
      sub_6BEC0();
    }
    uint64_t result = os_variant_has_internal_content();
    if (result) {
      abort();
    }
  }
  return result;
}

uint64_t sub_5CD68(pthread_mutex_t *a1)
{
  uint64_t result = pthread_mutex_unlock(a1);
  if (result)
  {
    if (os_log_type_enabled((os_log_t)qword_A2220, OS_LOG_TYPE_FAULT)) {
      sub_6BEC0();
    }
    uint64_t result = os_variant_has_internal_content();
    if (result) {
      abort();
    }
  }
  return result;
}

uint64_t sub_5CDCC(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = a2;
  *(unsigned char *)(a1 + 8) = 0;
  sub_5CDFC(a1);
  return a1;
}

uint64_t sub_5CDFC(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8))
  {
    int v2 = qword_A2220;
    if (os_log_type_enabled((os_log_t)qword_A2220, OS_LOG_TYPE_FAULT)) {
      sub_6BF28(v2);
    }
    if (os_variant_has_internal_content()) {
      abort();
    }
  }
  *(unsigned char *)(a1 + 8) = 1;
  return sub_5CD04(*(pthread_mutex_t **)a1);
}

uint64_t sub_5CE6C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    sub_5CEA4(a1);
  }
  return a1;
}

uint64_t sub_5CEA4(uint64_t a1)
{
  if (!*(unsigned char *)(a1 + 8))
  {
    int v2 = qword_A2220;
    if (os_log_type_enabled((os_log_t)qword_A2220, OS_LOG_TYPE_FAULT)) {
      sub_6BFAC(v2);
    }
    if (os_variant_has_internal_content()) {
      abort();
    }
  }
  *(unsigned char *)(a1 + 8) = 0;
  return sub_5CD68(*(pthread_mutex_t **)a1);
}

void sub_5CF14(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 8u);
}

os_log_t sub_5CF30()
{
  os_log_t result = os_log_create("com.apple.bluetooth", "BTAudio");
  qword_A2220 = (uint64_t)result;
  return result;
}

int *decoder_create(int a1)
{
  int v2 = (int *)malloc_type_malloc(0x30uLL, 0x10A0040D8AFB92EuLL);
  long long v3 = (int *)((char *)&hmModesConfig + 16 * a1);
  int v5 = *v3;
  signed int v4 = v3[1];
  *int v2 = (a1 - 5) < 2;
  v2[1] = v5;
  void v2[2] = v4;
  if ((a1 - 5) <= 1)
  {
    unpack_lite_create();
    *((void *)v2 + 4) = v6;
    signed int v4 = v2[2];
  }
  *((void *)v2 + 5) = imdct_create(v4);
  *((void *)v2 + 2) = malloc_type_malloc(4 * v2[2], 0x100004052888210uLL);
  return v2;
}

void decoder_destroy(void *a1)
{
  if (*(_DWORD *)a1 == 1) {
    unpack_lite_destroy(*((void **)a1 + 4));
  }
  imdct_destroy(*((void *)a1 + 5));
  free(*((void **)a1 + 2));

  free(a1);
}

void decode(uint64_t a1, unsigned __int16 *a2, float *a3, int a4)
{
  uint64_t v6 = *(float **)(a1 + 16);
  if (a4)
  {
    float __B = 0.9;
    vDSP_vsmul(v6, 1, &__B, v6, 1, *(int *)(a1 + 8));
    int v7 = *(_DWORD *)(a1 + 24);
  }
  else
  {
    if (*(_DWORD *)a1) {
      int v8 = unpack_lite_c(*(void *)(a1 + 32), a2, *(unsigned int *)(a1 + 4), (uint64_t)v6, *(_DWORD *)(a1 + 8));
    }
    else {
      int v8 = unpack(a2, *(_DWORD *)(a1 + 4), (uint64_t)v6, *(_DWORD *)(a1 + 8));
    }
    int v7 = v8;
    *(_DWORD *)(a1 + 24) = v8;
  }
  imdct(*(void *)(a1 + 40), v6, v7, a3);
}

int *encoder_create(int a1)
{
  int v2 = (int *)malloc_type_malloc(0x68uLL, 0x10A0040D1EDB599uLL);
  long long v3 = (int *)((char *)&hmModesConfig + 16 * a1);
  int v5 = *v3;
  int v4 = v3[1];
  *int v2 = (a1 - 5) < 2;
  v2[1] = v5;
  *((void *)v2 + 12) = &filters_875;
  int v6 = v3[2];
  void v2[2] = v4;
  v2[3] = v6;
  if (a1 == 6)
  {
    *((void *)v2 + 12) = &filters_583;
  }
  else
  {
    int v7 = v3[3];
    if ((a1 - 4) <= 2) {
      *((void *)v2 + 12) = &filters_777;
    }
    if ((a1 - 5) > 1)
    {
      int v8 = quantizer_create(v4, v6, v5, (float)v7);
      goto LABEL_8;
    }
  }
  quantizer_lite_create();
LABEL_8:
  *((void *)v2 + 11) = v8;
  *((void *)v2 + 7) = mdct_create(v2[2]);
  *((void *)v2 + 10) = malloc_type_malloc(4 * v2[2], 0x100004052888210uLL);
  *((void *)v2 + 8) = malloc_type_malloc(4 * v2[2] + 8, 0x100004052888210uLL);
  *((void *)v2 + 9) = malloc_type_malloc(4 * v2[2] + 8, 0x100004052888210uLL);
  *((_OWORD *)v2 + 1) = 0u;
  *((_OWORD *)v2 + 2) = 0u;
  *((void *)v2 + 6) = 0;
  return v2;
}

void encoder_destroy(int *a1)
{
  int v2 = *a1;
  long long v3 = (void *)*((void *)a1 + 11);
  if (v2) {
    quantizer_lite_destroy(v3);
  }
  else {
    quantizer_destroy((uint64_t)v3);
  }
  mdct_destroy(*((void *)a1 + 7));
  free(*((void **)a1 + 8));
  free(*((void **)a1 + 9));
  free(*((void **)a1 + 10));

  free(a1);
}

void encode(uint64_t a1, const float *__A, _OWORD *a3)
{
  vDSP_Length v5 = *(int *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 72);
  int v8 = *(const float **)(a1 + 80);
  *(_DWORD *)uint64_t v6 = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(v6 + 4) = *(_DWORD *)(a1 + 20);
  vDSP_mmov(__A, (float *)(v6 + 8), v5, 1uLL, v5, v5);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(v6 + 4 * v5);
  uint64_t v9 = 4 * v5 + 4;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(v6 + v9);
  int v10 = *(const float **)(a1 + 96);
  *(_DWORD *)uint64_t v7 = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(v7 + 4) = *(_DWORD *)(a1 + 28);
  vDSP_deq22((const float *)v6, 1, v10, (float *)v7, 1, v5);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(v7 + 4 * v5);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(v7 + v9);
  *(_DWORD *)uint64_t v6 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(v6 + 4) = *(_DWORD *)(a1 + 36);
  vDSP_deq22((const float *)v7, 1, v10 + 5, (float *)v6, 1, v5);
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(v6 + 4 * v5);
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(v6 + v9);
  *(_DWORD *)uint64_t v7 = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(v7 + 4) = *(_DWORD *)(a1 + 44);
  vDSP_deq22((const float *)v6, 1, v10 + 10, (float *)v7, 1, v5);
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(v7 + 4 * v5);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(v7 + v9);
  *(_DWORD *)uint64_t v6 = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(v6 + 4) = *(_DWORD *)(a1 + 52);
  vDSP_deq22((const float *)v7, 1, v10 + 15, (float *)v6, 1, v5);
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(v6 + 4 * v5);
  *(_DWORD *)(a1 + 52) = *(_DWORD *)(v6 + v9);
  mdct(*(void *)(a1 + 56), (const void *)(v6 + 8), (uint64_t)v8);
  uint64_t v11 = *(void *)(a1 + 88);
  if (*(_DWORD *)a1)
  {
    quantize_lite(v11, (uint64_t)v8, a3);
  }
  else
  {
    quantize(v11, v8, (uint64_t)a3);
  }
}

float butterfly2(uint64_t a1, float *a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = a3;
    uint64_t v4 = 2 * a3;
    vDSP_Length v5 = (float *)(a1 + 4);
    do
    {
      float v6 = *(v5 - 1);
      float v7 = a2[1];
      float v8 = (float)(v6 * *a2) - (float)(*v5 * v7);
      float v9 = (float)(*v5 * *a2) + (float)(v6 * v7);
      int v10 = &v5[v4];
      float v11 = v5[v4 - 1];
      float v12 = v5[2 * a3];
      float v13 = a2[2 * a3];
      float v14 = a2[v4 + 1];
      float v15 = (float)(v11 * v13) - (float)(v12 * v14);
      float v16 = (float)(v12 * v13) + (float)(v11 * v14);
      float v17 = v9 + v16;
      float result = v9 - v16;
      *(v5 - 1) = v8 + v15;
      float *v5 = v17;
      *(v10 - 1) = v8 - v15;
      *int v10 = result;
      a2 += 2;
      v5 += 2;
      --v3;
    }
    while (v3);
  }
  return result;
}

uint64_t butterfly3(uint64_t result, float *a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = 4 * a3;
    uint64_t v4 = (float *)(result + 4);
    uint64_t v5 = 2 * a3;
    uint64_t v6 = a3;
    do
    {
      float v7 = *(v4 - 1);
      float v8 = a2[1];
      float v9 = (float)(v7 * *a2) - (float)(*v4 * v8);
      float v10 = (float)(*v4 * *a2) + (float)(v7 * v8);
      float v11 = &v4[v5];
      float v12 = v4[v5 - 1];
      float v13 = v4[2 * a3];
      float v14 = a2[2 * a3];
      float v15 = a2[v5 + 1];
      float v16 = (float)(v12 * v14) - (float)(v13 * v15);
      float v17 = (float)(v13 * v14) + (float)(v12 * v15);
      long long v18 = &v4[v3];
      float v19 = v4[v3 - 1];
      float v20 = v4[4 * a3];
      float v21 = a2[4 * a3];
      float v22 = a2[v3 + 1];
      float v23 = (float)(v19 * v21) - (float)(v20 * v22);
      float v24 = (float)(v20 * v21) + (float)(v19 * v22);
      *(v4 - 1) = (float)(v9 + v16) + v23;
      float *v4 = (float)(v10 + v17) + v24;
      *(v11 - 1) = (float)(v9 + (float)((float)(v17 * 0.86603) + (float)(v16 * -0.5)))
                 + (float)((float)(v23 * -0.5) - (float)(v24 * 0.86603));
      *float v11 = (float)(v10 + (float)((float)(v17 * -0.5) - (float)(v16 * 0.86603)))
           + (float)((float)(v24 * -0.5) + (float)(v23 * 0.86603));
      *(v18 - 1) = (float)(v9 + (float)((float)(v16 * -0.5) - (float)(v17 * 0.86603)))
                 + (float)((float)(v24 * 0.86603) + (float)(v23 * -0.5));
      float *v18 = (float)(v10 + (float)((float)(v17 * -0.5) + (float)(v16 * 0.86603)))
           + (float)((float)(v24 * -0.5) - (float)(v23 * 0.86603));
      a2 += 2;
      v4 += 2;
      --v6;
    }
    while (v6);
  }
  return result;
}

float butterfly4(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 >= 1)
  {
    uint64_t v3 = 0;
    uint64_t v4 = a1 + 8 * a3;
    uint64_t v5 = a2 + 8 * a3;
    uint64_t v6 = a2 + 16 * a3;
    uint64_t v7 = 8 * a3;
    uint64_t v8 = a1 + 24 * a3 + 4;
    uint64_t v9 = a1 + 16 * a3 + 4;
    uint64_t v10 = a2 + 24 * a3;
    do
    {
      float v11 = (float *)(a1 + v3);
      float v12 = *(float *)(a1 + v3);
      float v13 = *(float *)(a1 + v3 + 4);
      float v14 = *(float *)(a2 + v3);
      float v15 = *(float *)(a2 + v3 + 4);
      float v16 = (float)(v12 * v14) - (float)(v13 * v15);
      float v17 = (float)(v13 * v14) + (float)(v12 * v15);
      long long v18 = (float *)(v4 + v3);
      float v19 = *(float *)(v4 + v3);
      float v20 = *(float *)(v4 + v3 + 4);
      float v21 = *(float *)(v5 + v3);
      float v22 = *(float *)(v5 + v3 + 4);
      float v23 = (float)(v19 * v21) - (float)(v20 * v22);
      float v24 = (float)(v20 * v21) + (float)(v19 * v22);
      uint64_t v25 = (float *)(v9 + v3);
      float v26 = *(float *)(v9 + v3 - 4);
      float v27 = *(float *)(v9 + v3);
      float v28 = *(float *)(v6 + v3);
      float v29 = *(float *)(v6 + v3 + 4);
      float v30 = (float)(v26 * v28) - (float)(v27 * v29);
      float v31 = (float)(v27 * v28) + (float)(v26 * v29);
      unsigned int v32 = (float *)(v8 + v3);
      float v33 = *(float *)(v8 + v3 - 4);
      float v34 = *(float *)(v8 + v3);
      float v35 = *(float *)(v10 + v3);
      float v36 = *(float *)(v10 + v3 + 4);
      float v37 = (float)(v33 * v35) - (float)(v34 * v36);
      float v38 = (float)(v34 * v35) + (float)(v33 * v36);
      float v39 = v16 + v30;
      float v40 = v17 + v31;
      float v41 = v16 - v30;
      float v42 = v17 - v31;
      float v43 = v24 + v38;
      float v44 = v24 - v38;
      *float v11 = v39 + (float)(v23 + v37);
      v11[1] = v40 + v43;
      float *v18 = v41 + v44;
      v18[1] = v42 + (float)(v37 - v23);
      float result = v42 - (float)(v37 - v23);
      *(v25 - 1) = v39 - (float)(v23 + v37);
      *uint64_t v25 = v40 - v43;
      *(v32 - 1) = v41 - v44;
      *unsigned int v32 = result;
      v3 += 8;
    }
    while (v7 != v3);
  }
  return result;
}

uint64_t butterfly5last(uint64_t result, int a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7, int a8)
{
  if (a7 >= 1)
  {
    int v8 = 0;
    for (int i = 0; i != a7; ++i)
    {
      if (a8 >= 1)
      {
        uint64_t v10 = 0;
        float v11 = (int *)(a6 + 4 * v8);
        int v12 = a8;
        do
        {
          uint64_t v13 = *v11++;
          float v14 = *(float *)(result + v10);
          float v15 = *(float *)(result + v10 + 4);
          float v16 = *(float *)(a3 + v10);
          float v17 = *(float *)(a3 + v10 + 4);
          long long v18 = (float *)(a4 + 8 * v13);
          float v19 = (float)(v14 * v16) - (float)(v15 * v17);
          float v20 = (float)(v15 * v16) + (float)(v14 * v17);
          float v22 = *(float *)(result + v10 + 8);
          float v21 = *(float *)(result + v10 + 12);
          float v23 = *(float *)(a3 + v10 + 8);
          float v24 = *(float *)(a3 + v10 + 12);
          float v25 = -(float)(v21 * v24);
          float v26 = v21 * v23;
          float v27 = v25 + (float)(v22 * v23);
          float v28 = v26 + (float)(v22 * v24);
          float v29 = *(float *)(result + v10 + 16);
          float v30 = *(float *)(result + v10 + 20);
          float v31 = *(float *)(a3 + v10 + 16);
          float v32 = *(float *)(a3 + v10 + 20);
          float v33 = (float)(v29 * v31) - (float)(v30 * v32);
          float v34 = v30 * v31;
          float v35 = *(float *)(result + v10 + 24);
          float v36 = *(float *)(result + v10 + 28);
          float v37 = v34 + (float)(v29 * v32);
          float v39 = *(float *)(a3 + v10 + 24);
          float v38 = *(float *)(a3 + v10 + 28);
          float v40 = (float)(v35 * v39) - (float)(v36 * v38);
          float v41 = (float)(v36 * v39) + (float)(v35 * v38);
          float v43 = *(float *)(result + v10 + 32);
          float v42 = *(float *)(result + v10 + 36);
          float v44 = *(float *)(a3 + v10 + 32);
          float v45 = *(float *)(a3 + v10 + 36);
          float v46 = -(float)(v42 * v45);
          float v47 = v42 * v44;
          float v48 = v46 + (float)(v43 * v44);
          float v49 = v47 + (float)(v43 * v45);
          float v50 = (float)((float)((float)(v19 + (float)(v27 * 0.30902)) + (float)(v33 * -0.80902))
                      + (float)(v40 * -0.80902))
              + (float)(v48 * 0.30902);
          float v51 = (float)((float)((float)(v28 * 0.95106) + (float)(v37 * 0.58779)) + (float)(v41 * -0.58779))
              + (float)(v49 * -0.95106);
          float v52 = (float)((float)((float)(v27 * -0.95106) + (float)(v33 * -0.58779)) + (float)(v40 * 0.58779))
              + (float)(v48 * 0.95106);
          float v53 = (float)((float)(v19 + v27) + v33) + v40;
          float v54 = (float)((float)((float)(v20 + (float)(v28 * 0.30902)) + (float)(v37 * -0.80902))
                      + (float)(v41 * -0.80902))
              + (float)(v49 * 0.30902);
          float v55 = (float)((float)((float)(v19 + (float)(v27 * -0.80902)) + (float)(v33 * 0.30902)) + (float)(v40 * 0.30902))
              + (float)(v48 * -0.80902);
          float v56 = (float)((float)((float)(v20 + v28) + v37) + v41) + v49;
          float v57 = (float)((float)((float)(v20 + (float)(v28 * -0.80902)) + (float)(v37 * 0.30902)) + (float)(v41 * 0.30902))
              + (float)(v49 * -0.80902);
          float v58 = (float)((float)((float)(v28 * 0.58779) + (float)(v37 * -0.95106)) + (float)(v41 * 0.95106))
              + (float)(v49 * -0.58779);
          float v59 = (float)((float)((float)(v27 * -0.58779) + (float)(v33 * 0.95106)) + (float)(v40 * -0.95106))
              + (float)(v48 * 0.58779);
          float *v18 = v53 + v48;
          v18[1] = v56;
          uint64_t v60 = &v18[2 * a5];
          *uint64_t v60 = v51 + v50;
          v60[1] = v54 + v52;
          int v61 = &v60[2 * a5];
          float *v61 = v58 + v55;
          v61[1] = v57 + v59;
          uint8x8_t v62 = &v61[2 * a5];
          *uint8x8_t v62 = v55 - v58;
          v62[1] = v57 - v59;
          int v63 = &v62[2 * a5];
          *int v63 = v50 - v51;
          v63[1] = v54 - v52;
          ++v8;
          v10 += 8 * (a2 - 4) + 32;
          --v12;
        }
        while (v12);
        result += v10;
      }
    }
  }
  return result;
}

uint64_t idxcomp(uint64_t result, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v7 = result;
  if (a5)
  {
    int v9 = *(_DWORD *)a5;
    if (*(int *)a5 >= 1)
    {
      uint64_t v10 = *(unsigned int *)(a5 + 4);
      int v11 = *(_DWORD *)(a5 + 8);
      do
      {
        float result = idxcomp(v7, v6, v5, v10, *(void *)(a5 + 32));
        uint64_t v6 = (v6 + v10);
        uint64_t v5 = (v5 + v11);
        --v9;
      }
      while (v9);
    }
  }
  else
  {
    *(_DWORD *)(result + 4 * ((int)a2 / a4)) = a3;
  }
  return result;
}

char *hfft_create(int *a1, int a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = (a2 - 1);
  if (a2 >= 2)
  {
    uint64_t v5 = (a2 - 1);
    uint64_t v6 = a1;
    do
    {
      int v7 = *v6++;
      if ((v7 - 6) < 0xFFFFFFFC) {
        return 0;
      }
    }
    while (--v5);
  }
  if (a1[(int)v4] != 5) {
    return 0;
  }
  int v8 = (char *)malloc_type_malloc(0x20uLL, 0x10B004083B02B1BuLL);
  if (a2 < 1) {
    goto LABEL_27;
  }
  unint64_t v9 = a2;
  int v10 = 1;
  uint64_t v11 = a2;
  int v12 = v3;
  do
  {
    int v13 = *v12++;
    v10 *= v13;
    --v11;
  }
  while (v11);
  if (a2 < 2)
  {
LABEL_27:
    free(v8);
    return 0;
  }
  uint64_t v14 = 0;
  float v15 = 0;
  float v42 = v8;
  float v43 = v8 + 24;
  float v16 = v3 + 1;
  uint64_t v17 = 1;
  int v18 = 1;
  unint64_t v44 = v9;
  uint64_t v45 = v4;
  float v46 = v3;
  do
  {
    float v19 = v15;
    float v20 = (int *)malloc_type_malloc(0x28uLL, 0x10A004035BA01DCuLL);
    *((void *)v20 + 4) = 0;
    float v21 = v19 + 8;
    if (!v19) {
      float v21 = v43;
    }
    *float v21 = v20;
    int v22 = v3[v14];
    *float v20 = v22;
    int v52 = v18;
    float v51 = v16;
    uint64_t v48 = v14 + 1;
    int v23 = 1;
    if (v14 + 1 < v9)
    {
      unint64_t v24 = v9;
      float v25 = v16;
      do
      {
        int v26 = *v25++;
        v23 *= v26;
        --v24;
      }
      while (v17 != v24);
    }
    v20[1] = v23;
    void v20[2] = v10 / (v23 * v22);
    uint64_t v49 = v14;
    float v50 = v20;
    int v47 = v3[v14];
    float v27 = (char *)malloc_type_malloc(8 * v22 * (uint64_t)v23, 0xDE9C4163uLL);
    if (v22 >= 1)
    {
      int v28 = 0;
      for (int i = 0; i != v22; ++i)
      {
        if (v23 >= 1)
        {
          int v30 = 0;
          float v31 = (float32x2_t *)&v27[8 * v28];
          v28 += v23;
          int v32 = v23;
          do
          {
            __double2 v34 = __sincos_stret((float)((float)((float)v30 * -6.2832) / (float)(v23 * v22)));
            v33.f64[0] = v34.__cosval;
            v33.f64[1] = v34.__sinval;
            *v31++ = vcvt_f32_f64(v33);
            v30 += i;
            --v32;
          }
          while (v32);
        }
      }
    }
    float v15 = v50;
    *((void *)v50 + 2) = v27;
    uint64_t v3 = v46;
    int v18 = v47 * v52;
    *((void *)v50 + 3) = kernels[v46[v49]];
    ++v17;
    float v16 = v51 + 1;
    uint64_t v14 = v48;
    unint64_t v9 = v44;
  }
  while (v48 != v45);
  float v35 = malloc_type_malloc(4 * v50[2] * (uint64_t)*v50, 0x34A6ED2EuLL);
  uint64_t v36 = *((void *)v42 + 3);
  int v37 = *(_DWORD *)v36;
  int v38 = *(_DWORD *)(v36 + 4);
  *(_DWORD *)float v42 = v18;
  if (v37 >= 1)
  {
    uint64_t v39 = 0;
    uint64_t v40 = 0;
    do
    {
      idxcomp((uint64_t)v35, v39, v40, 0, *(void *)(v36 + 32));
      uint64_t v39 = (v39 + v38);
      uint64_t v40 = (v40 + 1);
    }
    while (v37 != v40);
  }
  float result = v42;
  *((void *)v42 + 1) = v35;
  *((void *)v42 + 2) = butterfly5last;
  return result;
}

void hfft_destroy(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    do
    {
      uint64_t v3 = *(void *)(v2 + 32);
      free(*(void **)(v2 + 16));
      free((void *)v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  free(*(void **)(a1 + 8));

  free((void *)a1);
}

uint64_t hfft_run(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = (unsigned int *)a1[3];
  (*((void (**)(uint64_t, uint64_t, void))v4 + 3))(a2, a3, v4[1]);
  uint64_t v5 = *((void *)v4 + 2);
  signed int v6 = v4[1];
  uint64_t v7 = v4[2];
  uint64_t v8 = *v4;
  unint64_t v9 = (unsigned int *)*((void *)v4 + 4);
  if (v9)
  {
    do
    {
      uint64_t v10 = v9[1];
      if ((int)v7 >= 1)
      {
        int v11 = 0;
        unint64_t v24 = v9;
        int v12 = (void (*)(uint64_t, uint64_t, uint64_t))*((void *)v9 + 3);
        uint64_t v13 = 8 * v6;
        uint64_t v14 = a2;
        do
        {
          if ((int)v8 >= 1)
          {
            uint64_t v15 = 0;
            int v16 = v8;
            do
            {
              v12(v14 + v15, v5 + v15, v10);
              v15 += v13;
              --v16;
            }
            while (v16);
            v14 += v15;
          }
          ++v11;
        }
        while (v11 != v7);
        unint64_t v9 = v24;
        uint64_t v10 = v24[1];
      }
      uint64_t v5 = *((void *)v9 + 2);
      uint64_t v7 = v9[2];
      uint64_t v8 = *v9;
      signed int v6 = v10;
      unint64_t v9 = (unsigned int *)*((void *)v9 + 4);
    }
    while (v9);
  }
  else
  {
    uint64_t v10 = v4[1];
  }
  uint64_t v17 = *(unsigned int *)a1;
  uint64_t v18 = a1[1];
  float v19 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))a1[2];

  return v19(a2, v10, v5, a4, v17, v18, v7, v8);
}

char *imdct_create(signed int a1)
{
  uint64_t v2 = (char *)malloc_type_malloc(0x60uLL, 0x10A004068F99EA3uLL);
  *((_DWORD *)v2 + 4) = a1;
  int32x2_t v3 = vshl_s32(vdup_n_s32(a1), (int32x2_t)0xFFFFFFFEFFFFFFFFLL);
  int v53 = v3.i32[0];
  *(int32x2_t *)(v2 + 20) = v3;
  uint64_t v4 = 2 * a1;
  *(void *)uint64_t v2 = malloc_type_malloc(4 * v4, 0x100004052888210uLL);
  *((void *)v2 + 1) = malloc_type_malloc(4 * (a1 + 1), 0x100004052888210uLL);
  int v5 = v53;
  *((void *)v2 + 4) = malloc_type_malloc(4 * v53, 0x100004052888210uLL);
  *((void *)v2 + 5) = malloc_type_malloc(4 * v53, 0x100004052888210uLL);
  size_t v6 = 4 * (v53 + 1);
  *((void *)v2 + 7) = malloc_type_malloc(v6, 0x100004052888210uLL);
  *((void *)v2 + 8) = malloc_type_malloc(v6, 0x100004052888210uLL);
  *((void *)v2 + 6) = malloc_type_malloc(8 * v53, 0x100004000313F17uLL);
  *((void *)v2 + 9) = malloc_type_malloc(8 * v53, 0x100004000313F17uLL);
  *((void *)v2 + 10) = malloc_type_malloc(8 * v53, 0x100004000313F17uLL);
  uint64_t v7 = *(void *)v2;
  double v8 = (double)(2 * a1);
  if (2 * a1 >= 1)
  {
    uint64_t v9 = v4;
    float v10 = 3.14159265 / v8;
    double v47 = v10;
    uint64x2_t v46 = (uint64x2_t)vdupq_n_s64((unint64_t)v4 - 1);
    int32x2_t v11 = (int32x2_t)0x100000000;
    uint64x2_t v12 = (uint64x2_t)xmmword_72000;
    uint64_t v13 = (float *)(v7 + 4);
    __asm { FMOV            V2.2D, #0.5 }
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3FC90FDBu);
    int64x2_t v44 = vdupq_n_s64(2uLL);
    float64x2_t v45 = _Q2;
    do
    {
      int32x2_t v52 = vmovn_s64((int64x2_t)vcgeq_u64(v46, v12));
      int64x2_t v54 = (int64x2_t)v12;
      v20.i64[0] = v11.i32[0];
      v20.i64[1] = v11.i32[1];
      float64x2_t __x = vmulq_n_f64(vaddq_f64(vcvtq_f64_s64(v20), v45), v47);
      long double v50 = sin(__x.f64[1]);
      v21.f64[0] = sin(__x.f64[0]);
      v21.f64[1] = v50;
      *(float32x2_t *)&v21.f64[0] = vcvt_f32_f64(v21);
      float64x2_t __xa = vcvtq_f64_f32(vmul_f32(vmul_f32(*(float32x2_t *)&v21.f64[0], v19), *(float32x2_t *)&v21.f64[0]));
      double v51 = sin(__xa.f64[1]);
      double v22 = sin(__xa.f64[0]);
      if (v52.i8[0])
      {
        float v23 = v22;
        *(v13 - 1) = v23;
      }
      if (v52.i8[4])
      {
        float v24 = v51;
        *uint64_t v13 = v24;
      }
      uint64x2_t v12 = (uint64x2_t)vaddq_s64(v54, v44);
      int32x2_t v11 = vadd_s32(v11, (int32x2_t)0x200000002);
      v13 += 2;
      v9 -= 2;
    }
    while (v9);
  }
  int v25 = 3 * v5;
  if (3 * v5 < (int)v4)
  {
    int v26 = (float *)(v7 + 4 * v25);
    uint64_t v27 = v4 - v25;
    do
    {
      *int v26 = -*v26;
      ++v26;
      --v27;
    }
    while (v27);
  }
  if ((int)v4 >= 2)
  {
    for (uint64_t i = 1; i < v4; i += 2)
      *(float *)(v7 + 4 * i) = -*(float *)(v7 + 4 * i);
  }
  if (a1 >= 2)
  {
    uint64_t v29 = 0;
    float v30 = -6.28318531 / v8;
    float v31 = 8.0 / sqrt((float)a1);
    double v32 = sqrtf(v31);
    uint64_t v33 = *((void *)v2 + 5);
    uint64_t v34 = *((void *)v2 + 4);
    if (v5 <= 1) {
      uint64_t v35 = 1;
    }
    else {
      uint64_t v35 = v5;
    }
    uint64_t v36 = (float *)(*((void *)v2 + 6) + 4);
    do
    {
      __double2 v37 = __sincos_stret((float)((float)((float)(int)v29 + 0.125) * v30));
      float v38 = v37.__cosval * v32;
      *(float *)(v34 + 4 * v29) = v38;
      *(v36 - 1) = v38;
      float v39 = v37.__sinval * v32;
      *(float *)(v33 + 4 * v29) = v39;
      *uint64_t v36 = v39;
      v36 += 2;
      ++v29;
    }
    while (v35 != v29);
  }
  bzero(*((void **)v2 + 1), 4 * *((int *)v2 + 4));
  *((void *)v2 + 11) = 0;
  if (v5 <= 79)
  {
    if (v5 == 40)
    {
      uint64_t v42 = 0x400000002;
    }
    else
    {
      if (v5 != 60) {
        goto LABEL_34;
      }
      uint64_t v42 = 0x400000003;
    }
LABEL_31:
    qword_A2328 = v42;
    float v41 = &dword_A2330;
    int v40 = 3;
    goto LABEL_32;
  }
  if (v5 == 80)
  {
    uint64_t v42 = 0x400000004;
    goto LABEL_31;
  }
  if (v5 == 90)
  {
    qword_A2328 = 0x300000002;
    dword_A2330 = 3;
    float v41 = &dword_A2334;
    int v40 = 4;
    goto LABEL_32;
  }
  if (v5 != 120)
  {
LABEL_34:
    imdct_destroy((uint64_t)v2);
    return 0;
  }
  qword_A2328 = 0x300000002;
  int v40 = 4;
  dword_A2330 = 4;
  float v41 = &dword_A2334;
LABEL_32:
  int *v41 = 5;
  *((void *)v2 + 11) = hfft_create((int *)&qword_A2328, v40);
  return v2;
}

void imdct_reset(uint64_t a1)
{
}

void imdct_destroy(uint64_t a1)
{
  free(*(void **)a1);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 56));
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 72));
  free(*(void **)(a1 + 80));
  uint64_t v2 = *(void *)(a1 + 88);
  if (v2) {
    hfft_destroy(v2);
  }

  free((void *)a1);
}

void imdct(uint64_t a1, float *a2, int a3, float *a4)
{
  uint64_t v7 = *(const float **)a1;
  double v8 = *(float **)(a1 + 8);
  uint64_t v9 = *(unsigned int *)(a1 + 20);
  vDSP_Length __N = *(int *)(a1 + 24);
  vDSP_Length v11 = (int)v9;
  uint64_t v12 = *(void *)(a1 + 72);
  uint64_t v13 = *(const DSPComplex **)(a1 + 80);
  if (a3 < 0) {
    float v14 = (float)(1 << -(char)a3);
  }
  else {
    float v14 = 1.0 / (double)(1 << a3);
  }
  uint64_t v15 = *(int *)(a1 + 16);
  if ((int)v9 >= 1)
  {
    int v16 = &a2[v15 - 1];
    uint64_t v17 = (float *)(v12 + 4);
    do
    {
      float v18 = *a2;
      a2 += 2;
      *(v17 - 1) = v14 * v18;
      float v19 = *v16;
      v16 -= 2;
      *uint64_t v17 = v14 * v19;
      v17 += 2;
      --v9;
    }
    while (v9);
  }
  hfft_run(*(void **)(a1 + 88), v12, *(void *)(a1 + 48), (uint64_t)v13);
  vDSP_ctoz(v13, 2, (const DSPSplitComplex *)(a1 + 56), 1, v11);
  vDSP_zvmul((const DSPSplitComplex *)(a1 + 56), 1, (const DSPSplitComplex *)(a1 + 32), 1, (const DSPSplitComplex *)(a1 + 56), 1, v11, 1);
  vDSP_vma((const float *)(*(void *)(a1 + 56) + 4 * __N), 1, v7, 2, v8, 2, a4, 2, __N);
  vDSP_vmul((const float *)(*(void *)(a1 + 64) + 4 * __N), 1, &v7[v15], 2, v8, 2, __N);
  vDSP_vma((const float *)(*(void *)(a1 + 64) + 4 * __N - 4), -1, v7 + 1, 2, v8 + 1, 2, a4 + 1, 2, __N);
  vDSP_vmul((const float *)(*(void *)(a1 + 56) + 4 * __N - 4), -1, &v7[v15 + 1], 2, v8 + 1, 2, __N);
  int64x2_t v20 = &v7[v11];
  float64x2_t v21 = &v8[v11];
  double v22 = &a4[v11];
  vDSP_vma(*(const float **)(a1 + 64), 1, v20, 2, v21, 2, v22, 2, __N);
  float v23 = &v7[3 * v11];
  vDSP_vmul(*(const float **)(a1 + 56), 1, v23, 2, v21, 2, __N);
  float v24 = v21 + 1;
  vDSP_vma((const float *)(*(void *)(a1 + 56) + 4 * v11 - 4), -1, v20 + 1, 2, v24, 2, v22 + 1, 2, __N);
  int v25 = (const float *)(*(void *)(a1 + 64) + 4 * v11 - 4);

  vDSP_vmul(v25, -1, v23 + 1, 2, v24, 2, __N);
}

int32x2_t *mdct_create(signed int a1)
{
  uint64_t v2 = (int32x2_t *)malloc_type_malloc(0x60uLL, 0x10A0040482D8A59uLL);
  v2[2].i32[0] = 2 * a1;
  v2[2].i32[1] = a1;
  int32x2_t v3 = vshl_s32(vdup_n_s32(a1), (int32x2_t)0xFFFFFFFEFFFFFFFFLL);
  __int32 v51 = v3.i32[0];
  v2[3] = v3;
  uint64_t v4 = 2 * a1;
  *uint64_t v2 = (int32x2_t)malloc_type_malloc(4 * v4, 0x100004052888210uLL);
  v2[1] = (int32x2_t)malloc_type_malloc(4 * v4, 0x100004052888210uLL);
  uint64_t v5 = v51;
  v2[4] = (int32x2_t)malloc_type_malloc(4 * v51, 0x100004052888210uLL);
  double v2[5] = (int32x2_t)malloc_type_malloc(4 * v51, 0x100004052888210uLL);
  size_t v6 = 4 * (v51 + 1);
  v2[9] = (int32x2_t)malloc_type_malloc(v6, 0x100004052888210uLL);
  v2[10] = (int32x2_t)malloc_type_malloc(v6, 0x100004052888210uLL);
  v2[6] = (int32x2_t)malloc_type_malloc(8 * v51, 0x100004000313F17uLL);
  v2[7] = (int32x2_t)malloc_type_malloc(8 * v51, 0x100004000313F17uLL);
  v2[8] = (int32x2_t)malloc_type_malloc(8 * v51, 0x100004000313F17uLL);
  int32x2_t v7 = *v2;
  double v8 = (double)(2 * a1);
  if (2 * a1 >= 1)
  {
    uint64_t v9 = v4;
    float v10 = 3.14159265 / v8;
    double v45 = v10;
    uint64x2_t v44 = (uint64x2_t)vdupq_n_s64((unint64_t)v4 - 1);
    int32x2_t v11 = (int32x2_t)0x100000000;
    uint64x2_t v12 = (uint64x2_t)xmmword_72000;
    uint64_t v13 = (float *)(*(void *)&v7 + 4);
    __asm { FMOV            V2.2D, #0.5 }
    float32x2_t v19 = (float32x2_t)vdup_n_s32(0x3FC90FDBu);
    int64x2_t v42 = vdupq_n_s64(2uLL);
    float64x2_t v43 = _Q2;
    do
    {
      int32x2_t v50 = vmovn_s64((int64x2_t)vcgeq_u64(v44, v12));
      int64x2_t v52 = (int64x2_t)v12;
      v20.i64[0] = v11.i32[0];
      v20.i64[1] = v11.i32[1];
      float64x2_t __x = vmulq_n_f64(vaddq_f64(vcvtq_f64_s64(v20), v43), v45);
      long double v48 = sin(__x.f64[1]);
      v21.f64[0] = sin(__x.f64[0]);
      v21.f64[1] = v48;
      *(float32x2_t *)&v21.f64[0] = vcvt_f32_f64(v21);
      float64x2_t __xa = vcvtq_f64_f32(vmul_f32(vmul_f32(*(float32x2_t *)&v21.f64[0], v19), *(float32x2_t *)&v21.f64[0]));
      double v49 = sin(__xa.f64[1]);
      double v22 = sin(__xa.f64[0]);
      if (v50.i8[0])
      {
        float v23 = v22;
        *(v13 - 1) = v23;
      }
      if (v50.i8[4])
      {
        float v24 = v49;
        *uint64_t v13 = v24;
      }
      uint64x2_t v12 = (uint64x2_t)vaddq_s64(v52, v42);
      int32x2_t v11 = vadd_s32(v11, (int32x2_t)0x200000002);
      v13 += 2;
      v9 -= 2;
    }
    while (v9);
  }
  if ((int)v5 < (int)v4)
  {
    int v25 = (float *)(*(void *)&v7 + 4 * v5);
    uint64_t v26 = v4 - v5;
    do
    {
      *int v25 = -*v25;
      ++v25;
      --v26;
    }
    while (v26);
  }
  if (a1 >= 2)
  {
    uint64_t v27 = 0;
    float v28 = -6.28318531 / v8;
    float v29 = sqrt(0.25 / sqrt((float)a1));
    double v30 = v29;
    int32x2_t v31 = v2[5];
    int32x2_t v32 = v2[4];
    if ((int)v5 <= 1) {
      uint64_t v33 = 1;
    }
    else {
      uint64_t v33 = v5;
    }
    uint64_t v34 = (float *)(*(void *)&v2[6] + 4);
    do
    {
      __double2 v35 = __sincos_stret((float)((float)((float)(int)v27 + 0.125) * v28));
      float v36 = v35.__cosval * v30;
      *(float *)(*(void *)&v32 + 4 * v27) = v36;
      *(v34 - 1) = v36;
      float v37 = v35.__sinval * v30;
      *(float *)(*(void *)&v31 + 4 * v27) = v37;
      *uint64_t v34 = v37;
      v34 += 2;
      ++v27;
    }
    while (v33 != v27);
  }
  bzero(*(void **)&v2[1], 4 * v2[2].i32[0]);
  v2[11] = 0;
  if ((int)v5 <= 79)
  {
    if (v5 == 40)
    {
      uint64_t v40 = 0x400000002;
    }
    else
    {
      if (v5 != 60) {
        goto LABEL_31;
      }
      uint64_t v40 = 0x400000003;
    }
LABEL_28:
    qword_A2338 = v40;
    float v39 = &dword_A2340;
    int v38 = 3;
    goto LABEL_29;
  }
  if (v5 == 80)
  {
    uint64_t v40 = 0x400000004;
    goto LABEL_28;
  }
  if (v5 == 90)
  {
    qword_A2338 = 0x300000002;
    dword_A2340 = 3;
    float v39 = &dword_A2344;
    int v38 = 4;
    goto LABEL_29;
  }
  if (v5 != 120)
  {
LABEL_31:
    mdct_destroy((uint64_t)v2);
    return 0;
  }
  qword_A2338 = 0x300000002;
  int v38 = 4;
  dword_A2340 = 4;
  float v39 = &dword_A2344;
LABEL_29:
  *float v39 = 5;
  v2[11] = (int32x2_t)hfft_create((int *)&qword_A2338, v38);
  return v2;
}

void mdct_reset(uint64_t a1)
{
}

void mdct_destroy(uint64_t a1)
{
  free(*(void **)a1);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 72));
  free(*(void **)(a1 + 80));
  free(*(void **)(a1 + 56));
  free(*(void **)(a1 + 64));
  uint64_t v2 = *(void *)(a1 + 88);
  if (v2) {
    hfft_destroy(v2);
  }

  free((void *)a1);
}

float mdct(uint64_t a1, const void *a2, uint64_t a3)
{
  size_t v6 = *(const float **)a1;
  int32x2_t v7 = *(char **)(a1 + 8);
  uint64_t v8 = *(int *)(a1 + 20);
  vDSP_Length v9 = *(int *)(a1 + 24);
  vDSP_Length __N = *(int *)(a1 + 28);
  uint64_t v20 = *(int *)(a1 + 16);
  float __C = *(DSPComplex **)(a1 + 56);
  double v22 = *(const DSPComplex **)(a1 + 64);
  memcpy(v7, &v7[4 * v8], 4 * v8);
  memcpy(&v7[4 * v8], a2, 4 * v8);
  int32x2_t v11 = (const float **)(a1 + 72);
  vDSP_vmul(&v6[3 * v9], 2, (const float *)&v7[12 * v9], 2, *(float **)(a1 + 72), 1, __N);
  vDSP_vma(&v6[3 * v9 - 1], -2, (const float *)&v7[12 * v9 - 4], -2, *v11, 1, (float *)*v11, 1, __N);
  vDSP_vmul(&v6[v9 - 1], -2, (const float *)&v7[4 * v9 - 4], -2, *(float **)(a1 + 80), 1, __N);
  vDSP_vma(&v6[v9], 2, (const float *)&v7[4 * v9], 2, *(const float **)(a1 + 80), 1, *(float **)(a1 + 80), 1, __N);
  vDSP_vmul(v6, 2, (const float *)v7, 2, (float *)(*(void *)(a1 + 72) + 4 * __N), 1, __N);
  uint64x2_t v12 = (const float *)&v7[4 * v8];
  vDSP_vma(&v6[v8 - 1], -2, v12 - 1, -2, &(*v11)[__N], 1, (float *)&(*v11)[__N], 1, __N);
  vDSP_vmul(&v6[v20 - 1], -2, (const float *)&v7[4 * v20 - 4], -2, (float *)(*(void *)(a1 + 80) + 4 * __N), 1, __N);
  vDSP_vma(&v6[v8], 2, v12, 2, (const float *)(*(void *)(a1 + 80) + 4 * __N), 1, (float *)(*(void *)(a1 + 80) + 4 * __N), 1, __N);
  vDSP_ztoc((const DSPSplitComplex *)(a1 + 72), 1, __C, 2, v9);
  hfft_run(*(void **)(a1 + 88), (uint64_t)__C, *(void *)(a1 + 48), (uint64_t)v22);
  vDSP_ctoz(v22, 2, (const DSPSplitComplex *)(a1 + 72), 1, v9);
  vDSP_zvmul((const DSPSplitComplex *)(a1 + 72), 1, (const DSPSplitComplex *)(a1 + 32), 1, (const DSPSplitComplex *)(a1 + 72), 1, v9, 1);
  if ((int)v8 >= 1)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *(int **)(a1 + 72);
    int v16 = (float *)(*(void *)(a1 + 80) + 4 * v9 - 4);
    do
    {
      int v17 = *v15++;
      uint64_t v18 = a3 + 4 * v14;
      *(_DWORD *)uint64_t v18 = v17;
      float v19 = *v16--;
      float result = -v19;
      *(float *)(v18 + 4) = -v19;
      v14 += 2;
    }
    while (v14 < v8);
  }
  return result;
}

void *mask_create(int a1, float a2)
{
  uint64_t v4 = malloc_type_malloc(0x18uLL, 0x80040D6874129uLL);
  uint64_t v5 = (a1 - 1);
  size_t v6 = (float *)malloc_type_malloc(4 * (int)v5, 0x100004052888210uLL);
  void *v4 = v6;
  int32x2_t v7 = (float *)malloc_type_malloc(4 * (int)v5, 0x100004052888210uLL);
  v4[1] = v7;
  uint64_t v8 = (float *)malloc_type_malloc(4 * a1, 0x100004052888210uLL);
  _DWORD v4[2] = v8;
  float v26 = a2 / (float)(2 * a1);
  float v9 = v26 * 0.5;
  float v10 = logf((float)(v26 * 0.5) / 800.0) * 426.666667 / 2.30258512;
  float v11 = v10 * 0.000030518;
  BOOL v12 = v10 <= 0.0;
  float v13 = 0.0;
  if (v12) {
    float v13 = v11;
  }
  *uint64_t v8 = v13;
  if (a1 >= 2)
  {
    double v14 = atan(v9 * 0.00076);
    float v15 = atan((float)(v9 * v9) / 56250000.0) * 3.5 + v14 * 13.0;
    int v16 = v8 + 1;
    do
    {
      float v9 = v26 + v9;
      double v17 = atan(v9 * 0.00076);
      float v18 = atan((float)(v9 * v9) / 56250000.0) * 3.5 + v17 * 13.0;
      double v19 = (float)(v18 - v15);
      float v20 = v19 * 213.333333 * 0.0000305175781;
      *v6++ = v20;
      float v21 = v19 * 533.333333 * 0.0000305175781;
      *v7++ = v21;
      float v22 = logf(v9 / 800.0) * 426.666667 / 2.30258512;
      float v23 = v22 * 0.000030518;
      BOOL v12 = v22 <= 0.0;
      float v24 = 0.0;
      if (v12) {
        float v24 = v23;
      }
      *v16++ = v24;
      float v15 = v18;
      --v5;
    }
    while (v5);
  }
  return v4;
}

void mask_destroy(void **a1)
{
  free(*a1);
  free(a1[1]);
  free(a1[2]);

  free(a1);
}

_DWORD *quantizer_create(int a1, int a2, int a3, float a4)
{
  uint64_t v8 = malloc_type_malloc(0x48uLL, 0x10B00401F5B3E71uLL);
  *(void *)uint64_t v8 = mask_create(a1, a4);
  _OWORD v8[2] = a1;
  _DWORD v8[3] = a2;
  v8[4] = 16 * a3 - 4;
  v8[5] = a3;
  *((void *)v8 + 5) = malloc_type_malloc(4 * a1, 0x100004052888210uLL);
  *((void *)v8 + 6) = malloc_type_malloc(4 * a1, 0x100004052888210uLL);
  size_t v9 = 4 * a2;
  *((void *)v8 + 7) = malloc_type_malloc(v9, 0x100004052888210uLL);
  size_t v10 = 16 * a2;
  *((void *)v8 + 3) = malloc_type_malloc(v10, 0x1050040606E6C2FuLL);
  *((void *)v8 + 4) = malloc_type_malloc(v10, 0x1050040606E6C2FuLL);
  *((void *)v8 + 8) = malloc_type_malloc(v9, 0x100004052888210uLL);
  return v8;
}

void quantizer_destroy(uint64_t a1)
{
  mask_destroy(*(void ***)a1);
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 56));
  free(*(void **)(a1 + 24));
  free(*(void **)(a1 + 32));
  free(*(void **)(a1 + 64));

  free((void *)a1);
}

uint64_t computeMask(uint64_t result, float *a2, float *a3, int a4)
{
  uint64_t v4 = *(void *)(result + 8);
  uint64_t v5 = *(float **)(result + 16);
  float v6 = (float)(*a2 + *v5) - **(float **)result;
  uint64_t v7 = (a4 - 1);
  if (a4 >= 3)
  {
    uint64_t v8 = (float *)(*(void *)result + 4);
    size_t v9 = v5 + 1;
    size_t v10 = a2 + 1;
    float v11 = a3 + 1;
    uint64_t v12 = v7 - 1;
    do
    {
      *v11++ = v6;
      float v13 = *v10++;
      float v14 = v13;
      float v15 = *v9++;
      float v16 = v14 + v15;
      if (v16 > v6) {
        float v6 = v16;
      }
      float v17 = *v8++;
      float v6 = v6 - v17;
      --v12;
    }
    while (v12);
  }
  a3[(int)v7] = v6;
  float v18 = a2[(int)v7] + v5[(int)v7];
  uint64_t v19 = (a4 - 2);
  float v20 = v18 - *(float *)(v4 + 4 * (int)v19);
  if (a4 >= 3)
  {
    do
    {
      if (a3[v19] < v20) {
        a3[v19] = v20;
      }
      float v21 = v5[v19];
      if ((float)(a2[v19] + v21) > v20) {
        float v20 = a2[v19] + v21;
      }
      BOOL v22 = v19-- <= 1;
      float v20 = v20 - *(float *)(v4 + 4 * v19);
    }
    while (!v22);
  }
  *a3 = v20;
  return result;
}

uint64_t normalize(const float *a1, int a2)
{
  int32x2_t v3 = a1;
  float __C = 0.0;
  vDSP_maxmgv(a1, 1, &__C, a2);
  unsigned int v4 = 1056964608 - (LODWORD(__C) & 0xFF800000);
  if (LODWORD(__C) >> 27 < 7) {
    unsigned int v4 = 125829120;
  }
  if (HIBYTE(LODWORD(__C)) <= 0x3Eu) {
    unsigned int v5 = v4;
  }
  else {
    unsigned int v5 = 0;
  }
  if (a2 >= 1)
  {
    uint64_t v6 = a2;
    do
    {
      *(_DWORD *)v3++ += v5;
      --v6;
    }
    while (v6);
  }
  return v5 >> 23;
}

uint64_t q(float a1)
{
  int v1 = 0;
  unsigned int v2 = 62;
  int v3 = 62;
  do
  {
    int v4 = v1 + (v2 >> 1);
    if (huff_vals[v4] <= a1) {
      int v1 = v4;
    }
    else {
      int v3 = v4;
    }
    unsigned int v2 = v3 - v1;
  }
  while (v3 - v1 > 1);
  if (vabds_f32(huff_vals[v1], a1) >= vabds_f32(huff_vals[v3], a1)) {
    return v3;
  }
  else {
    return v1;
  }
}

uint64_t qred(float a1)
{
  LODWORD(v1) = 0;
  unsigned int v2 = 24;
  int v3 = 24;
  do
  {
    int v4 = v1 + (v2 >> 1);
    if (rhuff_vals[v4] <= a1) {
      LODWORD(v1) = v4;
    }
    else {
      int v3 = v4;
    }
    unsigned int v2 = v3 - v1;
  }
  while (v3 - (int)v1 > 1);
  if (vabds_f32(rhuff_vals[(int)v1], a1) >= vabds_f32(rhuff_vals[v3], a1)) {
    uint64_t v1 = v3;
  }
  else {
    uint64_t v1 = (int)v1;
  }
  return rix_xlat[v1];
}

void quantize(uint64_t a1, const float *a2, uint64_t a3)
{
  unsigned int v5 = *(char **)(a1 + 24);
  long long __dst = *(char **)(a1 + 32);
  int v7 = *(_DWORD *)(a1 + 8);
  uint64_t v6 = *(unsigned int *)(a1 + 12);
  size_t v9 = *(float **)(a1 + 40);
  uint64_t v8 = *(float **)(a1 + 48);
  size_t v10 = *(float **)(a1 + 56);
  int v53 = *(_DWORD *)(a1 + 16);
  unsigned int v11 = normalize(a2, v7);
  float v57 = 1.0;
  vDSP_vabs(a2, 1, v9, 1, v7);
  float __B = 1.0e-10;
  vDSP_vsadd(v9, 1, &__B, v9, 1, v7);
  vDSP_vdbcon(v9, 1, &v57, v9, 1, v7, 1u);
  uint64_t v49 = a1;
  computeMask(*(void *)a1, v9, v8, v7);
  int64x2_t v52 = v8;
  vDSP_vsub(v8, 1, v9, 1, v10, 1, (int)v6);
  if ((int)v6 < 1)
  {
    int v16 = v6;
  }
  else
  {
    uint64_t v12 = 0;
    float v13 = v5 + 8;
    do
    {
      *((_DWORD *)v13 - 2) = v12;
      int v14 = q(a2[v12]);
      *((_DWORD *)v13 - 1) = v14;
      *float v13 = *(&bitlists + v14);
      v13 += 2;
      ++v12;
    }
    while (v6 != v12);
    int v15 = 0;
    int v16 = v6;
    do
    {
      if (*(_DWORD *)&v5[16 * v15 + 4] == 31)
      {
        long long v17 = *(_OWORD *)&v5[16 * v15];
        *(_OWORD *)&v5[16 * v15] = *(_OWORD *)&v5[16 * --v16];
        *(_OWORD *)&v5[16 * v16] = v17;
        *(float *)&long long v17 = v10[v15];
        v10[v15] = v10[v16];
        LODWORD(v10[v16]) = v17;
      }
      else
      {
        ++v15;
      }
    }
    while (v15 < v16);
  }
  memcpy(__dst, v5, 16 * (int)v6);
  int v18 = v6 - v16;
  if (v16 >= 1)
  {
    for (uint64_t i = 0; i != v16; *(void *)&v5[16 * i++ + 8] = v22)
    {
      float v20 = &v5[16 * i];
      int v21 = qred(a2[*(int *)v20]);
      *((_DWORD *)v20 + 1) = v21;
      BOOL v22 = (char *)*(&bitlists + v21) - 4;
      do
      {
        int v23 = *((_DWORD *)v22 + 2);
        v22 += 4;
      }
      while (v23 != -1);
      v18 += huff_bits[v21];
    }
  }
  int v24 = v53;
  if (v18 <= v53) {
    int v25 = v18;
  }
  else {
    int v25 = v6;
  }
  if (v18 <= v53) {
    float v26 = v5;
  }
  else {
    float v26 = __dst;
  }
  if (v25 < v53 && v18 > v53 && v16 >= 1)
  {
    unsigned int v27 = 0;
    do
    {
      __I[0] = 0;
      vDSP_maxvi(v10, 1, (float *)__I, (vDSP_Length *)((char *)__I + 4), v16);
      uint64_t v28 = SHIDWORD(__I[0]);
      float v29 = &v26[16 * SHIDWORD(__I[0])];
      int32x2_t v32 = (int *)*((void *)v29 + 1);
      double v30 = (int **)(v29 + 8);
      int32x2_t v31 = v32;
      uint64_t v34 = v32 + 1;
      uint64_t v33 = v32[1];
      if (v33 == -1 || (int v35 = huff_bits[v33] - huff_bits[*v31] + v25, v35 > v24))
      {
        long long v36 = *(_OWORD *)&v26[16 * SHIDWORD(__I[0])];
        *(_OWORD *)&v26[16 * SHIDWORD(__I[0])] = *(_OWORD *)&v26[16 * --v16];
        *(_OWORD *)&v26[16 * v16] = v36;
        *(float *)&long long v36 = v10[v28];
        v10[v28] = v10[v16];
        LODWORD(v10[v16]) = v36;
      }
      else
      {
        uint64_t *v30 = v34;
        uint64_t v37 = *(int *)&v26[16 * v28];
        __C[0] = vabds_f32(a2[v37], huff_vals[v33]);
        vDSP_vdbcon(__C, 1, &v57, __C, 1, 1uLL, 1u);
        float v38 = v52[v37];
        int v24 = v53;
        v10[SHIDWORD(__I[0])] = __C[0] - v38;
        int v25 = v35;
      }
      if (v25 >= v24) {
        break;
      }
      if (v16 < 1) {
        break;
      }
    }
    while (v27++ < 0x9F);
  }
  if ((int)v6 < 1)
  {
    int v45 = 0;
    LOBYTE(v46) = 4;
LABEL_44:
    *(_WORD *)(a3 + 2 * v45++) = (-1 << v46) | v11;
    goto LABEL_45;
  }
  uint64_t v40 = *(int **)(v49 + 64);
  float v41 = (int **)(v26 + 8);
  uint64_t v42 = v6;
  do
  {
    uint64_t v43 = *((int *)v41 - 2);
    uint64x2_t v44 = *v41;
    v41 += 2;
    v40[v43] = *v44;
    --v42;
  }
  while (v42);
  int v45 = 0;
  int v46 = 4;
  do
  {
    uint64_t v47 = *v40++;
    v11 |= (unsigned __int16)huff_symbols[v47] << v46;
    v46 += huff_bits[v47];
    if (v46 >= 16)
    {
      *(_WORD *)(a3 + 2 * v45++) = v11;
      v11 >>= 16;
      v46 -= 16;
    }
    --v6;
  }
  while (v6);
  if ((v46 - 1) <= 0xE) {
    goto LABEL_44;
  }
LABEL_45:
  int v48 = *(_DWORD *)(v49 + 20);
  if (v45 < v48) {
    memset((void *)(a3 + 2 * v45), 255, 2 * (v48 + ~v45) + 2);
  }
}

double quantizer_lite_create()
{
  uint64_t v0 = malloc_type_malloc(0x2CuLL, 0x1000040D4159EFEuLL);
  *uint64_t v0 = xmmword_72410;
  v0[1] = xmmword_72420;
  *(void *)&double result = 3;
  *((void *)v0 + 4) = 3;
  *((_DWORD *)v0 + 10) = 4;
  return result;
}

uint64_t quantize_lite(uint64_t result, uint64_t a2, _OWORD *a3)
{
  uint64_t v3 = 0;
  LODWORD(v4) = *(_DWORD *)(result + 36);
  int v5 = *(_DWORD *)(result + 40);
  *(_OWORD *)((char *)a3 + 44) = 0u;
  a3[1] = 0u;
  a3[2] = 0u;
  *a3 = 0u;
  uint64_t v33 = result;
  uint64_t v34 = a3;
  do
  {
    uint64_t v6 = (int *)(result + 8 * v3);
    int v7 = *v6;
    uint64_t v8 = (float *)(a2 + 4 * *v6);
    int v9 = v6[1] - *v6;
    uint64_t v10 = (v9 + 1);
    float v11 = 0.0;
    if (v9 < 0) {
      goto LABEL_8;
    }
    uint64_t v12 = (float *)(a2 + 4 * v7);
    uint64_t v13 = (v9 + 1);
    do
    {
      float v14 = *v12++;
      float v15 = fabsf(v14);
      if (v15 > v11) {
        float v11 = v15;
      }
      --v13;
    }
    while (v13);
    if (v11 >= 0.5)
    {
      __int16 v17 = 0;
    }
    else
    {
LABEL_8:
      unsigned int v16 = 0;
      do
      {
        float v11 = v11 + v11;
        __int16 v17 = v16 + 1;
      }
      while (v11 < 0.5 && v16++ < 0xE);
    }
    *(_WORD *)a3 |= v17 << (12 - 4 * v3);
    if ((v9 & 0x80000000) == 0)
    {
      uint64_t v37 = v3;
      int v19 = *(_DWORD *)(result + 4 * v3 + 24);
      int v20 = 1 << (v19 - 1);
      int v36 = v19;
      double v21 = (double)(1 << v17);
      int v22 = ~(-1 << v19);
      int v23 = v8;
      uint64_t v24 = (v9 + 1);
      do
      {
        float v25 = *v23;
        float v26 = v21 * fabsf(*v23);
        float v27 = -8.0;
        if (v26 != 0.0) {
          float v27 = logf(v26) / 0.69315;
        }
        float v28 = v27 * -0.125;
        if (v27 < -8.0) {
          float v28 = 1.0;
        }
        int v29 = (int)((float)(v28 * (float)(unsigned __int16)v20) + 0.5);
        if ((unsigned __int16)v20 <= (unsigned __int16)v29) {
          LOWORD(v29) = v20 - 1;
        }
        if (v25 <= 0.0) {
          __int16 v30 = 0;
        }
        else {
          __int16 v30 = v20;
        }
        *v23++ = (float)(unsigned __int16)((v29 + v30) & v22);
        --v24;
      }
      while (v24);
      double result = v33;
      a3 = v34;
      uint64_t v3 = v37;
      do
      {
        unsigned int v31 = (int)*v8;
        int v32 = v5 - v36;
        if (v5 - v36 < 1)
        {
          if (v5 == v36)
          {
            *((_WORD *)v34 + (int)v4) |= v31;
            int v5 = 16;
            LODWORD(v4) = v4 + 1;
          }
          else
          {
            *((_WORD *)v34 + (int)v4) |= v31 >> (v36 - v5);
            uint64_t v4 = (int)v4 + 1;
            int v5 = v32 + 16;
            *((_WORD *)v34 + v4) = v31 << (v32 + 16);
          }
        }
        else
        {
          *((_WORD *)v34 + (int)v4) |= (_WORD)v31 << (v5 - v36);
          v5 -= v36;
        }
        ++v8;
        --v10;
      }
      while (v10);
    }
    ++v3;
  }
  while (v3 != 3);
  return result;
}

uint64_t unpack(unsigned __int16 *a1, int a2, uint64_t a3, int a4)
{
  unsigned int v4 = *a1;
  if (a2 < 1)
  {
    int v5 = 0;
LABEL_13:
    if (v5 < a4) {
      bzero((void *)(a3 + 4 * v5), 4 * (~v5 + a4) + 4);
    }
  }
  else
  {
    int v5 = 0;
    uint64_t v6 = root;
    unsigned int v7 = v4 >> 4;
    int v8 = 12;
    uint64_t v9 = 1;
    uint64_t v10 = root;
    while (1)
    {
      do
      {
        if (v7) {
          ++v10;
        }
        uint64_t v10 = (_UNKNOWN **********)*v10;
        if (!*v10)
        {
          if (v5 == a4) {
            return v4 & 0xF;
          }
          *(_DWORD *)(a3 + 4 * v5++) = *((_DWORD *)v10 + 2);
          uint64_t v10 = v6;
        }
        v7 >>= 1;
        --v8;
      }
      while (v8);
      if (v5 == a4) {
        break;
      }
      unsigned int v7 = a1[v9++];
      int v8 = 16;
      if (v9 == a2 + 1) {
        goto LABEL_13;
      }
    }
  }
  return v4 & 0xF;
}

double unpack_lite_create()
{
  uint64_t v0 = malloc_type_malloc(0x2CuLL, 0x1000040D4159EFEuLL);
  *uint64_t v0 = xmmword_72410;
  v0[1] = xmmword_72420;
  *(void *)&double result = 3;
  *((void *)v0 + 4) = 3;
  *((_DWORD *)v0 + 10) = 4;
  return result;
}

uint64_t unpack_lite_c(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5 = 0;
  int v7 = *(_DWORD *)(a1 + 36);
  int v6 = *(_DWORD *)(a1 + 40);
  unsigned int v8 = *a2;
  do
  {
    uint64_t v9 = (int *)(a1 + 8 * v5);
    int v11 = *v9;
    int v10 = v9[1];
    if (v11 <= v10)
    {
      int v13 = *(unsigned __int16 *)(a1 + 4 * v5 + 24);
      int v12 = v10 + 1;
      float v14 = (float *)(a4 + 4 * v11);
      int v15 = v12 - v11;
      do
      {
        v6 -= v13;
        if (v6 < 1)
        {
          uint64_t v17 = v7 + 1;
          int v16 = a2[v7];
          if (v6)
          {
            int v18 = v16 << -(char)v6;
            v6 += 16;
            int v16 = (a2[v17] >> v6) | v18;
          }
          else
          {
            int v6 = 16;
          }
          int v7 = v17;
        }
        else
        {
          int v16 = a2[v7] >> v6;
        }
        *v14++ = (float)((float)(0x8000u >> (((v8 >> (12 - 4 * v5)) & 0xF)
                                           + (((v16 & ~(-1 << v13))
                                             - ((unsigned __int16)(v16 & ~(-1 << v13)) >> (v13 - 1) << (v13 - 1))) << (4 - v13))))
                       * 0.000030518)
               * (float)(2 * ((unsigned __int16)(v16 & ~(-1 << v13)) >> (v13 - 1)) - 1);
        --v15;
      }
      while (v15);
    }
    else
    {
      int v12 = v11;
    }
    ++v5;
  }
  while (v5 != 3);
  if (v12 < a5) {
    bzero((void *)(a4 + 4 * v12), 4 * (~v12 + a5) + 4);
  }
  return 0;
}

uint64_t g726_init(uint64_t a1, int a2, __int16 a3)
{
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 4) = a2;
  *(_WORD *)a1 = a3;
  *(_DWORD *)(a1 + 10) = 0;
  *(_DWORD *)(a1 + 38) = 0;
  memset_pattern16((void *)(a1 + 42), asc_724A0, 4uLL);
  *(_DWORD *)(a1 + 22) = 0;
  *(void *)(a1 + 14) = 0;
  memset_pattern16((void *)(a1 + 26), asc_724A0, 0xCuLL);
  *(void *)(a1 + 46) = 0;
  *(_WORD *)(a1 + 60) = 544;
  *(_DWORD *)(a1 + 56) = 34816;
  return 0;
}

uint64_t g726_encode_frame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v69 = 0;
  int v70 = 0;
  unsigned __int16 v68 = 0;
  if (a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = a1 + 26;
    uint64_t v64 = a1 + 28;
    while (1)
    {
      __int16 v10 = *(_WORD *)(a2 + 2 * v5);
      if (*(_WORD *)a1 == 2) {
        __int16 v10 = linear_to_alaw(v10);
      }
      sub_603C8((__int16 *)a1, (_WORD *)&v70 + 1, &v70);
      unsigned int v11 = HIWORD(v70);
      if (*(_WORD *)a1 == 1) {
        unsigned int v12 = 0;
      }
      else {
        unsigned int v12 = (int)alaw_to_linear(v10) >> 2;
      }
      __int16 v13 = 0;
      if (v10 >= 0) {
        v12 &= 0x3FFFu;
      }
      if (v12 >= 0x2000) {
        LOWORD(v12) = v12 - 0x4000;
      }
      __int16 v14 = v11 ^ 0x8000;
      if (v11 < 0x4000) {
        __int16 v14 = v11;
      }
      int v15 = (__int16)(v12 - v14);
      int v16 = *(__int16 *)(a1 + 46);
      int v17 = v16 >> 2;
      if (v16 > 255) {
        LOWORD(v17) = 64;
      }
      unsigned int v18 = *(_DWORD *)(a1 + 56);
      unsigned int v19 = (*(_WORD *)(a1 + 60) - (unsigned __int16)(v18 >> 6)) & 0x3FFF;
      unsigned int v20 = (((v18 >> 6) - *(unsigned __int16 *)(a1 + 60)) & 0x1FFF) * (__int16)v17;
      __int16 v21 = (v19 * (__int16)v17) >> 6;
      int v22 = -(v20 >> 6) & 0x3FFF;
      if (v19 >= 0x2000) {
        __int16 v21 = v22;
      }
      if (v15 >= 0) {
        unsigned int v23 = v15;
      }
      else {
        unsigned int v23 = -v15 & 0x7FFF;
      }
      int v24 = (unsigned __int16)v23;
      if (v23 >= 2)
      {
        __int16 v13 = 0;
        int v25 = 2;
        do
        {
          ++v13;
          v25 *= 2;
        }
        while (v25 <= v24);
      }
      __int16 v26 = v21 + (v18 >> 6);
      unsigned int v27 = v26 & 0x1FFF;
      unsigned int v28 = v27 >> 2;
      if (*(_DWORD *)(a1 + 4) != 32000)
      {
        __int16 v30 = 0;
        int v32 = 0;
        goto LABEL_42;
      }
      unsigned int v29 = ((((v24 << 7) >> v13) & 0x7F | (unsigned __int16)(v13 << 7)) - (_WORD)v28) & 0xFFF;
      if (v15 < 0) {
        break;
      }
      if (v29 <= 0xF83)
      {
        if (v29 <= 0x7FF)
        {
          if (v29 <= 0x18F)
          {
            if (v29 <= 0x15C)
            {
              if (v29 <= 0x12B)
              {
                if (v29 <= 0xF5)
                {
                  if (v29 <= 0xB1)
                  {
                    if (v29 <= 0x4F) {
                      __int16 v30 = 1;
                    }
                    else {
                      __int16 v30 = 2;
                    }
                    char v31 = v30;
                  }
                  else
                  {
                    __int16 v30 = 3;
                    char v31 = 3;
                  }
                }
                else
                {
                  __int16 v30 = 4;
                  char v31 = 4;
                }
              }
              else
              {
                __int16 v30 = 5;
                char v31 = 5;
              }
            }
            else
            {
              __int16 v30 = 6;
              char v31 = 6;
            }
          }
          else
          {
            __int16 v30 = 7;
            char v31 = 7;
          }
          goto LABEL_41;
        }
LABEL_39:
        __int16 v30 = 15;
        goto LABEL_40;
      }
      __int16 v30 = 1;
      char v31 = 1;
LABEL_41:
      int v32 = 32 * word_72470[v31 & 7];
LABEL_42:
      unsigned int v33 = v32 - (v26 & 0x1FFF);
      int v34 = (v33 >> 5) & 0xFFF;
      if ((v33 & 0x10000) != 0) {
        __int16 v35 = v34 | 0x1000;
      }
      else {
        __int16 v35 = v34;
      }
      int v36 = (v35 + v26) & 0x1FFF;
      __int16 v37 = v36 + 15840;
      if ((((_WORD)v36 + 11264) & 0x2000) == 0) {
        int v36 = 5120;
      }
      if ((v37 & 0x2000) != 0) {
        int v36 = 544;
      }
      *(_WORD *)(a1 + 60) = v36;
      unsigned int v38 = v36 + (-v18 >> 6);
      if ((v38 & 0x2000) != 0) {
        int v39 = v38 | 0x7C000;
      }
      else {
        int v39 = v38 & 0x3FFF;
      }
      *(_DWORD *)(a1 + 56) = (v39 + v18) & 0x7FFFF;
      *(unsigned char *)(a4 + v5) = v30;
      if (*(_DWORD *)(a1 + 4) == 32000)
      {
        int v40 = (v30 & 0xFFF8) << 12;
        LOWORD(v28) = word_72480[(unsigned __int16)v30] + v28;
        unsigned int v41 = v28 & 0xFFF;
        if (v41 <= 0x7FF) {
          goto LABEL_56;
        }
      }
      else
      {
        int v40 = 0;
        unsigned int v41 = (v27 >> 2) & 0xFFF;
        if (v41 <= 0x7FF)
        {
LABEL_56:
          signed int v42 = (((v28 & 0x7F) << 7) | 0x4000) >> (14 - (v41 >> 7));
          goto LABEL_57;
        }
      }
      signed int v42 = 0;
LABEL_57:
      unsigned int v43 = v42 + v40;
      unsigned int v44 = (__int16)(v42 + v40);
      sub_608DC((_WORD *)a1, &v69, &v68, (_WORD *)&v69 + 1, v44, (__int16)v11, (__int16)v70);
      if ((int)(2 * v18) < 655360) {
        int v48 = (__int16)(((v18 >> 10) & 0x1F | 0x20) << (v18 >> 15));
      }
      else {
        int v48 = 31744;
      }
      int v49 = (v48 + (v48 >> 1)) >> 1;
      BOOL v51 = *(_WORD *)(a1 + 52) == 1 && v42 > v49;
      unsigned __int16 v52 = v68;
      *(_WORD *)(a1 + 52) = ((v68 - 0x8000) >> 9 < 0x29) & (unsigned __int16)~v51;
      sub_60A58(a1, v30, v27, v51, v45, v46, v47);
      sub_60B8C(a1, v44, v51);
      *(_WORD *)(a1 + 44) = *(_WORD *)(a1 + 42);
      int v53 = -HIWORD(v69) & 0x7FFF;
      if (v69 >= 0) {
        int v53 = HIWORD(v69);
      }
      if (v53)
      {
        __int16 v54 = 0;
        for (int i = 1; i <= v53; i *= 2)
          ++v54;
        __int16 v56 = (v53 << 6) >> v54;
        __int16 v57 = v54 << 6;
      }
      else
      {
        __int16 v57 = 0;
        __int16 v56 = 32;
      }
      *(_WORD *)(a1 + 42) = v57 + v56 + ((HIWORD(v69) >> 5) & 0x400);
      __int16 v58 = v69;
      if (v51) {
        __int16 v58 = 0;
      }
      *(_WORD *)(a1 + 10) = v58;
      if (v51) {
        unsigned __int16 v59 = 0;
      }
      else {
        unsigned __int16 v59 = v52;
      }
      *(_WORD *)(a1 + 12) = v59;
      __int16 v60 = *(_WORD *)(v6 + 8);
      *(void *)uint64_t v64 = *(void *)v6;
      *(_WORD *)(v64 + 8) = v60;
      int v61 = 0;
      if ((v43 & 0x7FFF) != 0)
      {
        int v62 = 1;
        do
        {
          LOWORD(v61) = v61 + 1;
          v62 *= 2;
        }
        while (v62 <= v42);
        int v61 = (__int16)v61;
      }
      unsigned int v7 = (v42 << 6) >> v61;
      int v8 = ((v43 >> 5) & 0x400) + (v61 << 6);
      if ((v43 & 0x7FFF) != 0) {
        __int16 v9 = v7;
      }
      else {
        __int16 v9 = 32;
      }
      *(_WORD *)uint64_t v6 = v8 + v9;
      if (++v5 == a3) {
        return a3;
      }
    }
    if (v29 <= 0xF83)
    {
      if (v29 > 0x7FF) {
        goto LABEL_39;
      }
      if (v29 <= 0x18F)
      {
        if (v29 <= 0x15C)
        {
          if (v29 <= 0x12B)
          {
            if (v29 <= 0xF5)
            {
              if (v29 <= 0xB1)
              {
                if (v29 > 0x4F) {
                  __int16 v30 = 13;
                }
                else {
                  __int16 v30 = 14;
                }
              }
              else
              {
                __int16 v30 = 12;
              }
            }
            else
            {
              __int16 v30 = 11;
            }
          }
          else
          {
            __int16 v30 = 10;
          }
        }
        else
        {
          __int16 v30 = 9;
        }
      }
      else
      {
        __int16 v30 = 8;
      }
    }
    else
    {
      __int16 v30 = 14;
    }
LABEL_40:
    char v31 = 7 - v30;
    goto LABEL_41;
  }
  return a3;
}

uint64_t sub_603C8(__int16 *a1, _WORD *a2, _WORD *a3)
{
  unsigned int v3 = a1[7];
  int v4 = a1[13];
  unsigned int v5 = -(v3 >> 2) & 0x1FFF;
  if ((v3 & 0x80000000) == 0) {
    unsigned int v5 = v3 >> 2;
  }
  if (v5)
  {
    int v6 = 13;
    if (v5 <= 0xFFF)
    {
      for (unsigned int i = 4096; i > v5; i >>= 1)
        --v6;
    }
    int v8 = v5 << 6 >> v6;
  }
  else
  {
    int v6 = 0;
    int v8 = 32;
  }
  int v9 = v6 + ((v4 >> 6) & 0xF);
  signed int v10 = ((8 * (v4 & 0x3F) * v8) & 0xFFFFFF80) + 384;
  int v11 = (v10 << (v9 - 26)) & 0x7F80;
  int v12 = v10 >> (26 - v9);
  if (v9 <= 26) {
    int v13 = v12;
  }
  else {
    int v13 = v11;
  }
  unsigned int v14 = a1[8];
  int v15 = a1[14];
  unsigned int v16 = -(v14 >> 2) & 0x1FFF;
  if ((v14 & 0x80000000) == 0) {
    unsigned int v16 = v14 >> 2;
  }
  if (v16)
  {
    int v17 = 13;
    if (v16 <= 0xFFF)
    {
      for (unsigned int j = 4096; j > v16; j >>= 1)
        --v17;
    }
    int v19 = v16 << 6 >> v17;
  }
  else
  {
    int v17 = 0;
    int v19 = 32;
  }
  int v20 = v17 + ((v15 >> 6) & 0xF);
  signed int v21 = ((8 * (v15 & 0x3F) * v19) & 0xFFFFFF80) + 384;
  if (v20 <= 26) {
    int v22 = v21 >> (26 - v20);
  }
  else {
    int v22 = (v21 << (v20 - 26)) & 0x7F80;
  }
  unsigned int v23 = a1[9];
  int v24 = a1[15];
  unsigned int v25 = -(v23 >> 2) & 0x1FFF;
  if ((v23 & 0x80000000) == 0) {
    unsigned int v25 = v23 >> 2;
  }
  if (v25)
  {
    int v26 = 13;
    if (v25 <= 0xFFF)
    {
      for (unsigned int k = 4096; k > v25; k >>= 1)
        --v26;
    }
    int v28 = v25 << 6 >> v26;
  }
  else
  {
    int v26 = 0;
    int v28 = 32;
  }
  int v29 = v26 + ((v24 >> 6) & 0xF);
  signed int v30 = ((8 * (v24 & 0x3F) * v28) & 0xFFFFFF80) + 384;
  int v31 = (v30 << (v29 - 26)) & 0x7F80;
  int v32 = v30 >> (26 - v29);
  if (v29 <= 26) {
    int v33 = v32;
  }
  else {
    int v33 = v31;
  }
  unsigned int v34 = a1[10];
  int v35 = a1[16];
  unsigned int v36 = -(v34 >> 2) & 0x1FFF;
  if ((v34 & 0x80000000) == 0) {
    unsigned int v36 = v34 >> 2;
  }
  if (v36)
  {
    int v37 = 13;
    if (v36 <= 0xFFF)
    {
      for (unsigned int m = 4096; m > v36; m >>= 1)
        --v37;
    }
    int v39 = v36 << 6 >> v37;
  }
  else
  {
    int v37 = 0;
    int v39 = 32;
  }
  int v40 = v37 + ((v35 >> 6) & 0xF);
  signed int v41 = ((8 * (v35 & 0x3F) * v39) & 0xFFFFFF80) + 384;
  if (v40 <= 26) {
    int v42 = v41 >> (26 - v40);
  }
  else {
    int v42 = (v41 << (v40 - 26)) & 0x7F80;
  }
  unsigned int v43 = a1[11];
  int v44 = a1[17];
  unsigned int v45 = -(v43 >> 2) & 0x1FFF;
  if ((v43 & 0x80000000) == 0) {
    unsigned int v45 = v43 >> 2;
  }
  if (v45)
  {
    int v46 = 13;
    if (v45 <= 0xFFF)
    {
      for (unsigned int n = 4096; n > v45; n >>= 1)
        --v46;
    }
    int v48 = v45 << 6 >> v46;
  }
  else
  {
    int v46 = 0;
    int v48 = 32;
  }
  int v49 = v46 + ((v44 >> 6) & 0xF);
  signed int v50 = ((8 * (v44 & 0x3F) * v48) & 0xFFFFFF80) + 384;
  int v51 = (v50 << (v49 - 26)) & 0x7F80;
  int v52 = v50 >> (26 - v49);
  if (v49 <= 26) {
    int v53 = v52;
  }
  else {
    int v53 = v51;
  }
  unsigned int v54 = a1[12];
  int v55 = a1[18];
  unsigned int v56 = -(v54 >> 2) & 0x1FFF;
  if ((v54 & 0x80000000) == 0) {
    unsigned int v56 = v54 >> 2;
  }
  if (v56)
  {
    int v57 = 13;
    if (v56 <= 0xFFF)
    {
      for (iunsigned int i = 4096; ii > v56; ii >>= 1)
        --v57;
    }
    int v59 = v56 << 6 >> v57;
  }
  else
  {
    int v57 = 0;
    int v59 = 32;
  }
  int v60 = v57 + ((v55 >> 6) & 0xF);
  signed int v61 = ((8 * (v55 & 0x3F) * v59) & 0xFFFFFF80) + 384;
  int v62 = v61 >> (26 - v60);
  if (v60 > 26) {
    int v62 = (v61 << (v60 - 26)) & 0x7F80;
  }
  unsigned int v63 = a1[5];
  int v64 = a1[21];
  unsigned int v65 = -(v63 >> 2) & 0x1FFF;
  if ((v63 & 0x80000000) == 0) {
    unsigned int v65 = v63 >> 2;
  }
  if (v65)
  {
    int v66 = 13;
    if (v65 <= 0xFFF)
    {
      for (junsigned int j = 4096; jj > v65; jj >>= 1)
        --v66;
    }
    int v68 = v65 << 6 >> v66;
  }
  else
  {
    int v66 = 0;
    int v68 = 32;
  }
  int v69 = v66 + ((v64 >> 6) & 0xF);
  signed int v70 = ((8 * (v64 & 0x3F) * v68) & 0xFFFFFF80) + 384;
  int v71 = (v70 << (v69 - 26)) & 0x7F80;
  int v72 = v70 >> (26 - v69);
  if (v69 > 26) {
    int v72 = v71;
  }
  unsigned int v73 = a1[6];
  uint64_t result = a1[22];
  unsigned int v75 = -(v73 >> 2) & 0x1FFF;
  if ((v73 & 0x80000000) == 0) {
    unsigned int v75 = v73 >> 2;
  }
  if (v75)
  {
    int v76 = 13;
    if (v75 <= 0xFFF)
    {
      for (kunsigned int k = 4096; kk > v75; kk >>= 1)
        --v76;
    }
    int v78 = v75 << 6 >> v76;
  }
  else
  {
    int v76 = 0;
    int v78 = 32;
  }
  int v79 = v76 + ((result >> 6) & 0xF);
  int v80 = ((8 * (result & 0x3F) * v78) & 0xFFFFFF80) + 384;
  int v81 = v80 >> (26 - v79);
  if (v79 > 26) {
    int v81 = (v80 << (v79 - 26)) & 0x7F80;
  }
  if (((v63 >> 15) & 1) == v64 >> 10) {
    LOWORD(v82) = v72;
  }
  else {
    int v82 = -v72;
  }
  if (((v3 >> 15) & 1) == v4 >> 10) {
    LOWORD(v83) = v13;
  }
  else {
    int v83 = -v13;
  }
  if (((v14 >> 15) & 1) == v15 >> 10) {
    LOWORD(v84) = v22;
  }
  else {
    int v84 = -v22;
  }
  __int16 v85 = v84 + v83;
  if (((v23 >> 15) & 1) == v24 >> 10) {
    LOWORD(v86) = v33;
  }
  else {
    int v86 = -v33;
  }
  if (((v34 >> 15) & 1) == v35 >> 10) {
    LOWORD(v87) = v42;
  }
  else {
    int v87 = -v42;
  }
  __int16 v88 = v85 + v86 + v87;
  if (((v43 >> 15) & 1) == v44 >> 10) {
    LOWORD(v89) = v53;
  }
  else {
    int v89 = -v53;
  }
  if (((v54 >> 15) & 1) == v55 >> 10) {
    LOWORD(v90) = v62;
  }
  else {
    int v90 = -v62;
  }
  unsigned __int16 v91 = v88 + v89 + v90;
  if (((v73 >> 15) & 1) == (int)result >> 10) {
    LOWORD(v92) = v81;
  }
  else {
    int v92 = -v81;
  }
  *a3 = v91 >> 1;
  *a2 = (unsigned __int16)(v82 + v91 + v92) >> 1;
  return result;
}

_WORD *sub_608DC(_WORD *result, _WORD *a2, _WORD *a3, _WORD *a4, int a5, unsigned int a6, unsigned int a7)
{
  int v7 = (unsigned __int16)result[20];
  result[20] = result[19];
  if (a5 < 0) {
    int v8 = -(a5 & 0x7FFF);
  }
  else {
    int v8 = a5;
  }
  unsigned int v9 = a7 + 0x8000;
  if (a7 < 0x4000) {
    unsigned int v9 = a7;
  }
  unsigned int v10 = v9 + v8;
  int v11 = (unsigned __int16)(v9 + v8);
  result[19] = (v10 >> 15) & 1;
  __int16 v12 = a6 ^ 0x8000;
  if (a6 < 0x4000) {
    __int16 v12 = a6;
  }
  *a4 = v12 + v8;
  int v13 = (unsigned __int16)result[19];
  unsigned int v14 = (unsigned __int16)result[5];
  unsigned int v15 = (__int16)result[6];
  int v16 = (unsigned __int16)(result[20] ^ v13);
  if (v13 == v7) {
    int v17 = 0x4000;
  }
  else {
    int v17 = 114688;
  }
  if (v14 > 0xE000) {
    int v18 = 4 * (v14 & 0x7FFF);
  }
  else {
    int v18 = 98308;
  }
  if (v14 >= 0x2000) {
    int v19 = 32764;
  }
  else {
    int v19 = 4 * v14;
  }
  if ((__int16)result[5] >= 0) {
    int v18 = v19;
  }
  if (v16 != 1) {
    int v18 = -v18 & 0x1FFFC;
  }
  unsigned int v20 = v18 + v17;
  if ((v20 & 0x10000) != 0) {
    int v21 = (v20 >> 7) & 0x3FF | 0xFC00;
  }
  else {
    int v21 = (v20 >> 7) & 0x3FF;
  }
  if (!v11) {
    int v21 = 0;
  }
  int v22 = (v15 >> 7) | 0x200;
  if ((v15 & 0x8000) != 0)
  {
    int v23 = 1023;
  }
  else
  {
    int v22 = (unsigned __int16)v15 >> 7;
    int v23 = 0xFFFF;
  }
  int v24 = (v23 & -v22) + v15 + v21;
  if ((unsigned __int16)v24 > 0xD000u) {
    __int16 v25 = v24;
  }
  else {
    __int16 v25 = -12288;
  }
  if ((unsigned __int16)v24 >= 0x8000u) {
    __int16 v26 = v25;
  }
  else {
    __int16 v26 = 12288;
  }
  if ((unsigned __int16)v24 >= 0x3000u) {
    LOWORD(v24) = v26;
  }
  *a3 = v24;
  if (result[19] == result[20]) {
    __int16 v27 = 192;
  }
  else {
    __int16 v27 = -192;
  }
  if (v11) {
    __int16 v28 = v27;
  }
  else {
    __int16 v28 = 0;
  }
  int v29 = (__int16)(result[5]
                - ((__int16)result[5] >> 8)
                + (((__int16)result[5] >> 7) & 0x100)
                + v28);
  int v30 = (__int16)(15360 - v24);
  if (v30 < v29) {
    LOWORD(v29) = v30;
  }
  *a2 = v29;
  return result;
}

uint64_t sub_60A58(uint64_t result, unsigned int a2, unsigned int a3, int a4, double a5, double a6, int32x2_t a7)
{
  char v7 = 7 - a2;
  if (a2 < 8) {
    char v7 = a2;
  }
  unsigned int v8 = v7 & 7;
  int v9 = v8 > 2;
  if (v8 == 6) {
    int v9 = 3;
  }
  if (v8 == 7) {
    int v10 = 7;
  }
  else {
    int v10 = v9;
  }
  if (*(_DWORD *)(result + 4) == 32000) {
    unsigned int v11 = v10;
  }
  else {
    unsigned int v11 = 0;
  }
  a7.i16[0] = *(_WORD *)(result + 48);
  a7.i16[2] = *(_WORD *)(result + 50);
  int8x8_t v12 = (int8x8_t)vsub_s32((int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(v11), (uint32x2_t)0xB00000009), a7);
  uint32x2_t v13 = (uint32x2_t)vand_s8(v12, (int8x8_t)0xFFFF0000FFFFLL);
  uint32x2_t v14 = (uint32x2_t)vand_s8(v12, (int8x8_t)0x7FFF00001FFFLL);
  int8x8_t v15 = vand_s8((int8x8_t)vadd_s32((int32x2_t)vbsl_s8((int8x8_t)vcgt_u32((uint32x2_t)0x400000001000, v14), (int8x8_t)vshl_u32(v14, (uint32x2_t)0xFFFFFFF9FFFFFFFBLL), vorr_s8((int8x8_t)vshl_u32(v13, (uint32x2_t)0xFFFFFFF9FFFFFFFBLL), (int8x8_t)0x3F0000000F00)), a7), (int8x8_t)0x3FFF00000FFFLL);
  *(_WORD *)(result + 48) = v15.i16[0];
  *(_WORD *)(result + 50) = v15.i16[2];
  if (((4 * v15.i16[0] - v15.i16[2]) & 0x4000) != 0) {
    unsigned int v16 = (v15.i32[1] - 4 * v15.i32[0]) & 0x3FFF;
  }
  else {
    unsigned int v16 = (4 * v15.i16[0] - v15.i16[2]) & 0x7FFF;
  }
  BOOL v18 = v16 < (unsigned __int32)v15.i32[1] >> 3 && a3 > 0x5FF && *(_WORD *)(result + 52) == 0;
  int v19 = *(unsigned __int16 *)(result + 46);
  if (v18) {
    int v20 = 0;
  }
  else {
    int v20 = 512;
  }
  unsigned int v21 = v20 - v19;
  int v22 = (v21 >> 4) & 0x7F;
  if ((v21 & 0x400) != 0) {
    __int16 v23 = v22 | 0x380;
  }
  else {
    __int16 v23 = v22;
  }
  __int16 v24 = (v23 + v19) & 0x3FF;
  if (a4) {
    __int16 v24 = 256;
  }
  *(_WORD *)(result + 46) = v24;
  return result;
}

int16x4_t sub_60B8C(uint64_t a1, unsigned int a2, int a3)
{
  if (*(_DWORD *)(a1 + 4) == 40000) {
    goto LABEL_12;
  }
  if ((a2 & 0x7FFF) == 0)
  {
    if (!a3)
    {
      int16x4_t result = vadd_s16(vsub_s16(*(int16x4_t *)(a1 + 14), (int16x4_t)vshr_n_u16(*(uint16x4_t *)(a1 + 14), 8uLL)), (int16x4_t)(*(void *)&vshr_n_u16(*(uint16x4_t *)(a1 + 14), 7uLL) & 0xFF00FF00FF00FF00));
      *(int16x4_t *)(a1 + 14) = result;
      *(_WORD *)(a1 + 22) = *(_WORD *)(a1 + 22) - HIBYTE(*(_WORD *)(a1 + 22)) + ((*(_WORD *)(a1 + 22) >> 7) & 0x100);
      *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 24) - HIBYTE(*(_WORD *)(a1 + 24)) + ((*(_WORD *)(a1 + 24) >> 7) & 0x100);
      return result;
    }
LABEL_12:
    *(_DWORD *)(a1 + 22) = 0;
    *(void *)(a1 + 14) = 0;
    return result;
  }
  if (a3) {
    goto LABEL_12;
  }
  unsigned int v3 = (a2 >> 15) & 1;
  int8x8_t v4 = (int8x8_t)vceq_s16(vdup_n_s16(v3), (int16x4_t)(*(void *)&vshr_n_u16(*(uint16x4_t *)(a1 + 26), 0xAuLL) & 0xFFC1FFC1FFC1FFC1));
  int16x4_t result = vadd_s16(vadd_s16(vsub_s16(*(int16x4_t *)(a1 + 14), (int16x4_t)vshr_n_u16(*(uint16x4_t *)(a1 + 14), 8uLL)), (int16x4_t)(*(void *)&vshr_n_u16(*(uint16x4_t *)(a1 + 14), 7uLL) & 0xFF00FF00FF00FF00)), (int16x4_t)vorr_s8(vand_s8(v4, (int8x8_t)0x80008000800080), (int8x8_t)(*(void *)&vmvn_s8(v4) & 0xFF80FF80FF80FF80)));
  *(int16x4_t *)(a1 + 14) = result;
  if (v3 == ((*(unsigned __int16 *)(a1 + 34) >> 10) & 1)) {
    __int16 v6 = 128;
  }
  else {
    __int16 v6 = -128;
  }
  *(_WORD *)(a1 + 22) = *(_WORD *)(a1 + 22) - HIBYTE(*(_WORD *)(a1 + 22)) + ((*(_WORD *)(a1 + 22) >> 7) & 0x100) + v6;
  if (v3 == ((*(unsigned __int16 *)(a1 + 36) >> 10) & 1)) {
    __int16 v7 = 128;
  }
  else {
    __int16 v7 = -128;
  }
  *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 24) - HIBYTE(*(_WORD *)(a1 + 24)) + ((*(_WORD *)(a1 + 24) >> 7) & 0x100) + v7;
  return result;
}

uint64_t g726_decode_frame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned __int16 v81 = 0;
  __int16 v77 = 0;
  if (a3)
  {
    uint64_t v5 = 0;
    __int16 v80 = 0;
    uint64_t v70 = a1 + 26;
    uint64_t v71 = a1 + 28;
    __int16 v79 = 0;
    while (1)
    {
      sub_603C8((__int16 *)a1, &v80, &v79);
      int v8 = *(__int16 *)(a1 + 46);
      int v9 = v8 >> 2;
      if (v8 > 255) {
        LOWORD(v9) = 64;
      }
      int v10 = *(_DWORD *)(a1 + 56) >> 6;
      unsigned int v11 = (*(_WORD *)(a1 + 60) - (_WORD)v10) & 0x3FFF;
      __int16 v12 = (v11 * (__int16)v9) >> 6;
      unsigned int v13 = -((((v10 - *(unsigned __int16 *)(a1 + 60)) & 0x1FFFu) * (__int16)v9) >> 6) & 0x3FFF;
      if (v11 < 0x2000) {
        LOWORD(v13) = v12;
      }
      uint64_t v14 = *(unsigned __int8 *)(a2 + v5);
      if (*(_DWORD *)(a1 + 4) == 32000)
      {
        __int16 v15 = word_72480[v14];
        int v16 = (v14 << 12) & 0xF8000;
      }
      else
      {
        __int16 v15 = 0;
        int v16 = 0;
      }
      __int16 v17 = v13 + v10;
      unsigned int v75 = ((_WORD)v13 + (_WORD)v10) & 0x1FFF;
      int v18 = v75 >> 2;
      unsigned int v19 = (v15 + (unsigned __int16)(v75 >> 2)) & 0xFFF;
      if (v19 <= 0x7FF) {
        signed int v20 = ((((v15 + (_WORD)v18) & 0x7F) << 7) | 0x4000u) >> (14 - (v19 >> 7));
      }
      else {
        signed int v20 = 0;
      }
      unsigned int v21 = v20 + v16;
      unsigned __int16 v22 = v80;
      int v23 = (__int16)(v20 + v16);
      sub_608DC((_WORD *)a1, &v77, &v81, &v78, v23, v80, v79);
      int v27 = *(_DWORD *)(a1 + 56);
      if (*(_DWORD *)(a1 + 4) == 32000)
      {
        char v28 = 7 - v14;
        if (v14 < 8) {
          char v28 = v14;
        }
        int v29 = 32 * word_72470[v28 & 7];
      }
      else
      {
        int v29 = 0;
      }
      unsigned int v30 = v29 - (v17 & 0x1FFF);
      int v31 = (v30 >> 5) & 0xFFF;
      if ((v30 & 0x10000) != 0) {
        __int16 v32 = v31 | 0x1000;
      }
      else {
        __int16 v32 = v31;
      }
      int v33 = (v32 + v17) & 0x1FFF;
      __int16 v34 = v33 + 15840;
      if ((((_WORD)v33 + 11264) & 0x2000) == 0) {
        int v33 = 5120;
      }
      if ((v34 & 0x2000) != 0) {
        int v33 = 544;
      }
      *(_WORD *)(a1 + 60) = v33;
      unsigned int v35 = v33 + (-v27 >> 6);
      if ((v35 & 0x2000) != 0) {
        int v36 = v35 | 0x7C000;
      }
      else {
        int v36 = v35 & 0x3FFF;
      }
      *(_DWORD *)(a1 + 56) = (v36 + v27) & 0x7FFFF;
      if (v23 < 0) {
        int v37 = -(v21 & 0x7FFF);
      }
      else {
        LOWORD(v37) = v21;
      }
      if (v22 >= 0x4000u) {
        __int16 v38 = v22 ^ 0x8000;
      }
      else {
        __int16 v38 = v22;
      }
      int v39 = (__int16)(v37 + v38);
      int v76 = v21 & 0x7FFF;
      if (*(_WORD *)a1 == 2)
      {
        if (v39 < 0x2000)
        {
          __int16 v40 = 4 * v39;
          if (4 * v39 <= -32768) {
            __int16 v40 = 0x8000;
          }
          unsigned int v41 = v75;
        }
        else
        {
          __int16 v40 = 0x7FFF;
          unsigned int v41 = v75;
        }
        goto LABEL_102;
      }
      int v42 = linear_to_alaw(v39);
      if (*(_WORD *)a1 == 1)
      {
        __int16 v43 = 0;
      }
      else
      {
        int v18 = v23;
        unsigned int v44 = v21;
        __int16 v45 = v42;
        int v46 = alaw_to_linear(v42);
        if (v46 < 0) {
          __int16 v43 = ((unsigned __int16)v46 >> 2) | 0xC000;
        }
        else {
          __int16 v43 = (unsigned __int16)v46 >> 2;
        }
        LOWORD(v42) = v45;
        unsigned int v21 = v44;
        int v23 = v18;
        LOWORD(v18) = v75 >> 2;
      }
      __int16 v47 = 0;
      unsigned __int16 v48 = v43 - v38;
      int v49 = (__int16)v48;
      if ((v48 & 0x8000u) != 0) {
        unsigned __int16 v48 = -v48 & 0x7FFF;
      }
      if (v48 >= 2u)
      {
        __int16 v47 = 0;
        int v50 = 2;
        do
        {
          ++v47;
          v50 *= 2;
        }
        while (v50 <= v48);
      }
      if (*(_DWORD *)(a1 + 4) != 32000)
      {
        LOWORD(v42) = 0;
        unsigned int v41 = v75;
        goto LABEL_101;
      }
      unsigned int v51 = ((((v48 << 7) >> v47) & 0x7F | (unsigned __int16)(v47 << 7)) - (_WORD)v18) & 0xFFF;
      unsigned int v52 = v14 & 7;
      if (v14 < 8) {
        unsigned int v52 = v14 + 8;
      }
      if (v49 < 0) {
        break;
      }
      if (v51 > 0xF83)
      {
        unsigned int v53 = 9;
LABEL_93:
        unsigned int v41 = v75;
        goto LABEL_94;
      }
      unsigned int v41 = v75;
      if (v51 <= 0x7FF)
      {
        if (v51 <= 0x18F)
        {
          if (v51 <= 0x15C)
          {
            if (v51 <= 0x12B)
            {
              if (v51 <= 0xF5)
              {
                if (v51 <= 0xB1)
                {
                  if (v51 <= 0x4F) {
                    unsigned int v53 = 9;
                  }
                  else {
                    unsigned int v53 = 10;
                  }
                }
                else
                {
                  unsigned int v53 = 11;
                }
              }
              else
              {
                unsigned int v53 = 12;
              }
            }
            else
            {
              unsigned int v53 = 13;
            }
          }
          else
          {
            unsigned int v53 = 14;
          }
        }
        else
        {
          unsigned int v53 = 15;
        }
      }
      else
      {
        unsigned int v53 = 7;
      }
LABEL_94:
      if (*(_WORD *)a1 != 1)
      {
        if (v53 >= v52)
        {
          if (v53 <= v52) {
            goto LABEL_101;
          }
          if ((v42 & 0x80) == 0)
          {
LABEL_100:
            LOWORD(v42) = v42 + 1;
            goto LABEL_101;
          }
        }
        else if ((v42 & 0x80) != 0)
        {
          goto LABEL_100;
        }
        LOWORD(v42) = v42 - 1;
      }
LABEL_101:
      __int16 v40 = v42;
LABEL_102:
      *(_WORD *)(a4 + 2 * v5) = v40;
      int v54 = (__int16)(((v27 >> 10) & 0x1F | 0x20) << (v27 >> 15));
      if (2 * v27 >= 655360) {
        int v54 = 31744;
      }
      int v55 = (v54 + (v54 >> 1)) >> 1;
      BOOL v57 = *(_WORD *)(a1 + 52) == 1 && v20 > v55;
      unsigned __int16 v58 = v81;
      *(_WORD *)(a1 + 52) = ((v81 - 0x8000) >> 9 < 0x29) & (unsigned __int16)~v57;
      sub_60A58(a1, v14, v41, v57, v24, v25, v26);
      sub_60B8C(a1, v23, v57);
      *(_WORD *)(a1 + 44) = *(_WORD *)(a1 + 42);
      if (v39 >= 0) {
        int v59 = v39;
      }
      else {
        int v59 = -v39 & 0x7FFF;
      }
      if (v59)
      {
        int v60 = 0;
        int v61 = 1;
        do
        {
          ++v60;
          v61 *= 2;
        }
        while (v61 <= (unsigned __int16)v59);
        __int16 v62 = ((unsigned __int16)v59 << 6) >> v60;
        __int16 v63 = (_WORD)v60 << 6;
      }
      else
      {
        __int16 v63 = 0;
        __int16 v62 = 32;
      }
      *(_WORD *)(a1 + 42) = v63 + v62 + ((v39 >> 5) & 0x400);
      __int16 v64 = v77;
      if (v57) {
        __int16 v64 = 0;
      }
      *(_WORD *)(a1 + 10) = v64;
      if (v57) {
        unsigned __int16 v65 = 0;
      }
      else {
        unsigned __int16 v65 = v58;
      }
      *(_WORD *)(a1 + 12) = v65;
      __int16 v66 = *(_WORD *)(v70 + 8);
      *(void *)uint64_t v71 = *(void *)v70;
      *(_WORD *)(v71 + 8) = v66;
      int v67 = 0;
      if (v76)
      {
        int v68 = 1;
        do
        {
          ++v67;
          v68 *= 2;
        }
        while (v68 <= v20);
        int v67 = (__int16)v67;
      }
      unsigned int v6 = (v20 << 6) >> v67;
      int v7 = ((v21 >> 5) & 0x400) + (v67 << 6);
      if (!v76) {
        LOWORD(v6) = 32;
      }
      *(_WORD *)uint64_t v70 = v7 + v6;
      if (++v5 == a3) {
        return a3;
      }
    }
    if (v51 <= 0xF83)
    {
      if (v51 <= 0x7FF)
      {
        if (v51 <= 0x18F)
        {
          if (v51 <= 0x15C)
          {
            if (v51 <= 0x12B)
            {
              if (v51 <= 0xF5)
              {
                if (v51 <= 0xB1)
                {
                  if (v51 > 0x4F) {
                    unsigned int v53 = 5;
                  }
                  else {
                    unsigned int v53 = 6;
                  }
                }
                else
                {
                  unsigned int v53 = 4;
                }
              }
              else
              {
                unsigned int v53 = 3;
              }
            }
            else
            {
              unsigned int v53 = 12;
            }
          }
          else
          {
            unsigned int v53 = 1;
          }
        }
        else
        {
          unsigned int v53 = 0;
        }
      }
      else
      {
        unsigned int v53 = 7;
      }
    }
    else
    {
      unsigned int v53 = 6;
    }
    goto LABEL_93;
  }
  return a3;
}

uint64_t linear_to_alaw(int a1)
{
  unsigned int v1 = (a1 >> 4) ^ (a1 >> 15);
  if (v1 >= 0x10)
  {
    if (v1 < 0x20)
    {
      char v5 = 16;
    }
    else
    {
      char v2 = 1;
      do
      {
        __int16 v3 = (unsigned __int16)v1 >> 1;
        unsigned int v4 = (unsigned __int16)v1;
        ++v2;
        LOWORD(v1) = (unsigned __int16)v1 >> 1;
      }
      while (v4 > 0x3F);
      char v5 = 16 * v2;
      LOBYTE(v1) = v3;
    }
    LOBYTE(v1) = v1 + v5 - 16;
  }
  if (a1 >= 0) {
    LOBYTE(v1) = v1 | 0x80;
  }
  return v1 ^ 0x55u;
}

uint64_t alaw_to_linear(int a1)
{
  if ((((a1 ^ 0x55u) >> 4) & 7) != 0) {
    int v1 = ((16 * ((a1 ^ 0x55) & 0xF)) | 0x108) << ((((a1 ^ 0x55u) >> 4) & 7) - 1);
  }
  else {
    int v1 = (16 * ((a1 ^ 0x55) & 0xF)) | 8;
  }
  if ((a1 & 0x80u) == 0) {
    int v1 = -v1;
  }
  return (__int16)v1;
}

uint64_t g722_encode_frame(int16x4_t *a1, __int16 *a2, int a3, unsigned char *a4, _WORD *a5)
{
  if (a3 >> (a1[6].u16[1] != 4) < 1)
  {
    __int16 v36 = 0;
  }
  else
  {
    int v38 = a3 >> (a1[6].u16[1] != 4);
    int v39 = a5;
    uint64_t v8 = (uint64_t)&a1[6] + 4;
    uint64_t v9 = (uint64_t)&a1[15] + 6;
    uint64_t v10 = (unsigned __int16)v38;
    unsigned int v11 = (int16x4_t *)((char *)a1 + 4);
    do
    {
      while (a1[6].i16[1] == 4)
      {
        __int16 v35 = *a2++;
        a1[15].i16[3] = v35;
        sub_6161C(v9);
        *a4++ = (a1[16].i8[4] >> 2) & 0xF;
        if (!--v10) {
          goto LABEL_27;
        }
      }
      long long v12 = *(_OWORD *)a1->i8;
      long long v13 = *(_OWORD *)a1[2].i8;
      int16x4_t v14 = a1[4];
      v11[5].i32[0] = a1[5].i32[0];
      void v11[4] = v14;
      *(_OWORD *)v11->i8 = v12;
      *(_OWORD *)v11[2].i8 = v13;
      a1->i16[0] = *a2;
      a1->i16[1] = a2[1];
      int8x16_t v15 = (int8x16_t)vmlal_s16(vmlal_s16(vmlal_s16(vmlal_s16(vmlal_s16(vmull_s16((int16x4_t)0x20016A000CFF64, a1[1]), (int16x4_t)0xFFF500350003FFF5, *a1), (int16x4_t)0x3B70F24FF2EFCDBLL, a1[2]), (int16x4_t)0xFCDBFF2E0F2403B7, a1[3]), (int16x4_t)0xFF64000C016A0020, a1[4]), (int16x4_t)0xFFF500030035FFF5, a1[5]);
      int32x2_t v16 = vadd_s32(*(int32x2_t *)v15.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v15, v15, 8uLL));
      int v17 = (v16.i32[0] + v16.i32[1]) >> 14;
      if (v17 <= -32768) {
        int v17 = -32768;
      }
      if (v17 >= 0x7FFF) {
        LOWORD(v17) = 0x7FFF;
      }
      a1[15].i16[3] = v17;
      int v18 = (v16.i32[1] - v16.i32[0]) >> 14;
      if (v18 <= -32768) {
        int v18 = -32768;
      }
      if (v18 >= 0x7FFF) {
        int v18 = 0x7FFF;
      }
      a1[6].i16[2] = v18;
      int v19 = a1[7].i16[0];
      int v20 = v18 - v19;
      BOOL v21 = v18 >= v19;
      if (v18 - v19 >= 0x7FFF) {
        int v20 = 0x7FFF;
      }
      if (v20 <= -32768) {
        int v20 = -32768;
      }
      a2 += 2;
      if (v18 >= v19) {
        int v22 = v20;
      }
      else {
        int v22 = ~v20;
      }
      a1[6].i16[3] = v20;
      int v23 = a1[7].i16[3];
      __int16 v24 = word_725DC[2 * v21 + (v22 >= (564 * v23) >> 12)];
      a1[7].i16[1] = v24;
      int v25 = (word_725E4[v24] * v23) >> 15;
      if (v25 >= 0x7FFF) {
        LOWORD(v25) = 0x7FFF;
      }
      a1[8].i16[0] = v25;
      int v26 = word_725D8[v24 & 1] + ((127 * a1[7].i16[2]) >> 7);
      int v27 = v26 & ~(v26 >> 31);
      if (v27 >= 22528) {
        int v27 = 22528;
      }
      a1[7].i16[2] = v27;
      int v28 = (v27 >> 6) & 0x1F;
      unsigned int v29 = v27 >> 11;
      char v30 = 10 - v29;
      int v31 = word_72598[v28];
      BOOL v32 = v29 > 0xA;
      int v33 = v31 << (v29 - 10);
      int v34 = v31 >> v30;
      if (!v32) {
        LOWORD(v33) = v34;
      }
      a1[7].i16[3] = 4 * v33;
      sub_61E4C(v8);
      sub_6161C(v9);
      *a4++ = a1[16].i8[4] | (a1[7].i8[2] << 6);
      --v10;
    }
    while (v10);
LABEL_27:
    __int16 v36 = v38;
    a5 = v39;
  }
  *a5 = v36;
  return 0;
}

uint64_t sub_6161C(uint64_t result)
{
  int v1 = *(__int16 *)result;
  int v2 = *(__int16 *)(result + 4);
  int v3 = v1 - v2;
  if (v1 - v2 >= 0x7FFF) {
    int v3 = 0x7FFF;
  }
  if (v3 <= -32768) {
    int v3 = -32768;
  }
  if (v1 >= v2) {
    int v4 = v3;
  }
  else {
    int v4 = ~v3;
  }
  *(_WORD *)(result + 2) = v3;
  int v5 = *(__int16 *)(result + 10);
  if (v4 >= (35 * v5) >> 12)
  {
    if (v4 >= (72 * v5) >> 12)
    {
      if (v4 >= (110 * v5) >> 12)
      {
        if (v4 >= (150 * v5) >> 12)
        {
          if (v4 >= (190 * v5) >> 12)
          {
            if (v4 >= (233 * v5) >> 12)
            {
              if (v4 >= (276 * v5) >> 12)
              {
                if (v4 >= (323 * v5) >> 12)
                {
                  if (v4 >= (370 * v5) >> 12)
                  {
                    if (v4 >= (422 * v5) >> 12)
                    {
                      if (v4 >= (473 * v5) >> 12)
                      {
                        if (v4 >= (530 * v5) >> 12)
                        {
                          if (v4 >= (587 * v5) >> 12)
                          {
                            if (v4 >= (650 * v5) >> 12)
                            {
                              if (v4 >= (714 * v5) >> 12)
                              {
                                if (v4 >= (786 * v5) >> 12)
                                {
                                  if (v4 >= (858 * v5) >> 12)
                                  {
                                    if (v4 >= (940 * v5) >> 12)
                                    {
                                      if (v4 >= (1023 * v5) >> 12)
                                      {
                                        if (v4 >= (1121 * v5) >> 12)
                                        {
                                          if (v4 >= (1219 * v5) >> 12)
                                          {
                                            if (v4 >= (1339 * v5) >> 12)
                                            {
                                              if (v4 >= (1458 * v5) >> 12)
                                              {
                                                if (v4 >= (1612 * v5) >> 12)
                                                {
                                                  if (v4 >= (1765 * v5) >> 12)
                                                  {
                                                    if (v4 >= (1980 * v5) >> 12)
                                                    {
                                                      if (v4 >= (2195 * v5) >> 12)
                                                      {
                                                        if (v4 >= (2557 * v5) >> 12)
                                                        {
                                                          BOOL v8 = __OFSUB__(v4, (2919 * v5) >> 12);
                                                          BOOL v7 = v4 - ((2919 * v5) >> 12) < 0;
                                                          uint64_t v6 = 28;
                                                          if (v7 == v8) {
                                                            uint64_t v6 = 29;
                                                          }
                                                        }
                                                        else
                                                        {
                                                          uint64_t v6 = 27;
                                                        }
                                                      }
                                                      else
                                                      {
                                                        uint64_t v6 = 26;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      uint64_t v6 = 25;
                                                    }
                                                  }
                                                  else
                                                  {
                                                    uint64_t v6 = 24;
                                                  }
                                                }
                                                else
                                                {
                                                  uint64_t v6 = 23;
                                                }
                                              }
                                              else
                                              {
                                                uint64_t v6 = 22;
                                              }
                                            }
                                            else
                                            {
                                              uint64_t v6 = 21;
                                            }
                                          }
                                          else
                                          {
                                            uint64_t v6 = 20;
                                          }
                                        }
                                        else
                                        {
                                          uint64_t v6 = 19;
                                        }
                                      }
                                      else
                                      {
                                        uint64_t v6 = 18;
                                      }
                                    }
                                    else
                                    {
                                      uint64_t v6 = 17;
                                    }
                                  }
                                  else
                                  {
                                    uint64_t v6 = 16;
                                  }
                                }
                                else
                                {
                                  uint64_t v6 = 15;
                                }
                              }
                              else
                              {
                                uint64_t v6 = 14;
                              }
                            }
                            else
                            {
                              uint64_t v6 = 13;
                            }
                          }
                          else
                          {
                            uint64_t v6 = 12;
                          }
                        }
                        else
                        {
                          uint64_t v6 = 11;
                        }
                      }
                      else
                      {
                        uint64_t v6 = 10;
                      }
                    }
                    else
                    {
                      uint64_t v6 = 9;
                    }
                  }
                  else
                  {
                    uint64_t v6 = 8;
                  }
                }
                else
                {
                  uint64_t v6 = 7;
                }
              }
              else
              {
                uint64_t v6 = 6;
              }
            }
            else
            {
              uint64_t v6 = 5;
            }
          }
          else
          {
            uint64_t v6 = 4;
          }
        }
        else
        {
          uint64_t v6 = 3;
        }
      }
      else
      {
        uint64_t v6 = 2;
      }
    }
    else
    {
      uint64_t v6 = 1;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  int v9 = word_72500[30 * (v1 >= v2) + v6];
  *(_WORD *)(result + 6) = v9;
  uint64_t v10 = 2 * (v9 >> 2);
  int v11 = (*(__int16 *)((char *)&unk_72578 + v10) * v5) >> 15;
  if (v11 >= 0x7FFF) {
    __int16 v12 = 0x7FFF;
  }
  else {
    __int16 v12 = v11;
  }
  *(_WORD *)(result + 12) = v12;
  int v13 = (*(__int16 *)((char *)&unk_724E0 + v10) + ((127 * *(__int16 *)(result + 8)) >> 7)) & ~((*(__int16 *)((char *)&unk_724E0 + v10)
                                                                                              + ((127
                                                                                                * *(__int16 *)(result + 8)) >> 7)) >> 31);
  if (v13 >= 18432) {
    int v13 = 18432;
  }
  *(_WORD *)(result + 8) = v13;
  unsigned int v14 = (v13 >> 6) & 0x1F;
  unsigned int v15 = v13 >> 11;
  char v16 = 8 - v15;
  BOOL v17 = v15 >= 8;
  BOOL v18 = v15 == 8;
  int v19 = word_72598[v14];
  int v20 = v19 << (v15 - 8);
  int v21 = v19 >> v16;
  if (v18 || !v17) {
    LOWORD(v20) = v21;
  }
  *(_WORD *)(result + 10) = 4 * v20;
  return sub_61E4C(result);
}

double g722_encoder_init(uint64_t a1, __int16 a2)
{
  *(void *)(a1 + 192) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_WORD *)(a1 + 136) = 32;
  *(_WORD *)(a1 + 62) = 8;
  *(_WORD *)(a1 + 50) = a2;
  return result;
}

uint64_t g722_decode_frame(int16x4_t *a1, unsigned char *a2, int a3, uint64_t a4, _WORD *a5)
{
  if (a3 < 1)
  {
    LOWORD(v8) = 0;
    goto LABEL_39;
  }
  int v8 = 0;
  int v9 = (_WORD *)&a1[6] + 2;
  uint64_t v10 = (_WORD *)&a1[15] + 3;
  uint64_t v11 = (unsigned __int16)a3;
  unsigned int v41 = a5;
  int v42 = a1 + 16;
  __int16 v12 = (char *)a1 + 4;
  do
  {
    while (1)
    {
      int v38 = a1[6].u16[1];
      if (v38 == 6) {
        break;
      }
      if (v38 == 7)
      {
        unint64_t v13 = (unint64_t)*a2 >> 6;
        a1[7].i16[1] = v13;
        int v14 = (*a2 >> 1) & 0x1F;
        goto LABEL_4;
      }
      if (v38 == 8)
      {
        unint64_t v13 = (unint64_t)*a2 >> 6;
        a1[7].i16[1] = v13;
        LOWORD(v14) = *a2 & 0x3F;
        goto LABEL_4;
      }
      unsigned int v39 = *a2++;
      a1[16].i16[2] = v39 >> 4;
      sub_61CF4(v38, v10);
      *(_WORD *)(a4 + 2 * v8++) = v42->i16[0];
      if (!--v11) {
        goto LABEL_37;
      }
    }
    unint64_t v13 = (unint64_t)*a2 >> 6;
    a1[7].i16[1] = v13;
    int v14 = (*a2 >> 2) & 0xF;
LABEL_4:
    a1[16].i16[2] = v14;
    int v15 = (word_725E4[v13] * a1[7].i16[3]) >> 15;
    if (v15 >= 0x7FFF) {
      LOWORD(v15) = 0x7FFF;
    }
    a1[8].i16[0] = v15;
    int v16 = a1[7].i16[0] + (__int16)v15;
    if (v16 >= 0x7FFF) {
      int v16 = 0x7FFF;
    }
    if (v16 <= -32768) {
      LOWORD(v16) = 0x8000;
    }
    a1[6].i16[3] = v16;
    int v17 = word_725D8[v13 & 1] + ((127 * a1[7].i16[2]) >> 7);
    int v18 = v17 & ~(v17 >> 31);
    if (v18 >= 22528) {
      int v18 = 22528;
    }
    a1[7].i16[2] = v18;
    int v19 = (v18 >> 6) & 0x1F;
    unsigned int v20 = v18 >> 11;
    char v21 = 10 - v20;
    int v22 = word_72598[v19];
    BOOL v23 = v20 > 0xA;
    int v24 = v22 << (v20 - 10);
    int v25 = v22 >> v21;
    if (!v23) {
      LOWORD(v24) = v25;
    }
    a1[7].i16[3] = 4 * v24;
    sub_61E4C((uint64_t)v9);
    sub_61CF4(a1[6].i16[1], v10);
    int v26 = a1[16].i16[0];
    int v27 = a1[6].i16[3];
    int v28 = v26 + v27;
    if (v26 + v27 >= 0x7FFF) {
      int v28 = 0x7FFF;
    }
    if (v28 <= -32768) {
      LOWORD(v28) = 0x8000;
    }
    a1[5].i16[2] = v28;
    int v29 = v26 - v27;
    if (v29 >= 0x7FFF) {
      int v29 = 0x7FFF;
    }
    if (v29 <= -32768) {
      LOWORD(v29) = 0x8000;
    }
    a1[5].i16[3] = v29;
    int32x4_t v30 = vmlal_s16(vmlal_s16(vmlal_s16(vmlal_s16(vmlal_s16(vmull_s16((int16x4_t)0x20016A000CFF64, a1[1]), (int16x4_t)0xFFF500350003FFF5, *a1), (int16x4_t)0x3B70F24FF2EFCDBLL, a1[2]), (int16x4_t)0xFCDBFF2E0F2403B7, a1[3]), (int16x4_t)0xFF64000C016A0020, a1[4]), (int16x4_t)0xFFF500030035FFF5, a1[5]);
    int v31 = vaddq_s32(v30, vdupq_laneq_s32(v30, 3)).i32[1];
    __int32 v32 = vaddq_s32(v30, vdupq_laneq_s32(v30, 2)).i32[0] >> 11;
    if (v32 <= -32768) {
      __int32 v32 = -32768;
    }
    if (v32 >= 0x7FFF) {
      LOWORD(v32) = 0x7FFF;
    }
    a1[15].i16[3] = v32;
    int v33 = v31 >> 11;
    if (v33 <= -32768) {
      int v33 = -32768;
    }
    if (v33 >= 0x7FFF) {
      LOWORD(v33) = 0x7FFF;
    }
    a1[6].i16[2] = v33;
    __int32 v34 = *((_DWORD *)v12 + 10);
    long long v35 = *(_OWORD *)v12;
    long long v36 = *((_OWORD *)v12 + 1);
    a1[4] = *(int16x4_t *)(v12 + 32);
    *(_OWORD *)a1->i8 = v35;
    *(_OWORD *)a1[2].i8 = v36;
    a1[5].i32[0] = v34;
    *(_WORD *)(a4 + 2 * v8) = v32;
    int v37 = v8 + 1;
    *(_WORD *)(a4 + 2 * v37) = *v9;
    int v8 = v37 + 1;
    ++a2;
    --v11;
  }
  while (v11);
LABEL_37:
  a5 = v41;
LABEL_39:
  *a5 = v8;
  return 0;
}

uint64_t sub_61CF4(__int16 a1, _WORD *a2)
{
  if (a1 == 7)
  {
    uint64_t v5 = (__int16)a2[3];
    __int16 v3 = word_7266C[v5];
    int v4 = (int)v5 >> 1;
    a2[3] = v4;
  }
  else if (a1 == 8)
  {
    uint64_t v2 = (__int16)a2[3];
    __int16 v3 = word_725EC[v2];
    int v4 = (int)v2 >> 2;
    a2[3] = v4;
  }
  else
  {
    LOWORD(v4) = a2[3];
    __int16 v3 = word_72578[(__int16)v4];
  }
  int v6 = (__int16)a2[5];
  int v7 = (__int16)a2[2] + ((v6 * v3) >> 15);
  if (v7 <= -32768) {
    int v7 = -32768;
  }
  if (v7 >= 0x7FFF) {
    LOWORD(v7) = 0x7FFF;
  }
  a2[1] = v7;
  uint64_t v8 = 2 * (__int16)v4;
  int v9 = ((__int16)word_72578[(unint64_t)v8 / 2] * v6) >> 15;
  if (v9 >= 0x7FFF) {
    LOWORD(v9) = 0x7FFF;
  }
  a2[6] = v9;
  int v10 = (*(__int16 *)((char *)&unk_724E0 + v8) + ((127 * (__int16)a2[4]) >> 7)) & ~((*(__int16 *)((char *)&unk_724E0 + v8)
                                                                                   + ((127 * (__int16)a2[4]) >> 7)) >> 31);
  if (v10 >= 18432) {
    int v10 = 18432;
  }
  a2[4] = v10;
  int v11 = (v10 >> 6) & 0x1F;
  unsigned int v12 = v10 >> 11;
  char v13 = 8 - v12;
  BOOL v14 = v12 > 8;
  int v15 = word_72598[v11];
  int v16 = v15 << (v12 - 8);
  int v17 = v15 >> v13;
  if (!v14) {
    LOWORD(v16) = v17;
  }
  a2[5] = 4 * v16;
  return sub_61E4C((uint64_t)a2);
}

double g722_decoder_init(uint64_t a1, __int16 a2)
{
  *(void *)(a1 + 192) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_WORD *)(a1 + 136) = 32;
  *(_WORD *)(a1 + 62) = 8;
  *(_WORD *)(a1 + 50) = a2;
  *(_WORD *)(a1 + 48) = 22;
  return result;
}

uint64_t sub_61E4C(uint64_t result)
{
  unsigned int v1 = *(__int16 *)(result + 12);
  int v2 = *(_WORD *)(result + 12) != 0;
  if ((int)(v1 + *(__int16 *)(result + 72)) >= 0x7FFF) {
    int v3 = 0x7FFF;
  }
  else {
    int v3 = v1 + *(__int16 *)(result + 72);
  }
  if (v3 <= -32768) {
    int v3 = -32768;
  }
  *(_WORD *)(result + 54) = v3;
  int v4 = v1 + *(__int16 *)(result + 4);
  if (v4 >= 0x7FFF) {
    int v4 = 0x7FFF;
  }
  if (v4 <= -32768) {
    LOWORD(v4) = 0x8000;
  }
  *(_WORD *)(result + 60) = v4;
  int v5 = v3 >> 15;
  int v6 = *(__int16 *)(result + 56);
  int v7 = *(__int16 *)(result + 68);
  int v8 = 4 * v7;
  if (4 * v7 <= -32768) {
    int v8 = -32768;
  }
  if (v8 >= 0x7FFF) {
    int v8 = 0x7FFF;
  }
  BOOL v9 = v5 == v6 >> 15;
  if (v5 == v6 >> 15) {
    int v10 = 192;
  }
  else {
    int v10 = -192;
  }
  if (v9) {
    int v8 = -v8;
  }
  if (v5 == *(__int16 *)(result + 58) >> 15) {
    int v11 = 128;
  }
  else {
    int v11 = -128;
  }
  int v12 = v11 + (v8 >> 7) + ((32512 * *(__int16 *)(result + 70)) >> 15);
  if (v12 <= -12288) {
    int v12 = -12288;
  }
  if (v12 >= 12288) {
    int v12 = 12288;
  }
  *(_WORD *)(result + 70) = v12;
  int v13 = v10 + ((32640 * v7) >> 15);
  if (v13 <= -32768) {
    int v13 = -32768;
  }
  if (v13 >= 0x7FFF) {
    int v13 = 0x7FFF;
  }
  int v14 = 15360 - v12;
  if (v13 <= -(unsigned __int16)v14) {
    int v15 = -(unsigned __int16)v14;
  }
  else {
    LOWORD(v15) = v13;
  }
  if (v14 >= v13) {
    LOWORD(v14) = v15;
  }
  *(_WORD *)(result + 68) = v14;
  int8x8_t v16 = *(int8x8_t *)(result + 14);
  int32x4_t v17 = vmull_s16(*(int16x4_t *)(result + 28), vdup_n_s16(0x7F80u));
  v18.i64[0] = vshrq_n_u32((uint32x4_t)v17, 0xFuLL).u64[0];
  v18.i64[1] = vshrq_n_s32(v17, 0xFuLL).i64[1];
  int32x4_t v19 = vaddq_s32(v18, (int32x4_t)vbslq_s8((int8x16_t)vmovl_s16(vcltz_s16((int16x4_t)veor_s8(v16, (int8x8_t)vdup_n_s16(v1)))), (int8x16_t)vdupq_n_s32(-128 * v2), (int8x16_t)vdupq_n_s32(v2 << 7)));
  int16x4_t v20 = vmovn_s32(v19);
  *(int16x4_t *)(result + 42) = v20;
  int v21 = *(__int16 *)(result + 22);
  if (((v21 ^ v1) & 0x80000000) == 0) {
    int v22 = v2 << 7;
  }
  else {
    int v22 = -128 * v2;
  }
  int v23 = v22 + ((32640 * *(__int16 *)(result + 36)) >> 15);
  *(_WORD *)(result + 50) = v23;
  if (((*(_WORD *)(result + 24) ^ v1) & 0x8000u) == 0) {
    int v24 = v2 << 7;
  }
  else {
    int v24 = -128 * v2;
  }
  int v25 = v24 + ((32640 * *(__int16 *)(result + 38)) >> 15);
  *(_WORD *)(result + 52) = v25;
  *(_WORD *)(result + 24) = v21;
  int v26 = 2 * v21;
  if (2 * v21 <= -32768) {
    int v26 = -32768;
  }
  if (v26 >= 0x7FFF) {
    int v26 = 0x7FFF;
  }
  *(_WORD *)(result + 38) = v25;
  int v27 = v26 * v25;
  *(_WORD *)(result + 22) = v16.i16[3];
  int v28 = 2 * v16.i16[3];
  if (v28 <= -32768) {
    int v28 = -32768;
  }
  if (v28 >= 0x7FFF) {
    int v28 = 0x7FFF;
  }
  *(_WORD *)(result + 36) = v23;
  *(_WORD *)(result + 20) = v16.i16[2];
  int v29 = ((v28 * v23) >> 15) + (v27 >> 15);
  int v30 = 2 * v16.i16[2];
  if (v30 <= -32768) {
    int v30 = -32768;
  }
  if (v30 >= 0x7FFF) {
    int v30 = 0x7FFF;
  }
  *(_WORD *)(result + 34) = v20.i16[3];
  __int32 v31 = v29 + ((v30 * v19.i32[3]) >> 15);
  int v32 = *(__int16 *)(result + 16);
  *(_WORD *)(result + 18) = v32;
  int v33 = 2 * v32;
  if (v33 <= -32768) {
    int v33 = -32768;
  }
  if (v33 >= 0x7FFF) {
    int v33 = 0x7FFF;
  }
  *(_WORD *)(result + 32) = v20.i16[2];
  __int32 v34 = v31 + ((v33 * v19.i32[2]) >> 15);
  int v35 = *(__int16 *)(result + 14);
  *(_WORD *)(result + 16) = v35;
  int v36 = 2 * v35;
  if (v36 <= -32768) {
    int v36 = -32768;
  }
  if (v36 >= 0x7FFF) {
    int v36 = 0x7FFF;
  }
  int v37 = *(__int16 *)(result + 44);
  *(_WORD *)(result + 30) = *(_WORD *)(result + 44);
  __int32 v38 = v34 + ((v36 * v37) >> 15);
  int v39 = *(__int16 *)(result + 12);
  *(_WORD *)(result + 14) = v39;
  int v40 = 2 * v39;
  if (v40 <= -32768) {
    int v40 = -32768;
  }
  if (v40 >= 0x7FFF) {
    int v40 = 0x7FFF;
  }
  int v41 = *(__int16 *)(result + 42);
  *(_WORD *)(result + 28) = *(_WORD *)(result + 42);
  int v42 = v38 + ((v40 * v41) >> 15);
  if (v42 <= -32768) {
    int v42 = -32768;
  }
  if (v42 >= 0x7FFF) {
    int v42 = 0x7FFF;
  }
  *(_WORD *)(result + 72) = v42;
  *(_DWORD *)(result + 56) = *(_DWORD *)(result + 54);
  int v43 = *(__int16 *)(result + 62);
  *(_WORD *)(result + 64) = v43;
  int v44 = 2 * v43;
  if (v44 <= -32768) {
    int v44 = -32768;
  }
  if (v44 >= 0x7FFF) {
    int v44 = 0x7FFF;
  }
  int v45 = v44 * *(__int16 *)(result + 70);
  int v46 = *(__int16 *)(result + 60);
  *(_WORD *)(result + 62) = v46;
  int v47 = 2 * v46;
  if (v47 <= -32768) {
    int v47 = -32768;
  }
  if (v47 >= 0x7FFF) {
    int v47 = 0x7FFF;
  }
  int v48 = ((v47 * *(__int16 *)(result + 68)) >> 15) + (v45 >> 15);
  if (v48 <= -32768) {
    int v48 = -32768;
  }
  if (v48 >= 0x7FFF) {
    int v48 = 0x7FFF;
  }
  int v49 = v48 + v42;
  if (v49 >= 0x7FFF) {
    int v50 = 0x7FFF;
  }
  else {
    int v50 = v49;
  }
  if (v50 <= -32768) {
    LOWORD(v50) = 0x8000;
  }
  *(_WORD *)(result + 4) = v50;
  return result;
}

void sub_62188(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62200(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62278(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_622F0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Wrong audio file type", v2, v3, v4, v5, v6);
}

void sub_62324()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Missing Encoder...", v2, v3, v4, v5, v6);
}

void sub_62358(uint8_t *buf, uint64_t a2, int a3, os_log_t log)
{
  *(_DWORD *)std::string buf = 134218240;
  *(void *)(buf + 4) = a2;
  *((_WORD *)buf + 6) = 1024;
  *(_DWORD *)(buf + 14) = a3;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "bufferSize (%lu) exceeds maxFrameSize (%d), not writing", buf, 0x12u);
}

void sub_623B0(uint8_t *buf, void *a2, os_log_t log)
{
  *(_DWORD *)std::string buf = 136446210;
  *a2 = "bufferSize <= GetFrameLength()";
  _os_log_fault_impl(&dword_0, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", buf, 0xCu);
}

void sub_62400(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *std::string buf = 0;
  *a2 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Input Decode:: decodeInputSize=0 for non-frame based codec", buf, 2u);
}

void sub_62440()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "IOOperationReadInput requested 0 Bytes read", v2, v3, v4, v5, v6);
}

void sub_62474()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "StartIO: failed to start because the ref count was maxed out", v2, v3, v4, v5, v6);
}

void sub_624A8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Audio start condition timed out waiting for signal", v2, v3, v4, v5, v6);
}

void sub_624DC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "IO was started on an ownership supported device that is not owned!", v2, v3, v4, v5, v6);
}

void sub_62510()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to initialize decoded input ring buffer", v2, v3, v4, v5, v6);
}

void sub_62544()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to initialize input ring buffer", v2, v3, v4, v5, v6);
}

void sub_62578()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to initialize output ring buffer", v2, v3, v4, v5, v6);
}

void sub_625AC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to initialize packetized output ring buffer", v2, v3, v4, v5, v6);
}

void sub_625E0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "StopIO: failed to stop because the ref count was already 0", v2, v3, v4, v5, v6);
}

void sub_62614(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "StopIO returns noErr (%llu)", (uint8_t *)&v3, 0xCu);
}

void sub_62690(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "Unable to decode mic mode %d to string", (uint8_t *)v2, 8u);
}

double sub_62708(__int32 *a1, NSObject *a2, uint8x8_t a3)
{
  a3.i32[0] = *a1;
  int16x8_t v3 = (int16x8_t)vmovl_u8(a3);
  *(int16x4_t *)v3.i8 = vrev64_s16(*(int16x4_t *)v3.i8);
  unsigned __int32 v5 = vmovn_s16(v3).u32[0];
  char v6 = 0;
  *(_DWORD *)std::string buf = 136446210;
  int v8 = &v5;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "Error in sending property change for property %{public}s", buf, 0xCu);
  return result;
}

void sub_6279C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62814(int *a1, uint64_t a2, os_log_t log)
{
  int v3 = *a1;
  int v4 = *(_DWORD *)(a2 + 52);
  v5[0] = 67109376;
  v5[1] = v3;
  __int16 v6 = 1024;
  int v7 = v4;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Failed in dispatched config change for AudioObjectProperty %u on object %d", (uint8_t *)v5, 0xEu);
}

void sub_628A4(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "Latency change received from BTServer, latency %u", (uint8_t *)v2, 8u);
}

void sub_6291C(char a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1 & 1;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "absolute volume set to %d", (uint8_t *)v2, 8u);
}

void sub_62998(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Wireless Splitter Stop, did not find a valid device", v1, 2u);
}

void sub_629DC(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "AACDecoder destructor try releasing NULL converter", v1, 2u);
}

void sub_62A20(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "LEA Packet length is not valid %u", (uint8_t *)v2, 8u);
}

void sub_62A98(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62B10(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62B88(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62C00(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62C78(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62CF0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62D68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_62DE0(unsigned char *a1, unsigned char *a2)
{
  sub_11AC4(a1, a2);
  sub_11AD4(&dword_0, v2, (uint64_t)v2, "Not a valid codec type!", v3);
}

void sub_62E10(unsigned char *a1, unsigned char *a2)
{
  sub_11AC4(a1, a2);
  sub_11AD4(&dword_0, v2, (uint64_t)v2, "lea packet length not specified, bypass codec selection", v3);
}

void sub_62E40()
{
  sub_BBE0();
  sub_11AD4(&dword_0, v0, v1, "codecData is NULL is NULL, can't add it", v2);
}

void sub_62E78(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "Want to get encoder type %u", (uint8_t *)v2, 8u);
}

void sub_62EF0(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "Want to get decoder type %u", (uint8_t *)v2, 8u);
}

void sub_62F68()
{
  sub_BBE0();
  sub_11AD4(&dword_0, v0, v1, "CODEC NOT FOUND!!!", v2);
}

void sub_62FA0()
{
  sub_BBE0();
  sub_11AD4(&dword_0, v0, v1, "Codec found was same as current", v2);
}

void sub_62FD8(float a1)
{
  double v5 = sub_11AEC(a1);
  __int16 v6 = v1;
  uint64_t v7 = v2;
  _os_log_debug_impl(&dword_0, v3, OS_LOG_TYPE_DEBUG, "volume %f, mScalarVolume %f, mDBVolume %f", v4, 0x20u);
}

void sub_6305C(float a1)
{
  double v1 = sub_11AEC(a1);
  uint64_t v6 = v2;
  __int16 v7 = v3;
  double v8 = v1;
  _os_log_debug_impl(&dword_0, v4, OS_LOG_TYPE_DEBUG, "volume %f, mScalarVolume %f, mDBVolume %f", v5, 0x20u);
}

void sub_630E0()
{
  sub_BBE0();
  _os_log_debug_impl(&dword_0, v0, OS_LOG_TYPE_DEBUG, "kBluetoothAudioDeviceCategory", v1, 2u);
}

void sub_63120()
{
  sub_BBE0();
  sub_11AD4(&dword_0, v0, v1, "setPropertyData: wrong size for the data for kAudioDevicePropertyNominalSampleRate", v2);
}

void sub_63158(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_631D0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_63248(uint64_t a1, NSObject *a2)
{
  int v2 = 138412290;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "Request to get the volume for wrong catetory: %@", (uint8_t *)&v2, 0xCu);
}

void sub_632C0(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Manual volume update, device invalid", v1, 2u);
}

void sub_63304(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_63374()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Even though some formats have cookies, some files don't take them and that's OK\n", v2, v3, v4, v5, v6);
}

void sub_633A8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Could not Get kAudioConverterCompressionMagicCookie from Audio Converter!\n", v2, v3, v4, v5, v6);
}

void sub_633DC(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6344C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Even though some formats have layouts, some files don't take them and that's OK\n", v2, v3, v4, v5, v6);
}

void sub_63480()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Could not Get kAudioConverterOutputChannelLayout from Audio Converter!\n", v2, v3, v4, v5, v6);
}

void sub_634B4(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_63524()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Some audio files can't contain packet table information and that's OK\n", v2, v3, v4, v5, v6);
}

void sub_63558(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "Total number of frames from output file: %lld\n", (uint8_t *)&v2, 0xCu);
}

void sub_635D0(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6363C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "No kAudioConverterPrimeInfo available and that's OK\n", v2, v3, v4, v5, v6);
}

void sub_63670(int a1, int a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "GetPropertyInfo for kAudioFilePropertyPacketTableInfo error: %d, isWritable: %u\n", (uint8_t *)v3, 0xEu);
}

void sub_636F8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Error trying to create AudioFileCreateWithURL!!", v2, v3, v4, v5, v6);
}

void sub_6372C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed creating destinationURL!", v2, v3, v4, v5, v6);
}

void sub_63760()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Created a good destinationURL!", v2, v3, v4, v5, v6);
}

void sub_63794(int a1, NSObject *a2)
{
  v2[0] = HIBYTE(a1);
  v2[1] = BYTE2(a1);
  _DWORD v2[2] = BYTE1(a1);
  v2[3] = a1;
  v2[4] = 0;
  *(_DWORD *)std::string buf = 136446210;
  uint64_t v4 = v2;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "device type %{public}s", buf, 0xCu);
}

void sub_63830(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_638A0(uint64_t a1, NSObject *a2)
{
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "XPC connection error: %{public}s", (uint8_t *)&v2, 0xCu);
}

void sub_63918(uint64_t a1, NSObject *a2)
{
  int v2 = 136446210;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "Unexpected XPC connection event: %{public}s", (uint8_t *)&v2, 0xCu);
}

void sub_63990()
{
  sub_16A44();
  sub_13758(&dword_0, v0, v1, "Unhandled XPC message: %u", v2, v3, v4, v5, v6);
}

void sub_639F8()
{
  sub_16A44();
  sub_13758(&dword_0, v0, v1, "Msg ID is %d, ignoring XPC message", v2, v3, v4, v5, v6);
}

void sub_63A60()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendStartMsg null values[1]", v2, v3, v4, v5, v6);
}

void sub_63A94()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendStartMsg null values[0]", v2, v3, v4, v5, v6);
}

void sub_63AC8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendStartMsg null args", v2, v3, v4, v5, v6);
}

void sub_63AFC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "XPC connection is no longer valid. Cannot send msg.", v2, v3, v4, v5, v6);
}

void sub_63B30()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendMsg null values[0]", v2, v3, v4, v5, v6);
}

void sub_63B64()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendMsg null values[1]", v2, v3, v4, v5, v6);
}

void sub_63B98()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendMsg null msg", v2, v3, v4, v5, v6);
}

void sub_63BCC()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "XPC STOP MESSAGE SENT!", v2, v3, v4, v5, v6);
}

void sub_63C00()
{
  sub_16A44();
  sub_16A28(&dword_0, v0, v1, "XPC %d Directional Transitiion SENT!", v2, v3, v4, v5, v6);
}

void sub_63C68()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendAudioDeliveryChangeCompletedMsg null value", v2, v3, v4, v5, v6);
}

void sub_63C9C()
{
  sub_16A50();
  sub_16A28(&dword_0, v0, v1, "XPC Send Audio delivery speed change completed Msg, status %d!", v2, v3, v4, v5, v6);
}

void sub_63D04()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSelectCodecMsg null value", v2, v3, v4, v5, v6);
}

void sub_63D38()
{
  sub_16A44();
  sub_16A28(&dword_0, v0, v1, "XPC Send Codec Selection Msg, codec type %d!", v2, v3, v4, v5, v6);
}

void sub_63DA0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSelectScoDataSourceMsg null values[2]", v2, v3, v4, v5, v6);
}

void sub_63DD4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSelectScoDataSourceMsg null values[1]", v2, v3, v4, v5, v6);
}

void sub_63E08()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSelectScoDataSourceMsg null values[0]", v2, v3, v4, v5, v6);
}

void sub_63E3C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSelectScoDataSourceMsg null msg", v2, v3, v4, v5, v6);
}

void sub_63E70()
{
  sub_16A44();
  __int16 v3 = 1024;
  int v4 = v0;
  _os_log_debug_impl(&dword_0, v1, OS_LOG_TYPE_DEBUG, "XPC Send Sco Data Source: %u, %u!", v2, 0xEu);
}

void sub_63EF4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendAudioContentTypeMsg null value", v2, v3, v4, v5, v6);
}

void sub_63F28()
{
  sub_16A44();
  sub_16A28(&dword_0, v0, v1, "XPC Send AudioContentType, type %u!", v2, v3, v4, v5, v6);
}

void sub_63F90()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendInputVolumePropertyChanged null values[0]", v2, v3, v4, v5, v6);
}

void sub_63FC4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendInputVolumePropertyChanged null args", v2, v3, v4, v5, v6);
}

void sub_63FF8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendVolumePropertyChanged null values[0]", v2, v3, v4, v5, v6);
}

void sub_6402C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendVolumePropertyChanged null args", v2, v3, v4, v5, v6);
}

void sub_64060()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendDynamicLatencyAudioAndInputAggregationStatePropertyChanged null values[0]", v2, v3, v4, v5, v6);
}

void sub_64094()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendDynamicLatencyAudioAndInputAggregationStatePropertyChanged null args", v2, v3, v4, v5, v6);
}

void sub_640C8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendExpanseStatePropertyChanged null values[0]", v2, v3, v4, v5, v6);
}

void sub_640FC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendExpanseStatePropertyChanged null args", v2, v3, v4, v5, v6);
}

void sub_64130()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendExpanseInA2DPChanged null values[0]", v2, v3, v4, v5, v6);
}

void sub_64164()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendExpanseInA2DPChanged null args", v2, v3, v4, v5, v6);
}

void sub_64198()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendCallScreeningState null args", v2, v3, v4, v5, v6);
}

void sub_641CC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendGameStatePropertyChanged null values[0]", v2, v3, v4, v5, v6);
}

void sub_64200()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendGameStatePropertyChanged null args", v2, v3, v4, v5, v6);
}

void sub_64234()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendVoiceOverStatePropertyChanged null values[0]", v2, v3, v4, v5, v6);
}

void sub_64268()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendVoiceOverStatePropertyChanged null args", v2, v3, v4, v5, v6);
}

void sub_6429C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendWirelessSplitterEnabled null values[0]", v2, v3, v4, v5, v6);
}

void sub_642D0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendWirelessSplitterEnabled null args", v2, v3, v4, v5, v6);
}

void sub_64304()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSpatialAudioActive null values[0]", v2, v3, v4, v5, v6);
}

void sub_64338()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSpatialAudioActive null args", v2, v3, v4, v5, v6);
}

void sub_6436C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendDynamicLatencyFrameCount null values[0]", v2, v3, v4, v5, v6);
}

void sub_643A0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendDynamicLatencyFrameCount null args", v2, v3, v4, v5, v6);
}

void sub_643D4()
{
  sub_16A44();
  sub_16A28(&dword_0, v0, v1, "Send frame count bluetoothd %u", v2, v3, v4, v5, v6);
}

void sub_6443C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSpatialAudioModeEnabled null values[0]", v2, v3, v4, v5, v6);
}

void sub_64470()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSpatialAudioModeEnabled null args", v2, v3, v4, v5, v6);
}

void sub_644A4()
{
  sub_16A44();
  sub_16A28(&dword_0, v0, v1, "Send spatial audio enabled %u", v2, v3, v4, v5, v6);
}

void sub_6450C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendAdaptiveVolumeRampEndConfig null values[0]", v2, v3, v4, v5, v6);
}

void sub_64540()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendAdaptiveVolumeRampEndConfig null args", v2, v3, v4, v5, v6);
}

void sub_64574()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendManualVolumeUpdateConfig null values[0]", v2, v3, v4, v5, v6);
}

void sub_645A8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendManualVolumeUpdateConfig null args", v2, v3, v4, v5, v6);
}

void sub_645DC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendPMEOnBudsEnabled null values[0]", v2, v3, v4, v5, v6);
}

void sub_64610()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendPMEOnBudsEnabled null args", v2, v3, v4, v5, v6);
}

void sub_64644()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSpatialAudioAppBasedConfig null values[0]", v2, v3, v4, v5, v6);
}

void sub_64678()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSpatialAudioAppBasedConfig null args", v2, v3, v4, v5, v6);
}

void sub_646AC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSpatialAudioAllowed null values[0]", v2, v3, v4, v5, v6);
}

void sub_646E0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSpatialAudioAllowed null args", v2, v3, v4, v5, v6);
}

void sub_64714()
{
  sub_16A50();
  sub_16A28(&dword_0, v0, v1, "Send Spatial Audio allowed %d", v2, v3, v4, v5, v6);
}

void sub_6477C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSoftwareVolumeEnabled null values[0]", v2, v3, v4, v5, v6);
}

void sub_647B0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSoftwareVolumeEnabled null args", v2, v3, v4, v5, v6);
}

void sub_647E4()
{
  sub_16A50();
  sub_16A28(&dword_0, v0, v1, "Send software volume enabled %d", v2, v3, v4, v5, v6);
}

void sub_6484C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetAllowScoForTBT null values[0]", v2, v3, v4, v5, v6);
}

void sub_64880()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetAllowScoForTBT null args", v2, v3, v4, v5, v6);
}

void sub_648B4()
{
  sub_16A50();
  sub_16A28(&dword_0, v0, v1, "Send allow sco for turn by turn %d", v2, v3, v4, v5, v6);
}

void sub_6491C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSampleRate null values[0]", v2, v3, v4, v5, v6);
}

void sub_64950()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSampleRate null args", v2, v3, v4, v5, v6);
}

void sub_64984()
{
  sub_16A44();
  sub_16A28(&dword_0, v0, v1, "Send sample Rate  %d", v2, v3, v4, v5, v6);
}

void sub_649EC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendHFPCodecTypeMsg null payload", v2, v3, v4, v5, v6);
}

void sub_64A20()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendHFPCodecTypeMsg null msg", v2, v3, v4, v5, v6);
}

void sub_64A54()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetOwnershipState null payloadValues[1]", v2, v3, v4, v5, v6);
}

void sub_64A88()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetOwnershipState null payloadValues[0]", v2, v3, v4, v5, v6);
}

void sub_64ABC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetOwnershipState null msgValues[0]", v2, v3, v4, v5, v6);
}

void sub_64AF0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetOwnershipState null msg", v2, v3, v4, v5, v6);
}

void sub_64B24()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetListenMode null values[0]", v2, v3, v4, v5, v6);
}

void sub_64B58()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetListenMode null args", v2, v3, v4, v5, v6);
}

void sub_64B8C()
{
  sub_16A44();
  sub_16A28(&dword_0, v0, v1, "Send set listen mode %d", v2, v3, v4, v5, v6);
}

void sub_64BF4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetDosimetrySensitivity null values[0]", v2, v3, v4, v5, v6);
}

void sub_64C28()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetDosimetrySensitivity null args", v2, v3, v4, v5, v6);
}

void sub_64C5C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetDosimetryVolumeCurve null values[0]", v2, v3, v4, v5, v6);
}

void sub_64C90()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "#Error BTAudioXpcConnection::SendSetDosimetryVolumeCurve null args", v2, v3, v4, v5, v6);
}

void sub_64CC4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Audio Device object is not created for this connection", v2, v3, v4, v5, v6);
}

void sub_64CF8()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "xpc object for kBTAudioMsgPropertyInEarDetection does not exist..!", v2, v3, v4, v5, v6);
}

void sub_64D2C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "xpc object type for kBTAudioMsgPropertyInEarDetection is not type BOOL!", v2, v3, v4, v5, v6);
}

void sub_64D60(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_64DD0()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "xpc object for kBTAudioMsgPropertyIsGenuineAirPods does not exist..!", v2, v3, v4, v5, v6);
}

void sub_64E04()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "xpc object type for kBTAudioMsgPropertyIsGenuineAirPods is not type BOOL!", v2, v3, v4, v5, v6);
}

void sub_64E38(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_64EA8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to create a nexus provider", v2, v3, v4, v5, v6);
}

void sub_64EDC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to create kevent for read queue", v2, v3, v4, v5, v6);
}

void sub_64F10(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "AudioSkywalk read loop is configured to an invalid audio interval (%llu). Defaulting to 22000us", (uint8_t *)&v3, 0xCu);
}

void sub_64F8C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "No channelId for skywalk pipe", v2, v3, v4, v5, v6);
}

void sub_64FC0()
{
  sub_17E1C();
  _os_log_debug_impl(&dword_0, v0, OS_LOG_TYPE_DEBUG, "%d bytes available skywalk slot %d", v1, 0xEu);
}

void sub_6503C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Unable to write into skywalk pipe because ring buffer is full", v2, v3, v4, v5, v6);
}

void sub_65070(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 134218240;
  uint64_t v4 = a1;
  __int16 v5 = 2048;
  uint64_t v6 = a2;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Unable to write %lu bytes into skywalk pipe, not enough free space (%lu bytes available)", (uint8_t *)&v3, 0x16u);
}

void sub_650F8()
{
  sub_17E1C();
  __int16 v3 = 2048;
  uint64_t v4 = v0;
  _os_log_debug_impl(&dword_0, v1, OS_LOG_TYPE_DEBUG, "Syncing slot %d with length %hu, offset %lu", v2, 0x18u);
}

void sub_65188()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Unable to create os_channel", v2, v3, v4, v5, v6);
}

void sub_651BC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to alloc a nexus provider", v2, v3, v4, v5, v6);
}

void sub_651F0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_65228(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Input decode: requested unsupported PLC", v1, 2u);
}

void sub_6526C(uint64_t a1, uint64_t a2, os_log_t log)
{
  int v3 = 136446466;
  uint64_t v4 = a1;
  __int16 v5 = 2082;
  uint64_t v6 = a2;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Error: %{public}s (%{public}s)\n", (uint8_t *)&v3, 0x16u);
}

void sub_652F4(void *a1)
{
  objc_msgSend(objc_msgSend(a1, "description"), "UTF8String");
  sub_1D754(&dword_0, v1, v2, "Received IDS message %s with no BTAudioIdsMsgCommands", v3, v4, v5, v6, 2u);
}

void sub_65378(void *a1)
{
  objc_msgSend(objc_msgSend(a1, "description"), "UTF8String");
  sub_1D754(&dword_0, v1, v2, "No value for command %s", v3, v4, v5, v6, 2u);
}

void sub_653FC(uint64_t a1, uint8_t *buf, os_log_t log)
{
  *(_DWORD *)std::string buf = 136446210;
  *(void *)(buf + 4) = a1;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Unknown arbitration message %{public}s receieved", buf, 0xCu);
}

void sub_65444()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BTAudioDetect output invalid inBufferFrameSize for virtual", v2, v3, v4, v5, v6);
}

void sub_65478()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BTAudioDetect output invalid buffer addr for virtual", v2, v3, v4, v5, v6);
}

void sub_654AC(uint64_t a1, NSObject *a2)
{
  int v2 = 134217984;
  uint64_t v3 = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "BTAudioDetect input invalid decodedBytes %zu", (uint8_t *)&v2, 0xCu);
}

void sub_65524()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BTAudioDetect invalid decoder config", v2, v3, v4, v5, v6);
}

void sub_65558()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BTAudioDetect output invalid inBufferFrameSize", v2, v3, v4, v5, v6);
}

void sub_6558C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BTAudioDetect output invalid buffer addr", v2, v3, v4, v5, v6);
}

void sub_655C0(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_debug_impl(&dword_0, log, OS_LOG_TYPE_DEBUG, "Sending BTAudioMetricA2DPDynamicLatency", v1, 2u);
}

void sub_65604(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "LC3Decoder destructor try releasing NULL converter", v1, 2u);
}

void sub_65648(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "No codec found for codecType %u", (uint8_t *)v2, 8u);
}

void sub_656C0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Shared memory has not been allocated yet, deferring read", v2, v3, v4, v5, v6);
}

void sub_656F4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "AudioRingBuffer::readFrameInternal, frame header cannot be wrapped around", v2, v3, v4, v5, v6);
}

void sub_65728(uint64_t a1, uint64_t a2)
{
  if (*(void *)a2) {
    atomic_load((unint64_t *)(*(void *)a2 + 24));
  }
  sub_200D4();
  HIWORD(v6) = v2;
  sub_200E8(&dword_0, v3, v4, "AudioRingBuffer::readFrameInternal, frame length(%lu) bigger than available buffer length (%lu)", v5, v6);
}

void sub_657A8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Shared memory has not been allocated yet, deferring write", v2, v3, v4, v5, v6);
}

void sub_657DC(uint64_t a1)
{
  atomic_load((unint64_t *)(*(void *)a1 + 24));
  sub_200D4();
  HIWORD(v4) = v1;
  sub_200E8(&dword_0, v1, v2, "Shared memory size (%lu bytes available) has less than requested buffer length (%lu), deferring write", v3, v4);
}

void sub_6585C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "AudioRingBuffer::writeFrameHeader, frame header cannot be wrapped around", v2, v3, v4, v5, v6);
}

void sub_65890(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "AACEncoder destructor try releasing NULL converter", v1, 2u);
}

void sub_658D4()
{
  sub_20CA8();
  sub_20C98();
  __int16 v4 = v0;
  int v5 = v1;
  _os_log_debug_impl(&dword_0, v2, OS_LOG_TYPE_DEBUG, "mOutputBufferSize %u, outputSizePerPacket %u, mNumOutputPackets %u", v3, 0x14u);
}

void sub_65960()
{
  sub_20CA8();
  sub_16A28(&dword_0, v0, v1, "kAudioCodecPropertyMaximumPacketByteSize returned max packet size of %u bytes", v2, v3, v4, v5, v6);
}

void sub_659CC()
{
  sub_20CA8();
  sub_16A28(&dword_0, v0, v1, "Actual target Bitrate is set to %u", v2, v3, v4, v5, v6);
}

void sub_65A38(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_65AA4()
{
  sub_20CA8();
  sub_16A28(&dword_0, v0, v1, "mOutputFormat.mBytesPerPacket %u", v2, v3, v4, v5, v6);
}

void sub_65B10(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Codec type and  frame length values did not make sense!", v1, 2u);
}

void sub_65B54()
{
  sub_20C98();
  sub_20CB4(&dword_0, v0, v1, "AACEncoder, skip processing, ioOutputDataPackets(%u) is bigger than numMaxBuffers(%u)", 67109376, v2);
}

void sub_65BC4()
{
  sub_20C98();
  sub_20CB4(&dword_0, v0, v1, "AACEncoder, mOutputBufferSize(%u) <= offset(%u)", 67109376, v2);
}

void sub_65C34()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Error: Spatial Audio: Can't allocate SpatialAudioClient", v2, v3, v4, v5, v6);
}

void sub_65C68(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_65CE0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_65D58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_65DD0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_65E48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_65EC0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "No Device name Received from Bluetoothd", v2, v3, v4, v5, v6);
}

void sub_65EF4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Cannot set Stereo HFP, not supported", v2, v3, v4, v5, v6);
}

void sub_65F28()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Cannot set Stereo HFP, invalid Audio Device", v2, v3, v4, v5, v6);
}

void sub_65F5C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_65FD4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6604C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_660C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6613C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_661B4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6622C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_662A4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6631C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66394(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6640C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66484(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_664FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66574(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_665EC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66664(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_666DC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66754(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_667CC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66844()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "kBTAudioMsgPropertyInEarStatus not present", v2, v3, v4, v5, v6);
}

void sub_66878(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_668F0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66968(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_669E0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66A58(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66AD0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Adaptive Volume: not able to call updateVolume API from MX, no valid stream", v2, v3, v4, v5, v6);
}

void sub_66B04()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "kBTAudioMsgPropertyForegroundApp get string fail", v2, v3, v4, v5, v6);
}

void sub_66B38(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66BB0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_66C28()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "kBTAudioMsgPropertySpatialAudioAppBasedMode get Dict fail", v2, v3, v4, v5, v6);
}

void sub_66C5C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Auto Volume mode no rampDownRate key in subdict", v2, v3, v4, v5, v6);
}

void sub_66C90()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Auto Volume mode no rampUpRate key in subdict", v2, v3, v4, v5, v6);
}

void sub_66CC4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Auto Volume mode no voiceTarget key in subdict", v2, v3, v4, v5, v6);
}

void sub_66CF8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Auto Volume mode no telephonyTarget key in subdict", v2, v3, v4, v5, v6);
}

void sub_66D2C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Auto Volume mode no mediaTarget key in subdict", v2, v3, v4, v5, v6);
}

void sub_66D60()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Spatial Audio Mode no headTrack key in subdict", v2, v3, v4, v5, v6);
}

void sub_66D94()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Spatial Audio Mode no spatialMode key in subdict", v2, v3, v4, v5, v6);
}

void sub_66DC8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "UpdateSpatialPerAppMode Dict invalid, skip", v2, v3, v4, v5, v6);
}

void sub_66DFC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetSpatialPerAppMode no valid headTrack value from local copy dict", v2, v3, v4, v5, v6);
}

void sub_66E30()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetSpatialPerAppMode no valid spatialMode key in subdict", v2, v3, v4, v5, v6);
}

void sub_66E64()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Error: Spatial Audio: We are upmixing stereo when user has requested to Not do it", v2, v3, v4, v5, v6);
}

void sub_66E98()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Error: Spatial Audio: We are not spatilaizing in Always spatial Mode", v2, v3, v4, v5, v6);
}

void sub_66ECC(void *a1)
{
  [a1 name];
  [a1 identifier];
  sub_2F22C();
  sub_2F248(&dword_0, v2, v3, "%{public}s - peripheral:%@ identifier:%@ - dosimetry sensitivity characteristic value is less than 4 bytes", v4, v5, v6, v7, 2u);
}

void sub_66F68(void *a1)
{
  [a1 identifier];
  sub_1D754(&dword_0, v1, v2, "Failed to read value for dosimetry sensitivity characteristic on peripheral %@", v3, v4, v5, v6, 2u);
}

void sub_66FE4(void *a1)
{
  [a1 name];
  [a1 identifier];
  sub_2F22C();
  sub_2F248(&dword_0, v2, v3, "%{public}s - peripheral:%@ identifier:%@ - dosimetry volume curve characteristic value is less than 68 bytes", v4, v5, v6, v7, 2u);
}

void sub_67080(void *a1)
{
  [a1 identifier];
  sub_1D754(&dword_0, v1, v2, "Failed to read value for dosimetry volume curve characteristic on peripheral %@", v3, v4, v5, v6, 2u);
}

void sub_670FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67134(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6716C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_671A4(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "Wrong Heimdall codec type %d", (uint8_t *)v2, 8u);
}

void sub_6721C(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "mInputFormat.mChannelsPerFrame <= kMaxInputBuffers";
  _os_log_fault_impl(&dword_0, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_672A0(int *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "kAudioConverterPropertyMaximumOutputPacketSize returned %u", (uint8_t *)v3, 8u);
}

void sub_6731C(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "Encoder type (%d) is not valid", (uint8_t *)v2, 8u);
}

void sub_67394()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Creating SBC Encoder", v2, v3, v4, v5, v6);
}

void sub_673C8()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Creating AAC-LC Encoder", v2, v3, v4, v5, v6);
}

void sub_673FC()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Creating AAC-ELD Encoder", v2, v3, v4, v5, v6);
}

void sub_67430(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "Audio Consumption Frame size =%d", (uint8_t *)v2, 8u);
}

void sub_674A8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67520(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67598(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67610(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67688(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67700(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67778(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_677F0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67868(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_678E0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67958(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_679D0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67A48(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67AC0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67B38(unsigned char *a1, uint64_t a2, os_log_t log)
{
  uint64_t v3 = "Schedule Delayed";
  int v4 = *(_DWORD *)(a2 + 9124);
  int v5 = *(_DWORD *)(a2 + 9168);
  if (!*a1) {
    uint64_t v3 = "Immediate";
  }
  int v6 = 136446722;
  uint64_t v7 = v3;
  __int16 v8 = 1024;
  int v9 = v4;
  __int16 v10 = 1024;
  int v11 = v5;
  _os_log_debug_impl(&dword_0, log, OS_LOG_TYPE_DEBUG, "Dynamic Latency : %{public}s Frame Count Update %u -> %u", (uint8_t *)&v6, 0x18u);
}

void sub_67BEC()
{
  sub_17E1C();
  _os_log_debug_impl(&dword_0, v0, OS_LOG_TYPE_DEBUG, "Dynamic Latency : Delayed Low LLM->MLM frame count update  %u -> %u", v1, 0xEu);
}

void sub_67C68()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "kBluetoothAudioDeviceCategory", v2, v3, v4, v5, v6);
}

void sub_67C9C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDeviceInputAggregate", v2, v3, v4, v5, v6);
}

void sub_67CD0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kA2DPLowLatencyMode", v2, v3, v4, v5, v6);
}

void sub_67D04()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyLatencyOverride", v2, v3, v4, v5, v6);
}

void sub_67D38(uint64_t a1, NSObject *a2)
{
  if (*(float *)(a1 + 540) <= 1.0) {
    uint64_t v3 = "Speed Up";
  }
  else {
    uint64_t v3 = "Slow Down";
  }
  int v4 = 136446466;
  uint64_t v5 = v3;
  __int16 v6 = 1024;
  int v7 = sub_3537C(a1);
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "Dynamic Latency : Start Latency Targeted %{public}s initial in-ear-delay=%u", (uint8_t *)&v4, 0x12u);
}

void sub_67DF0()
{
  sub_17E1C();
  _os_log_debug_impl(&dword_0, v0, OS_LOG_TYPE_DEBUG, "Dynamic Latency : Forced Delayed Low LLM->MLM frame count update  %u -> %u", v1, 0xEu);
}

void sub_67E6C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67EE4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67F5C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_67FD4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6804C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_680C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6813C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_681B4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6822C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_682A4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6831C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_68394(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6840C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_68484(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_684FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_68574()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Creating HFP Codec for UWBS", v2, v3, v4, v5, v6);
}

void sub_685A8()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Creating HFP Codec for SBW", v2, v3, v4, v5, v6);
}

void sub_685DC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_68654(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_686CC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_68744(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_687BC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_68834(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_688AC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "eq setting is not valid!", v2, v3, v4, v5, v6);
}

void sub_688E0(int a1, NSObject *a2)
{
  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "eq setting id %d is not valid!", (uint8_t *)v2, 8u);
}

void sub_68958()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Stop SCO AUDIO!", v2, v3, v4, v5, v6);
}

void sub_6898C(uint64_t *a1, NSObject *a2)
{
  uint64_t v2 = *a1;
  int v3 = 134217984;
  uint64_t v4 = v2;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, " SetStreamPropertyData sampling freq is %lf", (uint8_t *)&v3, 0xCu);
}

void sub_68A08()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Set kAudioStreamPropertyPhysicalFormat", v2, v3, v4, v5, v6);
}

void sub_68A3C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyBaseClass for the volume control", v2, v3, v4, v5, v6);
}

void sub_68A70()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyClass for the volume control", v2, v3, v4, v5, v6);
}

void sub_68AA4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioSelectorControlPropertyCurrentItem for the data source control", v2, v3, v4, v5, v6);
}

void sub_68AD8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioSelectorControlPropertyItemName for the data source control", v2, v3, v4, v5, v6);
}

void sub_68B0C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: wrong size for the qualifier of kAudioSelectorControlPropertyItemName for the data source control", v2, v3, v4, v5, v6);
}

void sub_68B40()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Unknown sco path", v2, v3, v4, v5, v6);
}

void sub_68B74()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Sco audio source set to hci", v2, v3, v4, v5, v6);
}

void sub_68BA8()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Sco audio source set to bbs", v2, v3, v4, v5, v6);
}

void sub_68BDC()
{
  sub_BBE0();
  sub_16A60(&dword_0, v0, v1, "Sco audio source set to i2s", v2, v3, v4, v5, v6);
}

void sub_68C10()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "SetControlPropertyData: wrong size for the data for kAudioSelectorControlPropertyCurrentItem", v2, v3, v4, v5, v6);
}

void sub_68C44(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_68CB0(uint64_t a1, int a2, os_log_t log)
{
  v3[0] = 67109378;
  v3[1] = a2;
  __int16 v4 = 2112;
  uint64_t v5 = a1;
  _os_log_debug_impl(&dword_0, log, OS_LOG_TYPE_DEBUG, "Audio Message %d from Audio Device UID: %@\n", (uint8_t *)v3, 0x12u);
}

void sub_68D38(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_68DA4(void *a1, NSObject *a2)
{
  int v3 = 136315138;
  id v4 = [a1 UTF8String];
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "Found HAL device for UID: %s, handling msg\n", (uint8_t *)&v3, 0xCu);
}

void sub_68E30(uint64_t a1, uint64_t *a2, os_log_t log)
{
  uint64_t v3 = *(void *)(a1 + 136);
  uint64_t v4 = *a2;
  int v5 = 134218240;
  uint64_t v6 = v3;
  __int16 v7 = 2048;
  uint64_t v8 = v4;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "BTAudioPlugin publish ready condition timed out %ld, %ld", (uint8_t *)&v5, 0x16u);
}

void sub_68EC0(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "deviceAddress";
  _os_log_fault_impl(&dword_0, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_68F44()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "AudioPlugin has not been initialized yet, not signaling plugin properties changed", v2, v3, v4, v5, v6);
}

void sub_68F78()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BTAudioDevice is NULL, can't destroy it", v2, v3, v4, v5, v6);
}

void sub_68FAC(char *a1, void *a2, NSObject *a3)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  LODWORD(v3) = 136446210;
  *(void *)((char *)&v3 + 4) = a2;
  sub_48708(&dword_0, (uint64_t)a2, a3, "Asked to take ownership for %{public}s, but device no longer exists", (void)v3, DWORD2(v3));
}

void sub_69024(char *a1, void *a2, NSObject *a3)
{
  if (*a1 < 0) {
    a2 = (void *)*a2;
  }
  LODWORD(v3) = 136446210;
  *(void *)((char *)&v3 + 4) = a2;
  sub_48708(&dword_0, (uint64_t)a2, a3, "Ownership requested on disconnected device %{public}s", (void)v3, DWORD2(v3));
}

void sub_6909C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Not enough space for the return value of kAudioObjectPropertyBaseClass for the plug-in", v2, v3, v4, v5, v6);
}

void sub_690D0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Not enough space for the return value of kAudioObjectPropertyClass for the plug-in", v2, v3, v4, v5, v6);
}

void sub_69104()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Not enough space for the return value of kAudioObjectPropertyOwner for the plug-in", v2, v3, v4, v5, v6);
}

void sub_69138()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Not enough space for the return value of kAudioObjectPropertyManufacturer for the plug-in", v2, v3, v4, v5, v6);
}

void sub_6916C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioPlugInPropertyTranslateUIDToDevice", v2, v3, v4, v5, v6);
}

void sub_691A0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: the qualifier is the wrong size for kAudioPlugInPropertyTranslateUIDToDevice", v2, v3, v4, v5, v6);
}

void sub_691D4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: no qualifier for kAudioPlugInPropertyTranslateUIDToDevice", v2, v3, v4, v5, v6);
}

void sub_69208()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioPlugInPropertyResourceBundle", v2, v3, v4, v5, v6);
}

void sub_6923C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_692B4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioPluginPropertyCustomHRTF", v2, v3, v4, v5, v6);
}

void sub_692E8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Wireless Splitter failed to aggregate two devices from BT", v2, v3, v4, v5, v6);
}

void sub_6931C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Wireless Splitter failed to aggregate two devices from CA", v2, v3, v4, v5, v6);
}

void sub_69350(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_693C4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BTUnifiedAudioDevice is NULL, can't add it", v2, v3, v4, v5, v6);
}

void sub_693F8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "HearingModeService Activate Failed", v2, v3, v4, v5, v6);
}

void sub_6942C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "QueryInterface: no place to store the returned interface", v2, v3, v4, v5, v6);
}

void sub_69460()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "QueryInterface: failed to create the CFUUIDRef", v2, v3, v4, v5, v6);
}

void sub_69494()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "QueryInterface: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_694C8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "AddRef: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_694FC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Release: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69530()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Initialize: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69564()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "CreateDevice: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69598()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "DestroyDevice: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_695CC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "AddDeviceClient: bad device ID", v2, v3, v4, v5, v6);
}

void sub_69600()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "AddDeviceClient: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69634()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "RemoveDeviceClient: bad device ID", v2, v3, v4, v5, v6);
}

void sub_69668()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "RemoveDeviceClient: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_6969C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "PerformDeviceConfigurationChange: bad object id", v2, v3, v4, v5, v6);
}

void sub_696D0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "PerformDeviceConfigurationChange: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69704()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "AbortDeviceConfigurationChange: bad object id", v2, v3, v4, v5, v6);
}

void sub_69738()
{
  sub_16A44();
  sub_13758(&dword_0, v0, v1, "HasProperty: bad object id %d", v2, v3, v4, v5, v6);
}

void sub_697A0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "HasProperty: no address", v2, v3, v4, v5, v6);
}

void sub_697D4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "HasProperty: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69808()
{
  sub_16A44();
  sub_13758(&dword_0, v0, v1, "GetPropertyData: AudioObjectId %d is not valid", v2, v3, v4, v5, v6);
}

void sub_69870()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "IsPropertySettable: no address", v2, v3, v4, v5, v6);
}

void sub_698A4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "IsPropertySettable: no place to put the return value", v2, v3, v4, v5, v6);
}

void sub_698D8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "IsPropertySettable: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_6990C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetPropertyDataSize: no address", v2, v3, v4, v5, v6);
}

void sub_69940()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetPropertyDataSize: no place to put the return value", v2, v3, v4, v5, v6);
}

void sub_69974()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetPropertyDataSize: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_699A8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetPropertyData: no address", v2, v3, v4, v5, v6);
}

void sub_699DC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetPropertyData: no place to put the return value size", v2, v3, v4, v5, v6);
}

void sub_69A10()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetPropertyData: no place to put the return value", v2, v3, v4, v5, v6);
}

void sub_69A44()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetPropertyData: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69A78()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "SetPropertyData: no address", v2, v3, v4, v5, v6);
}

void sub_69AAC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "SetPropertyData: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69AE0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "StartIO: bad object id", v2, v3, v4, v5, v6);
}

void sub_69B14()
{
  sub_16A44();
  sub_13758(&dword_0, v0, v1, "Object %d error with start", v2, v3, v4, v5, v6);
}

void sub_69B7C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "StartIO: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69BB0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "StopIO: bad object id", v2, v3, v4, v5, v6);
}

void sub_69BE4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "StopIO: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69C18()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetZeroTimeStamp: bad object id", v2, v3, v4, v5, v6);
}

void sub_69C4C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "GetZeroTimeStamp: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69C80()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "WillDoIOOperation: bad object id", v2, v3, v4, v5, v6);
}

void sub_69CB4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "WillDoIOOperation: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69CE8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BeginIOOperation: bad object id", v2, v3, v4, v5, v6);
}

void sub_69D1C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BeginIOOperation: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69D50()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "DoIOOperation: bad object id", v2, v3, v4, v5, v6);
}

void sub_69D84()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "DoIOOperation: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69DB8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "EndIOOperation: bad object id", v2, v3, v4, v5, v6);
}

void sub_69DEC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "EndIOOperation: bad driver reference", v2, v3, v4, v5, v6);
}

void sub_69E20()
{
  sub_48F24();
  _os_log_error_impl(&dword_0, v0, OS_LOG_TYPE_ERROR, "Unpacked %x %x %x %x", v1, 0x1Au);
}

void sub_69E9C()
{
  sub_48F24();
  _os_log_error_impl(&dword_0, v0, OS_LOG_TYPE_ERROR, "Packed %x %x %x %x", v1, 0x1Au);
}

void sub_69F18()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "BTUnifiedAudioDevice audioDevice Creation failed", v2, v3, v4, v5, v6);
}

void sub_69F4C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to initialize HFP device", v2, v3, v4, v5, v6);
}

void sub_69F80()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to initialize A2DP device", v2, v3, v4, v5, v6);
}

void sub_69FB4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "Failed to initialize LEA device", v2, v3, v4, v5, v6);
}

void sub_69FE8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6A060(uint8_t *buf, unsigned char *a2, os_log_t log)
{
  *std::string buf = 0;
  *a2 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Wireless Splitter device is not an aggregate", buf, 2u);
}

void sub_6A0A0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyBaseClass for the device", v2, v3, v4, v5, v6);
}

void sub_6A0D4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyClass for the device", v2, v3, v4, v5, v6);
}

void sub_6A108()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyOwner for the device", v2, v3, v4, v5, v6);
}

void sub_6A13C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyName for the device", v2, v3, v4, v5, v6);
}

void sub_6A170()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyClockDomain for the device", v2, v3, v4, v5, v6);
}

void sub_6A1A4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyManufacturer for the device", v2, v3, v4, v5, v6);
}

void sub_6A1D8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyDeviceUID for the device", v2, v3, v4, v5, v6);
}

void sub_6A20C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyTransportType for the device", v2, v3, v4, v5, v6);
}

void sub_6A240()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyNominalSampleRate for the device", v2, v3, v4, v5, v6);
}

void sub_6A274()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyZeroTimeStampPeriod for the device", v2, v3, v4, v5, v6);
}

void sub_6A2A8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertySafetyOffset for the device", v2, v3, v4, v5, v6);
}

void sub_6A2DC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyLatency for the device", v2, v3, v4, v5, v6);
}

void sub_6A310()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyDeviceCanBeDefault for the device", v2, v3, v4, v5, v6);
}

void sub_6A344()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyIsHidden for the device", v2, v3, v4, v5, v6);
}

void sub_6A378()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyPreferredChannelsForStereo for the device", v2, v3, v4, v5, v6);
}

void sub_6A3AC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: noactive profile the return value of kAudioDevicePropertyPreferredChannelLayout for the device", v2, v3, v4, v5, v6);
}

void sub_6A3E0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyPreferredChannelLayout for the device", v2, v3, v4, v5, v6);
}

void sub_6A414()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyDeviceType", v2, v3, v4, v5, v6);
}

void sub_6A448()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyInEarDetectEnabled", v2, v3, v4, v5, v6);
}

void sub_6A47C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyProductID", v2, v3, v4, v5, v6);
}

void sub_6A4B0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyDoAPSupported", v2, v3, v4, v5, v6);
}

void sub_6A4E4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyIsiAP", v2, v3, v4, v5, v6);
}

void sub_6A518()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyListenModeSupport", v2, v3, v4, v5, v6);
}

void sub_6A54C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioDevicePropertyListenMode", v2, v3, v4, v5, v6);
}

void sub_6A580()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyInEarStatusPrimary", v2, v3, v4, v5, v6);
}

void sub_6A5B4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyInEarStatus", v2, v3, v4, v5, v6);
}

void sub_6A5E8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyInEarStatusSecondary", v2, v3, v4, v5, v6);
}

void sub_6A61C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyPrimaryBudSide", v2, v3, v4, v5, v6);
}

void sub_6A650()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyFixedMicMode", v2, v3, v4, v5, v6);
}

void sub_6A684()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyAvailableAudioProfiles", v2, v3, v4, v5, v6);
}

void sub_6A6B8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyCurrentAudioProfile", v2, v3, v4, v5, v6);
}

void sub_6A6EC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialVolumeDb", v2, v3, v4, v5, v6);
}

void sub_6A720()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyDoAPUuid", v2, v3, v4, v5, v6);
}

void sub_6A754()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyDosimetrySensitivity", v2, v3, v4, v5, v6);
}

void sub_6A788()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyIsAppleAudioDevice", v2, v3, v4, v5, v6);
}

void sub_6A7BC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyDosimetryVolumeCurve", v2, v3, v4, v5, v6);
}

void sub_6A7F0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialAudioSupported", v2, v3, v4, v5, v6);
}

void sub_6A824()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialAudioEnabled", v2, v3, v4, v5, v6);
}

void sub_6A858()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialCCIsAvailable", v2, v3, v4, v5, v6);
}

void sub_6A88C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatializeStereoCCIsAvail", v2, v3, v4, v5, v6);
}

void sub_6A8C0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyIsAudioSessionSpatial", v2, v3, v4, v5, v6);
}

void sub_6A8F4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialCCState", v2, v3, v4, v5, v6);
}

void sub_6A928()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatializeStereoCCState", v2, v3, v4, v5, v6);
}

void sub_6A95C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyIsGenuineAirPods", v2, v3, v4, v5, v6);
}

void sub_6A990()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyAdaptiveVolumeEnabled", v2, v3, v4, v5, v6);
}

void sub_6A9C4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialNumChannels", v2, v3, v4, v5, v6);
}

void sub_6A9F8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialFormatId", v2, v3, v4, v5, v6);
}

void sub_6AA2C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialConfig", v2, v3, v4, v5, v6);
}

void sub_6AA60()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyExpanseStatus", v2, v3, v4, v5, v6);
}

void sub_6AA94()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyCallScreeningStatus", v2, v3, v4, v5, v6);
}

void sub_6AAC8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyCustomHRTFAllowed", v2, v3, v4, v5, v6);
}

void sub_6AAFC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialMode", v2, v3, v4, v5, v6);
}

void sub_6AB30()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialAudioUserEnableFeature", v2, v3, v4, v5, v6);
}

void sub_6AB64()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyStereoHFPSupported", v2, v3, v4, v5, v6);
}

void sub_6AB98()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyStereoHFPEnabled", v2, v3, v4, v5, v6);
}

void sub_6ABCC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyStereoHFPAllowed", v2, v3, v4, v5, v6);
}

void sub_6AC00()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySoftwareVolumeSupported", v2, v3, v4, v5, v6);
}

void sub_6AC34()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySoftwareVolumeEnabled", v2, v3, v4, v5, v6);
}

void sub_6AC68()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDeviceWirelessSplitterSupported", v2, v3, v4, v5, v6);
}

void sub_6AC9C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDeviceWirelessSplitterGuest", v2, v3, v4, v5, v6);
}

void sub_6ACD0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDeviceWirelessSplitterGuestNotInContacts", v2, v3, v4, v5, v6);
}

void sub_6AD04()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of Wireless Splitter Main Volume", v2, v3, v4, v5, v6);
}

void sub_6AD38()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyOwnsAudioConnection", v2, v3, v4, v5, v6);
}

void sub_6AD6C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyLiveListenSupported", v2, v3, v4, v5, v6);
}

void sub_6ADA0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyAllowScoForTBT", v2, v3, v4, v5, v6);
}

void sub_6ADD4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyShareplayScreenSharing", v2, v3, v4, v5, v6);
}

void sub_6AE08()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySupportedFeatures", v2, v3, v4, v5, v6);
}

void sub_6AE3C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyBudSideLoudnessEQEnabled", v2, v3, v4, v5, v6);
}

void sub_6AE70(int *a1, uint64_t a2, os_log_t log)
{
  int v3 = *a1;
  int v4 = *(_DWORD *)(a2 + 44);
  v5[0] = 67109376;
  v5[1] = v3;
  __int16 v6 = 1024;
  int v7 = v4;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Failed in dispatched config change for AudioObjectProperty %u on object %d", (uint8_t *)v5, 0xEu);
}

void sub_6AF00()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of kAudioDevicePropertyNominalSampleRate", v2, v3, v4, v5, v6);
}

void sub_6AF34()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: wrong size for the data for kAudioDevicePropertyNominalSampleRate", v2, v3, v4, v5, v6);
}

void sub_6AF68()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyOwnsAudioConnection", v2, v3, v4, v5, v6);
}

void sub_6AF9C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "No one should ever be setting kBluetoothAudioDevicePropertyOwnsAudioConnection to false", v2, v3, v4, v5, v6);
}

void sub_6AFD0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDeviceWirelessSplitterAggregation", v2, v3, v4, v5, v6);
}

void sub_6B004()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of kBluetoothAudioDeviceWirelessSplitterAggregation", v2, v3, v4, v5, v6);
}

void sub_6B038()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of Wireless Splitter Main volume", v2, v3, v4, v5, v6);
}

void sub_6B06C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyCurrentAudioProfile", v2, v3, v4, v5, v6);
}

void sub_6B0A0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySoftwareVolumeEnabled", v2, v3, v4, v5, v6);
}

void sub_6B0D4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of kBluetoothAudioDevicePropertySoftwareVolumeEnabled", v2, v3, v4, v5, v6);
}

void sub_6B108()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of kBluetoothAudioDevicePropertySpatialAudioEnabled", v2, v3, v4, v5, v6);
}

void sub_6B13C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyCallScreeningStatus", v2, v3, v4, v5, v6);
}

void sub_6B170()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of kBluetoothAudioDevicePropertyCallScreeningStatus", v2, v3, v4, v5, v6);
}

void sub_6B1A4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialAudioStreamInfo", v2, v3, v4, v5, v6);
}

void sub_6B1D8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatialCCState", v2, v3, v4, v5, v6);
}

void sub_6B20C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertySpatializeStereoCCState", v2, v3, v4, v5, v6);
}

void sub_6B240()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: not enough space for the return value of kBluetoothAudioDevicePropertyAllowScoForTBT", v2, v3, v4, v5, v6);
}

void sub_6B274()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no HFP profile supported device while processing of kBluetoothAudioDevicePropertyAllowScoForTBT", v2, v3, v4, v5, v6);
}

void sub_6B2A8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of property", v2, v3, v4, v5, v6);
}

void sub_6B2DC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyBaseClass for the stream", v2, v3, v4, v5, v6);
}

void sub_6B310()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyClass for the stream", v2, v3, v4, v5, v6);
}

void sub_6B344()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyOwner for the stream", v2, v3, v4, v5, v6);
}

void sub_6B378()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioStreamPropertyIsActive for the stream", v2, v3, v4, v5, v6);
}

void sub_6B3AC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioStreamPropertyDirection for the stream", v2, v3, v4, v5, v6);
}

void sub_6B3E0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioStreamPropertyTerminalType for the stream", v2, v3, v4, v5, v6);
}

void sub_6B414()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioStreamPropertyStartingChannel for the stream", v2, v3, v4, v5, v6);
}

void sub_6B448()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioStreamPropertyVirtualFormat for the stream", v2, v3, v4, v5, v6);
}

void sub_6B47C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: no active profile while processing of kAudioStreamPropertyPhysicalFormat", v2, v3, v4, v5, v6);
}

void sub_6B4B0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioStreamPropertyAvailablePhysicalFormats for the stream", v2, v3, v4, v5, v6);
}

void sub_6B4E4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of kAudioStreamPropertyPhysicalFormat", v2, v3, v4, v5, v6);
}

void sub_6B518()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: unsupported format ID for kAudioStreamPropertyPhysicalFormat", v2, v3, v4, v5, v6);
}

void sub_6B54C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: wrong size for the data for kAudioStreamPropertyPhysicalFormat", v2, v3, v4, v5, v6);
}

void sub_6B580()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyBaseClass for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B5B4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyClass for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B5E8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioObjectPropertyOwner for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B61C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioControlPropertyScope for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B650()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioControlPropertyElement for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B684()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioLevelControlPropertyScalarValue for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B6B8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: no active profile while processing of kAudioLevelControlPropertyScalarValue", v2, v3, v4, v5, v6);
}

void sub_6B6EC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: invalid volume control for kAudioLevelControlPropertyScalarValue", v2, v3, v4, v5, v6);
}

void sub_6B720()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioLevelControlPropertyDecibelValue for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B754()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: no active profile while processing of kAudioLevelControlPropertyDecibelValue", v2, v3, v4, v5, v6);
}

void sub_6B788()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: invalid volume control for kAudioLevelControlPropertyDecibelValue", v2, v3, v4, v5, v6);
}

void sub_6B7BC()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioLevelControlPropertyDecibelRange for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B7F0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: no active profile while processing of kAudioLevelControlPropertyDecibelRange", v2, v3, v4, v5, v6);
}

void sub_6B824()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: invalid volume control for kAudioLevelControlPropertyDecibelRange", v2, v3, v4, v5, v6);
}

void sub_6B858()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioLevelControlPropertyConvertScalarToDecibels for the volume control", v2, v3, v4, v5, v6);
}

void sub_6B88C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "getPropertyData: not enough space for the return value of kAudioBooleanControlPropertyValue for the device", v2, v3, v4, v5, v6);
}

void sub_6B8C0()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of kAudioLevelControlPropertyScalarValue", v2, v3, v4, v5, v6);
}

void sub_6B8F4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: wrong size for the data for kAudioLevelControlPropertyScalarValue", v2, v3, v4, v5, v6);
}

void sub_6B928()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: no active profile while processing of kAudioLevelControlPropertyDecibelValue", v2, v3, v4, v5, v6);
}

void sub_6B95C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "setPropertyData: wrong size for the data for kAudioLevelControlPropertyDecibleValue", v2, v3, v4, v5, v6);
}

void sub_6B990()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "HFPStereo output performFormatChange timedout wait for IO stop", v2, v3, v4, v5, v6);
}

void sub_6B9C4()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "StartIO received when no profile is active", v2, v3, v4, v5, v6);
}

void sub_6B9F8()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "StopIO received when no profile is active", v2, v3, v4, v5, v6);
}

void sub_6BA2C(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "*theNumberItemsToFetch <= maxItemCount";
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_6BAB0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
}

void sub_6BB28()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "No active Bluetooth profile when requesting volume, returning 0", v2, v3, v4, v5, v6);
}

void sub_6BB5C()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "No active Bluetooth profile when requesting volume, returning kA2DPAudioMinVolumeDB", v2, v3, v4, v5, v6);
}

void sub_6BB90()
{
  sub_BBE0();
  _os_log_fault_impl(&dword_0, v0, OS_LOG_TYPE_FAULT, "Error publish device before plugin ready", v1, 2u);
}

void sub_6BBD0(uint64_t a1, uint64_t a2, os_log_t log)
{
  uint64_t v3 = *(void *)(a1 + 9080);
  if (*(unsigned char *)(*(void *)(a1 + 9248) + 228)) {
    CFStringRef v4 = @"Supported";
  }
  else {
    CFStringRef v4 = @"Not-Supported";
  }
  int v5 = 138543874;
  uint64_t v6 = v3;
  __int16 v7 = 2112;
  uint64_t v8 = a2;
  __int16 v9 = 2112;
  CFStringRef v10 = v4;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Dropping Volume update becuase there is one already in flight %{public}@: manualVolumeUpdate: %@ Adaptive Volume: %@", (uint8_t *)&v5, 0x20u);
}

void sub_6BC84(uint64_t a1, NSObject *a2)
{
  uint64_t v2 = *(void *)(a1 + 9080);
  int v3 = 138543362;
  uint64_t v4 = v2;
  _os_log_error_impl(&dword_0, a2, OS_LOG_TYPE_ERROR, "[%{public}@ ] transport update: timed out", (uint8_t *)&v3, 0xCu);
}

void sub_6BD00()
{
  sub_BBE0();
  sub_BBA8(&dword_0, v0, v1, "HFPstereo SetDefaultHfpStereoFormat skipped", v2, v3, v4, v5, v6);
}

void sub_6BD34(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "LC3Encoder destructor try releasing NULL converter", v1, 2u);
}

void sub_6BD78(os_log_t log)
{
  *(_WORD *)uint64_t v1 = 0;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "Codec type and frame length values did not make sense!", v1, 2u);
}

void sub_6BDBC(int *a1, NSObject *a2)
{
  int v2 = *a1;
  v3[0] = 67109120;
  v3[1] = v2;
  _os_log_debug_impl(&dword_0, a2, OS_LOG_TYPE_DEBUG, "mOutputFormat.mBytesPerPacket %u", (uint8_t *)v3, 8u);
}

void sub_6BE38(int a1, int a2, os_log_t log)
{
  v3[0] = 67109376;
  v3[1] = a1;
  __int16 v4 = 1024;
  int v5 = a2;
  _os_log_error_impl(&dword_0, log, OS_LOG_TYPE_ERROR, "LC3Encoder, skip processing, ioOutputDataPackets(%u) is bigger than numMaxBuffers(%u)", (uint8_t *)v3, 0xEu);
}

void sub_6BEC0()
{
  sub_16A44();
  sub_5CF14(&dword_0, v0, v1, "error = %d", v2, v3, v4, v5, v6);
}

void sub_6BF28(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "!fIsLocked";
  _os_log_fault_impl(&dword_0, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

void sub_6BFAC(os_log_t log)
{
  int v1 = 136446210;
  uint64_t v2 = "fIsLocked";
  _os_log_fault_impl(&dword_0, log, OS_LOG_TYPE_FAULT, "Assertion failed: %{public}s", (uint8_t *)&v1, 0xCu);
}

uint64_t AnalyticsSendEventLazy()
{
  return _AnalyticsSendEventLazy();
}

AudioComponent AudioComponentRegister(const AudioComponentDescription *inDesc, CFStringRef inName, UInt32 inVersion, AudioComponentFactoryFunction inFactory)
{
  return _AudioComponentRegister(inDesc, inName, inVersion, inFactory);
}

OSStatus AudioConverterDispose(AudioConverterRef inAudioConverter)
{
  return _AudioConverterDispose(inAudioConverter);
}

OSStatus AudioConverterFillComplexBuffer(AudioConverterRef inAudioConverter, AudioConverterComplexInputDataProc inInputDataProc, void *inInputDataProcUserData, UInt32 *ioOutputDataPacketSize, AudioBufferList *outOutputData, AudioStreamPacketDescription *outPacketDescription)
{
  return _AudioConverterFillComplexBuffer(inAudioConverter, inInputDataProc, inInputDataProcUserData, ioOutputDataPacketSize, outOutputData, outPacketDescription);
}

OSStatus AudioConverterGetProperty(AudioConverterRef inAudioConverter, AudioConverterPropertyID inPropertyID, UInt32 *ioPropertyDataSize, void *outPropertyData)
{
  return _AudioConverterGetProperty(inAudioConverter, inPropertyID, ioPropertyDataSize, outPropertyData);
}

OSStatus AudioConverterGetPropertyInfo(AudioConverterRef inAudioConverter, AudioConverterPropertyID inPropertyID, UInt32 *outSize, Boolean *outWritable)
{
  return _AudioConverterGetPropertyInfo(inAudioConverter, inPropertyID, outSize, outWritable);
}

OSStatus AudioConverterNew(const AudioStreamBasicDescription *inSourceFormat, const AudioStreamBasicDescription *inDestinationFormat, AudioConverterRef *outAudioConverter)
{
  return _AudioConverterNew(inSourceFormat, inDestinationFormat, outAudioConverter);
}

OSStatus AudioConverterReset(AudioConverterRef inAudioConverter)
{
  return _AudioConverterReset(inAudioConverter);
}

OSStatus AudioConverterSetProperty(AudioConverterRef inAudioConverter, AudioConverterPropertyID inPropertyID, UInt32 inPropertyDataSize, const void *inPropertyData)
{
  return _AudioConverterSetProperty(inAudioConverter, inPropertyID, inPropertyDataSize, inPropertyData);
}

OSStatus AudioFileClose(AudioFileID inAudioFile)
{
  return _AudioFileClose(inAudioFile);
}

OSStatus AudioFileCreateWithURL(CFURLRef inFileRef, AudioFileTypeID inFileType, const AudioStreamBasicDescription *inFormat, AudioFileFlags inFlags, AudioFileID *outAudioFile)
{
  return _AudioFileCreateWithURL(inFileRef, inFileType, inFormat, inFlags, outAudioFile);
}

OSStatus AudioFileGetProperty(AudioFileID inAudioFile, AudioFilePropertyID inPropertyID, UInt32 *ioDataSize, void *outPropertyData)
{
  return _AudioFileGetProperty(inAudioFile, inPropertyID, ioDataSize, outPropertyData);
}

OSStatus AudioFileGetPropertyInfo(AudioFileID inAudioFile, AudioFilePropertyID inPropertyID, UInt32 *outDataSize, UInt32 *isWritable)
{
  return _AudioFileGetPropertyInfo(inAudioFile, inPropertyID, outDataSize, isWritable);
}

OSStatus AudioFileSetProperty(AudioFileID inAudioFile, AudioFilePropertyID inPropertyID, UInt32 inDataSize, const void *inPropertyData)
{
  return _AudioFileSetProperty(inAudioFile, inPropertyID, inDataSize, inPropertyData);
}

OSStatus AudioFileWritePackets(AudioFileID inAudioFile, Boolean inUseCache, UInt32 inNumBytes, const AudioStreamPacketDescription *inPacketDescriptions, SInt64 inStartingPacket, UInt32 *ioNumPackets, const void *inBuffer)
{
  return _AudioFileWritePackets(inAudioFile, inUseCache, inNumBytes, inPacketDescriptions, inStartingPacket, ioNumPackets, inBuffer);
}

OSStatus AudioFormatGetProperty(AudioFormatPropertyID inPropertyID, UInt32 inSpecifierSize, const void *inSpecifier, UInt32 *ioPropertyDataSize, void *outPropertyData)
{
  return _AudioFormatGetProperty(inPropertyID, inSpecifierSize, inSpecifier, ioPropertyDataSize, outPropertyData);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreate(allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return _CFArrayCreateCopy(allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayGetFirstIndexOfValue(theArray, range, value);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return _CFDataCreateCopy(allocator, theData);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryContainsKey(theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateCopy(allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateMutableCopy(allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return _CFDictionaryGetCount(theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFIndex CFGetRetainCount(CFTypeRef cf)
{
  return _CFGetRetainCount(cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return _CFNotificationCenterGetDarwinNotifyCenter();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return _CFStringCreateArrayBySeparatingStrings(alloc, theString, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return _CFStringCreateCopy(alloc, theString);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

CFRange CFStringFind(CFStringRef theString, CFStringRef stringToFind, CFStringCompareFlags compareOptions)
{
  CFRange v5 = _CFStringFind(theString, stringToFind, compareOptions);
  CFIndex length = v5.length;
  locatiounsigned int n = v5.location;
  result.CFIndex length = length;
  result.locatiounsigned int n = location;
  return result;
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return _CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return _CFUUIDCreateFromUUIDBytes(alloc, bytes);
}

CFUUIDRef CFUUIDGetConstantUUIDWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return _CFUUIDGetConstantUUIDWithBytes(alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15);
}

uint64_t CMSessionGetNotificationCenter()
{
  return _CMSessionGetNotificationCenter();
}

uint64_t CUXPCCreateCFObjectFromXPCObject()
{
  return _CUXPCCreateCFObjectFromXPCObject();
}

uint64_t DMIsMigrationNeeded()
{
  return _DMIsMigrationNeeded();
}

uint64_t FigNotificationCenterAddWeakListener()
{
  return _FigNotificationCenterAddWeakListener();
}

uint64_t FigNotificationCenterRemoveWeakListener()
{
  return _FigNotificationCenterRemoveWeakListener();
}

uint64_t MGGetStringAnswer()
{
  return _MGGetStringAnswer();
}

uint64_t TranslateValue()
{
  return _TranslateValue();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return __CFXPCCreateCFObjectFromXPCObject();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return __CFXPCCreateXPCObjectFromCFObject();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t IR::IRData::createNoisySoundProfilePack(IR::IRData *this, const __CFData *a2)
{
  return IR::IRData::createNoisySoundProfilePack(this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return std::logic_error::logic_error(this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return std::bad_array_new_length::bad_array_new_length(this);
}

std::string *__cdecl std::string::assign(std::string *this, const std::string::value_type *__s)
{
  return std::string::assign(this, __s);
}

void std::terminate(void)
{
}

void operator delete[]()
{
  while (1)
    ;
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void operator delete()
{
  while (1)
    ;
}

void operator new[]()
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

void operator new()
{
  while (1)
    ;
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return ___cxa_allocate_exception(thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return ___cxa_atexit(lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return ___cxa_begin_catch(a1);
}

void __cxa_free_exception(void *a1)
{
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
}

float __exp10f(float a1)
{
  return ___exp10f(a1);
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return ___maskrune(a1, a2);
}

__double2 __sincos_stret(double a1)
{
  __double2 v3 = ___sincos_stret(a1);
  double cosval = v3.__cosval;
  double sinval = v3.__sinval;
  result.__double cosval = cosval;
  result.__double sinval = sinval;
  return result;
}

uint64_t _os_feature_enabled_impl()
{
  return __os_feature_enabled_impl();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

long double atan(long double __x)
{
  return _atan(__x);
}

void bzero(void *a1, size_t a2)
{
}

int close(int a1)
{
  return _close(a1);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_block_cancel(dispatch_block_t block)
{
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  return _dispatch_block_create(flags, block);
}

intptr_t dispatch_block_testcancel(dispatch_block_t block)
{
  return _dispatch_block_testcancel(block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

intptr_t dispatch_source_testcancel(dispatch_source_t source)
{
  return _dispatch_source_testcancel(source);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return _dlopen(__path, __mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

void free(void *a1)
{
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

pid_t getpid(void)
{
  return _getpid();
}

int kevent(int kq, const kevent *changelist, int nchanges, kevent *eventlist, int nevents, const timespec *timeout)
{
  return _kevent(kq, changelist, nchanges, eventlist, nevents, timeout);
}

int kqueue(void)
{
  return _kqueue();
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return _localtime_r(a1, a2);
}

float log10f(float a1)
{
  return _log10f(a1);
}

float logf(float a1)
{
  return _logf(a1);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

mach_port_t mach_thread_self(void)
{
  return _mach_thread_self();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

int mkdir(const char *a1, mode_t a2)
{
  return _mkdir(a1, a2);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_enumerationMutation(id obj)
{
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return _objc_initWeak(location, val);
}

id objc_loadWeak(id *location)
{
  return _objc_loadWeak(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return _objc_msgSendSuper2(a1, a2);
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

void objc_release(id a1)
{
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return _a1;
}

id objc_retainBlock(id a1)
{
  return _objc_retainBlock(a1);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

uint64_t os_channel_advance_slot()
{
  return _os_channel_advance_slot();
}

uint64_t os_channel_attr_create()
{
  return _os_channel_attr_create();
}

uint64_t os_channel_attr_destroy()
{
  return _os_channel_attr_destroy();
}

uint64_t os_channel_attr_set()
{
  return _os_channel_attr_set();
}

uint64_t os_channel_attr_set_key()
{
  return _os_channel_attr_set_key();
}

uint64_t os_channel_create_extended()
{
  return _os_channel_create_extended();
}

uint64_t os_channel_destroy()
{
  return _os_channel_destroy();
}

uint64_t os_channel_get_fd()
{
  return _os_channel_get_fd();
}

uint64_t os_channel_get_next_slot()
{
  return _os_channel_get_next_slot();
}

uint64_t os_channel_ring_id()
{
  return _os_channel_ring_id();
}

uint64_t os_channel_rx_ring()
{
  return _os_channel_rx_ring();
}

uint64_t os_channel_set_slot_properties()
{
  return _os_channel_set_slot_properties();
}

uint64_t os_channel_sync()
{
  return _os_channel_sync();
}

uint64_t os_channel_tx_ring()
{
  return _os_channel_tx_ring();
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

uint64_t os_nexus_attr_create()
{
  return _os_nexus_attr_create();
}

uint64_t os_nexus_attr_destroy()
{
  return _os_nexus_attr_destroy();
}

uint64_t os_nexus_attr_set()
{
  return _os_nexus_attr_set();
}

uint64_t os_nexus_controller_alloc_provider_instance()
{
  return _os_nexus_controller_alloc_provider_instance();
}

uint64_t os_nexus_controller_bind_provider_instance()
{
  return _os_nexus_controller_bind_provider_instance();
}

uint64_t os_nexus_controller_create()
{
  return _os_nexus_controller_create();
}

uint64_t os_nexus_controller_deregister_provider()
{
  return _os_nexus_controller_deregister_provider();
}

uint64_t os_nexus_controller_destroy()
{
  return _os_nexus_controller_destroy();
}

uint64_t os_nexus_controller_free_provider_instance()
{
  return _os_nexus_controller_free_provider_instance();
}

uint64_t os_nexus_controller_register_provider()
{
  return _os_nexus_controller_register_provider();
}

uint64_t os_variant_has_internal_content()
{
  return _os_variant_has_internal_content();
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return _pthread_attr_init(a1);
}

int pthread_attr_setdetachstate(pthread_attr_t *a1, int a2)
{
  return _pthread_attr_setdetachstate(a1, a2);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return _pthread_cond_broadcast(a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return _pthread_cond_destroy(a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return _pthread_cond_init(a1, a2);
}

int pthread_cond_signal(pthread_cond_t *a1)
{
  return _pthread_cond_signal(a1);
}

int pthread_cond_timedwait_relative_np(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return _pthread_cond_timedwait_relative_np(a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return _pthread_cond_wait(a1, a2);
}

int pthread_create(pthread_t *a1, const pthread_attr_t *a2, void *(__cdecl *a3)(void *), void *a4)
{
  return _pthread_create(a1, a2, a3, a4);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_destroy(a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_init(a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return _pthread_mutexattr_settype(a1, a2);
}

int pthread_setname_np(const char *a1)
{
  return _pthread_setname_np(a1);
}

long double sin(long double __x)
{
  return _sin(__x);
}

int sprintf(char *a1, const char *a2, ...)
{
  return _sprintf(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  return _strlcat(__dst, __source, __size);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

kern_return_t thread_policy_set(thread_act_t thread, thread_policy_flavor_t flavor, thread_policy_t policy_info, mach_msg_type_number_t policy_infoCnt)
{
  return _thread_policy_set(thread, flavor, policy_info, policy_infoCnt);
}

time_t time(time_t *a1)
{
  return _time(a1);
}

void vDSP_ctoz(const DSPComplex *__C, vDSP_Stride __IC, const DSPSplitComplex *__Z, vDSP_Stride __IZ, vDSP_Length __N)
{
}

void vDSP_deq22(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_maxmgv(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_maxvi(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length *__I, vDSP_Length __N)
{
}

void vDSP_mmov(const float *__A, float *__C, vDSP_Length __M, vDSP_Length __N, vDSP_Length __TA, vDSP_Length __TC)
{
}

void vDSP_svesq(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Length __N)
{
}

void vDSP_vabs(const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vdbcon(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N, unsigned int __F)
{
}

void vDSP_vma(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, const float *__C, vDSP_Stride __IC, float *__D, vDSP_Stride __ID, vDSP_Length __N)
{
}

void vDSP_vmul(const float *__A, vDSP_Stride __IA, const float *__B, vDSP_Stride __IB, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vrampmul(const float *__I, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O, vDSP_Stride __OS, vDSP_Length __N)
{
}

void vDSP_vrampmul2(const float *__I0, const float *__I1, vDSP_Stride __IS, float *__Start, const float *__Step, float *__O0, float *__O1, vDSP_Stride __OS, vDSP_Length __N)
{
}

void vDSP_vrampmul2_s1_15(const __int16 *__I0, const __int16 *__I1, vDSP_Stride __IS, __int16 *__Start, const __int16 *__Step, __int16 *__O0, __int16 *__O1, vDSP_Stride __OS, vDSP_Length __N)
{
}

void vDSP_vrampmul_s1_15(const __int16 *__I, vDSP_Stride __IS, __int16 *__Start, const __int16 *__Step, __int16 *__O, vDSP_Stride __OS, vDSP_Length __N)
{
}

void vDSP_vsadd(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsmul(const float *__A, vDSP_Stride __IA, const float *__B, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_vsub(const float *__B, vDSP_Stride __IB, const float *__A, vDSP_Stride __IA, float *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_ztoc(const DSPSplitComplex *__Z, vDSP_Stride __IZ, DSPComplex *__C, vDSP_Stride __IC, vDSP_Length __N)
{
}

void vDSP_zvmul(const DSPSplitComplex *__A, vDSP_Stride __IA, const DSPSplitComplex *__B, vDSP_Stride __IB, const DSPSplitComplex *__C, vDSP_Stride __IC, vDSP_Length __N, int __Conjugate)
{
}

__int32 *__cdecl wmemchr(__int32 *__s, __int32 __c, size_t __n)
{
  return _wmemchr(__s, __c, __n);
}

xpc_object_t xpc_BOOL_create(BOOL value)
{
  return _xpc_BOOL_create(value);
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return _xpc_BOOL_get_value(xBOOL);
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return _xpc_copy_description(object);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return _xpc_dictionary_apply(xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_object_t xpc_double_create(double value)
{
  return _xpc_double_create(value);
}

double xpc_double_get_value(xpc_object_t xdouble)
{
  return _xpc_double_get_value(xdouble);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

xpc_object_t xpc_int64_create(int64_t value)
{
  return _xpc_int64_create(value);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return _xpc_int64_get_value(xint);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_shmem_create(void *region, size_t length)
{
  return _xpc_shmem_create(region, length);
}

xpc_object_t xpc_string_create(const char *string)
{
  return _xpc_string_create(string);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return _xpc_string_get_string_ptr(xstring);
}

const uint8_t *__cdecl xpc_uuid_get_bytes(xpc_object_t xuuid)
{
  return _xpc_uuid_get_bytes(xuuid);
}

id objc_msgSend_HighestQualityFormat(void *a1, const char *a2, ...)
{
  return [a1 HighestQualityFormat];
}

id objc_msgSend_ReleaseSpatialAudioQueueInfo(void *a1, const char *a2, ...)
{
  return [a1 ReleaseSpatialAudioQueueInfo];
}

id objc_msgSend_SpatialAudioClientProcExitHandler(void *a1, const char *a2, ...)
{
  return [a1 SpatialAudioClientProcExitHandler];
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return [a1 UUID];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return [a1 allKeys];
}

id objc_msgSend_audioDevice(void *a1, const char *a2, ...)
{
  return [a1 audioDevice];
}

id objc_msgSend_audioQueueRef(void *a1, const char *a2, ...)
{
  return [a1 audioQueueRef];
}

id objc_msgSend_bluetoothAddress(void *a1, const char *a2, ...)
{
  return [a1 bluetoothAddress];
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return [a1 BOOLValue];
}

id objc_msgSend_cancelExitHandler(void *a1, const char *a2, ...)
{
  return [a1 cancelExitHandler];
}

id objc_msgSend_centralManager(void *a1, const char *a2, ...)
{
  return [a1 centralManager];
}

id objc_msgSend_characteristics(void *a1, const char *a2, ...)
{
  return [a1 characteristics];
}

id objc_msgSend_compatibleAndConnected(void *a1, const char *a2, ...)
{
  return [a1 compatibleAndConnected];
}

id objc_msgSend_compatibleAndNearby(void *a1, const char *a2, ...)
{
  return [a1 compatibleAndNearby];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_defaultCStringEncoding(void *a1, const char *a2, ...)
{
  return [a1 defaultCStringEncoding];
}

id objc_msgSend_dercrementRefCount(void *a1, const char *a2, ...)
{
  return [a1 dercrementRefCount];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_devices(void *a1, const char *a2, ...)
{
  return [a1 devices];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return [a1 firstObject];
}

id objc_msgSend_floatValue(void *a1, const char *a2, ...)
{
  return [a1 floatValue];
}

id objc_msgSend_hearingAssistCapability(void *a1, const char *a2, ...)
{
  return [a1 hearingAssistCapability];
}

id objc_msgSend_hearingAssistEnabled(void *a1, const char *a2, ...)
{
  return [a1 hearingAssistEnabled];
}

id objc_msgSend_hearingAssistEnrolled(void *a1, const char *a2, ...)
{
  return [a1 hearingAssistEnrolled];
}

id objc_msgSend_hostProcess(void *a1, const char *a2, ...)
{
  return [a1 hostProcess];
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return [a1 identifier];
}

id objc_msgSend_incomingResponseIdentifier(void *a1, const char *a2, ...)
{
  return [a1 incomingResponseIdentifier];
}

id objc_msgSend_incrementRefCount(void *a1, const char *a2, ...)
{
  return [a1 incrementRefCount];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return [a1 invalidate];
}

id objc_msgSend_isActiveAudioQueue(void *a1, const char *a2, ...)
{
  return [a1 isActiveAudioQueue];
}

id objc_msgSend_isBluetoothRoute(void *a1, const char *a2, ...)
{
  return [a1 isBluetoothRoute];
}

id objc_msgSend_isConnected(void *a1, const char *a2, ...)
{
  return [a1 isConnected];
}

id objc_msgSend_isInput(void *a1, const char *a2, ...)
{
  return [a1 isInput];
}

id objc_msgSend_isNearby(void *a1, const char *a2, ...)
{
  return [a1 isNearby];
}

id objc_msgSend_isOutput(void *a1, const char *a2, ...)
{
  return [a1 isOutput];
}

id objc_msgSend_isRouteAvailable(void *a1, const char *a2, ...)
{
  return [a1 isRouteAvailable];
}

id objc_msgSend_lastUsedIdentifierKey(void *a1, const char *a2, ...)
{
  return [a1 lastUsedIdentifierKey];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_manualVolumeUpdatesQueue(void *a1, const char *a2, ...)
{
  return [a1 manualVolumeUpdatesQueue];
}

id objc_msgSend_name(void *a1, const char *a2, ...)
{
  return [a1 name];
}

id objc_msgSend_nowPlayingBundleID(void *a1, const char *a2, ...)
{
  return [a1 nowPlayingBundleID];
}

id objc_msgSend_numActiveQueue(void *a1, const char *a2, ...)
{
  return [a1 numActiveQueue];
}

id objc_msgSend_outgoingResponseIdentifier(void *a1, const char *a2, ...)
{
  return [a1 outgoingResponseIdentifier];
}

id objc_msgSend_peripheral(void *a1, const char *a2, ...)
{
  return [a1 peripheral];
}

id objc_msgSend_pmeMediaEnabled(void *a1, const char *a2, ...)
{
  return [a1 pmeMediaEnabled];
}

id objc_msgSend_pmeVoiceEnabled(void *a1, const char *a2, ...)
{
  return [a1 pmeVoiceEnabled];
}

id objc_msgSend_processInfo(void *a1, const char *a2, ...)
{
  return [a1 processInfo];
}

id objc_msgSend_processManualVolumeUpdates(void *a1, const char *a2, ...)
{
  return [a1 processManualVolumeUpdates];
}

id objc_msgSend_processName(void *a1, const char *a2, ...)
{
  return [a1 processName];
}

id objc_msgSend_productBuildVersion(void *a1, const char *a2, ...)
{
  return [a1 productBuildVersion];
}

id objc_msgSend_productName(void *a1, const char *a2, ...)
{
  return [a1 productName];
}

id objc_msgSend_refreshNowPlayingAppBundleID(void *a1, const char *a2, ...)
{
  return [a1 refreshNowPlayingAppBundleID];
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return [a1 removeAllObjects];
}

id objc_msgSend_resetNonUIRefCount(void *a1, const char *a2, ...)
{
  return [a1 resetNonUIRefCount];
}

id objc_msgSend_retainCount(void *a1, const char *a2, ...)
{
  return [a1 retainCount];
}

id objc_msgSend_service(void *a1, const char *a2, ...)
{
  return [a1 service];
}

id objc_msgSend_serviceMinCompatibilityVersion(void *a1, const char *a2, ...)
{
  return [a1 serviceMinCompatibilityVersion];
}

id objc_msgSend_services(void *a1, const char *a2, ...)
{
  return [a1 services];
}

id objc_msgSend_setNonUIRefCount(void *a1, const char *a2, ...)
{
  return [a1 setNonUIRefCount];
}

id objc_msgSend_sharedInstance(void *a1, const char *a2, ...)
{
  return [a1 sharedInstance];
}

id objc_msgSend_spatialAudioHeadTrackingUserSelection(void *a1, const char *a2, ...)
{
  return [a1 spatialAudioHeadTrackingUserSelection];
}

id objc_msgSend_spatialAudioUserSelection(void *a1, const char *a2, ...)
{
  return [a1 spatialAudioUserSelection];
}

id objc_msgSend_spatialNonUIRefCount(void *a1, const char *a2, ...)
{
  return [a1 spatialNonUIRefCount];
}

id objc_msgSend_spatialRefCount(void *a1, const char *a2, ...)
{
  return [a1 spatialRefCount];
}

id objc_msgSend_startManualVolumeUpdateTimer(void *a1, const char *a2, ...)
{
  return [a1 startManualVolumeUpdateTimer];
}

id objc_msgSend_state(void *a1, const char *a2, ...)
{
  return [a1 state];
}

id objc_msgSend_streamInfo(void *a1, const char *a2, ...)
{
  return [a1 streamInfo];
}

id objc_msgSend_systemController(void *a1, const char *a2, ...)
{
  return [a1 systemController];
}

id objc_msgSend_unregisterRouteChangeListener(void *a1, const char *a2, ...)
{
  return [a1 unregisterRouteChangeListener];
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntValue];
}

id objc_msgSend_updateHighestQualityFormat(void *a1, const char *a2, ...)
{
  return [a1 updateHighestQualityFormat];
}

id objc_msgSend_uuid(void *a1, const char *a2, ...)
{
  return [a1 uuid];
}

id objc_msgSend_value(void *a1, const char *a2, ...)
{
  return [a1 value];
}

id objc_msgSend_valueForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "valueForKey:");
}