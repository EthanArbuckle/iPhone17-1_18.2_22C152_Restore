unint64_t sub_100001040(uint32x4_t *a1, unint64_t a2, unint64_t a3, int8x16_t a4, int8x16_t a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t i;
  uint64_t v8;
  int64x2_t v9;
  int64x2_t v10;
  uint32x4_t v11;
  uint32x4_t v12;
  uint32x4_t v13;
  uint32x4_t v14;
  int64x2_t v15;
  uint64x2_t v16;
  uint64x2_t v17;
  int64x2_t v18;
  uint64x2_t v19;
  BOOL v20;
  uint64x2_t v21;
  uint32x4_t v22;
  uint64x2_t v23;
  int64x2_t v24;
  uint64x2_t v25;
  uint64x2_t v26;
  uint32x4_t v27;
  uint32x4_t v28;
  int64x2_t v29;
  uint32x4_t v30;
  int64x2_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unsigned __int32 v35;
  unint64_t v36;
  unint64_t v37;

  v5 = a3;
  v6 = HIDWORD(a3);
  if ((a2 & 3) == 0)
  {
    for (i = a2 >> 2; i; v6 = v34 + HIDWORD(v34))
    {
      if (i >= 0x16A00) {
        v8 = 92672;
      }
      else {
        v8 = i;
      }
      i -= v8;
      v9 = (int64x2_t)veorq_s8(a4, a4);
      v10 = (int64x2_t)veorq_s8(a5, a5);
      v9.i64[0] = v5;
      v10.i64[0] = v6;
      if (v8 >= 16)
      {
        v11 = *a1;
        v12 = a1[1];
        v13 = a1[2];
        v14 = a1[3];
        a1 += 4;
        v15 = vshlq_n_s64(v9, 4uLL);
        v16 = vmull_u32(*(uint32x2_t *)v12.i8, (uint32x2_t)0xB0000000CLL);
        v17 = vmull_u32(*(uint32x2_t *)v13.i8, (uint32x2_t)0x700000008);
        v18 = (int64x2_t)vmlal_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v11.i8, (uint32x2_t)0xF00000010), *(uint32x2_t *)v14.i8, (uint32x2_t)0x300000004);
        v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v11), v12), v13);
        v20 = v8 < 32;
        for (v8 -= 32; !v20; v8 -= 16)
        {
          v21 = vmlal_high_u32(v16, v11, *(uint32x4_t *)qword_100001000);
          v22 = *a1;
          a1 += 4;
          v11 = v22;
          v23 = vmlal_high_u32(v17, v12, *(uint32x4_t *)&qword_100001000[2]);
          v12 = a1[-3];
          v24 = (int64x2_t)vpadalq_u32(v19, v14);
          v25 = vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&qword_100001000[4]);
          v13 = a1[-2];
          v26 = vmlal_high_u32(v21, v14, *(uint32x4_t *)&qword_100001000[6]);
          v14 = a1[-1];
          v15 = vshlq_n_s64(v24, 4uLL);
          v16 = vmlal_u32(v26, *(uint32x2_t *)v12.i8, (uint32x2_t)0xB0000000CLL);
          v17 = vmlal_u32(v23, *(uint32x2_t *)v13.i8, (uint32x2_t)0x700000008);
          v18 = (int64x2_t)vmlal_u32(vmlal_u32(v25, *(uint32x2_t *)v22.i8, (uint32x2_t)0xF00000010), *(uint32x2_t *)v14.i8, (uint32x2_t)0x300000004);
          v19 = vpadalq_u32(vpadalq_u32(vpadalq_u32((uint64x2_t)v24, v22), v12), v13);
          v20 = v8 < 16;
        }
        v9 = (int64x2_t)vpadalq_u32(v19, v14);
        v10 = vaddq_s64(vaddq_s64((int64x2_t)vmlal_high_u32((uint64x2_t)vaddq_s64(v18, v15), v13, *(uint32x4_t *)&qword_100001000[4]), (int64x2_t)vmlal_high_u32(v17, v12, *(uint32x4_t *)&qword_100001000[2])), (int64x2_t)vmlal_high_u32(vmlal_high_u32(v16, v11, *(uint32x4_t *)qword_100001000), v14, *(uint32x4_t *)&qword_100001000[6]));
      }
      if ((v8 & 8) != 0)
      {
        v27 = *a1;
        a1 += 2;
        v28 = a1[-1];
        v29 = vshlq_n_s64(v9, 3uLL);
        v9 = (int64x2_t)vpadalq_u32(vpadalq_u32((uint64x2_t)v9, v27), v28);
        v10 = vaddq_s64((int64x2_t)vmlal_high_u32(vmlal_high_u32(vmlal_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v27.i8, (uint32x2_t)0x700000008), *(uint32x2_t *)v28.i8, (uint32x2_t)0x300000004), v27, *(uint32x4_t *)&qword_100001000[4]), v28, *(uint32x4_t *)&qword_100001000[6]), v29);
      }
      if ((v8 & 4) != 0)
      {
        v30 = *a1++;
        v31 = vshlq_n_s64(v9, 2uLL);
        v9 = (int64x2_t)vpadalq_u32((uint64x2_t)v9, v30);
        v10 = vaddq_s64((int64x2_t)vmlal_high_u32(vmlal_u32((uint64x2_t)v10, *(uint32x2_t *)v30.i8, (uint32x2_t)0x300000004), v30, *(uint32x4_t *)&qword_100001000[6]), v31);
      }
      v32 = v8 & 3;
      a4 = (int8x16_t)vpaddq_s64(v9, v9);
      a5 = (int8x16_t)vpaddq_s64(v10, v10);
      v33 = a4.i64[0];
      v34 = a5.i64[0];
      if (v32)
      {
        do
        {
          v35 = a1->i32[0];
          a1 = (uint32x4_t *)((char *)a1 + 4);
          v33 += v35;
          v34 += v33;
          v20 = v32-- <= 1;
        }
        while (!v20);
      }
      v5 = v33 + HIDWORD(v33);
    }
  }
  v36 = v5 + HIDWORD(v5);
  v37 = v6 + HIDWORD(v6);
  if (v36 == 0xFFFFFFFF) {
    v36 = 0;
  }
  if (v37 == 0xFFFFFFFF) {
    v37 = 0;
  }
  return v36 + (v37 << 32);
}

uint64_t gbitmap_key_compare(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

uint64_t sub_10000121C(void *a1)
{
  uint64_t v1 = a1[7];
  a1[47] = v1;
  a1[48] = v1 + 32;
  return 0;
}

uint64_t sub_100001230(void *a1, uint64_t a2, uint64_t *a3)
{
  if (!a3) {
    return 22;
  }
  uint64_t result = 0;
  uint64_t v5 = *a3;
  a1[4] = a3[2];
  a1[5] = v5;
  a1[6] = 0;
  return result;
}

uint64_t sub_100001258(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 376) = *(void *)(a1 + 56);
  *(void *)(a1 + 408) = 8 * *(unsigned int *)(a1 + 48) - 256;
  if (a2) {
    *(void *)(a1 + 384) = *(void *)(a2 + 24);
  }
  return 0;
}

uint64_t sub_100001284(void *a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v10 = (void *)a1[1];
  uint64_t v11 = *(void *)(*a1 + 392);
  if (v10) {
    v12 = (void *)a1[1];
  }
  else {
    v12 = *(void **)(*a1 + 392);
  }
  uint64_t v13 = a1[2];
  v65 = 0;
  if (v10 && obj_modify(v10, 0, a5, a4, a5, a6, a7, a8))
  {
    obj_type((uint64_t)v10);
    obj_oid((uint64_t)v10);
    log_err((uint64_t)"%s:%d: %s obj_modify(fs %lld) failed: %d\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"gbitmap_reap");
  }
  if (sub_10000160C(a1, 0, 0, &v65))
  {
    obj_type((uint64_t)v12);
    log_err((uint64_t)"%s:%d: %s Can't get tree: %d\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"gbitmap_reap");
  }
  if (v65)
  {
    unint64_t v28 = *a3;
    unint64_t v63 = 0;
    unint64_t v64 = v28;
    uint64_t v62 = 0;
    memset(v61, 0, sizeof(v61));
    bt_iterator_init((uint64_t)v61, v65, 0, 0, &v64, 8, 8u, &v63, 8u);
    int v30 = v29;
    int v31 = 1023;
    if (v29)
    {
LABEL_22:
      if (v30 != 2)
      {
        obj_type((uint64_t)v12);
        log_err((uint64_t)"%s:%d: %s Tree iteration threw %d at cursor %llu\n", v45, v46, v47, v48, v49, v50, v51, (uint64_t)"gbitmap_reap");
      }
    }
    else
    {
      while (!bt_iterator_ended((uint64_t)v61))
      {
        if ((v13 & 0x40000000) != 0 && (unint64_t v32 = v63, (v63 & 0x8000000000000000) != 0))
        {
          v63 &= ~0x8000000000000000;
          spaceman_free(v12, 0, v32 & 0x7FFFFFFFFFFFFFFFLL, 1, a5);
        }
        else
        {
          int v33 = *((_DWORD *)a1 + 4);
          if (v10) {
            unint64_t v34 = obj_oid((uint64_t)v10);
          }
          else {
            unint64_t v34 = 0;
          }
          uint64_t v35 = *(void *)(v11 + 392);
          int v36 = obj_size_phys((uint64_t)a1);
          if (obj_delete_and_free_by_oid(v35, v33 & 0xD8000000 | 0x1B, v36, v34, v63, a5))
          {
            obj_type((uint64_t)v12);
            log_err((uint64_t)"%s:%d: %s deletion threw %d for cursor %llu, oid %llu, oflags 0x%x\n", v37, v38, v39, v40, v41, v42, v43, (uint64_t)"gbitmap_reap");
          }
        }
        *a3 = v64 + 1;
        if (!v31)
        {
          uint64_t v44 = 36;
          goto LABEL_28;
        }
        int v30 = bt_iterator_next((uint64_t)v61);
        --v31;
        if (v30) {
          goto LABEL_22;
        }
      }
    }
    if (btree_delete((uint64_t)v65, a5, 0))
    {
      obj_type((uint64_t)v12);
      obj_oid((uint64_t)v65);
      log_err((uint64_t)"%s:%d: %s Tree delete oid %llu threw %d\n", v52, v53, v54, v55, v56, v57, v58, (uint64_t)"gbitmap_reap");
    }
  }
  obj_delete_and_free(a1, a5);
  uint64_t v44 = 0;
LABEL_28:
  if (v65) {
    obj_release(v65);
  }
  return v44;
}

uint64_t sub_10000160C(void *a1, unint64_t a2, uint64_t a3, uint64_t **a4)
{
  if (a1[1]) {
    uint64_t v8 = a1[1];
  }
  else {
    uint64_t v8 = *(void *)(*a1 + 392);
  }
  *a4 = 0;
  unsigned int v9 = obj_flags((uint64_t)a1) & 0xFFFFFC00;
  return btree_get(v8, v9, *(void *)(a1[47] + 32), a2, 3, a3 != 0, 26, (uint64_t)gbitmap_key_compare, a3, a4);
}

uint64_t pfkur_tree_key_cmp(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

unint64_t fletcher64_set_cksum(unint64_t *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t result = sub_100001040(a2, a3, a4, a5, a6);
  unint64_t v8 = (HIDWORD(result)
      + result
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(result) + result) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  *a1 = v8 | ((unint64_t)~(v8
                                + result
                                + ((unint64_t)(((v8 + result)
                                                                   * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) << 32);
  return result;
}

unint64_t fletcher64_verify_cksum(void *a1, uint32x4_t *a2, unint64_t a3, unint64_t a4, int8x16_t a5, int8x16_t a6)
{
  unint64_t v7 = sub_100001040(a2, a3, a4, a5, a6);
  unint64_t v8 = (HIDWORD(v7)
      + v7
      - 0xFFFFFFFF
      * ((unint64_t)(((HIDWORD(v7) + v7) * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) ^ 0xFFFFFFFF;
  return (v8 | ((unint64_t)~(v8
                                  + v7
                                  + ((unint64_t)(((v8 + v7)
                                                                     * (unsigned __int128)0x200000003uLL) >> 64) >> 1)) << 32)) ^ *a1;
}

uint64_t rolling_stats_init(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t result = new_lock((pthread_mutex_t *)a1);
  if (!result)
  {
    v8.tv_sec = 0;
    v8.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v8);
    *(void *)(a1 + 64) = v8.tv_sec / a2 * a2;
    *(_DWORD *)(a1 + 72) = a2;
    *(_DWORD *)(a1 + 76) = a3;
    unint64_t v7 = _apfs_calloc(a3, 8uLL);
    *(void *)(a1 + 80) = v7;
    if (v7)
    {
      uint64_t result = 0;
      *(void *)(a1 + 88) = 0;
    }
    else
    {
      free_lock((pthread_mutex_t *)a1);
      return 12;
    }
  }
  return result;
}

uint64_t rolling_stats_destroy(uint64_t a1)
{
  _apfs_free(*(void **)(a1 + 80), 8 * *(unsigned int *)(a1 + 76));
  *(void *)(a1 + 80) = 0;

  return free_lock((pthread_mutex_t *)a1);
}

uint64_t nx_corruption_detected_int(uint64_t a1)
{
  if (a1)
  {
    BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(a1);
    log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s Container corruption detected by %s:%u!\n", v2, v3, v4, v5, v6, v7, (uint64_t)"nx_corruption_detected_int");
  }
  else
  {
    BOOL v8 = nx_is_panic_on_corruption_enabled(0);
    log_corrupt(v8, (uint64_t)"%s:%d: Container corruption detected by %s:%u!\n", v9, v10, v11, v12, v13, v14, (uint64_t)"nx_corruption_detected_int");
  }
  return 92;
}

unint64_t obj_checksum_verify_phys(uint64_t a1, int a2, int8x16_t a3, int8x16_t a4)
{
  unint64_t result = fletcher64_verify_cksum((void *)a1, (uint32x4_t *)(a1 + 8), (a2 - 8), 0, a3, a4);
  if (result)
  {
    log_err((uint64_t)"%s:%d: failed: cksum 0x%016llx, oid 0x%llx, type 0x%x/0x%x, size %d\n", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"obj_checksum_verify_phys");
    BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(0);
    log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: Container corruption detected by %s:%u!\n", v13, v14, v15, v16, v17, v18, (uint64_t)"nx_corruption_detected_int");
    return 92;
  }
  return result;
}

uint64_t nx_superblock_sanity_check_extent(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5)
{
  if (*(unsigned char *)(a1 + 65))
  {
    if (a2)
    {
      unint64_t v7 = *(void *)(a2 + 48);
      unint64_t v5 = *(void *)(a2 + 96);
    }
    else
    {
      unint64_t v7 = *(void *)(a1 + 40);
      unint64_t v5 = v7;
    }
    int64_t v8 = 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(a1 + 36)));
    int64_t v9 = v8 | v5;
  }
  else
  {
    unint64_t v5 = 0;
    uint64_t v6 = (unint64_t *)(a2 + 48);
    if (!a2) {
      uint64_t v6 = (unint64_t *)(a1 + 40);
    }
    unint64_t v7 = *v6;
    int64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
    int64_t v9 = v7;
  }
  uint64_t result = 22;
  if ((a5 ^ 1u) <= a3 && v9 - 1 >= a3)
  {
    if (v5 && v7 <= a3)
    {
      if (a5)
      {
        if (v8 > a3) {
          return result;
        }
      }
      else if (v8 >= a3)
      {
        return result;
      }
    }
    if (a4 >= 2)
    {
      if (v9 - a3 >= a4)
      {
        if (v7 - a3 >= a4 || v7 <= a3 || v5 == 0) {
          return 0;
        }
        else {
          return 22;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

unint64_t nx_check_superblock(uint64_t a1, unsigned int a2, int a3, int8x16_t a4, int8x16_t a5)
{
  if (a2 < 0x1000) {
    return 22;
  }
  if (*(_DWORD *)(a1 + 32) != 1112758350) {
    return 79;
  }
  if (a3 || (unsigned int v8 = *(_DWORD *)(a1 + 36), v8 == a2))
  {
    unint64_t result = obj_checksum_verify_phys(a1, a2, a4, a5);
    if (result) {
      return result;
    }
    unsigned int v8 = *(_DWORD *)(a1 + 36);
  }
  int v9 = *(_DWORD *)(a1 + 24);
  int v10 = v9 != -2147483647;
  if (v9 == -2147483647) {
    int v11 = 1;
  }
  else {
    int v11 = 2;
  }
  if (*(_DWORD *)(a1 + 28)) {
    int v10 = v11;
  }
  if (*(void *)(a1 + 8) != 1) {
    ++v10;
  }
  if (v8 < 0x1000) {
    ++v10;
  }
  if (v8 <= 0x10000) {
    int v12 = v10;
  }
  else {
    int v12 = v10 + 1;
  }
  if (*(void *)(a1 + 88) < 0x400uLL) {
    ++v12;
  }
  int v13 = *(_DWORD *)(a1 + 104);
  if ((v13 & 0x7FFFFFF8) != 0) {
    int v14 = v12;
  }
  else {
    int v14 = v12 + 1;
  }
  unint64_t v15 = v13 & 0x7FFFFFFF;
  unint64_t v16 = *(void *)(a1 + 40);
  uint64_t v17 = *(void *)(a1 + 112);
  if (v13 < 0) {
    unint64_t v18 = 1;
  }
  else {
    unint64_t v18 = v13 & 0x7FFFFFFF;
  }
  if (v13 < 0) {
    int v19 = 1;
  }
  else {
    int v19 = v13 & 0x7FFFFFFF;
  }
  unsigned int v45 = v19;
  int v46 = v14;
  int v20 = nx_superblock_sanity_check_extent(a1, 0, v17, v18, 0);
  unsigned int v44 = *(_DWORD *)(a1 + 128);
  int v21 = *(_DWORD *)(a1 + 108);
  unint64_t v22 = v21 & 0x7FFFFFFF;
  uint64_t v23 = *(void *)(a1 + 120);
  if (v21 < 0) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v21 & 0x7FFFFFFF;
  }
  if (v21 < 0) {
    unsigned int v25 = 1;
  }
  else {
    unsigned int v25 = v21 & 0x7FFFFFFF;
  }
  int v26 = nx_superblock_sanity_check_extent(a1, 0, *(void *)(a1 + 120), v24, 0);
  int v27 = v46;
  if (v17 >= v23) {
    uint64_t v28 = v25;
  }
  else {
    uint64_t v28 = v45;
  }
  if (v17 >= v23) {
    uint64_t v29 = v23;
  }
  else {
    uint64_t v29 = v17;
  }
  if (v17 <= v23) {
    uint64_t v30 = v23;
  }
  else {
    uint64_t v30 = v17;
  }
  if (v15 > 0x1000) {
    int v27 = v46 + 1;
  }
  if (v16 <= v15) {
    ++v27;
  }
  if (v20) {
    ++v27;
  }
  if (v44 >= v15) {
    ++v27;
  }
  if ((v21 & 0x7FFFFFF8) == 0) {
    ++v27;
  }
  if (v16 <= v22) {
    ++v27;
  }
  if (v26) {
    ++v27;
  }
  uint64_t v31 = v29 + v28;
  if (*(_DWORD *)(a1 + 132) < v22) {
    int v32 = v27;
  }
  else {
    int v32 = v27 + 1;
  }
  if (v31 <= v30) {
    int v33 = v32;
  }
  else {
    int v33 = v32 + 1;
  }
  if ((*(void *)(a1 + 64) & 0xFFFFFFFFFFFFFEFDLL) == 0)
  {
    unsigned int v34 = *(_DWORD *)(a1 + 140);
    if (!*(void *)(a1 + 152)) {
      ++v33;
    }
    if (!*(void *)(a1 + 160)) {
      ++v33;
    }
    if (!(a3 | v34))
    {
      if (!*(_DWORD *)(a1 + 148) && !*(_DWORD *)(a1 + 136) && !*(_DWORD *)(a1 + 144)) {
        goto LABEL_91;
      }
      unsigned int v34 = 0;
    }
    if (*(_DWORD *)(a1 + 136) >= v15) {
      ++v33;
    }
    unsigned int v35 = *(_DWORD *)(a1 + 148);
    if (*(_DWORD *)(a1 + 144) >= v22) {
      ++v33;
    }
    if (v34 < 2) {
      ++v33;
    }
    if (v34 >= v15) {
      ++v33;
    }
    if (v35 < 2) {
      ++v33;
    }
    if (v35 >= v22) {
      ++v33;
    }
LABEL_91:
    if (*(_DWORD *)(a1 + 180) <= 0x64u) {
      int v36 = 0;
    }
    else {
      int v36 = -1;
    }
    if (v33 != v36) {
      goto LABEL_96;
    }
    return 0;
  }
  if (!v33) {
    return 0;
  }
LABEL_96:
  BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(0);
  log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: Container corruption detected by %s:%u!\n", v38, v39, v40, v41, v42, v43, (uint64_t)"nx_corruption_detected_int");
  return 92;
}

uint64_t supplemental_tree_create(pthread_mutex_t **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a4;
  unint64_t v16 = 0;
  int v10 = fext_tree_key_cmp;
  if (a3 == 5)
  {
    uint64_t v11 = 0x20000001FLL;
    uint64_t v13 = 16;
    uint64_t v12 = 16;
  }
  else
  {
    if (a3 != 6)
    {
      log_err((uint64_t)"%s:%d: %s unsupported tree type: %d\n", a2, a3, a4, (uint64_t)a5, a6, a4, a8, (uint64_t)"supplemental_tree_get_descriptor");
      return 45;
    }
    uint64_t v11 = 32;
    int v10 = pfkur_tree_key_cmp;
    uint64_t v12 = 24;
    uint64_t v13 = 8;
  }
  v17[1] = 0;
  long long v18 = 0u;
  uint64_t v22 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v19 = 0u;
  v17[0] = (uint64_t)v10;
  v17[2] = v11;
  if ((unsigned __int16)a2 != 2)
  {
    uint64_t extended = 22;
    goto LABEL_10;
  }
  uint64_t extended = btree_create_extended(a1, a2 & 0xFFFF0000, 0, v13, v12, v17, v9, (uint64_t *)&v16);
  if (extended)
  {
LABEL_10:
    log_err((uint64_t)"%s:%d: %s Failed to create supplemental tree (type %d): %d\n", a2, a3, v13, v12, a6, v9, a8, (uint64_t)"supplemental_tree_create");
    return extended;
  }
  *a5 = obj_oid((uint64_t)v16);
  obj_release(v16);
  return extended;
}

uint64_t supplemental_tree_destroy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, void *a6, uint64_t a7, uint64_t a8)
{
  int v10 = fext_tree_key_cmp;
  if (a3 == 5)
  {
    uint64_t v11 = 0x20000001FLL;
  }
  else
  {
    if (a3 != 6)
    {
      log_err((uint64_t)"%s:%d: %s unsupported tree type: %d\n", a2, a3, a4, a5, (uint64_t)a6, a7, a8, (uint64_t)"supplemental_tree_get_descriptor");
      return 45;
    }
    uint64_t v11 = 32;
    int v10 = pfkur_tree_key_cmp;
  }
  uint64_t v29 = 0;
  if (!a5)
  {
    uint64_t tree = jfs_get_tree(a1, a3, a4, &v29);
    if (tree) {
      return tree;
    }
    goto LABEL_11;
  }
  v30[1] = 0;
  long long v31 = 0u;
  uint64_t v35 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  v30[0] = v10;
  v30[2] = v11;
  if ((unsigned __int16)a2 != 2)
  {
    uint64_t tree = 22;
    goto LABEL_15;
  }
  uint64_t tree = btree_get_extended(a1, a2 & 0xFFFF0000, a5, 0, 0, (uint64_t)v30, 0, &v29);
  if (tree)
  {
LABEL_15:
    strerror(tree);
    log_err((uint64_t)"%s:%d: %s Failed to get supplemental tree (type %d, oid %llu): %d (%s)\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"supplemental_tree_destroy");
    return tree;
  }
LABEL_11:
  uint64_t v13 = btree_delete((uint64_t)v29, a4, a6);
  uint64_t tree = v13;
  if (v13)
  {
    strerror(v13);
    log_err((uint64_t)"%s:%d: %s Failed to delete supplemental tree (type %d): %d (%s)\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"supplemental_tree_destroy");
  }
  obj_release(v29);
  return tree;
}

unint64_t parse_size(const char *a1)
{
  __endptr = 0;
  unint64_t result = strtoull(a1, &__endptr, 10);
  uint64_t v3 = __endptr;
  unsigned int v4 = *__endptr;
  if (v4 > 0x66)
  {
    if (*__endptr <= 0x6Cu)
    {
      if (v4 != 103)
      {
        if (v4 != 107) {
          goto LABEL_19;
        }
LABEL_9:
        result <<= 10;
LABEL_18:
        uint64_t v3 = __endptr + 1;
        goto LABEL_19;
      }
LABEL_16:
      result <<= 30;
      goto LABEL_18;
    }
    if (v4 != 109)
    {
      if (v4 != 116) {
        goto LABEL_19;
      }
      goto LABEL_15;
    }
LABEL_17:
    result <<= 20;
    goto LABEL_18;
  }
  if (*__endptr <= 0x4Cu)
  {
    if (v4 != 71)
    {
      if (v4 != 75) {
        goto LABEL_19;
      }
      goto LABEL_9;
    }
    goto LABEL_16;
  }
  if (v4 == 77) {
    goto LABEL_17;
  }
  if (v4 == 84)
  {
LABEL_15:
    result <<= 40;
    goto LABEL_18;
  }
LABEL_19:
  if (v3 == a1) {
    return -1;
  }
  if (*v3) {
    return -1;
  }
  return result;
}

char *parse_nx_format_options(char *__s1, uuid_t out)
{
  uint64_t v3 = __s1;
  if (!__s1)
  {
    *((void *)out + 6) = 0;
    *((_OWORD *)out + 1) = 0u;
    *((_OWORD *)out + 2) = 0u;
    *(_OWORD *)out = 0u;
    uuid_generate(out);
    *((_DWORD *)out + 5) = 1073741826;
    return v3;
  }
  unsigned int v4 = strdup(__s1);
  if (v4)
  {
    unint64_t v5 = v4;
    __lasts = 0;
    uint64_t v6 = strtok_r(v4, ",", &__lasts);
    if (!v6)
    {
LABEL_33:
      uint64_t v3 = 0;
      goto LABEL_34;
    }
    unint64_t v7 = v6;
    while (1)
    {
      if (!strncasecmp(v7, "blocksize=", 0xAuLL))
      {
        unint64_t v9 = parse_size(v7 + 10);
        if (v9 - 4096 > 0xF000
          || (uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v10.i16[0] = vaddlv_u8(v10), v10.u32[0] >= 2uLL))
        {
LABEL_36:
          v3 += v7 - v5;
LABEL_34:
          free(v5);
          return v3;
        }
        *((_DWORD *)out + 4) = v9;
      }
      else if (!strcasecmp(v7, "omap=btree") || !strcasecmp(v7, "omap=physical"))
      {
        *((_DWORD *)out + 5) = 1073741826;
      }
      else if (!strcasecmp(v7, "omap=ephemeral"))
      {
        *((_DWORD *)out + 5) = -2147483646;
      }
      else
      {
        if (!strcasecmp(v7, "defragment=yes"))
        {
          __int16 v11 = *((_WORD *)out + 16) & 0xFFFC | 2;
LABEL_26:
          *((_WORD *)out + 16) = v11;
          goto LABEL_27;
        }
        if (!strcasecmp(v7, "defragment=no"))
        {
          __int16 v11 = *((_WORD *)out + 16) & 0xFFFC | 1;
          goto LABEL_26;
        }
        if (!strcasecmp(v7, "fusionlc=yes"))
        {
          __int16 v11 = *((_WORD *)out + 16) & 0xFFF3 | 8;
          goto LABEL_26;
        }
        if (!strcasecmp(v7, "fusionlc=no"))
        {
          __int16 v11 = *((_WORD *)out + 16) & 0xFFF3 | 4;
          goto LABEL_26;
        }
        if (!strncasecmp(v7, "wbcsize=", 8uLL))
        {
          unint64_t v12 = parse_size(v7 + 8);
          if (v12 - 102400 > 0x1FFFE7000 || (v12 & 0xFFF) != 0) {
            goto LABEL_36;
          }
          *((void *)out + 5) = v12;
        }
        else
        {
          if (strncasecmp(v7, "maxfs=", 6uLL)) {
            goto LABEL_36;
          }
          unint64_t v8 = parse_size(v7 + 6);
          if (v8 >= 0x65) {
            goto LABEL_36;
          }
          out[34] = v8;
        }
      }
LABEL_27:
      unint64_t v7 = strtok_r(0, ",", &__lasts);
      if (!v7) {
        goto LABEL_33;
      }
    }
  }
  return v3;
}

char *parse_apfs_format_options(char *a1, uuid_t out)
{
  uint64_t v3 = a1;
  if (!a1)
  {
    *((_OWORD *)out + 29) = 0u;
    *((_OWORD *)out + 30) = 0u;
    *((_OWORD *)out + 27) = 0u;
    *((_OWORD *)out + 28) = 0u;
    *((_OWORD *)out + 25) = 0u;
    *((_OWORD *)out + 26) = 0u;
    *((_OWORD *)out + 23) = 0u;
    *((_OWORD *)out + 24) = 0u;
    *((_OWORD *)out + 21) = 0u;
    *((_OWORD *)out + 22) = 0u;
    *((_OWORD *)out + 19) = 0u;
    *((_OWORD *)out + 20) = 0u;
    *((_OWORD *)out + 17) = 0u;
    *((_OWORD *)out + 18) = 0u;
    *((_OWORD *)out + 15) = 0u;
    *((_OWORD *)out + 16) = 0u;
    *((_OWORD *)out + 13) = 0u;
    *((_OWORD *)out + 14) = 0u;
    *((_OWORD *)out + 11) = 0u;
    *((_OWORD *)out + 12) = 0u;
    *((_OWORD *)out + 9) = 0u;
    *((_OWORD *)out + 10) = 0u;
    *((_OWORD *)out + 7) = 0u;
    *((_OWORD *)out + 8) = 0u;
    *((_OWORD *)out + 5) = 0u;
    *((_OWORD *)out + 6) = 0u;
    *((_OWORD *)out + 3) = 0u;
    *((_OWORD *)out + 4) = 0u;
    *((_OWORD *)out + 1) = 0u;
    *((_OWORD *)out + 2) = 0u;
    *(_OWORD *)out = 0u;
    uuid_generate(out);
    *((_OWORD *)out + 2) = xmmword_100076D20;
    *((_DWORD *)out + 123) = 1073741826;
    *((_DWORD *)out + 12) = -1;
    *((_DWORD *)out + 111) = getuid();
    *((_DWORD *)out + 112) = getgid();
    *((_WORD *)out + 26) &= ~0x80u;
    __strlcpy_chk();
    *((_WORD *)out + 26) = *((_WORD *)out + 26) & 0xFBF3 | 8;
    return (char *)v3;
  }
  if (!strncasecmp(a1, "uuid_from_role", 0xEuLL))
  {
    unsigned int v21 = *((unsigned __int16 *)out + 27);
    if (v21 > 0xBF)
    {
      if (*((unsigned __int16 *)out + 27) <= 0x1BFu)
      {
        if (*((unsigned __int16 *)out + 27) > 0x13Fu)
        {
          if (v21 == 320)
          {
            uint64_t v22 = "61706673-7575-6964-0140-766f6c756d00";
            goto LABEL_114;
          }
          if (v21 == 384)
          {
            uint64_t v22 = "61706673-7575-6964-0180-766f6c756d00";
            goto LABEL_114;
          }
        }
        else
        {
          if (v21 == 192)
          {
            uint64_t v22 = "61706673-7575-6964-00c0-766f6c756d00";
            goto LABEL_114;
          }
          if (v21 == 256)
          {
            uint64_t v22 = "61706673-7575-6964-0100-766f6c756d00";
            goto LABEL_114;
          }
        }
      }
      else if (*((unsigned __int16 *)out + 27) <= 0x23Fu)
      {
        if (v21 == 448)
        {
          uint64_t v22 = "61706673-7575-6964-01c0-766f6c756d00";
          goto LABEL_114;
        }
        if (v21 == 512)
        {
          uint64_t v22 = "61706673-7575-6964-0200-766f6c756d00";
          goto LABEL_114;
        }
      }
      else
      {
        switch(v21)
        {
          case 0x240u:
            uint64_t v22 = "61706673-7575-6964-0240-766f6c756d00";
            goto LABEL_114;
          case 0x280u:
            uint64_t v22 = "61706673-7575-6964-0280-766f6c756d00";
            goto LABEL_114;
          case 0x2C0u:
            uint64_t v22 = "61706673-7575-6964-02c0-766f6c756d00";
LABEL_114:
            uuid_parse(v22, out);
            return 0;
        }
      }
    }
    else
    {
      if (*((unsigned __int16 *)out + 27) <= 0xFu)
      {
        uint64_t v22 = "61706673-7575-6964-0000-766f6c756d00";
        switch(*((_WORD *)out + 27))
        {
          case 0:
            goto LABEL_114;
          case 1:
            uint64_t v22 = "61706673-7575-6964-0001-766f6c756d00";
            goto LABEL_114;
          case 2:
            uint64_t v22 = "61706673-7575-6964-0002-766f6c756d00";
            goto LABEL_114;
          case 4:
            uint64_t v22 = "61706673-7575-6964-0004-766f6c756d00";
            goto LABEL_114;
          case 8:
            uint64_t v22 = "61706673-7575-6964-0008-766f6c756d00";
            goto LABEL_114;
          default:
            goto LABEL_117;
        }
      }
      if (*((unsigned __int16 *)out + 27) > 0x3Fu)
      {
        if (v21 == 64)
        {
          uint64_t v22 = "61706673-7575-6964-0040-766f6c756d00";
          goto LABEL_114;
        }
        if (v21 == 128)
        {
          uint64_t v22 = "61706673-7575-6964-0080-766f6c756d00";
          goto LABEL_114;
        }
      }
      else
      {
        if (v21 == 16)
        {
          uint64_t v22 = "61706673-7575-6964-0010-766f6c756d00";
          goto LABEL_114;
        }
        if (v21 == 32)
        {
          uint64_t v22 = "61706673-7575-6964-0020-766f6c756d00";
          goto LABEL_114;
        }
      }
    }
LABEL_117:
    return strerror(22);
  }
  if (!strncasecmp(v3, "password=", 9uLL))
  {
    v3 += 9;
    __strlcpy_chk();
    int v23 = strnlen(v3, 0x80uLL);
    *((_DWORD *)out + 110) = v23;
    if ((v23 & 0xFFFFFF80) == 0) {
      return 0;
    }
    return (char *)v3;
  }
  if (!strncasecmp(v3, "empty_password", 0xFuLL))
  {
    uint64_t v3 = 0;
    out[312] = 0;
    *((_DWORD *)out + 110) = 0;
    return (char *)v3;
  }
  if (!strncasecmp(v3, "volname=", 8uLL))
  {
    __strlcpy_chk();
    return 0;
  }
  unsigned int v4 = strdup(v3);
  if (!v4) {
    return (char *)v3;
  }
  unint64_t v5 = v4;
  __lasts = 0;
  uint64_t v6 = strtok_r(v4, ",", &__lasts);
  if (!v6)
  {
    uint64_t v3 = 0;
    goto LABEL_103;
  }
  unint64_t v7 = v6;
  unint64_t v8 = "fsquota=";
  unint64_t v9 = "fsindex=";
  while (1)
  {
    if (!strncasecmp(v7, "fssize=", 7uLL))
    {
      unint64_t v11 = parse_size(v7 + 7);
      if (v11 == -1) {
        goto LABEL_102;
      }
      *((void *)out + 2) = v11;
LABEL_36:
      *((void *)out + 3) = v11;
      goto LABEL_37;
    }
    if (!strncasecmp(v7, "fsreserve=", 0xAuLL))
    {
      unint64_t v12 = parse_size(v7 + 10);
      if (v12 == -1) {
        goto LABEL_102;
      }
      *((void *)out + 2) = v12;
      goto LABEL_37;
    }
    if (!strncasecmp(v7, v8, 8uLL))
    {
      unint64_t v11 = parse_size(v7 + 8);
      if (v11 == -1) {
        goto LABEL_102;
      }
      goto LABEL_36;
    }
    if (!strncasecmp(v7, v9, 8uLL)) {
      break;
    }
    if (!strcasecmp(v7, "omap=btree") || !strcasecmp(v7, "omap=physical"))
    {
      int v13 = 1073741826;
LABEL_40:
      *((_DWORD *)out + 8) = v13;
      goto LABEL_37;
    }
    if (!strcasecmp(v7, "omap=ephemeral"))
    {
      int v13 = -2147483646;
      goto LABEL_40;
    }
    if (!strcasecmp(v7, "fstree=btree"))
    {
      *(void *)(out + 36) = 0x4000000200000002;
      *((_DWORD *)out + 11) = 1073741826;
      *((_DWORD *)out + 123) = 1073741826;
      goto LABEL_37;
    }
    if (!strcasecmp(v7, "encrypted"))
    {
      __int16 v10 = *((_WORD *)out + 26) | 1;
LABEL_55:
      *((_WORD *)out + 26) = v10;
      goto LABEL_37;
    }
    if (!strncasecmp(v7, "role=", 5uLL))
    {
      uint64_t v17 = parse_str_to_role(v7 + 5);
      if (v17 == -1) {
        goto LABEL_102;
      }
      *((_WORD *)out + 27) = v17;
    }
    else
    {
      if (!strcasecmp(v7, "case=insensitive"))
      {
        __int16 v10 = *((_WORD *)out + 26) & 0xFFF3 | 4;
        goto LABEL_55;
      }
      if (!strcasecmp(v7, "case=sensitive"))
      {
        __int16 v10 = *((_WORD *)out + 26) & 0xFFF3 | 8;
        goto LABEL_55;
      }
      if (!strcasecmp(v7, "defragment=yes"))
      {
        __int16 v10 = *((_WORD *)out + 26) & 0xFFCF | 0x20;
        goto LABEL_55;
      }
      if (!strcasecmp(v7, "defragment=no"))
      {
        __int16 v10 = *((_WORD *)out + 26) & 0xFFCF | 0x10;
        goto LABEL_55;
      }
      if (!strncasecmp(v7, "uid=", 4uLL))
      {
        uint64_t v14 = v8;
        uint64_t v15 = v9;
        __endptr = 0;
        unint64_t v18 = strtoull(v7 + 4, &__endptr, 10);
        if (__endptr == v7 + 4 || *__endptr || v18 == -1) {
          goto LABEL_102;
        }
        *((_DWORD *)out + 111) = v18;
        goto LABEL_45;
      }
      if (!strncasecmp(v7, "gid=", 4uLL))
      {
        uint64_t v14 = v8;
        uint64_t v15 = v9;
        __endptr = 0;
        unint64_t v19 = strtoull(v7 + 4, &__endptr, 10);
        if (__endptr == v7 + 4 || *__endptr || v19 == -1) {
          goto LABEL_102;
        }
        *((_DWORD *)out + 112) = v19;
        goto LABEL_45;
      }
      if (!strcasecmp(v7, "sealed=yes"))
      {
        *((_WORD *)out + 26) |= 0x80u;
        *((_DWORD *)out + 122) = 1;
        *((_DWORD *)out + 9) = 2;
        goto LABEL_37;
      }
      if (!strcasecmp(v7, "conformance")) {
        goto LABEL_102;
      }
      if (strncasecmp(v7, "hash=", 5uLL))
      {
        if (!strcasecmp(v7, "unwritten"))
        {
          __int16 v10 = *((_WORD *)out + 26) | 0x400;
        }
        else
        {
          if (strcasecmp(v7, "unwritten=no")) {
            goto LABEL_102;
          }
          __int16 v10 = *((_WORD *)out + 26) & 0xFBFF;
        }
        goto LABEL_55;
      }
      int v20 = sub_100002C64(v7 + 5);
      if (v20 == -1) {
        goto LABEL_102;
      }
      *((_DWORD *)out + 122) = v20;
    }
LABEL_37:
    unint64_t v7 = strtok_r(0, ",", &__lasts);
    if (!v7)
    {
      uint64_t v3 = 0;
      goto LABEL_103;
    }
  }
  uint64_t v14 = v8;
  uint64_t v15 = v9;
  __endptr = 0;
  unint64_t v16 = strtoull(v7 + 8, &__endptr, 10);
  if (__endptr != v7 + 8 && !*__endptr && v16 != -1)
  {
    *((_DWORD *)out + 12) = v16;
LABEL_45:
    unint64_t v9 = v15;
    unint64_t v8 = v14;
    goto LABEL_37;
  }
LABEL_102:
  v3 += v7 - v5;
LABEL_103:
  free(v5);
  return (char *)v3;
}

uint64_t sub_100002C64(const char *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (!strncasecmp(a1, "sha256", 7uLL)) {
    return 1;
  }
  if (!strncasecmp(a1, "sha512_256", 0xBuLL)) {
    return 5;
  }
  if (!strncasecmp(a1, "sha384", 7uLL)) {
    return 3;
  }
  if (!strncasecmp(a1, "sha512", 7uLL)) {
    return 4;
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_100002D14(void *a1)
{
  uint64_t v1 = a1[7];
  a1[47] = v1;
  a1[48] = v1 + 32;
  return 0;
}

uint64_t fs_lookup_snapshot_metadata_by_xid(uint64_t a1, uint64_t a2, unsigned __int16 **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  v17[0] = 5242881;
  v17[1] = a2;
  uint64_t v15 = lookup_jobj(a1, 3, 0, (unsigned __int8 *)v17, a3, a6, a7, a8);
  if (v15) {
    log_err((uint64_t)"%s:%d: %s Couldn't find snap_meta for xid %llu: %d\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"fs_lookup_snapshot_metadata_by_xid");
  }
  return v15;
}

uint64_t fs_delete_clone_superblock(uint64_t a1, unint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 392) + 392);
  unint64_t v7 = 0;
  uint64_t v5 = obj_get(v4, 0x40000000, a2, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v7);
  if (!v5)
  {
    obj_delete_and_free(v7, a3);
    obj_release(v7);
  }
  return v5;
}

uint64_t fs_delete_supplemental_tree(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v9 = *(void *)(*(void *)(a1 + 392) + 392);
  long long v18 = 0;
  uint64_t result = obj_get(v9, 0x40000000, a3, (int *)&apfs_desc, 0, 0, 0, a4, (uint64_t *)&v18);
  if (!result)
  {
    uint64_t v11 = v18[47];
    if (a2 == 6)
    {
      uint64_t v12 = (unint64_t *)(v11 + 1048);
      uint64_t v13 = (unsigned int *)(v11 + 1044);
    }
    else
    {
      if (a2 != 5)
      {
        obj_release(v18);
        return 45;
      }
      uint64_t v12 = (unint64_t *)(v11 + 1032);
      uint64_t v13 = (unsigned int *)(v11 + 1040);
    }
    uint64_t v14 = *v13;
    unint64_t v15 = *v12;
    obj_release(v18);
    if (v15) {
      return supplemental_tree_destroy(a1, v14, a2, a4, v15, a5, v16, v17);
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t fs_delete_snapshot_metadata_tree(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v8 = 0;
  uint64_t tree = jfs_get_tree(a1, 3, 0, &v8);
  if (!tree)
  {
    uint64_t tree = btree_delete((uint64_t)v8, a2, a3);
    obj_release(v8);
    if (!tree)
    {
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1472));
      *(void *)(*(void *)(a1 + 376) + 152) = 0;
      fs_sb_dirty(a1, a2);
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1472));
    }
  }
  return tree;
}

uint64_t get_timestamp()
{
  v1.tv_sec = 0;
  v1.tv_nsec = 0;
  clock_gettime(_CLOCK_REALTIME, &v1);
  return timespec_to_apfs_timestamp(&v1.tv_sec);
}

uint64_t timespec_to_apfs_timestamp(uint64_t *a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = a1[1];
  uint64_t v3 = v2 / 1000000000;
  uint64_t v4 = v2 % 1000000000;
  if (*a1 < 0 && v2 >= 1)
  {
    uint64_t v5 = v3 + 1;
    v4 -= 1000000000;
  }
  else
  {
    BOOL v6 = v2 >= 0;
    if (v2 < 0) {
      uint64_t v5 = v3 - 1;
    }
    else {
      uint64_t v5 = v2 / 1000000000;
    }
    if (v6) {
      uint64_t v7 = v4;
    }
    else {
      uint64_t v7 = v4 + 1000000000;
    }
    if (v1 >= 1) {
      uint64_t v4 = v7;
    }
    else {
      uint64_t v5 = v3;
    }
  }
  uint64_t v8 = v1 + v5;
  if (__OFADD__(v1, v5)
    || (uint64_t v9 = 1000000000 * v8, (unsigned __int128)(v8 * (__int128)1000000000) >> 64 != (1000000000 * v8) >> 63)
    || (uint64_t result = v4 + v9, __OFADD__(v4, v9)))
  {
    if (v1 > 0) {
      return 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      return 0x8000000000000000;
    }
  }
  return result;
}

uint64_t spaceman_metazone_init(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v31 = 0;
  if (*(unsigned char *)(a1 + 639))
  {
    log_debug((uint64_t)"%s:%d: %s Skipping metazone_init() as backing store is sparse\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"spaceman_metazone_init");
    return 0;
  }
  unint64_t v33 = 0;
  unint64_t v34 = 0;
  uint64_t v32 = 0;
  uint64_t v8 = spaceman_get((void *)a1, &v31);
  if (v8) {
    return v8;
  }
  uint64_t v10 = (uint64_t *)v31;
  if (!v31) {
    return 19;
  }
  if (!*(void *)(v31 + 376))
  {
    uint64_t v8 = 19;
    goto LABEL_11;
  }
  if (*(unsigned char *)(v31 + 1104) || *(unsigned char *)(v31 + 1208))
  {
    uint64_t v8 = 0;
LABEL_11:
    obj_release(v10);
    return v8;
  }
  uint64_t v12 = 0;
  char v13 = 1;
  do
  {
    char v14 = v13;
    uint64_t v15 = v31;
    uint64_t v16 = v31 + 104 * v12;
    *(_OWORD *)(v16 + 1008) = 0u;
    *(_OWORD *)(v16 + 1024) = 0u;
    *(_OWORD *)(v16 + 1040) = 0u;
    *(_OWORD *)(v16 + 1056) = 0u;
    *(_OWORD *)(v16 + 1072) = 0u;
    *(_OWORD *)(v16 + 1088) = 0u;
    *(void *)(v16 + 1104) = 0;
    uint64_t v17 = *(void *)(v15 + 376);
    unint64_t v18 = *(unsigned int *)(v17 + 32);
    unint64_t v19 = *(void *)(v17 + 48 * v12 + 48);
    if (is_mul_ok(v19, v18)) {
      unint64_t v20 = v19 * v18;
    }
    else {
      unint64_t v20 = 0x40000000000;
    }
    if (!spaceman_metazone_get_size(a2, v18, v19, v20, &v34, &v33))
    {
      uint64_t v21 = v15 + 104 * v12;
      unint64_t v22 = v33 + v34 / v18;
      spaceman_metazone_get_partitions(v18, v34, v33, v22, &v32, 0);
      *(void *)(v21 + 1008) = v33;
      *(void *)(v21 + 1024) = v33;
      *(void *)(v21 + 1016) = v32;
      *(unsigned char *)(v21 + 1034) = 1;
      *(void *)(v21 + 1040) = v32;
      *(void *)(v21 + 1056) = v32;
      *(void *)(v21 + 1048) = v22;
      *(unsigned char *)(v21 + 1066) = 1;
      *(unsigned char *)(v21 + 1105) = 1;
      uint64_t v23 = v31;
      uint64_t v24 = v31 + 8 * v12;
      unint64_t v25 = *(void *)(v24 + 992);
      if (v25 < v22 && v25 >= v33)
      {
        if (v22 == v19) {
          unint64_t v27 = 0;
        }
        else {
          unint64_t v27 = v22;
        }
        *(void *)(v24 + 992) = v27;
      }
      if (*(void *)(v24 + 1488))
      {
        unint64_t v28 = *(unsigned int *)(*(void *)(v23 + 376) + 36);
        unint64_t v29 = v33 / v28;
        unint64_t v30 = (v22 - 1) / v28;
        if (v29 <= v30)
        {
          do
            *(_DWORD *)(*(void *)(v31 + 8 * v12 + 1488) + 4 * v29++) |= 0x4000000u;
          while (v29 <= v30);
          uint64_t v23 = v31;
        }
      }
      *(unsigned char *)(v23 + 104 * v12 + 1104) = 1;
    }
    char v13 = 0;
    uint64_t v12 = 1;
  }
  while ((v14 & 1) != 0);
  uint64_t v8 = 0;
  uint64_t v10 = (uint64_t *)v31;
  if (v31) {
    goto LABEL_11;
  }
  return v8;
}

uint64_t spaceman_handle_metazone_freed(uint64_t result, uint64_t a2, unint64_t a3)
{
  uint64_t v3 = (a3 << __clz(__rbit64(*(unsigned int *)(*(void *)(result + 376) + 36))) >> 62) & 1;
  uint64_t v4 = a2 + 104 * v3;
  if (*(unsigned char *)(v4 + 1104) && *(unsigned char *)(a2 + 104 * v3 + 1105))
  {
    uint64_t v5 = (unint64_t *)(v4 + 1008);
    if (*v5 <= a3 && v5[1] > a3)
    {
      unint64_t v7 = v5[2];
      BOOL v6 = v5 + 2;
      if (v7 <= a3) {
        return result;
      }
LABEL_15:
      *BOOL v6 = a3;
      return result;
    }
    if (*(void *)(a2 + 104 * v3 + 1040) > a3
      || *(void *)(a2 + 104 * v3 + 1048) <= a3)
    {
      if (*(void *)(a2 + 104 * v3 + 1072) <= a3
        && *(void *)(a2 + 104 * v3 + 1080) > a3)
      {
        uint64_t v9 = a2 + 104 * v3;
        if (*(void *)(v9 + 1088) > a3)
        {
          BOOL v6 = (unint64_t *)(v9 + 1088);
          goto LABEL_15;
        }
      }
    }
    else
    {
      uint64_t v8 = a2 + 104 * v3;
      if (*(void *)(v8 + 1056) > a3)
      {
        BOOL v6 = (unint64_t *)(v8 + 1056);
        goto LABEL_15;
      }
    }
  }
  return result;
}

uint64_t spaceman_update_metazone_alloc_index(uint64_t result, unsigned int a2, int a3, unint64_t a4)
{
  if (a3 == 2)
  {
    uint64_t v9 = result + 104 * a2;
    uint64_t v5 = (unint64_t *)(v9 + 1072);
    BOOL v6 = (unint64_t *)(v9 + 1080);
    unint64_t v7 = (unint64_t *)(v9 + 1088);
    uint64_t v8 = (__int16 *)(v9 + 1096);
  }
  else if (a3 == 1)
  {
    uint64_t v10 = result + 104 * a2;
    uint64_t v5 = (unint64_t *)(v10 + 1040);
    BOOL v6 = (unint64_t *)(v10 + 1048);
    unint64_t v7 = (unint64_t *)(v10 + 1056);
    uint64_t v8 = (__int16 *)(v10 + 1064);
  }
  else
  {
    if (a3) {
      return result;
    }
    uint64_t v4 = result + 104 * a2;
    uint64_t v5 = (unint64_t *)(v4 + 1008);
    BOOL v6 = (unint64_t *)(v4 + 1016);
    unint64_t v7 = (unint64_t *)(v4 + 1024);
    uint64_t v8 = (__int16 *)(v4 + 1032);
  }
  unint64_t v11 = *v5;
  if (v11 <= a4 && *v6 > a4)
  {
    *unint64_t v7 = a4;
LABEL_18:
    *uint64_t v8 = 0;
    return result;
  }
  if (*v7 == v11)
  {
    *unint64_t v7 = a4;
    __int16 v12 = 1;
  }
  else
  {
    if (*v8 < 0)
    {
      *unint64_t v7 = v11;
      goto LABEL_18;
    }
    __int16 v13 = *v8;
    if (!*v8)
    {
      *unint64_t v7 = v11;
      return result;
    }
    *unint64_t v7 = a4;
    __int16 v12 = v13 + 1;
  }
  *uint64_t v8 = v12;
  return result;
}

uint64_t spaceman_get_metazone_alloc_index(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a2;
  if (a3 == 2)
  {
    if (*(unsigned char *)(a1 + 104 * a2 + 1098)) {
      uint64_t v10 = a1 + 104 * a2 + 1088;
    }
    else {
      uint64_t v10 = a1 + 104 * a2 + 1056;
    }
  }
  else if (a3 == 1)
  {
    uint64_t v10 = a1 + 104 * a2 + 1056;
  }
  else if (a3)
  {
    log_err((uint64_t)"%s:%d: %s tried to get metazone alloc index for unknown type: %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"spaceman_get_metazone_alloc_index");
    uint64_t v10 = a1 + 8 * v9 + 992;
  }
  else
  {
    uint64_t v10 = a1 + 104 * a2 + 1024;
  }
  return *(void *)v10;
}

uint64_t spaceman_allocation_init(void *a1)
{
  uint64_t v49 = 0;
  uint64_t v2 = spaceman_get(a1, &v49);
  if (!v2)
  {
    pthread_mutex_lock(v49 + 6);
    uint64_t v10 = v49;
    unint64_t v11 = *(_DWORD **)&v49[5].__opaque[48];
    if ((v11[36] & 1) == 0 || !v11[84])
    {
      int v12 = v11[29];
      if (!v12) {
        int v12 = v11[28];
      }
      uint64_t v13 = (v11[32] + 8 * v12);
      if ((int)v13 + 2184 <= (v13 + v11[8] - 1) / v11[8] * v11[8])
      {
        memmove(v11 + 630, v11 + 84, v13 - 336);
        uint64_t v14 = (v11[81] + 2184);
        v11[81] = v14;
        uint64_t v15 = (v11[82] + 2184);
        v11[82] = v15;
        uint64_t v16 = (v11[83] + 2184);
        v11[83] = v16;
        uint64_t v17 = (v11[20] + 2184);
        v11[20] = v17;
        uint64_t v18 = (v11[32] + 2184);
        v11[32] = v18;
        *(void *)&v10[13].__opaque[24] = (char *)v11 + v14;
        *(void *)&v10[13].__opaque[32] = (char *)v11 + v15;
        *(void *)&v10[13].__opaque[40] = (char *)v11 + v16;
        *(void *)&v10[13].__opaque[48] = (char *)v11 + v17;
        v10[14].__sig = (uint64_t)v11 + v18;
        *((void *)v11 + 42) = 0x9D800000001;
        bzero(v11 + 86, 0x880uLL);
        v11[36] |= 1u;
      }
      else
      {
        log_debug((uint64_t)"%s:%d: %s refusing to upgrade spaceman! new_smp_size %u old_smp_size %u block_size %u\n", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"spaceman_upgrade_sm_version_0_to_1");
        log_warn((uint64_t)"%s:%d: %s failed to upgrade spaceman from version 0 to 1: %d\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"spaceman_allocation_init");
      }
    }
    spaceman_free_queue_trim_list_init((uint64_t)a1, (uint64_t)v49);
    uint64_t v2 = spaceman_metazone_init((uint64_t)a1, 0, v26, v27, v28, v29, v30, v31);
    if (!v2)
    {
      spaceman_sanitize_datazone((uint64_t)v49, v32, v33, v34, v35, v36, v37, v38);
      uint64_t v39 = 1;
      while (1)
      {
        uint64_t v40 = spaceman_datazone_init(a1, v39);
        if (v40) {
          break;
        }
        if (++v39 == 5)
        {
          uint64_t v2 = spaceman_free_extent_cache_setup((uint64_t)a1, (uint64_t)v49);
          goto LABEL_15;
        }
      }
      uint64_t v2 = v40;
      log_err((uint64_t)"%s:%d: %s failed to initialize data zone for allocations of size %llu, error %d\n", v41, v42, v43, v44, v45, v46, v47, (uint64_t)"spaceman_allocation_init");
    }
  }
LABEL_15:
  if (v49)
  {
    pthread_mutex_unlock(v49 + 6);
    obj_release(&v49->__sig);
  }
  return v2;
}

void spaceman_sanitize_datazone(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    uint64_t v22 = *(void *)(a1 + 376);
    if (*(unsigned char *)(v22 + 144))
    {
      if (*(_DWORD *)(v22 + 336))
      {
        uint64_t v8 = 0;
        uint64_t v9 = v22 + 344;
        char v10 = 1;
        do
        {
          char v23 = v10;
          unint64_t v11 = *(void *)(v22 + 48 * v8 + 48);
          if (!v11) {
            goto LABEL_28;
          }
          uint64_t v12 = 0;
          uint64_t v13 = v22 + 368 + 1088 * v8;
          do
          {
            uint64_t v14 = v9 + 1088 * v8 + 136 * v12;
            if (*(void *)v14 >= v11
              || ((unint64_t v15 = *(void *)(v14 + 8), v15 <= v11) ? (v16 = *(void *)v14 > v15) : (v16 = 1), v16))
            {
              log_warn((uint64_t)"%s:%d: %s Persistent allocation zone at slot %llu has invalid current boundaries\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"spaceman_sanitize_datazone");
              char v17 = 1;
            }
            else
            {
              char v17 = 0;
            }
            uint64_t v18 = 0;
            uint64_t v19 = (unint64_t *)v13;
            do
            {
              unint64_t v20 = *(v19 - 1);
              if (v20 >= v11 || (*v19 <= v11 ? (BOOL v21 = v20 > *v19) : (BOOL v21 = 1), v21))
              {
                log_warn((uint64_t)"%s:%d: %s Persistent allocation zone at slot %llu has invalid previous boundary %llu\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"spaceman_sanitize_datazone");
                if (*(unsigned __int16 *)(v9 + 1088 * v8 + 136 * v12 + 130) < 7u) {
                  goto LABEL_26;
                }
LABEL_25:
                log_warn((uint64_t)"%s:%d: %s Persistent allocation zone at slot %llu has invalid previous boundary index\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"spaceman_sanitize_datazone");
                goto LABEL_26;
              }
              ++v18;
              v19 += 2;
            }
            while (v18 != 7);
            if (*(unsigned __int16 *)(v9 + 1088 * v8 + 136 * v12 + 130) > 6u) {
              goto LABEL_25;
            }
            if ((v17 & 1) == 0) {
              goto LABEL_27;
            }
LABEL_26:
            log_warn((uint64_t)"%s:%d: %s Clearing persistent allocation zone at slot %llu\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"spaceman_sanitize_datazone");
            *(void *)(v14 + 128) = 0;
            *(_OWORD *)(v14 + 96) = 0u;
            *(_OWORD *)(v14 + 112) = 0u;
            *(_OWORD *)(v14 + 64) = 0u;
            *(_OWORD *)(v14 + 80) = 0u;
            *(_OWORD *)(v14 + 32) = 0u;
            *(_OWORD *)(v14 + 48) = 0u;
            *(_OWORD *)uint64_t v14 = 0u;
            *(_OWORD *)(v14 + 16) = 0u;
LABEL_27:
            ++v12;
            v13 += 136;
          }
          while (v12 != 8);
LABEL_28:
          char v10 = 0;
          uint64_t v8 = 1;
        }
        while ((v23 & 1) != 0);
      }
    }
  }
}

uint64_t spaceman_datazone_init(void *a1, uint64_t a2)
{
  uint64_t v18 = 0;
  uint64_t v3 = spaceman_get(a1, &v18);
  if (v3) {
    return v3;
  }
  if (!v18) {
    return 19;
  }
  uint64_t v5 = v18[47];
  if (!v5)
  {
    uint64_t v3 = 19;
    goto LABEL_15;
  }
  if ((unint64_t)(a2 - 5) < 0xFFFFFFFFFFFFFFFCLL)
  {
    uint64_t v3 = 22;
    goto LABEL_15;
  }
  uint64_t v6 = v18 + 152;
  uint64_t v7 = &v18[4 * a2 + 148];
  if (*((unsigned char *)v7 + 24)) {
    goto LABEL_14;
  }
  unint64_t v8 = *(void *)(v5 + 56);
  if (!*((unsigned char *)v18 + 1104) || v8 < 8) {
    goto LABEL_14;
  }
  *((unsigned char *)v18 + 1344) = 1;
  *(_OWORD *)uint64_t v7 = 0u;
  *((_OWORD *)v7 + 1) = 0u;
  uint64_t v10 = spaceman_initialize_allocation_zone_from_disk((uint64_t)v18, 0, a2);
  if (v10)
  {
    uint64_t v3 = v10;
    log_err((uint64_t)"%s:%d: %s failed to initialize allocation zone for allocations of %llu blocks from disk: error %d\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"spaceman_datazone_init");
  }
  else
  {
    if (BYTE1(v6[4 * a2 - 1]))
    {
LABEL_14:
      uint64_t v3 = 0;
      goto LABEL_15;
    }
    log_debug((uint64_t)"%s:%d: %s allocation zone on dev %d for allocations of %llu blocks starting at paddr %llu\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"spaceman_datazone_init");
    uint64_t v3 = 0;
    *((unsigned char *)v7 + 24) = 1;
  }
LABEL_15:
  if (v18) {
    obj_release(v18);
  }
  return v3;
}

uint64_t spaceman_initialize_allocation_zone_from_disk(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3 = 22;
  if (a1)
  {
    unsigned __int16 v4 = a3;
    if ((unint64_t)(a3 - 5) >= 0xFFFFFFFFFFFFFFFCLL)
    {
      uint64_t v6 = a3 - 1;
      uint64_t v7 = a1 + 136 * a2 + 1216;
      uint64_t v8 = *(void *)(a1 + 376);
      if ((*(unsigned char *)(v8 + 144) & 1) != 0 && *(_DWORD *)(v8 + 336))
      {
        uint64_t v9 = v8 + 344;
        int v10 = v4;
        uint64_t v11 = -1;
        char v12 = 1;
        uint64_t v13 = 8;
        char v14 = v6;
        do
        {
          uint64_t v15 = v14 & 7;
          int v16 = *(unsigned __int16 *)(v9 + 1088 * a2 + 136 * v15 + 128);
          if (v16 == v10)
          {
            unint64_t v20 = (void *)(v9 + 1088 * a2 + 136 * v15);
            *(void *)(v7 + 32 * v6 + 16) = v20;
            uint64_t v3 = sub_100003DE8(a1, a2, v6, *v20 / (unint64_t)*(unsigned int *)(v8 + 36));
            if (v3) {
              log_err((uint64_t)"%s:%d: %s failed to update allocation zone boundaries: error %d\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"spaceman_initialize_allocation_zone_from_disk");
            }
            return v3;
          }
          if (!*(_WORD *)(v9 + 1088 * a2 + 136 * v15 + 128)) {
            char v12 = 0;
          }
          if (v11 == -1 && v16 == 0) {
            uint64_t v11 = v15;
          }
          char v14 = v15 + 1;
          --v13;
        }
        while (v13);
        if (v12) {
          goto LABEL_17;
        }
        uint64_t v3 = 0;
        uint64_t v18 = v7 + 32 * v6;
        *(void *)(v18 + 16) = v9 + 1088 * a2 + 136 * v11;
        *(unsigned char *)(v18 + 25) = 1;
      }
      else
      {
LABEL_17:
        uint64_t v3 = 0;
        *(_WORD *)(v7 + 32 * v6 + 25) = 257;
      }
    }
  }
  return v3;
}

void spaceman_datazone_destroy(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = 0;
    char v3 = 1;
    do
    {
      char v4 = v3;
      if (*(unsigned char *)(a1 + 136 * v2 + 1344))
      {
        uint64_t v5 = 0;
        uint64_t v6 = a1 + 136 * v2;
        do
        {
          uint64_t v7 = v6 + v5;
          if (*(unsigned char *)(v6 + v5 + 1240) && *(unsigned char *)(v7 + 1242))
          {
            uint64_t v8 = *(void **)(v6 + v5 + 1232);
            if (v8)
            {
              *(unsigned char *)(v7 + 1240) = 0;
              _apfs_free(v8, 136);
              *(void *)(v6 + v5 + 1232) = 0;
            }
          }
          v5 += 32;
        }
        while (v5 != 128);
      }
      char v3 = 0;
      uint64_t v2 = 1;
    }
    while ((v4 & 1) != 0);
  }
}

uint64_t sub_100003DE8(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4)
{
  if (!a1) {
    return 22;
  }
  uint64_t v6 = *(void *)(a1 + 376);
  unint64_t v7 = *(void *)(v6 + 48 * a2 + 56);
  if (v7 <= a4) {
    return 22;
  }
  uint64_t v8 = a2;
  uint64_t v9 = v6 + 48 * a2;
  uint64_t v10 = a1 + 136 * a2;
  uint64_t v11 = v10 + 1216;
  uint64_t v12 = v10 + 1216 + 32 * a3;
  uint64_t v13 = *(unsigned __int16 **)(v12 + 16);
  unint64_t v14 = *(unsigned int *)(v6 + 36);
  unint64_t v15 = *(void *)(v9 + 48);
  unint64_t v16 = *(void *)v12;
  if (*(unsigned char *)(v12 + 26)) {
    BOOL v17 = v13 == 0;
  }
  else {
    BOOL v17 = 0;
  }
  if (v17)
  {
    uint64_t v30 = v10 + 1216;
    uint64_t v18 = a3;
    uint64_t v13 = (unsigned __int16 *)_apfs_calloc(1uLL, 0x88uLL);
    a3 = v18;
    uint64_t v11 = v30;
    *(void *)(v12 + 16) = v13;
    if (!v13) {
      return 12;
    }
  }
  if (*(unsigned char *)(v12 + 24))
  {
    uint64_t v19 = 0;
    uint64_t v20 = v13[65];
    while (1)
    {
      uint64_t v21 = ((unint64_t)(v20 + v19) * (unsigned __int128)0x2492492492492493uLL) >> 64;
      uint64_t v22 = v20 + v19 - 7 * ((v21 + ((unint64_t)(v20 + v19 - v21) >> 1)) >> 2);
      uint64_t v23 = &v13[8 * v22];
      if (*((void *)v23 + 3))
      {
        if (*((void *)v23 + 2) / (unint64_t)*(unsigned int *)(*(void *)(a1 + 376) + 36) == a4) {
          break;
        }
      }
      if (++v19 == 7) {
        goto LABEL_19;
      }
    }
    if (v22 == v20)
    {
LABEL_19:
      *(_OWORD *)&v13[8 * v20 + 8] = *(_OWORD *)v12;
      v13[65] = v20
              + 1
              - 7
              * ((((unsigned __int16)(v20 + 1 - ((9363 * (unsigned __int16)(v20 + 1)) >> 16)) >> 1)
                + ((9363 * (unsigned __int16)(v20 + 1)) >> 16)) >> 2);
      goto LABEL_20;
    }
    do
    {
      if (v22 == 6) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = v22 + 1;
      }
      *(_OWORD *)&v13[8 * v22 + 8] = *(_OWORD *)&v13[8 * v27 + 8];
      uint64_t v22 = v27;
    }
    while (v27 != v20);
    uint64_t v28 = v20 - 1;
    BOOL v17 = v20 == 0;
    uint64_t v29 = 6;
    if (!v17) {
      uint64_t v29 = v28;
    }
    *(_OWORD *)&v13[8 * v29 + 8] = *(_OWORD *)v12;
  }
LABEL_20:
  *(void *)uint64_t v12 = v14 * a4;
  if (v7 - 1 == a4) {
    unint64_t v25 = v15;
  }
  else {
    unint64_t v25 = v14 + v14 * a4;
  }
  *(void *)uint64_t v13 = v14 * a4;
  *((void *)v13 + 1) = v25;
  uint64_t v26 = v11 + 32 * a3;
  *(void *)(v26 + 8) = v25;
  v13[64] = a3 + 1;
  *(unsigned char *)(v26 + 25) = 0;
  if (*(unsigned char *)(v12 + 24)) {
    *(_DWORD *)(*(void *)(a1 + 8 * v8 + 1488) + 4 * (v16 / v14)) &= ~0x8000000u;
  }
  uint64_t result = 0;
  *(_DWORD *)(*(void *)(a1 + 8 * v8 + 1488) + 4 * a4) |= 0x8000000u;
  return result;
}

uint64_t spaceman_get_number_of_disabled_allocation_zones(uint64_t result, unsigned int a2)
{
  if (result)
  {
    if (*(unsigned char *)(result + 136 * a2 + 1344))
    {
      uint64_t v2 = 0;
      uint64_t v3 = result + 136 * a2;
      uint64_t result = 4;
      do
      {
        if (*(unsigned char *)(v3 + v2 + 1240) || !*(unsigned char *)(v3 + v2 + 1241)) {
          uint64_t result = (result - 1);
        }
        v2 += 32;
      }
      while (v2 != 128);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t spaceman_evaluate_chunk_for_disabled_allocation_zones(uint64_t a1, unsigned int a2, unint64_t a3, unsigned char *a4)
{
  if (!a1 || !*(unsigned char *)(a1 + 136 * a2 + 1344) || *(void *)(*(void *)(a1 + 376) + 48 * a2 + 56) <= a3) {
    return 22;
  }
  unint64_t v5 = 0;
  for (i = (unsigned char *)(a1 + 136 * a2 + 1241); ; i += 32)
  {
    if (!*(i - 1) && *i)
    {
      int v7 = *(_DWORD *)(*(void *)(a1 + 8 * a2 + 1488) + 4 * a3);
      int v8 = v7 & 0xC000000;
      unint64_t v9 = *(void *)&v7 & 0xFFFFFFLL;
      if (!v8 && v5 < v9) {
        break;
      }
    }
    if (++v5 == 4) {
      return 0;
    }
  }
  uint64_t v13 = sub_100003DE8(a1, a2, v5, a3);
  if (v13)
  {
    uint64_t v11 = v13;
    log_err((uint64_t)"%s:%d: %s failed to assign chunk %llu to allocation zone %llu\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"spaceman_evaluate_chunk_for_disabled_allocation_zones");
  }
  else
  {
    log_debug((uint64_t)"%s:%d: %s allocation zone on dev %d for allocations of %llu blocks starting at paddr %llu\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"spaceman_evaluate_chunk_for_disabled_allocation_zones");
    uint64_t v11 = 0;
    *(i - 1) = 1;
    *a4 = 1;
  }
  return v11;
}

uint64_t spaceman_get_new_chunk_for_allocation_zone(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t v4 = 22;
  if (a1)
  {
    uint64_t v5 = a2;
    if (a2)
    {
      if (a3 <= 1 && a4 <= 3)
      {
        int v7 = *(unsigned int **)(a2 + 376);
        v98 = 0;
        unint64_t v99 = 0;
        v96 = 0;
        unint64_t v97 = 0;
        v94 = 0;
        v95 = 0;
        uint64_t v8 = a3;
        uint64_t v9 = a2 + 136 * a3 + 32 * a4;
        unint64_t v10 = *(void *)(v9 + 1216);
        unint64_t v11 = v7[9];
        uint64_t v12 = *(void *)(v9 + 1232);
        unint64_t v13 = *(void *)&v7[12 * a3 + 14];
        if (!v12) {
          goto LABEL_14;
        }
        uint64_t v14 = *(unsigned __int16 *)(v12 + 130);
        uint64_t v15 = 7;
        while (1)
        {
          unint64_t v16 = *(void *)(v12 + 16 * v14 + 24);
          if (v16 && v16 <= *(void *)&v7[12 * a3 + 12])
          {
            unint64_t v17 = *(void *)(v12 + 16 * v14 + 16) / v11;
            int v18 = *(_DWORD *)(*(void *)(a2 + 8 * a3 + 1488) + 4 * v17);
            int v19 = v18 & 0xC000000;
            unint64_t v20 = *(void *)&v18 & 0xFFFFFFLL;
            if (!v19 && v20 > a4) {
              break;
            }
          }
          uint64_t v14 = ((unsigned __int16)v14
                             + 1
                             - 7 * ((613566757 * (unint64_t)((unsigned __int16)v14 + 1)) >> 32));
          if (!--v15) {
            goto LABEL_14;
          }
        }
        if (v17 < v13)
        {
          unint64_t v31 = 0;
LABEL_55:
          uint64_t v72 = sub_100003DE8(v5, a3, a4, v17);
          if (v72)
          {
            uint64_t v4 = v72;
            log_err((uint64_t)"%s:%d: %s failed to update allocate zone %llu: error %d\n", v73, v74, v75, v76, v77, v78, v79, (uint64_t)"spaceman_get_new_chunk_for_allocation_zone");
          }
          else
          {
            uint64_t v81 = *(void *)(v5 + 1584);
            if (v81) {
              ++*(void *)(v81 + (v8 << 6) + 8 * a4 + 120);
            }
            if (*(_DWORD *)(v5 + 1592))
            {
              v82 = (uint64_t *)(*(void *)(v5 + 1600) + 16 * *(unsigned int *)(v5 + 1596));
              uint64_t v4 = 0;
              uint64_t *v82 = get_timestamp();
              v82[1] = v8 & 1 | (2 * (a4 & 7)) & 0xF | (v31 << 44) | (16 * (v17 & 0xFFFFFFFFFFLL));
              int v83 = *(_DWORD *)(v5 + 1596);
              if ((v83 + 1) < *(_DWORD *)(v5 + 1592)) {
                int v84 = v83 + 1;
              }
              else {
                int v84 = 0;
              }
              *(_DWORD *)(v5 + 1596) = v84;
            }
            else
            {
              uint64_t v4 = 0;
            }
          }
        }
        else
        {
LABEL_14:
          unint64_t v22 = v10 / v11;
          unint64_t v23 = v7[10];
          unint64_t v24 = v13 - 1;
          unint64_t v26 = v22 + 1 == v23 || v22 == v24;
          uint64_t v27 = &v7[12 * a3];
          unsigned int v30 = v27[16];
          uint64_t v29 = v27 + 16;
          LODWORD(v28) = v30;
          if (v30 > v26)
          {
            unint64_t v31 = 0;
            uint64_t v91 = 0;
            unint64_t v86 = v22;
            v88 = &v7[12 * a3 + 17];
            uint64_t v89 = (v22 / v23);
            uint64_t v32 = a2 + 8 * a3;
            v87 = (void *)(v32 + 888);
            uint64_t v33 = (void *)(v32 + 1488);
            int v90 = -1;
            unint64_t v17 = -1;
            uint64_t v34 = v29;
            do
            {
              unint64_t v35 = (v89 + v26) % v28;
              if (*v88)
              {
                unsigned int v36 = v7[11];
                unsigned int v37 = v35 / v36;
                int v38 = v90;
                uint64_t v39 = v91;
                if (v35 / v36 != v90 || v91 == 0)
                {
                  uint64_t v41 = *(void *)(*v87 + 8 * v37);
                  if (v95)
                  {
                    obj_release(v95);
                    v95 = 0;
                  }
                  v98 = v7;
                  unint64_t v99 = __PAIR64__(v37, a3);
                  uint64_t v42 = obj_get(*(void *)(a1 + 392), 0x40000000, v41, &sm_cab_desc, &v98, 0, 0, 0, &v95);
                  if (v42)
                  {
                    uint64_t v4 = v42;
                    log_err((uint64_t)"%s:%d: %s error getting cab %d: %d\n", v43, v44, v45, v46, v47, v48, v49, (uint64_t)"spaceman_get_new_chunk_for_allocation_zone");
                    goto LABEL_58;
                  }
                  uint64_t v39 = v95[7];
                  unsigned int v36 = v7[11];
                  int v38 = v37;
                }
                int v90 = v38;
                uint64_t v91 = v39;
                uint64_t v50 = (uint64_t *)(v39 + 8 * (v35 - v36 * v38) + 40);
              }
              else
              {
                uint64_t v50 = (uint64_t *)(*v87 + 8 * v35);
              }
              uint64_t v51 = *v50;
              v96 = v7;
              unint64_t v97 = __PAIR64__(v35, a3);
              uint64_t v52 = obj_get(*(void *)(a1 + 392), 0x40000000, v51, &sm_cib_desc, &v96, 0, 0, 0, &v94);
              if (v52)
              {
                uint64_t v4 = v52;
                log_err((uint64_t)"%s:%d: %s error getting cib %d: %d\n", v53, v54, v55, v56, v57, v58, v59, (uint64_t)"spaceman_get_new_chunk_for_allocation_zone");
                goto LABEL_58;
              }
              if (v26) {
                LODWORD(v60) = 0;
              }
              else {
                LODWORD(v60) = v86 % v7[10] + 1;
              }
              uint64_t v61 = v94[7];
              unsigned int v62 = *(_DWORD *)(v61 + 36);
              BOOL v63 = v62 >= v60;
              int v64 = v62 - v60;
              if (v64 != 0 && v63)
              {
                unint64_t v65 = v35 * v7[10];
                uint64_t v60 = v60;
                v66 = (int *)(v61 + 32 * v60 + 60);
                unint64_t v67 = v17;
                do
                {
                  int v68 = *v66;
                  v66 += 8;
                  unint64_t v69 = v68 & 0xFFFFF;
                  if (v31 < v69)
                  {
                    unint64_t v17 = v65 + v60;
                    int v70 = *(_DWORD *)(*v33 + 4 * (v65 + v60));
                    if ((v70 & 0xC000000) == 0 && (*(void *)&v70 & 0xFFFFFFuLL) > a4)
                    {
                      unint64_t v31 = v69;
                      unint64_t v67 = v65 + v60;
                      if (v69 == v7[9]) {
                        break;
                      }
                    }
                  }
                  ++v60;
                  unint64_t v17 = v67;
                  --v64;
                }
                while (v64);
              }
              if (v31 == v7[9]) {
                break;
              }
              obj_release(v94);
              v94 = 0;
              ++v26;
              unint64_t v28 = *v34;
            }
            while (v26 < v28);
            uint64_t v8 = a3;
            uint64_t v5 = a2;
            if (v17 != -1) {
              goto LABEL_55;
            }
          }
          uint64_t v4 = 28;
        }
LABEL_58:
        if (v95) {
          obj_release(v95);
        }
        if (v94) {
          obj_release(v94);
        }
      }
    }
  }
  return v4;
}

BOOL spaceman_should_avoid_data_allocation_at_block(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4)
{
  if (!a4) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8 * a2 + 1488);
  if (!v4) {
    return 0;
  }
  if (*(unsigned char *)(a1 + 104 * a2 + 1104))
  {
    uint64_t v5 = a1 + 104 * a2;
    uint64_t v6 = (unint64_t *)(*(unsigned char *)(v5 + 1098) ? v5 + 1080 : v5 + 1048);
    if (*(void *)(v5 + 1008) <= a3 && *v6 > a3) {
      return 1;
    }
  }
  if ((*(_DWORD *)(v4 + 4 * (a3 / *(unsigned int *)(*(void *)(a1 + 376) + 36))) & 0x8000000) == 0) {
    return 0;
  }
  if (a4 <= 4
    && (uint64_t v8 = a4 - 1, v9 = a1 + 136 * a2 + 1216, *(unsigned char *)(v9 + 32 * (a4 - 1) + 24))
    && *(void *)(v9 + 32 * v8) <= a3)
  {
    return *(void *)(v9 + 32 * v8 + 8) <= a3;
  }
  else
  {
    return 1;
  }
}

BOOL spaceman_clip_extent(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, __int16 a5, unint64_t a6, unint64_t *a7, unint64_t *a8)
{
  unint64_t v19 = 0;
  unint64_t v14 = calc_overlap_range(a1, a2, a3, a4, &v19);
  if (v14)
  {
    unint64_t v15 = a2 - v14;
    if (a2 == v14)
    {
      unint64_t v16 = 0;
LABEL_17:
      *a8 = v16;
      return v14 != 0;
    }
    unint64_t v16 = v19 - a1;
    if (v19 == a1)
    {
      unint64_t v17 = v14 + a1;
LABEL_9:
      *a7 = v17;
LABEL_10:
      unint64_t v16 = v15;
      goto LABEL_17;
    }
    unint64_t v15 = a2 - (v16 + v14);
    if ((a5 & 0x4000) != 0)
    {
      if (a6 > v19 && a2 != v16 + v14 && (v19 + v14 <= a6 || a6 - v19 > v19 + v14 - a6))
      {
        *a7 = v19 + v14;
        goto LABEL_10;
      }
    }
    else if (v15 > v16)
    {
      unint64_t v17 = v19 + v14;
      goto LABEL_9;
    }
    *a7 = a1;
    goto LABEL_17;
  }
  return v14 != 0;
}

uint64_t spaceman_clip_extent_to_zones(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, uint64_t a5, __int16 a6, unint64_t a7, unint64_t *a8, unint64_t *a9)
{
  uint64_t v12 = a5;
  unint64_t v13 = a4;
  uint64_t v16 = *(void *)(a1 + 1760);
  if (v16
    && !*(unsigned char *)(a1 + 636)
    && (uint64_t v17 = *(void *)(a1 + 1752),
        char v18 = __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36))),
        (((v17 << v18) & 0x4000000000000000) != 0) == a3))
  {
    uint64_t v19 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v18;
    unint64_t v20 = v19 & v17;
    if ((a6 & 0x200) != 0)
    {
      if (v20 && (v31 = v19 & v17, v32 = spaceman_clip_extent(a4, a5, 0, v19 & v17, a6, a7, a8, a9), unint64_t v20 = v31, v32))
      {
        unint64_t v13 = *a8;
        uint64_t v12 = *a9;
        char v21 = 1;
      }
      else
      {
        char v21 = 0;
      }
      v20 += v16;
      uint64_t v16 = *(void *)(*(void *)(a2 + 376) + 48 * a3 + 48) - v20;
    }
    else
    {
      char v21 = 0;
    }
    if (spaceman_clip_extent(v13, v12, v20, v16, a6, a7, a8, a9))
    {
      unint64_t v13 = *a8;
      uint64_t v12 = *a9;
      char v21 = 1;
    }
  }
  else
  {
    char v21 = 0;
  }
  if ((a6 & 0x2000) != 0)
  {
    unsigned int v22 = a3;
    if (*(unsigned char *)(a2 + 104 * a3 + 1104))
    {
      uint64_t v23 = a2 + 104 * a3;
      unint64_t v24 = *(void *)(v23 + 1008);
      int v25 = *(unsigned __int8 *)(v23 + 1098);
      unint64_t v26 = (void *)(v23 + 1080);
      uint64_t v27 = (void *)(v23 + 1048);
      if (v25) {
        uint64_t v27 = v26;
      }
      if (spaceman_clip_extent(v13, v12, v24, *v27 - v24, a6, a7, a8, a9))
      {
        unint64_t v13 = *a8;
        uint64_t v12 = *a9;
        char v21 = 1;
      }
    }
    if (*(unsigned char *)(a2 + 136 * a3 + 1344))
    {
      uint64_t v28 = 0;
      uint64_t v29 = a2 + 136 * v22;
      do
      {
        if (*(unsigned char *)(v29 + v28 + 1240)
          && spaceman_clip_extent(v13, v12, *(void *)(v29 + v28 + 1216), *(void *)(v29 + v28 + 1224) - *(void *)(v29 + v28 + 1216), a6, a7, a8, a9))
        {
          unint64_t v13 = *a8;
          uint64_t v12 = *a9;
          char v21 = 1;
        }
        v28 += 32;
      }
      while (v28 != 128);
    }
  }
  return v21 & 1;
}

uint64_t spaceman_free_extent_cache_init(uint64_t a1, uint64_t a2, unsigned __int8 a3, unsigned int a4, char *a5)
{
  if (a4) {
    size_t v5 = a4;
  }
  else {
    size_t v5 = 0x10000;
  }
  if ((v5 - 65537) < 0xFFFF0001) {
    return 22;
  }
  bzero(a5, 0x558uLL);
  if (!a1 || (uint64_t result = new_lock((pthread_mutex_t *)(a5 + 16)), !result))
  {
    *(void *)a5 = a1;
    *((void *)a5 + 1) = a2;
    *((_DWORD *)a5 + 22) = a3 | (v5 << 8);
    unint64_t v11 = _apfs_calloc(v5, 0x18uLL);
    *((void *)a5 + 10) = v11;
    if (v11)
    {
      sub_100004BA4((uint64_t)a5);
      return 0;
    }
    else
    {
      if (a1) {
        free_lock((pthread_mutex_t *)(a5 + 16));
      }
      return 12;
    }
  }
  return result;
}

uint64_t sub_100004BA4(uint64_t result)
{
  unsigned int v1 = *(_DWORD *)(result + 88);
  if (v1 <= 0x2FF)
  {
    int v5 = (v1 >> 8) - 1;
    uint64_t v2 = *(void *)(result + 80);
  }
  else
  {
    uint64_t v2 = *(void *)(result + 80);
    int v3 = 1;
    int v4 = 1;
    do
    {
      *(void *)(v2 + 24 * (unsigned __int16)v4++) = (v3 + 1);
      int v3 = (unsigned __int16)v4;
      int v5 = (*(_DWORD *)(result + 88) >> 8) - 1;
    }
    while (v5 > (unsigned __int16)v4);
  }
  *(void *)(v2 + 24 * v5) = 0;
  *(_WORD *)(result + 92) = 1;
  return result;
}

void spaceman_free_extent_cache_destroy(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 80);
    if (v2)
    {
      _apfs_free(v2, 24 * ((unint64_t)*(unsigned int *)(a1 + 88) >> 8));
      *(void *)(a1 + 80) = 0;
    }
    if (*(void *)a1)
    {
      free_lock((pthread_mutex_t *)(a1 + 16));
      *(void *)a1 = 0;
    }
  }
}

void spaceman_free_extent_cache_reset(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 88);
  if (HIBYTE(v2))
  {
    uint64_t v4 = *(void *)a1;
    uint64_t v3 = *(void *)(a1 + 8);
    spaceman_free_extent_cache_destroy(a1);
    if (spaceman_free_extent_cache_init(v4, v3, v2, (unsigned __int16)(v2 >> 8), (char *)a1))
    {
      log_err((uint64_t)"%s:%d: %s dev %d Error reinitializing %s free extent cache: %d\n", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"spaceman_free_extent_cache_reset");
      *(void *)(a1 + 280) |= 2uLL;
    }
  }
  else
  {
    bzero((void *)(a1 + 92), 0x4FCuLL);
    bzero(*(void **)(a1 + 80), 24 * (unsigned __int16)(v2 >> 8));
    sub_100004BA4(a1);
  }
}

uint64_t spaceman_free_extent_cache_scan_should_pause(uint64_t a1, unint64_t a2)
{
  if (a2 <= 1) {
    unint64_t v2 = 1;
  }
  else {
    unint64_t v2 = a2;
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 8) + 376) + 48 * *(unsigned __int8 *)(a1 + 88) + 56) / v2 > 0x64) {
    return 0;
  }
  if (*(void *)a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  }
  if ((*(unsigned char *)(a1 + 280) & 2) != 0 || (*(_DWORD *)(a1 + 88) >> 8) - 1 > *(unsigned __int16 *)(a1 + 94)) {
    goto LABEL_15;
  }
  unint64_t v5 = *(void *)(a1 + 176);
  if (v5 <= *(void *)(a1 + 224)) {
    unint64_t v5 = *(void *)(a1 + 224);
  }
  if (v5 < *(void *)(a1 + 248) || (uint64_t v6 = *(void *)(a1 + 128), (unint64_t)(v6 - *(void *)(a1 + 120)) > 3))
  {
LABEL_15:
    uint64_t v3 = 0;
  }
  else
  {
    *(void *)(a1 + 328) = v6;
    uint64_t v3 = 1;
  }
  if (*(void *)a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  return v3;
}

void spaceman_free_extent_cache_print_stats(void *a1)
{
  unint64_t v35 = 0;
  if (!spaceman_get(a1, &v35))
  {
    uint64_t v6 = 0;
    for (char i = 1; ; char i = 0)
    {
      char v8 = i;
      unint64_t v9 = *(void *)(v35[47] + 48 * v6 + 48);
      if (!v9) {
        goto LABEL_22;
      }
      uint64_t v10 = v35[v6 + 196];
      if (!v10) {
        goto LABEL_22;
      }
      char v34 = i;
      if (*(void *)v10) {
        pthread_mutex_lock((pthread_mutex_t *)(v10 + 16));
      }
      sub_1000071A0(v10, v10 + 1264, 1u, v1, v2, v3, v4, v5);
      if (sub_1000083A4(v10, v10 + 1264, v11, v12, v13, v14, v15, v16))
      {
        uint64_t v22 = 0;
      }
      else
      {
        uint64_t v33 = *(void *)(*(void *)(v10 + 80)
                        + 24 * *(unsigned __int16 *)(v10 + 1264 + 4 * *(unsigned __int8 *)(v10 + 1361))) & 0xFFFFFFFFFFFFFLL;
        if (sub_1000071A0(v10, v10 + 1264, 0, v17, v18, v19, v20, v21)) {
          uint64_t v22 = v33;
        }
        else {
          uint64_t v22 = v33;
        }
      }
      log_info((uint64_t)"%s:%d: %s dev %d smfree %lld/%lld table %d/%d blocks %lld %lld:%lld:%lld %d.%02d%% range %lld:%lld %d.%02d%% scans %lld\n", *(void *)(v10 + 336), v22, v17, v18, v19, v20, v21, (uint64_t)"spaceman_fxc_print_stats");
      uint64_t v24 = v10 + 272;
      uint64_t v25 = 3;
      do
      {
        if (*(void *)(v24 - 32)) {
          log_info((uint64_t)"%s:%d: %s dev %d scan_stats[%d]: foundmax %lld extents %lld blocks %lld long %lld avg %lld %d.%02d%% range %lld:%lld %d.%02d%%\n", *(void *)(v24 - 16), 10000 * *(void *)(v24 - 8) / v9 / 0x64, v25 - 1, v2, v3, v4, v5, (uint64_t)"spaceman_fxc_print_stats");
        }
        v24 -= 48;
        --v25;
      }
      while (v25);
      if (*(void *)(v10 + 344))
      {
        log_info((uint64_t)"%s:%d: %s dev %d Searches: %lld success %lld fail %lld partial %lld, bm search yes:%lld (%lld/%lld/%lld) no:%lld/%lld\n", *(unsigned __int8 *)(v10 + 88), v23, v1, v2, v3, v4, v5, (uint64_t)"spaceman_fxc_print_stats");
        char v8 = v34;
        log_info((uint64_t)"%s:%d: %s dev %d Remainders: zero %lld one %lld tiny %lld small %lld good %lld, total %lld blocks %lld avg %lld\n", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"spaceman_fxc_print_stats");
        if (!*(void *)v10) {
          goto LABEL_22;
        }
      }
      else
      {
        char v8 = v34;
        if (!*(void *)v10) {
          goto LABEL_22;
        }
      }
      pthread_mutex_unlock((pthread_mutex_t *)(v10 + 16));
LABEL_22:
      uint64_t v6 = 1;
      if ((v8 & 1) == 0)
      {
        obj_release(v35);
        return;
      }
    }
  }
}

uint64_t spaceman_free_extent_cache_setup(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = 0;
  for (char i = 1; ; char i = 0)
  {
    char v6 = i;
    uint64_t v7 = a2 + 8 * v4;
    if (!*(void *)(v7 + 1568))
    {
      unint64_t v8 = *(void *)(*(void *)(a2 + 376) + 48 * v4 + 48);
      if (v8)
      {
        uint64_t v9 = v7 + 1568;
        uint64_t v10 = (char *)_apfs_calloc(1uLL, 0x558uLL);
        *(void *)uint64_t v9 = v10;
        if (!v10)
        {
          uint64_t v20 = 12;
          goto LABEL_13;
        }
        unint64_t v18 = v8 >> 18;
        if (v8 >> 18 >= 0xFF80) {
          LODWORD(v18) = 65408;
        }
        uint64_t v19 = spaceman_free_extent_cache_init(a1, a2, v4, (int)v18 + 128, v10);
        if (v19) {
          break;
        }
      }
    }
    uint64_t v4 = 1;
    if ((v6 & 1) == 0) {
      return 0;
    }
  }
  uint64_t v20 = v19;
  if (*(void *)v9) {
    *(void *)(*(void *)v9 + 280) |= 2uLL;
  }
LABEL_13:
  log_err((uint64_t)"%s:%d: %s failed to initialize free extent cache for device %d, error %d\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"spaceman_free_extent_cache_setup");
  return v20;
}

uint64_t spaceman_free_extent_cache_insert(unint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 22;
  }
  unint64_t v8 = a4;
  if ((a4 | (unint64_t)a3) >> 52) {
    return 84;
  }
  if (!a4) {
    return 0;
  }
  if (*(void *)a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  }
  uint64_t v12 = *(void *)(a1 + 280);
  if ((v12 & 2) == 0)
  {
    unint64_t v13 = a1 + 48 * ((v12 & 4) == 0);
    unint64_t v15 = *(void *)(v13 + 176);
    uint64_t v14 = (unint64_t *)(v13 + 176);
    if (v15 < v8) {
      *uint64_t v14 = v8;
    }
    unsigned __int16 v112 = 0;
    int v16 = sub_100005AF4(a1, v8, a3, a4, a5, a6, a7, a8);
    if (v16 == 55)
    {
      unint64_t v17 = a1 + 16 * (a2 ^ 1u);
      uint64_t v18 = *(void *)(v17 + 296);
      if (v18)
      {
        if (v18 < a3 && v8 + a3 < *(void *)(v17 + 304))
        {
          uint64_t v19 = (uint64_t *)(v17 + 296);
          sub_100005D24(a1, a3, v8);
          uint64_t v20 = 0;
          *uint64_t v19 = a3;
          goto LABEL_28;
        }
      }
    }
    uint64_t v21 = *(void *)a1;
    unint64_t v22 = a3;
    if (*(unsigned char *)(a1 + 88) == 1) {
      unint64_t v22 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v21 + 376) + 36)))) | a3;
    }
    if (spaceman_extent_check(v21, *(void *)(a1 + 8), v22, v8))
    {
      if (nx_ratelimit_log_allowed(*(void *)a1)) {
        log_err((uint64_t)"%s:%d: %s dev %d free extent %lld:%lld appears to span container metadata and should not be free: %d\n", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"spaceman_free_extent_cache_insert");
      }
      goto LABEL_25;
    }
    uint64_t v33 = (_OWORD *)(a1 + 1068);
    uint64_t v20 = sub_100005D68(a1, 0, a3, v8, a1 + 1068, v23, v24, v25);
    if (v20) {
      goto LABEL_27;
    }
    int v42 = *((unsigned __int16 *)v33 + 2 * *(unsigned __int8 *)(a1 + 1165));
    uint64_t v43 = (_OWORD *)(a1 + 1166);
    long long v44 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v44;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    long long v45 = *(_OWORD *)(a1 + 1084);
    *(_OWORD *)(a1 + 1166) = *v33;
    *(_OWORD *)(a1 + 1182) = v45;
    long long v46 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v46;
    if (v42)
    {
      uint64_t v20 = 0;
    }
    else
    {
      uint64_t v77 = sub_10000854C(a1, a1 + 1166, 0xFFFFFFFFLL, v36, v37, v38, v39, v40);
      uint64_t v20 = v77;
      if ((v77 & 0xFFFFFFFD) != 0) {
        goto LABEL_27;
      }
      if (v77 == 2)
      {
        uint64_t v20 = 2;
        goto LABEL_34;
      }
    }
    uint64_t v37 = *((unsigned __int16 *)v43 + 2 * *(unsigned __int8 *)(a1 + 1263));
    uint64_t v47 = (void *)(*(void *)(a1 + 80) + 24 * v37);
    uint64_t v48 = *v47 & 0xFFFFFFFFFFFFFLL;
    unint64_t v35 = v47[1] & 0xFFFFFFFFFFFFFLL;
    if (v35 + v48 >= a3)
    {
      unint64_t v8 = v8 + a3 - v48;
      long long v78 = *(_OWORD *)(a1 + 1246);
      *(_OWORD *)(a1 + 1132) = *(_OWORD *)(a1 + 1230);
      *(_OWORD *)(a1 + 1148) = v78;
      *(_WORD *)(a1 + 1164) = *(_WORD *)(a1 + 1262);
      long long v79 = *(_OWORD *)(a1 + 1182);
      *uint64_t v33 = *v43;
      *(_OWORD *)(a1 + 1084) = v79;
      long long v80 = *(_OWORD *)(a1 + 1214);
      *(_OWORD *)(a1 + 1100) = *(_OWORD *)(a1 + 1198);
      *(_OWORD *)(a1 + 1116) = v80;
      if (v8 <= v35)
      {
        if (!v20) {
          goto LABEL_28;
        }
        uint64_t v20 = 1;
        goto LABEL_27;
      }
      uint64_t v20 = sub_100005EA8(a1, v48, v35, v8, v37, v38, v39, v40);
      if (v20) {
        goto LABEL_27;
      }
      unint64_t v81 = a1 + 48 * ((*(_DWORD *)(a1 + 280) & 4) == 0);
      unint64_t v83 = *(void *)(v81 + 176);
      v82 = (unint64_t *)(v81 + 176);
      if (v83 < v8) {
        unint64_t *v82 = v8;
      }
      sub_1000061AC(a1, v48, v8);
      uint64_t v20 = 0;
LABEL_35:
      int v49 = *(char *)(a1 + 1165);
      if (v49 < 0 || *((_WORD *)v33 + 2 * *(unsigned __int8 *)(a1 + 1165)))
      {
LABEL_37:
        unsigned int v110 = *((unsigned __int16 *)v33 + 2 * v49);
        unint64_t v111 = v8 + v48;
        unint64_t v50 = v8;
        uint64_t v109 = v48;
        while (1)
        {
          if (v20) {
            goto LABEL_27;
          }
          long long v51 = *(_OWORD *)(a1 + 1148);
          *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
          *(_OWORD *)(a1 + 1246) = v51;
          *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
          long long v52 = *(_OWORD *)(a1 + 1084);
          *uint64_t v43 = *v33;
          *(_OWORD *)(a1 + 1182) = v52;
          long long v53 = *(_OWORD *)(a1 + 1116);
          *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
          *(_OWORD *)(a1 + 1214) = v53;
          uint64_t v54 = sub_10000854C(a1, a1 + 1166, 1, v36, v37, v38, v39, v40);
          if (v54) {
            break;
          }
          unsigned int v55 = *((unsigned __int16 *)v43 + 2 * *(unsigned __int8 *)(a1 + 1263));
          uint64_t v56 = *(void *)(a1 + 80);
          unint64_t v57 = *(void *)(v56 + 24 * *((unsigned __int16 *)v43 + 2 * *(unsigned __int8 *)(a1 + 1263))) & 0xFFFFFFFFFFFFFLL;
          if (v111 < v57) {
            goto LABEL_62;
          }
          unint64_t v58 = *(void *)(v56 + 24 * *((unsigned __int16 *)v43 + 2 * *(unsigned __int8 *)(a1 + 1263)) + 8) & 0xFFFFFFFFFFFFFLL;
          if (v58 + v57 >= v111) {
            unint64_t v59 = v58 + v57 - v111;
          }
          else {
            unint64_t v59 = 0;
          }
          sub_100006778(a1, a1 + 1166);
          uint64_t v63 = sub_100005D68(a1, 1u, v57, v58, a1 + 1068, v60, v61, v62);
          if (v63)
          {
            uint64_t v20 = v63;
LABEL_71:
            log_err((uint64_t)"%s:%d: %s dev %d Failed to find successor node in length tree: %d\n", v64, v65, v66, v67, v68, v69, v70, (uint64_t)"spaceman_free_extent_cache_insert");
            goto LABEL_27;
          }
          if (!*((_WORD *)v33 + 2 * *(unsigned __int8 *)(a1 + 1165)))
          {
            uint64_t v20 = 2;
            goto LABEL_71;
          }
          if (v57 == *(void *)(a1 + 112))
          {
            if (v58 != *(void *)(a1 + 120)) {
              sub_10005D2B0();
            }
            long long v71 = *(_OWORD *)(a1 + 1148);
            *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
            *(_OWORD *)(a1 + 1246) = v71;
            *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
            long long v72 = *(_OWORD *)(a1 + 1084);
            *uint64_t v43 = *v33;
            *(_OWORD *)(a1 + 1182) = v72;
            long long v73 = *(_OWORD *)(a1 + 1116);
            *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
            *(_OWORD *)(a1 + 1214) = v73;
            sub_100006BB8((int8x16_t *)a1, a1 + 1166, v65, v66, v67, v68, v69, v70);
          }
          v50 += v59;
          sub_100006778(a1, a1 + 1068);
          sub_1000066E0(a1, v55);
          uint64_t v48 = v109;
          uint64_t v20 = sub_100005D68(a1, 0, v109, v8, a1 + 1068, v74, v75, v76);
          if (*((unsigned __int16 *)v33 + 2 * *(unsigned __int8 *)(a1 + 1165)) != v110) {
            sub_10005D284();
          }
        }
        uint64_t v20 = v54;
        if (v54 != 2) {
          goto LABEL_27;
        }
LABEL_62:
        if (v50 <= v8) {
          goto LABEL_25;
        }
        uint64_t v20 = sub_100005EA8(a1, v48, v8, v50, v110, v38, v39, v40);
        if (!v20)
        {
          unint64_t v84 = a1 + 48 * ((*(_DWORD *)(a1 + 280) & 4) == 0);
          unint64_t v86 = *(void *)(v84 + 176);
          v85 = (unint64_t *)(v84 + 176);
          if (v86 >= v50) {
            goto LABEL_25;
          }
          uint64_t v20 = 0;
          unint64_t *v85 = v50;
          goto LABEL_28;
        }
        goto LABEL_27;
      }
      if (v16 == 55)
      {
        uint64_t v87 = sub_10000854C(a1, a1 + 1068, 1, v36, v37, v38, v39, v40);
        if (v87)
        {
          uint64_t v20 = v87;
          unint64_t v91 = 0x7FFFFFFFFFFFFFFFLL;
          goto LABEL_78;
        }
        unsigned int v98 = *((unsigned __int16 *)v33 + 2 * *(unsigned __int8 *)(a1 + 1165));
        unint64_t v99 = (unint64_t *)(*(void *)(a1 + 80)
                                 + 24 * *((unsigned __int16 *)v33 + 2 * *(unsigned __int8 *)(a1 + 1165)));
        unint64_t v100 = *v99;
        unint64_t v91 = *v99 & 0xFFFFFFFFFFFFFLL;
        if (v8 + v48 < v91)
        {
          uint64_t v20 = 2;
LABEL_78:
          sub_100005D24(a1, v48, v8);
          unint64_t v101 = a1 + 16 * (a2 ^ 1u);
          *(void *)(v101 + 296) = v48;
          *(void *)(v101 + 304) = v91;
          if (v20 != 2) {
            goto LABEL_27;
          }
LABEL_25:
          uint64_t v20 = 0;
          goto LABEL_28;
        }
        unint64_t v102 = v99[1] & 0xFFFFFFFFFFFFFLL;
        unint64_t v103 = v91 - v48 + v102;
        if (v91 == *(void *)(a1 + 112)) {
          *(void *)(a1 + 112) = v48;
        }
        *unint64_t v99 = v100 & 0xFFF0000000000000 | v48;
        uint64_t v20 = sub_100005EA8(a1, v48, v102, v91 - v48 + v102, v98, v88, v89, v90);
        if (v20) {
          goto LABEL_27;
        }
        unint64_t v104 = a1 + 48 * ((*(_DWORD *)(a1 + 280) & 4) == 0);
        unint64_t v106 = *(void *)(v104 + 176);
        v105 = (unint64_t *)(v104 + 176);
        if (v106 >= v103) {
          goto LABEL_25;
        }
        uint64_t v20 = 0;
        unint64_t *v105 = v103;
LABEL_28:
        if (*(void *)a1) {
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
        }
        return v20;
      }
      unsigned __int16 v112 = 0;
      uint64_t v20 = sub_10000622C(a1, v48, v8, &v112, a1 + 1068);
      if (!v20)
      {
        uint64_t v92 = sub_10000654C(a1, 1u, v48, v8, &v112, v38, v39, v40);
        if (!v92)
        {
          uint64_t v107 = *(void *)(a1 + 120);
          if (v107 - 1 >= v8 || v8 == v107 && v48 > *(void *)(a1 + 112))
          {
            *(void *)(a1 + 112) = v48;
            *(void *)(a1 + 120) = v8;
          }
          if (v8 > *(void *)(a1 + 128)) {
            *(void *)(a1 + 128) = v8;
          }
          uint64_t v108 = sub_100005D68(a1, 0, v48, v8, a1 + 1068, v95, v96, v97);
          if (*((unsigned __int16 *)v33 + 2 * *(unsigned __int8 *)(a1 + 1165)) != v112) {
            sub_10005D2DC();
          }
          uint64_t v20 = v108;
          sub_1000061AC(a1, v48, v8);
          LOBYTE(v49) = *(unsigned char *)(a1 + 1165);
          goto LABEL_37;
        }
        uint64_t v20 = v92;
        if (!sub_100006664(a1, v48, v8, v93, v94, v95, v96, v97)) {
          sub_1000066E0(a1, v112);
        }
      }
LABEL_27:
      log_err((uint64_t)"%s:%d: %s dev %d Error %d, reinitializing\n", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"spaceman_free_extent_cache_insert");
      spaceman_free_extent_cache_reset(a1);
      goto LABEL_28;
    }
LABEL_34:
    uint64_t v48 = a3;
    goto LABEL_35;
  }
  if (*(void *)a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  return 45;
}

uint64_t sub_100005AF4(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_WORD *)(a1 + 92)) {
    return 0;
  }
  unint64_t v10 = *(void *)(a1 + 120);
  if (v10 > a2) {
    return 55;
  }
  uint64_t v12 = (void *)(a1 + 112);
  uint64_t v13 = *(void *)(a1 + 112);
  if (v10 == a2 && v13 < a3) {
    return 55;
  }
  if (!v13) {
    return 0;
  }
  unint64_t v15 = (_OWORD *)(a1 + 480);
  if (sub_100005D68(a1, 0, v13, v10, a1 + 480, a6, a7, a8)
    || (uint64_t v23 = 4 * *(unsigned __int8 *)(a1 + 577),
        unsigned int v24 = *(unsigned __int16 *)((char *)v15 + v23),
        !*(_WORD *)((char *)v15 + v23)))
  {
    log_err((uint64_t)"%s:%d: %s dev %d Failed to find smallest extent in paddr tree: %d\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"spaceman_fxc_tree_node_recycle_smallest");
  }
  else
  {
    sub_100006778(a1, a1 + 480);
    if (sub_100005D68(a1, 1u, *(void *)(a1 + 112), *(void *)(a1 + 120), a1 + 480, v25, v26, v27)
      || !*((_WORD *)v15 + 2 * *(unsigned __int8 *)(a1 + 577)))
    {
      log_err((uint64_t)"%s:%d: %s dev %d Failed to find smallest extent %d in length tree: %d\n", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"spaceman_fxc_tree_node_recycle_smallest");
    }
    else
    {
      if (v24 != *((unsigned __int16 *)v15 + 2 * *(unsigned __int8 *)(a1 + 577))) {
        sub_10005D308();
      }
      sub_100005D24(a1, *(void *)(a1 + 112), *(void *)(a1 + 120));
      long long v35 = *(_OWORD *)(a1 + 560);
      *(_OWORD *)(a1 + 642) = *(_OWORD *)(a1 + 544);
      *(_OWORD *)(a1 + 658) = v35;
      *(_WORD *)(a1 + 674) = *(_WORD *)(a1 + 576);
      long long v36 = *(_OWORD *)(a1 + 496);
      *(_OWORD *)(a1 + 578) = *v15;
      *(_OWORD *)(a1 + 594) = v36;
      long long v37 = *(_OWORD *)(a1 + 528);
      *(_OWORD *)(a1 + 610) = *(_OWORD *)(a1 + 512);
      *(_OWORD *)(a1 + 626) = v37;
      int v43 = sub_10000854C(a1, a1 + 578, 1, v38, v39, v40, v41, v42);
      if (!v43)
      {
        *(int8x16_t *)(a1 + 112) = vandq_s8(*(int8x16_t *)(*(void *)(a1 + 80)+ 24* *(unsigned __int16 *)(a1 + 578 + 4* *(unsigned __int8 *)(a1 + 675))), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
        goto LABEL_24;
      }
      if (v43 == 2)
      {
        void *v12 = 0;
        *(void *)(a1 + 120) = 0;
        *(void *)(a1 + 128) = 0;
LABEL_24:
        sub_100006778(a1, a1 + 480);
        sub_1000066E0(a1, v24);
        return 0;
      }
      log_err((uint64_t)"%s:%d: %s dev %d Failed to find next smallest extent in length tree: %d\n", v44, v45, v46, v47, v48, v49, v50, (uint64_t)"spaceman_fxc_tree_node_recycle_smallest");
    }
  }
  return 3;
}

uint64_t sub_100005D24(uint64_t a1, uint64_t a2, unint64_t a3)
{
  BOOL v3 = (*(_DWORD *)(a1 + 280) & 4) == 0;
  uint64_t v4 = a1 + 48 * ((*(_DWORD *)(a1 + 280) & 4) == 0);
  unint64_t v6 = *(void *)(v4 + 152);
  uint64_t v5 = (unint64_t *)(v4 + 152);
  if (v6 < a3) {
    *uint64_t v5 = a3;
  }
  uint64_t v7 = (void *)(a1 + 48 * v3);
  uint64_t v8 = v7[17];
  uint64_t v9 = v7[18];
  v7 += 17;
  *uint64_t v7 = v8 + 1;
  v7[1] = v9 + a3;
  return sub_1000074C4((uint64_t)v7, a2, a3);
}

uint64_t sub_100005D68(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_WORD *)(a5 + 96) = 0;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(unsigned char *)(a5 + 96) = a2;
  uint64_t v13 = *(unsigned __int16 *)(a1 + 2 * a2 + 104);
  *(_WORD *)a5 = v13;
  if (v13)
  {
    if (a2 >= 2) {
      sub_10005D334();
    }
    uint64_t v14 = *(void *)(a1 + 80) + 24 * v13;
    if (a2) {
      char v15 = *(unsigned char *)(v14 + 15);
    }
    else {
      char v15 = *(unsigned char *)(v14 + 7);
    }
    *(unsigned char *)(a5 + 2) = v15;
  }
  uint64_t v16 = 4 * *(unsigned __int8 *)(a5 + 97);
  unsigned int v17 = *(unsigned __int16 *)(a5 + v16);
  if (*(_WORD *)(a5 + v16))
  {
    do
    {
      uint64_t v18 = *(void *)(a1 + 80);
      uint64_t v19 = (void *)(v18 + 24 * v17);
      if (a2)
      {
        unint64_t v20 = *(void *)(v18 + 24 * v17 + 8) & 0xFFFFFFFFFFFFFLL;
        BOOL v21 = v20 > a4;
        int v22 = v20 < a4;
        if (v21) {
          int v22 = -1;
        }
        if (!v22)
        {
          uint64_t v23 = *v19 & 0xFFFFFFFFFFFFFLL;
          int v22 = v23 > a3;
          if (v23 < a3) {
            goto LABEL_19;
          }
        }
      }
      else
      {
        uint64_t v24 = *v19 & 0xFFFFFFFFFFFFFLL;
        int v22 = v24 < a3;
        if (v24 > a3) {
          goto LABEL_19;
        }
      }
      if (!v22) {
        return 0;
      }
      if (v22 < 0)
      {
LABEL_19:
        uint64_t v25 = a1;
        uint64_t v26 = a5;
        uint64_t v27 = 0xFFFFFFFFLL;
        goto LABEL_20;
      }
      uint64_t v25 = a1;
      uint64_t v26 = a5;
      uint64_t v27 = 1;
LABEL_20:
      uint64_t result = sub_100008438(v25, v26, v27, a4, a5, a6, a7, a8);
      if (result) {
        return result;
      }
      uint64_t v29 = 4 * *(unsigned __int8 *)(a5 + 97);
      unsigned int v17 = *(unsigned __int16 *)(a5 + v29);
    }
    while (*(_WORD *)(a5 + v29));
  }
  return 0;
}

uint64_t sub_100005EA8(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v42 = a5;
  uint64_t v13 = a1 + 676;
  uint64_t v14 = *(void *)(a1 + 112);
  uint64_t v22 = sub_100005D68(a1, 1u, a2, a3, a1 + 676, a6, a7, a8);
  if (v22) {
    return v22;
  }
  if (!*(_WORD *)(v13 + 4 * *(unsigned __int8 *)(a1 + 773))) {
    return 2;
  }
  if (*(unsigned __int16 *)(v13 + 4 * *(unsigned __int8 *)(a1 + 773)) != a5)
  {
    log_err((uint64_t)"%s:%d: %s dev %d length tree search for 0x%llx 0x%llx returned node %d instead of %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"spaceman_fxc_update_length");
    return 22;
  }
  uint64_t v24 = (_OWORD *)(a1 + 774);
  uint64_t v25 = *(void *)(a1 + 96);
  uint64_t v26 = *(void *)(a1 + 80) + 24 * a5;
  *(void *)(v26 + 8) = *(void *)(v26 + 8) & 0xFFF0000000000000 | a4 & 0xFFFFFFFFFFFFFLL;
  *(void *)(a1 + 96) = a4 - a3 + v25;
  if (a4 <= a3)
  {
    if (v14 != a2)
    {
      long long v31 = *(_OWORD *)(v13 + 80);
      *(_OWORD *)(a1 + 838) = *(_OWORD *)(v13 + 64);
      *(_OWORD *)(a1 + 854) = v31;
      *(_WORD *)(a1 + 870) = *(_WORD *)(v13 + 96);
      long long v32 = *(_OWORD *)(v13 + 16);
      *uint64_t v24 = *(_OWORD *)v13;
      *(_OWORD *)(a1 + 790) = v32;
      long long v33 = *(_OWORD *)(v13 + 48);
      *(_OWORD *)(a1 + 806) = *(_OWORD *)(v13 + 32);
      *(_OWORD *)(a1 + 822) = v33;
      uint64_t v34 = sub_10000854C(a1, a1 + 774, 0xFFFFFFFFLL, v17, v18, v19, v20, v21);
      if (v34)
      {
        uint64_t v22 = v34;
        if (v34 == 2) {
          log_err((uint64_t)"%s:%d: %s dev %d Failed to find length tree predecessor for node that wasn't the smallest\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"spaceman_fxc_update_length");
        }
        return v22;
      }
      if ((*(void *)(*(void *)(a1 + 80) + 24 * *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 871)) + 8) & 0xFFFFFFFFFFFFFuLL) >= a4)
      {
        unint64_t v37 = *(void *)(a1 + 120);
        if (v37 > a4 || v37 == a4 && *(void *)(a1 + 112) < a2)
        {
          *(void *)(a1 + 112) = a2;
          *(void *)(a1 + 120) = a4;
        }
        goto LABEL_36;
      }
      goto LABEL_31;
    }
  }
  else
  {
    long long v27 = *(_OWORD *)(v13 + 80);
    *(_OWORD *)(a1 + 838) = *(_OWORD *)(v13 + 64);
    *(_OWORD *)(a1 + 854) = v27;
    *(_WORD *)(a1 + 870) = *(_WORD *)(v13 + 96);
    long long v28 = *(_OWORD *)(v13 + 16);
    *uint64_t v24 = *(_OWORD *)v13;
    *(_OWORD *)(a1 + 790) = v28;
    long long v29 = *(_OWORD *)(v13 + 48);
    *(_OWORD *)(a1 + 806) = *(_OWORD *)(v13 + 32);
    *(_OWORD *)(a1 + 822) = v29;
    uint64_t v30 = sub_10000854C(a1, a1 + 774, 1, v17, v18, v19, v20, v21);
    if (v30)
    {
      uint64_t v22 = v30;
      if (v30 != 2) {
        return v22;
      }
      if (v14 == a2) {
        *(void *)(a1 + 120) = a4;
      }
      if (*(void *)(a1 + 128) >= a4) {
        return 0;
      }
      uint64_t v22 = 0;
LABEL_38:
      *(void *)(a1 + 128) = a4;
      return v22;
    }
    int8x16_t v35 = vandq_s8(*(int8x16_t *)(*(void *)(a1 + 80) + 24 * *((unsigned __int16 *)v24 + 2 * *(unsigned __int8 *)(a1 + 871))), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
    if (v35.i64[1] < a4 || (v35.i64[1] == a4 ? (BOOL v36 = v35.i64[0] <= a2) : (BOOL v36 = 1), !v36))
    {
      if (v14 == a2) {
        *(int8x16_t *)(a1 + 112) = v35;
      }
LABEL_36:
      sub_100006778(a1, v13);
      uint64_t v22 = sub_10000654C(a1, 1u, a2, a4, &v42, v38, v39, v40);
      goto LABEL_37;
    }
    if (v14 != a2)
    {
LABEL_31:
      uint64_t v22 = 0;
      goto LABEL_37;
    }
  }
  uint64_t v22 = 0;
  *(void *)(a1 + 120) = a4;
LABEL_37:
  unint64_t v41 = *(void *)(a1 + 128);
  if (v41 < a4) {
    goto LABEL_38;
  }
  if (v41 == a3) {
    sub_100007138(a1, v15, v16, v17, v18, v19, v20, v21);
  }
  return v22;
}

unint64_t sub_1000061AC(unint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = result;
  uint64_t v4 = 0;
  unint64_t v5 = a2 - 1;
  uint64_t v6 = a3 + 2;
  char v7 = 1;
  do
  {
    char v8 = v7;
    unint64_t v9 = v3 + 16 * v4;
    unint64_t v10 = *(void *)(v9 + 296);
    if (v10)
    {
      uint64_t result = calc_overlap_range(v5, v6, v10, *(void *)(v9 + 304) - v10, 0);
      if (result) {
        *(void *)(v9 + 296) = 0;
      }
    }
    char v7 = 0;
    uint64_t v4 = 1;
  }
  while ((v8 & 1) != 0);
  return result;
}

uint64_t sub_10000622C(uint64_t a1, uint64_t a2, unint64_t a3, _WORD *a4, uint64_t a5)
{
  uint64_t v6 = *(unsigned __int8 *)(a5 + 96);
  if (a4 && (unsigned int v7 = (unsigned __int16)*a4, *a4))
  {
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v9 = *(void *)(v8 + 24 * (unsigned __int16)*a4);
    if ((v9 & 0xFFFFFFFFFFFFFLL) != a2) {
      sub_10005D43C();
    }
    uint64_t v10 = v8 + 24 * (unsigned __int16)*a4;
    uint64_t v13 = *(void *)(v10 + 8);
    uint64_t v11 = (uint64_t *)(v10 + 8);
    uint64_t v12 = v13;
    if ((v13 & 0xFFFFFFFFFFFFFLL) != a3) {
      sub_10005D410();
    }
    *(_DWORD *)(v8 + 24 * (unsigned __int16)*a4 + 4 * v6 + 16) = 0;
    if (v6 >= 2) {
      sub_10005D38C();
    }
    if (v6) {
      uint64_t v9 = v12;
    }
    else {
      uint64_t v11 = (uint64_t *)(v8 + 24 * v7);
    }
    *uint64_t v11 = v9 & 0xFFFFFFFFFFFFFFLL;
  }
  else
  {
    unsigned int v7 = *(unsigned __int16 *)(a1 + 92);
    if (v7 > *(_DWORD *)(a1 + 88) >> 8) {
      return 22;
    }
    if (!*(_WORD *)(a1 + 92)) {
      return 12;
    }
    if (*(void *)a1)
    {
      unint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 8) + 376) + 48 * *(_DWORD *)(a1 + 88) + 48);
      if (v15 < a3) {
        sub_10005D3B8();
      }
      unint64_t v16 = *(void *)(a1 + 96) + a3;
      if (v16 > v15) {
        sub_10005D3E4();
      }
    }
    else
    {
      unint64_t v16 = *(void *)(a1 + 96) + a3;
    }
    uint64_t v17 = (void *)(*(void *)(a1 + 80) + 24 * *(unsigned __int16 *)(a1 + 92));
    *(_WORD *)(a1 + 92) = *v17;
    ++*(_WORD *)(a1 + 94);
    *(void *)(a1 + 96) = v16;
    v17[1] = 0;
    void v17[2] = 0;
    *uint64_t v17 = 0;
    if (a4) {
      *a4 = v7;
    }
    uint64_t v8 = *(void *)(a1 + 80);
    uint64_t v18 = (void *)(v8 + 24 * v7);
    *uint64_t v18 = a2;
    v18[1] = a3;
  }
  uint64_t v19 = *(unsigned __int8 *)(a5 + 97);
  uint64_t v20 = (_WORD *)(a5 + 4 * v19);
  *uint64_t v20 = v7;
  v20[1] = 0;
  if (v19)
  {
    int v21 = (char)v19;
    *(_WORD *)(v8
             + 24 * *(unsigned __int16 *)(a5 + 4 * (v19 - 1))
             + 4 * v6
             + 2
             * ((*(char *)(a5 + 4 * (v19 - 1) + 3)
                                + 1
                                + (((*(char *)(a5 + 4 * (v19 - 1) + 3) + 1) & 0x8000u) >> 15)) >> 1)
             + 16) = v7;
    unsigned __int8 v22 = v19;
    if (((char)v19 & 0x80000000) == 0)
    {
      while (!*(unsigned char *)(a5 + 4 * v22 + 2))
      {
        int v23 = (char)v22--;
        if (v23 <= 0)
        {
          unsigned __int8 v22 = -1;
          break;
        }
      }
    }
    int v24 = (char)(v22 + 1);
    if (v24 < v21)
    {
      if (v6 > 1) {
        sub_10005D38C();
      }
      LOBYTE(v25) = v22 + 1;
      do
      {
        uint64_t v26 = (unsigned __int16 *)(a5 + 4 * v25);
        uint64_t v27 = v8 + 24 * *v26;
        if (v6) {
          v27 += 8;
        }
        char v28 = *((unsigned char *)v26 + 3);
        *(unsigned char *)(v27 + 7) = v28;
        *((unsigned char *)v26 + 2) = v28;
        int v25 = (char)(v25 + 1);
      }
      while (v25 < v21);
    }
    if ((v22 & 0x80) == 0)
    {
      long long v29 = (unsigned __int16 *)(a5 + 4 * v22);
      int v30 = *((char *)v29 + 3);
      if (!(*((char *)v29 + 2) + v30))
      {
        if (v6 >= 2) {
          sub_10005D38C();
        }
        uint64_t result = 0;
        long long v31 = (void *)(v8 + 24 * *v29);
        if (v6) {
          ++v31;
        }
        *v31 &= 0xFFFFFFFFFFFFFFuLL;
        return result;
      }
      if (*((unsigned __int8 *)v29 + 2) == *((unsigned __int8 *)v29 + 3))
      {
        if (v22) {
          int8x16_t v35 = (_WORD *)(v8
        }
                        + 24 * *(unsigned __int16 *)(a5 + 4 * (v22 - 1))
                        + 4 * v6
                        + 2
                        * ((*(char *)(a5 + 4 * (v22 - 1) + 3)
                                           + 1
                                           + (((*(char *)(a5 + 4 * (v22 - 1) + 3) + 1) & 0x8000u) >> 15)) >> 1)
                        + 16);
        else {
          int8x16_t v35 = (_WORD *)(a1 + 2 * v6 + 104);
        }
        int v36 = -v30;
        unint64_t v37 = (unsigned __int16 *)(a5 + 4 * v24);
        int v38 = *((unsigned __int8 *)v37 + 2);
        if (v38 == *((unsigned __int8 *)v29 + 3))
        {
          sub_100008630(a1, v6, (char)v36, *v29, v35);
        }
        else if ((char)v38 == v36)
        {
          sub_100008760(a1, v6, (char)v30, *v29, *v37, v35);
        }
      }
    }
    return 0;
  }
  uint64_t v32 = a1 + 2 * v6;
  int v34 = *(unsigned __int16 *)(v32 + 104);
  long long v33 = (_WORD *)(v32 + 104);
  if (v34) {
    sub_10005D360();
  }
  uint64_t result = 0;
  *long long v33 = v7;
  return result;
}

uint64_t sub_10000654C(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, _WORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a4 | a3) >> 52) {
    return 84;
  }
  uint64_t v13 = a1 + 872;
  if (!a5 || !*a5) {
    sub_100005AF4(a1, a4, a3, a4, (uint64_t)a5, a6, a7, a8);
  }
  uint64_t result = sub_100005D68(a1, a2, a3, a4, v13, a6, a7, a8);
  if (!result)
  {
    if (*(_WORD *)(v13 + 4 * *(unsigned __int8 *)(a1 + 969)))
    {
      uint64_t v15 = *(void *)(a1 + 80);
      if ((*(void *)(v15 + 24 * *(unsigned __int16 *)(v13 + 4 * *(unsigned __int8 *)(a1 + 969))) & 0xFFFFFFFFFFFFFLL) != a3) {
        sub_10005D494();
      }
      if ((*(void *)(v15 + 24 * *(unsigned __int16 *)(v13 + 4 * *(unsigned __int8 *)(a1 + 969)) + 8) & 0xFFFFFFFFFFFFFLL) != a4) {
        sub_10005D468();
      }
      return 17;
    }
    else
    {
      return sub_10000622C(a1, a3, a4, a5, v13);
    }
  }
  return result;
}

uint64_t sub_100006664(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 | a2) >> 52) {
    return 84;
  }
  uint64_t v9 = a1 + 970;
  uint64_t result = sub_100005D68(a1, 0, a2, a3, a1 + 970, a6, a7, a8);
  if (!result)
  {
    if (*(_WORD *)(v9 + 4 * *(unsigned __int8 *)(a1 + 1067)))
    {
      sub_100006778(a1, v9);
      return 0;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t sub_1000066E0(uint64_t result, unsigned int a2)
{
  if (a2 <= *(_DWORD *)(result + 88) >> 8)
  {
    uint64_t v2 = *(void *)(result + 80);
    unint64_t v3 = *(void *)(v2 + 24 * a2 + 8) & 0xFFFFFFFFFFFFFLL;
    if (*(void *)result
      && v3 >= *(void *)(*(void *)(*(void *)(result + 8) + 376)
                         + 48 * *(_DWORD *)(result + 88)
                         + 48))
    {
      sub_10005D4EC();
    }
    unint64_t v4 = *(void *)(result + 96);
    BOOL v5 = v4 >= v3;
    unint64_t v6 = v4 - v3;
    if (!v5) {
      sub_10005D4C0();
    }
    --*(_WORD *)(result + 94);
    *(void *)(result + 96) = v6;
    *(void *)(v2 + 24 * a2) = *(unsigned __int16 *)(result + 92);
    *(_WORD *)(result + 92) = a2;
  }
  return result;
}

uint64_t sub_100006778(uint64_t result, uint64_t a2)
{
  unint64_t v2 = *(unsigned __int8 *)(a2 + 96);
  if (v2 >= 2) {
    sub_10005D334();
  }
  uint64_t v4 = *(unsigned __int8 *)(a2 + 97);
  int v5 = (char)v4;
  unint64_t v6 = (_WORD *)(a2 + 4 * v4);
  uint64_t v7 = *(void *)(result + 80);
  uint64_t v8 = v7 + 24 * (unsigned __int16)*v6;
  if (*(unsigned char *)(a2 + 96)) {
    char v9 = *(unsigned char *)(v8 + 15);
  }
  else {
    char v9 = *(unsigned char *)(v8 + 7);
  }
  uint64_t v10 = v7 + 24 * (unsigned __int16)*v6 + 4 * v2;
  unsigned int v11 = *(unsigned __int16 *)(v10 + 18);
  unsigned __int8 v12 = v4 - 1;
  if ((char)v4 < 1)
  {
    uint64_t v15 = 0;
    unsigned int v14 = 0;
  }
  else
  {
    uint64_t v13 = (unsigned __int16 *)(a2 + 4 * v12);
    unsigned int v14 = *v13;
    uint64_t v15 = ((*((char *)v13 + 3) + 1 + (((*((char *)v13 + 3) + 1) & 0x8000u) >> 15)) >> 1);
  }
  __int16 v16 = *(_WORD *)(v10 + 16);
  if (v11)
  {
    uint64_t v17 = v7 + 24 * v11 + 4 * v2;
    unsigned int v20 = *(unsigned __int16 *)(v17 + 16);
    uint64_t v19 = (_WORD *)(v17 + 16);
    unsigned int v18 = v20;
    if (v20)
    {
      uint64_t v21 = a2 + 4 * v4;
      *(unsigned char *)(v21 + 3) = 1;
      unsigned __int8 v22 = (unsigned char *)(v21 + 3);
      int v23 = (char)v4 + 1;
      *(unsigned char *)(a2 + 97) = v4 + 1;
      uint64_t v24 = a2 + 4 * (v4 + 1);
      *(_WORD *)uint64_t v24 = v11;
      *(unsigned char *)(v24 + 3) = 0;
      unsigned int v25 = v11;
      do
      {
        LOBYTE(v4) = v23;
        unsigned int v26 = v25;
        unsigned int v25 = v18;
        *(unsigned char *)(a2 + 4 * v23++ + 3) = -1;
        uint64_t v27 = a2 + 4 * v23;
        *(_WORD *)uint64_t v27 = v25;
        *(unsigned char *)(v27 + 3) = 0;
        uint64_t v28 = v7 + 24 * v25 + 4 * v2;
        unsigned int v30 = *(unsigned __int16 *)(v28 + 16);
        long long v29 = (_WORD *)(v28 + 16);
        unsigned int v18 = v30;
      }
      while (v30);
      __int16 v31 = v25;
      uint64_t v32 = v7 + 24 * v25;
      uint64_t v33 = v32 + 4 * v2;
      *(_WORD *)(v7 + 24 * v26 + 4 * v2 + 16) = *(_WORD *)(v33 + 18);
      *(_WORD *)(v33 + 18) = v11;
      *long long v29 = v16;
      uint64_t v34 = v32 + 8;
      if (!v2) {
        uint64_t v34 = v32;
      }
      *(unsigned char *)(v34 + 7) = v9;
      uint64_t v35 = v7 + 24 * v14 + 4 * v2 + 2 * v15 + 16;
      if (v5) {
        int v36 = (_WORD *)v35;
      }
      else {
        int v36 = (_WORD *)(result + 2 * v2 + 104);
      }
      *int v36 = v31;
      *unsigned __int8 v22 = 1;
      *unint64_t v6 = v31;
      *(unsigned char *)(a2 + 97) = v4;
      if ((v4 & 0x80) != 0) {
        return result;
      }
    }
    else
    {
      *uint64_t v19 = v16;
      int v38 = (_WORD *)(v7 + 24 * v14 + 4 * v2 + 2 * v15 + 16);
      if (!(_BYTE)v4) {
        int v38 = (_WORD *)(result + 2 * v2 + 104);
      }
      *int v38 = v11;
      uint64_t v39 = v7 + 24 * v11;
      if (v2) {
        v39 += 8;
      }
      *(unsigned char *)(v39 + 7) = v9;
      *(unsigned char *)(a2 + 4 * v4 + 3) = 1;
      *unint64_t v6 = v11;
      if ((v4 & 0x80) != 0) {
        return result;
      }
    }
  }
  else
  {
    if ((_BYTE)v4) {
      unint64_t v37 = (_WORD *)(v7 + 24 * v14 + 4 * v2 + 2 * v15 + 16);
    }
    else {
      unint64_t v37 = (_WORD *)(result + 2 * v2 + 104);
    }
    *unint64_t v37 = v16;
    *(unsigned char *)(a2 + 97) = v12;
    LOBYTE(v4) = v4 - 1;
    if ((v12 & 0x80) != 0) {
      return result;
    }
  }
  uint64_t v57 = result;
  uint64_t v58 = result + 2 * v2 + 104;
  while (1)
  {
    char v40 = v4;
    uint64_t v41 = *(unsigned __int16 *)(a2 + 4 * v4);
    uint64_t v42 = *(void *)(result + 80);
    uint64_t v43 = v42 + 24 * v41;
    if (v2) {
      unsigned __int8 v44 = *(unsigned char *)(v42 + 24 * *(unsigned __int16 *)(a2 + 4 * v4) + 15);
    }
    else {
      unsigned __int8 v44 = *(unsigned char *)(v43 + 7);
    }
    uint64_t v45 = a2 + 4 * v4;
    int v46 = *(unsigned __int8 *)(v45 + 3);
    if (!*(unsigned char *)(v45 + 3)) {
      sub_10005D518();
    }
    int v47 = (char)(v44 - v46);
    if (v47 < 0) {
      int v47 = -v47;
    }
    if (v47 << 24 > 0x1FFFFFF) {
      break;
    }
    uint64_t v48 = v42 + 24 * *(unsigned __int16 *)(a2 + 4 * v4) + 8;
    if (!v2) {
      uint64_t v48 = v42 + 24 * v41;
    }
    *(unsigned char *)(v48 + 7) = v44 - v46;
    if (!v44) {
      return result;
    }
    if (v46 != v44) {
      sub_10005D544();
    }
LABEL_56:
    LOBYTE(v4) = v40 - 1;
    if (v40 <= 0) {
      return result;
    }
  }
  uint64_t v49 = (_WORD *)v58;
  if ((_BYTE)v4) {
    uint64_t v49 = (_WORD *)(v42
  }
                  + 24 * *(unsigned __int16 *)(a2 + 4 * (v4 - 1))
                  + 4 * v2
                  + 2
                  * ((*(char *)(a2 + 4 * (v4 - 1) + 3)
                                     + 1
                                     + (((*(char *)(a2 + 4 * (v4 - 1) + 3) + 1) & 0x8000u) >> 15)) >> 1)
                  + 16);
  int v50 = (char)-(char)v46;
  uint64_t v51 = *(unsigned __int16 *)(v42
                            + 24 * *(unsigned __int16 *)(a2 + 4 * v4)
                            + 4 * v2
                            + 2 * ((v50 + 1 + (((v50 + 1) & 0x8000u) >> 15)) >> 1)
                            + 16);
  uint64_t v52 = v42 + 24 * v51;
  if (v2) {
    unsigned __int8 v53 = *(unsigned char *)(v42
  }
                   + 24
                   * *(unsigned __int16 *)(v42
                                         + 24 * *(unsigned __int16 *)(a2 + 4 * v4)
                                         + 4 * v2
                                         + 2 * ((v50 + 1 + (((v50 + 1) & 0x8000u) >> 15)) >> 1)
                                         + 16)
                   + 15);
  else {
    unsigned __int8 v53 = *(unsigned char *)(v52 + 7);
  }
  if (v46 == v53)
  {
    sub_100008760(result, v2, v50, *(unsigned __int16 *)(a2 + 4 * v4), v51, v49);
    uint64_t result = v57;
    goto LABEL_56;
  }
  unsigned __int8 v56 = -(char)v46;
  uint64_t result = sub_100008630(result, v2, (char)v46, v41, v49);
  if (v53)
  {
    if (v2)
    {
      uint64_t result = v57;
      if (*(unsigned char *)(v42 + 24 * v41 + 15)) {
        goto LABEL_66;
      }
      char v54 = *(unsigned char *)(v42 + 24 * v51 + 15);
    }
    else
    {
      uint64_t result = v57;
      if (*(unsigned char *)(v43 + 7)) {
LABEL_66:
      }
        sub_10005D5F4();
      char v54 = *(unsigned char *)(v52 + 7);
    }
    if (v54) {
      sub_10005D5C8();
    }
    goto LABEL_56;
  }
  if (!v2)
  {
    if (*(unsigned __int8 *)(v43 + 7) == v56)
    {
      unsigned __int8 v55 = *(unsigned char *)(v52 + 7);
      goto LABEL_63;
    }
LABEL_69:
    sub_10005D59C();
  }
  if (*(unsigned __int8 *)(v42 + 24 * v41 + 15) != v56) {
    goto LABEL_69;
  }
  unsigned __int8 v55 = *(unsigned char *)(v42 + 24 * v51 + 15);
LABEL_63:
  if (v46 != v55) {
    sub_10005D570();
  }
  return result;
}

void sub_100006BB8(int8x16_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10 = sub_10000854C((uint64_t)a1, a2, 1, a4, a5, a6, a7, a8);
  if (v10 == 2)
  {
    a1[7].i64[0] = 0;
    a1[7].i64[1] = 0;
  }
  else if (v10)
  {
    log_err((uint64_t)"%s:%d: %s dev %d Failed to find successor node from length tree while updating smallest: %d\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"spaceman_fxc_update_smallest_with_successor");
  }
  else
  {
    a1[7] = vandq_s8(*(int8x16_t *)(a1[5].i64[0] + 24 * *(unsigned __int16 *)(a2 + 4 * *(unsigned __int8 *)(a2 + 97))), (int8x16_t)vdupq_n_s64(0xFFFFFFFFFFFFFuLL));
  }
}

uint64_t spaceman_free_extent_cache_remove(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a1) {
    return 22;
  }
  if ((a3 | a2) >> 52) {
    return 84;
  }
  if (!a3) {
    return 0;
  }
  if (*(void *)a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  }
  if ((*(unsigned char *)(a1 + 280) & 2) == 0)
  {
    uint64_t v11 = (_OWORD *)(a1 + 1068);
    unsigned __int16 v81 = 0;
    uint64_t v19 = sub_100005D68(a1, 0, a2, a3, a1 + 1068, a6, a7, a8);
    if (v19)
    {
LABEL_8:
      log_err((uint64_t)"%s:%d: %s dev %d Error %d, reinitializing\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"spaceman_free_extent_cache_remove");
      spaceman_free_extent_cache_reset(a1);
      goto LABEL_9;
    }
    uint64_t v21 = (_OWORD *)(a1 + 1166);
    uint64_t v22 = a3 + a2;
    uint64_t v23 = 4 * *(unsigned __int8 *)(a1 + 1165);
    unsigned int v24 = *(unsigned __int16 *)((char *)v11 + v23);
    if (*(_WORD *)((char *)v11 + v23)) {
      goto LABEL_19;
    }
    long long v37 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v37;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    long long v38 = *(_OWORD *)(a1 + 1084);
    *uint64_t v21 = *v11;
    *(_OWORD *)(a1 + 1182) = v38;
    long long v39 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v39;
    uint64_t v40 = sub_10000854C(a1, a1 + 1166, 0xFFFFFFFFLL, v14, v15, v16, v17, v18);
    if (v40 == 2) {
      goto LABEL_43;
    }
    uint64_t v19 = v40;
    if (v40) {
      goto LABEL_8;
    }
    uint64_t v15 = *((unsigned __int16 *)v21 + 2 * *(unsigned __int8 *)(a1 + 1263));
    uint64_t v41 = (void *)(*(void *)(a1 + 80) + 24 * v15);
    unint64_t v42 = v41[1] & 0xFFFFFFFFFFFFFLL;
    unint64_t v43 = v42 + (*v41 & 0xFFFFFFFFFFFFFLL);
    if (v43 <= a2) {
      goto LABEL_43;
    }
    uint64_t v19 = sub_100005EA8(a1, *v41 & 0xFFFFFFFFFFFFFLL, v42, a2 - (*v41 & 0xFFFFFFFFFFFFFLL), v15, v16, v17, v18);
    if (v19) {
      goto LABEL_8;
    }
    unint64_t v44 = v43 - v22;
    if (v43 <= v22)
    {
LABEL_43:
      uint64_t v73 = sub_10000854C(a1, a1 + 1068, 1, v14, v15, v16, v17, v18);
      if (v73 != 2)
      {
        uint64_t v19 = v73;
        if (v73) {
          goto LABEL_8;
        }
        unsigned int v24 = *((unsigned __int16 *)v11 + 2 * *(unsigned __int8 *)(a1 + 1165));
LABEL_19:
        unsigned int v25 = (unint64_t *)(*(void *)(a1 + 80) + 24 * v24);
        unint64_t v26 = *v25;
        uint64_t v27 = *v25 & 0xFFFFFFFFFFFFFLL;
        unint64_t v28 = v25[1] & 0xFFFFFFFFFFFFFLL;
        unint64_t v29 = v28 + v27;
        if (v22 >= v28 + v27)
        {
          while (1)
          {
            sub_100006778(a1, a1 + 1068);
            uint64_t v51 = sub_100005D68(a1, 1u, v27, v28, a1 + 1068, v48, v49, v50);
            if (v51)
            {
              uint64_t v74 = v51;
              log_err((uint64_t)"%s:%d: %s dev %d Failed to delete covered node from length tree: %d\n", v52, v53, v54, v55, v56, v57, v58, (uint64_t)"spaceman_free_extent_cache_remove");
              uint64_t v19 = v74;
              goto LABEL_8;
            }
            if (v27 == *(void *)(a1 + 112))
            {
              if (v28 != *(void *)(a1 + 120)) {
                sub_10005D620();
              }
              long long v59 = *(_OWORD *)(a1 + 1148);
              *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
              *(_OWORD *)(a1 + 1246) = v59;
              *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
              long long v60 = *(_OWORD *)(a1 + 1084);
              *uint64_t v21 = *v11;
              *(_OWORD *)(a1 + 1182) = v60;
              long long v61 = *(_OWORD *)(a1 + 1116);
              *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
              *(_OWORD *)(a1 + 1214) = v61;
              sub_100006BB8((int8x16_t *)a1, a1 + 1166, v53, v54, v55, v56, v57, v58);
            }
            sub_100006778(a1, a1 + 1068);
            sub_1000066E0(a1, (unsigned __int16)v24);
            if (v28 == *(void *)(a1 + 128)) {
              sub_100007138(a1, v62, v63, v64, v65, v66, v67, v68);
            }
            uint64_t v19 = sub_100005D68(a1, 0, v27, v28, a1 + 1068, v66, v67, v68);
            if (!v19) {
              uint64_t v19 = sub_10000854C(a1, a1 + 1068, 1, v71, v72, v16, v17, v18);
            }
            if (v19) {
              break;
            }
            unsigned int v24 = *((unsigned __int16 *)v11 + 2 * *(unsigned __int8 *)(a1 + 1165));
            unsigned int v25 = (unint64_t *)(*(void *)(a1 + 80)
                                     + 24 * *((unsigned __int16 *)v11 + 2 * *(unsigned __int8 *)(a1 + 1165)));
            unint64_t v26 = *v25;
            uint64_t v27 = *v25 & 0xFFFFFFFFFFFFFLL;
            unint64_t v28 = v25[1] & 0xFFFFFFFFFFFFFLL;
            unint64_t v29 = v28 + v27;
            if (v22 < (uint64_t)(v28 + v27)) {
              goto LABEL_20;
            }
          }
          if (v19 == 2) {
            goto LABEL_47;
          }
          log_err((uint64_t)"%s:%d: %s dev %d Failed to get next extent: %d\n", v69, v70, v71, v72, v16, v17, v18, (uint64_t)"spaceman_free_extent_cache_remove");
          goto LABEL_8;
        }
LABEL_20:
        if (v22 > v27)
        {
          if (v27 == *(void *)(a1 + 112)) {
            *(void *)(a1 + 112) = v22;
          }
          *unsigned int v25 = v26 & 0xFFF0000000000000 | v22 & 0xFFFFFFFFFFFFFLL;
          uint64_t v19 = sub_100005EA8(a1, v22, v28, v29 - v22, v24, v16, v17, v18);
          if (!v19) {
            goto LABEL_9;
          }
          log_err((uint64_t)"%s:%d: %s dev %d Failed to update partially-covered node in length tree: %d\n", v30, v31, v32, v33, v34, v35, v36, (uint64_t)"spaceman_free_extent_cache_remove");
          goto LABEL_8;
        }
      }
    }
    else
    {
      unsigned __int16 v81 = 0;
      if (sub_10000654C(a1, 0, v22, v43 - v22, &v81, v16, v17, v18))
      {
LABEL_31:
        sub_100005D24(a1, v22, v43 - v22);
        goto LABEL_47;
      }
      if (sub_10000654C(a1, 1u, v22, v43 - v22, &v81, v45, v46, v47))
      {
        if (!sub_100006664(a1, v22, v43 - v22, v75, v76, v77, v78, v79)) {
          sub_1000066E0(a1, v81);
        }
        goto LABEL_31;
      }
      unint64_t v80 = *(void *)(a1 + 120);
      if (v44 < v80 || v44 == v80 && v22 > *(void *)(a1 + 112))
      {
        *(void *)(a1 + 112) = v22;
        *(void *)(a1 + 120) = v44;
      }
      if (v44 > *(void *)(a1 + 128))
      {
        uint64_t v19 = 0;
        *(void *)(a1 + 128) = v44;
LABEL_9:
        if (*(void *)a1) {
          pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
        }
        return v19;
      }
    }
LABEL_47:
    uint64_t v19 = 0;
    goto LABEL_9;
  }
  if (*(void *)a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  return 45;
}

uint64_t sub_100007138(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9 = a1 + 676;
  uint64_t result = sub_1000071A0(a1, a1 + 676, 1u, a4, a5, a6, a7, a8);
  if (result == 2)
  {
    uint64_t v11 = 0;
  }
  else
  {
    if (result) {
      return result;
    }
    uint64_t v11 = *(void *)(*(void *)(a1 + 80) + 24 * *(unsigned __int16 *)(v9 + 4 * *(unsigned __int8 *)(a1 + 773)) + 8) & 0xFFFFFFFFFFFFFLL;
  }
  *(void *)(a1 + 128) = v11;
  return result;
}

uint64_t sub_1000071A0(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_WORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(unsigned char *)(a2 + 96) = a3;
  uint64_t v10 = *(unsigned __int16 *)(a1 + 2 * a3 + 104);
  *(_WORD *)a2 = v10;
  if (v10)
  {
    if (a3 >= 2) {
      sub_10005D334();
    }
    uint64_t v11 = *(void *)(a1 + 80) + 24 * v10;
    if (a3) {
      char v12 = *(unsigned char *)(v11 + 15);
    }
    else {
      char v12 = *(unsigned char *)(v11 + 7);
    }
    *(unsigned char *)(a2 + 2) = v12;
  }
  while (1)
  {
    uint64_t v13 = *(unsigned __int8 *)(a2 + 97);
    if (!*(_WORD *)(a2 + 4 * v13)) {
      break;
    }
    uint64_t result = sub_100008438(a1, a2, 1, a4, a5, a6, a7, a8);
    if (result) {
      return result;
    }
  }
  unsigned int v15 = v13 - 1;
  *(unsigned char *)(a2 + 97) = v15;
  return (v15 >> 6) & 2;
}

uint64_t spaceman_free_extent_cache_bitmap_scan_begin(uint64_t a1, uint64_t *a2)
{
  if (!a1) {
    return 0;
  }
  if (*(void *)a1) {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  }
  uint64_t v4 = *(void *)(a1 + 280);
  BOOL v5 = (v4 & 6) == 0;
  if ((v4 & 6) == 0)
  {
    *(void *)(a1 + 280) = v4 | 4;
    uint64_t v6 = *(void *)(a1 + 288);
    if (v6)
    {
      if (a2)
      {
LABEL_9:
        *a2 = v6;
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v6 = 1;
      *(void *)(a1 + 288) = 1;
      if (a2) {
        goto LABEL_9;
      }
    }
    *(void *)(a1 + 280) = v4 | 0xC;
LABEL_12:
    if (!*(void *)a1) {
      return 1;
    }
    goto LABEL_13;
  }
  if (*(void *)a1)
  {
LABEL_13:
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    return v5;
  }
  return 0;
}

uint64_t spaceman_free_extent_cache_bitmap_scan_finished(uint64_t result, unint64_t a2, char a3)
{
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  uint64_t v6 = *(void *)(result + 8);
  if (*(void *)result) {
    uint64_t result = pthread_mutex_lock((pthread_mutex_t *)(result + 16));
  }
  uint64_t v7 = *(void *)(v5 + 280);
  if ((v7 & 6) != 0)
  {
    if (a3)
    {
      *(_OWORD *)(v5 + 184) = *(_OWORD *)(v5 + 136);
      *(_OWORD *)(v5 + 200) = *(_OWORD *)(v5 + 152);
      *(_OWORD *)(v5 + 216) = *(_OWORD *)(v5 + 168);
      *(void *)(v5 + 280) = v7 & 0xFFFFFFFFFFFFFFF3;
      *(_OWORD *)(v5 + 136) = 0u;
      *(_OWORD *)(v5 + 152) = 0u;
      *(_OWORD *)(v5 + 168) = 0u;
      goto LABEL_19;
    }
    if (*(void *)(*(void *)(v6 + 376) + 48 * *(unsigned __int8 *)(v5 + 88) + 48) > a2
      && ((unint64_t v8 = *(void *)(v5 + 288), (v7 & 8) != 0) || v8 <= a2))
    {
      int v9 = 0;
      if (v8 < a2) {
        *(void *)(v5 + 288) = a2;
      }
    }
    else
    {
      int v9 = 1;
    }
    unint64_t v10 = v7 & 0xFFFFFFFFFFFFFFF3;
    char v12 = (_OWORD *)(v5 + 136);
    uint64_t v11 = *(void *)(v5 + 136);
    *(void *)(v5 + 280) = v10;
    if (v11)
    {
      uint64_t v13 = *(void *)(v5 + 184) + v11;
      unint64_t v14 = *(void *)(v5 + 200);
      unint64_t v15 = *(void *)(v5 + 152);
      uint64_t v16 = *(void *)(v5 + 192) + *(void *)(v5 + 144);
      *(void *)(v5 + 184) = v13;
      *(void *)(v5 + 192) = v16;
      if (v14 < v15) {
        *(void *)(v5 + 200) = v15;
      }
      unint64_t v17 = *(void *)(v5 + 176);
      if (*(void *)(v5 + 224) < v17) {
        *(void *)(v5 + 224) = v17;
      }
      uint64_t result = sub_1000074C4(v5 + 184, *(void *)(v5 + 160), *(void *)(v5 + 168));
      *(_OWORD *)(v5 + 152) = 0u;
      *(_OWORD *)(v5 + 168) = 0u;
      _OWORD *v12 = 0u;
      if ((v9 & 1) == 0) {
        goto LABEL_21;
      }
      goto LABEL_19;
    }
    *(_OWORD *)(v5 + 152) = 0u;
    *(_OWORD *)(v5 + 168) = 0u;
    _OWORD *v12 = 0u;
    if (v9)
    {
LABEL_19:
      uint64_t v18 = *(void *)(v5 + 336) + 1;
      *(void *)(v5 + 328) = 0;
      *(void *)(v5 + 336) = v18;
      *(_OWORD *)(v5 + 232) = *(_OWORD *)(v5 + 184);
      *(_OWORD *)(v5 + 248) = *(_OWORD *)(v5 + 200);
      *(_OWORD *)(v5 + 264) = *(_OWORD *)(v5 + 216);
      *(_OWORD *)(v5 + 184) = 0u;
      *(_OWORD *)(v5 + 200) = 0u;
      *(_OWORD *)(v5 + 216) = 0u;
      *(void *)(v5 + 288) = 0;
      uint64_t v19 = *(void *)(v5 + 280);
      if ((v19 & 1) == 0) {
        *(void *)(v5 + 280) = v19 | 1;
      }
    }
  }
LABEL_21:
  if (*(void *)v5)
  {
    return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 16));
  }
  return result;
}

uint64_t sub_1000074C4(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(result + 24);
  if (v3)
  {
    if (v3 <= a2)
    {
      uint64_t v4 = *(void *)(result + 32);
    }
    else
    {
      uint64_t v4 = v3 - a2 + *(void *)(result + 32);
      *(void *)(result + 24) = a2;
      *(void *)(result + 32) = v4;
      uint64_t v3 = a2;
    }
    uint64_t v5 = v4 + v3;
    if (a3 + a2 > v5) {
      *(void *)(result + 32) = v4 + a3 + a2 - v5;
    }
  }
  else
  {
    *(void *)(result + 24) = a2;
    *(void *)(result + 32) = a3;
  }
  return result;
}

unint64_t spaceman_free_extent_cache_search_better_length(__int16 a1, unint64_t a2, unint64_t a3)
{
  if ((a1 & 0x1000) == 0) {
    return a2;
  }
  if (a3 <= 1) {
    return a3 + 1;
  }
  if (a3 + (a3 >> 1) >= a2) {
    return a2;
  }
  else {
    return a3 + (a3 >> 1);
  }
}

uint64_t spaceman_free_extent_cache_search(uint64_t a1, uint64_t a2, int64_t *a3, unint64_t *a4)
{
  int64_t v4 = *a3;
  unint64_t v5 = *a4;
  *a3 = 0;
  *a4 = 0;
  if (!a1) {
    return 6;
  }
  ++*(void *)(a1 + 344);
  if (!v5)
  {
    ++*(void *)(a1 + 352);
    return 22;
  }
  uint64_t v10 = *(void *)(*(void *)a1 + 376);
  uint64_t v11 = *(void *)(v10 + 1248);
  if (v11
    && (uint64_t v12 = *(void *)(v10 + 1240),
        char v13 = __clz(__rbit64(*(unsigned int *)(v10 + 36))),
        *(unsigned char *)(a1 + 88) == (((v12 << v13) & 0x4000000000000000) != 0)))
  {
    uint64_t v14 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v13) & v12;
    int v15 = 1;
  }
  else
  {
    int v15 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v79 = 0;
  v80[0] = 0;
  unint64_t v75 = 0;
  unint64_t v76 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 16));
  if ((*(unsigned char *)(a1 + 280) & 2) != 0)
  {
    if (*(void *)a1) {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
    }
    return 6;
  }
  unint64_t v71 = v14;
  int v72 = v15;
  uint64_t v19 = (_OWORD *)(a1 + 1068);
  uint64_t v77 = 0;
  uint64_t v78 = 0;
  unint64_t v73 = 0;
  uint64_t v74 = 0;
  if (!sub_100005D68(a1, 1u, v4, v5, a1 + 1068, v16, v17, v18))
  {
    if (*((_WORD *)v19 + 2 * *(unsigned __int8 *)(a1 + 1165)))
    {
      uint64_t v27 = (void *)(*(void *)(a1 + 80) + 24 * *((unsigned __int16 *)v19 + 2 * *(unsigned __int8 *)(a1 + 1165)));
      uint64_t v78 = *v27 & 0xFFFFFFFFFFFFFLL;
      uint64_t v28 = v27[1] & 0xFFFFFFFFFFFFFLL;
      uint64_t v74 = v28;
      if (v78 != v4) {
        sub_10005D678();
      }
      if (v28 != v5) {
        sub_10005D64C();
      }
      uint64_t v29 = v5;
      unint64_t v30 = v4;
      if (v15
        && (spaceman_clip_extent(v4, v5, v71, v11, a2, v4, (unint64_t *)&v78, (unint64_t *)&v74),
            uint64_t v29 = v74,
            unint64_t v30 = v78,
            !v74))
      {
        unint64_t v32 = 0;
      }
      else
      {
        int v31 = spaceman_clip_extent_to_zones(*(void *)a1, *(void *)(a1 + 8), *(unsigned __int8 *)(a1 + 88), v30, v29, a2, v4, (unint64_t *)&v77, &v73);
        unint64_t v30 = v78;
        unint64_t v32 = v74;
        if (v31)
        {
          uint64_t v79 = v78;
          unint64_t v75 = v74;
          unint64_t v30 = v77;
          uint64_t v78 = v77;
          unint64_t v32 = v73;
          uint64_t v74 = v73;
        }
      }
      v80[0] = v30;
      unint64_t v76 = v32;
      if (v32 == v5) {
        goto LABEL_22;
      }
    }
    long long v38 = (_OWORD *)(a1 + 1166);
    long long v39 = *(_OWORD *)(a1 + 1148);
    *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
    *(_OWORD *)(a1 + 1246) = v39;
    *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
    long long v40 = *(_OWORD *)(a1 + 1084);
    *(_OWORD *)(a1 + 1166) = *v19;
    *(_OWORD *)(a1 + 1182) = v40;
    long long v41 = *(_OWORD *)(a1 + 1116);
    *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
    *(_OWORD *)(a1 + 1214) = v41;
    if (!sub_100007C84(a1, a1 + 1166, v72, v71, v11, a2, v4, v5, 0xFFFFFFFFFFFFFFFFLL, v80, &v76, &v79, &v75, 0x301u))
    {
      long long v42 = *(_OWORD *)(a1 + 1148);
      *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
      *(_OWORD *)(a1 + 1246) = v42;
      *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
      long long v43 = *(_OWORD *)(a1 + 1084);
      *long long v38 = *v19;
      *(_OWORD *)(a1 + 1182) = v43;
      long long v44 = *(_OWORD *)(a1 + 1116);
      *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
      *(_OWORD *)(a1 + 1214) = v44;
      if (!sub_100007C84(a1, a1 + 1166, v72, v71, v11, a2, v4, v5, 0xFFFFFFFFFFFFFFFFLL, v80, &v76, &v79, &v75, 0x502u))
      {
        unint64_t v46 = v75;
        if (v76 >= v5 || v75 <= v76)
        {
          unint64_t v47 = v75;
          unint64_t v46 = v76;
        }
        else
        {
          unint64_t v47 = 0;
          uint64_t v48 = v79;
          uint64_t v79 = 0;
          v80[0] = v48;
          unint64_t v75 = 0;
          unint64_t v76 = v46;
          a2 = a2 & 0xFFFFDFFF;
        }
        if (v46 < v5 && (a2 & 0x1000) == 0) {
          goto LABEL_22;
        }
        if (v4 <= v80[0])
        {
          unint64_t v49 = v80[0] - v4;
        }
        else
        {
          if (v4 - v80[0] < v46) {
            goto LABEL_22;
          }
          unint64_t v49 = v4 - (v46 + v80[0]);
        }
        if (!v49) {
          goto LABEL_22;
        }
        unint64_t v65 = v47;
        uint64_t v68 = v80[0];
        unint64_t v69 = v46;
        unint64_t v70 = v49;
        if (!sub_100005D68(a1, 0, v4, v5, a1 + 1068, v24, v25, v26))
        {
          if (*((_WORD *)v19 + 2 * *(unsigned __int8 *)(a1 + 1165)))
          {
            uint64_t v51 = (void *)(*(void *)(a1 + 80)
                           + 24 * *((unsigned __int16 *)v19 + 2 * *(unsigned __int8 *)(a1 + 1165)));
            uint64_t v52 = *v51 & 0xFFFFFFFFFFFFFLL;
            uint64_t v78 = v52;
            uint64_t v53 = v51[1] & 0xFFFFFFFFFFFFFLL;
            uint64_t v74 = v53;
            if (v72)
            {
              spaceman_clip_extent(v52, v53, v71, v11, a2, v4, (unint64_t *)&v78, (unint64_t *)&v74);
              uint64_t v53 = v74;
              uint64_t v52 = v78;
            }
            if (v53)
            {
              int v54 = spaceman_clip_extent_to_zones(*(void *)a1, *(void *)(a1 + 8), *(unsigned __int8 *)(a1 + 88), v52, v53, a2, v4, (unint64_t *)&v77, &v73);
              uint64_t v52 = v78;
              unint64_t v55 = v74;
              if (v54)
              {
                unint64_t v56 = v65;
                uint64_t v63 = v78;
                unint64_t v66 = v74;
                if (sub_100007F70(v4, v5, v79, v56, v78, v74, a2))
                {
                  uint64_t v79 = v63;
                  unint64_t v75 = v66;
                }
                uint64_t v52 = v77;
                uint64_t v78 = v77;
                unint64_t v55 = v73;
                uint64_t v74 = v73;
              }
            }
            else
            {
              unint64_t v55 = 0;
            }
            uint64_t v64 = v52;
            unint64_t v67 = v55;
            if (sub_100007F70(v4, v5, v68, v69, v52, v55, a2))
            {
              v80[0] = v64;
              unint64_t v76 = v67;
              goto LABEL_22;
            }
          }
          long long v57 = *(_OWORD *)(a1 + 1148);
          *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
          *(_OWORD *)(a1 + 1246) = v57;
          *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
          long long v58 = *(_OWORD *)(a1 + 1084);
          *long long v38 = *v19;
          *(_OWORD *)(a1 + 1182) = v58;
          long long v59 = *(_OWORD *)(a1 + 1116);
          *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
          *(_OWORD *)(a1 + 1214) = v59;
          if (!sub_100007C84(a1, a1 + 1166, v72, v71, v11, a2, v4, v5, v70, v80, &v76, &v79, &v75, 0x1802u))
          {
            long long v60 = *(_OWORD *)(a1 + 1148);
            *(_OWORD *)(a1 + 1230) = *(_OWORD *)(a1 + 1132);
            *(_OWORD *)(a1 + 1246) = v60;
            *(_WORD *)(a1 + 1262) = *(_WORD *)(a1 + 1164);
            long long v61 = *(_OWORD *)(a1 + 1084);
            *long long v38 = *v19;
            *(_OWORD *)(a1 + 1182) = v61;
            long long v62 = *(_OWORD *)(a1 + 1116);
            *(_OWORD *)(a1 + 1198) = *(_OWORD *)(a1 + 1100);
            *(_OWORD *)(a1 + 1214) = v62;
            if (!sub_100007C84(a1, a1 + 1166, v72, v71, v11, a2, v4, v5, v70, v80, &v76, &v79, &v75, 0x1801u))
            {
LABEL_22:
              if (*(void *)a1) {
                pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
              }
              unint64_t v34 = v76;
              if (!v76 && v75)
              {
                v80[0] = v79;
                unint64_t v34 = v75;
              }
              unint64_t v35 = v34 - v5;
              if (v34 > v5)
              {
                unint64_t v36 = *(void *)(a1 + 368) + v35;
                ++*(void *)(a1 + 360);
                *(void *)(a1 + 368) = v36;
                if (v35 == 1)
                {
                  uint64_t result = 0;
                  long long v37 = (void *)(a1 + 400);
                }
                else if (v35 > 7)
                {
                  uint64_t result = 0;
                  if (v35 > 0xF) {
                    long long v37 = (void *)(a1 + 376);
                  }
                  else {
                    long long v37 = (void *)(a1 + 384);
                  }
                }
                else
                {
                  uint64_t result = 0;
                  long long v37 = (void *)(a1 + 392);
                }
                goto LABEL_62;
              }
              if (v34 >= v5)
              {
                uint64_t result = 0;
                ++*(void *)(a1 + 408);
                if (v34)
                {
LABEL_63:
                  uint64_t v50 = (void *)(a1 + 352);
LABEL_79:
                  ++*v50;
                  *a3 = v80[0];
                  *a4 = v34;
                  return result;
                }
              }
              else
              {
                if ((a2 & 0x1000) != 0) {
                  unsigned int v45 = 0;
                }
                else {
                  unsigned int v45 = 28;
                }
                if (sub_10000811C(a1, a2, v5, v34)) {
                  uint64_t result = 3;
                }
                else {
                  uint64_t result = v45;
                }
                if ((a2 & 0x1000) != 0)
                {
                  if (v34)
                  {
                    long long v37 = (void *)(a1 + 416);
                    unint64_t v5 = v34;
LABEL_62:
                    ++*v37;
                    unint64_t v34 = v5;
                    goto LABEL_63;
                  }
                  if (result) {
                    uint64_t result = result;
                  }
                  else {
                    uint64_t result = 28;
                  }
                }
                else
                {
                  v80[0] = 0;
                }
              }
              unint64_t v34 = 0;
              uint64_t v50 = (void *)(a1 + 424);
              goto LABEL_79;
            }
          }
        }
      }
    }
  }
  log_err((uint64_t)"%s:%d: %s dev %d Error searching %s free extent cache: %d; Reinitializing.\n",
    v20,
    v21,
    v22,
    v23,
    v24,
    v25,
    v26,
    (uint64_t)"spaceman_free_extent_cache_search");
  spaceman_free_extent_cache_reset(a1);
  if (*(void *)a1) {
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 16));
  }
  return 3;
}

uint64_t sub_100007C84(uint64_t a1, uint64_t a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, unint64_t a9, uint64_t *a10, unint64_t *a11, uint64_t *a12, unint64_t *a13, unsigned int a14)
{
  if ((a14 & 3) == 0 || (a14 & 0x1F00) == 0) {
    return 22;
  }
  unint64_t v17 = a7;
  __int16 v18 = a6;
  uint64_t v21 = a2;
  uint64_t v22 = a1;
  uint64_t v53 = 0;
  unint64_t v54 = 0;
  unint64_t v51 = 0;
  unint64_t v52 = 0;
  if (a14) {
    uint64_t v23 = 1;
  }
  else {
    uint64_t v23 = 0xFFFFFFFFLL;
  }
  uint64_t v15 = sub_10000854C(a1, a2, v23, a4, a5, a6, a7, a8);
  if ((v15 & 0xFFFFFFFD) == 0)
  {
    int v48 = a3;
    uint64_t v43 = a5;
    __int16 v50 = v18;
    unsigned int v29 = 0;
    unsigned int v47 = (char)v23;
    uint64_t v49 = v17;
    uint64_t v44 = v22;
    uint64_t v45 = v21;
    do
    {
      if (v15 == 2) {
        return 0;
      }
      unint64_t v30 = (void *)(*(void *)(v22 + 80) + 24 * *(unsigned __int16 *)(v21 + 4 * *(unsigned __int8 *)(v21 + 97)));
      unint64_t v31 = *v30 & 0xFFFFFFFFFFFFFLL;
      unint64_t v54 = v31;
      unint64_t v32 = v30[1] & 0xFFFFFFFFFFFFFLL;
      unint64_t v52 = v32;
      if (v48)
      {
        __int16 v33 = v50;
        spaceman_clip_extent(v31, v32, a4, v43, v50, v17, &v54, &v52);
        uint64_t v34 = v52;
        if (!v52) {
          goto LABEL_39;
        }
      }
      else
      {
        uint64_t v34 = v32;
        __int16 v33 = v50;
        if (!v32)
        {
LABEL_39:
          if ((a14 & 0x1000) != 0 && v29 > 0x7E) {
            return v15;
          }
          goto LABEL_44;
        }
      }
      int v35 = spaceman_clip_extent_to_zones(*(void *)v22, *(void *)(v22 + 8), *(unsigned __int8 *)(v22 + 88), v54, v34, v33, v17, (unint64_t *)&v53, &v51);
      __int16 v36 = v33;
      uint64_t v37 = v54;
      unint64_t v38 = v52;
      if (v35)
      {
        if (sub_100007F70(v17, a8, *a12, *a13, v54, v52, v36))
        {
          *a12 = v37;
          *a13 = v38;
        }
        uint64_t v37 = v53;
        unint64_t v54 = v53;
        unint64_t v38 = v51;
        unint64_t v52 = v51;
      }
      unint64_t v39 = *a11;
      if (sub_100007F70(v49, a8, *a10, *a11, v37, v38, v50))
      {
        *a10 = v37;
        *a11 = v38;
        unint64_t v39 = v38;
        if ((a14 & 0x800) != 0) {
          return v15;
        }
      }
      BOOL v40 = v38 == v32 && (v32 == a8) & BYTE1(a14);
      if (v40 || ((v39 > a8) & (a14 >> 9)) != 0) {
        return v15;
      }
      if ((a14 & 0x400) != 0 && v32 < a8 && v32 <= v39) {
        return v15;
      }
      unint64_t v17 = v49;
      uint64_t v22 = v44;
      uint64_t v21 = v45;
      if ((a14 & 0x1000) != 0)
      {
        if (v29 > 0x7E) {
          return v15;
        }
        unint64_t v42 = v37 - v49;
        if (v37 < v49)
        {
          if (v49 - v37 >= v38) {
            unint64_t v42 = v49 - v37 - v38;
          }
          else {
            unint64_t v42 = 0;
          }
        }
        if (v42 >= a9) {
          return v15;
        }
      }
LABEL_44:
      uint64_t v15 = sub_10000854C(v22, v21, v47, v24, v34, v25, v26, v27);
      ++v29;
    }
    while ((v15 & 0xFFFFFFFD) == 0);
  }
  return v15;
}

BOOL sub_100007F70(uint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, __int16 a7)
{
  if (!a6) {
    return 0;
  }
  if (!a4) {
    return 1;
  }
  if (a4 < a2)
  {
    if (a6 <= a4)
    {
      if (a6 != a4 || (a7 & 0x4000) == 0) {
        return 0;
      }
      if (a1 <= a3) {
        unint64_t v9 = a3 - a1;
      }
      else {
        unint64_t v9 = a1 - a3 >= a6 ? a1 - (a3 + a6) : 0;
      }
      if (a1 <= a5) {
        unint64_t v12 = a5 - a1;
      }
      else {
        unint64_t v12 = a1 - a5 >= a6 ? a1 - (a5 + a6) : 0;
      }
      if (v12 >= v9) {
        return 0;
      }
    }
    return 1;
  }
  if (a4 != a2)
  {
    unint64_t v10 = a4 - a2;
    if (a4 > a2)
    {
      unint64_t v11 = a6 - a2;
      if (a6 >= a2)
      {
        if (a6 == a2 || v10 <= 0xF && v11 > v10) {
          return 1;
        }
        if ((a7 & 0x4000) != 0)
        {
          if (a1 <= a3)
          {
            unint64_t v14 = a3 - a1;
          }
          else if (a1 - a3 >= a4)
          {
            unint64_t v14 = a1 - (a3 + a4);
          }
          else
          {
            unint64_t v14 = 0;
          }
          if (a1 <= a5)
          {
            unint64_t v15 = a5 - a1;
          }
          else if (a1 - a5 >= a6)
          {
            unint64_t v15 = a1 - (a5 + a6);
          }
          else
          {
            unint64_t v15 = 0;
          }
          return v11 >= 0x10 && v15 < v14;
        }
        if (v11 < v10 && v11 > 0xF) {
          return 1;
        }
      }
    }
    return 0;
  }
  if (a6 < a4 || a6 != a4 && (a7 & 0x4000) == 0) {
    return 0;
  }
  if (a1 <= a3) {
    unint64_t v8 = a3 - a1;
  }
  else {
    unint64_t v8 = a1 - a3 >= a4 ? a1 - (a3 + a4) : 0;
  }
  if (a1 <= a5) {
    unint64_t v13 = a5 - a1;
  }
  else {
    unint64_t v13 = a1 - a5 >= a6 ? a1 - (a5 + a6) : 0;
  }
  if (v13 >= v8) {
    return 0;
  }
  BOOL result = 1;
  if (a6 != a4 && a6 - a4 <= 0xF) {
    return 0;
  }
  return result;
}

uint64_t sub_10000811C(uint64_t a1, __int16 a2, unint64_t a3, unint64_t a4)
{
  unint64_t v8 = a3;
  if ((a2 & 0x1000) != 0)
  {
    if (a4 > 1)
    {
      if (a4 + (a4 >> 1) >= a3) {
        unint64_t v8 = a3;
      }
      else {
        unint64_t v8 = a4 + (a4 >> 1);
      }
    }
    else
    {
      unint64_t v8 = a4 + 1;
    }
  }
  unint64_t v9 = *(void *)(a1 + 200);
  uint64_t v10 = *(void *)(a1 + 208);
  int64_t v11 = *(void *)(a1 + 160);
  if (*(void *)(a1 + 152) > v9) {
    unint64_t v9 = *(void *)(a1 + 152);
  }
  uint64_t v12 = *(void *)(a1 + 168);
  unint64_t v42 = v8;
  if (v10)
  {
    uint64_t v14 = v10 - v11;
    BOOL v13 = v10 <= v11;
    uint64_t v15 = v12 + v11;
    if (v10 < v11) {
      int64_t v11 = *(void *)(a1 + 208);
    }
    if (v13) {
      uint64_t v16 = 0;
    }
    else {
      uint64_t v16 = v14;
    }
    uint64_t v17 = *(void *)(a1 + 216) + v16;
    if (v15 > v17 + v11) {
      uint64_t v12 = v15 - v11;
    }
    else {
      uint64_t v12 = v17;
    }
  }
  uint64_t v18 = *(void *)(a1 + 136);
  uint64_t v19 = *(void *)(a1 + 144);
  uint64_t v21 = *(void *)(a1 + 184);
  uint64_t v20 = *(void *)(a1 + 192);
  unint64_t v23 = *(void *)(a1 + 248);
  unint64_t v22 = *(void *)(a1 + 256);
  if (v9 <= v23) {
    unint64_t v24 = *(void *)(a1 + 248);
  }
  else {
    unint64_t v24 = v9;
  }
  unint64_t v25 = calc_overlap_range(v22, *(void *)(a1 + 264), v11, v12, 0);
  uint64_t v26 = *(void *)(a1 + 96);
  uint64_t v27 = *(void *)(*(void *)(*(void *)(a1 + 8) + 376) + 48 * *(_DWORD *)(a1 + 88) + 72);
  if (v26 == v27) {
    goto LABEL_22;
  }
  if ((*(unsigned char *)(a1 + 280) & 1) == 0)
  {
LABEL_53:
    *(void *)(a1 + 440) = 0;
    unsigned int v29 = (void *)(a1 + 448);
    uint64_t result = 1;
    goto LABEL_54;
  }
  unint64_t v30 = v20 + v19;
  if (!v26 && v27 && v30 + *(void *)(a1 + 240))
  {
    long long v41 = (void *)(a1 + 456);
    goto LABEL_52;
  }
  if ((a2 & 0x1000) == 0 || a4 <= (3 * a3) >> 2)
  {
    if (v24 >= v42)
    {
      long long v41 = (void *)(a1 + 464);
      goto LABEL_52;
    }
    if (v24 <= a4) {
      unint64_t v31 = a4;
    }
    else {
      unint64_t v31 = v24;
    }
    if (v42 <= *(void *)(a1 + 240) + v30 + v31 + v31 * (v18 + v21 + *(void *)(a1 + 232)))
    {
      unsigned int v32 = *(unsigned __int16 *)(a1 + 94);
      int v33 = *(_DWORD *)(a1 + 88) >> 8;
      signed int v34 = v33 - 1;
      int v35 = v33 - v32;
      if (v35 <= 4) {
        LODWORD(v36) = v35 + 4;
      }
      else {
        LODWORD(v36) = 8;
      }
      uint64_t v36 = (int)v36;
      if (v34 <= (int)v32) {
        uint64_t v36 = 4;
      }
      unint64_t v37 = (64 - v42) >> 4;
      if (v42 >= 0x40) {
        unint64_t v37 = 0;
      }
      unint64_t v38 = v36 + v37 + (*(void *)(a1 + 440) >> 14);
      if (v34 / 10 <= v32)
      {
        unint64_t v39 = *(void *)(a1 + 128);
        if (v39 < *(void *)(a1 + 328))
        {
          unint64_t v40 = *(void *)(a1 + 176);
          if (v40 <= *(void *)(a1 + 224)) {
            unint64_t v40 = *(void *)(a1 + 224);
          }
          if (v40 >= *(void *)(a1 + 248) && v39 - *(void *)(a1 + 120) < 4) {
            unint64_t v38 = 1;
          }
        }
      }
      if (v30 > (v12 - v25 + *(void *)(a1 + 264)) / v38)
      {
        long long v41 = (void *)(a1 + 472);
LABEL_52:
        ++*v41;
        goto LABEL_53;
      }
    }
  }
LABEL_22:
  uint64_t result = 0;
  ++*(void *)(a1 + 440);
  unsigned int v29 = (void *)(a1 + 432);
LABEL_54:
  ++*v29;
  return result;
}

uint64_t sub_1000083A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_WORD *)(a2 + 96) = 0;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  *(unsigned char *)(a2 + 96) = 0;
  uint64_t v10 = *(unsigned __int16 *)(a1 + 104);
  *(_WORD *)a2 = v10;
  if (v10) {
    *(unsigned char *)(a2 + 2) = *(unsigned char *)(*(void *)(a1 + 80) + 24 * v10 + 7);
  }
  while (1)
  {
    uint64_t v11 = *(unsigned __int8 *)(a2 + 97);
    if (!*(_WORD *)(a2 + 4 * v11)) {
      break;
    }
    uint64_t result = sub_100008438(a1, a2, 0xFFFFFFFFLL, a4, a5, a6, a7, a8);
    if (result) {
      return result;
    }
  }
  unsigned int v13 = v11 - 1;
  *(unsigned char *)(a2 + 97) = v13;
  return (v13 >> 6) & 2;
}

uint64_t sub_100008438(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(char *)(a2 + 97);
  uint64_t v9 = *(unsigned __int8 *)(a2 + 97);
  *(unsigned char *)(a2 + 4 * v9 + 3) = a3;
  if (v8 < 23)
  {
    uint64_t v11 = 4 * v9;
    unsigned __int8 v12 = v9 + 1;
    *(unsigned char *)(a2 + 97) = v12;
    unsigned int v13 = *(unsigned __int16 *)(a2 + v11);
    uint64_t v14 = *(void *)(a1 + 80);
    unsigned int v15 = *(unsigned __int8 *)(a2 + 96);
    uint64_t v16 = *(unsigned __int16 *)(v14 + 24 * v13 + 4 * *(unsigned __int8 *)(a2 + 96) + (((_WORD)a3 + 1) & 0x1FE) + 16);
    uint64_t v17 = a2 + 4 * v12;
    *(_WORD *)uint64_t v17 = v16;
    *(unsigned char *)(v17 + 3) = 0;
    if (v16)
    {
      if (v15 >= 2) {
        sub_10005D334();
      }
      if (v15) {
        char v18 = *(unsigned char *)(v14 + 24 * v16 + 15);
      }
      else {
        char v18 = *(unsigned char *)(v14 + 24 * v16 + 7);
      }
    }
    else
    {
      char v18 = 0;
    }
    uint64_t result = 0;
    *(unsigned char *)(a2 + 4 * v12 + 2) = v18;
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s dev %d %s tree: PATH TOO LONG: %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"spaceman_fxtp_add_child");
    return 84;
  }
  return result;
}

uint64_t sub_10000854C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9 = -(int)a3;
  uint64_t v10 = *(unsigned __int8 *)(a2 + 97);
  if (*(_WORD *)(*(void *)(a1 + 80)
                + 24 * *(unsigned __int16 *)(a2 + 4 * v10)
                + 4 * *(unsigned __int8 *)(a2 + 96)
                + (((_WORD)a3 + 1) & 0x1FE)
                + 16))
  {
    uint64_t result = sub_100008438(a1, a2, a3, a4, a5, a6, a7, a8);
    if (!result)
    {
      uint64_t v18 = (char)v9;
      while (1)
      {
        uint64_t v19 = *(unsigned __int8 *)(a2 + 97);
        if (!*(_WORD *)(a2 + 4 * v19)) {
          break;
        }
        uint64_t result = sub_100008438(a1, a2, v18, v13, v14, v15, v16, v17);
        if (result) {
          return result;
        }
      }
      unsigned __int8 v24 = v19 - 1;
      *(unsigned char *)(a2 + 97) = v24;
      unint64_t v22 = (unsigned char *)(a2 + 4 * v24 + 3);
LABEL_13:
      uint64_t result = 0;
      *unint64_t v22 = 0;
    }
  }
  else
  {
    LODWORD(v10) = (char)v10;
    while (1)
    {
      BOOL v20 = __OFSUB__(v10, 1);
      LODWORD(v10) = v10 - 1;
      if ((int)v10 < 0 != v20) {
        return 2;
      }
      uint64_t v21 = a2 + 4 * v10;
      int v23 = *(unsigned __int8 *)(v21 + 3);
      unint64_t v22 = (unsigned char *)(v21 + 3);
      if (v23 == v9)
      {
        *(unsigned char *)(a2 + 97) = v10;
        goto LABEL_13;
      }
    }
  }
  return result;
}

uint64_t sub_100008630(uint64_t result, unsigned int a2, int a3, unsigned int a4, _WORD *a5)
{
  if (!a4) {
    sub_10005D6A4();
  }
  uint64_t v5 = *(void *)(result + 80);
  uint64_t v6 = v5 + 24 * a4 + 4 * a2 + 16;
  unsigned int v7 = *(unsigned __int16 *)(v6
                           + 2
                           * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1));
  if (!*(_WORD *)(v6 + 2 * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1))) {
    sub_10005D6D0();
  }
  uint64_t v8 = v5
     + 24
     * *(unsigned __int16 *)(v6
                           + 2
                           * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1))
     + 4 * a2
     + 2 * ((a3 + 1 + (((a3 + 1) & 0x8000u) >> 15)) >> 1);
  *(_WORD *)(v6 + 2 * (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1)) = *(_WORD *)(v8 + 16);
  *(_WORD *)(v8 + 16) = a4;
  *a5 = v7;
  if (a2 >= 2) {
    sub_10005D334();
  }
  uint64_t v9 = v5 + 24 * v7;
  if (a2) {
    v9 += 8;
  }
  if (*(unsigned char *)(v9 + 7))
  {
    uint64_t v13 = (void *)(v5 + 24 * a4);
    if (a2) {
      ++v13;
    }
    *v13 &= 0xFFFFFFFFFFFFFFuLL;
    unint64_t v12 = *(void *)v9 & 0xFFFFFFFFFFFFFFLL;
  }
  else
  {
    uint64_t v10 = (uint64_t *)(v5 + 24 * a4);
    if (a2) {
      ++v10;
    }
    uint64_t v11 = *v10;
    if (a3 == -1)
    {
      uint64_t *v10 = v11 & 0xFFFFFFFFFFFFFFLL | 0x100000000000000;
      unint64_t v12 = *(void *)v9 | 0xFF00000000000000;
    }
    else
    {
      uint64_t *v10 = v11 | 0xFF00000000000000;
      unint64_t v12 = *(void *)v9 & 0xFFFFFFFFFFFFFFLL | 0x100000000000000;
    }
  }
  *(void *)uint64_t v9 = v12;
  return result;
}

uint64_t sub_100008760(uint64_t a1, unsigned int a2, int a3, unsigned int a4, unsigned int a5, _WORD *a6)
{
  if (!a4) {
    sub_10005D6FC();
  }
  if (!a5) {
    sub_10005D728();
  }
  int v6 = -a3;
  uint64_t v7 = *(void *)(a1 + 80);
  uint64_t v8 = v7 + 24 * a5 + 4 * a2 + 16;
  uint64_t v9 = (((char)-(char)a3 + 1 + ((((char)-(char)a3 + 1) & 0x8000u) >> 15)) >> 1);
  unsigned int v10 = *(unsigned __int16 *)(v8 + 2 * v9);
  if (!*(_WORD *)(v8 + 2 * v9)) {
    sub_10005D754();
  }
  uint64_t v11 = v7 + 24 * *(unsigned __int16 *)(v8 + 2 * v9);
  uint64_t v12 = v11 + 4 * a2 + 16;
  uint64_t result = *(unsigned __int16 *)(v12 + 2 * ((a3 + 1 + (((a3 + 1) & 0x8000u) >> 15)) >> 1));
  *(_WORD *)(v8 + 2 * v9) = result;
  *(_WORD *)(v12 + 2 * ((a3 + 1 + (((a3 + 1) & 0x8000u) >> 15)) >> 1)) = a5;
  *(_WORD *)(v7 + 24 * a4 + 4 * a2 + 2 * ((a3 + 1 + (((a3 + 1) & 0x8000u) >> 15)) >> 1) + 16) = *(_WORD *)(v12 + 2 * v9);
  *(_WORD *)(v12 + 2 * v9) = a4;
  *a6 = v10;
  if (a2 >= 2) {
    sub_10005D334();
  }
  if (a2) {
    unsigned __int8 v14 = *(unsigned char *)(v7 + 24 * v10 + 15);
  }
  else {
    unsigned __int8 v14 = *(unsigned char *)(v11 + 7);
  }
  if (v14 == a3)
  {
    uint64_t v15 = v7 + 24 * a4;
    BOOL v16 = a2 == 0;
    if (a2) {
      v15 += 8;
    }
    *(unsigned char *)(v15 + 7) = v6;
    uint64_t v17 = (void *)(v7 + 24 * a5);
LABEL_22:
    if (!v16) {
      ++v17;
    }
    *v17 &= 0xFFFFFFFFFFFFFFuLL;
    goto LABEL_25;
  }
  if (!v14)
  {
    BOOL v20 = (void *)(v7 + 24 * a4);
    BOOL v16 = a2 == 0;
    if (a2) {
      ++v20;
    }
    *v20 &= 0xFFFFFFFFFFFFFFuLL;
    uint64_t v17 = (void *)(v7 + 24 * a5);
    goto LABEL_22;
  }
  if (v14 != v6) {
    sub_10005D780();
  }
  uint64_t v18 = (void *)(v7 + 24 * a4);
  if (a2) {
    ++v18;
  }
  *v18 &= 0xFFFFFFFFFFFFFFuLL;
  uint64_t v19 = v7 + 24 * a5;
  if (a2) {
    v19 += 8;
  }
  *(unsigned char *)(v19 + 7) = a3;
LABEL_25:
  uint64_t v21 = (void *)(v7 + 24 * v10 + 8);
  if (!a2) {
    uint64_t v21 = (void *)v11;
  }
  *v21 &= 0xFFFFFFFFFFFFFFuLL;
  return result;
}

uint64_t xf_init(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (a2)
  {
    __int16 v2 = a2;
    *(_WORD *)(a1 + 2) = 4;
    int64_t v4 = _apfs_malloc(0x10uLL);
    *(void *)(a1 + 8) = v4;
    if (!v4) {
      *(_WORD *)(a1 + 2) = 0;
    }
    *(_WORD *)(a1 + 6) = (v2 + 7) & 0xFFF8;
    uint64_t v5 = _apfs_malloc((unsigned __int16)(v2 + 7) & 0xFFF8);
    *(void *)(a1 + 16) = v5;
    if (!v5) {
      *(_WORD *)(a1 + 6) = 0;
    }
  }
  return 0;
}

uint64_t xf_init_with_blob(unsigned __int16 *a1, unsigned __int16 *a2, unint64_t a3)
{
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  *((void *)a1 + 2) = 0;
  if (a3 < 4) {
    return 28;
  }
  uint64_t v6 = *a2;
  *a1 = v6;
  uint64_t v7 = a2[1];
  a1[2] = v7;
  a1[1] = v6;
  if (v7 + 4 * v6 + 4 > a3) {
    goto LABEL_10;
  }
  if (v6)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2 + 3;
    uint64_t v10 = v6;
    while (v7 > v8)
    {
      signed int v11 = *v9;
      if ((int)(v7 - v8) < v11) {
        break;
      }
      v8 += (v11 + 7) & 0x1FFF8;
      v9 += 2;
      if (!--v10) {
        goto LABEL_9;
      }
    }
    goto LABEL_10;
  }
LABEL_9:
  unsigned int v12 = ((_WORD)v7 + 7) & 0xFFF8;
  a1[3] = v12;
  if (v12 < v7)
  {
LABEL_10:
    uint64_t result = 22;
LABEL_11:
    *(void *)a1 = 0;
    *((void *)a1 + 1) = 0;
    *((void *)a1 + 2) = 0;
    return result;
  }
  uint64_t v13 = 2 * v6;
  *((void *)a1 + 1) = _apfs_malloc(4 * v6);
  unsigned __int8 v14 = _apfs_malloc(a1[3]);
  *((void *)a1 + 2) = v14;
  uint64_t v15 = (void *)*((void *)a1 + 1);
  uint64_t v16 = *a1;
  if (!v15 || !v14)
  {
    _apfs_free(v15, 4 * v16);
    _apfs_free(*((void **)a1 + 2), a1[3]);
    uint64_t result = 12;
    goto LABEL_11;
  }
  memcpy(v15, a2 + 2, 4 * v16);
  memcpy(*((void **)a1 + 2), &a2[v13 + 2], a1[2]);
  bzero((void *)(*((void *)a1 + 2) + a1[2]), a1[3] - (unint64_t)a1[2]);
  return 0;
}

uint64_t xf_get_from_blob(unsigned __int16 *a1, unint64_t a2, int a3, _DWORD *a4, void *a5, _DWORD *a6)
{
  if (a2 < 4) {
    return 28;
  }
  uint64_t v7 = *a1;
  uint64_t v8 = a1[1];
  if (v8 + 4 * v7 + 4 > a2) {
    return 22;
  }
  if (*a1)
  {
    unsigned int v9 = 0;
    uint64_t v10 = (uint64_t)&a1[2 * v7 + 2];
    for (char i = a1 + 3; ; i += 2)
    {
      int v12 = *i;
      if (v9 + v12 > v8) {
        break;
      }
      if (*((unsigned __int8 *)i - 2) == a3)
      {
        if (a4) {
          *a4 = *((unsigned __int8 *)i - 1);
        }
        if (a6) {
          *a6 = v12;
        }
        uint64_t result = 0;
        *a5 = v10 + v9;
        return result;
      }
      v9 += (v12 + 7) & 0x1FFF8;
      if (!--v7) {
        return 2;
      }
    }
    return 22;
  }
  return 2;
}

uint64_t xf_set_in_blob(unsigned __int16 *a1, unint64_t a2, int a3, const void *a4, int a5)
{
  int v9 = 0;
  __dst = 0;
  uint64_t result = xf_get_from_blob(a1, a2, a3, 0, &__dst, &v9);
  if (!result)
  {
    if (v9 == a5)
    {
      memcpy(__dst, a4, a5);
      return 0;
    }
    else
    {
      return 34;
    }
  }
  return result;
}

uint64_t xf_deep_copy(uint64_t a1, unsigned __int16 *a2)
{
  if (*((void *)a2 + 2))
  {
    int64_t v4 = _apfs_malloc(a2[3]);
    if (!v4) {
      return 12;
    }
    uint64_t v5 = v4;
    memcpy(v4, *((const void **)a2 + 2), a2[3]);
  }
  else
  {
    uint64_t v5 = 0;
  }
  if (!*((void *)a2 + 1))
  {
    uint64_t v7 = 0;
    goto LABEL_9;
  }
  uint64_t v6 = _apfs_malloc(4 * a2[1]);
  if (v6)
  {
    uint64_t v7 = v6;
    memcpy(v6, *((const void **)a2 + 1), 4 * *a2);
LABEL_9:
    uint64_t result = 0;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v5;
    return result;
  }
  _apfs_free(v5, a2[3]);
  return 12;
}

uint64_t xf_release(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  return 0;
}

uint64_t xf_get_size(unsigned __int16 *a1)
{
  return a1[2] + 4 * *a1 + 4;
}

uint64_t xf_serialize(unsigned __int16 *a1, _WORD *a2, unint64_t a3)
{
  uint64_t v3 = *a1;
  if ((unint64_t)a1[2] + 4 * v3 + 4 > a3) {
    return 28;
  }
  *a2 = v3;
  a2[1] = a1[2];
  uint64_t v6 = a2 + 2;
  memcpy(a2 + 2, *((const void **)a1 + 1), 4 * *a1);
  memcpy(&v6[2 * *a1], *((const void **)a1 + 2), a1[2]);
  return 0;
}

uint64_t xf_set(unsigned __int16 *a1, int a2, char a3, void *__src, size_t __n)
{
  char v8 = a2;
  uint64_t v10 = *a1;
  if (*a1)
  {
    int v11 = 0;
    uint64_t v12 = 0;
    unsigned int v13 = 0;
    unsigned int v14 = *a1;
    uint64_t v15 = *((void *)a1 + 1);
    int v16 = v10 - 1;
    while (*(unsigned __int8 *)(v15 + v12) != a2)
    {
      v13 += (*(unsigned __int16 *)(v15 + v12 + 2) + 7) & 0x1FFF8;
      v12 += 4;
      ++v11;
      if (4 * v10 == v12) {
        goto LABEL_14;
      }
    }
    uint64_t v17 = *((void *)a1 + 2);
    uint64_t v18 = (char *)(v17 + v13);
    uint64_t v19 = v15 + v12;
    *(unsigned char *)(v19 + 1) = a3;
    if (v18)
    {
      uint64_t v20 = *(unsigned __int16 *)(v19 + 2);
      if (v20 == __n) {
        goto LABEL_22;
      }
      unint64_t v21 = (v20 + 7) & 0x1FFF8;
      size_t v22 = (__n + 7) & 0xFFFFFFFFFFFFFFF8;
      size_t v23 = v22 - v21;
      if (v22 < v21)
      {
        if (v16 > v11) {
          memmove((void *)(v17 + v13 + v22), (const void *)(v17 + v13 + v21), a1[3] - (v13 + v21));
        }
        unsigned __int16 v24 = a1[2] - (v21 - v22);
LABEL_32:
        a1[2] = v24;
LABEL_33:
        *(_WORD *)(*((void *)a1 + 1) + v12 + 2) = __n;
        if (!v18) {
          return 22;
        }
        goto LABEL_22;
      }
      if (v22 <= v21) {
        goto LABEL_33;
      }
      uint64_t v33 = v13;
      uint64_t v34 = a1[2];
      if (v23 + v34 <= a1[3])
      {
LABEL_29:
        if (v16 > v11)
        {
          memmove(&v18[v22], &v18[v21], v34 - v33 - v21);
          LOWORD(v34) = a1[2];
        }
        unsigned __int16 v24 = v34 + v23;
        goto LABEL_32;
      }
      if (!sub_100008FBC((uint64_t)a1, __n))
      {
        uint64_t v18 = (char *)(*((void *)a1 + 2) + v33);
        LODWORD(v34) = a1[2];
        int v16 = *a1 - 1;
        goto LABEL_29;
      }
      return 28;
    }
    unsigned int v14 = v11;
  }
  else
  {
    unsigned int v14 = 0;
  }
LABEL_14:
  uint64_t v25 = a1[1];
  if (v10 >= v25)
  {
    unsigned __int16 v26 = v25 + 4;
    uint64_t v27 = _apfs_realloc(*((void **)a1 + 1), 4 * v25, (4 * (v25 + 4)));
    if (!v27) {
      return 28;
    }
    *((void *)a1 + 1) = v27;
    a1[1] = v26;
  }
  uint64_t v28 = a1[2];
  size_t v29 = (__n + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v29 + v28 > a1[3])
  {
    if (sub_100008FBC((uint64_t)a1, __n)) {
      return 28;
    }
    uint64_t v28 = a1[2];
  }
  uint64_t v31 = *((void *)a1 + 2);
  uint64_t v32 = *((void *)a1 + 1) + 4 * v14;
  *(unsigned char *)uint64_t v32 = v8;
  *(unsigned char *)(v32 + 1) = a3;
  *(_WORD *)(v32 + 2) = __n;
  ++*a1;
  uint64_t v18 = (char *)(v31 + v28);
  a1[2] = v28 + v29;
  if (!(v31 + v28)) {
    return 22;
  }
LABEL_22:
  memcpy(v18, __src, __n);
  if ((__n & 7) != 0) {
    bzero(&v18[__n], 8 - (__n & 7));
  }
  return 0;
}

uint64_t sub_100008FBC(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(unsigned __int16 *)(a1 + 6);
  size_t v4 = ((a2 + 7) & 0xFFFFFFFFFFFFFFF8) + v3;
  uint64_t v5 = _apfs_realloc(*(void **)(a1 + 16), v3, v4);
  if (!v5) {
    return 28;
  }
  uint64_t v6 = v5;
  uint64_t result = 0;
  *(void *)(a1 + 16) = v6;
  *(_WORD *)(a1 + 6) = v4;
  return result;
}

uint64_t xf_get(unsigned __int16 *a1, int a2, _DWORD *a3, char *__dst, size_t __n)
{
  if (!*a1) {
    return 2;
  }
  uint64_t v9 = 0;
  unsigned int v10 = 0;
  uint64_t v11 = *((void *)a1 + 1);
  while (*(unsigned __int8 *)(v11 + v9) != a2)
  {
    v10 += (*(unsigned __int16 *)(v11 + v9 + 2) + 7) & 0x1FFF8;
    v9 += 4;
    if (4 * *a1 == v9) {
      return 2;
    }
  }
  unsigned int v13 = (const void *)(*((void *)a1 + 2) + v10);
  size_t v14 = *(unsigned __int16 *)(v11 + v9 + 2);
  if (v14 >= __n)
  {
    memcpy(__dst, v13, __n);
  }
  else
  {
    memcpy(__dst, v13, v14);
    uint64_t v15 = *(unsigned __int16 *)(*((void *)a1 + 1) + v9 + 2);
    bzero(&__dst[v15], __n - v15);
  }
  uint64_t result = 0;
  if (a3) {
    *a3 = *(unsigned __int8 *)(*((void *)a1 + 1) + v9 + 1);
  }
  return result;
}

uint64_t xf_get_ptr_and_size(unsigned __int16 *a1, int a2, _DWORD *a3, void *a4, _DWORD *a5)
{
  if (!*a1) {
    return 2;
  }
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  uint64_t v7 = *((void *)a1 + 1);
  while (*(unsigned __int8 *)(v7 + v5) != a2)
  {
    v6 += (*(unsigned __int16 *)(v7 + v5 + 2) + 7) & 0x1FFF8;
    v5 += 4;
    if (4 * *a1 == v5) {
      return 2;
    }
  }
  *a4 = *((void *)a1 + 2) + v6;
  if (a3) {
    *a3 = *(unsigned __int8 *)(*((void *)a1 + 1) + v5 + 1);
  }
  uint64_t v8 = 0;
  if (a5) {
    *a5 = *(unsigned __int16 *)(*((void *)a1 + 1) + v5 + 2);
  }
  return v8;
}

uint64_t xf_remove(unsigned __int16 *a1, int a2)
{
  if (!*a1) {
    return 2;
  }
  uint64_t v3 = 0;
  unsigned int v4 = 0;
  uint64_t v5 = *((void *)a1 + 1);
  for (uint64_t i = 2; *(unsigned __int8 *)(v5 + i - 2) != a2; i += 4)
  {
    v4 += (*(unsigned __int16 *)(v5 + i) + 7) & 0x1FFF8;
    if (*a1 == ++v3) {
      return 2;
    }
  }
  uint64_t v8 = (*(unsigned __int16 *)(v5 + i) + 7) & 0x1FFF8;
  memmove((void *)(*((void *)a1 + 2) + v4), (const void *)(*((void *)a1 + 2) + v4 + v8), (int)(a1[3] - v4 - v8));
  a1[2] -= v8;
  memmove((void *)(*((void *)a1 + 1) + i - 2), (const void *)(*((void *)a1 + 1) + i + 2), 4 * (~v3 + *a1));
  uint64_t result = 0;
  --*a1;
  return result;
}

uint64_t tx_mgr_init(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6 = *(unsigned int *)(*(void *)(a1 + 376) + 36);
  uint64_t v7 = (pthread_mutex_t *)_apfs_calloc(1uLL, 0x130uLL);
  if (!v7) {
    return 12;
  }
  uint64_t v8 = (uint64_t)v7;
  v7[1].__sig = a2;
  *(void *)v7[1].__opaque = 0;
  *(void *)&v7[1].__opaque[40] = 0;
  *(_DWORD *)&v7[1].__opaque[8] = 0;
  *(_DWORD *)&v7[1].__opaque[12] = (v6 - 40) / 0x28uLL;
  *(void *)&v7[1].__opaque[48] = (char *)v7 + 112;
  v7[2].__sig = 0;
  *(void *)v7[2].__opaque = v7 + 2;
  uint64_t inited = new_lock(v7);
  if (!inited)
  {
    uint64_t v10 = new_cv((pthread_cond_t *)(v8 + 256));
    if (v10)
    {
      uint64_t inited = v10;
      free_lock((pthread_mutex_t *)v8);
    }
    else if (*(unsigned char *)(a1 + 627) || (uint64_t inited = tx_mgr_init_tx(v8, v6), !inited))
    {
      uint64_t inited = 0;
      uint64_t v12 = *(void *)(a1 + 376);
      int v13 = *(_DWORD *)(v12 + 104) & 0x7FFFFFFF;
      int v14 = *(_DWORD *)(v12 + 108) & 0x7FFFFFFF;
      *(_DWORD *)(v8 + 88) = v13;
      *(_DWORD *)(v8 + 92) = v14;
      *(void *)(v8 + 96) = *(void *)(v12 + 128);
      *(_DWORD *)(v8 + 104) = v13;
      *(_DWORD *)(v8 + 108) = v14;
      *a3 = v8;
      return inited;
    }
  }
  _apfs_free((void *)v8, 304);
  return inited;
}

uint64_t tx_mgr_init_tx(uint64_t a1, unsigned int a2)
{
  size_t v3 = a2;
  int v4 = 4;
  while (1)
  {
    uint64_t v5 = _apfs_calloc(1uLL, 0x78uLL);
    if (!v5) {
      break;
    }
    uint64_t v6 = v5;
    v5[7] = _apfs_malloc(v3);
    v6[8] = _apfs_malloc(v3);
    uint64_t v7 = *(void **)(a1 + 120);
    *uint64_t v6 = 0;
    v6[1] = v7;
    *uint64_t v7 = v6;
    *(void *)(a1 + 120) = v6;
    if (!v6[7] || !v6[8]) {
      break;
    }
    if (!--v4) {
      return 0;
    }
  }
  while (1)
  {
    int v13 = *(uint64_t **)(a1 + 112);
    if (!v13) {
      break;
    }
    uint64_t v9 = *v13;
    uint64_t v10 = (void *)v13[1];
    if (*v13)
    {
      *(void *)(v9 + 8) = v10;
      uint64_t v10 = (void *)v13[1];
    }
    else
    {
      *(void *)(a1 + 120) = v10;
    }
    void *v10 = v9;
    uint64_t v11 = (void *)v13[7];
    if (v11) {
      _apfs_free(v11, v3);
    }
    uint64_t v12 = (void *)v13[8];
    if (v12) {
      _apfs_free(v12, v3);
    }
    _apfs_free(v13, 120);
  }
  return 12;
}

void tx_mgr_free_tx(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = a3;
  if (a2[18])
  {
    log_err((uint64_t)"%s:%d: %s Trash unfinished tx xid=0x%llx\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"tx_mgr_free_tx");
    uint64_t v10 = (void *)a2[18];
    uint64_t v11 = (void *)a2[15];
    void *v10 = 0;
    v10[1] = v11;
    *uint64_t v11 = v10;
    a2[15] = a2[18];
    a2[18] = 0;
  }
  if (a2[16])
  {
    log_err((uint64_t)"%s:%d: %s Trash unfinished pending tx, xid range = 0x%llx - 0x%llx\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"tx_mgr_free_tx");
    uint64_t v12 = a2[16];
    if (v12)
    {
      *(void *)a2[15] = v12;
      *(void *)(a2[16] + 8) = a2[15];
      a2[15] = a2[17];
      a2[16] = 0;
      a2[17] = a2 + 16;
    }
  }
  int v13 = (void *)a2[14];
  if (v13)
  {
    do
    {
      uint64_t v15 = (void *)*v13;
      int v14 = (void *)v13[1];
      if (*v13)
      {
        v15[1] = v14;
        int v14 = (void *)v13[1];
      }
      else
      {
        a2[15] = v14;
      }
      *int v14 = v15;
      int v16 = (void *)v13[7];
      if (v16) {
        _apfs_free(v16, v8);
      }
      uint64_t v17 = (void *)v13[8];
      if (v17) {
        _apfs_free(v17, v8);
      }
      _apfs_free(v13, 120);
      int v13 = v15;
    }
    while (v15);
  }
}

void tx_mgr_destroy(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  tx_mgr_free_tx(a1, (void *)a2, a3, a4, a5, a6, a7, a8);
  free_lock((pthread_mutex_t *)a2);
  free_cv((pthread_cond_t *)(a2 + 256));

  _apfs_free((void *)a2, 304);
}

BOOL xid_is_current_tx(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 624))
  {
    __int16 v2 = (void *)(*(void *)(a1 + 376) + 96);
    return *v2 == a2;
  }
  uint64_t v3 = *(void *)(a1 + 400);
  if (v3)
  {
    uint64_t v4 = *(void *)(v3 + 144);
    if (v4)
    {
      __int16 v2 = (void *)(v4 + 16);
      return *v2 == a2;
    }
  }
  return 0;
}

uint64_t tx_checkpoint_desc_zero(void *a1, int a2)
{
  uint64_t v4 = a1[50];
  size_t v5 = *(unsigned int *)(a1[47] + 36);
  uint64_t v6 = _apfs_calloc(1uLL, v5);
  if (!v6) {
    return 12;
  }
  uint64_t v7 = v6;
  uint64_t v19 = 0;
  if (a2)
  {
    unsigned int v8 = *(_DWORD *)(v4 + 96);
    while (1)
    {
      uint64_t v19 = -1;
      uint64_t v9 = nx_checkpoint_desc_block_address((uint64_t)a1, v8, &v19);
      if (v9) {
        break;
      }
      uint64_t v9 = dev_write(a1[48], v19);
      if (v9) {
        break;
      }
      unsigned int v8 = (*(_DWORD *)(v4 + 96) + 1) % *(_DWORD *)(v4 + 88);
      *(_DWORD *)(v4 + 96) = v8;
      if (!--a2) {
        goto LABEL_7;
      }
    }
    uint64_t v17 = v9;
    log_err((uint64_t)"%s:%d: %s failed to zero checkpoint descriptor block %d @ %lld: %d\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"tx_checkpoint_desc_zero");
  }
  else
  {
LABEL_7:
    uint64_t v17 = 0;
  }
  _apfs_free(v7, v5);
  return v17;
}

uint64_t tx_checkpoint_space_check(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a3;
  char v11 = 0;
  uint64_t v12 = *(void *)(a1 + 400);
  while (1)
  {
    unsigned int v13 = *(_DWORD *)(v12 + 96);
    unsigned int v14 = *(_DWORD *)(v12 + 104);
    unsigned int v15 = v14;
    if (v13 > v14) {
      unsigned int v15 = *(_DWORD *)(v12 + 88) + v14;
    }
    unsigned int v16 = *(_DWORD *)(v12 + 100);
    unsigned int v17 = *(_DWORD *)(v12 + 108);
    unsigned int v18 = v17;
    if (v16 > v17) {
      unsigned int v18 = *(_DWORD *)(v12 + 92) + v17;
    }
    unsigned int v19 = v15 - v13;
    if (*(_DWORD *)(a2 + 48) + v8 <= v18 - v16 && !(v11 & 1 | (*(_DWORD *)(a2 + 40) + 1 > v19))) {
      return 0;
    }
    if ((v11 & 1) != 0 || !*(void *)(v12 + 128)) {
      break;
    }
    sub_100009888(a1, 0x50u, 0);
    char v11 = 1;
  }
  if (!*(_WORD *)(v12 + 82)) {
    log_err((uint64_t)"%s:%d: %s checkpoint area out of space: stable: %d %d - next %d %d available %d %d tx[%lld] %d %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"tx_checkpoint_space_check");
  }
  *(_WORD *)(v12 + 82) = 1;
  return 28;
}

uint64_t sub_100009888(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 400);
  if ((a2 & 0x40) != 0)
  {
    uint64_t v7 = *(void *)(v6 + 128);
    if (!v7 || (*(unsigned char *)(v7 + 24) & 0x40) == 0) {
      return 0;
    }
  }
  if (a3) {
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 400));
  }
  uint64_t v8 = dev_barrier(*(void *)(a1 + 384), (a2 >> 4) & 1);
  if (a3) {
    pthread_mutex_lock((pthread_mutex_t *)v6);
  }
  if (v8 == 25 || v8 == 0)
  {
    uint64_t v8 = *(void *)(v6 + 128);
    if (v8)
    {
      do
      {
        uint64_t v10 = *(void *)v8;
        int v11 = *(_DWORD *)(v8 + 24);
        if ((v11 & 0x40) != 0)
        {
          *(_DWORD *)(v8 + 24) = v11 & 0xFFFFFFBF;
          v19.tv_sec = 0;
          v19.tv_nsec = 0;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v19);
          __darwin_time_t v12 = 1000000 * v19.tv_sec + SLODWORD(v19.tv_nsec) / 1000;
          __darwin_time_t v13 = v12 - *(void *)(v8 + 72);
          *(void *)(v8 + 72) = v12;
          *(void *)(v8 + 104) += v13;
          unint64_t v14 = *(void *)(v8 + 16);
          if (!*(unsigned char *)(a1 + 632) || v14 < *(void *)(*(void *)(a1 + 376) + 1408))
          {
            *(_DWORD *)(v6 + 104) = *(_DWORD *)(v8 + 36);
            *(_DWORD *)(v6 + 108) = *(_DWORD *)(v8 + 44);
          }
          spaceman_tx_complete((void *)a1, v14);
          uint64_t v15 = *(void *)v8;
          unsigned int v16 = *(uint64_t **)(v8 + 8);
          if (*(void *)v8)
          {
            *(void *)(v15 + 8) = v16;
            unsigned int v16 = *(uint64_t **)(v8 + 8);
          }
          else
          {
            *(void *)(v6 + 136) = v16;
          }
          *unsigned int v16 = v15;
          *(void *)uint64_t v8 = 0;
          unsigned int v17 = *(uint64_t **)(v6 + 120);
          *(void *)(v8 + 8) = v17;
          *unsigned int v17 = v8;
          *(void *)(v6 + 120) = v8;
          cv_wakeup((pthread_cond_t *)(v6 + 256));
        }
        uint64_t v8 = v10;
      }
      while (v10);
    }
  }
  return v8;
}

uint64_t tx_checkpoint_write_prepare(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = (*(_DWORD *)(*(void *)(a1 + 376) + 36) + *(_DWORD *)(a3 + 48) - 1)
      / *(_DWORD *)(*(void *)(a1 + 376) + 36);
  uint64_t v11 = *(void *)(a2 + 64);
  if (*(_DWORD *)(v11 + 36) == *(_DWORD *)(*(void *)(a1 + 400) + 84))
  {
    ++*(_DWORD *)(a2 + 40);
    *(_DWORD *)(v11 + 36) = 0;
  }
  uint64_t v12 = tx_checkpoint_space_check(a1, a2, v10, a4, a5, a6, a7, a8);
  if (!v12)
  {
    if ((*(unsigned char *)(a3 + 19) & 0x20) == 0)
    {
      uint64_t v15 = *(void **)(a3 + 56);
      v13.i64[0] = *(void *)(a3 + 36);
      v15[3] = v13.i64[0];
      uint64_t v16 = *(void *)(a2 + 16);
      v15[1] = *(void *)(a3 + 112);
      v15[2] = v16;
      obj_checksum_set(a3, v13, v14);
    }
    *(void *)(a3 + 120) = *(void *)(a2 + 16);
    *(void *)(a3 + 144) = 0;
    ++*(_DWORD *)(*(void *)(a2 + 64) + 36);
    *(_DWORD *)(a2 + 48) += v10;
  }
  return v12;
}

uint64_t tx_checkpoint_write(void *a1, uint64_t a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  uint64_t v8 = (_DWORD *)a1[50];
  uint64_t v66 = 0;
  unint64_t v64 = 0;
  size_t v9 = *(unsigned int *)(a1[47] + 36);
  int v10 = *(_DWORD *)(a3 + 48);
  uint64_t v11 = *(void *)(a2 + 64);
  if (*(_DWORD *)(v11 + 36) == v8[21])
  {
    obj_checksum_set_phys((uint64_t)a1, (unint64_t *)v11, *(_DWORD *)(a1[47] + 36), a4, a5);
    uint64_t v12 = dev_write(a1[48], *(void *)(*(void *)(a2 + 64) + 8));
    if (v12)
    {
      uint64_t v20 = v12;
      if (!v8[19]) {
        log_err((uint64_t)"%s:%d: %s failed to write checkpoint map block %lld: %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"tx_checkpoint_write");
      }
      return v20;
    }
    unint64_t v21 = (*(_DWORD *)(a2 + 40) + v8[24]) % v8[22];
    uint64_t v66 = -1;
    uint64_t v22 = nx_checkpoint_desc_block_address((uint64_t)a1, v21, &v66);
    if (v22)
    {
      uint64_t v20 = v22;
      if (!v8[19]) {
        log_err((uint64_t)"%s:%d: %s error getting next checkpoint map block address %d: %d\n", v23, v24, v25, v26, v27, v28, v29, (uint64_t)"tx_checkpoint_write");
      }
      return v20;
    }
    bzero(*(void **)(a2 + 64), v9);
    uint64_t v30 = *(void *)(a2 + 64);
    *(_DWORD *)(v30 + 24) = 1073741836;
    *(void *)(v30 + 8) = v66;
    *(void *)(v30 + 16) = *(void *)(a2 + 16);
    ++*(_DWORD *)(a2 + 40);
  }
  unint64_t v31 = (*(_DWORD *)(a2 + 48) + v8[25]) % v8[23];
  uint64_t v65 = -1;
  uint64_t v32 = nx_checkpoint_data_block_address((uint64_t)a1, v31, &v65, &v64);
  if (v32)
  {
    uint64_t v20 = v32;
    if (!v8[19]) {
      log_err((uint64_t)"%s:%d: %s error getting next checkpoint data block address %d: %d\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"tx_checkpoint_write");
    }
  }
  else
  {
    signed int v40 = ((int)v9 + v10 - 1) / v9;
    pthread_mutex_lock((pthread_mutex_t *)(a1[49] + 328));
    for (uint64_t i = (atomic_uint *)(a3 + 32);
          (atomic_fetch_or_explicit(i, 8u, memory_order_relaxed) & 8) != 0;
          uint64_t i = (atomic_uint *)(a3 + 32))
    {
      pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328));
      pthread_mutex_lock((pthread_mutex_t *)(a1[49] + 328));
    }
    uint64_t v63 = *(char **)(a3 + 64);
    *(void *)(a3 + 128) = v65;
    signed int v62 = v40;
    if (v40 < 1)
    {
LABEL_27:
      if (v63 == *(char **)(a3 + 56)) {
        unint64_t v46 = 0;
      }
      else {
        unint64_t v46 = v63;
      }
      *(void *)(a3 + 64) = 0;
      uint64_t v47 = a1[49];
      if (*(void *)(v47 + 848) != a3) {
        sub_10005D7AC();
      }
      uint64_t v48 = *(void *)(a3 + 104);
      *(void *)(v47 + 848) = v48;
      if (!v48) {
        *(void *)(v47 + 856) = v47 + 848;
      }
      *(void *)(a3 + 104) = 3735928559;
      atomic_fetch_and_explicit((atomic_uint *volatile)(a3 + 32), 0xFFFFFFF7, memory_order_relaxed);
      pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328));
      uint64_t v49 = *(void *)(a2 + 64);
      unsigned int v50 = *(_DWORD *)(v49 + 36);
      uint64_t v51 = v49 + 40 * v50;
      *(void *)(v51 + 40) = *(void *)(a3 + 36);
      *(void *)(v51 + 48) = *(unsigned int *)(a3 + 48);
      uint64_t v52 = *(void *)(a3 + 8);
      if (v52)
      {
        uint64_t v52 = obj_oid(v52);
        uint64_t v49 = *(void *)(a2 + 64);
        unsigned int v50 = *(_DWORD *)(v49 + 36);
      }
      uint64_t v53 = (void *)(v49 + 40 * v50);
      v53[7] = v52;
      v53[8] = *(void *)(a3 + 112);
      v53[9] = *(void *)(a3 + 128);
      *(_DWORD *)(v49 + 36) = v50 + 1;
      *(_DWORD *)(a2 + 48) += v62;
      if (v46) {
        fs_obj_zfree_oc(v46, *(unsigned int *)(a3 + 48), *(void *)(a3 + 16), a1[49]);
      }
      return 0;
    }
    else
    {
      unint64_t v42 = v63;
      int v43 = v62;
      while (1)
      {
        unint64_t v44 = v64 >= v43 ? v43 : v64;
        uint64_t v45 = dev_write(a1[48], v65);
        if (v45) {
          break;
        }
        v43 -= v44;
        if (!v43) {
          goto LABEL_27;
        }
        unint64_t v31 = (int)v31 + (int)v44 >= (*(_DWORD *)(a1[47] + 108) & 0x7FFFFFFFu) ? 0 : (v31 + v44);
        uint64_t v45 = nx_checkpoint_data_block_address((uint64_t)a1, v31, &v65, &v64);
        if (v45) {
          break;
        }
        v42 += v44 * v9;
        if (v43 <= 0) {
          goto LABEL_27;
        }
      }
      uint64_t v20 = v45;
      atomic_fetch_and_explicit((atomic_uint *volatile)(a3 + 32), 0xFFFFFFF7, memory_order_relaxed);
      pthread_mutex_unlock((pthread_mutex_t *)(a1[49] + 328));
      if (!v8[19]) {
        log_err((uint64_t)"%s:%d: %s failed to write checkpoint data block %lld: %d\n", v54, v55, v56, v57, v58, v59, v60, (uint64_t)"tx_checkpoint_write");
      }
    }
  }
  return v20;
}

uint64_t tx_barrier(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 400);
  if ((a2 & 0x80) != 0 && (uint64_t v5 = *(void *)(v4 + 144)) != 0 && (*(unsigned char *)(v5 + 24) & 8) != 0)
  {
    int v6 = 0;
    if ((a2 & 0x40) == 0) {
      goto LABEL_11;
    }
  }
  else
  {
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 400));
    int v6 = 1;
    if ((a2 & 0x40) == 0) {
      goto LABEL_11;
    }
  }
  uint64_t v7 = *(void *)(v4 + 128);
  if (!v7 || (*(unsigned char *)(v7 + 24) & 0x40) == 0)
  {
    if (v6) {
      pthread_mutex_unlock((pthread_mutex_t *)v4);
    }
    return 0;
  }
LABEL_11:
  uint64_t v8 = sub_100009888(a1, a2, 0);
  if (v6) {
    pthread_mutex_unlock((pthread_mutex_t *)v4);
  }
  return v8;
}

void tx_unmount(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v2);
  int v3 = *(_DWORD *)(v2 + 72);
  if (v3) {
    sub_10005D7D8();
  }
  *(_DWORD *)(v2 + 72) = v3 | 1;
  pthread_mutex_unlock((pthread_mutex_t *)v2);
  while (1)
  {
    int v4 = tx_finish(a1, 8);
    if (v4 != 16) {
      break;
    }
    log_debug((uint64_t)"%s:%d: %s waiting for transaction to finish\n", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"tx_unmount");
    sleep(1u);
  }
  if (v4)
  {
    log_err((uint64_t)"%s:%d: %s tx_finish() failed, %d\n", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"tx_unmount");
    if (*(unsigned char *)(a1 + 629)) {
      return;
    }
    pthread_mutex_lock((pthread_mutex_t *)v2);
  }
  else
  {
    if (*(unsigned char *)(a1 + 629)) {
      return;
    }
    pthread_mutex_lock((pthread_mutex_t *)v2);
    if ((*(unsigned char *)(v2 + 72) & 2) != 0)
    {
      if (sub_100009888(a1, 0x10u, 0)) {
        log_err((uint64_t)"%s:%d: %s First sync/barrier failed: %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"tx_unmount");
      }
      if (!*(unsigned char *)(a1 + 628))
      {
        uint64_t v43 = *(void *)(a1 + 376);
        if (*(_DWORD *)(v43 + 140))
        {
          if (*(_DWORD *)(v43 + 148)) {
            *(void *)(v43 + 1264) |= 2uLL;
          }
        }
      }
      obj_checksum_set(a1, v19, v20);
      if (dev_write(*(void *)(a1 + 384), 0)) {
        log_err((uint64_t)"%s:%d: %s failed to write superblock to block 0: %d\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"tx_unmount");
      }
      uint64_t v28 = *(unsigned char **)(a1 + 376);
      if ((v28[65] & 1) != 0 && nx_fusion_superblock_write(a1, v28)) {
        log_err((uint64_t)"%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"tx_unmount");
      }
      if (sub_100009888(a1, 0x10u, 0)) {
        log_err((uint64_t)"%s:%d: %s Final sync/barrier failed: %d\n", v36, v37, v38, v39, v40, v41, v42, (uint64_t)"tx_unmount");
      }
    }
  }

  pthread_mutex_unlock((pthread_mutex_t *)v2);
}

uint64_t tx_finish(uint64_t a1, __int16 a2)
{
  if (*(unsigned char *)(a1 + 627)) {
    return 30;
  }
  uint64_t v5 = *(void *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v5);
  int v6 = *(_DWORD *)(v5 + 72);
  if (a2 & 8) == 0 && (v6)
  {
LABEL_18:
    uint64_t v2 = 1;
  }
  else
  {
    while (1)
    {
      uint64_t v7 = *(void *)(v5 + 144);
      if ((v6 & 0x40) == 0) {
        break;
      }
      if (v7) {
        *(_DWORD *)(v7 + 24) |= 0x100000u;
      }
      if ((a2 & 0x100) != 0)
      {
        *(_DWORD *)(v5 + 72) = v6 & 0xFFFFFFF3;
        cv_wakeup((pthread_cond_t *)(v5 + 256));
        uint64_t v7 = *(void *)(v5 + 144);
      }
      if (v7)
      {
        uint64_t v2 = *(unsigned int *)(v7 + 52);
        if (v2) {
          goto LABEL_19;
        }
      }
      cv_wait((pthread_cond_t *)(v5 + 256), (pthread_mutex_t *)v5, 8, (uint64_t)"nx_tx_finish_wait_for_dirty_data", 0);
      uint64_t v8 = *(void *)(v5 + 144);
      if (v8)
      {
        unsigned int v9 = *(_DWORD *)(v8 + 52);
        if (v9 | a2 & 0x100)
        {
          if (v9) {
            uint64_t v2 = v9;
          }
          else {
            uint64_t v2 = 35;
          }
          goto LABEL_19;
        }
      }
      else if ((a2 & 0x100) != 0)
      {
        goto LABEL_65;
      }
      int v6 = *(_DWORD *)(v5 + 72);
      if (a2 & 8) == 0 && (v6) {
        goto LABEL_18;
      }
    }
    if (v7 || (uint64_t v7 = **(void **)(*(void *)(v5 + 136) + 8)) != 0 && (*(unsigned char *)(v7 + 24) & 0x30) != 0)
    {
      if ((a2 & 2) == 0 && (v6 & 0xC) == 8)
      {
        uint64_t v2 = 16;
        goto LABEL_19;
      }
      uint64_t v11 = *(void *)(v7 + 16);
      if ((a2 & 8) == 0) {
        ++*(void *)(v5 + 176);
      }
      int v12 = *(_DWORD *)(v7 + 24);
      int v13 = a2 & 1;
      if (v12 & 0x100000 | a2 & 0x10 | v13 | a2 & 0x20) {
        *(_DWORD *)(v7 + 24) = ((a2 & 0x30) << 14) | (v13 << 17) | v12 & 0xFFEFFFFF;
      }
      if (v12) {
        sub_10000AAE4(v7, 1, 2);
      }
      if (*(_DWORD *)(v7 + 28))
      {
        uint64_t v2 = (16 * v13) ^ 0x10u;
      }
      else
      {
        if ((*(unsigned char *)(v7 + 24) & 2) != 0)
        {
          unint64_t v21 = sub_10000AAE4(v7, 2, 4);
          if (v21 >= 0xF4241) {
            log_warn((uint64_t)"%s:%d: %s tx xid %lld took %lld us to close\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"tx_finish");
          }
          *(void *)(v5 + 248) = (*(void *)(v5 + 248) + v21) >> 1;
        }
        uint64_t v2 = sub_10000AB90(a1);
        if (!v2)
        {
          int v22 = *(_DWORD *)(v5 + 72);
          if ((v22 & 0x40) != 0)
          {
            *(_DWORD *)(v5 + 72) = v22 & 0xFFFFFFF3;
            if ((a2 & 0x100) != 0)
            {
LABEL_65:
              uint64_t v2 = 35;
              goto LABEL_19;
            }
            cv_wakeup((pthread_cond_t *)(v5 + 256));
          }
          uint64_t v2 = 0;
        }
      }
      if ((a2 & 9) != 0)
      {
        if (a2) {
          int v23 = 126;
        }
        else {
          int v23 = 62;
        }
        do
        {
          if (*(void *)(v7 + 16) != v11 || (*(_DWORD *)(v7 + 24) & v23) == 0) {
            break;
          }
          if (!v2) {
            cv_wait((pthread_cond_t *)(v5 + 256), (pthread_mutex_t *)v5, 8, (uint64_t)"nx_tx_finish_wait", 0);
          }
          int v24 = *(_DWORD *)(v5 + 72);
          if (a2 & 8) == 0 && (v24) {
            goto LABEL_18;
          }
          if ((a2 & 0x100) != 0 && (v24 & 4) == 0) {
            goto LABEL_65;
          }
        }
        while (!*(_DWORD *)(v5 + 76));
        uint64_t v25 = **(void **)(*(void *)(v5 + 136) + 8);
        if (!v25 || (uint64_t v2 = *(unsigned int *)(v25 + 52), !v2)) {
          uint64_t v2 = *(unsigned int *)(v7 + 52);
        }
      }
    }
    else if ((a2 & 0x11) != 0)
    {
      uint64_t v2 = sub_100009888(a1, a2 & 0x10, 0);
    }
    else
    {
      uint64_t v2 = 0;
    }
  }
LABEL_19:
  pthread_mutex_unlock((pthread_mutex_t *)v5);
  return v2;
}

uint64_t sub_10000A518(uint64_t a1, uint64_t *a2, char a3)
{
  if (*(unsigned char *)(a1 + 627)) {
    return 30;
  }
  uint64_t v7 = *(void *)(a1 + 400);
  pthread_mutex_lock((pthread_mutex_t *)v7);
  if (*(_DWORD *)(v7 + 72))
  {
LABEL_38:
    pthread_mutex_unlock((pthread_mutex_t *)v7);
    return 1;
  }
  uint64_t v8 = *a2;
  if (*a2 != -1)
  {
    if (v8) {
      goto LABEL_6;
    }
    goto LABEL_16;
  }
  uint64_t v11 = *(void *)(v7 + 144);
  if (v11) {
    BOOL v12 = (*(_DWORD *)(v7 + 72) & 0xC) == 8;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12 || (*(unsigned char *)(v11 + 24) & 0x1C) != 0)
  {
    *a2 = 0;
LABEL_16:
    __tp.__darwin_time_t tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    int v22 = 0;
    uint64_t v60 = SLODWORD(__tp.tv_nsec) / 1000;
    __darwin_time_t tv_sec = __tp.tv_sec;
    while (1)
    {
      uint64_t v9 = *(void *)(v7 + 144);
      if (v9 && (*(unsigned char *)(v9 + 24) & 0x1E) != 0)
      {
        if (*(unsigned __int16 *)(v7 + 80) > 9u) {
          goto LABEL_74;
        }
        int v23 = "nx_tx_wait";
        if ((a3 & 2) != 0)
        {
LABEL_21:
          int v24 = *(_DWORD *)(v9 + 24);
          int v22 = "nx_tx_wait_closing";
          if ((v24 & 2) == 0)
          {
            if ((v24 & 4) != 0)
            {
              uint64_t v25 = **(void **)(*(void *)(v7 + 136) + 8);
              if (!v25 || (int v22 = "nx_tx_wait_closed_prev_flushing", (*(unsigned char *)(v25 + 24) & 0x30) == 0)) {
                int v22 = "nx_tx_wait_closed";
              }
            }
            else if ((v24 & 0x18) != 0)
            {
              int v22 = "nx_tx_wait_flush";
            }
            else
            {
              int v22 = v23;
            }
          }
          goto LABEL_37;
        }
      }
      else
      {
        if ((a3 & 2) != 0 || (*(unsigned char *)(v7 + 72) & 8) == 0)
        {
          uint64_t v3 = 0;
          int v62 = 0;
          if (!v9) {
            goto LABEL_43;
          }
LABEL_41:
          if (*(unsigned char *)(v9 + 24))
          {
            if (!v3)
            {
              ++*(_DWORD *)(v9 + 28);
              *a2 = *(void *)(v9 + 16);
              if (v22)
              {
                int v10 = v62;
                if (v62)
                {
                  if (strcmp(v22, "nx_tx_wait_frozen"))
                  {
                    __tp.__darwin_time_t tv_sec = 0;
                    __tp.tv_nsec = 0;
                    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
                    unint64_t v47 = 1000000 * (__tp.tv_sec - tv_sec) - v60 + SLODWORD(__tp.tv_nsec) / 1000;
                    *(void *)(v7 + 168) += v47;
                    if (v47 > 0xF4240 && nx_ratelimit_log_allowed(a1)) {
                      log_warn((uint64_t)"%s:%d: %s waited %lld us to open tx xid %lld (%s)\n", v48, v49, v50, v51, v52, v53, v54, (uint64_t)"tx_enter_internal");
                    }
                    ++*(void *)(v7 + 160);
                  }
                  int v10 = 1;
                }
              }
              else
              {
                int v10 = v62;
              }
LABEL_89:
              ++*(_DWORD *)(v9 + 32);
              pthread_mutex_unlock((pthread_mutex_t *)v7);
              if (v10) {
                spaceman_manage_free_queues((pthread_mutex_t **)a1, v9);
              }
              return 0;
            }
LABEL_87:
            pthread_mutex_unlock((pthread_mutex_t *)v7);
            return v3;
          }
          while (1)
          {
            int v30 = *(_DWORD *)(v9 + 24);
            if ((v30 & 1) == 0) {
              break;
            }
            do
            {
              log_debug((uint64_t)"%s:%d: %s waiting for available tx to open: xid %lld\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"tx_enter_internal");
              cv_wait((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8, (uint64_t)"nx_tx_wait_open", 0);
LABEL_63:
              uint64_t v9 = *(void *)(v7 + 144);
              if (v9) {
                goto LABEL_41;
              }
LABEL_43:
              uint64_t v26 = *(uint64_t **)(v7 + 112);
            }
            while (!v26);
            *(void *)(v7 + 144) = v26;
            uint64_t v27 = *v26;
            uint64_t v28 = (void *)v26[1];
            if (*v26)
            {
              *(void *)(v27 + 8) = v28;
              uint64_t v28 = (void *)v26[1];
            }
            else
            {
              *(void *)(v7 + 120) = v28;
            }
            *uint64_t v28 = v27;
            uint64_t v29 = *(void *)(v7 + 64);
            *(void *)(v7 + 64) = v29 + 1;
            uint64_t v9 = *(void *)(v7 + 144);
            *(void *)(v9 + 16) = v29;
            *(void *)(v9 + 24) = 0;
            *(_DWORD *)(v9 + 32) = 0;
            *(_DWORD *)(v9 + 52) = 0;
          }
          if (*(unsigned char *)(a1 + 626))
          {
            obj_checksum_set(a1, v20, v21);
            uint64_t v3 = dev_write(*(void *)(a1 + 384), 0);
            if (v3) {
              goto LABEL_51;
            }
            uint64_t v38 = *(unsigned char **)(a1 + 376);
            if (v38[65])
            {
              uint64_t v39 = nx_fusion_superblock_write(a1, v38);
              if (v39)
              {
                uint64_t v3 = v39;
                log_err((uint64_t)"%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"tx_enter_internal");
LABEL_51:
                log_err((uint64_t)"%s:%d: %s Error: tx[%lld] failed to unclean superblock: %d\n", v31, v32, v33, v34, v35, v36, v37, (uint64_t)"tx_enter_internal");
LABEL_54:
                log_err((uint64_t)"%s:%d: %s Error: tx[%lld] failed to start: %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"tx_enter_internal");
                goto LABEL_63;
              }
            }
            *(unsigned char *)(a1 + 626) = 0;
            uint64_t v9 = *(void *)(v7 + 144);
            int v30 = *(_DWORD *)(v9 + 24);
          }
          else if (v3)
          {
            goto LABEL_54;
          }
          if (v30) {
            sub_10005D804();
          }
          *(_DWORD *)(v9 + 24) = v30 | 1;
          __tp.__darwin_time_t tv_sec = 0;
          __tp.tv_nsec = 0;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
          *(void *)(v9 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
          if ((a3 & 2) != 0) {
            *(_DWORD *)(*(void *)(v7 + 144) + 24) |= 0x10000u;
          }
          cv_wakeup((pthread_cond_t *)(v7 + 256));
          uint64_t v3 = 0;
          int v62 = 1;
          goto LABEL_63;
        }
        if (*(unsigned __int16 *)(v7 + 80) >= 0xAu)
        {
LABEL_74:
          uint64_t v55 = **(void **)(*(void *)(v7 + 136) + 8);
          if (v55)
          {
            if (*(_DWORD *)(v55 + 24) & 0x30)
            {
              BOOL v57 = 0;
            }
            else
            {
              uint64_t v55 = *(void *)(v7 + 144);
              BOOL v57 = v9 == 0;
            }
            if (!v57)
            {
              uint64_t v9 = v55;
              goto LABEL_83;
            }
          }
          else if (v9)
          {
LABEL_83:
            unsigned int v58 = *(_DWORD *)(v9 + 52);
            if (v58) {
              uint64_t v3 = v58;
            }
            else {
              uint64_t v3 = 5;
            }
            goto LABEL_87;
          }
          uint64_t v3 = 5;
          goto LABEL_87;
        }
      }
      if ((*(_DWORD *)(v7 + 72) & 8) != 0) {
        int v23 = "nx_tx_wait_frozen";
      }
      else {
        int v23 = "nx_tx_wait";
      }
      if (v9) {
        goto LABEL_21;
      }
      int v22 = v23;
LABEL_37:
      cv_wait((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8, (uint64_t)v22, 0);
      if (*(unsigned char *)(v7 + 72)) {
        goto LABEL_38;
      }
    }
  }
  uint64_t v8 = *(void *)(v11 + 16);
  *a2 = v8;
  if (!v8) {
    goto LABEL_16;
  }
LABEL_6:
  uint64_t v9 = *(void *)(v7 + 144);
  if (v9 && v8 == *(void *)(v9 + 16))
  {
    if ((*(unsigned char *)(v9 + 24) & 0xF) == 0) {
      sub_10005D830();
    }
    int v10 = 0;
    ++*(_DWORD *)(v9 + 28);
    goto LABEL_89;
  }
  pthread_mutex_unlock((pthread_mutex_t *)v7);
  return 22;
}

__darwin_time_t sub_10000AAE4(uint64_t a1, int a2, int a3)
{
  if (a2 && (*(_DWORD *)(a1 + 24) & a2) == 0) {
    sub_10005D85C();
  }
  int v4 = *(_DWORD *)(a1 + 24);
  if (a3 && (v4 & a3) != 0) {
    sub_10005D804();
  }
  *(_DWORD *)(a1 + 24) = v4 & ~a2 | a3;
  v7.__darwin_time_t tv_sec = 0;
  v7.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v7);
  __darwin_time_t v5 = 1000000 * v7.tv_sec + SLODWORD(v7.tv_nsec) / 1000;
  __darwin_time_t result = v5 - *(void *)(a1 + 72);
  *(void *)(a1 + 72) = v5;
  return result;
}

uint64_t sub_10000AB90(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 400);
  for (int i = *(_DWORD *)(v2 + 72); (i & 0x10) != 0; int i = *(_DWORD *)(v2 + 72))
  {
    *(_DWORD *)(v2 + 72) = i | 0x20;
    cv_wait((pthread_cond_t *)(v2 + 256), (pthread_mutex_t *)v2, 8, (uint64_t)"nx_tx_flush_busy", 0);
  }
  *(_DWORD *)(v2 + 72) = i | 0x10;
  uint64_t v4 = **(void **)(*(void *)(v2 + 136) + 8);
  if (!v4 || (int v5 = *(_DWORD *)(v4 + 24), (v5 & 0x10) == 0))
  {
    uint64_t v4 = *(void *)(v2 + 144);
    if (!v4) {
      goto LABEL_9;
    }
    int v5 = *(_DWORD *)(v4 + 24);
  }
  if ((v5 & 0x14) == 0 || (uint64_t v6 = sub_10000AFB0(a1, v4), !v6))
  {
LABEL_9:
    uint64_t v7 = *(void *)(v2 + 144);
    if (v7 && (*(unsigned char *)(v7 + 24) & 4) != 0) {
      uint64_t v6 = sub_10000AFB0(a1, v7);
    }
    else {
      uint64_t v6 = 0;
    }
  }
  int v8 = *(_DWORD *)(v2 + 72);
  *(_DWORD *)(v2 + 72) = v8 & 0xFFFFFFCF;
  if ((v8 & 0x20) != 0) {
    cv_wakeup((pthread_cond_t *)(v2 + 256));
  }
  return v6;
}

uint64_t tx_enter(uint64_t a1, uint64_t *a2)
{
  return sub_10000A518(a1, a2, 0);
}

uint64_t tx_enter_frozen(uint64_t a1, uint64_t *a2)
{
  return sub_10000A518(a1, a2, 2);
}

uint64_t tx_leave(uint64_t a1, uint64_t a2, char a3)
{
  if (!*(unsigned char *)(a1 + 627))
  {
    uint64_t v7 = *(void *)(a1 + 400);
    pthread_mutex_lock((pthread_mutex_t *)v7);
    uint64_t v8 = *(void *)(v7 + 144);
    if (*(void *)(v8 + 16) != a2) {
      sub_10005D90C();
    }
    int v9 = *(_DWORD *)(v8 + 24);
    if ((v9 & 3) == 0) {
      sub_10005D888();
    }
    if ((a3 & 5) == 1) {
      sub_10005D8B4();
    }
    if ((v9 & 1) == 0) {
      goto LABEL_23;
    }
    if ((a3 & 4) != 0)
    {
      BOOL v10 = 0;
      ++*(void *)(v7 + 176);
    }
    else
    {
      if (*(_DWORD *)(v8 + 32) <= 0x186A0u && !obj_cache_tx_start_closing(*(void *)(a1 + 392)))
      {
        int started = spaceman_tx_start_closing((pthread_mutex_t **)a1);
        BOOL v10 = started == 0;
        BOOL v11 = started != 0;
LABEL_13:
        if ((*(unsigned char *)(v7 + 72) & 0x40) != 0)
        {
          if (!v10) {
            *(_DWORD *)(v8 + 24) |= 0x100000u;
          }
        }
        else
        {
          int v12 = *(_DWORD *)(v8 + 24);
          if ((v12 & 0x100000) != 0)
          {
            v12 &= ~0x100000u;
            *(_DWORD *)(v8 + 24) = v12;
          }
          else if (!v11)
          {
            goto LABEL_23;
          }
          if ((v12 & 1) == 0) {
            sub_10005D85C();
          }
          if ((v12 & 2) != 0) {
            sub_10005D804();
          }
          *(_DWORD *)(v8 + 24) = v12 & 0xFFFFFFFC | 2;
          __tp.__darwin_time_t tv_sec = 0;
          __tp.tv_nsec = 0;
          clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
          *(void *)(v8 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
        }
LABEL_23:
        if ((a3 & 5) == 5)
        {
          *(_DWORD *)(v8 + 24) |= 0x20000u;
          if ((a3 & 0x10) != 0) {
            goto LABEL_25;
          }
        }
        else if ((a3 & 0x10) != 0)
        {
LABEL_25:
          *(_DWORD *)(v8 + 24) |= 0x40000u;
          if ((a3 & 0x20) == 0)
          {
LABEL_30:
            int v13 = *(_DWORD *)(v8 + 28);
            if (!v13) {
              sub_10005D8E0();
            }
            int v14 = v13 - 1;
            *(_DWORD *)(v8 + 28) = v14;
            if (!v14 && (int v15 = *(_DWORD *)(v8 + 24), (v15 & 2) != 0))
            {
              if ((v15 & 4) != 0) {
                sub_10005D804();
              }
              *(_DWORD *)(v8 + 24) = v15 & 0xFFFFFFF9 | 4;
              __tp.__darwin_time_t tv_sec = 0;
              __tp.tv_nsec = 0;
              clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
              __darwin_time_t v25 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
              unint64_t v26 = v25 - *(void *)(v8 + 72);
              *(void *)(v8 + 72) = v25;
              if (v26 > 0xF4240) {
                log_warn((uint64_t)"%s:%d: %s tx xid %lld took %lld us to close\n", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"tx_leave");
              }
              *(void *)(v7 + 248) = (*(void *)(v7 + 248) + v26) >> 1;
              uint64_t v3 = sub_10000AB90(a1);
              if ((a3 & 1) == 0) {
                goto LABEL_43;
              }
            }
            else
            {
              uint64_t v3 = 0;
              if ((a3 & 1) == 0)
              {
LABEL_43:
                pthread_mutex_unlock((pthread_mutex_t *)v7);
                return v3;
              }
            }
            if ((a3 & 4) != 0) {
              int v16 = 127;
            }
            else {
              int v16 = 63;
            }
            do
            {
              if (*(void *)(v8 + 16) != a2 || (*(_DWORD *)(v8 + 24) & v16) == 0) {
                break;
              }
              if (!v3) {
                cv_wait((pthread_cond_t *)(v7 + 256), (pthread_mutex_t *)v7, 8, (uint64_t)"nx_tx_finish_wait", 0);
              }
            }
            while (!*(_DWORD *)(v7 + 76));
            uint64_t v3 = *(unsigned int *)(v8 + 52);
            goto LABEL_43;
          }
LABEL_29:
          *(_DWORD *)(v8 + 24) |= 0x80000u;
          goto LABEL_30;
        }
        if ((a3 & 0x20) == 0) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }
      BOOL v10 = 0;
    }
    BOOL v11 = 1;
    goto LABEL_13;
  }
  return 30;
}

uint64_t sub_10000AFB0(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 392);
  uint64_t v4 = *(void *)(a1 + 400);
  uint64_t v219 = 0;
  uint64_t v6 = **(void **)(*(void *)(v4 + 136) + 8);
  if (v6 && (*(unsigned char *)(v6 + 24) & 0x10) != 0)
  {
    if (v6 != a2) {
      panic("not handling the flushing tx!\n");
    }
  }
  else
  {
    if (*(void *)(v4 + 144) != a2) {
      panic("not handling the current tx!\n");
    }
    if ((*(unsigned char *)(a2 + 24) & 0x14) == 0) {
      panic("current tx not closed/flushing?!\n");
    }
  }
  int v7 = *(_DWORD *)(a2 + 24);
  if ((v7 & 0x10) != 0)
  {
LABEL_39:
    if (*(unsigned char *)(a1 + 629))
    {
      int v44 = *(_DWORD *)(a2 + 24);
      if ((v44 & 0x10) == 0) {
        sub_10005D85C();
      }
      if (v44) {
        sub_10005D804();
      }
      *(_DWORD *)(a2 + 24) = v44 & 0xFFFFFFEE | 1;
      __tp.__darwin_time_t tv_sec = 0;
      __tp.tv_nsec = 0;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      *(void *)(a2 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
      *(_DWORD *)(a2 + 32) = 0;
      *(_DWORD *)(a2 + 52) = 0;
    }
    else if (*(void *)(v4 + 144) == a2)
    {
      *(void *)a2 = 0;
      uint64_t v45 = *(uint64_t **)(v4 + 136);
      *(void *)(a2 + 8) = v45;
      *uint64_t v45 = a2;
      *(void *)(v4 + 136) = a2;
      *(void *)(v4 + 144) = 0;
    }
    pthread_mutex_unlock((pthread_mutex_t *)v4);
    cv_wakeup((pthread_cond_t *)(v4 + 256));
    uint64_t v46 = obj_cache_flush_write((pthread_mutex_t *)v5, 2 * (*(unsigned char *)(a1 + 629) == 0));
    if (*(unsigned char *)(a1 + 629))
    {
      pthread_mutex_lock((pthread_mutex_t *)v4);
      obj_cache_flush_unprepare(v5);
      sub_100009888(a1, 0, 0);
      cv_wakeup((pthread_cond_t *)(v4 + 256));
      uint64_t v25 = 0;
      *(_DWORD *)(a2 + 52) = 0;
      return v25;
    }
    uint64_t v25 = v46;
    if (v46)
    {
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76)) {
        log_err((uint64_t)"%s:%d: %s xid %lld error flushing objects from the cache: %d\n", v49, v50, v51, v52, v53, v54, v55, (uint64_t)"tx_flush");
      }
      int v56 = 1122;
      goto LABEL_65;
    }
    while (1)
    {
      unsigned int v58 = *(uint64_t **)(v5 + 848);
      if (!v58) {
        break;
      }
      uint64_t v57 = tx_checkpoint_write((void *)a1, a2, *(void *)(v5 + 848), v47, v48);
      if (v57)
      {
        uint64_t v25 = v57;
        pthread_mutex_lock((pthread_mutex_t *)v4);
        if (!*(_DWORD *)(v4 + 76)) {
          log_err((uint64_t)"%s:%d: %s xid %lld failed to write checkpoint data @ 0x%llx: %d\n", v76, v77, v78, v79, v80, v81, v82, (uint64_t)"tx_flush");
        }
        int v56 = 1138;
        goto LABEL_65;
      }
      obj_checkpoint_done((uint64_t)v58);
      obj_release(v58);
    }
    uint64_t v59 = *(void *)(a2 + 64);
    *(_DWORD *)(v59 + 32) |= 1u;
    obj_checksum_set_phys(a1, (unint64_t *)v59, *(_DWORD *)(*(void *)(a1 + 376) + 36), v47, v48);
    uint64_t v60 = dev_write(*(void *)(a1 + 384), *(void *)(*(void *)(a2 + 64) + 8));
    if (v60)
    {
      uint64_t v25 = v60;
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76)) {
        log_err((uint64_t)"%s:%d: %s xid %lld failed to write last checkpoint map block %lld: %d\n", v61, v62, v63, v64, v65, v66, v67, (uint64_t)"tx_flush");
      }
      int v56 = 1157;
LABEL_65:
      *(_DWORD *)(v4 + 76) = v56;
      ++*(_WORD *)(v4 + 80);
LABEL_66:
      uint64_t v33 = (pthread_cond_t *)(v4 + 256);
      goto LABEL_67;
    }
    ++*(_DWORD *)(a2 + 40);
    pthread_mutex_lock((pthread_mutex_t *)v4);
    int v110 = *(_DWORD *)(a2 + 40);
    unint64_t v111 = *(_DWORD **)(a2 + 56);
    int v112 = *(_DWORD *)(a2 + 48);
    int v113 = v111[37];
    if (v110 != v111[35] || v112 != v113) {
      panic("flush phase checkpoint lengths (%d %d) don't match prepare phase (%d %d)\n", v110, v112, v111[35], v113);
    }
    v115 = *(_DWORD **)(a1 + 376);
    v115[34] = v111[34];
    v115[35] = v110;
    v115[36] = v111[36];
    v115[37] = v112;
    int v116 = *(_DWORD *)(a2 + 24);
    if ((v116 & 0x10) == 0) {
      sub_10005D85C();
    }
    if ((v116 & 0x20) != 0) {
      sub_10005D804();
    }
    *(_DWORD *)(a2 + 24) = v116 & 0xFFFFFFCF | 0x20;
    __tp.__darwin_time_t tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t v124 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    unint64_t v125 = v124 - *(void *)(a2 + 72);
    *(void *)(a2 + 72) = v124;
    if (v125 > 0xF4240) {
      log_warn((uint64_t)"%s:%d: %s tx xid %lld took %lld us to flush\n", v117, v118, v119, v120, v121, v122, v123, (uint64_t)"tx_flush");
    }
    *(void *)(a2 + 104) = v125;
    cv_wakeup((pthread_cond_t *)(v4 + 256));
    uint64_t v126 = sub_100009888(a1, 0, 1);
    if (v126)
    {
      uint64_t v25 = v126;
      if (!*(_DWORD *)(v4 + 76)) {
        log_err((uint64_t)"%s:%d: %s xid %lld sync/barrier failed: %d\n", v127, v128, v129, v130, v131, v132, v133, (uint64_t)"tx_flush");
      }
      int v134 = 1195;
      goto LABEL_101;
    }
    pthread_mutex_unlock((pthread_mutex_t *)v4);
    if (*(unsigned char *)(a1 + 632))
    {
      *(_DWORD *)(a2 + 24) |= 0x80000u;
      bzero(*(void **)(a2 + 64), *(unsigned int *)(*(void *)(a1 + 376) + 36));
    }
    uint64_t v135 = dev_write(*(void *)(a1 + 384), *(void *)(a2 + 112));
    if (v135)
    {
      uint64_t v25 = v135;
      pthread_mutex_lock((pthread_mutex_t *)v4);
      if (!*(_DWORD *)(v4 + 76)) {
        log_err((uint64_t)"%s:%d: %s xid %lld failed to write checkpoint superblock %lld: %d\n", v136, v137, v138, v139, v140, v141, v142, (uint64_t)"tx_flush");
      }
      int v134 = 1224;
      goto LABEL_101;
    }
    if ((*(unsigned char *)(a2 + 26) & 8) == 0)
    {
LABEL_104:
      pthread_mutex_lock((pthread_mutex_t *)v4);
      unint64_t v152 = sub_10000AAE4(a2, 32, 64);
      if (v152 > 0xF4240) {
        log_warn((uint64_t)"%s:%d: %s tx xid %lld took %lld us to sync and write superblock\n", v145, v146, v147, v148, v149, v150, v151, (uint64_t)"tx_flush");
      }
      *(void *)(a2 + 104) += v152;
      unsigned int v153 = *(_DWORD *)(a2 + 24);
      if ((v153 & 0x20000) == 0) {
        goto LABEL_124;
      }
      ++*(void *)(v4 + 184);
      if ((v153 & 0x40000) != 0) {
        ++*(void *)(v4 + 192);
      }
      uint64_t v154 = sub_100009888(a1, (v153 >> 14) & 0x10, 0);
      if (!v154)
      {
LABEL_124:
        *(_DWORD *)(a2 + 52) = 0;
        *(_DWORD *)(v4 + 72) |= 2u;
        *(void *)(v4 + 76) = 0;
        uint64_t v190 = *(void *)(a2 + 56);
        int v191 = *(_DWORD *)(v190 + 128);
        uint64_t v192 = *(void *)(a1 + 376);
        *(_DWORD *)(v192 + 128) = v191;
        *(_DWORD *)(v4 + 96) = v191;
        int v193 = *(_DWORD *)(v190 + 132);
        *(_DWORD *)(v192 + 132) = v193;
        *(_DWORD *)(v4 + 100) = v193;
        *(void *)(v192 + 16) = *(void *)(v190 + 16);
        uint64_t v194 = *(void *)(v4 + 152);
        *(void *)(v4 + 152) = v194 + 1;
        if (v194)
        {
          v195.i64[0] = *(unsigned int *)(a2 + 32);
          v195.i64[1] = *(void *)(a2 + 80);
          *(uint64x2_t *)(v4 + 200) = vshrq_n_u64((uint64x2_t)vaddq_s64(*(int64x2_t *)(v4 + 200), v195), 1uLL);
          *(uint64x2_t *)(v4 + 216) = vshrq_n_u64((uint64x2_t)vaddq_s64(*(int64x2_t *)(a2 + 88), *(int64x2_t *)(v4 + 216)), 1uLL);
          *(void *)(v4 + 240) = (*(void *)(a2 + 104) + *(void *)(v4 + 240)) >> 1;
          if (__ROR8__(0xCCCCCCCCCCCCCCCDLL * (v194 + 1), 2) <= 0xCCCCCCCCCCCCCCCuLL
            && nx_ratelimit_log_allowed(a1))
          {
            log_debug((uint64_t)"%s:%d: %s xid %llu tx stats: # %llu owait %llu %lluus finish %llu bar2 %lld f %lld enter %llu fq %llu %llu %lluus close %lluus prep %lluus flush %lluus\n", v196, v197, v198, v199, v200, v201, v202, (uint64_t)"tx_flush");
          }
        }
        else
        {
          *(void *)(v4 + 200) = *(unsigned int *)(a2 + 32);
          *(_OWORD *)(v4 + 208) = *(_OWORD *)(a2 + 80);
          *(void *)(v4 + 224) = *(void *)(a2 + 96);
          *(void *)(v4 + 240) = *(void *)(a2 + 104);
        }
        cv_wakeup((pthread_cond_t *)(v4 + 256));
        return 0;
      }
      uint64_t v25 = v154;
      if (!*(_DWORD *)(v4 + 76)) {
        log_err((uint64_t)"%s:%d: %s xid %lld second sync/barrier failed: %d\n", v155, v156, v157, v158, v159, v160, v161, (uint64_t)"tx_flush");
      }
      *(_DWORD *)(v4 + 76) = 1299;
      ++*(_WORD *)(v4 + 80);
      --*(_DWORD *)(a2 + 40);
      uint64_t v143 = a2;
      int v144 = 64;
LABEL_102:
      *(void *)(a2 + 104) += sub_10000AAE4(v143, v144, 16);
      goto LABEL_66;
    }
    uint64_t v182 = dev_write(*(void *)(a1 + 384), 0);
    if (v182)
    {
      uint64_t v25 = v182;
      if (!*(_DWORD *)(v4 + 76)) {
        log_err((uint64_t)"%s:%d: %s xid %lld failed to write block 0 superblock: %d\n", v183, v184, v185, v186, v187, v188, v189, (uint64_t)"tx_flush");
      }
    }
    else
    {
      if ((*(unsigned char *)(*(void *)(a1 + 376) + 65) & 1) == 0) {
        goto LABEL_104;
      }
      uint64_t v203 = nx_fusion_superblock_write(a1, *(const void **)(a2 + 56));
      if (!v203) {
        goto LABEL_104;
      }
      uint64_t v25 = v203;
      if (!*(_DWORD *)(v4 + 76)) {
        log_err((uint64_t)"%s:%d: %s xid %lld failed to write superblock to fusion tier2 device block 0: %d\n", v204, v205, v206, v207, v208, v209, v210, (uint64_t)"tx_flush");
      }
    }
    pthread_mutex_lock((pthread_mutex_t *)v4);
    int v134 = 1259;
LABEL_101:
    *(_DWORD *)(v4 + 76) = v134;
    ++*(_WORD *)(v4 + 80);
    --*(_DWORD *)(a2 + 40);
    uint64_t v143 = a2;
    int v144 = 32;
    goto LABEL_102;
  }
  if ((v7 & 4) == 0) {
    sub_10005D85C();
  }
  if ((v7 & 8) != 0) {
    sub_10005D804();
  }
  *(_DWORD *)(a2 + 24) = v7 & 0xFFFFFFF3 | 8;
  __tp.__darwin_time_t tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  __darwin_time_t v15 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
  unint64_t v16 = v15 - *(void *)(a2 + 72);
  *(void *)(a2 + 72) = v15;
  if (v16 > 0xF4240) {
    log_warn((uint64_t)"%s:%d: %s tx xid %lld was closed for %lld us waiting to prepare to flush\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"tx_flush");
  }
  uint64_t v17 = obj_cache_flush_prepare(v5, 0, 2 * (*(unsigned char *)(a1 + 629) == 0), *(void *)(a2 + 16));
  if (v17)
  {
    uint64_t v25 = v17;
    if (!*(_DWORD *)(v4 + 76)) {
      log_err((uint64_t)"%s:%d: %s xid %lld error preparing to flush object cache: %d\n", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"tx_flush");
    }
    int v26 = 861;
    goto LABEL_18;
  }
  if (*(unsigned char *)(a1 + 629))
  {
    int v34 = *(_DWORD *)(a2 + 24);
    if ((v34 & 8) == 0) {
      sub_10005D85C();
    }
    if ((v34 & 0x10) != 0) {
      sub_10005D804();
    }
    *(_DWORD *)(a2 + 24) = v34 & 0xFFFFFFE7 | 0x10;
    __tp.__darwin_time_t tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t v42 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    unint64_t v43 = v42 - *(void *)(a2 + 72);
    *(void *)(a2 + 72) = v42;
    if (v43 <= 0xF4240) {
      goto LABEL_38;
    }
    goto LABEL_37;
  }
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(v4 + 96);
  *(_DWORD *)(a2 + 44) = *(_DWORD *)(v4 + 100);
  *(_DWORD *)(a2 + 48) = 0;
  *(_DWORD *)(a2 + 40) = 0;
  uint64_t v219 = -1;
  uint64_t v68 = nx_checkpoint_desc_block_address(a1, *(unsigned int *)(*(void *)(a1 + 376) + 128), &v219);
  if (v68)
  {
    uint64_t v25 = v68;
    if (!*(_DWORD *)(v4 + 76)) {
      log_err((uint64_t)"%s:%d: %s xid %lld error getting first checkpoint map block address %d: %d\n", v69, v70, v71, v72, v73, v74, v75, (uint64_t)"tx_flush");
    }
    int v26 = 893;
    goto LABEL_18;
  }
  bzero(*(void **)(a2 + 64), *(unsigned int *)(*(void *)(a1 + 376) + 36));
  uint64_t v84 = *(void *)(a2 + 64);
  *(_DWORD *)(v84 + 24) = 1073741836;
  *(void *)(v84 + 8) = v219;
  *(void *)(v84 + 16) = *(void *)(a2 + 16);
  ++*(_DWORD *)(a2 + 40);
  uint64_t v25 = nx_checkpoint_traverse(a1, a2, 1);
  if (v25) {
    goto LABEL_19;
  }
  uint64_t v90 = *(void *)(v5 + 736);
  if (!v90)
  {
LABEL_78:
    int v101 = *(_DWORD *)(v4 + 96);
    *(void *)(a2 + 112) = -1;
    uint64_t v102 = nx_checkpoint_desc_block_address(a1, (*(_DWORD *)(a2 + 40) + v101) % *(_DWORD *)(v4 + 88), (void *)(a2 + 112));
    if (v102)
    {
      uint64_t v25 = v102;
      if (!*(_DWORD *)(v4 + 76)) {
        log_err((uint64_t)"%s:%d: %s xid %lld error getting next checkpoint superblock address %d: %d\n", v103, v104, v105, v106, v107, v108, v109, (uint64_t)"tx_flush");
      }
      int v26 = 942;
      goto LABEL_18;
    }
    ++*(_DWORD *)(a2 + 40);
    if (*(_DWORD *)(a2 + 48) != *(_DWORD *)(v5 + 900) - 1) {
      log_err((uint64_t)"%s:%d: %s xid %lld checkpoint data block count is not value tracked by cache: %d != %d\n", v103, v104, v105, v106, v107, v108, v109, (uint64_t)"tx_flush");
    }
    uint64_t v162 = *(void *)(a1 + 376);
    *(void *)(v162 + 88) = *(void *)(v5 + 400);
    *(void *)(v162 + 96) = *(void *)(v4 + 64);
    memcpy(*(void **)(a2 + 56), (const void *)v162, *(unsigned int *)(v162 + 36));
    uint64_t v172 = *(void *)(a2 + 56);
    *(void *)(v172 + 16) = *(void *)(a2 + 16);
    int v173 = *(_DWORD *)(v4 + 96);
    *(_DWORD *)(v172 + 136) = v173;
    int v174 = *(_DWORD *)(v4 + 100);
    *(_DWORD *)(v172 + 144) = v174;
    unsigned int v175 = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(v172 + 140) = v175;
    unsigned int v176 = *(_DWORD *)(a2 + 48);
    *(_DWORD *)(v172 + 148) = v176;
    unsigned int v177 = *(_DWORD *)(v4 + 88);
    unsigned int v178 = *(_DWORD *)(v4 + 92);
    unsigned int v179 = (v175 + v173) % v177;
    if (!*(_DWORD *)(v4 + 76))
    {
      if (v175 <= v177 >> 2)
      {
        unsigned int v181 = *(_DWORD *)(v4 + 92);
        unsigned int v180 = v176;
      }
      else
      {
        log_err((uint64_t)"%s:%d: %s xid %lld checkpoint descriptor count is larger than expected: %d > %d\n", v163, v164, v165, v166, v167, v168, v169, (uint64_t)"tx_flush");
        unsigned int v180 = *(_DWORD *)(a2 + 48);
        unsigned int v181 = *(_DWORD *)(v4 + 92);
      }
      if (v180 > v181 >> 2)
      {
        log_err((uint64_t)"%s:%d: %s xid %lld checkpoint data block count is larger than expected: %d > %d\n", v163, v164, v165, v166, v167, v168, v169, (uint64_t)"tx_flush");
        unsigned int v180 = *(_DWORD *)(a2 + 48);
      }
      if (v180 != *(_DWORD *)(v5 + 900) - 1) {
        log_err((uint64_t)"%s:%d: %s xid %lld checkpoint data block count is not value tracked by cache: %d != %d\n", v163, v164, v165, v166, v167, v168, v169, (uint64_t)"tx_flush");
      }
    }
    uint64_t v211 = *(void *)(a2 + 56);
    unsigned int v212 = *(_DWORD *)(v211 + 136);
    unsigned int v213 = v179;
    if (v179 <= v212) {
      unsigned int v213 = *(_DWORD *)(v4 + 88) + v179;
    }
    if (*(_DWORD *)(a2 + 40) != v213 - v212) {
      sub_10005D964();
    }
    unsigned int v214 = (v176 + v174) % v178;
    unsigned int v215 = *(_DWORD *)(v211 + 144);
    unsigned int v216 = v214;
    if (v214 <= v215) {
      unsigned int v216 = *(_DWORD *)(v4 + 92) + v214;
    }
    if (*(_DWORD *)(a2 + 48) != v216 - v215) {
      sub_10005D938();
    }
    *(_DWORD *)(v211 + 128) = v179;
    *(_DWORD *)(v211 + 132) = v214;
    obj_checksum_set_phys(a1, (unint64_t *)v211, *(_DWORD *)(*(void *)(a1 + 376) + 36), v170, v171);
    *(_DWORD *)(a2 + 48) = 0;
    *(_DWORD *)(a2 + 40) = 1;
    *(_DWORD *)(*(void *)(a2 + 64) + 36) = 0;
    int v217 = *(_DWORD *)(a2 + 24);
    if ((v217 & 8) == 0) {
      sub_10005D85C();
    }
    if ((v217 & 0x10) != 0) {
      sub_10005D804();
    }
    *(_DWORD *)(a2 + 24) = v217 & 0xFFFFFFE7 | 0x10;
    __tp.__darwin_time_t tv_sec = 0;
    __tp.tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t v218 = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    unint64_t v43 = v218 - *(void *)(a2 + 72);
    *(void *)(a2 + 72) = v218;
    if (v43 <= 0xF4240) {
      goto LABEL_38;
    }
LABEL_37:
    log_warn((uint64_t)"%s:%d: %s tx xid %lld took %lld us to prepare to flush\n", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"tx_flush");
LABEL_38:
    *(void *)(v4 + 232) = (*(void *)(v4 + 232) + v43) >> 1;
    goto LABEL_39;
  }
  while (v90 == a1)
  {
LABEL_77:
    uint64_t v90 = *(void *)(v90 + 88);
    if (!v90) {
      goto LABEL_78;
    }
  }
  uint64_t v91 = tx_checkpoint_write_prepare(a1, a2, v90, v85, v86, v87, v88, v89);
  if (!v91)
  {
    obj_retain_ephemeral_no_ref(v90);
    if ((*(unsigned char *)(v90 + 32) & 4) == 0 && (*(unsigned char *)(v90 + 20) & 0x20) == 0) {
      log_warn((uint64_t)"%s:%d: %s Unknown NEW persistent ephemeral object found: oid 0x%llx type 0x%x/0x%x\n", v99, v100, v85, v86, v87, v88, v89, (uint64_t)"tx_flush");
    }
    *(void *)(v90 + 64) = *(void *)(v90 + 56);
    *(void *)(v90 + 104) = 0;
    **(void **)(v5 + 856) = v90;
    *(void *)(v5 + 856) = v90 + 104;
    goto LABEL_77;
  }
  uint64_t v25 = v91;
  if (!*(_DWORD *)(v4 + 76)) {
    log_err((uint64_t)"%s:%d: %s xid %lld error preparing ephemeral object (oid 0x%llx type 0x%x/0x%x): %d\n", v92, v93, v94, v95, v96, v97, v98, (uint64_t)"tx_flush");
  }
  int v26 = 921;
LABEL_18:
  *(_DWORD *)(v4 + 76) = v26;
  ++*(_WORD *)(v4 + 80);
LABEL_19:
  obj_cache_flush_unprepare(v5);
  uint64_t v27 = *(uint64_t **)(v5 + 848);
  if (v27)
  {
    uint64_t v28 = (uint64_t **)(v5 + 848);
    do
    {
      uint64_t v29 = v27[13];
      *uint64_t v28 = (uint64_t *)v29;
      if (!v29) {
        *(void *)(v5 + 856) = v28;
      }
      v27[13] = 3735928559;
      v27[8] = 0;
      obj_checkpoint_done((uint64_t)v27);
      obj_release(v27);
      uint64_t v27 = *v28;
    }
    while (*v28);
  }
  for (uint64_t i = *(void *)(v5 + 736); i; uint64_t i = *(void *)(i + 88))
  {
    if ((*(unsigned char *)(i + 32) & 4) != 0) {
      obj_checkpoint_done(i);
    }
  }
  int v31 = *(_DWORD *)(v4 + 72);
  if ((v31 & 0x40) != 0) {
    *(_DWORD *)(v4 + 72) = v31 & 0xFFFFFFBF;
  }
  int v32 = *(_DWORD *)(a2 + 24);
  if ((v32 & 8) == 0) {
    sub_10005D85C();
  }
  if (v32) {
    sub_10005D804();
  }
  *(_DWORD *)(a2 + 24) = v32 & 0xFFFFFFF6 | 1;
  __tp.__darwin_time_t tv_sec = 0;
  __tp.tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
  *(void *)(a2 + 72) = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
  uint64_t v33 = (pthread_cond_t *)(v4 + 256);
LABEL_67:
  cv_wakeup(v33);
  *(_DWORD *)(a2 + 52) = v25;
  return v25;
}

uint64_t sub_10000C018(uint64_t a1, unsigned int a2, _DWORD *a3)
{
  if (!a3) {
    return 22;
  }
  uint64_t v3 = *(void *)a3;
  uint64_t v4 = *(void *)(*(void *)a3 + 16);
  if (!v4) {
    return 22;
  }
  uint64_t v5 = *(void *)(v3 + 128);
  if (!v5) {
    return 22;
  }
  if (*(void *)(v3 + 136) != a2) {
    sub_10005D990();
  }
  int v6 = a3[2] | 1;
  *(void *)(a1 + 336) = 0x9D800000001;
  *(_DWORD *)(a1 + 32) = *(void *)(v3 + 8);
  *(int32x2_t *)(a1 + 36) = vmovn_s64(*(int64x2_t *)(v3 + 80));
  *(_DWORD *)(a1 + 44) = *(void *)(v3 + 96);
  uint64_t v7 = *(void *)(v3 + 24);
  *(void *)(a1 + 48) = v4;
  *(void *)(a1 + 56) = v7;
  int v8 = *(_DWORD *)(v3 + 32);
  int v9 = *(_DWORD *)(v3 + 40);
  *(_DWORD *)(a1 + 64) = v8;
  *(_DWORD *)(a1 + 68) = v9;
  *(void *)(a1 + 72) = v4;
  long long v10 = *(_OWORD *)(v3 + 48);
  *(_OWORD *)(a1 + 96) = v10;
  uint64_t v11 = *(void *)(v3 + 64);
  uint64_t v12 = *(void *)(v3 + 72);
  *(_DWORD *)(a1 + 112) = v11;
  *(_DWORD *)(a1 + 116) = v12;
  *(void *)(a1 + 120) = v10;
  *(void *)(a1 + 152) = *(void *)(v3 + 104);
  uint64_t v13 = *(void *)(v3 + 120);
  *(_DWORD *)(a1 + 144) = v6;
  *(_DWORD *)(a1 + 148) = v13;
  uint64_t v14 = *(void *)(v3 + 152);
  *(_WORD *)(a1 + 224) = *(void *)(v3 + 144);
  int v15 = *(_DWORD *)(v3 + 112);
  *(_DWORD *)(a1 + 160) = v15;
  *(_DWORD *)(a1 + 164) = v5;
  *(_WORD *)(a1 + 264) = v14;
  *(_WORD *)(a1 + 304) = *(void *)(v3 + 160);
  *(_DWORD *)(a1 + 324) = 2520;
  int v16 = 8 * v15 + 2520;
  *(_DWORD *)(a1 + 328) = v16;
  uint64_t v17 = ((2 * v15 + 6) & 0xFFFFFFF8) + v16;
  *(_DWORD *)(a1 + 332) = v17;
  uint64_t v18 = a1 + v17;
  *(_WORD *)(a1 + 322) = v5 - 1;
  *(_WORD *)(a1 + 320) = 0;
  uint64_t v19 = (v5 & 0x7FFFFFFF) - 1;
  if ((v5 & 0x7FFFFFFF) == 1)
  {
    uint64_t v19 = 0;
  }
  else
  {
    uint64_t v20 = 0;
    do
    {
      *(_WORD *)(v18 + 2 * v20) = v20 + 1;
      ++v20;
    }
    while (v19 != v20);
  }
  *(_WORD *)(v18 + 2 * v19) = -1;
  int v22 = v17 + ((2 * v5 + 6) & 0xFFFFFFF8);
  *(_DWORD *)(a1 + 80) = v22;
  if (v9) {
    int v8 = v9;
  }
  uint64_t v23 = (v22 + 8 * v8);
  *(_DWORD *)(a1 + 128) = v23;
  if (v12) {
    unsigned int v24 = v12;
  }
  else {
    unsigned int v24 = v11;
  }
  if (8 * (unint64_t)v24 + v23 <= a2) {
    return 0;
  }
  else {
    return 22;
  }
}

uint64_t sub_10000C194(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(void *)(*(void *)a1 + 392);
  uint64_t v77 = 0;
  long long v75 = 0u;
  long long v76 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v64 = 0u;
  unsigned int v4 = *(_DWORD *)(v2 + 32);
  uint64_t v5 = *(void *)(v3 + 376);
  int v6 = *(_DWORD *)(v5 + 36);
  if (*(unsigned char *)(v3 + 624))
  {
    if (v4 == v6) {
      goto LABEL_3;
    }
LABEL_9:
    uint64_t v10 = v3;
    goto LABEL_10;
  }
  if (*(void *)(v2 + 96) + *(void *)(v2 + 48) != *(void *)(v5 + 40) || v4 != v6) {
    goto LABEL_9;
  }
LABEL_3:
  unsigned int v7 = 336;
  if (*(unsigned char *)(v2 + 144))
  {
    if (*(_DWORD *)(v2 + 336)) {
      unsigned int v12 = 2520;
    }
    else {
      unsigned int v12 = 336;
    }
    unsigned int v13 = *(_DWORD *)(v2 + 340);
    if (*(_DWORD *)(v2 + 336)) {
      int v14 = 1;
    }
    else {
      int v14 = 2;
    }
    if (v13 <= v12) {
      unsigned int v7 = v12;
    }
    else {
      unsigned int v7 = *(_DWORD *)(v2 + 340);
    }
    if (v13 >= v12) {
      BOOL v8 = *(_DWORD *)(v2 + 336) == 0;
    }
    else {
      BOOL v8 = v14;
    }
  }
  else
  {
    BOOL v8 = 0;
  }
  unsigned int v15 = *(_DWORD *)(a1 + 48);
  uint64_t v16 = nx_calculate_metadata_parameters(v4, *(void *)(v2 + 48), *(void *)(v2 + 96), *(_DWORD *)(v5 + 180), (uint64_t)&v64);
  if (v16) {
    return v16;
  }
  if (v7 < v15) {
    int v17 = v8;
  }
  else {
    int v17 = v8 + 1;
  }
  if (*(_DWORD *)(v2 + 36) != v69) {
    ++v17;
  }
  if (*(_DWORD *)(v2 + 40) != DWORD2(v69)) {
    ++v17;
  }
  if (*(_DWORD *)(v2 + 44) != v70) {
    ++v17;
  }
  unint64_t v18 = *(void *)(v2 + 48);
  if (*(void *)(v2 + 56) != *((void *)&v65 + 1)) {
    ++v17;
  }
  unsigned int v19 = *(_DWORD *)(v2 + 64);
  uint64_t v20 = *(unsigned int *)(v2 + 68);
  if (v19 != v66) {
    ++v17;
  }
  if (v20 != DWORD2(v66) && *((void *)&v66 + 1) + v20 != 1) {
    ++v17;
  }
  if (*(void *)(v2 + 104) != *((void *)&v67 + 1)) {
    ++v17;
  }
  uint64_t v22 = *(unsigned int *)(v2 + 116);
  if (*(_DWORD *)(v2 + 112) != v68) {
    ++v17;
  }
  if (v22 != DWORD2(v68) && *((void *)&v68 + 1) + v22 != 1) {
    ++v17;
  }
  if ((*(void *)(v2 + 152) & 0x7FFFFFFFFFFFFFFFLL) != *((void *)&v70 + 1)) {
    ++v17;
  }
  uint64_t v24 = *(unsigned int *)(v2 + 160);
  if (v24 != v71) {
    ++v17;
  }
  unsigned int v25 = *(_DWORD *)(v2 + 164) & 0x7FFFFFFF;
  if (v25 > 0xFFFE) {
    ++v17;
  }
  if (*(_DWORD *)(v2 + 148) < 4u) {
    ++v17;
  }
  if (v25 / v24 < 4) {
    ++v17;
  }
  if (*(unsigned __int16 *)(v2 + 224) != v73) {
    ++v17;
  }
  if (*(unsigned __int16 *)(v2 + 264) != DWORD2(v73)) {
    ++v17;
  }
  if (*(unsigned __int16 *)(v2 + 304) != v74) {
    ++v17;
  }
  uint64_t v26 = *(unsigned int *)(v2 + 324);
  if (v26 < v7) {
    ++v17;
  }
  unint64_t v27 = *(unsigned int *)(v2 + 328);
  if (v26 + 8 * v24 > v27) {
    ++v17;
  }
  unint64_t v28 = *(unsigned int *)(v2 + 332);
  if (v27 + 2 * ((v24 + 3) & 0xFFFFFFFC) > v28) {
    ++v17;
  }
  unint64_t v29 = *(unsigned int *)(v2 + 80);
  if (v28 + 2 * ((v25 + 3) & 0xFFFFFFFC) > v29) {
    ++v17;
  }
  unint64_t v30 = *(unsigned int *)(v2 + 128);
  if (v20) {
    unsigned int v19 = *(_DWORD *)(v2 + 68);
  }
  if (v29 + 8 * v19 > v30) {
    ++v17;
  }
  if (v22) {
    unsigned int v31 = *(_DWORD *)(v2 + 116);
  }
  else {
    unsigned int v31 = *(_DWORD *)(v2 + 112);
  }
  if (v30 + 8 * v31 > *(unsigned int *)(a1 + 48)) {
    ++v17;
  }
  if (*(void *)(v2 + 72) > v18) {
    ++v17;
  }
  unint64_t v32 = *(void *)(v2 + 240);
  if (v32 < v18) {
    int v33 = v17;
  }
  else {
    int v33 = v17 + 1;
  }
  if (v32 && !*(void *)(v2 + 248)) {
    ++v33;
  }
  unint64_t v34 = *(void *)(v2 + 256);
  if (v34 <= obj_xid(a1)) {
    int v35 = v33;
  }
  else {
    int v35 = v33 + 1;
  }
  unint64_t v36 = *(void *)(v2 + 96);
  unint64_t v37 = *(void *)(v2 + 120);
  unint64_t v38 = *(void *)(v2 + 280);
  if (v36)
  {
    if (v37 > v36) {
      ++v35;
    }
    if (v38 < v36) {
      int v39 = v35;
    }
    else {
      int v39 = v35 + 1;
    }
    if (v38 && !*(void *)(v2 + 288)) {
      ++v39;
    }
    unint64_t v40 = *(void *)(v2 + 296);
    BOOL v41 = v40 > obj_xid(a1);
  }
  else
  {
    if (v37) {
      ++v35;
    }
    if (v38) {
      int v42 = v35 + 1;
    }
    else {
      int v42 = v35;
    }
    if (*(void *)(v2 + 288)) {
      int v39 = v42 + 1;
    }
    else {
      int v39 = v42;
    }
    BOOL v41 = *(void *)(v2 + 296) != 0;
  }
  int v43 = v39 + v41;
  unsigned int v44 = *(unsigned __int16 *)(v2 + 320);
  unsigned int v45 = *(_DWORD *)(v2 + 164) & 0x7FFFFFFF;
  if (v44 != 0xFFFF && v45 <= v44) {
    ++v43;
  }
  unsigned int v47 = *(unsigned __int16 *)(v2 + 322);
  if (v47 != 0xFFFF && v45 <= v47) {
    ++v43;
  }
  if (*(void *)(v2 + 192) <= *(void *)(v2 + 184)) {
    int v49 = 0;
  }
  else {
    int v49 = -1;
  }
  if (v43 == v49)
  {
LABEL_130:
    *(void *)(a1 + 376) = v2;
    *(void *)(a1 + 864) = v2 + *(unsigned int *)(v2 + 324);
    *(void *)(a1 + 872) = v2 + *(unsigned int *)(v2 + 328);
    *(void *)(a1 + 880) = v2 + *(unsigned int *)(v2 + 332);
    *(void *)(a1 + 888) = v2 + *(unsigned int *)(v2 + 80);
    *(void *)(a1 + 896) = v2 + *(unsigned int *)(v2 + 128);
    *(void *)(a1 + 904) = 0;
    *(_OWORD *)(a1 + 992) = 0u;
    *(_WORD *)(a1 + 1528) = 8;
    *(void *)(a1 + 1512) = *(void *)(v2 + 48) >> 5;
    *(void *)(a1 + 1520) = *(void *)(v2 + 96) >> 5;
    if (*(unsigned char *)(v3 + 625))
    {
      *(_WORD *)(a1 + 1528) = 0;
    }
    else if ((*(unsigned char *)(*(void *)(v3 + 376) + 65) & 1) == 0)
    {
      if (*(unsigned char *)(v3 + 628))
      {
        *(_WORD *)(a1 + 1528) = 32;
      }
      else
      {
        LODWORD(v64) = 0;
        dev_features(*(void *)(v3 + 384));
        if ((v64 & 2) != 0)
        {
          *(_WORD *)(a1 + 1528) = 2;
          unint64_t v50 = 0x40000000u / *(_DWORD *)(v2 + 32);
          if (*(void *)(a1 + 1512) > v50) {
            *(void *)(a1 + 1512) = v50;
          }
          if (*(void *)(a1 + 1520) > v50) {
            *(void *)(a1 + 1520) = v50;
          }
        }
      }
    }
    if ((*(unsigned char *)(a1 + 16) & 0x40) != 0) {
      uint64_t v51 = 0;
    }
    else {
      uint64_t v51 = obj_xid(a1);
    }
    uint64_t v52 = 0;
    *(void *)(a1 + 912) = v51;
    char v53 = 1;
    do
    {
      char v54 = v53;
      uint64_t v55 = v2 + 48 * v52;
      size_t v58 = *(void *)(v55 + 56);
      uint64_t v57 = (unint64_t *)(v55 + 56);
      size_t v56 = v58;
      if (v58)
      {
        uint64_t v59 = _apfs_calloc(v56, 4uLL);
        uint64_t v60 = a1 + 8 * v52;
        *(void *)(v60 + 1488) = v59;
        if (v59 && *v57)
        {
          unint64_t v61 = 0;
          uint64_t v62 = (void *)(v60 + 1488);
          do
          {
            *(_DWORD *)(*v62 + 4 * v61) = *(_DWORD *)(v2 + 36) & 0xFFFFFF | (*(unsigned __int8 *)(*v62 + 4 * v61 + 3) << 24);
            *(unsigned char *)(*v62 + 4 * v61++ + 3) = 3;
          }
          while (v61 < *v57);
        }
      }
      else
      {
        *(void *)(a1 + 8 * v52 + 1488) = 0;
      }
      char v53 = 0;
      uint64_t v52 = 1;
    }
    while ((v54 & 1) != 0);
    uint64_t v11 = new_lock((pthread_mutex_t *)(a1 + 384));
    if (v11) {
      goto LABEL_166;
    }
    uint64_t v11 = new_lock((pthread_mutex_t *)(a1 + 448));
    if (!v11)
    {
      uint64_t v11 = new_lock((pthread_mutex_t *)(a1 + 512));
      if (!v11)
      {
        uint64_t v11 = new_lock((pthread_mutex_t *)(a1 + 576));
        if (!v11)
        {
          uint64_t v11 = new_lock((pthread_mutex_t *)(a1 + 640));
          if (!v11)
          {
            uint64_t v11 = new_lock((pthread_mutex_t *)(a1 + 704));
            if (!v11)
            {
              uint64_t v11 = new_cv((pthread_cond_t *)(a1 + 768));
              if (!v11)
              {
LABEL_166:
                *(void *)(a1 + 1584) = _apfs_calloc(1uLL, 0xF8uLL);
                return v11;
              }
              free_lock((pthread_mutex_t *)(a1 + 704));
            }
            free_lock((pthread_mutex_t *)(a1 + 640));
          }
          free_lock((pthread_mutex_t *)(a1 + 576));
        }
        free_lock((pthread_mutex_t *)(a1 + 512));
      }
      free_lock((pthread_mutex_t *)(a1 + 448));
    }
    free_lock((pthread_mutex_t *)(a1 + 384));
    goto LABEL_166;
  }
  uint64_t v10 = v3;
LABEL_10:
  uint64_t v11 = nx_corruption_detected_int(v10);
  if (!v11) {
    goto LABEL_130;
  }
  return v11;
}

uint64_t sub_10000C7F8(uint64_t a1)
{
  _apfs_free(*(void **)(a1 + 1488), 4 * *(void *)(*(void *)(a1 + 376) + 56));
  _apfs_free(*(void **)(a1 + 1496), 4 * *(void *)(*(void *)(a1 + 376) + 104));
  uint64_t v2 = *(void **)(a1 + 1600);
  if (v2) {
    _apfs_free(v2, 16 * *(unsigned int *)(a1 + 1592));
  }
  uint64_t v3 = *(void **)(a1 + 1584);
  if (v3) {
    _apfs_free(v3, 248);
  }
  unsigned int v4 = *(void **)(a1 + 1536);
  if (v4) {
    _apfs_free(v4, 16 * *(unsigned __int16 *)(a1 + 1530));
  }
  spaceman_datazone_destroy(a1);
  uint64_t v5 = *(void *)(a1 + 1568);
  if (v5)
  {
    spaceman_free_extent_cache_destroy(v5);
    _apfs_free(*(void **)(a1 + 1568), 1368);
  }
  uint64_t v6 = *(void *)(a1 + 1576);
  if (v6)
  {
    spaceman_free_extent_cache_destroy(v6);
    _apfs_free(*(void **)(a1 + 1576), 1368);
  }
  free_lock((pthread_mutex_t *)(a1 + 384));
  free_lock((pthread_mutex_t *)(a1 + 448));
  free_lock((pthread_mutex_t *)(a1 + 512));
  free_lock((pthread_mutex_t *)(a1 + 576));
  free_lock((pthread_mutex_t *)(a1 + 640));
  free_lock((pthread_mutex_t *)(a1 + 704));
  free_cv((pthread_cond_t *)(a1 + 768));
  return 0;
}

uint64_t sub_10000C8EC(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[7];
  int v5 = obj_size_phys((uint64_t)a1);
  uint64_t v6 = *(void *)(*a1 + 392);
  int v7 = *(_DWORD *)(*(void *)(v6 + 376) + 36);
  BOOL v8 = v5 != v7;
  if (!a2) {
    goto LABEL_11;
  }
  uint64_t v9 = *a2;
  unsigned int v11 = *((_DWORD *)a2 + 2);
  int v10 = *((_DWORD *)a2 + 3);
  if (v5 == v7) {
    int v12 = 1;
  }
  else {
    int v12 = 2;
  }
  if (*(_DWORD *)(v4 + 32) != v10) {
    BOOL v8 = v12;
  }
  int v13 = v10 == *(_DWORD *)(v9 + 48 * v11 + 68) - 1
      ? *(_DWORD *)(v9 + 48 * v11 + 64) - *(_DWORD *)(v9 + 44) * v10
      : *(_DWORD *)(v9 + 44);
  if (*(_DWORD *)(v4 + 36) == v13)
  {
LABEL_11:
    if (!v8) {
      return 0;
    }
  }

  return nx_corruption_detected_int(v6);
}

uint64_t sub_10000C9D0(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[7];
  int v5 = obj_size_phys((uint64_t)a1);
  uint64_t v6 = *(void *)(*a1 + 392);
  int v7 = *(_DWORD *)(*(void *)(v6 + 376) + 36);
  BOOL v8 = v5 != v7;
  if (a2)
  {
    uint64_t v9 = *a2;
    unsigned int v11 = *((_DWORD *)a2 + 2);
    int v10 = *((_DWORD *)a2 + 3);
    if (v5 == v7) {
      int v12 = 1;
    }
    else {
      int v12 = 2;
    }
    if (*(_DWORD *)(v4 + 32) != v10) {
      BOOL v8 = v12;
    }
    if (v10 == *(_DWORD *)(v9 + 48 * v11 + 64) - 1)
    {
      if (*(_DWORD *)(v4 + 36) != *(_DWORD *)(v9 + 48 * v11 + 56) - *(_DWORD *)(v9 + 40) * v10) {
        goto LABEL_12;
      }
    }
    else if (*(_DWORD *)(v4 + 36) != *(_DWORD *)(v9 + 40))
    {
      goto LABEL_12;
    }
  }
  if (!v8) {
    return 0;
  }
LABEL_12:

  return nx_corruption_detected_int(v6);
}

uint64_t spaceman_create(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5)
{
  uint64_t v10 = *(void *)(a1 + 384);
  uint64_t v188 = 0;
  uint64_t v189 = 0;
  unint64_t v186 = 0;
  uint64_t v187 = 0;
  uint64_t v180 = 0;
  unsigned int v181 = a3;
  __int16 v179 = 0;
  *a5 = 0;
  uint64_t v190 = 0;
  uint64_t v183 = 0;
  uint64_t v182 = 0;
  uint64_t v184 = 64;
  unsigned int v11 = (char *)_apfs_malloc(0x400uLL);
  uint64_t v185 = v11;
  if (!v11)
  {
    uint64_t bootstrap = 12;
    goto LABEL_86;
  }
  if (!a3)
  {
    uint64_t v182 = *(void *)(a2 + 16);
    uint64_t v183 = 1;
  }
  uint64_t v12 = *(void *)(a1 + 376);
  if (*(unsigned char *)(v12 + 65))
  {
    unint64_t v186 = *(void *)(a2 + 208);
    uint64_t bootstrap = sub_10000D66C((uint64_t)v11, (uint64_t)&v181, v186, (void *)(v12 + 1368), 0);
    if (bootstrap) {
      goto LABEL_84;
    }
    uint64_t v153 = *(void *)(a1 + 376);
    if (((*(void *)(v153 + 1368) << __clz(__rbit64(*(unsigned int *)(v153 + 36)))) & 0x4000000000000000) != 0)
    {
      log_err((uint64_t)"%s:%d: %s WBC area was not allocated on main device\n", v146, v147, v148, v149, v150, v151, v152, (uint64_t)"spaceman_create");
      uint64_t bootstrap = 0;
      goto LABEL_84;
    }
    *(void *)(v153 + 1376) = v186;
  }
  LODWORD(v188) = 0;
  uint64_t v187 = a2;
  uint64_t bootstrap = obj_create_bootstrap(*(pthread_mutex_t **)(a1 + 392), 0x80000000, 0, (unsigned int *)&sm_desc, (uint64_t)&v187, *(unsigned int *)(a2 + 136), a4, (uint64_t *)&v190);
  if (bootstrap) {
    goto LABEL_84;
  }
  obj_dirty((uint64_t)v190, a4, 0);
  uint64_t v14 = v190[47];
  *a5 = v190[14];
  uint64_t v15 = *(void *)(a1 + 376);
  unint64_t v186 = *(unsigned int *)(v15 + 104);
  uint64_t bootstrap = nx_allocate_metadata_range((pthread_mutex_t **)a1, (uint64_t (*)(pthread_mutex_t **, uint64_t, int64_t, unint64_t *, int64_t *))sub_10000D66C, (uint64_t)&v181, (unint64_t *)(v15 + 112), (int64_t *)&v186, 0);
  if (bootstrap) {
    goto LABEL_84;
  }
  uint64_t v16 = *(void *)(a1 + 376);
  *(_DWORD *)(v16 + 104) = v186;
  unint64_t v186 = *(unsigned int *)(v16 + 108);
  uint64_t bootstrap = nx_allocate_metadata_range((pthread_mutex_t **)a1, (uint64_t (*)(pthread_mutex_t **, uint64_t, int64_t, unint64_t *, int64_t *))sub_10000D66C, (uint64_t)&v181, (unint64_t *)(v16 + 120), (int64_t *)&v186, 0);
  if (bootstrap
    || (*(_DWORD *)(*(void *)(a1 + 376) + 108) = v186,
        unint64_t v186 = *(unsigned int *)(v14 + 164),
        bootstrap = nx_allocate_metadata_range((pthread_mutex_t **)a1, (uint64_t (*)(pthread_mutex_t **, uint64_t, int64_t, unint64_t *, int64_t *))sub_10000D66C, (uint64_t)&v181, (unint64_t *)(v14 + 168), (int64_t *)&v186, 0), bootstrap)|| (*(_DWORD *)(v14 + 164) = v186, unint64_t v186 = *(void *)(v14 + 152), bootstrap = nx_allocate_metadata_range((pthread_mutex_t **)a1, (uint64_t (*)(pthread_mutex_t **, uint64_t, int64_t, unint64_t *, int64_t *))sub_10000D66C, (uint64_t)&v181, (unint64_t *)(v14 + 176), (int64_t *)&v186, 1), bootstrap))
  {
LABEL_84:
    if (v185) {
      _apfs_free(v185, 16 * v184);
    }
LABEL_86:
    uint64_t v154 = v190;
    if (bootstrap && v190)
    {
      obj_delete_and_free(v190, a4);
    }
    else if (v190)
    {
      *a5 = v190[14];
      obj_release(v154);
      return bootstrap;
    }
    *a5 = 0;
    return bootstrap;
  }
  unsigned int v178 = (int *)v14;
  *(void *)(v14 + 152) = v186;
  if (!v181 || !v181[2] || !HIDWORD(v184))
  {
LABEL_16:
    uint64_t v20 = _apfs_malloc(v178[8]);
    uint64_t v21 = _apfs_malloc(v178[8]);
    uint64_t bootstrap = 12;
    uint64_t v174 = (uint64_t)v21;
    int8x16_t v170 = (char *)_apfs_malloc(v178[8]);
    if (v170)
    {
      uint64_t v22 = v21;
      if (v21 && v20)
      {
        bzero(v20, v178[8]);
        unsigned int v25 = v178;
        if (v178[40])
        {
          unint64_t v26 = 0;
          while (1)
          {
            unint64_t v27 = v25;
            unint64_t v28 = v190;
            *(void *)(v190[108] + 8 * v26) = a4;
            uint64_t v29 = sub_10000D7D4(a1, (uint64_t)v28, a4, &v180, &v179);
            if (v29)
            {
              uint64_t bootstrap = v29;
              log_err((uint64_t)"%s:%d: %s failed to allocate bitmap block from IP bitmap pool: %d\n", v30, v31, v32, v33, v34, v35, v36, (uint64_t)"spaceman_create");
              goto LABEL_104;
            }
            *(_WORD *)(v190[109] + 2 * v26) = v179;
            uint64_t v37 = dev_write(v10, v180);
            if (v37) {
              break;
            }
            ++v26;
            unsigned int v25 = v27;
            if (v26 >= v27[40]) {
              goto LABEL_24;
            }
          }
          uint64_t bootstrap = v37;
        }
        else
        {
LABEL_24:
          uint64_t v38 = 0;
          uint64_t v39 = (uint64_t)v170;
          uint64_t v165 = (uint64_t)v20;
          uint64_t v40 = 0xFFFFFFFFLL;
          char v41 = 1;
          do
          {
            char v162 = v41;
            uint64_t v166 = (unsigned int *)&v25[12 * v38 + 16];
            if (*v166)
            {
              unsigned int v42 = 0;
              uint64_t v168 = &v25[12 * v38 + 17];
              uint64_t v171 = v38;
              do
              {
                if (*v168)
                {
                  unsigned int v43 = v25[11];
                  if (v42 / v43 != v40)
                  {
                    if (v40 == -1)
                    {
                      uint64_t v53 = v42 / v43;
                    }
                    else
                    {
                      unsigned int v44 = v25;
                      obj_checksum_set_phys(a1, (unint64_t *)v39, v25[8], v23, v24);
                      uint64_t v45 = dev_write(v10, *(void *)(v190[v171 + 111] + 8 * v40));
                      if (v45)
                      {
                        uint64_t bootstrap = v45;
                        log_err((uint64_t)"%s:%d: %s failed to write cab %d: %d\n", v46, v47, v48, v49, v50, v51, v52, (uint64_t)"spaceman_create");
                        goto LABEL_103;
                      }
                      uint64_t v53 = v42 / v44[11];
                      LODWORD(v38) = v171;
                    }
                    uint64_t v40 = v53;
                    uint64_t v56 = sub_10000D8D8(a1, (uint64_t)v190, v38, v53, v39, a4);
                    if (v56)
                    {
                      uint64_t v156 = v56;
                      log_err((uint64_t)"%s:%d: %s failed to initialize cab %d: %d\n", v57, v58, v59, v60, v61, v62, v63, (uint64_t)"spaceman_create");
                      uint64_t bootstrap = v156;
                      goto LABEL_103;
                    }
                    unsigned int v43 = v178[11];
                    LODWORD(v38) = v171;
                  }
                  uint64_t v175 = v40;
                  unsigned int v172 = v42 - v43 * v40;
                  ++*(_DWORD *)(v39 + 36);
                  char v54 = v190;
                  uint64_t v55 = (uint64_t)(v170 + 40);
                }
                else
                {
                  uint64_t v175 = v40;
                  char v54 = v190;
                  uint64_t v55 = v190[v38 + 111];
                  unsigned int v172 = v42;
                }
                uint64_t v64 = sub_10000D9A8(a1, (uint64_t)v54, v38, v42, v174, a4, &v189);
                if (v64)
                {
                  uint64_t bootstrap = v64;
                  log_err((uint64_t)"%s:%d: %s failed to initialize cib %d: %d\n", v65, v66, v67, v68, v69, v70, v71, (uint64_t)"spaceman_create");
                  uint64_t v20 = (void *)v165;
                  uint64_t v22 = (void *)v174;
                  goto LABEL_105;
                }
                *(void *)(v55 + 8 * v172) = v189;
                obj_checksum_set_phys(a1, (unint64_t *)v174, v178[8], v72, v73);
                uint64_t v74 = dev_write(v10, *(void *)(v55 + 8 * v172));
                if (v74)
                {
                  uint64_t bootstrap = v74;
                  log_err((uint64_t)"%s:%d: %s failed to write cib %d: %d\n", v75, v76, v77, v78, v79, v80, v81, (uint64_t)"spaceman_create");
                  goto LABEL_103;
                }
                ++v42;
                uint64_t v40 = v175;
                unsigned int v25 = v178;
                uint64_t v39 = (uint64_t)v170;
                uint64_t v38 = v171;
              }
              while (v42 < *v166);
            }
            uint64_t v176 = v40;
            uint64_t v20 = (void *)v165;
            if (v25[12 * v38 + 17])
            {
              uint64_t v82 = v38;
              obj_checksum_set_phys(a1, (unint64_t *)v39, v25[8], v23, v24);
              uint64_t v83 = dev_write(v10, *(void *)(v190[v82 + 111] + 8 * v176));
              unsigned int v25 = v178;
              if (v83)
              {
                uint64_t bootstrap = v83;
                log_err((uint64_t)"%s:%d: %s failed to write cab %d: %d\n", v84, v85, v86, v87, v88, v89, v90, (uint64_t)"spaceman_create");
                goto LABEL_104;
              }
            }
            char v41 = 0;
            uint64_t v38 = 1;
            uint64_t v40 = v176;
          }
          while ((v162 & 1) != 0);
          if (a3)
          {
            uint64_t bootstrap = 0;
            uint64_t v91 = 0;
            char v92 = 1;
            do
            {
              if (!bootstrap)
              {
                unint64_t v93 = 0;
                char v173 = v92;
                uint64_t v94 = &v178[12 * v91];
                uint64_t v95 = (unsigned int *)(v94 + 16);
                uint64_t v96 = v94 + 17;
                uint64_t v97 = (uint64_t *)(v94 + 18);
                int v98 = -1;
                uint64_t v163 = v94 + 17;
                uint64_t v164 = (unsigned int *)(v94 + 16);
                while (2)
                {
                  if (v93 >= *v95)
                  {
                    uint64_t bootstrap = 0;
                  }
                  else
                  {
                    unint64_t v177 = v93;
                    if (*v96)
                    {
                      unsigned int v99 = v178[11];
                      unsigned int v100 = v93 / v99;
                      if (v93 / v99 != v98)
                      {
                        unint64_t v101 = dev_read(v10, *(void *)(v190[v91 + 111] + 8 * v100));
                        if (v101
                          || (unint64_t v101 = obj_checksum_verify_phys((uint64_t)v170, v178[8], v109, v110), v101))
                        {
                          uint64_t bootstrap = v101;
                          log_err((uint64_t)"%s:%d: %s failed to read cab %d: %d\n", v102, v103, v104, v105, v106, v107, v108, (uint64_t)"spaceman_create");
                          goto LABEL_103;
                        }
                        LODWORD(v93) = v177;
                        unsigned int v99 = v178[11];
                        int v98 = v100;
                      }
                      int v169 = v98;
                      unint64_t v111 = (uint64_t *)&v170[8 * (v93 - v99 * v98) + 40];
                    }
                    else
                    {
                      int v169 = v98;
                      unint64_t v111 = (uint64_t *)(v190[v91 + 111] + 8 * v93);
                    }
                    uint64_t v167 = *v111;
                    unint64_t v112 = dev_read(*(void *)(a1 + 384), *v111);
                    if (v112 || (unint64_t v112 = obj_checksum_verify_phys(v174, v178[8], v120, v121), v112))
                    {
                      uint64_t bootstrap = v112;
                      log_err((uint64_t)"%s:%d: %s failed to read cib %d: %d\n", v113, v114, v115, v116, v117, v118, v119, (uint64_t)"spaceman_create");
LABEL_74:
                      char v92 = v173;
                    }
                    else
                    {
                      unint64_t v124 = 0;
                      while (v124 < *(unsigned int *)(v174 + 36))
                      {
                        uint64_t v125 = ((uint64_t (*)(void, uint64_t, unint64_t, void, uint64_t))a3[3])(*a3, v91, *(void *)(v174 + 32 * v124 + 48)/ (unint64_t)(8 * v178[8])* v178[8], v178[8], v165);
                        if (v125) {
                          goto LABEL_73;
                        }
                        if (!(v177 | v124)) {
                          bitmap_clear_range(v165, 0, 1);
                        }
                        unint64_t v126 = v174 + 32 * v124;
                        unint64_t v127 = *(_DWORD *)(v126 + 56) & 0xFFFFF;
                        if (v127)
                        {
                          unint64_t v128 = 0;
                          int v129 = *(_DWORD *)(v126 + 60);
                          uint64_t v130 = *v97;
                          uint64_t v131 = (int8x8_t *)v165;
                          do
                          {
                            int8x8_t v132 = *v131++;
                            uint8x8_t v133 = (uint8x8_t)vcnt_s8(v132);
                            v133.i16[0] = vaddlv_u8(v133);
                            v129 -= v133.i32[0];
                            v130 -= v133.u32[0];
                            *uint64_t v97 = v130;
                            v128 += 64;
                          }
                          while (v128 < v127);
                          *(_DWORD *)(v126 + 60) = v129;
                        }
                        uint64_t v136 = *(void *)(v126 + 64);
                        uint64_t v135 = (uint64_t *)(v126 + 64);
                        uint64_t v134 = v136;
                        if (!v136)
                        {
                          uint64_t v137 = sub_10000DB28(a1, (uint64_t)v190, a4, (unint64_t *)&v189);
                          if (v137)
                          {
                            uint64_t bootstrap = v137;
                            log_err((uint64_t)"%s:%d: %s failed to allocate block from internal pool: %d\n", v138, v139, v140, v141, v142, v143, v144, (uint64_t)"spaceman_create");
                            goto LABEL_74;
                          }
                          uint64_t v134 = v189;
                          *uint64_t v135 = v189;
                        }
                        uint64_t v125 = dev_write(v10, v134);
                        ++v124;
                        if (v125)
                        {
LABEL_73:
                          uint64_t bootstrap = v125;
                          goto LABEL_74;
                        }
                      }
                      obj_checksum_set_phys(a1, (unint64_t *)v174, v178[8], v122, v123);
                      uint64_t bootstrap = dev_write(v10, v167);
                      unint64_t v93 = v177 + 1;
                      char v92 = v173;
                      uint64_t v96 = v163;
                      uint64_t v95 = v164;
                      int v98 = v169;
                      if (!bootstrap) {
                        continue;
                      }
                    }
                  }
                  break;
                }
              }
              char v145 = v92 & (*(void *)(a2 + 48) != 0);
              uint64_t v91 = 1;
              char v92 = 0;
            }
            while ((v145 & 1) != 0);
            uint64_t v20 = (void *)v165;
            uint64_t v22 = (void *)v174;
            if (bootstrap) {
              goto LABEL_105;
            }
          }
          uint64_t v157 = sub_10000DEA0(a1, (uint64_t)v190, v10, 0, 1uLL, a4);
          uint64_t v22 = (void *)v174;
          uint64_t bootstrap = v157;
          if (v157) {
            goto LABEL_105;
          }
          uint64_t v158 = *(void *)(a1 + 376);
          if (*(unsigned char *)(v158 + 65))
          {
            uint64_t v159 = sub_10000DEA0(a1, (uint64_t)v190, v10, 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v158 + 36))), 1uLL, a4);
            uint64_t v22 = (void *)v174;
            uint64_t bootstrap = v159;
            if (v159) {
              goto LABEL_105;
            }
          }
          if (HIDWORD(v184))
          {
            uint64_t v160 = 0;
            unint64_t v161 = 0;
            uint64_t v20 = (void *)v165;
            while (1)
            {
              uint64_t bootstrap = sub_10000DEA0(a1, (uint64_t)v190, v10, *(void *)&v185[v160], *(void *)&v185[v160 + 8], a4);
              if (bootstrap) {
                break;
              }
              ++v161;
              v160 += 16;
              uint64_t v22 = (void *)v174;
              if (v161 >= HIDWORD(v184)) {
                goto LABEL_105;
              }
            }
          }
          else
          {
            uint64_t bootstrap = 0;
          }
LABEL_103:
          uint64_t v20 = (void *)v165;
        }
LABEL_104:
        uint64_t v22 = (void *)v174;
      }
    }
    else
    {
      uint64_t v22 = v21;
    }
LABEL_105:
    if (v170)
    {
      _apfs_free(v170, v178[8]);
      uint64_t v22 = (void *)v174;
    }
    if (v22) {
      _apfs_free(v22, v178[8]);
    }
    if (v20) {
      _apfs_free(v20, v178[8]);
    }
    goto LABEL_84;
  }
  uint64_t v17 = 0;
  unint64_t v18 = 0;
  while (1)
  {
    uint64_t v19 = ((uint64_t (*)(void, void, void))v181[2])(*v181, *(void *)&v185[v17], *(void *)&v185[v17 + 8]);
    if (v19) {
      return v19;
    }
    ++v18;
    v17 += 16;
    if (v18 >= HIDWORD(v184)) {
      goto LABEL_16;
    }
  }
}

uint64_t sub_10000D66C(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, unint64_t *a5)
{
  unint64_t v7 = a3;
  uint64_t v23 = 0;
  if (*(void *)a2)
  {
    uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t *, unint64_t *))(*(void *)a2 + 8))(**(void **)a2, a3, &v23, a5);
    if (result) {
      return result;
    }
    if (a5) {
      unint64_t v7 = *a5;
    }
  }
  else
  {
    uint64_t v11 = *(void *)(a2 + 8);
    uint64_t v10 = *(void *)(a2 + 16);
    uint64_t v23 = v10;
    if (v11 - v10 < a3) {
      return 28;
    }
    if (a5)
    {
      *a5 = a3;
      uint64_t v10 = *(void *)(a2 + 16);
    }
    *(void *)(a2 + 16) = v10 + a3;
  }
  uint64_t v12 = v23;
  *a4 = v23;
  unsigned int v13 = *(_DWORD *)(a2 + 28);
  if (v13)
  {
    uint64_t v14 = (uint64_t *)(*(void *)(a2 + 32) + 16 * (v13 - 1));
    uint64_t v15 = *v14;
    uint64_t v18 = v14[1];
    uint64_t v16 = v14 + 1;
    uint64_t v17 = v18;
    if (v12 == v18 + v15)
    {
      uint64_t result = 0;
      *uint64_t v16 = v17 + v7;
      return result;
    }
  }
  unsigned int v19 = *(_DWORD *)(a2 + 24);
  if (v13 >= v19)
  {
    uint64_t v21 = (char *)_apfs_malloc(16 * (v19 + 64));
    if (!v21) {
      return 12;
    }
    uint64_t v20 = v21;
    memcpy(v21, *(const void **)(a2 + 32), 16 * *(unsigned int *)(a2 + 24));
    bzero(&v20[16 * *(unsigned int *)(a2 + 24)], 0x400uLL);
    _apfs_free(*(void **)(a2 + 32), 16 * *(unsigned int *)(a2 + 24));
    *(void *)(a2 + 32) = v20;
    unsigned int v13 = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a2 + 24) += 64;
    uint64_t v12 = v23;
  }
  else
  {
    uint64_t v20 = *(char **)(a2 + 32);
  }
  uint64_t result = 0;
  uint64_t v22 = &v20[16 * v13];
  *(void *)uint64_t v22 = v12;
  *((void *)v22 + 1) = v7;
  *(_DWORD *)(a2 + 28) = v13 + 1;
  return result;
}

uint64_t sub_10000D7D4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, _WORD *a5)
{
  uint64_t v5 = *(void *)(a2 + 376);
  uint64_t v6 = *(unsigned __int16 *)(v5 + 320);
  if (v6 == 0xFFFF) {
    return 28;
  }
  if ((*(_DWORD *)(v5 + 164) & 0x7FFFFFFFu) <= v6)
  {
    return nx_corruption_detected_int(a1);
  }
  else
  {
    if (*(unsigned __int16 *)(v5 + 322) == v6) {
      *(_WORD *)(v5 + 322) = -1;
    }
    uint64_t v10 = *(void *)(a2 + 880);
    *(_WORD *)(v5 + 320) = *(_WORD *)(v10 + 2 * v6);
    *(_WORD *)(v10 + 2 * v6) = -1;
    obj_dirty(a2, a3, 0);
    *a5 = v6;
    return spaceman_ip_bm_block_address(a1, v5, v6, a4);
  }
}

uint64_t sub_10000D8D8(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v11 = *(void *)(a2 + 376);
  unint64_t v22 = 0;
  uint64_t v19 = sub_10000DB28(a1, a2, a6, &v22);
  if (v19)
  {
    log_err((uint64_t)"%s:%d: %s failed to allocate block from internal pool: %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"spaceman_init_cab");
  }
  else
  {
    unint64_t v20 = v22;
    *(void *)(*(void *)(a2 + 8 * a3 + 888) + 8 * a4) = v22;
    bzero((void *)a5, *(unsigned int *)(v11 + 32));
    *(void *)(a5 + 24) = 1073741830;
    *(void *)(a5 + 8) = v20;
    *(void *)(a5 + 16) = a6;
    *(_DWORD *)(a5 + 32) = a4;
  }
  return v19;
}

uint64_t sub_10000D9A8(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v12 = *(unsigned int **)(a2 + 376);
  unint64_t v34 = 0;
  uint64_t v20 = sub_10000DB28(a1, a2, a6, &v34);
  if (v20)
  {
    log_err((uint64_t)"%s:%d: %s failed to allocate block from internal pool: %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"spaceman_init_cib");
    return v20;
  }
  unint64_t v21 = v34;
  *a7 = v34;
  bzero((void *)a5, v12[8]);
  *(void *)(a5 + 24) = 1073741831;
  *(void *)(a5 + 8) = v21;
  *(void *)(a5 + 16) = a6;
  *(_DWORD *)(a5 + 32) = a4;
  unint64_t v22 = &v12[12 * a3];
  if (v22[16] - 1 != a4)
  {
    LODWORD(v23) = v12[10];
LABEL_7:
    *(_DWORD *)(a5 + 36) = v23;
    if (!v23) {
      return v20;
    }
    goto LABEL_8;
  }
  unint64_t v23 = v12[10];
  unint64_t v24 = *(void *)&v12[12 * a3 + 14] % v23;
  if (!v24) {
    goto LABEL_7;
  }
  *(_DWORD *)(a5 + 36) = v24;
  LODWORD(v23) = v24;
LABEL_8:
  unsigned int v25 = v22 + 12;
  unint64_t v26 = v12[9];
  unint64_t v27 = v12[10] * (unint64_t)a4;
  uint64_t v28 = v23;
  uint64_t v29 = (void *)(a5 + 64);
  unint64_t v30 = v27 * v26;
  unint64_t v31 = ~v27 + *(void *)&v12[12 * a3 + 14];
  do
  {
    *(v29 - 3) = a6;
    *(v29 - 2) = v30;
    LODWORD(v32) = v26;
    if (!v31)
    {
      unint64_t v32 = *v25 % v26;
      if (!v32) {
        LODWORD(v32) = v26;
      }
    }
    *((_DWORD *)v29 - 2) = v32;
    *((_DWORD *)v29 - 1) = v32 & 0xFFFFF;
    *uint64_t v29 = 0;
    v29 += 4;
    v30 += v26;
    --v31;
    --v28;
  }
  while (v28);
  return v20;
}

uint64_t sub_10000DB28(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  uint64_t v5 = a3;
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a2 + 376);
  uint64_t v49 = 0;
  uint64_t v50 = 0;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  if (!xid_is_current_tx(a1, a3) || !(8 * *(_DWORD *)(v8 + 32))) {
    return 22;
  }
  uint64_t v38 = a4;
  uint64_t v39 = (pthread_mutex_t *)(a2 + 448);
  int v9 = 8 * *(_DWORD *)(v8 + 32);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 448));
  unint64_t v10 = v9;
  uint64_t v42 = v5;
  uint64_t v43 = v7;
  int v40 = v9;
  unint64_t v41 = v9;
LABEL_4:
  unsigned int v11 = 0;
  unint64_t v12 = *(void *)(a2 + 904);
  unint64_t v46 = 0;
  while (1)
  {
    unsigned int v13 = *(_DWORD *)(v8 + 160);
    if (v11 > v13)
    {
LABEL_35:
      if (sub_10000E968(v7, a2, 0, 1, 0, v5)) {
        goto LABEL_4;
      }
      log_err((uint64_t)"%s:%d: %s unable to find free IP block or to free pending free IP blocks\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"spaceman_ip_block_alloc");
      uint64_t v36 = 28;
      goto LABEL_39;
    }
    unint64_t v14 = v12 / v10;
    unsigned int v44 = v11;
    if (v11 == v13)
    {
      unint64_t v15 = *(void *)(a2 + 904) % v10;
      if (!v15) {
        goto LABEL_35;
      }
    }
    else
    {
      LODWORD(v15) = v14 == v13 - 1
                   ? *(void *)(v8 + 152) - (*(void *)(v8 + 152) & 0x7FFFFFFFFFFFFFFFuLL) / v10 * v10
                   : v40;
    }
    unsigned int v16 = *(unsigned __int16 *)(*(void *)(a2 + 872) + 2 * v14);
    uint64_t v17 = v8;
    uint64_t v18 = spaceman_ip_bm_block_address(v7, v8, v16, &v48);
    if (v18
      || (uint64_t v18 = obj_get(*(void *)(v7 + 392), 1073741825, v48, &sm_bm_desc, 0, 0, 0, v5, &v50), v18))
    {
      uint64_t v36 = v18;
      pthread_mutex_unlock(v39);
      return v36;
    }
    unint64_t v19 = v12;
    uint64_t v20 = v12 % v10;
    uint64_t v21 = v50[7];
    if (bitmap_range_find_first(0, v21, v20, v15 - v20, &v49)) {
      break;
    }
    unint64_t v26 = v10 - v20 + v19;
    uint64_t v8 = v17;
    if (v26 >= (*(void *)(v17 + 152) & 0x7FFFFFFFFFFFFFFFuLL)) {
      unint64_t v12 = 0;
    }
    else {
      unint64_t v12 = v26;
    }
    uint64_t v5 = v42;
    uint64_t v7 = v43;
LABEL_33:
    obj_release(v50);
    unsigned int v11 = v44 + 1;
    if (v46)
    {
      uint64_t v36 = 0;
LABEL_39:
      pthread_mutex_unlock(v39);
      *uint64_t v38 = v46;
      return v36;
    }
  }
  uint64_t v22 = v49;
  unint64_t v23 = v49 + v14 * v10;
  uint64_t v24 = *(void *)(v17 + 152);
  if ((v24 & 0x7FFFFFFFFFFFFFFFuLL) > v23)
  {
    unint64_t v25 = v19;
    uint64_t v8 = v17;
    if (v24 < 0)
    {
      uint64_t v27 = nx_metadata_fragmented_block_address_lookup(v43, *(void *)(v17 + 176), v23, &v46, 0);
      if (v27) {
        goto LABEL_40;
      }
      uint64_t v22 = v49;
      uint64_t v8 = v17;
    }
    else
    {
      unint64_t v46 = *(void *)(v17 + 176) + v23;
    }
    if (!bitmap_range_is_clear(v21, v22, 1)) {
      sub_10005D9BC();
    }
    bitmap_set_range(v21, v49, 1);
    uint64_t v5 = v42;
    uint64_t v7 = v43;
    if (*(void *)(*(void *)(a2 + 864) + 8 * v14) != v42)
    {
      __int16 v45 = 0;
      uint64_t v27 = sub_10000D7D4(v43, a2, v42, &v47, &v45);
      if (v27 || (uint64_t v27 = sub_100017F3C(v43, a2, v16, v42), v27))
      {
LABEL_40:
        uint64_t v36 = v27;
        goto LABEL_42;
      }
      uint64_t v48 = v47;
      *(_WORD *)(*(void *)(a2 + 872) + 2 * v14) = v45;
      *(void *)(*(void *)(a2 + 864) + 8 * v14) = v42;
      uint64_t v8 = v17;
    }
    obj_dirty((uint64_t)v50, v42, v48);
    uint64_t v28 = v25 - v20 + v49;
    if (v28 + 1 < (*(void *)(v8 + 152) & 0x7FFFFFFFFFFFFFFFuLL)) {
      unint64_t v12 = v28 + 1;
    }
    else {
      unint64_t v12 = 0;
    }
    *(void *)(a2 + 904) = v12;
    unint64_t v10 = v41;
    goto LABEL_33;
  }
  uint64_t v36 = 22;
LABEL_42:
  pthread_mutex_unlock(v39);
  obj_release(v50);
  return v36;
}

uint64_t sub_10000DEA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(_DWORD **)(a2 + 376);
  char v7 = __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36)));
  uint64_t v8 = ((unint64_t)(a4 << v7) >> 62) & 1;
  uint64_t v9 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v7) & a4;
  unint64_t v10 = *(void *)&v6[12 * v8 + 12];
  BOOL v11 = v10 > v9;
  unint64_t v12 = v10 - v9;
  if (!v11 || v12 < a5) {
    return 22;
  }
  uint64_t v15 = a5;
  uint64_t v76 = &v6[12 * v8 + 17];
  if (*v76)
  {
    unsigned int v16 = (char *)_apfs_malloc(v6[8]);
    if (!v16) {
      return 12;
    }
  }
  else
  {
    unsigned int v16 = 0;
  }
  uint64_t v17 = _apfs_malloc(v6[8]);
  if (!v17) {
    return 12;
  }
  uint64_t v18 = (uint64_t)v17;
  unint64_t v19 = _apfs_malloc(v6[8]);
  if (!v19)
  {
    uint64_t v14 = 12;
    uint64_t v20 = (_DWORD *)v18;
    goto LABEL_55;
  }
  uint64_t v20 = v19;
  uint64_t v74 = v16;
  if (v15 < 1)
  {
    uint64_t v14 = 0;
    goto LABEL_52;
  }
  int8x16_t v72 = (void *)(a2 + 8 * v8 + 888);
  unsigned int v79 = v8;
  uint64_t v21 = &v6[12 * v8 + 18];
  int v75 = -1;
  while (1)
  {
    unint64_t v22 = v9 / v6[9];
    unint64_t v23 = v22 / v6[10];
    if (!*v76)
    {
      uint64_t v37 = (uint64_t *)(*v72 + 8 * v23);
      goto LABEL_21;
    }
    unsigned int v24 = v6[11];
    unsigned int v25 = v23 / v24;
    int v26 = v75;
    if (v23 / v24 != v75) {
      break;
    }
LABEL_19:
    int v75 = v26;
    uint64_t v37 = (uint64_t *)&v74[8 * (v23 - v24 * v26) + 40];
LABEL_21:
    uint64_t v38 = *v37;
    unint64_t v39 = dev_read(a3, *v37);
    if (v39 || (unint64_t v39 = obj_checksum_verify_phys(v18, v6[8], v47, v48), v39))
    {
      unint64_t v70 = v39;
      log_err((uint64_t)"%s:%d: %s failed to read cib %d: %d\n", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"spaceman_allocated");
      uint64_t v14 = v70;
      goto LABEL_52;
    }
    if (v15 < 1)
    {
      int v56 = 0;
    }
    else
    {
      uint64_t v73 = v38;
      unint64_t v51 = v22 % v6[10];
      while (v51 < *(unsigned int *)(v18 + 36))
      {
        unint64_t v52 = v18 + 32 * v51;
        uint64_t v55 = *(void *)(v52 + 64);
        char v54 = (uint64_t *)(v52 + 64);
        uint64_t v53 = v55;
        if (v55)
        {
          int v56 = 1;
          if (dev_read(a3, v53)) {
            goto LABEL_43;
          }
        }
        else
        {
          uint64_t v82 = 0;
          if (sub_10000DB28(a1, a2, a6, (unint64_t *)&v82))
          {
            log_err((uint64_t)"%s:%d: %s failed to allocate block from internal pool: %d\n", v57, v58, v59, v60, v61, v62, v63, (uint64_t)"spaceman_allocated");
            break;
          }
          *char v54 = v82;
          bzero(v20, v6[8]);
        }
        uint64_t v64 = v6[9];
        uint64_t v65 = v9 % v64;
        unint64_t v66 = v64 - (v9 % v64);
        if (v15 >= v66) {
          uint64_t v67 = v66;
        }
        else {
          uint64_t v67 = v15;
        }
        uint64_t v68 = v65;
        if (!bitmap_range_is_clear((uint64_t)v20, v65, v67)) {
          sub_10005D9E8();
        }
        bitmap_set_range((uint64_t)v20, v68, v67);
        sub_100017D6C(a2, v79, v20, v9 / v6[9]);
        *(_DWORD *)(v18 + 32 * v51 + 60) -= v67;
        *v21 -= v67;
        if (dev_write(a3, *v54))
        {
          int v56 = 1;
          goto LABEL_43;
        }
        ++v51;
        v9 += v67;
        BOOL v11 = v15 <= v67;
        v15 -= v67;
        if (v11)
        {
          int v56 = 0;
          goto LABEL_43;
        }
      }
      int v56 = 1;
LABEL_43:
      uint64_t v38 = v73;
    }
    obj_checksum_set_phys(a1, (unint64_t *)v18, v6[8], v49, v50);
    uint64_t v69 = dev_write(a3, v38);
    uint64_t v14 = v69;
    if (!v56 || v69) {
      goto LABEL_52;
    }
  }
  unint64_t v27 = dev_read(a3, *(void *)(*v72 + 8 * v25));
  if (!v27)
  {
    unint64_t v27 = obj_checksum_verify_phys((uint64_t)v74, v6[8], v35, v36);
    if (!v27)
    {
      unsigned int v24 = v6[11];
      int v26 = v25;
      goto LABEL_19;
    }
  }
  uint64_t v14 = v27;
  log_err((uint64_t)"%s:%d: %s failed to read cab %d: %d\n", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"spaceman_allocated");
LABEL_52:
  if (v74) {
    _apfs_free(v74, v6[8]);
  }
  _apfs_free((void *)v18, v6[8]);
LABEL_55:
  _apfs_free(v20, v6[8]);
  return v14;
}

uint64_t spaceman_extent_check(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t result = nx_superblock_sanity_check_extent(*(void *)(a1 + 376), *(void *)(a2 + 376), a3, a4, 0);
  if (!result)
  {
    return nx_metadata_range_overlap_check(a1, a3, a4, 0);
  }
  return result;
}

uint64_t spaceman_ip_bm_block_address(uint64_t a1, uint64_t a2, unsigned int a3, void *a4)
{
  int v4 = *(_DWORD *)(a2 + 164);
  if ((v4 & 0x7FFFFFFFu) <= a3) {
    return 22;
  }
  uint64_t v5 = *(void *)(a2 + 168);
  if (v4 < 0) {
    return nx_metadata_fragmented_block_address_lookup(a1, v5, a3, a4, 0);
  }
  uint64_t result = 0;
  *a4 = v5 + a3;
  return result;
}

uint64_t spaceman_get(void *a1, void *a2)
{
  if (!a1) {
    sub_10005DA14();
  }
  uint64_t v4 = a1[51];
  *a2 = v4;
  if (v4) {
    goto LABEL_3;
  }
  uint64_t result = obj_get(a1[49], 0x80000000, *(void *)(a1[47] + 152), &sm_desc, 0, 0, 0, 0, a2);
  if (!result)
  {
    a1[51] = *a2;
LABEL_3:
    obj_retain();
    return 0;
  }
  return result;
}

uint64_t spaceman_currently_available_space(uint64_t a1, unint64_t *a2, unint64_t *a3, unint64_t *a4, BOOL *a5)
{
  uint64_t v9 = (void *)a1;
  if (obj_type(a1) == 13) {
    uint64_t v10 = (uint64_t)v9;
  }
  else {
    uint64_t v10 = 0;
  }
  if (v10) {
    uint64_t v9 = *(void **)(v10 + 392);
  }
  uint64_t v21 = 0;
  uint64_t v11 = spaceman_get(v9, &v21);
  if (v11)
  {
    if (a2) {
      *a2 = 0;
    }
    if (a3) {
LABEL_10:
    }
      *a3 = 0;
  }
  else
  {
    uint64_t v13 = *(void *)&v21[5].__opaque[48];
    pthread_mutex_lock(v21 + 9);
    if (v10)
    {
      uint64_t v14 = v21;
      uint64_t v15 = *(void *)(v10 + 376);
      uint64_t v17 = *(void *)(v15 + 72);
      unint64_t v16 = *(void *)(v15 + 80);
      if (v16 >= *(void *)(*(void *)&v21[5].__opaque[48] + 96)
                + *(void *)(*(void *)&v21[5].__opaque[48] + 48)
                - *(void *)(*(void *)&v21[5].__opaque[48] + 184)
                + v17
        || v16 == 0)
      {
        unint64_t v19 = *(void *)(*(void *)&v21[5].__opaque[48] + 96)
            + *(void *)(*(void *)&v21[5].__opaque[48] + 48)
            - *(void *)(*(void *)&v21[5].__opaque[48] + 184)
            + v17;
      }
      else
      {
        unint64_t v19 = v16;
      }
    }
    else
    {
      unint64_t v19 = *(void *)(v13 + 96) + *(void *)(v13 + 48);
      uint64_t v14 = v21;
    }
    unint64_t v20 = sub_10000E558(v14, v10, a5);
    pthread_mutex_unlock(v14 + 9);
    obj_release(&v21->__sig);
    if (a2) {
      *a2 = v19;
    }
    if (a3) {
      *a3 = v20;
    }
    a3 = a4;
    if (a4) {
      goto LABEL_10;
    }
  }
  return v11;
}

unint64_t sub_10000E558(void *a1, uint64_t a2, BOOL *a3)
{
  uint64_t v3 = (void *)a1[47];
  uint64_t v4 = v3[30];
  uint64_t v5 = v3[35];
  uint64_t v6 = v3[24] - v3[23];
  uint64_t v7 = v3[15] + v3[9];
  unint64_t v8 = v7 + v4 + v5 + v6;
  if (!a2) {
    goto LABEL_6;
  }
  uint64_t v9 = *(void *)(a2 + 376);
  unint64_t v10 = *(void *)(v9 + 72);
  uint64_t v13 = v9 + 80;
  uint64_t v12 = *(void *)(v9 + 80);
  unint64_t v11 = *(void *)(v13 + 8);
  BOOL v14 = v10 >= v11;
  unint64_t v15 = v10 - v11;
  if (!v14) {
    unint64_t v15 = 0;
  }
  v8 += v15;
  if (v12) {
    unint64_t v16 = v12 - (v11 + *(void *)(a2 + 408));
  }
  else {
LABEL_6:
  }
    unint64_t v16 = v8;
  unint64_t v17 = v7 - (a1[104] + a1[105]);
  if (v8 >= v16) {
    unint64_t v8 = v16;
  }
  if (a3) {
    *a3 = v17 < v8;
  }
  if (v17 >= v8) {
    return v8;
  }
  else {
    return v17;
  }
}

uint64_t spaceman_compare_currently_available_space(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, atomic_ullong *a5, unint64_t *a6, unint64_t *a7, BOOL *a8, void *a9, unint64_t *a10, BOOL *a11)
{
  unint64_t v17 = (void *)a1;
  if (obj_type(a1) == 13) {
    uint64_t v18 = (uint64_t)v17;
  }
  else {
    uint64_t v18 = 0;
  }
  if (v18) {
    unint64_t v17 = *(void **)(v18 + 392);
  }
  uint64_t v31 = 0;
  if (!a5) {
    return 22;
  }
  uint64_t v19 = spaceman_get(v17, &v31);
  if (!v19)
  {
    pthread_mutex_lock(v31 + 9);
    unint64_t v20 = v31;
    unint64_t v21 = sub_10000E558(v31, v18, a8);
    unint64_t add_explicit = atomic_fetch_add_explicit(a5, a2, memory_order_relaxed);
    unint64_t v23 = a3 + a2 + add_explicit;
    BOOL v24 = v23 > v21;
    unint64_t v25 = v23 - v21;
    if (v24)
    {
      atomic_fetch_add_explicit(a5, -(uint64_t)a2, memory_order_relaxed);
      BOOL v26 = v25 <= add_explicit;
      uint64_t v19 = 28;
    }
    else
    {
      unint64_t v25 = 0;
      BOOL v26 = 0;
      uint64_t v19 = 0;
    }
    *a6 = v25;
    *a11 = v26;
    *a7 = v21;
    unint64_t v27 = *(void **)&v20[5].__opaque[48];
    *a9 = v27[35] + v27[30];
    unint64_t v28 = v27[32];
    *a10 = v28;
    unint64_t v29 = v27[37];
    if (v29)
    {
      if (v28 >= v29) {
        unint64_t v28 = v29;
      }
      *a10 = v28;
    }
    pthread_mutex_unlock(v20 + 9);
    obj_release(&v31->__sig);
  }
  return v19;
}

uint64_t spaceman_free_up_some_blocks(pthread_mutex_t **a1, void *a2, uint64_t a3)
{
  unint64_t v11 = 0;
  memset(v10, 0, sizeof(v10));
  uint64_t v6 = 0;
  if (!spaceman_get(a1, &v11))
  {
    uint64_t v7 = *(void *)&v11[5].__opaque[48];
    sub_10000E874((uint64_t)a1, (uint64_t)v10, 0, 0);
    pthread_mutex_lock(v11 + 7);
    sub_10000E968(a1, (uint64_t)v11, 0, 1, (uint64_t)v10, a3);
    pthread_mutex_unlock(v11 + 7);
    pthread_mutex_lock(v11 + 8);
    uint64_t v8 = sub_10000E968(a1, (uint64_t)v11, 2u, 1, (uint64_t)v10, a3);
    uint64_t v6 = sub_10000E968(a1, (uint64_t)v11, 1u, 1, (uint64_t)v10, a3) + v8;
    *a2 = *(void *)(v7 + 240) + *(void *)(v7 + 280);
    pthread_mutex_unlock(v11 + 8);
    sub_10000F1E4((uint64_t)a1, (uint64_t)v10);
    obj_release(&v11->__sig);
  }
  return v6;
}

uint64_t sub_10000E874(uint64_t result, uint64_t a2, int a3, int a4)
{
  if (a2)
  {
    *(_OWORD *)(a2 + 32) = 0u;
    *(_OWORD *)(a2 + 48) = 0u;
    *(_OWORD *)a2 = 0u;
    *(_OWORD *)(a2 + 16) = 0u;
    uint64_t result = dev_features(*(void *)(result + 384));
    if (result)
    {
      if (!a4) {
        return result;
      }
    }
    else if ((a4 & 1) == 0)
    {
      return result;
    }
    __tp.__darwin_time_t tv_sec = 0;
    __tp.uint64_t tv_nsec = 0;
    uint64_t result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t tv_sec = __tp.tv_sec;
    uint64_t tv_nsec = __tp.tv_nsec;
    *(void *)a2 = __tp.tv_sec;
    tv_nsec /= 1000;
    *(_DWORD *)(a2 + 8) = tv_nsec;
    uint64_t v9 = 1000000 * tv_sec + (int)tv_nsec;
    *(void *)(a2 + 16) = v9;
    *(void *)(a2 + 24) = v9;
    if (a3) {
      __int16 v10 = a3;
    }
    else {
      __int16 v10 = 30;
    }
    *(_WORD *)(a2 + 60) = v10;
    *(unsigned char *)(a2 + 62) = 1;
    *(unsigned char *)(a2 + 63) = a4 & 1;
  }
  return result;
}

uint64_t sub_10000E968(pthread_mutex_t **a1, uint64_t a2, unsigned int a3, char a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a2 + 376);
  unint64_t v99 = 0;
  unsigned int v100 = 0;
  unint64_t v97 = 0;
  unint64_t v98 = 0;
  uint64_t v85 = (pthread_mutex_t *)v6;
  int v83 = *(_DWORD *)(v6 + 36);
  uint64_t v7 = 1532;
  if (!a3) {
    uint64_t v7 = 1534;
  }
  uint64_t v82 = (unsigned __int16 *)(a2 + 1534);
  if (a3) {
    uint64_t v8 = (_WORD *)(a2 + 1532);
  }
  else {
    uint64_t v8 = (_WORD *)(a2 + 1534);
  }
  if (a3) {
    uint64_t v9 = 1552;
  }
  else {
    uint64_t v9 = 1544;
  }
  if (a3) {
    uint64_t v10 = 1560;
  }
  else {
    uint64_t v10 = 1561;
  }
  unsigned int v11 = *(unsigned __int16 *)(a2 + v7);
  if (*(_WORD *)(a2 + v7))
  {
    int v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    unint64_t v15 = (pthread_mutex_t *)(a2 + 512);
    uint64_t v90 = (pthread_mutex_t *)(a2 + 448);
    do
    {
      uint64_t v16 = v13;
      if ((a4 & 2) == 0) {
        int v12 = 16;
      }
      uint64_t v17 = *(void *)(a2 + v9);
      *(unsigned char *)(a2 + v10) = 1;
      if (a3)
      {
        pthread_mutex_unlock(v15);
        uint64_t v18 = v15;
      }
      else
      {
        uint64_t v18 = v90;
        pthread_mutex_unlock(v90);
      }
      uint64_t v13 = v17 + v16;
      v14 += v11;
      timespec __rqtp = (timespec)xmmword_100076DE0;
      nanosleep(&__rqtp, 0);
      pthread_mutex_lock(v18);
      unsigned int v11 = (unsigned __int16)*v8;
    }
    while (*v8);
    if (v12) {
      goto LABEL_33;
    }
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v19 = (uint64_t)a1;
  if (!spaceman_fq_tree_get(a1, a2, a3, 0, 0, (uint64_t *)&v100) && v100)
  {
    LODWORD(__rqtp.tv_sec) = 16;
    unsigned int v96 = 8;
    int v27 = bt_lookup_first(v100, 0, &v97, &__rqtp, &v99, &v96);
    unint64_t v91 = v97;
    if (a3 && !*(void *)(a2 + 1536)) {
      pthread_mutex_lock((pthread_mutex_t *)(a2 + 384));
    }
    unint64_t v28 = a6;
    if (v27)
    {
      uint64_t v29 = a5;
LABEL_30:
      if (*(void *)(a2 + 1536))
      {
        sub_100018124(v19, a2, a3, v29, v28);
        if (!a3)
        {
LABEL_96:
          obj_release(v100);
          return v13;
        }
      }
      else
      {
        dev_unmap_flush(*(void *)(v19 + 384));
        if (a3) {
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 384));
        }
        sub_100017E6C(v19, v29);
        if (!a3) {
          goto LABEL_96;
        }
      }
      if (*(void *)(a2 + 8 * (a3 - 1) + 976)) {
        sub_10005DA40();
      }
      goto LABEL_96;
    }
    char v31 = 0;
    unint64_t v80 = (4 * v83);
    uint64_t v81 = &v85[3].__opaque[40 * a3 + 16];
    uint64_t v86 = (pthread_mutex_t *)(a2 + 576);
    uint64_t v78 = (pthread_mutex_t *)(a2 + 448);
    int v84 = 2;
    uint64_t v29 = a5;
    while (1)
    {
      if ((v31 & 1) == 0 && obj_modify(a2, 0, v28)) {
        goto LABEL_30;
      }
      if (v96)
      {
        unint64_t v32 = v99;
      }
      else
      {
        unint64_t v99 = 1;
        unint64_t v32 = 1;
      }
      unint64_t v33 = v97;
      if (v97 <= v28)
      {
        if (v97 > v91)
        {
          *(void *)uint64_t v81 = v97;
          if ((a4 & 2) == 0) {
            goto LABEL_30;
          }
        }
        if (*(unsigned char *)(v19 + 632) && v33 >= *(void *)(*(void *)(v19 + 376) + 1408))
        {
          uint64_t v77 = a2 + 8 * a3;
          if (*(void *)(v77 + 920) < v28)
          {
            *(void *)(v77 + 920) = v28;
            log_info((uint64_t)"%s:%d: %s sfq %d processing xid %lld blocked by temporary checkpoints %lld\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"spaceman_free_completed");
          }
          goto LABEL_30;
        }
        unint64_t v34 = *(void *)(a2 + 912);
        if (v33 > v34)
        {
          if ((a4 & 3) != 0 && v84 && v33 != v28)
          {
            tx_barrier(v19, 0xD0u);
            --v84;
            unint64_t v33 = v97;
            unint64_t v34 = *(void *)(a2 + 912);
          }
          if (v33 > v34) {
            goto LABEL_30;
          }
        }
        if (a3)
        {
          if (spaceman_fq_over_threshold((pthread_mutex_t **)v19, a2, 0, 0)) {
            goto LABEL_30;
          }
          if (spaceman_extent_check(v19, a2, v98, v99))
          {
            pthread_mutex_lock(v86);
            sub_100017FE8(v19, a2, a3, v32);
            pthread_mutex_unlock(v86);
LABEL_61:
            if (nx_ratelimit_log_allowed(v19)) {
              log_err((uint64_t)"%s:%d: %s sfq %d error validating extent %lld %lld: %d\n", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"spaceman_free_completed");
            }
            goto LABEL_82;
          }
          if (v32 >= v80) {
            unint64_t v32 = v80;
          }
          pthread_mutex_lock(v86);
          unsigned int v79 = (void *)(a2 + 8 * (a3 - 1) + 976);
          *v79 += v32;
          sub_100017FE8(v19, a2, a3, v32);
          pthread_mutex_unlock(v86);
          unint64_t v42 = v98;
          uint64_t v43 = *(void *)(a2 + 1536);
          if (v43)
          {
            unint64_t v44 = *(unsigned __int16 *)(a2 + 1532);
            *(_WORD *)(a2 + 1532) = v44 + 1;
            unint64_t v45 = *(void *)(a2 + 1552) + v32;
            *(void *)(a2 + 1552) = v45;
            int v46 = *(_DWORD *)(*(void *)(a2 + 376) + 36);
            uint64_t v47 = v43 + 16 * v44;
            *(void *)(v47 + 256) = v42;
            *(void *)(v47 + 264) = v32;
            if (v44 > 0xEE || v45 >= (4 * v46)) {
              sub_100018124(v19, a2, a3, a5, v28);
            }
            goto LABEL_82;
          }
          dev_unmap(*(void *)(v19 + 384), v98);
          sub_1000184D8(v19, a2, v42, v32, 1, v28);
        }
        else
        {
          sub_100017FE8(v19, a2, 0, v32);
          if (sub_1000180A4(v19, a2, v98, v32, 0)) {
            goto LABEL_61;
          }
          unint64_t v48 = v98;
          uint64_t v49 = *(void *)(a2 + 1536);
          if (v49)
          {
            uint64_t v50 = *(unsigned __int16 *)(a2 + 1534);
            *(_WORD *)(a2 + 1534) = v50 + 1;
            *(void *)(a2 + 1544) += v32;
            unint64_t v51 = (unint64_t *)(v49 + 16 * v50);
            *unint64_t v51 = v48;
            v51[1] = v32;
            if ((unsigned __int16)(v50 + 1) >= 0x10u)
            {
              uint64_t v52 = v19;
              uint64_t v53 = v13;
              pthread_mutex_unlock(v78);
              uint64_t v54 = *v82;
              sub_100017E6C(v52, a5);
              if (v54)
              {
                uint64_t v55 = 0;
                uint64_t v56 = 16 * v54;
                do
                {
                  dev_unmap(*(void *)(v52 + 384), *(void *)(*(void *)(a2 + 1536) + v55));
                  v55 += 16;
                }
                while (v56 != v55);
                dev_unmap_flush(*(void *)(v52 + 384));
                pthread_mutex_lock(v78);
                uint64_t v57 = 0;
                uint64_t v13 = v53;
                uint64_t v19 = v52;
                unint64_t v58 = a6;
                do
                {
                  sub_100018280(v19, (void *)a2, *(void *)(*(void *)(a2 + 1536) + v57), *(void *)(*(void *)(a2 + 1536) + v57 + 8), a6);
                  v57 += 16;
                }
                while (v56 != v57);
              }
              else
              {
                dev_unmap_flush(*(void *)(v52 + 384));
                pthread_mutex_lock(v78);
                uint64_t v13 = v53;
                uint64_t v19 = v52;
                unint64_t v58 = a6;
              }
              *(void *)(a2 + 1544) = 0;
              *(_WORD *)(a2 + 1534) = 0;
              unint64_t v28 = v58;
            }
            goto LABEL_82;
          }
          dev_unmap(*(void *)(v19 + 384), v98);
          sub_100018280(v19, (void *)a2, v48, v32, v28);
        }
        sub_100017E6C(v19, a5);
      }
      else
      {
        log_err((uint64_t)"%s:%d: %s sfq %d entry %lld:%lld %lld - bad xid, current xid %lld\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"spaceman_free_completed");
        if (a3)
        {
          pthread_mutex_lock(v86);
          sub_100017FE8(v19, a2, a3, v32);
          pthread_mutex_unlock(v86);
        }
        else
        {
          sub_100017FE8(v19, a2, 0, v32);
        }
      }
LABEL_82:
      if (a5 && *(unsigned char *)(a5 + 62))
      {
        unint64_t v59 = *(void *)(a5 + 48) + v32;
        ++*(void *)(a5 + 40);
        *(void *)(a5 + 48) = v59;
      }
      if (bt_remove_first(v100, 0, 0, 0, 0, 0, v28)) {
        log_err((uint64_t)"%s:%d: %s sfq %d error removing entry %lld %lld from free queue: %d\n", v60, v61, v62, v63, v64, v65, v66, (uint64_t)"spaceman_free_completed");
      }
      uint64_t v67 = v99 - v32;
      if (v99 != v32)
      {
        v98 += v32;
        v99 -= v32;
        unsigned int v96 = 8 * (v67 != 1);
        if (bt_insert(v100, 0, &v97, 16, &v99, v96, v28)) {
          log_err((uint64_t)"%s:%d: %s sfq %d error inserting shortened entry %lld %lld into free queue: %d\n", v68, v69, v70, v71, v72, v73, v74, (uint64_t)"spaceman_free_completed");
        }
      }
      v13 += v32;
      LODWORD(__rqtp.tv_sec) = 16;
      unsigned int v96 = 8;
      int v75 = bt_lookup_first(v100, 0, &v97, &__rqtp, &v99, &v96);
      char v31 = 1;
      if (v75) {
        goto LABEL_30;
      }
    }
  }
LABEL_33:
  if (a5 && *(unsigned char *)(a5 + 62))
  {
    uint64_t v30 = *(void *)(a5 + 48) + v13;
    *(void *)(a5 + 40) += v14;
    *(void *)(a5 + 48) = v30;
  }
  return v13;
}

uint64_t sub_10000F1E4(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  if (!*(unsigned char *)(a2 + 62)) {
    return 0;
  }
  v8.__darwin_time_t tv_sec = 0;
  v8.uint64_t tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v8);
  __darwin_time_t tv_sec = v8.tv_sec;
  uint64_t tv_nsec = v8.tv_nsec;
  *(void *)a2 = v8.tv_sec;
  tv_nsec /= 1000;
  *(_DWORD *)(a2 + 8) = tv_nsec;
  *(void *)(a2 + 32) = 1000000 * tv_sec + (int)tv_nsec;
  *(unsigned char *)(a2 + 62) = 0;
  uint64_t v6 = *(int *)(a2 + 56);
  if (!v6) {
    return 0;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(a1 + 384) + 168), -v6, memory_order_relaxed);
  return 1;
}

void spaceman_manage_free_queues(pthread_mutex_t **a1, uint64_t a2)
{
  int v12 = 0;
  memset(v11, 0, sizeof(v11));
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v4 = *(void *)(a2 + 16);
  if (!spaceman_get(a1, &v12))
  {
    uint64_t v5 = *(void **)&v12[5].__opaque[48];
    sub_10000E874((uint64_t)a1, (uint64_t)&v9, 0, 1);
    pthread_mutex_lock(v12 + 7);
    if (spaceman_fq_over_threshold(a1, (uint64_t)v12, 0, 0))
    {
      while (spaceman_fq_over_threshold(a1, (uint64_t)v12, 0, 1)
           && sub_10000E968(a1, (uint64_t)v12, 0, 1, (uint64_t)&v9, v4))
        ;
    }
    while (1)
    {
      uint64_t v6 = v12;
      if (v4 - v5[27] <= (unint64_t)*(unsigned __int16 *)&v12[23].__opaque[48]) {
        break;
      }
      if (!sub_10000E968(a1, (uint64_t)v12, 0, 0, (uint64_t)&v9, v4))
      {
        uint64_t v6 = v12;
        break;
      }
    }
    pthread_mutex_unlock(v6 + 7);
    pthread_mutex_lock(v12 + 8);
    uint64_t v7 = v12;
    if (v5[30] > *(void *)&v12[23].__opaque[32])
    {
      while (1)
      {
        uint64_t v7 = v12;
        if (v5[30] <= *(void *)&v12[23].__opaque[32] >> 1) {
          break;
        }
        if (!sub_10000E968(a1, (uint64_t)v12, 1u, 1, (uint64_t)&v9, v4))
        {
          uint64_t v7 = v12;
          break;
        }
      }
    }
    if (v5[35] > *(void *)&v7[23].__opaque[40])
    {
      while (v5[35] > *(void *)&v12[23].__opaque[40] >> 1 && sub_10000E968(a1, (uint64_t)v12, 2u, 1, (uint64_t)&v9, v4))
        ;
    }
    if (v5[30] > v5[9])
    {
      while (v5[30] > v5[9] >> 1 && sub_10000E968(a1, (uint64_t)v12, 1u, 1, (uint64_t)&v9, v4))
        ;
    }
    if (v5[35] > v5[15])
    {
      while (v5[35] > v5[15] >> 1 && sub_10000E968(a1, (uint64_t)v12, 2u, 1, (uint64_t)&v9, v4))
        ;
    }
    if (spaceman_fq_over_threshold(a1, (uint64_t)v12, 1u, 0))
    {
      while (spaceman_fq_over_threshold(a1, (uint64_t)v12, 1u, 1)
           && sub_10000E968(a1, (uint64_t)v12, 1u, 1, (uint64_t)&v9, v4))
        ;
    }
    if (spaceman_fq_over_threshold(a1, (uint64_t)v12, 2u, 0))
    {
      while (spaceman_fq_over_threshold(a1, (uint64_t)v12, 2u, 1)
           && sub_10000E968(a1, (uint64_t)v12, 2u, 1, (uint64_t)&v9, v4))
        ;
    }
    while (v4 - v5[32] > (unint64_t)*(unsigned __int16 *)&v12[23].__opaque[48]
         && sub_10000E968(a1, (uint64_t)v12, 1u, 0, (uint64_t)&v9, v4))
      ;
    do
      uint64_t v8 = v5[37];
    while (v8
         && v4 - v8 > (unint64_t)*(unsigned __int16 *)&v12[23].__opaque[48]
         && sub_10000E968(a1, (uint64_t)v12, 2u, 0, (uint64_t)&v9, v4));
    sub_10000F1E4((uint64_t)a1, (uint64_t)&v9);
    *(_OWORD *)(a2 + 88) = *(_OWORD *)((char *)v11 + 8);
    *(void *)(a2 + 80) = *(void *)&v11[0] - v10;
    pthread_mutex_unlock(v12 + 8);
    obj_release(&v12->__sig);
  }
}

uint64_t spaceman_fq_over_threshold(pthread_mutex_t **a1, uint64_t a2, unsigned int a3, int a4)
{
  long long v9 = 0;
  uint64_t v7 = 0;
  if (!spaceman_fq_tree_get(a1, a2, a3, 0, 0, (uint64_t *)&v9) && v9)
  {
    uint64_t v7 = spaceman_fq_tree_over_threshold(a2, a3, (uint64_t)v9, a4);
    obj_release(v9);
  }
  return v7;
}

uint64_t spaceman_tx_start_closing(pthread_mutex_t **a1)
{
  uint64_t v14 = 0;
  if (spaceman_get(a1, &v14)) {
    return 0;
  }
  uint64_t v3 = *(void **)&v14[5].__opaque[48];
  pthread_mutex_lock(v14 + 9);
  unint64_t v4 = v3[9];
  unint64_t v5 = *(void *)&v14[23].__opaque[32] >> (v4 - v14[13].__sig < v3[6] >> 5);
  unint64_t v6 = v3[30];
  unint64_t v7 = v3[15];
  unint64_t v8 = *(void *)&v14[23].__opaque[40] >> (v7 - *(void *)v14[13].__opaque < v3[12] >> 5);
  unint64_t v9 = v3[35];
  pthread_mutex_unlock(v14 + 9);
  BOOL v12 = v9 > v7 || v9 > v8 || v6 > v4 || v6 > v5;
  if (v12 || spaceman_fq_over_threshold(a1, (uint64_t)v14, 0, 0))
  {
    uint64_t v2 = 1;
  }
  else
  {
    uint64_t v2 = 1;
    if (!spaceman_fq_over_threshold(a1, (uint64_t)v14, 1u, 0)) {
      uint64_t v2 = spaceman_fq_over_threshold(a1, (uint64_t)v14, 2u, 0);
    }
  }
  obj_release(&v14->__sig);
  return v2;
}

void spaceman_tx_complete(void *a1, uint64_t a2)
{
  unint64_t v4 = 0;
  if (!spaceman_get(a1, &v4))
  {
    uint64_t v3 = v4;
    v4[114] = a2;
    obj_release(v3);
  }
}

uint64_t spaceman_checkpoint_traverse(pthread_mutex_t **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8 = *(unsigned __int16 **)(a3 + 376);
  int v27 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  uint64_t v9 = spaceman_fq_tree_get(a1, a3, 0, 0, 0, (uint64_t *)&v26);
  if (v9) {
    goto LABEL_49;
  }
  uint64_t v9 = spaceman_fq_tree_get(a1, a3, 1u, 0, 0, (uint64_t *)&v27);
  if (v9) {
    goto LABEL_49;
  }
  uint64_t v9 = spaceman_fq_tree_get(a1, a3, 2u, 0, 0, (uint64_t *)&v25);
  if (v9) {
    goto LABEL_49;
  }
  if (a4 == 1)
  {
    uint64_t v20 = obj_checkpoint_start(a3);
    uint64_t v9 = v20;
    if (v20 || (uint64_t v17 = v26) == 0)
    {
      if (v20 || (uint64_t v18 = v27) == 0)
      {
        if (!v20)
        {
          uint64_t v19 = v25;
          if (v25) {
            goto LABEL_42;
          }
        }
        goto LABEL_49;
      }
      goto LABEL_32;
    }
    if (*(void *)(v26[49] + 32) <= (unint64_t)v8[112])
    {
      char v21 = 0;
    }
    else if (*(unsigned char *)(a3 + 968))
    {
      char v21 = 1;
    }
    else
    {
      log_err((uint64_t)"%s:%d: %s IP free queue tree is too large: %lld nodes (limit %d) xid %lld\n", v10, (uint64_t)v26, v11, v12, v13, v14, v15, (uint64_t)"spaceman_checkpoint_traverse");
      char v21 = 1;
      uint64_t v17 = v26;
    }
    *(unsigned char *)(a3 + 968) = v21;
    goto LABEL_28;
  }
  if (a4 == 2)
  {
    uint64_t v16 = obj_checkpoint_known(a3);
    uint64_t v9 = v16;
    if (v16 || (uint64_t v17 = v26) == 0)
    {
      if (v16 || (uint64_t v18 = v27) == 0)
      {
        if (v16) {
          goto LABEL_49;
        }
        uint64_t v19 = v25;
        if (!v25) {
          goto LABEL_49;
        }
LABEL_48:
        uint64_t v9 = btree_checkpoint_traverse((uint64_t)a1, a2, (uint64_t)v19, a4);
        goto LABEL_49;
      }
      goto LABEL_38;
    }
    goto LABEL_28;
  }
  uint64_t v17 = v26;
  if (v26)
  {
LABEL_28:
    uint64_t v9 = btree_checkpoint_traverse((uint64_t)a1, a2, (uint64_t)v17, a4);
    goto LABEL_29;
  }
  uint64_t v9 = 0;
LABEL_29:
  if (!v9)
  {
    uint64_t v18 = v27;
    if (v27)
    {
      if (a4 != 1)
      {
LABEL_38:
        uint64_t v9 = btree_checkpoint_traverse((uint64_t)a1, a2, (uint64_t)v18, a4);
        goto LABEL_39;
      }
LABEL_32:
      if (*(void *)(v18[49] + 32) <= (unint64_t)v8[132])
      {
        char v22 = 0;
      }
      else if (*(unsigned char *)(a3 + 969))
      {
        char v22 = 1;
      }
      else
      {
        log_err((uint64_t)"%s:%d: %s main free queue tree is too large: %lld nodes (limit %d) xid %lld\n", v10, (uint64_t)v18, v11, v12, v13, v14, v15, (uint64_t)"spaceman_checkpoint_traverse");
        char v22 = 1;
        uint64_t v18 = v27;
      }
      *(unsigned char *)(a3 + 969) = v22;
      goto LABEL_38;
    }
  }
LABEL_39:
  if (!v9)
  {
    uint64_t v19 = v25;
    if (v25)
    {
      if (a4 != 1) {
        goto LABEL_48;
      }
LABEL_42:
      if (*(void *)(v19[49] + 32) <= (unint64_t)v8[152])
      {
        char v23 = 0;
      }
      else if (*(unsigned char *)(a3 + 970))
      {
        char v23 = 1;
      }
      else
      {
        log_err((uint64_t)"%s:%d: %s tier2 free queue tree is too large: %lld nodes (limit %d) xid %lld\n", v10, (uint64_t)v19, v11, v12, v13, v14, v15, (uint64_t)"spaceman_checkpoint_traverse");
        char v23 = 1;
        uint64_t v19 = v25;
      }
      *(unsigned char *)(a3 + 970) = v23;
      goto LABEL_48;
    }
  }
LABEL_49:
  if (v26) {
    obj_release(v26);
  }
  if (v27) {
    obj_release(v27);
  }
  if (v25) {
    obj_release(v25);
  }
  return v9;
}

uint64_t spaceman_fq_tree_get(pthread_mutex_t **a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t *a6)
{
  if (a3 > 2) {
    return 22;
  }
  uint64_t v10 = *(void *)(a2 + 376);
  uint64_t v11 = a2 + 8 * a3;
  uint64_t v12 = *(void *)(v11 + 944);
  *a6 = v12;
  if (v12) {
    goto LABEL_4;
  }
  uint64_t v13 = v10 + 40 * a3;
  uint64_t v16 = *(void *)(v13 + 208);
  uint64_t v15 = (uint64_t *)(v13 + 208);
  uint64_t v14 = v16;
  if (v16)
  {
    uint64_t result = btree_get(a1, 0x80000000, v14, 0, 0, 0, 9, spaceman_free_queue_key_cmp, 0, a6);
    if (!result)
    {
LABEL_8:
      *(void *)(v11 + 944) = *a6;
      uint64_t v12 = *a6;
LABEL_4:
      obj_retain(v12);
      return 0;
    }
    return result;
  }
  if (!a5)
  {
    uint64_t result = 0;
    goto LABEL_14;
  }
  uint64_t result = obj_modify(a2, 0, a4);
  if (result)
  {
LABEL_14:
    *a6 = 0;
    return result;
  }
  uint64_t result = btree_create(a1, 0x80000000, 6, 9, 0, 0x10u, 8, (uint64_t)spaceman_free_queue_key_cmp, a4, a6);
  if (!result)
  {
    *uint64_t v15 = obj_oid(*a6);
    obj_dirty(a2, a4, 0);
    goto LABEL_8;
  }
  return result;
}

uint64_t spaceman_iterate_free_extents_internal(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(void *a1, unint64_t a2, int64_t a3), void *a5)
{
  uint64_t v8 = a1;
  long long v275 = 0u;
  long long v276 = 0u;
  memset(v274, 0, sizeof(v274));
  v273 = 0;
  v272 = 0;
  memset(v280, 0, 128);
  uint64_t v9 = (pthread_mutex_t *)(a1 + 848);
  unint64_t v259 = 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 848));
  if ((a2 & 0x30) == 0 && *(unsigned char *)(v8 + 641))
  {
    pthread_mutex_unlock(v9);
    return 16;
  }
  unint64_t v271 = 0;
  v270 = 0;
  v269 = 0;
  long long v260 = 0u;
  long long v261 = 0u;
  long long v262 = 0u;
  long long v263 = 0u;
  long long v264 = 0u;
  long long v265 = 0u;
  long long v266 = 0u;
  long long v267 = 0u;
  uint64_t v268 = 0;
  ++*(_DWORD *)(v8 + 824);
  pthread_mutex_unlock(v9);
  uint64_t v10 = spaceman_get((void *)v8, &v269);
  if (!v10)
  {
    v242 = *(unsigned int **)&v269[5].__opaque[48];
    v250 = a4;
    if ((a2 & 0x40) != 0)
    {
      unsigned int v11 = 4;
    }
    else if ((a2 & 0x20) != 0)
    {
      unsigned int v11 = 8;
    }
    else if (a4 == sub_100011654)
    {
      unsigned int v11 = 1;
    }
    else
    {
      unsigned int v11 = v242[10];
    }
    uint64_t v13 = (char *)_apfs_malloc(16 * v242[10]);
    uint64_t v14 = (char *)_apfs_malloc(8 * v242[10]);
    uint64_t v15 = v14;
    uint64_t v16 = 12;
    if (!v13 || !v14)
    {
LABEL_375:
      if (v15) {
        _apfs_free(v15, 8 * v242[10]);
      }
      uint64_t v10 = v16;
      if (v13) {
        _apfs_free(v13, 16 * v242[10]);
      }
      obj_release(&v269->__sig);
      goto LABEL_380;
    }
    if ((a2 & 2) == 0) {
      pthread_mutex_lock(v269 + 6);
    }
    if (a3)
    {
      if ((a2 & 0x6C) != 0x40)
      {
        uint64_t v16 = 22;
LABEL_365:
        if (v273) {
          obj_release(v273);
        }
        if (v272) {
          obj_release(v272);
        }
        for (uint64_t i = 0; i != 16; ++i)
        {
          uint64_t v205 = v280[i];
          if (v205)
          {
            obj_async_wait(v205);
            obj_release((uint64_t *)v280[i]);
          }
        }
        if ((a2 & 2) == 0) {
          pthread_mutex_unlock(v269 + 6);
        }
        goto LABEL_375;
      }
      int v218 = a2 & 0x30;
      uint64_t v17 = ((unint64_t)(a3 << __clz(__rbit64(*(unsigned int *)(*(void *)(v8 + 376) + 36)))) >> 62) & 1;
    }
    else
    {
      int v218 = a2 & 0x30;
      if ((a2 & 4) != 0)
      {
        LODWORD(v17) = 0;
        unsigned int v18 = 1;
LABEL_24:
        BOOL v214 = 0;
        char v221 = 0;
        char v223 = 0;
        uint64_t v225 = 0;
        uint64_t v257 = 0;
        uint64_t v19 = &v259;
        if ((a2 & 0x20) == 0) {
          uint64_t v19 = 0;
        }
        unsigned int v213 = (uint64_t *)v19;
        char v230 = a2 & 0xFE;
        uint64_t v20 = v17;
        uint64_t v209 = v18;
        unsigned int v215 = v13 + 8;
        v224 = v13 - 16;
        v232 = v9;
        __base = v13;
        v244 = v15;
        unsigned int v216 = v18;
        uint64_t v229 = v8;
        char v236 = a2;
        while (1)
        {
          if (a2)
          {
            uint64_t v268 = 0;
            long long v266 = 0u;
            long long v267 = 0u;
            long long v264 = 0u;
            long long v265 = 0u;
            long long v262 = 0u;
            long long v263 = 0u;
            long long v260 = 0u;
            long long v261 = 0u;
            LODWORD(v268) = spaceman_get_number_of_disabled_allocation_zones((uint64_t)v269, v20);
          }
          unint64_t v259 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v8 + 376) + 36)))) & a3;
          int v212 = spaceman_free_extent_cache_bitmap_scan_begin(*(void *)&v269[24].__opaque[8 * v20 + 24], v213);
          unint64_t v21 = v259;
          unint64_t v22 = v242[9];
          if ((a2 & 0x40) == 0)
          {
            unint64_t v21 = v259 / v22 * v22;
            unint64_t v259 = v21;
          }
          unint64_t v210 = v21;
          char v23 = &v242[12 * v20];
          uint64_t v24 = v23 + 16;
          uint64_t v219 = (int *)(v23 + 17);
          int v220 = -1;
          unint64_t v25 = v21 / v22 / v242[10];
          uint64_t v253 = v20;
          int v217 = v23 + 16;
LABEL_32:
          if (v25 < *v24) {
            break;
          }
          if ((a2 & 1) != 0 && v268)
          {
            int v190 = v25;
            qsort(&v260, 8uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1000118B0);
            if (v268)
            {
              LODWORD(v25) = v190;
              uint64_t v24 = v217;
              if (DWORD2(v267))
              {
                unsigned int v191 = 6;
                uint64_t v192 = &v267;
                while (1)
                {
                  LOBYTE(v279) = 0;
                  if (spaceman_evaluate_chunk_for_disabled_allocation_zones((uint64_t)v269, v20, *(void *)v192, &v279))log_err((uint64_t)"%s:%d: %s failed to evaluate chunk %llu (average free ext len %u) for disabled allocation zones, error %d\n", v193, v194, v195, v196, v197, v198, v199, (uint64_t)"spaceman_iterate_free_extents_internal"); {
                  int v200 = v268;
                  }
                  if ((_BYTE)v279)
                  {
                    int v200 = v268 - 1;
                    LODWORD(v268) = v268 - 1;
                  }
                  uint64_t v13 = __base;
                  unsigned int v18 = v216;
                  uint64_t v24 = v217;
                  uint64_t v257 = 0;
                  LODWORD(v25) = v190;
                  if (!v200 || v191 == -1) {
                    break;
                  }
                  uint64_t v192 = &v260 + v191--;
                  if (!*((_DWORD *)v192 + 2))
                  {
                    uint64_t v257 = 0;
                    uint64_t v13 = __base;
                    unsigned int v18 = v216;
                    break;
                  }
                }
              }
            }
            else
            {
              LODWORD(v25) = v190;
              uint64_t v24 = v217;
            }
          }
          if (v212)
          {
            if (v210) {
              char v201 = 0;
            }
            else {
              char v201 = v25 == *v24;
            }
            spaceman_free_extent_cache_bitmap_scan_finished(*(void *)&v269[24].__opaque[8 * v20 + 24], v259, v201);
          }
          a3 = 0;
          if (++v20 == v209)
          {
            char v206 = 0;
            LODWORD(v20) = v18;
            uint64_t v16 = v257;
            if (v223) {
              goto LABEL_355;
            }
            goto LABEL_356;
          }
        }
        unint64_t v26 = v259;
        unint64_t v27 = v242[9];
        unsigned int v28 = v242[10];
        if (!v218)
        {
          int v29 = v25;
          pthread_mutex_lock(v9);
          if (*(unsigned char *)(v8 + 641))
          {
            LODWORD(v20) = v253;
            log_info((uint64_t)"%s:%d: %s nx_resize detected while processing dev=%d cib=%u out of %u cibs\n", v30, v31, v32, v33, v34, v35, v36, (uint64_t)"spaceman_iterate_free_extents_internal");
            pthread_mutex_unlock(v9);
            char v206 = 0;
            uint64_t v16 = 16;
            uint64_t v13 = __base;
            goto LABEL_385;
          }
          pthread_mutex_unlock(v9);
          LODWORD(v25) = v29;
        }
        unsigned int v222 = v11;
        uint64_t v37 = v25;
        unsigned int v38 = v25;
        pthread_mutex_lock(&v269[v253 + 10]);
        int v39 = *v219;
        unsigned int v226 = v38;
        unsigned int v227 = v37;
        BOOL v255 = *v219 == 0;
        if (!*v219)
        {
          unint64_t v42 = (uint64_t *)(*(void *)&v269[13].__opaque[8 * v253 + 48] + 8 * v37);
          char v223 = 1;
          uint64_t v41 = v225;
LABEL_46:
          if (v272)
          {
            obj_lock((uint64_t)v272, 1u);
            LOBYTE(a2) = v236;
            goto LABEL_50;
          }
          uint64_t v52 = *v42;
          v270 = v242;
          unint64_t v271 = __PAIR64__(v226, v253);
          uint64_t v53 = obj_get(*(void *)(v8 + 392), 1073741892, v52, &sm_cib_desc, &v270, 0, 0, 0, &v272);
          LOBYTE(a2) = v236;
          if (!v53)
          {
            uint64_t v257 = 0;
            uint64_t v15 = v244;
LABEL_50:
            uint64_t v243 = v272[7];
            if (v250 == sub_100011654)
            {
              sub_10000E874(v8, (uint64_t)v274, 125, 0);
              if (v39) {
                goto LABEL_52;
              }
            }
            else if (v39)
            {
              goto LABEL_52;
            }
            pthread_mutex_unlock(&v269[v253 + 10]);
            char v223 = 0;
LABEL_52:
            uint64_t v225 = v41;
            if (v273)
            {
              obj_unlock((uint64_t)v273, 1u);
              char v221 = 0;
            }
            bzero(v15, 8 * v242[10]);
            unsigned int v65 = *(_DWORD *)(v243 + 36);
            unint64_t v231 = v26 / v27 - v28 * (unint64_t)v226;
            unsigned int v11 = v222;
            if (v222 >= v65 - v231) {
              size_t v66 = v65 - v231;
            }
            else {
              size_t v66 = v222;
            }
            unsigned int v67 = v242[10];
            if (v65 > v67) {
              sub_10005DA6C();
            }
            uint64_t v20 = v253;
            if (v66 > v67) {
              sub_10005DA98();
            }
            unsigned int v68 = v26 % v27;
            if (v66)
            {
              uint64_t v69 = 0;
              unsigned int v70 = v242[9];
              unsigned int v71 = v231;
              uint64_t v13 = __base;
              do
              {
                uint64_t v72 = &__base[v69];
                *(_DWORD *)uint64_t v72 = v71;
                *((void *)v72 + 1) = *(void *)(v243 + 32 * v71 + 64);
                if (v69) {
                  unsigned int v73 = 0;
                }
                else {
                  unsigned int v73 = v68;
                }
                v259 += v70 - v73;
                ++v71;
                v69 += 16;
              }
              while (16 * v66 != v69);
              if ((a2 & 0x40) != 0) {
                goto LABEL_67;
              }
            }
            else
            {
              unsigned int v71 = v231;
              uint64_t v13 = __base;
              if ((a2 & 0x40) != 0) {
                goto LABEL_67;
              }
            }
            qsort(v13, v66, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_1000117E4);
LABEL_67:
            if (!v66)
            {
              unsigned int v245 = 0;
              unsigned int v18 = v216;
              goto LABEL_300;
            }
            unsigned int v211 = v71;
            uint64_t v74 = 0;
            int v75 = 0;
            uint64_t v76 = v215;
            size_t v251 = v66;
            do
            {
              uint64_t v77 = v74;
              if (*v76)
              {
                uint64_t v78 = obj_get(*(void *)(v8 + 392), 1073742016, *v76, &sm_bm_desc, 0, 0, 0, 0, &v280[v75]);
                if (v78)
                {
                  uint64_t v82 = v78;
                  if (v78 != 45 && v78 != 16)
                  {
                    log_err((uint64_t)"%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", v79, v80, v81, v61, v62, v63, v64, (uint64_t)"spaceman_iterate_free_extents_internal");
                    uint64_t v16 = v82;
                    uint64_t v13 = __base;
                    uint64_t v15 = v244;
                    LODWORD(v20) = v253;
LABEL_348:
                    char v202 = v212;
LABEL_349:
                    char v206 = 1;
LABEL_350:
                    if (!v16) {
                      char v202 = 0;
                    }
                    if (v202) {
LABEL_353:
                    }
                      spaceman_free_extent_cache_bitmap_scan_finished(*(void *)&v269[24].__opaque[8 * v20 + 24], v259, 0);
                    if (v223) {
                      goto LABEL_355;
                    }
                    goto LABEL_356;
                  }
                  v280[v75] = 0;
                }
                ++v75;
                uint64_t v15 = v244;
                size_t v66 = v251;
                if (v75 == 16) {
                  break;
                }
              }
              uint64_t v74 = v77 + 1;
              v76 += 2;
            }
            while (v66 != v77 + 1);
            uint64_t v84 = 0;
            int v85 = 0;
            unsigned int v245 = 0;
            unsigned int v228 = v77 + 1;
            uint64_t v13 = __base;
            uint64_t v20 = v253;
            do
            {
              uint64_t v237 = v84;
              uint64_t v86 = &v13[16 * v84];
              unsigned int v235 = v242[10];
              uint64_t v87 = *(unsigned int *)v86;
              uint64_t v88 = &v280[v85];
              v241 = (uint64_t **)v88;
              uint64_t v239 = *((void *)v86 + 1);
              int v238 = v85;
              if (v239)
              {
                if (*v88) {
                  uint64_t v89 = obj_async_wait(*v88);
                }
                else {
                  uint64_t v89 = obj_get(*(void *)(v8 + 392), 1073741888, v239, &sm_bm_desc, 0, 0, 0, 0, &v280[v85]);
                }
                uint64_t v95 = v89;
                if (v89)
                {
                  log_err((uint64_t)"%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", v90, v91, v92, v61, v62, v63, v64, (uint64_t)"spaceman_iterate_free_extents_internal");
                  uint64_t v16 = v95;
                  if (*v241)
                  {
                    obj_release(*v241);
                    *v241 = 0;
                  }
                  char v202 = v212;
                  uint64_t v9 = v232;
                  goto LABEL_349;
                }
                unint64_t v93 = (void *)(*v241)[7];
                int v94 = *(_DWORD *)v86;
              }
              else
              {
                unint64_t v93 = 0;
                int v94 = *(_DWORD *)v86;
              }
              uint64_t v96 = v87;
              if ((a2 & 0x40) != 0 && v94)
              {
                *(void *)&v15[8 * v94] = *(void *)&v15[8 * (v94 - 1)];
                *(void *)&v15[8 * (*(_DWORD *)v86 - 1)] = 0;
                int v94 = *(_DWORD *)v86;
              }
              uint64_t v97 = 0;
              v247 = &v15[8 * v94];
              uint64_t v240 = v96;
              int v98 = *(_DWORD *)(v243 + 32 * v96 + 56);
              uint64_t v278 = 0;
              p_sig = &v269->__sig;
              uint64_t v234 = *(void *)&v269[23].__opaque[8 * v20 + 8];
              char v99 = v230;
              if (v234) {
                char v99 = a2;
              }
              char v258 = v99;
              if ((v99 & 0x40) != 0) {
                uint64_t v97 = *(void *)v247;
              }
              uint64_t v100 = *(void *)&v98 & 0xFFFFFLL;
              uint64_t v279 = 0;
              if ((v98 & 0xFFFFFu) <= v68)
              {
                unsigned int v102 = 0;
                LODWORD(v101) = 0;
                uint64_t v16 = 0;
LABEL_155:
                LOBYTE(a2) = v236;
                uint64_t v20 = v253;
                if ((v258 & 0x40) != 0) {
                  goto LABEL_156;
                }
                goto LABEL_157;
              }
              uint64_t v101 = 0;
              unsigned int v102 = 0;
              uint64_t v103 = v68;
              uint64_t v16 = 0;
              v248 = (void *)(v243 + 32 * v96 + 48);
              v249 = (unint64_t *)&v269[24].__opaque[8 * v253 + 24];
              unsigned int v104 = 1;
              v254 = v93;
              while (1)
              {
                if (!v93)
                {
                  uint64_t v278 = v100;
                  uint64_t v279 = v103;
                  uint64_t v105 = v100;
                  uint64_t v106 = v103;
                  goto LABEL_103;
                }
                if (!bitmap_range_find_first(0, (uint64_t)v93, v103, v100 - v103, &v279)) {
                  break;
                }
                if (bitmap_range_find_first(1, (uint64_t)v93, v279, v100 - v279, &v278))
                {
                  uint64_t v105 = v278;
                }
                else
                {
                  uint64_t v278 = v100;
                  uint64_t v105 = v100;
                }
                uint64_t v106 = v279;
LABEL_103:
                uint64_t v103 = v105;
                uint64_t v107 = v105 - v106;
                if (v105 - v106 > v101) {
                  uint64_t v101 = v105 - v106;
                }
                if ((v258 & 0x40) != 0)
                {
                  unsigned int v252 = 100 * (v104 / 0x64) - 1;
                  if (v97 && v106)
                  {
                    unsigned int v108 = v16;
                    if (v253 == 1)
                    {
                      char v109 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(*p_sig + 392) + 376) + 36)));
                      unint64_t v110 = (0x4000000000000000uLL >> v109) | (*v248 - v97);
                    }
                    else
                    {
                      unint64_t v110 = *v248 - v97;
                      char v109 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(*p_sig + 392) + 376) + 36)));
                    }
                    spaceman_free_extent_cache_insert(*v249, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v109) & v110, v97, v61, v62, v63, v64);
                    if (v250)
                    {
                      unsigned int v114 = v250(a5, v110, v97);
                      if (BYTE14(v276))
                      {
                        ++*((void *)&v275 + 1);
                        *(void *)&long long v276 = v276 + v97;
                      }
                    }
                    else
                    {
                      unsigned int v114 = 0;
                    }
                    uint64_t v97 = 0;
                    if (v108) {
                      BOOL v115 = 1;
                    }
                    else {
                      BOOL v115 = v114 == 0;
                    }
                    if (v115) {
                      uint64_t v16 = v108;
                    }
                    else {
                      uint64_t v16 = v114;
                    }
                    uint64_t v105 = v278;
                    size_t v66 = v251;
                  }
                  if (v105 != v100)
                  {
                    int v111 = v16;
                    if (v253 == 1)
                    {
                      char v112 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(*p_sig + 392) + 376) + 36)));
                      unint64_t v113 = (0x4000000000000000uLL >> v112) | (v106 - v97 + *v248);
                    }
                    else
                    {
                      unint64_t v113 = v106 - v97 + *v248;
                      char v112 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(*p_sig + 392) + 376) + 36)));
                    }
                    uint64_t v116 = v97 + v107;
LABEL_138:
                    spaceman_free_extent_cache_insert(*v249, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v112) & v113, v116, v61, v62, v63, v64);
                    if (v250)
                    {
                      unsigned int v117 = v250(a5, v113, v116);
                      int v118 = BYTE14(v276);
                      unint64_t v93 = v254;
                      if (BYTE14(v276))
                      {
                        ++*((void *)&v275 + 1);
                        *(void *)&long long v276 = v276 + v116;
                        int v118 = 1;
                      }
                      LODWORD(v16) = v111;
                    }
                    else
                    {
                      unsigned int v117 = 0;
                      int v118 = BYTE14(v276);
                      LODWORD(v16) = v111;
                      unint64_t v93 = v254;
                    }
                    uint64_t v97 = 0;
                    if (v16) {
                      BOOL v119 = 1;
                    }
                    else {
                      BOOL v119 = v117 == 0;
                    }
                    if (v119) {
                      uint64_t v16 = v16;
                    }
                    else {
                      uint64_t v16 = v117;
                    }
                    size_t v66 = v251;
                    if (v118 && v252 == v102)
                    {
                      sub_100017E6C(*(void *)(*p_sig + 392), (uint64_t)v274);
                      uint64_t v97 = 0;
                    }
                    goto LABEL_152;
                  }
                  v97 += v107;
                }
                else if (v106)
                {
                  if (v105 != v100)
                  {
                    int v111 = v16;
                    unsigned int v252 = 100 * (v104 / 0x64) - 1;
                    if (v253 == 1)
                    {
                      char v112 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(*p_sig + 392) + 376) + 36)));
                      unint64_t v113 = (0x4000000000000000uLL >> v112) | (v106 - v97 + *v248);
                    }
                    else
                    {
                      unint64_t v113 = v106 - v97 + *v248;
                      char v112 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(*p_sig + 392) + 376) + 36)));
                    }
                    uint64_t v116 = v107 + v97;
                    goto LABEL_138;
                  }
                  *((_DWORD *)v247 + 1) = v107;
                }
                else
                {
                  *(_DWORD *)v247 = v107;
                }
                unint64_t v93 = v254;
LABEL_152:
                ++v104;
                ++v102;
                if (v103 >= v100) {
                  goto LABEL_155;
                }
              }
              uint64_t v20 = v253;
              if ((v258 & 0x40) == 0 || !v97 || v102) {
                goto LABEL_155;
              }
              if (v253 == 1)
              {
                char v127 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(*p_sig + 392) + 376) + 36)));
                unint64_t v128 = (0x4000000000000000uLL >> v127) | (*v248 - v97);
              }
              else
              {
                unint64_t v128 = *v248 - v97;
                char v127 = __clz(__rbit64(*(unsigned int *)(*(void *)(*(void *)(*p_sig + 392) + 376) + 36)));
              }
              LOBYTE(a2) = v236;
              spaceman_free_extent_cache_insert(*v249, 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v127) & v128, v97, v61, v62, v63, v64);
              if (v250)
              {
                unsigned int v145 = v250(a5, v128, v97);
                if (BYTE14(v276))
                {
                  ++*((void *)&v275 + 1);
                  *(void *)&long long v276 = v276 + v97;
                }
              }
              else
              {
                unsigned int v145 = 0;
              }
              unsigned int v102 = 0;
              uint64_t v97 = 0;
              if (v16) {
                BOOL v161 = 1;
              }
              else {
                BOOL v161 = v145 == 0;
              }
              if (v161) {
                uint64_t v16 = v16;
              }
              else {
                uint64_t v16 = v145;
              }
LABEL_156:
              *(void *)v247 = v97;
LABEL_157:
              uint64_t v9 = v232;
              if ((v258 & 1) == 0) {
                goto LABEL_197;
              }
              unint64_t v120 = v240 + v235 * (unint64_t)v227;
              int v121 = *(_DWORD *)(v234 + 4 * v120);
              int v122 = v121 & 0xFF000000 | v101 & 0xFFFFFF;
              *(_DWORD *)(v234 + 4 * v120) = v122;
              if (v93)
              {
                int v123 = v121 & 0xFE000000 | v101 & 0xFFFFFF;
                int v124 = v122 | 0x1000000;
                if (*v93) {
                  int v124 = v123;
                }
                *(_DWORD *)(v234 + 4 * v120) = v124;
                uint64_t v125 = v234;
                if (v100 < 0x40 || (v93[(v100 >> 6) - 1] & 0x8000000000000000) != 0)
                {
                  unsigned int v126 = v124 & 0xFDFFFFFF;
                  goto LABEL_171;
                }
              }
              else
              {
                int v124 = v122 | 0x1000000;
                uint64_t v125 = v234;
              }
              unsigned int v126 = v124 | 0x2000000;
LABEL_171:
              *(_DWORD *)(v125 + 4 * v120) = v126;
              if (!v268) {
                goto LABEL_197;
              }
              unsigned int v129 = *(_DWORD *)(v243 + 32 * v240 + 60) & 0xFFFFF;
              if (v129 == *(_DWORD *)(p_sig[47] + 36))
              {
                char v277 = 0;
                if (spaceman_evaluate_chunk_for_disabled_allocation_zones((uint64_t)p_sig, v20, v120, &v277))log_err((uint64_t)"%s:%d: %s failed to evaluate free chunk %llu for disabled allocation zone, error %d\n", v130, v131, v132, v61, v62, v63, v64, (uint64_t)"spaceman_iterate_process_bitmap_block"); {
                if (v277)
                }
                  LODWORD(v268) = v268 - 1;
                goto LABEL_197;
              }
              if (!v102 || v129 < 4) {
                goto LABEL_197;
              }
              unsigned int v133 = v129 / v102;
              unint64_t v134 = (unint64_t)(&v260 + HIDWORD(v268));
              int v135 = v126 & 0xC000000;
              int v136 = v126 & 0xFFFFFC;
              BOOL v137 = v133 > *(_DWORD *)(v134 + 8) && v135 == 0;
              if (!v137 || v136 == 0) {
                goto LABEL_197;
              }
              int v139 = 0;
              *(_DWORD *)(v134 | 8) = v133;
              *(void *)unint64_t v134 = v120;
              uint64_t v140 = -7;
              unsigned int v141 = DWORD2(v260);
              uint64_t v142 = (unsigned int *)&v261 + 2;
              while (2)
              {
                unsigned int v144 = *v142;
                v142 += 4;
                unsigned int v143 = v144;
                if (v144 >= v141)
                {
LABEL_188:
                  BOOL v153 = __CFADD__(v140++, 1);
                  if (v153) {
                    goto LABEL_237;
                  }
                  continue;
                }
                break;
              }
              if (v143)
              {
                int v139 = v140 + 8;
                unsigned int v141 = v143;
                goto LABEL_188;
              }
              int v139 = v140 + 8;
LABEL_237:
              HIDWORD(v268) = v139;
LABEL_197:
              unsigned int v146 = v245;
              if (v245) {
                BOOL v147 = 1;
              }
              else {
                BOOL v147 = v16 == 0;
              }
              if (!v147) {
                unsigned int v146 = v16;
              }
              if ((a2 & 0x40) != 0 && v146)
              {
                uint64_t v8 = v229;
                uint64_t v13 = __base;
                uint64_t v15 = v244;
                goto LABEL_348;
              }
              unsigned int v245 = v146;
              uint64_t v8 = v229;
              uint64_t v13 = __base;
              uint64_t v15 = v244;
              if (!v239)
              {
                uint64_t v257 = v16;
                uint64_t v159 = v237;
                int v85 = v238;
                goto LABEL_225;
              }
              obj_release(*v241);
              *v241 = 0;
              if (v228 >= v66) {
                goto LABEL_223;
              }
              uint64_t v148 = v16;
              uint64_t v149 = 1;
              uint64_t v150 = &v224[16 * v228];
              do
              {
                uint64_t v151 = *((void *)v150 + 3);
                if ((a2 & 0x40) == 0 && !v151) {
                  sub_10005DB48();
                }
                size_t v152 = v228 + v149;
                v150 += 16;
                ++v149;
                if (v151) {
                  BOOL v153 = 1;
                }
                else {
                  BOOL v153 = v152 >= v66;
                }
              }
              while (!v153);
              unsigned int v228 = v228 + v149 - 1;
              if (!v151)
              {
                uint64_t v16 = v148;
                goto LABEL_223;
              }
              uint64_t v154 = obj_get(*(void *)(v229 + 392), 1073742016, v151, &sm_bm_desc, 0, 0, 0, 0, v241);
              if (v154 == 45 || v154 == 16)
              {
                uint64_t v16 = 0;
                *v241 = 0;
LABEL_223:
                uint64_t v159 = v237;
                int v160 = v238;
                goto LABEL_224;
              }
              int v160 = v238;
              if (v154)
              {
                uint64_t v16 = v154;
                log_err((uint64_t)"%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", v155, v156, v157, v61, v62, v63, v64, (uint64_t)"spaceman_iterate_free_extents_internal");
                goto LABEL_348;
              }
              uint64_t v16 = v154;
              uint64_t v159 = v237;
LABEL_224:
              uint64_t v257 = v16;
              int v85 = (v160 + 1) & 0xF;
LABEL_225:
              unsigned int v68 = 0;
              uint64_t v84 = v159 + 1;
            }
            while (v84 != v66);
            int v162 = 0;
            uint64_t v163 = 0;
            unint64_t v164 = 0;
            uint64_t v165 = (v66 - 1);
            while (1)
            {
              size_t v166 = v66;
              uint64_t v167 = (v162 + v231);
              uint64_t v168 = &v244[8 * v167];
              if ((a2 & 0x40) != 0)
              {
                uint64_t v169 = *(void *)v168;
                if (*(void *)v168)
                {
                  if (v165) {
                    sub_10005DB1C();
                  }
                  if (v164) {
                    sub_10005DAF0();
                  }
                  if (v163) {
                    sub_10005DAC4();
                  }
                  size_t v170 = v166;
                  if (v253 == 1) {
                    unint64_t v164 = (*(void *)(v243 + 32 * v167 + 48) - v169 + (*(_DWORD *)(v243 + 32 * v167 + 56) & 0xFFFFF)) | (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v229 + 376) + 36))));
                  }
                  else {
                    unint64_t v164 = *(void *)(v243 + 32 * v167 + 48) - v169 + (*(_DWORD *)(v243 + 32 * v167 + 56) & 0xFFFFF);
                  }
                  uint64_t v163 = v169;
                  goto LABEL_287;
                }
                goto LABEL_286;
              }
              uint64_t v171 = *(unsigned int *)v168;
              if (v171) {
                break;
              }
LABEL_269:
              uint64_t v176 = *((unsigned int *)v168 + 1);
              LOBYTE(a2) = v236;
              if (v176)
              {
                uint64_t v177 = v243 + 32 * v167;
                unsigned int v178 = (*(_DWORD *)(v177 + 56) & 0xFFFFF) - v176;
                if (v253 == 1)
                {
                  unint64_t v179 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v229 + 376) + 36)))) | (*(void *)(v177 + 48) + v178);
                  if (!v163)
                  {
LABEL_279:
                    uint64_t v180 = 0;
                    goto LABEL_280;
                  }
                }
                else
                {
                  unint64_t v179 = *(void *)(v177 + 48) + v178;
                  if (!v163) {
                    goto LABEL_279;
                  }
                }
                if (v163 + v164 == v179)
                {
                  uint64_t v180 = 0;
                  v176 += v163;
                  unint64_t v179 = v164;
                }
                else
                {
                  spaceman_free_extent_cache_insert(*(void *)&v269[24].__opaque[8 * v253 + 24], 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v229 + 376) + 36)))) & v164, v163, v61, v62, v63, v64);
                  if (!v250) {
                    goto LABEL_279;
                  }
                  uint64_t v180 = v250(a5, v164, v163);
                  if (BYTE14(v276))
                  {
                    ++*((void *)&v275 + 1);
                    *(void *)&long long v276 = v276 + v163;
                  }
                }
LABEL_280:
                unsigned int v181 = v245;
                if (v245) {
                  BOOL v182 = 1;
                }
                else {
                  BOOL v182 = v180 == 0;
                }
                uint64_t v257 = v180;
                if (!v182) {
                  unsigned int v181 = v180;
                }
                unsigned int v245 = v181;
                unint64_t v164 = v179;
                uint64_t v163 = v176;
              }
LABEL_286:
              size_t v170 = v166;
LABEL_287:
              ++v162;
              --v165;
              size_t v66 = v170 - 1;
              if (!v66)
              {
                if (v163)
                {
                  uint64_t v20 = v253;
                  spaceman_free_extent_cache_insert(*(void *)&v269[24].__opaque[8 * v253 + 24], 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v229 + 376) + 36)))) & v164, v163, v61, v62, v63, v64);
                  uint64_t v13 = __base;
                  unsigned int v11 = v222;
                  uint64_t v15 = v244;
                  if (v250)
                  {
                    uint64_t v183 = v250(a5, v164, v163);
                    if (BYTE14(v276))
                    {
                      ++*((void *)&v275 + 1);
                      *(void *)&long long v276 = v276 + v163;
                    }
                  }
                  else
                  {
                    uint64_t v183 = 0;
                  }
                  unsigned int v18 = v216;
                  unsigned int v71 = v211;
                  unsigned int v184 = v245;
                  if (v245) {
                    BOOL v185 = 1;
                  }
                  else {
                    BOOL v185 = v183 == 0;
                  }
                  uint64_t v257 = v183;
                  if (!v185) {
                    unsigned int v184 = v183;
                  }
                  unsigned int v245 = v184;
                }
                else
                {
                  uint64_t v13 = __base;
                  uint64_t v20 = v253;
                  unsigned int v11 = v222;
                  unsigned int v18 = v216;
                  unsigned int v71 = v211;
                  uint64_t v15 = v244;
                }
LABEL_300:
                if (v250 == sub_100011654) {
                  sub_1000117FC(v8);
                }
                obj_unlock((uint64_t)v272, 1u);
                if (BYTE14(v276))
                {
                  if (sub_10000F1E4(v8, (uint64_t)v274))
                  {
                    if (v11 <= 1) {
                      unsigned int v11 = 1;
                    }
                    else {
                      v11 >>= 1;
                    }
                    BOOL v186 = 1;
                  }
                  else
                  {
                    unsigned int v187 = v242[10];
                    int v188 = 4 * v11;
                    if (v187 < 4 * v11) {
                      int v188 = v242[10];
                    }
                    if (v187 >= v11 + 1) {
                      unsigned int v187 = v11 + 1;
                    }
                    if (v214) {
                      unsigned int v11 = v187;
                    }
                    else {
                      unsigned int v11 = v188;
                    }
                    BOOL v186 = v214;
                  }
                  BOOL v214 = v186;
                }
                if (*(_DWORD *)(v243 + 36) == v71)
                {
                  obj_release(v272);
                  v272 = 0;
                  unsigned int v189 = v226;
                }
                else
                {
                  unsigned int v189 = v226 - 1;
                }
                uint64_t v24 = v217;
                LODWORD(v25) = v189 + 1;
                if (v245)
                {
                  char v206 = 0;
                  uint64_t v16 = v245;
                  goto LABEL_385;
                }
                goto LABEL_32;
              }
            }
            if (v253 == 1)
            {
              unint64_t v172 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v229 + 376) + 36)))) | *(void *)(v243 + 32 * v167 + 48);
              if (!v163) {
                goto LABEL_262;
              }
            }
            else
            {
              unint64_t v172 = *(void *)(v243 + 32 * v167 + 48);
              if (!v163) {
                goto LABEL_262;
              }
            }
            if (v163 + v164 == v172)
            {
              uint64_t v173 = 0;
              v171 += v163;
              unint64_t v172 = v164;
LABEL_263:
              unsigned int v174 = v245;
              if (v245) {
                BOOL v175 = 1;
              }
              else {
                BOOL v175 = v173 == 0;
              }
              uint64_t v257 = v173;
              if (!v175) {
                unsigned int v174 = v173;
              }
              unsigned int v245 = v174;
              unint64_t v164 = v172;
              uint64_t v163 = v171;
              uint64_t v9 = v232;
              goto LABEL_269;
            }
            spaceman_free_extent_cache_insert(*(void *)&v269[24].__opaque[8 * v253 + 24], 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v229 + 376) + 36)))) & v164, v163, v61, v62, v63, v64);
            if (v250)
            {
              uint64_t v173 = v250(a5, v164, v163);
              if (BYTE14(v276))
              {
                ++*((void *)&v275 + 1);
                *(void *)&long long v276 = v276 + v163;
              }
              goto LABEL_263;
            }
LABEL_262:
            uint64_t v173 = 0;
            goto LABEL_263;
          }
          uint64_t v207 = v53;
          log_err((uint64_t)"%s:%d: %s error getting cib %d @ %lld: %d\n", v54, v55, v56, v57, v58, v59, v60, (uint64_t)"spaceman_iterate_free_extents_internal");
          char v206 = 0;
          uint64_t v16 = v207;
          char v223 = v255;
          uint64_t v13 = __base;
          uint64_t v15 = v244;
          LODWORD(v20) = v253;
LABEL_385:
          char v202 = v212;
          goto LABEL_350;
        }
        unsigned int v40 = v38 / v242[11];
        uint64_t v41 = v225;
        if (v40 == v220 && v225)
        {
          obj_lock((uint64_t)v273, 1u);
          unsigned int v40 = v220;
LABEL_45:
          pthread_mutex_unlock(&v269[v253 + 10]);
          char v223 = 0;
          unint64_t v42 = (uint64_t *)(v41 + 8 * (v38 - v242[11] * v40) + 40);
          char v221 = 1;
          goto LABEL_46;
        }
        uint64_t v43 = *(void *)(*(void *)&v269[13].__opaque[8 * v253 + 48] + 8 * v40);
        if (v273)
        {
          obj_release(v273);
          v273 = 0;
        }
        v270 = v242;
        unint64_t v271 = __PAIR64__(v40, v253);
        uint64_t v44 = obj_get(*(void *)(v8 + 392), 1073741892, v43, &sm_cab_desc, &v270, 0, 0, 0, &v273);
        if (!v44)
        {
          uint64_t v257 = 0;
          uint64_t v41 = v273[7];
          int v220 = v40;
          goto LABEL_45;
        }
        uint64_t v208 = v44;
        log_err((uint64_t)"%s:%d: %s error getting cab %d @ %lld: %d\n", v45, v46, v47, v48, v49, v50, v51, (uint64_t)"spaceman_iterate_free_extents_internal");
        char v206 = 0;
        uint64_t v16 = v208;
        if (v212)
        {
          char v223 = 1;
          LOBYTE(a2) = v236;
          uint64_t v13 = __base;
          LODWORD(v20) = v253;
          goto LABEL_353;
        }
        LOBYTE(a2) = v236;
        uint64_t v13 = __base;
        LODWORD(v20) = v253;
LABEL_355:
        pthread_mutex_unlock(&v269[(unint64_t)v20 + 10]);
LABEL_356:
        if (v273 && (v221 & 1) != 0) {
          obj_unlock((uint64_t)v273, 1u);
        }
        char v203 = v206 ^ 1;
        if (!v272) {
          char v203 = 1;
        }
        if ((v203 & 1) == 0)
        {
          sub_10000F1E4(v8, (uint64_t)v274);
          if (v250 == sub_100011654) {
            sub_1000117FC(v8);
          }
          obj_unlock((uint64_t)v272, 1u);
        }
        goto LABEL_365;
      }
      LODWORD(v17) = (a2 >> 3) & 1;
    }
    unsigned int v18 = 2;
    goto LABEL_24;
  }
LABEL_380:
  pthread_mutex_lock(v9);
  --*(_DWORD *)(v8 + 824);
  pthread_mutex_unlock(v9);
  return v10;
}

uint64_t sub_100011654(void *a1, unint64_t a2, int64_t a3)
{
  unint64_t v21 = 0;
  if (spaceman_get(a1, &v21)
    || (int v13 = spaceman_extent_check((uint64_t)a1, (uint64_t)v21, a2, a3), obj_release(v21), !v13))
  {
    a1[212] += a3;
    if (a3 < 2)
    {
      uint64_t v8 = 0;
    }
    else
    {
      uint64_t v6 = 0;
      unint64_t v7 = a3;
      do
      {
        uint64_t v8 = v6 + 1;
        if (v7 < 4) {
          break;
        }
        v7 >>= 2;
      }
      while (v6++ < 4);
    }
    ++a1[v8 + 213];
    __tp.__darwin_time_t tv_sec = 0;
    __tp.uint64_t tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    __darwin_time_t tv_sec = __tp.tv_sec;
    int v11 = SLODWORD(__tp.tv_nsec) / 1000;
    dev_unmap(a1[48], a2);
    __tp.__darwin_time_t tv_sec = 0;
    __tp.uint64_t tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    a1[211] += 1000000 * (__tp.tv_sec - tv_sec) - v11 + SLODWORD(__tp.tv_nsec) / 1000;
  }
  else if (nx_ratelimit_log_allowed((uint64_t)a1))
  {
    log_err((uint64_t)"%s:%d: %s free extent %lld:%lld appears to span container metadata and should not be free: %d\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"spaceman_trim_free_extent_callback");
  }
  return 0;
}

uint64_t sub_1000117E4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a2 + 8);
  BOOL v4 = v2 < v3;
  BOOL v5 = v2 > v3;
  if (v4) {
    return 0xFFFFFFFFLL;
  }
  else {
    return v5;
  }
}

uint64_t sub_1000117FC(uint64_t a1)
{
  v5.__darwin_time_t tv_sec = 0;
  v5.uint64_t tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v5);
  __darwin_time_t tv_sec = v5.tv_sec;
  int v3 = SLODWORD(v5.tv_nsec) / 1000;
  dev_unmap_flush(*(void *)(a1 + 384));
  v5.__darwin_time_t tv_sec = 0;
  v5.uint64_t tv_nsec = 0;
  uint64_t result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v5);
  *(void *)(a1 + 1688) += 1000000 * (v5.tv_sec - tv_sec) - v3 + SLODWORD(v5.tv_nsec) / 1000;
  return result;
}

uint64_t sub_1000118B0(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a2 + 8);
  BOOL v4 = v2 >= v3;
  BOOL v5 = v2 != v3;
  if (v4) {
    return v5;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t spaceman_scan_free_blocks(void *a1, int a2, int a3)
{
  dev_features(a1[48]);
  uint64_t v6 = 0;
  if (a3)
  {
    if (a2) {
      int v7 = 2;
    }
    else {
      int v7 = 0;
    }
    unsigned int v8 = v7 | a3;
    __tp.__darwin_time_t tv_sec = 0;
    __tp.uint64_t tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    a1[210] = 1000000 * __tp.tv_sec + SLODWORD(__tp.tv_nsec) / 1000;
    uint64_t v6 = spaceman_iterate_free_extents_internal((uint64_t)a1, v8, 0, 0, a1);
    __tp.__darwin_time_t tv_sec = 0;
    __tp.uint64_t tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    log_debug((uint64_t)"%s:%d: %s scan took %lld.%06lld s (no trims)\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"spaceman_scan_free_blocks");
  }
  return v6;
}

uint64_t spaceman_free_queue_key_cmp(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }
      else
      {
        uint64_t v8 = a2[1];
        uint64_t v9 = a4[1];
        BOOL v10 = v8 < v9;
        int v7 = v8 > v9;
        if (v10) {
          int v7 = -1;
        }
      }
    }
    else
    {
      int v7 = -1;
    }
    uint64_t result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t spaceman_fq_tree_find_overlap(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4, uint64_t a5, unsigned char *a6)
{
  uint64_t v6 = *(void *)(a2 + 376);
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  unint64_t v34 = 0;
  int64_t v35 = 0;
  *a6 = 0;
  if (!*(void *)(v6 + 40 * a3 + 208)) {
    return 0;
  }
  uint64_t v33 = 0;
  uint64_t v12 = spaceman_fq_tree_get();
  if (v12)
  {
    uint64_t v20 = v12;
    log_err((uint64_t)"%s:%d: %s can't get spaceman %d free queue tree %lld: %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"spaceman_fq_tree_find_overlap");
  }
  else
  {
    unint64_t v21 = *(void *)(v6 + 40 * a3 + 216);
    if (v21 > obj_xid(a2))
    {
LABEL_23:
      uint64_t v20 = 0;
    }
    else
    {
      int64_t v22 = a5 + a4;
      do
      {
        uint64_t v33 = 0x1000000008;
        unint64_t v34 = v21;
        int64_t v35 = a4;
        uint64_t v23 = bt_lookup_variant(v37, 0, &v34, (unsigned int *)&v33 + 1, 0x10u, &v36, (unsigned int *)&v33, 1u, 0, 0);
        if (v23 != 2)
        {
          uint64_t v20 = v23;
          if (v23) {
            break;
          }
          if (!v33) {
            uint64_t v36 = 1;
          }
          if (v21 == v34 && v36 + v35 > a4 && v22 > v35) {
            goto LABEL_27;
          }
        }
        uint64_t v33 = 0x1000000008;
        unint64_t v34 = v21;
        int64_t v35 = a4;
        uint64_t v31 = bt_lookup_variant(v37, 0, &v34, (unsigned int *)&v33 + 1, 0x10u, &v36, (unsigned int *)&v33, 4u, 0, 0);
        uint64_t v20 = v31;
        if (v31 != 2)
        {
          if (v31) {
            break;
          }
          if (!v33) {
            uint64_t v36 = 1;
          }
          if (v21 == v34 && v36 + v35 > a4 && v22 > v35)
          {
LABEL_27:
            uint64_t v20 = 0;
            *a6 = 1;
            goto LABEL_24;
          }
        }
        ++v21;
      }
      while (v21 <= obj_xid(a2));
      if ((v20 | 2) == 2) {
        goto LABEL_23;
      }
      log_err((uint64_t)"%s:%d: %s error searching spaceman free queue tree: %d\n", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"spaceman_fq_tree_find_overlap");
    }
LABEL_24:
    obj_release(v37);
  }
  return v20;
}

uint64_t spaceman_fq_tree_over_threshold(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  BOOL v4 = *(unsigned __int16 **)(a3 + 56);
  unint64_t v5 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 40 * a2 + 224);
  if (a4)
  {
    unint64_t v6 = *(void *)(*(void *)(a3 + 392) + 32);
    if (v5 >= 2) {
      return v6 > v5 >> 1;
    }
    if (v6 <= 1)
    {
      unsigned int v9 = v4[25] + v4[23] + v4[27];
      BOOL v10 = v9 >= obj_size_phys(a3) >> 1;
      return !v10;
    }
    return 1;
  }
  if (v5 >= 2) {
    return *(void *)(*(void *)(a3 + 392) + 32) > (3 * v5) >> 2;
  }
  if (*(void *)(*(void *)(a3 + 392) + 32) > 1uLL) {
    return 1;
  }
  unsigned int v11 = v4[25] + v4[23] + v4[27];
  BOOL v10 = v11 >= obj_size_phys(a3) >> 2;
  return !v10;
}

uint64_t spaceman_ip_block_index(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t *a4)
{
  uint64_t v6 = *(void *)(a2 + 376);
  uint64_t v7 = *(void *)(v6 + 152);
  if ((v7 & 0x8000000000000000) == 0)
  {
    uint64_t v8 = *(void *)(v6 + 176);
    unint64_t v9 = v8 + v7;
    BOOL v10 = __OFSUB__(a3, v8);
    uint64_t v11 = a3 - v8;
    if (v11 < 0 != v10 || v9 <= a3) {
      return 22;
    }
    uint64_t v13 = 0;
LABEL_12:
    *a4 = v11;
    return v13;
  }
  uint64_t v28 = 0;
  unint64_t v29 = 0;
  uint64_t v15 = (uint64_t **)(a2 + 1504);
  if (*(void *)(a2 + 1504))
  {
LABEL_8:
    *(void *)&v35[0] = a3;
    LODWORD(v32) = 8;
    LODWORD(v31[0]) = 16;
    uint64_t v13 = bt_lookup_variant(*v15, 0, (unint64_t *)v35, (unsigned int *)&v32, 8u, &v28, (unsigned int *)v31, 1u, 0, 0);
    if (v13) {
      return v13;
    }
    if (a3 - *(void *)&v35[0] >= v29) {
      return 2;
    }
    uint64_t v13 = 0;
    uint64_t v11 = v28 + a3 - *(void *)&v35[0];
    goto LABEL_12;
  }
  uint64_t v13 = btree_create(a1, 2281701376, 0, 0, 0, 8, 16, extent_list_key_cmp, 0, a2 + 1504);
  if (!v13)
  {
    uint64_t v37 = 0;
    memset(v35, 0, sizeof(v35));
    uint64_t v36 = 0;
    unint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v13 = nx_metadata_fragmented_extent_list_tree_get(a1, *(void *)(*(void *)(a2 + 376) + 176), &v37);
    if (!v13)
    {
      unint64_t v34 = 0;
      bt_iterator_init((uint64_t)v35, v37, 0, 0, &v34, 8, 8u, &v32, 0x10u);
      uint64_t v13 = v18;
      if (bt_iterator_ended((uint64_t)v35))
      {
        obj_release(v37);
        if (v13) {
          return v13;
        }
        goto LABEL_8;
      }
      while (1)
      {
        unint64_t v30 = v32;
        v31[0] = v34;
        v31[1] = v33;
        uint64_t v19 = bt_insert(*v15, 0, &v30, 8, v31, 0x10u, 0);
        if (v19) {
          break;
        }
        uint64_t v20 = bt_iterator_next((uint64_t)v35);
        if (v20)
        {
          uint64_t v13 = v20;
          strerror(v20);
          log_err((uint64_t)"%s:%d: %s failed to get next internal pool reverse mapping, error %s(%d)\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"spaceman_set_up_ip_reverse_mapping_tree");
          goto LABEL_26;
        }
        if (bt_iterator_ended((uint64_t)v35))
        {
          obj_release(v37);
          goto LABEL_8;
        }
      }
      uint64_t v13 = v19;
LABEL_26:
      obj_release(v37);
    }
  }
  return v13;
}

void *spaceman_free_queue_trim_list_init(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 1530) = 256;
  *(_WORD *)(a2 + 1534) = 0;
  uint64_t result = _apfs_calloc(0x100uLL, 0x10uLL);
  *(void *)(a2 + 1536) = result;
  if (!result) {
    *(_WORD *)(a2 + 1530) = 0;
  }
  return result;
}

uint64_t spaceman_alloc(void *a1, int a2, uint64_t a3, uint64_t a4, unint64_t *a5, uint64_t *a6)
{
  uint64_t v9 = (uint64_t)a1;
  long long v445 = 0u;
  long long v446 = 0u;
  long long v444 = 0u;
  v437 = 0;
  v438 = 0;
  v436 = 0;
  uint64_t v432 = 0;
  uint64_t v448 = 0;
  uint64_t v449 = 0;
  uint64_t v10 = 0;
  if (obj_type((uint64_t)a1) == 13)
  {
    uint64_t v10 = (uint64_t)a1;
    uint64_t v9 = a1[49];
  }
  long long v442 = 0u;
  long long v443 = 0u;
  long long v441 = 0u;
  memset(v433, 0, sizeof(v433));
  unsigned int v11 = a2 | 0x1000;
  if (!a6) {
    unsigned int v11 = a2 & 0xFFFFEBFF;
  }
  uint64_t v12 = *(void *)(v9 + 376);
  uint64_t v13 = *(void *)(v12 + 1240);
  char v14 = __clz(__rbit64(*(unsigned int *)(v12 + 36)));
  unint64_t v15 = 0x4000000000000000uLL >> v14;
  BOOL v16 = ((0x4000000000000000uLL >> v14) & v13) != 0;
  uint64_t v17 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v14;
  uint64_t v18 = v17 & v13;
  uint64_t v19 = *(void *)(v12 + 1248);
  uint64_t v20 = (v18 + v19) & v17;
  BOOL v21 = v19 == 0;
  if (v19) {
    unint64_t v22 = v18;
  }
  else {
    unint64_t v22 = 0;
  }
  unint64_t v415 = v22;
  if (v21) {
    unint64_t v23 = 0;
  }
  else {
    unint64_t v23 = v20;
  }
  unint64_t v412 = v23;
  uint64_t v24 = *(void *)(v9 + 1752);
  unint64_t v25 = v15 & v24;
  int v411 = (v15 & v24) != 0;
  if (*(unsigned char *)(v9 + 636) || (uint64_t v26 = *(void *)(v9 + 1760)) == 0)
  {
    unint64_t v419 = 0;
    unint64_t v417 = 0;
  }
  else
  {
    unint64_t v419 = v17 & v24;
    unint64_t v417 = (v26 + (v17 & v24)) & v17;
  }
  if ((v11 & 0x80) != 0) {
    v11 |= 0x8100u;
  }
  if ((v11 & 0x200) != 0)
  {
    v11 |= 0x102u;
    *a5 = *(void *)(v9 + 1768);
  }
  int v27 = (v11 >> 2) & 0x100;
  if (*(unsigned char *)(v9 + 639)) {
    int v27 = 2304;
  }
  int v28 = v27 | v11;
  if ((v11 & 2) != 0)
  {
    v28 &= ~0x40u;
    unint64_t v29 = *a5;
    if ((v28 & 0x40) == 0) {
      goto LABEL_23;
    }
  }
  else
  {
    unint64_t v29 = 0;
    if ((v28 & 0x40) == 0)
    {
LABEL_23:
      int v30 = 3;
      goto LABEL_26;
    }
  }
  int v30 = *(_DWORD *)a5;
LABEL_26:
  *a5 = 0;
  unsigned int v420 = v28;
  if ((v28 & 4) != 0)
  {
    if (a3 < 1) {
      return 22;
    }
  }
  else
  {
    BOOL is_current_tx = xid_is_current_tx(v9, a4);
    uint64_t v31 = 22;
    if (a3 < 1 || !is_current_tx) {
      return v31;
    }
  }
  v447 = 0;
  uint64_t v439 = 0;
  uint64_t v440 = 0;
  unint64_t v435 = 0;
  uint64_t v434 = 0;
  int64_t v431 = 0;
  unint64_t v430 = 0;
  unint64_t v429 = 0;
  unint64_t v428 = 0;
  uint64_t v31 = spaceman_get((void *)v9, &v447);
  if (v31) {
    return v31;
  }
  unsigned int v390 = v30;
  v384 = a5;
  uint64_t v33 = v447;
  uint64_t v34 = v447[47];
  int64_t v35 = (void *)v447[198];
  if (v35)
  {
    uint64_t v36 = v35[1] + a3;
    ++*v35;
    v35[1] = v36;
    if ((v420 & 0x40) == 0)
    {
      switch(a3)
      {
        case 1:
          unsigned int v38 = v35 + 4;
          goto LABEL_39;
        case 2:
          uint64_t v37 = v35 + 5;
          goto LABEL_35;
        case 3:
          uint64_t v37 = v35 + 6;
          goto LABEL_35;
        case 4:
          uint64_t v37 = v35 + 7;
          goto LABEL_35;
        default:
          goto LABEL_36;
      }
    }
    uint64_t v37 = v35 + 2;
LABEL_35:
    ++*v37;
LABEL_36:
    if ((unint64_t)a3 >= 2 && !a6)
    {
      unsigned int v38 = v35 + 8;
LABEL_39:
      ++*v38;
    }
  }
  if ((v420 & 0x200) != 0)
  {
    unint64_t v419 = v417;
    unint64_t v417 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36)))) & *(void *)(v34 + 48 * (v25 != 0) + 48);
  }
  if (!a6 && *(void *)(v34 + 96) + *(void *)(v34 + 48) <= (unint64_t)a3)
  {
    uint64_t v31 = 28;
    goto LABEL_663;
  }
  uint64_t v39 = *(void *)(v9 + 376);
  unsigned int v40 = v420;
  if ((v420 & 2) != 0)
  {
    char v41 = __clz(__rbit64(*(unsigned int *)(v39 + 36)));
    if ((((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v41) & v29) >= *(void *)(v34 + 48 * ((v29 << v41 >> 62) & 1) + 48)) {
      unsigned int v40 = v420 & 0xFFFFFFFD;
    }
    else {
      unsigned int v40 = v420;
    }
  }
  if ((v40 & 0x1A) == 2)
  {
    if (((v29 << __clz(__rbit64(*(unsigned int *)(v39 + 36)))) & 0x4000000000000000) != 0) {
      int v42 = 16;
    }
    else {
      int v42 = 8;
    }
    v40 |= v42;
  }
  uint64_t v43 = *(void *)(v39 + 48);
  if ((~v40 & 0x38) == 0) {
    panic("Absurd combination of allocation flags for spaceman %llx", v33);
  }
  if (*(void *)(v34 + 96))
  {
    int v44 = v40 & 0x20;
    switch((v40 >> 3) & 3)
    {
      case 1u:
      case 3u:
        uint64_t v448 = 0x200000001;
        uint64_t v449 = (uint64_t)&_mh_execute_header;
        break;
      default:
        uint64_t v448 = 0x100000002;
        uint64_t v449 = 1;
        v44 |= (unint64_t)(v43 & 2) >> 1;
        break;
    }
    unint64_t v383 = v29;
    int v372 = v16;
    if (v44) {
      char v45 = 1;
    }
    else {
      char v45 = 2;
    }
    unsigned __int8 v398 = v45;
  }
  else
  {
    if ((v40 & 0x10) != 0)
    {
      uint64_t v31 = 22;
      uint64_t v33 = v447;
      goto LABEL_663;
    }
    unint64_t v383 = v29;
    int v372 = v16;
    LODWORD(v449) = 0;
    unsigned __int8 v398 = 1;
    LODWORD(v448) = 1;
  }
  pthread_mutex_lock((pthread_mutex_t *)v447 + 6);
  uint64_t v403 = 0;
  unsigned int v397 = 0;
  unint64_t v51 = 0;
  int v52 = 0;
  char v376 = 0;
  int v380 = 0;
  BOOL v381 = 0;
  char v53 = 0;
  unsigned __int8 v410 = (v40 & 0x100 | v420 & 0x40) == 0;
  if (v447[186]) {
    int v54 = v40;
  }
  else {
    int v54 = v40 | 0x100;
  }
  int v418 = v54;
  int v373 = 2;
  unint64_t v421 = a3;
  uint64_t v55 = a3;
  while (2)
  {
    char v371 = v53;
    int v56 = v52;
    while (2)
    {
      int v57 = v56;
      unint64_t v413 = v51;
LABEL_73:
      unsigned int v58 = v418;
      int v409 = v57;
      while (1)
      {
        uint64_t v59 = v55;
        uint64_t v60 = a6;
        int v61 = v409;
        LOWORD(v418) = v58;
LABEL_75:
        uint64_t v55 = v421;
        if (v61 < v398)
        {
          int v62 = v61;
          goto LABEL_84;
        }
        if (v419)
        {
          if ((v58 & 0x200) == 0)
          {
            obj_type((uint64_t)a1);
            log_debug((uint64_t)"%s:%d: %s Could not find data to allocate outside the soft block-out range, disable soft block-out range\n", v63, v64, v65, v66, v67, v68, v69, (uint64_t)"spaceman_alloc");
            unint64_t v419 = 0;
            unint64_t v417 = 0;
            int v62 = 0;
            unsigned __int8 v410 = 0;
            *(unsigned char *)(v9 + 636) = 1;
            *(void *)(v9 + 1784) = 0;
            uint64_t v60 = a6;
            goto LABEL_84;
          }
          unint64_t v419 = 0;
          unint64_t v417 = 0;
        }
        else
        {
          if ((v410 & 1) == 0)
          {
            uint64_t v31 = 28;
LABEL_655:
            uint64_t v55 = v59;
            goto LABEL_656;
          }
          unint64_t v419 = 0;
        }
        int v62 = 0;
        unsigned __int8 v410 = 0;
LABEL_84:
        uint64_t v70 = *((unsigned int *)&v449 + v62);
        unsigned int v422 = *((_DWORD *)&v448 + v62);
        int v391 = v62;
        int v409 = v62 + 1;
        if ((v420 & 4) != 0)
        {
LABEL_111:
          BOOL v78 = v70 == v411;
          if (v417) {
            BOOL v79 = v70 == v411;
          }
          else {
            BOOL v79 = 0;
          }
          LODWORD(v80) = v420;
        }
        else
        {
          if ((v58 & 1) == 0)
          {
            BOOL v71 = 1;
            while (1)
            {
              if (v10)
              {
                uint64_t v72 = *(void *)(v10 + 376);
                unint64_t v73 = *(void *)(v72 + 80);
                if (v73)
                {
                  uint64_t v74 = *(void *)(v10 + 408) + *(void *)(v72 + 88);
                  if (v74 + v55 > v73)
                  {
                    uint64_t v55 = v73 - v74;
                    uint64_t v31 = 69;
                    if (!v60 || v55 < 1) {
                      goto LABEL_656;
                    }
                  }
                }
              }
              uint64_t v59 = *(void *)(v34 + 240)
                  + *(void *)(v34 + 72)
                  + *(void *)(v34 + 120)
                  + *(void *)(v34 + 280)
                  + *(void *)(v34 + 192)
                  - *(void *)(v34 + 184);
              if (v10)
              {
                uint64_t v75 = *(void *)(v10 + 376);
                unint64_t v76 = *(void *)(v75 + 72);
                unint64_t v77 = *(void *)(v75 + 88);
                if (v76 > v77) {
                  uint64_t v59 = v76 + v59 - v77;
                }
              }
              if (v55 > (unint64_t)v59)
              {
                uint64_t v31 = 28;
                if (!v60) {
                  goto LABEL_655;
                }
                uint64_t v55 = v59;
                if (v59 < 1) {
                  goto LABEL_655;
                }
              }
              uint64_t v59 = *(void *)(v34 + 48 * v70 + 72) - v447[v70 + 104];
              if (v55 > v59)
              {
                if (v71) {
                  v59 += *(void *)(v34 + 40 * v422 + 200);
                }
                if (v55 > v59)
                {
                  if (!v60 || v59 <= 0)
                  {
                    int v61 = v409;
                    v410 &= v409 < v398;
                    if (v447[v70 + 196] != 0 && v381) {
                      sub_10005DC50();
                    }
                    goto LABEL_75;
                  }
                  uint64_t v55 = v59;
                }
                if (!v71) {
                  goto LABEL_111;
                }
                pthread_mutex_unlock((pthread_mutex_t *)v447 + 6);
                pthread_mutex_lock((pthread_mutex_t *)v447 + 8);
                sub_10000E874(v9, (uint64_t)v433, 0, 0);
                BOOL v71 = sub_10000E968((pthread_mutex_t **)v9, (uint64_t)v447, v422, 1, (uint64_t)v433, a4) != 0;
                sub_10000F1E4(v9, (uint64_t)v433);
                pthread_mutex_unlock((pthread_mutex_t *)v447 + 8);
                pthread_mutex_lock((pthread_mutex_t *)v447 + 6);
                uint64_t v59 = 0;
                uint64_t v55 = v421;
                uint64_t v60 = a6;
              }
              if (v55 <= v59) {
                goto LABEL_111;
              }
            }
          }
          BOOL v78 = v70 == v411;
          if (v417) {
            BOOL v79 = v70 == v411;
          }
          else {
            BOOL v79 = 0;
          }
          LODWORD(v80) = v420;
          if ((v58 & 0x40) != 0)
          {
            if (v447[v70 + 106] < v421)
            {
              obj_type((uint64_t)a1);
              uint64_t v55 = v421;
              log_err((uint64_t)"%s:%d: %s Bogus attempt to perform metadata reserved allocation %lld with insufficient reserve %lld (%lld)\n", v319, v320, v321, v322, v323, v324, v325, (uint64_t)"spaceman_alloc");
              goto LABEL_682;
            }
          }
          else if (v447[v70 + 104] - v447[v70 + 106] < v421)
          {
            obj_type((uint64_t)a1);
            uint64_t v55 = v421;
            log_err((uint64_t)"%s:%d: %s Bogus attempt to perform non-metadata reserved allocation %lld with insufficient reserve %lld (%lld)\n", v312, v313, v314, v315, v316, v317, v318, (uint64_t)"spaceman_alloc");
LABEL_682:
            uint64_t v31 = 28;
            goto LABEL_656;
          }
        }
        BOOL v396 = v78;
        BOOL v81 = 0;
        uint64_t v82 = v447;
        unsigned int v83 = (LOBYTE(v447[13 * v70 + 138]) != 0) & (v80 >> 6);
        unsigned int v386 = v83;
        unsigned __int8 v84 = 0;
        if (v55 <= 4 && (v83 & 1) == 0)
        {
          unsigned __int8 v84 = v55 - 1;
          int v85 = &v447[17 * v70 + 152];
          uint64_t v86 = (v55 - 1);
          BOOL v81 = LOBYTE(v85[4 * v86 + 3]) != 0;
          if (LOBYTE(v85[4 * v86 + 3]) && (v58 & 0x100) == 0)
          {
            unsigned __int8 v388 = v55 - 1;
            uint64_t v90 = 0;
            uint64_t v432 = v85[4 * v86];
            BOOL v91 = v55 <= (*(_DWORD *)(v447[v70 + 186] + 4 * (v432 / *(unsigned int *)(v34 + 36))) & 0xFFFFFFu);
            char v387 = 1;
            goto LABEL_132;
          }
        }
        if (v390 < 3) {
          unsigned int v88 = (LOBYTE(v447[13 * v70 + 138]) != 0) & (v80 >> 6);
        }
        else {
          unsigned int v88 = 0;
        }
        unsigned __int8 v388 = v84;
        char v387 = v81;
        if (v88 == 1)
        {
          uint64_t metazone_alloc_index = spaceman_get_metazone_alloc_index((uint64_t)v447, v70, v390, v46, v47, v48, v49, v50);
          LODWORD(v80) = v420;
          uint64_t v90 = 0;
          BOOL v91 = 0;
          uint64_t v432 = metazone_alloc_index;
          uint64_t v82 = v447;
LABEL_132:
          int v93 = v58;
          goto LABEL_135;
        }
        if ((v58 & 2) != 0
          && (char v92 = __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36))),
              v70 == (((v383 << v92) & 0x4000000000000000) != 0)))
        {
          BOOL v91 = 0;
          uint64_t v90 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v92) & v383;
          uint64_t v432 = v90;
        }
        else
        {
          if ((v58 & 0x800) == 0)
          {
            uint64_t v90 = 0;
            BOOL v91 = 0;
            uint64_t v432 = v447[v70 + 124];
            goto LABEL_132;
          }
          uint64_t v90 = 0;
          BOOL v91 = 0;
          uint64_t v432 = 0;
        }
        int v93 = v58 | 0x4000;
LABEL_135:
        unsigned int v94 = (v80 >> 6) & 1;
        uint64_t v439 = 0;
        uint64_t v440 = 0;
        int64_t v431 = 0;
        unint64_t v429 = 0;
        uint64_t v95 = v82[v70 + 196];
        if (!v95) {
          LOBYTE(v94) = 1;
        }
        char v96 = v91 | v94;
        char v97 = (v93 & 0x8400) != 0 ? 1 : v96;
        if (v97) {
          break;
        }
        int64_t v431 = v90;
        unint64_t v429 = v55;
        unsigned int v98 = v93 & 0xFFFFDFFF;
        if (v410) {
          int v99 = 0x2000;
        }
        else {
          int v99 = 0;
        }
        unsigned int v58 = v98 | v99;
        int v100 = spaceman_free_extent_cache_search(v95, v98 | v99, &v431, &v429);
        if (v100 != 28)
        {
          unint64_t v364 = v90;
          unint64_t v400 = v429;
          int64_t v374 = v431;
          if (v429)
          {
            LOBYTE(v80) = v420;
            if (!v431)
            {
              unint64_t v400 = 0;
              unint64_t v429 = 0;
            }
          }
          else
          {
            LOBYTE(v80) = v420;
          }
          if (v373 == v70) {
            int v101 = 0;
          }
          else {
            int v101 = 3;
          }
          if (v100 != 3) {
            int v101 = v100;
          }
          int v418 = v58;
          if (v101 != 3)
          {
            if (!v101 && v400 && v431)
            {
              BOOL v267 = (v93 & 0x200) == 0 && v79;
              unsigned int v395 = 1;
              if (v267 && v431 < (uint64_t)v417)
              {
                if ((uint64_t)(v400 + v431) < (uint64_t)v419)
                {
                  unint64_t v406 = v413;
                  int v357 = 0;
                  uint64_t v31 = 0;
                }
                else
                {
                  obj_type((uint64_t)a1);
                  log_debug((uint64_t)"%s:%d: %s Could not find data to allocate outside the soft block-out range, disable soft block-out range\n", v268, v269, v270, v271, v272, v273, v274, (uint64_t)"spaceman_alloc");
                  int v357 = 0;
                  uint64_t v31 = 0;
                  unsigned int v395 = 1;
                  *(unsigned char *)(v9 + 636) = 1;
                  *(void *)(v9 + 1784) = 0;
                  unint64_t v406 = v413;
                }
                LOBYTE(v80) = v420;
              }
              else
              {
                unint64_t v406 = v413;
                int v357 = 0;
                uint64_t v31 = 0;
              }
              uint64_t v125 = v400;
              uint64_t v127 = v403;
              goto LABEL_595;
            }
            int v114 = v58 | 0x100;
            goto LABEL_191;
          }
          long long v426 = 0u;
          long long v427 = 0u;
          long long v425 = 0u;
          *(void *)&long long v425 = v447[v70 + 196];
          *((void *)&v425 + 1) = v55;
          *(void *)&long long v426 = v400;
          *((void *)&v426 + 1) = spaceman_free_extent_cache_search_better_length(v58, v55, v400);
          *(void *)&long long v427 = 0;
          *((void *)&v427 + 1) = v58;
          unsigned int v102 = v447;
          uint64_t v103 = &v447[v70];
          unsigned int v104 = v103 + 102;
          uint64_t v105 = v103[102];
          if ((v105 & 0x10) != 0)
          {
            uint64_t v106 = v103[102];
            int v57 = v391;
            do
            {
              *unsigned int v104 = v106 | 0x20;
              cv_wait((pthread_cond_t *)v102 + 16, (pthread_mutex_t *)v102 + 6, 8, (uint64_t)"spaceman_alloc_fxc_scan_wait", 0);
              unsigned int v102 = v447;
              unsigned int v104 = &v447[v70 + 102];
              uint64_t v106 = *v104;
            }
            while ((*v104 & 0x10) != 0);
            *unsigned int v104 = v106 | 0x10;
            if ((v105 & 0x10) != 0 && *(void *)(v102[v70 + 196] + 128) >= *((void *)&v426 + 1))
            {
              uint64_t v31 = 0;
              goto LABEL_183;
            }
          }
          else
          {
            *unsigned int v104 = v105 | 0x10;
            int v57 = v391;
          }
          pthread_mutex_unlock((pthread_mutex_t *)v102 + 6);
          if (v70 == 1) {
            unsigned int v107 = 42;
          }
          else {
            unsigned int v107 = 38;
          }
          LODWORD(v31) = spaceman_iterate_free_extents_internal(v9, v107, 0, (uint64_t (*)(void *, unint64_t, int64_t))sub_100014D84, &v425);
          pthread_mutex_lock((pthread_mutex_t *)v447 + 6);
          if (v31 == 34 || v31 == 37) {
            unsigned int v109 = 0;
          }
          else {
            unsigned int v109 = v31;
          }
          if (v31 == HIDWORD(v427)) {
            uint64_t v31 = v109;
          }
          else {
            uint64_t v31 = v31;
          }
          int v373 = v70;
LABEL_183:
          unint64_t v429 = 0;
          int64_t v431 = 0;
          unint64_t v110 = v447;
          uint64_t v111 = v447[v70 + 102];
          if ((v111 & 0x20) != 0)
          {
            cv_wakeup((pthread_cond_t *)v447 + 16);
            unint64_t v110 = v447;
            uint64_t v111 = v447[v70 + 102];
          }
          v110[v70 + 102] = v111 & 0xFFFFFFFFFFFFFFCFLL;
          if (v31) {
            goto LABEL_656;
          }
          goto LABEL_73;
        }
      }
      unint64_t v364 = v90;
      if ((v91 | ((v80 & 0x40) >> 6)))
      {
        unsigned int v395 = 0;
        v361 = 0;
        int v112 = v91 || (v420 & 0x40) == 0;
        BOOL v408 = v70 == v372;
        int v113 = !v396;
        BOOL v358 = v396;
        int v418 = v93;
        goto LABEL_213;
      }
      int v114 = v93;
LABEL_191:
      int v418 = v114;
      if (!v447[v70 + 186] || (v114 & 0x100) != 0)
      {
        BOOL v408 = v70 == v372;
        if (v97)
        {
          unsigned int v395 = 0;
          int v112 = 0;
          v361 = 0;
          int v113 = !v396;
          BOOL v358 = v396;
          goto LABEL_213;
        }
        goto LABEL_212;
      }
      *(void *)&long long v444 = v432;
      *((void *)&v444 + 1) = v55;
      LOBYTE(v445) = v410 & 1;
      BYTE8(v446) = a6 == 0;
      *((void *)&v445 + 1) = 0;
      *(void *)&long long v446 = 0;
      if (v79)
      {
        *((void *)&v445 + 1) = v419;
        *(void *)&long long v446 = v417 - v419;
      }
      sub_100014DFC((unint64_t)v447, v70, (uint64_t)&v444, &v441);
      if (v115 == 28) {
        goto LABEL_203;
      }
      if (v115)
      {
        obj_type((uint64_t)a1);
        log_err((uint64_t)"%s:%d: %s failed to search bitmap hints: %d\n", v117, v118, v119, v120, v121, v122, v123, (uint64_t)"spaceman_alloc");
LABEL_203:
        int v116 = 0;
        goto LABEL_204;
      }
      int v116 = v442;
      uint64_t v432 = v441;
      if (a6) {
        uint64_t v55 = *((void *)&v441 + 1);
      }
      char v376 = 1;
LABEL_204:
      if (v116) {
        BOOL v124 = 0;
      }
      else {
        BOOL v124 = v79;
      }
      LOBYTE(v80) = v420;
      if (v124)
      {
        unint64_t v419 = 0;
        unint64_t v417 = 0;
        if ((v114 & 0x200) == 0)
        {
          *(unsigned char *)(v9 + 636) = 1;
          *(void *)(v9 + 1784) = 0;
        }
      }
      unsigned __int8 v410 = v116 != 0;
      BOOL v408 = v70 == v372;
      if (v97)
      {
        unsigned int v395 = 0;
        int v112 = 0;
        v361 = 0;
        int v113 = !v396;
        BOOL v358 = v396;
        goto LABEL_213;
      }
LABEL_212:
      BOOL v358 = 0;
      int v112 = 0;
      v361 = &v432;
      int v113 = 1;
      unsigned int v395 = 1;
LABEL_213:
      int64_t v374 = 0;
      uint64_t v125 = 0;
      uint64_t v126 = v34 + 48 * v70;
      v392 = (unint64_t *)(v126 + 48);
      v389 = (unsigned int *)(v126 + 64);
      v367 = (_DWORD *)(v126 + 68);
      int v382 = v418 & 0x400;
      int v370 = v113 ^ 1;
      int v357 = v112;
      int v377 = v112 | ((v80 & 0x40) >> 6);
      int v359 = !v79;
      char v360 = v113;
      uint64_t v127 = v403;
      uint64_t v365 = v9;
      while (2)
      {
        if (v408 && v432 >= (uint64_t)v415 && v432 < (uint64_t)v412)
        {
          BOOL v129 = v358;
          if ((uint64_t)v412 < (uint64_t)v419) {
            BOOL v129 = 0;
          }
          if (v129 && (uint64_t)v412 < (uint64_t)v417) {
            unint64_t v130 = v417;
          }
          else {
            unint64_t v130 = v412;
          }
          uint64_t v432 = v130;
        }
        if ((v113 & 1) == 0 && v432 >= (uint64_t)v419 && v432 < (uint64_t)v417)
        {
          BOOL v132 = v408;
          if ((uint64_t)v417 < (uint64_t)v415) {
            BOOL v132 = 0;
          }
          if (v132 && (uint64_t)v417 < (uint64_t)v412) {
            unint64_t v133 = v412;
          }
          else {
            unint64_t v133 = v417;
          }
          uint64_t v432 = v133;
        }
        uint64_t v134 = v447[v70 + 196];
        if (v134)
        {
          LODWORD(v134) = spaceman_free_extent_cache_bitmap_scan_begin(v134, v361);
          int v380 = 0;
        }
        unint64_t v48 = v432;
        if (v432 >= *v392)
        {
          unint64_t v48 = 0;
          uint64_t v432 = 0;
        }
        LODWORD(v399) = 0;
        unsigned int v397 = 0;
        uint64_t v135 = 0;
        int v362 = v134;
        BOOL v381 = v134 != 0;
        if (v134) {
          unsigned int v136 = v395;
        }
        else {
          unsigned int v136 = 0;
        }
        int v385 = v136;
        int v368 = -1;
        unint64_t v406 = v413;
        while (1)
        {
          uint64_t v401 = v125;
          uint64_t v404 = v127;
          unint64_t v137 = v48 / *(unsigned int *)(v34 + 36) / *(unsigned int *)(v34 + 40);
          uint64_t v414 = v135;
          if (*v367)
          {
            unsigned int v138 = *(_DWORD *)(v34 + 44);
            unsigned int v139 = v137 / v138;
            uint64_t v140 = v438;
            if (v137 / v138 == v368)
            {
              LODWORD(v141) = v48 / *(unsigned int *)(v34 + 36) / *(unsigned int *)(v34 + 40);
              unsigned int v139 = v368;
            }
            else
            {
              unint64_t v142 = v48;
              uint64_t v144 = *(void *)(v447[v70 + 111] + 8 * v139);
              if (v438)
              {
                obj_release(v438);
                v438 = 0;
              }
              uint64_t v434 = v34;
              unint64_t v435 = __PAIR64__(v139, v70);
              uint64_t v145 = obj_get(*(void *)(v9 + 392), 0x40000000, v144, &sm_cab_desc, &v434, 0, 0, 0, &v438);
              if (v145)
              {
LABEL_569:
                uint64_t v31 = v145;
                LOBYTE(v80) = v420;
                uint64_t v127 = v404;
                unint64_t v48 = v142;
                uint64_t v125 = v401;
                goto LABEL_573;
              }
              unsigned int v138 = *(_DWORD *)(v34 + 44);
              uint64_t v140 = v438;
              unint64_t v48 = v142;
              int v368 = v139;
              unint64_t v141 = v142 / *(unsigned int *)(v34 + 36) / *(unsigned int *)(v34 + 40);
            }
            unint64_t v142 = v48;
            unsigned int v143 = (uint64_t *)(v140[7] + 8 * (v137 - v138 * v139) + 40);
            LODWORD(v137) = v141;
          }
          else
          {
            unint64_t v142 = v48;
            unsigned int v143 = (uint64_t *)(v447[v70 + 111] + 8 * v137);
          }
          uint64_t v146 = *v143;
          uint64_t v434 = v34;
          unint64_t v435 = __PAIR64__(v137, v70);
          uint64_t v145 = obj_get(*(void *)(v9 + 392), 0x40000000, v146, &sm_cib_desc, &v434, 0, 0, 0, &v437);
          if (v145) {
            goto LABEL_569;
          }
          uint64_t v127 = v437[7];
          unsigned int v147 = *(_DWORD *)(v127 + 32);
          uint64_t v149 = *(unsigned int *)(v34 + 36);
          unsigned int v148 = *(_DWORD *)(v34 + 40);
          unint64_t v150 = v148 * (unint64_t)v147;
          unint64_t v48 = v142;
          unsigned int v151 = v397 == *v389 ? v432 / v149 - v150 + 1 : *(_DWORD *)(v127 + 36);
          size_t v152 = a6;
          uint64_t v125 = v401;
          uint64_t v46 = v414;
          unint64_t v153 = v48 / v149 - v148 * (unint64_t)v147;
          if (v151 > v153) {
            break;
          }
          unint64_t v406 = v153;
          uint64_t v31 = 0;
LABEL_526:
          LOBYTE(v80) = v420;
LABEL_527:
          if (!v439 && v125 != v55)
          {
            BOOL v247 = v46 || !v125 ? v31 == 0 : (v31 | v382) == 0;
            BOOL v248 = !v247;
            if (((v248 | v380) & 1) == 0)
            {
              uint64_t v249 = v125;
              unint64_t v250 = v48;
              uint64_t v251 = v127;
              uint64_t v252 = v46;
              obj_release(v437);
              uint64_t v135 = v252;
              uint64_t v127 = v251;
              uint64_t v9 = v365;
              unint64_t v48 = v250;
              uint64_t v125 = v249;
              LOBYTE(v80) = v420;
              v437 = 0;
              if (++v397 <= *v389) {
                continue;
              }
            }
          }
          goto LABEL_573;
        }
        unint64_t v366 = v151 - 1;
        unint64_t v154 = v153;
        unsigned int v363 = v151;
        unint64_t v393 = v151;
        unint64_t v394 = v150;
        uint64_t v405 = v437[7];
LABEL_261:
        unint64_t v413 = v154;
        if (v399 <= 2)
        {
          unsigned int v156 = *(_DWORD *)(v34 + 36);
        }
        else
        {
          uint64_t v155 = v443;
          unsigned int v156 = *(_DWORD *)(v34 + 36);
          if (!((v376 ^ 1) & 1 | ((uint64_t)v443 < 1)) && v55 <= 2 * v156)
          {
            if (v437)
            {
              obj_release(v437);
              v437 = 0;
              uint64_t v155 = v443;
            }
            char v376 = 0;
            uint64_t v432 = *((void *)&v442 + 1);
            if (a6) {
              uint64_t v55 = v155;
            }
            unsigned __int8 v410 = BYTE8(v443) != 0;
            int v255 = v359;
            LOBYTE(v113) = v360;
            if (BYTE8(v443)) {
              int v255 = 1;
            }
            unint64_t v256 = v419;
            if (!v255) {
              unint64_t v256 = 0;
            }
            unint64_t v419 = v256;
            unint64_t v257 = v417;
            if (!v255) {
              unint64_t v257 = 0;
            }
            unint64_t v417 = v257;
            if ((v255 & 1) == 0 && (v418 & 0x200) == 0)
            {
              unint64_t v419 = 0;
              unint64_t v417 = 0;
              unsigned __int8 v410 = 0;
              char v376 = 0;
              *(unsigned char *)(v9 + 636) = 1;
              *(void *)(v9 + 1784) = 0;
            }
            continue;
          }
        }
        break;
      }
      uint64_t v157 = v127 + 32 * v154;
      unint64_t v158 = *(void *)(v157 + 48);
      v407 = (void *)(v157 + 48);
      unint64_t v159 = v150 + v154;
      if (v158 != (v150 + v154) * v156)
      {
        obj_type((uint64_t)a1);
        log_err((uint64_t)"%s:%d: %s skip bad chunk info ci @ block %lld (cib %lld) ci_index 0x%x ci_addr 0x%llx (expect 0x%llx)\n", v161, v162, v163, v164, v165, v166, v167, (uint64_t)"spaceman_alloc");
        unint64_t v154 = v413;
        unint64_t v168 = *(unsigned int *)(v34 + 36) + *(unsigned int *)(v34 + 36) * v159;
        size_t v152 = a6;
        unint64_t v150 = v394;
        goto LABEL_344;
      }
      if (v397 == *v389 && v432 / v156 - v150 == v154) {
        uint64_t v160 = v432 - v158;
      }
      else {
        uint64_t v160 = *(_DWORD *)(v127 + 32 * v154 + 56) & 0xFFFFFLL;
      }
      if (v408 && v415 > v158 && v415 < v160 + v158 && v415 - v158 < v160) {
        uint64_t v160 = v415 - v158;
      }
      if (v396)
      {
        unint64_t v169 = v419 - v158;
        BOOL v170 = v419 <= v158 || v419 >= v160 + v158;
        int v171 = v170;
        char v172 = v395;
        if (v170) {
          char v172 = 1;
        }
        int v173 = v171 ^ 1;
        if (v169 >= v160) {
          unint64_t v169 = v160;
        }
        if (v172)
        {
          int v174 = v173;
        }
        else
        {
          uint64_t v160 = v169;
          int v174 = 0;
        }
      }
      else
      {
        int v174 = 0;
      }
      uint64_t v175 = v48 - v158;
      if (v408 && v412 > v158 && v412 < v160 + v158)
      {
        if (v412 - v158 > v175) {
          uint64_t v175 = v412 - v158;
        }
        unint64_t v48 = v175 + v158;
        if (v175 > 0) {
          uint64_t v46 = 0;
        }
      }
      if (v396 && v417 > v158 && v417 < v160 + v158)
      {
        if (v395)
        {
          int v174 = 1;
          goto LABEL_305;
        }
        if (v417 - v158 > v175) {
          uint64_t v175 = v417 - v158;
        }
        unint64_t v48 = v175 + v158;
        if (v175 > 0) {
          uint64_t v46 = 0;
        }
        if (!v152)
        {
LABEL_391:
          uint64_t v207 = v405 + 32 * v154;
          uint64_t v208 = *(_DWORD *)(v207 + 60) & 0xFFFFF;
          if (!v46 || v208 < (*(_DWORD *)(v207 + 56) & 0xFFFFFu) && v55 - v46 > v208)
          {
            if (v208)
            {
              if (v154 >= v366
                || (uint64_t v209 = v405 + 32 * (v154 + 1),
                    unsigned int v210 = *(_DWORD *)(v209 + 60) & 0xFFFFF,
                    v55 <= v210 + v208))
              {
                uint64_t v46 = 0;
              }
              else
              {
                uint64_t v46 = 0;
                if (v210 < (*(_DWORD *)(v209 + 56) & 0xFFFFFu)) {
                  int v174 = 1;
                }
              }
            }
            else
            {
              uint64_t v46 = 0;
              int v174 = 2;
            }
          }
        }
      }
      else
      {
LABEL_305:
        if (!v152) {
          goto LABEL_391;
        }
      }
      if (v408 && v412 >= v160 + v158 && v415 <= v175 + v158) {
        int v174 = 2;
      }
      if (v174) {
        BOOL v177 = 0;
      }
      else {
        BOOL v177 = v396;
      }
      BOOL v179 = v419 <= v175 + v158 && v417 >= v160 + v158;
      if (v177) {
        unsigned int v180 = v179;
      }
      else {
        unsigned int v180 = v174;
      }
      if (v152)
      {
        uint64_t v181 = v405;
        if ((*(_DWORD *)(v405 + 32 * v154 + 60) & 0xFFFFF) == 0) {
          unsigned int v180 = 2;
        }
      }
      else
      {
        uint64_t v181 = v405;
      }
      uint64_t v182 = v181 + 32 * v154;
      uint64_t v184 = *(void *)(v182 + 64);
      uint64_t v183 = (uint64_t *)(v182 + 64);
      unint64_t v402 = v125;
      if (!v184 && ((*(_DWORD *)(v181 + 32 * v154 + 56) ^ *(_DWORD *)(v181 + 32 * v154 + 60)) & 0xFFFFF) != 0) {
        unsigned int v180 = 2;
      }
      unint64_t v185 = v48;
      if (((v180 == 0) & v410) == 1)
      {
        uint64_t v186 = v46;
        BOOL should_avoid_data_allocation_at_block = spaceman_should_avoid_data_allocation_at_block((uint64_t)v447, v70, v158, v55);
        uint64_t v46 = v186;
        unint64_t v48 = v185;
        unsigned int v180 = should_avoid_data_allocation_at_block;
        unint64_t v154 = v413;
        size_t v152 = a6;
      }
      if (v180 > v395)
      {
        unint64_t v168 = v48 + v160 - v175;
        BOOL v188 = v408;
        if (v168 < v415) {
          BOOL v188 = 0;
        }
        uint64_t v125 = v402;
        uint64_t v127 = v405;
        unint64_t v150 = v394;
        if (v188 && v168 < v412) {
          goto LABEL_343;
        }
        int v189 = v370;
        if (v168 < v419) {
          int v189 = 0;
        }
        if (v189 == 1 && v168 < v417) {
LABEL_343:
        }
          unint64_t v168 = *v407 + (*(_DWORD *)(v405 + 32 * v154 + 56) & 0xFFFFF);
LABEL_344:
        uint64_t v46 = 0;
        if (v168 >= *v392) {
          unint64_t v48 = 0;
        }
        else {
          unint64_t v48 = v168;
        }
        goto LABEL_347;
      }
      unint64_t v399 = (v399 + 1);
      uint64_t v190 = *v183;
      v436 = 0;
      if (v190)
      {
        uint64_t v191 = v46;
        uint64_t v192 = obj_get(*(void *)(v9 + 392), 0x40000000, v190, &sm_bm_desc, 0, 0, 0, 0, &v436);
        uint64_t v46 = v191;
        unint64_t v48 = v185;
        unint64_t v154 = v413;
        if (v192)
        {
          uint64_t v31 = v192;
LABEL_540:
          unint64_t v406 = v154;
          LOBYTE(v80) = v420;
          goto LABEL_543;
        }
      }
      if (!v46) {
        goto LABEL_435;
      }
      if (v175) {
        sub_10005DC24();
      }
      uint64_t v193 = v55 - v46;
      if (v55 - v46 >= v160) {
        uint64_t v193 = v160;
      }
      if (v180) {
        uint64_t v194 = v160;
      }
      else {
        uint64_t v194 = v193;
      }
      if (v436)
      {
        uint64_t v195 = v46;
        int first = bitmap_range_find_first(1, v436[7], 0, v194, &v440);
        uint64_t v46 = v195;
        unint64_t v48 = v185;
        if (first)
        {
          uint64_t v197 = v440;
          if (!a6) {
            goto LABEL_434;
          }
          uint64_t v47 = v440 + v195;
          if (v440 + v195 <= (uint64_t)v402) {
            goto LABEL_434;
          }
          if (v180)
          {
            int64_t v198 = v185 - v195;
            uint64_t v199 = v46;
            if (spaceman_clip_extent_to_zones(v9, (uint64_t)v447, v70, v185 - v46, v47, v418, v364, &v430, &v428))
            {
              unint64_t v200 = v428;
              if (v428 >= v55) {
                unint64_t v200 = v55;
              }
              unint64_t v428 = v200;
              unint64_t v201 = v402;
              unint64_t v202 = v374;
              if (v200 > v402) {
                unint64_t v202 = v430;
              }
              int64_t v374 = v202;
              if (v200 > v402) {
                unint64_t v201 = v200;
              }
              LOBYTE(v80) = v420;
              unint64_t v48 = v185;
              uint64_t v46 = v199;
LABEL_431:
              unint64_t v402 = v201;
              if (v201 && (v418 & 0x400) != 0)
              {
                if (v436)
                {
                  obj_release(v436);
                  unint64_t v48 = v185;
                  LOBYTE(v80) = v420;
                }
                uint64_t v46 = 0;
                uint64_t v31 = 0;
                v436 = 0;
                unint64_t v406 = v413;
                goto LABEL_543;
              }
              uint64_t v197 = v440;
LABEL_434:
              spaceman_free_extent_cache_insert(v447[v70 + 196], v385, v48 - v46, v197 + v46, v47, v48, v49, v50);
              uint64_t v175 = v440;
              unint64_t v48 = v185 + v440;
              unint64_t v154 = v413;
LABEL_435:
              uint64_t v379 = v48;
              if (v436)
              {
                if (v447[v70 + 196])
                {
                  if (v160 <= v175)
                  {
                    uint64_t v369 = 0;
                    uint64_t v217 = 0;
                  }
                  else
                  {
                    uint64_t v217 = 0;
                    uint64_t v369 = 0;
                    unint64_t v378 = v48 - v175;
                    uint64_t v218 = v175;
                    do
                    {
                      bitmap_range_find_first_clear_range(v436[7], v160 - v218, v218, v160, &v440, &v439);
                      if (!v439) {
                        break;
                      }
                      if (v439 > v217)
                      {
                        BOOL v220 = v217 < v55;
                        if ((v418 & 0x400) != 0) {
                          BOOL v220 = v217 == 0;
                        }
                        if (v220)
                        {
                          uint64_t v369 = v440;
                          if (v55 >= v439) {
                            uint64_t v217 = v439;
                          }
                          else {
                            uint64_t v217 = v55;
                          }
                        }
                      }
                      if (v180) {
                        BOOL v221 = 1;
                      }
                      else {
                        BOOL v221 = v217 < v55;
                      }
                      char v222 = v377;
                      if (v221) {
                        char v222 = 0;
                      }
                      if (v222) {
                        break;
                      }
                      spaceman_free_extent_cache_insert(v447[v70 + 196], v385, v378 + v440, v439, v47, v219, v49, v50);
                      uint64_t v218 = v439 + v440;
                    }
                    while (v439 + v440 < v160);
                  }
                  uint64_t v225 = 0;
                  uint64_t v439 = v217;
                  uint64_t v440 = v369;
                  if (!v180)
                  {
                    unsigned int v226 = a6;
                    LOBYTE(v80) = v420;
                    unint64_t v227 = v413;
                    if (v217 >= v55)
                    {
                      uint64_t v46 = 0;
                      uint64_t v31 = 0;
                      unint64_t v48 = v160 - v175 + v379;
                      goto LABEL_542;
                    }
                    goto LABEL_469;
                  }
                }
                else
                {
                  if (bitmap_range_find_desired_or_first_clear_range(v436[7], v55, v175, v160, &v440, &v439, v382 != 0))
                  {
                    uint64_t v46 = 0;
                    uint64_t v31 = 0;
                    unint64_t v406 = v413;
                    LOBYTE(v80) = v420;
                    uint64_t v127 = v405;
                    unint64_t v48 = v379;
                    goto LABEL_544;
                  }
                  uint64_t v225 = 0;
                }
                unsigned int v226 = a6;
                LOBYTE(v80) = v420;
                unint64_t v227 = v413;
                goto LABEL_469;
              }
              uint64_t v223 = v160 - v175;
              if (v55 >= v160 - v175) {
                uint64_t v224 = v160 - v175;
              }
              else {
                uint64_t v224 = v55;
              }
              uint64_t v439 = v224;
              uint64_t v440 = v175;
              if (v55 <= v160 - v175)
              {
                if (!v180)
                {
                  uint64_t v46 = 0;
                  uint64_t v31 = 0;
                  goto LABEL_540;
                }
              }
              else
              {
                uint64_t v223 = 0;
              }
              uint64_t v228 = v223;
              spaceman_free_extent_cache_insert(v447[v70 + 196], v385, v48, v224, v47, v48, v49, v50);
              uint64_t v225 = v228;
              unint64_t v227 = v413;
              unsigned int v226 = a6;
              LOBYTE(v80) = v420;
LABEL_469:
              uint64_t v229 = v439;
              if (v226)
              {
                uint64_t v230 = v379;
                if (v439 > (uint64_t)v402)
                {
                  uint64_t v231 = v440;
                  if (v180)
                  {
                    uint64_t v232 = v225;
                    uint64_t v233 = v379 - v175;
                    if (spaceman_clip_extent_to_zones(v9, (uint64_t)v447, v70, v379 - v175 + v440, v439, v418, v364, &v430, &v428))
                    {
                      unint64_t v80 = v402;
                      unint64_t v234 = v374;
                      if (v428 > v402) {
                        unint64_t v234 = v430;
                      }
                      int64_t v374 = v234;
                      if (v428 > v402) {
                        unint64_t v80 = v428;
                      }
                      unint64_t v402 = v80;
                      uint64_t v229 = v439;
                      LOBYTE(v80) = v420;
                      unint64_t v227 = v413;
                      uint64_t v230 = v379;
                      uint64_t v225 = v232;
                      goto LABEL_482;
                    }
                    uint64_t v229 = v439;
                    uint64_t v231 = v440;
                    LOBYTE(v80) = v420;
                    unint64_t v227 = v413;
                    uint64_t v230 = v379;
                    uint64_t v225 = v232;
                  }
                  else
                  {
                    uint64_t v233 = v379 - v175;
                  }
                  int64_t v374 = v233 + v231;
                  unint64_t v402 = v229;
                }
              }
              else
              {
                uint64_t v230 = v379;
              }
LABEL_482:
              if (!v229 || v440 + v229 != v160)
              {
                if (!v436 && v160) {
                  sub_10005DBCC();
                }
                if ((v418 & 0x400) != 0 && v402)
                {
                  uint64_t v46 = 0;
                  uint64_t v31 = 0;
                  unint64_t v48 = v160 - v175 + v230;
LABEL_542:
                  unint64_t v406 = v227;
LABEL_543:
                  uint64_t v127 = v405;
LABEL_544:
                  uint64_t v125 = v402;
                  goto LABEL_527;
                }
                uint64_t v229 = v225;
                if (!v225)
                {
                  uint64_t v235 = v160 - v55;
                  if (v160 >= v55)
                  {
                    uint64_t v236 = v55;
                  }
                  else
                  {
                    uint64_t v235 = 0;
                    uint64_t v236 = v160;
                  }
                  int last_set = bitmap_range_find_last_set(v436[7], v235, v236, &v440);
                  uint64_t v230 = v379;
                  if (last_set && v440 < v160 - 1)
                  {
                    uint64_t v229 = v160 + ~v440;
                    spaceman_free_extent_cache_insert(v447[v70 + 196], v385, v379 - v175 + v440 + 1, v229, v47, v379, v49, v50);
                    uint64_t v230 = v379;
                  }
                  else
                  {
                    uint64_t v229 = 0;
                  }
                  unint64_t v227 = v413;
                }
              }
              uint64_t v439 = 0;
              unint64_t v238 = v230 + v160 - v175;
              BOOL v239 = v408;
              if (v238 < v415) {
                BOOL v239 = 0;
              }
              uint64_t v125 = v402;
              uint64_t v127 = v405;
              unint64_t v150 = v394;
              if (v239 && v238 < v412) {
                goto LABEL_505;
              }
              int v240 = v370;
              if (v238 < v419) {
                int v240 = 0;
              }
              if (v240 == 1 && v238 < v417)
              {
LABEL_505:
                uint64_t v229 = 0;
                unint64_t v238 = *v407 + (*(_DWORD *)(v405 + 32 * v227 + 56) & 0xFFFFF);
              }
              if (v238 >= *v392) {
                uint64_t v46 = 0;
              }
              else {
                uint64_t v46 = v229;
              }
              if (v238 >= *v392) {
                unint64_t v48 = 0;
              }
              else {
                unint64_t v48 = v238;
              }
              if (v436)
              {
                unint64_t v241 = v48;
                uint64_t v242 = v46;
                obj_release(v436);
                uint64_t v46 = v242;
                uint64_t v125 = v402;
                uint64_t v127 = v405;
                unint64_t v48 = v241;
              }
              v436 = 0;
              if (v399) {
                BOOL v243 = v46 == 0;
              }
              else {
                BOOL v243 = 0;
              }
              unsigned int v244 = v395;
              if (!v243) {
                unsigned int v244 = 0;
              }
              if (v244 == 1)
              {
                if (v125 | v429)
                {
                  unint64_t v245 = v48;
                  int should_pause = spaceman_free_extent_cache_scan_should_pause(v447[v70 + 196], v399);
                  uint64_t v46 = 0;
                  if (should_pause)
                  {
                    uint64_t v31 = 0;
                    unint64_t v253 = v402;
                    int64_t v254 = v374;
                    if (v429 > v402) {
                      int64_t v254 = v431;
                    }
                    int64_t v374 = v254;
                    if (v429 > v402) {
                      unint64_t v253 = v429;
                    }
                    int v380 = 1;
                    unint64_t v406 = v413;
                    LOBYTE(v80) = v420;
                    unint64_t v48 = v245;
                    uint64_t v125 = v253;
                    goto LABEL_527;
                  }
                  size_t v152 = a6;
                  unint64_t v154 = v413;
                  unint64_t v48 = v245;
                  uint64_t v125 = v402;
                  goto LABEL_347;
                }
                uint64_t v46 = 0;
                uint64_t v125 = 0;
              }
              size_t v152 = a6;
              unint64_t v154 = v413;
LABEL_347:
              if (++v154 >= v393)
              {
                uint64_t v31 = 0;
                unint64_t v406 = v363;
                goto LABEL_526;
              }
              goto LABEL_261;
            }
            uint64_t v47 = v440 + v199;
            int64_t v374 = v198;
            LOBYTE(v80) = v420;
            unint64_t v48 = v185;
            uint64_t v46 = v199;
          }
          else
          {
            int64_t v374 = v185 - v195;
            LOBYTE(v80) = v420;
          }
          if (v47 >= v55) {
            unint64_t v201 = v55;
          }
          else {
            unint64_t v201 = v47;
          }
          goto LABEL_431;
        }
      }
      uint64_t v203 = v194 + v46;
      if (v180 || v55 != v203)
      {
        if (v194 != v160) {
          sub_10005DBF8();
        }
        unint64_t v204 = v48 - v46;
        spaceman_free_extent_cache_insert(v447[v70 + 196], v385, v48 - v46, v203, v47, v48, v49, v50);
        if (a6 && v203 > (uint64_t)v402)
        {
          if (v180
            && spaceman_clip_extent_to_zones(v9, (uint64_t)v447, v70, v204, v203, v418, v364, &v430, &v428))
          {
            unint64_t v205 = v428;
            if (v428 >= v55) {
              unint64_t v205 = v55;
            }
            unint64_t v428 = v205;
            unint64_t v206 = v402;
            if (v205 <= v402) {
              unint64_t v204 = v374;
            }
            else {
              unint64_t v204 = v430;
            }
            if (v205 > v402) {
              unint64_t v206 = v205;
            }
            unint64_t v402 = v206;
          }
          else
          {
            if (v203 >= v55) {
              unint64_t v211 = v55;
            }
            else {
              unint64_t v211 = v203;
            }
            unint64_t v402 = v211;
          }
        }
        else
        {
          unint64_t v204 = v374;
        }
        unint64_t v212 = v160 + v185;
        BOOL v213 = v408;
        if (v212 < v415) {
          BOOL v213 = 0;
        }
        if (v213 && v212 < v412) {
          goto LABEL_414;
        }
        int v214 = v370;
        if (v212 < v419) {
          int v214 = 0;
        }
        if (v214 == 1 && v212 < v417)
        {
LABEL_414:
          uint64_t v203 = 0;
          unint64_t v212 = *v407 + (*(_DWORD *)(v405 + 32 * v413 + 56) & 0xFFFFF);
        }
        unint64_t v215 = *v392;
        if (v212 < *v392) {
          unint64_t v48 = v212;
        }
        else {
          unint64_t v48 = 0;
        }
        if (v436)
        {
          unint64_t v216 = v48;
          obj_release(v436);
          unint64_t v48 = v216;
        }
        v436 = 0;
        if (v212 < v215 && v203)
        {
          uint64_t v46 = v203;
          int64_t v374 = v204;
          size_t v152 = a6;
          uint64_t v125 = v402;
          uint64_t v127 = v405;
          unint64_t v154 = v413;
          unint64_t v150 = v394;
        }
        else
        {
          uint64_t v46 = 0;
          size_t v152 = a6;
          uint64_t v125 = v402;
          uint64_t v127 = v405;
          unint64_t v154 = v413;
          unint64_t v150 = v394;
          if ((v418 & 0x400) != 0 && v402)
          {
            uint64_t v46 = 0;
            uint64_t v31 = 0;
            unint64_t v406 = v413;
            int64_t v374 = v204;
            goto LABEL_526;
          }
          int64_t v374 = v204;
        }
        goto LABEL_347;
      }
      if (v436)
      {
        uint64_t v258 = v46;
        obj_release(v436);
        uint64_t v46 = v258;
        unint64_t v48 = v185;
      }
      uint64_t v31 = 0;
      int64_t v374 = v48 - v46;
      v436 = 0;
      uint64_t v125 = v55;
      unint64_t v406 = v413;
      LOBYTE(v80) = v420;
      uint64_t v127 = v405;
LABEL_573:
      if (v397 <= *v389)
      {
        if (v362)
        {
          if (v395)
          {
            if (v31) {
              BOOL v260 = 0;
            }
            else {
              BOOL v260 = v48 > v432;
            }
            if (v260)
            {
              unint64_t v261 = v439 || !v125 ? *(void *)(v127 + 32 * v406 + 48) + v439 + v440 : v125 + v374;
              if (v48 <= v261) {
                unint64_t v48 = v261;
              }
            }
          }
          else
          {
            unint64_t v48 = 0;
          }
          uint64_t v262 = v447[v70 + 196];
          unint64_t v259 = v48;
          char v263 = 0;
LABEL_594:
          spaceman_free_extent_cache_bitmap_scan_finished(v262, v259, v263);
          BOOL v381 = 0;
          LOBYTE(v80) = v420;
        }
      }
      else if (v362)
      {
        if (v395) {
          unint64_t v259 = *(void *)(v447[47] + 48 * v70 + 48);
        }
        else {
          unint64_t v259 = 0;
        }
        uint64_t v262 = v447[v70 + 196];
        char v263 = 1;
        goto LABEL_594;
      }
LABEL_595:
      uint64_t v264 = v439;
      uint64_t v403 = v127;
      if (!v439 && v125)
      {
        unint64_t v275 = v374;
        uint64_t v276 = v374 % *(unsigned int *)(v34 + 36);
        uint64_t v439 = v125;
        uint64_t v440 = v276;
        unsigned int v277 = v406;
        if (v31) {
          goto LABEL_656;
        }
        uint64_t v264 = v125;
        if (!v374) {
          goto LABEL_629;
        }
        goto LABEL_630;
      }
      if (!v439 && !v31)
      {
        if (v397 != *(_DWORD *)(v34 + 48 * v70 + 64) + 1)
        {
          uint64_t v264 = 0;
          unsigned int v277 = v406;
          goto LABEL_629;
        }
        if ((v80 & 4) == 0)
        {
          pthread_mutex_unlock((pthread_mutex_t *)v447 + 6);
          pthread_mutex_lock((pthread_mutex_t *)v447 + 8);
          sub_10000E874(v9, (uint64_t)v433, 0, 0);
          uint64_t v265 = sub_10000E968((pthread_mutex_t **)v9, (uint64_t)v447, v422, 1, (uint64_t)v433, a4);
          sub_10000F1E4(v9, (uint64_t)v433);
          pthread_mutex_unlock((pthread_mutex_t *)v447 + 8);
          pthread_mutex_lock((pthread_mutex_t *)v447 + 6);
          int v266 = v409;
          if (v265) {
            int v266 = v391;
          }
          int v409 = v266;
        }
        if (v438)
        {
          obj_release(v438);
          v438 = 0;
        }
        int v56 = v409;
        unint64_t v51 = v406;
        if (v447[v70 + 196] != 0 && v381) {
          sub_10005DBA0();
        }
        continue;
      }
      break;
    }
    unsigned int v277 = v406;
    if (v31) {
      goto LABEL_656;
    }
LABEL_629:
    unint64_t v275 = v440 + *(void *)(v127 + 32 * v277 + 48);
    uint64_t v125 = v264;
LABEL_630:
    unint64_t v375 = v275;
    if (v70 == 1) {
      v275 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36)));
    }
    if (spaceman_extent_check(v9, (uint64_t)v447, v275, v125))
    {
      if (nx_ratelimit_log_allowed(*(void *)(*a1 + 392)))
      {
        obj_type((uint64_t)a1);
        log_err((uint64_t)"%s:%d: %s found free extent (0x%llx:0x%llx) which should not be free!: %d\n", v336, v337, v338, v339, v340, v341, v342, (uint64_t)"spaceman_alloc");
      }
      uint64_t v279 = nx_corruption_detected_int(v9);
LABEL_727:
      uint64_t v31 = v279;
      goto LABEL_656;
    }
    unint64_t v278 = *(void *)(v34 + 48 * v70 + 48);
    if ((v420 & 4) != 0 || v439 < 1) {
      break;
    }
    if (*(unsigned char *)(v9 + 627))
    {
      uint64_t v31 = 30;
      goto LABEL_656;
    }
    if (v438)
    {
      obj_release(v438);
      v438 = 0;
    }
    if (v437)
    {
      obj_release(v437);
      v437 = 0;
    }
    if (v436)
    {
      obj_release(v436);
      v436 = 0;
    }
    uint64_t v279 = obj_modify(v447, 0, a4);
    if (v279) {
      goto LABEL_727;
    }
    unint64_t v280 = v375;
    if (v70 == 1) {
      unint64_t v280 = (0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36)))) | v375;
    }
    uint64_t v31 = sub_100015218(v9, v10, (uint64_t)v447, v280, v125, a4, 0, v418);
    spaceman_free_extent_cache_remove(v447[v70 + 196], v375, v125, v281, v282, v283, v284, v285);
    if (v31)
    {
      obj_type((uint64_t)a1);
      log_err((uint64_t)"%s:%d: %s Failed to set bits for allocation %lld:%lld: %d\n", v286, v287, v288, v289, v290, v291, v292, (uint64_t)"spaceman_alloc");
      int v52 = v391;
      if (!v395) {
        goto LABEL_656;
      }
      spaceman_free_extent_cache_reset(v447[v70 + 196]);
      char v53 = 1;
      unint64_t v51 = v406;
      if (v371) {
        goto LABEL_656;
      }
      continue;
    }
    break;
  }
  if (v375 + v125 >= v278) {
    unint64_t v326 = 0;
  }
  else {
    unint64_t v326 = v375 + v125;
  }
  if (v70 == 1) {
    v375 |= 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36)));
  }
  unint64_t *v384 = v375;
  if (a6) {
    *a6 = v125;
  }
  v327 = v447;
  v328 = (void *)v447[198];
  if (v328)
  {
    v328[10] += v125;
    if (v125 < (uint64_t)v421) {
      ++v328[11];
    }
  }
  if (v357)
  {
    if ((v387 & 1) == 0) {
      sub_10005DB74();
    }
    if (v328) {
      ++v328[3];
    }
    if ((*(_DWORD *)(v327[v70 + 186]
                    + 4
                    * (v327[17 * v70 + 152 + 4 * v388]
                     / (unint64_t)*(unsigned int *)(v34 + 36))) & 0xFFFFFFu) > v388)
      goto LABEL_728;
    int new_chunk_for_allocation_zone = spaceman_get_new_chunk_for_allocation_zone(v9, (uint64_t)v327, v70, v388);
    uint64_t v31 = 0;
    if (new_chunk_for_allocation_zone && new_chunk_for_allocation_zone != 28)
    {
      obj_type((uint64_t)a1);
      log_err((uint64_t)"%s:%d: %s failed to update chunk for alloc zone %d: %d\n", v343, v344, v345, v346, v347, v348, v349, (uint64_t)"spaceman_alloc");
      goto LABEL_728;
    }
  }
  else
  {
    if ((v418 & 0x200) == 0)
    {
      if ((v418 & 0x142) != 0
        && v70 == (((v383 << __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36)))) & 0x4000000000000000) != 0))
      {
        if (v386) {
          spaceman_update_metazone_alloc_index((uint64_t)v327, v70, v390, v326);
        }
      }
      else
      {
        v327[v70 + 124] = v326;
        if ((v410 & 1) != 0 && spaceman_should_avoid_data_allocation_at_block((uint64_t)v327, v70, v326, 5))
        {
          *(void *)&long long v444 = v326;
          *((void *)&v444 + 1) = 1;
          LOBYTE(v445) = 1;
          BYTE8(v446) = 1;
          *((void *)&v445 + 1) = 0;
          *(void *)&long long v446 = 0;
          sub_100014DFC((unint64_t)v447, v70, (uint64_t)&v444, &v441);
          if (v335)
          {
            if (v335 != 28)
            {
              obj_type((uint64_t)a1);
              log_err((uint64_t)"%s:%d: %s failed to move roving pointer for dev %d error %d\n", v350, v351, v352, v353, v354, v355, v356, (uint64_t)"spaceman_alloc");
            }
          }
          else if (*((uint64_t *)&v441 + 1) >= 1)
          {
            uint64_t v31 = 0;
            v447[v70 + 124] = v441;
            goto LABEL_656;
          }
        }
      }
LABEL_728:
      uint64_t v31 = 0;
      goto LABEL_656;
    }
    unint64_t v330 = *(void *)(v9 + 1752);
    char v331 = __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36)));
    unint64_t v332 = 0x4000000000000000uLL >> v331;
    if (v70 == (((0x4000000000000000uLL >> v331) & v330) != 0)
      && (uint64_t v333 = (uint64_t)0xBFFFFFFFFFFFFFFFLL >> v331, v326 >= (v333 & v330))
      && v326 < ((*(void *)(v9 + 1760) + v330) & v333))
    {
      uint64_t v31 = 0;
      if (v70 == 1) {
        unint64_t v334 = v332;
      }
      else {
        unint64_t v334 = 0;
      }
      unint64_t v330 = v334 | v326;
    }
    else
    {
      uint64_t v31 = 0;
    }
    *(void *)(v9 + 1768) = v330;
  }
LABEL_656:
  if (v438) {
    obj_release(v438);
  }
  if (v437) {
    obj_release(v437);
  }
  if (v436) {
    obj_release(v436);
  }
  pthread_mutex_unlock((pthread_mutex_t *)v447 + 6);
  uint64_t v33 = v447;
  if (!v31)
  {
    obj_release(v447);
    if ((v418 & 4) == 0)
    {
      uint64_t v31 = 0;
      uint64_t v295 = *(void *)(v9 + 1760);
      if (!v295 || (v418 & 0x200) != 0) {
        return v31;
      }
      int64_t v296 = *(void *)(v9 + 1752);
      if ((uint64_t)*v384 < v296 || *v384 >= v296 + v295)
      {
        if (*(unsigned char *)(v9 + 636))
        {
          if (a6) {
            uint64_t v55 = *a6;
          }
          unint64_t v297 = *(void *)(v9 + 1784) + v55;
          *(void *)(v9 + 1784) = v297;
          if (v297 >= 0x401)
          {
            obj_type((uint64_t)a1);
            log_debug((uint64_t)"%s:%d: %s Found enough data to allocate outside the soft block-out range, re-enable soft block-out range\n", v298, v299, v300, v301, v302, v303, v304, (uint64_t)"spaceman_alloc");
            uint64_t v31 = 0;
            *(unsigned char *)(v9 + 636) = 0;
            return v31;
          }
        }
        else if (a6 && 10000 * *a6 < v55 && *a6 * *(unsigned int *)(*(void *)(v9 + 376) + 36) < 0x40000)
        {
          obj_type((uint64_t)a1);
          log_debug((uint64_t)"%s:%d: %s Space outside soft block-out range seems fragmented (requested %llu, but could alloc only %llu), disable soft block-out range\n", v305, v306, v307, v308, v309, v310, v311, (uint64_t)"spaceman_alloc");
          uint64_t v31 = 0;
          *(unsigned char *)(v9 + 636) = 1;
          *(void *)(v9 + 1784) = 0;
          return v31;
        }
      }
    }
    return 0;
  }
LABEL_663:
  uint64_t v293 = v33[198];
  if (v293) {
    ++*(void *)(v293 + 72);
  }
  obj_release(v33);
  return v31;
}

uint64_t sub_100014D84(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t result = *(unsigned int *)(a1 + 44);
  if (!result)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (!v5)
    {
      *(void *)(a1 + 32) = a2;
      uint64_t v5 = a2;
    }
    if (*(void *)(a1 + 24) <= a3)
    {
      uint64_t result = 37;
    }
    else
    {
      uint64_t v6 = *(unsigned int *)(*(void *)(*(void *)(*(void *)a1 + 8) + 376) + 36);
      uint64_t result = spaceman_free_extent_cache_scan_should_pause(*(void *)a1, (a2 - v5 / v6 * v6) / v6);
      if (!result) {
        return result;
      }
      uint64_t result = 34;
    }
    *(_DWORD *)(a1 + 44) = result;
  }
  return result;
}

double sub_100014DFC(unint64_t a1, unsigned int a2, uint64_t a3, _OWORD *a4)
{
  char v6 = 0;
  long long v7 = *(_OWORD *)(a3 + 16);
  long long v8 = *(_OWORD *)(a3 + 32);
  v62[0] = *(_OWORD *)a3;
  v62[1] = v7;
  uint64_t v9 = *(void *)(a1 + 376);
  int v58 = *(unsigned __int8 *)(a3 + 16);
  int v52 = *(unsigned __int8 *)(a3 + 40);
  unint64_t v10 = *(void *)a3 / (uint64_t)*(unsigned int *)(v9 + 36);
  unint64_t v11 = v10;
  v62[2] = v8;
  uint64_t v13 = (void *)(a1 + 8 * a2 + 1488);
  uint64_t v14 = *v13 + 4 * v10;
  uint64_t v56 = *(void *)(a3 + 8);
  *(void *)&long long v15 = 0;
  a4[1] = 0u;
  a4[2] = 0u;
  *a4 = 0u;
  uint64_t v57 = v9;
  BOOL v16 = (void *)(v9 + 48 * a2 + 56);
  uint64_t v53 = v14;
  do
  {
    if (!v58)
    {
      int v29 = 1;
      uint64_t v30 = v56;
      uint64_t v14 = v53;
      unint64_t v31 = v10;
      goto LABEL_24;
    }
    uint64_t v17 = *(void *)(a1 + 376);
    if ((*(unsigned char *)(v14 + 3) & 0xC) == 0)
    {
      uint64_t v18 = v17 + 48 * a2;
      unint64_t v19 = *(void *)(v18 + 56);
      if (v19 <= v11) {
        goto LABEL_19;
      }
      uint64_t v20 = *(void *)(a3 + 32);
      if (!v20) {
        goto LABEL_19;
      }
      unint64_t v21 = *(unsigned int *)(v17 + 36);
      uint64_t v22 = v21;
      if (v19 - 1 == v11) {
        uint64_t v22 = *(void *)(v18 + 48) % v21;
      }
      if (!calc_overlap_range(v11 * v21, v22, *(void *)(a3 + 24), v20, 0))
      {
LABEL_19:
        if (v11 == v10)
        {
          int v29 = 1;
        }
        else
        {
          int v29 = 0;
          *(void *)&v62[0] = v11 * *(unsigned int *)(v57 + 36);
        }
        unint64_t v31 = v11;
        uint64_t v30 = v56;
        goto LABEL_24;
      }
      uint64_t v17 = *(void *)(a1 + 376);
    }
    uint64_t v23 = v17 + 48 * a2;
    unint64_t v24 = *(void *)(v23 + 56);
    if (v24 > v11 && (uint64_t v25 = *(void *)(a3 + 32)) != 0)
    {
      unint64_t v26 = *(unsigned int *)(v17 + 36);
      uint64_t v27 = v26;
      if (v24 - 1 == v11) {
        uint64_t v27 = *(void *)(v23 + 48) % v26;
      }
      BOOL v28 = calc_overlap_range(v11 * v26, v27, *(void *)(a3 + 24), v25, 0) != 0;
    }
    else
    {
      BOOL v28 = 0;
    }
    v6 |= v28;
    unint64_t v11 = (v11 + 1) % *v16;
    uint64_t v14 = *v13 + 4 * v11;
  }
  while (v11 != v10);
  if ((v6 & 1) == 0) {
    return *(double *)&v15;
  }
  int v29 = 1;
  uint64_t v30 = v56;
  unint64_t v31 = v10;
LABEL_24:
  if (v30 < 2) {
    goto LABEL_55;
  }
  LODWORD(v32) = *(_DWORD *)v14 & 0xFFFFFF;
  if (v30 <= (unint64_t)v32) {
    goto LABEL_55;
  }
  if ((*(_DWORD *)v14 & 0x2000000) != 0 && v31 < *v16 - 1)
  {
    int v33 = *(_DWORD *)(*v13 + 4 * v31 + 4);
    if ((v33 & 0x1000000) != 0 && (!v58 || (v33 & 0xC000000) == 0))
    {
      unsigned int v42 = v33 & 0xFFFFFF;
      int v37 = v52;
      if (v52)
      {
        uint64_t v36 = (uint64_t)a4;
        uint64_t v34 = v57;
        if (v30 <= (unint64_t)(v42 + v32)) {
          goto LABEL_56;
        }
        unsigned int v35 = *(_DWORD *)(v57 + 36);
        goto LABEL_32;
      }
      if (v32 <= v42) {
        unint64_t v32 = v42;
      }
      else {
        unint64_t v32 = v32;
      }
      if (v30 >= v32) {
        uint64_t v30 = v32;
      }
LABEL_55:
      uint64_t v36 = (uint64_t)a4;
      uint64_t v34 = v57;
      goto LABEL_56;
    }
  }
  uint64_t v34 = v57;
  unsigned int v35 = *(_DWORD *)(v57 + 36);
  uint64_t v36 = (uint64_t)a4;
  int v37 = v52;
  if (!v52)
  {
LABEL_36:
    *(void *)&v62[0] = v31 * v35;
    sub_100018598(a1, a2, 0, (uint64_t)v62, v36);
    uint64_t v39 = *(void *)(v36 + 8);
    if (v37) {
      BOOL v40 = v39 < v30;
    }
    else {
      BOOL v40 = 0;
    }
    int v41 = v40;
    if (!v39 || v41)
    {
      long long v15 = *(_OWORD *)(v36 + 24);
      *(_OWORD *)uint64_t v36 = v15;
      *(void *)(v36 + 16) = *(void *)(v36 + 40);
      *(void *)(v36 + 24) = 0;
      *(void *)(v36 + 32) = 0;
      *(void *)(v36 + 40) = 0;
    }
    return *(double *)&v15;
  }
LABEL_32:
  if (v35 >= 0xFFFFFF) {
    unint64_t v38 = 0xFFFFFFLL;
  }
  else {
    unint64_t v38 = v35;
  }
  if (v30 <= v38) {
    goto LABEL_36;
  }
LABEL_56:
  uint64_t v43 = *(void *)&v62[0];
  *(void *)uint64_t v36 = *(void *)&v62[0];
  *(void *)(v36 + 8) = v30;
  *(unsigned char *)(v36 + 16) = v58;
  if (v29)
  {
    uint64_t v44 = *(void *)(a1 + 376);
    uint64_t v45 = v44 + 48 * a2;
    unint64_t v46 = *(void *)(v45 + 56);
    if (v46 > v10)
    {
      uint64_t v47 = *(void *)(a3 + 32);
      if (v47)
      {
        unint64_t v48 = *(unsigned int *)(v44 + 36);
        unint64_t v49 = v10 * v48;
        if (v46 - 1 == v10) {
          unint64_t v48 = *(void *)(v45 + 48) % v48;
        }
        if (calc_overlap_range(v49, v48, *(void *)(a3 + 24), v47, 0)) {
          *(unsigned char *)(v36 + 16) = 0;
        }
      }
    }
  }
  if (v43 % *(unsigned int *)(v34 + 36))
  {
    long long v60 = 0u;
    long long v61 = 0u;
    long long v59 = 0u;
    sub_100018598(a1, a2, 3uLL, (uint64_t)v62, (uint64_t)&v59);
    uint64_t v50 = (_OWORD *)(v36 + 24);
    if (*((uint64_t *)&v59 + 1) >= v30)
    {
      *(void *)&long long v15 = v59;
      *uint64_t v50 = v59;
      *(void *)(v36 + 40) = v60;
    }
    else
    {
      long long v15 = *(_OWORD *)v36;
      *uint64_t v50 = *(_OWORD *)v36;
      *(void *)(v36 + 40) = *(void *)(v36 + 16);
      *(void *)(v36 + 24) = v43 / *(unsigned int *)(v34 + 36) * *(unsigned int *)(v34 + 36);
    }
  }
  return *(double *)&v15;
}

uint64_t sub_100015218(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, char a8)
{
  uint64_t v9 = a4;
  uint64_t v202 = 0;
  unint64_t v205 = 0;
  int v10 = 0;
  unint64_t v11 = *(unsigned int **)(a3 + 376);
  uint64_t v229 = 0;
  uint64_t v230 = 0;
  unint64_t v227 = 0;
  uint64_t v228 = 0;
  char v12 = __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36)));
  uint64_t v225 = 0;
  unsigned int v226 = 0;
  uint64_t v13 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v12) & a4;
  uint64_t v14 = ((unint64_t)(a4 << v12) >> 62) & 1;
  long long v15 = (pthread_mutex_t *)(a3 + (v14 << 6) + 640);
  BOOL v16 = &v11[12 * v14 + 17];
  uint64_t v199 = (uint64_t *)(a3 + 8 * v14 + 888);
  unsigned int v210 = (pthread_mutex_t *)(a3 + 576);
  if (a2) {
    uint64_t v17 = a2;
  }
  else {
    uint64_t v17 = a1;
  }
  uint64_t v198 = v17;
  unsigned int v204 = -1;
  unint64_t v201 = (pthread_mutex_t *)(a3 + (v14 << 6) + 640);
  uint64_t v209 = v11;
  uint64_t v203 = v14;
  uint64_t v197 = (uint64_t)&v11[12 * v14 + 17];
  while (1)
  {
    uint64_t v216 = a5;
    pthread_mutex_lock(v15);
    unint64_t v18 = v13 / v11[9];
    unint64_t v19 = v18 / v11[10];
    unsigned int v222 = *v16;
    if (!*v16)
    {
      uint64_t v31 = *v199;
      unsigned int v226 = v11;
      unint64_t v227 = __PAIR64__(v19, v14);
      if (!v31)
      {
        char v187 = 0;
        uint64_t v188 = 22;
        uint64_t v189 = a3;
        long long v15 = v201;
        goto LABEL_143;
      }
      goto LABEL_22;
    }
    unsigned int v20 = v19 / v11[11];
    if (v20 != v204 || v202 == 0) {
      break;
    }
    obj_lock((uint64_t)v230, 2u);
LABEL_17:
    pthread_mutex_unlock(v15);
    if (obj_xid((uint64_t)v230) == a6)
    {
      uint64_t v32 = v205;
      unsigned int v33 = v204;
    }
    else
    {
      uint64_t v34 = sub_10000DB28(a1, a3, a6, (unint64_t *)&v225);
      if (v34)
      {
        uint64_t v188 = v34;
        a5 = v216;
        if (nx_ratelimit_log_allowed(a1)) {
          log_err((uint64_t)"%s:%d: %s failed to allocate block from internal pool: %d\n", v190, v191, v192, v193, v194, v195, v196, (uint64_t)"spaceman_modify_bits");
        }
        char v187 = 0;
        LOBYTE(v10) = 1;
        uint64_t v189 = a3;
        goto LABEL_118;
      }
      uint64_t v32 = v225;
      unsigned int v33 = v204;
      *(void *)(*v199 + 8 * v204) = v225;
      obj_dirty((uint64_t)v230, a6, v32);
      uint64_t v35 = sub_100018810(a1, (pthread_mutex_t *)a3, v205, a6);
      if (v35)
      {
        uint64_t v188 = v35;
        log_err((uint64_t)"%s:%d: %s failed to free internal pool block %lld: %d\n", v36, v37, v38, v39, v40, v41, v42, (uint64_t)"spaceman_modify_bits");
        char v187 = 0;
        LOBYTE(v10) = 1;
        uint64_t v189 = a3;
        a5 = v216;
LABEL_115:
        uint64_t v14 = v203;
        goto LABEL_118;
      }
    }
    uint64_t v31 = v202 + 40;
    unint64_t v43 = v209[10];
    LODWORD(v19) = v19 - v209[11] * v33;
    unsigned int v226 = v209;
    LODWORD(v227) = v203;
    HIDWORD(v227) = v18 / v43;
    int v10 = 1;
    unint64_t v205 = v32;
LABEL_22:
    unint64_t v44 = *(void *)(v31 + 8 * v19);
    uint64_t v45 = v19;
    uint64_t v46 = obj_get(*(void *)(a1 + 392), 1073741829, v44, &sm_cib_desc, &v226, 0, 0, a6, &v229);
    if (v46)
    {
      uint64_t v188 = v46;
      a5 = v216;
      uint64_t v189 = a3;
      long long v15 = v201;
      log_err((uint64_t)"%s:%d: %s error getting cib %d @ %lld: %d\n", v47, v48, v49, v50, v51, v52, v53, (uint64_t)"spaceman_modify_bits");
      char v187 = 0;
      goto LABEL_140;
    }
    uint64_t v218 = v229[7];
    a5 = v216;
    if (obj_xid((uint64_t)v229) == a6)
    {
      uint64_t v208 = v44;
      long long v15 = v201;
      uint64_t v54 = v13;
      goto LABEL_29;
    }
    uint64_t v55 = sub_10000DB28(a1, a3, a6, (unint64_t *)&v225);
    if (v55)
    {
      uint64_t v188 = v55;
      log_err((uint64_t)"%s:%d: %s failed to allocate block from internal pool: %d\n", v56, v57, v58, v59, v60, v61, v62, (uint64_t)"spaceman_modify_bits");
      char v187 = 1;
      uint64_t v189 = a3;
      long long v15 = v201;
      goto LABEL_140;
    }
    *(void *)(v31 + 8 * v45) = v225;
    uint64_t v54 = v13;
    if (v230) {
      obj_dirty((uint64_t)v230, a6, v205);
    }
    uint64_t v208 = v225;
    obj_dirty((uint64_t)v229, a6, v225);
    uint64_t v63 = sub_100018810(a1, (pthread_mutex_t *)a3, v44, a6);
    long long v15 = v201;
    if (v63)
    {
      uint64_t v188 = v63;
      log_err((uint64_t)"%s:%d: %s failed to free internal pool block %lld: %d\n", v64, v65, v66, v67, v68, v69, v70, (uint64_t)"spaceman_modify_bits");
      char v187 = 1;
      uint64_t v189 = a3;
LABEL_140:
      uint64_t v14 = v203;
      if (!v222) {
        goto LABEL_144;
      }
      goto LABEL_118;
    }
LABEL_29:
    if (!v222) {
      pthread_mutex_unlock(v15);
    }
    BOOL v71 = v209;
    if (v230)
    {
      obj_unlock((uint64_t)v230, 2u);
      int v10 = 0;
    }
    int v200 = v10;
    unint64_t v72 = v18 % v209[10];
    uint64_t v73 = v218;
    uint64_t v74 = a6;
    unint64_t v75 = v218 + 32 * v72;
    unint64_t v78 = *(void *)(v75 + 64);
    unint64_t v76 = (uint64_t *)(v75 + 64);
    unint64_t v77 = v78;
    if (a7 == 1)
    {
LABEL_34:
      if (v77) {
        goto LABEL_35;
      }
      LOBYTE(v10) = v200;
      if (((*(_DWORD *)(v73 + 32 * v72 + 56) ^ *(_DWORD *)(v73 + 32 * v72 + 60)) & 0xFFFFF) != 0) {
        uint64_t v188 = nx_corruption_detected_int(a1);
      }
      else {
        uint64_t v188 = 22;
      }
      char v187 = 1;
      uint64_t v189 = a3;
      goto LABEL_115;
    }
    while (1)
    {
LABEL_35:
      uint64_t v215 = v9;
      if (v77)
      {
        uint64_t v79 = obj_get(*(void *)(a1 + 392), 1073741825, v77, &sm_bm_desc, 0, 0, 0, v74, &v228);
        if (v79)
        {
          uint64_t v188 = v79;
          uint64_t v189 = a3;
          log_err((uint64_t)"%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", v80, v81, v82, v83, v84, v85, v86, (uint64_t)"spaceman_modify_bits");
          char v187 = 1;
          uint64_t v14 = v203;
          LOBYTE(v10) = v200;
          goto LABEL_118;
        }
        uint64_t v87 = (_DWORD *)v228[7];
        uint64_t v73 = v218;
      }
      else
      {
        uint64_t v87 = 0;
      }
      unsigned int v88 = (uint64_t *)(v73 + 32 * v72 + 40);
      uint64_t v89 = v71[9];
      uint64_t v223 = v54;
      uint64_t v90 = v54 % v89;
      uint64_t v91 = v89 - v90;
      uint64_t v217 = a5;
      if (a5 >= v91) {
        a5 = v91;
      }
      if (v77 && *v88 == a6)
      {
        uint64_t v213 = v77;
        uint64_t v189 = a3;
        uint64_t v92 = v215;
        goto LABEL_50;
      }
      uint64_t v93 = sub_10000DB28(a1, a3, a6, (unint64_t *)&v225);
      if (v93)
      {
        uint64_t v181 = v93;
        log_err((uint64_t)"%s:%d: %s failed to allocate block from internal pool: %d\n", v94, v95, v96, v97, v98, v99, v100, (uint64_t)"spaceman_modify_bits");
        char v187 = 1;
        uint64_t v188 = v181;
        uint64_t v189 = a3;
        goto LABEL_117;
      }
      uint64_t *v88 = a6;
      unint64_t v101 = v225;
      *unint64_t v76 = v225;
      uint64_t v213 = v101;
      if (v77)
      {
        obj_dirty((uint64_t)v228, a6, v101);
        uint64_t v189 = a3;
        uint64_t v102 = sub_100018810(a1, (pthread_mutex_t *)a3, v77, a6);
        uint64_t v92 = v215;
        uint64_t v73 = v218;
        if (v102)
        {
          uint64_t v182 = v102;
          log_err((uint64_t)"%s:%d: %s failed to free internal pool block %lld: %d\n", v103, v104, v105, v106, v107, v108, v109, (uint64_t)"spaceman_modify_bits");
          char v187 = 1;
          uint64_t v188 = v182;
LABEL_117:
          uint64_t v14 = v203;
          LOBYTE(v10) = v200;
          a5 = v217;
          goto LABEL_118;
        }
      }
      else
      {
        uint64_t v110 = obj_create(*(void *)(a1 + 392), 0x40000000, v101, (int)&sm_bm_desc, 0, 0, a6, (uint64_t)&v228);
        uint64_t v189 = a3;
        uint64_t v92 = v215;
        if (v110)
        {
          uint64_t v188 = v110;
          log_err((uint64_t)"%s:%d: %s failed to create bitmap object %lld: %d\n", v111, v112, v113, v114, v115, v116, v117, (uint64_t)"spaceman_modify_bits");
          char v187 = 1;
          goto LABEL_117;
        }
        uint64_t v87 = (_DWORD *)v228[7];
        uint64_t v73 = v218;
      }
LABEL_50:
      uint64_t v211 = *(void *)(v189 + 376);
      char v118 = __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36)));
      unint64_t v119 = (0x4000000000000000uLL >> v118) & v92;
      unint64_t v212 = v72;
      if (a7 == 1)
      {
        unsigned int v120 = v119 != 0;
        unint64_t v128 = bitmap_count_bits((uint64_t)v87, 0, v90, a5 + v90);
        if (v128) {
          log_err((uint64_t)"%s:%d: %s freeing 0x%llx:%lld, but %lld bits are already clear.  Double free?\n", v121, v122, v123, v124, v125, v126, v127, (uint64_t)"spaceman_clear_bits_in_bm");
        }
        int64_t v129 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v118) & v92;
        uint64_t v130 = *(void *)(a1 + 376);
        uint64_t v131 = *(void *)(v130 + 1248);
        if (!v131
          || (uint64_t v132 = *(void *)(v130 + 1240),
              char v133 = __clz(__rbit64(*(unsigned int *)(v130 + 36))),
              (v119 != 0) == (((v132 << v133) & 0x4000000000000000) == 0)))
        {
          unint64_t v135 = 0;
          unint64_t v136 = v128;
        }
        else
        {
          unint64_t v231 = 0;
          unint64_t v134 = calc_overlap_range(v129, a5, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v133) & v132, v131, &v231);
          unint64_t v135 = v134;
          if (v134) {
            unint64_t v134 = bitmap_count_bits((uint64_t)v87, 0, v231 - *(void *)(v218 + 32 * v72 + 48), v231 + v134 - *(void *)(v218 + 32 * v72 + 48));
          }
          unint64_t v136 = v128 - v134;
        }
        BOOL v143 = v119 != 0;
        bitmap_clear_range((uint64_t)v87, v90, a5);
        uint64_t v144 = v129 / *(unsigned int *)(v211 + 36);
        uint64_t v189 = a3;
        sub_100017D6C(a3, v120, v87, v144);
        *(_DWORD *)(v218 + 32 * v72 + 60) += a5 - v128;
        pthread_mutex_lock(v210);
        *(void *)(v211 + 48 * v143 + 72) += a5 - v136 - v135;
        uint64_t v92 = v215;
        if (a8)
        {
          uint64_t v145 = a3 + 8 * v143;
          unint64_t v146 = *(void *)(v145 + 976);
          BOOL v147 = v146 >= a5;
          unint64_t v148 = v146 - a5;
          if (!v147) {
            unint64_t v148 = 0;
          }
          *(void *)(v145 + 976) = v148;
        }
        goto LABEL_98;
      }
      unint64_t v137 = v73 + 32 * v72;
      if ((*(_DWORD *)(v137 + 56) & 0xFFFFF) - v90 >= a5) {
        unint64_t v138 = a5;
      }
      else {
        unint64_t v138 = (*(_DWORD *)(v137 + 56) & 0xFFFFF) - v90;
      }
      uint64_t v139 = v73;
      if (bitmap_range_is_clear((uint64_t)v87, v90, v138))
      {
        bitmap_set_range((uint64_t)v87, v90, v138);
        sub_100017D6C(a3, v119 != 0, v87, v72 + *(unsigned int *)(v211 + 40) * (unint64_t)*(unsigned int *)(v139 + 32));
        pthread_mutex_lock(v210);
        *(_DWORD *)(v137 + 60) -= v138;
        uint64_t v140 = v211 + 48 * (v119 != 0);
        uint64_t v142 = *(void *)(v140 + 72);
        unint64_t v141 = (unint64_t *)(v140 + 72);
        *unint64_t v141 = v142 - v138;
        if (a8)
        {
          uint64_t v151 = a3 + 8 * (v119 != 0);
          size_t v152 = (void *)(v151 + 848);
          unint64_t v153 = *(void *)(v151 + 848);
          if (*(void *)(v151 + 832) < v153)
          {
            unint64_t v154 = "Main";
            if (v119) {
              unint64_t v154 = "T2";
            }
            panic("%s, Reserved space < reserved metadata: %llu < %llu\n", v154, *(void *)(a3 + 832), *(void *)(a3 + 848));
          }
          uint64_t v155 = (void *)(v151 + 832);
          if ((a8 & 0x40) != 0)
          {
            if (v153 < v138) {
              panic("reserved metadata space underflow: %lld (%lld)\n", v153, v138);
            }
            *size_t v152 = v153 - v138;
            unint64_t v153 = *v155 - v138;
            *uint64_t v155 = v153;
            uint64_t v189 = a3;
          }
          else
          {
            if (*v155 - v153 >= v138)
            {
              unint64_t v153 = *v155 - v138;
              uint64_t v189 = a3;
            }
            else
            {
              uint64_t v189 = a3;
              obj_type(v198);
              log_err((uint64_t)"%s:%d: %s reserved space underflow: %lld (+meta:%llu) < %lld\n", v156, v157, v158, v159, v160, v161, v162, (uint64_t)"spaceman_set_bits_in_bm");
            }
            *uint64_t v155 = v153;
          }
          if (v153 > *v141) {
            sub_10005DCD4();
          }
          if (!a2) {
            goto LABEL_98;
          }
          unint64_t v163 = *(void *)(a2 + 408);
          BOOL v147 = v163 >= v138;
          unint64_t v164 = v163 - v138;
          if (!v147)
          {
            obj_type(a2);
            log_err((uint64_t)"%s:%d: %s fs reserved space underflow: %lld (%lld)\n", v165, v166, v167, v168, v169, v170, v171, (uint64_t)"spaceman_set_bits_in_bm");
            unint64_t v164 = 0;
          }
          *(void *)(a2 + 408) = v164;
        }
        else
        {
          uint64_t v189 = a3;
          if (!a2)
          {
LABEL_98:
            pthread_mutex_unlock(v210);
            char v150 = 0;
            uint64_t v188 = 0;
            int v149 = 1;
            goto LABEL_99;
          }
        }
        char v172 = *(void **)(a2 + 376);
        unint64_t v173 = v172[11];
        v172[11] = v173 + v138;
        unint64_t v174 = v172[9];
        if (v173 + v138 <= v174)
        {
          unint64_t v177 = *(void *)(v211 + 192) + v138;
        }
        else
        {
          unint64_t v175 = v172[10];
          if (v175 && v173 + v138 > v175) {
            sub_10005DC7C();
          }
          BOOL v147 = v174 >= v173;
          unint64_t v176 = v174 - v173;
          if (v176 == 0 || !v147)
          {
            unint64_t v177 = *(void *)(v211 + 192);
LABEL_96:
            if (v177 > *(void *)(v211 + 184)) {
              sub_10005DCA8();
            }
            fs_sb_dirty(a2, a6);
            goto LABEL_98;
          }
          unint64_t v177 = *(void *)(v211 + 192) + v176;
        }
        *(void *)(v211 + 192) = v177;
        goto LABEL_96;
      }
      int v149 = 0;
      uint64_t v188 = 22;
      char v150 = 1;
      uint64_t v189 = a3;
LABEL_99:
      uint64_t v74 = a6;
      obj_dirty(v189, a6, 0);
      obj_dirty((uint64_t)v229, a6, v208);
      obj_dirty((uint64_t)v228, a6, v213);
      obj_release(v228);
      uint64_t v228 = 0;
      uint64_t v9 = a5 + v92;
      uint64_t v224 = a5 + v223;
      uint64_t v73 = v218;
      a5 = v217 - a5;
      if (!v149 || a5 < 1 || v72 >= (*(_DWORD *)(v218 + 36) - 1)) {
        break;
      }
      ++v72;
      uint64_t v178 = v218 + 32 * (v212 + 1);
      unint64_t v179 = *(void *)(v178 + 64);
      unint64_t v76 = (uint64_t *)(v178 + 64);
      unint64_t v77 = v179;
      BOOL v71 = v209;
      uint64_t v54 = v224;
      if (a7 == 1) {
        goto LABEL_34;
      }
    }
    obj_unlock((uint64_t)v229, 2u);
    obj_release(v229);
    uint64_t v229 = 0;
    if (a5 < 1) {
      char v180 = 1;
    }
    else {
      char v180 = v150;
    }
    uint64_t v14 = v203;
    int v10 = v200;
    long long v15 = v201;
    unint64_t v11 = v209;
    uint64_t v13 = v224;
    BOOL v16 = (unsigned int *)v197;
    if (v180)
    {
      char v187 = 0;
      goto LABEL_118;
    }
  }
  unint64_t v22 = *(void *)(*v199 + 8 * v20);
  if (v230)
  {
    obj_release(v230);
    uint64_t v230 = 0;
  }
  unsigned int v226 = v209;
  unint64_t v227 = __PAIR64__(v20, v14);
  unint64_t v205 = v22;
  uint64_t v23 = obj_get(*(void *)(a1 + 392), 1073741829, v22, &sm_cab_desc, &v226, 0, 0, a6, &v230);
  if (!v23)
  {
    uint64_t v202 = v230[7];
    unsigned int v204 = v20;
    goto LABEL_17;
  }
  uint64_t v188 = v23;
  log_err((uint64_t)"%s:%d: %s error getting cab %d @ %lld: %d\n", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"spaceman_modify_bits");
  char v187 = 0;
  uint64_t v189 = a3;
LABEL_143:
  a5 = v216;
LABEL_144:
  pthread_mutex_unlock(v15);
LABEL_118:
  if (v230 && (v10 & 1) != 0) {
    obj_unlock((uint64_t)v230, 2u);
  }
  char v183 = v187 ^ 1;
  if (!v229) {
    char v183 = 1;
  }
  if ((v183 & 1) == 0) {
    obj_unlock((uint64_t)v229, 2u);
  }
  if (v230) {
    obj_release(v230);
  }
  if (v229) {
    obj_release(v229);
  }
  if (v228) {
    obj_release(v228);
  }
  if (a7 == 1)
  {
    if (v188)
    {
      if (a5)
      {
        uint64_t v184 = v189 + 8 * v14;
        uint64_t v185 = *(void *)(v184 + 976);
        if (v185) {
          *(void *)(v184 + 976) = v185 - a5;
        }
      }
    }
  }
  return v188;
}

uint64_t spaceman_free(void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  int v37 = 0;
  if (obj_type((uint64_t)a1) == 13)
  {
    uint64_t v9 = a1[49];
    uint64_t v10 = (uint64_t)a1;
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = (uint64_t)a1;
  }
  if (((a3 << __clz(__rbit64(*(unsigned int *)(*(void *)(v9 + 376) + 36)))) & 0x4000000000000000) != 0) {
    uint64_t v11 = 2;
  }
  else {
    uint64_t v11 = 1;
  }
  BOOL is_current_tx = xid_is_current_tx(v9, a5);
  uint64_t v13 = 22;
  if (a4 >= 1 && is_current_tx)
  {
    uint64_t v38 = 0;
    int is_allocated = spaceman_is_allocated((void *)v9, a3, a4, (uint64_t)&v37);
    if (!(is_allocated | v37))
    {
      obj_type((uint64_t)a1);
      log_err((uint64_t)"%s:%d: %s Attempt to free range containing unallocated block(s): %lld:%lld\n", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"spaceman_free");
      return v13;
    }
    uint64_t v13 = spaceman_get((void *)v9, &v38);
    if (!v13)
    {
      p_sig = &v38->__sig;
      uint64_t v16 = *(void *)&v38[24].__opaque[40];
      if (v16)
      {
        uint64_t v17 = *(void *)(v16 + 104) + a4;
        ++*(void *)(v16 + 96);
        *(void *)(v16 + 104) = v17;
      }
      if (spaceman_extent_check(v9, (uint64_t)p_sig, a3, a4))
      {
        if (nx_ratelimit_log_allowed(*(void *)(*a1 + 392)))
        {
          obj_type((uint64_t)a1);
          log_err((uint64_t)"%s:%d: %s attempt to free extent (0x%llx:0x%llx) which should not be freed: %d\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"spaceman_free");
        }
        obj_release(&v38->__sig);
        return 22;
      }
      uint64_t v26 = obj_modify(v38, 0, a5);
      if (v26)
      {
        uint64_t v13 = v26;
LABEL_33:
        obj_release(&v38->__sig);
        return v13;
      }
      if (*(unsigned char *)(v9 + 629))
      {
        int v34 = sub_100016488(v9, a3, a4, (uint64_t)&v37);
        if (v34 | v37)
        {
          uint64_t v13 = 0;
          goto LABEL_33;
        }
        pthread_mutex_lock(v38 + 6);
        uint64_t v13 = sub_100016520(v9, (uint64_t)v38, a3, a4, a5);
        dev_unmap_flush(*(void *)(v9 + 384));
        if (v10 && !v13)
        {
          sub_10001661C(v10, (uint64_t)v38, a4, a5);
          obj_dirty((uint64_t)v38, a5, 0);
        }
        uint64_t v36 = v38 + 6;
      }
      else
      {
        pthread_mutex_lock(v38 + 8);
        uint64_t v35 = sub_100016740(v9, (uint64_t)v38, v11, a3, a4, a5);
        uint64_t v13 = v35;
        if (v10 && !v35)
        {
          pthread_mutex_lock(v38 + 6);
          sub_10001661C(v10, (uint64_t)v38, a4, a5);
          obj_dirty((uint64_t)v38, a5, 0);
          pthread_mutex_unlock(v38 + 6);
        }
        uint64_t v36 = v38 + 8;
      }
      pthread_mutex_unlock(v36);
      goto LABEL_33;
    }
  }
  return v13;
}

uint64_t spaceman_is_allocated(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = 0;
  if (spaceman_get(a1, &v18))
  {
    log_err((uint64_t)"%s:%d: %s failed to get spaceman structure: %d\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"spaceman_is_allocated");
    return 0;
  }
  else
  {
    pthread_mutex_lock(v18 + 8);
    pthread_mutex_lock(v18 + 6);
    uint64_t v15 = sub_100016B2C((uint64_t)a1, (uint64_t)v18, 0, a2, a3, a4, 0, v16);
    pthread_mutex_unlock(v18 + 6);
    pthread_mutex_unlock(v18 + 8);
    obj_release(&v18->__sig);
  }
  return v15;
}

uint64_t sub_100016488(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(pthread_mutex_t **)(a1 + 416);
  pthread_mutex_lock(v8 + 8);
  pthread_mutex_lock(v8 + 6);
  uint64_t v10 = sub_100016B2C(a1, (uint64_t)v8, 1, a2, a3, a4, 0, v9);
  pthread_mutex_unlock(v8 + 6);
  pthread_mutex_unlock(v8 + 8);
  return v10;
}

uint64_t sub_100016520(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  if (!xid_is_current_tx(a1, a5)) {
    return 22;
  }
  if (spaceman_extent_check(a1, a2, a3, a4))
  {
    if (nx_ratelimit_log_allowed(a1)) {
      log_err((uint64_t)"%s:%d: %s attempt to free extent (0x%llx:0x%llx) which should not be free: %d\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"spaceman_freed");
    }
    return 22;
  }
  dev_unmap(*(void *)(a1 + 384), a3);

  return sub_1000184D8(a1, a2, a3, a4, 0, a5);
}

void sub_10001661C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v7 = *(void *)(a2 + 376);
  uint64_t v8 = (pthread_mutex_t *)(a2 + 576);
  pthread_mutex_lock((pthread_mutex_t *)(a2 + 576));
  uint64_t v16 = *(void *)(a1 + 376);
  unint64_t v17 = *(void *)(v16 + 88);
  BOOL v18 = v17 >= a3;
  unint64_t v19 = v17 - a3;
  if (v18)
  {
    *(void *)(v16 + 88) = v19;
  }
  else
  {
    obj_oid(a1);
    log_err((uint64_t)"%s:%d: %s fs %lld alloc count underflow: %lld (%lld)\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"spaceman_free_fs_deduct_block_counts");
    unint64_t v19 = 0;
    uint64_t v16 = *(void *)(a1 + 376);
    *(void *)(v16 + 88) = 0;
  }
  unint64_t v27 = *(void *)(v16 + 72);
  if (v27)
  {
    unint64_t v28 = v19 + a3;
    BOOL v18 = v27 >= v19;
    unint64_t v29 = v27 - v19;
    if (!v18) {
      unint64_t v29 = 0;
    }
    if (v28 <= v27) {
      unint64_t v29 = a3;
    }
    unint64_t v30 = *(void *)(v7 + 192);
    unint64_t v31 = v30 - v29;
    if (v30 < v29)
    {
      log_err((uint64_t)"%s:%d: %s spaceman fs reserve alloc count underflow: %lld (%lld)\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"spaceman_free_fs_deduct_block_counts");
      unint64_t v31 = 0;
    }
    *(void *)(v7 + 192) = v31;
  }
  pthread_mutex_unlock(v8);

  fs_sb_dirty(a1, a4);
}

uint64_t sub_100016740(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12 = *(void *)(a2 + 376);
  uint64_t v56 = 0;
  v55[0] = 0;
  long long v52 = 0uLL;
  uint64_t v53 = 0;
  *((void *)&v51 + 1) = 0;
  uint64_t v13 = spaceman_fq_tree_get();
  if (!v13)
  {
    *(void *)&long long v51 = 0;
    *(void *)&long long v54 = a6;
    *((void *)&v54 + 1) = a4;
    unsigned int v49 = 8;
    unsigned int v50 = 16;
    uint64_t v14 = bt_lookup_variant(v56, 0, (unint64_t *)&v54, &v50, 0x10u, v55, &v49, 1u, 0, 0);
    if (v14 == 2) {
      goto LABEL_13;
    }
    uint64_t v13 = v14;
    if (v14) {
      goto LABEL_43;
    }
    if ((void)v54 != a6) {
      goto LABEL_13;
    }
    if (v49)
    {
      uint64_t v22 = v55[0];
    }
    else
    {
      uint64_t v22 = 1;
      v55[0] = 1;
    }
    if (v22 + *((void *)&v54 + 1) <= a4)
    {
      if (v22 + *((void *)&v54 + 1) != a4) {
        goto LABEL_13;
      }
    }
    else
    {
      log_err((uint64_t)"%s:%d: %s range 0x%llx:%lld overlaps with recently-freed range 0x%llx:%lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"spaceman_fq_tree_insert");
      uint64_t v22 = v55[0];
      a5 += a4 - (v55[0] + *((void *)&v54 + 1));
      if (a5 < 1)
      {
        uint64_t v13 = 22;
        goto LABEL_43;
      }
      a4 = v55[0] + *((void *)&v54 + 1);
    }
    long long v52 = v54;
    uint64_t v23 = v22 + a5;
    uint64_t v53 = v22 + a5;
    if ((void)v54)
    {
LABEL_14:
      long long v54 = v52;
      unsigned int v49 = 8;
      unsigned int v50 = 16;
      uint64_t v24 = bt_lookup_variant(v56, 0, (unint64_t *)&v54, &v50, 0x10u, v55, &v49, 4u, 0, 0);
      if (v24 == 2)
      {
LABEL_31:
        unsigned int v49 = 8 * (v23 != 1);
        uint64_t v13 = bt_insert(v56, 0, (unint64_t *)&v52, 16, &v53, v49, a6);
        if (!v13)
        {
          pthread_mutex_lock((pthread_mutex_t *)(a2 + 576));
          uint64_t v36 = v12 + 40 * a3;
          uint64_t v39 = *(void *)(v36 + 200);
          int v37 = (void *)(v36 + 200);
          uint64_t v38 = v39;
          if (!v39) {
            *(void *)(v12 + 40 * a3 + 216) = a6;
          }
          *int v37 = v38 + a5;
          pthread_mutex_unlock((pthread_mutex_t *)(a2 + 576));
          obj_dirty(a2, a6, 0);
          if ((void)v51 && bt_remove(v56, 0, (unint64_t *)&v51, 0x10u, a6)) {
            log_err((uint64_t)"%s:%d: %s removal of replaced free extent failed: %d\n", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"spaceman_fq_tree_insert");
          }
          if (spaceman_fq_tree_over_threshold(a2, a3, (uint64_t)v56, 0))
          {
            memset(v48, 0, sizeof(v48));
            sub_10000E874(a1, (uint64_t)v48, 0, 0);
            while (spaceman_fq_tree_over_threshold(a2, a3, (uint64_t)v56, 1)
                 && sub_10000E968(a1, a2, a3, 1, v48, a6))
              ;
            sub_10000F1E4(a1, (uint64_t)v48);
          }
          uint64_t v13 = 0;
        }
        goto LABEL_43;
      }
      uint64_t v13 = v24;
      if (!v24)
      {
        if ((void)v54 == a6)
        {
          if (v49)
          {
            uint64_t v32 = v55[0];
          }
          else
          {
            uint64_t v32 = 1;
            v55[0] = 1;
          }
          uint64_t v33 = v23 + *((void *)&v52 + 1);
          if (*((uint64_t *)&v54 + 1) <= v23 + *((void *)&v52 + 1))
          {
            if (*((uint64_t *)&v54 + 1) < v23 + *((void *)&v52 + 1))
            {
              uint64_t v34 = v32 + *((void *)&v54 + 1);
              log_err((uint64_t)"%s:%d: %s range 0x%llx:%lld overlaps with recently-freed range 0x%llx:%lld\n", v25, v26, v27, v28, v29, v30, v31, (uint64_t)"spaceman_fq_tree_insert");
              if (v34 > v33)
              {
                v23 += v34 - v33;
                uint64_t v53 = v23;
              }
              if (v34 >= v33) {
                uint64_t v35 = v33;
              }
              else {
                uint64_t v35 = v34;
              }
              a5 = a5 - v35 + *((void *)&v54 + 1);
            }
            else
            {
              v23 += v32;
              uint64_t v53 = v23;
            }
            long long v51 = v54;
          }
        }
        goto LABEL_31;
      }
LABEL_43:
      obj_release(v56);
      return v13;
    }
LABEL_13:
    *(void *)&long long v52 = a6;
    *((void *)&v52 + 1) = a4;
    uint64_t v23 = a5;
    uint64_t v53 = a5;
    goto LABEL_14;
  }
  return v13;
}

uint64_t sub_100016B2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8)
{
  uint64_t v8 = (_DWORD *)a6;
  uint64_t v9 = a5;
  unint64_t v10 = a4;
  char v11 = a3;
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  uint64_t v80 = 0;
  char v12 = __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36)));
  unint64_t v13 = (0x4000000000000000uLL >> v12) & a4;
  BOOL v74 = v13 != 0;
  if (v13) {
    int v14 = 2;
  }
  else {
    int v14 = 1;
  }
  uint64_t v15 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v12) & a4;
  if ((a3 & 2) != 0) {
    *a7 = 0;
  }
  unint64_t v78 = 0;
  unint64_t v79 = 0;
  uint64_t v16 = *(unsigned int **)(a2 + 376);
  unint64_t v17 = *(void *)&v16[12 * (v13 != 0) + 12];
  if (v17 <= a5 || v15 > v17 - a5)
  {
    log_err((uint64_t)"%s:%d: %s block range %lld:%lld out of %s bounds %lld\n", a2, a3, a4, a5, a6, (uint64_t)a7, a8, (uint64_t)"spaceman_check_allocation_status_internal");
    return 22;
  }
  unsigned int v66 = v14;
  if (a5 <= 0)
  {
    BOOL is_set = 0;
    uint64_t v19 = 0;
    if ((a3 & 3) == 0) {
      goto LABEL_62;
    }
    goto LABEL_70;
  }
  BOOL is_set = 0;
  uint64_t v21 = 0;
  uint64_t v22 = v15 + a5;
  uint64_t v70 = &v16[12 * (v13 != 0) + 17];
  uint64_t v69 = (uint64_t *)(a2 + 8 * (v13 != 0) + 888);
  int v73 = a3 & 3;
  int v23 = -1;
  while (1)
  {
    unint64_t v24 = v16[10];
    unint64_t v25 = v15 / v16[9];
    unint64_t v72 = v25;
    unint64_t v26 = v25 / v24;
    if (*v70) {
      break;
    }
    uint64_t v21 = *v69;
    unint64_t v32 = v25 / v24;
LABEL_22:
    unint64_t v78 = v16;
    unint64_t v79 = __PAIR64__(v26, v74);
    if (!v21)
    {
      uint64_t v19 = 22;
LABEL_57:
      uint64_t v8 = (_DWORD *)a6;
      unint64_t v10 = a4;
      uint64_t v9 = a5;
      goto LABEL_61;
    }
    int v71 = v23;
    uint64_t v33 = v21;
    uint64_t v34 = obj_get(*(void *)(a1 + 392), 0x40000000, *(void *)(v21 + 8 * v32), &sm_cib_desc, &v78, 0, 0, 0, &v81);
    if (v34)
    {
      uint64_t v19 = v34;
      log_err((uint64_t)"%s:%d: %s error getting cib %d @ %lld: %d\n", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"spaceman_check_allocation_status_internal");
      goto LABEL_60;
    }
    if (v15 < v22)
    {
      uint64_t v42 = v81[7];
      unint64_t v43 = v72 % v16[10];
      do
      {
        if (v43 >= *(unsigned int *)(v42 + 36)) {
          break;
        }
        uint64_t v44 = *(void *)(v42 + 32 * v43 + 64);
        if (v44)
        {
          uint64_t v45 = obj_get(*(void *)(a1 + 392), 0x40000000, v44, &sm_bm_desc, 0, 0, 0, 0, &v80);
          if (v45)
          {
            uint64_t v19 = v45;
            log_err((uint64_t)"%s:%d: %s error getting cib %d bitmap %d @ %lld: %d\n", v46, v47, v48, v49, v50, v51, v52, (uint64_t)"spaceman_check_allocation_status_internal");
            goto LABEL_47;
          }
          uint64_t v53 = v80[7];
          uint64_t v54 = v16[9];
          uint64_t v55 = v15 % v54;
          uint64_t v56 = v54 - v15 % v54;
          if (v22 - v15 >= v56) {
            uint64_t v57 = v56;
          }
          else {
            uint64_t v57 = v22 - v15;
          }
          if (v11)
          {
            int is_clear = bitmap_range_is_clear(v53, v55, v57);
            int v59 = v11 & 2 | is_clear;
            BOOL is_set = is_clear == 0;
            obj_release(v80);
            uint64_t v80 = 0;
            if (!v59)
            {
              uint64_t v19 = 0;
              BOOL is_set = 1;
              goto LABEL_55;
            }
          }
          else if ((v11 & 2) != 0)
          {
            *a7 += bitmap_count_bits(v53, 0, v55, v57 + v55);
            obj_release(v80);
            uint64_t v80 = 0;
          }
          else
          {
            BOOL is_set = bitmap_range_is_set(v53, v55, v57);
            obj_release(v80);
            uint64_t v80 = 0;
            if (!is_set) {
              goto LABEL_54;
            }
          }
        }
        else
        {
          if (!v73)
          {
            BOOL is_set = 0;
LABEL_54:
            uint64_t v19 = 0;
LABEL_55:
            uint64_t v8 = (_DWORD *)a6;
            goto LABEL_72;
          }
          if (v22 - v15 >= (*(_DWORD *)(v42 + 32 * v43 + 60) & 0xFFFFF) + v15 / v16[9] * v16[9] - v15) {
            uint64_t v57 = (*(_DWORD *)(v42 + 32 * v43 + 60) & 0xFFFFF) + v15 / v16[9] * v16[9] - v15;
          }
          else {
            uint64_t v57 = v22 - v15;
          }
          BOOL is_set = 0;
          if (a7) {
            *a7 += v57;
          }
        }
        v15 += v57;
        ++v43;
      }
      while (v15 < v22);
    }
    uint64_t v19 = 0;
LABEL_47:
    obj_release(v81);
    uint64_t v81 = 0;
    if (v15 < v22)
    {
      uint64_t v21 = v33;
      int v23 = v71;
      if (!v19) {
        continue;
      }
    }
    goto LABEL_57;
  }
  unsigned int v27 = v16[11];
  unsigned int v28 = v26 / v27;
  unint64_t v29 = v25 / v24;
  if (v26 / v27 == v23)
  {
LABEL_20:
    LODWORD(v32) = v26 - v27 * v23;
    LODWORD(v26) = v29;
    goto LABEL_22;
  }
  uint64_t v30 = *(void *)(*v69 + 8 * v28);
  if (v82)
  {
    obj_release(v82);
    uint64_t v82 = 0;
  }
  unint64_t v78 = v16;
  unint64_t v79 = __PAIR64__(v28, v74);
  uint64_t v31 = obj_get(*(void *)(a1 + 392), 0x40000000, v30, &sm_cab_desc, &v78, 0, 0, 0, &v82);
  if (!v31)
  {
    uint64_t v21 = v82[7] + 40;
    unsigned int v27 = v16[11];
    int v23 = v28;
    unint64_t v29 = v72 / v16[10];
    goto LABEL_20;
  }
  uint64_t v60 = v31;
  log_err((uint64_t)"%s:%d: %s error getting cab %d @ %lld: %d\n", a2, a3, a4, a5, a6, (uint64_t)a7, a8, (uint64_t)"spaceman_check_allocation_status_internal");
  uint64_t v19 = v60;
LABEL_60:
  uint64_t v8 = (_DWORD *)a6;
  unint64_t v10 = a4;
  uint64_t v9 = a5;
LABEL_61:
  if (!v73)
  {
LABEL_62:
    if (!v19 && is_set)
    {
      char v77 = 0;
      uint64_t overlap = spaceman_fq_tree_find_overlap(a1, a2, v66, v10, v9, &v77);
      uint64_t v19 = overlap;
      if (v77 && overlap == 0) {
        BOOL is_set = 0;
      }
    }
  }
LABEL_70:
  if (v19) {
    log_debug((uint64_t)"%s:%d: %s %lld:%lld error: %d\n", a2, a3, a4, a5, a6, (uint64_t)a7, a8, (uint64_t)"spaceman_check_allocation_status_internal");
  }
LABEL_72:
  if (v82) {
    obj_release(v82);
  }
  if (v81) {
    obj_release(v81);
  }
  if (v80) {
    obj_release(v80);
  }
  *uint64_t v8 = is_set;
  return v19;
}

uint64_t spaceman_reserve(uint64_t a1, unsigned int a2, unint64_t a3, uint64_t a4, int *a5)
{
  uint64_t v8 = (void *)a1;
  if (obj_type(a1) == 13) {
    uint64_t v9 = v8;
  }
  else {
    uint64_t v9 = 0;
  }
  if (v9) {
    uint64_t v8 = (void *)v9[49];
  }
  uint64_t v40 = 0;
  memset(v39, 0, sizeof(v39));
  uint64_t v41 = 0;
  uint64_t v42 = 0;
  if ((uint64_t)a3 < 1) {
    return 22;
  }
  uint64_t v10 = spaceman_get(v8, &v40);
  if (!v10)
  {
    char v11 = *(void **)&v40[5].__opaque[48];
    uint64_t v12 = *(void *)(v8[47] + 48);
    if ((~a2 & 0x38) == 0) {
      panic("Absurd combination of allocation flags for spaceman %llx", v40);
    }
    if (*(void *)(*(void *)&v40[5].__opaque[48] + 96))
    {
      int v13 = a2 & 0x20;
      switch((a2 >> 3) & 3)
      {
        case 1u:
        case 3u:
          uint64_t v41 = 0x200000001;
          uint64_t v42 = (uint64_t)&_mh_execute_header;
          break;
        default:
          uint64_t v41 = 0x100000002;
          uint64_t v42 = 1;
          v13 |= (unint64_t)(v12 & 2) >> 1;
          break;
      }
      uint64_t v35 = a5;
      BOOL v14 = v13 == 0;
      uint64_t v15 = 1;
      if (v14) {
        uint64_t v15 = 2;
      }
      uint64_t v37 = v15;
    }
    else
    {
      if ((a2 & 0x10) != 0)
      {
        uint64_t v10 = 22;
        goto LABEL_52;
      }
      uint64_t v35 = a5;
      LODWORD(v42) = 0;
      uint64_t v37 = 1;
      LODWORD(v41) = 1;
    }
    int v36 = a2 & 0x40;
    pthread_mutex_lock(v40 + 6);
    pthread_mutex_lock(v40 + 9);
    uint64_t v16 = 0;
LABEL_21:
    uint64_t v17 = *((unsigned int *)&v42 + v16);
    uint64_t v18 = *((unsigned int *)&v41 + v16++);
    uint64_t v19 = &v11[6 * v17 + 9];
    BOOL v20 = 1;
    while (1)
    {
      if (v9)
      {
        uint64_t v21 = v9[47];
        unint64_t v22 = *(void *)(v21 + 80);
        if (v22)
        {
          if (*(void *)(v21 + 88) + a3 + v9[51] > v22)
          {
            uint64_t v10 = 69;
            goto LABEL_50;
          }
        }
      }
      unint64_t v23 = v11[30] + v11[9] + v11[15] + v11[35] + v11[24] - v11[23];
      if (v9)
      {
        uint64_t v24 = v9[47];
        unint64_t v25 = *(void *)(v24 + 72);
        unint64_t v26 = *(void *)(v24 + 88);
        BOOL v27 = v25 >= v26;
        unint64_t v28 = v25 - v26;
        if (!v27) {
          unint64_t v28 = 0;
        }
        v23 += v28;
      }
      if (v23 < a3)
      {
        uint64_t v10 = 28;
LABEL_50:
        unint64_t v29 = v40;
        goto LABEL_51;
      }
      unint64_t v29 = v40;
      unint64_t v30 = *v19 - *(&v40[13].__sig + v17);
      if (v30 < a3)
      {
        if (!v20 || v11[5 * v18 + 25] + v30 < a3 || !v20)
        {
          if (v16 != v37) {
            goto LABEL_21;
          }
          uint64_t v10 = 28;
LABEL_51:
          pthread_mutex_unlock(v29 + 9);
          pthread_mutex_unlock(v40 + 6);
LABEL_52:
          obj_release(&v40->__sig);
          return v10;
        }
        pthread_mutex_unlock(v40 + 9);
        pthread_mutex_unlock(v40 + 6);
        pthread_mutex_lock(v40 + 8);
        sub_10000E874((uint64_t)v8, (uint64_t)v39, 0, 0);
        BOOL v20 = sub_10000E968(v8, v40, v18, 1, v39, a4) != 0;
        sub_10000F1E4((uint64_t)v8, (uint64_t)v39);
        pthread_mutex_unlock(v40 + 8);
        pthread_mutex_lock(v40 + 6);
        pthread_mutex_lock(v40 + 9);
        unint64_t v30 = 0;
      }
      if (v30 >= a3)
      {
        unint64_t v29 = v40;
        uint64_t v31 = &v40->__sig + v17;
        unint64_t v32 = v31[104] + a3;
        v31[104] = v32;
        if (v32 > *v19) {
          sub_10005DD00();
        }
        if (v36) {
          *(void *)&v29[13].__opaque[8 * v17 + 8] += a3;
        }
        if (v9) {
          v9[51] += a3;
        }
        uint64_t v10 = 0;
        if (v17 == 1) {
          int v33 = 16;
        }
        else {
          int v33 = 8;
        }
        *uint64_t v35 = v33 | v36;
        goto LABEL_51;
      }
    }
  }
  return v10;
}

uint64_t spaceman_unreserve(uint64_t a1, unsigned int a2, unint64_t a3)
{
  if (obj_type(a1) == 13) {
    uint64_t v6 = a1;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = (void *)a1;
  if (v6) {
    uint64_t v7 = *(void **)(v6 + 392);
  }
  uint64_t v33 = 0;
  if ((a2 & 0x18) == 0) {
    sub_10005DD2C();
  }
  uint64_t v8 = spaceman_get(v7, &v33);
  if (!v8)
  {
    uint64_t v9 = (a2 >> 4) & 1;
    pthread_mutex_lock((pthread_mutex_t *)(v33 + 384));
    pthread_mutex_lock((pthread_mutex_t *)(v33 + 576));
    if (*(void *)(v33 + 8 * v9 + 832) < *(void *)(v33 + 8 * v9 + 848))
    {
      uint64_t v10 = "T2";
      if (!v9) {
        uint64_t v10 = "Main";
      }
      panic("%s, Reserved space < reserved metadata: %llu < %llu\n", v10, *(void *)(v33 + 832), *(void *)(v33 + 848));
    }
    uint64_t v11 = v33;
    uint64_t v12 = v33 + 8 * v9;
    unint64_t v13 = *(void *)(v12 + 848);
    if ((a2 & 0x40) != 0)
    {
      if (v13 < a3) {
        panic("reserved metadata space underflow: %lld (%lld)\n", *(void *)(v12 + 848), a3);
      }
      *(void *)(v12 + 848) = v13 - a3;
      *(void *)(v11 + 8 * v9 + 832) -= a3;
      if (!v6) {
        goto LABEL_25;
      }
      goto LABEL_22;
    }
    uint64_t v14 = *(void *)(v12 + 832);
    if (v14 - v13 >= a3)
    {
      *(void *)(v12 + 832) = v14 - a3;
      if (v6)
      {
LABEL_22:
        unint64_t v22 = *(void *)(v6 + 408);
        BOOL v23 = v22 >= a3;
        unint64_t v24 = v22 - a3;
        if (!v23)
        {
          obj_type(a1);
          log_err((uint64_t)"%s:%d: %s fs reserved space underflow: %lld (%lld)\n", v25, v26, v27, v28, v29, v30, v31, (uint64_t)"spaceman_unreserve");
          unint64_t v24 = 0;
        }
        *(void *)(v6 + 408) = v24;
      }
    }
    else
    {
      obj_type(a1);
      log_err((uint64_t)"%s:%d: %s reserved space underflow: %lld (+meta:%llu) < %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"spaceman_unreserve");
      *(void *)(v33 + 8 * v9 + 832) = v13;
      if (v6) {
        goto LABEL_22;
      }
    }
LABEL_25:
    pthread_mutex_unlock((pthread_mutex_t *)(v33 + 576));
    pthread_mutex_unlock((pthread_mutex_t *)(v33 + 384));
    obj_release(v33);
  }
  return v8;
}

uint64_t spaceman_fs_bounds_set(void *a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5)
{
  uint64_t v38 = 0;
  uint64_t v15 = spaceman_get(a1, &v38);
  if (!v15)
  {
    uint64_t v16 = *(void **)&v38[5].__opaque[48];
    uint64_t v15 = obj_modify(v38, 0, a5, v10, v11, v12, v13, v14);
    if (!v15)
    {
      pthread_mutex_lock(v38 + 8);
      pthread_mutex_lock(v38 + 6);
      pthread_mutex_lock(v38 + 9);
      unint64_t v24 = *(void **)(a2 + 376);
      unint64_t v25 = v24[9];
      uint64_t v26 = a3 - v25;
      if ((uint64_t)(a3 - v25) < 0 && v16[23] < v25 - a3)
      {
        uint64_t v15 = nx_corruption_detected_int((uint64_t)a1);
LABEL_30:
        pthread_mutex_unlock(v38 + 9);
        pthread_mutex_unlock(v38 + 6);
        pthread_mutex_unlock(v38 + 8);
        obj_release(&v38->__sig);
        return v15;
      }
      if (a4 && a3 > a4)
      {
        log_err((uint64_t)"%s:%d: %s Quota %llu is smaller than reserve %llu\n", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"spaceman_fs_bounds_set");
LABEL_9:
        uint64_t v15 = 22;
        goto LABEL_30;
      }
      if (a4 && *(void *)(a2 + 408) + v24[11] > a4)
      {
        log_err((uint64_t)"%s:%d: %s Quota %llu is smaller than what's currently allocated and reserved %llu\n", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"spaceman_fs_bounds_set");
        uint64_t v15 = 69;
        goto LABEL_30;
      }
      if (v26 <= 0)
      {
        uint64_t v27 = v16[24];
        unint64_t v29 = v16[23] + v26;
      }
      else
      {
        uint64_t v28 = v16[23];
        uint64_t v27 = v16[24];
        if (v26 > (unint64_t)(v16[9]
                                    - v38[13].__sig
                                    + v16[30]
                                    + v16[15]
                                    + v16[35]
                                    - (*(void *)v38[13].__opaque
                                     + v28)
                                    + v27))
        {
          uint64_t v15 = 28;
          goto LABEL_30;
        }
        unint64_t v30 = v16[12] + v16[6];
        unint64_t v31 = 50;
        if (v30 >> 2 > 0x4FA) {
          unint64_t v31 = v30 / 0x64;
        }
        unint64_t v29 = v28 + v26;
        if (v29 > v30 - v31)
        {
          log_err((uint64_t)"%s:%d: %s %llu blocks are already reserved in container, Cannot reserve more than %llu blocks in the container\n", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"spaceman_fs_bounds_set");
          goto LABEL_9;
        }
      }
      unint64_t v32 = v24[11];
      if (v25 >= v32) {
        unint64_t v33 = v24[11];
      }
      else {
        unint64_t v33 = v24[9];
      }
      v24[9] = a3;
      if (v32 >= a3) {
        unint64_t v34 = a3;
      }
      else {
        unint64_t v34 = v32;
      }
      unint64_t v35 = v27 + v34;
      v16[23] = v29;
      v16[24] = v35;
      unint64_t v36 = v35 - v33;
      if (v35 < v33)
      {
        log_err((uint64_t)"%s:%d: %s sm_fs_reserve_alloc_count underflow, sm_fs_reserve_alloc_count %lld, new fs_reserve_block_count %lld, old fs_reserve_block_count %lld alloc_count %lld\n", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"spaceman_fs_bounds_set");
        unint64_t v36 = 0;
        unint64_t v24 = *(void **)(a2 + 376);
      }
      v16[24] = v36;
      v24[10] = a4;
      obj_dirty((uint64_t)v38, a5, 0);
      fs_sb_dirty(a2, a5);
      uint64_t v15 = 0;
      goto LABEL_30;
    }
  }
  return v15;
}

uint64_t spaceman_fs_bounds_clear(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v44 = 0;
  uint64_t result = spaceman_get(a1, &v44);
  if (!result)
  {
    uint64_t v11 = *(void *)&v44[5].__opaque[48];
    uint64_t result = obj_modify(v44, 0, a3, v6, v7, v8, v9, v10);
    if (!result)
    {
      pthread_mutex_lock(v44 + 6);
      pthread_mutex_lock(v44 + 9);
      uint64_t v12 = *(void **)(a2 + 376);
      unint64_t v13 = v12[9];
      unint64_t v14 = v12[11];
      unint64_t v15 = v14;
      if (v14)
      {
        obj_oid(a2);
        log_err((uint64_t)"%s:%d: %s file system %lld alloc block count is not zero: %lld/%lld\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"spaceman_fs_bounds_clear");
        uint64_t v12 = *(void **)(a2 + 376);
        if (v12[9]) {
          goto LABEL_8;
        }
      }
      else if (v13)
      {
        goto LABEL_8;
      }
      if (!v12[10])
      {
LABEL_16:
        pthread_mutex_unlock(v44 + 9);
        pthread_mutex_unlock(v44 + 6);
        obj_release(&v44->__sig);
        return 0;
      }
LABEL_8:
      if (v14 > v13)
      {
        unint64_t v23 = v12[10];
        unint64_t v15 = v13;
        if (v23)
        {
          unint64_t v15 = v13;
          if (v14 > v23) {
            sub_10005DD58();
          }
        }
      }
      unint64_t v24 = *(void *)(v11 + 184);
      BOOL v25 = v24 >= v13;
      unint64_t v26 = v24 - v13;
      if (!v25)
      {
        obj_oid(a2);
        log_err((uint64_t)"%s:%d: %s file system %lld fs reserve block count %lld larger than global fs reserve block count %lld\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"spaceman_fs_bounds_clear");
        unint64_t v26 = 0;
      }
      *(void *)(v11 + 184) = v26;
      unint64_t v34 = *(void *)(v11 + 192);
      BOOL v25 = v34 >= v15;
      unint64_t v35 = v34 - v15;
      if (!v25)
      {
        obj_oid(a2);
        log_err((uint64_t)"%s:%d: %s file system %lld fs reserve alloc count %lld larger than global fs reserve alloc count %lld\n", v36, v37, v38, v39, v40, v41, v42, (uint64_t)"spaceman_fs_bounds_clear");
        unint64_t v35 = 0;
      }
      *(void *)(v11 + 192) = v35;
      uint64_t v43 = *(void *)(a2 + 376);
      *(void *)(v43 + 72) = 0;
      *(void *)(v43 + 80) = 0;
      obj_dirty((uint64_t)v44, a3, 0);
      fs_sb_dirty(a2, a3);
      goto LABEL_16;
    }
  }
  return result;
}

uint64_t spaceman_unset_block_out_range(void *a1, uint64_t a2)
{
  uint64_t v2 = a1[47];
  if (!*(void *)(v2 + 1248)) {
    return 0;
  }
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  uint64_t v10 = spaceman_get(a1, &v16);
  if (!v10)
  {
    uint64_t v11 = *(void *)&v16[5].__opaque[48];
    uint64_t v10 = obj_modify(v16, 0, a2, v5, v6, v7, v8, v9);
    if (!v10)
    {
      uint64_t v12 = (*(void *)(v2 + 1240) << __clz(__rbit64(*(unsigned int *)(a1[47] + 36))) >> 62) & 1;
      pthread_mutex_lock(v16 + 8);
      pthread_mutex_lock(v16 + 6);
      uint64_t v10 = sub_100016B2C((uint64_t)a1, (uint64_t)v16, 2, *(void *)(v2 + 1240), *(void *)(v2 + 1248), (uint64_t)v17, &v15, v13);
      pthread_mutex_lock(v16 + 9);
      *(void *)(v11 + 48 * v12 + 72) += v15;
      pthread_mutex_unlock(v16 + 9);
      *(_OWORD *)(a1[47] + 1240) = 0u;
      pthread_mutex_unlock(v16 + 6);
      pthread_mutex_unlock(v16 + 8);
      obj_dirty((uint64_t)v16, a2, 0);
    }
    obj_release(&v16->__sig);
  }
  return v10;
}

uint64_t sub_100017D6C(uint64_t result, unsigned int a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(result + 376);
  uint64_t v5 = *(void *)(result + 8 * a2 + 1488);
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (v5)
  {
    uint64_t v8 = *(void *)(result + 1584);
    if (v8) {
      ++*(void *)(v8 + 112);
    }
    if (*(void *)(v4 + 48 * a2 + 56) - 1 == a4) {
      unint64_t v9 = *(void *)(v4 + 48 * a2 + 48) % (unint64_t)*(unsigned int *)(v4 + 36);
    }
    else {
      unint64_t v9 = *(unsigned int *)(v4 + 36);
    }
    *(_DWORD *)(v5 + 4 * a4) = (*(_DWORD *)(v5 + 4 * a4) & 0xFEFFFFFF | ((*a3 & 1) << 24)) ^ 0x1000000;
    uint64_t result = bitmap_range_find_clear_range((uint64_t)a3, 0xFFFFFFLL, 0, v9, &v12, &v11);
    if (v9 < 0x40 || (*(void *)&a3[2 * (v9 >> 6) - 2] & 0x8000000000000000) != 0) {
      unsigned int v10 = *(_DWORD *)(v5 + 4 * a4) & 0xFDFFFFFF;
    }
    else {
      unsigned int v10 = *(_DWORD *)(v5 + 4 * a4) | 0x2000000;
    }
    *(_DWORD *)(v5 + 4 * a4) = v10 & 0xFF000000 | v11 & 0xFFFFFF;
  }
  return result;
}

uint64_t sub_100017E6C(uint64_t result, uint64_t a2)
{
  if (a2 && *(unsigned char *)(a2 + 62) && !*(unsigned char *)(a2 + 63))
  {
    uint64_t v3 = result;
    v7.__darwin_time_t tv_sec = 0;
    v7.int tv_nsec = 0;
    uint64_t result = clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v7);
    __darwin_time_t tv_sec = v7.tv_sec;
    int tv_nsec = v7.tv_nsec;
    *(void *)a2 = v7.tv_sec;
    tv_nsec /= 1000;
    *(_DWORD *)(a2 + 8) = tv_nsec;
    uint64_t v6 = 1000000 * tv_sec + tv_nsec;
    *(void *)(a2 + 32) = v6;
    if (v6 - *(void *)(a2 + 24) >= 1000 * (unint64_t)*(unsigned __int16 *)(a2 + 60))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(v3 + 384) + 168), 1uLL, memory_order_relaxed);
      ++*(_DWORD *)(a2 + 56);
      *(void *)(a2 + 24) = *(void *)(a2 + 32);
    }
  }
  return result;
}

uint64_t sub_100017F3C(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a2 + 376);
  unsigned int v5 = *(_DWORD *)(v4 + 164) & 0x7FFFFFFF;
  if (v5 <= a3) {
    return 22;
  }
  unsigned int v6 = *(unsigned __int16 *)(v4 + 322);
  if (v6 == 0xFFFF)
  {
    uint64_t v7 = *(void *)(a2 + 880);
    goto LABEL_7;
  }
  if (v5 > v6)
  {
    uint64_t v7 = *(void *)(a2 + 880);
    *(_WORD *)(v7 + 2 * *(unsigned __int16 *)(v4 + 322)) = a3;
LABEL_7:
    *(_WORD *)(v7 + 2 * a3) = -1;
    *(_WORD *)(v4 + 322) = a3;
    if (*(__int16 *)(v4 + 320) == -1) {
      *(_WORD *)(v4 + 320) = a3;
    }
    obj_dirty(a2, a4, 0);
    return 0;
  }

  return nx_corruption_detected_int(a1);
}

void sub_100017FE8(uint64_t a1, uint64_t a2, unsigned int a3, unint64_t a4)
{
  uint64_t v4 = *(void *)(a2 + 376) + 40 * a3;
  unint64_t v6 = *(void *)(v4 + 200);
  unsigned int v5 = (unint64_t *)(v4 + 200);
  unint64_t v7 = v6 - a4;
  if (v6 >= a4)
  {
    *unsigned int v5 = v7;
  }
  else
  {
    if (nx_ratelimit_log_allowed(a1)) {
      log_err((uint64_t)"%s:%d: %s sfq %d count underflow %lld - %lld\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"spaceman_decrement_free_queue_count");
    }
    *(void *)(*(void *)(a2 + 376) + 40 * a3 + 200) = 0;
  }
}

uint64_t sub_1000180A4(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  uint64_t v7 = *(void *)(*(void *)(a2 + 376) + 152);
  unint64_t v9 = 0;
  uint64_t result = spaceman_ip_block_index(a1, a2, a3, (uint64_t *)&v9);
  if (result == 2) {
    return 22;
  }
  if (result) {
    return result;
  }
  if ((v7 & 0x7FFFFFFFFFFFFFFFLL) <= a4 || v9 > (v7 & 0x7FFFFFFFFFFFFFFFuLL) - a4) {
    return 22;
  }
  uint64_t result = 0;
  if (a5) {
    *a5 = v9;
  }
  return result;
}

void sub_100018124(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    if (!*(_WORD *)(a2 + 1532)) {
      return;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 512));
    unsigned int v10 = *(unsigned __int16 *)(a2 + 1532) + 16;
    unsigned int v11 = 16;
  }
  else
  {
    if (!*(_WORD *)(a2 + 1534)) {
      return;
    }
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 448));
    unsigned int v11 = 0;
    unsigned int v10 = *(unsigned __int16 *)(a2 + 1534);
  }
  sub_100017E6C(a1, a4);
  if (v11 < v10)
  {
    uint64_t v12 = 16 * v11;
    unint64_t v13 = v10 - (unint64_t)v11;
    do
    {
      dev_unmap(*(void *)(a1 + 384), *(void *)(*(void *)(a2 + 1536) + v12));
      v12 += 16;
      --v13;
    }
    while (v13);
  }
  dev_unmap_flush(*(void *)(a1 + 384));
  if (a3)
  {
    pthread_mutex_lock((pthread_mutex_t *)(a2 + 512));
    uint64_t v14 = (pthread_mutex_t *)(a2 + 384);
  }
  else
  {
    uint64_t v14 = (pthread_mutex_t *)(a2 + 448);
  }
  pthread_mutex_lock(v14);
  if (v11 < v10)
  {
    uint64_t v15 = 16 * v11;
    unint64_t v16 = v10 - (unint64_t)v11;
    do
    {
      uint64_t v17 = (unint64_t *)(*(void *)(a2 + 1536) + v15);
      unint64_t v18 = *v17;
      uint64_t v19 = v17[1];
      if (a3) {
        sub_1000184D8(a1, a2, v18, v19, 1, a5);
      }
      else {
        sub_100018280(a1, (void *)a2, v18, v19, a5);
      }
      v15 += 16;
      --v16;
    }
    while (v16);
  }
  if (a3)
  {
    pthread_mutex_unlock((pthread_mutex_t *)(a2 + 384));
    *(void *)(a2 + 1552) = 0;
    *(_WORD *)(a2 + 1532) = 0;
  }
  else
  {
    *(void *)(a2 + 1544) = 0;
    *(_WORD *)(a2 + 1534) = 0;
  }
}

void sub_100018280(uint64_t a1, void *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = a2[47];
  uint64_t v32 = 0;
  if (xid_is_current_tx(a1, a5))
  {
    unint64_t v33 = 0;
    uint64_t v30 = 0;
    uint64_t v31 = 0;
    int v11 = sub_1000180A4(a1, (uint64_t)a2, a3, a4, &v33);
    if (v11)
    {
      if (v11 == 22) {
        log_err((uint64_t)"%s:%d: %s attempt to free block(s) outside of internal pool: 0x%llx:0x%llx\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"spaceman_ip_freed");
      }
      else {
        log_err((uint64_t)"%s:%d: %s Error mapping freed IP block range 0x%llx:0x%llx to index: %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"spaceman_ip_freed");
      }
    }
    else
    {
      int v19 = 8 * *(_DWORD *)(v10 + 32);
      if (v19) {
        BOOL v20 = a4 < 1;
      }
      else {
        BOOL v20 = 1;
      }
      if (!v20)
      {
        unint64_t v21 = v19;
        unint64_t v22 = v33;
        uint64_t v28 = v10;
        do
        {
          unint64_t v23 = v22 / v21;
          unsigned int v24 = *(unsigned __int16 *)(a2[109] + 2 * (v22 / v21));
          if (spaceman_ip_bm_block_address(a1, v10, v24, &v31)
            || obj_get(*(void *)(a1 + 392), 1073741825, v31, &sm_bm_desc, 0, 0, 0, a5, &v32))
          {
            break;
          }
          uint64_t v25 = v32[7];
          unint64_t v26 = v33 % v21;
          if (a4 >= (uint64_t)(v21 - v33 % v21)) {
            uint64_t v27 = v21 - v33 % v21;
          }
          else {
            uint64_t v27 = a4;
          }
          if (*(void *)(a2[108] + 8 * v23) != a5)
          {
            uint64_t v30 = 0;
            __int16 v29 = 0;
            if (sub_10000D7D4(a1, (uint64_t)a2, a5, &v30, &v29)
              || sub_100017F3C(a1, (uint64_t)a2, v24, a5))
            {
              obj_release(v32);
              return;
            }
            uint64_t v31 = v30;
            *(_WORD *)(a2[109] + 2 * v23) = v29;
            *(void *)(a2[108] + 8 * v23) = a5;
          }
          if (!bitmap_range_is_set(v25, v26, v27)) {
            sub_10005DD84();
          }
          bitmap_clear_range(v25, v26, v27);
          obj_dirty((uint64_t)v32, a5, v31);
          obj_release(v32);
          unint64_t v22 = v33 + v27;
          v33 += v27;
          BOOL v20 = a4 <= v27;
          a4 -= v27;
          uint64_t v10 = v28;
        }
        while (!v20);
      }
    }
  }
}

uint64_t sub_1000184D8(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, char a5, uint64_t a6)
{
  if (a4) {
    spaceman_handle_metazone_freed(a1, a2, a3);
  }
  uint64_t v16 = sub_100015218(a1, 0, a2, a3, a4, a6, 1, a5);
  if (!v16)
  {
    char v17 = __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36)));
    spaceman_free_extent_cache_insert(*(void *)(a2 + (((a3 << v17) & 0x4000000000000000) >> 59) + 1568), 0, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v17) & a3, a4, v12, v13, v14, v15);
  }
  return v16;
}

unint64_t sub_100018598(unint64_t result, unsigned int a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a5;
  unint64_t v7 = result;
  uint64_t v8 = *(void *)(result + 376);
  uint64_t v9 = a2;
  unint64_t v10 = *(void *)(v8 + 48 * a2 + 56);
  uint64_t v11 = *(void *)(a4 + 8);
  uint64_t v12 = *(unsigned int *)(v8 + 36);
  uint64_t v13 = *(void *)a4 / v12;
  uint64_t v14 = result + 8 * a2;
  unsigned int v15 = *(_DWORD *)(*(void *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
  if (a3) {
    unint64_t v16 = a3;
  }
  else {
    unint64_t v16 = *(void *)(v8 + 48 * a2 + 56);
  }
  if (v10 < v16) {
    unint64_t v16 = *(void *)(v8 + 48 * a2 + 56);
  }
  if (v12 >= 0xFFFFFF) {
    int v17 = 0xFFFFFF;
  }
  else {
    int v17 = *(_DWORD *)(v8 + 36);
  }
  if (v15 == v17 || v16 < 2)
  {
    unint64_t v19 = *(void *)a4 / v12;
    LODWORD(v14) = *(_DWORD *)(*(void *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
    goto LABEL_37;
  }
  BOOL v20 = (uint64_t *)(v14 + 1488);
  unint64_t v21 = v16 - 1;
  unint64_t v22 = v13 + 1;
  unsigned int v23 = *(_DWORD *)(*(void *)(v14 + 1488) + 4 * v13) & 0xFFFFFF;
  uint64_t v24 = *(void *)a4 / v12;
  do
  {
    unint64_t v19 = v22 % v10;
    uint64_t v25 = *v20;
    int v26 = *(_DWORD *)(*v20 + 4 * (v22 % v10));
    LODWORD(v14) = v26 & 0xFFFFFF;
    if ((v26 & 0xFFFFFFu) > v15)
    {
      uint64_t v13 = v22 % v10;
      unsigned int v15 = v26 & 0xFFFFFF;
    }
    if (v14 > v23)
    {
      if (*(unsigned char *)(a4 + 16))
      {
        if ((v26 & 0xC000000) != 0) {
          goto LABEL_34;
        }
        uint64_t v27 = *(void *)(v7 + 376);
        uint64_t v28 = v27 + 48 * v9;
        unint64_t v29 = *(void *)(v28 + 56);
        if (v29 > v19)
        {
          uint64_t v30 = *(void *)(a4 + 32);
          if (v30)
          {
            uint64_t v47 = v24;
            unint64_t v48 = v7;
            uint64_t v49 = v9;
            uint64_t v50 = v11;
            uint64_t v51 = v8;
            unint64_t v31 = *(unsigned int *)(v27 + 36);
            uint64_t v32 = v31;
            if (v29 - 1 == v19) {
              uint64_t v32 = *(void *)(v28 + 48) % v31;
            }
            uint64_t result = calc_overlap_range(v19 * v31, v32, *(void *)(a4 + 24), v30, 0);
            uint64_t v11 = v50;
            uint64_t v8 = v51;
            unint64_t v7 = v48;
            uint64_t v9 = v49;
            uint64_t v24 = v47;
            if (result) {
              goto LABEL_34;
            }
            LODWORD(v14) = *(_DWORD *)(v25 + 4 * v19) & 0xFFFFFF;
          }
        }
      }
      LODWORD(v12) = *(_DWORD *)(v8 + 36);
      if (v12 >= 0xFFFFFF) {
        int v33 = 0xFFFFFF;
      }
      else {
        int v33 = *(_DWORD *)(v8 + 36);
      }
      if (v11 <= v14 || v14 == v33) {
        goto LABEL_36;
      }
      uint64_t v24 = v22 % v10;
      unsigned int v23 = v14;
    }
LABEL_34:
    ++v22;
    --v21;
  }
  while (v21);
  LODWORD(v12) = *(_DWORD *)(v8 + 36);
  unint64_t v19 = v24;
  LODWORD(v14) = v23;
LABEL_36:
  uint64_t v12 = v12;
  uint64_t v5 = a5;
LABEL_37:
  unint64_t v35 = v19 * v12;
  if (v11 >= v14) {
    uint64_t v14 = v14;
  }
  else {
    uint64_t v14 = v11;
  }
  *(void *)uint64_t v5 = v35;
  *(void *)(v5 + 8) = v14;
  char v36 = *(unsigned char *)(a4 + 16);
  if (v36)
  {
    uint64_t v37 = *(void *)(v7 + 376);
    uint64_t v38 = v37 + 48 * v9;
    unint64_t v39 = *(void *)(v38 + 56);
    if (v39 > v19 && (uint64_t v40 = *(void *)(a4 + 32)) != 0)
    {
      unint64_t v41 = *(unsigned int *)(v37 + 36);
      unint64_t v42 = v19 * v41;
      if (v39 - 1 == v19) {
        unint64_t v41 = *(void *)(v38 + 48) % v41;
      }
      unint64_t v43 = *(void *)(a4 + 24);
      uint64_t v44 = v8;
      uint64_t v45 = v11;
      uint64_t result = calc_overlap_range(v42, v41, v43, v40, 0);
      uint64_t v11 = v45;
      uint64_t v8 = v44;
      char v36 = result == 0;
    }
    else
    {
      char v36 = 1;
    }
  }
  *(unsigned char *)(v5 + 16) = v36;
  if (v19 != v13)
  {
    uint64_t v46 = v15;
    if (v11 < v15) {
      uint64_t v46 = v11;
    }
    *(void *)(v5 + 24) = v13 * *(unsigned int *)(v8 + 36);
    *(void *)(v5 + 32) = v46;
    *(unsigned char *)(v5 + 40) = 0;
  }
  return result;
}

uint64_t sub_100018810(uint64_t a1, pthread_mutex_t *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v8 = 22;
  if (xid_is_current_tx(a1, a4))
  {
    pthread_mutex_lock(a2 + 7);
    unsigned int v9 = spaceman_ip_block_index(a1, (uint64_t)a2, a3, &v11);
    if (v9 == 2) {
      uint64_t v8 = 22;
    }
    else {
      uint64_t v8 = v9;
    }
    if (!v8) {
      uint64_t v8 = sub_100016740(a1, (uint64_t)a2, 0, a3, 1, a4);
    }
    pthread_mutex_unlock(a2 + 7);
  }
  return v8;
}

uint64_t omap_key_cmp(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }
      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }
    else
    {
      int v7 = -1;
    }
    uint64_t result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t omap_snapshot_key_cmp(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

uint64_t omap_map_tree_get(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v9 = *(void *)(a2 + 472);
  if ((a3 & 1) == 0 && v9)
  {
    *a5 = v9;
    obj_retain(v9);
    return 0;
  }
  if (v9)
  {
    *a5 = v9;
    obj_retain(v9);
    if ((a3 & 1) == 0)
    {
LABEL_6:
      if (obj_oid(*a5) != *(void *)(*(void *)(a2 + 376) + 48)) {
        sub_10005DDB0();
      }
      return 0;
    }
    uint64_t v21 = obj_modify((void *)*a5, (*(_DWORD *)(*(void *)(a2 + 376) + 40) >> 29) & 2, a4, v10, v11, v12, v13, v14);
    if (v21)
    {
      uint64_t extended = v21;
      obj_release((uint64_t *)*a5);
      *a5 = 0;
      return extended;
    }
LABEL_18:
    if (obj_oid(*a5) != *(void *)(*(void *)(a2 + 376) + 48))
    {
      *(void *)(*(void *)(a2 + 376) + 48) = obj_oid(*a5);
      obj_dirty(a2, a4, 0);
    }
    goto LABEL_6;
  }
  uint64_t v17 = *(void *)(a2 + 376);
  int v18 = *(_DWORD *)(v17 + 40);
  uint64_t v19 = *(void *)(v17 + 48);
  v22[1] = 0;
  long long v23 = 0u;
  uint64_t v27 = 0;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  v22[0] = omap_key_cmp;
  v22[2] = 0x20000000BLL;
  if ((unsigned __int16)v18 != 2) {
    return 22;
  }
  uint64_t extended = btree_get_extended(a1, v18 & 0xFFFF0000, v19, 0, a3, v22, a4, a5);
  if (!extended)
  {
    uint64_t v20 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)(a2 + 472), (unint64_t *)&v20, *a5);
    if (!v20) {
      obj_retain(*a5);
    }
    if ((a3 & 1) == 0) {
      goto LABEL_6;
    }
    goto LABEL_18;
  }
  return extended;
}

uint64_t sub_100018B1C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    return 22;
  }
  uint64_t result = 0;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)a3;
  *(void *)(a1 + 40) = *(void *)(a3 + 4);
  return result;
}

uint64_t sub_100018B44(void *a1)
{
  uint64_t v2 = a1[7];
  int v3 = *(_DWORD *)(v2 + 44);
  BOOL v4 = v3 == 1073741826 || v3 == -2147483646;
  if (v4 && ((int v5 = *(_DWORD *)(v2 + 40), v5 != -2147483646) ? (v6 = v5 == 1073741826) : (v6 = 1), v6)
    || (uint64_t result = nx_corruption_detected_int(*(void *)(*a1 + 392)), !result))
  {
    uint64_t result = 0;
    a1[47] = v2;
  }
  return result;
}

uint64_t sub_100018BBC(void *a1)
{
  uint64_t v2 = (uint64_t *)a1[59];
  if (v2 && !*(_DWORD *)(*a1 + 912)) {
    obj_release(v2);
  }
  return 0;
}

uint64_t sub_100018BF0(uint64_t *a1, char a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = a5;
  uint64_t v11 = a1[47];
  uint64_t v12 = (void *)a1[1];
  uint64_t v13 = *(void *)(*a1 + 392);
  if (v12) {
    uint64_t v14 = (void *)a1[1];
  }
  else {
    uint64_t v14 = *(void **)(*a1 + 392);
  }
  uint64_t v227 = 0;
  unint64_t v228 = 0;
  uint64_t v225 = 0;
  unsigned int v226 = 0;
  unsigned int v15 = *(_DWORD *)(*(void *)(v13 + 376) + 36);
  if ((a2 & 2) == 0)
  {
    if (*a3)
    {
      if (v12) {
        goto LABEL_7;
      }
    }
    else
    {
      *a3 = 1;
      if (v12)
      {
LABEL_7:
        uint64_t extended = obj_modify(v12, 0, a5, a4, a5, a6, a7, a8);
        if (extended)
        {
          obj_type((uint64_t)v12);
          log_err((uint64_t)"%s:%d: %s obj_modify() failed: %d\n", v30, v31, v32, v33, v34, v35, v36, (uint64_t)"omap_reap");
        }
LABEL_25:
        int v37 = *a3;
        if (*a3 == 1)
        {
          uint64_t v242 = 0;
          *(void *)&v231[0] = 0;
          spaceman_currently_available_space((uint64_t)v14, (unint64_t *)&v242, (unint64_t *)v231, 0, 0);
          uint64_t v38 = omap_map_tree_get((uint64_t)v14, (uint64_t)a1, 0, 0, (uint64_t *)&v226);
          if (v38)
          {
            uint64_t extended = v38;
            obj_type((uint64_t)v14);
            log_err((uint64_t)"%s:%d: %s failed to get omap tree for reaping: %d\n", v52, v53, v54, v55, v56, v57, v58, (uint64_t)"omap_reap");
            return extended;
          }
          unsigned int v39 = v15;
          unint64_t v40 = 0;
          uint64_t v41 = 1024;
          if (*(void *)&v231[0] < 0x7D1uLL) {
            uint64_t v41 = 102;
          }
          uint64_t v42 = 51;
          if (*(void *)&v231[0] >= 0x3E9uLL) {
            uint64_t v42 = v41;
          }
          unint64_t v218 = v42;
          uint64_t v225 = 0x1000000010;
          unsigned int v220 = v39;
          unsigned int v213 = v39 - 1;
          while (1)
          {
            uint64_t v43 = bt_lookup_variant(v226, 0, (unint64_t *)a3 + 1, (unsigned int *)&v225 + 1, 0x10u, &v227, (unsigned int *)&v225, 4u, 0, 0);
            if (v43) {
              break;
            }
            if (v227)
            {
              uint64_t v225 = 0x1000000010;
            }
            else
            {
              uint64_t v44 = (v213 + HIDWORD(v227)) / v220;
              if (spaceman_free(v14, 0, v228, v44, v8))
              {
                obj_type((uint64_t)v14);
                log_err((uint64_t)"%s:%d: %s spaceman_free(%lld, %lld) failed: %d\n", v45, v46, v47, v48, v49, v50, v51, (uint64_t)"omap_reap");
              }
              obj_cache_remove(*(pthread_mutex_t **)(v13 + 392), (uint64_t)v12, *((void *)a3 + 1), *((void *)a3 + 2));
              v40 += v44;
              if (v40 >= v218)
              {
                uint64_t extended = 36;
                goto LABEL_51;
              }
              uint64_t v225 = 0x1000000010;
            }
          }
          uint64_t extended = v43;
          if (v43 != 36)
          {
            uint64_t extended = btree_delete((uint64_t)v226, v8, 0);
            if (extended)
            {
              obj_type((uint64_t)v14);
              log_err((uint64_t)"%s:%d: %s tree_delete() failed: %d\n", v68, v69, v70, v71, v72, v73, v74, (uint64_t)"omap_reap");
            }
            *a3 = 2;
          }
LABEL_51:
          obj_release(v226);
          int v37 = *a3;
        }
        if (v37 != 2) {
          return extended;
        }
        unint64_t v75 = *(void *)(v11 + 56);
        if (v75)
        {
          int v76 = *(_DWORD *)(v11 + 44);
          long long v243 = 0u;
          uint64_t v248 = 0;
          long long v247 = 0u;
          long long v246 = 0u;
          long long v245 = 0u;
          long long v244 = 0u;
          uint64_t v242 = omap_snapshot_key_cmp;
          DWORD2(v243) = 19;
          if ((unsigned __int16)v76 == 2)
          {
            uint64_t extended = btree_get_extended((uint64_t)v14, v76 & 0xFFFF0000, v75, 0, 0, (uint64_t)&v242, 0, &v226);
            if (!extended)
            {
              uint64_t extended = btree_delete((uint64_t)v226, v8, 0);
              if (extended)
              {
                obj_type((uint64_t)v14);
                log_err((uint64_t)"%s:%d: %s tree_delete() failed: %d\n", v146, v147, v148, v149, v150, v151, v152, (uint64_t)"omap_reap");
              }
              obj_release(v226);
              goto LABEL_60;
            }
          }
          else
          {
            uint64_t extended = 22;
          }
          obj_type((uint64_t)v14);
          log_err((uint64_t)"%s:%d: %s failed to get omap snapshot tree for reaping: %d\n", v77, v78, v79, v80, v81, v82, v83, (uint64_t)"omap_reap");
        }
LABEL_60:
        obj_delete_and_free(a1, v8);
        *a3 = -1;
        return extended;
      }
    }
    uint64_t extended = 0;
    goto LABEL_25;
  }
  int v240 = 0;
  unint64_t v241 = 0;
  v238[1] = 0;
  BOOL v239 = 0;
  v238[0] = 0;
  long long v237 = 0uLL;
  long long v236 = 0uLL;
  long long v235 = 0uLL;
  long long v234 = 0uLL;
  uint64_t v232 = 0;
  uint64_t v233 = 0;
  memset(v231, 0, sizeof(v231));
  unint64_t v229 = 0;
  unint64_t v230 = 0;
  spaceman_currently_available_space((uint64_t)v14, &v230, &v229, 0, 0);
  if (v229 >= 0x7D1) {
    int v17 = 1024;
  }
  else {
    int v17 = 102;
  }
  if (v229 >= 0x3E9) {
    int v18 = v17;
  }
  else {
    int v18 = 51;
  }
  obj_lock((uint64_t)a1, 2u);
  int v19 = *((_DWORD *)a1 + 96);
  if (v19) {
    sub_10005DF68();
  }
  *((_DWORD *)a1 + 96) = v19 | 1;
  unsigned int v20 = sub_10001B5A0(v14, a1, v8);
  if (v20)
  {
    unsigned int v21 = v20;
    obj_type((uint64_t)v14);
    log_err((uint64_t)"%s:%d: %s error modifying omap: %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"omap_cleanup");
    if (v21 == 28) {
      uint64_t extended = 36;
    }
    else {
      uint64_t extended = v21;
    }
    goto LABEL_44;
  }
  unsigned int v223 = v18;
  uint64_t v29 = omap_map_tree_get((uint64_t)v14, (uint64_t)a1, 1, v8, (uint64_t *)&v239);
  if (v29)
  {
    uint64_t extended = v29;
    obj_type((uint64_t)v14);
    log_err((uint64_t)"%s:%d: %s error getting mapping tree: %d\n", v61, v62, v63, v64, v65, v66, v67, (uint64_t)"omap_cleanup");
    goto LABEL_44;
  }
  int v59 = *a3;
  if (*a3)
  {
    unsigned int v60 = 0;
  }
  else
  {
    obj_unlock((uint64_t)a1, 2u);
    long long v237 = 0uLL;
    uint64_t v233 = 0x1000000010;
    bt_iterator_init_with_hint((uint64_t)v231, v239, 0, 0, (unint64_t *)&v237, 16, 0x10u, &v235, 0x10u, 0);
    unsigned int v60 = 0;
    if (!bt_iterator_ended((uint64_t)v231))
    {
      unsigned int v60 = 0;
      uint64_t v215 = v11;
      do
      {
        if ((unint64_t)v237 >= *(void *)(v11 + 88)) {
          break;
        }
        if (bt_remove(v239, 0, (unint64_t *)&v237, 0x10u, v8))
        {
          obj_type((uint64_t)v14);
          log_err((uint64_t)"%s:%d: %s remove mapping (%lld, %lld) below watermark failed: %d\n", v97, v98, v99, v100, v101, v102, v103, (uint64_t)"omap_cleanup");
        }
        if ((v235 & 1) == 0)
        {
          if (spaceman_free(v14, 0, *((unint64_t *)&v235 + 1), (v15 - 1 + DWORD1(v235)) / v15, v8))
          {
            obj_type((uint64_t)v14);
            log_err((uint64_t)"%s:%d: %s spaceman_free(%lld, %d) failed: %d\n", v104, v105, v106, v107, v108, v109, v110, (uint64_t)"omap_cleanup");
          }
          obj_cache_remove(*(pthread_mutex_t **)(v13 + 392), (uint64_t)v12, v237, *((uint64_t *)&v237 + 1));
          uint64_t v11 = v215;
        }
        if (v18 == v60)
        {
          obj_lock((uint64_t)a1, 2u);
          uint64_t extended = 36;
          goto LABEL_44;
        }
        ++v60;
        bt_iterator_next((uint64_t)v231);
      }
      while (!bt_iterator_ended((uint64_t)v231));
    }
    obj_lock((uint64_t)a1, 2u);
    int v59 = *a3;
  }
  unint64_t v85 = *(void *)(v11 + 56);
  if (!v85)
  {
    if (v59) {
      sub_10005DDDC();
    }
    goto LABEL_78;
  }
  unsigned int v221 = v15;
  if (v59 && *((void *)a3 + 4) != -1) {
    goto LABEL_67;
  }
  int v87 = *(_DWORD *)(v11 + 44);
  long long v243 = 0u;
  uint64_t v248 = 0;
  long long v247 = 0u;
  long long v246 = 0u;
  long long v245 = 0u;
  long long v244 = 0u;
  uint64_t v242 = omap_snapshot_key_cmp;
  DWORD2(v243) = 19;
  if ((unsigned __int16)v87 != 2)
  {
    uint64_t extended = 22;
    goto LABEL_80;
  }
  uint64_t extended = btree_get_extended((uint64_t)v14, v87 & 0xFFFF0000, v85, 0, 0, (uint64_t)&v242, v8, &v240);
  if (extended)
  {
LABEL_80:
    obj_type((uint64_t)v14);
    log_err((uint64_t)"%s:%d: %s unable to get snapshot tree: %d\n", v90, v91, v92, v93, v94, v95, v96, (uint64_t)"omap_cleanup");
    goto LABEL_44;
  }
  if (!*a3)
  {
    uint64_t v217 = v11;
    uint64_t v175 = v8;
    *((void *)a3 + 2) = 0;
    *((void *)a3 + 3) = 0;
    unint64_t v176 = (uint64_t *)(a3 + 4);
    unint64_t v241 = 0;
    uint64_t v233 = 0x800000010;
    bt_iterator_init_with_hint((uint64_t)v231, v240, 0, 0, &v241, 8, 8u, v238, 0x10u, 0);
    while (!bt_iterator_ended((uint64_t)v231))
    {
      int v177 = v238[0];
      uint64_t v178 = *v176;
      if (v238[0])
      {
        if (v178)
        {
          if (((a3[1] ^ LODWORD(v238[0])) & 2) != 0) {
            break;
          }
          *((void *)a3 + 3) = v241;
        }
        else
        {
          unint64_t v179 = v241;
          *((void *)a3 + 2) = v241;
          *((void *)a3 + 3) = v179;
          a3[1] = v177;
        }
      }
      else if (v178)
      {
        goto LABEL_177;
      }
      bt_iterator_next((uint64_t)v231);
    }
    uint64_t v178 = *v176;
    if (*v176)
    {
LABEL_177:
      *((void *)a3 + 1) = v178;
      uint64_t v233 = 0x800000010;
      uint64_t v180 = bt_lookup_variant(v240, 0, (unint64_t *)a3 + 1, (unsigned int *)&v233 + 1, 8u, v238, (unsigned int *)&v233, 2u, 0, 0);
      uint64_t v8 = v175;
      uint64_t v11 = v217;
      if (v180)
      {
        uint64_t extended = v180;
        if (v180 != 2) {
          goto LABEL_193;
        }
        *((void *)a3 + 1) = 0;
      }
      *((void *)a3 + 5) = 0;
      *((void *)a3 + 6) = 0;
      obj_type((uint64_t)v14);
      log_debug((uint64_t)"%s:%d: %s started cleaning snapshots %lld-%lld\n", v181, v182, v183, v184, v185, v186, v187, (uint64_t)"omap_cleanup");
      a1[60] = *((void *)a3 + 1);
      unint64_t v89 = *((void *)a3 + 3);
      a1[61] = v89;
      *a3 = 1;
      *((_DWORD *)a1 + 96) |= 2u;
      unsigned int v88 = (unint64_t *)(a3 + 8);
      goto LABEL_190;
    }
LABEL_78:
    uint64_t extended = 0;
    goto LABEL_44;
  }
  unsigned int v88 = (unint64_t *)(a3 + 8);
  if (*((void *)a3 + 4) != -1) {
    goto LABEL_67;
  }
  unint64_t v89 = *((void *)a3 + 3);
LABEL_190:
  unint64_t *v88 = v89;
  uint64_t v233 = 0x800000010;
  uint64_t v188 = bt_lookup_variant(v240, 0, v88, (unsigned int *)&v233 + 1, 8u, v238, (unsigned int *)&v233, 4u, 0, 0);
  if (v188)
  {
    uint64_t extended = v188;
    if (v188 == 2)
    {
      unint64_t *v88 = -1;
      goto LABEL_67;
    }
LABEL_193:
    obj_type((uint64_t)v14);
    log_err((uint64_t)"%s:%d: %s error searching snapshot tree: %d\n", v190, v191, v192, v193, v194, v195, v196, (uint64_t)"omap_cleanup");
    goto LABEL_44;
  }
LABEL_67:
  if (v240)
  {
    obj_release(v240);
    int v240 = 0;
  }
  unsigned int v219 = a3[1];
  unint64_t v212 = *((void *)a3 + 3);
  unint64_t v214 = *((void *)a3 + 1);
  unint64_t v211 = *((void *)a3 + 4);
  long long v237 = *(_OWORD *)(a3 + 10);
  uint64_t v233 = 0x1000000010;
  uint64_t v86 = bt_lookup_variant(v239, 0, (unint64_t *)&v237, (unsigned int *)&v233 + 1, 0x10u, &v235, (unsigned int *)&v233, 3u, 0, 0);
  if (v86)
  {
    uint64_t extended = v86;
    if (v86 != 2) {
      goto LABEL_44;
    }
    *(void *)&long long v237 = 0;
  }
  else
  {
    if (HIDWORD(v233) != 16) {
      sub_10005DF3C();
    }
    if (v233 != 16) {
      sub_10005DF10();
    }
  }
  obj_unlock((uint64_t)a1, 2u);
  uint64_t v111 = v237;
  if (!(void)v237)
  {
    obj_lock((uint64_t)a1, 2u);
    goto LABEL_142;
  }
  uint64_t v216 = v11;
  uint64_t v112 = 0;
  uint64_t v222 = 0;
  do
  {
    if (v235) {
      sub_10005DEE4();
    }
    uint64_t v113 = v112;
    if (v111 != v222)
    {
      if (v60 >= v223)
      {
        uint64_t extended = 36;
        goto LABEL_165;
      }
      uint64_t v113 = 0;
    }
    uint64_t v222 = v111;
    long long v236 = v237;
    uint64_t v233 = 0x1000000010;
    uint64_t v114 = bt_lookup_variant(v239, 0, (unint64_t *)&v236, (unsigned int *)&v233 + 1, 0x10u, &v234, (unsigned int *)&v233, 4u, 0, 0);
    if (v114)
    {
      uint64_t extended = v114;
      if (v114 == 2)
      {
        *(void *)&long long v236 = 0;
        goto LABEL_105;
      }
      obj_type((uint64_t)v14);
      log_err((uint64_t)"%s:%d: %s lookup returned unexpected error while iterating: %d\n", v168, v169, v170, v171, v172, v173, v174, (uint64_t)"omap_cleanup");
LABEL_165:
      *(_OWORD *)(a3 + 10) = v237;
      obj_lock((uint64_t)a1, 2u);
      goto LABEL_44;
    }
    if (HIDWORD(v233) != 16) {
      sub_10005DEB8();
    }
    if (v233 != 16) {
      sub_10005DE8C();
    }
LABEL_105:
    uint64_t v112 = (v113 + 1);
    if (*((void *)&v237 + 1) <= v214 || *((void *)&v237 + 1) > v212)
    {
      if ((v219 & 2) == 0 || (void)v236 != (void)v237)
      {
        uint64_t extended = 0;
        int v115 = 0;
        goto LABEL_126;
      }
      uint64_t extended = 0;
      if (*((void *)&v236 + 1) > v214 && *((void *)&v236 + 1) <= v211)
      {
        uint64_t extended = 0;
        int v115 = v234 & 1;
        goto LABEL_126;
      }
LABEL_118:
      int v115 = 0;
      goto LABEL_126;
    }
    if ((v219 & 2) == 0)
    {
      uint64_t extended = 0;
      if ((void)v236 != (void)v237) {
        goto LABEL_118;
      }
      int v115 = 0;
      if (*((void *)&v236 + 1) > v211) {
        goto LABEL_126;
      }
    }
    if (bt_remove(v239, 0, (unint64_t *)&v237, 0x10u, v8))
    {
      obj_type((uint64_t)v14);
      log_err((uint64_t)"%s:%d: %s remove mapping (%lld, %lld) failed: %d\n", v116, v117, v118, v119, v120, v121, v122, (uint64_t)"omap_cleanup");
    }
    uint64_t extended = spaceman_free(v14, 0, *((unint64_t *)&v235 + 1), (v221 - 1 + DWORD1(v235)) / v221, v8);
    if (extended)
    {
      obj_type((uint64_t)v14);
      log_err((uint64_t)"%s:%d: %s spaceman_free(%lld, %d) failed: %d\n", v123, v124, v125, v126, v127, v128, v129, (uint64_t)"omap_cleanup");
    }
    if ((v219 & 2) == 0) {
      obj_cache_remove(*(pthread_mutex_t **)(v13 + 392), (uint64_t)v12, v237, *((uint64_t *)&v237 + 1));
    }
    int v130 = (v219 >> 1) & 1;
    if (!v113) {
      LOBYTE(v130) = 1;
    }
    int v115 = (v234 & v130);
    uint64_t v112 = v113;
LABEL_126:
    if (v234)
    {
      if (v115 && bt_remove(v239, 0, (unint64_t *)&v236, 0x10u, v8))
      {
        obj_type((uint64_t)v14);
        log_err((uint64_t)"%s:%d: %s remove mapping (%lld, %lld) failed: %d\n", v131, v132, v133, v134, v135, v136, v137, (uint64_t)"omap_cleanup");
      }
      uint64_t v233 = 0x1000000010;
      uint64_t v138 = bt_lookup_variant(v239, 0, (unint64_t *)&v236, (unsigned int *)&v233 + 1, 0x10u, &v234, (unsigned int *)&v233, 4u, 0, 0);
      if (v138)
      {
        uint64_t extended = v138;
        if (v138 == 2)
        {
          uint64_t extended = 0;
          *(void *)&long long v236 = 0;
        }
        else
        {
          obj_type((uint64_t)v14);
          log_err((uint64_t)"%s:%d: %s lookup returned unexpected error while iterating: %d\n", v139, v140, v141, v142, v143, v144, v145, (uint64_t)"omap_cleanup");
        }
      }
      else
      {
        if (HIDWORD(v233) != 16) {
          sub_10005DE60();
        }
        if (v233 != 16) {
          sub_10005DE34();
        }
        uint64_t extended = 0;
      }
    }
    ++v60;
    long long v237 = v236;
    long long v235 = v234;
    uint64_t v111 = v236;
  }
  while ((void)v236);
  obj_lock((uint64_t)a1, 2u);
  uint64_t v11 = v216;
  if (extended) {
    goto LABEL_44;
  }
LABEL_142:
  int v153 = *(_DWORD *)(v11 + 44);
  unint64_t v154 = *(void *)(v11 + 56);
  long long v243 = 0u;
  uint64_t v248 = 0;
  long long v247 = 0u;
  long long v246 = 0u;
  long long v245 = 0u;
  long long v244 = 0u;
  uint64_t v242 = omap_snapshot_key_cmp;
  DWORD2(v243) = 19;
  if ((unsigned __int16)v153 != 2)
  {
    uint64_t extended = 22;
    goto LABEL_80;
  }
  uint64_t extended = btree_get_extended((uint64_t)v14, v153 & 0xFFFF0000, v154, 0, 1u, (uint64_t)&v242, v8, &v240);
  if (extended) {
    goto LABEL_80;
  }
  if (obj_oid((uint64_t)v240) != *(void *)(v11 + 56))
  {
    *(void *)(v11 + 56) = obj_oid((uint64_t)v240);
    obj_dirty((uint64_t)a1, v8, 0);
  }
  unint64_t v241 = v214;
  uint64_t v224 = (void *)(v11 + 72);
  while (1)
  {
    uint64_t v233 = 0x800000010;
    uint64_t v155 = bt_lookup_variant(v240, 0, &v241, (unsigned int *)&v233 + 1, 8u, v238, (unsigned int *)&v233, 4u, 0, 0);
    if (v155) {
      break;
    }
    unint64_t v156 = v241;
    unint64_t v157 = v211;
    if (v241 < v211)
    {
      if ((v238[0] & 1) == 0) {
        sub_10005DE08();
      }
      uint64_t v158 = bt_remove(v240, 0, &v241, HIDWORD(v233), v8);
      if (v158)
      {
        uint64_t extended = v158;
        obj_type((uint64_t)v14);
        log_err((uint64_t)"%s:%d: %s error updating snapshot tree: %d\n", v197, v198, v199, v200, v201, v202, v203, (uint64_t)"omap_cleanup");
        goto LABEL_44;
      }
      --*(_DWORD *)(v11 + 36);
      obj_type((uint64_t)v14);
      log_debug((uint64_t)"%s:%d: %s completed cleaning snapshot %lld, om_snap_count %d om_most_recent_snap %lld\n", v159, v160, v161, v162, v163, v164, v165, (uint64_t)"omap_cleanup");
      if ((v219 & 2) != 0 && v241 >= *v224)
      {
        unint64_t v166 = *(void *)(v11 + 80);
        BOOL v167 = v241 >= v166;
        if (v241 <= v166)
        {
          void *v224 = v241;
          if (v167)
          {
            void *v224 = 0;
            *(void *)(v11 + 80) = 0;
          }
        }
      }
      obj_dirty((uint64_t)a1, v8, 0);
      unint64_t v156 = v241;
      unint64_t v157 = v211;
    }
    if (v156 >= v157) {
      goto LABEL_183;
    }
  }
  uint64_t extended = v155;
  if (v155 != 2) {
    goto LABEL_193;
  }
LABEL_183:
  if (v12 && (v219 & 2) != 0) {
    obj_cache_remove_reverted_fs_objects(*(void *)(v13 + 392), (uint64_t)v12, v214 + 1, v212);
  }
  if (*(_DWORD *)(v11 + 36))
  {
    unint64_t v241 = -1;
    uint64_t v233 = 0x800000010;
    uint64_t extended = bt_lookup_variant(v240, 0, &v241, (unsigned int *)&v233 + 1, 8u, v238, (unsigned int *)&v233, 1u, 0, 0);
    if (extended) {
      goto LABEL_44;
    }
    *(void *)(v11 + 64) = v241;
  }
  else
  {
    *(void *)(v11 + 64) = 0;
    uint64_t v189 = btree_delete((uint64_t)v240, v8, 0);
    if (v189)
    {
      uint64_t extended = v189;
      obj_type((uint64_t)v14);
      log_err((uint64_t)"%s:%d: %s error deleting empty snapshot tree: %d\n", v204, v205, v206, v207, v208, v209, v210, (uint64_t)"omap_cleanup");
      goto LABEL_44;
    }
    *(void *)(v11 + 56) = 0;
    obj_dirty((uint64_t)a1, v8, 0);
  }
  *a3 = 0;
  *((_DWORD *)a1 + 96) &= ~2u;
  a1[60] = 0;
  a1[61] = 0;
  if (*(void *)(v11 + 56)) {
    uint64_t extended = 36;
  }
  else {
    uint64_t extended = 0;
  }
LABEL_44:
  *((_DWORD *)a1 + 96) &= ~1u;
  obj_unlock((uint64_t)a1, 2u);
  if (v240) {
    obj_release(v240);
  }
  if (v239) {
    obj_release(v239);
  }
  return extended;
}

uint64_t omap_create(pthread_mutex_t **a1, unsigned int a2, unsigned int a3, int a4, uint64_t a5, void *a6)
{
  if (obj_type((uint64_t)a1) == 13) {
    uint64_t v12 = (uint64_t)a1;
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v13 = a1;
  if (v12) {
    uint64_t v13 = *(pthread_mutex_t ***)(v12 + 392);
  }
  unsigned int v21 = 0;
  uint64_t v22 = 0;
  if (!v13) {
    sub_10005DF94();
  }
  if (a3 >= 2) {
    sub_10005DFC0();
  }
  *a6 = 0;
  uint64_t extended = 22;
  if (a2 >> 30 && (a2 & 0x8000000) == 0 && (a4 == 1073741826 || a4 == -2147483646))
  {
    v20[0] = a3;
    v20[1] = a4;
    v20[2] = 1073741826;
    uint64_t extended = obj_create(v13[49], a2 & 0xFFFF0000, 0, (unsigned int *)&om_desc, (uint64_t)v20, v12, a5, (uint64_t *)&v22);
    if (!extended)
    {
      v23[1] = 0;
      long long v24 = 0u;
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v25 = 0u;
      v23[0] = (uint64_t)omap_key_cmp;
      v23[2] = 0x20000000BLL;
      if (a4 < 0) {
        unsigned int v15 = 0x80000000;
      }
      else {
        unsigned int v15 = 0x40000000;
      }
      uint64_t extended = btree_create_extended(a1, v15 | a4 & 0xFFFF0000, 0, 0x10u, 16, v23, a5, (uint64_t *)&v21);
      if (extended)
      {
        obj_delete_and_free(v22, a5);
        obj_release(v22);
      }
      else
      {
        unint64_t v16 = v21;
        *(_DWORD *)(v22[47] + 40) = a4;
        uint64_t v17 = obj_oid((uint64_t)v16);
        int v18 = v22;
        *(void *)(v22[47] + 48) = v17;
        obj_dirty((uint64_t)v18, a5, 0);
        obj_release(v21);
        uint64_t extended = 0;
        if (v22) {
          *a6 = v22;
        }
      }
    }
  }
  return extended;
}

uint64_t omap_destroy(uint64_t a1, unint64_t a2, uint64_t a3, void *a4)
{
  if (obj_type(a1) == 13) {
    uint64_t v8 = a1;
  }
  else {
    uint64_t v8 = 0;
  }
  if (!v8)
  {
    long long v24 = 0;
    uint64_t v9 = a1;
    if (a1) {
      goto LABEL_9;
    }
LABEL_22:
    sub_10005DFEC();
  }
  uint64_t v9 = *(void *)(v8 + 392);
  long long v24 = 0;
  if (!v9) {
    goto LABEL_22;
  }
  if (*(void *)(v8 + 496)) {
    sub_10005E018();
  }
LABEL_9:
  if (!xid_is_current_tx(v9, a3)) {
    return 22;
  }
  uint64_t v10 = obj_get(*(void *)(v9 + 392), 0x40000000, a2, (int *)&om_desc, 0, v8, 0, a3, (uint64_t *)&v24);
  if (!v10)
  {
    if (v8) {
      uint64_t v11 = obj_oid(v8);
    }
    else {
      uint64_t v11 = 0;
    }
    int v12 = obj_type_and_flags((uint64_t)v24);
    int v13 = obj_size_phys((uint64_t)v24);
    uint64_t v14 = obj_oid((uint64_t)v24);
    if (a4) {
      uint64_t v15 = nx_reaper_add(v9, v12, v13, v11, v14, a3, 0, a4);
    }
    else {
      uint64_t v15 = nx_reaper_add_sub_object(v9, v12, v13, v11, v14, a3, 0);
    }
    uint64_t v10 = v15;
    if (v15)
    {
      obj_type(a1);
      obj_oid((uint64_t)v24);
      obj_type_and_flags((uint64_t)v24);
      log_err((uint64_t)"%s:%d: %s error adding omap 0x%llx type 0x%x to reap list: %d\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"omap_destroy");
    }
    obj_release(v24);
  }
  return v10;
}

uint64_t omap_obj_get(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t **a4)
{
  int v8 = obj_type(a1);
  uint64_t v9 = 0;
  uint64_t v10 = a1;
  if (a1 && v8 == 13)
  {
    uint64_t v10 = *(void *)(a1 + 392);
    if (*(void *)(a1 + 496)) {
      uint64_t v9 = *(void *)(a1 + 496);
    }
    else {
      uint64_t v9 = a1;
    }
  }
  if ((a2 & 1) == 0)
  {
LABEL_9:
    if (v9)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v9 + 1152));
      int v12 = *(uint64_t **)(v9 + 3616);
      *a4 = v12;
      int v13 = (uint64_t *)(*(void *)(v9 + 376) + 128);
    }
    else
    {
      pthread_mutex_lock((pthread_mutex_t *)(v10 + 656));
      int v12 = *(uint64_t **)(v10 + 720);
      *a4 = v12;
      int v13 = (uint64_t *)(*(void *)(v10 + 376) + 160);
    }
    uint64_t v14 = *v13;
    if (v12)
    {
      obj_retain(v12);
      if ((a2 & 1) == 0) {
        goto LABEL_25;
      }
      uint64_t v15 = obj_modify(*a4, a2, a3);
      if (v15)
      {
        uint64_t v11 = v15;
        obj_release(*a4);
        if (v9) {
          uint64_t v16 = (pthread_mutex_t *)(v9 + 1152);
        }
        else {
          uint64_t v16 = (pthread_mutex_t *)(v10 + 656);
        }
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v17 = obj_get(*(void *)(v10 + 392), a2 | 0x40000000, v14, &om_desc, 0, v9, 0, a3, a4);
      if (v17)
      {
        uint64_t v11 = v17;
        if (v9)
        {
LABEL_27:
          uint64_t v16 = (pthread_mutex_t *)(v9 + 1152);
LABEL_33:
          pthread_mutex_unlock(v16);
          return v11;
        }
LABEL_32:
        uint64_t v16 = (pthread_mutex_t *)(v10 + 656);
        goto LABEL_33;
      }
      uint64_t v18 = (uint64_t **)(v9 + 3616);
      if (!v9) {
        uint64_t v18 = (uint64_t **)(v10 + 720);
      }
      *uint64_t v18 = *a4;
      obj_retain(*a4);
      if ((a2 & 1) == 0) {
        goto LABEL_25;
      }
    }
    if (obj_oid((uint64_t)*a4) != v14)
    {
      uint64_t v19 = obj_oid((uint64_t)*a4);
      if (v9)
      {
        *(void *)(*(void *)(v9 + 376) + 128) = v19;
        fs_sb_dirty(v9, a3);
        goto LABEL_26;
      }
      *(void *)(*(void *)(v10 + 376) + 160) = v19;
      obj_dirty(a1, a3, 0);
      goto LABEL_31;
    }
LABEL_25:
    if (v9)
    {
LABEL_26:
      uint64_t v11 = 0;
      goto LABEL_27;
    }
LABEL_31:
    uint64_t v11 = 0;
    goto LABEL_32;
  }
  uint64_t v11 = obj_modify(a1, 0, a3);
  if (!v11)
  {
    a2 = a2 | 2;
    goto LABEL_9;
  }
  return v11;
}

uint64_t omap_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v8 = obj_type(a1);
  long long v21 = 0uLL;
  if (a4 == 2)
  {
    if (v8 == 13) {
      uint64_t v9 = a1;
    }
    else {
      uint64_t v9 = 0;
    }
    *(void *)(a3 + 8) = v9;
  }
  if ((*(unsigned char *)(a3 + 20) & 0x40) != 0) {
    return 0;
  }
  obj_lock(a3, 1u);
  int v10 = obj_type_is_or_contains_ephemeral(*(_DWORD *)(*(void *)(a3 + 376) + 40));
  uint64_t v11 = *(void *)(a3 + 376);
  if (!v10 || !*(void *)(v11 + 48))
  {
LABEL_12:
    if (obj_type_is_or_contains_ephemeral(*(_DWORD *)(v11 + 44))
      && (uint64_t v14 = *(void *)(a3 + 376), (v15 = *(void *)(v14 + 56)) != 0))
    {
      int v16 = *(_DWORD *)(v14 + 44);
      long long v23 = 0u;
      long long v24 = 0u;
      uint64_t v28 = 0;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v25 = 0u;
      uint64_t v22 = omap_snapshot_key_cmp;
      DWORD2(v23) = 19;
      if ((unsigned __int16)v16 != 2)
      {
        obj_unlock(a3, 1u);
        uint64_t v18 = (uint64_t *)*((void *)&v21 + 1);
        if (!*((void *)&v21 + 1))
        {
          uint64_t v17 = (uint64_t *)v21;
          uint64_t extended = 22;
          if (!(void)v21) {
            return extended;
          }
          goto LABEL_39;
        }
        uint64_t extended = 22;
        goto LABEL_35;
      }
      uint64_t extended = btree_get_extended(a1, v16 & 0xFFFF0000, v15, 0, 0, (uint64_t)&v22, 0, (uint64_t **)&v21);
      obj_unlock(a3, 1u);
      if (extended) {
        goto LABEL_32;
      }
    }
    else
    {
      obj_unlock(a3, 1u);
    }
    if ((obj_type_and_flags(a3) & 0x80000000) == 0)
    {
      uint64_t v18 = (uint64_t *)*((void *)&v21 + 1);
      uint64_t v17 = (uint64_t *)v21;
      if (v21 != 0)
      {
        if (!*((void *)&v21 + 1))
        {
          if (!(void)v21) {
            return 0;
          }
          goto LABEL_38;
        }
        goto LABEL_34;
      }
      obj_set_skip_checkpoint_traverse(a3, 1);
      goto LABEL_27;
    }
    if (a4 == 2)
    {
      uint64_t v19 = obj_checkpoint_known(a3);
    }
    else
    {
      if (a4 != 1)
      {
LABEL_27:
        uint64_t extended = 0;
        goto LABEL_32;
      }
      uint64_t v19 = obj_checkpoint_start(a3);
    }
    uint64_t extended = v19;
LABEL_32:
    uint64_t v18 = (uint64_t *)*((void *)&v21 + 1);
    if (!*((void *)&v21 + 1)) {
      goto LABEL_36;
    }
    if (extended)
    {
LABEL_35:
      obj_release(v18);
LABEL_36:
      uint64_t v17 = (uint64_t *)v21;
      if (!(void)v21) {
        return extended;
      }
      if (extended)
      {
LABEL_39:
        obj_release(v17);
        return extended;
      }
LABEL_38:
      uint64_t extended = btree_checkpoint_traverse(a1, a2, (uint64_t)v17, a4);
      uint64_t v17 = (uint64_t *)v21;
      goto LABEL_39;
    }
LABEL_34:
    uint64_t extended = btree_checkpoint_traverse(a1, a2, (uint64_t)v18, a4);
    uint64_t v18 = (uint64_t *)*((void *)&v21 + 1);
    goto LABEL_35;
  }
  uint64_t v12 = omap_map_tree_get(a1, a3, 0, 0, (uint64_t *)&v21 + 1);
  if (!v12)
  {
    uint64_t v11 = *(void *)(a3 + 376);
    goto LABEL_12;
  }
  uint64_t extended = v12;
  obj_unlock(a3, 1u);
  return extended;
}

uint64_t omap_set(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  if (obj_type(a1) == 13) {
    uint64_t v14 = a1;
  }
  else {
    uint64_t v14 = 0;
  }
  unint64_t v15 = (void *)a1;
  if (v14) {
    unint64_t v15 = *(void **)(v14 + 392);
  }
  v34[1] = a3;
  uint64_t v35 = 0;
  uint64_t v33 = a4;
  v34[0] = a2;
  v32[0] = a6;
  v32[1] = a5;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  if (!v15) {
    sub_10005E044();
  }
  if (v14 && *(void *)(v14 + 496)) {
    sub_10005E09C();
  }
  if ((a6 & 0x10) != 0) {
    sub_10005E070();
  }
  uint64_t v16 = 22;
  if (xid_is_current_tx((uint64_t)v15, a7) && a2 && a3 && a5)
  {
    uint64_t v17 = v15[47];
    if (*(unsigned char *)(v17 + 65))
    {
      uint64_t v21 = spaceman_get(v15, &v35);
      if (v21)
      {
        uint64_t v16 = v21;
        obj_type(a1);
        log_err((uint64_t)"%s:%d: %s unable to get spaceman: %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"omap_set");
        return v16;
      }
      uint64_t v17 = v15[47];
      unsigned int v19 = (a5 + *(_DWORD *)(v17 + 36) - 1) / *(_DWORD *)(v17 + 36);
      if (v35) {
        uint64_t v18 = v35[47];
      }
      else {
        uint64_t v18 = 0;
      }
    }
    else
    {
      uint64_t v18 = 0;
      unsigned int v19 = (a5 + *(_DWORD *)(v17 + 36) - 1) / *(_DWORD *)(v17 + 36);
    }
    uint64_t v16 = nx_superblock_sanity_check_extent(v17, v18, a4, v19, 0);
    if (v35) {
      obj_release(v35);
    }
    if (!v16)
    {
      uint64_t v16 = omap_obj_get(a1, 1, a7, &v31);
      if (!v16)
      {
        obj_lock((uint64_t)v31, 2u);
        uint64_t v20 = omap_map_tree_get(a1, (uint64_t)v31, 1, a7, (uint64_t *)&v30);
        if (v20)
        {
          uint64_t v16 = v20;
        }
        else
        {
          if ((a6 & 4) != 0) {
            v32[0] = *(_DWORD *)(v31[47] + 32) & 0x10 | a6;
          }
          uint64_t v16 = bt_insert(v30, 0, v34, 16, v32, 0x10u, a7);
          obj_release(v30);
        }
        obj_unlock((uint64_t)v31, 2u);
        obj_release(v31);
      }
    }
  }
  return v16;
}

uint64_t omap_delete(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, int a6, uint64_t a7)
{
  if (obj_type(a1) == 13) {
    uint64_t v14 = a1;
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = a1;
  if (v14) {
    uint64_t v15 = *(void *)(v14 + 392);
  }
  *(void *)&long long v34 = a2;
  *((void *)&v34 + 1) = a3;
  v32[0] = a6;
  v32[1] = a5;
  uint64_t v33 = a4;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  uint64_t v29 = 0;
  if (!v15) {
    sub_10005E0C8();
  }
  if (v14 && *(void *)(v14 + 496)) {
    sub_10005E0F4();
  }
  uint64_t v16 = 22;
  if (!xid_is_current_tx(v15, a7)) {
    return v16;
  }
  if (!a2) {
    return v16;
  }
  if (!a3) {
    return v16;
  }
  uint64_t v16 = omap_obj_get(a1, 1, a7, &v31);
  if (v16) {
    return v16;
  }
  obj_lock((uint64_t)v31, 2u);
  uint64_t v16 = omap_map_tree_get(a1, v31, 1, a7, &v30);
  uint64_t v17 = v31;
  if (v16)
  {
LABEL_50:
    obj_unlock((uint64_t)v17, 2u);
    obj_release(v31);
    return v16;
  }
  uint64_t v18 = v31[47];
  unint64_t v19 = *(void *)(v18 + 64);
  if ((v31[48] & 2) != 0 && v31[61] == v19) {
    unint64_t v19 = v31[60];
  }
  if (*(unsigned char *)(v18 + 32))
  {
    if ((a6 & 1) == 0)
    {
      *(_OWORD *)uint64_t v28 = v34;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      uint64_t v29 = 0x1000000010;
      uint64_t v22 = bt_lookup_variant(v30, 0, v28, (unsigned int *)&v29 + 1, 0x10u, &v26, (unsigned int *)&v29, 0, 0, 0);
      if (v22) {
        goto LABEL_48;
      }
      int v20 = 0;
      BOOL v23 = ((v26 >> 1) & 1) == 0;
      goto LABEL_32;
    }
    int v20 = 0;
    goto LABEL_31;
  }
  int v20 = a6 & 1;
  if (v19 < a3)
  {
    if (v20)
    {
      *(_OWORD *)uint64_t v28 = v34;
      uint64_t v26 = 0;
      uint64_t v27 = 0;
      uint64_t v29 = 0x1000000010;
      if (bt_lookup_variant(v30, 0, v28, (unsigned int *)&v29 + 1, 0x10u, &v26, (unsigned int *)&v29, 2u, 0, 0))BOOL v21 = 0; {
      else
      }
        BOOL v21 = v28[0] == a2;
      int v20 = v21;
    }
LABEL_31:
    BOOL v23 = 1;
    goto LABEL_32;
  }
  BOOL v23 = 0;
LABEL_32:
  if (v20 | v23)
  {
    if (v20)
    {
      *((void *)&v34 + 1) = a7;
      uint64_t v16 = bt_insert(v30, 0, &v34, 16, v32, 16, a7);
    }
    else
    {
      uint64_t v16 = 0;
    }
    if (v23 && !v16)
    {
      if (a3 == a7 && v20)
      {
        uint64_t v16 = 0;
      }
      else
      {
        *((void *)&v34 + 1) = a3;
        uint64_t v24 = bt_remove(v30, 0, (unint64_t *)&v34, 0x10u, a7);
        uint64_t v16 = v24;
        if (v20 && v24)
        {
          *((void *)&v34 + 1) = a7;
          bt_remove(v30, 0, (unint64_t *)&v34, 0x10u, a7);
LABEL_49:
          obj_release(v30);
          uint64_t v17 = v31;
          goto LABEL_50;
        }
      }
    }
    if (!v23 || v16) {
      goto LABEL_49;
    }
    uint64_t v22 = spaceman_free(a1, 0, a4, (a5 + *(_DWORD *)(*(void *)(v15 + 376) + 36) - 1)/ *(_DWORD *)(*(void *)(v15 + 376) + 36), a7);
LABEL_48:
    uint64_t v16 = v22;
    goto LABEL_49;
  }
  obj_release(v30);
  obj_unlock((uint64_t)v31, 2u);
  obj_release(v31);
  return 0;
}

uint64_t omap_get(uint64_t a1, unint64_t a2, unint64_t a3, void *a4, _DWORD *a5, _DWORD *a6, unint64_t *a7)
{
  uint64_t v11 = a3;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  unint64_t v29 = a2;
  unint64_t v30 = a3;
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  unsigned int v25 = 16;
  unsigned int v26 = 16;
  char v24 = 0;
  uint64_t v14 = omap_obj_get(a1, 0, 0, &v32);
  if (!v14)
  {
    obj_lock((uint64_t)v32, 1u);
    if (*(void *)(v32[47] + 88) > a2)
    {
      obj_unlock((uint64_t)v32, 1u);
      uint64_t v14 = 2;
LABEL_33:
      obj_release(v32);
      return v14;
    }
    uint64_t v15 = omap_map_tree_get(a1, (uint64_t)v32, 0, 0, (uint64_t *)&v31);
    if (v15)
    {
      uint64_t v14 = v15;
      obj_unlock((uint64_t)v32, 1u);
      goto LABEL_33;
    }
    if (!v11)
    {
      uint64_t v11 = -1;
      unint64_t v30 = -1;
    }
    BOOL v16 = 1;
    uint64_t v17 = bt_lookup_variant(v31, 0, &v29, &v26, 0x10u, &v27, &v25, 1u, 0, 0);
    if (v17) {
      goto LABEL_9;
    }
    uint64_t v18 = v32[47];
    unint64_t v19 = *(void *)(v18 + 72);
    unint64_t v20 = v29;
    if (v19) {
      BOOL v21 = v29 == a2;
    }
    else {
      BOOL v21 = 0;
    }
    if (v21)
    {
      if (v30 < v19 || v30 > *(void *)(v18 + 80)) {
        goto LABEL_18;
      }
      unint64_t v29 = a2;
      unint64_t v30 = v19 - 1;
      uint64_t v17 = bt_lookup_variant(v31, 0, &v29, &v26, 0x10u, &v27, &v25, 1u, 0, 0);
      if (v17)
      {
LABEL_9:
        uint64_t v14 = v17;
        goto LABEL_31;
      }
      unint64_t v20 = v29;
    }
    if (v20 != a2)
    {
LABEL_30:
      uint64_t v14 = 2;
LABEL_31:
      obj_release(v31);
      obj_unlock((uint64_t)v32, 1u);
      if (!v16) {
        sub_10001B260(a1, (uint64_t)v32);
      }
      goto LABEL_33;
    }
LABEL_18:
    int v22 = v27;
    if ((v27 & 1) == 0)
    {
      if (a4) {
        *a4 = v28;
      }
      if (a5) {
        *a5 = HIDWORD(v27);
      }
      if (a6)
      {
        *a6 = v22 & 0xFFFFFFEF;
        if (((*(_DWORD *)(v32[47] + 32) ^ v22) & 0x10) != 0) {
          *a6 = v22 | 0x10;
        }
      }
      if (a7) {
        *a7 = v30;
      }
      if (v32[53])
      {
        sub_10001B11C((uint64_t)v32, a2, v11, &v24);
        uint64_t v14 = 0;
        BOOL v16 = v24 == 0;
      }
      else
      {
        uint64_t v14 = 0;
      }
      goto LABEL_31;
    }
    goto LABEL_30;
  }
  return v14;
}

uint64_t sub_10001B11C(uint64_t result, unint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v13 = 1;
  unint64_t v14 = a2;
  if (*(void *)(result + 424))
  {
    uint64_t v4 = result;
    if (!*(_DWORD *)(result + 440))
    {
      unsigned __int8 v12 = 0;
      uint64_t v11 = 0;
      __tp.__darwin_time_t tv_sec = 0;
      __tp.int tv_nsec = 0;
      clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
      if (__tp.tv_sec - *(void *)(v4 + 432) >= 601) {
        *a4 = 1;
      }
      btree_node_count(*(void *)(v4 + 424), &v13);
      unint64_t v7 = v13;
      uint64_t result = obj_size_phys(*(void *)(v4 + 424));
      if (v7 <= 0x200000 / result)
      {
        LODWORD(__tp.tv_sec) = 8;
        unsigned int v10 = 9;
        uint64_t result = bt_lookup_variant(*(uint64_t **)(v4 + 424), 0, &v14, (unsigned int *)&__tp, 8u, &v11, &v10, 0, 0, 0);
        if (result == 2)
        {
          LOBYTE(v8) = *(unsigned char *)(v4 + 464);
        }
        else
        {
          if (result) {
            return result;
          }
          if (!v11) {
            return result;
          }
          int v8 = *(unsigned __int8 *)(v4 + 464);
          if (v12 == v8) {
            return result;
          }
        }
        if (a3 == -1) {
          uint64_t v9 = 0;
        }
        else {
          uint64_t v9 = a3;
        }
        uint64_t v11 = v9;
        unsigned __int8 v12 = v8;
        return bt_insert(*(uint64_t **)(v4 + 424), 0, &v14, 8, &v11, 9u, 0);
      }
    }
  }
  return result;
}

uint64_t sub_10001B260(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a1;
  if (obj_type(a1) != 13) {
    uint64_t v3 = 0;
  }
  obj_lock(a2, 2u);
  if (*(void *)(a2 + 424))
  {
    v6.__darwin_time_t tv_sec = 0;
    v6.int tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v6);
    if (v6.tv_sec - *(void *)(a2 + 432) >= 601)
    {
      btree_delete(*(void *)(a2 + 424), 0, 0);
      obj_release(*(uint64_t **)(a2 + 424));
      *(void *)(a2 + 424) = 0;
    }
  }
  if (v3)
  {
    if (*(void *)(v3 + 496)) {
      uint64_t v3 = *(void *)(v3 + 496);
    }
    uint64_t v4 = *(uint64_t **)(v3 + 3624);
    if (v4)
    {
      obj_release(v4);
      *(void *)(v3 + 3624) = 0;
    }
  }
  return obj_unlock(a2, 2u);
}

uint64_t omap_find_next_snapshot_xid(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v38 = 0;
  unsigned int v39 = 0;
  v37[0] = 0;
  v37[1] = 0;
  unint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v6 = omap_obj_get(a1, 0, 0, &v39);
  if (v6)
  {
    uint64_t extended = v6;
    obj_type(a1);
    log_err((uint64_t)"%s:%d: %s unable to get omap: %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"omap_find_next_snapshot_xid");
    return extended;
  }
  uint64_t v8 = v39[47];
  obj_lock((uint64_t)v39, 1u);
  if ((*(unsigned char *)(v8 + 32) & 1) == 0)
  {
    unint64_t v9 = *(void *)(v8 + 56);
    if (v9)
    {
      int v10 = *(_DWORD *)(v8 + 44);
      long long v41 = 0u;
      long long v42 = 0u;
      uint64_t v46 = 0;
      long long v44 = 0u;
      long long v45 = 0u;
      long long v43 = 0u;
      unint64_t v40 = omap_snapshot_key_cmp;
      DWORD2(v41) = 19;
      if ((unsigned __int16)v10 == 2)
      {
        uint64_t extended = btree_get_extended(a1, v10 & 0xFFFF0000, v9, 0, 0, (uint64_t)&v40, 0, &v38);
        if (!extended)
        {
          unint64_t v35 = a2;
          do
          {
            uint64_t v36 = 0x800000010;
            uint64_t v11 = bt_lookup_variant(v38, 0, &v35, (unsigned int *)&v36 + 1, 8u, v37, (unsigned int *)&v36, 4u, 0, 0);
            if (v11) {
              BOOL v12 = 1;
            }
            else {
              BOOL v12 = (v37[0] & 1) == 0;
            }
          }
          while (!v12);
          uint64_t extended = v11;
          if (!v11)
          {
            *a3 = v35;
            goto LABEL_18;
          }
          if (v11 != 2)
          {
            obj_type(a1);
            log_err((uint64_t)"%s:%d: %s error searching snapshot tree: %d\n", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"omap_find_next_snapshot_xid");
            goto LABEL_18;
          }
          goto LABEL_15;
        }
      }
      else
      {
        uint64_t extended = 22;
      }
      obj_type(a1);
      log_err((uint64_t)"%s:%d: %s unable to get snapshot tree: %d\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"omap_find_next_snapshot_xid");
      goto LABEL_18;
    }
  }
LABEL_15:
  uint64_t extended = 2;
LABEL_18:
  if (v38) {
    obj_release(v38);
  }
  obj_unlock((uint64_t)v39, 1u);
  obj_release(v39);
  return extended;
}

uint64_t sub_10001B5A0(void *a1, void *a2, uint64_t a3)
{
  if (obj_type((uint64_t)a1) == 13) {
    uint64_t v11 = (pthread_mutex_t *)a1;
  }
  else {
    uint64_t v11 = 0;
  }
  if (!v11)
  {
    uint64_t result = obj_modify(a1, 0, a3, v6, v7, v8, v9, v10);
    if (result) {
      return result;
    }
    uint64_t v14 = (pthread_mutex_t *)(a1 + 82);
    BOOL v12 = a1;
LABEL_10:
    pthread_mutex_lock(v14);
    uint64_t v15 = obj_oid((uint64_t)a2);
    unsigned int v16 = obj_type_and_flags((uint64_t)a2);
    if (obj_modify(a2, (v16 >> 29) & 2, a3, v17, v18, v19, v20, v21) || obj_oid((uint64_t)a2) == v15)
    {
      if (v11)
      {
LABEL_13:
        uint64_t v22 = v11 + 18;
LABEL_18:
        pthread_mutex_unlock(v22);
        return 0;
      }
    }
    else
    {
      uint64_t v23 = obj_oid((uint64_t)a2);
      if (v11)
      {
        *(void *)(*(void *)&v11[5].__opaque[48] + 128) = v23;
        fs_sb_dirty((uint64_t)v11, a3);
        goto LABEL_13;
      }
      *(void *)(v12[47] + 160) = v23;
      obj_dirty((uint64_t)a1, a3, 0);
    }
    uint64_t v22 = (pthread_mutex_t *)(v12 + 82);
    goto LABEL_18;
  }
  if (*(void *)&v11[7].__opaque[40]) {
    sub_10005E120();
  }
  BOOL v12 = *(void **)v11[6].__opaque;
  uint64_t result = obj_modify(a1, 0, a3, v6, v7, v8, v9, v10);
  if (!result)
  {
    uint64_t v14 = v11 + 18;
    goto LABEL_10;
  }
  return result;
}

atomic_ullong *fs_obj_zfree_oc(void *a1, unint64_t a2, int a3, uint64_t a4)
{
  if (!qword_100084A18) {
    sub_10005E14C();
  }
  _apfs_obj_zfree(a1, a2, *(void *)(a4 + 920));
  sub_10001B73C((atomic_ullong *)(a4 + 944), a3, a2);
  uint64_t v7 = (atomic_ullong *)(qword_100084A18 + 136);

  return sub_10001B73C(v7, a3, a2);
}

atomic_ullong *sub_10001B73C(atomic_ullong *result, int a2, unint64_t a3)
{
  unsigned int v4 = a2 & 0xC8000000;
  if (a2 < 0 != v3)
  {
    if (v4 == 0x80000000)
    {
      atomic_fetch_add_explicit(result + 29, -(uint64_t)a3, memory_order_relaxed);
      atomic_fetch_add_explicit(result + 31, a3, memory_order_relaxed);
      int v5 = result + 33;
    }
    else
    {
      if (v4 != -2013265920) {
        goto LABEL_12;
      }
      atomic_fetch_add_explicit(result + 35, -(uint64_t)a3, memory_order_relaxed);
      atomic_fetch_add_explicit(result + 37, a3, memory_order_relaxed);
      int v5 = result + 39;
    }
  }
  else
  {
    if (v4 != 0x40000000 && v4 != 0) {
LABEL_12:
    }
      panic("unexpected storagetype: 0x%x\n", a2 & 0xC8000000);
    atomic_fetch_add_explicit(result + 23, -(uint64_t)a3, memory_order_relaxed);
    atomic_fetch_add_explicit(result + 25, a3, memory_order_relaxed);
    int v5 = result + 27;
  }
  atomic_fetch_add_explicit(v5, 1uLL, memory_order_relaxed);
  return result;
}

uint64_t obj_cache_create(unsigned int a1, unsigned int a2, unsigned int a3, void *a4)
{
  uint64_t v8 = obj_mem_mgr_init();
  if (!v8)
  {
    uint64_t v9 = (char *)_apfs_calloc(1uLL, 0x558uLL);
    if (v9)
    {
      uint64_t v10 = v9;
      bzero(v9, 0x558uLL);
      uint64_t v11 = new_lock((pthread_mutex_t *)v10);
      if (v11)
      {
        uint64_t v8 = v11;
LABEL_13:
        _apfs_free(v10, 1368);
        return v8;
      }
      uint64_t v12 = new_rwlock((pthread_rwlock_t *)(v10 + 128));
      if (v12)
      {
        uint64_t v8 = v12;
LABEL_12:
        free_lock((pthread_mutex_t *)v10);
        goto LABEL_13;
      }
      uint64_t v13 = new_lock((pthread_mutex_t *)(v10 + 328));
      if (v13)
      {
        uint64_t v8 = v13;
LABEL_11:
        free_rwlock((pthread_rwlock_t *)(v10 + 128));
        goto LABEL_12;
      }
      uint64_t v14 = new_cv((pthread_cond_t *)v10 + 27);
      if (v14)
      {
        uint64_t v8 = v14;
        free_lock((pthread_mutex_t *)(v10 + 328));
        goto LABEL_11;
      }
      if (!a1) {
        a1 = 4096;
      }
      uint64_t v15 = _apfs_malloc(8 * a1);
      *((void *)v10 + 88) = v15;
      if (v15)
      {
        bzero(v15, 8 * a1);
        *((_DWORD *)v10 + 174) = a1;
        *((_DWORD *)v10 + 175) = a1 - 1;
        if (a2) {
          unsigned int v16 = a2;
        }
        else {
          unsigned int v16 = 4096;
        }
        *((_DWORD *)v10 + 169) = 128;
        *((_DWORD *)v10 + 170) = v16;
        *((_DWORD *)v10 + 171) = 0;
        *((void *)v10 + 86) = 0;
        *((_DWORD *)v10 + 168) = a3;
        sub_10001BC0C((uint64_t)(v10 + 944), 0x80u, v16, a3);
        uint64_t v17 = _apfs_calloc(0x100uLL, 8uLL);
        *((void *)v10 + 109) = v17;
        if (v17)
        {
          uint64_t v8 = 0;
          *((void *)v10 + 93) = v10 + 736;
          *((void *)v10 + 95) = v10 + 752;
          *((void *)v10 + 97) = v10 + 768;
          *((void *)v10 + 99) = v10 + 784;
          *((void *)v10 + 101) = v10 + 800;
          *((void *)v10 + 103) = v10 + 816;
          *((void *)v10 + 169) = v10 + 1344;
          *((void *)v10 + 107) = v10 + 848;
          *((void *)v10 + 105) = v10 + 832;
          *(_OWORD *)(v10 + 712) = 0u;
          *((void *)v10 + 94) = 0;
          *((void *)v10 + 96) = 0;
          *((void *)v10 + 98) = 0;
          *((void *)v10 + 100) = 0;
          *((void *)v10 + 102) = 0;
          *((void *)v10 + 168) = 0;
          *((void *)v10 + 106) = 0;
          *((void *)v10 + 104) = 0;
          *((void *)v10 + 92) = 0;
          *((void *)v10 + 91) = 0;
          *((int64x2_t *)v10 + 25) = vdupq_n_s64(0x400uLL);
          *a4 = v10;
          return v8;
        }
        _apfs_free(*((void **)v10 + 88), 8 * a1);
      }
      free_cv((pthread_cond_t *)v10 + 27);
      free_lock((pthread_mutex_t *)(v10 + 328));
      free_rwlock((pthread_rwlock_t *)(v10 + 128));
      free_lock((pthread_mutex_t *)v10);
      _apfs_free(v10, 1368);
    }
    return 12;
  }
  return v8;
}

uint64_t obj_mem_mgr_init()
{
  if (!atomic_load_explicit(&qword_100084A18, memory_order_acquire))
  {
    uint64_t v2 = (char *)_apfs_calloc(1uLL, 0x1E0uLL);
    if (!v2) {
      return 12;
    }
    unint64_t v3 = (unint64_t)v2;
    unsigned int v4 = (pthread_mutex_t *)(v2 + 8);
    *((_OWORD *)v2 + 28) = 0u;
    *((_OWORD *)v2 + 29) = 0u;
    *((_OWORD *)v2 + 26) = 0u;
    *((_OWORD *)v2 + 27) = 0u;
    *((_OWORD *)v2 + 24) = 0u;
    *((_OWORD *)v2 + 25) = 0u;
    *((_OWORD *)v2 + 22) = 0u;
    *((_OWORD *)v2 + 23) = 0u;
    *((_OWORD *)v2 + 20) = 0u;
    *((_OWORD *)v2 + 21) = 0u;
    *((_OWORD *)v2 + 18) = 0u;
    *((_OWORD *)v2 + 19) = 0u;
    *((_OWORD *)v2 + 16) = 0u;
    *((_OWORD *)v2 + 17) = 0u;
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    uint64_t v5 = new_lock((pthread_mutex_t *)(v2 + 8));
    if (v5)
    {
      uint64_t v0 = v5;
      log_err((uint64_t)"%s:%d: object memory manager failed to create lock, error: %d\n", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"obj_mem_mgr_init");
      _apfs_free((void *)v3, 480);
      return v0;
    }
    *(void *)(v3 + 72) = 0;
    __tp.__darwin_time_t tv_sec = 0;
    __tp.int tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    uint64_t v20 = 0;
    *(_OWORD *)(v3 + 136) = 0u;
    *(_OWORD *)(v3 + 440) = 0u;
    *(_OWORD *)(v3 + 456) = 0u;
    *(_OWORD *)(v3 + 408) = 0u;
    *(_OWORD *)(v3 + 424) = 0u;
    *(_OWORD *)(v3 + 376) = 0u;
    *(_OWORD *)(v3 + 392) = 0u;
    *(_OWORD *)(v3 + 344) = 0u;
    *(_OWORD *)(v3 + 360) = 0u;
    *(_OWORD *)(v3 + 312) = 0u;
    *(_OWORD *)(v3 + 328) = 0u;
    *(_OWORD *)(v3 + 280) = 0u;
    *(_OWORD *)(v3 + 296) = 0u;
    *(_OWORD *)(v3 + 264) = 0u;
    __darwin_time_t tv_sec = __tp.tv_sec;
    *(_OWORD *)(v3 + 248) = 0u;
    *(_OWORD *)(v3 + 232) = 0u;
    *(_OWORD *)(v3 + 216) = 0u;
    *(_OWORD *)(v3 + 200) = 0u;
    *(_OWORD *)(v3 + 184) = 0u;
    *(_OWORD *)(v3 + 168) = 0u;
    *(_OWORD *)(v3 + 152) = 0u;
    *(void *)(v3 + 464) = tv_sec;
    *(void *)(v3 + 472) = 0;
    atomic_compare_exchange_strong_explicit(&qword_100084A18, (unint64_t *)&v20, v3, memory_order_release, memory_order_relaxed);
    if (v20)
    {
      atomic_load_explicit(&qword_100084A18, memory_order_acquire);
      free_lock(v4);
      _apfs_free((void *)v3, 480);
    }
    else
    {
      if (!qword_100084A18) {
        sub_10005E178();
      }
      if ((*(_DWORD *)qword_100084A18 & 4) != 0) {
        log_debug((uint64_t)"%s:%d: object memory manager initialized with feature flags: 0x%x, apfs_mem_max: %lld\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"obj_mem_mgr_init");
      }
    }
  }
  return 0;
}

double sub_10001BC0C(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  v11.__darwin_time_t tv_sec = 0;
  v11.int tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v11);
  __darwin_time_t tv_sec = v11.tv_sec;
  double result = 0.0;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  unint64_t v10 = a4 * (unint64_t)a3;
  *(void *)(a1 + 8) = a4 * (unint64_t)a2;
  *(void *)(a1 + 16) = v10;
  *(void *)a1 = v10;
  *(void *)(a1 + 328) = tv_sec;
  *(void *)(a1 + 336) = 0;
  return result;
}

uint64_t obj_cache_ephemeral_adjust(uint64_t result, int a2, int a3, int a4)
{
  if (a4 != -1 && a4 != 1) {
    sub_10005E1A4();
  }
  if ((a2 & 0x8000000) != 0)
  {
    int v9 = *(_DWORD *)(result + 692);
    if (a4 <= 0 && !v9) {
      sub_10005E228();
    }
    *(_DWORD *)(result + 692) = v9 + a4;
  }
  else
  {
    int v4 = *(_DWORD *)(result + 688);
    if (a4 <= 0 && !v4) {
      sub_10005E1D0();
    }
    *(_DWORD *)(result + 688) = v4 + a4;
    uint64_t v5 = *(void *)(result + 392);
    if (v5)
    {
      unsigned int v6 = (a3 + *(_DWORD *)(*(void *)(v5 + 376) + 36) - 1)
         / *(_DWORD *)(*(void *)(v5 + 376) + 36);
      int v7 = *(_DWORD *)(result + 900);
      if (a4 < 0) {
        int v8 = v7 - v6;
      }
      else {
        int v8 = v7 + v6;
      }
    }
    else
    {
      if (a4 != 1) {
        sub_10005E1FC();
      }
      int v8 = *(_DWORD *)(result + 900) + 1;
    }
    *(_DWORD *)(result + 900) = v8;
  }
  return result;
}

void obj_cache_unlock_write(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 720);
  if (v1)
  {
    *(void *)(a1 + 720) = 0;
    *(void *)(a1 + 728) = 0;
    pthread_mutex_unlock((pthread_mutex_t *)a1);
    do
    {
      uint64_t v2 = (void *)v1[9];
      sub_100024AE8(v1, 0);
      uint64_t v1 = v2;
    }
    while (v2);
  }
  else
  {
    pthread_mutex_unlock((pthread_mutex_t *)a1);
  }
}

uint64_t obj_cache_lock_by_state(pthread_mutex_t *a1, int a2)
{
  if ((a2 - 3) <= 0xFFFFFFFD) {
    sub_10005E254();
  }
  if (a2 != 2 && a2 != 1) {
    panic("obj_cache_lock_by_state, invalid oc_lock_state %d\n", a2);
  }

  return pthread_mutex_lock(a1);
}

void obj_cache_unlock_by_state(pthread_mutex_t *a1, int a2)
{
  if ((a2 - 3) <= 0xFFFFFFFD) {
    sub_10005E280();
  }
  if (a2 == 2)
  {
    obj_cache_unlock_write((uint64_t)a1);
  }
  else
  {
    if (a2 != 1) {
      panic("obj_cache_unlock_by_state, invalid oc_lock_state %d\n", a2);
    }
    pthread_mutex_unlock(a1);
  }
}

void obj_cache_reset(pthread_mutex_t *a1, int a2)
{
  if (!a2)
  {
    pthread_mutex_lock(a1);
    atomic_fetch_add_explicit((atomic_uint *volatile)&a1[14].__opaque[8], 1u, memory_order_relaxed);
  }
  while (atomic_fetch_add_explicit((atomic_uint *volatile)&a1[14].__opaque[12], 0, memory_order_relaxed))
  {
    char v18 = 1;
    uint64_t sig = a1[21].__sig;
    if (sig)
    {
      if ((*(unsigned char *)(*(void *)(sig + 136) + 20) & 0x80) == 0)
      {
        sub_10002377C(sig, &v18);
        if (!v18) {
          pthread_mutex_lock(a1);
        }
      }
    }
  }
  if (a1[11].__sig)
  {
    unint64_t v5 = *(unsigned int *)&a1[10].__opaque[48];
    if (v5)
    {
      for (unint64_t i = 0; i < v5; ++i)
      {
        uint64_t v7 = *(void *)(a1[11].__sig + 8 * i);
        if (v7)
        {
          do
          {
            uint64_t v8 = *(void *)(v7 + 72);
            if (v7 != *(void *)a1[6].__opaque)
            {
              uint64_t v9 = *(void *)(v7 + 16);
              if ((v9 & 0x80000000) != 0)
              {
                obj_cache_ephemeral_adjust((uint64_t)a1, v9, *(_DWORD *)(v7 + 48), -1);
              }
              else
              {
                int v10 = *(_DWORD *)&a1[10].__opaque[36];
                if (!v10) {
                  sub_10005E2D8();
                }
                *(_DWORD *)&a1[10].__opaque[36] = v10 - 1;
              }
              sub_100022918(v7, 0);
            }
            uint64_t v7 = v8;
          }
          while (v8);
          unint64_t v5 = *(unsigned int *)&a1[10].__opaque[48];
        }
      }
    }
  }
  uint64_t v11 = *(void *)a1[11].__opaque;
  if (v11)
  {
    do
    {
      int v12 = *(_DWORD *)&a1[10].__opaque[36];
      if (!v12) {
        sub_10005E2AC();
      }
      uint64_t v13 = *(void *)(v11 + 72);
      *(_DWORD *)&a1[10].__opaque[36] = v12 - 1;
      sub_100022918(v11, 0);
      uint64_t v11 = v13;
    }
    while (v13);
  }
  uint64_t v14 = *(void *)&a1[11].__opaque[24];
  if (v14)
  {
    do
    {
      uint64_t v15 = *(void *)(v14 + 88);
      if (v14 != *(void *)a1[6].__opaque) {
        sub_100022918(v14, 0);
      }
      uint64_t v14 = v15;
    }
    while (v15);
  }
  uint64_t v16 = *(void *)&a1[11].__opaque[40];
  if (v16)
  {
    do
    {
      uint64_t v17 = *(void *)(v16 + 88);
      sub_100022918(v16, 0);
      uint64_t v16 = v17;
    }
    while (v17);
  }
  if (!a2)
  {
    obj_cache_unlock_write((uint64_t)a1);
    atomic_fetch_add_explicit((atomic_uint *volatile)&a1[14].__opaque[8], 0xFFFFFFFF, memory_order_relaxed);
  }
}

void obj_cache_destroy(uint64_t a1)
{
  if (!qword_100084A18) {
    sub_10005E304();
  }
  pthread_mutex_lock((pthread_mutex_t *)(qword_100084A18 + 8));
  uint64_t v2 = *(void *)(a1 + 1288);
  if (v2)
  {
    *(void *)(a1 + 1288) = v2 & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v3 = *(void *)(a1 + 928);
    if (v3) {
      *(void *)(v3 + 936) = *(void *)(a1 + 936);
    }
    **(void **)(a1 + 936) = v3;
    if ((v2 & 2) == 0)
    {
      uint64_t v4 = qword_100084A18;
      --*(void *)(qword_100084A18 + 104);
      *(int64x2_t *)(v4 + 136) = vsubq_s64(*(int64x2_t *)(v4 + 136), *(int64x2_t *)(a1 + 944));
      *(void *)(v4 + 152) -= *(void *)(a1 + 960);
      goto LABEL_9;
    }
    *(void *)(a1 + 1288) = v2 & 0xFFFFFFFFFFFFFFFCLL;
  }
  uint64_t v4 = qword_100084A18;
LABEL_9:
  pthread_mutex_unlock((pthread_mutex_t *)(v4 + 8));
  pthread_mutex_lock((pthread_mutex_t *)a1);
  atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 912), 1u, memory_order_relaxed);
  obj_cache_reset((pthread_mutex_t *)a1, 1);
  uint64_t v5 = *(void *)(a1 + 392);
  if (v5)
  {
    obj_cache_ephemeral_adjust(a1, *(void *)(v5 + 16), *(_DWORD *)(v5 + 48), -1);
    sub_100022918(*(void *)(a1 + 392), 0);
  }
  unsigned int v6 = *(void **)(a1 + 704);
  if (v6)
  {
    uint64_t v7 = *(unsigned int *)(a1 + 696);
    if (v7)
    {
      uint64_t v8 = *(unsigned int *)(a1 + 696);
      uint64_t v9 = *(void **)(a1 + 704);
      do
      {
        if (*v9) {
          sub_10005E5F0();
        }
        ++v9;
        --v8;
      }
      while (v8);
    }
    else
    {
      uint64_t v7 = 0;
    }
    _apfs_free(v6, 8 * v7);
  }
  if (*(void *)(a1 + 712)) {
    sub_10005E5C4();
  }
  if (*(void *)(a1 + 736)) {
    sub_10005E598();
  }
  if (*(void *)(a1 + 752)) {
    sub_10005E56C();
  }
  if (*(void *)(a1 + 768)) {
    sub_10005E540();
  }
  if (*(void *)(a1 + 784)) {
    sub_10005E514();
  }
  if (*(void *)(a1 + 800)) {
    sub_10005E4E8();
  }
  if (*(void *)(a1 + 816)) {
    sub_10005E4BC();
  }
  if (*(void *)(a1 + 1344)) {
    sub_10005E490();
  }
  if (*(_DWORD *)(a1 + 900)) {
    sub_10005E464();
  }
  if (*(_DWORD *)(a1 + 688)) {
    sub_10005E438();
  }
  if (*(_DWORD *)(a1 + 692)) {
    sub_10005E40C();
  }
  if (*(_DWORD *)(a1 + 684)) {
    sub_10005E3E0();
  }
  obj_cache_unlock_write(a1);
  int v10 = *(void **)(a1 + 872);
  if (v10)
  {
    uint64_t v11 = *(unsigned int *)(a1 + 880);
    if ((int)v11 >= 1)
    {
      int v12 = *(void **)(a1 + 872);
      do
      {
        if (*v12) {
          sub_10005E3B4();
        }
        ++v12;
        --v11;
      }
      while (v11);
    }
    _apfs_free(v10, 2048);
  }
  free_cv((pthread_cond_t *)(a1 + 1296));
  free_lock((pthread_mutex_t *)(a1 + 328));
  free_rwlock((pthread_rwlock_t *)(a1 + 128));
  free_lock((pthread_mutex_t *)a1);
  if (*(void *)(a1 + 1128)) {
    sub_10005E388();
  }
  if (*(void *)(a1 + 1176)) {
    sub_10005E35C();
  }
  if (*(void *)(a1 + 1224)) {
    sub_10005E330();
  }

  _apfs_free((void *)a1, 1368);
}

uint64_t obj_cache_flush_prepare(uint64_t a1, unsigned int a2, char a3, uint64_t a4)
{
  unsigned int v139 = 0;
  if ((a2 & 0x80000000) != 0) {
    return 22;
  }
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v136 = a4;
  unsigned int v137 = a2;
  if (a2)
  {
    if (*(_DWORD *)(a1 + 908))
    {
      obj_cache_unlock_write(a1);
      return 0;
    }
  }
  else
  {
    int v8 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
    if (v8) {
      panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 793, v8);
    }
    uint64_t v16 = *(void *)(a1 + 800);
    if (v16)
    {
      int v17 = 0;
      int v18 = 0;
      do
      {
        if ((*(unsigned char *)(v16 + 19) & 0xC0) != 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s non-virtual object in virtual dirty list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        int v19 = *(_DWORD *)(v16 + 32);
        if ((v19 & 1) == 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s non-dirty object in dirty list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
          int v19 = *(_DWORD *)(v16 + 32);
        }
        if ((v19 & 0x10) != 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s deferred update object in dirty list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        ++v18;
        uint64_t v16 = *(void *)(v16 + 88);
      }
      while (v16);
    }
    else
    {
      int v18 = 0;
      int v17 = 0;
    }
    if (*(_DWORD *)(a1 + 884) != v18)
    {
      ++v17;
      log_err((uint64_t)"%s:%d: %s virtual dirty list count mismatch %d != %d\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
    }
    uint64_t v20 = *(void *)(a1 + 816);
    if (v20)
    {
      int v21 = 0;
      do
      {
        if ((*(unsigned char *)(v20 + 19) & 0x40) == 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s non-physical object in physical dirty list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        int v22 = *(_DWORD *)(v20 + 32);
        if ((v22 & 1) == 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s non-dirty object in phys dirty list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
          int v22 = *(_DWORD *)(v20 + 32);
        }
        if ((v22 & 0x10) != 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s deferred update object in phys dirty list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        ++v21;
        uint64_t v20 = *(void *)(v20 + 88);
      }
      while (v20);
    }
    else
    {
      int v21 = 0;
    }
    if (*(_DWORD *)(a1 + 888) != v21)
    {
      ++v17;
      log_err((uint64_t)"%s:%d: %s physical dirty list count mismatch %d != %d\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
    }
    uint64_t v23 = *(void *)(a1 + 768);
    if (v23)
    {
      int v24 = 0;
      do
      {
        if (*(_WORD *)(v23 + 36) == 13)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s fs object in virtual free list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        if ((*(unsigned char *)(v23 + 19) & 0xC0) != 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s non-virtual object in virtual free list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        if ((*(_DWORD *)(v23 + 32) & 0x11) == 1)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s dirty object in virtual free list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 24), 0, memory_order_relaxed);
        if ((add_explicit & 0xFFFFFF) != ((add_explicit >> 24) & 0xFFFFF) && (*(unsigned char *)(v23 + 32) & 0x10) == 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s referenced object in virtual free list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        ++v24;
        uint64_t v23 = *(void *)(v23 + 88);
      }
      while (v23);
    }
    else
    {
      int v24 = 0;
    }
    if (*(_DWORD *)(a1 + 892) != v24)
    {
      ++v17;
      log_err((uint64_t)"%s:%d: %s virtual free list count mismatch %d != %d\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
    }
    uint64_t v26 = *(void *)(a1 + 784);
    if (v26)
    {
      int v27 = 0;
      do
      {
        if (*(_WORD *)(v26 + 36) == 13)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s fs object in physical free list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        if ((*(unsigned char *)(v26 + 19) & 0x40) == 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s non-physical object in physical free list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        if ((*(_DWORD *)(v26 + 32) & 0x11) == 1)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s dirty object in physical free list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        unint64_t v28 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 24), 0, memory_order_relaxed);
        if ((v28 & 0xFFFFFF) != ((v28 >> 24) & 0xFFFFF) && (*(unsigned char *)(v26 + 32) & 0x10) == 0)
        {
          ++v17;
          log_err((uint64_t)"%s:%d: %s referenced object in physical free list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        }
        ++v27;
        uint64_t v26 = *(void *)(v26 + 88);
      }
      while (v26);
    }
    else
    {
      int v27 = 0;
    }
    if (*(_DWORD *)(a1 + 896) != v27)
    {
      ++v17;
      log_err((uint64_t)"%s:%d: %s physical free list count mismatch %d != %d\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
    }
    for (uint64_t i = *(void *)(a1 + 736); i; uint64_t i = *(void *)(i + 88))
    {
      uint64_t v30 = *(void *)(i + 16);
      if ((v30 & 0x80000000) == 0)
      {
        ++v17;
        log_err((uint64_t)"%s:%d: %s non-ephemeral object in ephemeral list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        uint64_t v30 = *(void *)(i + 16);
      }
      if ((v30 & 0x8000000) != 0)
      {
        ++v17;
        log_err((uint64_t)"%s:%d: %s non-persistent ephemeral object in persistent ephemeral list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
      }
    }
    for (uint64_t j = *(void *)(a1 + 752); j; uint64_t j = *(void *)(j + 88))
    {
      uint64_t v32 = *(void *)(j + 16);
      if ((v32 & 0x80000000) == 0)
      {
        ++v17;
        log_err((uint64_t)"%s:%d: %s non-ephemeral object in non-persistent ephemeral list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
        uint64_t v32 = *(void *)(j + 16);
      }
      if ((v32 & 0x8000000) == 0)
      {
        ++v17;
        log_err((uint64_t)"%s:%d: %s persistent ephemeral object in non-persistent ephemeral list\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
      }
    }
    if (*(_DWORD *)(a1 + 880))
    {
      unint64_t v33 = 0;
      do
      {
        uint64_t v34 = *(void *)(*(void *)(a1 + 872) + 8 * v33);
        if (v34)
        {
          int v35 = *(_DWORD *)(v34 + 32);
          if ((v35 & 0x10) == 0)
          {
            ++v17;
            log_err((uint64_t)"%s:%d: %s object in deferred updates queue but not flagged with OBJ_AFLAG_DEFERRED_LIST_UPDATE\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
            int v35 = *(_DWORD *)(v34 + 32);
          }
          if (v35)
          {
            ++v17;
            log_err((uint64_t)"%s:%d: %s dirty object in deferred updates queue\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
          }
          if ((*(unsigned char *)(v34 + 19) & 0x80) != 0)
          {
            ++v17;
            log_err((uint64_t)"%s:%d: %s ephemeral object in deferred updates queue\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"obj_cache_sanity");
          }
        }
        ++v33;
      }
      while (v33 < *(unsigned int *)(a1 + 880));
    }
    if (v17) {
      sub_10005E61C();
    }
    int v36 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
    if (v36) {
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 903, v36);
    }
    a4 = v136;
    while (*(_DWORD *)(a1 + 908))
    {
      *(_DWORD *)(a1 + 908) = 2;
      cv_wait_rw((pthread_cond_t *)(a1 + 1296), (pthread_mutex_t *)a1, 2, 0);
    }
  }
  *(_DWORD *)(a1 + 908) = 1;
  uint64_t v133 = (pthread_rwlock_t *)(a1 + 128);
  int v37 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v37) {
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 1097, v37);
  }
  unsigned int v38 = v137;
  if (v137)
  {
    if (a3)
    {
      long long v42 = 0;
      int v40 = v137;
      goto LABEL_174;
    }
    if (*(_DWORD *)(a1 + 884) >= v137) {
      int v39 = v137;
    }
    else {
      int v39 = *(_DWORD *)(a1 + 884);
    }
    int v40 = v137 - v39;
  }
  else
  {
    int v40 = 0;
    if (a3)
    {
      long long v42 = 0;
      goto LABEL_174;
    }
    int v39 = 0;
  }
  int v41 = 0;
  long long v42 = 0;
  uint64_t v43 = 0;
  if (v137) {
    int v44 = -1;
  }
  else {
    int v44 = 0;
  }
  int v134 = v44;
  while (1)
  {
    uint64_t v45 = *(void *)(a1 + 800);
    if (!v45) {
      goto LABEL_152;
    }
    while (!v38 || v39 >= 1)
    {
      if (*(_DWORD *)(v45 + 36) >> 30) {
        panic("non-virtual object on virtual object dirty list: oid %lld flags 0x%llx 0x%x\n", *(void *)(v45 + 112), *(void *)(v45 + 16), *(_DWORD *)(v45 + 32));
      }
      int v46 = *(_DWORD *)(v45 + 32);
      if ((v46 & 1) == 0) {
        panic("virtual object on dirty list not dirty: oid %lld flags 0x%llx 0x%x\n", *(void *)(v45 + 112), *(void *)(v45 + 16), v46);
      }
      if (v41)
      {
        if (v41 > 1) {
          goto LABEL_122;
        }
      }
      else
      {
        uint64_t v47 = *(void *)(v45 + 8);
        if (!v47) {
          goto LABEL_136;
        }
        if (*(void *)(v47 + 496)) {
          uint64_t v47 = *(void *)(v47 + 496);
        }
        if (*(unsigned char *)(*(void *)(v47 + 376) + 264)) {
          goto LABEL_136;
        }
      }
      if (*(_WORD *)(v45 + 36) == 13)
      {
LABEL_136:
        uint64_t v45 = *(void *)(v45 + 88);
        *(void *)(a1 + 864) = v45;
        if (!v45) {
          goto LABEL_152;
        }
      }
      else
      {
LABEL_122:
        if (v38)
        {
          unint64_t v48 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 24), 0, memory_order_relaxed);
          if ((v48 & 0xFFFFFF) != ((v48 >> 24) & 0xFFFFF)) {
            goto LABEL_136;
          }
        }
        uint64_t v50 = (void *)(v45 + 104);
        uint64_t v49 = *(const void **)(v45 + 104);
        unint64_t v51 = *(void *)(v45 + 16);
        if ((v49 == (const void *)3735928559) == ((v51 >> 41) & 1)) {
          panic("dirty object flush state inconsistent: oid %lld flags 0x%llx 0x%x fl %p\n", *(void *)(v45 + 112), v51, *(_DWORD *)(v45 + 32), v49);
        }
        if ((v51 & 0x20000000000) != 0 && *v50 != 3735928559) {
          goto LABEL_138;
        }
        if (v45 != v43) {
          unsigned int v139 = 16000;
        }
        *(void *)(a1 + 864) = v45;
        uint64_t v43 = v45;
        if (sub_10001D40C((void *)v45, (int *)&v139, 1, 2))
        {
          if (v139 > 0x773593FF)
          {
            uint64_t v52 = *(void *)(v45 + 8);
            if (!v52) {
              uint64_t v52 = *(void *)(*(void *)v45 + 392);
            }
            if (nx_ratelimit_log_allowed(*(void *)(*(void *)v52 + 392))) {
              log_debug((uint64_t)"%s:%d: %s oid %lld flags 0x%llx 0x%x refs 0x%llx taking too long to get reference!\n", v53, v54, v55, v56, v57, v58, v59, (uint64_t)"obj_cache_flush_prepare");
            }
          }
          uint64_t v43 = v45;
        }
        else
        {
LABEL_138:
          uint64_t v60 = *(void *)(v45 + 88);
          *(void *)(a1 + 864) = v60;
          if (!*(_DWORD *)(a1 + 884)) {
            panic("virtual object dirty count underflow\n");
          }
          uint64_t v61 = *(void **)(v45 + 96);
          if (v60)
          {
            *(void *)(v60 + 96) = v61;
            uint64_t v61 = *(void **)(v45 + 96);
          }
          else
          {
            *(void *)(a1 + 808) = v61;
          }
          *uint64_t v61 = v60;
          --*(_DWORD *)(a1 + 884);
          *(void *)(v45 + 88) = 3735928559;
          atomic_fetch_and_explicit((atomic_uint *volatile)(v45 + 32), 0xFFFFFFFE, memory_order_relaxed);
          *(void *)(v45 + 16) |= 0x20000000000uLL;
          if ((a3 & 2) != 0) {
            *(void *)(v45 + 64) = *(void *)(v45 + 56);
          }
          if (*v50 == 3735928559)
          {
            *(void *)(v45 + 104) = 0;
            **(void **)(a1 + 840) = v45;
            *(void *)(a1 + 840) = v50;
            ++*(_DWORD *)(a1 + 904);
          }
          v39 += v134;
        }
        uint64_t v45 = *(void *)(a1 + 864);
        unsigned int v38 = v137;
        if (!v45) {
          goto LABEL_152;
        }
      }
    }
    int v41 = 3;
LABEL_152:
    int v62 = pthread_rwlock_unlock(v133);
    if (v62) {
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 1217, v62);
    }
    obj_cache_unlock_write(a1);
    uint64_t v65 = v42 + 13;
    if (!v42) {
      uint64_t v65 = (uint64_t *)(a1 + 832);
    }
    uint64_t v66 = *v65;
    if (v66) {
      break;
    }
LABEL_163:
    pthread_mutex_lock((pthread_mutex_t *)a1);
    int v69 = pthread_rwlock_wrlock(v133);
    if (v69) {
      panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 1244, v69);
    }
    BOOL v79 = v41++ < 2;
    unsigned int v38 = v137;
    if (!v79)
    {
      a4 = v136;
LABEL_174:
      uint64_t v78 = *(void *)(a1 + 816);
      if (v38) {
        BOOL v79 = v40 < 1;
      }
      else {
        BOOL v79 = 0;
      }
      char v80 = v79;
      if (v78 && (v80 & 1) == 0)
      {
        if (v137) {
          int v81 = -1;
        }
        else {
          int v81 = 0;
        }
        int v135 = v81;
        do
        {
          if (*(_DWORD *)(v78 + 36) >> 30 != 1) {
            panic("non-physical object on physical object dirty list: oid %lld flags 0x%llx 0x%x\n", *(void *)(v78 + 112), *(void *)(v78 + 16), *(_DWORD *)(v78 + 32));
          }
          int v82 = *(_DWORD *)(v78 + 32);
          if ((v82 & 1) == 0) {
            panic("physical object on dirty list not dirty: oid %lld flags 0x%llx 0x%x\n", *(void *)(v78 + 112), *(void *)(v78 + 16), v82);
          }
          uint64_t v84 = (void *)(v78 + 104);
          uint64_t v83 = *(const void **)(v78 + 104);
          unint64_t v85 = *(void *)(v78 + 16);
          if ((v83 == (const void *)3735928559) == ((v85 >> 41) & 1)) {
            panic("dirty object flush state inconsistent: oid %lld flags 0x%llx 0x%x fl %p\n", *(void *)(v78 + 112), v85, *(_DWORD *)(v78 + 32), v83);
          }
          if ((v85 & 0x20000000000) == 0 || *v84 == 3735928559)
          {
            unsigned int v139 = 16000;
            if (sub_10001D40C((void *)v78, (int *)&v139, 1, 2))
            {
              do
              {
                if (v139 > 0x773593FF)
                {
                  uint64_t v86 = *(void *)(v78 + 8);
                  if (!v86) {
                    uint64_t v86 = *(void *)(*(void *)v78 + 392);
                  }
                  if (nx_ratelimit_log_allowed(*(void *)(*(void *)v86 + 392))) {
                    log_debug((uint64_t)"%s:%d: %s oid %lld flags 0x%llx 0x%x refs 0x%llx taking too long to get reference!\n", v87, v88, v89, v90, v91, v92, v93, (uint64_t)"obj_cache_flush_prepare");
                  }
                }
              }
              while ((sub_10001D40C((void *)v78, (int *)&v139, 1, 2) & 1) != 0);
            }
          }
          if (!*(_DWORD *)(a1 + 888)) {
            panic("physical object dirty count underflow\n");
          }
          uint64_t v94 = *(void *)(v78 + 88);
          uint64_t v95 = *(void **)(v78 + 96);
          if (v94)
          {
            *(void *)(v94 + 96) = v95;
            uint64_t v95 = *(void **)(v78 + 96);
          }
          else
          {
            *(void *)(a1 + 824) = v95;
          }
          void *v95 = v94;
          --*(_DWORD *)(a1 + 888);
          *(void *)(v78 + 88) = 3735928559;
          atomic_fetch_and_explicit((atomic_uint *volatile)(v78 + 32), 0xFFFFFFFE, memory_order_relaxed);
          *(void *)(v78 + 16) |= 0x20000000000uLL;
          if ((a3 & 2) != 0) {
            *(void *)(v78 + 64) = *(void *)(v78 + 56);
          }
          if (*v84 == 3735928559)
          {
            *(void *)(v78 + 104) = 0;
            **(void **)(a1 + 840) = v78;
            *(void *)(a1 + 840) = v84;
            ++*(_DWORD *)(a1 + 904);
          }
          v40 += v135;
          uint64_t v78 = *(void *)(a1 + 816);
          if (v137) {
            BOOL v96 = v40 < 1;
          }
          else {
            BOOL v96 = 0;
          }
          int v97 = v96;
          a4 = v136;
        }
        while (v78 && !v97);
      }
      int v98 = pthread_rwlock_unlock(v133);
      if (v98) {
        panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 1305, v98);
      }
      obj_cache_unlock_write(a1);
      uint64_t v101 = (void **)(v42 + 13);
      if (!v42) {
        uint64_t v101 = (void **)(a1 + 832);
      }
      uint64_t v102 = *v101;
      if (*v101)
      {
        while (1)
        {
          uint64_t v103 = obj_write_prepare((uint64_t)v102, 0, a4, v99, v100);
          if (v103) {
            break;
          }
          if ((a3 & 2) != 0)
          {
            uint64_t v104 = v102[19];
            if (!v104) {
              uint64_t v104 = v102[16];
            }
            v102[17] = v104;
          }
          uint64_t v102 = (void *)v102[13];
          if (!v102) {
            goto LABEL_229;
          }
        }
        uint64_t v7 = v103;
        if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 392) + 400) + 76))
        {
          uint64_t v132 = v102[1];
          if (!v132) {
            uint64_t v132 = *(void *)(*v102 + 392);
          }
          if (nx_ratelimit_log_allowed(*(void *)(*(void *)v132 + 392))) {
            goto LABEL_290;
          }
        }
        return v7;
      }
LABEL_229:
      int v105 = *(_DWORD *)(a1 + 904);
      if (v105 >= 2)
      {
        uint64_t v106 = 0;
        uint64_t v107 = *(void **)(a1 + 832);
        for (int k = 1; k < v105; k *= 2)
        {
          if (v107)
          {
            uint64_t v109 = 0;
            char v110 = 1;
            uint64_t v111 = v107;
            while (1)
            {
              int v112 = k;
              uint64_t v113 = v111;
              if (k >= 2) {
                break;
              }
              uint64_t v114 = (void *)v111[13];
              uint64_t v113 = v111;
              uint64_t v116 = v114;
              if (!v114) {
                goto LABEL_279;
              }
LABEL_241:
              uint64_t v118 = v111[19];
              if (!v118) {
                uint64_t v118 = v111[16];
              }
              uint64_t v119 = v114[19];
              if (!v119) {
                uint64_t v119 = v114[16];
              }
              uint64_t v120 = (void *)v116[13];
              BOOL v121 = v118 <= v119;
              if (v118 > v119) {
                uint64_t v122 = v114;
              }
              else {
                uint64_t v122 = (void *)v116[13];
              }
              if (v118 > v119) {
                uint64_t v123 = v111;
              }
              else {
                uint64_t v123 = v114;
              }
              if (v121) {
                uint64_t v106 = v116;
              }
              else {
                uint64_t v106 = v113;
              }
              if (!v121)
              {
                uint64_t v113 = v116;
                uint64_t v111 = v114;
              }
              if (v111 == v113 || v123 == v122)
              {
                uint64_t v125 = v111;
              }
              else
              {
                uint64_t v124 = v111;
                do
                {
                  uint64_t v125 = (void *)v124[13];
                  uint64_t v126 = v125[19];
                  if (!v126) {
                    uint64_t v126 = v125[16];
                  }
                  uint64_t v127 = v123[19];
                  if (!v127) {
                    uint64_t v127 = v123[16];
                  }
                  if (v126 > v127)
                  {
                    uint64_t v128 = (void *)v123[13];
                    v123[13] = v125;
                    v124[13] = v123;
                    uint64_t v125 = v123;
                    uint64_t v123 = v128;
                  }
                  BOOL v129 = v125 == v113 || v123 == v122;
                  uint64_t v124 = v125;
                }
                while (!v129);
              }
              if (v125 == v113) {
                v113[13] = v123;
              }
              else {
                uint64_t v106 = v113;
              }
              int v130 = v109 + 13;
              if (v110)
              {
                int v130 = (void *)(a1 + 832);
                uint64_t v107 = v111;
              }
              *int v130 = v111;
              uint64_t v109 = v106;
              uint64_t v111 = v120;
              char v110 = 0;
              if (!v120)
              {
                uint64_t v109 = v106;
                goto LABEL_279;
              }
            }
            while (1)
            {
              uint64_t v113 = (void *)v113[13];
              if (!v113) {
                break;
              }
              if (--v112 < 2)
              {
                uint64_t v114 = (void *)v113[13];
                int v115 = k;
                uint64_t v116 = v114;
                if (!v114) {
                  break;
                }
                while (1)
                {
                  uint64_t v117 = (void *)v116[13];
                  if (!v117) {
                    goto LABEL_241;
                  }
                  --v115;
                  uint64_t v116 = (void *)v116[13];
                  if (v115 < 2)
                  {
                    uint64_t v116 = v117;
                    goto LABEL_241;
                  }
                }
              }
            }
LABEL_279:
            if (v109) {
              v109[13] = v111;
            }
          }
        }
        if (v106)
        {
          uint64_t v7 = 0;
          *(void *)(a1 + 840) = v106 + 13;
          return v7;
        }
      }
      return 0;
    }
  }
  while (1)
  {
    long long v42 = (uint64_t *)v66;
    uint64_t v67 = obj_write_prepare(v66, 0, v136, v63, v64);
    if (v67) {
      break;
    }
    if ((a3 & 2) != 0)
    {
      uint64_t v68 = v42[19];
      if (!v68) {
        uint64_t v68 = v42[16];
      }
      v42[17] = v68;
    }
    uint64_t v66 = v42[13];
    if (!v66) {
      goto LABEL_163;
    }
  }
  uint64_t v7 = v67;
  if (!*(_DWORD *)(*(void *)(*(void *)(a1 + 392) + 400) + 76))
  {
    uint64_t v70 = v42[1];
    if (!v70) {
      uint64_t v70 = *(void *)(*v42 + 392);
    }
    if (nx_ratelimit_log_allowed(*(void *)(*(void *)v70 + 392))) {
LABEL_290:
    }
      log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error preparing for write: %d\n", v71, v72, v73, v74, v75, v76, v77, (uint64_t)"obj_cache_flush_prepare");
  }
  return v7;
}

uint64_t obj_type_and_flags(uint64_t a1)
{
  return *(unsigned int *)(a1 + 36);
}

uint64_t obj_type(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 36);
}

uint64_t obj_refcount(uint64_t a1)
{
  unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 24), 0, memory_order_relaxed);
  return (add_explicit & 0xFFFFFF) - ((add_explicit >> 24) & 0xFFFFF);
}

uint64_t sub_10001D40C(void *a1, int *a2, int a3, int a4)
{
  uint64_t v4 = *a1;
  unint64_t add_explicit = atomic_fetch_add_explicit(a1 + 3, 0x1000001uLL, memory_order_relaxed);
  if ((add_explicit & 0xFFFFFF) >= 0x186A1) {
    sub_10005E648();
  }
  uint64_t v10 = (add_explicit >> 24) & 0xFFFFF;
  if (v10 == 0xFFFFF) {
    panic("Get count overflowed for object %p!\n", a1);
  }
  BOOL v11 = (-(add_explicit >> 44) & 0xFFFFF) != 0 && (add_explicit & 0xFFFFFF) == v10;
  if (v11 && (-(atomic_fetch_add_explicit(a1 + 3, 0, memory_order_relaxed) >> 44) & 0xFFFFF) != 0)
  {
    atomic_fetch_or_explicit((atomic_uint *volatile)a1 + 8, 2u, memory_order_relaxed);
    atomic_fetch_add_explicit(a1 + 3, 0xFFFFFFFFFEFFFFFFLL, memory_order_relaxed);
    if (a3)
    {
      int v12 = pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 128));
      if (v12) {
        panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 3966, v12);
      }
    }
    uint64_t v13 = *a2 % 0x3B9ACA00u;
    v18.__darwin_time_t tv_sec = *a2 / 0x3B9ACA00uLL;
    v18.int tv_nsec = v13;
    if (a4 == 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = 2;
    }
    if (cv_wait_rw((pthread_cond_t *)(v4 + 1296), (pthread_mutex_t *)v4, v14, &v18) == 35
      && *a2 != 2000000000)
    {
      if ((4 * *a2) >= 0x77359400) {
        int v15 = 2000000000;
      }
      else {
        int v15 = 4 * *a2;
      }
      *a2 = v15;
    }
    if (a3)
    {
      int v16 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 128));
      if (v16) {
        panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 3983, v16);
      }
    }
    return 1;
  }
  else
  {
    uint64_t result = 0;
    atomic_fetch_add_explicit(a1 + 3, 0xFFFFFFFFFF000000, memory_order_relaxed);
  }
  return result;
}

uint64_t obj_write_prepare(uint64_t a1, int a2, uint64_t a3, int8x16_t a4, int8x16_t a5)
{
  uint64_t v5 = *(void *)(*(void *)a1 + 392);
  if (*(void *)(a1 + 8)) {
    unsigned int v6 = *(void **)(a1 + 8);
  }
  else {
    unsigned int v6 = *(void **)(*(void *)a1 + 392);
  }
  if (*(unsigned char *)(v5 + 627)) {
    return 30;
  }
  uint64_t v12 = (*(_DWORD *)(*(void *)(v5 + 376) + 36) + *(_DWORD *)(a1 + 48) - 1)
      / *(_DWORD *)(*(void *)(v5 + 376) + 36);
  uint64_t v14 = (void *)(a1 + 144);
  unint64_t v13 = *(void *)(a1 + 144);
  uint64_t v15 = *(void *)(a1 + 16);
  unint64_t v16 = *(void *)(a1 + 120);
  unint64_t v70 = v16;
  if (*(void *)(a1 + 152))
  {
    unint64_t v71 = *(void *)(a1 + 152);
  }
  else
  {
    unint64_t v71 = *(void *)(a1 + 128);
    if (!v71)
    {
      if ((v15 & 0xC0000000) != 0)
      {
        if (nx_ratelimit_log_allowed(*(void *)(*v6 + 392))) {
          log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x non-virtual object missing paddr!\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"obj_write_prepare");
        }
        return 22;
      }
      if ((v15 & 0x40) == 0)
      {
        uint64_t v40 = v12;
        uint64_t v41 = omap_get((uint64_t)v6, *(void *)(a1 + 112), v16, &v71, 0, 0, 0);
        unint64_t v16 = v70;
        uint64_t v12 = v40;
        if ((v41 & 0xFFFFFFFD) != 0)
        {
          uint64_t v7 = v41;
          if (!nx_ratelimit_log_allowed(*(void *)(*v6 + 392))) {
            return v7;
          }
          int v39 = "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error getting mapping to write %d\n";
LABEL_69:
          log_err((uint64_t)v39, v25, v26, v27, v28, v29, v30, v31, (uint64_t)"obj_write_prepare");
          return v7;
        }
      }
      goto LABEL_48;
    }
  }
  if ((v15 & 0xC0000000) != 0)
  {
    uint64_t v69 = v12;
    unint64_t v17 = 0;
    unint64_t v18 = 0;
    int v19 = 0;
    goto LABEL_12;
  }
LABEL_48:
  uint64_t v69 = v12;
  if (v13 == v16)
  {
    unint64_t v17 = v71;
  }
  else
  {
    unint64_t v17 = v71;
    if (a2 || v13) {
      goto LABEL_57;
    }
  }
  unint64_t v42 = v17;
  unint64_t v17 = 0;
  if (v42)
  {
    int v19 = 0;
LABEL_54:
    uint64_t v43 = *(void *)(a1 + 152);
    if (!v43)
    {
      unint64_t v18 = 0;
      goto LABEL_12;
    }
    unint64_t v18 = 0;
    if (v43 == *(void *)(a1 + 128))
    {
LABEL_12:
      if ((*(void *)(a1 + 16) & 0x80020000000) == 0)
      {
        uint64_t v20 = *(unint64_t **)(a1 + 56);
        a4.i64[0] = *(void *)(a1 + 36);
        _DWORD v20[3] = a4.i64[0];
        if (v13) {
          unint64_t v21 = v13;
        }
        else {
          unint64_t v21 = v16;
        }
        v20[1] = *(void *)(a1 + 112);
        v20[2] = v21;
        obj_checksum_set_phys(*(void *)(*(void *)a1 + 392), v20, *(_DWORD *)(a1 + 48), a4, a5);
        uint64_t v22 = *(void *)(a1 + 56);
        if ((*(_DWORD *)(a1 + 16) & 0xC0000040) == 0 && *(void *)(a1 + 112) != *(void *)(v22 + 8)) {
          sub_10005E6A0();
        }
        if (!*(void *)(v22 + 16)) {
          sub_10005E674();
        }
      }
      uint64_t v7 = 0;
      goto LABEL_20;
    }
    goto LABEL_78;
  }
LABEL_57:
  BOOL v44 = a2 == 0;
  uint64_t v45 = *(void *)(a1 + 16);
  BOOL v46 = (v45 & 0xC00000000) != 0;
  if ((v45 & 0x800000000) != 0) {
    int v47 = 113;
  }
  else {
    int v47 = 105;
  }
  int v19 = v44 && v46;
  if (v44 && v46) {
    int v48 = v47;
  }
  else {
    int v48 = 72;
  }
  if ((v45 & 0x10000000) != 0)
  {
    unint64_t v71 = 0;
  }
  else
  {
    if (*(_WORD *)(a1 + 36) == 11 || *(_WORD *)(a1 + 40) == 11) {
      unint64_t v49 = 2;
    }
    else {
      unint64_t v49 = 1;
    }
    unint64_t v71 = v49;
  }
  uint64_t v50 = spaceman_alloc(v6, v48, v12, a3, &v71, 0);
  if (v50)
  {
    uint64_t v7 = v50;
    if (nx_ratelimit_log_allowed(*(void *)(*v6 + 392))) {
      log_err((uint64_t)"%s:%d: %s oid %lld flags 0x%llx 0x%x type 0x%x/0x%x xid %lld (cur xid %lld) error allocating space to write %d; blkcount %d (o_size_phys %d) paddr %lld\n",
    }
        v51,
        v52,
        v53,
        v54,
        v55,
        v56,
        v57,
        (uint64_t)"obj_write_prepare");
    unint64_t v18 = 0;
    int v19 = 0;
    goto LABEL_90;
  }
  if (*(void *)(a1 + 8)) {
    apfs_check_for_spillover();
  }
  unint64_t v16 = v70;
  unint64_t v18 = v71;
  uint64_t v43 = v71;
  if (!v71) {
    goto LABEL_54;
  }
LABEL_78:
  unint64_t v71 = v43;
  uint64_t v58 = *(void *)(a1 + 16);
  unsigned int v59 = (v58 >> 2) & 0x700 | (v58 >> 8) & 0xE0 | 4;
  if ((v58 & 0x10000000) == 0) {
    unsigned int v59 = 0;
  }
  if (v13) {
    unint64_t v60 = v13;
  }
  else {
    unint64_t v60 = v16;
  }
  uint64_t v61 = omap_set((uint64_t)v6, *(void *)(a1 + 112), v60, v43, *(_DWORD *)(a1 + 48), v59 | (v58 >> 26) & 8, a3);
  if (!v61)
  {
    unint64_t v16 = v70;
    goto LABEL_12;
  }
  uint64_t v7 = v61;
  if (nx_ratelimit_log_allowed(*(void *)(*v6 + 392))) {
    log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error setting mapping for write %d\n", v62, v63, v64, v65, v66, v67, v68, (uint64_t)"obj_write_prepare");
  }
  if (!a2)
  {
LABEL_20:
    pthread_mutex_lock(*(pthread_mutex_t **)a1);
    if (v18) {
      *(void *)(a1 + 152) = v18;
    }
    if (v19) {
      goto LABEL_23;
    }
    goto LABEL_24;
  }
LABEL_90:
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  unint64_t v17 = v18;
  if (v19) {
LABEL_23:
  }
    *(void *)(a1 + 16) &= 0xFFFFFFF3FFFFFFFFLL;
LABEL_24:
  if (!v7)
  {
    uint64_t v23 = *(void *)(a1 + 16);
    if ((v23 & 0x40) != 0) {
      *(void *)(a1 + 16) = v23 & 0xFFFFFFFFFFFFFFBFLL;
    }
    if (v13) {
      *(void *)(a1 + 120) = v13;
    }
    uint64_t v24 = *(void *)(a1 + 152);
    if (v24) {
      *(void *)(a1 + 128) = v24;
    }
    if ((atomic_fetch_or_explicit((atomic_uint *volatile)(a1 + 32), 0, memory_order_relaxed) & 1) == 0)
    {
      *uint64_t v14 = 0;
      v14[1] = 0;
    }
  }
  obj_cache_unlock_write(*(void *)a1);
  if (v17)
  {
    if (v13)
    {
      if (omap_delete((uint64_t)v6, *(void *)(a1 + 112), v70, v17, *(_DWORD *)(a1 + 48), 0, a3)
        && nx_ratelimit_log_allowed(*(void *)(*v6 + 392)))
      {
        int v39 = "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error deleting old mapping %d\n";
        goto LABEL_69;
      }
    }
    else if (spaceman_free(v6, 0, v17, v69, a3) {
           && nx_ratelimit_log_allowed(*(void *)(*v6 + 392)))
    }
    {
      int v39 = "%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error freeing old location %d\n";
      goto LABEL_69;
    }
  }
  return v7;
}

void obj_cache_flush_unprepare(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  int v2 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v2) {
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 1354, v2);
  }
  for (uint64_t i = *(void *)(a1 + 832); i; uint64_t i = *(void *)(i + 104))
  {
    if ((atomic_fetch_or_explicit((atomic_uint *volatile)(i + 32), 1u, memory_order_relaxed) & 1) == 0)
    {
      uint64_t v4 = i + 88;
      if (*(void *)(i + 88) != 3735928559) {
        sub_10005E6CC();
      }
      int v5 = *(_DWORD *)(i + 36) >> 30;
      if (v5)
      {
        if (v5 != 1) {
          panic("bad object type in flush list: oid %lld flags 0x%llx 0x%x\n", *(void *)(i + 112), *(void *)(i + 16), *(_DWORD *)(i + 32));
        }
        uint64_t v7 = *(void **)(a1 + 824);
        *(void *)(i + 88) = 0;
        *(void *)(i + 96) = v7;
        *uint64_t v7 = i;
        *(void *)(a1 + 824) = v4;
        ++*(_DWORD *)(a1 + 888);
      }
      else
      {
        unsigned int v6 = *(void **)(a1 + 808);
        *(void *)(i + 88) = 0;
        *(void *)(i + 96) = v6;
        *unsigned int v6 = i;
        *(void *)(a1 + 808) = v4;
        ++*(_DWORD *)(a1 + 884);
      }
    }
    uint64_t v8 = *(void *)(i + 16);
    *(void *)(i + 16) = v8 & 0xFFFFFDFFFFFFFFFFLL;
    if ((v8 & 0x80) != 0)
    {
      *(void *)(i + 16) = v8 & 0xFFFFFDFFFFFFFF7FLL;
      cv_wakeup((pthread_cond_t *)(a1 + 1296));
    }
  }
  int v9 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
  if (v9) {
    panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 1374, v9);
  }
  obj_cache_unlock_write(a1);
  uint64_t v10 = *(void *)(a1 + 832);
  if (v10)
  {
    BOOL v11 = (uint64_t *)(a1 + 832);
    do
    {
      uint64_t v12 = *(void *)(v10 + 104);
      *BOOL v11 = v12;
      if (!v12) {
        *(void *)(a1 + 840) = v11;
      }
      *(void *)(v10 + 104) = 3735928559;
      --*(_DWORD *)(a1 + 904);
      unint64_t v13 = *(void **)(v10 + 64);
      if (v13)
      {
        if (v13 != *(void **)(v10 + 56)) {
          fs_obj_zfree_oc(v13, *(unsigned int *)(v10 + 48), *(void *)(v10 + 16), a1);
        }
        *(void *)(v10 + 64) = 0;
        *(void *)(v10 + 136) = 0;
      }
      obj_release((uint64_t *)v10);
      uint64_t v10 = *v11;
    }
    while (*v11);
  }
  pthread_mutex_lock((pthread_mutex_t *)a1);
  if (*(_DWORD *)(a1 + 908) >= 2u) {
    cv_wakeup((pthread_cond_t *)(a1 + 1296));
  }
  *(_DWORD *)(a1 + 908) = 0;

  obj_cache_unlock_write(a1);
}

void obj_release(uint64_t *a1)
{
  uint64_t v3 = *a1;
  uint64_t v2 = a1[1];
  if (!v2) {
    uint64_t v2 = *(void *)(v3 + 392);
  }
  unint64_t add_explicit = atomic_fetch_add_explicit(a1 + 3, 0xFFFFEFFFFFFFFFFFLL, memory_order_relaxed);
  if ((add_explicit & 0xFFFFFF) == 0) {
    panic("Reference count underflowed for object %p!\n", a1);
  }
  uint64_t v5 = -(uint64_t)(add_explicit >> 44) & 0xFFFFF;
  if (v5 == 0x80000) {
    panic("Release count overflowed for object %p!\n", a1);
  }
  if ((add_explicit & 0xFFFFFF) >= 2)
  {
    unint64_t v6 = atomic_fetch_add_explicit(a1 + 3, 0x100000000000uLL, memory_order_relaxed);
    if ((v6 & 0xFFFFFF) == 0 && (-(v6 >> 44) & 0xFFFFF) == 1)
    {
      cv_wakeup((pthread_cond_t *)(v3 + 1296));
    }
    return;
  }
  int v7 = pthread_rwlock_trywrlock((pthread_rwlock_t *)(a1 + 22));
  if (v7) {
    panic("%s:%d: trywrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 5008, v7);
  }
  int v8 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 22));
  if (v8) {
    panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 5008, v8);
  }
  uint64_t v9 = a1[2];
  if ((v9 & 0xC) != 0
    || (v9 & 0xC00000000) != 0
    && (atomic_fetch_or_explicit((atomic_uint *volatile)a1 + 8, 0, memory_order_relaxed) & 1) == 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)v3);
    char v10 = 0;
    uint64_t v9 = a1[2];
    if (v5 && (v9 & 8) != 0)
    {
      if ((-(atomic_fetch_add_explicit(a1 + 3, 0, memory_order_relaxed) >> 44) & 0xFFFFE) != 0)
      {
        do
        {
          long long v29 = xmmword_100076E10;
          cv_wait_rw((pthread_cond_t *)(v3 + 1296), (pthread_mutex_t *)v3, 2, (timespec *)&v29);
        }
        while ((-(atomic_fetch_add_explicit(a1 + 3, 0, memory_order_relaxed) >> 44) & 0xFFFFE) != 0);
        char v10 = 0;
        uint64_t v9 = a1[2];
      }
      else
      {
        char v10 = 0;
      }
    }
  }
  else
  {
    char v10 = 1;
  }
  if ((v9 & 0x80000008) == 0 && *((_WORD *)a1 + 18) != 13 && (a1[4] & 1) == 0)
  {
    int v11 = pthread_rwlock_rdlock((pthread_rwlock_t *)(v3 + 128));
    if (v11) {
      panic("%s:%d: rdlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 5039, v11);
    }
    sub_100023980(v3, (uint64_t)a1);
    int v12 = pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 128));
    if (v12) {
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 5041, v12);
    }
  }
  uint64_t v13 = a1[2];
  if (v10)
  {
    uint64_t v14 = 0;
    unsigned int v15 = 0;
    unsigned int v16 = 0;
    goto LABEL_44;
  }
  if ((v13 & 4) != 0)
  {
    unint64_t v17 = v13 & 0xFFFFFFFFFFFFFFFBLL;
    a1[2] = v13 & 0xFFFFFFFFFFFFFFFBLL;
    uint64_t v14 = a1;
  }
  else
  {
    uint64_t v14 = 0;
    unint64_t v17 = a1[2];
  }
  if ((v17 & 0xC00000000) != 0)
  {
    char v18 = atomic_fetch_or_explicit((atomic_uint *volatile)a1 + 8, 0, memory_order_relaxed);
    if ((v17 & 8) != 0 || (v18 & 1) == 0)
    {
      unsigned int v19 = *(_DWORD *)(*(void *)(*(void *)(v3 + 392) + 376) + 36);
      unsigned int v16 = (v19 + *((_DWORD *)a1 + 12) - 1) / v19;
      if ((v17 & 0x800000000) != 0) {
        unsigned int v15 = 80;
      }
      else {
        unsigned int v15 = 72;
      }
      v17 &= 0xFFFFFFF3FFFFFFFFLL;
      a1[2] = v17;
      if ((v17 & 8) == 0) {
        goto LABEL_43;
      }
LABEL_52:
      if ((v17 & 0x80000000) != 0)
      {
        obj_cache_ephemeral_adjust(v3, v17, *((_DWORD *)a1 + 12), -1);
      }
      else
      {
        int v20 = *(_DWORD *)(v3 + 684);
        if (!v20) {
          sub_10005E6F8();
        }
        *(_DWORD *)(v3 + 684) = v20 - 1;
      }
      atomic_fetch_add_explicit(a1 + 3, 0x100000000000uLL, memory_order_relaxed);
      char v21 = atomic_fetch_and_explicit((atomic_uint *volatile)a1 + 8, 0xFFFFFFFD, memory_order_relaxed);
      sub_100022918((uint64_t)a1, 0);
      obj_cache_unlock_write(v3);
      if ((v21 & 2) != 0) {
        goto LABEL_58;
      }
      goto LABEL_57;
    }
  }
  unsigned int v16 = 0;
  unsigned int v15 = 0;
  if ((v17 & 8) != 0) {
    goto LABEL_52;
  }
LABEL_43:
  obj_cache_unlock_write(v3);
LABEL_44:
  if ((atomic_fetch_and_explicit((atomic_uint *volatile)a1 + 8, 0xFFFFFFFD, memory_order_relaxed) & 2) != 0) {
    uint64_t v14 = a1;
  }
  if ((atomic_fetch_add_explicit(a1 + 3, 0x100000000000uLL, memory_order_relaxed) & 0xFFFFFF) != 0) {
    goto LABEL_58;
  }
LABEL_57:
  if (v14) {
LABEL_58:
  }
    cv_wakeup((pthread_cond_t *)(v3 + 1296));
  if (v16 && spaceman_unreserve(v2, v15, v16)) {
    log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error unreserving space on non-dirty release: %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"obj_release");
  }
}

void obj_was_being_written_wakeup(uint64_t a1)
{
  uint64_t v2 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  uint64_t v3 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = (v3 & 0x80 ^ 0xFFFFFDFFFFFFFFFFLL) & v3;
  obj_cache_unlock_write((uint64_t)v2);
  if ((v3 & 0x80) != 0)
  {
    cv_wakeup((pthread_cond_t *)&v2[20].__opaque[8]);
  }
}

uint64_t obj_cache_flush_write(pthread_mutex_t *a1, unsigned int a2)
{
  uint64_t sig = a1[13].__sig;
  if (!sig)
  {
LABEL_27:
    pthread_mutex_lock(a1);
    if (*(_DWORD *)&a1[14].__opaque[4] >= 2u) {
      cv_wakeup((pthread_cond_t *)&a1[20].__opaque[8]);
    }
    *(_DWORD *)&a1[14].__opaque[4] = 0;
    obj_cache_unlock_write((uint64_t)a1);
    uint64_t v5 = 0;
    if (*(_DWORD *)a1[14].__opaque) {
      sub_10005E724();
    }
    return v5;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v26 = a1 + 13;
  int v6 = (a2 >> 1) & 1;
  do
  {
    uint64_t v7 = *(void *)(sig + 104);
    while (1)
    {
      pthread_mutex_lock((pthread_mutex_t *)((char *)a1 + 328));
      if ((atomic_fetch_or_explicit((atomic_uint *volatile)(sig + 32), 8u, memory_order_acquire) & 8) == 0) {
        break;
      }
      pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
    }
    unsigned int v10 = obj_write_internal((void *)sig, v6, v8, v9);
    if (!v10)
    {
      char v21 = *(void **)(sig + 56);
      int v20 = *(void **)(sig + 64);
      *(void *)(sig + 64) = 0;
      *(void *)(sig + 136) = 0;
      atomic_fetch_and_explicit((atomic_uint *volatile)(sig + 32), 0xFFFFFFF7, memory_order_release);
      pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
      if (v20 && v20 != v21) {
        fs_obj_zfree_oc(v20, *(unsigned int *)(sig + 48), *(void *)(sig + 16), (uint64_t)a1);
      }
      if (v4)
      {
        uint64_t v22 = (pthread_mutex_t *)(v4 + 104);
        uint64_t v23 = *(void *)(*(void *)(v4 + 104) + 104);
        *(void *)(v4 + 104) = v23;
        if (v23)
        {
LABEL_17:
          *(void *)(sig + 104) = 3735928559;
          --*(_DWORD *)a1[14].__opaque;
          obj_was_being_written_wakeup(sig);
          obj_release((uint64_t *)sig);
          goto LABEL_22;
        }
      }
      else
      {
        uint64_t v24 = *(void *)(v26->__sig + 104);
        v26->__uint64_t sig = v24;
        uint64_t v22 = v26;
        if (v24) {
          goto LABEL_17;
        }
      }
      *(void *)a1[13].__opaque = v22;
      goto LABEL_17;
    }
    unsigned int v11 = v10;
    atomic_fetch_and_explicit((atomic_uint *volatile)(sig + 32), 0xFFFFFFF7, memory_order_release);
    pthread_mutex_unlock((pthread_mutex_t *)((char *)a1 + 328));
    uint64_t v12 = *(void *)(sig + 8);
    if (!v12) {
      uint64_t v12 = *(void *)(*(void *)sig + 392);
    }
    if (nx_ratelimit_log_allowed(*(void *)(*(void *)v12 + 392))) {
      log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error writing: %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"obj_cache_flush_write");
    }
    if (v5) {
      uint64_t v5 = v5;
    }
    else {
      uint64_t v5 = v11;
    }
    uint64_t v4 = sig;
LABEL_22:
    uint64_t sig = v7;
  }
  while (v7);
  if (!v5) {
    goto LABEL_27;
  }
  return v5;
}

uint64_t obj_write_internal(void *a1, int a2, int8x16_t a3, int8x16_t a4)
{
  uint64_t v5 = *(void *)(*a1 + 392);
  unsigned int v6 = *(_DWORD *)(*(void *)(v5 + 376) + 36);
  if (!a2)
  {
    uint64_t v7 = a1[7];
LABEL_7:
    uint64_t v8 = a1[19];
    if (!v8)
    {
      uint64_t v8 = a1[16];
      if (!v8) {
        panic("Object has no address: o %p oid %llu flags 0x%llx 0x%x paddr %llu naddr %llu\n", a1, a1[14], a1[2], *((_DWORD *)a1 + 8), 0, 0);
      }
    }
    goto LABEL_10;
  }
  uint64_t v7 = a1[8];
  if (!v7) {
    uint64_t v7 = a1[7];
  }
  uint64_t v8 = a1[17];
  if (!v8) {
    goto LABEL_7;
  }
LABEL_10:
  if (*(unsigned char *)(v5 + 627)) {
    return 30;
  }
  unint64_t v10 = a1[2];
  if ((v10 & 0x10000000) != 0)
  {
    uint64_t v12 = 0;
    LODWORD(v11) = 0;
    if ((v10 & 0x80000000000) != 0)
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v23 = a1[1];
      uint64_t v13 = 0;
      if (v23)
      {
        if ((unsigned __int16)v10 >> 13 == 1)
        {
          uint64_t v12 = v23 + 624;
        }
        else
        {
          if ((unsigned __int16)v10 >> 13) {
            panic("invalid crypto index %d\n");
          }
          uint64_t v12 = v23 + 528;
        }
        uint64_t v11 = (v10 >> 10) & 7;
        if (v11)
        {
          if (v11 != 1) {
            panic("invalid tweak type %d\n");
          }
          uint64_t v13 = a1[14] ^ HIDWORD(a1[15]) | a1[14] & 0xFFFFFFFF00000000 ^ (a1[15] << 32);
          LODWORD(v11) = 4;
        }
        else
        {
          uint64_t v13 = (v10 >> 10) & 7;
        }
      }
    }
  }
  else
  {
    LODWORD(v11) = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
  }
  unsigned int v14 = v6 + *((_DWORD *)a1 + 12) - 1;
  if (a2)
  {
    if ((v10 & 0x80020000000) == 0 && obj_checksum_verify_phys(v7, *((_DWORD *)a1 + 12), a3, a4))
    {
      uint64_t v15 = a1[1];
      if (v15) {
        BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(v15 + 392));
      }
      else {
        BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(*a1 + 392));
      }
      log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x paddr 0x%llx error verifying checksum, phys %p/%p buf %p &o_aflags %p &o_phys_flush %p\n", v17, v18, v19, v20, v21, v22, (uint64_t)"obj_write_internal");
    }
    if ((atomic_fetch_or_explicit((atomic_uint *volatile)a1 + 8, 0, memory_order_relaxed) & 1) != 0 && v7 == a1[7])
    {
      uint64_t v24 = a1[1];
      if (v24) {
        BOOL v25 = nx_is_panic_on_corruption_enabled(*(void *)(v24 + 392));
      }
      else {
        BOOL v25 = nx_is_panic_on_corruption_enabled(*(void *)(*a1 + 392));
      }
      log_corrupt(v25, (uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x paddr 0x%llx tx flushing dirty object WITHOUT flush buffer?!, phys %p/%p buf %p &o_aflags %p &o_phys_flush %p\n", v26, v27, v28, v29, v30, v31, (uint64_t)"obj_write_internal");
    }
  }
  uint64_t v32 = *(void *)(v5 + 384);
  if (v12 && *(void *)(a1[1] + 1144)) {
    uint64_t v32 = *(void *)(a1[1] + 1144);
  }

  return dev_write_extended(v32, v8, v14 / v6, v7, v12, v13, v11);
}

BOOL obj_cache_tx_start_closing(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 888) + *(_DWORD *)(a1 + 884);
  if (dev_is_solidstate(*(void *)(*(void *)(a1 + 392) + 384))) {
    unsigned int v2 = 1024;
  }
  else {
    unsigned int v2 = 256;
  }
  return v1 >= v2;
}

void obj_cache_remove(pthread_mutex_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = a2;
  if (!a2) {
    uint64_t v8 = *(void *)a1[6].__opaque;
  }
  pthread_mutex_lock(a1);
  uint64_t v9 = *(void *)(a1[11].__sig + 8 * (*(_DWORD *)&a1[10].__opaque[52] & a3));
  if (v9)
  {
    unint64_t v10 = 0;
    unint64_t v11 = 0;
    opaque = (uint64_t *)a1[11].__opaque;
    while (1)
    {
      while (1)
      {
        uint64_t v13 = v9;
        unsigned int v14 = (uint64_t *)(v9 + 72);
        uint64_t v9 = *(void *)(v9 + 72);
        if (v13 != a2 && *(void *)(v13 + 8) == a2)
        {
          uint64_t v15 = *(void *)(v13 + 16);
          if ((v15 & 0xC0000000) == 0 && *(void *)(v13 + 112) == a3 && *(void *)(v13 + 120) == a4) {
            break;
          }
        }
LABEL_18:
        if (!v9) {
          goto LABEL_27;
        }
      }
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 24), 0, memory_order_relaxed);
      if ((add_explicit & 0xFFFFFF) == ((add_explicit >> 24) & 0xFFFFF))
      {
        if ((v15 & 0xC00000000) != 0)
        {
          unsigned int v17 = *(_DWORD *)(*(void *)(*(void *)a1[6].__opaque + 376) + 36);
          uint64_t v18 = (v17 + *(_DWORD *)(v13 + 48) - 1) / v17;
          if ((v15 & 0x800000000) != 0) {
            uint64_t v19 = 0;
          }
          else {
            uint64_t v19 = v18;
          }
          v11 += v19;
          v10 += v18 & (v15 << 28 >> 63);
          *(void *)(v13 + 16) = v15 & 0xFFFFFFF3FFFFFFFFLL;
        }
        int v20 = *(_DWORD *)&a1[10].__opaque[36];
        if (!v20) {
          sub_10005E750();
        }
        *(_DWORD *)&a1[10].__opaque[36] = v20 - 1;
        sub_100022918(v13, 0);
        goto LABEL_18;
      }
      if (v15)
      {
        if (v9) {
          *(void *)(v9 + 80) = *(void *)(v13 + 80);
        }
        **(void **)(v13 + 80) = v9;
      }
      uint64_t v21 = *opaque;
      *unsigned int v14 = *opaque;
      if (v21) {
        *(void *)(v21 + 80) = v14;
      }
      uint64_t *opaque = v13;
      *(void *)(v13 + 80) = opaque;
      *(void *)(v13 + 16) = v15 | 9;
      if (!v9)
      {
LABEL_27:
        obj_cache_unlock_write((uint64_t)a1);
        if (v11 && spaceman_unreserve(v8, 0x48u, v11)) {
          log_err((uint64_t)"%s:%d: %s error unreserving space, %lld blocks: %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"obj_cache_remove");
        }
        if (v10)
        {
          if (spaceman_unreserve(v8, 0x50u, v10)) {
            log_err((uint64_t)"%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"obj_cache_remove");
          }
        }
        return;
      }
    }
  }

  obj_cache_unlock_write((uint64_t)a1);
}

void obj_cache_remove_reverted_fs_objects(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  log_debug((uint64_t)"%s:%d: %s removing reverted fs objects for fs %lld: %lld - %lld\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"obj_cache_remove_reverted_fs_objects");
  unint64_t v22 = *(unsigned int *)(a1 + 696);
  if (v22)
  {
    uint64_t v23 = 0;
    unint64_t v53 = 0;
    unint64_t v54 = 0;
    uint64_t v24 = (uint64_t *)(a1 + 712);
    while (1)
    {
      uint64_t v25 = *(void *)(*(void *)(a1 + 704) + 8 * v23);
      if (!v25) {
        goto LABEL_33;
      }
      do
      {
        while (1)
        {
          uint64_t v26 = v25;
          uint64_t v27 = (uint64_t *)(v25 + 72);
          uint64_t v25 = *(void *)(v25 + 72);
          if (v26 == a2 || *(void *)(v26 + 8) != a2 || (*(void *)(v26 + 16) & 0xC0000000) != 0) {
            goto LABEL_23;
          }
          unint64_t v28 = *(void *)(v26 + 120);
          if (v28 <= *(void *)(v26 + 144)) {
            unint64_t v28 = *(void *)(v26 + 144);
          }
          if (v28 < a3 || v28 > a4) {
            goto LABEL_23;
          }
          if (*(_DWORD *)(v26 + 32)) {
            log_debug((uint64_t)"%s:%d: %s danger: oid %lld type 0x%x/0x%x flags 0x%llx 0x%x xid %lld refs 0x%llx - is dirty\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"obj_cache_remove_reverted_fs_objects");
          }
          unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 24), 0, memory_order_relaxed);
          if ((add_explicit & 0xFFFFFF) != ((add_explicit >> 24) & 0xFFFFF)) {
            break;
          }
          uint64_t v31 = *(void *)(v26 + 16);
          if ((v31 & 0xC00000000) != 0)
          {
            unsigned int v32 = *(_DWORD *)(*(void *)(*(void *)(a1 + 392) + 376) + 36);
            uint64_t v33 = (v32 + *(_DWORD *)(v26 + 48) - 1) / v32;
            if ((v31 & 0x800000000) != 0) {
              uint64_t v34 = 0;
            }
            else {
              uint64_t v34 = v33;
            }
            v53 += v34;
            v54 += v33 & (v31 << 28 >> 63);
            *(void *)(v26 + 16) = v31 & 0xFFFFFFF3FFFFFFFFLL;
          }
          int v35 = *(_DWORD *)(a1 + 684);
          if (!v35) {
            sub_10005E77C();
          }
          *(_DWORD *)(a1 + 684) = v35 - 1;
          sub_100022918(v26, 0);
LABEL_23:
          if (!v25) {
            goto LABEL_32;
          }
        }
        log_debug((uint64_t)"%s:%d: %s danger: oid %lld type 0x%x/0x%x flags 0x%llx 0x%x xid %lld refs 0x%llx - has refs\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"obj_cache_remove_reverted_fs_objects");
        uint64_t v36 = *(void *)(v26 + 16);
        if (v36)
        {
          uint64_t v37 = *v27;
          if (*v27) {
            *(void *)(v37 + 80) = *(void *)(v26 + 80);
          }
          **(void **)(v26 + 80) = v37;
        }
        uint64_t v38 = *v24;
        *uint64_t v27 = *v24;
        if (v38) {
          *(void *)(v38 + 80) = v27;
        }
        *uint64_t v24 = v26;
        *(void *)(v26 + 80) = v24;
        *(void *)(v26 + 16) = v36 | 9;
      }
      while (v25);
LABEL_32:
      unint64_t v22 = *(unsigned int *)(a1 + 696);
LABEL_33:
      if (++v23 >= v22)
      {
        obj_cache_unlock_write(a1);
        if (v53)
        {
          log_debug((uint64_t)"%s:%d: %s unreserving %lld blocks for reverted fs objects\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"obj_cache_remove_reverted_fs_objects");
          if (spaceman_unreserve(a2, 0x48u, v53)) {
            log_err((uint64_t)"%s:%d: %s error unreserving space, %lld blocks: %d\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"obj_cache_remove_reverted_fs_objects");
          }
        }
        if (v54)
        {
          log_debug((uint64_t)"%s:%d: %s unreserving %lld blocks for reverted fs objects\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"obj_cache_remove_reverted_fs_objects");
          if (spaceman_unreserve(a2, 0x50u, v54)) {
            log_err((uint64_t)"%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n", v46, v47, v48, v49, v50, v51, v52, (uint64_t)"obj_cache_remove_reverted_fs_objects");
          }
        }
        return;
      }
    }
  }

  obj_cache_unlock_write(a1);
}

uint64_t obj_oid(uint64_t a1)
{
  return *(void *)(a1 + 112);
}

uint64_t obj_xid(uint64_t a1)
{
  if (*(void *)(a1 + 120) <= *(void *)(a1 + 144)) {
    return *(void *)(a1 + 144);
  }
  else {
    return *(void *)(a1 + 120);
  }
}

void obj_cache_remove_new_fs_objects(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = 0;
  uint64_t v37 = &v36;
  pthread_mutex_lock((pthread_mutex_t *)a1);
  int v4 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
  if (v4) {
    panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 1973, v4);
  }
  for (i = *(void *)(a1 + 800); i; uint64_t v37 = v7)
  {
    while (1)
    {
      uint64_t v6 = i;
      uint64_t v7 = (uint64_t *)(i + 88);
      uint64_t i = *(void *)(i + 88);
      if (*(v7 - 10) == a2 && (*(unsigned char *)(v6 + 19) & 0xC0) == 0 && !*(void *)(v6 + 128)) {
        break;
      }
      if (!i) {
        goto LABEL_14;
      }
    }
    int v8 = *(_DWORD *)(a1 + 884);
    if (!v8) {
      sub_10005E7D4();
    }
    uint64_t v9 = *(void **)(v6 + 96);
    if (i)
    {
      *(void *)(i + 96) = v9;
      uint64_t v9 = *(void **)(v6 + 96);
    }
    else
    {
      *(void *)(a1 + 808) = v9;
    }
    *uint64_t v9 = i;
    *(_DWORD *)(a1 + 884) = v8 - 1;
    uint64_t v10 = v37;
    *(void *)(v6 + 88) = 0;
    *(void *)(v6 + 96) = v10;
    uint64_t *v10 = v6;
  }
LABEL_14:
  int v11 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
  if (v11) {
    panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 1985, v11);
  }
  uint64_t v12 = v36;
  if (v36)
  {
    unint64_t v13 = 0;
    unint64_t v14 = 0;
    do
    {
      uint64_t v16 = *(void *)(v12 + 88);
      uint64_t v15 = *(uint64_t **)(v12 + 96);
      if (v16)
      {
        *(void *)(v16 + 96) = v15;
        uint64_t v15 = *(uint64_t **)(v12 + 96);
      }
      else
      {
        uint64_t v37 = *(uint64_t **)(v12 + 96);
      }
      *uint64_t v15 = v16;
      *(void *)(v12 + 88) = 3735928559;
      uint64_t v17 = *(void *)(v12 + 16);
      if ((v17 & 0xC00000000) != 0)
      {
        unsigned int v18 = *(_DWORD *)(*(void *)(*(void *)(a1 + 392) + 376) + 36);
        uint64_t v19 = (v18 + *(_DWORD *)(v12 + 48) - 1) / v18;
        if ((v17 & 0x800000000) != 0) {
          uint64_t v20 = 0;
        }
        else {
          uint64_t v20 = v19;
        }
        v14 += v20;
        v13 += v19 & (v17 << 28 >> 63);
        *(void *)(v12 + 16) = v17 & 0xFFFFFFF3FFFFFFFFLL;
      }
      int v21 = *(_DWORD *)(a1 + 684);
      if (!v21) {
        sub_10005E7A8();
      }
      *(_DWORD *)(a1 + 684) = v21 - 1;
      sub_100022918(v12, 0);
      uint64_t v12 = v16;
    }
    while (v16);
    obj_cache_unlock_write(a1);
    if (v14 && spaceman_unreserve(a2, 0x48u, v14)) {
      log_err((uint64_t)"%s:%d: %s error unreserving space, %lld blocks: %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"obj_cache_remove_new_fs_objects");
    }
    if (v13)
    {
      if (spaceman_unreserve(a2, 0x50u, v13)) {
        log_err((uint64_t)"%s:%d: %s error unreserving tier2 space, %lld blocks: %d\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"obj_cache_remove_new_fs_objects");
      }
    }
  }
  else
  {
    obj_cache_unlock_write(a1);
  }
}

uint64_t obj_subtype(uint64_t a1)
{
  return *(unsigned __int16 *)(a1 + 40);
}

uint64_t obj_flags(uint64_t a1)
{
  return *(void *)(a1 + 16);
}

uint64_t obj_size_phys(uint64_t a1)
{
  return *(unsigned int *)(a1 + 48);
}

uint64_t obj_type_is_or_contains_ephemeral(int a1)
{
  if (a1 < 0) {
    return 1;
  }
  char v1 = a1;
  if ((unsigned __int16)a1 > 0xDu) {
    return 0;
  }
  uint64_t result = 1;
  if (((1 << v1) & 0x2832) == 0) {
    return 0;
  }
  return result;
}

uint64_t obj_create_bootstrap(pthread_mutex_t *a1, int a2, unint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  if (a6 >= 0x1000) {
    return sub_10001F1DC(a1, a2, a3, a4, a5, a6, 0, 0, a7, 1, a8);
  }
  else {
    return 22;
  }
}

uint64_t sub_10001F1DC(pthread_mutex_t *a1, int a2, unint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, unint64_t a8, uint64_t a9, char a10, uint64_t *a11)
{
  uint64_t v11 = *(void *)a1[6].__opaque;
  if (a7) {
    uint64_t v12 = a7;
  }
  else {
    uint64_t v12 = *(void *)a1[6].__opaque;
  }
  uint64_t v90 = 0;
  unsigned int v89 = 0;
  if ((a2 & 0x7FF03FB) != 0) {
    sub_10005E884();
  }
  uint64_t v15 = a6;
  if ((a10 & 1) == 0 && !v11) {
    sub_10005E858();
  }
  if (!a4) {
    return 22;
  }
  if (a4[3] < 0x178) {
    return 22;
  }
  if (!a6)
  {
    uint64_t v15 = a4[2];
    if (!v15)
    {
      if (!v11) {
        return 22;
      }
      uint64_t v15 = *(unsigned int *)(*(void *)(v11 + 376) + 36);
      if (!v15) {
        return 22;
      }
    }
  }
  if ((a10 & 1) == 0 && v15 % *(_DWORD *)(*(void *)(v11 + 376) + 36)) {
    return 22;
  }
  unsigned int v21 = a2 | (*((unsigned __int16 *)a4 + 1) << 16);
  unsigned int v22 = v21 >> 31;
  unsigned int v23 = v21 >> 30;
  if (!(v21 >> 30)) {
    ++v22;
  }
  uint64_t v19 = 22;
  if ((v21 & 0x88000000) == 0x8000000 || v22 + ((v21 & 0x40000000) >> 30) != 1) {
    return v19;
  }
  if (!v23 && a10) {
    sub_10005E800();
  }
  uint64_t v24 = a2 | (*((unsigned __int16 *)a4 + 1) << 16);
  if (a7)
  {
    uint64_t v24 = a2 | (*((unsigned __int16 *)a4 + 1) << 16);
    if (!v23)
    {
      uint64_t v25 = *(void *)(a7 + 496);
      if (!v25) {
        uint64_t v25 = a7;
      }
      if (*(unsigned char *)(*(void *)(v25 + 376) + 264))
      {
        uint64_t v24 = v21 & 0xEFFF03FF;
      }
      else
      {
        if (a4[1] == 36) {
          int v26 = 268443648;
        }
        else {
          int v26 = 0x10000000;
        }
        int v80 = v26;
        uint64_t v82 = v12;
        uint64_t v27 = a5;
        BOOL has_secondary_fsroot = apfs_has_secondary_fsroot(a7);
        unsigned int v23 = 0;
        a5 = v27;
        uint64_t v12 = v82;
        if (has_secondary_fsroot) {
          int v29 = 1024;
        }
        else {
          int v29 = 0;
        }
        uint64_t v24 = v80 | v29 | v21 & 0xEFFF03FF;
      }
    }
  }
  unint64_t v30 = a9;
  if ((v24 & 0x10000000) != 0)
  {
    unint64_t v88 = 0;
    if ((v24 & 0x8000000) != 0) {
      goto LABEL_49;
    }
  }
  else
  {
    if (*a4 == 11 || a4[1] == 11) {
      uint64_t v31 = 2;
    }
    else {
      uint64_t v31 = 1;
    }
    unint64_t v88 = v31;
    if ((v24 & 0x8000000) != 0) {
      goto LABEL_49;
    }
  }
  if ((a10 & 1) == 0)
  {
    if (*(unsigned char *)(v11 + 627)) {
      return 30;
    }
    uint64_t v83 = v12;
    uint64_t v85 = v24;
    uint64_t v32 = a5;
    unsigned int v86 = v23;
    BOOL is_current_tx = xid_is_current_tx(v11, a9);
    unint64_t v30 = a9;
    uint64_t v12 = v83;
    unsigned int v23 = v86;
    a5 = v32;
    uint64_t v24 = v85;
    if (!is_current_tx) {
      return 22;
    }
  }
LABEL_49:
  unint64_t v34 = v30;
  if (a8)
  {
    unint64_t v34 = a8;
    if (a8 > v30) {
      return 22;
    }
  }
  if (a3) {
    char v35 = 1;
  }
  else {
    char v35 = a10;
  }
  uint64_t v91 = 0;
  if ((v21 & 0x40000000) == 0) {
    char v35 = 1;
  }
  uint64_t v78 = a5;
  unint64_t v79 = v34;
  unsigned int v87 = v23;
  char v84 = v35;
  if (v35)
  {
    if (v23)
    {
      uint64_t v81 = v30;
      uint64_t v37 = (void *)v12;
      unsigned int v50 = 0;
    }
    else
    {
      unsigned int v36 = (v15 + *(_DWORD *)(*(void *)(v11 + 376) + 36) - 1)
          / *(_DWORD *)(*(void *)(v11 + 376) + 36);
      uint64_t v37 = (void *)v12;
      unint64_t v38 = v30;
      uint64_t v39 = spaceman_reserve(v12, 0x48u, v36, v30, (int *)&v89);
      if (v39)
      {
        uint64_t v19 = v39;
        uint64_t v67 = "%s:%d: %s flags 0x%x type 0x%x/0x%x error reserving %d blocks of space: %d\n";
LABEL_85:
        log_err((uint64_t)v67, v40, v41, v42, v43, v44, v45, v46, (uint64_t)"obj_create_internal");
        return v19;
      }
      uint64_t v81 = v38;
      unsigned int v50 = v36;
    }
  }
  else
  {
    unsigned int v47 = (v15 + *(_DWORD *)(*(void *)(v11 + 376) + 36) - 1)
        / *(_DWORD *)(*(void *)(v11 + 376) + 36);
    uint64_t v37 = (void *)v12;
    unint64_t v48 = v30;
    uint64_t v49 = spaceman_alloc(v12, 72, v47, v30, &v88, 0);
    if (v49)
    {
      uint64_t v19 = v49;
      uint64_t v67 = "%s:%d: %s flags 0x%x type 0x%x/0x%x error allocating new physical location %d\n";
      goto LABEL_85;
    }
    uint64_t v81 = v48;
    if (a7) {
      apfs_check_for_spillover();
    }
    unsigned int v50 = v47;
  }
  pthread_mutex_lock(a1);
  uint64_t v52 = sub_10001FE08((uint64_t)a1, a4[3], *a4, v15, v24, 0, &v91, v51);
  if (v52)
  {
    uint64_t v19 = v52;
    obj_cache_unlock_write((uint64_t)a1);
    if (v84)
    {
      if (v87) {
        return v19;
      }
      unsigned int v53 = v89;
      unint64_t v54 = v50;
LABEL_119:
      spaceman_unreserve((uint64_t)v37, v53, v54);
      return v19;
    }
    unint64_t v65 = v88;
    uint64_t v66 = v50;
    goto LABEL_121;
  }
  int v55 = v24;
  uint64_t v56 = v91;
  uint64_t v57 = *(void *)(v91 + 16) | v24 & 0xFFFFFC00;
  *(void *)(v91 + 16) = v57 | 0x42;
  int v58 = *a4 | v24 & 0xFFFF0000;
  *(_DWORD *)(v56 + 36) = v58;
  uint64_t v59 = a4[1];
  uint64_t v60 = v56;
  *(_DWORD *)(v56 + 40) = v59;
  if (!a7 || (uint64_t v61 = *(void *)(a7 + 496)) == 0) {
    uint64_t v61 = a7;
  }
  *(void *)(v60 + 8) = v61;
  *(void *)(v60 + 120) = v79;
  *(void *)(v60 + 144) = 0;
  if ((v21 & 0x80000000) != 0)
  {
    if (a3) {
      goto LABEL_95;
    }
    if ((v24 & 0x8000000) != 0)
    {
      uint64_t v77 = *(void *)&a1[6].__opaque[16];
      *(void *)(v60 + 112) = v77;
      *(void *)&a1[6].__opaque[16] = v77 + 1;
      goto LABEL_96;
    }
    uint64_t v68 = *(void *)&a1[6].__opaque[8];
    *(void *)(v60 + 112) = v68;
    *(void *)&a1[6].__opaque[8] = v68 + 1;
    if (byte_100084A20)
    {
      uint64_t v64 = "ephemeral";
LABEL_90:
      sub_100024688(v60, v64);
    }
  }
  else
  {
    if ((v21 & 0x40000000) != 0)
    {
      if (a3) {
        unint64_t v88 = a3;
      }
      else {
        a3 = v88;
      }
      *(void *)(v60 + 128) = a3;
      goto LABEL_95;
    }
    if (!v87)
    {
      uint64_t v62 = 0x800000162;
      if ((v89 & 0x10) == 0) {
        uint64_t v62 = 0x400000162;
      }
      *(void *)(v60 + 16) = v57 | v62;
      if (!a3)
      {
        uint64_t v63 = *(void *)&a1[6].__opaque[8];
        *(void *)(v60 + 112) = v63;
        *(void *)&a1[6].__opaque[8] = v63 + 1;
        if (!byte_100084A20 || qword_100084A28 == v58 && qword_100084A30 == v59) {
          goto LABEL_96;
        }
        uint64_t v64 = "virtual";
        goto LABEL_90;
      }
LABEL_95:
      *(void *)(v60 + 112) = a3;
    }
  }
LABEL_96:
  if ((*(unsigned char *)(v60 + 19) & 0x20) == 0)
  {
    uint64_t v69 = *(void *)(v60 + 56);
    *(void *)(v69 + 24) = *(void *)(v60 + 36);
    *(_OWORD *)(v69 + 8) = *(_OWORD *)(v60 + 112);
  }
  obj_retain_0((atomic_ullong *)v60);
  uint64_t v19 = obj_descriptor_funcs_for_type(*(_DWORD *)(v60 + 36), &v90);
  if (v19
    || (unint64_t v71 = v90, *v90)
    && (uint64_t v19 = ((uint64_t (*)(void, uint64_t, uint64_t))*v90)(*(void *)(v60 + 56), v15, v78), v19)
    || (v72 = (uint64_t (*)(uint64_t, uint64_t))v71[1]) != 0 && (uint64_t v19 = v72(v60, v78), v19))
  {
    if (v55 < 0)
    {
      obj_cache_ephemeral_adjust((uint64_t)a1, v55, v15, -1);
    }
    else
    {
      int v70 = *(_DWORD *)&a1[10].__opaque[36];
      if (!v70) {
        sub_10005E82C();
      }
      *(_DWORD *)&a1[10].__opaque[36] = v70 - 1;
    }
    sub_100022918(v60, 0);
    obj_cache_unlock_write((uint64_t)a1);
    if (v84)
    {
      if (v87) {
        return v19;
      }
      unsigned int v53 = v89;
      unint64_t v54 = v50;
      goto LABEL_119;
    }
    unint64_t v65 = v88;
    uint64_t v66 = v50;
LABEL_121:
    spaceman_free(v37, 0, v65, v66, v81);
    return v19;
  }
  sub_100020868(v60, v55);
  uint64_t v73 = (uint64_t *)(a1[11].__sig + 8 * (*(void *)(v60 + 112) & *(unsigned int *)&a1[10].__opaque[52]));
  uint64_t v74 = *v73;
  *(void *)(v60 + 72) = *v73;
  if (v74) {
    *(void *)(v74 + 80) = v60 + 72;
  }
  *uint64_t v73 = v60;
  *(void *)(v60 + 80) = v73;
  *(void *)(v60 + 16) |= 1uLL;
  if (v55 < 0)
  {
    *(void *)(v60 + 88) = 0;
    uint64_t v75 = 760;
    if ((v55 & 0x8000000) == 0) {
      uint64_t v75 = 744;
    }
    uint64_t v76 = *(uint64_t **)((char *)&a1->__sig + v75);
    *(void *)(v60 + 96) = v76;
    *uint64_t v76 = v60;
    *(uint64_t *)((char *)&a1->__sig + v75) = v60 + 88;
  }
  obj_cache_unlock_write((uint64_t)a1);
  if ((v55 & 4) != 0) {
    obj_lock(v60, 2u);
  }
  uint64_t v19 = 0;
  *a11 = v60;
  return v19;
}

uint64_t obj_create(pthread_mutex_t *a1, int a2, unint64_t a3, unsigned int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8)
{
  return sub_10001F1DC(a1, a2, a3, a4, a5, 0, a6, 0, a7, 0, a8);
}

uint64_t obj_clone(pthread_cond_t **a1, __int16 a2, uint64_t *a3, unsigned char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12 = a1[7];
  unint64_t v13 = *a1;
  v36[0] = 0;
  v36[1] = 0;
  unsigned int v35 = 0;
  if (a4) {
    *a4 = 0;
  }
  int v14 = a2 & 0x210;
  if ((a2 & 0x210) != 0
    || (uint64_t v28 = obj_descriptor_and_flags_for_type(*((_DWORD *)a1 + 9), &v35, (uint64_t)v36), !v28))
  {
    uint64_t v15 = a1[2];
    if ((v15 & 2) != 0) {
      return 22;
    }
    uint64_t v37 = 0;
    uint64_t v16 = (unint64_t)v15 | 2;
    a1[2] = (pthread_cond_t *)((unint64_t)v15 | 2);
    if (*a3)
    {
      uint64_t v37 = *a3;
    }
    else
    {
      uint64_t v28 = sub_10001FE08((uint64_t)v13, *((unsigned int *)a1 + 11), *((unsigned int *)a1 + 9), *((unsigned int *)a1 + 12), v15 & 0xC0000000, a4, &v37, a8);
      if (v28) {
        return v28;
      }
      uint64_t v16 = (uint64_t)a1[2];
    }
    LODWORD(v17) = v16 & 0xFFFFFFFB;
    a1[2] = (pthread_cond_t *)(v16 & 0xFFFFFE7FFFFFFFFBLL);
    if (!*((_DWORD *)a1 + 13))
    {
      LODWORD(v17) = v16 & 0xFFFFFFF9;
      a1[2] = (pthread_cond_t *)(v16 & 0xFFFFFE7FFFFFFFF9);
    }
    if ((v16 & 4) != 0)
    {
      cv_wakeup(*a1 + 27);
      uint64_t v17 = a1[2];
    }
    uint64_t v18 = v37;
    *(void *)(v37 + 36) = *(pthread_cond_t **)((char *)a1 + 36);
    *(void *)(v18 + 8) = a1[1];
    *(_OWORD *)(v18 + 112) = *((_OWORD *)a1 + 7);
    *(void *)(v18 + 128) = a1[16];
    uint64_t v19 = v17 & 0xFFFFFC00 | *(void *)(v18 + 16);
    uint64_t v20 = v19 | 0x40000000002;
    *(void *)(v18 + 16) = v19 | 0x40000000002;
    if ((a2 & 0x50) != 0)
    {
      uint64_t v20 = v19 | 0x4000000000ALL;
      *(void *)(v18 + 16) = v19 | 0x4000000000ALL;
      if ((a2 & 0x40) != 0)
      {
        uint64_t v20 = v19 | 0x4100000000ALL;
        *(void *)(v18 + 16) = v19 | 0x4100000000ALL;
      }
    }
    if ((a2 & 0x200) != 0) {
      *(void *)(v18 + 16) = v20 | 0x80000000000;
    }
    memcpy(*(void **)(v18 + 56), v12, *((unsigned int *)a1 + 12));
    if (v14) {
      goto LABEL_17;
    }
    uint64_t v34 = 0;
    memcpy((void *)(v18 + 376), a1 + 47, *((unsigned int *)a1 + 11) - 376);
    uint64_t v29 = obj_descriptor_funcs_for_type(*((_DWORD *)a1 + 9), &v34);
    if (v29)
    {
      uint64_t v28 = v29;
    }
    else
    {
      uint64_t v32 = *(uint64_t (**)(uint64_t, void))(v34 + 8);
      if (!v32 || (uint64_t v28 = v32(v18, 0), !v28))
      {
LABEL_17:
        unsigned int v21 = (uint64_t *)(*(void *)&v13[14].__opaque[24]
                        + 8 * (*(void *)(v18 + 112) & *(unsigned int *)&v13[14].__opaque[20]));
        uint64_t v22 = *v21;
        *(void *)(v18 + 72) = *v21;
        if (v22) {
          *(void *)(v22 + 80) = v18 + 72;
        }
        *unsigned int v21 = v18;
        *(void *)(v18 + 80) = v21;
        uint64_t v23 = *(void *)(v18 + 16);
        *(void *)(v18 + 16) = v23 | 1;
        uint64_t v24 = a1[2];
        if ((v24 & 0x80000000) != 0)
        {
          *(void *)(v18 + 88) = 0;
          BOOL v25 = (v24 & 0x8000000) == 0;
          uint64_t v26 = 760;
          if (v25) {
            uint64_t v26 = 744;
          }
          uint64_t v27 = *(uint64_t **)((char *)&v13->__sig + v26);
          *(void *)(v18 + 96) = v27;
          *uint64_t v27 = v18;
          *(uint64_t *)((char *)&v13->__sig + v26) = v18 + 88;
        }
        *(void *)(v18 + 16) = v23 & 0xFFFFFA7FFFFFFFFALL | 1;
        if (!(*(_DWORD *)(v18 + 52) | a2 & 0x10)) {
          *(void *)(v18 + 16) = v23 & 0xFFFFFA7FFFFFFFF8 | 1;
        }
        if ((v23 & 4) != 0) {
          cv_wakeup((pthread_cond_t *)(*(void *)v18 + 1296));
        }
        obj_retain_0((atomic_ullong *)v18);
        uint64_t v28 = 0;
        *a3 = v18;
        return v28;
      }
    }
    uint64_t v30 = *(void *)(v18 + 16);
    if ((v30 & 0x80000000) != 0)
    {
      obj_cache_ephemeral_adjust((uint64_t)v13, v30, *(_DWORD *)(v18 + 48), -1);
    }
    else
    {
      int v31 = *(_DWORD *)&v13[14].__opaque[4];
      if (!v31) {
        sub_10005E8B0();
      }
      *(_DWORD *)&v13[14].__opaque[4] = v31 - 1;
    }
    if (*a3) {
      *(void *)(v18 + 16) &= ~0x40000000000uLL;
    }
    else {
      sub_100022918(v18, 0);
    }
  }
  return v28;
}

uint64_t obj_descriptor_and_flags_for_type(int a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3 = 22;
  switch((__int16)a1)
  {
    case 1:
      int v4 = &nx_desc;
      goto LABEL_17;
    case 2:
      *(_OWORD *)a3 = btree_node_desc;
      *(_DWORD *)a3 = 2;
      goto LABEL_18;
    case 3:
      int v4 = &btree_node_desc;
      goto LABEL_17;
    case 5:
      int v4 = &sm_desc;
      goto LABEL_17;
    case 6:
      int v4 = &sm_cab_desc;
      goto LABEL_17;
    case 7:
      int v4 = &sm_cib_desc;
      goto LABEL_17;
    case 8:
      int v4 = &sm_bm_desc;
      goto LABEL_17;
    case 11:
      int v4 = &om_desc;
      goto LABEL_17;
    case 13:
      int v4 = &apfs_desc;
      goto LABEL_17;
    case 17:
      int v4 = &nx_reaper_desc;
      goto LABEL_17;
    case 18:
      int v4 = &nx_reap_list_desc;
      goto LABEL_17;
    case 25:
      int v4 = &gbitmap_desc;
      goto LABEL_17;
    case 27:
      int v4 = (long long *)"\x1B";
      goto LABEL_17;
    case 29:
      int v4 = &snap_meta_ext_desc;
      goto LABEL_17;
    case 30:
      int v4 = &integrity_meta_desc;
LABEL_17:
      *(_OWORD *)a3 = *v4;
LABEL_18:
      uint64_t v3 = 0;
      unsigned int v5 = *a2 | a1 & 0xFFFF0000;
      *a2 = v5;
      *a2 = v5 | (*(unsigned __int16 *)(a3 + 2) << 16);
      break;
    default:
      return v3;
  }
  return v3;
}

uint64_t sub_10001FE08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6, uint64_t *a7, uint64_t a8)
{
  int v8 = a6;
  int v9 = a5;
  unsigned int v10 = a4;
  int v11 = a3;
  if (a6) {
    *a6 = 0;
  }
  if (a2) {
    size_t v13 = a2;
  }
  else {
    size_t v13 = 376;
  }
  if (a4)
  {
    uint64_t v14 = 0;
  }
  else
  {
    uint64_t v15 = *(void *)(a1 + 392);
    if (!v15)
    {
      unsigned int v10 = 0;
      uint64_t v14 = 22;
      goto LABEL_11;
    }
    uint64_t v14 = 0;
    unsigned int v10 = *(_DWORD *)(*(void *)(v15 + 376) + 36);
  }
  LOBYTE(v15) = 1;
LABEL_11:
  uint64_t v16 = *(void *)(a1 + 392);
  if (v13 < 0x178)
  {
    uint64_t v14 = 22;
    if (!v16) {
      goto LABEL_23;
    }
LABEL_19:
    log_err((uint64_t)"%s:%d: %s invalid object size: %d size_phys %d\n", a2, a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"obj_alloc");
    return v14;
  }
  if (v16)
  {
    if (v10 % *(_DWORD *)(*(void *)(v16 + 376) + 36))
    {
      LOBYTE(v15) = 0;
      uint64_t v14 = 22;
    }
    else
    {
      uint64_t v14 = v14;
    }
    if ((v15 & 1) == 0) {
      goto LABEL_19;
    }
  }
  else if ((v15 & 1) == 0)
  {
LABEL_23:
    log_err((uint64_t)"%s:%d: invalid object size: %d size_phys %d\n", a2, a3, a4, a5, (uint64_t)a6, (uint64_t)a7, a8, (uint64_t)"obj_alloc");
    return v14;
  }
  uint64_t v17 = &OBJC_INSTANCE_METHODS_NSObject;
  size_t v79 = v13;
  int v78 = a3;
  unsigned int v77 = v10;
  int v80 = a5;
  if ((a5 & 0x80000000) != 0)
  {
    char v76 = 0;
    char v22 = 0;
    char v74 = 0;
    goto LABEL_95;
  }
  char v84 = 0;
  uint64_t v18 = 0;
  char v76 = 0;
  int v19 = 0;
  char v74 = 0;
  unsigned int v20 = *(_DWORD *)(a1 + 684);
  while (2)
  {
    if (v20 < *(_DWORD *)(a1 + 676))
    {
      uint64_t v23 = 0;
      goto LABEL_93;
    }
    uint64_t v81 = v18;
    int v82 = v19;
    if ((v9 & 0x40000000) != 0) {
      uint64_t v24 = (uint64_t *)(a1 + 784);
    }
    else {
      uint64_t v24 = (uint64_t *)(a1 + 768);
    }
    if ((v9 & 0x40000000) != 0) {
      BOOL v25 = (uint64_t *)(a1 + 768);
    }
    else {
      BOOL v25 = (uint64_t *)(a1 + 784);
    }
    while (1)
    {
      int v26 = pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 128));
      if (v26) {
        panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 2172, v26);
      }
      uint64_t v27 = *v24;
      if (*v24) {
        break;
      }
      uint64_t v28 = *v25;
      if (!*v25)
      {
        uint64_t v23 = 0;
        uint64_t v27 = 0;
        size_t v13 = v79;
        int v11 = v78;
        unsigned int v10 = v77;
        goto LABEL_88;
      }
      if ((*(unsigned char *)(v28 + 32) & 0x10) == 0) {
        goto LABEL_50;
      }
LABEL_44:
      sub_1000247A0(a1);
      int v29 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
      if (v29) {
        panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 2209, v29);
      }
      if (*(_DWORD *)(a1 + 684) < *(_DWORD *)(a1 + 676))
      {
        uint64_t v23 = 0;
        size_t v13 = v79;
        int v11 = v78;
        unsigned int v10 = v77;
        int v9 = v80;
        goto LABEL_93;
      }
    }
    if ((*(unsigned char *)(v27 + 32) & 0x10) != 0) {
      goto LABEL_44;
    }
    uint64_t v28 = *v25;
    if (*v25)
    {
      if ((*(unsigned char *)(v28 + 32) & 0x10) != 0) {
        goto LABEL_44;
      }
    }
    unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 24), 0, memory_order_relaxed);
    if ((add_explicit & 0xFFFFFF) != ((add_explicit >> 24) & 0xFFFFF)) {
      sub_10005E960();
    }
    uint64_t v31 = 0;
    int v32 = 1;
    if (v28)
    {
LABEL_50:
      int v32 = 0;
      unint64_t v33 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 24), 0, memory_order_relaxed);
      uint64_t v31 = v28;
      if ((v33 & 0xFFFFFF) != ((v33 >> 24) & 0xFFFFF)) {
        sub_10005E934();
      }
    }
    __tp.__darwin_time_t tv_sec = 0;
    __tp.int tv_nsec = 0;
    clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &__tp);
    int v11 = v78;
    if (v27 && __tp.tv_sec - *(unsigned int *)(v27 + 160) > 599)
    {
      size_t v13 = v79;
      unsigned int v10 = v77;
      goto LABEL_63;
    }
    size_t v13 = v79;
    unsigned int v10 = v77;
    if (v32)
    {
      BOOL v34 = *(_DWORD *)(a1 + 684) < *(_DWORD *)(a1 + 680);
      goto LABEL_56;
    }
    uint64_t v35 = *(unsigned int *)(v31 + 160);
    if (__tp.tv_sec - v35 > 599)
    {
      uint64_t v27 = v31;
LABEL_63:
      int v19 = v82;
LABEL_64:
      uint64_t v18 = v81;
      goto LABEL_65;
    }
    unsigned int v38 = *(_DWORD *)(a1 + 684);
    unsigned int v39 = *(_DWORD *)(a1 + 680);
    BOOL v40 = v38 >= v39;
    BOOL v34 = v38 < v39;
    char v41 = !v40;
    if (v27)
    {
      int v19 = v82;
      if ((v41 & 1) == 0)
      {
        if (v35 < *(_DWORD *)(v27 + 160)) {
          uint64_t v27 = v31;
        }
        goto LABEL_64;
      }
      uint64_t v27 = v31;
    }
    else
    {
      uint64_t v27 = v31;
LABEL_56:
      int v19 = v82;
    }
    uint64_t v23 = 0;
    uint64_t v18 = v81;
    if (!v34 && v27)
    {
LABEL_65:
      if (*(_DWORD *)(v27 + 44) == v13 && *(_DWORD *)(v27 + 48) == v10)
      {
        sub_1000248FC((uint64_t *)v27);
        if (v18)
        {
          fs_obj_zfree_oc(v84, v10, v80, a1);
          free_rwlock((pthread_rwlock_t *)(v18 + 176));
          sub_100024998((void *)v18, v78, v13);
          char v84 = 0;
          char v74 = 1;
        }
        uint64_t v36 = *(void *)(v27 + 16);
        char v76 = 1;
        if (v36)
        {
          uint64_t v42 = *(void *)(v27 + 72);
          if (v42) {
            *(void *)(v42 + 80) = *(void *)(v27 + 80);
          }
          uint64_t v18 = 0;
          **(void **)(v27 + 80) = v42;
          *(void *)(v27 + 16) = v36 & 0xFFFFFFFFFFFFFFFELL;
          char v76 = 1;
        }
        else
        {
          uint64_t v18 = 0;
        }
        uint64_t v23 = v27;
        uint64_t v27 = 0;
      }
      else
      {
        unsigned int v37 = *(_DWORD *)(a1 + 684);
        char v76 = 1;
        if (v37 < *(_DWORD *)(a1 + 680))
        {
          uint64_t v23 = 0;
          goto LABEL_73;
        }
        if (!v37) {
          sub_10005E908();
        }
        uint64_t v23 = 0;
        *(_DWORD *)(a1 + 684) = v37 - 1;
        char v76 = 1;
      }
    }
    else
    {
LABEL_73:
      uint64_t v27 = 0;
    }
LABEL_88:
    int v43 = pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 128));
    if (v43) {
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 2267, v43);
    }
    if (v27) {
      sub_100022918(v27, 0);
    }
    int v9 = v80;
LABEL_93:
    if (v23 | v18)
    {
      if (v23)
      {
        uint64_t v97 = 0;
        long long v95 = 0u;
        long long v96 = 0u;
        long long v93 = 0u;
        long long v94 = 0u;
        long long v91 = 0u;
        long long v92 = 0u;
        long long v89 = 0u;
        long long v90 = 0u;
        long long v87 = 0u;
        long long v88 = 0u;
        timespec __tp = (timespec)0;
        long long v86 = 0u;
        uint64_t v49 = sub_100024A98(v23);
        if (v49)
        {
          unsigned int v50 = (unsigned int (*)(uint64_t))v49;
          obj_cache_unlock_write(a1);
          if (a6) {
            *a6 = 1;
          }
          if (v50(v23)) {
            log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error destroying: %d\n", v51, v52, v53, v54, v55, v56, v57, (uint64_t)"obj_alloc");
          }
          pthread_mutex_lock((pthread_mutex_t *)a1);
        }
        int v58 = *(void **)(v23 + 56);
        long long v59 = *(_OWORD *)(v23 + 352);
        long long v95 = *(_OWORD *)(v23 + 336);
        long long v96 = v59;
        uint64_t v97 = *(void *)(v23 + 368);
        long long v60 = *(_OWORD *)(v23 + 288);
        long long v91 = *(_OWORD *)(v23 + 272);
        long long v92 = v60;
        long long v61 = *(_OWORD *)(v23 + 320);
        long long v93 = *(_OWORD *)(v23 + 304);
        long long v94 = v61;
        long long v62 = *(_OWORD *)(v23 + 224);
        long long v87 = *(_OWORD *)(v23 + 208);
        long long v88 = v62;
        long long v63 = *(_OWORD *)(v23 + 256);
        long long v89 = *(_OWORD *)(v23 + 240);
        long long v90 = v63;
        long long v64 = *(_OWORD *)(v23 + 192);
        timespec __tp = *(timespec *)(v23 + 176);
        long long v86 = v64;
        char v84 = v58;
        bzero(v58, v10);
        bzero((void *)v23, v13);
        long long v65 = v96;
        *(_OWORD *)(v23 + 336) = v95;
        *(_OWORD *)(v23 + 352) = v65;
        *(void *)(v23 + 368) = v97;
        long long v66 = v92;
        *(_OWORD *)(v23 + 272) = v91;
        *(_OWORD *)(v23 + 288) = v66;
        long long v67 = v94;
        *(_OWORD *)(v23 + 304) = v93;
        *(_OWORD *)(v23 + 320) = v67;
        long long v68 = v88;
        *(_OWORD *)(v23 + 208) = v87;
        *(_OWORD *)(v23 + 224) = v68;
        long long v69 = v90;
        *(_OWORD *)(v23 + 240) = v89;
        *(_OWORD *)(v23 + 256) = v69;
        long long v70 = v86;
        char v22 = v19;
        *(timespec *)(v23 + 176) = __tp;
        *(_OWORD *)(v23 + 192) = v70;
      }
      else
      {
        ++*(_DWORD *)(a1 + 684);
        uint64_t v23 = v18;
        char v22 = v19;
      }
      break;
    }
    char v22 = v19;
    uint64_t v17 = &OBJC_INSTANCE_METHODS_NSObject;
    int v8 = a6;
LABEL_95:
    obj_cache_unlock_write(a1);
    if (v8) {
      *int v8 = 1;
    }
    if (!*(void *)&v17[323]) {
      sub_10005E8DC();
    }
    uint64_t v44 = _apfs_obj_zalloc(v10, *(void *)(a1 + 920));
    sub_100024E98((atomic_ullong *)(a1 + 944), v9, (uint64_t)v44, v10);
    char v84 = v44;
    sub_100024E98((atomic_ullong *)(*(void *)&v17[323] + 136), v9, (uint64_t)v44, v10);
    switch((__int16)v11)
    {
      case 1:
        if (v13 != 1928) {
          sub_10005E9B8();
        }
        size_t v46 = 1928;
        break;
      case 2:
      case 3:
        if (v13 != 448) {
          sub_10005E9E4();
        }
        goto LABEL_102;
      case 5:
        if (v13 != 1608) {
          sub_10005EA10();
        }
        size_t v46 = 1608;
        break;
      case 6:
      case 7:
      case 8:
        if (v13 != 448) {
          sub_10005EA3C();
        }
LABEL_102:
        uint64_t v45 = _apfs_zalloc(4u);
        goto LABEL_126;
      case 11:
        if (v13 != 496) {
          sub_10005EA68();
        }
        size_t v46 = 496;
        break;
      case 13:
        if (v13 != 4032) {
          sub_10005EA94();
        }
        size_t v46 = 4032;
        break;
      case 17:
        if (v13 != 400) {
          sub_10005EAC0();
        }
        goto LABEL_124;
      case 18:
        if (v13 != 384) {
          sub_10005EAEC();
        }
        size_t v46 = 384;
        break;
      case 25:
        if (v13 != 416) {
          sub_10005EB18();
        }
        size_t v46 = 416;
        break;
      case 27:
        if (v13 != 392) {
          sub_10005EB44();
        }
        goto LABEL_122;
      case 29:
        if (v13 != 392) {
          sub_10005EB70();
        }
LABEL_122:
        size_t v46 = 392;
        break;
      case 30:
        if (v13 != 400) {
          sub_10005EB9C();
        }
LABEL_124:
        size_t v46 = 400;
        break;
      default:
        if (v13 != 376) {
          sub_10005E98C();
        }
        size_t v46 = 376;
        break;
    }
    uint64_t v45 = _apfs_calloc(1uLL, v46);
LABEL_126:
    uint64_t v23 = (uint64_t)v45;
    unsigned int v47 = v84;
    if (!v84 || !v23)
    {
      uint64_t v14 = 12;
      if (!v84) {
        goto LABEL_142;
      }
      goto LABEL_141;
    }
    *(void *)(v23 + 24) = 0;
    uint64_t v48 = new_rwlock((pthread_rwlock_t *)(v23 + 176));
    if (v48)
    {
      uint64_t v14 = v48;
      unsigned int v47 = v84;
LABEL_141:
      fs_obj_zfree_oc(v47, v10, v9, a1);
LABEL_142:
      if (v23) {
        sub_100024998((void *)v23, v11, v13);
      }
      pthread_mutex_lock((pthread_mutex_t *)a1);
      return v14;
    }
    pthread_mutex_lock((pthread_mutex_t *)a1);
    if (v9 < 0)
    {
      int v19 = 1;
      obj_cache_ephemeral_adjust(a1, v9, v10, 1);
    }
    else
    {
      unsigned int v20 = *(_DWORD *)(a1 + 684);
      int v19 = 1;
      if (*(_DWORD *)(a1 + 680) - 1 < v20)
      {
        uint64_t v18 = v23;
        continue;
      }
      *(_DWORD *)(a1 + 684) = v20 + 1;
    }
    break;
  }
  *(void *)uint64_t v23 = a1;
  *(_DWORD *)(v23 + 36) = v11;
  *(_DWORD *)(v23 + 44) = v13;
  *(_DWORD *)(v23 + 48) = v10;
  *(void *)(v23 + 56) = v84;
  *(void *)(v23 + 88) = 3735928559;
  *(void *)(v23 + 104) = 3735928559;
  *(_DWORD *)(v23 + 160) = -1;
  if ((v9 & 0x80000000) == 0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 1024), 1uLL, memory_order_relaxed);
    if (v19)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 1032), 1uLL, memory_order_relaxed);
      if (v22) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 1040), 1uLL, memory_order_relaxed);
      }
      uint64_t v71 = 1048;
      if (v74) {
        uint64_t v71 = 1056;
      }
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + v71), 1uLL, memory_order_relaxed);
    }
    if (v76) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 1064), 1uLL, memory_order_relaxed);
    }
    uint64_t v72 = (atomic_ullong *)qword_100084A18;
    atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_100084A18 + 216), 1uLL, memory_order_relaxed);
    if (v19)
    {
      atomic_fetch_add_explicit(v72 + 28, 1uLL, memory_order_relaxed);
      if (v22) {
        atomic_fetch_add_explicit(v72 + 29, 1uLL, memory_order_relaxed);
      }
      uint64_t v73 = 30;
      if (v74) {
        uint64_t v73 = 31;
      }
      atomic_fetch_add_explicit(&v72[v73], 1uLL, memory_order_relaxed);
    }
    if (v76) {
      atomic_fetch_add_explicit(v72 + 32, 1uLL, memory_order_relaxed);
    }
  }
  uint64_t v14 = 0;
  *a7 = v23;
  return v14;
}

uint64_t sub_100020868(uint64_t result, char a2)
{
  uint64_t v2 = *(void *)(result + 16);
  *(void *)(result + 16) = v2 & 0xFFFFFE7FFFFFFFFBLL;
  if (*(_DWORD *)(result + 52) | a2 & 0x10)
  {
    if ((v2 & 4) == 0) {
      return result;
    }
    return cv_wakeup((pthread_cond_t *)(*(void *)result + 1296));
  }
  *(void *)(result + 16) = v2 & 0xFFFFFE7FFFFFFFF9;
  if ((v2 & 4) != 0) {
    return cv_wakeup((pthread_cond_t *)(*(void *)result + 1296));
  }
  return result;
}

uint64_t obj_descriptor_funcs_for_type(__int16 a1, void *a2)
{
  __int16 v2 = a1 - 1;
  if ((unsigned __int16)(a1 - 1) > 0x1Du || ((0x350314F7u >> v2) & 1) == 0) {
    return 22;
  }
  uint64_t result = 0;
  *a2 = off_1000806D8[v2];
  return result;
}

atomic_ullong *obj_retain_0(atomic_ullong *result)
{
  unint64_t v1 = atomic_fetch_add_explicit(result + 3, 1uLL, memory_order_relaxed) & 0xFFFFFF;
  if (v1 == 0xFFFFFF) {
    panic("Reference count overflowed for object %p!\n", result);
  }
  if (v1 >= 0x186A1) {
    sub_10005EBC8();
  }
  return result;
}

void sub_100020950(uint64_t *a1, uint64_t a2, int a3)
{
  uint64_t v6 = *a1;
  if ((*((unsigned char *)a1 + 19) & 8) == 0 && !xid_is_current_tx(*(void *)(v6 + 392), a2)) {
    panic("can not delete an object w/a non-current xid %lld o == %p\n", a2, a1);
  }
  pthread_mutex_lock((pthread_mutex_t *)v6);
  for (uint64_t i = a1[2]; (i & 0x20000000000) != 0; uint64_t i = a1[2])
  {
    a1[2] = i | 0x80;
    cv_wait_rw((pthread_cond_t *)(v6 + 1296), (pthread_mutex_t *)v6, 2, 0);
  }
  a1[2] = i | 0x10;
  a1[18] = a2;
  if ((i & 0x80000000) != 0)
  {
    if (a3) {
      a1[2] = i & 0xFFFFFFEFFFFFFFE7 | 0x18;
    }
    obj_cache_unlock_write(v6);
  }
  else
  {
    uint64_t v8 = a1[19];
    if (!v8) {
      uint64_t v8 = a1[16];
    }
    uint64_t v35 = v8;
    a1[16] = 0;
    a1[19] = 0;
    if (atomic_fetch_and_explicit((atomic_uint *volatile)a1 + 8, 0xFFFFFFFE, memory_order_relaxed))
    {
      int v9 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 128));
      if (v9) {
        panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 3014, v9);
      }
      uint64_t v10 = a1[11];
      if (v10 != 3735928559)
      {
        if (*(uint64_t **)(v6 + 864) == a1) {
          *(void *)(v6 + 864) = v10;
        }
        int v11 = (uint64_t *)a1[12];
        if ((*((unsigned char *)a1 + 19) & 0x40) != 0)
        {
          if (v10)
          {
            *(void *)(v10 + 96) = v11;
            int v11 = (uint64_t *)a1[12];
          }
          else
          {
            *(void *)(v6 + 824) = v11;
          }
          *int v11 = v10;
          --*(_DWORD *)(v6 + 888);
        }
        else
        {
          if (v10)
          {
            *(void *)(v10 + 96) = v11;
            int v11 = (uint64_t *)a1[12];
          }
          else
          {
            *(void *)(v6 + 808) = v11;
          }
          *int v11 = v10;
          --*(_DWORD *)(v6 + 884);
        }
        a1[11] = 3735928559;
      }
      int v12 = pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 128));
      if (v12) {
        panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 3028, v12);
      }
    }
    uint64_t v13 = a1[1];
    if (!v13) {
      uint64_t v13 = *(void *)(v6 + 392);
    }
    uint64_t v14 = a1[2];
    unint64_t v15 = a1[15];
    uint64_t v16 = a1[18];
    if (a3) {
      a1[2] = v14 & 0xFFFFFFEFFFFFFFF7 | 8;
    }
    int v17 = *((_DWORD *)a1 + 12);
    uint64_t v18 = a1[14];
    obj_cache_unlock_write(v6);
    if (v8)
    {
      if ((v14 & 0x40000000) != 0)
      {
        unsigned int v19 = *(_DWORD *)(*(void *)(*(void *)(v6 + 392) + 376) + 36);
        if (!spaceman_free(v13, 0, v8, (v17 + v19 - 1) / v19, v16)) {
          return;
        }
        BOOL v34 = "%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error freeing space %d\n";
LABEL_47:
        log_err((uint64_t)v34, v20, v21, v22, v23, v24, v25, v26, (uint64_t)"obj_delete_internal");
        return;
      }
LABEL_45:
      if (!omap_delete(v13, v18, v15, v8, v17, 1, v16)) {
        return;
      }
      BOOL v34 = "%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error deleting mapping %d\n";
      goto LABEL_47;
    }
    if ((v14 & 0x40000000) != 0) {
      sub_10005EBF4();
    }
    if ((v14 & 0x40) == 0)
    {
      if (omap_get(v13, v18, v15, &v35, 0, 0, 0)) {
        log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error getting mapping to free %d\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"obj_delete_internal");
      }
    }
    uint64_t v8 = v35;
    if (v35) {
      goto LABEL_45;
    }
  }
}

void obj_delete_and_free(uint64_t *a1, uint64_t a2)
{
}

void obj_free(uint64_t a1)
{
  __int16 v2 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFEFFFFFFFF7 | 8;

  obj_cache_unlock_write((uint64_t)v2);
}

uint64_t obj_delete_and_free_by_oid(uint64_t a1, int a2, int a3, unint64_t a4, unint64_t a5, uint64_t a6)
{
  int v11 = *(uint64_t **)(a1 + 392);
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  unsigned int v47 = 0;
  v46[0] = 0;
  v46[1] = 0;
  uint64_t v12 = obj_descriptor_and_flags_for_type(a2, &v47, (uint64_t)v46);
  if (v12) {
    return v12;
  }
  uint64_t v45 = 0;
  if (a4)
  {
    uint64_t v14 = obj_get(a1, 0, a4, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v49);
    if (v14)
    {
      uint64_t v12 = v14;
      log_err((uint64_t)"%s:%d: %s unable to get fs object 0x%llx: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"obj_delete_and_free_by_oid");
      return v12;
    }
    uint64_t v22 = v49;
  }
  else
  {
    uint64_t v22 = 0;
  }
  if (v22) {
    uint64_t v23 = v22;
  }
  else {
    uint64_t v23 = v11;
  }
  unsigned int v24 = v47;
  uint64_t v25 = obj_get(a1, v47, a5, 0, 0, (uint64_t)v22, 0, 0, (uint64_t *)&v48);
  if (!v25)
  {
    BOOL v34 = v48;
    sub_100020950(v48, a6, 1);
    obj_release(v34);
    uint64_t v12 = 0;
    goto LABEL_25;
  }
  if ((v24 & 0x80000000) != 0)
  {
    uint64_t v12 = v25;
    goto LABEL_25;
  }
  if ((v24 & 0x40000000) != 0)
  {
    uint64_t v12 = spaceman_free(v23, 0, a5, (a3 + *(_DWORD *)(v11[47] + 36) - 1) / *(_DWORD *)(v11[47] + 36), a6);
    if (v12) {
      log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error freeing space %d\n", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"obj_delete_and_free_by_oid");
    }
    goto LABEL_25;
  }
  int v44 = 0;
  unint64_t v43 = 0;
  uint64_t v26 = omap_get((uint64_t)v23, a5, 0, &v45, &v44, 0, &v43);
  if (v26)
  {
    uint64_t v12 = v26;
    uint64_t v42 = "%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error getting mapping to free %d\n";
  }
  else
  {
    if (v44 != a3) {
      sub_10005EC20();
    }
    uint64_t v12 = omap_delete((uint64_t)v23, a5, v43, v45, a3, 1, a6);
    if (!v12) {
      goto LABEL_24;
    }
    uint64_t v42 = "%s:%d: %s oid 0x%llx flags 0x%x type 0x%x error deleting mapping %d\n";
  }
  log_err((uint64_t)v42, v27, v28, v29, v30, v31, v32, v33, (uint64_t)"obj_delete_and_free_by_oid");
LABEL_24:
  uint64_t v22 = v49;
LABEL_25:
  if (v22) {
    obj_release(v22);
  }
  return v12;
}

uint64_t obj_get(uint64_t a1, uint64_t a2, unint64_t a3, int *a4, _WORD *a5, uint64_t a6, unint64_t a7, uint64_t a8, uint64_t *a9)
{
  unsigned int v122 = a2;
  if ((a2 & 8) != 0) {
    unint64_t v9 = a7;
  }
  else {
    unint64_t v9 = 0;
  }
  unint64_t v119 = v9;
  unint64_t v120 = 0;
  unsigned int v117 = 0;
  int v118 = 16000;
  __int16 v114 = 0;
  *a9 = 0;
  if ((a2 & 0x7FF0200) != 0) {
    sub_10005EDAC();
  }
  uint64_t v10 = a2;
  if (a2 >> 30 == 3) {
    return 22;
  }
  unint64_t v14 = a7;
  if ((a2 & 0x8000001) == 1)
  {
    BOOL is_current_tx = xid_is_current_tx(*(void *)(a1 + 392), a8);
    uint64_t v11 = 22;
    if ((~v10 & 0x180) == 0 || !is_current_tx) {
      return v11;
    }
  }
  else if ((~a2 & 0x180) == 0)
  {
    return 22;
  }
  if ((~v10 & 0x81) == 0 || (v10 & 0x100) != 0 && (v10 & 0x15) != 0) {
    return 22;
  }
  uint64_t v11 = 22;
  if ((v10 & 0x210) == 0x200 || !a3) {
    return v11;
  }
  char v115 = 0;
  if (*(void *)(a1 + 1344))
  {
    pthread_mutex_lock((pthread_mutex_t *)a1);
    unsigned __int8 v116 = 2;
    sub_100021D8C(a1, &v114);
    if ((_BYTE)v114) {
      obj_cache_unlock_write(a1);
    }
  }
  if (a4)
  {
    uint64_t v10 = v10 | (*((unsigned __int16 *)a4 + 1) << 16);
    unsigned int v122 = v10;
  }
  unsigned int v21 = v10 >> 30;
  if ((v10 & 0x40000000) == 0 && v10 >> 30 < 2) {
    int v22 = 4;
  }
  else {
    int v22 = 0;
  }
  unsigned int v23 = (v10 & 0x40000000) >> 30;
  if (v21 > 1) {
    ++v23;
  }
  if (v23 + ((v10 & 0x40000000) == 0 && v10 >> 30 < 2) != 1
    || (((v10 & 0x40000000) != 0 || v10 >> 30 >= 2) & ((unsigned __int16)(v10 & 0x200) >> 9)) != 0)
  {
    return 22;
  }
  if ((v10 & 0x40000000) != 0 || v10 >> 30 >= 2)
  {
    unint64_t v14 = 0;
    unint64_t v119 = 0;
  }
  if ((v10 & 0x8000000) != 0)
  {
    if (v21 < 2) {
      return 22;
    }
    unint64_t v24 = *(void *)(a1 + 408);
    if (v24 <= *(void *)(a1 + 400)) {
      unint64_t v24 = *(void *)(a1 + 400);
    }
    goto LABEL_42;
  }
  if ((v10 & 1) != 0 && *(unsigned char *)(*(void *)(a1 + 392) + 627)) {
    return 30;
  }
  if ((v10 & 0x48000000) == 0)
  {
    unint64_t v24 = *(void *)(a1 + 400);
LABEL_42:
    if (v24 > a3) {
      goto LABEL_43;
    }
    return 22;
  }
LABEL_43:
  uint64_t v103 = a5;
  if (a4)
  {
    int v26 = *a4;
    unsigned int v25 = a4[1];
  }
  else
  {
    int v26 = 0;
    unsigned int v25 = 0;
  }
  unsigned int v112 = v25;
  uint64_t v27 = v10;
  if (a6 != 0 && (v10 & 0x40000000) == 0 && v10 >> 30 < 2)
  {
    sub_100021E1C(a6, v112, &v122);
    uint64_t v27 = v122;
  }
  unsigned int v113 = v27 & 0xFFFF0000 | v26;
  uint64_t v121 = 0;
  unsigned int v28 = v22 | (v10 >> 30) | 0x20;
  uint64_t v29 = v27;
  pthread_mutex_lock((pthread_mutex_t *)a1);
  uint64_t v35 = v29;
  uint64_t v11 = 0;
  unsigned __int8 v116 = 1;
  uint64_t v101 = (pthread_cond_t *)(a1 + 1296);
  uint64_t v36 = 512;
  if (!v14) {
    uint64_t v36 = 288;
  }
  uint64_t v104 = v36;
  while (2)
  {
    unsigned int v37 = (v28 & 0xFFFFFFBF | (((v35 >> 8) & 1) << 6)) ^ 0x40;
    char v115 = 0;
    uint64_t v38 = *(void *)(*(void *)(a1 + 704) + 8 * (*(_DWORD *)(a1 + 700) & a3));
    if (!v38)
    {
      if ((v28 & 2) == 0) {
        goto LABEL_110;
      }
LABEL_239:
      uint64_t v38 = 0;
      uint64_t v11 = 2;
      goto LABEL_240;
    }
    uint64_t v31 = 0;
    uint64_t v32 = v112;
    do
    {
      uint64_t v39 = *(void *)(v38 + 8);
      if (v39 != a6 && (!a6 || v39 != *(void *)(a6 + 496))) {
        goto LABEL_100;
      }
      uint64_t v40 = *(void *)(v38 + 16);
      if ((v40 & 0xC8000000) != (v35 & 0xC8000000) || *(void *)(v38 + 112) != a3) {
        goto LABEL_100;
      }
      if ((v40 & 2) != 0)
      {
        if ((v35 & 0x180) == 0)
        {
          char v83 = v116;
          if (v116 == 1) {
            char v83 = 2;
          }
          unsigned __int8 v116 = v83;
          *(void *)(v38 + 16) = v40 | 4;
          unsigned int v84 = (v28 & 0xFFFFFFBF | (((v35 >> 8) & 1) << 6)) ^ 0x40;
          sub_100021EB4((uint64_t *)v38);
          unsigned int v37 = v84;
          goto LABEL_189;
        }
        if (*(_DWORD *)(v38 + 52))
        {
          uint64_t v11 = *(unsigned int *)(v38 + 52);
        }
        else if ((~(_BYTE)v40 & 0xA) != 0)
        {
          if ((v35 & 0x100) == 0)
          {
            unsigned int v111 = (v28 & 0xFFFFFFBF | (((v35 >> 8) & 1) << 6)) ^ 0x40;
            if ((v40 & 0x8000000000) != 0)
            {
              *(void *)(v38 + 16) = v40 | 4;
              cv_wait_rw(v101, (pthread_mutex_t *)a1, 2, 0);
            }
            else
            {
              int v72 = v116;
              if ((sub_10001D40C((void *)v38, &v118, 0, v116) & 1) == 0)
              {
                uint64_t v11 = 0;
                LOBYTE(v37) = v111;
LABEL_241:
                uint64_t v89 = v121;
                if (v121)
                {
                  if (v72 != 2) {
                    sub_10005EC78();
                  }
LABEL_243:
                  char v110 = v37;
                  int v90 = *(_DWORD *)(a1 + 684);
                  if (!v90) {
                    sub_10005EC4C();
                  }
                  *(_DWORD *)(a1 + 684) = v90 - 1;
                  sub_100022918(v89, 1);
                  int v72 = v116;
                }
                else
                {
                  char v110 = v37;
                }
                if (v72) {
                  obj_cache_unlock_by_state((pthread_mutex_t *)a1, v72);
                }
                goto LABEL_254;
              }
            }
            unsigned int v37 = v111;
            goto LABEL_189;
          }
          uint64_t v11 = 0;
        }
        else
        {
          uint64_t v11 = 16;
        }
        goto LABEL_240;
      }
      if ((_WORD)v113 && (unsigned __int16)*(_DWORD *)(v38 + 36) && ((*(_DWORD *)(v38 + 36) ^ v113) & 0xEFFFFFFF) != 0
        || v112 && *(_DWORD *)(v38 + 40) != v112)
      {
        goto LABEL_100;
      }
      if ((v28 & 3) != 0)
      {
        uint64_t v31 = v38;
        if ((v28 & 2) == 0) {
          goto LABEL_102;
        }
LABEL_176:
        if (v31)
        {
          if (!a4)
          {
            LODWORD(v32) = *(_DWORD *)(v31 + 40);
            unsigned int v113 = *(_DWORD *)(v31 + 36);
          }
          goto LABEL_187;
        }
        goto LABEL_239;
      }
      if (v119)
      {
        unint64_t v41 = *(void *)(v38 + 120);
        if (v41 <= *(void *)(v38 + 144)) {
          unint64_t v41 = *(void *)(v38 + 144);
        }
        if (!v14)
        {
          if (v41 < v119) {
            goto LABEL_100;
          }
LABEL_77:
          char v42 = 1;
          goto LABEL_78;
        }
        if (v41 != v119) {
          goto LABEL_100;
        }
      }
      else
      {
        if (!v14) {
          goto LABEL_77;
        }
        unint64_t v41 = *(void *)(v38 + 120);
        if (v41 <= *(void *)(v38 + 144)) {
          unint64_t v41 = *(void *)(v38 + 144);
        }
      }
      if (v41 > v14) {
        goto LABEL_100;
      }
      char v42 = 0;
LABEL_78:
      if (!v31) {
        goto LABEL_99;
      }
      unint64_t v43 = *(void *)(v38 + 120);
      if (v43 <= *(void *)(v38 + 144)) {
        unint64_t v43 = *(void *)(v38 + 144);
      }
      unint64_t v44 = *(void *)(v31 + 120);
      if (v44 <= *(void *)(v31 + 144)) {
        unint64_t v44 = *(void *)(v31 + 144);
      }
      if (v43 >= v44)
      {
        if (v43 == v44)
        {
          uint64_t v45 = *(void *)(v31 + 16);
          if ((v40 & 0x200) == (v45 & 0x200)) {
            sub_10005ED54();
          }
          if (((v45 ^ v40) & 0x100) == 0) {
            sub_10005ED80();
          }
          if (v42)
          {
            if ((v40 & 0x200) != 0 && (v45 & 0x200) == 0) {
              goto LABEL_100;
            }
          }
          else if ((v40 & 0x200) == 0 && (v45 & 0x200) != 0)
          {
            goto LABEL_100;
          }
        }
        if ((v35 & 0x200) != 0)
        {
          if ((v40 & 0x80000000000) != 0 || (*(unsigned char *)(v31 + 21) & 8) == 0) {
LABEL_99:
          }
            uint64_t v31 = v38;
        }
        else if ((v40 & 0x80000000000) == 0 || (*(unsigned char *)(v31 + 21) & 8) != 0)
        {
          goto LABEL_99;
        }
      }
LABEL_100:
      uint64_t v38 = *(void *)(v38 + 72);
    }
    while (v38);
    if ((v28 & 2) != 0) {
      goto LABEL_176;
    }
LABEL_102:
    if (!v31 || (v28 & 4) == 0)
    {
      if (!v31) {
        goto LABEL_110;
      }
      if ((v28 & 4) != 0)
      {
        uint64_t v46 = *(void *)(v31 + 16);
        goto LABEL_191;
      }
LABEL_187:
      unsigned int v77 = v37;
      uint64_t v38 = v31;
      unsigned int v112 = v32;
      uint64_t v11 = sub_100022670(v31, v35, a3, v14, v113, v32, (v37 >> 6) & 1, &v118, &v116);
      if (v11 == 35) {
        goto LABEL_188;
      }
      goto LABEL_238;
    }
    uint64_t v46 = *(void *)(v31 + 16);
    if ((v46 & 0x40) != 0) {
      goto LABEL_191;
    }
    if (v14)
    {
      if (v14 > *(void *)(v31 + 168) && !v119) {
        goto LABEL_208;
      }
LABEL_191:
      if ((v46 & 0x300) != 0x100 && (v46 & 0x300) != 0x200) {
        sub_10005ECFC();
      }
      if (!v14)
      {
        if ((v46 & 0x100) == 0) {
          goto LABEL_197;
        }
        goto LABEL_187;
      }
      if ((v46 & 0x200) != 0) {
        goto LABEL_187;
      }
LABEL_197:
      char v78 = v116;
      if (v116 == 1) {
        char v78 = 2;
      }
      unsigned __int8 v116 = v78;
      unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 24), 0, memory_order_relaxed);
      if ((add_explicit & 0xFFFFFF) == ((add_explicit >> 24) & 0xFFFFF))
      {
        if (v14)
        {
          if ((v35 & 0x200) == 0 || (v46 & 0x80000000000) != 0)
          {
            unint64_t v80 = v46 & 0xFFFFFFFFFFFFFCFFLL | 0x200;
            goto LABEL_218;
          }
LABEL_207:
          v37 |= 8u;
        }
        else
        {
          unint64_t v80 = v46 & 0xFFFFFFFFFFFFFCDFLL | 0x120;
LABEL_218:
          *(void *)(v31 + 16) = v80;
        }
        goto LABEL_233;
      }
      if (!v14)
      {
        if ((v46 & 0x200) == 0) {
          goto LABEL_233;
        }
        unsigned int v77 = (v28 & 0xFFFFFFBF | (((v35 >> 8) & 1) << 6)) ^ 0x40;
        if (v121) {
          goto LABEL_225;
        }
        uint64_t v38 = v31;
        uint64_t v11 = sub_10001FE08(a1, *(unsigned int *)(v38 + 44), *(unsigned int *)(v31 + 36), *(unsigned int *)(v38 + 48), v35, &v115, &v121, v34);
        if (!v11)
        {
          if (v121 != v38 && !v115)
          {
            uint64_t v31 = v38;
            uint64_t v46 = *(void *)(v38 + 16);
LABEL_225:
            *(void *)(v31 + 16) = v46 & 0xFFFFFFFFFFFFFFDFLL;
            uint64_t v85 = v31;
            int v86 = obj_clone((pthread_cond_t **)v31, 0, &v121, &v115, v31, v32, v33, v34);
            if (v115) {
              sub_10005ED28();
            }
            unsigned int v37 = v77;
            uint64_t v32 = v112;
            uint64_t v11 = 0;
            if (v86)
            {
              unsigned int v37 = v77 | 8;
              uint64_t v31 = v85;
            }
            else
            {
              uint64_t v31 = v121;
              uint64_t v121 = 0;
              *(void *)(v31 + 16) |= 0x120uLL;
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 24), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
            }
            goto LABEL_233;
          }
LABEL_188:
          unsigned int v37 = v77;
          goto LABEL_189;
        }
LABEL_238:
        LOBYTE(v37) = v77;
        goto LABEL_240;
      }
      if ((v46 & 0x100) != 0 && (v35 & 8) == 0) {
        goto LABEL_207;
      }
      if ((v35 & 0x200) != 0 && (v46 & 0x80000000000) == 0) {
        v37 |= 8u;
      }
LABEL_233:
      if ((v37 & 8) == 0)
      {
        LODWORD(v35) = v122;
        goto LABEL_187;
      }
      uint64_t v87 = *(void *)(v31 + 16);
      if ((v87 & 0x20000000000) != 0)
      {
        *(void *)(v31 + 16) = v87 | 0x80;
        unsigned int v88 = v37;
        cv_wait_rw(v101, (pthread_mutex_t *)a1, 2, 0);
        unsigned int v37 = v88 & 0xFFFFFFF7;
        goto LABEL_189;
      }
      unint64_t v119 = *(void *)(v31 + 120);
LABEL_110:
      if (!a4)
      {
        if ((v122 & 0x10) != 0)
        {
          int v50 = v116;
          if (!v121)
          {
            unsigned int v109 = v37;
            uint64_t v51 = 0;
            uint64_t v52 = 0;
            if (v116 == 1) {
              int v50 = 2;
            }
            unsigned __int8 v116 = v50;
            goto LABEL_126;
          }
LABEL_128:
          if (v50 != 2) {
            goto LABEL_293;
          }
          uint64_t v47 = v121;
          uint64_t v121 = 0;
          unsigned int v48 = v122;
          unsigned int v49 = v122 & 0xFFFF0000;
          if (a4)
          {
LABEL_130:
            int v53 = a4[1];
            unsigned int v54 = *a4 | v49;
          }
          else
          {
            int v53 = 0;
            unsigned int v54 = v122 & 0xFFFF0000;
          }
          *(_DWORD *)(v47 + 36) = v54;
          *(_DWORD *)(v47 + 40) = v53;
          *(void *)(v47 + 112) = a3;
          if (!a6 || (uint64_t v55 = *(void *)(a6 + 496)) == 0) {
            uint64_t v55 = a6;
          }
          uint64_t v56 = (uint64_t *)(*(void *)(a1 + 704) + 8 * (*(_DWORD *)(a1 + 700) & a3));
          uint64_t v57 = *v56;
          *(void *)(v47 + 72) = *v56;
          *(void *)(v47 + 8) = v55;
          unint64_t v58 = v119;
          if ((v37 & 8) == 0) {
            unint64_t v58 = v14;
          }
          *(void *)(v47 + 120) = v58;
          if (v37) {
            unint64_t v59 = a3;
          }
          else {
            unint64_t v59 = 0;
          }
          *(void *)(v47 + 128) = v59;
          uint64_t v60 = *(void *)(v47 + 16);
          unint64_t v61 = (unsigned __int16)v48 & 0xFC00;
          if ((v37 & 4) != 0) {
            unint64_t v61 = 0;
          }
          if (v57) {
            *(void *)(v57 + 80) = v47 + 72;
          }
          unint64_t v62 = v60 | v49 | v61;
          *uint64_t v56 = v47;
          *(void *)(v47 + 80) = v56;
          uint64_t v63 = v62 | 0x10000000003;
          *(void *)(v47 + 16) = v62 | 0x10000000003;
          if ((v48 & 0x50) != 0)
          {
            uint64_t v63 = v62 | 0x1000000000BLL;
            *(void *)(v47 + 16) = v62 | 0x1000000000BLL;
            if ((v48 & 0x40) != 0)
            {
              uint64_t v63 = v62 | 0x1100000000BLL;
              *(void *)(v47 + 16) = v62 | 0x1100000000BLL;
            }
          }
          int v105 = v48 & 0x180;
          if ((v48 & 0x180) != 0) {
            v63 |= 0x8000000000uLL;
          }
          unint64_t v64 = v63 | ((unint64_t)(v48 & 0x200) << 34);
          if ((v37 & 4) != 0) {
            v64 |= v104;
          }
          if ((v48 & 0x380) != 0 || (v37 & 4) != 0) {
            *(void *)(v47 + 16) = v64;
          }
          unsigned int v106 = v48;
          unint64_t v65 = atomic_fetch_add_explicit((atomic_ullong *volatile)(v47 + 24), 0, memory_order_relaxed);
          if ((v65 & 0xFFFFFF) != ((v65 >> 24) & 0xFFFFF)) {
            sub_10005ECA4();
          }
          unsigned int v66 = v37;
          obj_retain_0((atomic_ullong *)v47);
          if (!v105) {
            v66 |= 0x10u;
          }
          obj_cache_unlock_write(a1);
          unsigned __int8 v116 = 0;
          uint64_t v107 = (atomic_ullong *)v47;
          char v102 = v66;
          char v110 = v66 & 0x9F;
          if ((v66 & 4) != 0)
          {
            uint64_t v71 = *(void *)(v47 + 8);
            if (!v71) {
              uint64_t v71 = *(void *)(a1 + 392);
            }
            uint64_t v11 = omap_get(v71, a3, v14, (void *)(v47 + 128), 0, &v117, &v120);
            long long v69 = v103;
            if (v11) {
              goto LABEL_180;
            }
            if ((v106 & 8) != 0 && v120 != v14)
            {
              uint64_t v11 = 2;
              goto LABEL_180;
            }
LABEL_158:
            if (!v105)
            {
              uint64_t v11 = obj_read((uint64_t)v107, v120, v117, 0, v67, v68, v120, v117);
              goto LABEL_180;
            }
            unint64_t v70 = sub_100021F5C(a1, v106, a4, v69, a6, v107, v120, v117, (unsigned char *)&v114 + 1);
            uint64_t v11 = v70;
            if (!HIBYTE(v114)) {
              goto LABEL_180;
            }
            if (v70)
            {
              long long v91 = v107;
              obj_free((uint64_t)v107);
            }
            else
            {
              if ((v106 & 0x100) == 0)
              {
                uint64_t v38 = (uint64_t)v107;
LABEL_256:
                char v93 = v122;
                if ((v122 & 4) != 0)
                {
                  if (v122) {
                    unsigned int v94 = 2;
                  }
                  else {
                    unsigned int v94 = 1;
                  }
                  obj_lock(v38, v94);
                  char v93 = v122;
                }
                if ((v93 & 1) != 0
                  && (uint64_t v95 = obj_modify((void *)v38, v93 & 3, a8, v30, v31, v32, v33, v34), v95))
                {
                  uint64_t v11 = v95;
                  if ((v122 & 4) != 0)
                  {
                    if (v122) {
                      unsigned int v96 = 2;
                    }
                    else {
                      unsigned int v96 = 1;
                    }
                    obj_unlock(v38, v96);
                  }
                  obj_release((uint64_t *)v38);
                }
                else
                {
                  if ((v110 & 2) == 0)
                  {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + 1072), 1uLL, memory_order_relaxed);
                    uint64_t v97 = 1080;
                    if ((v110 & 0x20) == 0) {
                      uint64_t v97 = 1088;
                    }
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(a1 + v97), 1uLL, memory_order_relaxed);
                    uint64_t v98 = qword_100084A18;
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_100084A18 + 264), 1uLL, memory_order_relaxed);
                    uint64_t v99 = 272;
                    if ((v110 & 0x20) == 0) {
                      uint64_t v99 = 280;
                    }
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v98 + v99), 1uLL, memory_order_relaxed);
                  }
                  uint64_t v11 = 0;
                  if ((v122 & 0x100) != 0) {
                    uint64_t v100 = 0;
                  }
                  else {
                    uint64_t v100 = v38;
                  }
                  *a9 = v100;
                }
                return v11;
              }
              uint64_t v11 = 0;
              long long v91 = v107;
            }
            uint64_t v38 = (uint64_t)v91;
          }
          else
          {
            long long v69 = v103;
            if (!v11) {
              goto LABEL_158;
            }
LABEL_180:
            pthread_mutex_lock((pthread_mutex_t *)a1);
            unsigned __int8 v116 = 2;
            unint64_t v73 = v117;
            uint64_t v74 = (uint64_t)v107;
            if ((v117 & 0xE0) != 0) {
              v107[2] = v107[2] & 0xFFFFFFFFFFFF1FFFLL | ((unint64_t)(v117 >> 5) << 13);
            }
            if ((v73 & 0x700) != 0) {
              v107[2] = v107[2] & 0xFFFFFFFFFFFFE3FFLL | (((v73 >> 8) & 7) << 10);
            }
            char v75 = v106;
            if (!v11)
            {
              uint64_t v76 = sub_100022450((pthread_cond_t **)v107, v106, a3, a4, (uint64_t)v69, v14, v113, v112);
              if (!v76)
              {
                unsigned int v37 = v66 & 0xFFFFFF9F;
                LODWORD(v32) = v112;
                uint64_t v31 = (uint64_t)v107;
                LODWORD(v35) = v106;
                goto LABEL_187;
              }
              uint64_t v11 = v76;
              uint64_t v74 = (uint64_t)v107;
              char v75 = v106;
            }
            *(_DWORD *)(v74 + 52) = v11;
            long long v91 = (uint64_t *)v74;
            sub_100020868(v74, v75);
            char v92 = v110;
            if ((v102 & 0x10) != 0) {
              char v92 = v102 & 0x8F;
            }
            char v110 = v92;
            v91[2] = v91[2] & 0xFFFFFFEFFFFFFFF7 | 8;
            obj_cache_unlock_by_state((pthread_mutex_t *)a1, 2);
            uint64_t v38 = 0;
          }
          obj_release(v91);
LABEL_254:
          if (v11) {
            return v11;
          }
          if (!v38) {
            return 2;
          }
          goto LABEL_256;
        }
        uint64_t v38 = 0;
LABEL_240:
        int v72 = v116;
        goto LABEL_241;
      }
      uint64_t v47 = v121;
      if (v121)
      {
        if (v116 == 2)
        {
          uint64_t v121 = 0;
          unsigned int v48 = v122;
          unsigned int v49 = v122 & 0xFFFF0000;
          goto LABEL_130;
        }
LABEL_293:
        sub_10005ECD0();
      }
      unsigned int v109 = v37;
      if (v116 == 1) {
        int v50 = 2;
      }
      else {
        int v50 = v116;
      }
      unsigned __int8 v116 = v50;
      uint64_t v52 = a4[2];
      uint64_t v51 = a4[3];
LABEL_126:
      uint64_t v11 = sub_10001FE08(a1, v51, v113, v52, v122, &v115, &v121, v34);
      if (v11)
      {
        uint64_t v38 = 0;
        LOBYTE(v37) = v109;
        goto LABEL_240;
      }
      unsigned int v37 = v109;
      if (!v115) {
        goto LABEL_128;
      }
LABEL_189:
      uint64_t v35 = v122;
      unsigned int v28 = v37;
      continue;
    }
    break;
  }
  if (*(void *)(v31 + 16) & 0x20 | v119) {
    goto LABEL_191;
  }
LABEL_208:
  uint64_t v108 = v31;
  unsigned int v77 = (v28 & 0xFFFFFFBF | (((v35 >> 8) & 1) << 6)) ^ 0x40;
  int v81 = v116;
  obj_cache_unlock_by_state((pthread_mutex_t *)a1, v116);
  uint64_t v82 = a6;
  if (!a6) {
    uint64_t v82 = *(void *)(a1 + 392);
  }
  uint64_t v11 = omap_get(v82, a3, v14, 0, 0, 0, &v119);
  if (!v11)
  {
    obj_cache_lock_by_state((pthread_mutex_t *)a1, v81);
    unsigned __int8 v116 = v81;
    goto LABEL_188;
  }
  uint64_t v89 = v121;
  if (v121)
  {
    pthread_mutex_lock((pthread_mutex_t *)a1);
    unsigned __int8 v116 = 2;
    uint64_t v38 = v108;
    LOBYTE(v37) = v77;
    goto LABEL_243;
  }
  return v11;
}

uint64_t sub_100021D8C(uint64_t result, unsigned char *a2)
{
  *a2 = 1;
  uint64_t v2 = *(void *)(result + 1344);
  if (v2)
  {
    uint64_t v4 = result;
    while (1)
    {
      if ((*(unsigned char *)(*(void *)(v2 + 136) + 20) & 0x80) == 0)
      {
        uint64_t result = dev_read_poll(*(void *)(*(void *)(v4 + 392) + 384));
        if (result != 36) {
          break;
        }
      }
      uint64_t v2 = *(void *)(v2 + 104);
      if (!v2) {
        return result;
      }
    }
    return sub_10002377C(v2, a2);
  }
  return result;
}

uint64_t sub_100021E1C(uint64_t result, int a2, unsigned int *a3)
{
  unsigned int v3 = *a3;
  if (*a3 >> 30) {
    sub_10005EDD8();
  }
  uint64_t v5 = *(void *)(result + 496);
  if (!v5) {
    uint64_t v5 = result;
  }
  if (*(unsigned char *)(*(void *)(v5 + 376) + 264))
  {
    unsigned int v9 = v3 & 0xEFFF03FF;
  }
  else
  {
    unsigned int v6 = v3 & 0xFFFF1FFF;
    if (a2 == 36) {
      int v7 = 268443648;
    }
    else {
      int v7 = 0x10000000;
    }
    *a3 = v6 | v7;
    uint64_t result = apfs_has_secondary_fsroot(result);
    if (result) {
      int v8 = 1024;
    }
    else {
      int v8 = 0;
    }
    unsigned int v9 = *a3 & 0xFFFFE3FF | v8;
  }
  *a3 = v9;
  return result;
}

uint64_t sub_100021EB4(uint64_t *a1)
{
  uint64_t v1 = a1[2];
  if ((v1 & 2) == 0) {
    __assert_rtn("obj_initting_wait", "obj.c", 4003, "o->o_flags & OBJ_INITTING");
  }
  uint64_t v2 = *a1;
  long long v5 = xmmword_100076E10;
  char v4 = 0;
  uint64_t result = cv_wait_rw((pthread_cond_t *)(v2 + 1296), (pthread_mutex_t *)v2, 2, (timespec *)((unint64_t)&v5 & (v1 << 23 >> 63)));
  if ((v1 & 0x10000000000) != 0 && *(void *)(v2 + 1344))
  {
    uint64_t result = sub_100021D8C(v2, &v4);
    if (!v4) {
      return pthread_mutex_lock((pthread_mutex_t *)v2);
    }
  }
  return result;
}

unint64_t sub_100021F5C(uint64_t a1, int a2, _OWORD *a3, _WORD *a4, uint64_t a5, atomic_ullong *a6, unint64_t a7, uint64_t a8, unsigned char *a9)
{
  *a9 = 0;
  uint64_t v16 = (void (**)(uint64_t, int8x16_t, int8x16_t))_apfs_calloc(1uLL, 0xA0uLL);
  if (!v16)
  {
    unint64_t v30 = 12;
LABEL_12:
    *a9 = 1;
    return v30;
  }
  unint64_t v24 = v16;
  if (!a4) {
    goto LABEL_15;
  }
  if (*a4 != 25987)
  {
    log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%x type 0x%x/0x%x: attempt to perform async fetch without proper init args\n", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"obj_get_async_read");
    unint64_t v30 = 22;
LABEL_11:
    _apfs_free(v24, 160);
    goto LABEL_12;
  }
  size_t v25 = (unsigned __int16)a4[1];
  if (!a4[1])
  {
    size_t v29 = 0;
    unsigned int v28 = v24[19];
    goto LABEL_14;
  }
  if (v25 <= 3
    || (int v26 = (void (*)(uint64_t, int8x16_t, int8x16_t))_apfs_malloc(v25),
        size_t v27 = (unsigned __int16)a4[1],
        v27 <= 3))
  {
    __assert_rtn("obj_get_async_read", "obj.c", 3593, "args->oia_size >= sizeof(obj_init_async_args_t)");
  }
  unsigned int v28 = v26;
  bzero(v26, v27);
  v24[19] = v28;
  if (!v28)
  {
    unint64_t v30 = 12;
    goto LABEL_11;
  }
  size_t v29 = (unsigned __int16)a4[1];
LABEL_14:
  memcpy(v28, a4, v29);
  *((unsigned char *)v24 + 148) = 1;
LABEL_15:
  pthread_mutex_lock((pthread_mutex_t *)a1);
  v24[13] = 0;
  uint64_t v31 = *(void (****)(uint64_t, int8x16_t, int8x16_t))(a1 + 1352);
  v24[14] = (void (*)(uint64_t, int8x16_t, int8x16_t))v31;
  *uint64_t v31 = v24;
  *(void *)(a1 + 1352) = v24 + 13;
  obj_cache_unlock_write(a1);
  *unint64_t v24 = sub_100024C04;
  v24[17] = (void (*)(uint64_t, int8x16_t, int8x16_t))a6;
  *(_OWORD *)(v24 + 15) = *a3;
  *((_DWORD *)v24 + 36) = a2;
  obj_retain_0(a6);
  atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 916), 1u, memory_order_relaxed);
  unint64_t v30 = obj_read((uint64_t)a6, a7, a8, (uint64_t)v24, v32, v33, v34, v35);
  if (!v30)
  {
    *a9 = 1;
    pthread_mutex_lock((pthread_mutex_t *)a1);
    atomic_ullong v36 = a6[2];
    unint64_t v37 = (v36 & 4 ^ 0xFFFFFF7FFFFFFFFFLL) & v36;
    if ((a8 & 0xE0) != 0) {
      unint64_t v37 = v37 & 0xFFFFFFFFFFFF1FFFLL | (a8 << 8) & 0xE000;
    }
    if ((a8 & 0x700) != 0) {
      unint64_t v37 = v37 & 0xFFFFFFFFFFFFE3FFLL | (4 * a8) & 0x1C00;
    }
    a6[2] = v37;
    obj_cache_unlock_write(a1);
    if ((v36 & 4) != 0) {
      cv_wakeup((pthread_cond_t *)(a1 + 1296));
    }
    return 0;
  }
  return v30;
}

unint64_t obj_read(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(_DWORD *)(a1 + 48);
  uint64_t v9 = *(void *)(*(void *)a1 + 392);
  unsigned int v10 = *(_DWORD *)(*(void *)(v9 + 376) + 36);
  if (v8 % v10) {
    sub_10005EE04();
  }
  uint64_t v14 = *(void *)(a1 + 128);
  uint64_t v15 = *(void *)(a1 + 8);
  if (v14)
  {
    int v16 = *(_DWORD *)(a1 + 36);
    if ((a3 & 4) != 0 && v15)
    {
      *(_DWORD *)(a1 + 36) = v16 | 0x10000000;
      if ((*(unsigned char *)(a1 + 21) & 8) == 0)
      {
        if (a3 >> 5 == 1)
        {
          uint64_t v17 = v15 + 624;
          uint64_t v18 = v15 + 816;
        }
        else
        {
          if (a3 >> 5) {
            panic("invalid crypto index %d\n");
          }
          uint64_t v17 = v15 + 528;
          uint64_t v18 = v15 + 720;
        }
        if ((a3 & 0x10) != 0) {
          uint64_t v20 = v18;
        }
        else {
          uint64_t v20 = v17;
        }
        unsigned int v19 = (a3 >> 8) & 7;
        if (v19)
        {
          if (v19 != 1) {
            panic("invalid tweak type %d\n");
          }
          uint64_t v21 = *(void *)(a1 + 112) ^ HIDWORD(a2) | *(void *)(a1 + 112) & 0xFFFFFFFF00000000 ^ (a2 << 32);
          unsigned int v19 = 4;
          if ((a3 & 8) != 0) {
            goto LABEL_26;
          }
        }
        else
        {
          uint64_t v21 = (a3 >> 8) & 7;
          if ((a3 & 8) != 0) {
            goto LABEL_26;
          }
        }
LABEL_25:
        if ((*(unsigned char *)(a1 + 21) & 8) == 0) {
          goto LABEL_27;
        }
        goto LABEL_26;
      }
      unsigned int v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      if ((a3 & 8) == 0) {
        goto LABEL_25;
      }
    }
    else
    {
      unsigned int v19 = 0;
      uint64_t v20 = 0;
      uint64_t v21 = 0;
      *(_DWORD *)(a1 + 36) = v16 & 0xEFFFFFFF;
      if ((a3 & 8) == 0) {
        goto LABEL_25;
      }
    }
LABEL_26:
    *(void *)(a1 + 120) = a2;
LABEL_27:
    if (!v20 || (uint64_t v23 = *(void *)(v15 + 1144)) == 0) {
      uint64_t v23 = *(void *)(v9 + 384);
    }
    uint64_t extended = dev_read_extended(v23, v14, (v8 + v10 - 1) / v10, *(void *)(a1 + 56), v20, a4 != 0, a4, v21, v19);
    unint64_t v22 = extended;
    if (!a4 && !extended)
    {
      if ((*(void *)(a1 + 16) & 0x80020000000) != 0)
      {
        return 0;
      }
      else
      {
        unint64_t v22 = obj_checksum_verify(a1, v25, v26);
        if (v22) {
          log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x paddr 0x%llx error verifying checksum\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"obj_read");
        }
      }
    }
    return v22;
  }
  log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x object missing paddr!\n", 0, a3, a4, a5, a6, a7, a8, (uint64_t)"obj_read");
  unint64_t v22 = 22;
  if (a4)
  {
    *(_DWORD *)(a4 + 96) = 22;
    (*(void (**)(uint64_t))a4)(a4);
  }
  return v22;
}

uint64_t sub_100022450(pthread_cond_t **a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v10 = a2;
  unint64_t v12 = (unint64_t)a1[2];
  if ((v12 & 0x80020000000) != 0)
  {
LABEL_2:
    uint64_t v13 = 0;
    if ((v10 & 0x210) == 0 && a4)
    {
      uint64_t v23 = 0;
      uint64_t v14 = obj_descriptor_funcs_for_type(*((_DWORD *)a1 + 9), &v23);
      if (v14)
      {
        uint64_t v13 = v14;
      }
      else
      {
        uint64_t v17 = *(uint64_t (**)(pthread_cond_t **, uint64_t))(v23 + 8);
        if (v17)
        {
          uint64_t v13 = v17(a1, a5);
          unint64_t v12 = (unint64_t)a1[2];
        }
        else
        {
          uint64_t v13 = 0;
        }
      }
    }
    goto LABEL_30;
  }
  uint64_t v15 = a1[7];
  int v16 = *(pthread_cond_t **)&v15->__opaque[8];
  a1[15] = v16;
  if (!a8) {
    *((_DWORD *)a1 + 10) = *(_DWORD *)&v15->__opaque[20];
  }
  if ((_WORD)a7 && ((*(_DWORD *)&v15->__opaque[16] ^ a7) & 0xEFFFFFFF) != 0
    || a8 && *(_DWORD *)&v15->__opaque[20] != a8
    || *(void *)v15->__opaque != a3
    || (uint64_t v13 = 0, a6) && (unint64_t)v16 > a6)
  {
    if ((a2 & 0x20) == 0)
    {
      log_err((uint64_t)"%s:%d: %s wrong object at 0x%llx - wanted oid 0x%llx type 0x%x:0x%x xid %lld - got oid 0x%llx type 0x%x:0x%x xid %lld\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"obj_init");
      uint64_t v13 = nx_corruption_detected_int(*(void *)(*a1)[8].__opaque);
      if (!a4) {
        goto LABEL_24;
      }
      goto LABEL_22;
    }
    uint64_t v13 = 2;
  }
  if (!a4) {
    goto LABEL_24;
  }
LABEL_22:
  if (*a4)
  {
    int v18 = *((_DWORD *)a1 + 9);
    goto LABEL_25;
  }
LABEL_24:
  unsigned int v19 = a1[7];
  int v18 = *(unsigned __int16 *)&v19->__opaque[16] | (*((unsigned __int16 *)a1 + 19) << 16);
  LODWORD(v19) = *(_DWORD *)&v19->__opaque[20];
  *((_DWORD *)a1 + 9) = v18;
  *((_DWORD *)a1 + 10) = v19;
LABEL_25:
  unint64_t v12 = (unint64_t)a1[2];
  uint64_t v20 = v18 & 0x10000000;
  if ((v12 & 0x10000000) != v20)
  {
    unint64_t v12 = v12 & 0xFFFFFFFFEFFFFFFFLL | v20;
    a1[2] = (pthread_cond_t *)v12;
  }
  if (!v13) {
    goto LABEL_2;
  }
LABEL_30:
  *((_DWORD *)a1 + 13) = v13;
  if (v13 | v10 & 0x10) {
    unint64_t v21 = 0xFFFFFE7FFFFFFFFBLL;
  }
  else {
    unint64_t v21 = 0xFFFFFE7FFFFFFFF9;
  }
  a1[2] = (pthread_cond_t *)(v12 & v21);
  if ((v12 & 4) != 0) {
    cv_wakeup(*a1 + 27);
  }
  return v13;
}

uint64_t sub_100022670(uint64_t a1, int a2, uint64_t a3, unint64_t a4, int a5, int a6, int a7, int *a8, unsigned char *a9)
{
  uint64_t v9 = *(void *)(a1 + 16);
  if ((v9 & 0x10) != 0) {
    return 2;
  }
  uint64_t v16 = *(void *)a1;
  if ((a2 & 0x40) == 0 && (v9 & 0x1000000008) == 0x1000000008)
  {
    if (*a9 == 1)
    {
      *a9 = 2;
      uint64_t v9 = *(void *)(a1 + 16);
    }
    v9 &= 0xFFFFFFEFFFFFFFF7;
    *(void *)(a1 + 16) = v9;
  }
  if ((a2 & 0x50) == 0 && (v9 & 8) != 0) {
    sub_10005EF64();
  }
  if (a7 && (sub_10001D40C((void *)a1, a8, 0, *a9) & 1) != 0) {
    return 35;
  }
  unsigned int v18 = a2 & 0xC8000000;
  if ((atomic_fetch_and_explicit((atomic_uint *volatile)(a1 + 32), 0xFFFFFFFD, memory_order_relaxed) & 2) != 0) {
    cv_wakeup((pthread_cond_t *)(v16 + 1296));
  }
  if ((*(unsigned char *)(a1 + 32) & 1) == 0 && (*(unsigned char *)(a1 + 19) & 0x80) == 0)
  {
    int v19 = pthread_rwlock_rdlock((pthread_rwlock_t *)(v16 + 128));
    if (v19) {
      panic("%s:%d: rdlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 3303, v19);
    }
    if (*(void *)(a1 + 88) != 3735928559) {
      sub_100023980(v16, a1);
    }
    int v20 = pthread_rwlock_unlock((pthread_rwlock_t *)(v16 + 128));
    if (v20) {
      panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 3307, v20);
    }
  }
  if (!v18 && a4)
  {
    unint64_t v21 = *(void *)(a1 + 168);
    if (v21 <= a4) {
      unint64_t v21 = a4;
    }
    *(void *)(a1 + 168) = v21;
  }
  uint64_t v22 = *(void *)(a1 + 16);
  if ((a2 & 1) != 0 && !a4 && (v22 & 0x200) != 0) {
    sub_10005EF38();
  }
  if ((*(void *)(a1 + 16) & 0xC8000000) != v18) {
    sub_10005EF0C();
  }
  if ((_WORD)a5 && ((*(_DWORD *)(a1 + 36) ^ a5) & 0xEFFFFFFF) != 0 || a6 && *(_DWORD *)(a1 + 40) != a6) {
    sub_10005EEE0();
  }
  if ((v22 & 0x80020000040) == 0
    && ((_WORD)a5 && ((*(_DWORD *)(*(void *)(a1 + 56) + 24) ^ a5) & 0xEFFFFFFF) != 0
     || a6 && *(_DWORD *)(*(void *)(a1 + 56) + 28) != a6))
  {
    sub_10005EEB4();
  }
  uint64_t v23 = *(void *)(a1 + 112);
  if (v23 != a3 && v23 != *(void *)(a1 + 128) && v23 != *(void *)(a1 + 152)) {
    sub_10005EE88();
  }
  if ((v22 & 0x800E0000040) == 0 && v23 != *(void *)(*(void *)(a1 + 56) + 8)) {
    sub_10005EE5C();
  }
  uint64_t result = 0;
  if (a4)
  {
    if (*(void *)(a1 + 120) > a4) {
      sub_10005EE30();
    }
  }
  return result;
}

void sub_100022918(uint64_t a1, char a2)
{
  uint64_t v4 = *(void *)a1;
  uint64_t v5 = *(void *)(a1 + 16);
  if ((v5 & 0xC00000000) != 0 && !*(_DWORD *)(v4 + 912)) {
    sub_10005F014();
  }
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 72);
    if (v6) {
      *(void *)(v6 + 80) = *(void *)(a1 + 80);
    }
    **(void **)(a1 + 80) = v6;
    *(void *)(a1 + 16) = v5 & 0xFFFFFFFFFFFFFFFELL;
  }
  unsigned int v7 = atomic_load_explicit((atomic_uint *volatile)(a1 + 32), memory_order_acquire) & 0x10;
  if (*(void *)(a1 + 88) != 3735928559 || v7 != 0)
  {
    int v9 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v4 + 128));
    if (v9) {
      panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 2908, v9);
    }
    uint64_t v10 = *(void *)(a1 + 88);
    if (v10 == 3735928559) {
      goto LABEL_34;
    }
    uint64_t v11 = *(void *)(a1 + 16);
    if ((v11 & 0x80000000) == 0)
    {
      if ((*(unsigned char *)(a1 + 32) & 1) == 0)
      {
        sub_1000248FC((uint64_t *)a1);
        goto LABEL_34;
      }
      if (*(void *)(v4 + 864) == a1) {
        *(void *)(v4 + 864) = v10;
      }
      if ((v11 & 0x40000000) != 0)
      {
        int v15 = *(_DWORD *)(v4 + 888);
        if (!v15) {
          sub_10005EFE8();
        }
        uint64_t v16 = *(void **)(a1 + 96);
        if (v10)
        {
          *(void *)(v10 + 96) = v16;
          uint64_t v16 = *(void **)(a1 + 96);
        }
        else
        {
          *(void *)(v4 + 824) = v16;
        }
        *uint64_t v16 = v10;
        *(_DWORD *)(v4 + 888) = v15 - 1;
      }
      else
      {
        int v13 = *(_DWORD *)(v4 + 884);
        if (!v13) {
          sub_10005EFBC();
        }
        uint64_t v14 = *(void **)(a1 + 96);
        if (v10)
        {
          *(void *)(v10 + 96) = v14;
          uint64_t v14 = *(void **)(a1 + 96);
        }
        else
        {
          *(void *)(v4 + 808) = v14;
        }
        *uint64_t v14 = v10;
        *(_DWORD *)(v4 + 884) = v13 - 1;
      }
LABEL_33:
      *(void *)(a1 + 88) = 3735928559;
LABEL_34:
      sub_100024E54(v4, a1);
      int v17 = pthread_rwlock_unlock((pthread_rwlock_t *)(v4 + 128));
      if (v17) {
        panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 2936, v17);
      }
      goto LABEL_36;
    }
    unint64_t v12 = *(void **)(a1 + 96);
    if ((v11 & 0x8000000) != 0)
    {
      if (!v10)
      {
        *(void *)(v4 + 760) = v12;
        goto LABEL_32;
      }
    }
    else if (!v10)
    {
      *(void *)(v4 + 744) = v12;
LABEL_32:
      void *v12 = v10;
      goto LABEL_33;
    }
    *(void *)(v10 + 96) = v12;
    unint64_t v12 = *(void **)(a1 + 96);
    goto LABEL_32;
  }
LABEL_36:
  if ((a2 & 1) != 0 || !sub_100024A98(a1))
  {
    sub_100024AE8((void *)a1, 1);
  }
  else
  {
    if (*(void *)(v4 + 720))
    {
      uint64_t v18 = *(void *)(v4 + 728);
      if (!v18) {
        sub_10005EF90();
      }
      uint64_t v20 = *(void *)(v18 + 72);
      uint64_t v19 = v18 + 72;
      *(void *)(a1 + 72) = v20;
      if (v20) {
        *(void *)(*(void *)v19 + 80) = a1 + 72;
      }
    }
    else
    {
      uint64_t v19 = v4 + 720;
      *(void *)(a1 + 72) = 0;
    }
    *(void *)uint64_t v19 = a1;
    *(void *)(a1 + 80) = v19;
    *(void *)(v4 + 728) = a1;
  }
}

uint64_t obj_lock(uint64_t a1, unsigned int a2)
{
  if (a2 >= 4) {
    sub_10005F040();
  }
  if (a2)
  {
    if (pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 176))) {
      panic("%s:%d: rdlock == 0 failed %d\n");
    }
  }
  else
  {
    if ((a2 & 2) == 0) {
      panic("invalid lock flags: 0x%x\n");
    }
    if (pthread_rwlock_wrlock((pthread_rwlock_t *)(a1 + 176))) {
      panic("%s:%d: wrlock == 0 failed %d\n");
    }
  }
  return 0;
}

uint64_t obj_modify(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *a1;
  uint64_t v9 = *(void *)(*a1 + 392);
  if (a1[1]) {
    uint64_t v10 = a1[1];
  }
  else {
    uint64_t v10 = *(void *)(*a1 + 392);
  }
  if (a2 >= 4) {
    sub_10005F06C();
  }
  char v12 = a2;
  uint64_t v14 = a1[2];
  if ((v14 & 0x8000000) == 0)
  {
    if (*(unsigned char *)(v9 + 627)) {
      return 30;
    }
    if (!xid_is_current_tx(*(void *)(*a1 + 392), a3)) {
      return 22;
    }
    uint64_t v14 = a1[2];
  }
  if ((v14 & 0x10000000000) != 0)
  {
    log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x can't modify object before read completes\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"obj_modify");
    return 22;
  }
  uint64_t v16 = a1[8];
  if (v16 && v16 == a1[7])
  {
    if (!qword_100084A18) {
      sub_10005E8DC();
    }
    size_t v17 = *((unsigned int *)a1 + 12);
    uint64_t v18 = _apfs_obj_zalloc(v17, *(void *)(v8 + 920));
    sub_100024E98((atomic_ullong *)(v8 + 944), v14, (uint64_t)v18, v17);
    sub_100024E98((atomic_ullong *)(qword_100084A18 + 136), v14, (uint64_t)v18, v17);
    if (!v18) {
      return 12;
    }
    while ((atomic_fetch_or_explicit((atomic_uint *volatile)a1 + 8, 8u, memory_order_acquire) & 8) != 0)
    {
      pthread_mutex_lock((pthread_mutex_t *)(v8 + 328));
      pthread_mutex_unlock((pthread_mutex_t *)(v8 + 328));
    }
    uint64_t v21 = a1[8];
    if (v21 && v21 == a1[7])
    {
      if ((a1[2] & 0x80020000000) == 0 && obj_checksum_verify_phys(v21, *((_DWORD *)a1 + 12), v19, v20))
      {
        if (*(_WORD *)(v10 + 36) == 13) {
          BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(v10 + 392));
        }
        else {
          BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(v10);
        }
        log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x paddr 0x%llx error verifying checksum, phys %p/%p\n", v23, v24, v25, v26, v27, v28, (uint64_t)"obj_modify");
      }
      memcpy(v18, (const void *)a1[7], v17);
      a1[8] = v18;
      atomic_fetch_and_explicit((atomic_uint *volatile)a1 + 8, 0xFFFFFFF7, memory_order_release);
    }
    else
    {
      atomic_fetch_and_explicit((atomic_uint *volatile)a1 + 8, 0xFFFFFFF7, memory_order_release);
      fs_obj_zfree_oc(v18, v17, a1[2], v8);
    }
  }
  uint64_t v29 = a1[2];
  if ((v29 & 0x80000000) != 0) {
    return 0;
  }
  if ((v29 & 0xC0000000) == 0)
  {
    if ((v29 & 0xC00000000) != 0 || a1[15] == a3) {
      return 0;
    }
    pthread_mutex_lock((pthread_mutex_t *)v8);
    uint64_t v31 = a1[2];
    if ((v31 & 0xC00000000) == 0)
    {
      while (a1[15] != a3)
      {
        unsigned int v33 = *(_DWORD *)(*(void *)(v9 + 376) + 36);
        int v34 = *((_DWORD *)a1 + 12);
        int v65 = 0;
        if ((v31 & 0x100000000) == 0)
        {
          a1[2] = v31 | (unint64_t)&_mh_execute_header;
          unint64_t v37 = (v33 + v34 - 1) / v33;
          obj_cache_unlock_write(v8);
          uint64_t v15 = spaceman_reserve(v10, 0x48u, v37, a3, &v65);
          pthread_mutex_lock((pthread_mutex_t *)v8);
          uint64_t v45 = a1[2];
          a1[2] = v45 & 0xFFFFFFFCFFFFFFFFLL;
          if (v15)
          {
            log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error reserving %d blocks of space: %d\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"obj_modify");
          }
          else
          {
            uint64_t v46 = 0x800000000;
            if ((v65 & 0x10) == 0) {
              uint64_t v46 = 0x400000000;
            }
            a1[2] = v46 | v45 & 0xFFFFFFFCFFFFFFFFLL;
          }
          obj_cache_unlock_write(v8);
          if ((v45 & 0x200000000) != 0) {
            cv_wakeup((pthread_cond_t *)(v8 + 1296));
          }
          return v15;
        }
        a1[2] = v31 | 0x200000000;
        cv_wait_rw((pthread_cond_t *)(v8 + 1296), (pthread_mutex_t *)v8, 2, 0);
        uint64_t v31 = a1[2];
        if ((v31 & 0xC00000000) != 0) {
          goto LABEL_42;
        }
      }
    }
    goto LABEL_42;
  }
  if (v12 & 2) == 0 || (a1[4]) {
    return 0;
  }
  pthread_mutex_lock((pthread_mutex_t *)v8);
  if (a1[4]) {
    goto LABEL_42;
  }
  uint64_t v30 = a1[19];
  if (v30)
  {
LABEL_38:
    sub_100023DDC(a1, a3, v30);
LABEL_42:
    obj_cache_unlock_write(v8);
    return 0;
  }
  if (a1[15] == a3)
  {
    uint64_t v30 = a1[16];
    goto LABEL_38;
  }
  uint64_t v35 = (*(_DWORD *)(*(void *)(v9 + 376) + 36) + *((_DWORD *)a1 + 12) - 1)
      / *(_DWORD *)(*(void *)(v9 + 376) + 36);
  atomic_fetch_or_explicit((atomic_uint *volatile)a1 + 8, 1u, memory_order_relaxed);
  obj_cache_unlock_write(v8);
  if ((*((unsigned char *)a1 + 19) & 0x10) != 0)
  {
    unint64_t v64 = 0;
  }
  else
  {
    if (*((_WORD *)a1 + 18) == 11 || *((_WORD *)a1 + 20) == 11) {
      uint64_t v36 = 2;
    }
    else {
      uint64_t v36 = 1;
    }
    unint64_t v64 = v36;
  }
  uint64_t v47 = spaceman_alloc((void *)v10, 72, v35, a3, &v64, 0);
  if (v47)
  {
    uint64_t v55 = v47;
    log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error allocating new location %d\n", v48, v49, v50, v51, v52, v53, v54, (uint64_t)"obj_modify");
    pthread_mutex_lock((pthread_mutex_t *)v8);
    atomic_fetch_and_explicit((atomic_uint *volatile)a1 + 8, 0xFFFFFFFE, memory_order_relaxed);
    obj_cache_unlock_write(v8);
    return v55;
  }
  else
  {
    if (a1[1]) {
      apfs_check_for_spillover();
    }
    pthread_mutex_lock((pthread_mutex_t *)v8);
    unint64_t v56 = a1[16];
    atomic_fetch_and_explicit((atomic_uint *volatile)a1 + 8, 0xFFFFFFFE, memory_order_relaxed);
    sub_100023DDC(a1, a3, v64);
    obj_cache_unlock_write(v8);
    uint64_t v15 = spaceman_free((void *)v10, 0, v56, v35, a3);
    if (v15) {
      log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x error freeing old space @ 0x%llx: %d\n", v57, v58, v59, v60, v61, v62, v63, (uint64_t)"obj_modify");
    }
  }
  return v15;
}

uint64_t obj_unlock(uint64_t a1, unsigned int a2)
{
  if (a2 >= 4) {
    sub_10005F098();
  }
  if (a2)
  {
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 176))) {
      goto LABEL_8;
    }
  }
  else
  {
    if ((a2 & 2) == 0) {
      panic("invalid unlock flags: 0x%x\n");
    }
    if (pthread_rwlock_unlock((pthread_rwlock_t *)(a1 + 176))) {
LABEL_8:
    }
      panic("%s:%d: unlock == 0 failed %d\n");
  }
  return 0;
}

uint64_t obj_checkpoint_get(pthread_mutex_t *a1, int a2, uint64_t a3, unsigned int *a4, uint64_t a5, int a6, unint64_t a7, uint64_t a8, uint64_t *a9)
{
  unint64_t v56 = a7;
  uint64_t v57 = a5;
  uint64_t v54 = 0;
  if (!a4) {
    return 22;
  }
  if (a4[3] < 0x178) {
    return 22;
  }
  unsigned int v10 = a4[2];
  if (!v10) {
    return 22;
  }
  unsigned int v12 = *(_DWORD *)(*(void *)(*(void *)a1[6].__opaque + 376) + 36);
  if (v10 % v12) {
    return 22;
  }
  __int16 v15 = a2;
  uint64_t v16 = a2 | (*((unsigned __int16 *)a4 + 1) << 16);
  if ((v16 & 0x80000000) == 0) {
    sub_10005F0C4();
  }
  LODWORD(v18) = a6;
  uint64_t v55 = 0;
  pthread_mutex_lock(a1);
  uint64_t v22 = sub_10001FE08((uint64_t)a1, a4[3], *a4, a4[2], v16, 0, &v55, v21);
  if (v22)
  {
    uint64_t v13 = v22;
    goto LABEL_51;
  }
  int v23 = v16;
  unint64_t v24 = (v10 + v12 - 1) / v12;
  uint64_t v25 = v55;
  *(_DWORD *)(v55 + 36) = *a4 | v23 & 0xFFFF0000;
  *(_DWORD *)(v25 + 40) = a4[1];
  *(void *)(v25 + 112) = a3;
  *(void *)(v25 + 120) = a8;
  char v26 = v23;
  *(void *)(v25 + 16) |= v23 & 0xA000FC00 | ((unint64_t)(v15 & 0x200) << 34) | 0x2000000002;
  *(void *)(v25 + 128) = a5;
  obj_retain_0((atomic_ullong *)v25);
  obj_cache_unlock_write((uint64_t)a1);
  if (v24 <= a7)
  {
    unint64_t v41 = obj_read(v25, 0, 0, 0, v27, v28, v29, v30);
    goto LABEL_28;
  }
  uint64_t v31 = *(void *)(v25 + 56);
  int v32 = v24;
  do
  {
    if (v56 >= v32) {
      unint64_t v33 = v32;
    }
    else {
      unint64_t v33 = v56;
    }
    uint64_t v34 = dev_read(*(void *)(*(void *)(*(void *)v25 + 392) + 384), v57);
    if (v34)
    {
      uint64_t v13 = v34;
      goto LABEL_36;
    }
    v32 -= v33;
    if (!v32) {
      goto LABEL_25;
    }
    uint64_t v37 = *(void *)a1[6].__opaque;
    uint64_t v38 = *(void *)(v37 + 376);
    if ((int)v18 + (int)v33 >= (*(_DWORD *)(v38 + 108) & 0x7FFFFFFFu)) {
      unint64_t v18 = 0;
    }
    else {
      unint64_t v18 = (v18 + v33);
    }
    v31 += v33 * *(unsigned int *)(v38 + 36);
    uint64_t v39 = nx_checkpoint_data_block_address(v37, v18, &v57, &v56);
  }
  while (v32 >= 1 && v39 == 0);
  uint64_t v13 = v39;
  if (v39)
  {
LABEL_36:
    pthread_mutex_lock(a1);
    goto LABEL_49;
  }
LABEL_25:
  if ((*(void *)(v25 + 16) & 0x80020000000) != 0)
  {
    pthread_mutex_lock(a1);
    goto LABEL_29;
  }
  unint64_t v41 = obj_checksum_verify(v25, v35, v36);
LABEL_28:
  uint64_t v13 = v41;
  pthread_mutex_lock(a1);
  if (v13)
  {
LABEL_49:
    uint64_t v49 = *(void *)(v25 + 16);
    int v47 = *(_DWORD *)(v25 + 48);
    uint64_t v48 = a1;
    goto LABEL_50;
  }
LABEL_29:
  if ((*(void *)(v25 + 16) & 0x80020000000) == 0)
  {
    uint64_t v50 = *(void *)(v25 + 56);
    if (*(_DWORD *)(v50 + 24) != *(_DWORD *)(v25 + 36)
      || *(_DWORD *)(v50 + 28) != *(_DWORD *)(v25 + 40)
      || *(void *)(v50 + 8) != a3
      || *(void *)(v50 + 16) != a8)
    {
      uint64_t v13 = nx_corruption_detected_int(*(void *)a1[6].__opaque);
      if (v13) {
        goto LABEL_49;
      }
    }
  }
  uint64_t v42 = (uint64_t *)(a1[11].__sig + 8 * (*(void *)(v25 + 112) & *(unsigned int *)&a1[10].__opaque[52]));
  uint64_t v43 = *v42;
  *(void *)(v25 + 72) = *v42;
  if (v43) {
    *(void *)(v43 + 80) = v25 + 72;
  }
  *uint64_t v42 = v25;
  *(void *)(v25 + 80) = v42;
  uint64_t v44 = *(void *)(v25 + 16) | 1;
  *(void *)(v25 + 88) = 0;
  *(void *)(v25 + 16) = v44;
  uint64_t v45 = *(uint64_t **)&a1[11].__opaque[32];
  *(void *)(v25 + 96) = v45;
  *uint64_t v45 = v25;
  *(void *)&a1[11].__opaque[32] = v25 + 88;
  uint64_t v46 = obj_descriptor_funcs_for_type(*(_DWORD *)(v25 + 36), &v54);
  if (v46)
  {
    uint64_t v13 = v46;
    goto LABEL_34;
  }
  uint64_t v51 = *(uint64_t (**)(uint64_t, void))(v54 + 8);
  if (v51 && (uint64_t v52 = v51(v25, 0), v52))
  {
    uint64_t v13 = v52;
    uint64_t v44 = *(void *)(v25 + 16);
LABEL_34:
    int v47 = *(_DWORD *)(v25 + 48);
    uint64_t v48 = a1;
    LODWORD(v49) = v44;
LABEL_50:
    obj_cache_ephemeral_adjust((uint64_t)v48, v49, v47, -1);
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 24), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    sub_100022918(v25, 0);
LABEL_51:
    obj_cache_unlock_write((uint64_t)a1);
  }
  else
  {
    sub_100020868(v25, v26);
    obj_cache_unlock_write((uint64_t)a1);
    uint64_t v13 = 0;
    *a9 = v25;
  }
  return v13;
}

unint64_t obj_checksum_verify(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  uint64_t v4 = *(void *)(*(void *)a1 + 392);
  unint64_t result = fletcher64_verify_cksum(*(void **)(a1 + 56), (uint32x4_t *)(*(void *)(a1 + 56) + 8), (*(_DWORD *)(a1 + 48) - 8), 0, a2, a3);
  if (result)
  {
    log_err((uint64_t)"%s:%d: %s failed: cksum 0x%016llx, oid 0x%llx, o_xid 0x%llx, o_type 0x%x, o_subtype 0x%x, size %d\n", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"obj_checksum_verify");
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(v4 + 376) + 992), 1uLL, memory_order_relaxed);
    if (*(unsigned char *)(v4 + 625))
    {
      uint64_t v13 = *(void (**)(uint64_t))(v4 + 616);
      if (v13) {
        v13(a1);
      }
    }
    return nx_corruption_detected_int(v4);
  }
  return result;
}

uint64_t sub_10002377C(uint64_t result, unsigned char *a2)
{
  uint64_t v2 = *(pthread_mutex_t ***)(result + 136);
  unsigned int v3 = v2[2];
  if (((unint64_t)v3 & 0x10000000000) != 0)
  {
    uint64_t v5 = *v2;
    uint64_t v6 = (pthread_cond_t *)&(*v2)[20].__opaque[8];
    while (((unint64_t)v3 & 0x8000000000) != 0)
    {
      v2[2] = (pthread_mutex_t *)((unint64_t)v3 | 4);
      *a2 = 1;
      unint64_t result = cv_wait_rw(v6, v5, 2, 0);
      unsigned int v3 = v2[2];
      if (((unint64_t)v3 & 0x10000000000) == 0) {
        return result;
      }
    }
    v2[2] = (pthread_mutex_t *)((unint64_t)v3 | 0x8000000000);
    obj_cache_unlock_write((uint64_t)v5);
    *a2 = 0;
    uint64_t v7 = *(void *)(*(void *)(*v2)[6].__opaque + 384);
    return dev_read_finish(v7);
  }
  return result;
}

uint64_t obj_async_wait(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  char v7 = 0;
  pthread_mutex_lock((pthread_mutex_t *)v2);
  uint64_t v3 = *(void *)(v2 + 1344);
  if (v3)
  {
    while (1)
    {
      while (*(void *)(v3 + 136) != a1)
      {
        uint64_t v3 = *(void *)(v3 + 104);
        if (!v3) {
          goto LABEL_7;
        }
      }
      uint64_t v4 = *(void *)(a1 + 16);
      if ((v4 & 0x8000000000) == 0) {
        break;
      }
      *(void *)(a1 + 16) = v4 | 4;
      cv_wait_rw((pthread_cond_t *)(v2 + 1296), (pthread_mutex_t *)v2, 2, 0);
      uint64_t v3 = *(void *)(v2 + 1344);
      if (!v3) {
        goto LABEL_7;
      }
    }
    sub_10002377C(v3, &v7);
    if (v7) {
      obj_cache_unlock_write(v2);
    }
    return *(unsigned int *)(a1 + 52);
  }
  else
  {
LABEL_7:
    if (*(unsigned char *)(a1 + 21)) {
      uint64_t v5 = 2;
    }
    else {
      uint64_t v5 = *(unsigned int *)(a1 + 52);
    }
    obj_cache_unlock_write(v2);
  }
  return v5;
}

atomic_ullong *obj_retain_ephemeral_no_ref(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  if ((v1 & 0x80000000) == 0) {
    panic("obj %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x refs 0x%llx is not ephemeral\n", (const void *)a1, *(void *)(a1 + 112), v1, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 40), *(void *)(a1 + 24));
  }

  return obj_retain_0((atomic_ullong *)a1);
}

uint64_t sub_100023980(uint64_t result, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 19) & 0x80) != 0
    || (atomic_fetch_or_explicit((atomic_uint *volatile)(a2 + 32), 0, memory_order_relaxed) & 1) != 0)
  {
    sub_10005F0F0();
  }
  if ((atomic_fetch_or_explicit((atomic_uint *volatile)(a2 + 32), 0x10u, memory_order_relaxed) & 0x10) == 0)
  {
    uint64_t v3 = result;
    unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(result + 880), 1u, memory_order_relaxed);
    if (add_explicit >= 0x100)
    {
      do
      {
        atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 880), 0xFFFFFFFF, memory_order_relaxed);
        int v5 = pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 128));
        if (v5) {
          panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 483, v5);
        }
        int v6 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v3 + 128));
        if (v6) {
          panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 484, v6);
        }
        sub_1000247A0(v3);
        int v7 = pthread_rwlock_unlock((pthread_rwlock_t *)(v3 + 128));
        if (v7) {
          panic("%s:%d: unlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 490, v7);
        }
        unint64_t result = pthread_rwlock_rdlock((pthread_rwlock_t *)(v3 + 128));
        if (result) {
          panic("%s:%d: rdlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 493, result);
        }
        unsigned int add_explicit = atomic_fetch_add_explicit((atomic_uint *volatile)(v3 + 880), 1u, memory_order_relaxed);
      }
      while (add_explicit > 0xFF);
    }
    *(void *)(*(void *)(v3 + 872) + 8 * add_explicit) = a2;
    atomic_fetch_or_explicit((atomic_uint *volatile)(a2 + 32), add_explicit << 24, memory_order_relaxed);
  }
  return result;
}

uint64_t obj_ephemeral_set_persistent(uint64_t a1, int a2)
{
  if ((*(unsigned char *)(a1 + 19) & 0x80) == 0) {
    return 22;
  }
  int v5 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  uint64_t v6 = *(void *)(a1 + 16);
  if ((a2 != 0) != ((v6 & 0x8000000) == 0))
  {
    obj_cache_ephemeral_adjust((uint64_t)v5, v6, *(_DWORD *)(a1 + 48), -1);
    uint64_t v8 = *(void *)(a1 + 88);
    uint64_t v9 = *(void **)(a1 + 96);
    uint64_t v7 = a1 + 88;
    if (a2)
    {
      if (v8)
      {
        *(void *)(v8 + 96) = v9;
        uint64_t v9 = *(void **)(a1 + 96);
      }
      else
      {
        *(void *)&v5[11].__opaque[48] = v9;
      }
      *uint64_t v9 = v8;
      uint64_t v10 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v10 & 0xFFFFFFFFF7FFFFFFLL;
      *(_DWORD *)(a1 + 36) &= ~0x8000000u;
      if ((v10 & 0x80020000000) == 0) {
        *(_DWORD *)(*(void *)(a1 + 56) + 24) &= ~0x8000000u;
      }
      uint64_t v11 = *(void **)&v5[11].__opaque[32];
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 96) = v11;
      *uint64_t v11 = a1;
      *(void *)&v5[11].__opaque[32] = v7;
      unint64_t v12 = *(unsigned int *)(a1 + 48);
      atomic_fetch_add_explicit((atomic_ullong *volatile)v5[19].__opaque, -(uint64_t)v12, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)&v5[19].__opaque[16], v12, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)&v5[19].__opaque[32], 1uLL, memory_order_relaxed);
      uint64_t v13 = (atomic_ullong *)qword_100084A18;
      unint64_t v14 = *(unsigned int *)(a1 + 48);
      atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_100084A18 + 416), -(uint64_t)v14, memory_order_relaxed);
      atomic_fetch_add_explicit(v13 + 54, v14, memory_order_relaxed);
      atomic_fetch_add_explicit(v13 + 56, 1uLL, memory_order_relaxed);
      if (*(void *)(a1 + 56))
      {
        unint64_t v15 = *(unsigned int *)(a1 + 48);
        atomic_fetch_add_explicit((atomic_ullong *volatile)&v5[18].__opaque[16], v15, memory_order_relaxed);
        atomic_fetch_add_explicit((atomic_ullong *volatile)&v5[18].__opaque[24], v15, memory_order_relaxed);
        p_uint64_t sig = (atomic_ullong *)&v5[18].__opaque[40];
      }
      else
      {
        p_uint64_t sig = &v5[19].__sig;
      }
      atomic_fetch_add_explicit(p_sig, 1uLL, memory_order_relaxed);
      if (*(void *)(a1 + 56))
      {
        unint64_t v17 = *(unsigned int *)(a1 + 48);
        atomic_fetch_add_explicit(v13 + 46, v17, memory_order_relaxed);
        atomic_fetch_add_explicit(v13 + 47, v17, memory_order_relaxed);
        unint64_t v18 = v13 + 49;
      }
      else
      {
        unint64_t v18 = v13 + 51;
      }
    }
    else
    {
      if (v8)
      {
        *(void *)(v8 + 96) = v9;
        uint64_t v9 = *(void **)(a1 + 96);
      }
      else
      {
        *(void *)&v5[11].__opaque[32] = v9;
      }
      *uint64_t v9 = v8;
      uint64_t v19 = *(void *)(a1 + 16);
      *(void *)(a1 + 16) = v19 | 0x8000000;
      *(_DWORD *)(a1 + 36) |= 0x8000000u;
      if ((v19 & 0x80020000000) == 0) {
        *(_DWORD *)(*(void *)(a1 + 56) + 24) |= 0x8000000u;
      }
      int8x16_t v20 = *(void **)&v5[11].__opaque[48];
      *(void *)(a1 + 88) = 0;
      *(void *)(a1 + 96) = v20;
      *int8x16_t v20 = a1;
      *(void *)&v5[11].__opaque[48] = v7;
      unint64_t v21 = *(unsigned int *)(a1 + 48);
      atomic_fetch_add_explicit((atomic_ullong *volatile)&v5[18].__opaque[16], -(uint64_t)v21, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)&v5[18].__opaque[32], v21, memory_order_relaxed);
      atomic_fetch_add_explicit((atomic_ullong *volatile)&v5[18].__opaque[48], 1uLL, memory_order_relaxed);
      uint64_t v22 = (atomic_ullong *)qword_100084A18;
      unint64_t v23 = *(unsigned int *)(a1 + 48);
      atomic_fetch_add_explicit((atomic_ullong *volatile)(qword_100084A18 + 368), -(uint64_t)v23, memory_order_relaxed);
      atomic_fetch_add_explicit(v22 + 48, v23, memory_order_relaxed);
      atomic_fetch_add_explicit(v22 + 50, 1uLL, memory_order_relaxed);
      if (*(void *)(a1 + 56))
      {
        unint64_t v24 = *(unsigned int *)(a1 + 48);
        atomic_fetch_add_explicit((atomic_ullong *volatile)v5[19].__opaque, v24, memory_order_relaxed);
        atomic_fetch_add_explicit((atomic_ullong *volatile)&v5[19].__opaque[8], v24, memory_order_relaxed);
        uint64_t v25 = (atomic_ullong *)&v5[19].__opaque[24];
      }
      else
      {
        uint64_t v25 = (atomic_ullong *)&v5[19].__opaque[40];
      }
      atomic_fetch_add_explicit(v25, 1uLL, memory_order_relaxed);
      if (*(void *)(a1 + 56))
      {
        unint64_t v26 = *(unsigned int *)(a1 + 48);
        atomic_fetch_add_explicit(v22 + 52, v26, memory_order_relaxed);
        atomic_fetch_add_explicit(v22 + 53, v26, memory_order_relaxed);
        unint64_t v18 = v22 + 55;
      }
      else
      {
        unint64_t v18 = v22 + 57;
      }
    }
    atomic_fetch_add_explicit(v18, 1uLL, memory_order_relaxed);
    obj_cache_ephemeral_adjust((uint64_t)v5, *(void *)(a1 + 16), *(_DWORD *)(a1 + 48), 1);
  }
  obj_cache_unlock_write((uint64_t)v5);
  return 0;
}

uint64_t obj_set_skip_checkpoint_traverse(uint64_t a1, int a2)
{
  BOOL v3 = a2 != 0;
  uint64_t v4 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  *(void *)(a1 + 16) = *(void *)(a1 + 16) & 0xFFFFFFBFFFFFFFFFLL | ((unint64_t)v3 << 38);
  obj_cache_unlock_write((uint64_t)v4);
  return 0;
}

uint64_t *sub_100023DDC(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t)result;
  uint64_t v6 = *result;
  uint64_t v7 = result[2];
  if ((v7 & 0x10) != 0) {
    panic("deleted object @ %p can not be dirtied!! (flags: 0x%llx)\n", result, v7);
  }
  if ((v7 & 0x80000000000) != 0) {
    panic("ciphertext object @ %p can not be dirtied!! (flags: 0x%llx)\n", result, v7);
  }
  if ((v7 & 0x8000000) == 0)
  {
    unint64_t result = (uint64_t *)xid_is_current_tx(*(void *)(v6 + 392), a2);
    if (!result) {
      panic("oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x bad dirty xid: 0x%llx\n", *(void *)(v5 + 112), *(void *)(v5 + 16), *(_DWORD *)(v5 + 32), *(_DWORD *)(v5 + 36), *(_DWORD *)(v5 + 40), a2);
    }
  }
  uint64_t v8 = *(void *)(v5 + 64);
  if (v8 && v8 == *(void *)(v5 + 56)) {
    panic("oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x object not prepared before dirtying\n", *(void *)(v5 + 112), *(void *)(v5 + 16), *(_DWORD *)(v5 + 32), *(_DWORD *)(v5 + 36), *(_DWORD *)(v5 + 40));
  }
  uint64_t v9 = *(void *)(v5 + 16);
  if ((v9 & 0x80000000) != 0)
  {
    *(void *)(v5 + 144) = a2;
  }
  else if (atomic_fetch_or_explicit((atomic_uint *volatile)(v5 + 32), 1u, memory_order_relaxed))
  {
    if (a3 && *(void *)(v5 + 152) != a3) {
      panic("new address mismatch on redirty 0x%llx 0x%llx\n");
    }
  }
  else
  {
    unsigned int v10 = *(_DWORD *)(v5 + 36);
    if ((v9 & 0xC00000000) == 0 && !(v10 >> 30))
    {
      uint64_t v11 = *(void *)(v5 + 120);
      if (v11 != a2 && *(void *)(v5 + 144) != a2) {
        panic("virtual object not prepared before dirtying: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx\n", *(void *)(v5 + 112), v9, *(_DWORD *)(v5 + 32), v10, *(_DWORD *)(v5 + 40), v11, *(void *)(v5 + 144), a2);
      }
    }
    *(void *)(v5 + 168) = 0;
    if (v10 >> 30 == 1)
    {
      uint64_t v12 = *(void *)(v5 + 16);
      if ((v12 & 0x40) == 0)
      {
        uint64_t v13 = *(void *)(v5 + 120);
        if (v13 != a2)
        {
          uint64_t v14 = *(void *)(v5 + 144);
          if (v13 != v14 && !(*(void *)(v5 + 152) | a3)) {
            panic("physical object not prepared before dirtying: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx naddr 0x%llx 0x%llx\n", *(void *)(v5 + 112), v12, *(_DWORD *)(v5 + 32), v10, *(_DWORD *)(v5 + 40), v13, v14, a2, 0, 0);
          }
        }
      }
    }
    uint64_t v15 = *(void *)(v5 + 152);
    if (v15)
    {
      if (v15 != a3)
      {
        if (a3)
        {
          int v16 = *(_DWORD *)(v5 + 36);
          if ((v16 & 0xC0000000) == 0x40000000) {
            panic("physical object new address mismatch: oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x xid 0x%llx 0x%llx 0x%llx naddr 0x%llx 0x%llx\n", *(void *)(v5 + 112), *(void *)(v5 + 16), *(_DWORD *)(v5 + 32), v16, *(_DWORD *)(v5 + 40), *(void *)(v5 + 120), *(void *)(v5 + 144), a2, *(void *)(v5 + 152), a3);
          }
        }
      }
    }
    else
    {
      *(void *)(v5 + 152) = a3;
      if (a3 && (*(void *)(v5 + 16) & 0x40000000) != 0 && *(void *)(v5 + 112) != a3)
      {
        uint64_t v17 = *(void *)(v5 + 72);
        if (v17) {
          *(void *)(v17 + 80) = *(void *)(v5 + 80);
        }
        **(void **)(v5 + 80) = v17;
        *(void *)(v5 + 112) = a3;
        unint64_t v18 = (uint64_t *)(*(void *)(v6 + 704) + 8 * (*(_DWORD *)(v6 + 700) & a3));
        uint64_t v19 = *v18;
        *(void *)(v5 + 72) = *v18;
        if (v19) {
          *(void *)(v19 + 80) = v5 + 72;
        }
        *unint64_t v18 = v5;
        *(void *)(v5 + 80) = v18;
      }
    }
    *(void *)(v5 + 144) = a2;
    int v20 = pthread_rwlock_wrlock((pthread_rwlock_t *)(v6 + 128));
    if (v20) {
      panic("%s:%d: wrlock == 0 failed %d\n", "/Library/Caches/com.apple.xbs/Sources/apfs_userfs/nx/obj.c", 5760, v20);
    }
    uint64_t v21 = v5 + 88;
    if (*(void *)(v5 + 88) != 3735928559) {
      sub_1000248FC((uint64_t *)v5);
    }
    sub_100024E54(v6, v5);
    if (*(void *)(v5 + 88) != 3735928559) {
      panic("obj %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x dirty object on the free list?!\n", (const void *)v5, *(void *)(v5 + 112), *(void *)(v5 + 16), *(_DWORD *)(v5 + 32), *(_DWORD *)(v5 + 36), *(_DWORD *)(v5 + 40));
    }
    uint64_t v22 = *(void *)(v5 + 16);
    *(void *)(v5 + 88) = 0;
    if ((v22 & 0x40000000) != 0)
    {
      unint64_t v24 = *(uint64_t **)(v6 + 824);
      *(void *)(v5 + 96) = v24;
      *unint64_t v24 = v5;
      *(void *)(v6 + 824) = v21;
      ++*(_DWORD *)(v6 + 888);
    }
    else
    {
      unint64_t v23 = *(uint64_t **)(v6 + 808);
      *(void *)(v5 + 96) = v23;
      *unint64_t v23 = v5;
      *(void *)(v6 + 808) = v21;
      ++*(_DWORD *)(v6 + 884);
    }
    unint64_t result = (uint64_t *)pthread_rwlock_unlock((pthread_rwlock_t *)(v6 + 128));
    if (result) {
      panic("%s:%d: unlock == 0 failed %d\n");
    }
  }
  return result;
}

void obj_dirty(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(a1 + 19) & 0x80) != 0)
  {
    *(void *)(a1 + 144) = a2;
  }
  else
  {
    uint64_t v5 = *(pthread_mutex_t **)a1;
    if ((atomic_fetch_or_explicit((atomic_uint *volatile)(a1 + 32), 0, memory_order_relaxed) & 1) == 0)
    {
      pthread_mutex_lock(v5);
      sub_100023DDC((uint64_t *)a1, a2, a3);
      obj_cache_unlock_write((uint64_t)v5);
    }
  }
}

uint64_t obj_exchange_phys(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(pthread_mutex_t **)a1;
  pthread_mutex_lock(*(pthread_mutex_t **)a1);
  uint64_t v5 = *(void *)(a1 + 16);
  if ((v5 & 0x20000000000) != 0)
  {
    do
    {
      *(void *)(a1 + 16) = v5 | 0x80;
      uint64_t v7 = cv_wait_rw((pthread_cond_t *)&v4[20].__opaque[8], v4, 2, 0);
      uint64_t v5 = *(void *)(a1 + 16);
    }
    while ((v5 & 0x20000000000) != 0);
    uint64_t v6 = v7;
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v8 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = *(void *)(a2 + 56);
  *(void *)(a2 + 56) = v8;
  obj_cache_unlock_write((uint64_t)v4);
  return v6;
}

uint64_t obj_checkpoint_start(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 19) & 0x80) != 0) {
    return (4 * atomic_fetch_or_explicit((atomic_uint *volatile)(a1 + 32), 4u, memory_order_relaxed)) & 0x10;
  }
  else {
    return nx_corruption_detected_int(*(void *)(*(void *)a1 + 392));
  }
}

uint64_t obj_checkpoint_done(uint64_t a1)
{
  if ((*(unsigned char *)(a1 + 19) & 0x80) == 0) {
    return nx_corruption_detected_int(*(void *)(*(void *)a1 + 392));
  }
  if ((atomic_fetch_and_explicit((atomic_uint *volatile)(a1 + 32), 0xFFFFFFFB, memory_order_relaxed) & 4) != 0) {
    return 0;
  }
  return 22;
}

uint64_t obj_checkpoint_known(uint64_t a1)
{
  uint64_t v1 = *(pthread_mutex_t **)a1;
  if ((*(unsigned char *)(a1 + 19) & 0x80) != 0)
  {
    pthread_mutex_lock(*(pthread_mutex_t **)a1);
    uint64_t v5 = *(void *)(a1 + 16);
    if ((v5 & 0x2000000000) != 0)
    {
      *(void *)(a1 + 16) = v5 & 0xFFFFFFDFFFFFFFFFLL;
      obj_cache_unlock_write((uint64_t)v1);
      return 0;
    }
    else
    {
      obj_cache_unlock_write((uint64_t)v1);
      return 22;
    }
  }
  else
  {
    uint64_t v2 = *(void *)v1[6].__opaque;
    return nx_corruption_detected_int(v2);
  }
}

uint64_t obj_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4 = *(unsigned __int16 *)(a3 + 36);
  if (v4 > 0xA)
  {
    if (v4 == 11)
    {
      return omap_checkpoint_traverse(a1, a2, a3, a4);
    }
    else
    {
      if (v4 != 13) {
        return 22;
      }
      if (*(_WORD *)(a1 + 36) != 1) {
        sub_10005F11C();
      }
      return apfs_checkpoint_traverse(a1, a2, a3, a4);
    }
  }
  else
  {
    if (v4 != 2)
    {
      if (v4 == 3)
      {
        return btree_node_checkpoint_traverse(a1, a2, 0, a3, a4);
      }
      return 22;
    }
    return btree_checkpoint_traverse(a1, a2, a3, a4);
  }
}

void obj_checkpoint_check_for_unknown(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)a1);
  for (uint64_t i = *(void *)(a1 + 736); i; uint64_t i = *(void *)(i + 88))
  {
    if ((*(unsigned char *)(i + 20) & 0x20) != 0) {
      log_warn((uint64_t)"%s:%d: %s Unknown object loaded from checkpoint: oid 0x%llx type 0x%x/0x%x\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"obj_checkpoint_check_for_unknown");
    }
  }

  obj_cache_unlock_write(a1);
}

unint64_t obj_checksum_set(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  return obj_checksum_set_phys(*(void *)(*(void *)a1 + 392), *(unint64_t **)(a1 + 56), *(_DWORD *)(a1 + 48), a2, a3);
}

unint64_t obj_checksum_set_phys(uint64_t a1, unint64_t *a2, int a3, int8x16_t a4, int8x16_t a5)
{
  if (!a1) {
    sub_10005F148();
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(a1 + 376) + 984), 1uLL, memory_order_relaxed);
  unint64_t v5 = (a3 - 8);
  uint64_t v7 = (uint32x4_t *)(a2 + 1);

  return fletcher64_set_cksum(a2, v7, v5, 0, a4, a5);
}

uint64_t obj_mem_mgr_register(int64x2_t *a1, int a2)
{
  if (!qword_100084A18) {
    sub_10005F174();
  }
  pthread_mutex_lock((pthread_mutex_t *)(qword_100084A18 + 8));
  uint64_t v4 = a1[80].i64[1];
  a1[80].i64[1] = v4 | 1;
  if (a2)
  {
    a1[80].i64[1] = v4 | 3;
    uint64_t v5 = qword_100084A18;
    uint64_t v6 = (int64x2_t **)(qword_100084A18 + 80);
    uint64_t v7 = *(void *)(qword_100084A18 + 80);
    a1[58].i64[0] = v7;
    if (v7) {
      *(void *)(v7 + 936) = a1 + 58;
    }
    *uint64_t v6 = a1;
    a1[58].i64[1] = (uint64_t)v6;
  }
  else
  {
    uint64_t v5 = qword_100084A18;
    uint64_t v8 = qword_100084A18 + 72;
    uint64_t v9 = *(void *)(qword_100084A18 + 72);
    a1[58].i64[0] = v9;
    if (v9) {
      *(void *)(v9 + 936) = a1 + 58;
    }
    *(void *)(v5 + 72) = a1;
    a1[58].i64[1] = v8;
    ++*(void *)(v5 + 104);
    *(int64x2_t *)(v5 + 136) = vaddq_s64(*(int64x2_t *)(v5 + 136), a1[59]);
    *(void *)(v5 + 152) += a1[60].i64[0];
  }

  return pthread_mutex_unlock((pthread_mutex_t *)(v5 + 8));
}

void sub_100024688(uint64_t a1, const char *a2)
{
  long long v18 = 0u;
  long long v19 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  *(_OWORD *)uint64_t v12 = 0u;
  long long v13 = 0u;
  int v4 = backtrace(v12, 16);
  uint64_t v5 = backtrace_symbols(v12, v4);
  fprintf(__stderrp, "Allocated %s object with OID %lld flags %llx type %x %d from\n", a2, *(void *)(a1 + 112), *(void *)(a1 + 16), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 40));
  if (v4 >= 1)
  {
    uint64_t v6 = v4;
    uint64_t v7 = v12;
    uint64_t v8 = (const char **)v5;
    do
    {
      unsigned int v10 = *v7++;
      uint64_t v9 = v10;
      uint64_t v11 = *v8++;
      fprintf(__stderrp, "\t%16p %s\n", v9, v11);
      --v6;
    }
    while (v6);
  }
  free(v5);
}

uint64_t *sub_1000247A0(uint64_t a1)
{
  v18.int tv_sec = 0;
  v18.int tv_nsec = 0;
  unint64_t result = (uint64_t *)clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v18);
  unint64_t v3 = *(unsigned int *)(a1 + 880);
  if (v3)
  {
    unint64_t v4 = 0;
    int tv_sec = v18.tv_sec;
    do
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 872) + 8 * v4);
      if (v6)
      {
        unsigned int v7 = atomic_fetch_or_explicit((atomic_uint *volatile)(v6 + 32), 0, memory_order_relaxed);
        if ((v7 & 0x10) == 0) {
          sub_10005F1A0();
        }
        if (v4 != HIBYTE(v7)) {
          sub_10005F1F8();
        }
        uint64_t v8 = *(void *)(v6 + 16);
        if ((v8 & 0x80000000) != 0) {
          sub_10005F1CC();
        }
        unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 24), 0, memory_order_relaxed);
        unint64_t v10 = add_explicit & 0xFFFFFF;
        unint64_t v11 = (add_explicit >> 24) & 0xFFFFF;
        unint64_t v12 = -(add_explicit >> 44) & 0xFFFFF;
        uint64_t v13 = v6 + 88;
        uint64_t v14 = *(void *)(v6 + 88);
        if (v10 <= v11 && v12 == 0)
        {
          if (v14 == 3735928559 && *(_WORD *)(v6 + 36) != 13)
          {
            *(_DWORD *)(v6 + 160) = tv_sec;
            *(void *)(v6 + 88) = 0;
            if ((v8 & 0x40000000) != 0)
            {
              long long v17 = *(void **)(a1 + 792);
              *(void *)(v6 + 96) = v17;
              *long long v17 = v6;
              *(void *)(a1 + 792) = v13;
              ++*(_DWORD *)(a1 + 896);
            }
            else
            {
              long long v16 = *(void **)(a1 + 776);
              *(void *)(v6 + 96) = v16;
              *long long v16 = v6;
              *(void *)(a1 + 776) = v13;
              ++*(_DWORD *)(a1 + 892);
            }
          }
        }
        else if (v14 != 3735928559)
        {
          unint64_t result = sub_1000248FC((uint64_t *)v6);
        }
        atomic_fetch_and_explicit((atomic_uint *volatile)(v6 + 32), 0xFFFFEFu, memory_order_release);
        unint64_t v3 = *(unsigned int *)(a1 + 880);
      }
      ++v4;
    }
    while (v4 < v3);
  }
  *(_DWORD *)(a1 + 880) = 0;
  return result;
}

uint64_t *sub_1000248FC(uint64_t *result)
{
  uint64_t v1 = result[11];
  if (v1 != 3735928559)
  {
    uint64_t v2 = *result;
    if ((*((unsigned char *)result + 19) & 0x40) != 0)
    {
      int v5 = *(_DWORD *)(v2 + 896);
      if (!v5) {
        sub_10005F250();
      }
      uint64_t v6 = (void *)result[12];
      if (v1)
      {
        *(void *)(v1 + 96) = v6;
        uint64_t v6 = (void *)result[12];
      }
      else
      {
        *(void *)(v2 + 792) = v6;
      }
      *uint64_t v6 = v1;
      *(_DWORD *)(v2 + 896) = v5 - 1;
    }
    else
    {
      int v3 = *(_DWORD *)(v2 + 892);
      if (!v3) {
        sub_10005F224();
      }
      unint64_t v4 = (void *)result[12];
      if (v1)
      {
        *(void *)(v1 + 96) = v4;
        unint64_t v4 = (void *)result[12];
      }
      else
      {
        *(void *)(v2 + 776) = v4;
      }
      *unint64_t v4 = v1;
      *(_DWORD *)(v2 + 892) = v3 - 1;
    }
    result[11] = 3735928559;
  }
  return result;
}

void sub_100024998(void *a1, __int16 a2, int a3)
{
  if (a3 == 376)
  {
LABEL_2:
    uint64_t v3 = 376;
LABEL_3:
    _apfs_free(a1, v3);
  }
  else
  {
    switch(a2)
    {
      case 1:
        uint64_t v3 = 1928;
        goto LABEL_3;
      case 2:
      case 3:
      case 6:
      case 7:
      case 8:
        _apfs_zfree(a1, 4u);
        break;
      case 5:
        uint64_t v3 = 1608;
        goto LABEL_3;
      case 11:
        uint64_t v3 = 496;
        goto LABEL_3;
      case 13:
        uint64_t v3 = 4032;
        goto LABEL_3;
      case 17:
      case 30:
        uint64_t v3 = 400;
        goto LABEL_3;
      case 18:
        uint64_t v3 = 384;
        goto LABEL_3;
      case 25:
        uint64_t v3 = 416;
        goto LABEL_3;
      case 27:
      case 29:
        uint64_t v3 = 392;
        goto LABEL_3;
      default:
        goto LABEL_2;
    }
  }
}

uint64_t sub_100024A98(uint64_t a1)
{
  uint64_t result = 0;
  uint64_t v3 = 0;
  if ((*(unsigned char *)(a1 + 16) & 2) == 0)
  {
    if (obj_descriptor_funcs_for_type(*(_DWORD *)(a1 + 36), &v3)) {
      return 0;
    }
    else {
      return *(void *)(v3 + 16);
    }
  }
  return result;
}

void sub_100024AE8(void *a1, char a2)
{
  if ((a2 & 1) == 0)
  {
    uint64_t v3 = (unsigned int (*)(void *))sub_100024A98((uint64_t)a1);
    if (v3)
    {
      if (v3(a1)) {
        log_err((uint64_t)"%s:%d: %s oid 0x%llx flags 0x%llx type 0x%x/0x%x error destroying: %d\n", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"obj_destroy_complete");
      }
    }
  }
  if (a1[11] != 3735928559) {
    panic("object to be freed is on a list, o %p oid 0x%llx flags 0x%llx 0x%x type 0x%x/0x%x refs 0x%llx list %p/%p\n", a1, a1[14], a1[2], *((_DWORD *)a1 + 8), *((_DWORD *)a1 + 9), *((_DWORD *)a1 + 10), a1[3], (const void *)a1[11], (const void *)a1[12]);
  }
  free_rwlock((pthread_rwlock_t *)(a1 + 22));
  fs_obj_zfree_oc((void *)a1[7], *((unsigned int *)a1 + 12), a1[2], *a1);
  int v11 = *((_DWORD *)a1 + 9);
  int v12 = *((_DWORD *)a1 + 11);

  sub_100024998(a1, v11, v12);
}

void sub_100024C04(uint64_t a1, int8x16_t a2, int8x16_t a3)
{
  int v21 = 16000;
  int v4 = *(_DWORD *)(a1 + 120);
  uint64_t v5 = *(pthread_cond_t ***)(a1 + 136);
  if (v4) {
    uint64_t v6 = (_DWORD *)(a1 + 120);
  }
  else {
    uint64_t v6 = 0;
  }
  if (*(unsigned char *)(a1 + 148)) {
    uint64_t v7 = *(void *)(a1 + 152);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = (pthread_mutex_t *)*v5;
  int v9 = *(_DWORD *)(a1 + 96);
  uint64_t v10 = *(unsigned int *)(a1 + 144);
  uint64_t v11 = v10 & 0xFFFF0000;
  if (v4)
  {
    uint64_t v11 = v4 | v11;
    uint64_t v12 = *(unsigned int *)(a1 + 124);
    if (v9)
    {
LABEL_9:
      pthread_mutex_lock((pthread_mutex_t *)*v5);
      *((_DWORD *)v5 + 13) = v9;
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v12 = 0;
    if (v9) {
      goto LABEL_9;
    }
  }
  if (((unint64_t)v5[2] & 0x80020000000) != 0)
  {
    pthread_mutex_lock((pthread_mutex_t *)*v5);
    *((_DWORD *)v5 + 13) = 0;
    uint64_t v14 = (_DWORD *)v5 + 13;
  }
  else
  {
    int v19 = obj_checksum_verify(*(void *)(a1 + 136), a2, a3);
    pthread_mutex_lock(v8);
    *((_DWORD *)v5 + 13) = v19;
    uint64_t v14 = (_DWORD *)v5 + 13;
    if (v19)
    {
LABEL_10:
      unint64_t v13 = (unint64_t)v5[2];
      v5[2] = (pthread_cond_t *)(v13 & 0xFFFFFE7FFFFFFFFBLL);
      if ((v13 & 4) != 0) {
        cv_wakeup(*v5 + 27);
      }
LABEL_18:
      v5[2] = (pthread_cond_t *)((unint64_t)v5[2] & 0xFFFFFFEFFFFFFFF7 | 8);
      goto LABEL_19;
    }
  }
  if (sub_100022450(v5, v10, (uint64_t)v5[14], v6, v7, (unint64_t)v5[15], v11, v12)) {
    goto LABEL_18;
  }
  char v20 = 2;
  int v15 = sub_100022670((uint64_t)v5, v10, (uint64_t)v5[14], (unint64_t)v5[15], v11, v12, 0, &v21, &v20);
  if (v15 == 35) {
    sub_10005F27C();
  }
  *uint64_t v14 = v15;
  if (v15) {
    goto LABEL_18;
  }
LABEL_19:
  uint64_t v16 = *(void *)(a1 + 104);
  long long v17 = *(void **)(a1 + 112);
  if (v16)
  {
    *(void *)(v16 + 112) = v17;
    long long v17 = *(void **)(a1 + 112);
  }
  else
  {
    *(void *)v8[21].__opaque = v17;
  }
  *long long v17 = v16;
  obj_cache_unlock_write((uint64_t)v8);
  obj_release((uint64_t *)v5);
  if (*(unsigned char *)(a1 + 148))
  {
    unint64_t v18 = *(unsigned __int16 *)(v7 + 2);
    if (v18 <= 3) {
      sub_10005F2A8();
    }
    _apfs_free(*(void **)(a1 + 152), v18);
  }
  _apfs_free((void *)a1, 160);
  if (atomic_fetch_add_explicit((atomic_uint *volatile)&v8[14].__opaque[12], 0xFFFFFFFF, memory_order_relaxed) == 1
    && atomic_fetch_add_explicit((atomic_uint *volatile)&v8[14].__opaque[8], 0, memory_order_relaxed))
  {
    pthread_mutex_lock(v8);
    cv_wakeup((pthread_cond_t *)&v8[20].__opaque[8]);
    obj_cache_unlock_write((uint64_t)v8);
  }
}

uint64_t sub_100024E54(uint64_t result, uint64_t a2)
{
  unsigned int v2 = atomic_fetch_and_explicit((atomic_uint *volatile)(a2 + 32), 0xFFFFEFu, memory_order_relaxed);
  if ((v2 & 0x10) != 0)
  {
    uint64_t v3 = *(void *)(result + 872);
    uint64_t v4 = HIBYTE(v2);
    if (*(void *)(v3 + 8 * v4) != a2) {
      sub_10005F2D4();
    }
    *(void *)(v3 + 8 * v4) = 0;
  }
  return result;
}

atomic_ullong *sub_100024E98(atomic_ullong *result, int a2, uint64_t a3, unint64_t a4)
{
  unsigned int v5 = a2 & 0xC8000000;
  if (a2 < 0 != v4)
  {
    if (v5 == 0x80000000)
    {
      if (a3)
      {
        atomic_fetch_add_explicit(result + 29, a4, memory_order_relaxed);
        atomic_fetch_add_explicit(result + 30, a4, memory_order_relaxed);
        uint64_t v6 = result + 32;
      }
      else
      {
        uint64_t v6 = result + 34;
      }
    }
    else
    {
      if (v5 != -2013265920) {
        goto LABEL_16;
      }
      if (a3)
      {
        atomic_fetch_add_explicit(result + 35, a4, memory_order_relaxed);
        atomic_fetch_add_explicit(result + 36, a4, memory_order_relaxed);
        uint64_t v6 = result + 38;
      }
      else
      {
        uint64_t v6 = result + 40;
      }
    }
  }
  else
  {
    if (v5 != 0x40000000 && v5 != 0) {
LABEL_16:
    }
      panic("unexpected storagetype: 0x%x\n", a2 & 0xC8000000);
    if (a3)
    {
      atomic_fetch_add_explicit(result + 23, a4, memory_order_relaxed);
      atomic_fetch_add_explicit(result + 24, a4, memory_order_relaxed);
      uint64_t v6 = result + 26;
    }
    else
    {
      uint64_t v6 = result + 28;
    }
  }
  atomic_fetch_add_explicit(v6, 1uLL, memory_order_relaxed);
  return result;
}

uint64_t fext_tree_key_cmp(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 16 && a5 == 16)
  {
    if (*a2 >= *a4)
    {
      if (*a2 > *a4)
      {
        int v7 = 1;
      }
      else
      {
        unint64_t v8 = a2[1];
        unint64_t v9 = a4[1];
        BOOL v10 = v8 >= v9;
        int v7 = v8 > v9;
        if (!v10) {
          int v7 = -1;
        }
      }
    }
    else
    {
      int v7 = -1;
    }
    uint64_t result = 0;
    *a6 = v7;
  }
  return result;
}

uint64_t fext_tree_insert_with_tree(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (obj_subtype((uint64_t)a1) != 31) {
    sub_10005F300();
  }
  uint64_t v8 = *(unsigned char *)(a4 + 48) & 0xFE;
  long long v12 = *(_OWORD *)(a4 + 8);
  uint64_t v9 = *(void *)(a4 + 24);
  v11[0] = *(void *)(a4 + 40) | (v8 << 56);
  v11[1] = v9;
  return bt_insert(a1, a3, (unint64_t *)&v12, 16, v11, 0x10u, a2);
}

uint64_t fext_tree_insert(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v8 = 0;
  uint64_t tree = jfs_get_tree(a1, 5, a2, &v8);
  if (!tree)
  {
    uint64_t tree = fext_tree_insert_with_tree(v8, a2, *(void *)(a1 + 432), a3);
    obj_release(v8);
  }
  return tree;
}

uint64_t fext_tree_remove(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v8 = 0;
  v9[0] = a3;
  v9[1] = a4;
  uint64_t tree = jfs_get_tree(a1, 5, a2, &v8);
  if (!tree)
  {
    uint64_t tree = bt_remove(v8, *(void *)(a1 + 432), v9, 0x10u, a2);
    obj_release(v8);
  }
  return tree;
}

uint64_t fext_tree_iterate_fexts_with_flags(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, _OWORD *a6, int a7, uint64_t (*a8)(long long *, uint64_t), uint64_t a9)
{
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  uint64_t v25 = 0;
  memset(v24, 0, sizeof(v24));
  unint64_t v23 = 0;
  unint64_t v28 = a4;
  uint64_t v29 = a5;
  uint64_t tree_in_snap = jfs_get_tree_in_snap(a1, 5, a2, a3, &v23);
  if (!tree_in_snap)
  {
    bt_iterator_init_with_hint((uint64_t)v24, v23, a3, (unsigned __int16)a7, &v28, 16, 0x10u, &v26, 0x10u, a6);
    if (v15 != 2)
    {
      uint64_t tree_in_snap = v15;
      if (v15)
      {
LABEL_13:
        obj_release(v23);
        return tree_in_snap;
      }
      uint64_t v22 = 0;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v19 = 0u;
      while (!bt_iterator_ended((uint64_t)v24) && (!a4 || v28 == a4))
      {
        LODWORD(v19) = 3670280;
        *((void *)&v19 + 1) = v28;
        *(void *)&long long v20 = v29;
        *(void *)&long long v21 = 0;
        *((void *)&v21 + 1) = v26 & 0xFFFFFFFFFFFFFFLL;
        *((void *)&v20 + 1) = v27;
        LOBYTE(v22) = HIBYTE(v26);
        uint64_t v16 = a8(&v19, a9);
        if (v16)
        {
          uint64_t tree_in_snap = v16;
          goto LABEL_13;
        }
        uint64_t v17 = bt_iterator_next((uint64_t)v24);
        if ((a7 & 0x40000) == 0)
        {
          uint64_t tree_in_snap = v17;
          if (v17) {
            goto LABEL_13;
          }
        }
      }
    }
    uint64_t tree_in_snap = 0;
    goto LABEL_13;
  }
  return tree_in_snap;
}

uint64_t new_lock(pthread_mutex_t *a1)
{
  return pthread_mutex_init(a1, 0);
}

uint64_t new_rwlock(pthread_rwlock_t *a1)
{
  return pthread_rwlock_init(a1, 0);
}

uint64_t new_cv(pthread_cond_t *a1)
{
  return pthread_cond_init(a1, 0);
}

pthread_cond_t *free_cv(pthread_cond_t *result)
{
  if (result) {
    return (pthread_cond_t *)pthread_cond_destroy(result);
  }
  return result;
}

uint64_t cv_wait(pthread_cond_t *a1, pthread_mutex_t *a2, uint64_t a3, uint64_t a4, timespec *a5)
{
  if (a5)
  {
    v15.int tv_sec = 0;
    v15.uint64_t tv_nsec = 0;
    clock_gettime(_CLOCK_REALTIME, &v15);
    BOOL v8 = __OFADD__(a5->tv_sec, v15.tv_sec);
    __darwin_time_t v9 = a5->tv_sec + v15.tv_sec;
    a5->int tv_sec = v9;
    if (v8)
    {
      return 35;
    }
    else
    {
      uint64_t tv_nsec = a5->tv_nsec;
      BOOL v8 = __OFADD__(tv_nsec, v15.tv_nsec);
      unint64_t v12 = tv_nsec + v15.tv_nsec;
      if (v8) {
        unint64_t v12 = 999999999;
      }
      a5->uint64_t tv_nsec = v12;
      if (v12 > 0x3B9ACA00)
      {
        unint64_t v13 = v12 - 1000000000;
        unint64_t v14 = (v13 - 1) / 0x3B9ACA00;
        a5->int tv_sec = v9 + v14 + 1;
        a5->uint64_t tv_nsec = v13 - 1000000000 * v14;
      }
      LODWORD(result) = pthread_cond_timedwait(a1, a2, a5);
      if (result == 60) {
        return 35;
      }
      else {
        return result;
      }
    }
  }
  else
  {
    return pthread_cond_wait(a1, a2);
  }
}

uint64_t cv_wait_rw(pthread_cond_t *a1, pthread_mutex_t *a2, uint64_t a3, timespec *a4)
{
  return cv_wait(a1, a2, a3, (uint64_t)a4, a4);
}

uint64_t io_get_device_features(int a1, dev_t *a2, _DWORD *a3, int *a4, dev_t *a5)
{
  if (a2)
  {
    v60.dev_t st_dev = 0;
    if (ioctl(a1, 0x4004644CuLL, &v60))
    {
      if (*__error() != 25)
      {
        BOOL v10 = __error();
        strerror(*v10);
        log_err((uint64_t)"%s:%d: can't get features for device (%s)\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"io_get_device_features");
      }
      dev_t st_dev = 0;
    }
    else
    {
      dev_t st_dev = v60.st_dev;
    }
    *a2 = st_dev;
  }
  if (a3) {
    *a3 = (fcntl(a1, 3) & 3) != 0;
  }
  if (!a4) {
    goto LABEL_14;
  }
  memset(&v60, 0, sizeof(v60));
  if (fstat(a1, &v60) || (v60.st_mode & 0xB000 | 0x4000) != 0x6000 || (CFMutableDictionaryRef v29 = IOServiceMatching("IOMedia")) == 0)
  {
LABEL_12:
    int v19 = 0;
    goto LABEL_13;
  }
  uint64_t v30 = v29;
  int v58 = v60.st_rdev & 0xFFFFFF;
  unsigned int valuePtr = HIBYTE(v60.st_rdev);
  CFNumberRef v31 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v31)
  {
    CFNumberRef v32 = v31;
    CFDictionarySetValue(v30, @"BSD Major", v31);
    CFRelease(v32);
  }
  CFNumberRef v33 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v58);
  if (v33)
  {
    CFNumberRef v34 = v33;
    CFDictionarySetValue(v30, @"BSD Minor", v33);
    CFRelease(v34);
  }
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v30);
  if (!MatchingService)
  {
    log_debug((uint64_t)"%s:%d: fd %d is type %o rdev %d (%d, %d): I/O registry entry not found\n", v36, v37, v38, v39, v40, v41, v42, (uint64_t)"io_get_device_features");
    goto LABEL_12;
  }
  io_object_t v43 = MatchingService;
  IOObjectRetain(MatchingService);
  iterator[0] = 0;
  io_object_t v44 = v43;
  while (1)
  {
    io_registry_entry_t parent = 0;
    if (IOObjectConformsTo(v44, "AppleAPFSContainerScheme")) {
      break;
    }
    if (IOObjectConformsTo(v44, "IOBlockStorageDevice")) {
      goto LABEL_43;
    }
    if (IORegistryEntryGetParentEntry(v44, "IOService", &parent)) {
      io_registry_entry_t parent = 0;
    }
    IOObjectRelease(v44);
    io_object_t v44 = parent;
    if (!parent)
    {
      int v19 = 0;
      goto LABEL_45;
    }
  }
  CFDictionaryRef v46 = (const __CFDictionary *)IORegistryEntrySearchCFProperty(v44, "IOService", @"Device Characteristics", kCFAllocatorDefault, 3u);
  if (v46)
  {
    CFDictionaryRef v47 = v46;
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue(v46, @"Target Disk Mode");
    if (Value)
    {
      int v49 = CFBooleanGetValue(Value);
      CFRelease(v47);
      if (v49)
      {
LABEL_43:
        int v19 = 0;
        goto LABEL_44;
      }
    }
    else
    {
      CFRelease(v47);
    }
  }
  if (IORegistryEntryGetParentIterator(v44, "IOService", iterator)) {
    goto LABEL_43;
  }
  while (1)
  {
    io_object_t v50 = IOIteratorNext(iterator[0]);
    if (!v50) {
      break;
    }
    io_registry_entry_t v51 = v50;
    if (sub_1000259B4(v50, @"image-format-read-only"))
    {
      BOOL v52 = 0;
    }
    else
    {
      if (!sub_1000259B4(v51, @"Removable"))
      {
        CFTypeRef v53 = IORegistryEntrySearchCFProperty(v51, "IOService", @"Protocol Characteristics", kCFAllocatorDefault, 3u);
        if (v53)
        {
          uint64_t v54 = v53;
          CFTypeID TypeID = CFDictionaryGetTypeID();
          if (TypeID != CFGetTypeID(v54)) {
            goto LABEL_56;
          }
          unint64_t v56 = CFDictionaryGetValue((CFDictionaryRef)v54, @"Physical Interconnect Location");
          if (!v56) {
            goto LABEL_57;
          }
          CFTypeID v57 = CFStringGetTypeID();
          if (v57 == CFGetTypeID(v56)) {
            LODWORD(v56) = CFEqual(v56, @"Internal") == 0;
          }
          else {
LABEL_56:
          }
            LODWORD(v56) = 0;
LABEL_57:
          CFRelease(v54);
        }
        else
        {
          LODWORD(v56) = 0;
        }
        BOOL v52 = v56 != 0;
        goto LABEL_60;
      }
      BOOL v52 = 1;
    }
LABEL_60:
    IOObjectRelease(v51);
    if (v52)
    {
      int v19 = 1;
      goto LABEL_63;
    }
  }
  int v19 = 0;
LABEL_63:
  IOObjectRelease(iterator[0]);
LABEL_44:
  IOObjectRelease(v44);
LABEL_45:
  IOObjectRelease(v43);
LABEL_13:
  *a4 = v19;
LABEL_14:
  if (a5)
  {
    v60.dev_t st_dev = 0;
    if (ioctl(a1, 0x4004644FuLL, &v60))
    {
      if (*__error() != 25)
      {
        long long v20 = __error();
        strerror(*v20);
        log_err((uint64_t)"%s:%d: can't get solidstate for device (%s)\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"io_get_device_features");
      }
      dev_t v28 = 1;
    }
    else
    {
      dev_t v28 = v60.st_dev;
    }
    *a5 = v28;
  }
  return 0;
}

unint64_t device_container_path(char *a1, _DWORD *a2)
{
  if (!device_is_volume(a1)) {
    return 0;
  }
  unint64_t result = (unint64_t)strrchr(a1, 115);
  if (result)
  {
    unint64_t v5 = result;
    unint64_t result = strtoul((const char *)(result + 1), 0, 10);
    if (result)
    {
      int v6 = result;
      unint64_t result = (unint64_t)strndup(a1, v5 - (void)a1);
      if (result)
      {
        if (a2) {
          *a2 = v6 - 1;
        }
      }
    }
  }
  return result;
}

BOOL device_is_volume(const char *a1)
{
  uint64_t v1 = a1;
  if (!strncmp(a1, "/dev/", 5uLL))
  {
    int v2 = *((unsigned __int8 *)v1 + 5);
    v1 += 5;
    if (v2 == 114) {
      ++v1;
    }
  }
  CFDictionaryRef v3 = IOBSDNameMatching(kIOMasterPortDefault, 0, v1);
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v3);
  if (!MatchingService) {
    return 0;
  }
  io_object_t v5 = MatchingService;
  BOOL v6 = IOObjectConformsTo(MatchingService, "AppleAPFSVolume") != 0;
  IOObjectRelease(v5);
  return v6;
}

BOOL sub_1000259B4(io_registry_entry_t a1, CFStringRef key)
{
  CFBooleanRef v2 = (CFBooleanRef)IORegistryEntrySearchCFProperty(a1, "IOService", key, kCFAllocatorDefault, 3u);
  if (!v2) {
    return 0;
  }
  BOOL v3 = v2 == kCFBooleanTrue;
  CFRelease(v2);
  return v3;
}

uint64_t doc_id_tree_key_cmp(uint64_t a1, _DWORD *a2, int a3, _DWORD *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 4 && a5 == 4)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

uint64_t utf8_normalizeOptCaseFoldAndHash(unint64_t a1, uint64_t a2, int a3, void (*a4)(_OWORD *, uint64_t, uint64_t), uint64_t a5)
{
  uint64_t v16 = 0;
  unint64_t v17 = a1;
  v20[0] = 0;
  v20[1] = 0;
  unint64_t v8 = a1 + a2;
  int v15 = 0;
  char v14 = 1;
  do
  {
    memset(v19, 0, sizeof(v19));
    memset(v18, 0, sizeof(v18));
    unsigned int v13 = 0;
    char v12 = 0;
    uint64_t v9 = sub_100025B9C(&v17, v8, a3, (unsigned int *)v20, (uint64_t)&v16 + 4, (int *)&v16, &v15, (uint64_t)v19, (uint64_t)v18, (int *)&v13, &v12, &v14);
    if (v9) {
      break;
    }
    uint64_t v10 = v13;
    if ((int)v13 >= 1)
    {
      if (v12) {
        doReorder((uint64_t)v19, (uint64_t)v18, v13);
      }
      a4(v19, 4 * v10, a5);
    }
  }
  while (v17 < v8 || (int)v16 > 0);
  return v9;
}

uint64_t sub_100025B9C(unint64_t *a1, unint64_t a2, int a3, unsigned int *a4, uint64_t a5, int *a6, int *a7, uint64_t a8, uint64_t a9, int *a10, unsigned char *a11, unsigned char *a12)
{
  int v18 = *a6;
  int v19 = *a7;
  if (*a6 >= 1 && v19 < v18)
  {
    int v22 = 0;
    *a11 = 0;
    *a10 = 0;
    int v19 = *a7;
    while (1)
    {
      if (v22 >= 1
        && *(unsigned char *)(a5 + v19)
        && *(unsigned __int8 *)(a5 + v19) < *(unsigned __int8 *)(a9 + (v22 - 1)))
      {
        *a11 = 1;
      }
      *(_DWORD *)(a8 + 4 * v22) = a4[v19];
      uint64_t v23 = *a7;
      *a7 = v23 + 1;
      LOBYTE(v23) = *(unsigned char *)(a5 + v23);
      uint64_t v24 = *a10;
      *a10 = v24 + 1;
      *(unsigned char *)(a9 + v24) = v23;
      int v19 = *a7;
      int v18 = *a6;
      if (*a7 >= *a6 || !*(unsigned char *)(a5 + v19)) {
        break;
      }
      int v22 = *a10;
    }
  }
  if (v19 < v18) {
    return 0;
  }
  uint64_t result = 0;
  *a6 = 0;
  *a7 = 0;
  uint64_t v25 = (unsigned __int8 *)*a1;
  if (*a1 < a2)
  {
    while (1)
    {
      uint64_t v27 = v25 + 1;
      *a1 = (unint64_t)(v25 + 1);
      unsigned int v28 = *v25;
      uint64_t result = 92;
      if (!*v25 || v28 == 47) {
        return result;
      }
      if ((v28 & 0x80) == 0)
      {
        uint64_t result = 0;
        if (v28 - 91 < 0xFFFFFFE6) {
          int v66 = 1;
        }
        else {
          int v66 = a3;
        }
        if (v66) {
          unsigned int v67 = *v25;
        }
        else {
          unsigned int v67 = v28 + 32;
        }
        *a4 = v67;
        *a6 = 1;
        *(unsigned char *)a5 = 0;
LABEL_138:
        *a12 = 0;
        return result;
      }
      if (v28 - 225 > 0xB)
      {
        if (v28 - 194 <= 0x1D && (unint64_t)v27 < a2)
        {
          unsigned int v33 = *v27 ^ 0x80;
          if (v33 <= 0x3F)
          {
            unsigned int v31 = ((v28 & 0x1F) << 6) | v33;
            uint64_t v27 = v25 + 2;
            goto LABEL_52;
          }
        }
      }
      else if ((unint64_t)(v25 + 2) < a2)
      {
        unsigned int v29 = *v27 ^ 0x80;
        if (v29 <= 0x3F)
        {
          unsigned int v30 = v25[2] ^ 0x80;
          if (v30 <= 0x3F)
          {
            unsigned int v31 = ((v28 & 0xF) << 12) | (v29 << 6) | v30;
            uint64_t v27 = v25 + 3;
            goto LABEL_52;
          }
        }
      }
      if (v28 > 0xEF)
      {
        if (v28 > 0xFD)
        {
          unsigned __int8 v36 = 0;
          goto LABEL_41;
        }
        if (v28 <= 0xF7) {
          char v34 = 3;
        }
        else {
          char v34 = 4;
        }
        BOOL v35 = v28 > 0xFB;
      }
      else
      {
        char v34 = v28 > 0xDF;
        BOOL v35 = v28 > 0xBF;
      }
      if (v35) {
        unsigned __int8 v36 = v34 + 1;
      }
      else {
        unsigned __int8 v36 = v34;
      }
LABEL_41:
      unsigned int v31 = -1;
      if ((unint64_t)&v27[v36] <= a2)
      {
        unsigned int v37 = v28 & ~(-1 << (6 - v36));
        if (v36 == 1) {
          goto LABEL_49;
        }
        if (v36 == 2
          || v36 == 3
          && (uint64_t v27 = v25 + 2, v38 = v25[1] ^ 0x80, v31 = -1, v38 <= 0x3F)
          && (unsigned int v37 = v38 | (v37 << 6), v37 <= 0x10F))
        {
          int v39 = *v27++;
          int v40 = v39 ^ 0x80;
          unsigned int v31 = -1;
          if ((v39 ^ 0x80u) <= 0x3F)
          {
            unsigned int v37 = v40 | (v37 << 6);
            if ((v37 & 0xFFE0) != 0x360)
            {
LABEL_49:
              int v41 = *v27++;
              int v42 = v41 ^ 0x80;
              if ((v41 ^ 0x80u) > 0x3F || (unsigned int v31 = v42 | (v37 << 6), (signed int)v31 < dword_100076E20[v36])) {
                unsigned int v31 = -1;
              }
            }
          }
        }
      }
LABEL_52:
      *a1 = (unint64_t)v27;
      if ((int)v31 < 1) {
        return result;
      }
      *(unsigned char *)a5 = 0;
      if (v31 >= 0xF0000)
      {
        if ((~v31 & 0xFFFE) == 0) {
          goto LABEL_139;
        }
LABEL_55:
        *a4 = v31;
        goto LABEL_63;
      }
      int v43 = v31;
      if (v31 >> 10 >= 0xC9)
      {
        if (v31 - 918016 < 0xFFFFFE00) {
          goto LABEL_139;
        }
        int v43 = v31 - 711680;
      }
      int v44 = (unsigned __int16)word_100076E30[v43 >> 8];
      if (!word_100076E30[v43 >> 8]) {
        goto LABEL_62;
      }
      if (v44 == 0xFFFF) {
        goto LABEL_139;
      }
      if ((v44 & 0xFF00) == 0xAD00)
      {
LABEL_62:
        *a4 = v31;
        *(unsigned char *)a5 = v44;
        goto LABEL_63;
      }
      if ((unint64_t)(((uint64_t)v43 >> 8) - 172) <= 0x2A) {
        goto LABEL_77;
      }
      int v52 = word_100079838[16 * (v44 & 0xFFF) + (v43 >> 4)];
      if (!v52)
      {
LABEL_83:
        *a4 = v31;
        *(unsigned char *)a5 = v52;
        goto LABEL_84;
      }
      if (v52 == 0xFFFF) {
        goto LABEL_139;
      }
      if ((v52 & 0xFF00) == 0xAE00)
      {
        if ((word_10007747C[v52] >> (v43 & 0xF))) {
          goto LABEL_139;
        }
        *a4 = v31;
        int v45 = 1;
        if (v31 <= 0x4FF && (a3 & 1) == 0) {
          *a4 = word_10007AA98[v31];
        }
        goto LABEL_64;
      }
      if ((v52 & 0xFF00) == 0xAD00) {
        goto LABEL_83;
      }
      if (v52 == 44032 || (unsigned int v54 = (unsigned __int16)word_10007B498[16 * (v52 & 0xFFF) + (v43 & 0xF)], v54 == 44032))
      {
LABEL_77:
        signed int v48 = v31 - 44032;
        int v49 = v48 / 28;
        int v50 = v48 / 588;
        *(_WORD *)(a5 + 1) = 0;
        int v51 = v48 % 28;
        *a4 = v50 + 4352;
        a4[1] = (unsigned __int16)(v49
                                 - 21
                                 * (((__int16)((49933 * (__int16)v49) >> 16) >> 4)
                                  + ((unsigned __int16)(((49933 * (__int16)v49) >> 16) & 0x8000) >> 15))
                                 + 4449);
        if (v51)
        {
          a4[2] = v51 + 4519;
          int v45 = 3;
        }
        else
        {
          int v45 = 2;
        }
        goto LABEL_64;
      }
      if (v54 == 0xFFFF)
      {
LABEL_139:
        int v68 = -1;
LABEL_140:
        *a6 = v68;
        return result;
      }
      if (((unsigned __int16)(v54 + 1792) >> 8) <= 0xB6u)
      {
        if (!v54 || (v54 & 0xFF00) == 0xAD00)
        {
          *a4 = v31;
          *(unsigned char *)a5 = v54;
        }
        else
        {
          *a4 = v54;
        }
LABEL_84:
        if ((a3 & 1) == 0)
        {
          uint64_t v53 = (int)*a4;
          if ((int)v53 <= 1279)
          {
            unsigned int v31 = word_10007AA98[v53];
            goto LABEL_55;
          }
        }
LABEL_63:
        int v45 = 1;
LABEL_64:
        *a6 = v45;
        goto LABEL_65;
      }
      switch(((v54 & 0xF000) - 45056) >> 12)
      {
        case 0u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_110;
          }
          long long v69 = 0;
          uint64_t v55 = (char *)&unk_10007758A + 4 * (v54 & 0x7FF);
          int v45 = 2;
          goto LABEL_115;
        case 1u:
          if ((v54 & 0x800) != 0 && a3) {
            goto LABEL_110;
          }
          long long v69 = 0;
          uint64_t v55 = (char *)&unk_10007819E + 6 * (v54 & 0x7FF);
          int v45 = 3;
          goto LABEL_115;
        case 2u:
          long long v69 = 0;
          unint64_t v56 = (unsigned __int16 *)((char *)&unk_1000786D2 + 2 * (v54 & 0x3FF));
          unsigned int v58 = *v56;
          uint64_t v55 = (char *)(v56 + 1);
          unsigned int v57 = v58;
          goto LABEL_112;
        case 3u:
          if ((v54 & 0x800) != 0 && a3)
          {
LABEL_110:
            *a4 = v31;
            int v45 = 1;
            goto LABEL_64;
          }
          uint64_t v55 = 0;
          long long v69 = (int *)((char *)&unk_100078860 + 4 * (v54 & 0x7FF));
          int v45 = 1;
LABEL_115:
          uint64_t v60 = 0;
          unint64_t v70 = a12;
          int v71 = a3;
          do
          {
            if (v55)
            {
              int v62 = *(unsigned __int16 *)v55;
              v55 += 2;
              int v61 = v62;
            }
            else
            {
              int v61 = *v69++;
            }
            a4[v60] = v61;
            if (v60)
            {
              uint64_t v72 = v60;
              unint64_t v73 = v55;
              char v63 = sub_100026858(v61);
              uint64_t v60 = v72;
              uint64_t v55 = v73;
              *(unsigned char *)(a5 + v72) = v63;
            }
            ++v60;
            a12 = v70;
            a3 = v71;
          }
          while (v45 != v60);
          if (v71) {
            goto LABEL_128;
          }
          uint64_t v64 = (int)*a4;
          if ((int)v64 <= 1279) {
            *a4 = word_10007AA98[v64];
          }
          if (v45 < 2) {
            goto LABEL_63;
          }
          uint64_t v65 = (v45 - 1);
          if (a4[v65] == 837) {
            a4[v65] = 953;
          }
LABEL_128:
          *a6 = v45;
          if (v45 < 1) {
            return 92;
          }
          break;
        case 4u:
          uint64_t v55 = 0;
          uint64_t v59 = (_DWORD *)((char *)&unk_1000796DC + 4 * (v54 & 0x3FF));
          unsigned int v57 = *v59;
          long long v69 = v59 + 1;
LABEL_112:
          int v45 = v57 & 0xF;
          *(unsigned char *)a5 = v57 >> 4;
          if ((v45 - 5) >= 0xFFFFFFFC) {
            goto LABEL_115;
          }
          int v68 = 0;
          goto LABEL_140;
        default:
          goto LABEL_139;
      }
LABEL_65:
      if (!*(unsigned char *)a5 || *a12)
      {
        uint64_t result = 0;
        goto LABEL_138;
      }
      int v46 = *a10;
      if (v45 + *a10 > 32) {
        return 92;
      }
      uint64_t v47 = 0;
      do
      {
        if (v46 >= 1
          && *(unsigned char *)(a5 + v47)
          && *(unsigned __int8 *)(a5 + v47) < *(unsigned __int8 *)(a9 + (v46 - 1)))
        {
          *a11 = 1;
        }
        *(_DWORD *)(a8 + 4 * v46) = a4[v47];
        *(unsigned char *)(a9 + *a10) = *(unsigned char *)(a5 + v47++);
        int v46 = *a10 + 1;
        *a10 = v46;
      }
      while (v47 < *a6);
      *a6 = 0;
      uint64_t v25 = (unsigned __int8 *)*a1;
      if (*a1 >= a2) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t doReorder(uint64_t result, uint64_t a2, unsigned int a3)
{
  if ((int)a3 >= 2)
  {
    uint64_t v3 = 0;
    uint64_t v4 = result + 4 * a3 - 4;
    do
    {
      uint64_t v5 = *(unsigned __int8 *)(a2 + a3 - 1);
      BOOL v6 = (int *)v4;
      uint64_t v7 = a3 - 2;
      do
      {
        uint64_t v8 = *(unsigned __int8 *)(a2 + v7);
        if (v5 < v8)
        {
          uint64_t v9 = (unsigned char *)(a2 + v7);
          int v10 = *v6;
          *BOOL v6 = *(v6 - 1);
          uint64_t result = *(unsigned __int8 *)(a2 + v7);
          v9[1] = result;
          *(v6 - 1) = v10;
          *uint64_t v9 = v5;
          uint64_t v8 = v5;
        }
        --v6;
        uint64_t v5 = v8;
      }
      while (v7-- > v3);
      ++v3;
    }
    while (v3 != a3 - 1);
  }
  return result;
}

uint64_t utf8_normalizeOptCaseFoldAndCompare(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int a5, BOOL *a6)
{
  unint64_t v32 = a3;
  unint64_t v33 = a1;
  unint64_t v7 = a1 + a2;
  unint64_t v8 = a3 + a4;
  memset(__b, 0, 32);
  long long v41 = 0u;
  long long v42 = 0u;
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  char v29 = 1;
  char v28 = 1;
  while (1)
  {
    long long v38 = 0u;
    memset(__s1, 0, sizeof(__s1));
    memset(__s2, 0, sizeof(__s2));
    memset(v35, 0, sizeof(v35));
    memset(v34, 0, sizeof(v34));
    unsigned int v26 = 0;
    unsigned int v27 = 0;
    __int16 v25 = 0;
    uint64_t result = sub_100025B9C(&v33, v7, a5, __b, (uint64_t)&v40, (int *)&v31 + 1, (int *)&v30 + 1, (uint64_t)__s1, (uint64_t)v35, (int *)&v27, (unsigned char *)&v25 + 1, &v29);
    if (result) {
      return result;
    }
    uint64_t result = sub_100025B9C(&v32, v8, a5, (unsigned int *)&v41, (uint64_t)&v39, (int *)&v31, (int *)&v30, (uint64_t)__s2, (uint64_t)v34, (int *)&v26, &v25, &v28);
    if (result) {
      return result;
    }
    unint64_t v10 = v26;
    unint64_t v11 = v27;
    if ((int)v27 > 0 || (int)v26 >= 1)
    {
      if (HIBYTE(v25)) {
        doReorder((uint64_t)__s1, (uint64_t)v35, v27);
      }
      if ((_BYTE)v25) {
        doReorder((uint64_t)__s2, (uint64_t)v34, v10);
      }
      if (a5)
      {
        int v12 = v10;
        unsigned int v13 = v11;
        goto LABEL_50;
      }
      if ((int)v11 < 2 || __s1[(v11 - 1)] != 953 || HIDWORD(v30))
      {
        unsigned int v13 = v11;
      }
      else
      {
        int v14 = HIDWORD(v31);
        if (SHIDWORD(v31) >= 8)
        {
          int v15 = 0;
          unsigned int v27 = v11;
          goto LABEL_25;
        }
        int v15 = 0;
        while (__s1[(v11 - 1)] == 953)
        {
          ++v15;
          unsigned int v13 = v11 - 1;
          if (v15 < 8 - HIDWORD(v31))
          {
            BOOL v16 = v11-- > 2;
            if (v16) {
              continue;
            }
          }
          goto LABEL_24;
        }
        unsigned int v13 = v11;
LABEL_24:
        unsigned int v27 = v13;
        LODWORD(v11) = v13;
        if (SHIDWORD(v31) >= 1)
        {
LABEL_25:
          unint64_t v17 = HIDWORD(v31);
          do
          {
            __b[v15 - 1 + v17] = __b[v17 - 1];
            *((unsigned char *)&v39 + v15 + v17 + 7) = *((unsigned char *)&v39 + v17 + 7);
            BOOL v16 = v17-- > 1;
          }
          while (v16);
          unsigned int v13 = v11;
        }
        if (v15)
        {
          bzero(&v40, v15);
          memset_pattern16(__b, &unk_10007EB40, 4 * v15);
        }
        HIDWORD(v31) = v14 + v15;
      }
      if ((int)v10 >= 2
        && (*((_DWORD *)__s2 + (v10 - 1)) == 953 ? (BOOL v18 = v30 == 0) : (BOOL v18 = 0), v18))
      {
        int v19 = v31;
        int v20 = 0;
        if ((int)v31 > 7) {
          goto LABEL_44;
        }
        while (*((_DWORD *)__s2 + (v10 - 1)) == 953)
        {
          ++v20;
          int v12 = v10 - 1;
          if (v20 < 8 - (int)v31)
          {
            BOOL v16 = v10-- > 2;
            if (v16) {
              continue;
            }
          }
          goto LABEL_43;
        }
        int v12 = v10;
LABEL_43:
        unsigned int v26 = v12;
        LODWORD(v10) = v12;
        if ((int)v31 >= 1)
        {
LABEL_44:
          unint64_t v21 = v31;
          do
          {
            *((_DWORD *)&v40 + v20 + v21 + 1) = *((_DWORD *)&v40 + v21 + 1);
            *((unsigned char *)&v38 + v20 + v21 + 15) = *((unsigned char *)&v38 + v21 + 15);
            BOOL v16 = v21-- > 1;
          }
          while (v16);
          int v12 = v10;
        }
        if (v20)
        {
          bzero(&v39, v20);
          memset_pattern16(&v41, &unk_10007EB40, 4 * v20);
        }
        LODWORD(v31) = v19 + v20;
      }
      else
      {
        int v12 = v10;
      }
LABEL_50:
      if (v13 != v12 || memcmp(__s1, __s2, 4 * v12))
      {
        uint64_t result = 0;
        *a6 = 0;
        return result;
      }
    }
    if (v33 >= v7 && SHIDWORD(v31) < 1 || v32 >= v8 && (int)v31 <= 0)
    {
      BOOL v22 = 0;
      if (v33 != v7 || HIDWORD(v31))
      {
        uint64_t v23 = a6;
      }
      else
      {
        uint64_t v23 = a6;
        if (v32 == v8) {
          BOOL v22 = v31 == 0;
        }
      }
      uint64_t result = 0;
      *uint64_t v23 = v22;
      return result;
    }
  }
}

uint64_t sub_100026858(int a1)
{
  if (a1 >= 983040) {
    return 0;
  }
  if (a1 == 953) {
    return 240;
  }
  int v2 = a1 - 711680;
  if (a1 <= 205823) {
    int v2 = a1;
  }
  LOWORD(v3) = word_100076E30[v2 >> 8];
  if ((_WORD)v3) {
    BOOL v4 = (v3 & 0xFF00) == 44288;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4) {
    return v3;
  }
  int v3 = word_100079838[16 * (v3 & 0xFFF) + (v2 >> 4)];
  if (!v3) {
    return v3;
  }
  if ((v3 & 0xFF00) == 0xAE00) {
    return 0;
  }
  if ((v3 & 0xFF00) == 0xAD00) {
    return v3;
  }
  __int16 v5 = word_10007B498[16 * (v3 & 0xFFF) + (v2 & 0xF)];
  if ((v5 & 0xFF00) == 0xAD00) {
    return v5;
  }
  else {
    return 0;
  }
}

void crc32c_init()
{
  if (!crc32c)
  {
    int cpu_capabilities = _get_cpu_capabilities();
    uint64_t v1 = sub_1000269EC;
    if ((cpu_capabilities & 0x4000000) == 0)
    {
      int v2 = (char *)crc32c;
      if (crc32c) {
        return;
      }
      do
      {
        unsigned int v3 = 0;
        for (int i = 0; i != 8; ++i)
        {
          unsigned int v5 = (v2 >> i) ^ v3;
          unsigned int v6 = v3 >> 1;
          unsigned int v3 = (v3 >> 1) ^ 0x82F63B78;
          if ((v5 & 1) == 0) {
            unsigned int v3 = v6;
          }
        }
        crc32c_table[(void)v2++] = v3;
        uint64_t v1 = sub_1000269C0;
      }
      while (v2 != (char *)256);
    }
    crc32c = (uint64_t (*)(void, void, void))v1;
  }
}

uint64_t sub_1000269C0(uint64_t result, char *a2, uint64_t a3)
{
  for (; a3; --a3)
  {
    char v3 = *a2++;
    uint64_t result = crc32c_table[(v3 ^ result)] ^ (result >> 8);
  }
  return result;
}

uint64_t sub_1000269EC(uint64_t result, unsigned __int16 *a2, unint64_t a3)
{
  if ((a2 & 7) != 0)
  {
    if (!a3) {
      return result;
    }
    if (a2)
    {
      int v4 = *(unsigned __int8 *)a2;
      a2 = (unsigned __int16 *)((char *)a2 + 1);
      _W8 = v4;
      __asm { CRC32CB         W0, W0, W8 }
      uint64_t result = _OFF;
      __asm { CRC32CB         W0, W0, W8 }
      --a3;
    }
    if (a3 >= 2 && (a2 & 3) != 0)
    {
      int v11 = *a2++;
      _W9 = v11;
      __asm { CRC32CH         W0, W0, W9 }
      uint64_t result = _OFF;
      __asm { CRC32CH         W0, W0, W9 }
      a3 -= 2;
    }
    if (a3 >= 4 && (a2 & 7) != 0)
    {
      int v14 = *(_DWORD *)a2;
      a2 += 2;
      _W9 = v14;
      __asm { CRC32CW         W0, W0, W9 }
      uint64_t result = _OFF;
      __asm { CRC32CW         W0, W0, W9 }
      a3 -= 4;
    }
  }
  if (a3 >= 8)
  {
    do
    {
      uint64_t v17 = *(void *)a2;
      a2 += 4;
      _X8 = v17;
      __asm { CRC32CX         W0, W0, X8 }
      uint64_t result = _OFF;
      __asm { CRC32CX         W0, W0, X8 }
      a3 -= 8;
    }
    while (a3 > 7);
  }
  if (a3 >= 4)
  {
    int v20 = *(_DWORD *)a2;
    a2 += 2;
    _W9 = v20;
    __asm { CRC32CW         W0, W0, W9 }
    uint64_t result = _OFF;
    __asm { CRC32CW         W0, W0, W9 }
    a3 -= 4;
  }
  if (a3 >= 2)
  {
    int v23 = *a2++;
    _W9 = v23;
    __asm { CRC32CH         W0, W0, W9 }
    uint64_t result = _OFF;
    __asm { CRC32CH         W0, W0, W9 }
    a3 -= 2;
  }
  if (a3)
  {
    _W8 = *(unsigned __int8 *)a2;
    __asm { CRC32CB         W0, W0, W8 }
    uint64_t result = _OFF;
    __asm { CRC32CB         W0, W0, W8 }
  }
  return result;
}

uint64_t get_pending_purgeable_flags_from_ino(uint64_t a1)
{
  uint64_t __dst = 0;
  if (xf_get((unsigned __int16 *)(a1 + 408), 15, 0, (char *)&__dst, 8uLL)) {
    return 66048;
  }
  else {
    return __dst;
  }
}

uint64_t btree_node_space_stats(uint64_t a1, _DWORD *a2, _DWORD *a3, int *a4)
{
  unsigned int v5 = *(unsigned __int16 **)(a1 + 56);
  *a2 = (*(void *)(a1 + 400) >> 27) & 0x1F000;
  LODWORD(v5) = v5[25] + v5[23] + v5[27];
  *a3 = v5;
  BOOL v6 = *a2 >= v5;
  int v7 = *a2 - v5;
  if (v6)
  {
    uint64_t result = 0;
  }
  else
  {
    obj_oid(a1);
    log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): freespace %u larger than nodespace %u\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"btree_node_space_stats");
    int v7 = 0;
    uint64_t result = 22;
  }
  *a4 = v7;
  return result;
}

uint64_t btree_node_debug_stats(uint64_t a1, void *a2, unsigned int a3, uint64_t a4)
{
  uint64_t v7 = a2[7];
  if ((*(_WORD *)(v7 + 32) & 2) != 0)
  {
    ++*(_DWORD *)(a4 + 4);
    *(_DWORD *)(a4 + 16) += *(_DWORD *)(v7 + 36);
  }
  else
  {
    ++*(_DWORD *)a4;
    *(_DWORD *)(a4 + 12) += *(_DWORD *)(v7 + 36);
  }
  if (*(_DWORD *)(a4 + 8) < a3) {
    *(_DWORD *)(a4 + 8) = a3;
  }
  unint64_t v8 = *(unsigned __int16 *)(v7 + 34);
  if (v8 <= 0xF) {
    ++*(_DWORD *)(a4 + 4 * v8 + 216);
  }
  uint64_t v9 = btree_node_sanity_check(a2, 0);
  if (!v9)
  {
    unsigned int v41 = 0;
    unsigned int v39 = 0;
    int v40 = 0;
    uint64_t v9 = btree_node_space_stats((uint64_t)a2, &v41, &v40, (int *)&v39);
    uint64_t v10 = v39;
    uint64_t v11 = v41;
    uint64_t v12 = 5 * v39 / v41;
    ++*(_DWORD *)(a4 + 4 * v12 + 20);
    uint64_t v13 = *(void *)(a4 + 56) + v10;
    *(void *)(a4 + 48) += v11;
    *(void *)(a4 + 56) = v13;
    if ((*(unsigned char *)(a2[7] + 32) & 2) != 0)
    {
      ++*(_DWORD *)(a4 + 4 * v12 + 104);
      uint64_t v15 = *(void *)(a4 + 136);
      *(void *)(a4 + 128) += v11;
      *(void *)(a4 + 136) = v15 + v10;
      if (*(_DWORD *)(v7 + 36))
      {
        unsigned int v16 = 0;
        do
        {
          unsigned int v17 = btree_node_key_len((uint64_t)a2, (unsigned __int16)v16);
          unsigned int v18 = btree_node_val_len((uint64_t)a2, (unsigned __int16)v16);
          uint64_t v19 = *(void *)(a1 + 392);
          if (*(_DWORD *)(v19 + 16) < v17)
          {
            if (v9) {
              uint64_t v9 = v9;
            }
            else {
              uint64_t v9 = 22;
            }
            obj_oid((uint64_t)a2);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): index %d key length %d longer than tree longest %d\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"btree_node_debug_stats");
            uint64_t v19 = *(void *)(a1 + 392);
            unsigned int v17 = *(unsigned __int16 *)(v19 + 16);
          }
          if (v18 == 65534
            || *(_DWORD *)(v19 + 20) < v18
            && (v9 ? (uint64_t v9 = v9) : (uint64_t v9 = 22),
                obj_oid((uint64_t)a2),
                log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): index %d val length %d longer than tree longest %d\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"btree_node_debug_stats"), v19 = *(void *)(a1 + 392), unsigned int v18 = (unsigned __int16)*(_DWORD *)(v19 + 20), v18 == 65534))
          {
            unsigned int v18 = 0;
          }
          if (*(_DWORD *)(a4 + 208) < v17) {
            *(_DWORD *)(a4 + 208) = v17;
          }
          if (*(_DWORD *)(a4 + 212) < v18) {
            *(_DWORD *)(a4 + 212) = v18;
          }
          *(void *)(a4 + 144) += v17;
          unsigned int v34 = *(_DWORD *)(v19 + 16);
          BOOL v35 = (_DWORD *)(a4 + 180);
          if (v34) {
            BOOL v35 = (_DWORD *)(a4 + 4 * (5 * v17 / v34) + 160);
          }
          ++*v35;
          *(void *)(a4 + 152) += v18;
          unsigned int v36 = *(_DWORD *)(v19 + 20);
          unsigned int v37 = (_DWORD *)(a4 + 204);
          if (v36) {
            unsigned int v37 = (_DWORD *)(a4 + 4 * (5 * v18 / v36) + 184);
          }
          ++*v37;
          ++v16;
        }
        while (v16 < *(_DWORD *)(v7 + 36));
      }
    }
    else
    {
      ++*(_DWORD *)(a4 + 4 * v12 + 64);
      uint64_t v14 = *(void *)(a4 + 96) + v10;
      *(void *)(a4 + 88) += v11;
      *(void *)(a4 + 96) = v14;
    }
  }
  return v9;
}

uint64_t btree_node_check(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, unsigned __int8 a11)
{
  if (!a5 || (uint64_t v12 = a5[7]) == 0)
  {
    log_err((uint64_t)"%s:%d: %s btree_node is null\n", a2, a3, a4, (uint64_t)a5, a6, a7, a8, (uint64_t)"btree_node_check");
    return 22;
  }
  int v13 = a8;
  uint64_t v14 = a7;
  int v15 = a6;
  unsigned int v619 = a4;
  v621 = (unsigned char *)a3;
  uint64_t v618 = a2;
  uint64_t v17 = a5[1];
  if (!v17) {
    uint64_t v17 = *(void *)(*a5 + 392);
  }
  uint64_t v620 = v17;
  if (a9)
  {
    uint64_t v18 = btree_node_debug_stats((uint64_t)a1, a5, a6, a9);
    if (v18) {
      return v18;
    }
  }
  if (!a1 && (a5[4] & 1) == 0) {
    return 0;
  }
  uint64_t v616 = a9;
  int v615 = a11;
  int v617 = v15;
  if ((a11 & 1) == 0)
  {
    uint64_t v18 = 0;
    if (v621 && (*(_WORD *)(v12 + 32) & 1) != 0)
    {
      obj_oid((uint64_t)a5);
      obj_oid((uint64_t)v621);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): root node has a parent 0x%llx (level %d)\n", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
      int v15 = v617;
    }
    if ((*(_WORD *)(v12 + 32) & 2) != 0 && *(_WORD *)(v12 + 34))
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): leaf node has non-zero level\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    if (a1)
    {
      if (*(unsigned __int16 *)(a5[7] + 34) > *(unsigned __int16 *)(a1[7] + 34))
      {
        if (v18) {
          uint64_t v18 = v18;
        }
        else {
          uint64_t v18 = 22;
        }
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): node level greater than root level %d\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"btree_node_check");
      }
      if (*(unsigned __int16 *)(a1[7] + 34) - (v15 - 1) != *(unsigned __int16 *)(a5[7] + 34))
      {
        if (v18) {
          uint64_t v18 = v18;
        }
        else {
          uint64_t v18 = 22;
        }
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): node level should be %d\n", v46, v47, v48, v49, v50, v51, v52, (uint64_t)"btree_node_check");
      }
    }
    if (*(_WORD *)(v12 + 32)) {
      __int16 v53 = -96;
    }
    else {
      __int16 v53 = -56;
    }
    unsigned __int16 v54 = v53 + ((a5[50] >> 27) & 0xF000);
    if (*(_WORD *)(v12 + 40))
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): invalid table space offset\n", v55, v56, v57, v58, v59, v60, v61, (uint64_t)"btree_node_check");
    }
    if (*(unsigned __int16 *)(v12 + 42) > v54)
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): table space length larger than available data space\n", v62, v63, v64, v65, v66, v67, v68, (uint64_t)"btree_node_check");
    }
    if ((*(_WORD *)(v12 + 32) & 4) == 0)
    {
      unsigned int v69 = *(unsigned __int16 *)(v12 + 42);
      if (v69 < 8 * btree_node_toc_entry_size((uint64_t)a5))
      {
        if (v18) {
          uint64_t v18 = v18;
        }
        else {
          uint64_t v18 = 22;
        }
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): table space length smaller than minimum\n", v71, v72, v73, v74, v75, v76, v77, (uint64_t)"btree_node_check");
        return v18;
      }
    }
    if (v18) {
      return v18;
    }
    uint64_t v70 = (unsigned __int16)(v54 - *(_WORD *)(v12 + 42));
    if (*(unsigned __int16 *)(v12 + 44) <= (unsigned __int16)(v54 - *(_WORD *)(v12 + 42)))
    {
      uint64_t v18 = 0;
    }
    else
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): free space offset too large\n", v86, v87, v88, v89, v90, v91, v92, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    if (*(unsigned __int16 *)(v12 + 46) + *(unsigned __int16 *)(v12 + 44) > v70)
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): free space extends beyond end of node\n", v93, v94, v95, v96, v97, v98, v99, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    uint64_t v612 = *(unsigned __int16 *)(v12 + 44);
    int v100 = *(unsigned __int16 *)(v12 + 46);
    if (*(_DWORD *)(v12 + 36) > v70)
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key count larger than possible\n", v101, v102, v103, v104, v105, v106, v107, (uint64_t)"btree_node_check");
    }
    unsigned int v108 = *(_DWORD *)(v12 + 36);
    uint64_t v611 = v70;
    if (v108 > v612 && (*(__int16 *)(v12 + 32) & 0x80000000) == 0)
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key count larger than gross key space\n", v109, v110, v111, v112, v113, v114, v115, (uint64_t)"btree_node_check");
    }
    unsigned int v116 = *(_DWORD *)(v12 + 36);
    unsigned int v117 = *(unsigned __int16 *)(v12 + 42);
    if (v116 > v117 / btree_node_toc_entry_size((uint64_t)a5))
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key count larger than TOC space\n", v118, v119, v120, v121, v122, v123, v124, (uint64_t)"btree_node_check");
      return v18;
    }
    if (v18) {
      return v18;
    }
    if (a5[47] == v12 + 56)
    {
      uint64_t v18 = 0;
    }
    else
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): invalid TOC[] pointer\n", v132, v133, v134, v135, v136, v137, v138, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    if (a5[48] != v12 + 56 + *(unsigned __int16 *)(v12 + 42))
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): invalid keys[] pointer\n", v139, v140, v141, v142, v143, v144, v145, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    if ((*(_WORD *)(v12 + 32) & 1) != 0 && a5[49] != v12 + ((a5[50] >> 27) & 0x1F000) - 40)
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): invalid vals[] pointer\n", v146, v147, v148, v149, v150, v151, v152, (uint64_t)"btree_node_check");
    }
    if ((*(_WORD *)(v12 + 32) & 1) == 0 && a5[49] != v12 + ((a5[50] >> 27) & 0x1F000))
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): invalid vals[] pointer\n", v154, v155, v156, v157, v158, v159, v160, (uint64_t)"btree_node_check");
      return v18;
    }
    if (v18) {
      return v18;
    }
    int v153 = v612 + v100;
    if (*(unsigned __int16 *)(v12 + 50) <= v612)
    {
      uint64_t v18 = 0;
      int v252 = v611;
    }
    else
    {
      int v252 = v611;
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key free list space larger than key space available\n", v253, v254, v255, v256, v257, v258, v259, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    int v260 = v252 - v153;
    unint64_t v261 = *(unsigned __int16 *)(v12 + 48);
    if (v261 != 0xFFFF && v612 - 4 < v261)
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key free list head beyond key space available\n", v262, v263, v264, v265, v266, v267, v268, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    if (*(unsigned __int16 *)(v12 + 54) > (unsigned __int16)v260)
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val free list space larger than val space available\n", v269, v270, v271, v272, v273, v274, v275, (uint64_t)"btree_node_check");
    }
    unsigned int v276 = *(unsigned __int16 *)(v12 + 52);
    if (v276 != 0xFFFF)
    {
      if (v276 > (unsigned __int16)v260)
      {
        if (v18) {
          uint64_t v18 = v18;
        }
        else {
          uint64_t v18 = 22;
        }
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val free list head beyond val space available\n", v284, v285, v286, v287, v288, v289, v290, (uint64_t)"btree_node_check");
        unsigned int v276 = *(unsigned __int16 *)(v12 + 52);
      }
      if (v276 <= 3)
      {
        if (v18) {
          uint64_t v18 = v18;
        }
        else {
          uint64_t v18 = 22;
        }
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val free list head beyond end of node\n", v307, v308, v309, v310, v311, v312, v313, (uint64_t)"btree_node_check");
        return v18;
      }
    }
    if (v18) {
      return v18;
    }
    unint64_t v610 = v612 - 4;
    uint64_t v291 = _apfs_calloc((v611 + 63) >> 6, 8uLL);
    size_t v608 = (v611 + 63) >> 6;
    uint64_t v292 = _apfs_calloc(v608, 8uLL);
    v609 = v292;
    if (!v291 || !v292)
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): couldn't allocate bitmap to check btree node space usage\n", v314, v315, v316, v317, v318, v319, v320, (uint64_t)"btree_node_check");
      uint64_t v18 = 12;
      goto LABEL_253;
    }
    int v607 = v260;
    uint64_t v613 = v14;
    int v614 = v13;
    bitmap_set_range((uint64_t)v291, *(unsigned __int16 *)(v12 + 44), *(unsigned __int16 *)(v12 + 46));
    unsigned __int16 v293 = 0;
    LOWORD(v294) = *(_WORD *)(v12 + 48);
    uint64_t v295 = v291;
    while (1)
    {
      uint64_t v296 = (unsigned __int16)v294;
      if ((unsigned __int16)v294 == 0xFFFF) {
        break;
      }
      if ((unsigned __int16)v294 >= v612 || v610 < (unsigned __int16)v294)
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key free list entry starts beyond key space available\n", v348, v349, v350, v351, v352, v353, v354, (uint64_t)"btree_node_check");
LABEL_251:
        uint64_t v18 = 22;
        goto LABEL_252;
      }
      unint64_t v297 = (unsigned __int16 *)(a5[48] + (unsigned __int16)v294);
      uint64_t v298 = v297[1];
      if (v298 <= 3)
      {
LABEL_249:
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key free list entry len value too small\n", v355, v356, v357, v358, v359, v360, v361, (uint64_t)"btree_node_check");
        goto LABEL_251;
      }
      if (v298 + (unsigned __int16)v294 > v612)
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key free list entry extends beyond key space available\n", v362, v363, v364, v365, v366, v367, v368, (uint64_t)"btree_node_check");
        goto LABEL_251;
      }
      if (!bitmap_range_is_clear((uint64_t)v291, (unsigned __int16)v294, v298))
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key free list entry overlaps with other free space\n", v369, v370, v371, v372, v373, v374, v375, (uint64_t)"btree_node_check");
        goto LABEL_251;
      }
      bitmap_set_range((uint64_t)v291, v296, v297[1]);
      v293 += v297[1];
      unsigned int v299 = *(unsigned __int16 *)(v12 + 50);
      if (v293 <= v299)
      {
        uint64_t v18 = 0;
      }
      else
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key free list entries total space exceeds free list space\n", v300, v301, v302, v303, v304, v305, v306, (uint64_t)"btree_node_check");
        uint64_t v18 = 22;
      }
      int v294 = *v297;
      if (v296 == v294)
      {
LABEL_250:
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key free list entry points to itself\n", v376, v377, v378, v379, v380, v381, v382, (uint64_t)"btree_node_check");
        goto LABEL_251;
      }
      uint64_t v291 = v295;
      if (v293 > v299) {
        goto LABEL_253;
      }
    }
    unsigned __int16 v328 = 0;
    LOWORD(v329) = *(_WORD *)(v12 + 52);
    while (1)
    {
      unsigned int v330 = (unsigned __int16)v329;
      if ((unsigned __int16)v329 == 0xFFFF) {
        break;
      }
      if ((unsigned __int16)v329 <= 3u)
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val free list entry beyond end of node\n", v331, v332, v333, v334, v335, v336, v337, (uint64_t)"btree_node_check");
        uint64_t v18 = 22;
      }
      else
      {
        uint64_t v18 = 0;
      }
      if (v330 > (unsigned __int16)v607)
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val free list entry starts beyond val space available\n", v383, v384, v385, v386, v387, v388, v389, (uint64_t)"btree_node_check");
        goto LABEL_251;
      }
      uint64_t v291 = v295;
      if (v330 < 4) {
        goto LABEL_253;
      }
      uint64_t v338 = (unsigned __int16 *)(a5[49] - v330);
      unint64_t v339 = v338[1];
      if (v339 <= 3) {
        goto LABEL_249;
      }
      if (v330 < v339)
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val free list entry extends beyond val space available\n", v390, v391, v392, v393, v394, v395, v396, (uint64_t)"btree_node_check");
        goto LABEL_251;
      }
      if (!bitmap_range_is_clear((uint64_t)v295, (int)(v611 - v330), v339))
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val free list entry overlaps with other free space\n", v397, v398, v399, v400, v401, v402, v403, (uint64_t)"btree_node_check");
        goto LABEL_251;
      }
      bitmap_set_range((uint64_t)v295, (int)(v611 - v330), v338[1]);
      v328 += v338[1];
      unsigned int v340 = *(unsigned __int16 *)(v12 + 54);
      if (v328 <= v340)
      {
        uint64_t v18 = 0;
      }
      else
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val free list entries total space exceeds free list space\n", v341, v342, v343, v344, v345, v346, v347, (uint64_t)"btree_node_check");
        uint64_t v18 = 22;
      }
      int v329 = *v338;
      if (v330 == v329) {
        goto LABEL_250;
      }
      uint64_t v291 = v295;
      if (v328 > v340) {
        goto LABEL_253;
      }
    }
    if ((*(_WORD *)(v12 + 32) & 4) != 0 && (a5[50] & 0x7FFE00) == 0)
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): node says kv size is fixed, but tree says key size is variable\n", v404, v405, v406, v407, v408, v409, v410, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    else
    {
      uint64_t v18 = 0;
    }
    if ((*(_WORD *)(a5[7] + 32) & 2) == 0 && (a5[50] & 0x7FFE00) != 0 && (*(_WORD *)(v12 + 32) & 4) == 0)
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): tree says key size is fixed, but node says kv size is variable\n", v411, v412, v413, v414, v415, v416, v417, (uint64_t)"btree_node_check");
      uint64_t v18 = 22;
    }
    if ((*(_WORD *)(v12 + 32) & 4) != 0 && (*(_WORD *)(a5[7] + 32) & 2) != 0 && (a5[50] & 0x7FFF800000) == 0)
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): node says kv size is fixed, but tree says val size is variable\n", v418, v419, v420, v421, v422, v423, v424, (uint64_t)"btree_node_check");
    }
    uint64_t v425 = a5[7];
    __int16 v426 = *(_WORD *)(v425 + 32);
    if ((v426 & 2) != 0)
    {
      uint64_t v427 = a5[50];
      if ((v427 & 0x7FFF800000) != 0 && (v427 & 4) == 0 && (v427 & 0x7FFE00) != 0 && (*(_WORD *)(v12 + 32) & 4) == 0)
      {
        if (v18) {
          uint64_t v18 = v18;
        }
        else {
          uint64_t v18 = 22;
        }
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): tree says kv sizes are fixed, but leaf says kv size is variable\n", v575, v576, v577, v578, v579, v580, v581, (uint64_t)"btree_node_check");
        goto LABEL_252;
      }
    }
    uint64_t v291 = v295;
    if (v18) {
      goto LABEL_253;
    }
    uint64_t v428 = a5[47];
    if ((*(_WORD *)(v12 + 32) & 4) != 0)
    {
      unint64_t v502 = a5[50];
      if ((v426 & 2) != 0) {
        uint64_t v503 = (unsigned __int16)(v502 >> 23);
      }
      else {
        uint64_t v503 = 8;
      }
      if (*(_DWORD *)(v425 + 36))
      {
        unint64_t v504 = 0;
        unint64_t v606 = (v502 >> 9) & 0x3FFF;
        unsigned int v604 = ((_WORD)v606 + 7) & 0x7FF8;
        uint64_t v605 = (v503 + 7) & 0x1FFF8;
        v505 = (unsigned __int16 *)(v428 + 2);
        do
        {
          uint64_t v506 = *(v505 - 1);
          unint64_t v610 = *v505;
          if (v506 == 0xFFFF)
          {
            if ((*(__int16 *)(v12 + 32) & 0x80000000) == 0)
            {
LABEL_422:
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): invalid key offset\n", v589, v590, v591, v592, v593, v594, v595, (uint64_t)"btree_node_check");
              goto LABEL_251;
            }
            uint64_t v18 = 0;
          }
          else
          {
            __int16 v507 = *(_WORD *)(v425 + 32);
            if ((v507 & 2) != 0
              && (a1 && *(_DWORD *)(a1[49] + 16) < v606
               || (v507 & 1) != 0 && *(_DWORD *)(a5[49] + 16) < v606))
            {
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key size greater than longest recorded for tree\n", v508, v509, v510, v511, v512, v513, v514, (uint64_t)"btree_node_check");
              uint64_t v18 = 22;
            }
            else
            {
              uint64_t v18 = 0;
            }
            if (v506 >= v612)
            {
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key location not within key space\n", v515, v516, v517, v518, v519, v520, v521, (uint64_t)"btree_node_check");
              uint64_t v18 = 22;
            }
            if ((int)v606 + (int)v506 <= v612)
            {
              if (!v18)
              {
                if (bitmap_range_is_clear((uint64_t)v295, v506, v606))
                {
                  uint64_t v18 = 0;
                }
                else
                {
                  obj_oid((uint64_t)a5);
                  log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key entry overlaps with free space\n", v529, v530, v531, v532, v533, v534, v535, (uint64_t)"btree_node_check");
                  uint64_t v18 = 22;
                }
                if (!bitmap_range_is_clear((uint64_t)v609, v506, v606))
                {
                  obj_oid((uint64_t)a5);
                  log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key entry overlaps with other entries\n", v536, v537, v538, v539, v540, v541, v542, (uint64_t)"btree_node_check");
                  uint64_t v18 = 22;
                }
                if ((a5[50] & 0x40) != 0) {
                  uint64_t v543 = v606;
                }
                else {
                  uint64_t v543 = v604;
                }
                bitmap_set_range((uint64_t)v609, v506, v543);
              }
            }
            else
            {
              if (v18) {
                uint64_t v18 = v18;
              }
              else {
                uint64_t v18 = 22;
              }
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key location extends beyond key space\n", v522, v523, v524, v525, v526, v527, v528, (uint64_t)"btree_node_check");
            }
          }
          if (v610 <= 0xFFFD)
          {
            __int16 v544 = *(_WORD *)(a5[7] + 32);
            if ((v544 & 2) != 0
              && (a1 && *(_DWORD *)(a1[49] + 20) < v503
               || (v544 & 1) != 0 && *(_DWORD *)(a5[49] + 20) < v503))
            {
              if (v18) {
                uint64_t v18 = v18;
              }
              else {
                uint64_t v18 = 22;
              }
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val size greater than longest recorded for tree\n", v545, v546, v547, v548, v549, v550, v551, (uint64_t)"btree_node_check");
            }
            if (v610 > (unsigned __int16)v607)
            {
              if (v18) {
                uint64_t v18 = v18;
              }
              else {
                uint64_t v18 = 22;
              }
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val location not within val space\n", v552, v553, v554, v555, v556, v557, v558, (uint64_t)"btree_node_check");
            }
            if (v610 < v503)
            {
              if (v18) {
                uint64_t v18 = v18;
              }
              else {
                uint64_t v18 = 22;
              }
LABEL_421:
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val location extends beyond val space\n", v582, v583, v584, v585, v586, v587, v588, (uint64_t)"btree_node_check");
LABEL_252:
              uint64_t v291 = v295;
LABEL_253:
              if (v291) {
                _apfs_free(v291, (8 * v608));
              }
              if (v609) {
                _apfs_free(v609, (8 * v608));
              }
              return v18;
            }
            uint64_t v291 = v295;
            if (v18) {
              goto LABEL_253;
            }
            uint64_t v559 = v611 - v610;
            if (bitmap_range_is_clear((uint64_t)v295, v611 - v610, v503))
            {
              uint64_t v18 = 0;
            }
            else
            {
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val entry overlaps with free space\n", v560, v561, v562, v563, v564, v565, v566, (uint64_t)"btree_node_check");
              uint64_t v18 = 22;
            }
            if (!bitmap_range_is_clear((uint64_t)v609, v559, v503))
            {
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val entry overlaps with other entries\n", v567, v568, v569, v570, v571, v572, v573, (uint64_t)"btree_node_check");
              uint64_t v18 = 22;
            }
            if ((a5[50] & 0x40) != 0) {
              uint64_t v574 = v503;
            }
            else {
              uint64_t v574 = v605;
            }
            bitmap_set_range((uint64_t)v609, v559, v574);
          }
          uint64_t v291 = v295;
          if (v18) {
            goto LABEL_253;
          }
          v505 += 2;
          ++v504;
          uint64_t v425 = a5[7];
        }
        while (v504 < *(unsigned int *)(v425 + 36));
      }
    }
    else if (*(_DWORD *)(v425 + 36))
    {
      unint64_t v429 = 0;
      unint64_t v430 = (unsigned __int16 *)(v428 + 4);
      do
      {
        uint64_t v431 = *(v430 - 2);
        unint64_t v610 = *v430;
        uint64_t v432 = v430[1];
        if (v431 == 0xFFFF)
        {
          if ((*(__int16 *)(v12 + 32) & 0x80000000) == 0) {
            goto LABEL_422;
          }
          uint64_t v18 = 0;
        }
        else
        {
          uint64_t v433 = *(v430 - 1);
          __int16 v434 = *(_WORD *)(v425 + 32);
          if ((v434 & 2) != 0
            && (a1 && *(_DWORD *)(a1[49] + 16) < v433
             || (v434 & 1) != 0 && *(_DWORD *)(a5[49] + 16) < v433))
          {
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key size greater than longest recorded for tree\n", v435, v436, v437, v438, v439, v440, v441, (uint64_t)"btree_node_check");
            uint64_t v18 = 22;
          }
          else
          {
            uint64_t v18 = 0;
          }
          if (v431 >= v612)
          {
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key location not within key space\n", v442, v443, v444, v445, v446, v447, v448, (uint64_t)"btree_node_check");
            uint64_t v18 = 22;
          }
          if ((int)v433 + (int)v431 <= v612)
          {
            if (!v18)
            {
              if (bitmap_range_is_clear((uint64_t)v295, v431, v433))
              {
                uint64_t v18 = 0;
              }
              else
              {
                obj_oid((uint64_t)a5);
                log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key entry overlaps with free space\n", v456, v457, v458, v459, v460, v461, v462, (uint64_t)"btree_node_check");
                uint64_t v18 = 22;
              }
              if (!bitmap_range_is_clear((uint64_t)v609, v431, v433))
              {
                obj_oid((uint64_t)a5);
                log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key entry overlaps with other entries\n", v463, v464, v465, v466, v467, v468, v469, (uint64_t)"btree_node_check");
                uint64_t v18 = 22;
              }
              if ((a5[50] & 0x40) != 0) {
                uint64_t v470 = v433;
              }
              else {
                uint64_t v470 = (v433 + 7) & 0x1FFF8;
              }
              bitmap_set_range((uint64_t)v609, v431, v470);
            }
          }
          else
          {
            if (v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22;
            }
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key location extends beyond key space\n", v449, v450, v451, v452, v453, v454, v455, (uint64_t)"btree_node_check");
          }
        }
        if (v610 > 0xFFFD)
        {
          if (v432 && v432 != 65534)
          {
            if (v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22;
            }
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): invalid val offset has non-zero length\n", v596, v597, v598, v599, v600, v601, v602, (uint64_t)"btree_node_check");
            goto LABEL_252;
          }
        }
        else
        {
          __int16 v471 = *(_WORD *)(a5[7] + 32);
          if ((v471 & 2) != 0
            && (a1 && *(_DWORD *)(a1[49] + 20) < v432
             || (v471 & 1) != 0 && *(_DWORD *)(a5[49] + 20) < v432))
          {
            if (v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22;
            }
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val size greater than longest recorded for tree\n", v472, v473, v474, v475, v476, v477, v478, (uint64_t)"btree_node_check");
          }
          if (v610 > (unsigned __int16)v607)
          {
            if (v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22;
            }
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val location not within val space\n", v479, v480, v481, v482, v483, v484, v485, (uint64_t)"btree_node_check");
          }
          if (v610 < v432)
          {
            if (v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22;
            }
            goto LABEL_421;
          }
          uint64_t v291 = v295;
          if (v18) {
            goto LABEL_253;
          }
          uint64_t v486 = v611 - v610;
          if (bitmap_range_is_clear((uint64_t)v295, v611 - v610, v432))
          {
            uint64_t v18 = 0;
          }
          else
          {
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val entry overlaps with free space\n", v487, v488, v489, v490, v491, v492, v493, (uint64_t)"btree_node_check");
            uint64_t v18 = 22;
          }
          if (!bitmap_range_is_clear((uint64_t)v609, v486, v432))
          {
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): val entry overlaps with other entries\n", v494, v495, v496, v497, v498, v499, v500, (uint64_t)"btree_node_check");
            uint64_t v18 = 22;
          }
          if ((a5[50] & 0x40) != 0) {
            uint64_t v501 = v432;
          }
          else {
            uint64_t v501 = (v432 + 7) & 0x1FFF8;
          }
          bitmap_set_range((uint64_t)v609, v486, v501);
        }
        uint64_t v291 = v295;
        if (v18) {
          goto LABEL_253;
        }
        v430 += 4;
        ++v429;
        uint64_t v425 = a5[7];
      }
      while (v429 < *(unsigned int *)(v425 + 36));
    }
    _apfs_free(v295, 8 * v608);
    _apfs_free(v609, 8 * v608);
    int v13 = v614;
    uint64_t v14 = v613;
    LOWORD(v15) = v617;
  }
  uint64_t v627 = 0;
  uint64_t v628 = 0;
  int v625 = 0;
  int v626 = 0;
  uint64_t v20 = a5[7];
  uint64_t v21 = (uint64_t)v621;
  unsigned int v22 = v619;
  if (v621 && *(_DWORD *)(v20 + 36))
  {
    uint64_t v23 = btree_node_key_ptr((uint64_t)v621, v619, &v628, (_WORD *)&v626 + 1);
    if (v23)
    {
      uint64_t v18 = v23;
      obj_oid((uint64_t)v621);
      goto LABEL_186;
    }
    uint64_t v31 = btree_node_key_ptr((uint64_t)a5, 0, &v627, &v626);
    if (v31)
    {
      uint64_t v18 = v31;
      obj_oid((uint64_t)a5);
      goto LABEL_186;
    }
    uint64_t v85 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t, void, int *))a5[52])(v620, v628, HIWORD(v626), v627, (unsigned __int16)v626, &v625);
    if (v85)
    {
      uint64_t v18 = v85;
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): minkey compare error: %d\n", v125, v126, v127, v128, v129, v130, v131, (uint64_t)"btree_node_check");
      return v18;
    }
    if (v625 >= 1)
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): minkey not correct\n", v161, v162, v163, v164, v165, v166, v167, (uint64_t)"btree_node_check");
      return 22;
    }
    if (v625)
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): minkey not in sync\n", v277, v278, v279, v280, v281, v282, v283, (uint64_t)"btree_node_check");
      return 22;
    }
    uint64_t v20 = a5[7];
    uint64_t v21 = (uint64_t)v621;
    unsigned int v22 = v619;
  }
  unsigned int v168 = *(_DWORD *)(v20 + 36);
  if (v168 < 2) {
    goto LABEL_129;
  }
  uint64_t v613 = v14;
  int v614 = v13;
  uint64_t v18 = 0;
  for (unsigned int i = 1; i < v168; ++i)
  {
    if (btree_node_key_off((uint64_t)a5, (unsigned __int16)(i - 1)) == 0xFFFF
      || btree_node_key_off((uint64_t)a5, (unsigned __int16)i) == 0xFFFF)
    {
      goto LABEL_126;
    }
    unsigned int v170 = btree_node_key_ptr((uint64_t)a5, (unsigned __int16)(i - 1), &v628, (_WORD *)&v626 + 1);
    if (v170)
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = v170;
      }
    }
    else
    {
      unsigned int v171 = btree_node_key_ptr((uint64_t)a5, (unsigned __int16)i, &v627, &v626);
      if (!v171) {
        goto LABEL_120;
      }
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = v171;
      }
    }
    obj_oid((uint64_t)a5);
    log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n", v172, v173, v174, v175, v176, v177, v178, (uint64_t)"btree_node_check");
LABEL_120:
    if (!v18)
    {
      uint64_t v179 = ((uint64_t (*)(uint64_t, uint64_t, void, uint64_t, void, int *))a5[52])(v620, v628, HIWORD(v626), v627, (unsigned __int16)v626, &v625);
      if (v179)
      {
        uint64_t v18 = v179;
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): key %d compare error: %d\n", v180, v181, v182, v183, v184, v185, v186, (uint64_t)"btree_node_check");
      }
      else if (v625 < 0)
      {
        uint64_t v18 = 0;
      }
      else
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): keys out of order: %d\n", v187, v188, v189, v190, v191, v192, v193, (uint64_t)"btree_node_check");
        uint64_t v18 = 22;
      }
    }
LABEL_126:
    unsigned int v168 = *(_DWORD *)(a5[7] + 36);
  }
  int v13 = v614;
  uint64_t v14 = v613;
  LOWORD(v15) = v617;
  if (v18) {
    return v18;
  }
  uint64_t v21 = (uint64_t)v621;
  unsigned int v22 = v619;
LABEL_129:
  if (v21)
  {
    if (btree_node_key_ptr((uint64_t)a5, (unsigned __int16)(v168 - 1), &v628, (_WORD *)&v626 + 1))
    {
      obj_oid((uint64_t)a5);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n", v195, v196, v197, v198, v199, v200, v201, (uint64_t)"btree_node_check");
      return 22;
    }
    if (*(_DWORD *)(*(void *)(v21 + 56) + 36) - 1 <= v22)
    {
      uint64_t v627 = v14;
      LOWORD(v626) = v13;
      int v202 = v13;
      uint64_t v203 = v14;
    }
    else
    {
      uint64_t v194 = btree_node_key_ptr(v21, (unsigned __int16)(v22 + 1), &v627, &v626);
      if (v194)
      {
        uint64_t v18 = v194;
        obj_oid((uint64_t)v621);
LABEL_186:
        long long v244 = "%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n";
LABEL_187:
        log_err((uint64_t)v244, v78, v79, v80, v81, v82, v83, v84, (uint64_t)"btree_node_check");
        return v18;
      }
      uint64_t v203 = v627;
      int v202 = (unsigned __int16)v626;
    }
    if (v203 && v202 && HIWORD(v626))
    {
      uint64_t v204 = ((uint64_t (*)(uint64_t, uint64_t))a5[52])(v620, v628);
      if (v204)
      {
        uint64_t v18 = v204;
        obj_oid((uint64_t)a5);
        long long v244 = "%s:%d: %s oid 0x%llx (level %d): key %d compare error: %d\n";
        goto LABEL_187;
      }
      if ((v625 & 0x80000000) == 0)
      {
        obj_oid((uint64_t)a5);
        log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): node's max key is not less than next sibling's entry in parent\n", v245, v246, v247, v248, v249, v250, v251, (uint64_t)"btree_node_check");
        return 22;
      }
    }
  }
  if (!a1) {
    return 0;
  }
  uint64_t v205 = a5[7];
  if ((*(_WORD *)(v205 + 32) & 2) != 0 || *(_DWORD *)(v205 + 36))
  {
    uint64_t v18 = 0;
  }
  else
  {
    obj_oid((uint64_t)a5);
    log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): non-leaf node has no children?\n", v237, v238, v239, v240, v241, v242, v243, (uint64_t)"btree_node_check");
    uint64_t v18 = 22;
  }
  if ((*(_WORD *)(a5[7] + 32) & 2) == 0 && (a10 & 1) == 0)
  {
    v621 = v603;
    __chkstk_darwin();
    uint64_t v207 = &v603[-v206];
    bzero(&v603[-v206], v208);
    if (*(_DWORD *)(a5[7] + 36))
    {
      uint64_t v613 = v14;
      int v614 = v13;
      __int16 v209 = v15;
      unsigned int v210 = 0;
      LODWORD(v620) = (unsigned __int16)(v209 + 1);
      do
      {
        if (btree_node_key_off((uint64_t)a5, (unsigned __int16)v210) != 0xFFFF
          && btree_node_val_off((uint64_t)a5, (unsigned __int16)v210) != 0xFFFF)
        {
          if (btree_node_child_val((uint64_t)a5, (unsigned __int16)v210, v207))
          {
            if (v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22;
            }
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): can't get child %d oid: %d\n", v214, v215, v216, v217, v218, v219, v220, (uint64_t)"btree_node_check");
          }
          else if (*v207)
          {
            uint64_t v623 = v613;
            v624 = 0;
            __int16 v622 = v614;
            uint64_t v211 = a5[7];
            if (v210 < *(_DWORD *)(v211 + 36) - 1)
            {
              if (btree_node_key_ptr((uint64_t)a5, (unsigned __int16)(v210 + 1), &v623, &v622))
              {
                if (v18) {
                  uint64_t v18 = v18;
                }
                else {
                  uint64_t v18 = 22;
                }
                obj_oid((uint64_t)a5);
                log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): can't get key %d: %d\n", v321, v322, v323, v324, v325, v326, v327, (uint64_t)"btree_node_check");
                return v18;
              }
              uint64_t v211 = a5[7];
            }
            uint64_t v212 = v618;
            if (btree_node_get(a1, v207, v618, 2u, *(_WORD *)(v211 + 34) - 1, 0, &v624)) {
              BOOL v213 = 1;
            }
            else {
              BOOL v213 = v624 == 0;
            }
            if (v213)
            {
              if (v18) {
                uint64_t v18 = v18;
              }
              else {
                uint64_t v18 = 22;
              }
              obj_oid((uint64_t)a5);
              log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): can't get child: 0x%llx\n", v230, v231, v232, v233, v234, v235, v236, (uint64_t)"btree_node_check");
            }
            else
            {
              unsigned int v221 = btree_node_check(a1, v212, a5, (unsigned __int16)v210);
              if (v18) {
                BOOL v222 = 1;
              }
              else {
                BOOL v222 = v221 == 0;
              }
              if (v222) {
                uint64_t v18 = v18;
              }
              else {
                uint64_t v18 = v221;
              }
              obj_unlock((uint64_t)v624, 1u);
              obj_release(v624);
            }
          }
          else
          {
            if (v18) {
              uint64_t v18 = v18;
            }
            else {
              uint64_t v18 = 22;
            }
            obj_oid((uint64_t)a5);
            log_err((uint64_t)"%s:%d: %s oid 0x%llx (level %d): invalid child oid: 0x%llx\n", v223, v224, v225, v226, v227, v228, v229, (uint64_t)"btree_node_check");
          }
        }
        ++v210;
      }
      while (v210 < *(_DWORD *)(a5[7] + 36));
    }
  }
  return v18;
}

uint64_t btree_check_ext(FILE *a1, void *a2, uint64_t a3, int a4, int a5)
{
  if (obj_type((uint64_t)a2) == 2)
  {
    uint64_t v52 = 0;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v36 = 0u;
    long long v37 = 0u;
    long long v35 = 0u;
    uint64_t v17 = btree_node_check(a2, a3, 0, 0, a2, 1, 0, 0, (uint64_t)&v35, 0, 0);
    uint64_t v18 = v17;
    if (*(void *)(a2[49] + 24) != v36)
    {
      if (v17) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a2);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx: btree key count (%llu) doesn't match # leaf entries (%u)\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"btree_check_ext");
    }
    if (*(void *)(a2[49] + 32) == DWORD1(v35) + v35)
    {
      if (a5 && a4 && !v18)
      {
        if (a1) {
          uint64_t v26 = a1;
        }
        else {
          uint64_t v26 = __stdoutp;
        }
        btree_debug_stats_print(v26, (uint64_t)a2, &v35, a5);
      }
    }
    else
    {
      if (v18) {
        uint64_t v18 = v18;
      }
      else {
        uint64_t v18 = 22;
      }
      obj_oid((uint64_t)a2);
      log_err((uint64_t)"%s:%d: %s oid 0x%llx: btree node count (%llu) doesn't match # nodes traversed (%u)\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"btree_check_ext");
    }
  }
  else
  {
    uint64_t v18 = 22;
    log_err((uint64_t)"%s:%d: %s btree check called with non-root btree node: %d\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"btree_check_ext");
  }
  return v18;
}

uint64_t btree_debug_stats_print(FILE *a1, uint64_t a2, _DWORD *a3, int a4)
{
  if (a1) {
    a4 = 5;
  }
  if (a1) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = __stdoutp;
  }
  if (a4 >= 2)
  {
    unint64_t v8 = *(_DWORD **)(a2 + 392);
    int v9 = v8[1];
    int v10 = v8[2];
    int v11 = v8[3];
    if (v10) {
      int v12 = v10;
    }
    else {
      int v12 = 8;
    }
    if (v11) {
      int v13 = v11;
    }
    else {
      int v13 = 8;
    }
    unsigned int v14 = *a3;
    if (*a3 <= 1u) {
      unsigned int v14 = 1;
    }
    fprintf(v7, "nodesize: %d  dataspace: %d  key size: %d  val size: %d  max keys: node %d leaf %d  avg keys: node %d leaf %d\n", v9, v9 - 56, v10, v11, (v9 - 56) / (v12 + 8), (v9 - 56) / (v13 + v12), a3[3] / v14, a3[4] / a3[1]);
  }
  unint64_t v16 = *((void *)a3 + 11);
  if (v16 <= 1) {
    unint64_t v16 = 1;
  }
  double v17 = (double)*((unint64_t *)a3 + 12) * 100.0 / (double)v16;
  unint64_t v18 = *((void *)a3 + 16);
  if (v18 <= 1) {
    unint64_t v18 = 1;
  }
  unsigned int v15 = a3[1];
  uint64_t result = fprintf(v7, "levels: %d  keys: %lld  nodes: total %d  internal: %d (%.2f%%)  leaves: %d (%.2f%%)  usage: %.2f%% (%.2f%% %.2f%%)\n", a3[2], *(void *)(*(void *)(a2 + 392) + 24), v15 + *a3, *a3, (double)*a3 * 100.0 / (double)(v15 + *a3), v15, (double)v15 * 100.0 / (double)(v15 + *a3), (double)*((unint64_t *)a3 + 7) * 100.0 / (double)*((unint64_t *)a3 + 6), v17, (double)*((unint64_t *)a3 + 17) * 100.0 / (double)v18);
  if (a4 > 2)
  {
    uint64_t v20 = 0;
    int v21 = 0;
    uint64_t v22 = a3 + 54;
    do
    {
      if (v22[v20])
      {
        if (v20) {
          uint64_t result = fprintf(v7, "level %d: %d nodes %.2f average descendents\n");
        }
        else {
          uint64_t result = fprintf(v7, "level %d: %d nodes\n");
        }
        v21 += v22[v20];
      }
      ++v20;
    }
    while (v20 != 16);
  }
  if (a4 >= 2)
  {
    LODWORD(v23) = a3[4];
    unint64_t v23 = v23 <= 1 ? 1 : v23;
    uint64_t result = fprintf(v7, "key/val sizes:  tree max k:%d v:%d  max k:%d v:%d  avg k:%llu v:%llu\n", *(_DWORD *)(*(void *)(a2 + 392) + 16), *(_DWORD *)(*(void *)(a2 + 392) + 20), a3[52], a3[53], *((void *)a3 + 18) / v23, *((void *)a3 + 19) / v23);
    if (a4 >= 4)
    {
      long long v65 = 0u;
      long long v66 = 0u;
      long long v63 = 0u;
      long long v64 = 0u;
      *(_OWORD *)__str = 0u;
      long long v62 = 0u;
      snprintf(__str, 0x10uLL, "<%d", *(_DWORD *)(*(void *)(a2 + 392) + 16) / 5u);
      snprintf((char *)&v62, 0x10uLL, "<%d", 2 * *(_DWORD *)(*(void *)(a2 + 392) + 16) / 5u);
      snprintf((char *)&v63, 0x10uLL, "<%d", 3 * *(_DWORD *)(*(void *)(a2 + 392) + 16) / 5u);
      snprintf((char *)&v64, 0x10uLL, "<%d", 4 * *(_DWORD *)(*(void *)(a2 + 392) + 16) / 5u);
      snprintf((char *)&v65, 0x10uLL, "<%d", *(_DWORD *)(*(void *)(a2 + 392) + 16));
      snprintf((char *)&v66, 0x10uLL, "=%d", *(_DWORD *)(*(void *)(a2 + 392) + 16));
      fprintf(v7, "    keys: %9s %9s %9s %9s %9s %9s\n", __str, (const char *)&v62, (const char *)&v63, (const char *)&v64, (const char *)&v65, (const char *)&v66);
      fprintf(v7, "    keys: %9d %9d %9d %9d %9d %9d\n", a3[40], a3[41], a3[42], a3[43], a3[44], a3[45]);
      LODWORD(v29) = a3[40];
      double v30 = (double)v29 * 100.0;
      unsigned int v31 = a3[4];
      if (v31 <= 1) {
        unsigned int v31 = 1;
      }
      LODWORD(v24) = a3[41];
      LODWORD(v25) = a3[42];
      LODWORD(v26) = a3[43];
      LODWORD(v27) = a3[44];
      LODWORD(v28) = a3[45];
      fprintf(v7, "    keys: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n", v30 / (double)v31, (double)v24 * 100.0 / (double)v31, (double)v25 * 100.0 / (double)v31, (double)v26 * 100.0 / (double)v31, (double)v27 * 100.0 / (double)v31, (double)v28 * 100.0 / (double)v31);
      snprintf(__str, 0x10uLL, "<%d", *(_DWORD *)(*(void *)(a2 + 392) + 20) / 5u);
      snprintf((char *)&v62, 0x10uLL, "<%d", 2 * *(_DWORD *)(*(void *)(a2 + 392) + 20) / 5u);
      snprintf((char *)&v63, 0x10uLL, "<%d", 3 * *(_DWORD *)(*(void *)(a2 + 392) + 20) / 5u);
      snprintf((char *)&v64, 0x10uLL, "<%d", 4 * *(_DWORD *)(*(void *)(a2 + 392) + 20) / 5u);
      snprintf((char *)&v65, 0x10uLL, "<%d", *(_DWORD *)(*(void *)(a2 + 392) + 20));
      snprintf((char *)&v66, 0x10uLL, "=%d", *(_DWORD *)(*(void *)(a2 + 392) + 20));
      fprintf(v7, "  values: %9s %9s %9s %9s %9s %9s\n", __str, (const char *)&v62, (const char *)&v63, (const char *)&v64, (const char *)&v65, (const char *)&v66);
      fprintf(v7, "  values: %9d %9d %9d %9d %9d %9d\n", a3[46], a3[47], a3[48], a3[49], a3[50], a3[51]);
      LODWORD(v37) = a3[46];
      double v38 = (double)v37 * 100.0;
      unsigned int v39 = a3[4];
      if (v39 <= 1) {
        unsigned int v40 = 1;
      }
      else {
        unsigned int v40 = a3[4];
      }
      double v41 = v38 / (double)v40;
      LODWORD(v32) = a3[47];
      double v42 = (double)v32 * 100.0 / (double)v40;
      LODWORD(v33) = a3[48];
      LODWORD(v34) = a3[49];
      double v43 = (double)v33 * 100.0 / (double)v40;
      double v44 = (double)v34 * 100.0;
      double v45 = (double)v39;
      if (!v39) {
        double v45 = 1.0;
      }
      LODWORD(v35) = a3[50];
      LODWORD(v36) = a3[51];
      fprintf(v7, "  values: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n", v41, v42, v43, v44 / v45, (double)v35 * 100.0 / v45, (double)v36 * 100.0 / v45);
      fprintf(v7, "capacity: all    %llu / %llu => %.2f %% used\n", *((void *)a3 + 7), *((void *)a3 + 6), (double)*((unint64_t *)a3 + 7) * 100.0 / (double)*((unint64_t *)a3 + 6));
      if (a4 == 4)
      {
        fprintf(v7, "capacity: nodes  %llu / %llu => %.2f %% used\n");
      }
      else
      {
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[5], a3[6], a3[7], a3[8], a3[9], a3[10]);
        LODWORD(v46) = a3[5];
        LODWORD(v47) = a3[6];
        unsigned int v48 = a3[1] + *a3;
        LODWORD(v49) = a3[7];
        LODWORD(v50) = a3[8];
        LODWORD(v51) = a3[9];
        LODWORD(v52) = a3[10];
        fprintf(v7, "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n", (double)v46 * 100.0 / (double)v48, (double)v47 * 100.0 / (double)v48, (double)v49 * 100.0 / (double)v48, (double)v50 * 100.0 / (double)v48, (double)v51 * 100.0 / (double)v48, (double)v52 * 100.0 / (double)v48);
        fprintf(v7, "capacity: nodes  %llu / %llu => %.2f %% used\n", *((void *)a3 + 12), *((void *)a3 + 11), (double)*((unint64_t *)a3 + 12) * 100.0 / (double)*((unint64_t *)a3 + 11));
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[16], a3[17], a3[18], a3[19], a3[20], a3[21]);
        fprintf(v7, "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n");
      }
      uint64_t result = fprintf(v7, "capacity: leaves %llu / %llu => %.2f %% used\n", *((void *)a3 + 17), *((void *)a3 + 16), (double)*((unint64_t *)a3 + 17) * 100.0 / (double)*((unint64_t *)a3 + 16));
      if (a4 != 4)
      {
        fprintf(v7, "capacity: %9s %9s %9s %9s %9s %9s\n", "<20", "<40", "<60", "<80", "<100", "FULL");
        fprintf(v7, "capacity: %9d %9d %9d %9d %9d %9d\n", a3[26], a3[27], a3[28], a3[29], a3[30], a3[31]);
        LODWORD(v53) = a3[26];
        LODWORD(v54) = a3[27];
        LODWORD(v55) = a3[1];
        double v56 = (double)v55;
        LODWORD(v57) = a3[28];
        LODWORD(v58) = a3[29];
        LODWORD(v59) = a3[30];
        LODWORD(v60) = a3[31];
        return fprintf(v7, "capacity: %9.2f %9.2f %9.2f %9.2f %9.2f %9.2f\n", (double)v53 * 100.0 / v56, (double)v54 * 100.0 / v56, (double)v57 * 100.0 / v56, (double)v58 * 100.0 / v56, (double)v59 * 100.0 / v56, (double)v60 * 100.0 / v56);
      }
    }
  }
  return result;
}

uint64_t btree_check(void *a1, uint64_t a2, int a3, int a4)
{
  return btree_check_ext(0, a1, a2, a3, a4);
}

uint64_t btree_check_recent_sanity(void *a1, unint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, unint64_t, uint64_t, void, uint64_t, void), uint64_t a4)
{
  uint64_t v51 = a4;
  unint64_t v52 = a3;
  uint64_t v6 = a1[1];
  if (!v6) {
    uint64_t v6 = *(void *)(*a1 + 392);
  }
  __chkstk_darwin();
  unint64_t v8 = (uint64_t *)((char *)&v51 - v7);
  bzero((char *)&v51 - v7, v9);
  uint64_t v55 = 0;
  uint64_t v56 = 0;
  int v53 = 0;
  unsigned int v54 = 0;
  obj_lock((uint64_t)a1, 1u);
  uint64_t v10 = btree_level_count((uint64_t)a1, &v54);
  if (v10)
  {
    uint64_t v11 = v10;
    obj_unlock((uint64_t)a1, 1u);
    return v11;
  }
  int v12 = _apfs_calloc(v54, 0x10uLL);
  if (!v12)
  {
    obj_unlock((uint64_t)a1, 1u);
    return 12;
  }
  int v13 = v12;
  void *v12 = a1;
  *((_WORD *)v12 + 4) = 0;
  obj_retain(a1);
  unsigned __int16 v14 = 0;
  while (1)
  {
    while (1)
    {
      uint64_t v15 = v14;
      unint64_t v16 = &v13[2 * v14];
      if (obj_xid(*v16) <= a2)
      {
        int v21 = (uint64_t *)*v16;
        goto LABEL_16;
      }
      double v17 = (char *)&v13[2 * v15];
      unsigned int v20 = *((unsigned __int16 *)v17 + 4);
      uint64_t v19 = v17 + 8;
      unsigned int v18 = v20;
      int v21 = (uint64_t *)*v16;
      uint64_t v22 = *(void *)(*v16 + 56);
      if (*(_DWORD *)(v22 + 36) > v20) {
        break;
      }
LABEL_16:
      btree_node_release(v21, 1);
      *unint64_t v16 = 0;
      unsigned __int16 v14 = v15 - 1;
      if ((((_WORD)v15 - 1) & 0x8000) != 0)
      {
LABEL_27:
        uint64_t v11 = 0;
        goto LABEL_30;
      }
    }
    if ((*(_WORD *)(v22 + 32) & 2) != 0) {
      break;
    }
    uint64_t v23 = btree_node_child_val((uint64_t)v21, v18, v8);
    if (v23)
    {
      uint64_t v11 = v23;
      obj_oid(*v16);
      double v38 = "%s:%d: %s node 0x%llx (level %d): error getting index %d child oid: %d\n";
LABEL_29:
      log_err((uint64_t)v38, v31, v32, v33, v34, v35, v36, v37, (uint64_t)"btree_check_recent_sanity");
      goto LABEL_30;
    }
    ++*v19;
    unsigned __int16 v24 = v15 + 1;
    if (v54 <= (__int16)v24)
    {
      obj_oid(v13[2 * (__int16)v24 - 2]);
      log_err((uint64_t)"%s:%d: %s node 0x%llx (level %d) index %d: more levels than expected\n", v44, v45, v46, v47, v48, v49, v50, (uint64_t)"btree_check_recent_sanity");
      uint64_t v11 = 22;
      goto LABEL_30;
    }
    unint64_t v25 = (char *)&v13[2 * (__int16)v24];
    *((_WORD *)v25 + 4) = 0;
    uint64_t v26 = (__int16)v24 - 1;
    uint64_t v27 = btree_node_get(a1, v8, 0, 2u, *(_WORD *)(*(void *)(v13[2 * v26] + 56) + 34) - 1, 0, (uint64_t **)v25);
    unsigned __int16 v14 = v24;
    if (v27)
    {
      uint64_t v11 = v27;
      obj_oid(v13[2 * v26]);
      double v38 = "%s:%d: %s node 0x%llx (level %d): error getting index %d child: %d\n";
      goto LABEL_29;
    }
    if ((v24 & 0x8000) != 0) {
      goto LABEL_27;
    }
  }
  if (!v52) {
    goto LABEL_16;
  }
  unsigned int v28 = 0;
  while (1)
  {
    uint64_t v29 = btree_node_key_ptr((uint64_t)v21, (unsigned __int16)v28, &v56, (_WORD *)&v53 + 1);
    if (v29
      || (uint64_t v29 = btree_node_val_ptr((void *)*v16, (unsigned __int16)v28, &v55, (__int16 *)&v53), v29))
    {
      uint64_t v11 = v29;
      obj_oid(*v16);
      double v38 = "%s:%d: %s node 0x%llx (level %d): error getting index %d key/val: %d\n";
      goto LABEL_29;
    }
    uint64_t v30 = v52(v6, v51, a2, v56, HIWORD(v53), v55, (unsigned __int16)v53);
    if (v30) {
      break;
    }
    ++v28;
    int v21 = (uint64_t *)*v16;
    if (v28 >= *(_DWORD *)(*(void *)(*v16 + 56) + 36)) {
      goto LABEL_16;
    }
  }
  uint64_t v11 = v30;
LABEL_30:
  unsigned int v39 = v54;
  if ((((_WORD)v54 - 1) & 0x8000) == 0)
  {
    unsigned __int16 v40 = v54 - 1;
    do
    {
      double v41 = (uint64_t *)v13[2 * v40];
      if (v41)
      {
        if (!v11) {
          sub_10005F32C();
        }
        btree_node_release(v41, 1);
      }
      int v42 = (__int16)v40--;
    }
    while (v42 > 0);
    unsigned int v39 = v54;
  }
  _apfs_free(v13, 16 * v39);
  return v11;
}

BOOL bitmap_range_is_set(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  unint64_t v6 = 0xFFFFFFFFFFFFFFFFLL >> ((v3 & 0xC0u) - a2);
  if (a3 >= 64)
  {
    while (((-1 << v5) & ~((-1 << v5) & *(void *)(a1 + 8 * v4))) == 0
         && (!v5 || (v6 & ~*(void *)(a1 + 8 * v4 + 8)) == 0))
    {
      uint64_t v7 = a3 - 64;
      ++v4;
      BOOL v8 = a3 <= 127;
      a3 -= 64;
      if (v8)
      {
        if (v7) {
          goto LABEL_13;
        }
        return 1;
      }
    }
    return 0;
  }
  uint64_t v7 = a3;
  if (!a3) {
    return 1;
  }
LABEL_13:
  unint64_t v9 = ~(-1 << v7);
  unint64_t v10 = v9 << v5;
  unint64_t v11 = v9 >> (64 - v5);
  if (!v5) {
    unint64_t v11 = 0;
  }
  return (v10 & ~((-1 << v5) & *(void *)(a1 + 8 * v4))) == 0
      && (v7 <= (uint64_t)(64 - v5) || !v11 || (v11 & ~(v6 & *(void *)(a1 + 8 * v4 + 8))) == 0);
}

uint64_t bitmap_range_is_clear(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v6 = 64 - v5;
  if (a3 >= 64)
  {
    while (((-1 << v5) & *(void *)(a1 + 8 * v4)) == 0
         && (!v5 || (*(void *)(a1 + 8 * v4 + 8) & (0xFFFFFFFFFFFFFFFFLL >> v6)) == 0))
    {
      uint64_t v7 = a3 - 64;
      ++v4;
      BOOL v8 = a3 <= 127;
      a3 -= 64;
      if (v8)
      {
        if (v7) {
          goto LABEL_13;
        }
        return 1;
      }
    }
    return 0;
  }
  uint64_t v7 = a3;
  if (a3)
  {
LABEL_13:
    unint64_t v9 = ~(-1 << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (!v5) {
      unint64_t v11 = 0;
    }
    if ((v10 & (-1 << v5) & *(void *)(a1 + 8 * v4)) != 0
      || v7 > v6 && v11 && ((0xFFFFFFFFFFFFFFFFLL >> v6) & v11 & *(void *)(a1 + 8 * v4 + 8)) != 0)
    {
      return 0;
    }
  }
  return 1;
}

uint64_t bitmap_set_range(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v6 = 64 - v5;
  if (a3 < 64)
  {
    uint64_t v7 = a3;
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }
  do
  {
    *(void *)(result + 8 * v4) = *(void *)(result + 8 * v4) & ~(-1 << v5) | (-1 << v5);
    if (v5) {
      *(void *)(result + 8 * v4 + 8) |= 0xFFFFFFFFFFFFFFFFLL >> v6;
    }
    uint64_t v7 = a3 - 64;
    ++v4;
    BOOL v8 = a3 <= 127;
    a3 -= 64;
  }
  while (!v8);
  if (v7)
  {
LABEL_12:
    unint64_t v9 = ~(-1 << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (!v5) {
      unint64_t v11 = 0;
    }
    *(void *)(result + 8 * v4) = *(void *)(result + 8 * v4) & ~v10 | v10 & (-1 << v5);
    if (v7 > v6)
    {
      if (v11) {
        *(void *)(result + 8 * v4 + 8) = *(void *)(result + 8 * v4 + 8) & ~v11 | v11 & (0xFFFFFFFFFFFFFFFFLL >> v6);
      }
    }
  }
  return result;
}

uint64_t bitmap_clear_range(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (a2 >= 0) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = a2 + 63;
  }
  uint64_t v4 = v3 >> 6;
  unint64_t v5 = a2 - (v3 & 0xFFFFFFFFFFFFFFC0);
  uint64_t v6 = 64 - v5;
  if (a3 < 64)
  {
    uint64_t v7 = a3;
    if (!a3) {
      return result;
    }
    goto LABEL_12;
  }
  do
  {
    *(void *)(result + 8 * v4) &= ~(-1 << v5);
    if (v5) {
      *(void *)(result + 8 * v4 + 8) &= ~(0xFFFFFFFFFFFFFFFFLL >> v6);
    }
    uint64_t v7 = a3 - 64;
    ++v4;
    BOOL v8 = a3 <= 127;
    a3 -= 64;
  }
  while (!v8);
  if (v7)
  {
LABEL_12:
    unint64_t v9 = ~(-1 << v7);
    unint64_t v10 = v9 << v5;
    unint64_t v11 = v9 >> v6;
    if (v5) {
      unint64_t v12 = v11;
    }
    else {
      unint64_t v12 = 0;
    }
    *(void *)(result + 8 * v4) &= ~v10;
    if (v7 > v6)
    {
      if (v12) {
        *(void *)(result + 8 * v4 + 8) &= ~v12;
      }
    }
  }
  return result;
}

uint64_t bitmap_range_find_first(int a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  if (a4 < 1) {
    return 0;
  }
  if (a1) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = -1;
  }
  uint64_t v6 = (unint64_t *)(a2 + 8 * (a3 / 64));
  while (1)
  {
    uint64_t v7 = a3 & 0x3F;
    if (a3 <= 0) {
      uint64_t v7 = -(-a3 & 0x3F);
    }
    unint64_t v8 = 64 - v7;
    unint64_t v10 = *v6++;
    unint64_t v9 = v10;
    if (64 - v7 >= (unint64_t)a4) {
      unint64_t v8 = a4;
    }
    unint64_t v11 = __clz(__rbit64((v9 >> v7) ^ v5));
    if (v8 > v11) {
      break;
    }
    a3 += v8;
    BOOL v12 = a4 <= (uint64_t)v8;
    a4 -= v8;
    if (v12) {
      return 0;
    }
  }
  *a5 = v11 + a3;
  return 1;
}

uint64_t bitmap_range_find_last_set(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a3 < 1) {
    return 0;
  }
  uint64_t v4 = a3 + a2;
  uint64_t v5 = a3 + a2 - 1;
  if (a3 + a2 < 1) {
    uint64_t v5 = a3 + a2 + 62;
  }
  uint64_t v6 = (uint64_t *)(a1 + 8 * (v5 >> 6));
  while (1)
  {
    if (v4 <= 0) {
      uint64_t v7 = -(-v4 & 0x3F);
    }
    else {
      uint64_t v7 = v4 & 0x3F;
    }
    char v8 = 64 - v7;
    if (!v7)
    {
      uint64_t v7 = 64;
      char v8 = 0;
    }
    if (v7 >= a3) {
      uint64_t v7 = a3;
    }
    uint64_t v9 = *v6--;
    int64_t v10 = __clz(v9 << v8);
    if (v7 > v10) {
      break;
    }
    v4 -= v7;
    BOOL v11 = a3 <= v7;
    a3 -= v7;
    if (v11) {
      return 0;
    }
  }
  *a4 = v4 + ~v10;
  return 1;
}

BOOL bitmap_range_find_desired_or_first_clear_range(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6, int a7)
{
  uint64_t v12 = 0;
  uint64_t v36 = 0;
  uint64_t v34 = a4 - 1;
  uint64_t v13 = -1;
  do
  {
    if (v12 >= a2) {
      break;
    }
    unint64_t v14 = a4 - a3;
    if (a4 - a3 < 1) {
      break;
    }
    uint64_t v15 = 8 * (a3 / 64);
    while (1)
    {
      uint64_t v16 = a3 & 0x3F;
      if (a3 <= 0) {
        uint64_t v16 = -(-a3 & 0x3F);
      }
      unint64_t v17 = 64 - v16;
      if (64 - v16 >= v14) {
        unint64_t v17 = v14;
      }
      unint64_t v18 = __clz(__rbit64(~(*(void *)(a1 + v15) >> v16)));
      if (v17 > v18) {
        break;
      }
      a3 += v17;
      v15 += 8;
      BOOL v19 = (uint64_t)v14 <= (uint64_t)v17;
      v14 -= v17;
      if (v19) {
        goto LABEL_46;
      }
    }
    uint64_t v20 = v18 + a3;
    if ((uint64_t)(v18 + a3) >= a4 - v12) {
      break;
    }
    if (!v12)
    {
      uint64_t v13 = v18 + a3;
      uint64_t v12 = 1;
      if (v20 >= v34)
      {
        uint64_t v13 = v18 + a3;
        uint64_t v12 = 1;
        break;
      }
    }
    uint64_t v21 = v12 + 1;
    if (v12 + 1 < a4 - v20) {
      uint64_t v22 = v12 + 1;
    }
    else {
      uint64_t v22 = a4 - v20;
    }
    if (v22 + v20 > a4) {
      sub_10005F358();
    }
    int v35 = a7;
    if (bitmap_range_find_last_set(a1, v20, v22, &v36))
    {
      uint64_t v23 = v36;
      a7 = v35;
    }
    else
    {
      uint64_t v24 = v21 + v20;
      uint64_t v25 = a4 - (v21 + v20);
      if (a4 < v21 + v20) {
        sub_10005F384();
      }
      if (a2 == v21)
      {
        uint64_t v13 = v20;
        uint64_t v12 = a2;
        break;
      }
      if (a2 - v21 < v25) {
        uint64_t v25 = a2 - v21;
      }
      if (v25 + v24 > a4) {
        sub_10005F3DC();
      }
      if (v25 < 1)
      {
LABEL_38:
        uint64_t v12 = v25 + v21;
      }
      else
      {
        uint64_t v26 = v24 + 63;
        if (v24 >= 0) {
          uint64_t v26 = v21 + v20;
        }
        uint64_t v27 = (unint64_t *)(a1 + 8 * (v26 >> 6));
        unint64_t v28 = v25;
        while (1)
        {
          uint64_t v29 = v24 & 0x3F;
          if (v24 <= 0) {
            uint64_t v29 = -(-v24 & 0x3F);
          }
          unint64_t v30 = 64 - v29;
          if (64 - v29 >= v28) {
            unint64_t v30 = v28;
          }
          unint64_t v31 = *v27++;
          unint64_t v32 = __clz(__rbit64(v31 >> v29));
          if (v30 > v32) {
            break;
          }
          v24 += v30;
          BOOL v19 = (uint64_t)v28 <= (uint64_t)v30;
          v28 -= v30;
          if (v19) {
            goto LABEL_38;
          }
        }
        uint64_t v12 = v32 + v24 - v20;
      }
      uint64_t v23 = v12 + v20;
      a7 = v35;
      if (v12 + v20 > a4) {
        sub_10005F408();
      }
      uint64_t v36 = v12 + v20;
      uint64_t v13 = v20;
    }
    a3 = v23 + 1;
  }
  while (!a7);
LABEL_46:
  if (v12 + v13 > a4) {
    sub_10005F3B0();
  }
  *a5 = v13;
  *a6 = v12;
  return v12 == a2;
}

BOOL bitmap_range_find_clear_range(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  return bitmap_range_find_desired_or_first_clear_range(a1, a2, a3, a4, a5, a6, 0);
}

BOOL bitmap_range_find_first_clear_range(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  return bitmap_range_find_desired_or_first_clear_range(a1, a2, a3, a4, a5, a6, 1);
}

unint64_t bitmap_count_bits(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a3 >= a4) {
    return 0;
  }
  unint64_t result = 0;
  if (a2) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = -1;
  }
  if (a2) {
    uint64_t v7 = -1;
  }
  else {
    uint64_t v7 = 0;
  }
  do
  {
    unint64_t v8 = a4 - a3;
    if (a4 - a3 < 1) {
      break;
    }
    uint64_t v9 = (unint64_t *)(a1 + 8 * (a3 / 64));
    while (1)
    {
      uint64_t v10 = a3 & 0x3F;
      if (a3 <= 0) {
        uint64_t v10 = -(-a3 & 0x3F);
      }
      unint64_t v11 = 64 - v10;
      unint64_t v13 = *v9++;
      unint64_t v12 = v13;
      if (64 - v10 >= v8) {
        unint64_t v11 = v8;
      }
      unint64_t v14 = __clz(__rbit64((v12 >> v10) ^ v6));
      if (v11 > v14) {
        break;
      }
      a3 += v11;
      BOOL v15 = (uint64_t)v8 <= (uint64_t)v11;
      v8 -= v11;
      if (v15) {
        return result;
      }
    }
    uint64_t v16 = v14 + a3;
    uint64_t v17 = a4 - (v14 + a3);
    if (v17 < 1) {
      return result - v16 + a4;
    }
    uint64_t v18 = v16 + 63;
    if (v16 >= 0) {
      uint64_t v18 = v14 + a3;
    }
    BOOL v19 = (unint64_t *)(a1 + 8 * (v18 >> 6));
    uint64_t v20 = v14 + a3;
    while (1)
    {
      uint64_t v21 = v20 & 0x3F;
      if (v20 <= 0) {
        uint64_t v21 = -(-v20 & 0x3F);
      }
      unint64_t v22 = 64 - v21;
      unint64_t v24 = *v19++;
      unint64_t v23 = v24;
      if (64 - v21 >= (unint64_t)v17) {
        unint64_t v22 = v17;
      }
      unint64_t v25 = __clz(__rbit64((v23 >> v21) ^ v7));
      if (v22 > v25) {
        break;
      }
      v20 += v22;
      BOOL v15 = v17 <= (uint64_t)v22;
      v17 -= v22;
      if (v15) {
        return result - v16 + a4;
      }
    }
    a3 = v25 + v20;
    unint64_t result = result - v16 + v25 + v20;
  }
  while ((uint64_t)(v25 + v20) < a4);
  return result;
}

uint64_t authapfs_valid_hash_type(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 <= 5 && (a1 & 0xFFFFFFFD) != 0) {
    return 0;
  }
  log_err((uint64_t)"%s:%d: Invalid or unknown hash type: %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"authapfs_valid_hash_type");
  return 22;
}

uint64_t authapfs_hash_size(int a1)
{
  if ((a1 - 1) > 4) {
    return 0;
  }
  else {
    return dword_10007EB68[a1 - 1];
  }
}

uint64_t sub_10002B59C(uint64_t a1, uint64_t a2, int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 <= 0xFFF) {
    sub_10005F434();
  }
  if (!a3) {
    sub_10005F460();
  }
  int v8 = *a3;
  if (*a3 > 5 || (*a3 & 0xFFFFFFFD) == 0)
  {
    log_err((uint64_t)"%s:%d: Invalid or unknown hash type: %d\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"authapfs_valid_hash_type");
    return 22;
  }
  else
  {
    uint64_t v10 = 0;
    *(void *)(a1 + 32) = 2;
    *(_DWORD *)(a1 + 40) = v8;
    *(_DWORD *)(a1 + 44) = 128;
  }
  return v10;
}

uint64_t sub_10002B624(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = *(_DWORD **)(a1 + 56);
  unsigned int v9 = v8[10];
  if (v9 - 1 > 4) {
    unsigned int v10 = 0;
  }
  else {
    unsigned int v10 = dword_10007EB68[v9 - 1];
  }
  if (v8[8])
  {
    uint64_t v11 = v8[11];
    if (v11 >= 0x30)
    {
      if (v9 > 5 || (v9 & 0xFFFFFFFD) == 0)
      {
        log_err((uint64_t)"%s:%d: Invalid or unknown hash type: %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"authapfs_valid_hash_type");
      }
      else if (*(_DWORD *)(a1 + 48) >= v11 + v10)
      {
        uint64_t v13 = 0;
        *(void *)(a1 + 376) = v8;
        *(void *)(a1 + 384) = (char *)v8 + v11;
        *(_DWORD *)(a1 + 392) = v10;
        return v13;
      }
    }
  }
  return 92;
}

uint64_t sub_10002B6DC(uint64_t a1, void *a2, int a3)
{
  if (!a1) {
    return 22;
  }
  if (!a2 && !a3) {
    return 22;
  }
  unint64_t v7 = *(void *)(*(void *)(a1 + 376) + 1024);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 392);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1728));
    uint64_t v9 = *(void *)(a1 + 3608);
    if (v9)
    {
      if (a2)
      {
        obj_retain(v9);
        *a2 = *(void *)(a1 + 3608);
      }
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1728));
      return 0;
    }
    BOOL v19 = 0;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1728));
    uint64_t result = obj_get(*(void *)(v8 + 392), 0, v7, (int *)&integrity_meta_desc, 0, a1, *(void *)(a1 + 432), 0, (uint64_t *)&v19);
    if (!result)
    {
      uint64_t v17 = v19;
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 3912));
      uint64_t v18 = (int32x2_t *)v17[47];
      *(int32x2_t *)(a1 + 3980) = vrev64_s32(v18[4]);
      *(int32x2_t *)(a1 + 3992) = v18[6];
      *(unsigned char *)(a1 + 3976) = 1;
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 3912));
      if (a3)
      {
        pthread_mutex_lock((pthread_mutex_t *)(a1 + 1728));
        if (!*(void *)(a1 + 3608))
        {
          obj_retain(v19);
          *(void *)(a1 + 3608) = v19;
        }
        pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1728));
      }
      if (!a2)
      {
        obj_release(v19);
        return 0;
      }
      uint64_t result = 0;
      *a2 = v19;
    }
  }
  else
  {
    obj_oid(a1);
    log_err((uint64_t)"%s:%d: %s integrity_meta object of fs %llu, oid invalid\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"authapfs_integrity_meta_get_internal");
    return 2;
  }
  return result;
}

uint64_t authapfs_get_hash_args(uint64_t a1, _DWORD *a2)
{
  uint64_t v8 = 0;
  if (!a2) {
    return 22;
  }
  uint64_t result = sub_10002B6DC(a1, &v8, 0);
  if (!result)
  {
    uint64_t v4 = (uint64_t *)v8;
    unsigned int v5 = *(_DWORD *)(v8 + 392);
    if (v5 >= 0x40) {
      size_t v6 = 64;
    }
    else {
      size_t v6 = v5;
    }
    unint64_t v7 = *(const void **)(v8 + 384);
    a2[6] = *(_DWORD *)(*(void *)(v8 + 376) + 40);
    a2[7] = v5;
    a2[5] |= 0x180u;
    memcpy(a2 + 8, v7, v6);
    obj_release(v4);
    return 0;
  }
  return result;
}

uint64_t authapfs_integrity_meta_create(uint64_t a1, int a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v32 = a2;
  unint64_t v31 = 0;
  if (!a1) {
    return 22;
  }
  if (*(_DWORD *)(a1 + 1100)) {
    return 30;
  }
  uint64_t v12 = *(void *)(a1 + 392);
  if (!a4 && *(void *)(*(void *)(a1 + 376) + 1024)) {
    return 17;
  }
  uint64_t v13 = obj_modify((void *)a1, 0, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (v13)
  {
    uint64_t v9 = v13;
    log_err((uint64_t)"%s:%d: %s obj_modify failed - %d\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"authapfs_integrity_meta_create");
  }
  else
  {
    uint64_t v21 = obj_create(*(pthread_mutex_t **)(v12 + 392), 0, 0, (unsigned int *)&integrity_meta_desc, (uint64_t)&v32, a1, a3, (uint64_t *)&v31);
    if (v21)
    {
      uint64_t v9 = v21;
      log_err((uint64_t)"%s:%d: %s obj_create failed - %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"authapfs_integrity_meta_create");
    }
    else
    {
      obj_dirty((uint64_t)v31, a3, 0);
      uint64_t v29 = obj_oid((uint64_t)v31);
      if (a4)
      {
        uint64_t v9 = 0;
        *a4 = v31;
      }
      else
      {
        *(void *)(*(void *)(a1 + 376) + 1024) = v29;
        fs_sb_dirty(a1, a3);
        obj_release(v31);
        return 0;
      }
    }
  }
  return v9;
}

uint64_t authapfs_seal_is_broken(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)(a1 + 1728);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 1728));
  uint64_t v5 = *(void *)(a1 + 3608);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 376);
    unint64_t v7 = (unsigned int *)(v6 + 36);
    uint64_t v8 = (unsigned int *)(v6 + 32);
    uint64_t v9 = (unint64_t *)(v6 + 48);
  }
  else
  {
    pthread_mutex_unlock(v4);
    if (!*(unsigned char *)(a1 + 3976)) {
      return 0;
    }
    uint64_t v4 = (pthread_mutex_t *)(a1 + 3912);
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 3912));
    unint64_t v7 = (unsigned int *)(a1 + 3980);
    uint64_t v8 = (unsigned int *)(a1 + 3984);
    uint64_t v9 = (unint64_t *)(a1 + 3992);
  }
  unint64_t v10 = *v9;
  unsigned int v11 = *v8;
  unsigned int v12 = *v7;
  pthread_mutex_unlock(v4);
  if (a2) {
    BOOL v13 = v11 >= 2;
  }
  else {
    BOOL v13 = 0;
  }
  int v14 = !v13;
  uint64_t result = v14 & v12;
  if (v13 && (v12 & 1) != 0) {
    return obj_xid(a2) >= v10;
  }
  return result;
}

void *authapfs_hexdump_hash(unsigned __int8 *a1, void *a2, unsigned int a3)
{
  unsigned int v6 = (2 * a3) | 1;
  bzero(a2, v6);
  if (a3)
  {
    uint64_t v7 = a3;
    uint64_t v8 = (char *)a2;
    do
    {
      int v9 = *a1++;
      int v10 = snprintf(v8, v6, "%02hhx", v9);
      v8 += v10;
      v6 -= v10;
      --v7;
    }
    while (v7);
  }
  return a2;
}

uint64_t authapfs_get_hash_info(int a1)
{
  switch(a1)
  {
    case 1:
      uint64_t result = ccsha256_di();
      break;
    case 2:
    case 5:
      uint64_t result = _ccsha512_256_di();
      break;
    case 3:
      uint64_t result = _ccsha384_di();
      break;
    case 4:
      uint64_t result = _ccsha512_di();
      break;
    default:
      uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t authapfs_should_hash_node(uint64_t a1)
{
  if (!a1) {
    sub_10005F48C();
  }
  if ((*(unsigned char *)(a1 + 21) & 4) != 0) {
    return 0;
  }
  if ((obj_type_and_flags(a1) & 0x8000000) != 0 || (*(unsigned char *)(a1 + 17) & 2) != 0)
  {
    LODWORD(v2) = 0;
  }
  else
  {
    uint64_t v2 = *(void *)(a1 + 8);
    if (v2) {
      LODWORD(v2) = (*(unsigned __int8 *)(*(void *)(v2 + 376) + 56) >> 5) & 1;
    }
  }
  if (*(_DWORD *)(a1 + 40) != 14) {
    return 0;
  }
  else {
    return v2 | ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 8) >> 3);
  }
}

uint64_t authapfs_validate_node_hash(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  memset(__s1, 0, sizeof(__s1));
  if (!a2) {
    return 22;
  }
  unsigned int v8 = a3;
  uint64_t result = authapfs_hash_node(a1, (uint64_t)__s1, a3, a4, a5, a6, a7, a8);
  if (!result)
  {
    uint64_t result = memcmp(__s1, a2, v8);
    if (result)
    {
      char v21 = 0;
      memset(v20, 0, sizeof(v20));
      char v19 = 0;
      memset(v18, 0, sizeof(v18));
      authapfs_hexdump_hash((unsigned __int8 *)a2, v18, v8);
      authapfs_hexdump_hash((unsigned __int8 *)__s1, v20, v8);
      log_err((uint64_t)"%s:%d: hash mismatch! expected: %s, actual: %s\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"authapfs_validate_node_hash");
      return 80;
    }
  }
  return result;
}

uint64_t authapfs_hash_node(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result = 22;
  if (a2 && (*(_WORD *)(*(void *)(a1 + 56) + 32) & 8) != 0)
  {
    int v10 = a4;
    int v11 = a3;
    if (authapfs_valid_hash_type(a4, a2, a3, a4, a5, a6, a7, a8)
      || authapfs_hash_size(v10) != v11)
    {
      return 22;
    }
    else
    {
      authapfs_get_hash_info(v10);
      obj_size_phys(a1);
      ccdigest();
      return 0;
    }
  }
  return result;
}

uint64_t authapfs_validate_node(uint64_t a1, uint64_t a2)
{
  if (!authapfs_should_hash_node(a1)) {
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  unint64_t v5 = *(void *)(a1 + 400);
  if (obj_subtype(a1) != 255 && !v4) {
    sub_10005F4B8();
  }
  if (byte_100084688 & 1) == 0 || (authapfs_seal_is_broken(v4, a1)) {
    return 0;
  }
  memset(__s2, 0, sizeof(__s2));
  if (!a2) {
    return a2;
  }
  uint64_t v7 = (void *)(a2 + 32);
  if (!memcmp(v7, __s2, HIWORD(v5) & 0x7F)) {
    return 0;
  }
  a2 = authapfs_validate_node_hash(a1, v7, HIWORD(v5) & 0x7F, (v5 >> 44) & 0xF, v8, v9, v10, v11);
  if (a2)
  {
    obj_oid(a1);
    obj_xid(a1);
    obj_oid(v4);
    log_err((uint64_t)"failed to validate node %p (oid:%llu, xid:%llu) of fs %p (%llu) - %d\n", v12, v13, v14, v15, v16, v17, v18, a1);
  }
  return a2;
}

const char *apfs_source_version()
{
  return "2317.60.23.0.1";
}

uint64_t apfs_source_version_val_full()
{
  return 0x83B5A93981BC1;
}

uint64_t apfs_set_formatted_by(uint64_t a1, const char *a2, uint64_t a3)
{
  unsigned int v6 = (char *)(a1 + 272);
  uint64_t v7 = apfs_source_version();
  unsigned int v8 = snprintf(v6, 0x20uLL, "%s (%s)", a2, v7);
  if ((v8 & 0x80000000) != 0) {
    sub_10005F4E4();
  }
  if (v8 >= 0x20)
  {
    size_t v9 = strlen(v7);
    if (v9 + 4 >= 0x21) {
      sub_10005F510();
    }
    snprintf((char *)(a1 - v9 + 300), v9 + 4, " (%s)", v7);
  }
  uint64_t result = get_timestamp();
  *(void *)(a1 + 304) = result;
  *(void *)(a1 + 312) = a3;
  return result;
}

BOOL nx_is_panic_on_corruption_enabled(uint64_t a1)
{
  if (a1) {
    return *(unsigned char *)(a1 + 637) != 0;
  }
  else {
    return apfs_corruption_panics & 1;
  }
}

uint64_t nx_calculate_metadata_parameters(unsigned int a1, unint64_t a2, unint64_t a3, unsigned int a4, uint64_t a5)
{
  *(void *)(a5 + 208) = 0;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  uint64_t v5 = 22;
  *(_OWORD *)a5 = 0u;
  if (a1 - 65537 < 0xFFFF0FFF || !a2) {
    return v5;
  }
  unint64_t v6 = 8 * a1;
  unint64_t v7 = a1 - 40;
  *(void *)(a5 + 88) = v7 >> 5;
  *(void *)(a5 + 96) = v7 >> 3;
  *(void *)(a5 + 8) = a1;
  *(void *)(a5 + 16) = a2;
  unint64_t v8 = (a2 + v6 - 1) / v6;
  uint64_t v9 = (v7 >> 5) - 1;
  unint64_t v10 = (v9 + v8) / (v7 >> 5);
  *(void *)(a5 + 24) = v8;
  *(void *)(a5 + 32) = v10;
  uint64_t v11 = (v7 >> 3) - 1;
  unint64_t v12 = (v11 + v10) / (v7 >> 3);
  if (v12 == 1) {
    unint64_t v13 = 0;
  }
  else {
    unint64_t v13 = (v11 + v10) / (v7 >> 3);
  }
  *(void *)(a5 + 40) = v13;
  *(void *)(a5 + 48) = a3;
  unint64_t v14 = (a3 + v6 - 1) / v6;
  unint64_t v15 = (v9 + v14) / (v7 >> 5);
  *(void *)(a5 + 56) = v14;
  *(void *)(a5 + 64) = v15;
  unint64_t v16 = (v11 + v15) / (v7 >> 3);
  if (v16 == 1) {
    unint64_t v17 = 0;
  }
  else {
    unint64_t v17 = v16;
  }
  *(void *)(a5 + 72) = v17;
  *(void *)(a5 + 80) = v6;
  uint64_t v18 = 3 * (v10 + v8 + v14 + v15 + v13 + v17);
  *(void *)(a5 + 104) = v18;
  unint64_t v19 = (unint64_t)(v18 + 63) >> 6;
  unint64_t v20 = (a1 - 1 + 8 * v19) / a1;
  if (HIDWORD(v20)) {
    return 27;
  }
  *(void *)(a5 + 112) = v20;
  *(void *)(a5 + 120) = 16;
  if (v20 < 0x1000)
  {
    uint64_t v21 = 16 * v20;
    goto LABEL_14;
  }
  if (v20 >> 13) {
    return 27;
  }
  uint64_t v21 = 65534;
LABEL_14:
  *(void *)(a5 + 128) = v21;
  uint64_t v22 = (2 * v21 + 6) & 0x7FFFFFFFFFFFFFF8;
  if (v13) {
    unint64_t v10 = v12;
  }
  if (v17) {
    unint64_t v23 = v16;
  }
  else {
    unint64_t v23 = v15;
  }
  unint64_t v24 = ((2 * v20 + 6) & 0x7FFFFFFFFFFFFFF8) + 8 * (v20 + v10 + v23) + v22 + 2520;
  if (v24 > 0x100000) {
    return 27;
  }
  if (v24 % a1) {
    unint64_t v24 = a1 - 1 + v24 - (a1 - 1 + v24) % a1;
  }
  *(void *)(a5 + 136) = v24;
  unint64_t v26 = (a1 - 96 - (((((18725 * ((unsigned __int16)(a1 - 96) >> 2)) >> 15) & 0x3FFC) + 28) & 0x7FE0))
      / 0x30uLL;
  unint64_t v27 = 0x200000 / a1;
  uint64_t v28 = 15;
  if (a2 >= 0x100000) {
    uint64_t v29 = 15;
  }
  else {
    uint64_t v29 = 31;
  }
  if (a2 >= 0x100000) {
    char v30 = 4;
  }
  else {
    char v30 = 5;
  }
  if (a2 < 0x40000)
  {
    uint64_t v29 = 63;
    char v30 = 6;
  }
  unint64_t v31 = (v29 + a2) >> v30;
  unint64_t v32 = v26 - 1;
  unint64_t v33 = (v26 - 1 + v31) / v26;
  if (v33 >= v27) {
    unint64_t v33 = 0x200000 / a1;
  }
  if (v33 == 2) {
    unint64_t v33 = 3;
  }
  if (a3 >= 0x100000)
  {
    char v34 = 4;
  }
  else
  {
    uint64_t v28 = 31;
    char v34 = 5;
  }
  if (a3 < 0x40000)
  {
    uint64_t v28 = 63;
    char v34 = 6;
  }
  unint64_t v35 = (v32 + ((v28 + a3) >> v34)) / v26;
  if (v35 >= v27) {
    unint64_t v35 = 0x200000 / a1;
  }
  if (v35 == 2) {
    unint64_t v35 = 3;
  }
  *(void *)(a5 + 152) = v33;
  *(void *)(a5 + 160) = v35;
  unint64_t v36 = a3 + a2;
  if ((a3 + a2) >> 18)
  {
    if (v36 >> 20) {
      unint64_t v19 = (unint64_t)(v18 + 15) >> 4;
    }
    else {
      unint64_t v19 = (unint64_t)(v18 + 31) >> 5;
    }
  }
  unint64_t v37 = (v32 + v19) / v26;
  if (v37 >= v27) {
    unint64_t v37 = 0x200000 / a1;
  }
  if (v37 == 2) {
    unint64_t v37 = 3;
  }
  *(void *)(a5 + 144) = v37;
  uint64_t v38 = v24 / a1;
  uint64_t v39 = v38 - 1;
  if (v38 <= 1) {
    uint64_t v39 = 0;
  }
  uint64_t v40 = 8;
  if (v33 < 8) {
    uint64_t v40 = v33;
  }
  *(void *)(a5 + 192) = 4;
  *(void *)(a5 + 200) = v40;
  if (a4)
  {
    if (a4 > 0x64) {
      return 22;
    }
  }
  else
  {
    int v41 = v36 * a1;
    unint64_t v42 = (v36 * a1) >> 29;
    if ((v41 & 0x1FFFFFFF) != 0) {
      unint64_t v43 = v42 + 1;
    }
    else {
      unint64_t v43 = v42;
    }
    if (v43 >= 0x64) {
      a4 = 100;
    }
    else {
      a4 = v43;
    }
  }
  *(void *)(a5 + 184) = a4;
  uint64_t v44 = v40 * a4;
  uint64_t v45 = 2;
  if (a3) {
    uint64_t v45 = 3;
  }
  uint64_t v46 = v45 + v33 + v35 + v37 + v38 + v39 + 8 * v44;
  *(void *)(a5 + 168) = 4
                        * ((unsigned __int16)(v46 + (unsigned __int16)(a1 - 40) / 0x28u - 1)
                         / ((unsigned __int16)(a1 - 40)
                          / 0x28u))
                        + 4;
  *(void *)(a5 + 176) = 4 * v46;
  *(void *)(a5 + 208) = 0;
  uint64_t v5 = 0;
  if (a3)
  {
    unint64_t v47 = (unint64_t)&_mh_execute_header;
    if (0x800000000uLL / a1 < a2) {
      unint64_t v47 = 0x200000000;
    }
    unint64_t v48 = v47 / a1;
    if (v48 >= a2 / 5) {
      unint64_t v48 = a2 / 5;
    }
    *(void *)(a5 + 208) = v48;
  }
  return v5;
}

uint64_t nx_get_evict_mapping_tree(uint64_t a1, unsigned int a2, unint64_t a3, int a4, int a5, uint64_t **a6)
{
  *(void *)&long long v20 = 0;
  long long v21 = 0u;
  uint64_t v25 = 0;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  unint64_t v19 = evict_mapping_key_compare;
  DWORD2(v20) = 33;
  HIDWORD(v20) = a4;
  uint64_t result = btree_get_extended(a1, a2, a3, 0, 0, (uint64_t)&v19, 0, a6);
  if (result == 92 && a5)
  {
    long long v20 = 0u;
    long long v21 = 0u;
    uint64_t v25 = 0;
    long long v23 = 0u;
    long long v24 = 0u;
    long long v22 = 0u;
    unint64_t v19 = evict_mapping_key_compare;
    HIDWORD(v20) = a4;
    uint64_t result = btree_get_extended(a1, 0, a3, 0, 0, (uint64_t)&v19, 0, a6);
    if (!result)
    {
      log_debug((uint64_t)"%s:%d: %s found mapping tree with old subtype\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"nx_get_evict_mapping_tree");
      return 0;
    }
  }
  return result;
}

uint64_t sub_10002C554(uint64_t a1, int a2, uint64_t a3)
{
  if (!a3) {
    return 22;
  }
  if (*(_DWORD *)(a3 + 4) != a2) {
    sub_10005F53C();
  }
  *(_DWORD *)(a1 + 32) = 1112758350;
  *(_DWORD *)(a1 + 36) = a2;
  *(void *)(a1 + 1264) = 0;
  *(_OWORD *)(a1 + 40) = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(a1 + 56) = xmmword_10007EB80;
  uint64_t v5 = *(void *)(a3 + 32);
  *(void *)(a1 + 88) = 1024;
  *(void *)(a1 + 96) = v5;
  uuid_copy((unsigned __int8 *)(a1 + 72), (const unsigned __int8 *)(a3 + 64));
  unint64_t v6 = (const unsigned __int8 *)(a3 + 80);
  if (uuid_is_null(v6)) {
    return 0;
  }
  uuid_copy((unsigned __int8 *)(a1 + 1280), v6);
  uint64_t result = 0;
  *(void *)(a1 + 64) |= 0x100uLL;
  return result;
}

uint64_t sub_10002C604(uint64_t a1, unsigned int *a2)
{
  if (!a2) {
    return 22;
  }
  uint64_t v3 = *(void *)(a1 + 56);
  unsigned int v4 = *a2;
  *(_DWORD *)(a1 + 648) = *a2;
  *(_DWORD *)(a1 + 652) = *(_DWORD *)(v3 + 36) / v4;
  uint64_t v5 = *((void *)a2 + 3);
  *(void *)(a1 + 376) = v3;
  *(void *)(a1 + 384) = v5;
  LODWORD(v5) = a2[11];
  *(unsigned char *)(a1 + 627) = a2[10] != 0;
  *(unsigned char *)(a1 + 628) = v5 != 0;
  LODWORD(v5) = a2[13];
  *(unsigned char *)(a1 + 629) = a2[12] != 0;
  *(unsigned char *)(a1 + 631) = v5 != 0;
  LODWORD(v5) = a2[15];
  *(unsigned char *)(a1 + 632) = a2[14] != 0;
  *(unsigned char *)(a1 + 633) = v5 != 0;
  *(void *)(a1 + 392) = *(void *)a1;
  new_lock((pthread_mutex_t *)(a1 + 656));
  new_lock((pthread_mutex_t *)(a1 + 848));
  *(void *)(a1 + 912) = nx_keybag_init(a1);
  *(void *)(a1 + 920) = 0;
  new_rwlock((pthread_rwlock_t *)(a1 + 928));
  *(void *)(a1 + 1128) = 0;
  *(void *)(a1 + 1336) = 0;
  *(unsigned char *)(a1 + 635) = 0;
  new_lock((pthread_mutex_t *)(a1 + 1856));
  new_rwlock((pthread_rwlock_t *)(a1 + 1136));
  new_lock((pthread_mutex_t *)(a1 + 736));
  *(void *)(a1 + 812) = 0;
  *(void *)(a1 + 800) = 0;
  *(_WORD *)(a1 + 808) = 0;
  new_lock((pthread_mutex_t *)(a1 + 504));
  new_cv((pthread_cond_t *)(a1 + 568));
  return 0;
}

uint64_t sub_10002C758(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 720);
  if (v2 && !*(_DWORD *)(*(void *)a1 + 912)) {
    obj_release(v2);
  }
  free_rwlock((pthread_rwlock_t *)(a1 + 928));
  free_rwlock((pthread_rwlock_t *)(a1 + 1136));
  free_lock((pthread_mutex_t *)(a1 + 848));
  free_lock((pthread_mutex_t *)(a1 + 656));
  nx_keybag_free(*(void *)(a1 + 912));
  free_lock((pthread_mutex_t *)(a1 + 1856));
  free_lock((pthread_mutex_t *)(a1 + 736));
  free_lock((pthread_mutex_t *)(a1 + 504));
  free_cv((pthread_cond_t *)(a1 + 568));
  return 0;
}

uint64_t nx_fusion_superblock_write(uint64_t a1, const void *a2)
{
  uint64_t v2 = *(void *)(a1 + 376);
  if ((*(unsigned char *)(v2 + 65) & 1) == 0) {
    return 0;
  }
  unint64_t v6 = _apfs_malloc(*(unsigned int *)(v2 + 36));
  memcpy(v6, a2, *(unsigned int *)(*(void *)(a1 + 376) + 36));
  v6[1295] |= 1u;
  obj_checksum_set_phys(a1, (unint64_t *)v6, *(_DWORD *)(*(void *)(a1 + 376) + 36), v7, v8);
  uint64_t v9 = dev_write(*(void *)(a1 + 384), 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36))));
  _apfs_free(v6, *(unsigned int *)(*(void *)(a1 + 376) + 36));
  return v9;
}

uint64_t nx_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v97 = 0;
  uint64_t v98 = 0;
  uint64_t v96 = 0;
  uint64_t v95 = 0;
  uint64_t v6 = spaceman_get((void *)a1, &v98);
  if (v6)
  {
    uint64_t v14 = v6;
    uint64_t v15 = *(void *)(a1 + 400);
    if (v15 && *(_DWORD *)(v15 + 76)) {
      return v14;
    }
    int v16 = 831;
    log_err((uint64_t)"%s:%d: %s failed to get spaceman oid %lld for checkpoint %s traverse: %d\n", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"nx_checkpoint_traverse");
    goto LABEL_9;
  }
  uint64_t v14 = spaceman_checkpoint_traverse((pthread_mutex_t **)a1, a2, (uint64_t)v98, a3);
  obj_release(v98);
  if (v14)
  {
    uint64_t v24 = *(void *)(a1 + 400);
    if (v24 && *(_DWORD *)(v24 + 76)) {
      return v14;
    }
    int v16 = 838;
    log_err((uint64_t)"%s:%d: %s spaceman checkpoint %s traverse failed: %d\n", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"nx_checkpoint_traverse");
    goto LABEL_9;
  }
  uint64_t v27 = *(void *)(a1 + 376);
  unint64_t v28 = *(void *)(v27 + 160);
  if (v28 && !*(_DWORD *)(a1 + 728))
  {
    uint64_t v38 = obj_get(*(void *)(a1 + 392), 0x40000000, v28, (int *)&om_desc, 0, 0, 0, 0, (uint64_t *)&v96);
    if (v38)
    {
      uint64_t v14 = v38;
      uint64_t v46 = *(void *)(a1 + 400);
      if (v46 && *(_DWORD *)(v46 + 76)) {
        return v14;
      }
      int v16 = 848;
      log_err((uint64_t)"%s:%d: %s failed to get omap for checkpoint %s traverse: %d\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"nx_checkpoint_traverse");
      goto LABEL_9;
    }
    uint64_t v14 = omap_checkpoint_traverse(a1, a2, (uint64_t)v96, a3);
    obj_release(v96);
    if (v14)
    {
      uint64_t v62 = *(void *)(a1 + 400);
      if (v62 && *(_DWORD *)(v62 + 76)) {
        return v14;
      }
      int v16 = 854;
      log_err((uint64_t)"%s:%d: %s omap checkpoint %s traverse failed: %d\n", v55, v56, v57, v58, v59, v60, v61, (uint64_t)"nx_checkpoint_traverse");
      goto LABEL_9;
    }
    uint64_t v27 = *(void *)(a1 + 376);
  }
  if (*(void *)(v27 + 168))
  {
    uint64_t v29 = nx_reaper_get((void *)a1, &v97);
    if (v29)
    {
      uint64_t v14 = v29;
      uint64_t v37 = *(void *)(a1 + 400);
      if (v37 && *(_DWORD *)(v37 + 76)) {
        return v14;
      }
      int v16 = 867;
      log_err((uint64_t)"%s:%d: %s failed to get reaper for checkpoint %s traverse: %d\n", v30, v31, v32, v33, v34, v35, v36, (uint64_t)"nx_checkpoint_traverse");
      goto LABEL_9;
    }
    uint64_t v14 = nx_reaper_checkpoint_traverse((uint64_t *)a1, a2, (uint64_t)v97, a3);
    obj_release(v97);
    if (v14)
    {
      uint64_t v54 = *(void *)(a1 + 400);
      if (v54 && *(_DWORD *)(v54 + 76)) {
        return v14;
      }
      int v16 = 874;
      log_err((uint64_t)"%s:%d: %s nx reaper checkpoint %s traverse failed: %d\n", v47, v48, v49, v50, v51, v52, v53, (uint64_t)"nx_checkpoint_traverse");
      goto LABEL_9;
    }
    uint64_t v27 = *(void *)(a1 + 376);
  }
  if (!*(_DWORD *)(v27 + 180))
  {
LABEL_39:
    if (!*(void *)(v27 + 1344) || !obj_type_is_or_contains_ephemeral(*(_DWORD *)(v27 + 176))) {
      return 0;
    }
    v94[0] = 0;
    v94[1] = 0;
    uint64_t v93 = 0;
    unsigned int v92 = 0;
    uint64_t v14 = obj_descriptor_and_flags_for_type(*(_DWORD *)(*(void *)(a1 + 376) + 176), &v92, (uint64_t)v94);
    HIDWORD(v94[0]) = 255;
    if (!v14)
    {
      uint64_t v14 = obj_get(*(void *)(a1 + 392), v92, *(void *)(*(void *)(a1 + 376) + 1344), (int *)v94, 0, 0, 0, 0, (uint64_t *)&v93);
      if (!v14)
      {
        uint64_t v14 = obj_checkpoint_traverse(a1, a2, (uint64_t)v93, a3);
        obj_release(v93);
        if (!v14) {
          return v14;
        }
        uint64_t v91 = *(void *)(a1 + 400);
        if (v91)
        {
          if (*(_DWORD *)(v91 + 76)) {
            return v14;
          }
        }
        int v16 = 931;
        log_err((uint64_t)"%s:%d: %s failed to checkpoint %s traverse test object 0x%llx of type 0x%x/0x%x: %d\n", v84, v85, v86, v87, v88, v89, v90, (uint64_t)"nx_checkpoint_traverse");
        uint64_t v25 = *(void *)(a1 + 400);
        if (!v25) {
          return v14;
        }
LABEL_10:
        *(_DWORD *)(v25 + 76) = v16;
        ++*(_WORD *)(v25 + 80);
        return v14;
      }
    }
    uint64_t v80 = *(void *)(a1 + 400);
    if (v80 && *(_DWORD *)(v80 + 76)) {
      return v14;
    }
    int v16 = 925;
    uint64_t v81 = "%s:%d: %s unable to get test object 0x%llx of type 0x%x/0x%x for checkpoint %s traverse: %d\n";
LABEL_50:
    log_err((uint64_t)v81, v66, v67, v68, v69, v70, v71, v72, (uint64_t)"nx_checkpoint_traverse");
LABEL_9:
    uint64_t v25 = *(void *)(a1 + 400);
    if (!v25) {
      return v14;
    }
    goto LABEL_10;
  }
  uint64_t v63 = 0;
  while (1)
  {
    unint64_t v64 = *(void *)(v27 + 8 * v63 + 184);
    if (v64) {
      break;
    }
LABEL_38:
    if (++v63 >= (unint64_t)*(unsigned int *)(v27 + 180)) {
      goto LABEL_39;
    }
  }
  uint64_t v65 = obj_get(*(void *)(a1 + 392), 0, v64, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v95);
  if (v65)
  {
    uint64_t v14 = v65;
    uint64_t v82 = *(void *)(a1 + 400);
    if (!v82 || !*(_DWORD *)(v82 + 76))
    {
      int v16 = 898;
      uint64_t v81 = "%s:%d: %s failed to get fs[%d] oid %lld for checkpoint %s traverse: %d\n";
      goto LABEL_50;
    }
    return v14;
  }
  uint64_t v14 = apfs_checkpoint_traverse(a1, a2, (uint64_t)v95, a3);
  obj_release(v95);
  if (!v14)
  {
    uint64_t v27 = *(void *)(a1 + 376);
    goto LABEL_38;
  }
  uint64_t v83 = *(void *)(a1 + 400);
  if (!v83 || !*(_DWORD *)(v83 + 76))
  {
    int v16 = 904;
    log_err((uint64_t)"%s:%d: %s fs[%d] checkpoint %s traverse failed: %d\n", v73, v74, v75, v76, v77, v78, v79, (uint64_t)"nx_checkpoint_traverse");
    goto LABEL_9;
  }
  return v14;
}

uint64_t nx_reaper_get(void *a1, void *a2)
{
  if (!a1) {
    sub_10005F568();
  }
  uint64_t v4 = a1[53];
  *a2 = v4;
  if (v4) {
    goto LABEL_3;
  }
  uint64_t result = obj_get(a1[49], 0x80000000, *(void *)(a1[47] + 168), &nx_reaper_desc, 0, 0, 0, 0, a2);
  if (!result)
  {
    a1[53] = *a2;
    uint64_t v4 = *a2;
LABEL_3:
    obj_retain(v4);
    return 0;
  }
  return result;
}

uint64_t nx_reaper_checkpoint_traverse(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = a4;
  uint64_t v6 = *(void *)(a3 + 376);
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  uint64_t v51 = 0;
  if (a4 == 2)
  {
    uint64_t v7 = obj_checkpoint_known(a3);
LABEL_5:
    uint64_t v8 = v7;
    if (v7)
    {
      LODWORD(v9) = *(_DWORD *)(v6 + 68);
      uint64_t v10 = (_DWORD *)(v6 + 68);
      goto LABEL_76;
    }
    goto LABEL_7;
  }
  if (a4 == 1)
  {
    uint64_t v7 = obj_checkpoint_start(a3);
    goto LABEL_5;
  }
LABEL_7:
  if (*(void *)(v6 + 88) && obj_type_is_or_contains_ephemeral(*(_DWORD *)(v6 + 72)))
  {
    uint64_t v8 = 0;
    if ((*(_DWORD *)(v6 + 104) & 0x10) == 0 && (*(_DWORD *)(v6 + 104) & 6) != 2)
    {
      uint64_t v11 = nx_reaper_obj_get(a1, *(_DWORD *)(v6 + 72), *(_DWORD *)(v6 + 76), *(void *)(v6 + 80), *(void *)(v6 + 88), &v51, &v52);
      if (v11)
      {
        uint64_t v8 = v11;
        uint64_t v19 = a1[50];
        if (!v19 || !*(_DWORD *)(v19 + 76)) {
          log_err((uint64_t)"%s:%d: %s failed to get object oid %lld: %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"nx_reaper_checkpoint_traverse");
        }
      }
      else
      {
        if (v51) {
          uint64_t v47 = v51;
        }
        else {
          uint64_t v47 = a1;
        }
        uint64_t v8 = obj_checkpoint_traverse((uint64_t)v47, a2, (uint64_t)v52, v4);
        obj_release(v52);
      }
      if (v51)
      {
        obj_release(v51);
        uint64_t v51 = 0;
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
  }
  uint64_t v10 = (_DWORD *)(v6 + 68);
  uint64_t v9 = *(unsigned int *)(v6 + 68);
  if (v8) {
    goto LABEL_76;
  }
  unint64_t v20 = *(void *)(v6 + 48);
  if (!v20) {
    goto LABEL_76;
  }
  unsigned int v49 = v4;
  do
  {
    uint64_t v21 = obj_get(a1[49], 0x80000000, v20, (int *)&nx_reap_list_desc, 0, 0, 0, 0, (uint64_t *)&v53);
    if (v21)
    {
      uint64_t v8 = v21;
      uint64_t v44 = a1[50];
      if (!v44 || !*(_DWORD *)(v44 + 76)) {
        log_err((uint64_t)"%s:%d: %s failed to get reap list object oid %lld: %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_reaper_checkpoint_traverse");
      }
      break;
    }
    uint64_t v29 = v53[47];
    if (v4 == 2)
    {
      uint64_t v30 = obj_checkpoint_known((uint64_t)v53);
      goto LABEL_24;
    }
    if (v4 == 1)
    {
      uint64_t v30 = obj_checkpoint_start((uint64_t)v53);
LABEL_24:
      uint64_t v8 = v30;
      goto LABEL_26;
    }
    uint64_t v8 = 0;
LABEL_26:
    uint64_t v50 = v9;
    unint64_t v20 = *(void *)(v29 + 32);
    if (v8) {
      goto LABEL_57;
    }
    unsigned int v31 = *(_DWORD *)(v29 + 52);
    if (v31 == -1) {
      goto LABEL_57;
    }
    unsigned int v32 = -1;
    while (1)
    {
      unsigned int v33 = *(_DWORD *)(v29 + 40 * v31 + 64);
      if (v33 != -1 && v33 > *(_DWORD *)(v29 + 44)) {
        break;
      }
      uint64_t v34 = v29 + 40 * v31;
      int v37 = *(_DWORD *)(v34 + 72);
      uint64_t v36 = (int *)(v34 + 72);
      int v35 = v37;
      if ((v37 != *(_DWORD *)(v6 + 72) || *(void *)(v29 + 40 * v31 + 88) != *(void *)(v6 + 88))
        && (v32 == -1
         || v35 != *(_DWORD *)(v29 + 40 * v32 + 72)
         || *(void *)(v29 + 64 + 40 * v31 + 24) != *(void *)(v29 + 64 + 40 * v32 + 24)))
      {
        uint64_t v8 = 0;
        if ((*(_DWORD *)(v29 + 40 * v31 + 68) & 0x10) != 0 || (*(_DWORD *)(v29 + 40 * v31 + 68) & 6) == 2) {
          goto LABEL_50;
        }
        if (obj_type_is_or_contains_ephemeral(v35))
        {
          uint64_t v38 = nx_reaper_obj_get(a1, *v36, *(_DWORD *)(v29 + 40 * v31 + 76), *(void *)(v29 + 40 * v31 + 80), *(void *)(v29 + 40 * v31 + 88), &v51, &v52);
          if (v38)
          {
            uint64_t v8 = v38;
            uint64_t v39 = a1[50];
            if (!v39 || !*(_DWORD *)(v39 + 76)) {
              log_err((uint64_t)"%s:%d: %s failed to get object oid %lld: %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_reaper_checkpoint_traverse");
            }
          }
          else
          {
            if (v51) {
              uint64_t v40 = v51;
            }
            else {
              uint64_t v40 = a1;
            }
            uint64_t v8 = obj_checkpoint_traverse((uint64_t)v40, a2, (uint64_t)v52, v49);
            obj_release(v52);
          }
          if (v51)
          {
            obj_release(v51);
            uint64_t v51 = 0;
          }
          goto LABEL_50;
        }
      }
      uint64_t v8 = 0;
LABEL_50:
      if (!v8)
      {
        unsigned int v32 = v31;
        unsigned int v31 = v33;
        if (v33 != -1) {
          continue;
        }
      }
      goto LABEL_57;
    }
    uint64_t v41 = a1[50];
    if (!v41 || !*(_DWORD *)(v41 + 76)) {
      log_err((uint64_t)"%s:%d: %s Invalid reap list entry nrl_entries[%d].nrle_next = %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_reaper_checkpoint_traverse");
    }
    obj_release(v53);
    uint64_t v8 = nx_corruption_detected_int((uint64_t)a1);
LABEL_57:
    uint64_t v10 = (_DWORD *)(v6 + 68);
    if (*(_DWORD *)(v6 + 68))
    {
      uint64_t v9 = (v50 - 1);
      if (v20 && v50 == 1)
      {
        uint64_t v42 = a1[50];
        LODWORD(v4) = v49;
        if (!v42 || !*(_DWORD *)(v42 + 76)) {
          log_err((uint64_t)"%s:%d: %s reap list expected %u objects, but haven't seen last reap list object yet\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_reaper_checkpoint_traverse");
        }
        uint64_t v8 = nx_corruption_detected_int((uint64_t)a1);
        uint64_t v9 = 0;
      }
      else
      {
        LODWORD(v4) = v49;
        if (!v20 && v50 != 1)
        {
          uint64_t v43 = a1[50];
          if (!v43 || !*(_DWORD *)(v43 + 76)) {
            log_warn((uint64_t)"%s:%d: %s reap list expected %u objects, but got last reap list object with %u more objects left\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_reaper_checkpoint_traverse");
          }
        }
      }
    }
    else
    {
      LODWORD(v4) = v49;
      uint64_t v9 = v50;
    }
    obj_release(v53);
  }
  while (!v8 && v20);
LABEL_76:
  if (*v10) {
    BOOL v45 = v9 == 0;
  }
  else {
    BOOL v45 = 1;
  }
  if (!v45) {
    sub_10005F594();
  }
  return v8;
}

uint64_t sub_10002D4FC(uint64_t a1, int a2)
{
  *(void *)(a1 + 32) = 1;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 108) = (a2 & 0xFFFFFFFC) - 112;
  return 0;
}

uint64_t sub_10002D520(void *a1)
{
  uint64_t v2 = a1[7];
  unint64_t v4 = *(void *)(v2 + 32);
  unint64_t v3 = *(void *)(v2 + 40);
  unint64_t v5 = *(unsigned int *)(v2 + 108);
  unint64_t v6 = (obj_size_phys((uint64_t)a1) & 0xFFFFFFFCLL) - 112;
  if (v3 < v4) {
    int v7 = 1;
  }
  else {
    int v7 = 2;
  }
  if (v6 >= v5) {
    BOOL v8 = v3 >= v4;
  }
  else {
    BOOL v8 = v7;
  }
  int v9 = *(_DWORD *)(v2 + 68);
  if (v9 == 1)
  {
    BOOL v10 = *(void *)(v2 + 48) == *(void *)(v2 + 56);
  }
  else
  {
    if (v9)
    {
      if (v8) {
        goto LABEL_19;
      }
      goto LABEL_20;
    }
    if (*(void *)(v2 + 48)) {
      goto LABEL_19;
    }
    BOOL v10 = *(void *)(v2 + 56) == 0;
  }
  if (!v10 || v8)
  {
LABEL_19:
    uint64_t result = nx_corruption_detected_int(*(void *)(*a1 + 392));
    if (result) {
      return result;
    }
  }
LABEL_20:
  a1[47] = v2;
  unsigned int v13 = obj_size_phys((uint64_t)a1);
  uint64_t result = 0;
  a1[48] = v2 + v13 - *(unsigned int *)(v2 + 108);
  return result;
}

uint64_t sub_10002D5FC(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = ((unint64_t)a2 - 64) / 0x28;
  *(_DWORD *)(a1 + 44) = v2;
  *(void *)(a1 + 52) = -1;
  *(_DWORD *)(a1 + 60) = 0;
  uint64_t v3 = (v2 - 1);
  if (v3)
  {
    uint64_t v4 = 0;
    unint64_t v5 = (_DWORD *)(a1 + 64);
    do
    {
      *unint64_t v5 = ++v4;
      v5 += 10;
    }
    while (v3 != v4);
  }
  else
  {
    LODWORD(v3) = 0;
  }
  *(_DWORD *)(a1 + 40 * v3 + 64) = -1;
  return 0;
}

uint64_t sub_10002D664(void *a1)
{
  unint64_t v2 = (_DWORD *)a1[7];
  unsigned int v3 = v2[11];
  BOOL v4 = v3 > (((unint64_t)obj_size_phys((uint64_t)a1) - 64) / 0x28);
  unsigned int v6 = v2[11];
  unsigned int v5 = v2[12];
  if (v4) {
    int v7 = 2;
  }
  else {
    int v7 = 1;
  }
  if (v5 <= v6) {
    int v8 = v4;
  }
  else {
    int v8 = v7;
  }
  unsigned int v9 = v2[13];
  unsigned int v10 = v2[14];
  if (v9 != -1 && v9 >= v6) {
    ++v8;
  }
  if (v10 != -1 && v10 >= v6) {
    ++v8;
  }
  unsigned int v13 = v2[15];
  if (v13 != -1 && v13 >= v6) {
    int v15 = v8 + 1;
  }
  else {
    int v15 = v8;
  }
  if (v5 == 1)
  {
    BOOL v16 = v9 == v10;
  }
  else
  {
    if (v5)
    {
      if (v15) {
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    BOOL v16 = v9 == -1 && v10 == -1;
  }
  if (!v16 || v15 != 0)
  {
LABEL_36:
    uint64_t result = nx_corruption_detected_int(*(void *)(*a1 + 392));
    if (result) {
      return result;
    }
  }
LABEL_37:
  uint64_t result = 0;
  a1[47] = v2;
  return result;
}

uint64_t nx_reaper_obj_get(uint64_t *a1, int a2, int a3, unint64_t a4, unint64_t a5, uint64_t **a6, uint64_t **a7)
{
  uint64_t v36 = 0;
  unsigned int v35 = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  *a7 = 0;
  *a6 = 0;
  if (a4)
  {
    uint64_t v13 = obj_get(a1[49], 0, a4, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v36);
    if (v13)
    {
      uint64_t v21 = v13;
      log_err((uint64_t)"%s:%d: %s unable to get fs object 0x%llx: %d\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"nx_reaper_obj_get");
      return v21;
    }
    uint64_t v23 = v36;
  }
  else
  {
    uint64_t v23 = 0;
  }
  *a6 = v23;
  if ((a2 & 0x4000FFFF) == 0x4000000B)
  {
    uint64_t v24 = (uint64_t)(v23 ? v23 : a1);
    if (!omap_obj_get(v24, 0, 0, a7)) {
      return 0;
    }
  }
  uint64_t v22 = obj_descriptor_and_flags_for_type(a2, &v35, (uint64_t)&v33);
  if (v22
    || (LODWORD(v34) = a3,
        uint64_t v22 = obj_get(a1[49], v35, a5, (int *)&v33, 0, (uint64_t)v36, 0, 0, (uint64_t *)a7),
        v22))
  {
    log_err((uint64_t)"%s:%d: %s unable to get object 0x%llx: %d\n", v25, v26, v27, v28, v29, v30, v31, (uint64_t)"nx_reaper_obj_get");
    if (v36) {
      obj_release(v36);
    }
    *a7 = 0;
    *a6 = 0;
  }
  return v22;
}

uint64_t nx_reaper_add(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, void *a8)
{
  uint64_t v71 = 0;
  uint64_t v72 = 0;
  uint64_t v69 = 0;
  uint64_t v70 = 0;
  uint64_t v16 = nx_reaper_get((void *)a1, &v72);
  if (v16) {
    return v16;
  }
  uint64_t v17 = v72[47];
  uint64_t v16 = obj_descriptor_funcs_for_type(a2, &v69);
  if (v16)
  {
LABEL_3:
    log_err((uint64_t)"%s:%d: %s object type 0x%x not reapable: %d\n", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"nx_reaper_add");
LABEL_14:
    obj_release(v72);
    return v16;
  }
  if (!*(void *)(v69 + 24))
  {
    uint64_t v16 = 22;
    goto LABEL_3;
  }
  obj_lock((uint64_t)v72, 2u);
  uint64_t v30 = obj_modify(v72, 0, a6, v25, v26, v27, v28, v29);
  if (v30)
  {
    uint64_t v16 = v30;
LABEL_13:
    obj_unlock((uint64_t)v72, 2u);
    goto LABEL_14;
  }
  uint64_t v31 = *(pthread_mutex_t **)(a1 + 392);
  if (*(_OWORD *)(v17 + 48) == 0)
  {
    uint64_t v32 = obj_create(v31, 0x80000000, 0, (unsigned int *)&nx_reap_list_desc, 0, 0, a6, (uint64_t *)&v71);
    if (v32)
    {
      uint64_t v16 = v32;
      log_err((uint64_t)"%s:%d: %s failed to create reap list: %d\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"nx_reaper_add");
      goto LABEL_13;
    }
    uint64_t v49 = obj_oid((uint64_t)v71);
    *(void *)(v17 + 48) = v49;
    *(void *)(v17 + 56) = v49;
    uint64_t v50 = (_DWORD *)(v17 + 68);
  }
  else
  {
    uint64_t v40 = obj_get(v31, 2147483649, *(void *)(v17 + 56), &nx_reap_list_desc, 0, 0, 0, a6, &v71);
    if (v40)
    {
      uint64_t v16 = v40;
      log_err((uint64_t)"%s:%d: %s failed to get reap list tail: %d\n", v41, v42, v43, v44, v45, v46, v47, (uint64_t)"nx_reaper_add");
      goto LABEL_13;
    }
    uint64_t v50 = (_DWORD *)(v17 + 68);
    if (*(_DWORD *)(v17 + 68) || *(void *)(v17 + 48) != *(void *)(v17 + 56)) {
      goto LABEL_20;
    }
  }
  *uint64_t v50 = 1;
  obj_dirty((uint64_t)v72, a6, 0);
LABEL_20:
  uint64_t v51 = (_DWORD *)v71[47];
  if (v51[12] > (v51[11] - 2))
  {
    uint64_t v52 = obj_create(*(pthread_mutex_t **)(a1 + 392), 0x80000000, 0, (unsigned int *)&nx_reap_list_desc, 0, 0, a6, (uint64_t *)&v70);
    if (v52)
    {
      uint64_t v16 = v52;
      obj_unlock((uint64_t)v72, 2u);
      obj_release(v71);
      goto LABEL_14;
    }
    uint64_t v53 = obj_oid((uint64_t)v70);
    *(void *)(v71[47] + 32) = v53;
    *(void *)(v17 + 56) = obj_oid((uint64_t)v70);
    int v54 = *(_DWORD *)(v17 + 68);
    if (v54) {
      *(_DWORD *)(v17 + 68) = v54 + 1;
    }
    obj_dirty((uint64_t)v72, a6, 0);
    obj_release(v71);
    uint64_t v71 = v70;
    uint64_t v51 = (_DWORD *)v70[47];
  }
  uint64_t v55 = *(void *)(v17 + 32);
  *(void *)(v17 + 32) = v55 + 1;
  int v56 = v51[15];
  if (v56 == -1) {
    goto LABEL_43;
  }
  uint64_t v57 = &v51[10 * v56];
  int v60 = v57[16];
  uint64_t v58 = v57 + 16;
  int v59 = v60;
  v51[15] = v60;
  int v61 = v51[14];
  if (v61 != -1) {
    v51[10 * v61 + 16] = v56;
  }
  int v62 = v51[12];
  if (v51[13] == -1)
  {
    if (v62) {
      sub_10005F5C0();
    }
    v51[13] = v56;
  }
  v51[14] = v56;
  v51[12] = v62 + 1;
  *uint64_t v58 = -1;
  uint64_t v63 = &v51[10 * v56];
  int v64 = (a7 & 2) != 0 ? 21 : 5;
  v63[17] = v64;
  v63[18] = a2;
  v63[19] = a3;
  *((void *)v63 + 10) = a4;
  *((void *)v63 + 11) = a5;
  *((void *)v63 + 12) = a6;
  if (v59 == -1)
  {
LABEL_43:
    log_err((uint64_t)"%s:%d: %s reap list object free list erroneously empty?\n", v41, v42, v43, v44, v45, v46, v47, (uint64_t)"nx_reaper_add");
    obj_unlock((uint64_t)v72, 2u);
    obj_release(v71);
    obj_release(v72);
    return nx_corruption_detected_int(a1);
  }
  else
  {
    uint64_t v65 = &v51[10 * v59];
    int v66 = v65[16];
    *uint64_t v58 = v59;
    v51[14] = v59;
    v51[15] = v66;
    v51[12] = v62 + 2;
    if ((a7 & 2) != 0) {
      int v67 = 19;
    }
    else {
      int v67 = 3;
    }
    if (a7) {
      v67 |= 0xCu;
    }
    v65[16] = -1;
    v65[17] = v67;
    v65[18] = a2;
    v65[19] = a3;
    *((void *)v65 + 10) = a4;
    *((void *)v65 + 11) = a5;
    *((void *)v65 + 12) = v55;
    obj_dirty((uint64_t)v71, a6, 0);
    obj_unlock((uint64_t)v72, 2u);
    obj_release(v71);
    obj_release(v72);
    if (a8)
    {
      uint64_t v68 = v55;
      uint64_t v16 = 0;
      *a8 = v68;
    }
    else
    {
      return 0;
    }
  }
  return v16;
}

uint64_t nx_reaper_add_sub_object(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v72 = 0;
  uint64_t v73 = 0;
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  uint64_t v14 = nx_reaper_get((void *)a1, &v73);
  if (v14) {
    return v14;
  }
  uint64_t v15 = v73[47];
  uint64_t v14 = obj_descriptor_funcs_for_type(a2, &v70);
  if (v14)
  {
LABEL_3:
    log_err((uint64_t)"%s:%d: %s object type 0x%x not reapable: %d\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"nx_reaper_add_sub_object");
LABEL_4:
    obj_release(v73);
    return v14;
  }
  if (!*(void *)(v70 + 24))
  {
    uint64_t v14 = 22;
    goto LABEL_3;
  }
  obj_lock((uint64_t)v73, 2u);
  uint64_t v29 = obj_modify(v73, 0, a6, v24, v25, v26, v27, v28);
  if (v29)
  {
    uint64_t v14 = v29;
    obj_unlock((uint64_t)v73, 2u);
    goto LABEL_4;
  }
  uint64_t v30 = *(void *)(v15 + 48);
  if (!v30 && !*(void *)(v15 + 56))
  {
    uint64_t v47 = obj_create(*(pthread_mutex_t **)(a1 + 392), 0x80000000, 0, (unsigned int *)&nx_reap_list_desc, 0, 0, a6, (uint64_t *)&v72);
    if (v47)
    {
      uint64_t v14 = v47;
      log_err((uint64_t)"%s:%d: %s failed to create reap list: %d\n", v48, v49, v50, v51, v52, v53, v54, (uint64_t)"nx_reaper_add_sub_object");
      goto LABEL_14;
    }
    uint64_t v55 = obj_oid((uint64_t)v72);
    *(void *)(v15 + 48) = v55;
    *(void *)(v15 + 56) = v55;
    uint64_t v46 = (_DWORD *)(v15 + 68);
    goto LABEL_21;
  }
  uint64_t v31 = obj_get(*(void *)(a1 + 392), 2147483649, v30, &nx_reap_list_desc, 0, 0, 0, a6, &v72);
  if (v31)
  {
    uint64_t v14 = v31;
    log_err((uint64_t)"%s:%d: %s failed to get reap list head: %d\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"nx_reaper_add_sub_object");
LABEL_14:
    log_err((uint64_t)"%s:%d: %s failed to get reap list head: %d\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"nx_reaper_add_sub_object");
    obj_unlock((uint64_t)v73, 2u);
    obj_release(v73);
    return v14;
  }
  uint64_t v46 = (_DWORD *)(v15 + 68);
  if (!*(_DWORD *)(v15 + 68) && *(void *)(v15 + 48) == *(void *)(v15 + 56))
  {
LABEL_21:
    *uint64_t v46 = 1;
    obj_dirty((uint64_t)v73, a6, 0);
  }
  int v56 = (_DWORD *)v72[47];
  if (v56[12] > v56[11] + ~(a7 & 1u))
  {
    uint64_t v57 = obj_create(*(pthread_mutex_t **)(a1 + 392), 0x80000000, 0, (unsigned int *)&nx_reap_list_desc, 0, 0, a6, (uint64_t *)&v71);
    if (v57)
    {
      uint64_t v14 = v57;
      obj_unlock((uint64_t)v73, 2u);
      obj_release(v72);
      goto LABEL_4;
    }
    uint64_t v58 = (uint64_t)v71;
    *(void *)(v71[47] + 32) = *(void *)(v15 + 48);
    *(void *)(v15 + 48) = obj_oid(v58);
    int v59 = *(_DWORD *)(v15 + 68);
    if (v59) {
      *(_DWORD *)(v15 + 68) = v59 + 1;
    }
    obj_dirty((uint64_t)v73, a6, 0);
    obj_release(v72);
    uint64_t v72 = v71;
    int v56 = (_DWORD *)v71[47];
  }
  int v60 = v56[15];
  if (a7)
  {
    if (v60 == -1)
    {
LABEL_43:
      log_err((uint64_t)"%s:%d: %s reap list object free list erroneously empty?\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"nx_reaper_add_sub_object");
      obj_unlock((uint64_t)v73, 2u);
      obj_release(v72);
      obj_release(v73);
      return nx_corruption_detected_int(a1);
    }
    int v61 = &v56[10 * v60];
    int v62 = v61[16];
    v56[15] = v62;
    int v63 = v56[14];
    v61[16] = v56[13];
    v56[13] = v60;
    if (v63 == -1) {
      v56[14] = v60;
    }
    ++v56[12];
    int v64 = &v56[10 * v60];
    if ((a7 & 2) != 0) {
      int v65 = 29;
    }
    else {
      int v65 = 13;
    }
    v64[17] = v65;
    v64[18] = a2;
    v64[19] = a3;
    *((void *)v64 + 10) = a4;
    *((void *)v64 + 11) = a5;
    *((void *)v64 + 12) = a6;
    int v60 = v62;
  }
  if (v60 == -1) {
    goto LABEL_43;
  }
  int v66 = &v56[10 * v60];
  v56[15] = v66[16];
  int v67 = v56[14];
  v66[16] = v56[13];
  v56[13] = v60;
  if (v67 == -1) {
    v56[14] = v60;
  }
  ++v56[12];
  uint64_t v68 = &v56[10 * v60];
  if ((a7 & 2) != 0) {
    int v69 = 21;
  }
  else {
    int v69 = 5;
  }
  v68[17] = v69;
  v68[18] = a2;
  v68[19] = a3;
  *((void *)v68 + 10) = a4;
  *((void *)v68 + 11) = a5;
  *((void *)v68 + 12) = a6;
  obj_dirty((uint64_t)v72, a6, 0);
  obj_unlock((uint64_t)v73, 2u);
  obj_release(v72);
  obj_release(v73);
  return 0;
}

void nx_reaper_check_for_work(uint64_t *a1)
{
  unsigned int v5 = 0;
  unsigned int v6 = 0;
  if (!nx_reaper_get(a1, &v6))
  {
    uint64_t v2 = v6[47];
    obj_lock((uint64_t)v6, 2u);
    if (!*(void *)(v2 + 88))
    {
      unint64_t v3 = *(void *)(v2 + 48);
      if (!v3
        || obj_get(a1[49], 0x80000000, v3, (int *)&nx_reap_list_desc, 0, 0, 0, 0, (uint64_t *)&v5))
      {
        goto LABEL_4;
      }
      uint64_t v4 = v5[47];
      if (!*(_DWORD *)(v4 + 48) && !*(void *)(v4 + 32))
      {
        obj_release(v5);
        goto LABEL_4;
      }
      obj_release(v5);
    }
    obj_unlock((uint64_t)v6, 2u);
    sub_10002E35C(a1);
    obj_lock((uint64_t)v6, 2u);
LABEL_4:
    obj_unlock((uint64_t)v6, 2u);
    obj_release(v6);
  }
}

uint64_t sub_10002E35C(uint64_t *a1)
{
  uint64_t v52 = 0;
  uint64_t v50 = 0;
  uint64_t v51 = 0;
  uint64_t v48 = 0;
  uint64_t v49 = 0;
  uint64_t result = nx_reaper_get(a1, &v52);
  if (result) {
    return result;
  }
  uint64_t v3 = v52[47];
  obj_lock((uint64_t)v52, 2u);
  uint64_t v4 = v52;
  if (*((_DWORD *)v52 + 98) || *((_DWORD *)v52 + 99))
  {
    obj_unlock((uint64_t)v52, 2u);
    obj_release(v52);
    log_debug((uint64_t)"%s:%d: reaper thread is exiting, returning EBUSY\n", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"nx_reaper");
    return 16;
  }
  int v12 = 0;
  *((_DWORD *)v52 + 98) = 1;
  while (1)
  {
    unint64_t v46 = 0;
    unint64_t v47 = 0;
    obj_unlock((uint64_t)v4, 2u);
    uint64_t v51 = 0;
    unsigned int v13 = tx_enter((uint64_t)a1, &v51);
    obj_lock((uint64_t)v52, 2u);
    uint64_t v4 = v52;
    if (v13)
    {
LABEL_37:
      int v45 = 0;
      goto LABEL_41;
    }
    unsigned int v19 = obj_modify(v52, 0, v51, v14, v15, v16, v17, v18);
    uint64_t v4 = v52;
    if (v19)
    {
      unsigned int v13 = v19;
LABEL_40:
      int v45 = 1;
      goto LABEL_41;
    }
    if (*(void *)(v3 + 88)) {
      goto LABEL_13;
    }
    if (*((_DWORD *)v52 + 99)) {
      goto LABEL_39;
    }
    unsigned int v20 = sub_10002F860((uint64_t)a1, (uint64_t)v52, v51);
    if (v20) {
      break;
    }
    uint64_t v4 = v52;
    if (!*(void *)(v3 + 88))
    {
LABEL_39:
      unsigned int v13 = 0;
      goto LABEL_40;
    }
LABEL_13:
    obj_unlock((uint64_t)v4, 2u);
    if ((*(unsigned char *)(v3 + 104) & 4) == 0) {
      goto LABEL_16;
    }
    if (obj_descriptor_funcs_for_type(*(_DWORD *)(v3 + 72), &v50) || !*(void *)(v50 + 24))
    {
      log_err((uint64_t)"%s:%d: %s object type 0x%x not reapable?: %d\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"nx_reaper");
      int v12 = 1;
LABEL_16:
      obj_lock((uint64_t)v52, 2u);
      goto LABEL_17;
    }
    int v28 = nx_reaper_obj_get(a1, *(_DWORD *)(v3 + 72), *(_DWORD *)(v3 + 76), *(void *)(v3 + 80), *(void *)(v3 + 88), &v48, &v49);
    if (v28)
    {
      int v36 = v28;
      log_err((uint64_t)"%s:%d: %s unable to get object 0x%llx of type 0x%x: %d\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"nx_reaper");
    }
    else
    {
      if ((*(unsigned char *)(v3 + 64) & 2) == 0) {
        bzero((void *)v52[48], *(unsigned int *)(v3 + 108));
      }
      int v37 = (*(uint64_t (**)(uint64_t *, void, uint64_t, void, uint64_t))(v50 + 24))(v49, (*(_DWORD *)(v3 + 104) >> 3) & 3, v52[48], *(unsigned int *)(v3 + 108), v51);
      int v36 = v37;
      if (v37 && v37 != 36) {
        log_err((uint64_t)"%s:%d: %s error reaping object 0x%llx of type 0x%x: %d\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"nx_reaper");
      }
      obj_release(v49);
      if (v48)
      {
        obj_release(v48);
        uint64_t v48 = 0;
      }
    }
    obj_lock((uint64_t)v52, 2u);
    if (v36 == 36)
    {
      *(_DWORD *)(v3 + 64) |= 2u;
      int v12 = 1;
      goto LABEL_20;
    }
    int v12 = 1;
LABEL_17:
    if ((*(unsigned char *)(v3 + 104) & 2) != 0) {
      *(void *)(v3 + 40) = *(void *)(v3 + 96);
    }
    *(_DWORD *)(v3 + 64) &= ~2u;
    *(void *)(v3 + 88) = 0;
LABEL_20:
    obj_dirty((uint64_t)v52, v51, 0);
    obj_unlock((uint64_t)v52, 2u);
    spaceman_currently_available_space((uint64_t)a1, &v47, &v46, 0, 0);
    unsigned int v13 = tx_leave((uint64_t)a1, v51, (v46 < 0x3E8) | (4 * (v46 < 0x7D0)));
    obj_lock((uint64_t)v52, 2u);
    uint64_t v4 = v52;
    if (v13) {
      goto LABEL_37;
    }
    if (*((_DWORD *)v52 + 99))
    {
      int v45 = 0;
      unsigned int v13 = 0;
      goto LABEL_41;
    }
  }
  unsigned int v13 = v20;
  int v45 = 1;
  uint64_t v4 = v52;
LABEL_41:
  *((_DWORD *)v4 + 98) = 0;
  obj_unlock((uint64_t)v4, 2u);
  obj_release(v52);
  if (v45) {
    tx_leave((uint64_t)a1, v51, 0);
  }
  if (v13 | v12) {
    return v13;
  }
  else {
    return 2;
  }
}

void nx_reaper_shut_down(void *a1)
{
  uint64_t v4 = 0;
  if (!nx_reaper_get(a1, &v4))
  {
    obj_lock((uint64_t)v4, 2u);
    uint64_t v2 = v4;
    ++*((_DWORD *)v4 + 99);
    obj_unlock((uint64_t)v2, 2u);
    uint64_t v3 = (uint64_t *)a1[53];
    if (v3)
    {
      obj_release(v3);
      a1[53] = 0;
    }
    obj_release(v4);
  }
}

uint64_t nx_reaper_wait(uint64_t *a1, unint64_t a2)
{
  uint64_t v15 = 0;
  uint64_t v4 = nx_reaper_get(a1, &v15);
  if (!v4)
  {
    uint64_t v5 = v15[7];
    obj_lock((uint64_t)v15, 2u);
    unint64_t v13 = *(void *)(v5 + 32);
    if (a2 == -1) {
      a2 = v13 - 1;
    }
    if (a2 >= v13)
    {
      log_err((uint64_t)"%s:%d: %s invalid reap_id (%llu), must be smaller than nr_next_reap_id (%llu)\n", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"nx_reaper_wait");
      uint64_t v4 = 22;
    }
    else
    {
      while (*(void *)(v5 + 40) < a2)
      {
        obj_unlock((uint64_t)v15, 2u);
        uint64_t v4 = sub_10002E35C(a1);
        obj_lock((uint64_t)v15, 2u);
        if (v4) {
          goto LABEL_10;
        }
      }
      uint64_t v4 = 0;
    }
LABEL_10:
    obj_unlock((uint64_t)v15, 2u);
    obj_release(v15);
  }
  return v4;
}

uint64_t extent_list_key_cmp(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

uint64_t nx_metadata_fragmented_extent_list_tree_store(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v3 = *a2;
  if ((*a2 & 0x8000000000000000) == 0) {
    sub_10005F5EC();
  }
  uint64_t v8 = 0;
  uint64_t v6 = btree_get(a1, 0x88000000, v3 & 0x7FFFFFFFFFFFFFFFLL, 0, 0, 0, 10, (uint64_t)extent_list_key_cmp, 0, &v10);
  if (!v6)
  {
    uint64_t v6 = btree_copy(v10, 0x40000000u, 0, a3, (uint64_t *)&v9);
    if (!v6)
    {
      btree_delete((uint64_t)v10, a3, &v8);
      *a2 = obj_oid((uint64_t)v9);
    }
    if (v10) {
      obj_release(v10);
    }
    if (v9) {
      obj_release(v9);
    }
  }
  return v6;
}

uint64_t nx_metadata_fragmented_extent_list_tree_get(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a2) {
    return 22;
  }
  for (uint64_t i = 432; i != 464; i += 8)
  {
    uint64_t v7 = *(void *)(a1 + i);
    if (v7 && obj_oid(*(void *)(a1 + i)) == a2)
    {
      obj_retain(v7);
      uint64_t v12 = 0;
      *a3 = v7;
      return v12;
    }
  }
  obj_lock(a1, 2u);
  uint64_t v8 = 0;
  int v9 = -1;
  do
  {
    uint64_t v10 = a1 + 8 * v8;
    uint64_t v11 = *(void *)(v10 + 432);
    if (v11)
    {
      if (obj_oid(*(void *)(v10 + 432)) == a2)
      {
        obj_retain(v11);
        *a3 = v11;
        obj_unlock(a1, 2u);
        return 0;
      }
    }
    else if (v9 == -1)
    {
      int v9 = v8;
    }
    ++v8;
  }
  while (v8 != 4);
  if (a2 < 0)
  {
    uint64_t v12 = btree_get(a1, 2281701376, a2 & 0x7FFFFFFFFFFFFFFFLL, 0, 0, 0, 10, extent_list_key_cmp, 0, a3);
  }
  else
  {
    uint64_t v12 = btree_get(a1, 0x40000000, a2, 0, 0, 0, 10, extent_list_key_cmp, 0, a3);
    if (!v12 && v9 != -1)
    {
      *(void *)(a1 + 8 * v9 + 432) = *a3;
      obj_retain(*a3);
      uint64_t v12 = 0;
    }
  }
  obj_unlock(a1, 2u);
  return v12;
}

uint64_t nx_metadata_fragmented_sanity_check(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v23 = 0;
  uint64_t v20 = 0;
  unint64_t v21 = 0;
  uint64_t v19 = 0;
  memset(v18, 0, sizeof(v18));
  uint64_t v5 = nx_metadata_fragmented_extent_list_tree_get(a1, a2, &v23);
  if (!v5)
  {
    unint64_t v22 = 0;
    bt_iterator_init((uint64_t)v18, v23, 0, 0, &v22, 8, 8u, &v20, 0x10u);
    uint64_t v5 = v6;
    if (!v6)
    {
      uint64_t v8 = 0;
      while (!bt_iterator_ended((uint64_t)v18))
      {
        if (v22 == v8) {
          uint64_t v5 = 0;
        }
        else {
          uint64_t v5 = nx_corruption_detected_int(a1);
        }
        if (nx_superblock_sanity_check_extent(*(void *)(a1 + 376), 0, v20, v21, 0)) {
          uint64_t v5 = nx_corruption_detected_int(a1);
        }
        unint64_t v9 = v21;
        if (v21 > (unint64_t)a3 - v8)
        {
          uint64_t v5 = nx_corruption_detected_int(a1);
          unint64_t v9 = v21;
        }
        if (v5) {
          goto LABEL_3;
        }
        v8 += v9;
        uint64_t v10 = bt_iterator_next((uint64_t)v18);
        if (v10)
        {
          uint64_t v5 = v10;
          strerror(v10);
          log_err((uint64_t)"%s:%d: %s failed to get next extent in metadata fragmented extent list tree, error %s(%d)\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"nx_metadata_fragmented_sanity_check");
          goto LABEL_3;
        }
      }
      if (a3 == v8) {
        uint64_t v5 = 0;
      }
      else {
        uint64_t v5 = nx_corruption_detected_int(a1);
      }
    }
LABEL_3:
    obj_release(v23);
  }
  return v5;
}

uint64_t nx_metadata_fragmented_block_address_lookup(uint64_t a1, uint64_t a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v16 = 0;
  uint64_t v13 = 0;
  unint64_t v14 = 0;
  uint64_t v8 = nx_metadata_fragmented_extent_list_tree_get(a1, a2, &v16);
  if (!v8)
  {
    unint64_t v15 = a3;
    unsigned int v11 = 16;
    unsigned int v12 = 8;
    uint64_t v8 = bt_lookup_variant(v16, 0, &v15, &v12, 8u, &v13, &v11, 1u, 0, 0);
    if (!v8)
    {
      uint64_t v9 = v14 - (a3 - v15);
      if (v14 <= a3 - v15)
      {
        uint64_t v8 = 2;
      }
      else
      {
        *a4 = v13 + a3 - v15;
        uint64_t v8 = 0;
        if (a5) {
          *a5 = v9;
        }
      }
    }
    obj_release(v16);
  }
  return v8;
}

uint64_t nx_metadata_range_overlap_check(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 480);
  if (!v8)
  {
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    unint64_t v15 = a2;
    unsigned int v12 = 8;
    unsigned int v11 = 16;
    LODWORD(result) = bt_lookup_variant(*(uint64_t **)(a1 + 464), 0, &v15, &v12, 8u, &v13, &v11, 1u, 0, 0);
    if (result || (unint64_t v10 = v15, a2 - v15 >= v14))
    {
      if (result == 2) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = result;
      }
      if (a3 < 2 || result) {
        return result;
      }
      unint64_t v15 = a2;
      unsigned int v11 = 16;
      unsigned int v12 = 8;
      LODWORD(result) = bt_lookup_variant(*(uint64_t **)(a1 + 464), 0, &v15, &v12, 8u, &v13, &v11, 4u, 0, 0);
      if (result || (unint64_t v10 = v15, v15 - a2 >= a3))
      {
        if (result == 2) {
          return 0;
        }
        else {
          return result;
        }
      }
    }
    if (a4) {
      *a4 = v10;
    }
    return 17;
  }
  if (calc_overlap_range(*(void *)(a1 + 472), v8, a2, a3, a4)) {
    return 17;
  }
  if ((((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36)))) & a2) == 0)
  {
    if (a4) {
      *a4 = a2;
    }
    return 17;
  }
  return 0;
}

uint64_t nx_metadata_range_add(uint64_t a1, unint64_t a2, int a3, char a4, int a5)
{
  if (a4)
  {
    uint64_t v24 = 0;
    unint64_t v21 = 0;
    unint64_t v22 = 0;
    memset(v19, 0, sizeof(v19));
    uint64_t v20 = 0;
    uint64_t v6 = nx_metadata_fragmented_extent_list_tree_get(a1, a2, &v24);
    if (v6) {
      return v6;
    }
    uint64_t v7 = btree_iterate_nodes((uint64_t)v24, 0, 0, (uint64_t (*)(void))sub_10002F198, 0, 0);
    if (!v7)
    {
      unint64_t v23 = 0;
      bt_iterator_init((uint64_t)v19, v24, 0, 0, &v23, 8, 8u, &v21, 0x10u);
      uint64_t v6 = v10;
      if (bt_iterator_ended((uint64_t)v19)) {
        goto LABEL_9;
      }
      while (1)
      {
        uint64_t v7 = sub_10002F0B4(a1, v21, v22, 0);
        if (v7) {
          break;
        }
        uint64_t v11 = bt_iterator_next((uint64_t)v19);
        if (v11)
        {
          uint64_t v6 = v11;
          strerror(v11);
          log_err((uint64_t)"%s:%d: %s failed to get next extent in metadata fragmented extent list tree, error %s(%d)\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"nx_metadata_range_add");
          goto LABEL_9;
        }
        if (bt_iterator_ended((uint64_t)v19))
        {
          uint64_t v6 = 0;
          goto LABEL_9;
        }
      }
    }
    uint64_t v6 = v7;
LABEL_9:
    obj_release(v24);
    return v6;
  }
  unint64_t v8 = a3 & 0x7FFFFFFF;

  return sub_10002F0B4(a1, a2, v8, a5);
}

uint64_t sub_10002F0B4(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  if (nx_superblock_sanity_check_extent(*(void *)(a1 + 376), 0, a2, a3, a4)) {
    return 22;
  }
  if (*(void *)(a1 + 464))
  {
    uint64_t result = nx_metadata_range_overlap_check(a1, a2, a3, 0);
    if (result) {
      return result;
    }
    goto LABEL_5;
  }
  uint64_t result = btree_create((pthread_mutex_t **)a1, 0x88000000, 0, 10, 0, 8u, 16, (uint64_t)extent_list_key_cmp, 0, (uint64_t *)(a1 + 464));
  if (!result)
  {
LABEL_5:
    v8[1] = a3;
    unint64_t v9 = a2;
    v8[0] = a2;
    return bt_insert(*(uint64_t **)(a1 + 464), 0, &v9, 8, v8, 0x10u, 0);
  }
  return result;
}

uint64_t sub_10002F198(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)a1 + 392);
  unint64_t v3 = obj_oid(a1);
  unint64_t v4 = (obj_size_phys(a1) + *(_DWORD *)(*(void *)(v2 + 376) + 36) - 1)
     / *(_DWORD *)(*(void *)(v2 + 376) + 36);

  return sub_10002F0B4(v2, v3, v4, 0);
}

void nx_metadata_range_optimize(void *a1)
{
  a1[59] = 0;
  a1[60] = 0;
  uint64_t v1 = (uint64_t *)a1[58];
  if (v1)
  {
    long long v23 = 0uLL;
    memset(v20, 0, sizeof(v20));
    uint64_t v21 = 0;
    *(_OWORD *)unint64_t v22 = 0uLL;
    unint64_t v24 = 0;
    bt_iterator_init((uint64_t)v20, v1, 0, 0, &v24, 8, 8u, &v23, 0x10u);
    if (!bt_iterator_ended((uint64_t)v20))
    {
      uint64_t v3 = 0;
      while (1)
      {
        uint64_t v4 = *((void *)&v23 + 1);
        uint64_t v5 = v23;
        if ((((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(a1[47] + 36)))) & (unint64_t)v23) != 0)
        {
          if (*((void *)&v23 + 1)) {
            goto LABEL_9;
          }
        }
        else
        {
          uint64_t v5 = v23 + 1;
          uint64_t v4 = *((void *)&v23 + 1) - 1;
          *(void *)&long long v23 = v23 + 1;
          *((void *)&v23 + 1) = v4;
          if (v4)
          {
LABEL_9:
            if (v22[1] && v22[0] + v22[1] == v5)
            {
              v22[1] += v4;
              if (bt_update(a1[58], 0, v22, 8, v22, 0x10u, 0))
              {
                log_err((uint64_t)"%s:%d: %s error updating metadata ranges tree: %d\n", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"nx_metadata_range_optimize");
                return;
              }
              if (bt_remove((uint64_t *)a1[58], 0, (unint64_t *)&v23, 8u, 0))
              {
                log_err((uint64_t)"%s:%d: %s error removing coalesced extent from metadata ranges tree: %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"nx_metadata_range_optimize");
                return;
              }
            }
            else
            {
              ++v3;
              *(_OWORD *)unint64_t v22 = v23;
            }
          }
        }
        bt_iterator_next((uint64_t)v20);
        if (bt_iterator_ended((uint64_t)v20))
        {
          if (v3 == 1) {
            *(_OWORD *)(a1 + 59) = *(_OWORD *)v22;
          }
          return;
        }
      }
    }
  }
}

uint64_t nx_checkpoint_desc_block_address(uint64_t a1, unint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 376);
  int v4 = *(_DWORD *)(v3 + 104);
  if ((v4 & 0x7FFFFFFFu) <= a2) {
    return 22;
  }
  uint64_t v7 = *(void *)(v3 + 112);
  if (v4 < 0) {
    return nx_metadata_fragmented_block_address_lookup(a1, v7, a2, a3, 0);
  }
  uint64_t result = 0;
  *a3 = v7 + a2;
  return result;
}

uint64_t nx_checkpoint_data_block_address(uint64_t a1, unint64_t a2, void *a3, unint64_t *a4)
{
  uint64_t v4 = *(void *)(a1 + 376);
  int v5 = *(_DWORD *)(v4 + 108);
  unint64_t v6 = (v5 & 0x7FFFFFFF) - a2;
  if ((v5 & 0x7FFFFFFFu) <= a2) {
    return 22;
  }
  uint64_t v10 = *(void *)(v4 + 120);
  if (v5 < 0) {
    return nx_metadata_fragmented_block_address_lookup(a1, v10, a2, a3, a4);
  }
  *a3 = v10 + a2;
  uint64_t result = 0;
  if (a4) {
    *a4 = v6;
  }
  return result;
}

uint64_t nx_unblock_physical_range(void *a1)
{
  if (!*(void *)(a1[47] + 1256))
  {
LABEL_8:
    uint64_t v36 = 0;
    uint64_t v2 = tx_enter((uint64_t)a1, &v36);
    if (v2) {
      return v2;
    }
    uint64_t v18 = spaceman_unset_block_out_range(a1, v36);
    if (!v18) {
      return tx_leave((uint64_t)a1, v36, 0);
    }
    uint64_t v2 = v18;
    log_err((uint64_t)"%s:%d: %s spaceman_unset_block_out_range failed with error %u\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"nx_unblock_physical_range");
    goto LABEL_11;
  }
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  uint64_t v34 = 0;
  uint64_t v2 = tx_enter((uint64_t)a1, &v36);
  if (v2) {
    return v2;
  }
  evict_mapping_uint64_t tree = nx_get_evict_mapping_tree((uint64_t)a1, 0x40000000u, *(void *)(a1[47] + 1256), 1, 1, &v35);
  if (evict_mapping_tree)
  {
    uint64_t v2 = evict_mapping_tree;
    log_err((uint64_t)"%s:%d: %s failed to get mapping tree, error: %d\n", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"nx_unblock_physical_range");
    goto LABEL_11;
  }
  uint64_t v2 = btree_delete((uint64_t)v35, v36, &v34);
  obj_release(v35);
  if (!v2)
  {
    *(void *)(a1[47] + 1256) = 0;
    uint64_t v2 = tx_leave((uint64_t)a1, v36, 0);
    if (v2) {
      return v2;
    }
    goto LABEL_8;
  }
  log_err((uint64_t)"%s:%d: %s failed to delete mapping, error: %d\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"nx_unblock_physical_range");
LABEL_11:
  if (tx_leave((uint64_t)a1, v36, 0)) {
    log_err((uint64_t)"%s:%d: %s tx_leave failed with error: %d\n", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"nx_unblock_physical_range");
  }
  return v2;
}

uint64_t nx_ratelimit_log_allowed(uint64_t a1)
{
  if (!a1) {
    return 1;
  }
  uint64_t timestamp = get_timestamp();
  if ((unint64_t)(timestamp - *(void *)(a1 + 1792)) >= 0x3B9ACA01)
  {
    unint64_t v3 = 0;
    *(void *)(a1 + 1792) = timestamp;
LABEL_6:
    *(void *)(a1 + 1800) = v3 + 1;
    return 1;
  }
  unint64_t v3 = *(void *)(a1 + 1800);
  if (v3 <= 0xF) {
    goto LABEL_6;
  }
  return 0;
}

uint64_t nx_allocate_metadata_range(pthread_mutex_t **a1, uint64_t (*a2)(pthread_mutex_t **, uint64_t, int64_t, unint64_t *, int64_t *), uint64_t a3, unint64_t *a4, int64_t *a5, int a6)
{
  int64_t v12 = *a5;
  unint64_t v25 = 0;
  int64_t v26 = 0;
  uint64_t v24 = 0;
  uint64_t v13 = a2(a1, a3, v12, &v25, &v26);
  if (!v13)
  {
    if (v26 >= v12)
    {
      uint64_t v13 = 0;
      *a4 = v25;
      return v13;
    }
    uint64_t v13 = btree_create(a1, 0x88000000, 2, 10, 0, 8u, 16, (uint64_t)extent_list_key_cmp, 0, (uint64_t *)&v24);
    if (!v13)
    {
      unint64_t v21 = v25;
      int64_t v22 = v26;
      unint64_t v23 = 0;
      uint64_t v13 = bt_insert(v24, 0, &v23, 8, &v21, 0x10u, 0);
      if (!v13)
      {
        unint64_t v14 = v26;
        uint64_t v15 = v12 - v26;
        if (v15 < 1)
        {
LABEL_10:
          unint64_t v18 = 0x80000000;
          if (a6) {
            unint64_t v18 = 0x8000000000000000;
          }
          *a5 |= v18;
          uint64_t v13 = 0;
          *a4 = obj_oid((uint64_t)v24) | 0x8000000000000000;
          uint64_t v19 = v24;
          if (v24) {
            goto LABEL_19;
          }
          return v13;
        }
        while (1)
        {
          uint64_t v16 = a2(a1, a3, v15, &v25, &v26);
          if (v16) {
            break;
          }
          unint64_t v21 = v25;
          int64_t v22 = v26;
          unint64_t v23 = v14;
          uint64_t v16 = bt_insert(v24, 0, &v23, 8, &v21, 0x10u, 0);
          if (v16) {
            break;
          }
          v14 += v26;
          BOOL v17 = v15 <= v26;
          v15 -= v26;
          if (v17) {
            goto LABEL_10;
          }
        }
        uint64_t v13 = v16;
      }
      if (v24)
      {
        btree_delete((uint64_t)v24, 0, 0);
        uint64_t v19 = v24;
LABEL_19:
        obj_release(v19);
      }
    }
  }
  return v13;
}

uint64_t sub_10002F860(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 376);
  unint64_t v5 = *(void *)(v4 + 48);
  if (!v5) {
    return 0;
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  uint64_t v8 = obj_get(*(void *)(a1 + 392), 2147483649, v5, (int *)&nx_reap_list_desc, 0, 0, 0, a3, (uint64_t *)&v30);
  if (v8)
  {
    uint64_t v16 = v8;
    log_err((uint64_t)"%s:%d: %s failed to get reap list head: %d\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"nx_reaper_next_record");
    return v16;
  }
  BOOL v17 = v30;
  if (*(void *)(v4 + 88))
  {
LABEL_21:
    obj_release(v17);
    return 0;
  }
  uint64_t v18 = v30[47];
  while (1)
  {
    while (1)
    {
      unsigned int v19 = *(_DWORD *)(v18 + 52);
      if (v19 == -1) {
        break;
      }
      uint64_t v20 = v18 + 40 * v19;
      unint64_t v21 = (_DWORD *)(v20 + 68);
      *(_DWORD *)(v4 + 104) = *(_DWORD *)(v20 + 68);
      *(void *)(v4 + 72) = *(void *)(v20 + 72);
      *(_OWORD *)(v4 + 80) = *(_OWORD *)(v20 + 80);
      *(void *)(v4 + 96) = *(void *)(v20 + 96);
      obj_dirty(a2, a3, 0);
      int v24 = *(_DWORD *)(v20 + 64);
      unint64_t v23 = (_DWORD *)(v20 + 64);
      int v22 = v24;
      if (*(_DWORD *)(v18 + 52) == *(_DWORD *)(v18 + 56)) {
        *(_DWORD *)(v18 + 56) = v22;
      }
      *unint64_t v21 = 0;
      *unint64_t v23 = *(_DWORD *)(v18 + 60);
      *(_DWORD *)(v18 + 60) = v19;
      --*(_DWORD *)(v18 + 48);
      *(_DWORD *)(v18 + 52) = v22;
      obj_dirty((uint64_t)v30, a3, 0);
      if (*(void *)(v4 + 88)) {
        goto LABEL_20;
      }
    }
    unint64_t v25 = *(void *)(v18 + 32);
    if (!v25)
    {
      if (!*(_DWORD *)(v4 + 68) && *(void *)(v4 + 48) == *(void *)(v4 + 56))
      {
        *(_DWORD *)(v4 + 68) = 1;
        obj_dirty(a2, a3, 0);
      }
LABEL_20:
      BOOL v17 = v30;
      goto LABEL_21;
    }
    uint64_t v26 = obj_get(*(void *)(a1 + 392), 0x80000000, v25, (int *)&nx_reap_list_desc, 0, 0, 0, a3, (uint64_t *)&v29);
    if (v26) {
      break;
    }
    *(void *)(v4 + 48) = *(void *)(v18 + 32);
    int v27 = *(_DWORD *)(v4 + 68);
    if (v27) {
      *(_DWORD *)(v4 + 68) = v27 - 1;
    }
    obj_dirty(a2, a3, 0);
    obj_free((uint64_t)v30);
    obj_release(v30);
    BOOL v17 = v29;
    uint64_t v29 = 0;
    uint64_t v30 = v17;
    uint64_t v18 = v17[47];
    if (*(void *)(v4 + 88)) {
      goto LABEL_21;
    }
  }
  uint64_t v16 = v26;
  obj_release(v30);
  return v16;
}

uint64_t fusion_mt_key_cmp(uint64_t a1, void *a2, int a3, void *a4, int a5, int *a6)
{
  uint64_t result = 22;
  if (a3 == 8 && a5 == 8)
  {
    uint64_t result = 0;
    int v7 = *a2 > *a4;
    if (*a2 < *a4) {
      int v7 = -1;
    }
    *a6 = v7;
  }
  return result;
}

uint64_t btree_entry_max_size(char a1, __int16 a2, int a3, int a4)
{
  if (a3 && a4)
  {
    __int16 v4 = (a3 + 7) & 0xFFF8;
    if ((a1 & 0x40) != 0) {
      __int16 v4 = a3;
    }
    __int16 v5 = (a4 + 7) & 0xFFF8;
    if ((a1 & 0x40) != 0) {
      __int16 v5 = a4;
    }
    return (unsigned __int16)(v5 + v4);
  }
  else
  {
    unsigned __int16 v6 = a2 - 160;
    if (a4)
    {
      unsigned __int16 v7 = (v6 >> 2) - 72;
      if ((unsigned __int16)(a3 - 1) < v7) {
        unsigned __int16 v7 = a3;
      }
      if ((a1 & 0x40) == 0) {
        unsigned __int16 v7 = (v7 + 7) & 0xFFF8;
      }
      __int16 v8 = (a4 + 7) & 0xFFF8;
      if ((a1 & 0x40) != 0) {
        __int16 v8 = a4;
      }
      return (unsigned __int16)(v7 + v8);
    }
  }
  return v6;
}

uint64_t btree_entry_size_check(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unint64_t v4 = *(void *)(a1 + 400);
  unsigned int v5 = (v4 >> 9) & 0x3FFF;
  if (v5) {
    BOOL v6 = v5 == a2;
  }
  else {
    BOOL v6 = 1;
  }
  if (!v6) {
    return 22;
  }
  BOOL v8 = !(unsigned __int16)(v4 >> 23) || (unsigned __int16)(v4 >> 23) == a3;
  if (!v8 && (a3 != 65534 && a3 || (v4 & 4) == 0)) {
    return 22;
  }
  uint64_t v9 = (v4 >> 27) & 0x1F000;
  if (!v5 && a2 > (unsigned __int16)(((unsigned __int16)(v9 - 160) >> 2) - 72)) {
    return 22;
  }
  if (a3 == 65534) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = a3;
  }
  unsigned int v12 = btree_entry_max_size(v4, v9, v5, (unsigned __int16)(v4 >> 23));
  unsigned int v13 = (a2 + 7) & 0xFFFFFFF8;
  if ((v4 & 0x40) != 0) {
    unsigned int v13 = a2;
  }
  unsigned int v14 = (v11 + 7) & 0xFFFFFFF8;
  if ((v4 & 0x40) != 0) {
    unsigned int v14 = v11;
  }
  if (v13 + v14 <= v12) {
    return 0;
  }
  else {
    return 34;
  }
}

uint64_t btree_node_sanity_check(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[7];
  unsigned int v5 = obj_size_phys((uint64_t)a1);
  unsigned int v6 = v5;
  unsigned int v7 = *(unsigned __int16 *)(v4 + 32);
  if ((v7 & 4) != 0) {
    unsigned int v8 = 4;
  }
  else {
    unsigned int v8 = 8;
  }
  if (a2)
  {
    unint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = (v9 >> 27) & 0x1F000;
    BOOL v11 = v5 != v10;
    int v12 = *(unsigned __int16 *)(a2 + 6);
    if (v12 == 61455)
    {
      unsigned __int8 v13 = v5 != v10;
    }
    else
    {
      if (v5 == v10) {
        char v15 = 1;
      }
      else {
        char v15 = 2;
      }
      if (*(unsigned __int16 *)(v4 + 34) == v12) {
        unsigned __int8 v13 = v11;
      }
      else {
        unsigned __int8 v13 = v15;
      }
    }
    if (((v9 >> 7) & 1) != ((v7 >> 3) & 1)) {
      ++v13;
    }
    if (((v9 >> 8) & 1) == ((v7 >> 4) & 1)) {
      unsigned __int8 v14 = v13;
    }
    else {
      unsigned __int8 v14 = v13 + 1;
    }
  }
  else
  {
    unsigned __int8 v14 = 0;
  }
  if (v5 % *(_DWORD *)(*(void *)(*(void *)(*a1 + 392) + 376) + 36)) {
    unsigned __int8 v16 = v14 + 1;
  }
  else {
    unsigned __int8 v16 = v14;
  }
  int v17 = obj_type((uint64_t)a1);
  unsigned int v18 = *(unsigned __int16 *)(v4 + 32);
  if (v17 != 2)
  {
    if ((v18 & 0x10) == 0 && *(_WORD *)(v4 + 24) != 3) {
      ++v16;
    }
    if (v18) {
      unsigned __int8 v19 = v16 + 1;
    }
    else {
      unsigned __int8 v19 = v16;
    }
    if ((v18 & 2) == 0) {
      goto LABEL_38;
    }
LABEL_36:
    if (*(_WORD *)(v4 + 34)) {
      ++v19;
    }
    goto LABEL_38;
  }
  if ((v18 & 0x10) == 0 && *(_WORD *)(v4 + 24) != 2) {
    ++v16;
  }
  if ((v18 & 1) == 0)
  {
    unsigned __int8 v19 = v16 + 1;
    if ((v18 & 2) == 0) {
      goto LABEL_38;
    }
    goto LABEL_36;
  }
  uint64_t v38 = v4 + v6;
  unsigned int v39 = *(_DWORD *)(v38 - 40);
  if (v6 <= 0x10000 && *(_DWORD *)(v38 - 36) == v6) {
    unsigned __int8 v41 = v16;
  }
  else {
    unsigned __int8 v41 = v16 + 1;
  }
  uint64_t v43 = *(unsigned int *)(v38 - 32);
  unint64_t v42 = *(unsigned int *)(v38 - 28);
  if (v43 > (unsigned __int16)(((unsigned __int16)(v6 - 160) >> 2) - 72)) {
    ++v41;
  }
  if (v6 - (v43 + (unint64_t)v8) - 96 > v42) {
    unsigned __int8 v44 = v41;
  }
  else {
    unsigned __int8 v44 = v41 + 1;
  }
  if (((v39 >> 7) & 1) == ((v18 >> 3) & 1)) {
    unsigned __int8 v45 = v44;
  }
  else {
    unsigned __int8 v45 = v44 + 1;
  }
  if (((v39 >> 8) & 1) == ((v18 >> 4) & 1)) {
    unsigned __int8 v19 = v45;
  }
  else {
    unsigned __int8 v19 = v45 + 1;
  }
  if ((v18 & 2) != 0) {
    goto LABEL_36;
  }
LABEL_38:
  if (v18) {
    __int16 v20 = -96;
  }
  else {
    __int16 v20 = -56;
  }
  unsigned __int16 v21 = v20 + v6;
  if (*(_WORD *)(v4 + 40)) {
    ++v19;
  }
  unsigned int v22 = *(unsigned __int16 *)(v4 + 42);
  if (v21 < v22) {
    ++v19;
  }
  if (((v8 - 1) & v22) != 0) {
    ++v19;
  }
  if ((v7 & 4) != 0) {
    char v23 = 2;
  }
  else {
    char v23 = 3;
  }
  if (*(_DWORD *)(v4 + 36) > v22 >> v23) {
    ++v19;
  }
  unsigned int v24 = *(unsigned __int16 *)(v4 + 44);
  unsigned int v25 = (unsigned __int16)(v21 - v22);
  BOOL v26 = v25 >= v24;
  int v27 = v25 - v24;
  if (!v26) {
    ++v19;
  }
  if (v27 >= *(unsigned __int16 *)(v4 + 46)) {
    int v28 = 0;
  }
  else {
    int v28 = 255;
  }
  if (v28 == v19) {
    return 0;
  }
  uint64_t v30 = *(void *)(*a1 + 392);
  if (v30)
  {
    BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(v30);
    obj_type((uint64_t)a1);
    obj_subtype((uint64_t)a1);
    obj_oid((uint64_t)a1);
    log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s BT node sanity check failed for node type %u subtype %u oid %llu with mask 0x%x!\n", v32, v33, v34, v35, v36, v37, (uint64_t)"btree_node_sanity_check");
    uint64_t v30 = *(void *)(*a1 + 392);
  }

  return nx_corruption_detected_int(v30);
}

uint64_t sub_10002FFAC(uint64_t a1, unsigned int a2, uint64_t a3)
{
  if (!a3) {
    return 22;
  }
  __int16 v3 = *(_WORD *)(a3 + 4);
  __int16 v4 = v3 & 0x1B;
  *(_WORD *)(a1 + 32) = v4;
  *(_WORD *)(a1 + 34) = *(_WORD *)(a3 + 6);
  unint64_t v5 = *(void *)(a3 + 8);
  if (((v5 >> 27) & 0x1F000) != a2) {
    return 22;
  }
  unint64_t v6 = a2 - 56;
  unsigned int v7 = (v5 >> 9) & 0x3FFF;
  uint64_t v8 = (HIWORD(v5) & 0x7F) + 8;
  int v9 = (unsigned __int16)(v5 >> 23);
  if ((v3 & 2) != 0) {
    int v10 = v9;
  }
  else {
    int v10 = v8;
  }
  LOWORD(v11) = 64;
  if (v7 && v10)
  {
    v4 |= 4u;
    *(_WORD *)(a1 + 32) = v4;
    int v11 = (4 * (v6 / (v7 + v10 + 4))) & 0xFFFFFFF8;
  }
  uint64_t v12 = 0;
  if (v4) {
    LOWORD(v6) = a2 - 96;
  }
  *(_WORD *)(a1 + 40) = 0;
  *(_WORD *)(a1 + 42) = v11;
  *(_WORD *)(a1 + 44) = 0;
  *(_WORD *)(a1 + 46) = v6 - v11;
  *(void *)(a1 + 48) = 0xFFFF0000FFFFLL;
  if (v4)
  {
    uint64_t v12 = 0;
    unsigned __int8 v13 = (_DWORD *)(a1 + (unsigned __int16)(a2 - 96));
    v13[14] = *(_DWORD *)(a3 + 8) & 0x1FF;
    v13[15] = a2;
    v13[16] = (*(_DWORD *)(a3 + 8) >> 9) & 0x3FFF;
    v13[17] = (unsigned __int16)(*(void *)(a3 + 8) >> 23);
  }
  return v12;
}

uint64_t sub_100030094(uint64_t a1, uint64_t a2)
{
  return sub_10003B8EC(a1, a2, 1);
}

uint64_t sub_10003009C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8 = *(_WORD *)(a1[7] + 32);
  if ((v8 & 8) != 0) {
    return 45;
  }
  uint64_t v11 = a1[1];
  if (v11)
  {
    if (obj_modify((void *)a1[1], 0, a5, a4, a5, a6, a7, a8))
    {
      obj_oid(v11);
      log_err((uint64_t)"%s:%d: %s obj_modify(fs %lld) failed: %d\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"btree_node_reap");
    }
    if ((*(_WORD *)(a1[7] + 32) & 2) != 0) {
      goto LABEL_22;
    }
    uint64_t v13 = obj_oid(v11);
    goto LABEL_10;
  }
  if ((v8 & 2) == 0)
  {
    uint64_t v13 = 0;
LABEL_10:
    int v21 = obj_type_and_flags((uint64_t)a1);
    if (((*(_WORD *)(a1[7] + 36) - 1) & 0x8000) == 0)
    {
      unsigned int v22 = v21 & 0xFFFF0000 | 3;
      int v23 = (unsigned __int16)(*(_WORD *)(a1[7] + 36) - 1);
      do
      {
        unint64_t v50 = 0;
        if (btree_node_child_id((uint64_t)a1, (unsigned __int16)v23, &v50))
        {
          obj_oid((uint64_t)a1);
          log_err((uint64_t)"%s:%d: %s error getting oid for child %d of 0x%llx: %d\n", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"btree_node_reap");
        }
        else
        {
          uint64_t v24 = *a1;
          if (*(unsigned __int16 *)(a1[7] + 34) < 2u)
          {
            int v42 = obj_size_phys((uint64_t)a1);
            if (obj_delete_and_free_by_oid(v24, v22, v42, v13, v50, a5)) {
              log_err((uint64_t)"%s:%d: %s error deleting child 0x%llx type 0x%x: %d\n", v43, v44, v45, v46, v47, v48, v49, (uint64_t)"btree_node_reap");
            }
          }
          else
          {
            uint64_t v25 = *(void *)(v24 + 392);
            int v26 = obj_size_phys((uint64_t)a1);
            if (nx_reaper_add_sub_object(v25, v22, v26, v13, v50, a5, 0)) {
              log_err((uint64_t)"%s:%d: %s error adding child 0x%llx type 0x%x to reap list: %d\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"btree_node_reap");
            }
          }
        }
      }
      while (v23-- > 0);
    }
  }
LABEL_22:
  obj_delete_and_free(a1, a5);
  return 0;
}

uint64_t btree_node_get(void *a1, void *a2, uint64_t a3, unsigned int a4, __int16 a5, uint64_t a6, uint64_t **a7)
{
  unint64_t v14 = a1[50];
  if ((v14 & 0x40000000000000) != 0) {
    size_t v15 = 96;
  }
  else {
    size_t v15 = (HIWORD(v14) & 0x7F) + 32;
  }
  __chkstk_darwin();
  uint64_t v17 = (char *)&v31 - v16;
  bzero((char *)&v31 - v16, v15);
  uint64_t v32 = 0;
  long long v31 = btree_node_desc;
  __int16 v18 = obj_flags((uint64_t)a1);
  if ((a4 & 0xFFFFFE30) != 0) {
    sub_10005F644();
  }
  int v19 = v18 & 0xFC00;
  *(_WORD *)uint64_t v17 = 25987;
  *((_WORD *)v17 + 1) = v15;
  *(_OWORD *)(v17 + 8) = *((_OWORD *)a1 + 25);
  *((void *)v17 + 3) = a1[52];
  unint64_t v20 = a1[50];
  if ((v20 & 0x80) != 0)
  {
    if ((v20 & 0x40000000000000) != 0) {
      size_t v21 = 64;
    }
    else {
      size_t v21 = HIWORD(v20) & 0x7F;
    }
    memcpy(v17 + 32, a2 + 1, v21);
  }
  *((_WORD *)v17 + 2) = 0;
  *((_WORD *)v17 + 3) = a5;
  DWORD2(v31) = obj_size_phys((uint64_t)a1);
  int v22 = obj_type_and_flags((uint64_t)a1);
  LODWORD(v31) = v22 & 0xFFFF0000 | 3;
  DWORD1(v31) = obj_subtype((uint64_t)a1);
  if ((v22 & 0x40000000) != 0) {
    int v23 = 3;
  }
  else {
    int v23 = 1;
  }
  unsigned int v24 = v19 | v22 & 0xFFFF0000 | ((int)(a4 << 31) >> 31) & v23;
  if ((a4 & 0x40) != 0) {
    uint64_t v25 = 0;
  }
  else {
    uint64_t v25 = &v31;
  }
  uint64_t result = obj_get(*a1, (2 * (a4 & 2)) & 0xDF | (32 * ((a4 >> 2) & 1)) | a4 & 0x180 | v24, *a2, v25, v17, a1[1], a3, a6, &v32);
  uint64_t v27 = v32;
  if ((a4 & 0x104) != 4 || result)
  {
    if (result)
    {
      uint64_t v30 = 0;
      goto LABEL_29;
    }
LABEL_28:
    uint64_t v30 = v32;
LABEL_29:
    *a7 = v30;
    if (result | a4 & 0x180) {
      return result;
    }
    if (v27)
    {
      uint64_t result = 0;
      if ((~v24 & 0x40000001) == 0 || v27[14] == *a2) {
        return result;
      }
    }
    else if ((~v24 & 0x40000001) == 0)
    {
      return 0;
    }
    sub_10005F618();
  }
  if ((v32[2] & 0x10) == 0) {
    goto LABEL_28;
  }
  if (a4) {
    char v28 = 2;
  }
  else {
    char v28 = 1;
  }
  if ((a4 & 2) != 0) {
    char v29 = v28;
  }
  else {
    char v29 = 0;
  }
  btree_node_release(v32, v29);
  *a7 = 0;
  return 2;
}

void btree_node_release(uint64_t *a1, char a2)
{
  unsigned int v3 = a2 & 3;
  if (v3) {
    obj_unlock((uint64_t)a1, v3);
  }

  obj_release(a1);
}

uint64_t btree_node_toc_entry_size(uint64_t a1)
{
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 4) != 0) {
    return 4;
  }
  else {
    return 8;
  }
}

uint64_t btree_node_toc_required_capacity(uint64_t a1, int a2)
{
  uint64_t v2 = *(_WORD **)(a1 + 56);
  __int16 v3 = v2[16];
  if ((v3 & 4) != 0)
  {
    unint64_t v5 = *(void *)(a1 + 400);
    if ((v5 & 4) != 0)
    {
      if ((v3 & 2) != 0) {
        unint64_t v9 = v5 >> 23;
      }
      else {
        LODWORD(v9) = (HIWORD(v5) & 0x7F) + 8;
      }
      unint64_t v10 = (((v5 >> 27) & 0x1F000) - 56) / (((v5 >> 9) & 0x3FFF) + (unsigned __int16)v9 + 4);
      unsigned __int16 v11 = v2[18] + a2;
      if ((v10 & 0xFFFE) >= v11) {
        LOWORD(v4) = v10 & 0xFFFE;
      }
      else {
        LOWORD(v4) = (v11 + 7) & 0xFFF8;
      }
    }
    else
    {
      unsigned int v6 = (unsigned __int16)v2[21];
      BOOL v7 = (v3 & 4) == 0;
      char v8 = 2;
      if (v7) {
        char v8 = 3;
      }
      return (unsigned __int16)(v6 >> v8);
    }
  }
  else
  {
    unsigned int v4 = (a2 + *((_DWORD *)v2 + 9) + 7) & 0xFFFFFFF8;
    if (!v4) {
      LOWORD(v4) = 8;
    }
  }
  return (unsigned __int16)v4;
}

uint64_t btree_node_key_off(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 376);
  __int16 v3 = (unsigned __int16 *)(v2 + 4 * a2);
  unsigned int v4 = (unsigned __int16 *)(v2 + 8 * a2);
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 4) != 0) {
    unint64_t v5 = v3;
  }
  else {
    unint64_t v5 = v4;
  }
  return *v5;
}

uint64_t btree_node_key_len(uint64_t a1, unsigned int a2)
{
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 4) != 0) {
    return (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else {
    return *(unsigned __int16 *)(*(void *)(a1 + 376) + 8 * a2 + 2);
  }
}

uint64_t btree_node_val_off(uint64_t a1, unsigned int a2)
{
  uint64_t v2 = *(void *)(a1 + 376);
  uint64_t v3 = v2 + 4 * a2 + 2;
  uint64_t v4 = v2 + 8 * a2 + 4;
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 4) != 0) {
    unint64_t v5 = (unsigned __int16 *)v3;
  }
  else {
    unint64_t v5 = (unsigned __int16 *)v4;
  }
  return *v5;
}

uint64_t btree_node_val_len(uint64_t a1, unsigned int a2)
{
  __int16 v2 = *(_WORD *)(*(void *)(a1 + 56) + 32);
  uint64_t v3 = *(void *)(a1 + 376);
  if ((v2 & 4) != 0)
  {
    uint64_t v4 = (unsigned __int16 *)(v3 + 4 * a2 + 2);
    uint64_t v5 = *(void *)(a1 + 400) >> 23;
  }
  else
  {
    uint64_t v5 = v3 + 8 * a2;
    uint64_t v4 = (unsigned __int16 *)(v5 + 4);
    LOWORD(v5) = *(_WORD *)(v5 + 6);
  }
  int v6 = *v4;
  if (v6 == 0xFFFF)
  {
    LOWORD(v5) = 0;
  }
  else if (v6 == 65534)
  {
    LOWORD(v5) = -2;
  }
  else if ((v2 & 2) == 0)
  {
    LOWORD(v5) = (*(_WORD *)(a1 + 406) & 0x7F) + 8;
  }
  return (unsigned __int16)v5;
}

uint64_t btree_node_key_ptr(uint64_t a1, unsigned int a2, void *a3, _WORD *a4)
{
  if (!a1) {
    return 22;
  }
  uint64_t v5 = *(void *)(a1 + 56);
  if (*(_DWORD *)(v5 + 36) <= a2) {
    return 22;
  }
  __int16 v8 = *(_WORD *)(v5 + 32);
  uint64_t v9 = *(void *)(a1 + 376);
  unint64_t v10 = (unsigned __int16 *)(v9 + 4 * a2);
  if ((v8 & 4) == 0) {
    unint64_t v10 = (unsigned __int16 *)(v9 + 8 * a2);
  }
  uint64_t v11 = *v10;
  if ((v8 & 4) != 0) {
    int v12 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else {
    int v12 = *(unsigned __int16 *)(v9 + 8 * a2 + 2);
  }
  uint64_t result = sub_100030894(a1, *v10, v12);
  if (!result)
  {
    *a3 = *(void *)(a1 + 384) + v11;
    uint64_t result = 0;
    if (a4) {
      *a4 = v12;
    }
  }
  return result;
}

uint64_t sub_100030894(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v3 = *(unsigned __int16 *)(*(void *)(a1 + 56) + 44);
  BOOL v4 = v3 >= a2;
  int v5 = v3 - a2;
  if (v5 == 0 || !v4) {
    return nx_corruption_detected_int(*(void *)(*(void *)a1 + 392));
  }
  int v6 = (a3 + 7) & 0x1FFF8;
  if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
    int v6 = a3;
  }
  if (v6 <= v5) {
    return 0;
  }
  else {
    return nx_corruption_detected_int(*(void *)(*(void *)a1 + 392));
  }
}

uint64_t btree_node_val_ptr(void *a1, unsigned int a2, void *a3, __int16 *a4)
{
  uint64_t v4 = a1[7];
  if (*(_DWORD *)(v4 + 36) <= (signed int)a2) {
    return 22;
  }
  uint64_t v8 = a1[47];
  uint64_t v9 = v8 + 4 * a2 + 2;
  uint64_t v10 = v8 + 8 * a2 + 4;
  if ((*(_WORD *)(v4 + 32) & 4) != 0) {
    uint64_t v11 = (unsigned __int16 *)v9;
  }
  else {
    uint64_t v11 = (unsigned __int16 *)v10;
  }
  uint64_t v12 = *v11;
  unsigned int v13 = btree_node_val_len((uint64_t)a1, a2);
  __int16 v14 = v13;
  uint64_t result = sub_1000309C0((uint64_t)a1, v12, v13);
  if (!result)
  {
    if (v12 >= 0xFFFE)
    {
      *a3 = 0;
      if (!a4) {
        return 0;
      }
      if (v12 == 0xFFFF) {
        __int16 v14 = 0;
      }
      else {
        __int16 v14 = -2;
      }
    }
    else
    {
      *a3 = a1[49] - v12;
      if (!a4) {
        return 0;
      }
    }
    uint64_t result = 0;
    *a4 = v14;
  }
  return result;
}

uint64_t sub_1000309C0(uint64_t a1, unsigned int a2, unsigned int a3)
{
  if (a2 < 0xFFFE)
  {
    if (!a3 || a3 == 65534) {
      goto LABEL_16;
    }
    __int16 v6 = obj_size_phys(a1);
    uint64_t v7 = *(void *)(a1 + 56);
    __int16 v8 = (*(unsigned char *)(v7 + 32) & 1) != 0 ? -96 : -56;
    if (a2 > (unsigned __int16)(v6 - *(_WORD *)(v7 + 42) + v8 - (*(_WORD *)(v7 + 46) + *(_WORD *)(v7 + 44)))) {
      goto LABEL_16;
    }
    unsigned int v9 = (a3 + 7) & 0x1FFF8;
    if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
      unsigned int v9 = a3;
    }
    if (v9 > a2) {
      goto LABEL_16;
    }
    return 0;
  }
  if ((*(unsigned char *)(a1 + 400) & 4) != 0 && (!a3 || a3 == 65534)) {
    return 0;
  }
LABEL_16:
  uint64_t v10 = *(void *)(*(void *)a1 + 392);

  return nx_corruption_detected_int(v10);
}

uint64_t btree_node_child_val(uint64_t a1, unsigned int a2, void *a3)
{
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 2) != 0) {
    return 22;
  }
  unsigned int v9 = 0;
  unsigned __int16 v8 = 0;
  uint64_t result = btree_node_val_ptr((void *)a1, a2, &v9, (__int16 *)&v8);
  if (result) {
    return result;
  }
  if ((*(_WORD *)(a1 + 406) & 0x7F) + 8 == v8)
  {
    uint64_t result = 0;
    if (!a3) {
      return result;
    }
  }
  else
  {
    uint64_t result = nx_corruption_detected_int(*(void *)(*(void *)a1 + 392));
    if (!a3) {
      return result;
    }
  }
  if (!result)
  {
    __int16 v6 = v9;
    uint64_t v7 = *v9;
    *a3 = *v9;
    if ((*(unsigned char *)(*(void *)(a1 + 56) + 32) & 8) != 0)
    {
      *a3 = *(void *)(a1 + 408) + v7;
      memcpy(a3 + 1, v6 + 1, v8 - 8);
    }
    return 0;
  }
  return result;
}

uint64_t btree_node_child_id(uint64_t a1, unsigned int a2, void *a3)
{
  __chkstk_darwin();
  uint64_t v7 = (uint64_t *)((char *)&v10 - v6);
  bzero((char *)&v10 - v6, v8);
  uint64_t result = btree_node_child_val(a1, a2, v7);
  if (!result) {
    *a3 = *v7;
  }
  return result;
}

uint64_t bt_insert(uint64_t *a1, uint64_t a2, unint64_t *a3, int a4, void *a5, unsigned int a6, uint64_t a7)
{
  LODWORD(v10) = a4;
  __chkstk_darwin();
  size_t v15 = (uint64_t *)((char *)&v222 - v14);
  bzero((char *)&v222 - v14, v16);
  long long v258 = 0u;
  long long v259 = 0u;
  long long v257 = 0u;
  uint64_t v255 = 0;
  uint64_t v256 = 0;
  uint64_t v254 = 0;
  int v253 = 0;
  uint64_t v249 = 0;
  if (!obj_refcount((uint64_t)a1)) {
    sub_10005F670();
  }
  if (!a1[52]) {
    return 22;
  }
  unsigned __int16 v251 = v10;
  if (a6 == 65534) {
    unsigned __int16 v17 = 0;
  }
  else {
    unsigned __int16 v17 = a6;
  }
  unsigned __int16 v250 = v17;
  uint64_t v18 = btree_entry_size_check((uint64_t)a1, v10, a6);
  if (v18)
  {
    uint64_t v19 = v18;
    btree_entry_max_size(a1[50], ((unint64_t)a1[50] >> 27) & 0xF000, (a1[50] >> 9) & 0x3FFF, (unsigned __int16)((unint64_t)a1[50] >> 23));
    log_err((uint64_t)"%s:%d: %s request to insert entry %d (%d) %d (%d) = (%d), max size is %d key %d, error %d\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"bt_insert");
    return v19;
  }
  obj_lock((uint64_t)a1, 2u);
  uint64_t v20 = obj_modify(a1, (*((_DWORD *)a1 + 100) >> 3) & 2, a7);
  if (v20)
  {
    uint64_t v19 = v20;
    obj_unlock((uint64_t)a1, 2u);
    return v19;
  }
  unsigned __int16 v252 = 0;
  *(void *)&long long v257 = a1;
  obj_retain(a1);
  uint64_t v29 = a1[49];
  int v30 = *(_DWORD *)(v29 + 16);
  unsigned int v31 = (unsigned __int16)v30;
  BOOL v32 = *(_DWORD *)(v29 + 20) >= v17;
  if ((unsigned __int16)v30 < (unsigned __int16)v10) {
    int v30 = v10;
  }
  int v233 = v30;
  if (v31 < (unsigned __int16)v10) {
    BOOL v32 = 0;
  }
  BOOL v245 = v32;
  uint64_t v33 = (uint64_t)a1;
  if (a1[54])
  {
    uint64_t v34 = (uint64_t (*)(uint64_t, unint64_t *, void))a1[53];
    uint64_t v33 = (uint64_t)a1;
    if (v34)
    {
      uint64_t v35 = a1[1];
      if (!v35) {
        uint64_t v35 = *(void *)(*a1 + 392);
      }
      int v36 = v34(v35, a3, (unsigned __int16)v10);
      uint64_t v33 = (uint64_t)a1;
      if (v36)
      {
        long long v258 = v257;
        *(void *)&long long v257 = 0;
        uint64_t v37 = a1[54];
        *size_t v15 = v37;
        if (v37 != obj_oid((uint64_t)a1)
          && !btree_node_get(a1, v15, a2, (a7 != 0) | (((*(unsigned __int16 *)(a1[7] + 32) >> 3) & 1) << 6) | 6u, 61455, a7, (uint64_t **)&v257))
        {
          uint64_t v243 = a2;
          uint64_t v38 = (uint64_t *)v257;
          if ((*(_WORD *)(*(void *)(v257 + 56) + 32) & 2) != 0 && a1[54] == *(void *)(v257 + 112))
          {
            int v39 = sub_100032A9C(v257, a3, (unsigned __int16)v10, (_WORD *)&v257 + 4, (BOOL *)((unint64_t)&v257 | 0xA));
            uint64_t v38 = (uint64_t *)v257;
            if (!v39)
            {
              if (WORD4(v257))
              {
                uint64_t v40 = (unsigned int (*)(void))sub_100032C58;
                if (!BYTE10(v257)) {
                  uint64_t v40 = (unsigned int (*)(void))sub_1000334DC;
                }
                if (!v40(v257))
                {
                  uint64_t v162 = 0;
                  uint64_t v44 = 0;
                  uint64_t v19 = 0;
                  int v239 = 0;
                  BOOL v246 = 0;
                  goto LABEL_332;
                }
              }
            }
          }
          obj_unlock((uint64_t)v38, 2u);
          obj_release(v38);
          a2 = v243;
        }
        long long v257 = v258;
        *(void *)&long long v258 = 0;
        uint64_t v33 = v257;
      }
    }
  }
  __int16 v41 = *(_WORD *)(*(void *)(v33 + 56) + 32);
  int v42 = (BOOL *)((unint64_t)&v257 | 0xA);
  long long v244 = (BOOL *)((unint64_t)&v257 | 0xA);
  if ((v41 & 2) != 0) {
    uint64_t v43 = sub_100032A9C(v33, a3, (unsigned __int16)v10, (_WORD *)&v257 + 4, v42);
  }
  else {
    uint64_t v43 = sub_10003393C(v33, a3, (unsigned __int16)v10, (_WORD *)&v257 + 4, v42);
  }
  uint64_t v19 = v43;
  if (v43) {
    goto LABEL_36;
  }
  uint64_t v45 = (uint64_t *)v257;
  uint64_t v46 = *(void *)(v257 + 56);
  unsigned int v47 = *(_DWORD *)(v46 + 36);
  __int16 v48 = *(_WORD *)(v46 + 32);
  LODWORD(v247) = (__PAIR64__(v47, v48 & 2) - 1) >> 32 == WORD4(v257);
  int v49 = WORD4(v257) | BYTE10(v257) | v48 & 2;
  uint64_t v242 = (unsigned __int16 *)&v257 + 4;
  uint64_t v243 = a2;
  if (v49)
  {
    uint64_t v45 = 0;
    if ((v48 & 2) != 0)
    {
      int v239 = 0;
      BOOL v246 = 0;
      uint64_t v238 = 0;
      uint64_t v44 = 0;
LABEL_40:
      unint64_t v50 = (uint64_t *)v259;
      if ((void)v259)
      {
        int v51 = v245;
        if ((uint64_t *)v259 != a1) {
          int v51 = 1;
        }
        if (v51 == 1 && (uint64_t *)v259 != v44 && (uint64_t *)v259 != v238)
        {
          obj_unlock(v259, 2u);
          obj_release(v50);
        }
        *(void *)&long long v259 = 0;
      }
      uint64_t v52 = v242;
      if (v247)
      {
        uint64_t v53 = a1[54];
        uint64_t v54 = *(void *)(v257 + 112);
        if (v53)
        {
          if (v53 != v54) {
            sub_10005F6F4();
          }
        }
        else if (v54 && (a1[50] & 0x10) == 0)
        {
          a1[54] = v54;
        }
      }
      uint64_t v10 = v251;
      if (BYTE10(v257)) {
        uint64_t v55 = sub_100032C58(v257, WORD4(v257), a3, v251, a5, (unsigned __int16)a6, a7);
      }
      else {
        uint64_t v55 = sub_1000334DC(v257, WORD4(v257), a3, v251, a5, (unsigned __int16)a6, a7);
      }
      uint64_t v19 = v55;
      if (v55 != 28) {
        goto LABEL_315;
      }
      uint64_t v150 = sub_100033C6C(a1, v258, WORD4(v258), (void *)v257, WORD4(v257), a3, v10, 1u, (__int16 *)&v251, (__int16 *)&v250, 0, v243, a7, &v256);
      if (v150)
      {
        uint64_t v19 = v150;
LABEL_314:
        log_err((uint64_t)"%s:%d: %s bt_shift_or_split failed with error: %d\n", v151, v152, v153, v154, v155, v156, v157, (uint64_t)"bt_insert");
LABEL_315:
        if (v19)
        {
          uint64_t v162 = v238;
        }
        else
        {
          uint64_t v162 = v238;
          if (!WORD4(v257) && (void)v258)
          {
            uint64_t v163 = btree_node_key_ptr(v258, WORD4(v258), &v254, &v252);
            if (v163)
            {
              uint64_t v19 = v163;
            }
            else
            {
              uint64_t v164 = a1[1];
              if (!v164) {
                uint64_t v164 = *(void *)(*a1 + 392);
              }
              uint64_t v19 = ((uint64_t (*)(uint64_t, unint64_t *, uint64_t, unint64_t *, void, int *))a1[52])(v164, a3, v10, v254, v252, &v253);
              if (!v19)
              {
                if (v253)
                {
                  uint64_t v19 = sub_100032C58(v258, WORD4(v258), a3, v10, 0, 0, a7);
                  if (v19) {
                    log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v165, v166, v167, v168, v169, v170, v171, (uint64_t)"bt_insert");
                  }
                }
              }
            }
          }
        }
LABEL_332:
        uint64_t v176 = (uint64_t *)v258;
        if ((void)v258)
        {
          int v177 = v245;
          if ((uint64_t *)v258 != a1) {
            int v177 = 1;
          }
          if (v177 == 1 && (uint64_t *)v258 != v44 && (uint64_t *)v258 != v162)
          {
            obj_unlock(v258, 2u);
            obj_release(v176);
          }
          *(void *)&long long v258 = 0;
        }
        uint64_t v178 = (uint64_t *)v257;
        if ((void)v257)
        {
          int v179 = v245;
          if ((uint64_t *)v257 != a1) {
            int v179 = 1;
          }
          if (v179 == 1 && (uint64_t *)v257 != v44 && (uint64_t *)v257 != v162)
          {
            obj_unlock(v257, 2u);
            obj_release(v178);
          }
          *(void *)&long long v257 = 0;
        }
        if (v19) {
          goto LABEL_408;
        }
        uint64_t v180 = a1[49];
        unsigned int v181 = *(_DWORD *)(v180 + 16);
        BOOL v182 = v181 >= (unsigned __int16)v10;
        int v183 = v181 < (unsigned __int16)v10;
        if (!v182) {
          *(_DWORD *)(v180 + 16) = (unsigned __int16)v10;
        }
        if (*(_DWORD *)(v180 + 20) < v250)
        {
          *(_DWORD *)(v180 + 20) = v250;
          int v183 = 1;
        }
        if (BYTE10(v257))
        {
          if ((((a1[50] & 0x80) == 0) & ~v183) != 0) {
            goto LABEL_358;
          }
        }
        else
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v180 + 24), 1uLL, memory_order_relaxed);
        }
        obj_dirty((uint64_t)a1, a7, 0);
LABEL_358:
        if (!v246 || WORD4(v257) != 0)
        {
          uint64_t v19 = 0;
          goto LABEL_408;
        }
        if (v44)
        {
          uint64_t v19 = sub_100032C58((uint64_t)v44, (unsigned __int16)v239, a3, (unsigned __int16)v10, 0, 0, a7);
          if (v19) {
            log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v184, v185, v186, v187, v188, v189, v190, (uint64_t)"bt_insert");
          }
          int v191 = v245;
          if (v44 != a1) {
            int v191 = 1;
          }
          if (v44 != (uint64_t *)v259 && v44 != (uint64_t *)v258 && v191)
          {
            obj_unlock((uint64_t)v44, 2u);
            obj_release(v44);
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
        uint64_t v192 = v255;
        uint64_t v193 = v255 + 7;
        if (*(unsigned __int16 *)(v255[7] + 34) < 2u)
        {
LABEL_401:
          int v215 = v245;
          if (v192 != a1) {
            int v215 = 1;
          }
          if (v192 != (uint64_t *)v259 && v192 != (uint64_t *)v258 && v215)
          {
            obj_unlock((uint64_t)v192, 2u);
            obj_release(v192);
          }
          uint64_t v44 = 0;
          uint64_t v255 = 0;
          goto LABEL_408;
        }
        uint64_t v194 = v251;
        while (1)
        {
          WORD2(v248) = 0;
          LOBYTE(v248) = 0;
          uint64_t v195 = sub_10003393C((uint64_t)v192, a3, v194, (_WORD *)&v248 + 2, (BOOL *)&v248);
          if (v195)
          {
            uint64_t v19 = v195;
            goto LABEL_36;
          }
          if ((_BYTE)v248) {
            BOOL v196 = 0;
          }
          else {
            BOOL v196 = WORD2(v248) == 0;
          }
          if (!v196)
          {
            obj_oid((uint64_t)v192);
            obj_subtype((uint64_t)v192);
            log_err((uint64_t)"%s:%d: %s minkey update traversal unexpectedly found the key (%d) or a non-zero index (%d); oid %"
                       "llu subtype 0x%x level %d\n",
              v208,
              v209,
              v210,
              v211,
              v212,
              v213,
              v214,
              (uint64_t)"bt_insert");
LABEL_400:
            uint64_t v19 = 0;
            goto LABEL_401;
          }
          uint64_t v19 = sub_100032C58((uint64_t)v192, 0, a3, v194, 0, 0, a7);
          if (v19) {
            log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v197, v198, v199, v200, v201, v202, v203, (uint64_t)"bt_insert");
          }
          int v204 = *(unsigned __int16 *)(*v193 + 34);
          if (v204 == 2) {
            goto LABEL_401;
          }
          uint64_t v19 = btree_node_child_val((uint64_t)v192, 0, v15);
          uint64_t v255 = 0;
          if (!v19) {
            uint64_t v19 = btree_node_get(a1, v15, v243, 3u, (unsigned __int16)v204 - 1, a7, &v255);
          }
          int v205 = v245;
          if (v192 != a1) {
            int v205 = 1;
          }
          if (v192 != (uint64_t *)v259 && v192 != (uint64_t *)v258 && v205)
          {
            obj_unlock((uint64_t)v192, 2u);
            obj_release(v192);
          }
          uint64_t v192 = v255;
          if (v19) {
            break;
          }
          uint64_t v193 = v255 + 7;
          if (*(unsigned __int16 *)(v255[7] + 34) <= 1u) {
            goto LABEL_400;
          }
        }
        if (v255) {
          goto LABEL_401;
        }
LABEL_36:
        uint64_t v44 = 0;
        goto LABEL_408;
      }
      uint64_t v158 = v256;
      if (v256)
      {
        if ((void)v258)
        {
          if (v246) {
            sub_10005F6C8();
          }
          ++WORD4(v258);
          uint64_t v159 = (uint64_t *)v257;
          int v160 = v245;
          if ((uint64_t *)v257 != a1) {
            int v160 = 1;
          }
          if ((void)v257 && v160 && (uint64_t *)v257 != v44 && (uint64_t *)v257 != v238)
          {
            uint64_t v161 = v256;
            obj_unlock(v257, 2u);
            obj_release(v159);
            uint64_t v158 = v161;
          }
          uint64_t v256 = 0;
          *(void *)&long long v257 = v158;
          uint64_t v52 = v242;
        }
        else
        {
          uint64_t v172 = (uint64_t *)&v258 + 1;
          uint64_t v173 = v257;
          *(void *)&long long v258 = v257;
          int v174 = *(_DWORD *)(v256[7] + 36);
          uint64_t v247 = v256;
          if (v174)
          {
            uint64_t v241 = (uint64_t *)&v258 + 1;
            uint64_t v175 = btree_node_key_ptr((uint64_t)v256, 0, &v254, &v252);
            if (v175)
            {
              uint64_t v19 = v175;
              uint64_t v256 = 0;
              *(void *)&long long v257 = v247;
              goto LABEL_314;
            }
            uint64_t v173 = v258;
            uint64_t v206 = v254;
            uint64_t v207 = v252;
            uint64_t v172 = v241;
          }
          else
          {
            uint64_t v206 = a3;
            uint64_t v207 = v10;
          }
          uint64_t v19 = sub_10003393C(v173, v206, v207, v172, (BOOL *)&v258 + 10);
          uint64_t v158 = v247;
          uint64_t v256 = 0;
          *(void *)&long long v257 = v247;
          if (v19) {
            goto LABEL_314;
          }
        }
      }
      else
      {
        uint64_t v158 = (unint64_t *)v257;
      }
      uint64_t v19 = sub_100035BF4((uint64_t)v158, a3, v10, (unint64_t *)a5, (unsigned __int16)a6, a7, v52, v244);
      if (!v19) {
        goto LABEL_315;
      }
      goto LABEL_314;
    }
  }
  else
  {
    uint64_t v255 = (uint64_t *)v257;
  }
  int v239 = 0;
  uint64_t v44 = 0;
  BOOL v246 = v49 == 0;
  uint64_t v232 = &v259;
  uint64_t v231 = &v258;
  uint64_t v226 = (_WORD *)&v258 + 4;
  uint64_t v224 = (_WORD *)&v259 + 4;
  uint64_t v225 = (BOOL *)&v258 + 10;
  uint64_t v223 = (BOOL *)&v259 + 10;
  uint64_t v234 = v45;
  uint64_t v235 = v45;
  uint64_t v236 = v45;
  uint64_t v237 = v45;
  uint64_t v241 = v45;
  uint64_t v238 = v45;
  while (2)
  {
    int v56 = (uint64_t *)v259;
    int v57 = v245;
    if ((uint64_t *)v259 != a1) {
      int v57 = 1;
    }
    if ((void)v259) {
      BOOL v58 = v57 == 0;
    }
    else {
      BOOL v58 = 1;
    }
    BOOL v59 = v58 || (void)v259 == (void)v44;
    uint64_t v240 = v45;
    if (!v59 && (void)v259 != (void)v45)
    {
      obj_unlock(v259, 2u);
      obj_release(v56);
    }
    int v61 = v231;
    long long *v232 = *v231;
    *int v61 = v257;
    *(void *)&long long v257 = 0;
    uint64_t v62 = btree_node_child_val(v258, WORD4(v258), v15);
    if (v62
      || (uint64_t v62 = btree_node_get(a1, v15, v243, 3u, *(_WORD *)(*(void *)(v258 + 56) + 34) - 1, a7, (uint64_t **)&v257),
          v62))
    {
LABEL_291:
      uint64_t v19 = v62;
      goto LABEL_408;
    }
    int v66 = v242;
    while (1)
    {
      uint64_t v67 = v257;
      if ((a1[50] & 0x10) != 0)
      {
        uint64_t v68 = v244;
        if (*(void *)(v257 + 112) != *v15)
        {
          sub_100033980(v258, WORD4(v258), (unint64_t *)(v257 + 112), a7, v63, v64, v65);
          uint64_t v67 = v257;
        }
      }
      else
      {
        uint64_t v68 = v244;
      }
      if ((*(_WORD *)(*(void *)(v67 + 56) + 32) & 2) != 0) {
        uint64_t v69 = sub_100032A9C(v67, a3, v251, v66, v68);
      }
      else {
        uint64_t v69 = sub_10003393C(v67, a3, v251, v66, v68);
      }
      uint64_t v19 = v69;
      if (v69) {
        goto LABEL_408;
      }
      uint64_t v70 = (uint64_t *)v257;
      if ((v247 & 1) == 0)
      {
        LODWORD(v247) = 0;
        uint64_t v72 = *(void *)(v257 + 56);
        int v71 = WORD4(v257);
        if ((*(_WORD *)(v72 + 32) & 2) == 0) {
          goto LABEL_115;
        }
        goto LABEL_88;
      }
      int v71 = WORD4(v257);
      uint64_t v72 = *(void *)(v257 + 56);
      unsigned int v73 = *(unsigned __int16 *)(v72 + 32);
      if (((v73 >> 1) & 1) + *(_DWORD *)(v72 + 36) - 1 == WORD4(v257)) {
        break;
      }
      LODWORD(v247) = 0;
      if ((v73 & 2) == 0) {
        goto LABEL_115;
      }
LABEL_88:
      if (*(_DWORD *)(v72 + 36) != v71
        || (__int16 v74 = WORD4(v258), v75 = v258, *(_DWORD *)(*(void *)(v258 + 56) + 36) - 1 <= WORD4(v258))
        || sub_100033A54((uint64_t)v70, 1u, (__int16 *)&v251, (__int16 *)&v250, 0, 0, 0))
      {
        BOOL v80 = v71 != 0;
        if (v246 || v80 || BYTE10(v257)) {
          goto LABEL_118;
        }
LABEL_135:
        BOOL v246 = 0;
        goto LABEL_136;
      }
      uint64_t v62 = btree_node_child_val(v75, (unsigned __int16)(v74 + 1), v15);
      if (!v62)
      {
        uint64_t v76 = (uint64_t *)v257;
        obj_unlock(v257, 2u);
        obj_release(v76);
        *(void *)&long long v257 = 0;
        int v77 = WORD4(v258);
        ++WORD4(v258);
        if (v246 && v77 == 0)
        {
          int v66 = v242;
          if (v44)
          {
            int v78 = v245;
            if (v44 != a1) {
              int v78 = 1;
            }
            if (v44 != (uint64_t *)v259 && v44 != (uint64_t *)v258 && v78)
            {
              obj_unlock((uint64_t)v44, 2u);
              obj_release(v44);
              uint64_t v234 = v255;
              uint64_t v235 = v255;
              uint64_t v236 = v255;
              uint64_t v237 = v255;
              uint64_t v238 = v255;
              uint64_t v241 = v255;
            }
          }
          uint64_t v44 = v241;
          if (v241)
          {
            int v79 = v245;
            if (v241 != a1) {
              int v79 = 1;
            }
            if (v241 != (uint64_t *)v259 && v241 != (uint64_t *)v258 && v79)
            {
              obj_unlock((uint64_t)v241, 2u);
              obj_release(v44);
            }
            uint64_t v238 = 0;
            uint64_t v234 = 0;
            uint64_t v235 = 0;
            uint64_t v236 = 0;
            uint64_t v237 = 0;
            uint64_t v240 = 0;
            uint64_t v241 = 0;
            uint64_t v44 = 0;
            int v239 = 0;
            BOOL v246 = 0;
            uint64_t v255 = 0;
          }
          else
          {
            uint64_t v240 = 0;
            uint64_t v241 = 0;
            int v239 = 0;
            BOOL v246 = 0;
          }
        }
        else
        {
          int v66 = v242;
        }
        uint64_t v62 = btree_node_get(a1, v15, v243, 3u, *(_WORD *)(*(void *)(v258 + 56) + 34) - 1, a7, (uint64_t **)&v257);
        if (!v62) {
          continue;
        }
      }
      goto LABEL_291;
    }
    if (a1[54] == *(void *)(v258 + 112)) {
      a1[54] = *(void *)(v257 + 112);
    }
    LODWORD(v247) = 1;
    if ((v73 & 2) != 0) {
      goto LABEL_88;
    }
LABEL_115:
    BOOL v80 = v71 != 0;
    if (!v246 && !v80 && !BYTE10(v257))
    {
      uint64_t v44 = (uint64_t *)v258;
      BOOL v246 = 1;
      uint64_t v238 = v70;
      uint64_t v234 = v70;
      uint64_t v235 = v70;
      int v239 = WORD4(v258);
      uint64_t v236 = v70;
      uint64_t v255 = v70;
      uint64_t v237 = v70;
      uint64_t v240 = v70;
      uint64_t v241 = v70;
      goto LABEL_136;
    }
LABEL_118:
    if (!v246 || !v80) {
      goto LABEL_136;
    }
    if (v44)
    {
      int v81 = v245;
      if (v44 != a1) {
        int v81 = 1;
      }
      if (v44 != (uint64_t *)v259 && v44 != (uint64_t *)v258 && v81)
      {
        obj_unlock((uint64_t)v44, 2u);
        obj_release(v44);
        uint64_t v234 = v255;
        uint64_t v235 = v255;
        uint64_t v236 = v255;
        uint64_t v238 = v255;
        uint64_t v237 = v255;
      }
    }
    uint64_t v82 = v237;
    if (!v237)
    {
      uint64_t v237 = 0;
      uint64_t v240 = 0;
      uint64_t v241 = 0;
      uint64_t v44 = 0;
      int v239 = 0;
      goto LABEL_135;
    }
    int v83 = v245;
    if (v237 != a1) {
      int v83 = 1;
    }
    if (v237 != (uint64_t *)v259 && v237 != (uint64_t *)v258 && v83)
    {
      obj_unlock((uint64_t)v237, 2u);
      obj_release(v82);
    }
    uint64_t v238 = 0;
    uint64_t v234 = 0;
    uint64_t v235 = 0;
    uint64_t v236 = 0;
    uint64_t v237 = 0;
    uint64_t v240 = 0;
    uint64_t v241 = 0;
    uint64_t v44 = 0;
    int v239 = 0;
    BOOL v246 = 0;
    uint64_t v255 = 0;
LABEL_136:
    unsigned int v84 = sub_100033BF4(v257);
    int v85 = 0;
    if (WORD4(v257))
    {
      char v86 = 0;
    }
    else
    {
      char v86 = 0;
      if (!BYTE10(v257))
      {
        uint64_t v62 = btree_node_key_ptr(v258, WORD4(v258), &v254, &v252);
        if (v62) {
          goto LABEL_291;
        }
        uint64_t v87 = a1[1];
        if (!v87) {
          uint64_t v87 = *(void *)(*a1 + 392);
        }
        unsigned int v88 = v251;
        uint64_t v62 = ((uint64_t (*)(uint64_t, unint64_t *, void, unint64_t *, void, int *))a1[52])(v87, a3, v251, v254, v252, &v253);
        if (v62) {
          goto LABEL_291;
        }
        if (v253 < 0)
        {
          uint64_t v89 = *(void *)(v257 + 400);
          if ((v89 & 0x40) != 0) {
            unsigned int v90 = v88;
          }
          else {
            unsigned int v90 = (v88 + 7) & 0x1FFF8;
          }
          if ((v89 & 0x40) != 0) {
            unsigned int v91 = v252;
          }
          else {
            unsigned int v91 = (v252 + 7) & 0x1FFF8;
          }
          if (v90 <= v91)
          {
            int v85 = 0;
          }
          else
          {
            if ((v89 & 0x40) != 0) {
              int v92 = v88;
            }
            else {
              int v92 = (v88 + 7) & 0x1FFF8;
            }
            if ((*(void *)(v257 + 400) & 0x40) != 0) {
              int v93 = v252;
            }
            else {
              int v93 = (v252 + 7) & 0x1FFF8;
            }
            int v85 = v92 - v93;
          }
          char v86 = 1;
        }
        else
        {
          int v85 = 0;
          char v86 = 0;
        }
      }
    }
    unsigned int v94 = *(unsigned __int16 *)(*(void *)(v258 + 56) + 34);
    if (v94 < 2)
    {
      WORD2(v249) = v84;
      unint64_t v96 = *(void *)(v258 + 400);
      LOWORD(v97) = (BYTE6(v96) & 0x7F) + 8;
      LOWORD(v249) = v97;
      if ((v86 & 1) == 0)
      {
        unsigned __int16 v95 = v251;
        goto LABEL_169;
      }
      goto LABEL_167;
    }
    unsigned __int16 v95 = v251;
    if (v84 > v251) {
      unsigned __int16 v95 = v84;
    }
    WORD2(v249) = v95;
    unint64_t v96 = *(void *)(v258 + 400);
    int v97 = (HIWORD(v96) & 0x7F) + 8;
    LOWORD(v249) = (BYTE6(v96) & 0x7F) + 8;
    if (v86)
    {
LABEL_167:
      unsigned int v98 = 1;
      goto LABEL_170;
    }
LABEL_169:
    HIWORD(v249) = v95;
    WORD1(v249) = v97;
    unsigned int v98 = 2;
LABEL_170:
    LODWORD(v230) = v85;
    uint64_t v229 = (void *)v258;
    unsigned int v227 = v98;
    LODWORD(v228) = (__int16)v85;
    if (sub_100033A54(v258, v98, (__int16 *)&v249 + 2, (__int16 *)&v249, v85, 0, 0)) {
      goto LABEL_202;
    }
    if (v94 < 2)
    {
      uint64_t v100 = v257;
      if (BYTE10(v257))
      {
        if ((*(_WORD *)(*(void *)(v257 + 56) + 32) & 4) != 0)
        {
          uint64_t v102 = *(void *)(v257 + 400);
          unsigned int v101 = (v102 >> 9) & 0x3FFF;
        }
        else
        {
          unsigned int v101 = *(unsigned __int16 *)(*(void *)(v257 + 376) + 8 * WORD4(v257) + 2);
          uint64_t v102 = *(void *)(v257 + 400);
        }
        unsigned __int16 v252 = v101;
        unsigned int v106 = btree_node_val_len(v257, WORD4(v257));
        if (v106 == 65534) {
          unsigned int v107 = 0;
        }
        else {
          unsigned int v107 = v106;
        }
        unsigned int v108 = v251;
        if ((v102 & 0x40) == 0) {
          unsigned int v108 = (v251 + 7) & 0x1FFF8;
        }
        unsigned int v109 = (v101 + 7) & 0x1FFF8;
        if ((v102 & 0x40) != 0) {
          unsigned int v109 = v101;
        }
        unsigned int v110 = v250;
        if ((v102 & 0x40) == 0) {
          unsigned int v110 = (v250 + 7) & 0x1FFF8;
        }
        unsigned int v111 = (v107 + 7) & 0x1FFF8;
        if ((v102 & 0x40) != 0) {
          unsigned int v111 = v107;
        }
        __int16 v112 = v108 - v109;
        if (v108 < v109) {
          __int16 v112 = 0;
        }
        __int16 v113 = v110 - v111;
        if (v110 < v111) {
          __int16 v113 = 0;
        }
        if ((unsigned __int16)v112 | (unsigned __int16)v113 && !sub_100033A54(v100, 0, 0, 0, v112, v113, 0)) {
          goto LABEL_205;
        }
      }
      else if (!sub_100033A54(v257, 1u, (__int16 *)&v251, (__int16 *)&v250, 0, 0, 0))
      {
        goto LABEL_205;
      }
      if ((_WORD)v230)
      {
        uint64_t v103 = v229;
        unsigned int v99 = 0;
        uint64_t v104 = 0;
        uint64_t v105 = 0;
        goto LABEL_201;
      }
LABEL_202:
      uint64_t v45 = v240;
      goto LABEL_203;
    }
    uint64_t v248 = (unsigned __int16)((BYTE6(v96) & 0x7F) + 8);
    if (v86)
    {
      unsigned int v99 = 1;
    }
    else
    {
      HIWORD(v248) = v233;
      WORD1(v248) = (BYTE6(v96) & 0x7F) + 8;
      unsigned int v99 = 2;
    }
    uint64_t v103 = (void *)v257;
    uint64_t v104 = (__int16 *)&v248 + 2;
    uint64_t v105 = (__int16 *)&v248;
LABEL_201:
    if (sub_100033A54((uint64_t)v103, v99, v104, v105, (__int16)v228, 0, 0)) {
      goto LABEL_202;
    }
LABEL_205:
    unsigned __int16 v114 = WORD4(v258);
    if (!BYTE10(v258)) {
      unsigned __int16 v114 = WORD4(v258) + 1;
    }
    uint64_t v115 = v251;
    uint64_t v116 = sub_100033C6C(a1, v259, WORD4(v259), v229, v114, a3, v251, v227, (__int16 *)&v249 + 2, (__int16 *)&v249, (unsigned __int16)v230, v243, a7, &v256);
    if (v116)
    {
      uint64_t v19 = v116;
      log_err((uint64_t)"%s:%d: %s bt_shift_or_split failed with error: %d\n", v117, v118, v119, v120, v121, v122, v123, (uint64_t)"bt_insert");
      goto LABEL_408;
    }
    uint64_t v124 = v256;
    uint64_t v45 = v240;
    if (!v256) {
      goto LABEL_203;
    }
    uint64_t v125 = (uint64_t *)v258;
    uint64_t v230 = (uint64_t *)v258;
    if ((void)v259)
    {
      if (v246 && v236 != (uint64_t *)v257) {
        sub_10005F74C();
      }
      ++WORD4(v259);
      if ((void)v258)
      {
        int v126 = v245;
        if ((uint64_t *)v258 != a1) {
          int v126 = 1;
        }
        if (v126 == 1)
        {
          uint64_t v127 = v236;
          if (v44 != (uint64_t *)v258 && (uint64_t *)v258 != v236)
          {
            uint64_t v228 = v256;
            uint64_t v128 = v236;
            obj_unlock(v258, 2u);
            obj_release(v125);
            uint64_t v229 = 0;
            uint64_t v237 = v128;
            uint64_t v240 = v128;
            uint64_t v241 = v128;
            uint64_t v124 = v228;
            goto LABEL_227;
          }
        }
        else
        {
          uint64_t v127 = v236;
        }
        uint64_t v237 = v127;
        uint64_t v240 = v127;
        uint64_t v241 = v127;
        uint64_t v229 = (void *)v258;
      }
      else
      {
        uint64_t v229 = 0;
        uint64_t v237 = v236;
        uint64_t v240 = v236;
        uint64_t v241 = v236;
      }
LABEL_227:
      BOOL v132 = v44 != (uint64_t *)v259 || v44 == 0;
      int v133 = v239;
      if (!v132) {
        int v133 = WORD4(v259);
      }
      int v239 = v133;
      *(void *)&long long v258 = v124;
      uint64_t v256 = 0;
      uint64_t v62 = sub_10003393C((uint64_t)v124, a3, v115, v226, v225);
      if (v62) {
        goto LABEL_291;
      }
      uint64_t v134 = (uint64_t *)v257;
      obj_unlock(v257, 2u);
      obj_release(v134);
      *(void *)&long long v257 = 0;
      uint64_t v62 = btree_node_child_val(v258, WORD4(v258), v15);
      if (v62) {
        goto LABEL_291;
      }
      uint64_t v62 = btree_node_get(a1, v15, v243, 3u, *(_WORD *)(*(void *)(v258 + 56) + 34) - 1, a7, (uint64_t **)&v257);
      uint64_t v138 = v242;
      if (v62) {
        goto LABEL_291;
      }
      uint64_t v139 = v115;
      uint64_t v140 = v257;
      if ((a1[50] & 0x10) != 0)
      {
        uint64_t v141 = v244;
        if (*(void *)(v257 + 112) != *v15)
        {
          sub_100033980(v258, WORD4(v258), (unint64_t *)(v257 + 112), a7, v135, v136, v137);
          uint64_t v140 = v257;
        }
      }
      else
      {
        uint64_t v141 = v244;
      }
      if ((*(_WORD *)(*(void *)(v140 + 56) + 32) & 2) != 0) {
        uint64_t v142 = sub_100032A9C(v140, a3, v139, v138, v141);
      }
      else {
        uint64_t v142 = sub_10003393C(v140, a3, v139, v138, v141);
      }
      uint64_t v19 = v142;
      uint64_t v45 = v240;
      if (v142) {
        goto LABEL_408;
      }
      if (v44 != v230)
      {
        uint64_t v143 = v229;
        if (!v246)
        {
          LODWORD(v145) = v239;
          goto LABEL_265;
        }
        if (WORD4(v258) | WORD4(v257))
        {
          if (v44)
          {
            int v144 = v245;
            if (v44 != a1) {
              int v144 = 1;
            }
            if (v44 != (uint64_t *)v259 && v44 != (uint64_t *)v258 && v144)
            {
              obj_unlock((uint64_t)v44, 2u);
              obj_release(v44);
              uint64_t v234 = v255;
              uint64_t v238 = v255;
              uint64_t v235 = v255;
            }
          }
          uint64_t v145 = v235;
          if (v235)
          {
            int v146 = v245;
            if (v235 != a1) {
              int v146 = 1;
            }
            if (v235 != (uint64_t *)v259 && v235 != (uint64_t *)v258 && v146)
            {
              obj_unlock((uint64_t)v235, 2u);
              obj_release(v145);
            }
            uint64_t v238 = 0;
            uint64_t v234 = 0;
            uint64_t v235 = 0;
            uint64_t v236 = 0;
            uint64_t v237 = 0;
            uint64_t v241 = 0;
            uint64_t v45 = 0;
            uint64_t v44 = 0;
            LODWORD(v145) = 0;
            uint64_t v255 = 0;
          }
          else
          {
            uint64_t v235 = 0;
            uint64_t v236 = 0;
            uint64_t v237 = 0;
            uint64_t v241 = 0;
            uint64_t v45 = 0;
            uint64_t v44 = 0;
          }
LABEL_265:
          if (WORD4(v257))
          {
LABEL_266:
            BOOL v246 = 0;
            goto LABEL_280;
          }
          if (!WORD4(v258) && !BYTE10(v258))
          {
            uint64_t v44 = (uint64_t *)v259;
            uint64_t v147 = (uint64_t *)v258;
            BOOL v246 = 1;
            goto LABEL_278;
          }
          if (BYTE10(v257) || (*(_WORD *)(*(void *)(v257 + 56) + 32) & 2) != 0) {
            goto LABEL_266;
          }
          BOOL v246 = 1;
          uint64_t v44 = (uint64_t *)v258;
          uint64_t v238 = (uint64_t *)v257;
          uint64_t v234 = (uint64_t *)v257;
          uint64_t v235 = (uint64_t *)v257;
          uint64_t v255 = (uint64_t *)v257;
          uint64_t v236 = (uint64_t *)v257;
          uint64_t v237 = (uint64_t *)v257;
          uint64_t v241 = (uint64_t *)v257;
          uint64_t v45 = (uint64_t *)v257;
          LODWORD(v145) = WORD4(v258);
        }
        else
        {
          BOOL v246 = 1;
          LODWORD(v145) = v239;
        }
        goto LABEL_280;
      }
      LODWORD(v145) = WORD4(v258);
      uint64_t v143 = v229;
      if (v44 != a1 || WORD4(v258))
      {
        if (WORD4(v258))
        {
          if (v234 != (uint64_t *)v257) {
            sub_10005F720();
          }
          uint64_t v147 = v234;
          uint64_t v238 = v234;
          uint64_t v235 = v234;
          uint64_t v44 = (uint64_t *)v258;
          uint64_t v255 = v234;
          uint64_t v236 = v234;
          uint64_t v237 = v234;
          uint64_t v241 = v234;
        }
        else
        {
          uint64_t v44 = (uint64_t *)v259;
          uint64_t v147 = (uint64_t *)v258;
LABEL_278:
          uint64_t v234 = v147;
          uint64_t v235 = v147;
          LODWORD(v145) = WORD4(v259);
          uint64_t v255 = v147;
          uint64_t v236 = v147;
          uint64_t v237 = v147;
          uint64_t v241 = v147;
          uint64_t v238 = v147;
        }
        uint64_t v45 = v147;
LABEL_280:
        if (v143)
        {
          int v148 = v245;
          if (v143 != a1) {
            int v148 = 1;
          }
          if (v148 != 1 || v143 == v44)
          {
            uint64_t v234 = v238;
            uint64_t v235 = v238;
            uint64_t v236 = v238;
            uint64_t v237 = v238;
            uint64_t v241 = v238;
            uint64_t v45 = v238;
          }
          else
          {
            uint64_t v149 = v238;
            if (v143 != v238)
            {
              obj_unlock((uint64_t)v143, 2u);
              obj_release(v143);
            }
            uint64_t v234 = v149;
            uint64_t v235 = v149;
            uint64_t v236 = v149;
            uint64_t v237 = v149;
            uint64_t v241 = v149;
            uint64_t v45 = v149;
          }
        }
        int v239 = (int)v145;
      }
      else
      {
        uint64_t v234 = (uint64_t *)v258;
        uint64_t v235 = (uint64_t *)v258;
        uint64_t v236 = (uint64_t *)v258;
        uint64_t v255 = (uint64_t *)v258;
        uint64_t v237 = (uint64_t *)v258;
        uint64_t v241 = (uint64_t *)v258;
        uint64_t v238 = (uint64_t *)v258;
        uint64_t v45 = (uint64_t *)v258;
        uint64_t v44 = a1;
      }
LABEL_203:
      if ((*(_WORD *)(*(void *)(v257 + 56) + 32) & 2) == 0) {
        continue;
      }
      goto LABEL_40;
    }
    break;
  }
  *(void *)&long long v259 = v258;
  if (*(_DWORD *)(v256[7] + 36))
  {
    uint64_t v62 = btree_node_key_ptr((uint64_t)v256, 0, &v254, &v252);
    if (v62) {
      goto LABEL_291;
    }
    uint64_t v129 = v259;
    uint64_t v130 = v254;
    uint64_t v131 = v252;
  }
  else
  {
    uint64_t v129 = v258;
    uint64_t v130 = a3;
    uint64_t v131 = v115;
  }
  uint64_t v19 = sub_10003393C(v129, v130, v131, v224, v223);
  if (!v19)
  {
    uint64_t v229 = 0;
    goto LABEL_227;
  }
LABEL_408:
  uint64_t v216 = (uint64_t *)v259;
  uint64_t v217 = v255;
  if ((void)v259 && (uint64_t *)v259 != v44 && (uint64_t *)v259 != v255)
  {
    obj_unlock(v259, 2u);
    obj_release(v216);
  }
  uint64_t v218 = (uint64_t *)v258;
  if ((void)v258 && (uint64_t *)v258 != v44 && (uint64_t *)v258 != v217)
  {
    obj_unlock(v258, 2u);
    obj_release(v218);
  }
  uint64_t v219 = (uint64_t *)v257;
  if ((void)v257 && (uint64_t *)v257 != v44 && (uint64_t *)v257 != v217)
  {
    obj_unlock(v257, 2u);
    obj_release(v219);
  }
  if (v44)
  {
    obj_unlock((uint64_t)v44, 2u);
    obj_release(v44);
    uint64_t v217 = v255;
  }
  if (v217)
  {
    obj_unlock((uint64_t)v217, 2u);
    obj_release(v217);
  }
  uint64_t v220 = (uint64_t *)v256;
  if (v256)
  {
    obj_unlock((uint64_t)v256, 2u);
    obj_release(v220);
  }
  char v221 = v245;
  if ((uint64_t *)v259 == a1) {
    char v221 = 1;
  }
  if (v217 != a1 && (v221 & 1) == 0 && (uint64_t *)v258 != a1 && (uint64_t *)v257 != a1 && v44 != a1)
  {
    obj_unlock((uint64_t)a1, 2u);
    obj_release(a1);
  }
  if (!obj_refcount((uint64_t)a1)) {
    sub_10005F69C();
  }
  return v19;
}

uint64_t sub_100032A9C(uint64_t a1, unint64_t *a2, uint64_t a3, _WORD *a4, BOOL *a5)
{
  int v23 = 0;
  int v10 = *(_DWORD *)(*(void *)(a1 + 56) + 36) - 1;
  unsigned __int16 v22 = 0;
  if ((*(unsigned char *)(a1 + 400) & 1) == 0)
  {
    if ((v10 & 0x80000000) == 0)
    {
      int v11 = 0;
      uint64_t v25 = 0;
      while (1)
      {
        int v12 = v10 + v11;
        if (v10 + v11 < 0 != __OFADD__(v10, v11)) {
          ++v12;
        }
        int v13 = v12 >> 1;
        uint64_t result = btree_node_key_ptr(a1, (unsigned __int16)(v12 >> 1), &v25, &v22);
        if (result) {
          return result;
        }
        uint64_t v15 = *(void *)(a1 + 8);
        if (!v15) {
          uint64_t v15 = *(void *)(*(void *)a1 + 392);
        }
        uint64_t result = (*(uint64_t (**)(uint64_t, unint64_t *, uint64_t, unint64_t *, void, int *))(a1 + 416))(v15, a2, a3, v25, v22, &v23);
        if (result) {
          return result;
        }
        BOOL v16 = v23 == 0;
        if (!v23)
        {
          LOWORD(v11) = v13;
          goto LABEL_38;
        }
        if (v23 < 0) {
          int v10 = v13 - 1;
        }
        else {
          int v11 = v13 + 1;
        }
        if (v11 > v10) {
          goto LABEL_38;
        }
      }
    }
    BOOL v16 = 0;
    LOWORD(v11) = 0;
LABEL_38:
    uint64_t result = 0;
    *a4 = v11;
LABEL_41:
    *a5 = v16;
    return result;
  }
  if (a3 != 8) {
    return 22;
  }
  if (v10 < 0)
  {
    BOOL v16 = 0;
    LOWORD(v17) = 0;
LABEL_40:
    uint64_t result = 0;
    *a4 = v17;
    goto LABEL_41;
  }
  int v17 = 0;
  unint64_t v18 = *a2;
  uint64_t v25 = 0;
  __int16 v24 = 0;
  while (1)
  {
    int v19 = v17 + v10;
    if (v17 + v10 < 0 != __OFADD__(v17, v10)) {
      ++v19;
    }
    int v20 = v19 >> 1;
    LODWORD(result) = btree_node_key_ptr(a1, (unsigned __int16)(v19 >> 1), &v25, &v24);
    BOOL v21 = v24 != 8 && result == 0;
    uint64_t result = v21 ? 22 : result;
    if (result) {
      return result;
    }
    BOOL v16 = *v25 == v18;
    if (*v25 == v18)
    {
      LOWORD(v17) = v20;
      goto LABEL_40;
    }
    if (*v25 > v18) {
      int v10 = v20 - 1;
    }
    else {
      int v17 = v20 + 1;
    }
    if (v17 > v10) {
      goto LABEL_40;
    }
  }
}

uint64_t sub_100032C58(uint64_t a1, unsigned int a2, void *a3, unsigned int a4, const void *a5, unsigned int a6, uint64_t a7)
{
  int v95 = 0;
  unsigned __int16 v94 = 0;
  unsigned __int16 v93 = 0;
  uint64_t v11 = *(void *)(a1 + 56);
  __int16 v12 = *(_WORD *)(v11 + 32);
  if (a6 == 65534) {
    size_t v13 = 0;
  }
  else {
    size_t v13 = a6;
  }
  size_t v92 = v13;
  __src = a3;
  __int16 v88 = *(_WORD *)(v11 + 32);
  if (*(_DWORD *)(v11 + 36) <= a2)
  {
    int v20 = 0;
    __int16 v21 = 0;
    unsigned int v19 = 0;
    unsigned int v22 = 0;
    __int16 v23 = 0;
    BOOL v86 = 0;
    unsigned int v16 = 0xFFFF;
    unsigned int v18 = 0xFFFF;
    goto LABEL_27;
  }
  uint64_t v14 = *(void *)(a1 + 376);
  if ((v12 & 4) != 0) {
    uint64_t v15 = (unsigned __int16 *)(v14 + 4 * a2);
  }
  else {
    uint64_t v15 = (unsigned __int16 *)(v14 + 8 * a2);
  }
  unsigned int v16 = *v15;
  int v17 = (unsigned __int16 *)(v14 + 4 * a2 + 2);
  if ((v12 & 4) == 0) {
    int v17 = (unsigned __int16 *)(v14 + 8 * a2 + 4);
  }
  unsigned int v18 = *v17;
  if (v16 == 0xFFFF)
  {
    unsigned int v19 = 0;
  }
  else if ((v12 & 4) != 0)
  {
    unsigned int v19 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else
  {
    unsigned int v19 = *(unsigned __int16 *)(v14 + 8 * a2 + 2);
  }
  if (v18 > 0xFFFD) {
    unsigned int v22 = 0;
  }
  else {
    unsigned int v22 = btree_node_val_len(a1, a2);
  }
  BOOL v86 = v19 != 0;
  if (v19)
  {
    uint64_t v24 = sub_100030894(a1, v16, v19);
    if (v24) {
      return v24;
    }
    __int16 v23 = v19;
    if (!v22) {
      goto LABEL_22;
    }
LABEL_24:
    uint64_t v24 = sub_1000309C0(a1, v18, v22);
    if (v24) {
      return v24;
    }
    int v20 = 1;
    __int16 v21 = v22;
    goto LABEL_26;
  }
  __int16 v23 = 0;
  if (v22) {
    goto LABEL_24;
  }
LABEL_22:
  int v20 = 0;
  __int16 v21 = 0;
LABEL_26:
  a3 = __src;
LABEL_27:
  HIWORD(v95) = v16;
  LOWORD(v95) = v18;
  unsigned __int16 v25 = a4 - v19;
  if (!a3) {
    unsigned __int16 v25 = 0;
  }
  int v26 = (__int16)v25;
  unsigned __int16 v27 = v92 - v22;
  if (!a5) {
    unsigned __int16 v27 = 0;
  }
  int v28 = (__int16)v27;
  if (!(v25 | v27))
  {
    uint64_t v32 = a7;
    goto LABEL_40;
  }
  if (a3)
  {
    if ((*(void *)(a1 + 400) & 0x40) != 0) {
      __int16 v29 = a4;
    }
    else {
      __int16 v29 = (a4 + 7) & 0xFFF8;
    }
    __int16 v30 = (v23 + 7) & 0xFFF8;
    if ((*(void *)(a1 + 400) & 0x40) != 0) {
      __int16 v30 = v23;
    }
    __int16 v31 = v29 - v30;
  }
  else
  {
    __int16 v31 = 0;
  }
  int v84 = v28;
  int v85 = v26;
  if (a5)
  {
    if ((*(void *)(a1 + 400) & 0x40) != 0) {
      __int16 v35 = v92;
    }
    else {
      __int16 v35 = (v92 + 7) & 0xFFF8;
    }
    if ((*(void *)(a1 + 400) & 0x40) == 0) {
      __int16 v21 = (v21 + 7) & 0xFFF8;
    }
    __int16 v36 = v35 - v21;
  }
  else
  {
    __int16 v36 = 0;
  }
  if (v36 + v31 > (int)sub_10003B9E8(a1)) {
    return 28;
  }
  unsigned __int16 v37 = 0;
  unsigned __int16 v93 = -1;
  unsigned __int16 v94 = -1;
  if (!a4) {
    goto LABEL_73;
  }
  int v26 = v85;
  if (!v85) {
    goto LABEL_74;
  }
  sub_10003BA68(a1, 1, a4, (__int16 *)&v94, (unsigned __int16 *)&v95 + 1);
  if (SHIWORD(v95) != -1)
  {
    unsigned __int16 v37 = 0;
LABEL_73:
    int v26 = v85;
    goto LABEL_74;
  }
  int v26 = v85;
  if (v85 < 0)
  {
    unsigned __int16 v37 = 0;
    HIWORD(v95) = v16;
    unsigned __int16 v94 = -1;
  }
  else
  {
    unsigned __int16 v37 = (a4 + 7) & 0xFFF8;
    if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
      unsigned __int16 v37 = a4;
    }
  }
LABEL_74:
  unsigned __int16 v82 = v37;
  if (!v92)
  {
LABEL_78:
    int v28 = v84;
    goto LABEL_90;
  }
  int v28 = v84;
  if (v84)
  {
    sub_10003BA68(a1, 2, v92, (__int16 *)&v93, (unsigned __int16 *)&v95);
    if ((__int16)v95 == -1)
    {
      int v28 = v84;
      if (v84 < 0)
      {
        LOWORD(v95) = v18;
        unsigned __int16 v93 = -1;
      }
      else
      {
        if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
          __int16 v38 = v92;
        }
        else {
          __int16 v38 = (v92 + 7) & 0xFFF8;
        }
        v82 += v38;
      }
      int v26 = v85;
      goto LABEL_90;
    }
    int v26 = v85;
    goto LABEL_78;
  }
LABEL_90:
  unsigned int v39 = *(unsigned __int16 *)(*(void *)(a1 + 56) + 46);
  if (v26) {
    BOOL v40 = v86;
  }
  else {
    BOOL v40 = 0;
  }
  BOOL v87 = v40;
  if (v40)
  {
    int v41 = (*(void *)(a1 + 400) & 0x40) != 0 ? v19 : ((_WORD)v19 + 7) & 0xFFF8;
    sub_10003BC88(a1, 1, v16, v41);
    int v28 = v84;
    int v26 = v85;
    if (HIWORD(v95) != 0xFFFF
      && v94 == 0xFFFF
      && HIWORD(v95) != v16
      && *(unsigned __int16 *)(*(void *)(a1 + 56) + 48) == v16)
    {
      unsigned __int16 v94 = v16;
    }
  }
  if (!v28) {
    int v20 = 0;
  }
  if (v20 == 1)
  {
    int v42 = (*(void *)(a1 + 400) & 0x40) != 0 ? v22 : ((_WORD)v22 + 7) & 0xFFF8;
    sub_10003BC88(a1, 2, v18, v42);
    int v28 = v84;
    int v26 = v85;
    if ((unsigned __int16)v95 != 0xFFFF
      && v93 == 0xFFFF
      && (unsigned __int16)v95 != v18
      && *(unsigned __int16 *)(*(void *)(a1 + 56) + 52) == v18)
    {
      unsigned __int16 v93 = v18;
    }
  }
  BOOL v43 = v39 >= v82;
  uint64_t v32 = a7;
  if (!v43)
  {
    uint64_t v44 = *(void *)(a1 + 56);
    if ((v88 & 0x8000) == 0) {
      *(_WORD *)(v44 + 32) |= 0x8000u;
    }
    if (*(_DWORD *)(v44 + 36) > a2)
    {
      __int16 v45 = *(_WORD *)(v44 + 32);
      uint64_t v46 = *(void *)(a1 + 376);
      if ((v45 & 4) != 0)
      {
        if (v87) {
          *(_WORD *)(v46 + 4 * a2) = -1;
        }
        if (v20) {
          *(_WORD *)(v46 + 4 * a2 + 2) = -1;
        }
      }
      else
      {
        if (v87) {
          *(_DWORD *)(v46 + 8 * a2) = 0xFFFF;
        }
        if (v20) {
          *(_DWORD *)(v46 + 8 * a2 + 4) = 0xFFFF;
        }
      }
    }
    int v83 = v20;
    uint64_t v47 = sub_10003BE34(a1, 0, a7);
    if (v47)
    {
      uint64_t v24 = v47;
      if (v87)
      {
        unsigned __int16 v48 = (*(void *)(a1 + 400) & 0x40) != 0 ? a4 : (a4 + 7) & 0xFFF8;
        if (sub_10003C238(a1, 1, v48, 0xFFFF, v16)) {
          log_err((uint64_t)"%s:%d: %s unable to reclaim just-freed key space on error path: %d\n", v49, v50, v51, v52, v53, v54, v55, (uint64_t)"btree_node_entry_update");
        }
      }
      if (v83)
      {
        if ((*(void *)(a1 + 400) & 0x40) != 0) {
          unsigned __int16 v73 = v22;
        }
        else {
          unsigned __int16 v73 = (v22 + 7) & 0xFFF8;
        }
        if (sub_10003C238(a1, 2, v73, 0xFFFF, v18)) {
          log_err((uint64_t)"%s:%d: %s unable to reclaim just-freed val space on error path: %d\n", v74, v75, v76, v77, v78, v79, v80, (uint64_t)"btree_node_entry_update");
        }
      }
      return v24;
    }
    unsigned __int16 v93 = -1;
    unsigned __int16 v94 = -1;
    int v95 = -1;
    int v28 = v84;
    int v26 = v85;
  }
  if (v26)
  {
    if (HIWORD(v95) == 0xFFFF) {
      uint64_t v56 = sub_10003C368(a1, 1, a4, (_WORD *)&v95 + 1);
    }
    else {
      uint64_t v56 = sub_10003C238(a1, 1, a4, v94, HIWORD(v95));
    }
    uint64_t v24 = v56;
    int v28 = v84;
    int v26 = v85;
    if (v56) {
      goto LABEL_164;
    }
  }
  else
  {
    uint64_t v64 = *(void *)(a1 + 376);
    uint64_t v65 = (_WORD *)(v64 + 4 * a2);
    int v66 = (_WORD *)(v64 + 8 * a2);
    if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 4) != 0) {
      uint64_t v67 = v65;
    }
    else {
      uint64_t v67 = v66;
    }
    HIWORD(v95) = *v67;
  }
  if (v28)
  {
    if (v92)
    {
      if ((unsigned __int16)v95 == 0xFFFF) {
        uint64_t v68 = sub_10003C368(a1, 2, v92, &v95);
      }
      else {
        uint64_t v68 = sub_10003C238(a1, 2, v92, v93, (unsigned __int16)v95);
      }
      uint64_t v24 = v68;
      int v28 = v84;
      int v26 = v85;
      if (!v68)
      {
        LOWORD(v18) = v95;
        goto LABEL_40;
      }
LABEL_164:
      log_err((uint64_t)"%s:%d: %s unable allocate space that should be there: %d\n", v57, v58, v59, v60, v61, v62, v63, (uint64_t)"btree_node_entry_update");
      return v24;
    }
    if (a6 == 65534) {
      LOWORD(v18) = -2;
    }
    else {
      LOWORD(v18) = -1;
    }
  }
  else
  {
    uint64_t v69 = *(void *)(a1 + 376);
    uint64_t v70 = v69 + 4 * a2 + 2;
    uint64_t v71 = v69 + 8 * a2 + 4;
    if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 4) != 0) {
      uint64_t v72 = (_WORD *)v70;
    }
    else {
      uint64_t v72 = (_WORD *)v71;
    }
    LOWORD(v18) = *v72;
  }
  LOWORD(v95) = v18;
LABEL_40:
  if (a6 == 65534 && (unsigned __int16)v18 != 65534)
  {
    LOWORD(v18) = -2;
    LOWORD(v95) = -2;
    int v28 = 1;
  }
  sub_10003BD28((void *)a1, a2, v26 != 0, v28 != 0, HIWORD(v95), a4, (unsigned __int16)v18, a6);
  if ((v88 & 0x8000) == 0) {
    *(_WORD *)(*(void *)(a1 + 56) + 32) &= ~0x8000u;
  }
  unsigned int v33 = *(unsigned __int16 *)(a1 + 440);
  if (!*(_WORD *)(a1 + 440) || (__int16 v34 = a4, v33 >= a4))
  {
    if (a4 >= v19 || v33 > v19) {
      goto LABEL_51;
    }
    __int16 v34 = 0;
  }
  *(_WORD *)(a1 + 440) = v34;
LABEL_51:
  if (__src && a4) {
    memcpy((void *)(*(void *)(a1 + 384) + HIWORD(v95)), __src, a4);
  }
  if (a5 && v92) {
    memcpy((void *)(*(void *)(a1 + 392) - (unsigned __int16)v95), a5, v92);
  }
  obj_dirty(a1, v32, 0);
  return 0;
}

uint64_t sub_1000334DC(uint64_t a1, unsigned int a2, const void *a3, unsigned int a4, const void *a5, unsigned int a6, uint64_t a7)
{
  __int16 v43 = a4;
  if (a6 == 65534) {
    unsigned int v11 = 0;
  }
  else {
    unsigned int v11 = a6;
  }
  __int16 v39 = v11;
  if (a3)
  {
    unsigned int v12 = a4;
    if (a4) {
      size_t v13 = a3;
    }
    else {
      size_t v13 = 0;
    }
    if (a5) {
      goto LABEL_9;
    }
LABEL_13:
    unsigned int v11 = 0;
    uint64_t v14 = 0;
    __int16 v39 = 0;
    goto LABEL_14;
  }
  unsigned int v12 = 0;
  size_t v13 = 0;
  __int16 v43 = 0;
  if (!a5) {
    goto LABEL_13;
  }
LABEL_9:
  if (v11) {
    uint64_t v14 = a5;
  }
  else {
    uint64_t v14 = 0;
  }
LABEL_14:
  unsigned __int16 v42 = 0;
  int v40 = 0;
  int v41 = 0;
  if (!sub_100033A54(a1, 1u, &v43, &v39, 0, 0, &v42)) {
    return 28;
  }
  int v40 = -1;
  int v41 = -1;
  if (v13) {
    sub_10003BA68(a1, 1, v12, (__int16 *)&v41 + 1, (unsigned __int16 *)&v41);
  }
  if (v14) {
    sub_10003BA68(a1, 2, v11, (__int16 *)&v40 + 1, (unsigned __int16 *)&v40);
  }
  if ((__int16)v41 == -1)
  {
    if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
      unsigned __int16 v21 = v12;
    }
    else {
      unsigned __int16 v21 = (v12 + 7) & 0xFFF8;
    }
  }
  else
  {
    unsigned __int16 v21 = 0;
  }
  if ((__int16)v40 == -1)
  {
    if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
      __int16 v23 = v11;
    }
    else {
      __int16 v23 = (v11 + 7) & 0xFFF8;
    }
    v21 += v23;
  }
  uint64_t v24 = *(_WORD **)(a1 + 56);
  unsigned int v25 = (unsigned __int16)v24[23];
  if (v42 + v21 <= v25)
  {
    if (v42)
    {
      memmove((void *)(*(void *)(a1 + 384) + v42), *(const void **)(a1 + 384), (unsigned __int16)v24[22]);
      bzero(*(void **)(a1 + 384), v42);
      unsigned __int16 v26 = v42;
      *(void *)(a1 + 384) += v42;
      uint64_t v24 = *(_WORD **)(a1 + 56);
      LOWORD(v25) = v24[23] - v26;
      v24[23] = v25;
      v24[21] += v26;
    }
  }
  else
  {
    uint64_t v22 = sub_10003BE34(a1, 1, a7);
    if (v22) {
      return v22;
    }
    uint64_t v24 = *(_WORD **)(a1 + 56);
    unsigned int v25 = (unsigned __int16)v24[23];
    if (v25 < v21) {
      sub_10005F778();
    }
    LOWORD(v40) = -1;
    LOWORD(v41) = -1;
    unsigned __int16 v42 = 0;
  }
  if (!v13) {
    goto LABEL_39;
  }
  uint64_t v27 = (unsigned __int16)v41;
  if ((unsigned __int16)v41 != 0xFFFF)
  {
    uint64_t v22 = sub_10003C238(a1, 1, v12, HIWORD(v41), (unsigned __int16)v41);
    if (v22) {
      goto LABEL_56;
    }
LABEL_39:
    if (!v14) {
      goto LABEL_58;
    }
    goto LABEL_40;
  }
  if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
    unsigned __int16 v28 = v12;
  }
  else {
    unsigned __int16 v28 = (v12 + 7) & 0xFFF8;
  }
  if ((unsigned __int16)v25 < v28)
  {
    uint64_t v22 = 28;
    goto LABEL_56;
  }
  __int16 v32 = v24[22];
  v24[22] = v32 + v28;
  v24[23] = v25 - v28;
  LOWORD(v41) = v32;
  if (!v14) {
    goto LABEL_58;
  }
LABEL_40:
  uint64_t v27 = (unsigned __int16)v40;
  if ((unsigned __int16)v40 != 0xFFFF)
  {
    uint64_t v22 = sub_10003C238(a1, 2, v11, HIWORD(v40), (unsigned __int16)v40);
    if (!v22) {
      goto LABEL_58;
    }
LABEL_56:
    log_err((uint64_t)"%s:%d: %s unable allocate space that should be there: %d\n", v15, v16, v17, v27, v18, v19, v20, (uint64_t)"btree_node_insert_internal");
    return v22;
  }
  int v29 = (v11 + 7) & 0x1FFF8;
  if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
    int v29 = v11;
  }
  uint64_t v30 = *(void *)(a1 + 56);
  unsigned int v31 = *(unsigned __int16 *)(v30 + 46);
  if (v31 < (unsigned __int16)v29)
  {
    uint64_t v22 = 28;
    goto LABEL_56;
  }
  unsigned int v33 = v31 - v29;
  int v34 = *(_DWORD *)(a1 + 392) - (v33 + *(_DWORD *)(a1 + 384) + *(unsigned __int16 *)(v30 + 44));
  *(_WORD *)(v30 + 46) = v33;
  LOWORD(v40) = v34;
LABEL_58:
  if (!v11)
  {
    if (a6 == 65534) {
      __int16 v35 = -2;
    }
    else {
      __int16 v35 = -1;
    }
    LOWORD(v40) = v35;
  }
  uint64_t v36 = *(void *)(a1 + 56);
  unsigned int v37 = *(_DWORD *)(v36 + 36);
  if (v37 > a2)
  {
    sub_10003C5C8(a1, a2, 1);
    uint64_t v36 = *(void *)(a1 + 56);
    unsigned int v37 = *(_DWORD *)(v36 + 36);
  }
  *(_DWORD *)(v36 + 36) = v37 + 1;
  sub_10003BD28((void *)a1, a2, 1, 1, (unsigned __int16)v41, v12, (unsigned __int16)v40, a6);
  if (*(_WORD *)(a1 + 440) && *(unsigned __int16 *)(a1 + 440) < v12) {
    *(_WORD *)(a1 + 440) = v12;
  }
  if (v13) {
    memcpy((void *)(*(void *)(a1 + 384) + (unsigned __int16)v41), v13, v12);
  }
  if (v14) {
    memcpy((void *)(*(void *)(a1 + 392) - (unsigned __int16)v40), v14, v11);
  }
  obj_dirty(a1, a7, 0);
  return 0;
}

uint64_t sub_10003393C(uint64_t a1, unint64_t *a2, uint64_t a3, _WORD *a4, BOOL *a5)
{
  uint64_t result = sub_100032A9C(a1, a2, a3, a4, a5);
  if (!result && !*a5)
  {
    if (*a4) {
      --*a4;
    }
  }
  return result;
}

uint64_t sub_100033980(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  size_t v8 = (uint64_t *)a3;
  unint64_t v13 = 0;
  __int16 v9 = *(_WORD *)(*(void *)(a1 + 56) + 32);
  if ((v9 & 8) != 0)
  {
    unint64_t v10 = *(void *)(a1 + 408);
    if (*a3 <= v10)
    {
      log_err((uint64_t)"%s:%d: %s invalid relative OID: %llu < root OID: %llu\n", a2, (uint64_t)a3, a4, (uint64_t)a3, a6, a7, a4, (uint64_t)"btree_node_child_id_update");
      return 22;
    }
    unint64_t v13 = *a3 - v10;
    size_t v8 = (uint64_t *)&v13;
  }
  if ((v9 & 4) != 0) {
    uint64_t v11 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else {
    uint64_t v11 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 8 * a2 + 2);
  }
  return sub_10003664C(a1, a2, 0, v11, (uint64_t)v8, 8, 0, a4, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_10003C638, 0);
}

BOOL sub_100033A54(uint64_t a1, unsigned int a2, __int16 *a3, __int16 *a4, __int16 a5, __int16 a6, _WORD *a7)
{
  unsigned int v12 = *(_WORD **)(a1 + 56);
  __int16 v13 = v12[16];
  int v14 = (unsigned __int16)v12[18];
  unsigned int v15 = (unsigned __int16)v12[21];
  if ((v13 & 4) != 0) {
    char v16 = 2;
  }
  else {
    char v16 = 3;
  }
  char v43 = v16;
  if ((v13 & 4) != 0) {
    char v17 = 2;
  }
  else {
    char v17 = 3;
  }
  unsigned int v18 = btree_node_toc_required_capacity(a1, 0);
  if ((v13 & 4) == 0 || (*(unsigned char *)(a1 + 400) & 4) != 0 || v14 + a2 <= v18)
  {
    unsigned int v20 = v18;
    unsigned int v21 = btree_node_toc_required_capacity(a1, (__int16)a2);
    if (a7)
    {
      if ((v13 & 4) != 0) {
        char v22 = 2;
      }
      else {
        char v22 = 3;
      }
      unsigned int v23 = v21 << v22;
      BOOL v24 = v23 >= v15;
      unsigned int v25 = v23 - v15;
      if (v25 == 0 || !v24) {
        LOWORD(v25) = 0;
      }
      *a7 = v25;
    }
    unsigned int v26 = v15 >> v17;
    __int16 v27 = 0;
    if (a2)
    {
      uint64_t v28 = a2;
      char v29 = v43;
      __int16 v31 = a5;
      __int16 v30 = a6;
      unsigned int v32 = v20;
      do
      {
        __int16 v34 = *a3++;
        __int16 v33 = v34;
        if ((*(void *)(a1 + 400) & 0x40) != 0)
        {
          __int16 v35 = *a4;
        }
        else
        {
          __int16 v33 = (v33 + 7) & 0xFFF8;
          __int16 v35 = (*a4 + 7) & 0xFFF8;
        }
        v27 += v33 + v35;
        ++a4;
        --v28;
      }
      while (v28);
    }
    else
    {
      char v29 = v43;
      __int16 v31 = a5;
      __int16 v30 = a6;
      unsigned int v32 = v20;
    }
    unsigned __int16 v36 = v30 + v31 + v27;
    if ((v13 & 4) != 0) {
      char v37 = 2;
    }
    else {
      char v37 = 3;
    }
    int v38 = ((v21 - v32) << v37) & 0xFFFC;
    if (v21 <= v32) {
      int v38 = 0;
    }
    BOOL v39 = v26 > v32;
    int v40 = (v26 - v32) << v29;
    if (!v39) {
      LOWORD(v40) = 0;
    }
    return v38 + v36 <= (unsigned __int16)(v12[23] + v40 + v12[25] + v12[27]);
  }
  else
  {
    BOOL result = 0;
    if (a7) {
      *a7 = -1;
    }
  }
  return result;
}

uint64_t sub_100033BF4(uint64_t a1)
{
  int v1 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  if (!v1)
  {
    LOWORD(v1) = *(_WORD *)(a1 + 440);
    if (!(_WORD)v1)
    {
      uint64_t v2 = *(void *)(a1 + 56);
      int v3 = *(_DWORD *)(v2 + 36);
      if (v3)
      {
        int v4 = 0;
        LOWORD(v1) = 0;
        __int16 v5 = *(_WORD *)(v2 + 32);
        do
        {
          if ((v5 & 4) != 0) {
            unsigned int v6 = 0;
          }
          else {
            unsigned int v6 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 8 * (unsigned __int16)v4 + 2);
          }
          if (v6 > (unsigned __int16)v1 && v6 != 0xFFFF) {
            LOWORD(v1) = v6;
          }
          ++v4;
        }
        while (v3 != v4);
      }
      else
      {
        LOWORD(v1) = 0;
      }
      *(_WORD *)(a1 + 440) = v1;
    }
  }
  return (unsigned __int16)v1;
}

uint64_t sub_100033C6C(void *a1, uint64_t a2, unsigned int a3, void *a4, unsigned int a5, void *a6, unsigned int a7, unsigned int a8, __int16 *a9, __int16 *a10, unsigned __int16 a11, uint64_t a12, uint64_t a13, unint64_t **a14)
{
  unsigned int v327 = a7;
  uint64_t v326 = a6;
  uint64_t v19 = a13;
  uint64_t v351 = a1;
  __chkstk_darwin();
  unsigned int v21 = (unint64_t *)&v319[-v20];
  bzero(&v319[-v20], v22);
  LODWORD(v349) = 0;
  memset(v359, 0, sizeof(v359));
  uint64_t v357 = 0;
  uint64_t v358 = 0;
  uint64_t v355 = 0;
  uint64_t v356 = 0;
  uint64_t v354 = 0;
  int v352 = 0;
  int v353 = 0;
  if ((*(_WORD *)(a4[7] + 32) & 4) != 0) {
    LODWORD(v349) = (a4[50] & 4) == 0;
  }
  uint64_t v342 = v351 + 50;
  *a14 = 0;
  unsigned int v325 = a3;
  uint64_t v321 = a14;
  if (a2 && *(_DWORD *)(*(void *)(a2 + 56) + 36) - 1 > a3)
  {
    unsigned __int16 v23 = a3 + 1;
    if (btree_node_child_val(a2, v23, v21)
      || btree_node_get(v351, v21, a12, 3u, *(_WORD *)(*(void *)(a2 + 56) + 34) - 1, a13, (uint64_t **)&v358)|| (BOOL v24 = v358) == 0)
    {
      BOOL v24 = 0;
      uint64_t v358 = 0;
    }
    else if ((*v342 & 0x10) != 0 && v358[14] != *v21)
    {
      sub_100033980(a2, v23, v358 + 14, a13, v103, v104, v105);
    }
  }
  else
  {
    BOOL v24 = 0;
  }
  *(_OWORD *)((char *)v359 + 8) = *(_OWORD *)v342;
  *((void *)&v359[1] + 1) = a4[52];
  LODWORD(v359[0]) = 2123139;
  uint64_t v25 = a4[7];
  WORD2(v359[0]) = *(_WORD *)(v25 + 32) & 0x1A;
  WORD3(v359[0]) = *(_WORD *)(v25 + 34);
  unsigned __int16 v26 = 0;
  if (a8)
  {
    uint64_t v29 = a8;
    do
    {
      __int16 v31 = *a9++;
      __int16 v30 = v31;
      if ((a4[50] & 0x40) != 0)
      {
        __int16 v32 = *a10;
      }
      else
      {
        __int16 v30 = (v30 + 7) & 0xFFF8;
        __int16 v32 = (*a10 + 7) & 0xFFF8;
      }
      v26 += v30 + v32;
      ++a10;
      --v29;
    }
    while (v29);
  }
  uint64_t v322 = v21;
  int v329 = (void *)a2;
  if (*(_DWORD *)(v25 + 36) <= a5) {
    goto LABEL_20;
  }
  uint64_t v33 = btree_node_key_ptr((uint64_t)a4, a5, &v355, (_WORD *)&v352 + 1);
  if (v33) {
    return v33;
  }
  uint64_t v34 = v351[1];
  if (!v34) {
    uint64_t v34 = *(void *)(*v351 + 392);
  }
  uint64_t v33 = ((uint64_t (*)(uint64_t, void *, void, void *, void, int *))v351[52])(v34, v326, v327, v355, HIWORD(v352), &v353);
  if (v33) {
    return v33;
  }
  if (v353)
  {
LABEL_20:
    unsigned int v337 = 0;
    int v334 = 0;
    int v35 = 0;
  }
  else
  {
    if ((*(_WORD *)(a4[7] + 32) & 2) != 0)
    {
      int v216 = btree_node_val_len((uint64_t)a4, a5);
      if (v216 == 65534) {
        int v217 = 0;
      }
      else {
        int v217 = v216;
      }
      LOWORD(v352) = v217;
      if ((a4[50] & 0x40) != 0) {
        unsigned int v218 = HIWORD(v352);
      }
      else {
        unsigned int v218 = (HIWORD(v352) + 7) & 0xFFFFFFF8;
      }
      if ((a4[50] & 0x40) == 0) {
        int v217 = (v217 + 7) & 0x1FFF8;
      }
      unsigned int v337 = v218 + v217;
      int v334 = 1;
    }
    else
    {
      unsigned int v337 = 0;
      int v334 = 0;
    }
    int v35 = 1;
  }
  BOOL v346 = v24 == 0;
  uint64_t v338 = a13;
  uint64_t v347 = a4;
  if (!v24)
  {
    uint64_t v98 = obj_flags((uint64_t)a4) & 0xFFFFFC00;
    uint64_t v99 = v351[1];
    if (!v99) {
      uint64_t v99 = *(void *)(*v351 + 392);
    }
    uint64_t v100 = obj_subtype((uint64_t)a4);
    uint64_t v33 = sub_100039D48(v99, v98, v100, v359, a13, &v358);
    if (v33) {
      return v33;
    }
    unsigned int v101 = v351;
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v351[49] + 32), 1uLL, memory_order_relaxed);
    obj_dirty((uint64_t)v101, a13, 0);
    if ((v101[50] & 2) != 0 || v351[54] == a4[14])
    {
      uint64_t v102 = a4[7];
      if (*(_DWORD *)(v102 + 36) == a5)
      {
        int v106 = 0;
        a8 = 0;
        int v39 = a5 + ((*(unsigned __int16 *)(v102 + 32) >> 1) & 1) - 1;
        BOOL v346 = 1;
        goto LABEL_133;
      }
    }
  }
  uint64_t v36 = a4[7];
  __int16 v37 = *(_WORD *)(v36 + 32);
  int v332 = btree_node_toc_required_capacity((uint64_t)a4, 0);
  if ((v37 & 4) != 0) {
    uint64_t v38 = 2;
  }
  else {
    uint64_t v38 = 3;
  }
  int v39 = *(_DWORD *)(v36 + 36);
  if (((v39 - 1) & 0x8000) != 0)
  {
    int v106 = 0;
    goto LABEL_133;
  }
  int v323 = v26;
  int v40 = a11 + v26;
  unsigned int v320 = v35 + a5;
  unsigned int v41 = a8;
  int v42 = (__int16)(v39 - 1);
  char v43 = (uint64_t *)v358;
  int v339 = sub_10003B9E8((uint64_t)v358);
  unsigned int v340 = btree_node_toc_required_capacity((uint64_t)v43, 0) << v38;
  int v331 = sub_10003B9E8((uint64_t)a4);
  LOWORD(v44) = 0;
  int v341 = 0;
  LODWORD(v348) = 0;
  int v328 = v334 ^ 1;
  unsigned int v333 = v41;
  unsigned int v343 = a5;
  int v45 = v334;
  int v324 = v40;
  HIDWORD(v348) = v40;
  uint64_t v19 = v338;
  uint64_t v344 = v38;
  while (1)
  {
    int v335 = v39;
    __int16 v46 = v41 - v45;
    int v47 = btree_node_toc_required_capacity((uint64_t)a4, (__int16)(v41 - v45));
    int v48 = v331 + (unsigned __int16)v337 + (__int16)((v332 - v47) << v38);
    int v49 = HIDWORD(v348);
    int v336 = (__int16)(v331 + v337 + ((v332 - v47) << v38) - WORD2(v348));
    int v50 = (int)v349;
    if (v48 < WORD2(v348)) {
      int v50 = 0;
    }
    BOOL v345 = v45;
    if (v50 == 1)
    {
      unsigned int v51 = *(_DWORD *)(a4[7] + 36) - (__int16)v45 + (__int16)v41;
      if (v51 >= btree_node_toc_required_capacity((uint64_t)a4, 0)) {
        goto LABEL_31;
      }
    }
    else if (v48 < WORD2(v348))
    {
LABEL_31:
      a5 = v343;
      goto LABEL_40;
    }
    a5 = v343;
    if (!v346) {
      goto LABEL_132;
    }
    if ((*v342 & 2) != 0 || v351[54] == a4[14])
    {
      if ((*(_WORD *)(a4[7] + 32) & 2) != 0) {
        goto LABEL_132;
      }
      if (!(_WORD)v42) {
        goto LABEL_132;
      }
      if ((unsigned __int16)(v341 + *(_WORD *)(v43[7] + 36)) > 1u) {
        goto LABEL_132;
      }
      int v52 = btree_node_toc_required_capacity((uint64_t)v43, (__int16)v341);
      __int16 v53 = v339 + v340 + v44 - (v52 << v38);
      if (v336 >= (__int16)(v53 + ((v53 >> 29) & 3)) >> 2) {
        goto LABEL_132;
      }
    }
    else if (v349)
    {
      if (!(_WORD)v42
        || (unsigned __int16)(v46 + *(_WORD *)(a4[7] + 36)) <= (unsigned __int16)(v341
                                                                                                + *(_WORD *)(v43[7] + 36)))
      {
        goto LABEL_132;
      }
    }
    else
    {
      int v97 = btree_node_toc_required_capacity((uint64_t)v43, (__int16)v341);
      if (!(_WORD)v42 || v336 >= (__int16)(v339 + v340 + v44 - (v97 << v38))) {
        goto LABEL_132;
      }
    }
LABEL_40:
    LODWORD(v350) = v41;
    uint64_t v330 = a4[7];
    __int16 v54 = *(_WORD *)(v330 + 32);
    if ((v54 & 2) == 0 || v328 + (unsigned __int16)v42 != a5) {
      goto LABEL_67;
    }
    uint64_t v55 = v19;
    unsigned int v56 = v333;
    __int16 v57 = v341;
    int v58 = v341 + v333;
    int v59 = btree_node_toc_required_capacity((uint64_t)v43, (__int16)(v341 + v333));
    unsigned int v60 = (v59 << v344) - v340;
    int v61 = v323 + (unsigned __int16)v348 + (__int16)(((_WORD)v59 << v344) - v340);
    uint64_t v62 = (uint64_t)v43;
    __int16 v63 = v339;
    int v64 = (int)v349;
    if (v61 > (unsigned __int16)v339) {
      int v64 = 0;
    }
    if (v64 != 1) {
      break;
    }
    unsigned int v65 = v56 + v57 + *(_DWORD *)(*(void *)(v62 + 56) + 36);
    int v66 = (uint64_t *)v62;
    BOOL v67 = v65 >= btree_node_toc_required_capacity(v62, 0);
    uint64_t v19 = v338;
    __int16 v68 = v63;
    if (!v67) {
      goto LABEL_53;
    }
LABEL_47:
    a5 = v343;
    if (v346)
    {
      if (v334) {
        LOWORD(v42) = v335 - 2;
      }
      if (v336 < 0)
      {
        char v43 = v66;
        LOWORD(v39) = v42 + 1;
        int v106 = 2840;
        a8 = v350;
        goto LABEL_293;
      }
LABEL_121:
      BOOL v346 = 1;
LABEL_131:
      a4 = v347;
      unsigned int v41 = v350;
LABEL_132:
      int v106 = 0;
      LOWORD(v39) = v42 + 1;
      a8 = v41;
      goto LABEL_133;
    }
    a4 = v347;
    int v69 = obj_flags((uint64_t)v347);
    obj_unlock((uint64_t)v66, 2u);
    obj_release(v66);
    uint64_t v358 = 0;
    uint64_t v70 = v351[1];
    int v39 = v335;
    if (!v70) {
      uint64_t v70 = *(void *)(*v351 + 392);
    }
    uint64_t v71 = obj_subtype((uint64_t)a4);
    uint64_t v72 = sub_100039D48(v70, v69 & 0xFFFFFC00, v71, v359, v19, &v358);
    int v45 = v345;
    if (v72) {
      return v72;
    }
    unsigned __int16 v73 = v351;
    uint64_t v74 = (atomic_ullong *)(v351[49] + 32);
    BOOL v346 = 1;
    atomic_fetch_add_explicit(v74, 1uLL, memory_order_relaxed);
    obj_dirty((uint64_t)v73, v19, 0);
    char v43 = (uint64_t *)v358;
    int v75 = btree_node_toc_required_capacity((uint64_t)v358, 0);
    LOBYTE(v38) = v344;
    unsigned int v340 = v75 << v344;
    int v339 = sub_10003B9E8((uint64_t)v43);
LABEL_101:
    int v44 = -(int)v348;
    int v42 = (__int16)(v39 - 1);
    unsigned int v41 = v350;
    if (((v39 - 1) & 0x8000) != 0)
    {
      int v106 = 0;
      a8 = v350;
      a5 = v343;
      goto LABEL_133;
    }
  }
  int v66 = (uint64_t *)v62;
  uint64_t v19 = v55;
  __int16 v68 = v339;
  if (v61 > (unsigned __int16)v339) {
    goto LABEL_47;
  }
LABEL_53:
  LODWORD(v350) = v350 - v333;
  a5 = v343;
  if (!v346)
  {
    BOOL v346 = 0;
    if (v334) {
      LOWORD(v42) = v335 - 2;
    }
    goto LABEL_131;
  }
  if ((*v342 & 2) != 0 || v351[54] == v347[14])
  {
LABEL_119:
    if (v334) {
      LOWORD(v42) = v335 - 2;
    }
    goto LABEL_121;
  }
  char v43 = v66;
  HIDWORD(v348) -= v324;
  LODWORD(v348) = v348 + v324;
  if (v349)
  {
    if (!(_WORD)v42
      || (unsigned __int16)(v350 - v345 + *(_WORD *)(v330 + 36)) <= (unsigned __int16)(v58 + *(_WORD *)(v66[7] + 36)))
    {
      goto LABEL_119;
    }
  }
  else if (!(_WORD)v42 || v336 >= (__int16)(v68 - v348 - v60))
  {
    goto LABEL_119;
  }
  int v341 = v58;
  int v49 = HIDWORD(v348);
LABEL_67:
  HIDWORD(v348) = v49;
  if ((v54 & 4) != 0)
  {
    uint64_t v77 = v347[50];
    unsigned int v76 = (v77 >> 9) & 0x3FFF;
  }
  else
  {
    unsigned int v76 = *(unsigned __int16 *)(v347[47] + 8 * (unsigned __int16)v42 + 2);
    uint64_t v77 = v347[50];
  }
  HIWORD(v352) = v76;
  int v78 = btree_node_val_len((uint64_t)v347, (unsigned __int16)v42);
  if (v78 == 65534) {
    int v79 = 0;
  }
  else {
    int v79 = v78;
  }
  LOWORD(v352) = v79;
  int v80 = (v76 + 7) & 0x1FFF8;
  if ((v77 & 0x40) != 0) {
    int v80 = v76;
  }
  else {
    int v79 = (v79 + 7) & 0x1FFF8;
  }
  char v81 = v334;
  if ((unsigned __int16)v42 != a5) {
    char v81 = 0;
  }
  if (v81)
  {
    int v39 = v42;
    uint64_t v19 = v338;
    a4 = v347;
    LOBYTE(v38) = v344;
    int v45 = v345;
    goto LABEL_101;
  }
  unsigned int v82 = a5;
  int v83 = v80 + v79;
  if ((_WORD)v350 != 0 && v320 > (unsigned __int16)v42) {
    unsigned int v84 = v333;
  }
  else {
    unsigned int v84 = 0;
  }
  if ((_WORD)v350 != 0 && v320 > (unsigned __int16)v42) {
    int v85 = v324;
  }
  else {
    int v85 = 0;
  }
  __int16 v86 = v341;
  LODWORD(v38) = v341 + v84 + 1;
  int v87 = btree_node_toc_required_capacity((uint64_t)v43, (__int16)(v341 + v84 + 1));
  int v88 = (unsigned __int16)v85 + (unsigned __int16)v348 + (unsigned __int16)v83 + (__int16)((v87 << v344) - v340);
  int v89 = (int)v349;
  if (v88 > (unsigned __int16)v339) {
    int v89 = 0;
  }
  if (v89 == 1)
  {
    unsigned int v90 = v84 + v86 + *(_DWORD *)(v43[7] + 36) + 1;
    BOOL v67 = v90 >= btree_node_toc_required_capacity((uint64_t)v43, 0);
    a5 = v343;
    if (!v67) {
      goto LABEL_97;
    }
  }
  else
  {
    a5 = v82;
    if (v88 <= (unsigned __int16)v339)
    {
LABEL_97:
      LODWORD(v348) = v348 + v85 + v83;
      LODWORD(v350) = v350 - v84;
      if (v84) {
        int v96 = v85;
      }
      else {
        int v96 = 0;
      }
      HIDWORD(v348) -= v96;
      int v45 = v345 + 1;
      v337 += v83;
      int v39 = v42;
      int v341 = v38;
      uint64_t v19 = v338;
      a4 = v347;
      LOBYTE(v38) = v344;
      goto LABEL_101;
    }
  }
  if (!v346)
  {
    a4 = v347;
    int v91 = obj_flags((uint64_t)v347);
    obj_unlock((uint64_t)v43, 2u);
    obj_release(v43);
    uint64_t v358 = 0;
    uint64_t v92 = v351[1];
    uint64_t v19 = v338;
    if (!v92) {
      uint64_t v92 = *(void *)(*v351 + 392);
    }
    uint64_t v93 = obj_subtype((uint64_t)a4);
    uint64_t v72 = sub_100039D48(v92, v91 & 0xFFFFFC00, v93, v359, v19, &v358);
    int v39 = v335;
    int v45 = v345;
    if (v72) {
      return v72;
    }
    unsigned __int16 v94 = v351;
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v351[49] + 32), 1uLL, memory_order_relaxed);
    obj_dirty((uint64_t)v94, v19, 0);
    char v43 = (uint64_t *)v358;
    int v95 = btree_node_toc_required_capacity((uint64_t)v358, 0);
    LOBYTE(v38) = v344;
    unsigned int v340 = v95 << v344;
    int v339 = sub_10003B9E8((uint64_t)v43);
    BOOL v346 = 1;
    goto LABEL_101;
  }
  uint64_t v19 = v338;
  if ((v336 & 0x80000000) == 0)
  {
    int v106 = 0;
    BOOL v346 = 1;
    a8 = v350;
LABEL_273:
    a4 = v347;
    LOWORD(v39) = v335;
    goto LABEL_133;
  }
  int v106 = 2914;
  a8 = v350;
  if ((__int16)v335 <= 1 && (v54 & 2) == 0)
  {
    int v106 = 0;
    BOOL v346 = 1;
    goto LABEL_273;
  }
  LOWORD(v39) = v335;
LABEL_293:
  if (*(unsigned __int16 *)(v330 + 36) == (unsigned __int16)v39 && v43)
  {
    BOOL v346 = 0;
    uint64_t v356 = v43;
    uint64_t v358 = 0;
    a4 = v347;
    goto LABEL_133;
  }
  __int16 v313 = v39;
  a4 = v347;
  uint64_t v314 = obj_flags((uint64_t)v347) & 0xFFFFFC00;
  uint64_t v315 = v351[1];
  if (!v315) {
    uint64_t v315 = *(void *)(*v351 + 392);
  }
  uint64_t v316 = obj_subtype((uint64_t)a4);
  uint64_t v317 = sub_100039D48(v315, v314, v316, v359, v19, &v356);
  if (v317)
  {
    uint64_t v33 = v317;
    uint64_t v349 = 0;
    size_t v350 = 0;
    LOWORD(v119) = 0;
    int v120 = 0;
    LOWORD(v121) = 0;
    int v122 = 0;
    uint64_t v348 = 0;
    BOOL v345 = 0;
    LODWORD(v344) = 0;
    int v123 = 0;
    BOOL v346 = 1;
    goto LABEL_223;
  }
  uint64_t v318 = v351;
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v351[49] + 32), 1uLL, memory_order_relaxed);
  obj_dirty((uint64_t)v318, v19, 0);
  BOOL v346 = 1;
  LOWORD(v39) = v313;
LABEL_133:
  if (!v329 && (v106 != 0 || v346))
  {
    __int16 v107 = v39;
    uint64_t v108 = obj_flags((uint64_t)a4) & 0xFFFFFC00;
    uint64_t v109 = v351[1];
    if (!v109) {
      uint64_t v109 = *(void *)(*v351 + 392);
    }
    uint64_t v110 = obj_subtype((uint64_t)a4);
    uint64_t v111 = sub_100039D48(v109, v108, v110, v359, v19, &v357);
    if (v111)
    {
      uint64_t v33 = v111;
      uint64_t v349 = 0;
      size_t v350 = 0;
      LOWORD(v119) = 0;
      int v120 = 0;
      LOWORD(v121) = 0;
      int v122 = 0;
      uint64_t v348 = 0;
      BOOL v345 = 0;
      LODWORD(v344) = 0;
      int v123 = 0;
      uint64_t v124 = 0;
      goto LABEL_224;
    }
    uint64_t v125 = v351;
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v351[49] + 32), 1uLL, memory_order_relaxed);
    obj_dirty((uint64_t)v125, v19, 0);
    LOWORD(v39) = v107;
  }
  __int16 v126 = v39;
  if ((__int16)v39 <= (int)a5) {
    int v127 = v334;
  }
  else {
    int v127 = 0;
  }
  uint64_t v128 = a4[7];
  if (v127 != 1)
  {
    uint64_t v138 = v19;
    HIDWORD(v348) = v127;
    unsigned int v333 = a8;
    uint64_t v349 = 0;
    size_t v350 = 0;
    LODWORD(v342) = 0;
    unsigned int v139 = 0;
    goto LABEL_148;
  }
  int v119 = *(_DWORD *)(v128 + 36) + ~a5;
  if (v119 << 16 < 1) {
    goto LABEL_162;
  }
  uint64_t v129 = (uint64_t *)v358;
  uint64_t v130 = sub_10003C658(a4, v358, (__int16)v119, v19);
  if (!v130)
  {
    if (!v346)
    {
      uint64_t v33 = btree_node_key_ptr((uint64_t)v129, 0, &v355, (_WORD *)&v352 + 1);
      if (v33
        || (uint64_t v33 = sub_100032C58((uint64_t)v329, (unsigned __int16)(v325 + 1), v355, HIWORD(v352), 0, 0, v19),
            v33))
      {
        log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v209, v210, v211, v212, v213, v214, v215, (uint64_t)"bt_shift_or_split");
        BOOL v346 = 0;
        uint64_t v349 = 0;
        size_t v350 = 0;
        goto LABEL_222;
      }
      LODWORD(v342) = v119;
      unsigned int v139 = 1;
      goto LABEL_163;
    }
LABEL_162:
    LODWORD(v342) = v119;
    unsigned int v139 = 0;
LABEL_163:
    if (*(_DWORD *)(a4[7] + 36) - 1 != a5) {
      sub_10005F7A4();
    }
    uint64_t v169 = btree_node_val_ptr(a4, a5, &v354, (__int16 *)&v352);
    if (v169)
    {
      uint64_t v33 = v169;
      uint64_t v348 = v139;
      uint64_t v349 = 0;
      size_t v350 = 0;
      goto LABEL_178;
    }
    uint64_t v349 = 0;
    size_t v350 = (unsigned __int16)v352;
    if ((_WORD)v352 && (unsigned __int16)v352 != 65534)
    {
      uint64_t v180 = _apfs_malloc(v350);
      if (!v180)
      {
        uint64_t v348 = v139;
        uint64_t v349 = 0;
        size_t v350 = 0;
        int v120 = 0;
        LOWORD(v121) = 0;
        int v122 = 0;
        BOOL v345 = 0;
        LODWORD(v344) = 0;
        int v123 = 0;
        uint64_t v33 = 12;
        goto LABEL_221;
      }
      uint64_t v349 = v180;
      memcpy(v180, v354, (unsigned __int16)v352);
      size_t v350 = (unsigned __int16)v352;
    }
    HIDWORD(v348) = 1;
    unsigned int v333 = a8;
    sub_1000379AC((uint64_t)a4, a5, v19);
    unsigned int v181 = v351;
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v351[49] + 24), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    uint64_t v138 = v19;
    obj_dirty((uint64_t)v181, v19, 0);
    uint64_t v128 = a4[7];
LABEL_148:
    __int16 v140 = *(_WORD *)(v128 + 36) - v126;
    int v120 = v140;
    LODWORD(v348) = v139;
    if (v140 < 1)
    {
      BOOL v345 = 0;
    }
    else
    {
      uint64_t v141 = (uint64_t *)v358;
      uint64_t v142 = sub_10003C658(a4, v358, v140, v138);
      if (v142)
      {
        uint64_t v33 = v142;
        log_err((uint64_t)"%s:%d: %s bt_move_entries %d failed: %d\n", v143, v144, v145, v146, v147, v148, v149, (uint64_t)"bt_shift_or_split");
LABEL_178:
        int v120 = 0;
LABEL_179:
        LOWORD(v121) = 0;
        int v122 = 0;
        BOOL v345 = 0;
        goto LABEL_180;
      }
      if (!v346)
      {
        uint64_t v33 = btree_node_key_ptr((uint64_t)v141, 0, &v355, (_WORD *)&v352 + 1);
        if (v33
          || (uint64_t v33 = sub_100032C58((uint64_t)v329, (unsigned __int16)(v325 + 1), v355, HIWORD(v352), 0, 0, v138),
              v33))
        {
          log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v193, v194, v195, v196, v197, v198, v199, (uint64_t)"bt_shift_or_split");
          BOOL v346 = 0;
          goto LABEL_179;
        }
      }
      BOOL v345 = !v346;
      if (v329 && !*(_DWORD *)(a4[7] + 36))
      {
        uint64_t v161 = sub_100032C58((uint64_t)v329, v325, v326, v327, 0, 0, v138);
        if (v161)
        {
          uint64_t v33 = v161;
          log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v162, v163, v164, v165, v166, v167, v168, (uint64_t)"bt_shift_or_split");
          LOWORD(v121) = 0;
          int v122 = 0;
LABEL_180:
          LODWORD(v344) = 0;
LABEL_220:
          int v123 = 0;
          goto LABEL_221;
        }
        int v150 = 1;
LABEL_153:
        uint64_t v151 = (uint64_t *)v357;
        LODWORD(v344) = v150;
        if (v357)
        {
          uint64_t v152 = a4[7];
          int v121 = *(_DWORD *)(v152 + 36);
          uint64_t v153 = sub_10003C658(v357, a4, (__int16)-*(_WORD *)(v152 + 36), v138);
          if (v153)
          {
            uint64_t v33 = v153;
            log_err((uint64_t)"%s:%d: %s bt_move_entries %d failed: %d\n", v154, v155, v156, v157, v158, v159, v160, (uint64_t)"bt_shift_or_split");
            LOWORD(v121) = 0;
LABEL_219:
            int v122 = 0;
            goto LABEL_220;
          }
          sub_10003CB10((uint64_t)a4, (unsigned __int16)(*(_WORD *)(a4[7] + 34) + 1), v138);
          if (*(_DWORD *)(v151[7] + 36))
          {
            uint64_t v33 = btree_node_key_ptr((uint64_t)v151, 0, &v355, (_WORD *)&v352 + 1);
            if (v33)
            {
LABEL_218:
              log_err((uint64_t)"%s:%d: %s btree_node_insert failed: %d\n", v200, v201, v202, v203, v204, v205, v206, (uint64_t)"bt_shift_or_split");
              goto LABEL_219;
            }
            uint64_t v207 = (unint64_t *)v355;
            uint64_t v208 = HIWORD(v352);
          }
          else
          {
            uint64_t v207 = (unint64_t *)v326;
            uint64_t v355 = v326;
            uint64_t v208 = v327;
            HIWORD(v352) = v327;
          }
          uint64_t v232 = v322;
          *uint64_t v322 = v151[14];
          uint64_t v33 = sub_100035BF4((uint64_t)a4, v207, v208, v232, (*((_WORD *)a4 + 203) & 0x7Fu) + 8, v138, 0, 0);
          if (v33) {
            goto LABEL_218;
          }
          int v329 = a4;
        }
        else
        {
          LOWORD(v121) = 0;
        }
        if (v346 && (uint64_t v170 = (uint64_t *)v358) != 0)
        {
          uint64_t v171 = v358[7];
          if (*(_DWORD *)(v171 + 36))
          {
            uint64_t v33 = btree_node_key_ptr((uint64_t)v358, 0, &v355, (_WORD *)&v352 + 1);
            if (v33
              || (int v179 = v322,
                  *uint64_t v322 = v170[14],
                  uint64_t v33 = sub_100035BF4((uint64_t)v329, (unint64_t *)v355, HIWORD(v352), v179, (*((_WORD *)v329 + 203) & 0x7Fu) + 8, v138, 0, 0), v33))
            {
              log_err((uint64_t)"%s:%d: %s btree_node_insert failed: %d\n", v172, v173, v174, v175, v176, v177, v178, (uint64_t)"bt_shift_or_split");
              int v122 = 0;
              int v123 = 0;
              BOOL v346 = 1;
LABEL_221:
              uint64_t v124 = (uint64_t)v329;
              LOWORD(v119) = (_WORD)v342;
              goto LABEL_224;
            }
            int v123 = 1;
          }
          else
          {
            if ((*(_WORD *)(v171 + 32) & 2) != 0)
            {
              uint64_t v356 = (uint64_t *)v358;
              int v106 = 1;
            }
            else
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v351[49] + 32), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
              obj_delete_and_free(v170, v138);
              obj_unlock((uint64_t)v170, 2u);
              obj_release(v170);
            }
            int v123 = 0;
            uint64_t v358 = 0;
          }
        }
        else
        {
          int v123 = 0;
        }
        LOWORD(v119) = (_WORD)v342;
        if (v106)
        {
          if (v151) {
            BOOL v182 = v151;
          }
          else {
            BOOL v182 = a4;
          }
          if ((*(_WORD *)(v182[7] + 32) & 2) != 0)
          {
            int v122 = 0;
            uint64_t v222 = (unint64_t *)v326;
            uint64_t v355 = v326;
            uint64_t v223 = v327;
            HIWORD(v352) = v327;
            int v183 = v356;
            uint64_t v124 = (uint64_t)v329;
            uint64_t v192 = v322;
          }
          else
          {
            int v183 = v356;
            uint64_t v184 = sub_10003C658(v182, v356, 1, v338);
            uint64_t v124 = (uint64_t)v329;
            uint64_t v192 = v322;
            if (v184)
            {
              uint64_t v33 = v184;
              log_err((uint64_t)"%s:%d: %s bt_move_entries %d failed: %d\n", v185, v186, v187, v188, v189, v190, v191, (uint64_t)"bt_shift_or_split");
LABEL_303:
              int v122 = 0;
              goto LABEL_224;
            }
            uint64_t v303 = btree_node_key_ptr((uint64_t)v183, 0, &v355, (_WORD *)&v352 + 1);
            if (v303)
            {
              uint64_t v33 = v303;
              log_err((uint64_t)"%s:%d: %s failed to get newnode minkey: %d\n", v304, v305, v306, v307, v308, v309, v310, (uint64_t)"bt_shift_or_split");
              goto LABEL_303;
            }
            uint64_t v222 = (unint64_t *)v355;
            int v122 = 1;
            uint64_t v223 = HIWORD(v352);
          }
          *uint64_t v192 = v183[14];
          uint64_t v224 = sub_100035BF4(v124, v222, v223, v192, (*(_WORD *)(v124 + 406) & 0x7Fu) + 8, v338, 0, 0);
          if (v224)
          {
            uint64_t v33 = v224;
            log_err((uint64_t)"%s:%d: %s btree_node_insert failed: %d\n", v225, v226, v227, v228, v229, v230, v231, (uint64_t)"bt_shift_or_split");
            goto LABEL_224;
          }
          uint64_t v219 = (uint64_t *)v358;
          uint64_t v358 = (unint64_t *)v183;
          uint64_t v220 = v351;
          a4 = v347;
          char v221 = v349;
        }
        else
        {
          if ((_WORD)v333)
          {
            uint64_t v219 = (uint64_t *)v358;
            uint64_t v220 = v351;
            uint64_t v124 = (uint64_t)v329;
            char v221 = v349;
            if (v151) {
              uint64_t v358 = (unint64_t *)v151;
            }
            else {
              uint64_t v358 = 0;
            }
          }
          else
          {
            uint64_t v219 = 0;
            uint64_t v220 = v351;
            uint64_t v124 = (uint64_t)v329;
            char v221 = v349;
          }
          if (!v346) {
            goto LABEL_280;
          }
        }
        sub_10003CBD4((uint64_t)v220, v124, (uint64_t)a4);
LABEL_280:
        if (v221) {
          _apfs_free(v221, v350);
        }
        if (v219)
        {
          obj_unlock((uint64_t)v219, 2u);
          obj_release(v219);
        }
        uint64_t v311 = (uint64_t *)v357;
        uint64_t v312 = v358;
        if (v357 && v358 != v357)
        {
          obj_unlock((uint64_t)v357, 2u);
          obj_release(v311);
        }
        uint64_t v33 = 0;
        *uint64_t v321 = v312;
        return v33;
      }
    }
    int v150 = 0;
    goto LABEL_153;
  }
  uint64_t v33 = v130;
  log_err((uint64_t)"%s:%d: %s bt_move_entries %d failed: %d\n", v131, v132, v133, v134, v135, v136, v137, (uint64_t)"bt_shift_or_split");
  uint64_t v349 = 0;
  size_t v350 = 0;
  LOWORD(v119) = 0;
LABEL_222:
  int v120 = 0;
  LOWORD(v121) = 0;
  int v122 = 0;
  uint64_t v348 = 0;
  BOOL v345 = 0;
  LODWORD(v344) = 0;
  int v123 = 0;
LABEL_223:
  uint64_t v124 = (uint64_t)v329;
LABEL_224:
  log_err((uint64_t)"%s:%d: %s reverting on error: %d\n", v112, v113, v114, v115, v116, v117, v118, (uint64_t)"bt_shift_or_split");
  if (v123) {
    sub_1000379AC(v124, (unsigned __int16)(v325 + 1), v338);
  }
  uint64_t v233 = v338;
  if (v122)
  {
    uint64_t v33 = sub_10003C658(v347, v356, -1, v338);
    if (v33) {
      log_err((uint64_t)"%s:%d: %s bt_move_entries %d failed: %d\n", v234, v235, v236, v237, v238, v239, v240, (uint64_t)"bt_shift_or_split");
    }
  }
  int v241 = (__int16)v121;
  uint64_t v242 = v347;
  uint64_t v243 = (unint64_t *)v349;
  unsigned int v244 = v350;
  if (v241 >= 1)
  {
    sub_10003CB10((uint64_t)v347, (unsigned __int16)(*(_WORD *)(v347[7] + 34) - 1), v233);
    if (sub_10003C658(v357, v242, v241, v233)) {
      log_err((uint64_t)"%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n", v245, v246, v247, v248, v249, v250, v251, (uint64_t)"bt_shift_or_split");
    }
    uint64_t v124 = 0;
  }
  if (v120 >= 1)
  {
    unsigned __int16 v252 = (uint64_t *)v358;
    if (sub_10003C658(v242, v358, (__int16)-(__int16)v120, v233)) {
      log_err((uint64_t)"%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n", v253, v254, v255, v256, v257, v258, v259, (uint64_t)"bt_shift_or_split");
    }
    if (!v346
      && v345
      && (btree_node_key_ptr((uint64_t)v252, 0, &v355, (_WORD *)&v352 + 1)
       || sub_100032C58(v124, (unsigned __int16)(v325 + 1), v355, HIWORD(v352), 0, 0, v233)))
    {
      log_err((uint64_t)"%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n", v260, v261, v262, v263, v264, v265, v266, (uint64_t)"bt_shift_or_split");
    }
    if (v344
      && (btree_node_key_ptr((uint64_t)v242, 0, &v355, (_WORD *)&v352 + 1)
       || sub_100032C58(v124, v325, v355, HIWORD(v352), 0, 0, v233)))
    {
      log_err((uint64_t)"%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n", v267, v268, v269, v270, v271, v272, v273, (uint64_t)"bt_shift_or_split");
    }
  }
  if (HIDWORD(v348))
  {
    if (sub_100035BF4((uint64_t)v242, (unint64_t *)v326, v327, v243, v244, v233, 0, 0)) {
      log_err((uint64_t)"%s:%d: %s btree_node_insert() failed (%d) while trying to revert changes due to error: %d\n", v274, v275, v276, v277, v278, v279, v280, (uint64_t)"bt_shift_or_split");
    }
    if (v243) {
      _apfs_free(v243, v244);
    }
  }
  uint64_t v281 = v351;
  if ((__int16)v119 >= 1)
  {
    uint64_t v282 = (uint64_t *)v358;
    int v283 = sub_10003C658(v242, v358, (__int16)-(__int16)v119, v233);
    char v291 = v348;
    if (v283) {
      log_err((uint64_t)"%s:%d: %s bt_move_entries() failed (%d) while trying to revert changes due to error: %d\n", v284, v285, v286, v287, v288, v289, v290, (uint64_t)"bt_shift_or_split");
    }
    if (!v346
      && (v291 & 1) != 0
      && (btree_node_key_ptr((uint64_t)v282, 0, &v355, (_WORD *)&v352 + 1)
       || sub_100032C58(v124, (unsigned __int16)(v325 + 1), v355, HIWORD(v352), 0, 0, v233)))
    {
      log_err((uint64_t)"%s:%d: %s btree_node_key_update() failed (%d) while trying to revert changes due to error: %d\n", v292, v293, v294, v295, v296, v297, v298, (uint64_t)"bt_shift_or_split");
    }
  }
  unsigned int v299 = (uint64_t *)v358;
  if (v358)
  {
    if (!*(_DWORD *)(v358[7] + 36))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v281[49] + 32), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
      obj_delete_and_free(v299, v233);
    }
    obj_unlock((uint64_t)v299, 2u);
    obj_release(v299);
  }
  uint64_t v300 = v356;
  if (v356)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v281[49] + 32), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    obj_delete_and_free(v300, v233);
    obj_unlock((uint64_t)v300, 2u);
    obj_release(v300);
  }
  uint64_t v301 = (uint64_t *)v357;
  if (v357)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v281[49] + 32), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    obj_delete_and_free(v301, v233);
    obj_unlock((uint64_t)v301, 2u);
    obj_release(v301);
  }
  return v33;
}

uint64_t sub_100035BF4(uint64_t a1, unint64_t *a2, uint64_t a3, unint64_t *a4, unsigned int a5, uint64_t a6, unsigned __int16 *a7, unsigned char *a8)
{
  __chkstk_darwin();
  char v17 = (unint64_t *)&v28[-v16];
  bzero(&v28[-v16], v18);
  unsigned __int16 v30 = 0;
  BOOL v29 = 0;
  uint64_t result = sub_100032A9C(a1, a2, a3, &v30, &v29);
  if (!result)
  {
    if (a8) {
      *a8 = v29;
    }
    if (a7) {
      *a7 = v30;
    }
    if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 0xA) == 8)
    {
      if ((*(_WORD *)(a1 + 406) & 0x7F) + 8 != a5) {
        sub_10005F7D0();
      }
      unint64_t v27 = *(void *)(a1 + 408);
      if (*a4 <= v27)
      {
        log_err((uint64_t)"%s:%d: %s invalid relative OID: %llu < root OID: %llu\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"btree_node_insert");
        return 22;
      }
      *char v17 = *a4 - v27;
      a4 = v17;
    }
    if (v29) {
      return sub_100032C58(a1, v30, a2, a3, a4, a5, a6);
    }
    else {
      return sub_1000334DC(a1, v30, a2, a3, a4, a5, a6);
    }
  }
  return result;
}

uint64_t bt_update_with_hint(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, const void *a5, unsigned int a6, uint64_t a7, uint64_t *a8)
{
  __chkstk_darwin();
  char v17 = (const void **)((char *)&v49 - v16);
  bzero((char *)&v49 - v16, v18);
  int v58 = 0;
  unsigned __int16 v57 = 0;
  if (!obj_refcount(a1)) {
    sub_10005F7FC();
  }
  if (!*(void *)(a1 + 416)) {
    return 22;
  }
  uint64_t v24 = btree_entry_size_check(a1, a4, a6);
  if (!v24)
  {
    uint64_t v24 = obj_modify((void *)a1, (*(_DWORD *)(a1 + 400) >> 3) & 2, a7, v19, v20, v21, v22, v23);
    if (!v24)
    {
      uint64_t v25 = *(void *)(a1 + 392);
      unsigned int v26 = *(_DWORD *)(v25 + 16);
      int v49 = a5;
      BOOL v27 = v26 < a4 || *(_DWORD *)(v25 + 20) < a6;
      BOOL v52 = v27;
      int v59 = 0;
      BOOL v56 = 0;
      int v50 = a8;
      unsigned int v51 = a3;
      if (a8)
      {
        uint64_t v29 = *a8;
        if (*a8)
        {
          if (a8[1] == a1 && ((v52 | ((*(unsigned char *)(a1 + 400) & 0x10) >> 4)) & 1) == 0)
          {
            *char v17 = v29;
            if (v29 != obj_oid(a1)
              && !btree_node_get((void *)a1, v17, a2, (a7 != 0) | (((*(unsigned __int16 *)(*(void *)(a1 + 56) + 32) >> 3) & 1) << 6) | 6u, 0, a7, &v59))
            {
              unsigned __int16 v30 = v59;
              if ((*(_WORD *)(v59[7] + 32) & 2) != 0
                && !sub_10003393C((uint64_t)v59, v51, (unsigned __int16)a4, &v57, &v56)
                && v56)
              {
                if ((*(_WORD *)(v30[7] + 32) & 2) == 0) {
                  goto LABEL_55;
                }
                goto LABEL_40;
              }
              obj_unlock((uint64_t)v30, 2u);
              obj_release(v30);
            }
          }
        }
      }
      uint64_t v24 = 2;
      obj_lock(a1, 2u);
      obj_retain(a1);
      __int16 v32 = (uint64_t *)(a1 + 56);
      uint64_t v31 = *(void *)(a1 + 56);
      if ((*(_WORD *)(v31 + 32) & 2) == 0)
      {
        char v33 = 0;
        uint64_t v34 = 2;
        unsigned __int16 v30 = (uint64_t *)a1;
        while (1)
        {
          if (!*(_DWORD *)(v31 + 36))
          {
            uint64_t v24 = v34;
            goto LABEL_35;
          }
          uint64_t v35 = sub_10003393C((uint64_t)v30, v51, (unsigned __int16)a4, &v57, &v56);
          if (v35
            || (v36 = v57, uint64_t v35 = btree_node_child_val((uint64_t)v30, v57, v17), v35)
            || (uint64_t v35 = btree_node_get((void *)a1, v17, a2, 3u, *(_WORD *)(*v32 + 34) - 1, a7, (uint64_t **)&v58),
                v35))
          {
            uint64_t v24 = v35;
            int v59 = v30;
            goto LABEL_57;
          }
          if ((*(unsigned char *)(a1 + 400) & 0x10) != 0 && v58[14] != *v17) {
            sub_100033980((uint64_t)v30, v36, v58 + 14, a7, v37, v38, v39);
          }
          BOOL v40 = v52;
          if (v30 != (uint64_t *)a1) {
            BOOL v40 = 0;
          }
          if (!v40)
          {
            obj_unlock((uint64_t)v30, 2u);
            obj_release(v30);
          }
          unsigned __int16 v30 = (uint64_t *)v58;
          if (!v58) {
            break;
          }
          uint64_t v34 = 0;
          uint64_t v24 = 0;
          __int16 v32 = (uint64_t *)(v58 + 7);
          uint64_t v31 = v58[7];
          char v33 = 1;
          if ((*(_WORD *)(v31 + 32) & 2) != 0) {
            goto LABEL_35;
          }
        }
        int v59 = 0;
        goto LABEL_55;
      }
      char v33 = 0;
      unsigned __int16 v30 = (uint64_t *)a1;
LABEL_35:
      int v59 = v30;
      if ((*(_WORD *)(v30[7] + 32) & 2) == 0)
      {
        if ((v33 & 1) == 0) {
          goto LABEL_56;
        }
        goto LABEL_55;
      }
      uint64_t v24 = sub_10003393C((uint64_t)v30, v51, (unsigned __int16)a4, &v57, &v56);
      if (v24)
      {
LABEL_56:
        unsigned __int16 v30 = v59;
        if (v59)
        {
LABEL_57:
          obj_unlock((uint64_t)v30, 2u);
          obj_release(v30);
        }
        char v48 = !v52;
        if (v30 == (uint64_t *)a1) {
          char v48 = 1;
        }
        if ((v48 & 1) == 0)
        {
          obj_unlock(a1, 2u);
          obj_release((uint64_t *)a1);
        }
        if (!obj_refcount(a1)) {
          sub_10005F828();
        }
        return v24;
      }
      if (!v56)
      {
LABEL_55:
        uint64_t v24 = 2;
        goto LABEL_56;
      }
LABEL_40:
      uint64_t v55 = 0;
      int v54 = 0;
      unsigned __int16 v53 = 0;
      unsigned int v41 = v57;
      int v42 = btree_node_key_ptr((uint64_t)v30, v57, &v55, &v53);
      char v43 = v50;
      if (!v42)
      {
        int v44 = v55;
        uint64_t v45 = *(void *)(a1 + 8);
        if (!v45) {
          uint64_t v45 = *(void *)(*(void *)a1 + 392);
        }
        if (!(*(unsigned int (**)(uint64_t, const void *, void, unint64_t *, uint64_t, int *))(a1 + 416))(v45, v55, v53, v51, a4, &v54)&& v54)
        {
          panic("you can't change a key here!  (ekey %p eklen %d; key %p klen %d; n %p bt %p)\n",
            v44,
            v53,
            v51,
            a4,
            v30,
            (const void *)a1);
        }
      }
      uint64_t v24 = sub_100032C58((uint64_t)v30, v41, v51, (unsigned __int16)a4, v49, (unsigned __int16)a6, a7);
      if (v24) {
        goto LABEL_56;
      }
      uint64_t v46 = *(void *)(a1 + 392);
      unsigned int v47 = *(_DWORD *)(v46 + 16);
      if (v47 < a4) {
        *(_DWORD *)(v46 + 16) = a4;
      }
      if (*(_DWORD *)(v46 + 20) >= a6)
      {
        if (v47 >= a4 && (*(void *)(a1 + 400) & 0x80) == 0)
        {
LABEL_66:
          if (v43)
          {
            *char v43 = obj_oid((uint64_t)v30);
            v43[1] = a1;
          }
          goto LABEL_56;
        }
      }
      else
      {
        *(_DWORD *)(v46 + 20) = a6;
      }
      obj_dirty(a1, a7, 0);
      goto LABEL_66;
    }
  }
  return v24;
}

uint64_t bt_update(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, const void *a5, unsigned int a6, uint64_t a7)
{
  return bt_update_with_hint(a1, a2, a3, a4, a5, a6, a7, 0);
}

uint64_t bt_update_via_callback(uint64_t a1, uint64_t a2, unint64_t *a3, unsigned int a4, uint64_t a5, unsigned int a6, int a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a10)
{
  __chkstk_darwin();
  uint64_t v19 = (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((char *)&v39 - v18);
  bzero((char *)&v39 - v18, v20);
  uint64_t v46 = 0;
  if (!obj_refcount(a1)) {
    sub_10005F854();
  }
  if (!*(void *)(a1 + 416)) {
    return 22;
  }
  uint64_t v21 = btree_entry_size_check(a1, a4, a6);
  if (!v21)
  {
    obj_lock(a1, 2u);
    uint64_t v27 = obj_modify((void *)a1, (*(_DWORD *)(a1 + 400) >> 3) & 2, a8, v22, v23, v24, v25, v26);
    if (v27)
    {
      uint64_t v21 = v27;
      obj_unlock(a1, 2u);
      return v21;
    }
    char v43 = a3;
    int v42 = a7;
    uint64_t v40 = a10;
    uint64_t v41 = a5;
    uint64_t v39 = a9;
    unsigned __int16 v45 = 0;
    BOOL v44 = 0;
    obj_retain(a1);
    char v29 = 0;
    uint64_t v21 = 2;
    unsigned __int16 v30 = (uint64_t *)a1;
    while (1)
    {
      uint64_t v31 = v30;
      uint64_t v32 = v30[7];
      if ((*(_WORD *)(v32 + 32) & 2) != 0) {
        break;
      }
      if (!*(_DWORD *)(v32 + 36))
      {
        if (v29) {
LABEL_25:
        }
          uint64_t v21 = 2;
        goto LABEL_26;
      }
      uint64_t v33 = sub_10003393C((uint64_t)v30, v43, (unsigned __int16)a4, &v45, &v44);
      if (v33
        || (v34 = v45, uint64_t v33 = btree_node_child_val((uint64_t)v30, v45, v19), v33)
        || (uint64_t v33 = btree_node_get((void *)a1, v19, a2, 3u, *(_WORD *)(v30[7] + 34) - 1, a8, (uint64_t **)&v46),
            v33))
      {
        uint64_t v21 = v33;
        obj_unlock((uint64_t)v30, 2u);
        obj_release(v30);
        if (!obj_refcount(a1)) {
          sub_10005F8AC();
        }
        return v21;
      }
      unsigned __int16 v30 = (uint64_t *)v46;
      if ((*(unsigned char *)(a1 + 400) & 0x10) != 0 && v46[14] != *v19) {
        sub_100033980((uint64_t)v31, v34, v46 + 14, a8, v35, v36, v37);
      }
      obj_unlock((uint64_t)v31, 2u);
      obj_release(v31);
      uint64_t v21 = 0;
      char v29 = 1;
      if (!v30)
      {
        uint64_t v21 = 2;
LABEL_30:
        if (!obj_refcount(a1)) {
          sub_10005F880();
        }
        return v21;
      }
    }
    uint64_t v38 = v43;
    uint64_t v21 = sub_10003393C((uint64_t)v30, v43, (unsigned __int16)a4, &v45, &v44);
    if (!v21)
    {
      if (!v44) {
        goto LABEL_25;
      }
      uint64_t v21 = sub_10003664C((uint64_t)v30, v45, (uint64_t)v38, (unsigned __int16)a4, v41, (unsigned __int16)a6, v42, a8, v39, v40);
    }
LABEL_26:
    obj_unlock((uint64_t)v30, 2u);
    obj_release(v30);
    if (!v21)
    {
      if ((*(unsigned char *)(a1 + 400) & 0x80) != 0) {
        obj_dirty(a1, a8, 0);
      }
      uint64_t v21 = 0;
    }
    goto LABEL_30;
  }
  return v21;
}

uint64_t sub_10003664C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a10)
{
  uint64_t v10 = *(void *)(a1 + 56);
  if (*(_DWORD *)(v10 + 36) <= a2) {
    return 22;
  }
  __int16 v17 = *(_WORD *)(v10 + 32);
  uint64_t v18 = *(void *)(a1 + 376);
  if ((v17 & 4) != 0) {
    uint64_t v19 = (unsigned __int16 *)(v18 + 4 * a2);
  }
  else {
    uint64_t v19 = (unsigned __int16 *)(v18 + 8 * a2);
  }
  uint64_t v20 = *v19;
  uint64_t v21 = (unsigned __int16 *)(v18 + 4 * a2 + 2);
  if ((v17 & 4) == 0) {
    uint64_t v21 = (unsigned __int16 *)(v18 + 8 * a2 + 4);
  }
  uint64_t v22 = *v21;
  if (v20 == 0xFFFF)
  {
    uint64_t v23 = 0;
  }
  else if ((v17 & 4) != 0)
  {
    uint64_t v23 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else
  {
    uint64_t v23 = *(unsigned __int16 *)(v18 + 8 * a2 + 2);
  }
  if (v22 > 0xFFFD)
  {
    uint64_t v24 = 0;
    if (!v23) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v24 = btree_node_val_len(a1, a2);
    if (!v23) {
      goto LABEL_17;
    }
  }
  uint64_t result = sub_100030894(a1, v20, v23);
  if (result) {
    return result;
  }
LABEL_17:
  if (!v24)
  {
    if (v20 != 0xFFFF)
    {
LABEL_27:
      if (v24 >= a6) {
        int v28 = 1;
      }
      else {
        int v28 = a7;
      }
      uint64_t result = 22;
      if (v23 == a4 && v28)
      {
        uint64_t result = a9(*(void *)(a1 + 384) + v20, v23, a3, a4, *(void *)(a1 + 392) - v22, v24, a5, a6, a10);
        if (!result)
        {
          obj_dirty(a1, a8, 0);
          return 0;
        }
      }
      return result;
    }
    return 22;
  }
  LODWORD(result) = sub_1000309C0(a1, v22, v24);
  int v26 = result;
  if (result) {
    uint64_t result = result;
  }
  else {
    uint64_t result = 22;
  }
  if (v20 != 0xFFFF && v26 == 0) {
    goto LABEL_27;
  }
  return result;
}

uint64_t bt_remove_internal(uint64_t *a1, uint64_t a2, int a3, unint64_t *a4, unsigned int a5, void *a6, unsigned int *a7, void *a8, unsigned int *a9, uint64_t a10)
{
  uint64_t v153 = a4;
  long long v165 = 0u;
  long long v166 = 0u;
  long long v164 = 0u;
  uint64_t v163 = 0;
  __chkstk_darwin();
  uint64_t v18 = (uint64_t *)((char *)&v131 - v17);
  bzero((char *)&v131 - v17, v19);
  uint64_t v161 = 0;
  uint64_t v162 = 0;
  uint64_t v160 = 0;
  unsigned __int16 v159 = a5;
  int v20 = *(unsigned __int16 *)(a1[49] + 16);
  if (!obj_refcount((uint64_t)a1)) {
    sub_10005F8D8();
  }
  int v158 = 0;
  unsigned __int16 v157 = 0;
  if (!a1[52]) {
    return 22;
  }
  unint64_t v21 = a1[50];
  uint64_t v22 = (v21 >> 9) & 0x3FFF;
  if (!v22)
  {
    if (((unsigned __int16)((((v21 >> 27) & 0xF000) - 160) & 0xFFE0) >> 2) - 72 >= a5) {
      goto LABEL_5;
    }
    return 22;
  }
  if (v22 != a5) {
    return 22;
  }
LABEL_5:
  uint64_t v144 = a8;
  uint64_t v151 = a2;
  obj_lock((uint64_t)a1, 2u);
  uint64_t v23 = obj_modify(a1, (*((_DWORD *)a1 + 100) >> 3) & 2, a10);
  if (v23)
  {
    uint64_t v24 = v23;
    obj_unlock((uint64_t)a1, 2u);
    return v24;
  }
  uint64_t v142 = a6;
  uint64_t v148 = a10;
  uint64_t v149 = &v131;
  *(void *)&long long v164 = a1;
  obj_retain(a1);
  uint64_t v26 = sub_1000378D4((uint64_t)a1, a3, 1, v153, &v159, (unsigned __int16)a5, (_WORD *)&v164 + 4, (BOOL *)((unint64_t)&v164 | 0xA));
  if (v26)
  {
LABEL_11:
    uint64_t v24 = v26;
    goto LABEL_12;
  }
  uint64_t v152 = (BOOL *)((unint64_t)&v164 | 0xA);
  uint64_t v146 = (_WORD *)&v164 + 4;
  uint64_t v27 = 0;
  uint64_t v147 = 0;
  int v143 = 0;
  char v29 = 0;
  uint64_t v135 = a9;
  __int16 v140 = (_WORD *)&v165 + 4;
  int v141 = (v20 + 7) & 0x1FFF8;
  uint64_t v145 = &v166;
  uint64_t v138 = (_WORD *)&v166 + 4;
  unsigned int v139 = (BOOL *)&v165 + 10;
  uint64_t v137 = (BOOL *)&v166 + 10;
  uint64_t v136 = a7;
  int v30 = v20;
  while (1)
  {
    if ((v29 & 1) == 0)
    {
      uint64_t v31 = v165;
      if (BYTE10(v164)) {
        BOOL v32 = WORD4(v164) == 0;
      }
      else {
        BOOL v32 = 0;
      }
      if (!v32)
      {
        int v150 = 0;
        if (!(void)v165) {
          goto LABEL_41;
        }
        goto LABEL_29;
      }
      int v143 = WORD4(v165);
      uint64_t v27 = (uint64_t *)v164;
      uint64_t v147 = (uint64_t *)v165;
    }
    if (BYTE10(v164)) {
      BOOL v33 = WORD4(v164) == 0;
    }
    else {
      BOOL v33 = 0;
    }
    if (!v33) {
      sub_10005FA0C();
    }
    int v150 = 1;
    uint64_t v31 = v165;
    if (!(void)v165) {
      goto LABEL_41;
    }
LABEL_29:
    if ((a1[50] & 0x7FFE00) != 0) {
      goto LABEL_41;
    }
    uint64_t v156 = 0;
    if (BYTE10(v164))
    {
      uint64_t v34 = btree_node_key_ptr(v31, WORD4(v165), &v162, &v157);
      if (v34) {
        goto LABEL_113;
      }
      __int16 v35 = v141;
      if ((*(void *)(v165 + 400) & 0x40) != 0) {
        __int16 v35 = v30;
      }
      __int16 v36 = v157;
      if ((*(void *)(v165 + 400) & 0x40) == 0) {
        __int16 v36 = (v157 + 7) & 0xFFF8;
      }
      __int16 v37 = v35 - v36;
      __int16 v38 = v37 < 0 ? 0 : v37;
    }
    else
    {
      __int16 v38 = 0;
    }
    __int16 v155 = sub_100033BF4(v164);
    uint64_t v39 = v165;
    __int16 v154 = (*(_WORD *)(v164 + 406) & 0x7F) + 8;
    if (sub_100033A54(v165, 1u, &v155, &v154, v38, 0, 0)) {
      goto LABEL_41;
    }
    unsigned __int16 v47 = WORD4(v165);
    if (!BYTE10(v165)) {
      unsigned __int16 v47 = WORD4(v165) + 1;
    }
    uint64_t v48 = v159;
    uint64_t v42 = sub_100033C6C(a1, v166, WORD4(v166), v39, v47, v153);
    if (v42)
    {
LABEL_114:
      uint64_t v24 = v42;
      goto LABEL_115;
    }
    uint64_t v49 = v156;
    uint64_t v40 = v152;
    if (!v156) {
      goto LABEL_42;
    }
    uint64_t v50 = v165;
    int v134 = v30;
    uint64_t v133 = (uint64_t *)v165;
    if ((void)v166)
    {
      ++WORD4(v166);
      if ((void)v165)
      {
        if (v147 == (uint64_t *)v165 || (uint64_t *)v165 == v27)
        {
          int v54 = (uint64_t *)v165;
        }
        else
        {
          uint64_t v51 = v156;
          BOOL v52 = (uint64_t *)v165;
          obj_unlock(v165, 2u);
          unsigned __int16 v53 = v52;
          uint64_t v49 = v51;
          obj_release(v53);
          int v54 = 0;
        }
      }
      else
      {
        int v54 = 0;
      }
      goto LABEL_74;
    }
    *(void *)&long long v166 = v165;
    if (*(_DWORD *)(*(void *)(v156 + 56) + 36))
    {
      uint64_t v132 = v156;
      uint64_t v34 = btree_node_key_ptr(v156, 0, &v162, &v157);
      if (v34) {
        goto LABEL_113;
      }
      uint64_t v50 = v166;
      uint64_t v55 = v162;
      uint64_t v56 = v157;
    }
    else
    {
      if (a3)
      {
        if (!*(_DWORD *)(*(void *)(v165 + 56) + 36)) {
          goto LABEL_164;
        }
        int v54 = 0;
        WORD4(v166) = 0;
        BYTE10(v166) = 1;
        goto LABEL_74;
      }
      uint64_t v132 = v156;
      uint64_t v55 = v153;
      uint64_t v56 = v48;
    }
    uint64_t v24 = sub_10003393C(v50, v55, v56, v138, v137);
    if (v24) {
      goto LABEL_115;
    }
    int v54 = 0;
    uint64_t v49 = v132;
LABEL_74:
    BOOL v57 = v147 != (uint64_t *)v166 || v147 == 0;
    int v58 = v143;
    if (!v57) {
      int v58 = WORD4(v166);
    }
    *(void *)&long long v165 = v49;
    int v143 = v58;
    if (a3)
    {
      if (!*(_DWORD *)(*(void *)(v49 + 56) + 36))
      {
LABEL_164:
        uint64_t v24 = 2;
LABEL_115:
        uint64_t v163 = v27;
LABEL_116:
        int v28 = v147;
        goto LABEL_117;
      }
      WORD4(v165) = 0;
      BYTE10(v165) = 1;
    }
    else
    {
      uint64_t v34 = sub_10003393C(v49, v153, v48, v140, v139);
      if (v34) {
        goto LABEL_113;
      }
    }
    int v59 = (uint64_t *)v164;
    obj_unlock(v164, 2u);
    obj_release(v59);
    *(void *)&long long v164 = 0;
    uint64_t v42 = btree_node_child_val(v165, WORD4(v165), v18);
    if (v42) {
      goto LABEL_114;
    }
    uint64_t v34 = btree_node_get(a1, v18, v151, 3u, *(_WORD *)(*(void *)(v165 + 56) + 34) - 1, v148, (uint64_t **)&v164);
    if (v34) {
      goto LABEL_113;
    }
    uint64_t v63 = v164;
    if ((a1[50] & 0x10) != 0 && *(void *)(v164 + 112) != *v18)
    {
      sub_100033980(v165, WORD4(v165), (unint64_t *)(v164 + 112), v148, v60, v61, v62);
      uint64_t v63 = v164;
    }
    uint64_t v34 = sub_1000378D4(v63, a3, 1, v153, &v159, (unsigned __int16)a5, v146, v152);
    if (v34)
    {
LABEL_113:
      uint64_t v24 = v34;
      goto LABEL_115;
    }
    if (v147 == v133)
    {
      int v66 = WORD4(v165);
      int v64 = v54;
      if (v147 == a1 && !WORD4(v165))
      {
        uint64_t v27 = (uint64_t *)v165;
        uint64_t v147 = a1;
        uint64_t v40 = v152;
        int v30 = v134;
        goto LABEL_42;
      }
      int v65 = v150;
      if (!WORD4(v165))
      {
        int v143 = WORD4(v166);
        goto LABEL_107;
      }
      int v30 = v134;
      if (v27 != (uint64_t *)v164) {
        sub_10005F9E0();
      }
      uint64_t v147 = (uint64_t *)v165;
LABEL_105:
      int v143 = v66;
      goto LABEL_109;
    }
    int v64 = v54;
    if (v150)
    {
      int v65 = 1;
LABEL_108:
      int v30 = v134;
      goto LABEL_109;
    }
    int v66 = WORD4(v165);
    if (BYTE10(v165) && !WORD4(v165))
    {
      int v143 = WORD4(v166);
      int v65 = 1;
LABEL_107:
      uint64_t v147 = (uint64_t *)v166;
      uint64_t v27 = (uint64_t *)v165;
      goto LABEL_108;
    }
    int v65 = 0;
    int v30 = v134;
    if (BYTE10(v164) && !WORD4(v164))
    {
      int v65 = 1;
      uint64_t v147 = (uint64_t *)v165;
      uint64_t v27 = (uint64_t *)v164;
      goto LABEL_105;
    }
LABEL_109:
    int v150 = v65;
    if (!v64) {
      goto LABEL_41;
    }
    uint64_t v40 = v152;
    if (v64 != v147 && v64 != v27)
    {
      obj_unlock((uint64_t)v64, 2u);
      obj_release(v64);
LABEL_41:
      uint64_t v40 = v152;
    }
LABEL_42:
    if ((*(_WORD *)(*(void *)(v164 + 56) + 32) & 2) != 0) {
      break;
    }
    uint64_t v41 = (uint64_t *)v166;
    if ((void)v166 && (uint64_t *)v166 != v147 && (uint64_t *)v166 != v27)
    {
      obj_unlock(v166, 2u);
      obj_release(v41);
    }
    *uint64_t v145 = v165;
    long long v165 = v164;
    *(void *)&long long v164 = 0;
    uint64_t v42 = btree_node_child_val(v165, WORD4(v165), v18);
    if (v42) {
      goto LABEL_114;
    }
    uint64_t v34 = btree_node_get(a1, v18, v151, 3u, *(_WORD *)(*(void *)(v165 + 56) + 34) - 1, v148, (uint64_t **)&v164);
    if (!v34)
    {
      uint64_t v46 = v164;
      if ((a1[50] & 0x10) != 0 && *(void *)(v164 + 112) != *v18)
      {
        sub_100033980(v165, WORD4(v165), (unint64_t *)(v164 + 112), v148, v43, v44, v45);
        uint64_t v46 = v164;
      }
      uint64_t v34 = sub_1000378D4(v46, a3, 1, v153, &v159, (unsigned __int16)a5, v146, v152);
      char v29 = v150;
      if (!v34) {
        continue;
      }
    }
    goto LABEL_113;
  }
  uint64_t v163 = v27;
  uint64_t v71 = sub_1000378D4(v164, a3, 1, v153, &v159, (unsigned __int16)a5, v146, v40);
  if (v71)
  {
LABEL_146:
    uint64_t v24 = v71;
    goto LABEL_116;
  }
  if (v150)
  {
    uint64_t v72 = v142;
    if (!BYTE10(v164) || WORD4(v164)) {
      sub_10005F9B4();
    }
  }
  else
  {
    uint64_t v72 = v142;
    if (!BYTE10(v164))
    {
      uint64_t v24 = 2;
      goto LABEL_116;
    }
  }
  if (v72)
  {
    uint64_t v71 = btree_node_key_ptr(v164, 0, &v161, (_WORD *)&v158 + 1);
    if (v71) {
      goto LABEL_146;
    }
    unsigned int v73 = HIWORD(v158);
    uint64_t v74 = v136;
    unsigned int v75 = *v136;
    if (*v136 >= HIWORD(v158)) {
      size_t v76 = HIWORD(v158);
    }
    else {
      size_t v76 = v75;
    }
    memcpy(v72, v161, v76);
    *uint64_t v74 = v73;
    if (v75 < v73)
    {
      uint64_t v24 = 34;
      goto LABEL_116;
    }
  }
  int v28 = v147;
  if (v144)
  {
    uint64_t v77 = btree_node_val_ptr((void *)v164, 0, &v160, (__int16 *)&v158);
    if (v77) {
      goto LABEL_161;
    }
    unsigned int v78 = (unsigned __int16)v158;
    unsigned int v79 = (unsigned __int16)v158 == 65534 ? 0 : (unsigned __int16)v158;
    int v80 = v135;
    unsigned int v81 = *v135;
    size_t v82 = *v135 >= v79 ? v79 : v81;
    memcpy(v144, v160, v82);
    *int v80 = v78;
    if (v81 < v79)
    {
      uint64_t v24 = 34;
      goto LABEL_117;
    }
  }
  uint64_t v83 = v148;
  sub_1000379AC(v164, WORD4(v164), v148);
  uint64_t v84 = a1[49];
  if (!*(void *)(v84 + 24)) {
    sub_10005F930();
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(v84 + 24), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
  obj_dirty((uint64_t)a1, v83, 0);
  if (WORD4(v164))
  {
    uint64_t v24 = 0;
  }
  else
  {
    uint64_t v24 = 0;
    if (*(_DWORD *)(*(void *)(v164 + 56) + 36))
    {
      if ((void)v165)
      {
        uint64_t v24 = btree_node_key_ptr(v164, 0, &v162, &v157);
        if (v24 || (uint64_t v24 = sub_100032C58(v165, WORD4(v165), v162, v157, 0, 0, v148), v24))
        {
          log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v85, v86, v87, v88, v89, v90, v91, (uint64_t)"bt_remove_internal");
          int v28 = v147;
        }
      }
    }
  }
  int v92 = sub_100037C2C((uint64_t)a1, v164);
  uint64_t v93 = (uint64_t *)v166;
  int v94 = v150;
  if ((void)v166)
  {
    if ((uint64_t *)v166 != v28 && (uint64_t *)v166 != v27)
    {
      obj_unlock(v166, 2u);
      obj_release(v93);
      int v94 = v150;
    }
    *(void *)&long long v166 = 0;
  }
  int v95 = (uint64_t *)v165;
  if ((void)v165)
  {
    if ((uint64_t *)v165 != v28 && (uint64_t *)v165 != v27)
    {
      obj_unlock(v165, 2u);
      obj_release(v95);
      int v94 = v150;
    }
    *(void *)&long long v165 = 0;
  }
  if (v94 && *(_DWORD *)(*(void *)(v164 + 56) + 36))
  {
    uint64_t v77 = btree_node_key_ptr(v164, 0, &v162, &v157);
    if (v77)
    {
LABEL_161:
      uint64_t v24 = v77;
      goto LABEL_117;
    }
    if (v28)
    {
      uint64_t v24 = sub_100032C58((uint64_t)v28, (unsigned __int16)v143, v162, v157, 0, 0, v148);
      if (v24) {
        log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v96, v97, v98, v99, v100, v101, v102, (uint64_t)"bt_remove_internal");
      }
      if (v147 != (uint64_t *)v166 && v147 != (uint64_t *)v165 && v147 != (uint64_t *)v164)
      {
        uint64_t v103 = v147;
        obj_unlock((uint64_t)v147, 2u);
        obj_release(v103);
      }
    }
    else
    {
      uint64_t v24 = 0;
    }
    uint64_t v104 = v163;
    uint64_t v105 = v163 + 7;
    if ((*(_WORD *)(v163[7] + 32) & 2) == 0)
    {
      uint64_t v106 = v159;
      __int16 v107 = v162;
      while (1)
      {
        LOWORD(v156) = 0;
        LOBYTE(v155) = 0;
        uint64_t v27 = v104;
        uint64_t v108 = sub_10003393C((uint64_t)v104, v153, v106, &v156, (BOOL *)&v155);
        if (v108)
        {
          uint64_t v24 = v108;
          goto LABEL_13;
        }
        int v109 = *(unsigned __int16 *)(*v105 + 34);
        if (!(_BYTE)v155) {
          break;
        }
        if (v109 == 1)
        {
          obj_oid((uint64_t)v27);
          obj_subtype((uint64_t)v27);
          log_err((uint64_t)"%s:%d: %s minkey update traversal unexpectedly found the removed key in level 1 node; oid %llu subt"
                     "ype 0x%x level %d\n",
            v118,
            v119,
            v120,
            v121,
            v122,
            v123,
            v124,
            (uint64_t)"bt_remove_internal");
          goto LABEL_227;
        }
        if ((_WORD)v156) {
          sub_10005F988();
        }
        if (sub_100032C58((uint64_t)v27, 0, v107, v157, 0, 0, v148)) {
          log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v110, v111, v112, v113, v114, v115, v116, (uint64_t)"bt_remove_internal");
        }
        uint64_t v24 = btree_node_child_val((uint64_t)v27, 0, v18);
        __int16 v117 = *(_WORD *)(*v105 + 34);
        uint64_t v163 = 0;
        if (!v24) {
          uint64_t v24 = btree_node_get(a1, v18, v151, 3u, v117 - 1, v148, &v163);
        }
        if (v27 != (uint64_t *)v166 && v27 != (uint64_t *)v165 && v27 != (uint64_t *)v164)
        {
          obj_unlock((uint64_t)v27, 2u);
          obj_release(v27);
        }
        if (!v24)
        {
          uint64_t v104 = v163;
          uint64_t v105 = v163 + 7;
          if ((*(_WORD *)(v163[7] + 32) & 2) == 0) {
            continue;
          }
        }
        goto LABEL_228;
      }
      if (v109 != 1) {
        sub_10005F95C();
      }
LABEL_227:
      uint64_t v24 = 0;
    }
  }
  else if (v28 && v28 != (uint64_t *)v166 && v28 != (uint64_t *)v164)
  {
    obj_unlock((uint64_t)v28, 2u);
    obj_release(v28);
  }
LABEL_228:
  uint64_t v125 = v163;
  if (v163)
  {
    if (v163 != (uint64_t *)v166 && v163 != (uint64_t *)v165 && v163 != (uint64_t *)v164)
    {
      obj_unlock((uint64_t)v163, 2u);
      obj_release(v125);
    }
    uint64_t v163 = 0;
  }
  if (!v92)
  {
    __int16 v126 = 0;
    unsigned __int16 v128 = 0;
    goto LABEL_241;
  }
  if (WORD4(v164) || !*(_DWORD *)(*(void *)(v164 + 56) + 36))
  {
    __int16 v126 = 0;
    unsigned __int16 v127 = 0;
    goto LABEL_237;
  }
  uint64_t v26 = btree_node_key_ptr(v164, 0, &v162, &v157);
  if (v26) {
    goto LABEL_11;
  }
  unsigned __int16 v127 = v157;
  uint64_t v130 = (unint64_t *)_apfs_malloc(v157);
  __int16 v126 = v130;
  if (v130) {
    memcpy(v130, v162, v157);
  }
  uint64_t v24 = 0;
LABEL_237:
  if (v126)
  {
    unsigned __int16 v128 = v127;
  }
  else
  {
    __int16 v126 = v153;
    unsigned __int16 v128 = v159;
  }
LABEL_241:
  uint64_t v129 = (uint64_t *)v164;
  obj_unlock(v164, 2u);
  obj_release(v129);
  *(void *)&long long v164 = 0;
  if (v92)
  {
    sub_100037CDC((uint64_t)a1, v151, v126, v128, v148);
    if (v126 != v153) {
      _apfs_free(v126, v128);
    }
  }
LABEL_12:
  uint64_t v27 = 0;
LABEL_13:
  int v28 = 0;
LABEL_117:
  BOOL v67 = (uint64_t *)v166;
  if ((void)v166)
  {
    if ((uint64_t *)v166 != v28 && (void)v166 != (void)v27)
    {
      obj_unlock(v166, 2u);
      obj_release(v67);
    }
    *(void *)&long long v166 = 0;
  }
  int v69 = (uint64_t *)v165;
  if ((void)v165)
  {
    if ((uint64_t *)v165 != v28 && (uint64_t *)v165 != v27)
    {
      obj_unlock(v165, 2u);
      obj_release(v69);
    }
    *(void *)&long long v165 = 0;
  }
  uint64_t v70 = (uint64_t *)v164;
  if ((void)v164)
  {
    if ((uint64_t *)v164 != v28 && (uint64_t *)v164 != v27)
    {
      obj_unlock(v164, 2u);
      obj_release(v70);
    }
    *(void *)&long long v164 = 0;
  }
  if (v28 && v28 != (uint64_t *)v166 && v28 != (uint64_t *)v165)
  {
    obj_unlock((uint64_t)v28, 2u);
    obj_release(v28);
    uint64_t v27 = v163;
  }
  if (v27 && v27 != (uint64_t *)v166 && v27 != (uint64_t *)v165 && v27 != (uint64_t *)v164)
  {
    obj_unlock((uint64_t)v27, 2u);
    obj_release(v27);
  }
  if (!obj_refcount((uint64_t)a1)) {
    sub_10005F904();
  }
  return v24;
}

uint64_t sub_1000378D4(uint64_t a1, char a2, int a3, void *a4, _WORD *a5, unsigned int a6, _WORD *a7, BOOL *a8)
{
  if (a2)
  {
    if (!*(_DWORD *)(*(void *)(a1 + 56) + 36)) {
      return 2;
    }
    uint64_t v10 = 0;
    *a7 = 0;
    *a8 = 1;
    if (a3)
    {
      __src = 0;
      unsigned __int16 v15 = 0;
      uint64_t v10 = btree_node_key_ptr(a1, 0, &__src, &v15);
      if (!v10)
      {
        if (v15 >= a6) {
          size_t v12 = a6;
        }
        else {
          size_t v12 = v15;
        }
        *a5 = v12;
        memcpy(a4, __src, v12);
      }
    }
    return v10;
  }
  else
  {
    uint64_t v13 = (unsigned __int16)*a5;
    return sub_10003393C(a1, (unint64_t *)a4, v13, a7, a8);
  }
}

void sub_1000379AC(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  int v7 = *(_WORD *)(v6 + 32) & 4;
  if (v7) {
    unsigned int v8 = (*(_DWORD *)(a1 + 400) >> 9) & 0x3FFF;
  }
  else {
    unsigned int v8 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 8 * a2 + 2);
  }
  if (*(unsigned __int16 *)(a1 + 440) <= v8)
  {
    *(_WORD *)(a1 + 440) = 0;
    int v7 = *(_WORD *)(v6 + 32) & 4;
  }
  uint64_t v9 = *(void *)(a1 + 376);
  uint64_t v10 = (unsigned __int16 *)(v9 + 4 * a2);
  uint64_t v11 = (unsigned __int16 *)(v9 + 8 * a2);
  if (v7) {
    size_t v12 = v10;
  }
  else {
    size_t v12 = v11;
  }
  unsigned int v13 = *v12;
  if ((*(unsigned char *)(a1 + 400) & 0x40) == 0) {
    LOWORD(v8) = (v8 + 7) & 0xFFF8;
  }
  if (v13 != 0xFFFF)
  {
    int v14 = (unsigned __int16)v8;
    if (!sub_100030894(a1, v13, (unsigned __int16)v8)) {
      sub_10003BC88(a1, 1, v13, v14);
    }
  }
  uint64_t v15 = *(void *)(a1 + 376);
  uint64_t v16 = v15 + 4 * a2 + 2;
  uint64_t v17 = v15 + 8 * a2 + 4;
  if ((*(_WORD *)(*(void *)(a1 + 56) + 32) & 4) != 0) {
    uint64_t v18 = (unsigned __int16 *)v16;
  }
  else {
    uint64_t v18 = (unsigned __int16 *)v17;
  }
  unsigned int v19 = *v18;
  uint64_t v20 = *(void *)(a1 + 400);
  unsigned __int16 v21 = btree_node_val_len(a1, a2);
  unsigned __int16 v22 = (v21 + 7) & 0xFFF8;
  if ((v20 & 0x40) != 0) {
    unsigned __int16 v22 = v21;
  }
  if (v19 <= 0xFFFD)
  {
    int v23 = v22;
    if (!sub_1000309C0(a1, v19, v22)) {
      sub_10003BC88(a1, 2, v19, v23);
    }
  }
  uint64_t v24 = *(void *)(a1 + 56);
  unsigned int v25 = *(_DWORD *)(v24 + 36) - 1;
  if (v25 > a2)
  {
    sub_10003C5C8(a1, a2, -1);
    uint64_t v24 = *(void *)(a1 + 56);
    unsigned int v25 = *(_DWORD *)(v24 + 36) - 1;
  }
  *(_DWORD *)(v24 + 36) = v25;
  __int16 v26 = *(_WORD *)(v24 + 32);
  if ((v26 & 4) != 0)
  {
    if ((*(unsigned char *)(a1 + 400) & 4) == 0) {
      goto LABEL_39;
    }
    unsigned int v27 = 4;
  }
  else
  {
    unsigned int v27 = 8;
  }
  unsigned int v28 = *(unsigned __int16 *)(v24 + 42) / v27;
  if (v28 - v25 >= 0x10)
  {
    if ((v26 & 4) != 0)
    {
      unint64_t v30 = *(void *)(a1 + 400);
      if ((v26 & 2) != 0) {
        unint64_t v31 = v30 >> 23;
      }
      else {
        LODWORD(v31) = (HIWORD(v30) & 0x7F) + 8;
      }
      unint64_t v32 = (((v30 >> 27) & 0x1F000) - 56) / (((v30 >> 9) & 0x3FFF) + (unsigned __int16)v31 + 4);
      if (v28 <= (v32 & 0xFFFE)) {
        goto LABEL_39;
      }
      unsigned __int16 v33 = v32 & 0xFFFE;
      int v34 = v28 - 8;
      __int16 v35 = v28 - v33;
      if (v34 >= v33) {
        __int16 v29 = 8;
      }
      else {
        __int16 v29 = v35;
      }
    }
    else
    {
      __int16 v29 = 8;
    }
    unsigned __int16 v36 = v29 * v27;
    memmove((void *)(*(void *)(a1 + 384) - (unsigned __int16)(v29 * v27)), *(const void **)(a1 + 384), *(unsigned __int16 *)(v24 + 44));
    *(void *)(a1 + 384) -= v36;
    uint64_t v37 = *(void *)(a1 + 56);
    *(_WORD *)(v37 + 42) -= v36;
    *(_WORD *)(v37 + 46) += v36;
  }
LABEL_39:

  obj_dirty(a1, a3, 0);
}

uint64_t sub_100037C2C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  int v3 = *(unsigned __int16 *)(v2 + 32);
  if ((~v3 & 3) == 0) {
    return 0;
  }
  unsigned int v4 = *(_DWORD *)(v2 + 36);
  if (!v4) {
    return 1;
  }
  if (*(void *)(a1 + 432) == *(void *)(a2 + 112)) {
    return 0;
  }
  if ((v3 & 4) != 0 && (*(unsigned char *)(a2 + 400) & 4) == 0) {
    return v4 < *(unsigned __int16 *)(v2 + 42) >> 3;
  }
  __int16 v7 = obj_size_phys(a2);
  if (*(_WORD *)(*(void *)(a2 + 56) + 32)) {
    __int16 v8 = -96;
  }
  else {
    __int16 v8 = -56;
  }
  return sub_10003B9E8(a2) > (unsigned __int16)((v8 + v7) & 0xFFFE) >> 1;
}

void sub_100037CDC(uint64_t a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v52 = a2;
  __chkstk_darwin();
  uint64_t v10 = (uint64_t *)((char *)&v50 - v9);
  bzero((char *)&v50 - v9, v11);
  uint64_t v12 = *(void *)(a1 + 56);
  if (!v12) {
    return;
  }
  memset(v60, 0, sizeof(v60));
  unsigned int v13 = *(unsigned __int16 *)(v12 + 34);
  if (v13 >= 6)
  {
    uint64_t v14 = v13 + 11;
    uint64_t v16 = (unsigned __int16)(v13 + 11);
    uint64_t v15 = _apfs_malloc(8 * v16);
    unsigned __int16 v53 = _apfs_malloc(2 * v16);
  }
  else
  {
    uint64_t v14 = 8;
    unsigned __int16 v53 = v59;
    uint64_t v15 = v60;
  }
  obj_lock(a1, 2u);
  if (obj_modify(a1, (*(_DWORD *)(a1 + 400) >> 3) & 2, a5))
  {
    obj_unlock(a1, 2u);
    return;
  }
  v59[0] = 0;
  v59[1] = 0;
  int v55 = 0;
  int v56 = 0;
  *(void *)uint64_t v15 = a1;
  obj_retain(a1);
  LOWORD(v17) = 0;
  uint64_t v18 = *(uint64_t **)v15;
  if ((*(_WORD *)(*(void *)(*(void *)v15 + 56) + 32) & 2) == 0)
  {
    uint64_t v19 = 0;
    uint64_t v17 = 0;
    uint64_t v57 = 0;
    int v58 = 0;
    BOOL v54 = 0;
    __int16 v20 = v14;
    uint64_t v51 = v14;
    if ((v14 & 0xFFFE) == 0) {
      __int16 v20 = 1;
    }
    uint64_t v21 = (unsigned __int16)(v20 - 1);
    unsigned __int16 v22 = (uint64_t **)v15 + 1;
    do
    {
      if (sub_10003393C((uint64_t)v18, a3, a4, &v53[v19], &v54)) {
        goto LABEL_63;
      }
      if (v21 == v17)
      {
        LOWORD(v14) = v51;
        LOWORD(v17) = v51 - 1;
        goto LABEL_64;
      }
      void *v10 = 0;
      if (btree_node_child_val((uint64_t)*(v22 - 1), (unsigned __int16)v53[v17], v10)
        || btree_node_get((void *)a1, v10, v52, 3u, *(_WORD *)((*(v22 - 1))[7] + 34) - 1, a5, v22))
      {
        goto LABEL_63;
      }
      uint64_t v18 = *v22;
      if ((*(unsigned char *)(a1 + 400) & 0x10) != 0 && v18[14] != *v10)
      {
        sub_100033980((uint64_t)*(v22 - 1), (unsigned __int16)v53[v17], (unint64_t *)v18 + 14, a5, v23, v24, v25);
        uint64_t v18 = *v22;
      }
      ++v19;
      ++v22;
      ++v17;
    }
    while ((*(_WORD *)(v18[7] + 32) & 2) == 0);
    if ((_WORD)v17)
    {
      unsigned __int16 v26 = v17;
      LOWORD(v14) = v51;
      while (1)
      {
        uint64_t v27 = ((__int16)v26 - 1);
        if ((__int16)v26 < 1) {
          break;
        }
        if ((int)v17 <= (__int16)v26) {
          unsigned int v28 = 0;
        }
        else {
          unsigned int v28 = (uint64_t *)*((void *)v15 + ((__int16)v26 + 1));
        }
        sub_10003CD34(a1, *((void *)v15 + v27), (unsigned __int16)v53[v27], *((void *)v15 + v26), (unsigned __int16)v53[v26], v28, v52, a5);
        int v29 = *(_DWORD *)(*(void *)(*((void *)v15 + v26) + 56) + 36);
        if ((__int16)v26 < 2 || v29)
        {
          if (v29)
          {
            if (btree_node_key_ptr(*((void *)v15 + v27), (unsigned __int16)v53[v27], &v57, &v55)) {
              goto LABEL_64;
            }
            int v56 = 0;
            if (btree_node_key_ptr(*((void *)v15 + v26), 0, &v58, (_WORD *)&v55 + 1)) {
              goto LABEL_64;
            }
            uint64_t v45 = *(void *)(a1 + 8);
            if (!v45) {
              uint64_t v45 = *(void *)(*(void *)a1 + 392);
            }
            uint64_t v46 = v58;
            int v47 = (*(uint64_t (**)(uint64_t, void *, void, uint64_t, void, int *))(a1 + 416))(v45, v58, HIWORD(v55), v57, (unsigned __int16)v55, &v56);
            if (!v47 && v56) {
              int v47 = sub_100032C58(*((void *)v15 + v27), (unsigned __int16)v53[v27], v46, HIWORD(v55), 0, 0, a5);
            }
            if (v47) {
              goto LABEL_64;
            }
          }
        }
        else if (!v53[v27])
        {
          uint64_t v30 = (unsigned __int16)(v26 - 1);
          if (v26 != 1)
          {
            uint64_t v31 = *((void *)v15 + (unsigned __int16)(v26 - 1));
            if (*(_DWORD *)(*(void *)(v31 + 56) + 36))
            {
              unint64_t v32 = &v53[v30];
              unsigned int v33 = v30 - 1;
              --v26;
              while (1)
              {
                if (*v32--) {
                  goto LABEL_27;
                }
                if (btree_node_key_ptr(v31, 0, &v58, (_WORD *)&v55 + 1)) {
                  goto LABEL_62;
                }
                int v56 = 0;
                if (btree_node_key_ptr(*((void *)v15 + v33), (unsigned __int16)v53[v33], &v57, &v55)) {
                  goto LABEL_62;
                }
                uint64_t v42 = *(void *)(a1 + 8);
                if (!v42) {
                  uint64_t v42 = *(void *)(*(void *)a1 + 392);
                }
                uint64_t v43 = v58;
                int v44 = (*(uint64_t (**)(uint64_t, void *, void, uint64_t, void, int *))(a1 + 416))(v42, v58, HIWORD(v55), v57, (unsigned __int16)v55, &v56);
                if (!v44 && v56) {
                  int v44 = sub_100032C58(*((void *)v15 + v33), (unsigned __int16)v53[v33], v43, HIWORD(v55), 0, 0, a5);
                }
                if (v44)
                {
LABEL_62:
                  log_err((uint64_t)"%s:%d: %s updating grandparent failed w/%d\n", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"bt_merge_up");
                  goto LABEL_63;
                }
                LOWORD(v27) = v27 - 1;
                if ((_WORD)v27)
                {
                  uint64_t v31 = *((void *)v15 + (unsigned __int16)v27);
                  --v33;
                  if (*(_DWORD *)(*(void *)(v31 + 56) + 36)) {
                    continue;
                  }
                }
                goto LABEL_27;
              }
            }
          }
        }
        --v26;
LABEL_58:
        if ((sub_100037C2C(a1, *((void *)v15 + v26)) & 1) == 0) {
          goto LABEL_64;
        }
      }
      --v26;
      sub_10003CD34(a1, 0, 0, *(void *)v15, (unsigned __int16)*v53, *((uint64_t **)v15 + 1), v52, a5);
LABEL_27:
      if ((v26 & 0x8000) != 0) {
        goto LABEL_63;
      }
      LOWORD(v14) = v51;
      goto LABEL_58;
    }
    LOWORD(v17) = 0;
LABEL_63:
    LOWORD(v14) = v51;
  }
LABEL_64:
  int v48 = 0;
  do
  {
    uint64_t v49 = (uint64_t *)*((void *)v15 + (__int16)v48);
    obj_unlock((uint64_t)v49, 2u);
    obj_release(v49);
    ++v48;
  }
  while ((unsigned __int16)v17 >= (__int16)v48);
  if ((unsigned __int16)v14 >= 9u)
  {
    _apfs_free(v15, 8 * (unsigned __int16)v14);
    _apfs_free(v53, 2 * (unsigned __int16)v14);
  }
}

uint64_t bt_remove(uint64_t *a1, uint64_t a2, unint64_t *a3, unsigned int a4, uint64_t a5)
{
  return bt_remove_internal(a1, a2, 0, a3, a4, 0, 0, 0, 0, a5);
}

uint64_t bt_remove_first(uint64_t *a1, uint64_t a2, void *a3, unsigned int *a4, void *a5, unsigned int *a6, uint64_t a7)
{
  size_t v14 = *(unsigned int *)(a1[49] + 16);
  uint64_t v15 = (unint64_t *)_apfs_malloc(v14);
  if (!v15) {
    return 12;
  }
  uint64_t v16 = v15;
  uint64_t v17 = bt_remove_internal(a1, a2, 1, v15, v14, a3, a4, a5, a6, a7);
  _apfs_free(v16, v14);
  return v17;
}

uint64_t bt_lookup_first(uint64_t *a1, uint64_t a2, void *a3, _DWORD *a4, void *a5, unsigned int *a6)
{
  __chkstk_darwin();
  unsigned int v13 = &v29[-v12];
  bzero(&v29[-v12], v14);
  unsigned int v33 = 0;
  if (!obj_refcount((uint64_t)a1)) {
    sub_10005FA38();
  }
  if (!a1[52]) {
    return 22;
  }
  unint64_t v15 = a1[50];
  unsigned int v16 = (v15 >> 9) & 0x3FFF;
  if (v16)
  {
    if (*a4 != v16) {
      return 22;
    }
  }
  int v17 = (unsigned __int16)(v15 >> 23);
  if (v17)
  {
    if (*a6 != v17) {
      return 22;
    }
  }
  int v30 = 0;
  obj_lock((uint64_t)a1, 1u);
  obj_retain(a1);
  uint64_t v19 = a1 + 7;
  uint64_t v18 = a1[7];
  if ((*(_WORD *)(v18 + 32) & 2) != 0)
  {
    __int16 v20 = a1;
LABEL_16:
    if (*(_DWORD *)(v18 + 36))
    {
      unint64_t v32 = 0;
      uint64_t v21 = btree_node_key_ptr((uint64_t)v20, 0, &v32, (_WORD *)&v30 + 1);
      if (!v21)
      {
        uint64_t v31 = 0;
        uint64_t v21 = btree_node_val_ptr(v20, 0, &v31, (__int16 *)&v30);
        if (!v21)
        {
          unsigned int v22 = (unsigned __int16)v30;
          if ((unsigned __int16)v30 == 65534) {
            unsigned int v23 = 0;
          }
          else {
            unsigned int v23 = (unsigned __int16)v30;
          }
          int v24 = HIWORD(v30);
          if (*a4 >= HIWORD(v30)) {
            size_t v25 = HIWORD(v30);
          }
          else {
            size_t v25 = *a4;
          }
          if (*a4 >= HIWORD(v30) && *a6 >= v23) {
            uint64_t v21 = 0;
          }
          else {
            uint64_t v21 = 34;
          }
          memcpy(a3, v32, v25);
          if (*a6 >= v23) {
            size_t v27 = v23;
          }
          else {
            size_t v27 = *a6;
          }
          memcpy(a5, v31, v27);
          *a4 = v24;
          *a6 = v22;
        }
      }
    }
    else
    {
      uint64_t v21 = 2;
    }
    obj_unlock((uint64_t)v20, 1u);
    obj_release(v20);
  }
  else
  {
    __int16 v20 = a1;
    while (1)
    {
      *unsigned int v13 = 0;
      uint64_t v21 = btree_node_child_val((uint64_t)v20, 0, v13);
      if (!v21) {
        uint64_t v21 = btree_node_get(a1, v13, a2, 2u, *(_WORD *)(*v19 + 34) - 1, 0, &v33);
      }
      obj_unlock((uint64_t)v20, 1u);
      obj_release(v20);
      if (v21) {
        break;
      }
      __int16 v20 = v33;
      uint64_t v19 = v33 + 7;
      uint64_t v18 = v33[7];
      if ((*(_WORD *)(v18 + 32) & 2) != 0) {
        goto LABEL_16;
      }
    }
  }
  return v21;
}

uint64_t bt_lookup_variant(uint64_t *a1, uint64_t a2, unint64_t *a3, unsigned int *a4, unsigned int a5, void *a6, unsigned int *a7, unsigned int a8, int a9, uint64_t *a10)
{
  if (!obj_refcount((uint64_t)a1)) {
    sub_10005FA64();
  }
  if (!a1[52]) {
    return 22;
  }
  unint64_t v18 = a1[50];
  unsigned int v19 = (v18 >> 9) & 0x3FFF;
  if (v19)
  {
    if (*a4 != v19) {
      return 22;
    }
  }
  if ((unsigned __int16)(v18 >> 23) && *a7 != (unsigned __int16)(v18 >> 23)) {
    return 22;
  }
  unsigned int v20 = *a4;
  if ((v18 & 0x7FFE00) == 0 && v20 > ((unsigned __int16)((((v18 >> 27) & 0xF000) - 160) & 0xFFE0) >> 2) - 72) {
    return 22;
  }
  unsigned __int16 v26 = 0;
  unsigned __int16 v25 = 0;
  uint64_t v21 = sub_1000387A8(a1, a2, a3, (unsigned __int16)v20, a8, a9, 0, a10, &v26, &v25);
  if (!v21)
  {
    unsigned int v23 = v26;
    uint64_t v24 = sub_100038D88((uint64_t)a1, v26, v25, a3, a4, a5, a6, a7, a8);
    uint64_t v21 = v24;
    if (a10 && !v24)
    {
      *a10 = obj_oid((uint64_t)v23);
      a10[1] = (uint64_t)a1;
    }
    obj_unlock((uint64_t)v23, 1u);
    obj_release(v23);
  }
  return v21;
}

uint64_t sub_1000387A8(uint64_t *a1, uint64_t a2, unint64_t *a3, unsigned int a4, unsigned int a5, int a6, unsigned int a7, uint64_t *a8, uint64_t **a9, unsigned __int16 *a10)
{
  int v41 = a6;
  unsigned int v42 = a7;
  unsigned int v45 = a4;
  uint64_t v43 = a2;
  int v44 = a3;
  uint64_t v39 = a9;
  uint64_t v13 = a1[50];
  __chkstk_darwin();
  unint64_t v15 = &v37[-v14];
  bzero(&v37[-v14], v16);
  int v48 = 0;
  uint64_t v49 = 0;
  unsigned __int16 v47 = 0;
  char v46 = 0;
  if (!a8) {
    goto LABEL_9;
  }
  uint64_t v17 = *a8;
  if (!*a8) {
    goto LABEL_9;
  }
  if ((uint64_t *)a8[1] != a1) {
    goto LABEL_9;
  }
  if ((v13 & 0x10) != 0) {
    goto LABEL_9;
  }
  *unint64_t v15 = v17;
  if (v17 == obj_oid((uint64_t)a1)
    || btree_node_get(a1, v15, v43, (((*(unsigned __int16 *)(a1[7] + 32) >> 3) & 1) << 6) | 6u, 0, 0, &v49))
  {
    goto LABEL_9;
  }
  unint64_t v18 = v49;
  if ((*(_WORD *)(v49[7] + 32) & 2) == 0) {
    goto LABEL_8;
  }
  int v35 = sub_100032A9C((uint64_t)v49, v44, v45, &v47, (BOOL *)&v46);
  if (!v35 && v46)
  {
    if (a5 != 4)
    {
      if (a5 != 2) {
        goto LABEL_80;
      }
      if (v47)
      {
        --v47;
        goto LABEL_80;
      }
LABEL_83:
      char v46 = 0;
      goto LABEL_8;
    }
    if (*(_DWORD *)(v18[7] + 36) <= ++v47) {
      goto LABEL_83;
    }
LABEL_80:
    int v34 = v39;
LABEL_81:
    uint64_t v33 = 0;
    *int v34 = v18;
    *a10 = v47;
    return v33;
  }
  if (!(v35 | a5))
  {
    if (v47 && *(_DWORD *)(v18[7] + 36) > v47)
    {
      unsigned __int16 v25 = 0;
      uint64_t v33 = 2;
      int v34 = v39;
      goto LABEL_53;
    }
    goto LABEL_8;
  }
  if (!v35 && a5 - 3 <= 1 && v47 && *(_DWORD *)(v18[7] + 36) > v47) {
    goto LABEL_80;
  }
LABEL_8:
  obj_unlock((uint64_t)v18, 1u);
  obj_release(v18);
LABEL_9:
  BOOL v19 = a5 == 2;
  unsigned int v38 = a5 - 3;
  BOOL v20 = a5 - 3 < 2;
  obj_lock((uint64_t)a1, 1u);
  uint64_t v49 = a1;
  obj_retain(a1);
  unsigned __int16 v21 = 0;
  unsigned int v22 = a1;
  unsigned int v40 = a5;
  while (1)
  {
    char v46 = 0;
    uint64_t v24 = v22 + 7;
    uint64_t v23 = v22[7];
    if ((*(_WORD *)(v23 + 32) & 2) != 0)
    {
      unsigned __int16 v25 = 0;
    }
    else
    {
      unsigned __int16 v25 = 0;
      while (*(unsigned __int16 *)(v23 + 34) > v42)
      {
        uint64_t v26 = sub_10003393C((uint64_t)v22, v44, v45, &v47, (BOOL *)&v46);
        if (v26) {
          goto LABEL_48;
        }
        unsigned int v27 = v47;
        if (v19 && v47 != 0 || v20 && *(_DWORD *)(*v24 + 36) - 1 > v47)
        {
          if (v25)
          {
            obj_unlock((uint64_t)v25, 1u);
            obj_release(v25);
            unsigned int v27 = v47;
          }
          unsigned __int16 v25 = v49;
          obj_retain(v49);
          unsigned __int16 v21 = v20 - v19 + v27;
        }
        unsigned int v28 = v49;
        if ((v41 & 0x100) != 0)
        {
          uint64_t v29 = v49[7];
          if (*(_WORD *)(v29 + 34) == 1
            && *(_DWORD *)(v29 + 36) - 1 > v27
            && !btree_node_child_val((uint64_t)v49, (unsigned __int16)(v27 + 1), v15))
          {
            btree_node_get(a1, v15, v43, 0x100u, *(_WORD *)(v28[7] + 34) - 1, 0, &v48);
          }
        }
        uint64_t v26 = btree_node_child_val((uint64_t)v28, v27, v15);
        if (v26) {
          goto LABEL_48;
        }
        uint64_t v26 = btree_node_get(a1, v15, v43, 2u, *(_WORD *)(v28[7] + 34) - 1, 0, &v48);
        if (v26) {
          goto LABEL_48;
        }
        btree_node_release(v28, v28 != v25);
        unsigned int v22 = v48;
        uint64_t v49 = v48;
        uint64_t v24 = v48 + 7;
        uint64_t v23 = v48[7];
        if ((*(unsigned char *)(v23 + 32) & 2) != 0) {
          break;
        }
      }
    }
    uint64_t v26 = sub_100032A9C((uint64_t)v22, v44, v45, &v47, (BOOL *)&v46);
    if (v26)
    {
LABEL_48:
      uint64_t v33 = v26;
      goto LABEL_49;
    }
    if (v46) {
      break;
    }
    if (!v40)
    {
      uint64_t v33 = 2;
      goto LABEL_49;
    }
    unsigned int v30 = v47;
    if (v40 <= 2 && v47)
    {
      uint64_t v33 = 0;
      char v46 = 1;
      goto LABEL_69;
    }
    if (v38 <= 1)
    {
      unsigned int v31 = *(_DWORD *)(*v24 + 36);
      goto LABEL_43;
    }
LABEL_44:
    if (!v25)
    {
      uint64_t v33 = 2;
      unint64_t v18 = v49;
      int v34 = v39;
      if (v49) {
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    btree_node_release(v22, v22 != v25);
    uint64_t v32 = btree_node_child_val((uint64_t)v25, v21, v15);
    if (v32 || (uint64_t v32 = btree_node_get(a1, v15, v43, 2u, *(_WORD *)(v25[7] + 34) - 1, 0, &v49), v32))
    {
      uint64_t v33 = v32;
      uint64_t v49 = 0;
      int v34 = v39;
      goto LABEL_50;
    }
    obj_unlock((uint64_t)v25, 1u);
    obj_release(v25);
    BOOL v19 = 0;
    BOOL v20 = 0;
    unsigned int v22 = v49;
  }
  if (v40 != 2)
  {
    if (v40 != 4 || (++v47, unsigned int v31 = *(_DWORD *)(*v24 + 36), v31 > v47))
    {
      uint64_t v33 = 0;
      goto LABEL_49;
    }
    unsigned int v30 = v47;
    char v46 = 0;
LABEL_43:
    if (v31 > v30)
    {
      uint64_t v33 = 0;
      char v46 = 1;
      goto LABEL_49;
    }
    goto LABEL_44;
  }
  LOWORD(v30) = v47;
  if (!v47)
  {
    char v46 = 0;
    goto LABEL_44;
  }
  uint64_t v33 = 0;
LABEL_69:
  unsigned __int16 v47 = v30 - 1;
LABEL_49:
  int v34 = v39;
  if (!v25) {
    goto LABEL_51;
  }
LABEL_50:
  obj_unlock((uint64_t)v25, 1u);
  obj_release(v25);
LABEL_51:
  unint64_t v18 = v49;
  if (!v33) {
    goto LABEL_81;
  }
  if (!v49) {
    goto LABEL_54;
  }
LABEL_53:
  btree_node_release(v18, v18 != v25);
LABEL_54:
  *int v34 = 0;
  return v33;
}

uint64_t sub_100038D88(uint64_t a1, void *a2, unsigned __int16 a3, void *a4, _DWORD *a5, unsigned int a6, void *a7, unsigned int *a8, int a9)
{
  __src = 0;
  int v28 = 0;
  int v29 = 0;
  if (!(a9 | a6))
  {
    __src = 0;
    HIWORD(v28) = 0;
    goto LABEL_22;
  }
  uint64_t v17 = btree_node_key_ptr((uint64_t)a2, a3, &__src, (_WORD *)&v28 + 1);
  uint64_t v18 = v17;
  if (a9) {
    BOOL v19 = v17 == 0;
  }
  else {
    BOOL v19 = 0;
  }
  if (!v19)
  {
LABEL_19:
    if (v18) {
      return v18;
    }
    goto LABEL_22;
  }
  uint64_t v20 = *(void *)(a1 + 8);
  if (!v20) {
    uint64_t v20 = *(void *)(*(void *)a1 + 392);
  }
  uint64_t v18 = (*(uint64_t (**)(uint64_t, void *, void, void *, void, int *))(a1 + 416))(v20, __src, HIWORD(v28), a4, *a5, &v29);
  if (!v18)
  {
    if (a9 == 2 && (v29 & 0x80000000) == 0 || a9 == 1 && v29 > 0 || a9 == 3 && v29 < 0 || a9 == 4 && v29 <= 0)
    {
      uint64_t v18 = nx_corruption_detected_int(*(void *)(*(void *)a1 + 392));
      goto LABEL_19;
    }
LABEL_22:
    unsigned int v30 = 0;
    uint64_t v18 = btree_node_val_ptr(a2, a3, &v30, (__int16 *)&v28);
    if (!v18)
    {
      unsigned int v21 = (unsigned __int16)v28;
      if ((unsigned __int16)v28 == 65534) {
        unsigned int v22 = 0;
      }
      else {
        unsigned int v22 = (unsigned __int16)v28;
      }
      unsigned int v23 = *a8;
      if (*a8 < v22 || (uint64_t v18 = 0, a6) && HIWORD(v28) > a6) {
        uint64_t v18 = 34;
      }
      if (a6)
      {
        int v24 = HIWORD(v28);
        if (HIWORD(v28) >= a6) {
          size_t v25 = a6;
        }
        else {
          size_t v25 = HIWORD(v28);
        }
        memcpy(a4, __src, v25);
        *a5 = v24;
        unsigned int v23 = *a8;
      }
      if (v23 >= v22) {
        size_t v26 = v22;
      }
      else {
        size_t v26 = v23;
      }
      memcpy(a7, v30, v26);
      *a8 = v21;
    }
  }
  return v18;
}

__n128 bt_iterator_init_with_hint(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, unint64_t *a5, int a6, unsigned int a7, void *a8, unsigned int a9, _OWORD *a10)
{
  *(void *)a1 = a2;
  *(void *)(a1 + 8) = a3;
  int v16 = a4 & 0x180;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 20) = a7;
  *(void *)(a1 + 32) = a5;
  *(void *)(a1 + 40) = a8;
  *(void *)(a1 + 24) = a9;
  uint64_t v17 = (uint64_t *)(a1 + 56);
  if (a10)
  {
    *(_OWORD *)uint64_t v17 = *a10;
  }
  else
  {
    *uint64_t v17 = 0;
    *(void *)(a1 + 64) = 0;
  }
  *(_DWORD *)(a1 + 48) = a6;
  *(_DWORD *)(a1 + 52) = a9;
  if ((a4 & 4) != 0)
  {
    unsigned int v18 = 4;
  }
  else if ((a4 & 2) != 0)
  {
    int v21 = a4 & 0x180;
    int v19 = bt_lookup_variant(a2, a3, a5, (unsigned int *)(a1 + 48), a7, a8, (unsigned int *)(a1 + 52), 1u, v16, (uint64_t *)(a1 + 56));
    if (v19 != 2) {
      goto LABEL_11;
    }
    unsigned int v18 = 3;
    int v16 = v21;
  }
  else
  {
    unsigned int v18 = 3;
  }
  int v19 = bt_lookup_variant(a2, a3, a5, (unsigned int *)(a1 + 48), a7, a8, (unsigned int *)(a1 + 52), v18, v16, v17);
LABEL_11:
  if (v19)
  {
    *(_DWORD *)(a1 + 16) |= 1u;
    if (v19 != 2) {
      *(_DWORD *)(a1 + 28) = v19;
    }
  }
  else if (a10)
  {
    __n128 result = *(__n128 *)v17;
    *a10 = *(_OWORD *)v17;
  }
  return result;
}

double bt_iterator_init(uint64_t a1, uint64_t *a2, uint64_t a3, int a4, unint64_t *a5, int a6, unsigned int a7, void *a8, unsigned int a9)
{
  *(void *)&double result = bt_iterator_init_with_hint(a1, a2, a3, a4, a5, a6, a7, a8, a9, 0).n128_u64[0];
  return result;
}

uint64_t bt_iterator_ended(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 28);
  if (!result) {
    return *(_DWORD *)(a1 + 16) & 1;
  }
  return result;
}

uint64_t bt_iterator_next(uint64_t a1)
{
  uint64_t result = *(unsigned int *)(a1 + 28);
  if (!result)
  {
    int v3 = *(_DWORD *)(a1 + 16);
    uint64_t result = 2;
    if ((v3 & 1) == 0)
    {
      unsigned int v4 = *(_DWORD *)(a1 + 20);
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a1 + 24);
      if ((v3 & 0x1000) != 0) {
        unsigned int v5 = 2;
      }
      else {
        unsigned int v5 = 4;
      }
      uint64_t result = bt_lookup_variant(*(uint64_t **)a1, *(void *)(a1 + 8), *(unint64_t **)(a1 + 32), (unsigned int *)(a1 + 48), v4, *(void **)(a1 + 40), (unsigned int *)(a1 + 52), v5, v3 & 0x180, (uint64_t *)(a1 + 56));
      if (result == 2)
      {
        uint64_t result = 0;
        *(_DWORD *)(a1 + 16) |= 1u;
      }
      *(_DWORD *)(a1 + 28) = result;
    }
  }
  return result;
}

uint64_t bt_iterate_individual(uint64_t *a1, uint64_t a2, int a3, void *__src, size_t __n, _OWORD *a6, uint64_t (*a7)(void, void, void, void, uint64_t, __n128), uint64_t a8, void *a9, void *a10)
{
  unsigned int v10 = __n;
  unint64_t v12 = a1[50];
  unint64_t v13 = v12 >> 27;
  uint64_t v14 = (v12 >> 27) & 0x1F000;
  unsigned int v15 = (v12 >> 9) & 0x3FFF;
  if (v15)
  {
    uint64_t v44 = 0;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    unsigned int v16 = __n;
    if (v15 == __n) {
      goto LABEL_3;
    }
    return 34;
  }
  unsigned int v16 = (unsigned __int16)(((unsigned __int16)(v14 - 160) >> 2) - 72);
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  if ((v12 & 0x7FFE00) == 0 && v16 < __n) {
    return 34;
  }
LABEL_3:
  uint64_t v17 = a9;
  if (!a9)
  {
    unsigned int v18 = __src;
    int v19 = _apfs_calloc(1uLL, v16);
    __src = v18;
    uint64_t v17 = v19;
  }
  uint64_t v20 = a10;
  if (!a10)
  {
    int v21 = __src;
    unsigned int v22 = _apfs_calloc(1uLL, v13 & 0x1F000);
    __src = v21;
    uint64_t v20 = v22;
  }
  unsigned int v23 = 0;
  unsigned int v24 = 12;
  if (v17 && v20)
  {
    size_t v25 = v20;
    memcpy(v17, __src, v10);
    size_t v26 = a1;
    unsigned int v27 = v25;
    __n128 v29 = bt_iterator_init_with_hint((uint64_t)&v40, v26, a2, a3, (unint64_t *)v17, v10, v16, v25, v14, a6);
    if (v28)
    {
LABEL_10:
      unsigned int v24 = v28;
      unsigned int v23 = 0;
    }
    else
    {
      while (1)
      {
        if (HIDWORD(v41) || (v41 & 1) != 0)
        {
          unsigned int v23 = 0;
          goto LABEL_23;
        }
        unsigned int v32 = a7(v42, v43, *((void *)&v42 + 1), DWORD1(v43), a8, v29);
        if (v32) {
          break;
        }
        unsigned int v28 = bt_iterator_next((uint64_t)&v40);
        if (v28) {
          goto LABEL_10;
        }
      }
      unsigned int v23 = v32;
LABEL_23:
      unsigned int v24 = 0;
    }
    uint64_t v20 = v27;
  }
  if (a9)
  {
    if (a10) {
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v33 = v16;
    int v34 = v20;
    _apfs_free(v17, v33);
    uint64_t v20 = v34;
    if (a10) {
      goto LABEL_27;
    }
  }
  _apfs_free(v20, v13 & 0x1F000);
LABEL_27:
  if (v24) {
    return v24;
  }
  else {
    return v23;
  }
}

uint64_t bt_iterate_bulk(uint64_t *a1, uint64_t a2, __int16 a3, unint64_t *a4, unsigned int a5, uint64_t *a6, uint64_t (*a7)(void, uint64_t, void, void, uint64_t), uint64_t a8)
{
  unint64_t v8 = a1[50];
  long long v48 = 0uLL;
  unsigned int v47 = 4;
  unsigned int v9 = (v8 >> 9) & 0x3FFF;
  if (v9) {
    BOOL v10 = v9 == a5;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10) {
    return 34;
  }
  unsigned __int16 v14 = a5;
  unint64_t v19 = v8 >> 27;
  uint64_t v20 = (v8 >> 27) & 0x1F000;
  if ((v8 & 0x7FFE00) == 0 && a5 > (unsigned __int16)(((unsigned __int16)(v20 - 160) >> 2) - 72)) {
    return 34;
  }
  uint64_t v22 = v19 & 0x1F000;
  unsigned int v23 = (char *)_apfs_calloc(1uLL, v19 & 0x1F000);
  if (!v23) {
    return 12;
  }
  memset(v52, 0, 128);
  memset(v50, 0, sizeof(v50));
  memset(v51, 0, sizeof(v51));
  memset(v49, 0, sizeof(v49));
  unsigned int v24 = a4;
  size_t v25 = v23;
  uint64_t v21 = sub_1000395F8(a1, a2, v24, v14, a3, a6, v23, v20, (int *)&v47, (uint64_t)v52, (uint64_t)v50, (uint64_t)v51, (uint64_t)v49);
  if (!v21)
  {
    unsigned int v45 = v25;
    if (a6) {
      long long v48 = *(_OWORD *)a6;
    }
    __int16 v41 = a3 & 0xFFF9 | 4;
    unsigned int v42 = v20;
    int v26 = 4;
    uint64_t v43 = a2;
    uint64_t v44 = v22;
    while (1)
    {
      int v46 = v47;
      if ((int)v47 >= 1) {
        break;
      }
LABEL_18:
      uint64_t v36 = v46 - 1;
      uint64_t v37 = (unint64_t *)v52[v36];
      unsigned int v38 = *((unsigned __int16 *)v50 + 2 * v36);
      unsigned int v47 = v26;
      uint64_t v39 = sub_1000395F8(a1, v43, v37, v38, v41, (uint64_t *)&v48, v45, v42, (int *)&v47, (uint64_t)v52, (uint64_t)v50, (uint64_t)v51, (uint64_t)v49);
      v26 <<= v26 < 16;
      uint64_t v22 = v44;
      if (v39)
      {
        uint64_t v21 = v39;
        size_t v25 = v45;
        if (v39 == 2) {
          uint64_t v21 = 0;
        }
        goto LABEL_23;
      }
    }
    unsigned int v27 = (unsigned int *)v49;
    unsigned int v28 = v51;
    __n128 v29 = (unsigned int *)v50;
    unsigned int v30 = v52;
    uint64_t v31 = v47;
    while (1)
    {
      unsigned int v33 = *v29++;
      uint64_t v32 = v33;
      unsigned int v34 = *v27++;
      uint64_t v35 = a7(*v30, v32, *v28, v34, a8);
      if (v35) {
        break;
      }
      ++v28;
      ++v30;
      if (!--v31) {
        goto LABEL_18;
      }
    }
    uint64_t v21 = v35;
    uint64_t v22 = v44;
    size_t v25 = v45;
  }
LABEL_23:
  _apfs_free(v25, v22);
  return v21;
}

uint64_t sub_1000395F8(uint64_t *a1, uint64_t a2, unint64_t *a3, unsigned int a4, __int16 a5, uint64_t *a6, char *a7, unsigned int a8, int *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  int v15 = *a9;
  unsigned int v34 = 0;
  unsigned __int16 v33 = 0;
  uint64_t v16 = sub_100039A04(a1, a2, a3, a4, a5, a6, &v34, &v33);
  uint64_t v17 = v34;
  if (!v16)
  {
    int v18 = 0;
    unsigned int v19 = v33;
    *a9 = 0;
    if (*(_DWORD *)(v17[7] + 36) <= v19 || v15 < 1)
    {
LABEL_17:
      if (v18) {
        uint64_t v16 = 0;
      }
      else {
        uint64_t v16 = 34;
      }
    }
    else
    {
      while (1)
      {
        __src = 0;
        memset(__n, 0, sizeof(__n));
        uint64_t v21 = btree_node_key_ptr((uint64_t)v17, (unsigned __int16)v19, &__src, (_WORD *)__n + 1);
        if (v21) {
          break;
        }
        uint64_t v21 = btree_node_val_ptr(v17, (unsigned __int16)v19, &__n[1], (__int16 *)__n);
        if (v21) {
          break;
        }
        int v22 = LOWORD(__n[0]);
        if (LOWORD(__n[0]) == 65534) {
          size_t v23 = 0;
        }
        else {
          size_t v23 = LOWORD(__n[0]);
        }
        int v24 = HIWORD(__n[0]);
        unsigned int v25 = v23 + HIWORD(__n[0]);
        BOOL v26 = a8 >= v25;
        a8 -= v25;
        if (!v26)
        {
          int v18 = *a9;
          goto LABEL_17;
        }
        memcpy(a7, __src, HIWORD(__n[0]));
        uint64_t v27 = *a9;
        *(void *)(a10 + 8 * v27) = a7;
        *(_DWORD *)(a11 + 4 * v27) = v24;
        unsigned int v28 = &a7[v24];
        memcpy(v28, *(const void **)&__n[1], v23);
        uint64_t v29 = *a9;
        *(void *)(a12 + 8 * v29) = v28;
        *(_DWORD *)(a13 + 4 * v29) = v22;
        LOWORD(v19) = v19 + 1;
        int v18 = *a9 + 1;
        *a9 = v18;
        if (*(_DWORD *)(v17[7] + 36) > (unsigned __int16)v19)
        {
          a7 = &v28[v23];
          if (v18 < v15) {
            continue;
          }
        }
        goto LABEL_17;
      }
      uint64_t v16 = v21;
    }
  }
  if (v17)
  {
    obj_unlock((uint64_t)v17, 1u);
    obj_release(v17);
  }
  return v16;
}

uint64_t bt_iterate_per_node(uint64_t *a1, uint64_t a2, __int16 a3, unint64_t *a4, unsigned int a5, uint64_t *a6, uint64_t (*a7)(const void *, void, uint64_t, void, uint64_t), uint64_t a8)
{
  unsigned __int16 v11 = a5;
  unint64_t v16 = a1[50];
  unsigned int v17 = (v16 >> 9) & 0x3FFF;
  if (v17)
  {
    __int16 v41 = 0;
    unsigned __int16 v40 = 0;
    unsigned int v18 = a5;
    if (v17 == a5) {
      goto LABEL_3;
    }
    return 34;
  }
  unsigned int v18 = ((unsigned __int16)((((v16 >> 27) & 0xF000) - 160) & 0xFFE0) >> 2) - 72;
  __int16 v41 = 0;
  unsigned __int16 v40 = 0;
  if ((v16 & 0x7FFE00) == 0 && v18 < a5) {
    return 34;
  }
LABEL_3:
  uint64_t v19 = v18;
  uint64_t v20 = _apfs_calloc(1uLL, v18);
  if (!v20) {
    return 12;
  }
  uint64_t v21 = v20;
  unsigned int v22 = sub_100039A04(a1, a2, a4, v11, a3, a6, &v41, &v40);
  if (!v22)
  {
    __int16 v28 = a3 & 0xFFF9 | 4;
    __int16 v36 = v28;
    while (1)
    {
      uint64_t v38 = 0;
      uint64_t v39 = 0;
      int v37 = 0;
      uint64_t v29 = v41;
      unsigned __int16 v30 = v40;
      if (*(_DWORD *)(v41[7] + 36) > v40) {
        break;
      }
      unsigned int v33 = 0;
      uint64_t v31 = 0;
LABEL_26:
      unsigned __int16 v40 = v30;
      if (v19 >= v33) {
        size_t v34 = v33;
      }
      else {
        size_t v34 = v19;
      }
      memcpy(v21, v31, v34);
      obj_unlock((uint64_t)v29, 1u);
      obj_release(v29);
      __int16 v41 = 0;
      unsigned int v35 = sub_100039A04(a1, a2, (unint64_t *)v21, HIWORD(v37), v28, 0, &v41, &v40);
      if (v35)
      {
        unsigned int v24 = 0;
        if (v35 == 2) {
          unsigned int v23 = 0;
        }
        else {
          unsigned int v23 = v35;
        }
        goto LABEL_6;
      }
    }
    while (1)
    {
      unsigned int v22 = btree_node_key_ptr((uint64_t)v29, v30, &v39, (_WORD *)&v37 + 1);
      if (v22) {
        break;
      }
      unsigned int v22 = btree_node_val_ptr(v29, v30, &v38, (__int16 *)&v37);
      if (v22) {
        break;
      }
      uint64_t v31 = v39;
      unsigned int v32 = a7(v39, HIWORD(v37), v38, (unsigned __int16)v37, a8);
      if (v32)
      {
        unsigned int v24 = v32;
        unsigned int v23 = 0;
        goto LABEL_6;
      }
      if (*(_DWORD *)(v29[7] + 36) <= ++v30)
      {
        unsigned int v33 = HIWORD(v37);
        __int16 v28 = v36;
        goto LABEL_26;
      }
    }
  }
  unsigned int v23 = v22;
  unsigned int v24 = 0;
LABEL_6:
  unsigned int v25 = v41;
  if (v41)
  {
    obj_unlock((uint64_t)v41, 1u);
    obj_release(v25);
  }
  _apfs_free(v21, v19);
  if (v23) {
    return v23;
  }
  else {
    return v24;
  }
}

uint64_t sub_100039A04(uint64_t *a1, uint64_t a2, unint64_t *a3, unsigned int a4, __int16 a5, uint64_t *a6, uint64_t **a7, unsigned __int16 *a8)
{
  int v15 = a5 & 0x180;
  if ((a5 & 4) != 0)
  {
    unsigned int v17 = 4;
    goto LABEL_6;
  }
  if ((a5 & 2) == 0 || (uint64_t v16 = sub_1000387A8(a1, a2, a3, a4, 1u, v15, 0, a6, a7, a8), v16 == 2))
  {
    unsigned int v17 = 3;
LABEL_6:
    uint64_t v16 = sub_1000387A8(a1, a2, a3, a4, v17, v15, 0, a6, a7, a8);
  }
  if (a6 && !v16)
  {
    *a6 = obj_oid((uint64_t)*a7);
    a6[1] = (uint64_t)a1;
  }
  return v16;
}

uint64_t btree_create_extended(pthread_mutex_t **a1, unsigned int a2, unsigned int a3, unsigned int a4, int a5, uint64_t *a6, uint64_t a7, uint64_t *a8)
{
  uint64_t v38 = 0;
  if ((a2 & 0x7FF03FF) != 0) {
    sub_10005FB14();
  }
  unsigned int v9 = *((_DWORD *)a6 + 5);
  if (v9 >= 0x200) {
    sub_10005FAE8();
  }
  __int16 v12 = a4;
  unsigned int v13 = a3;
  unsigned int v15 = a2 >> 30;
  int v16 = (v9 << 26) & 0x40000000 | ((v9 >> 3) << 31) | (((v9 >> 5) & 1) << 27) | a2;
  if ((v9 & 0x18) == 0) {
    int v16 = a2;
  }
  int v17 = v9 | (a2 >> 26) & 0x10;
  if ((a2 & 0x80000000) != 0) {
    v17 |= 8u;
  }
  unsigned int v18 = v17 | (a2 >> 22) & 0x20;
  if (v15) {
    int v19 = a2;
  }
  else {
    int v19 = v16;
  }
  if (v15) {
    uint64_t v20 = v18;
  }
  else {
    uint64_t v20 = v9;
  }
  if ((v19 & 0x40000000) != 0 && (v19 & 0x88000000) != 0) {
    sub_10005FA90();
  }
  if ((v20 & 0x10) != 0 && (v20 & 0x28) != 0) {
    sub_10005FABC();
  }
  if (!a3) {
    unsigned int v13 = *(_DWORD *)(*(void *)(*(void *)(*a1)[6].__opaque + 376) + 36);
  }
  if (v13 - 65537 < 0xFFFF0060 || a4 != 8 && (v20 & 1) != 0) {
    return 22;
  }
  if (a4 > (unsigned __int16)(((unsigned __int16)(v13 - 160) >> 2) - 72)) {
    return 22;
  }
  uint64_t v21 = (unsigned __int16)a5;
  if (a5 + a4 > btree_entry_max_size(v20, v13, (unsigned __int16)a4, (unsigned __int16)a5)) {
    return 22;
  }
  unint64_t v29 = ((unsigned __int16)(v12 & 0x3FFF) << 9) | (unint64_t)(v21 << 23) | v20 | ((unint64_t)(v13 >> 12) << 39);
  uint64_t v30 = *a6;
  unint64_t v37 = v29;
  uint64_t v39 = v30;
  uint64_t v36 = 0x300086583;
  if ((v20 & 0x80) == 0)
  {
    __int16 v31 = 19;
    if ((v20 & 0x100) == 0) {
      goto LABEL_27;
    }
    goto LABEL_26;
  }
  if (authapfs_valid_hash_type(*((_DWORD *)a6 + 6), v22, v23, v24, v25, v26, v27, v28)) {
    return 22;
  }
  unsigned int v34 = *((_DWORD *)a6 + 6);
  if (v34 > 0xF) {
    return 22;
  }
  unsigned int v35 = *((_DWORD *)a6 + 7);
  unint64_t v37 = v29 & 0xFF800FFFFFFFFFFFLL | ((unint64_t)(v34 & 0xF) << 44) | ((unint64_t)(v35 & 0x7F) << 48);
  if (v35 > 0x7F) {
    return 22;
  }
  WORD2(v36) = 11;
  __int16 v31 = 27;
  if ((v20 & 0x100) != 0) {
LABEL_26:
  }
    WORD2(v36) = v31;
LABEL_27:
  uint64_t result = sub_100039D48(a1, v19, *((_DWORD *)a6 + 4), (uint64_t)&v36, a7, a8);
  if (!result)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(*a8 + 392) + 32), 1uLL, memory_order_relaxed);
    uint64_t v33 = a6[1];
    if (v33) {
      *(void *)(*a8 + 424) = v33;
    }
    obj_unlock(*a8, 2u);
    return 0;
  }
  return result;
}

uint64_t sub_100039D48(pthread_mutex_t **a1, int a2, int a3, uint64_t a4, uint64_t a5, void *a6)
{
  long long v19 = btree_node_desc;
  unsigned int v6 = *(unsigned __int16 *)(a4 + 4);
  if ((v6 & 0xFFE4) != 0) {
    sub_10005FBC4();
  }
  if ((a2 & 0x7FF03FF) != 0) {
    sub_10005FB98();
  }
  unint64_t v8 = *(void *)(a4 + 8);
  if (((v6 >> 3) ^ (v8 >> 7))) {
    sub_10005FB6C();
  }
  if (((v6 >> 4) ^ (v8 >> 8))) {
    sub_10005FB40();
  }
  DWORD2(v19) = (v8 >> 27) & 0x1F000;
  if (v6) {
    LODWORD(v19) = 2;
  }
  uint64_t v20 = 0;
  DWORD1(v19) = a3;
  if ((v6 & 0x10) != 0) {
    int v12 = 536870916;
  }
  else {
    int v12 = 4;
  }
  int v13 = v12 | a2;
  unsigned __int16 v14 = *a1;
  if (obj_type((uint64_t)a1) == 13) {
    uint64_t v15 = (uint64_t)a1;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t v16 = obj_create(v14, v13, 0, (unsigned int *)&v19, a4, v15, a5, &v20);
  if (!v16)
  {
    uint64_t v17 = v20;
    *a6 = v20;
    obj_dirty(v17, a5, 0);
  }
  return v16;
}

uint64_t btree_create(pthread_mutex_t **a1, unsigned int a2, int a3, int a4, unsigned int a5, unsigned int a6, int a7, uint64_t a8, uint64_t a9, uint64_t *a10)
{
  v11[1] = 0;
  long long v14 = 0u;
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  v11[0] = a8;
  int v12 = a4;
  int v13 = a3;
  return btree_create_extended(a1, a2, a5, a6, a7, v11, a9, a10);
}

uint64_t btree_get_extended(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, uint64_t **a8)
{
  unsigned int v16 = *(_DWORD *)(a6 + 28);
  if (v16 >= 0x40) {
    unsigned int v16 = 64;
  }
  size_t v17 = v16 + 32;
  __chkstk_darwin();
  long long v19 = (char *)&v50 - v18;
  bzero((char *)&v50 - v18, v17);
  unsigned __int16 v53 = 0;
  long long v52 = btree_node_desc;
  if ((a2 & 0x7FF03FF) != 0) {
    sub_10005FCCC();
  }
  unsigned int v27 = *(_DWORD *)(a6 + 20);
  if (v27 >= 0x200) {
    sub_10005FCA0();
  }
  if (a5 >= 0x10) {
    sub_10005FC74();
  }
  unint64_t v51 = a4;
  int v28 = (v27 << 26) & 0x40000000 | ((v27 >> 3) << 31) | (((v27 >> 5) & 1) << 27) | a2;
  if ((v27 & 0x18) == 0) {
    int v28 = a2;
  }
  int v29 = v27 | (a2 >> 26) & 0x10;
  if ((a2 & 0x80000000) != 0) {
    v29 |= 8u;
  }
  unsigned int v30 = v29 | (a2 >> 22) & 0x20;
  if (a2 >> 30)
  {
    uint64_t v31 = v30;
  }
  else
  {
    a2 = v28;
    uint64_t v31 = v27;
  }
  if ((a2 & 0x40000000) != 0 && (a2 & 0x88000000) != 0) {
    sub_10005FBF0();
  }
  if ((v31 & 0x10) != 0 && (v31 & 0x28) != 0) {
    sub_10005FC1C();
  }
  uint64_t v50 = a8;
  *(_WORD *)long long v19 = 25987;
  *((_WORD *)v19 + 1) = v17;
  uint64_t v32 = *(void *)a1;
  unint64_t v33 = *((void *)v19 + 1) & 0xFFFFF07FFFFFFE00 | v31 | ((unint64_t)((*(_DWORD *)(*(void *)(*(void *)(*(void *)a1 + 392) + 376)
                                                                                           + 36) >> 12) & 0x1F) << 39);
  *((void *)v19 + 1) = v33;
  *((void *)v19 + 3) = *(void *)a6;
  *((_DWORD *)v19 + 1) = -267452416;
  if ((v31 & 0x80) != 0)
  {
    if (authapfs_valid_hash_type(*(_DWORD *)(a6 + 24), v20, v21, v22, v23, v24, v25, v26)) {
      return 22;
    }
    unsigned int v41 = *(_DWORD *)(a6 + 24);
    if (v41 > 0xF) {
      return 22;
    }
    unint64_t v42 = v33 & 0xFF800FFFFFFFFFFFLL | ((unint64_t)(v41 & 0xF) << 44);
    unsigned int v43 = *(_DWORD *)(a6 + 28);
    *((void *)v19 + 1) = v42 | ((unint64_t)(v43 & 0x7F) << 48);
    if (v43 > 0x7F) {
      return 22;
    }
    if (v43 >= 0x40) {
      size_t v44 = 64;
    }
    else {
      size_t v44 = v43;
    }
    memcpy(v19 + 32, (const void *)(a6 + 32), v44);
    uint64_t v32 = *(void *)a1;
  }
  int v34 = *(_DWORD *)(a6 + 16);
  LODWORD(v52) = (v31 << 21) & 0x20000000 | a2 & 0xFFFF0000 | 2;
  DWORD1(v52) = v34;
  if ((a2 & 0x40000000) != 0) {
    int v35 = 3;
  }
  else {
    int v35 = 1;
  }
  int v36 = (v31 << 21) & 0x20000000 | a2 | ((int)(a5 << 31) >> 31) & v35;
  if (obj_type(a1) == 13) {
    uint64_t v37 = a1;
  }
  else {
    uint64_t v37 = 0;
  }
  uint64_t v38 = obj_get(v32, v36 | (8 * (a5 & 4)) | (4 * (((a5 & 2) >> 1) & 1)), a3, (int *)&v52, v19, v37, v51, a7, (uint64_t *)&v53);
  uint64_t v39 = v38;
  if ((a5 & 4) == 0 || v38)
  {
    unsigned __int16 v40 = v53;
    if (v39) {
      unsigned int v45 = 0;
    }
    else {
      unsigned int v45 = v53;
    }
    *uint64_t v50 = v45;
    if (!v39)
    {
      if (!v40)
      {
        if ((~v36 & 0x40000001) != 0) {
          goto LABEL_61;
        }
        unsigned __int16 v40 = 0;
LABEL_53:
        uint64_t v48 = *(void *)(a6 + 8);
        uint64_t v39 = 0;
        if (v48) {
          v40[53] = v48;
        }
        return v39;
      }
LABEL_41:
      if (v40[14] != a3 && (v36 & 0x40000001) != 0x40000001) {
LABEL_61:
      }
        sub_10005FC48();
      goto LABEL_53;
    }
  }
  else
  {
    unsigned __int16 v40 = v53;
    if ((v53[2] & 0x10) == 0)
    {
      *uint64_t v50 = v53;
      goto LABEL_41;
    }
    if (a5) {
      char v46 = 2;
    }
    else {
      char v46 = 1;
    }
    if ((a5 & 2) != 0) {
      char v47 = v46;
    }
    else {
      char v47 = 0;
    }
    btree_node_release(v53, v47);
    *uint64_t v50 = 0;
    return 2;
  }
  return v39;
}

uint64_t btree_get(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4, int a5, unsigned int a6, int a7, uint64_t a8, uint64_t a9, uint64_t **a10)
{
  v11[1] = 0;
  long long v14 = 0u;
  uint64_t v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v15 = 0u;
  v11[0] = a8;
  int v12 = a7;
  int v13 = a5;
  return btree_get_extended(a1, a2, a3, a4, a6, (uint64_t)v11, a9, a10);
}

uint64_t btree_iterate_nodes(uint64_t a1, uint64_t a2, int a3, uint64_t (*a4)(void), uint64_t a5, uint64_t a6)
{
  uint64_t v129 = a6;
  uint64_t v131 = a4;
  uint64_t v127 = a2;
  long long v139 = 0u;
  long long v140 = 0u;
  long long v137 = 0u;
  long long v138 = 0u;
  long long v135 = 0u;
  long long v136 = 0u;
  long long v133 = 0u;
  long long v134 = 0u;
  __chkstk_darwin();
  BOOL v10 = (void *)((char *)v111 - v9);
  bzero((char *)v111 - v9, v11);
  int v126 = a3 & 0x180;
  int v12 = v126 != 0;
  if (a3) {
    int v13 = 2;
  }
  else {
    int v13 = 1;
  }
  obj_lock(a1, v13);
  uint64_t v14 = *(void *)(a1 + 56);
  if (!v14)
  {
    obj_unlock(a1, v13);
    return 22;
  }
  uint64_t v15 = *(unsigned __int16 *)(v14 + 34);
  uint64_t v16 = v15 + 1;
  uint64_t v124 = v15;
  if (v15 < 8)
  {
    long long v139 = 0u;
    long long v140 = 0u;
    long long v137 = 0u;
    long long v138 = 0u;
    long long v135 = 0u;
    long long v136 = 0u;
    long long v17 = &v133;
    long long v133 = 0u;
    long long v134 = 0u;
  }
  else
  {
    long long v17 = (long long *)_apfs_calloc(v15 + 1, 0x10uLL);
    if (!v17)
    {
      obj_unlock(a1, v13);
      return 12;
    }
  }
  *(void *)long long v17 = a1;
  *((_WORD *)v17 + 4) = 0;
  obj_retain(a1);
  uint64_t v18 = 0;
  if (a3)
  {
    uint64_t v18 = obj_modify((void *)a1, 2, v129, v19, v20, v21, v22, v23);
    if (!v18)
    {
      if ((*(unsigned char *)(a1 + 400) & 0x80) != 0) {
        obj_dirty(a1, v129, 0);
      }
      uint64_t v18 = 0;
    }
  }
  uint64_t v122 = v111;
  int v24 = a3 & 0x20;
  uint64_t v121 = v16;
  if (v131 && !(v18 | v24) && ((a3 & 0x10) == 0 || *(_WORD *)(*(void *)(a1 + 56) + 34))) {
    uint64_t v18 = ((uint64_t (*)(uint64_t, uint64_t))v131)(a1, a5);
  }
  if (v18) {
    goto LABEL_21;
  }
  unsigned __int16 v30 = 0;
  unsigned int v115 = a3 & 0xFFFFFE4F;
  unsigned int v31 = a3 & 0xFFFFFE4D | 2;
  if (v126) {
    unsigned int v31 = a3 & 0xFFFFFE4C;
  }
  BOOL v32 = v24 != 0;
  if (!v131) {
    BOOL v32 = 0;
  }
  BOOL v130 = v32;
  int v114 = v12 << 7;
  uint64_t v123 = (v12 << 7) | v31;
  unsigned int v117 = a3 & 0xFFFFFE4C;
  uint64_t v116 = a3 & 0xFFFFFE4C | 0x100;
  if (v131) {
    BOOL v33 = v24 == 0;
  }
  else {
    BOOL v33 = 0;
  }
  BOOL v120 = v33;
  uint64_t v119 = a5;
  while (1)
  {
    unsigned __int16 v34 = v30;
    int v35 = (uint64_t *)&v17[v30];
    int v36 = (uint64_t *)*v35;
    uint64_t v37 = *(void *)(*v35 + 56);
    if ((*(_WORD *)(v37 + 32) & 2) != 0
      || (uint64_t v38 = &v17[v30],
          unsigned int v41 = *((unsigned __int16 *)v38 + 4),
          unsigned __int16 v40 = (_WORD *)v38 + 4,
          unsigned int v39 = v41,
          *(_DWORD *)(v37 + 36) <= v41)
      || (a3 & 0x10) != 0 && *(_WORD *)(v37 + 34) == 1)
    {
      if (v130)
      {
        uint64_t v18 = v131();
        int v36 = (uint64_t *)*v35;
      }
      else
      {
        uint64_t v18 = 0;
      }
      btree_node_release(v36, v13);
      *int v35 = 0;
      unsigned __int16 v30 = v34 - 1;
      goto LABEL_46;
    }
    void *v10 = 0;
    uint64_t v42 = btree_node_child_val((uint64_t)v36, v39, v10);
    if (v42)
    {
      uint64_t v18 = v42;
      obj_oid(*v35);
      uint64_t v89 = "%s:%d: %s level %d node 0x%llx: error getting index %d child oid: %d\n";
      goto LABEL_88;
    }
    ++*v40;
    unsigned __int16 v30 = v34 + 1;
    if (v124 < (__int16)(v34 + 1))
    {
      obj_oid(*(void *)&v17[(__int16)v30 - 1]);
      log_err((uint64_t)"%s:%d: %s level %d node 0x%llx index %d: more levels than expected\n", v90, v91, v92, v93, v94, v95, v96, (uint64_t)"btree_iterate_nodes");
      uint64_t v18 = 22;
      goto LABEL_21;
    }
    unsigned int v43 = &v17[(__int16)v30];
    *((_WORD *)v43 + 4) = 0;
    uint64_t v125 = (__int16)v30 - 1;
    unsigned __int16 v128 = (uint64_t *)&v17[v125];
    uint64_t v18 = btree_node_get((void *)a1, v10, v127, v123, *(_WORD *)(*(void *)(*v128 + 56) + 34) - 1, v129, (uint64_t **)v43);
    if (v18)
    {
      obj_oid(*v128);
      log_err((uint64_t)"%s:%d: %s level %d node 0x%llx: error getting index %d child 0x%llx flags 0x%x: %d\n", v44, v45, v46, v47, v48, v49, v50, (uint64_t)"btree_iterate_nodes");
      if (!v126) {
        goto LABEL_87;
      }
    }
    else if (!v126)
    {
      if (a3) {
        goto LABEL_76;
      }
      goto LABEL_78;
    }
    unint64_t v51 = &v17[v125];
    unsigned int v53 = *((unsigned __int16 *)v51 + 4);
    long long v52 = (unsigned __int16 *)v51 + 4;
    if (*(_DWORD *)(*(void *)(*v128 + 56) + 36) > v53)
    {
      uint64_t v118 = v111;
      __chkstk_darwin();
      int v55 = (void *)((char *)v111 - v54);
      bzero((char *)v111 - v54, v56);
      uint64_t v132 = 0;
      unsigned int v57 = *v52;
      if (*(_DWORD *)(*(void *)(*v128 + 56) + 36) > v57)
      {
        uint64_t v58 = btree_node_child_val(*v128, v57, v55);
        if (v58
          || (uint64_t v58 = btree_node_get((void *)a1, v55, v127, v116, *(_WORD *)(*(void *)(*v128 + 56) + 34) - 1, v129, &v132), v58))
        {
          uint64_t v113 = v58;
          uint64_t v59 = *(void *)(a1 + 8);
          if (v59) {
            uint64_t v112 = v59 + 4000;
          }
          else {
            uint64_t v112 = *(void *)(*(void *)(*(void *)a1 + 392) + 384) + 208;
          }
          uint64_t v60 = *v128;
          v111[1] = *(unsigned __int16 *)(*(void *)(*v128 + 56) + 34);
          obj_oid(v60);
          log_err((uint64_t)"%s:%d: %s level %d node 0x%llx: error prefetching index %d child 0x%llx flags 0x%x: %d\n", v61, v62, v63, v64, v65, v66, v67, (uint64_t)"btree_iterate_nodes");
        }
        if (v132) {
          sub_10005FD24();
        }
      }
    }
    if (!v18) {
      break;
    }
    if (v18 != 45 && v18 != 16) {
      goto LABEL_87;
    }
    uint64_t v69 = btree_node_get((void *)a1, v10, v127, v117, *(_WORD *)(*(void *)(*v128 + 56) + 34) - 1, v129, (uint64_t **)&v17[(__int16)v30]);
    if (v69)
    {
      uint64_t v18 = v69;
      goto LABEL_87;
    }
LABEL_74:
    obj_lock(*(void *)v43, v13);
    if (a3)
    {
      uint64_t v71 = *(uint64_t **)v43;
      unsigned int v72 = obj_type_and_flags(*(void *)v43);
      uint64_t v78 = obj_modify(v71, (v72 >> 29) & 2, v129, v73, v74, v75, v76, v77);
      if (v78)
      {
        uint64_t v18 = v78;
        obj_oid(*v128);
        obj_oid(*(void *)v43);
        log_err((uint64_t)"%s:%d: %s level %d node 0x%llx: error MODIFYING index %d child 0x%llx flags 0x%x: %d\n", v97, v98, v99, v100, v101, v102, v103, (uint64_t)"btree_iterate_nodes");
        btree_node_release(*(uint64_t **)v43, 2);
        goto LABEL_86;
      }
LABEL_76:
      if (obj_oid(*(void *)v43) != *v10) {
        sub_100033980(*v128, (unsigned __int16)(WORD4(v17[v125]) - 1), (unint64_t *)(*(void *)v43 + 112), v129, v79, v80, v81);
      }
    }
LABEL_78:
    if (v120) {
      uint64_t v18 = ((uint64_t (*)(void, uint64_t))v131)(*(void *)v43, v119);
    }
    else {
      uint64_t v18 = 0;
    }
LABEL_46:
    if (v18 || (v30 & 0x8000) != 0) {
      goto LABEL_21;
    }
  }
  uint64_t v70 = obj_async_wait(*(void *)v43);
  if (!v70) {
    goto LABEL_74;
  }
  uint64_t v18 = v70;
  obj_oid(*v128);
  obj_oid(*(void *)v43);
  log_err((uint64_t)"%s:%d: %s level %d node 0x%llx: error ON WAIT getting index %d child 0x%llx flags 0x%x: %d\n", v104, v105, v106, v107, v108, v109, v110, (uint64_t)"btree_iterate_nodes");
  obj_release(*(uint64_t **)v43);
LABEL_86:
  *(void *)unsigned int v43 = 0;
LABEL_87:
  obj_oid(*v128);
  uint64_t v89 = "%s:%d: %s level %d node 0x%llx: error getting index %d child flags 0x%x: %d\n";
LABEL_88:
  log_err((uint64_t)v89, v82, v83, v84, v85, v86, v87, v88, (uint64_t)"btree_iterate_nodes");
LABEL_21:
  int v25 = v121;
  if ((((_WORD)v121 - 1) & 0x8000) == 0)
  {
    unsigned __int16 v26 = v121 - 1;
    do
    {
      unsigned int v27 = *(uint64_t **)&v17[v26];
      if (v27)
      {
        if (!v18) {
          sub_10005FCF8();
        }
        btree_node_release(v27, v13);
      }
      int v28 = (__int16)v26--;
    }
    while (v28 > 0);
  }
  if (v17 != &v133) {
    _apfs_free(v17, (16 * v25));
  }
  return v18;
}

uint64_t btree_level_count(uint64_t a1, _DWORD *a2)
{
  if (!a1) {
    return 22;
  }
  uint64_t v2 = *(void *)(a1 + 56);
  if (!v2) {
    return 22;
  }
  uint64_t result = 0;
  *a2 = *(unsigned __int16 *)(v2 + 34) + 1;
  return result;
}

uint64_t btree_node_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __chkstk_darwin();
  size_t v11 = (uint64_t **)((char *)&v22 - v10);
  bzero((char *)&v22 - v10, v12);
  if (a5 == 2)
  {
    if (obj_type(a1) == 13) {
      uint64_t v14 = a1;
    }
    else {
      uint64_t v14 = 0;
    }
    *(void *)(a4 + 8) = v14;
    unsigned __int16 v15 = obj_subtype(a4);
    uint64_t v16 = tree_key_compare_function_for_type(v15);
    if (!v16) {
      return 22;
    }
    *(void *)(a4 + 416) = v16;
    if (a4 != a3) {
      *(_OWORD *)(a4 + 400) = *(_OWORD *)(a3 + 400);
    }
    uint64_t v13 = obj_checkpoint_known(a4);
    goto LABEL_11;
  }
  if (a5 == 1)
  {
    uint64_t v13 = obj_checkpoint_start(a4);
LABEL_11:
    uint64_t v17 = v13;
    goto LABEL_13;
  }
  uint64_t v17 = 0;
LABEL_13:
  if (!(*(_WORD *)(*(void *)(a4 + 56) + 32) & 2 | v17))
  {
    unsigned int v18 = 0;
    uint64_t v22 = 0;
    while (v18 < *(_DWORD *)(*(void *)(a4 + 56) + 36))
    {
      *size_t v11 = 0;
      uint64_t v19 = btree_node_child_val(a4, (unsigned __int16)v18, v11);
      if (v19) {
        return v19;
      }
      uint64_t v19 = btree_node_get((void *)a3, v11, 0, 2u, *(_WORD *)(*(void *)(a4 + 56) + 34) - 1, 0, &v22);
      if (v19) {
        return v19;
      }
      uint64_t v20 = v22;
      uint64_t v17 = btree_node_checkpoint_traverse(a1, a2, a3, v22, a5);
      obj_unlock((uint64_t)v20, 1u);
      obj_release(v20);
      ++v18;
      if (v17) {
        return v17;
      }
    }
    return 0;
  }
  return v17;
}

uint64_t btree_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((**(_DWORD **)(a3 + 392) & 0x28) != 8) {
    sub_10005FD50();
  }

  return btree_node_checkpoint_traverse(a1, a2, a3, a3, a4);
}

uint64_t btree_node_copy(void *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, unsigned int a6, uint64_t *a7)
{
  unsigned int v43 = a6;
  __chkstk_darwin();
  uint64_t v14 = (uint64_t *)((char *)&v41 - v13);
  bzero((char *)&v41 - v13, v15);
  uint64_t v47 = 0;
  memset(v46, 0, sizeof(v46));
  unsigned int v16 = (a3 >> 26) & 0x10 | a4;
  if ((int)a3 < 0) {
    v16 |= 8u;
  }
  uint64_t v17 = v16 | (a3 >> 22) & 0x20;
  if ((v16 & 0x10) != 0 && v16 & 0x28 | (a3 >> 22) & 0x20) {
    sub_10005FD7C();
  }
  LODWORD(v46[0]) = 2123139;
  *(_OWORD *)((char *)v46 + 8) = *(_OWORD *)(a2 + 400);
  uint64_t v18 = *(void *)(a2 + 416);
  *((void *)&v46[0] + 1) = *((void *)&v46[0] + 1) & 0xFFFFFFFFFFFFFE00 | BYTE8(v46[0]) & 0x47 | v16 & 0x1B8 | (a3 >> 22) & 0x20;
  *((void *)&v46[1] + 1) = v18;
  uint64_t v19 = *(void *)(a2 + 56);
  WORD2(v46[0]) = *(_WORD *)(v19 + 32) & 0x1B;
  WORD3(v46[0]) = *(_WORD *)(v19 + 34);
  uint64_t v20 = *(void *)(a2 + 8);
  if (!v20) {
    uint64_t v20 = *(void *)(*(void *)a2 + 392);
  }
  unsigned __int16 v44 = 0;
  uint64_t v21 = obj_subtype(a2);
  uint64_t v22 = sub_100039D48(v20, a3, v21, v46, a5, a7);
  uint64_t v23 = v22;
  if (v43 && !(*(_WORD *)(*(void *)(a2 + 56) + 32) & 2 | v22))
  {
    uint64_t v42 = a7;
    unsigned int v29 = 0;
    uint64_t v48 = 0;
    uint64_t v45 = 0;
    while (1)
    {
      if (v29 >= *(_DWORD *)(*(void *)(a2 + 56) + 36))
      {
        uint64_t v23 = 0;
        goto LABEL_27;
      }
      *uint64_t v14 = 0;
      uint64_t v30 = btree_node_child_val(a2, (unsigned __int16)v29, v14);
      if (v30
        || (uint64_t v30 = btree_node_get(a1, v14, 0, 2u, *(_WORD *)(*(void *)(a2 + 56) + 34) - 1, 0, &v48), v30))
      {
        uint64_t v23 = v30;
        goto LABEL_27;
      }
      unsigned int v31 = v48;
      uint64_t v32 = btree_node_copy(a1, v48, a3, v17, a5, v43, &v47);
      if (v32) {
        break;
      }
      uint64_t v23 = btree_node_key_ptr(a2, (unsigned __int16)v29, &v45, &v44);
      if (v23
        || (*uint64_t v14 = v47[14],
            uint64_t v23 = sub_1000334DC(*v42, (unsigned __int16)v29, v45, v44, v14, (*(_WORD *)(*v42 + 406) & 0x7Fu) + 8, a5),
            v23))
      {
        log_err((uint64_t)"%s:%d: %s btree_node_insert_internal failed: %d\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"btree_node_copy");
      }
      obj_release(v47);
      obj_unlock((uint64_t)v31, 1u);
      obj_release(v31);
      uint64_t v47 = 0;
      ++v29;
      if (v23) {
        goto LABEL_27;
      }
    }
    uint64_t v23 = v32;
    obj_unlock((uint64_t)v31, 1u);
    obj_release(v31);
    if (v47) {
      obj_release(v47);
    }
LABEL_27:
    a7 = v42;
    obj_dirty(*v42, a5, 0);
    goto LABEL_28;
  }
  if (!v22)
  {
    int v24 = (void *)(*(void *)(*a7 + 56) + 32);
    int v25 = (const void *)(*(void *)(a2 + 56) + 32);
    unsigned int v26 = obj_size_phys(a2);
    memcpy(v24, v25, v26 - 32);
    uint64_t v27 = *a7;
    if (*(_WORD *)(*(void *)(a2 + 56) + 32))
    {
      int v28 = *(int **)(v27 + 392);
      *int v28 = WORD4(v46[0]) & 0x1FF;
      v28[1] = (*((void *)&v46[0] + 1) >> 27) & 0x1F000;
      v28[2] = (DWORD2(v46[0]) >> 9) & 0x3FFF;
      unint64_t v28[3] = (unsigned __int16)(*((void *)&v46[0] + 1) >> 23);
    }
    sub_10003B8EC(v27, (uint64_t)v46, 0);
    uint64_t v23 = 0;
LABEL_28:
    obj_unlock(*a7, 2u);
  }
  return v23;
}

uint64_t btree_copy(void *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t *a5)
{
  *a5 = 0;
  if ((a3 & 0x18) != 0) {
    uint64_t v9 = (a3 << 26) & 0x40000000 | ((a3 >> 3) << 31) | (((a3 >> 5) & 1) << 27) | a2;
  }
  else {
    uint64_t v9 = a2;
  }
  obj_lock((uint64_t)a1, 1u);
  uint64_t v10 = btree_node_copy(a1, (uint64_t)a1, v9, a3, a4, 1u, a5);
  if (v10)
  {
    uint64_t v11 = *a5;
    if (*a5)
    {
      uint64_t v16 = 0;
      btree_delete(v11, a4, &v16);
      obj_release((uint64_t *)*a5);
      *a5 = 0;
    }
  }
  else
  {
    uint64_t v12 = a1[49];
    uint64_t v13 = *(void *)(*a5 + 392);
    long long v14 = *(_OWORD *)(v12 + 16);
    *(void *)(v13 + 32) = *(void *)(v12 + 32);
    *(_OWORD *)(v13 + 16) = v14;
  }
  obj_unlock((uint64_t)a1, 1u);
  return v10;
}

uint64_t btree_delete(uint64_t a1, uint64_t a2, void *a3)
{
  obj_lock(a1, 2u);
  if ((*(unsigned char *)(a1 + 19) & 0x80) != 0 || (*(unsigned char *)(a1 + 400) & 0x80) != 0)
  {
    uint64_t v8 = btree_delete_node((void *)a1, (uint64_t *)a1, a2);
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6) {
      uint64_t v7 = obj_oid(v6);
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v10 = *(void *)(*(void *)a1 + 392);
    int v11 = obj_type_and_flags(a1);
    int v12 = obj_size_phys(a1);
    uint64_t v13 = obj_oid(a1);
    if (a3) {
      uint64_t v14 = nx_reaper_add(v10, v11, v12, v7, v13, a2, 0, a3);
    }
    else {
      uint64_t v14 = nx_reaper_add_sub_object(v10, v11, v12, v7, v13, a2, 0);
    }
    uint64_t v8 = v14;
    if (v14)
    {
      obj_oid(a1);
      obj_type_and_flags(a1);
      log_err((uint64_t)"%s:%d: %s error adding btree 0x%llx type 0x%x to reap list: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"btree_delete");
    }
  }
  obj_unlock(a1, 2u);
  return v8;
}

uint64_t btree_delete_node(void *a1, uint64_t *a2, uint64_t a3)
{
  __chkstk_darwin();
  uint64_t v7 = (uint64_t **)((char *)&v14 - v6);
  bzero((char *)&v14 - v6, v8);
  if ((*(_WORD *)(a2[7] + 32) & 2) == 0)
  {
    unsigned int v9 = 0;
    uint64_t v14 = 0;
    while (v9 < *(_DWORD *)(a2[7] + 36))
    {
      *uint64_t v7 = 0;
      uint64_t v10 = btree_node_child_val((uint64_t)a2, (unsigned __int16)v9, v7);
      if (v10 || (uint64_t v10 = btree_node_get(a1, v7, 0, 0, *(_WORD *)(a2[7] + 34) - 1, 0, &v14), v10))
      {
        uint64_t v12 = v10;
        goto LABEL_10;
      }
      int v11 = v14;
      obj_lock((uint64_t)v14, 2u);
      uint64_t v12 = btree_delete_node(a1, v11, a3);
      obj_unlock((uint64_t)v11, 2u);
      obj_release(v11);
      ++v9;
      if (v12) {
        goto LABEL_10;
      }
    }
  }
  uint64_t v12 = 0;
LABEL_10:
  obj_delete_and_free(a2, a3);
  return v12;
}

uint64_t btree_node_count(uint64_t a1, void *a2)
{
  if (!a1) {
    return 22;
  }
  if (obj_type(a1) != 2) {
    return 22;
  }
  uint64_t result = 0;
  *a2 = *(void *)(*(void *)(a1 + 392) + 32);
  return result;
}

uint64_t sub_10003B8EC(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t result = btree_node_sanity_check((void *)a1, a2);
  if (!result)
  {
    if (a2)
    {
      *(_OWORD *)(a1 + 400) = *(_OWORD *)(a2 + 8);
      *(void *)(a1 + 416) = *(void *)(a2 + 24);
    }
    uint64_t v8 = v6 + 56 + *(unsigned __int16 *)(v6 + 42);
    *(void *)(a1 + 376) = v6 + 56;
    *(void *)(a1 + 384) = v8;
    unsigned int v9 = obj_size_phys(a1);
    __int16 v10 = *(_WORD *)(v6 + 32);
    uint64_t v11 = -40;
    if ((v10 & 1) == 0) {
      uint64_t v11 = 0;
    }
    uint64_t v12 = v6 + v9 + v11;
    *(void *)(a1 + 392) = v12;
    if (v10)
    {
      unint64_t v13 = *(void *)(a1 + 400) & 0xFFFFFFFFFFFFFE00 | *(_DWORD *)v12 & 0x1FF;
      *(void *)(a1 + 400) = v13;
      unint64_t v14 = v13 & 0xFFFFF07FFFFFFFFFLL | ((unint64_t)((*(_DWORD *)(v12 + 4) >> 12) & 0x1F) << 39);
      *(void *)(a1 + 400) = v14;
      unint64_t v15 = v14 & 0xFFFFFFFFFF8001FFLL | ((*(_DWORD *)(v12 + 8) & 0x3FFFLL) << 9);
      *(void *)(a1 + 400) = v15;
      *(void *)(a1 + 400) = v15 & 0xFFFFFF80007FFFFFLL | ((unint64_t)*(unsigned __int16 *)(v12 + 12) << 23);
      *(void *)(a1 + 408) = obj_oid(a1);
    }
    if (a3)
    {
      return authapfs_validate_node(a1, a2);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10003B9E8(uint64_t a1)
{
  int v1 = *(_WORD **)(a1 + 56);
  if ((v1[16] & 4) != 0)
  {
    if ((*(unsigned char *)(a1 + 400) & 4) == 0)
    {
      __int16 v3 = 0;
      return (unsigned __int16)(v1[23] + v3 + v1[25] + v1[27]);
    }
    __int16 v2 = 4;
  }
  else
  {
    __int16 v2 = 8;
  }
  unsigned int v4 = (unsigned __int16)v1[21];
  __int16 v5 = btree_node_toc_required_capacity(a1, 0);
  __int16 v3 = v4 - v5 * v2;
  if (v4 < (unsigned __int16)(v5 * v2)) {
    __int16 v3 = 0;
  }
  return (unsigned __int16)(v1[23] + v3 + v1[25] + v1[27]);
}

uint64_t sub_10003BA68(uint64_t result, int a2, unsigned __int16 a3, __int16 *a4, unsigned __int16 *a5)
{
  if ((*(unsigned char *)(result + 400) & 0x40) != 0) {
    unsigned __int16 v5 = a3;
  }
  else {
    unsigned __int16 v5 = (a3 + 7) & 0xFFF8;
  }
  uint64_t v6 = 48;
  if (a2 != 1) {
    uint64_t v6 = 52;
  }
  uint64_t v7 = 392;
  if (a2 == 1) {
    uint64_t v7 = 384;
  }
  int v8 = *(unsigned __int16 *)(*(void *)(result + 56) + v6);
  unsigned __int16 v9 = -1;
  if (v8 == 0xFFFF)
  {
    __int16 v13 = -1;
    if (a4) {
      goto LABEL_40;
    }
    goto LABEL_41;
  }
  uint64_t v11 = result;
  int v24 = a4;
  int v25 = a5;
  uint64_t v12 = *(void *)(result + v7);
  __int16 v13 = -1;
  do
  {
    unsigned __int16 v9 = v8;
    uint64_t v14 = (unsigned __int16)v8;
    if (a2 == 1)
    {
      unsigned int v15 = *(unsigned __int16 *)(*(void *)(v11 + 56) + 44);
      BOOL v16 = v15 >= v9;
      unsigned int v17 = v15 - v9;
      if (v17 != 0 && v16 && v17 >= 4)
      {
        int v20 = *(unsigned __int16 *)(*(void *)(v11 + 384) + v14 + 2);
        if (v20 >= 4)
        {
          if ((*(unsigned char *)(v11 + 400) & 0x40) == 0) {
            int v20 = (v20 + 7) & 0x1FFF8;
          }
          if (v20 <= (int)v17) {
            goto LABEL_33;
          }
        }
      }
    }
    else
    {
      uint64_t result = obj_size_phys(v11);
      uint64_t v18 = *(void *)(v11 + 56);
      if (*(unsigned char *)(v18 + 32)) {
        __int16 v19 = -96;
      }
      else {
        __int16 v19 = -56;
      }
      if (v9 <= (unsigned __int16)(result
                                                - *(_WORD *)(v18 + 42)
                                                + v19
                                                - (*(_WORD *)(v18 + 46)
                                                 + *(_WORD *)(v18 + 44)))
        && v9 >= 4u)
      {
        unsigned int v21 = *(unsigned __int16 *)(*(void *)(v11 + 392) - v14 + 2);
        if (v21 >= 4)
        {
          if ((*(unsigned char *)(v11 + 400) & 0x40) == 0) {
            unsigned int v21 = (v21 + 7) & 0x1FFF8;
          }
          if (v21 <= v9) {
            goto LABEL_33;
          }
        }
      }
    }
    uint64_t result = nx_corruption_detected_int(*(void *)(*(void *)v11 + 392));
    if (result) {
      break;
    }
LABEL_33:
    if (a2 == 1) {
      uint64_t v22 = v14;
    }
    else {
      uint64_t v22 = -v14;
    }
    uint64_t v23 = (unsigned __int16 *)(v12 + v22);
    if (v23[1] >= v5) {
      goto LABEL_39;
    }
    int v8 = *v23;
    __int16 v13 = v9;
  }
  while (v8 != 0xFFFF);
  unsigned __int16 v9 = -1;
  __int16 v13 = -1;
LABEL_39:
  a4 = v24;
  a5 = v25;
  if (v24) {
LABEL_40:
  }
    *a4 = v13;
LABEL_41:
  if (a5) {
    *a5 = v9;
  }
  return result;
}

uint64_t sub_10003BC88(uint64_t result, int a2, unsigned int a3, int a4)
{
  if (a3 >= 0xFFFE) {
    sub_10005FDA8();
  }
  if (a4 == 65534 || !a4) {
    sub_10005FDD4();
  }
  if ((*(unsigned char *)(result + 400) & 0x40) != 0) {
    unsigned __int16 v4 = a4;
  }
  else {
    unsigned __int16 v4 = (a4 + 7) & 0xFFF8;
  }
  uint64_t v5 = *(void *)(result + 56);
  if (a2 == 1)
  {
    uint64_t v6 = (_WORD *)(v5 + 48);
    if (v4 > 3u)
    {
      uint64_t v7 = (_WORD *)(*(void *)(result + 384) + a3);
LABEL_12:
      v7[1] = v4;
      *uint64_t v7 = *v6;
      *uint64_t v6 = a3;
    }
  }
  else
  {
    uint64_t v6 = (_WORD *)(v5 + 52);
    if (v4 > 3u)
    {
      uint64_t v7 = (_WORD *)(*(void *)(result + 392) - a3);
      goto LABEL_12;
    }
  }
  v6[1] += v4;
  return result;
}

void *sub_10003BD28(void *result, unsigned int a2, int a3, int a4, unsigned int a5, int a6, unsigned int a7, unsigned int a8)
{
  if (a3)
  {
    if (a5 == 0xFFFF)
    {
      if (a6) {
        sub_10005FEB0();
      }
    }
    else
    {
      unsigned int v8 = *(unsigned __int16 *)(result[7] + 44);
      if (v8 <= a5) {
        sub_10005FF08();
      }
      if (a6 + a5 > v8) {
        sub_10005FEDC();
      }
    }
  }
  if (a4)
  {
    if (a7 == 65534)
    {
      if (a8 != 65534) {
        sub_10005FE84();
      }
    }
    else if (a7 == 0xFFFF)
    {
      if (a8) {
        sub_10005FE58();
      }
    }
    else
    {
      if (((result[50] >> 27) & 0x1F000)
         - *(unsigned __int16 *)(result[7] + 46)
         - (*(unsigned __int16 *)(result[7] + 42)
          + *(unsigned __int16 *)(result[7] + 44))
         - 56 < a7)
        sub_10005FE00();
      if (a7 < a8) {
        sub_10005FE2C();
      }
    }
  }
  uint64_t v9 = result[47];
  if ((*(_WORD *)(result[7] + 32) & 4) != 0)
  {
    if (a3) {
      *(_WORD *)(v9 + 4 * a2) = a5;
    }
    if (a4) {
      *(_WORD *)(v9 + 4 * a2 + 2) = a7;
    }
  }
  else
  {
    __int16 v10 = (_WORD *)(v9 + 8 * a2);
    if (a3)
    {
      _WORD *v10 = a5;
      v10[1] = a6;
    }
    if (a4)
    {
      v10[2] = a7;
      v10[3] = a8;
    }
  }
  return result;
}

uint64_t sub_10003BE34(uint64_t a1, __int16 a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  __int16 v7 = *(_WORD *)(v6 + 32);
  if ((v7 & 4) != 0 && (*(unsigned char *)(a1 + 400) & 4) == 0) {
    sub_10005FF34();
  }
  uint64_t v54 = 0;
  if (v7)
  {
    uint64_t v10 = btree_node_copy(0, a1, 2281701376, (16 * v7) & 0x180, a3, 0, (uint64_t *)&v54);
    if (v10) {
      return v10;
    }
    uint64_t v11 = *(void *)(a1 + 56);
    *(_DWORD *)(v11 + 36) = 0;
    *(_WORD *)(v11 + 44) = 0;
    uint64_t v12 = *(void *)(a1 + 392) - *(void *)(a1 + 384);
    *(_WORD *)(v11 + 46) = v12;
    *(void *)(v11 + 48) = 0xFFFF0000FFFFLL;
    bzero(*(void **)(a1 + 376), *(unsigned __int16 *)(v11 + 42) + (unint64_t)(unsigned __int16)v12);
    __int16 v13 = v54;
    uint64_t v14 = v54[7];
    goto LABEL_11;
  }
  long long v48 = btree_node_desc;
  int v49 = 2123139;
  long long v52 = *(_OWORD *)(a1 + 400);
  uint64_t v53 = *(void *)(a1 + 416);
  __int16 v50 = v7;
  __int16 v51 = *(_WORD *)(v6 + 34);
  int v8 = *(_DWORD *)(a1 + 40);
  LODWORD(v48) = *(unsigned __int16 *)(a1 + 36);
  DWORD1(v48) = v8;
  DWORD2(v48) = (*(void *)(a1 + 400) >> 27) & 0x1F000;
  uint64_t v9 = obj_create(*(void *)a1, -2013265920, 0, (int)&v48, (int)&v49, *(void *)(a1 + 8), a3, (uint64_t)&v54);
  if (!v9)
  {
    unsigned int v15 = v54;
    BOOL v16 = (_OWORD *)v54[7];
    unsigned int v17 = *(_OWORD **)(a1 + 56);
    long long v18 = v17[1];
    *BOOL v16 = *v17;
    v16[1] = v18;
    uint64_t v19 = obj_exchange_phys(a1, (uint64_t)v15);
    if (v19)
    {
      uint64_t v10 = v19;
      obj_oid(a1);
      obj_oid((uint64_t)v54);
      log_err((uint64_t)"%s:%d: %s obj_exchange_phys (%llx, %llx) with xid %llu failed: %d\n", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"btree_node_compact");
LABEL_35:
      obj_free((uint64_t)v54);
      obj_release(v54);
      obj_dirty(a1, a3, 0);
      return v10;
    }
    sub_10003B8EC(a1, (uint64_t)&v49, 0);
    sub_10003B8EC((uint64_t)v54, (uint64_t)&v49, 0);
    __int16 v13 = v54;
    uint64_t v14 = v54[7];
    *(_WORD *)(*(void *)(a1 + 56) + 32) |= *(_WORD *)(v14 + 32) & 0x8000;
LABEL_11:
    int v20 = btree_node_toc_required_capacity((uint64_t)v13, a2);
    char v21 = 2;
    if ((*(_WORD *)(v14 + 32) & 4) == 0) {
      char v21 = 3;
    }
    sub_10003C474(a1, (v20 << v21) & 0xFFFC);
    uint64_t v22 = v54;
    uint64_t v23 = v54[7];
    if (*(_DWORD *)(v23 + 36))
    {
      unsigned __int16 v24 = 0;
      while (1)
      {
        __int16 v25 = *(_WORD *)(v23 + 32);
        uint64_t v26 = v22[47];
        uint64_t v27 = v24;
        int v28 = (unsigned __int16 *)(v26 + 4 * v24);
        unsigned int v29 = (unsigned __int16 *)(v26 + 8 * v24);
        if ((v25 & 4) != 0)
        {
          unsigned int v29 = v28;
          int v30 = (*((_DWORD *)v22 + 100) >> 9) & 0x3FFF;
        }
        else
        {
          int v30 = *(unsigned __int16 *)(v26 + 8 * v27 + 2);
        }
        uint64_t v31 = *v29;
        uint64_t v32 = (unsigned __int16 *)(v26 + 4 * v27 + 2);
        uint64_t v33 = v26 + 8 * v27 + 4;
        if ((v25 & 4) == 0) {
          uint64_t v32 = (unsigned __int16 *)v33;
        }
        uint64_t v34 = *v32;
        unsigned int v35 = btree_node_val_len((uint64_t)v22, v27);
        if (v31 == 0xFFFF)
        {
          uint64_t v37 = 0;
        }
        else
        {
          uint64_t v36 = sub_100030894((uint64_t)v22, v31, v30);
          if (v36) {
            break;
          }
          uint64_t v22 = v54;
          uint64_t v37 = (const void *)(v54[48] + v31);
        }
        if (v34 > 0xFFFD)
        {
          uint64_t v38 = 0;
        }
        else
        {
          uint64_t v36 = sub_1000309C0((uint64_t)v22, v34, v35);
          if (v36) {
            break;
          }
          uint64_t v38 = (const void *)(v54[49] - v34);
        }
        uint64_t v36 = sub_1000334DC(a1, v27, v37, v30, v38, v35, a3);
        if (v36) {
          break;
        }
        unsigned __int16 v24 = v27 + 1;
        uint64_t v22 = v54;
        uint64_t v23 = v54[7];
        if (*(_DWORD *)(v23 + 36) <= (unsigned __int16)(v27 + 1)) {
          goto LABEL_30;
        }
      }
      uint64_t v10 = v36;
      if (v7)
      {
        memcpy((void *)(*(void *)(a1 + 56) + 32), (const void *)(v54[7] + 32), v54[49] - v54[7] - 32);
        uint64_t v39 = (uint64_t *)a1;
      }
      else
      {
        obj_exchange_phys(a1, (uint64_t)v54);
        sub_10003B8EC(a1, 0, 0);
        uint64_t v39 = v54;
      }
      sub_10003B8EC((uint64_t)v39, 0, 0);
    }
    else
    {
LABEL_30:
      uint64_t v10 = 0;
    }
    goto LABEL_35;
  }
  return v9;
}

uint64_t sub_10003C238(uint64_t a1, int a2, unsigned __int16 a3, int a4, int a5)
{
  if (a5 == 0xFFFF) {
    return 22;
  }
  if ((*(void *)(a1 + 400) & 0x40) != 0) {
    unsigned __int16 v5 = a3;
  }
  else {
    unsigned __int16 v5 = (a3 + 7) & 0xFFF8;
  }
  uint64_t v6 = *(void *)(a1 + 56);
  uint64_t v7 = 52;
  if (a2 == 1)
  {
    uint64_t v7 = 48;
    int v8 = (_WORD *)(v6 + 48);
  }
  else
  {
    int v8 = (_WORD *)(v6 + 52);
  }
  uint64_t v9 = 392;
  if (a2 == 1)
  {
    uint64_t v9 = 384;
    int v10 = 1;
  }
  else
  {
    int v10 = -1;
  }
  uint64_t v11 = *(void *)(a1 + v9);
  __int16 v12 = v8[1] - v5;
  v8[1] = v12;
  if (a4 != 0xFFFF || *(unsigned __int16 *)(v6 + v7) == a5)
  {
    int v13 = v5;
    int v14 = v10;
    unsigned int v15 = (_WORD *)(v11 + a5 * (uint64_t)v10);
    unsigned __int16 v16 = v15[1] - v13;
    if (v16 < 5u)
    {
      if (a4 == 0xFFFF) {
        *(_WORD *)(v6 + v7) = *v15;
      }
      else {
        *(_WORD *)(v11 + v10 * (uint64_t)a4) = *v15;
      }
    }
    else
    {
      unsigned int v17 = (_WORD *)(v11 + v10 * (uint64_t)a4);
      if (a4 == 0xFFFF) {
        unsigned int v17 = v8;
      }
      int v18 = v10 * v13 + a5;
      *unsigned int v17 = v18;
      uint64_t v19 = (_WORD *)(v11 + v14 * (uint64_t)v18);
      v19[1] = v16;
      *uint64_t v19 = *v15;
      __int16 v12 = v8[1];
    }
  }
  if (!v12 && *(__int16 *)(v6 + v7) != -1) {
    sub_10005FF60();
  }
  return 0;
}

uint64_t sub_10003C368(uint64_t a1, int a2, unsigned __int16 a3, _WORD *a4)
{
  unsigned __int16 v15 = -1;
  unsigned __int16 v14 = -1;
  sub_10003BA68(a1, a2, a3, (__int16 *)&v14, &v15);
  if (v15 == 0xFFFF)
  {
    if ((a2 - 3) <= 0xFDu) {
      sub_10005FF8C();
    }
    if ((*(unsigned char *)(a1 + 400) & 0x40) != 0) {
      unsigned __int16 v10 = a3;
    }
    else {
      unsigned __int16 v10 = (a3 + 7) & 0xFFF8;
    }
    uint64_t v11 = *(void *)(a1 + 56);
    unsigned int v12 = *(unsigned __int16 *)(v11 + 46);
    if (v12 < v10) {
      return 28;
    }
    if (a2 == 1)
    {
      LOWORD(v9) = *(_WORD *)(v11 + 44);
      *(_WORD *)(v11 + 44) = v9 + v10;
      unsigned __int16 v13 = v12 - v10;
    }
    else
    {
      unsigned __int16 v13 = v12 - v10;
      int v9 = *(_DWORD *)(a1 + 392) - *(unsigned __int16 *)(v11 + 44) - (*(_DWORD *)(a1 + 384) + v13);
    }
    *(_WORD *)(v11 + 46) = v13;
  }
  else
  {
    uint64_t result = sub_10003C238(a1, a2, a3, v14, v15);
    if (result) {
      return result;
    }
    LOWORD(v9) = v15;
  }
  uint64_t result = 0;
  *a4 = v9;
  return result;
}

void sub_10003C474(uint64_t a1, unsigned int a2)
{
  uint64_t v3 = *(void *)(a1 + 56);
  __int16 v4 = *(_WORD *)(v3 + 32);
  if ((v4 & 4) != 0 && (*(unsigned char *)(a1 + 400) & 4) == 0) {
    sub_10006003C();
  }
  unsigned int v5 = *(unsigned __int16 *)(v3 + 42);
  unsigned __int16 v6 = v5 - a2;
  if (v5 >= a2)
  {
    if (v5 <= a2) {
      return;
    }
    char v10 = 2;
    if ((v4 & 4) == 0) {
      char v10 = 3;
    }
    if (*(_DWORD *)(v3 + 36) > a2 >> v10) {
      sub_10005FFE4();
    }
    if ((v4 & 4) != 0)
    {
      unint64_t v11 = *(void *)(a1 + 400);
      unint64_t v12 = ((v11 >> 27) & 0x1F000) - 56;
      uint64_t v13 = (v11 >> 9) & 0x3FFF;
      uint64_t v14 = (HIWORD(v11) & 0x7F) + 8;
      uint64_t v15 = (unsigned __int16)(v11 >> 23);
      uint64_t v16 = (v4 & 2) != 0 ? v15 : v14;
      if (((4 * (v12 / (v13 + v16 + 4))) & 0xFFFFFFFFFFFFFFF8) > a2) {
        sub_100060010();
      }
    }
    memmove((void *)(*(void *)(a1 + 384) - v6), *(const void **)(a1 + 384), *(unsigned __int16 *)(v3 + 44));
    *(void *)(a1 + 384) -= v6;
    uint64_t v8 = *(void *)(a1 + 56);
    *(_WORD *)(v8 + 46) += v6;
    __int16 v9 = *(_WORD *)(v8 + 42) - v6;
  }
  else
  {
    unsigned __int16 v7 = a2 - v5;
    if (*(unsigned __int16 *)(v3 + 46) < (unsigned __int16)(a2 - v5)) {
      sub_10005FFB8();
    }
    memmove((void *)(*(void *)(a1 + 384) + v7), *(const void **)(a1 + 384), *(unsigned __int16 *)(v3 + 44));
    bzero(*(void **)(a1 + 384), v7);
    *(void *)(a1 + 384) += v7;
    uint64_t v8 = *(void *)(a1 + 56);
    *(_WORD *)(v8 + 46) -= v7;
    __int16 v9 = *(_WORD *)(v8 + 42) + v7;
  }
  *(_WORD *)(v8 + 42) = v9;
}

void *sub_10003C5C8(uint64_t a1, int a2, int a3)
{
  uint64_t v3 = *(void *)(a1 + 56);
  __int16 v4 = *(_WORD *)(v3 + 32);
  if ((v4 & 4) != 0) {
    char v5 = 2;
  }
  else {
    char v5 = 3;
  }
  unsigned int v6 = (a2 + (unsigned __int16)a3) << v5;
  int v7 = a2 + (__int16)-(__int16)a3;
  if ((v4 & 4) != 0) {
    char v8 = 2;
  }
  else {
    char v8 = 3;
  }
  uint64_t v9 = v7 << v8;
  if (a3 >= 0) {
    int v7 = a2;
  }
  else {
    unsigned int v6 = a2 << v8;
  }
  if (a3 >= 0)
  {
    char v8 = v5;
    uint64_t v9 = (a2 << v5);
  }
  return memmove((void *)(*(void *)(a1 + 376) + v6), (const void *)(*(void *)(a1 + 376) + v9), ((*(_DWORD *)(v3 + 36) - v7) << v8) & 0xFFFC);
}

uint64_t sub_10003C638(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, void *a7, int a8)
{
  if (a8 != 8) {
    return 22;
  }
  uint64_t result = 0;
  *a5 = *a7;
  return result;
}

uint64_t sub_10003C658(void *a1, void *a2, int a3, uint64_t a4)
{
  if (a3 >= 0) {
    LOWORD(v7) = a3;
  }
  else {
    int v7 = -a3;
  }
  int v8 = (__int16)v7;
  if (a3 >= 0) {
    uint64_t v9 = (uint64_t)a1;
  }
  else {
    uint64_t v9 = (uint64_t)a2;
  }
  if (a3 >= 0) {
    uint64_t v10 = (uint64_t)a2;
  }
  else {
    uint64_t v10 = (uint64_t)a1;
  }
  unint64_t v11 = *(_WORD **)(v10 + 56);
  if ((v11[16] & 4) != 0)
  {
    if ((*(unsigned char *)(v10 + 400) & 4) == 0) {
      goto LABEL_19;
    }
    __int16 v12 = 4;
  }
  else
  {
    __int16 v12 = 8;
  }
  unsigned __int16 v13 = btree_node_toc_required_capacity(v10, (__int16)v7) * v12;
  unsigned int v14 = (unsigned __int16)v11[21];
  if (v14 >= v13) {
    goto LABEL_19;
  }
  if (v13 - v14 <= (unsigned __int16)v11[23])
  {
    sub_10003C474(v10, v13);
    goto LABEL_19;
  }
  uint64_t v15 = sub_10003BE34(v10, v8, a4);
  if (!v15)
  {
LABEL_19:
    uint64_t v54 = 0;
    int v55 = 0;
    int v53 = 0;
    if ((void *)v9 == a2)
    {
      if (v8 < 1)
      {
        __int16 v37 = 0;
        int v38 = 0;
LABEL_53:
        uint64_t v15 = 0;
      }
      else
      {
        uint64_t v36 = btree_node_key_ptr((uint64_t)a2, 0, &v55, (_WORD *)&v53 + 1);
        if (v36)
        {
          uint64_t v15 = v36;
          __int16 v37 = 0;
          int v38 = 0;
        }
        else
        {
          int v38 = 0;
          do
          {
            uint64_t v39 = btree_node_val_ptr(a2, (unsigned __int16)v38, &v54, (__int16 *)&v53);
            if (v39) {
              break;
            }
            uint64_t v39 = sub_1000334DC((uint64_t)a1, *(unsigned __int16 *)(a1[7] + 36), v55, HIWORD(v53), v54, (unsigned __int16)v53, a4);
            if (v39) {
              break;
            }
            uint64_t v40 = a2[47];
            uint64_t v41 = (unsigned __int16 *)(v40 + 4 * (unsigned __int16)v38);
            uint64_t v42 = (unsigned __int16 *)(v40 + 8 * (unsigned __int16)v38);
            if ((*(_WORD *)(a2[7] + 32) & 4) != 0) {
              uint64_t v43 = v41;
            }
            else {
              uint64_t v43 = v42;
            }
            unsigned int v44 = *v43;
            if ((a2[50] & 0x40) != 0) {
              unsigned __int16 v45 = HIWORD(v53);
            }
            else {
              unsigned __int16 v45 = (HIWORD(v53) + 7) & 0xFFF8;
            }
            sub_10003BC88((uint64_t)a2, 1, v44, v45);
            if ((_WORD)v53 && (unsigned __int16)v53 != 65534)
            {
              uint64_t v46 = a2[47];
              uint64_t v47 = (unsigned __int16 *)(v46 + 8 * (unsigned __int16)v38 + 4);
              if ((*(_WORD *)(a2[7] + 32) & 4) != 0) {
                uint64_t v47 = (unsigned __int16 *)(v46 + 4 * (unsigned __int16)v38 + 2);
              }
              if ((a2[50] & 0x40) != 0) {
                int v48 = (unsigned __int16)v53;
              }
              else {
                int v48 = ((_WORD)v53 + 7) & 0xFFF8;
              }
              sub_10003BC88((uint64_t)a2, 2, *v47, v48);
            }
            __int16 v37 = ++v38;
            if ((__int16)v38 >= v8) {
              goto LABEL_53;
            }
            uint64_t v39 = btree_node_key_ptr((uint64_t)a2, (unsigned __int16)v38, &v55, (_WORD *)&v53 + 1);
          }
          while (!v39);
          uint64_t v15 = v39;
          __int16 v37 = v38;
        }
      }
      sub_10003C5C8((uint64_t)a2, 0, (__int16)-v37);
      *(_DWORD *)(a2[7] + 36) -= v38;
    }
    else if (v8 < 1)
    {
      uint64_t v15 = 0;
    }
    else
    {
      sub_10003C5C8((uint64_t)a2, 0, v8);
      uint64_t v16 = 0;
      uint64_t v17 = a2[7];
      *(_DWORD *)(v17 + 36) += (unsigned __int16)v8;
      *(_WORD *)(v17 + 32) |= 0x8000u;
      uint64_t v18 = a2[47];
      do
      {
        if ((*(_WORD *)(v17 + 32) & 4) != 0) {
          *(_DWORD *)(v18 + 4 * v16) = -1;
        }
        else {
          *(void *)(v18 + 8 * v16) = 0xFFFF0000FFFFLL;
        }
        ++v16;
      }
      while (v8 > (__int16)v16);
      LOWORD(v19) = 0;
      while (1)
      {
        uint64_t v20 = btree_node_key_ptr((uint64_t)a1, (unsigned __int16)(*(_WORD *)(a1[7] + 36) - 1), &v55, (_WORD *)&v53 + 1);
        if (v20) {
          break;
        }
        uint64_t v20 = btree_node_val_ptr(a1, (unsigned __int16)(*(_WORD *)(a1[7] + 36) - 1), &v54, (__int16 *)&v53);
        if (v20) {
          break;
        }
        uint64_t v20 = sub_100032C58((uint64_t)a2, (unsigned __int16)(v8 + ~(_WORD)v19), v55, HIWORD(v53), v54, (unsigned __int16)v53, a4);
        if (v20) {
          break;
        }
        uint64_t v21 = a1[7];
        int v22 = *(_DWORD *)(v21 + 36) - 1;
        *(_DWORD *)(v21 + 36) = v22;
        uint64_t v23 = a1[47];
        unsigned __int16 v24 = (unsigned __int16 *)(v23 + 4 * (unsigned __int16)v22);
        __int16 v25 = (unsigned __int16 *)(v23 + 8 * (unsigned __int16)v22);
        if ((*(_WORD *)(v21 + 32) & 4) != 0) {
          uint64_t v26 = v24;
        }
        else {
          uint64_t v26 = v25;
        }
        unsigned int v27 = *v26;
        if ((a1[50] & 0x40) != 0) {
          unsigned __int16 v28 = HIWORD(v53);
        }
        else {
          unsigned __int16 v28 = (HIWORD(v53) + 7) & 0xFFF8;
        }
        sub_10003BC88((uint64_t)a1, 1, v27, v28);
        if ((_WORD)v53 && (unsigned __int16)v53 != 65534)
        {
          uint64_t v29 = a1[7];
          uint64_t v30 = *(unsigned __int16 *)(v29 + 36);
          uint64_t v31 = a1[47];
          uint64_t v32 = v31 + 4 * v30 + 2;
          uint64_t v33 = v31 + 8 * v30 + 4;
          if ((*(_WORD *)(v29 + 32) & 4) != 0) {
            uint64_t v34 = (unsigned __int16 *)v32;
          }
          else {
            uint64_t v34 = (unsigned __int16 *)v33;
          }
          if ((a1[50] & 0x40) != 0) {
            int v35 = (unsigned __int16)v53;
          }
          else {
            int v35 = ((_WORD)v53 + 7) & 0xFFF8;
          }
          sub_10003BC88((uint64_t)a1, 2, *v34, v35);
        }
        int v19 = (__int16)(v19 + 1);
        if (v19 >= v8)
        {
          uint64_t v15 = 0;
          *(_WORD *)(a2[7] + 32) &= ~0x8000u;
          goto LABEL_75;
        }
      }
      uint64_t v15 = v20;
      *(_WORD *)(a2[7] + 32) &= ~0x8000u;
      sub_10003C5C8((uint64_t)a2, 0, (__int16)(v19 - v8));
    }
LABEL_75:
    uint64_t v49 = *(void *)(v9 + 56);
    if ((*(_WORD *)(v49 + 32) & 4) != 0)
    {
      if ((*(unsigned char *)(v9 + 400) & 4) == 0)
      {
LABEL_81:
        *(_WORD *)(v9 + 440) = 0;
        obj_dirty((uint64_t)a1, a4, 0);
        obj_dirty((uint64_t)a2, a4, 0);
        return v15;
      }
      __int16 v50 = 4;
    }
    else
    {
      __int16 v50 = 8;
    }
    __int16 v51 = btree_node_toc_required_capacity(v9, 8);
    if (*(unsigned __int16 *)(v49 + 42) > (unsigned __int16)(v51 * v50)) {
      sub_10003C474(v9, (unsigned __int16)(v51 * v50));
    }
    goto LABEL_81;
  }
  return v15;
}

void sub_10003CB10(uint64_t a1, int a2, uint64_t a3)
{
  int v9 = 2123139;
  if (a2) {
    __int16 v5 = 1;
  }
  else {
    __int16 v5 = 3;
  }
  uint64_t v6 = *(void *)(a1 + 56);
  __int16 v10 = *(_WORD *)(v6 + 32) & 0x18 | v5;
  __int16 v11 = a2;
  long long v12 = *(_OWORD *)(a1 + 400);
  uint64_t v13 = *(void *)(a1 + 416);
  bzero((void *)(v6 + 32), ((*(void *)(a1 + 400) >> 27) & 0x1F000) - 72);
  uint64_t v7 = *(void *)(a1 + 56);
  unsigned int v8 = obj_size_phys(a1);
  sub_10002FFAC(v7, v8, (uint64_t)&v9);
  sub_10003B8EC(a1, (uint64_t)&v9, 0);
  obj_dirty(a1, a3, 0);
}

void sub_10003CBD4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a1 + 432) == *(void *)(a3 + 112))
  {
    uint64_t v5 = *(void *)(a2 + 56);
    if ((*(_WORD *)(v5 + 32) & 2) != 0 || !*(_DWORD *)(v5 + 36))
    {
      *(void *)(a1 + 432) = *(void *)(a2 + 112);
    }
    else
    {
      __chkstk_darwin();
      uint64_t v7 = (uint64_t *)((char *)&v17 - v6);
      bzero((char *)&v17 - v6, v8);
      if (btree_node_child_val(a2, (unsigned __int16)(*(_WORD *)(*(void *)(a2 + 56) + 36) - 1), v7))
      {
        log_err((uint64_t)"%s:%d: %s failed to update rightmost leaf field: %d\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"bt_update_last_leaf");
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v16 = *v7;
      }
      *(void *)(a1 + 432) = v16;
    }
  }
}

void sub_10003CD34(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, int a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = a6;
  uint64_t v85 = (unint64_t *)a6;
  __chkstk_darwin();
  uint64_t v17 = (uint64_t *)((char *)&v76 - v16);
  bzero((char *)&v76 - v16, v18);
  uint64_t v83 = 0;
  unsigned __int16 v82 = 0;
  uint64_t v19 = *(void *)(a4 + 56);
  if (!a2)
  {
    if ((*(_WORD *)(v19 + 32) & 2) != 0 || *(_DWORD *)(v19 + 36) != 1) {
      return;
    }
    if (a5 || v10 && (v10[2] & 0x10) != 0)
    {
      if (btree_node_child_val(a4, 0, v17)
        || btree_node_get((void *)a1, v17, a7, 3u, *(_WORD *)(*(void *)(a4 + 56) + 34) - 1, a8, (uint64_t **)&v85))
      {
        return;
      }
      uint64_t v10 = (uint64_t *)v85;
      if ((*(unsigned char *)(a1 + 400) & 0x10) != 0 && v85[14] != *v17) {
        sub_100033980(a4, 0, v85 + 14, a8, v47, v48, v49);
      }
      int v50 = 1;
    }
    else
    {
      int v50 = 0;
    }
    if (sub_10003B9E8((uint64_t)v10) > 0x27)
    {
      uint64_t v52 = v10[7];
      if (*(unsigned __int16 *)(v52 + 46) > 0x27u
        || ((*(_WORD *)(v52 + 32) & 4) == 0 || (v10[50] & 4) != 0)
        && (sub_10003BE34((uint64_t)v10, 0, a8), *(unsigned __int16 *)(v10[7] + 46) > 0x27u))
      {
        sub_1000379AC(a4, 0, a8);
        sub_10003CB10(a4, (unsigned __int16)(*(_WORD *)(*(void *)(a4 + 56) + 34) - 1), a8);
        if (!sub_10003C658((void *)a4, v10, (__int16)-*(_WORD *)(v10[7] + 36), a8))
        {
          sub_10003CBD4(a1, a4, (uint64_t)v10);
          obj_delete_and_free(v10, a8);
          if (v50)
          {
            obj_unlock((uint64_t)v10, 2u);
            obj_release(v10);
          }
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(a1 + 392) + 32), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
          obj_dirty(a1, a8, 0);
          return;
        }
        log_err((uint64_t)"%s:%d: %s failed to move all entries: %d\n", v53, v54, v55, v56, v57, v58, v59, (uint64_t)"bt_merge_nodes");
        sub_10003C658((void *)a4, v10, *(__int16 *)(*(void *)(a4 + 56) + 36), a8);
        sub_10003CB10(a4, (unsigned __int16)(*(_WORD *)(*(void *)(a4 + 56) + 34) + 1), a8);
        if (!btree_node_key_ptr((uint64_t)v10, 0, &v83, &v82))
        {
          *uint64_t v17 = v10[14];
          sub_1000334DC(a4, 0, v83, v82, v17, (*(_WORD *)(a4 + 406) & 0x7F) + 8, a8);
        }
      }
    }
    if (!v50) {
      return;
    }
    obj_unlock((uint64_t)v10, 2u);
    uint64_t v75 = v10;
    goto LABEL_101;
  }
  if (*(_DWORD *)(v19 + 36))
  {
    if (*(_DWORD *)(*(void *)(a2 + 56) + 36) - 1 > a3)
    {
      uint64_t v20 = a3 + 1;
      if (!btree_node_child_val(a2, (unsigned __int16)v20, v17))
      {
        uint64_t v84 = 0;
        if (!btree_node_get((void *)a1, v17, a7, 3u, *(_WORD *)(*(void *)(a2 + 56) + 34) - 1, a8, (uint64_t **)&v84))
        {
          if ((*(unsigned char *)(a1 + 400) & 0x10) != 0 && v84[14] != *v17) {
            sub_100033980(a2, (unsigned __int16)v20, v84 + 14, a8, v21, v22, v23);
          }
          uint64_t v24 = *(void *)(a4 + 56);
          if ((*(_WORD *)(v24 + 32) & 4) != 0)
          {
            unsigned int v60 = *(_DWORD *)(v24 + 36);
            unsigned int v27 = (uint64_t *)v84;
            uint64_t v80 = v84[7];
            int v46 = *(_DWORD *)(v80 + 36);
            unsigned int v61 = v46 + v60;
            if (v46 + v60 <= btree_node_toc_required_capacity(a4, 0))
            {
              uint64_t v81 = 0;
              LOWORD(v33) = v46;
            }
            else
            {
              if (v60 >= (unsigned __int16)(v61 >> 1)) {
                uint64_t v33 = 0;
              }
              else {
                uint64_t v33 = (v61 >> 1) - v60;
              }
              uint64_t v81 = v33;
            }
          }
          else
          {
            uint64_t v77 = v20;
            __int16 v25 = btree_node_toc_required_capacity(a4, 0);
            unsigned int v26 = sub_10003B9E8(a4);
            unsigned int v27 = (uint64_t *)v84;
            int v28 = sub_10003B9E8((uint64_t)v84);
            unsigned int v29 = 0;
            int v30 = 0;
            uint64_t v80 = v27[7];
            uint64_t v81 = 0;
            unsigned int v31 = *(_DWORD *)(v80 + 36);
            unsigned int v32 = 8 * (v25 & 0x1FFF);
            int v78 = v26 - ((v28 + v26) >> 1);
            unsigned int v79 = v31;
            do
            {
              LODWORD(v33) = v29;
              if (v79 <= (unsigned __int16)v29) {
                break;
              }
              if (!(_WORD)v81 && (_WORD)v29)
              {
                int v34 = btree_node_toc_required_capacity(a4, (__int16)v29);
                int v35 = (8 * (_WORD)v34 - (_WORD)v32) & 0xFFF8;
                if (((8 * v34) & 0xFFF8u) <= v32) {
                  int v35 = 0;
                }
                if (v35 + (unsigned __int16)v30 <= v78) {
                  uint64_t v36 = 0;
                }
                else {
                  uint64_t v36 = v29;
                }
                uint64_t v81 = v36;
              }
              uint64_t v37 = v27[50];
              __int16 v38 = *(_WORD *)(v80 + 32);
              if ((v37 & 0x40) != 0)
              {
                if ((v38 & 4) != 0) {
                  unsigned int v40 = (v37 >> 9) & 0x3FFF;
                }
                else {
                  unsigned int v40 = *(unsigned __int16 *)(v27[47] + 8 * (unsigned __int16)v33 + 2);
                }
              }
              else
              {
                if ((v38 & 4) != 0) {
                  unsigned int v39 = (v37 >> 9) & 0x3FFF;
                }
                else {
                  unsigned int v39 = *(unsigned __int16 *)(v27[47] + 8 * (unsigned __int16)v33 + 2);
                }
                unsigned int v40 = (v39 + 7) & 0x1FFF8;
              }
              int v41 = v40 + v30;
              int v42 = btree_node_val_len((uint64_t)v27, (unsigned __int16)v33);
              if (v42 == 65534) {
                int v43 = 0;
              }
              else {
                int v43 = v42;
              }
              if ((v37 & 0x40) == 0) {
                int v43 = (v43 + 7) & 0x1FFF8;
              }
              int v30 = v41 + v43;
              unsigned int v29 = v33 + 1;
              int v44 = btree_node_toc_required_capacity(a4, (__int16)(v33 + 1));
              int v45 = (8 * (_WORD)v44 - (_WORD)v32) & 0xFFF8;
              if (((8 * v44) & 0xFFF8u) <= v32) {
                int v45 = 0;
              }
            }
            while (v45 + (unsigned __int16)v30 <= v26);
            LOWORD(v20) = v77;
            int v46 = v79;
          }
          if (v46 != (unsigned __int16)v33)
          {
            if ((*(_WORD *)(*(void *)(a2 + 56) + 32) & 4) != 0) {
              int v62 = (*(_DWORD *)(a2 + 400) >> 9) & 0x3FFF;
            }
            else {
              int v62 = *(unsigned __int16 *)(*(void *)(a2 + 376) + 8 * (unsigned __int16)v20 + 2);
            }
            if ((*(_WORD *)(v80 + 32) & 4) != 0) {
              int v63 = (*((_DWORD *)v27 + 100) >> 9) & 0x3FFF;
            }
            else {
              int v63 = *(unsigned __int16 *)(v27[47] + 8 * (unsigned __int16)v81 + 2);
            }
            unsigned __int16 v82 = v63;
            uint64_t v64 = *(void *)(a2 + 400);
            if ((v64 & 0x40) != 0) {
              unsigned int v65 = v62;
            }
            else {
              unsigned int v65 = (v62 + 7) & 0x1FFF8;
            }
            unsigned int v66 = (v63 + 7) & 0x1FFF8;
            if ((v64 & 0x40) != 0) {
              unsigned int v66 = v63;
            }
            if (v65 >= v66)
            {
              LOWORD(v33) = v81;
            }
            else
            {
              if ((v64 & 0x40) == 0)
              {
                LOWORD(v63) = (v63 + 7) & 0xFFF8;
                LOWORD(v62) = (v62 + 7) & 0xFFF8;
              }
              BOOL v67 = sub_100033A54(a2, 0, 0, 0, v63 - v62, 0, 0);
              LOWORD(v33) = v81;
              if (!v67) {
                goto LABEL_100;
              }
            }
          }
          if ((_WORD)v33 && !sub_10003C658((void *)a4, v27, (__int16)-(__int16)v33, a8))
          {
            if (*(_DWORD *)(v27[7] + 36))
            {
              if (btree_node_key_ptr((uint64_t)v27, 0, &v83, &v82)
                || sub_100032C58(a2, (unsigned __int16)v20, v83, v82, 0, 0, a8))
              {
                log_err((uint64_t)"%s:%d: %s btree_node_key_update failed: %d\n", v68, v69, v70, v71, v72, v73, v74, (uint64_t)"bt_merge_nodes");
              }
            }
            else
            {
              sub_1000379AC(a2, (unsigned __int16)v20, a8);
              sub_10003CBD4(a1, a2, (uint64_t)v27);
              obj_delete_and_free(v27, a8);
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(a1 + 392) + 32), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
              obj_dirty(a1, a8, 0);
            }
          }
LABEL_100:
          obj_unlock((uint64_t)v27, 2u);
          uint64_t v75 = v27;
LABEL_101:
          obj_release(v75);
        }
      }
    }
  }
  else
  {
    sub_1000379AC(a2, a3, a8);
    uint64_t v51 = *(void *)(a2 + 56);
    if ((*(_WORD *)(v51 + 32) & 1) != 0 && !*(_DWORD *)(v51 + 36)) {
      sub_10003CB10(a2, 0, a8);
    }
    sub_10003CBD4(a1, a2, a4);
    obj_delete_and_free(a4, a8);
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(a1 + 392) + 32), 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    obj_dirty(a1, a8, 0);
  }
}

uint64_t (*tree_key_compare_function_for_type(unsigned __int16 a1))()
{
  int v1 = a1;
  uint64_t result = (uint64_t (*)())spaceman_free_queue_key_cmp;
  switch(v1)
  {
    case 9:
      return result;
    case 10:
      uint64_t v3 = (uint64_t (*)())extent_list_key_cmp;
      goto LABEL_3;
    case 11:
      uint64_t v3 = (uint64_t (*)())omap_key_cmp;
      goto LABEL_3;
    case 12:
    case 13:
    case 17:
    case 18:
    case 20:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 35:
      goto LABEL_6;
    case 14:
    case 15:
    case 16:
    case 36:
      uint64_t v3 = (uint64_t (*)())apfs_key_compare;
      goto LABEL_3;
    case 19:
      uint64_t v3 = (uint64_t (*)())omap_snapshot_key_cmp;
      goto LABEL_3;
    case 21:
      uint64_t v3 = (uint64_t (*)())fusion_mt_key_cmp;
      goto LABEL_3;
    case 31:
      uint64_t v3 = (uint64_t (*)())fext_tree_key_cmp;
      goto LABEL_3;
    case 32:
      uint64_t v3 = (uint64_t (*)())pfkur_tree_key_cmp;
      goto LABEL_3;
    case 33:
      uint64_t v3 = (uint64_t (*)())evict_mapping_key_compare;
      goto LABEL_3;
    case 34:
      uint64_t v3 = (uint64_t (*)())doc_id_tree_key_cmp;
LABEL_3:
      uint64_t result = v3;
      break;
    default:
      if (v1 == 255) {
        uint64_t result = test_key_compare_function;
      }
      else {
LABEL_6:
      }
        uint64_t result = 0;
      break;
  }
  return result;
}

uint64_t default_test_key_compare()
{
  return 22;
}

uint64_t nx_check(void *a1, char a2)
{
  uint64_t v3 = (uint64_t)a1;
  uint64_t v531 = 0;
  uint64_t v532 = 0;
  int v530 = 0;
  uint64_t v528 = 0;
  uint64_t v529 = 0;
  uint64_t v526 = 0;
  uint64_t v527 = 0;
  long long v524 = 0uLL;
  unint64_t v525 = 0;
  unint64_t v522 = 0;
  uint64_t v523 = 0;
  uint64_t v520 = 0;
  uint64_t v521 = 0;
  uint64_t v4 = a1[47];
  uint64_t v5 = spaceman_get(a1, &v532);
  if (v5)
  {
    uint64_t v13 = v5;
    log_err((uint64_t)"%s:%d: %s unable to get spaceman: %d\n", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"nx_check");
    return v13;
  }
  uint64_t v14 = (uint32x2_t *)v532[47];
  unint64_t v22 = obj_xid((uint64_t)v532);
  __int32 v23 = v14[4].i32[0];
  uint64_t v511 = v4;
  if (v23 != *(_DWORD *)(v4 + 36))
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman block size %d doesn't match nx superblock block size %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    __int32 v23 = v14[4].i32[0];
  }
  char v497 = a2;
  LODWORD(v24) = v23;
  if (v14[4].i32[1] != 8 * v23)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman blocks per chunk is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    LODWORD(v24) = v14[4].i32[0];
  }
  unint64_t v25 = v24 + 0x1FFFFFFFD8;
  unint64_t v26 = v25 >> 5;
  if (v14[5].i32[0] == (v25 >> 5))
  {
    uint64_t v24 = v24;
  }
  else
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman chunks per cib is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    uint64_t v24 = v14[4].u32[0];
  }
  unint64_t v515 = v24 + 0x7FFFFFFD8;
  unint64_t v505 = (unint64_t)(v24 + 0x7FFFFFFD8) >> 3;
  if (v14[5].i32[1] != v505)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman cibs per cab is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  unint64_t v27 = (8 * v23);
  uint32x2_t v28 = v14[6];
  if (*(void *)&v14[12] + *(void *)&v28 != *(void *)(v511 + 40))
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman block count %lld doesn't match nx superblock block count %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    uint32x2_t v28 = v14[6];
  }
  uint32x2_t v29 = v14[7];
  if (*(void *)&v28 % v27) {
    uint64_t v30 = *(void *)&v28 / v27 + 1;
  }
  else {
    uint64_t v30 = *(void *)&v28 / v27;
  }
  if (*(void *)&v29 != v30)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman chunk count is bad: %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    uint32x2_t v29 = v14[7];
  }
  uint64_t v31 = v14[8].u32[0];
  unint64_t v32 = (v25 >> 5);
  unint64_t v504 = v32;
  if (*(void *)&v29 % v32) {
    uint64_t v33 = *(void *)&v29 / v32 + 1;
  }
  else {
    uint64_t v33 = *(void *)&v29 / v32;
  }
  if (v33 != v31)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman cib count is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    LODWORD(v31) = v14[8].i32[0];
  }
  unsigned int v34 = v31 / v505;
  if (v31 % v505) {
    ++v34;
  }
  if (v34 == 1) {
    unsigned int v35 = 0;
  }
  else {
    unsigned int v35 = v34;
  }
  if (v14[8].i32[1] != v35)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman cab count is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (*(void *)&v14[9] > *(void *)&v14[6])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman free count is too large: %lld > %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  uint32x2_t v37 = v14[12];
  uint32x2_t v36 = v14[13];
  if (*(void *)&v37 % v27) {
    uint64_t v38 = *(void *)&v37 / v27 + 1;
  }
  else {
    uint64_t v38 = *(void *)&v37 / v27;
  }
  if (*(void *)&v36 != v38)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman tier2 chunk count is bad: %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    uint32x2_t v36 = v14[13];
  }
  uint64_t v39 = v14[14].u32[0];
  if (*(void *)&v36 % v504) {
    uint64_t v40 = *(void *)&v36 / v504 + 1;
  }
  else {
    uint64_t v40 = *(void *)&v36 / v504;
  }
  if (v40 != v39)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman tier2 cib count is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    LODWORD(v39) = v14[14].i32[0];
  }
  unsigned int v41 = v39 / v505;
  if (v39 % v505) {
    ++v41;
  }
  if (v41 == 1) {
    unsigned int v42 = 0;
  }
  else {
    unsigned int v42 = v41;
  }
  if (v14[14].i32[1] != v42)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman tier2 cab count is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (*(void *)&v14[15] > *(void *)&v14[12])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman tier2 free count is too large: %lld > %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  uint64_t v43 = vaddvq_s64((int64x2_t)vaddl_u32(v14[8], v14[14])) + *(void *)&v14[7] + *(void *)&v14[13];
  uint64_t v44 = *(void *)&v14[19] & 0x7FFFFFFFFFFFFFFFLL;
  if (v44 != 3 * v43)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP block count is bad: %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    uint64_t v44 = *(void *)&v14[19] & 0x7FFFFFFFFFFFFFFFLL;
  }
  if ((v14[4].u32[0] + 8 * ((unint64_t)(v44 + 63) >> 6) - 1) / v14[4].u32[0] != v14[20].i32[0])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bm block count is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if ((v14[20].i32[1] & 0x7FFFFFFFu) >= 0xFFFF)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap block count is too large: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (v14[18].i32[1] <= 3u)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap tx multiplier is too small: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  unsigned __int32 v45 = v14[20].u32[0];
  unsigned int v46 = v14[20].i32[1] & 0x7FFFFFFF;
  if (v46 / v45 <= 3)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap block count per tx is too small: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    unsigned __int32 v45 = v14[20].u32[0];
    unsigned int v46 = v14[20].i32[1] & 0x7FFFFFFF;
  }
  unsigned __int32 v47 = v14[18].u32[1];
  if (v46 != v47 * v45)
  {
    unsigned int v48 = 65534;
    if (v46 != 65534)
    {
      ++v530;
      log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap block count is bad: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
      unsigned __int32 v45 = v14[20].u32[0];
      unsigned __int32 v47 = v14[18].u32[1];
      unsigned int v48 = v14[20].i32[1] & 0x7FFFFFFF;
    }
    if (v48 / v45 < v47 >> 1)
    {
      ++v530;
      log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap block count is too low: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    }
  }
  uint32x2_t v49 = v14[6];
  uint32x2_t v50 = v14[21];
  if (!*(void *)&v50 || *(void *)&v50 >= *(void *)&v49)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bm base address is bad: %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  uint32x2_t v51 = v14[22];
  if (!*(void *)&v51 || *(void *)&v51 >= *(void *)&v49)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP base address is bad: %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  uint64_t v517 = v43;
  unint64_t v508 = v22;
  unint64_t v502 = v14;
  if (v14[20].i32[0])
  {
    unint64_t v52 = 0;
    unint64_t v499 = 0;
    do
    {
      uint64_t v53 = v532;
      if (*(void *)(v532[108] + 8 * v52) > v22)
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap block %d xid %lld > spaceman xid %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
        uint64_t v53 = v532;
      }
      uint64_t v54 = *(unsigned __int16 *)(v53[109] + 2 * v52);
      if ((v14[20].i32[1] & 0x7FFFFFFFu) <= v54)
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap block %d index %d out of range\n", v15, v54, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
        LODWORD(v54) = *(unsigned __int16 *)(v532[109] + 2 * v52);
      }
      if (spaceman_ip_bm_block_address(v3, (uint64_t)v14, v54, &v522)
        || obj_get(*(void *)(v3 + 392), 0x40000000, v522, (int *)&sm_bm_desc, 0, 0, 0, 0, (uint64_t *)&v527))
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap unable to get bitmap block %d @ %lld: %d\n", v55, v56, v57, v58, v59, v60, v61, (uint64_t)"nx_check");
      }
      else
      {
        if (v52 == v14[20].i32[0] - 1) {
          unint64_t v62 = (*(void *)&v14[19] & 0x7FFFFFFFFFFFFFFFuLL) % (8 * v14[4].i32[0]);
        }
        else {
          unint64_t v62 = (8 * v14[4].i32[0]);
        }
        v499 += bitmap_count_bits(v527[7], 0, 0, v62);
        obj_release(v527);
      }
      ++v52;
    }
    while (v52 < v14[20].u32[0]);
  }
  else
  {
    unint64_t v499 = 0;
  }
  uint64_t v63 = v43;
  if (v499 > *(void *)&v14[7] + 2 * v43 + *(void *)&v14[13] - 1)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap has too many free blocks %lld > %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  __int32 v64 = v14[20].i32[1];
  LODWORD(v65) = v64 & 0x7FFFFFFF;
  if ((v64 & 0x7FFFFFFFu) <= v14[40].u16[0])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap free head %d out of range\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    __int32 v64 = v14[20].i32[1];
    LODWORD(v65) = v64 & 0x7FFFFFFF;
  }
  if (v65 > v14[40].u16[1]
    || (++v530,
        log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap free head %d out of range\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check"), __int32 v64 = v14[20].i32[1], LODWORD(v65) = v64 & 0x7FFFFFFF, (v64 & 0x7FFFFFFF) != 0))
  {
    unint64_t v66 = 0;
    uint64_t v67 = 0;
    uint64_t v68 = v532[110];
    do
    {
      unsigned int v69 = *(unsigned __int16 *)(v68 + 2 * v66);
      BOOL v70 = v69 == 0xFFFF || v65 > v69;
      if (!v70)
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap free next %d, value %d invalid\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
        __int32 v64 = v14[20].i32[1];
        uint64_t v68 = v532[110];
        unsigned int v69 = *(unsigned __int16 *)(v68 + 2 * v66);
      }
      unint64_t v65 = v64 & 0x7FFFFFFF;
      if (v65 > v69) {
        ++v67;
      }
      ++v66;
    }
    while (v66 < v65);
  }
  else
  {
    uint64_t v67 = 0;
  }
  uint64_t v71 = v14;
  unsigned int v72 = v14[40].u16[0];
  if (v72 == 0xFFFF) {
    uint64_t v73 = v67;
  }
  else {
    uint64_t v73 = v67 + 1;
  }
  if (v73 != v65 - v14[20].i32[0])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap next array free count is wrong, %lld != %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    __int32 v64 = v14[20].i32[1];
    unsigned int v72 = v14[40].u16[0];
  }
  unsigned int v74 = v64 & 0x7FFFFFFF;
  if (v74 && v74 > v72)
  {
    uint64_t v75 = 0;
    do
    {
      ++v75;
      unsigned int v72 = *(unsigned __int16 *)(v532[110] + 2 * v72);
    }
    while (v75 < v74 && v74 > v72);
    v73 -= v75;
  }
  if (v73 < 0)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap free list corrupted, too long, count %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  else if (v73)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP bitmap free list corrupted, too short, count %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (*(void *)&v14[25] > (*(void *)&v14[19] & 0x7FFFFFFFFFFFFFFFuLL))
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP free queue count is too large: %lld > %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (v14[26])
  {
    if (spaceman_fq_tree_get((pthread_mutex_t **)v3, (uint64_t)v532, 0, 0, 0, (uint64_t *)&v526))
    {
      ++v530;
      log_warn((uint64_t)"%s:%d: %s unable to get spaceman IP free queue tree: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    }
    else if (v526)
    {
      int v215 = btree_check(v526, 0, 0, 0);
      if (v215)
      {
        int v223 = v215;
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman IP free queue tree sanity check failed: %d\n", v216, v217, v218, v219, v220, v221, v222, (uint64_t)"nx_check");
        uint64_t v521 = 0x1000000008;
      }
      else
      {
        uint64_t v521 = 0x1000000008;
        int v223 = bt_lookup_first(v526, 0, &v524, (_DWORD *)&v521 + 1, &v525, (unsigned int *)&v521);
      }
      unint64_t v310 = 0;
      uint64_t v77 = 0;
      for (uint64_t i = 0;
            !v223;
            int v223 = bt_lookup_variant(v526, 0, (unint64_t *)&v524, (unsigned int *)&v521 + 1, HIDWORD(v521), &v525, (unsigned int *)&v521, 4u, 0, 0))
      {
        if (v521)
        {
          uint64_t v312 = v525;
        }
        else
        {
          unint64_t v525 = 1;
          uint64_t v312 = 1;
        }
        unint64_t v313 = v524;
        if ((unint64_t)v524 > v508)
        {
          ++v530;
          log_warn((uint64_t)"%s:%d: %s spaceman IP free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n", v224, v225, v226, v227, v228, v229, v230, (uint64_t)"nx_check");
          unint64_t v313 = v524;
        }
        if (v313 >= v310)
        {
          unint64_t v314 = *((void *)&v524 + 1);
          if (v313 == v310)
          {
            if (*((uint64_t *)&v524 + 1) < i)
            {
              ++v530;
              log_warn((uint64_t)"%s:%d: %s spaceman IP free queue tree entries out of order: addr %lld < %lld\n", v224, *((uint64_t *)&v524 + 1), v226, v227, v228, v229, v230, (uint64_t)"nx_check");
              unint64_t v314 = *((void *)&v524 + 1);
            }
            uint64_t i = v525 + v314;
          }
          else
          {
            uint64_t i = 0;
            unint64_t v310 = v313;
          }
        }
        else
        {
          ++v530;
          log_warn((uint64_t)"%s:%d: %s spaceman IP free queue tree entries out of order: xid %lld < %lld\n", v224, v225, v226, v227, v228, v229, v230, (uint64_t)"nx_check");
          uint64_t i = 0;
          unint64_t v314 = *((void *)&v524 + 1);
          unint64_t v310 = v524;
        }
        int v315 = spaceman_ip_block_index(v3, (uint64_t)v532, v314, &v520);
        if (v315)
        {
          ++v530;
          if (v315 == 2) {
            log_warn((uint64_t)"%s:%d: %s spaceman IP free queue tree entry %lld:%lld %lld addr is bad\n", v316, v317, v318, v319, v320, v321, v322, (uint64_t)"nx_check");
          }
          else {
            log_warn((uint64_t)"%s:%d: %s error getting IP block index for spaceman IP free queue tree entry %lld:%lld %lld\n", v316, v317, v318, v319, v320, v321, v322, (uint64_t)"nx_check");
          }
        }
        if (v525 >= 2)
        {
          int v323 = spaceman_ip_block_index(v3, (uint64_t)v532, v525 + *((void *)&v524 + 1) - 1, &v520);
          if (v323)
          {
            ++v530;
            if (v323 == 2) {
              log_warn((uint64_t)"%s:%d: %s spaceman IP free queue tree entry %lld:%lld %lld end addr is bad\n", v324, v325, v326, v327, v328, v329, v330, (uint64_t)"nx_check");
            }
            else {
              log_warn((uint64_t)"%s:%d: %s error getting end block index for spaceman IP free queue tree entry %lld:%lld %lld\n", v324, v325, v326, v327, v328, v329, v330, (uint64_t)"nx_check");
            }
          }
        }
        v77 += v312;
        LODWORD(v521) = 8;
      }
      if (v223 != 2)
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman IP free queue tree iteration aborted with error %d\n", v224, v225, v226, v227, v228, v229, v230, (uint64_t)"nx_check");
      }
      obj_release(v526);
      uint64_t v71 = v502;
      uint64_t v63 = v517;
      goto LABEL_127;
    }
  }
  uint64_t v77 = 0;
LABEL_127:
  if (v77 != *(void *)&v71[25])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP free queue count %lld doesn't match count in the free queue: %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  uint64_t v78 = 0;
  uint64_t v79 = 0;
  uint64_t v513 = 0;
  uint64_t v514 = v3;
  uint64_t v498 = 2 * v63;
  unint64_t v80 = (v515 >> 3);
  char v81 = 1;
  uint64_t v500 = v77;
  unint64_t v82 = v508;
  unint64_t v506 = v80;
  do
  {
    uint64_t v83 = &v71[6 * v78];
    __int32 v85 = v83[8].i32[0];
    uint64_t v84 = v83 + 8;
    char v501 = v81;
    if (v85)
    {
      unint64_t v86 = 0;
      uint64_t v516 = 0;
      uint32x2_t v518 = 0;
      uint64_t v510 = v78;
      uint64_t v87 = &v71[6 * v78];
      uint64_t v509 = (_DWORD *)&v87[8] + 1;
      uint64_t v503 = v87 + 7;
      uint64_t v88 = 0xFFFFFFFFLL;
      while (1)
      {
        if (!*v509)
        {
          uint64_t v512 = v88;
          uint64_t v99 = v532;
          uint64_t v100 = (unint64_t *)(v532[v78 + 111] + 8 * v86);
          goto LABEL_155;
        }
        if (v86 / v80 == v88 && v79 != 0) {
          goto LABEL_154;
        }
        unint64_t v90 = v86 / v80;
        unint64_t v91 = *(void *)(v532[v78 + 111] + 8 * v90);
        if (v529)
        {
          obj_release(v529);
          uint64_t v529 = 0;
        }
        if (obj_get(*(void *)(v3 + 392), 0x40000000, v91, (int *)&sm_cab_desc, 0, 0, 0, 0, (uint64_t *)&v529))
        {
          ++v530;
          log_warn((uint64_t)"%s:%d: %s unable to read cab %d @ %lld: %d\n", v92, v93, v94, v95, v96, v97, v98, (uint64_t)"nx_check");
          uint64_t v88 = v90;
          unint64_t v82 = v508;
          unint64_t v80 = v506;
        }
        else
        {
          uint64_t v101 = v529[7];
          unint64_t v102 = *(unsigned int *)(v101 + 36);
          if (v102 <= ((unint64_t)obj_size_phys((uint64_t)v529) - 40) >> 3)
          {
            if (obj_xid((uint64_t)v529) > v508)
            {
              ++v530;
              obj_xid((uint64_t)v529);
              log_warn((uint64_t)"%s:%d: %s cab %d xid %lld > spaceman xid %lld\n", v117, v118, v119, v120, v121, v122, v123, (uint64_t)"nx_check");
            }
            uint64_t v88 = v90;
            if (*(_DWORD *)(v101 + 32) != v90)
            {
              ++v530;
              log_warn((uint64_t)"%s:%d: %s cab %d index %d should be %d\n", v110, v111, v112, v113, v114, v115, v116, (uint64_t)"nx_check");
              uint64_t v88 = v90;
            }
            int v124 = *(_DWORD *)(v101 + 36);
            uint64_t v78 = v510;
            if (v124 != v505 && (*v509 - 1 != v88 || v124 != v84->i32[0] % v505))
            {
              ++v530;
              log_warn((uint64_t)"%s:%d: %s cab %d cib count %d should be %d\n", v110, v111, v112, v113, v114, v115, v116, (uint64_t)"nx_check");
              uint64_t v88 = v90;
            }
            uint64_t v79 = v101;
            unint64_t v82 = v508;
            unint64_t v80 = v506;
LABEL_154:
            uint64_t v512 = v88;
            uint64_t v100 = (unint64_t *)(v79 + 8 * (v86 - (v88 * v505)) + 40);
            uint64_t v99 = v532;
LABEL_155:
            unint64_t v125 = *v100;
            int v126 = spaceman_ip_block_index(v3, (uint64_t)v99, *v100, &v520);
            if (v126)
            {
              ++v530;
              if (v126 == 2) {
                log_warn((uint64_t)"%s:%d: %s spaceman chunk info block %lld addr %lld not within IP block range\n", v127, v128, v129, v130, v131, v132, v133, (uint64_t)"nx_check");
              }
              else {
                log_warn((uint64_t)"%s:%d: %s error getting IP block index for spaceman chunk info block %lld addr %lld\n", v127, v128, v129, v130, v131, v132, v133, (uint64_t)"nx_check");
              }
            }
            if (obj_get(*(void *)(v3 + 392), 0x40000000, v125, (int *)&sm_cib_desc, 0, 0, 0, 0, (uint64_t *)&v528))
            {
              ++v530;
              log_warn((uint64_t)"%s:%d: %s unable to read cib %lld @ %lld: %d\n", v134, v135, v136, v137, v138, v139, v140, (uint64_t)"nx_check");
LABEL_212:
              uint64_t v88 = v512;
              goto LABEL_213;
            }
            if (obj_xid((uint64_t)v528) > v82)
            {
              ++v530;
              obj_xid((uint64_t)v528);
              log_warn((uint64_t)"%s:%d: %s cib %lld xid %lld > spaceman xid %lld\n", v148, v149, v150, v151, v152, v153, v154, (uint64_t)"nx_check");
            }
            uint64_t v155 = v528[7];
            if (v86 != *(_DWORD *)(v155 + 32))
            {
              ++v530;
              log_warn((uint64_t)"%s:%d: %s cib %lld index %d should be %lld\n", v141, v142, v143, v144, v145, v146, v147, (uint64_t)"nx_check");
            }
            uint64_t v156 = *(unsigned int *)(v155 + 36);
            unsigned int v157 = v26;
            if (v156 != v26)
            {
              if (v86 != v84->i32[0] - 1 || (unsigned int v157 = *(_DWORD *)(v155 + 36), *(void *)v503 % v504 != v156))
              {
                ++v530;
                log_warn((uint64_t)"%s:%d: %s cib %lld chunk info count %d should be %lld\n", v141, v142, v143, v144, v145, v146, v147, (uint64_t)"nx_check");
                unsigned int v157 = *(_DWORD *)(v155 + 36);
              }
              if (v157 > v26)
              {
                ++v530;
                log_warn((uint64_t)"%s:%d: %s cib %lld cib_chunk_info_count %d invalid\n", v141, v142, v143, v144, v145, v146, v147, (uint64_t)"nx_check");
                unsigned int v157 = *(_DWORD *)(v155 + 36);
              }
            }
            uint64_t v507 = v79;
            if (v157 >= v26) {
              unsigned int v158 = v26;
            }
            else {
              unsigned int v158 = v157;
            }
            if (!v158)
            {
LABEL_211:
              obj_release(v528);
              uint64_t v79 = v507;
              unint64_t v82 = v508;
              unint64_t v80 = v506;
              uint64_t v78 = v510;
              goto LABEL_212;
            }
            unint64_t v159 = 0;
            unint64_t v160 = v27 * (unint64_t)v504 * v86;
            uint64_t v161 = (unint64_t *)(v155 + 64);
            while (2)
            {
              unint64_t v162 = *(v161 - 3);
              if (v162 > obj_xid((uint64_t)v528))
              {
                ++v530;
                obj_xid((uint64_t)v528);
                uint64_t v3 = v514;
                log_warn((uint64_t)"%s:%d: %s cib %lld chunk info %d xid %lld > cib xid %lld\n", v170, v171, v172, v173, v174, v175, v176, (uint64_t)"nx_check");
              }
              if (v160 != *(v161 - 2))
              {
                ++v530;
                log_warn((uint64_t)"%s:%d: %s cib %lld chunk info %d addr %lld should be %lld\n", v163, v164, v165, v166, v167, v168, v169, (uint64_t)"nx_check");
              }
              uint64_t v177 = *(_DWORD *)(v161 - 1) & 0xFFFFF;
              if (v177 != v27
                && (v86 != v84->i32[0] - 1 || v159 != *(_DWORD *)(v155 + 36) - 1 || *(void *)&v84[-2] % v27 != v177))
              {
                ++v530;
                log_warn((uint64_t)"%s:%d: %s cib %lld chunk info %d block count %d should be %d\n", v163, v164, v165, v166, v167, v168, v169, (uint64_t)"nx_check");
                goto LABEL_205;
              }
              if ((*((_DWORD *)v161 - 1) & 0xFFFFFu) > v177)
              {
                ++v530;
                log_warn((uint64_t)"%s:%d: %s cib %lld chunk info %d free count %d > chunk block count %d\n", v163, v164, v165, v166, v167, v168, v169, (uint64_t)"nx_check");
              }
              unint64_t v178 = *v161;
              if (*v161)
              {
                int v179 = spaceman_ip_block_index(v3, (uint64_t)v532, v178, &v520);
                if (v179)
                {
                  ++v530;
                  if (v179 == 2) {
                    log_warn((uint64_t)"%s:%d: %s cib %lld ci %d bm addr %lld not within IP block range\n", v180, v181, v182, v183, v184, v185, v186, (uint64_t)"nx_check");
                  }
                  else {
                    log_warn((uint64_t)"%s:%d: %s error getting IP block index for cib %lld ci %d bm addr %lld\n", v180, v181, v182, v183, v184, v185, v186, (uint64_t)"nx_check");
                  }
                  goto LABEL_205;
                }
                if (obj_get(*(void *)(v3 + 392), 0x40000000, *v161, (int *)&sm_bm_desc, 0, 0, 0, 0, (uint64_t *)&v527))
                {
                  ++v530;
                  log_warn((uint64_t)"%s:%d: %s cib %lld chunk %d unable to get bitmap block @ %lld: %d\n", v193, v194, v195, v196, v197, v198, v199, (uint64_t)"nx_check");
                  goto LABEL_205;
                }
                unint64_t v187 = bitmap_count_bits(v527[7], 0, 0, *(_DWORD *)(v161 - 1) & 0xFFFFF);
              }
              else
              {
                ++v513;
                unint64_t v187 = *(_DWORD *)(v161 - 1) & 0xFFFFFLL;
              }
              uint64_t v188 = *((_DWORD *)v161 - 1) & 0xFFFFF;
              if (v187 != v188)
              {
                ++v530;
                log_warn((uint64_t)"%s:%d: %s cib %lld ci %d free count %d doesn't match free bits in bitmap block %lld\n", v163, v178, v165, v166, v167, v168, v169, (uint64_t)"nx_check");
                uint64_t v188 = *((_DWORD *)v161 - 1) & 0xFFFFF;
              }
              v516 += v187;
              *(void *)&v518 += v188;
              uint64_t v189 = *(void *)(v511 + 1248);
              if (v189)
              {
                uint64_t v190 = *(void *)(v511 + 1240);
                char v191 = __clz(__rbit64(*(unsigned int *)(*(void *)(v3 + 376) + 36)));
                if (v510 == ((v190 << v191) & 0x4000000000000000uLL) >> 62)
                {
                  v533[0] = 0;
                  unint64_t v192 = calc_overlap_range(*(v161 - 2), *(_DWORD *)(v161 - 1) & 0xFFFFF, ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> v191) & v190, v189, (unint64_t *)v533);
                  if (v192)
                  {
                    if (*v161) {
                      unint64_t v192 = bitmap_count_bits(v527[7], 0, (uint64_t)v533[0] - *(v161 - 2), (uint64_t)v533[0] + v192 - *(v161 - 2));
                    }
                    v516 -= v192;
                    *(void *)&v518 -= v192;
                  }
                }
              }
              if (*v161) {
                obj_release(v527);
              }
LABEL_205:
              ++v159;
              LODWORD(v200) = *(_DWORD *)(v155 + 36);
              if (v200 >= v26) {
                unint64_t v200 = v26;
              }
              else {
                unint64_t v200 = v200;
              }
              v160 += v27;
              v161 += 4;
              if (v159 >= v200) {
                goto LABEL_211;
              }
              continue;
            }
          }
          ++v530;
          log_warn((uint64_t)"%s:%d: %s cab %d @ %lld cab_cib_count %d invalid\n", v103, v104, v105, v106, v107, v108, v109, (uint64_t)"nx_check");
          uint64_t v88 = v90;
          unint64_t v80 = v506;
          unint64_t v86 = v86 + v506 - 1 + ~((v86 + v506 - 1) % v506);
          uint64_t v78 = v510;
          uint64_t v79 = v101;
          unint64_t v82 = v508;
        }
LABEL_213:
        if (++v86 >= v84->u32[0]) {
          goto LABEL_216;
        }
      }
    }
    uint64_t v516 = 0;
    uint32x2_t v518 = 0;
LABEL_216:
    if (v529)
    {
      obj_release(v529);
      uint64_t v529 = 0;
    }
    uint64_t v71 = v502;
    uint64_t v201 = &v502[6 * v78];
    uint32x2_t v203 = v201[9];
    uint64_t v202 = v201 + 9;
    uint32x2_t v204 = v518;
    if (*(void *)&v518 != *(void *)&v203)
    {
      ++v530;
      log_warn((uint64_t)"%s:%d: %s spaceman free count %lld doesn't match free count in chunks %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
      uint32x2_t v204 = *v202;
    }
    if (v516 != *(void *)&v204)
    {
      ++v530;
      log_warn((uint64_t)"%s:%d: %s spaceman free count %lld doesn't match free count in bitmap %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    }
    char v81 = 0;
    uint64_t v78 = 1;
  }
  while ((v501 & 1) != 0);
  if (v500 + v499 != v513 + v498)
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman IP free block count is wrong %lld != %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (*(void *)&v502[30] > *(void *)&v502[6])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman free queue count is too large: %lld > %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (!*(void *)&v502[31]) {
    goto LABEL_230;
  }
  if (spaceman_fq_tree_get((pthread_mutex_t **)v3, (uint64_t)v532, 1u, 0, 0, (uint64_t *)&v526))
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s unable to get spaceman free queue tree: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    goto LABEL_230;
  }
  if (v526)
  {
    int v231 = btree_check(v526, 0, 0, 0);
    if (v231)
    {
      int v239 = v231;
      ++v530;
      log_warn((uint64_t)"%s:%d: %s spaceman free queue tree sanity check failed: %d\n", v232, v233, v234, v235, v236, v237, v238, (uint64_t)"nx_check");
      uint64_t v521 = 0x1000000008;
    }
    else
    {
      uint64_t v521 = 0x1000000008;
      int v239 = bt_lookup_first(v526, 0, &v524, (_DWORD *)&v521 + 1, &v525, (unsigned int *)&v521);
    }
    unint64_t v331 = 0;
    uint64_t v205 = 0;
    for (uint64_t j = 0;
          !v239;
          int v239 = bt_lookup_variant(v526, 0, (unint64_t *)&v524, (unsigned int *)&v521 + 1, HIDWORD(v521), &v525, (unsigned int *)&v521, 4u, 0, 0))
    {
      if (v521)
      {
        uint64_t v333 = v525;
      }
      else
      {
        unint64_t v525 = 1;
        uint64_t v333 = 1;
      }
      unint64_t v334 = v524;
      if ((unint64_t)v524 > v508)
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n", v240, v241, v242, v243, v244, v245, v246, (uint64_t)"nx_check");
        unint64_t v334 = v524;
      }
      if (v334 >= v331)
      {
        uint64_t v335 = *((void *)&v524 + 1);
        if (v334 == v331)
        {
          if (*((uint64_t *)&v524 + 1) < j)
          {
            ++v530;
            log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entries out of order: addr %lld < %lld\n", v240, v241, v242, v243, v244, v245, v246, (uint64_t)"nx_check");
            uint64_t v335 = *((void *)&v524 + 1);
          }
          uint64_t j = v525 + v335;
        }
        else
        {
          uint64_t j = 0;
          unint64_t v331 = v334;
        }
      }
      else
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entries out of order: xid %lld < %lld\n", v240, v241, v242, v243, v244, v245, v246, (uint64_t)"nx_check");
        uint64_t j = 0;
        uint64_t v335 = *((void *)&v524 + 1);
        unint64_t v331 = v524;
      }
      if (v335 < 1 || (unint64_t v336 = (unint64_t)v502[6], v335 >= v336))
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entry %lld:%lld %lld addr is bad\n", v240, v241, v242, v243, v244, v245, v246, (uint64_t)"nx_check");
        unint64_t v336 = (unint64_t)v502[6];
        uint64_t v335 = *((void *)&v524 + 1);
      }
      BOOL v70 = v336 > v525;
      unint64_t v337 = v336 - v525;
      if (!v70 || v335 > v337)
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entry %lld:%lld %lld range is bad\n", v240, v241, v242, v243, v244, v245, v246, (uint64_t)"nx_check");
      }
      v205 += v333;
      LODWORD(v521) = 8;
    }
    if (v239 != 2)
    {
      ++v530;
      log_warn((uint64_t)"%s:%d: %s spaceman free queue tree iteration aborted with error %d\n", v240, v241, v242, v243, v244, v245, v246, (uint64_t)"nx_check");
    }
    obj_release(v526);
    unint64_t v82 = v508;
    uint64_t v71 = v502;
  }
  else
  {
LABEL_230:
    uint64_t v205 = 0;
  }
  if (v205 != *(void *)&v71[30])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman free queue count %lld doesn't match count in the free queue: %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (*(void *)&v71[35] > *(void *)&v71[12])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman free queue count is too large: %lld > %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (!*(void *)&v71[36]) {
    goto LABEL_238;
  }
  if (spaceman_fq_tree_get((pthread_mutex_t **)v3, (uint64_t)v532, 2u, 0, 0, (uint64_t *)&v526))
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s unable to get spaceman free queue tree: %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
    goto LABEL_238;
  }
  if (v526)
  {
    int v247 = btree_check(v526, 0, 0, 0);
    if (v247)
    {
      int v255 = v247;
      ++v530;
      log_warn((uint64_t)"%s:%d: %s spaceman free queue tree sanity check failed: %d\n", v248, v249, v250, v251, v252, v253, v254, (uint64_t)"nx_check");
      uint64_t v521 = 0x1000000008;
    }
    else
    {
      uint64_t v521 = 0x1000000008;
      int v255 = bt_lookup_first(v526, 0, &v524, (_DWORD *)&v521 + 1, &v525, (unsigned int *)&v521);
    }
    unint64_t v338 = 0;
    uint64_t v206 = 0;
    for (uint64_t k = 0;
          !v255;
          int v255 = bt_lookup_variant(v526, 0, (unint64_t *)&v524, (unsigned int *)&v521 + 1, HIDWORD(v521), &v525, (unsigned int *)&v521, 4u, 0, 0))
    {
      if (v521)
      {
        uint64_t v340 = v525;
      }
      else
      {
        unint64_t v525 = 1;
        uint64_t v340 = 1;
      }
      unint64_t v341 = v524;
      if ((unint64_t)v524 > v508)
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entry %lld:%lld xid larger than spaceman xid %lld\n", v256, v257, v258, v259, v260, v261, v262, (uint64_t)"nx_check");
        unint64_t v341 = v524;
      }
      if (v341 >= v338)
      {
        uint64_t v342 = *((void *)&v524 + 1);
        if (v341 == v338)
        {
          if (*((uint64_t *)&v524 + 1) < k)
          {
            ++v530;
            log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entries out of order: addr %lld < %lld\n", v256, v257, v258, v259, v260, v261, v262, (uint64_t)"nx_check");
            uint64_t v342 = *((void *)&v524 + 1);
          }
          uint64_t k = v525 + v342;
        }
        else
        {
          uint64_t k = 0;
          unint64_t v338 = v341;
        }
      }
      else
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entries out of order: xid %lld < %lld\n", v256, v257, v258, v259, v260, v261, v262, (uint64_t)"nx_check");
        uint64_t k = 0;
        uint64_t v342 = *((void *)&v524 + 1);
        unint64_t v338 = v524;
      }
      uint64_t v343 = ((uint64_t)0xBFFFFFFFFFFFFFFFLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(v3 + 376) + 36)))) & v342;
      if (v343 < 1 || (unint64_t v344 = (unint64_t)v502[12], v343 >= v344))
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entry %lld:%lld %lld addr is bad\n", v256, v257, v258, v259, v260, v261, v262, (uint64_t)"nx_check");
        unint64_t v344 = (unint64_t)v502[12];
      }
      BOOL v70 = v344 > v525;
      unint64_t v345 = v344 - v525;
      if (!v70 || v343 > v345)
      {
        ++v530;
        log_warn((uint64_t)"%s:%d: %s spaceman free queue tree entry %lld:%lld %lld range is bad\n", v256, v257, v258, v259, v260, v261, v262, (uint64_t)"nx_check");
      }
      v206 += v340;
      LODWORD(v521) = 8;
    }
    if (v255 != 2)
    {
      ++v530;
      log_warn((uint64_t)"%s:%d: %s spaceman free queue tree iteration aborted with error %d\n", v256, v257, v258, v259, v260, v261, v262, (uint64_t)"nx_check");
    }
    obj_release(v526);
    unint64_t v82 = v508;
    uint64_t v71 = v502;
  }
  else
  {
LABEL_238:
    uint64_t v206 = 0;
  }
  if (v206 != *(void *)&v71[35])
  {
    ++v530;
    log_warn((uint64_t)"%s:%d: %s spaceman free queue count %lld doesn't match count in the free queue: %lld\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_check");
  }
  if (*(void *)(v511 + 168))
  {
    uint64_t v207 = nx_reaper_get((void *)v3, &v531);
    if (v207)
    {
      uint64_t v13 = v207;
      log_err((uint64_t)"%s:%d: %s unable to get reaper: %d\n", v208, v209, v210, v211, v212, v213, v214, (uint64_t)"nx_check");
      goto LABEL_382;
    }
    uint64_t v263 = v531[47];
    if (*(void *)(v263 + 40) >= *(void *)(v263 + 32))
    {
      log_warn((uint64_t)"%s:%d: %s reaper completed ID 0x%llx not less than next reap ID 0x%llx\n", v208, v209, v210, v211, v212, v213, v214, (uint64_t)"nx_check_reaper");
      int v264 = 1;
    }
    else
    {
      int v264 = 0;
    }
    if ((*(_DWORD *)(v263 + 64) & 1) == 0)
    {
      ++v264;
      log_warn((uint64_t)"%s:%d: %s reaper needs more cowbell, flags 0x%x\n", v208, v209, v210, v211, v212, v213, v214, (uint64_t)"nx_check_reaper");
    }
    unint64_t v265 = *(void *)(v263 + 48);
    if (!v265)
    {
      if (!*(void *)(v263 + 56)
        || (++v264,
            log_warn((uint64_t)"%s:%d: %s reaper has tail with no head\n", v208, v209, v210, v211, v212, v213, v214, (uint64_t)"nx_check_reaper"), (unint64_t v265 = *(void *)(v263 + 48)) == 0))
      {
LABEL_374:
        v530 += v264;
        obj_release(v531);
        unint64_t v82 = v508;
        goto LABEL_375;
      }
    }
    v533[0] = 0;
    int v266 = *(_DWORD *)(v263 + 68);
    while (2)
    {
      uint64_t v267 = obj_get(*(void *)(v3 + 392), 0x80000000, v265, (int *)&nx_reap_list_desc, 0, 0, 0, 0, (uint64_t *)v533);
      if (v267)
      {
        uint64_t v13 = v267;
        log_err((uint64_t)"%s:%d: %s failed to get reap list head: %d\n", v268, v269, v270, v271, v272, v273, v274, (uint64_t)"nx_check_reaper");
        obj_release(v531);
        log_err((uint64_t)"%s:%d: %s reaper check failed with error: %d\n", v303, v304, v305, v306, v307, v308, v309, (uint64_t)"nx_check");
        goto LABEL_382;
      }
      uint64_t v275 = v533[0][47];
      int v276 = *(_DWORD *)(v275 + 44);
      if (v276 != (((unint64_t)obj_size_phys((uint64_t)v533[0]) - 64) / 0x28))
      {
        ++v264;
        obj_size_phys((uint64_t)v533[0]);
        log_warn((uint64_t)"%s:%d: %s reap list object 0x%llx max record count %u not expected value %u\n", v284, v285, v286, v287, v288, v289, v290, (uint64_t)"nx_check_reaper");
      }
      if (*(_DWORD *)(v275 + 48) <= *(_DWORD *)(v275 + 44))
      {
        uint64_t v3 = v514;
      }
      else
      {
        ++v264;
        uint64_t v3 = v514;
        log_warn((uint64_t)"%s:%d: %s reap list object 0x%llx record count %d larger than max %d\n", v277, v278, v279, v280, v281, v282, v283, (uint64_t)"nx_check_reaper");
      }
      unsigned int v291 = *(_DWORD *)(v275 + 52);
      if (v291 != -1 && v291 > *(_DWORD *)(v275 + 44))
      {
        ++v264;
        log_warn((uint64_t)"%s:%d: %s reap list object 0x%llx first index %u larger than max %u\n", v277, v278, v279, v280, v281, v282, v283, (uint64_t)"nx_check_reaper");
      }
      unsigned int v292 = *(_DWORD *)(v275 + 56);
      if (v292 != -1 && v292 > *(_DWORD *)(v275 + 44))
      {
        ++v264;
        log_warn((uint64_t)"%s:%d: %s reap list object 0x%llx last index %u larger than max %u\n", v277, v278, v279, v280, v281, v282, v283, (uint64_t)"nx_check_reaper");
      }
      unsigned int v293 = *(_DWORD *)(v275 + 60);
      if (v293 != -1 && v293 > *(_DWORD *)(v275 + 44))
      {
        ++v264;
        log_warn((uint64_t)"%s:%d: %s reap list object 0x%llx free index %u larger than max %u\n", v277, v278, v279, v280, v281, v282, v283, (uint64_t)"nx_check_reaper");
      }
      unint64_t v294 = *(void *)(v275 + 32);
      uint64_t v295 = *(void *)(v263 + 56);
      if (v294)
      {
LABEL_279:
        if (v295 == v265)
        {
          if (!v294) {
            goto LABEL_283;
          }
          ++v264;
          log_warn((uint64_t)"%s:%d: %s reap list tail 0x%llx is not last reap list object, next 0x%llx\n", v277, v278, v279, v280, v281, v282, v283, (uint64_t)"nx_check_reaper");
          unint64_t v265 = *(void *)(v275 + 32);
        }
        else
        {
          unint64_t v265 = v294;
        }
      }
      else
      {
        if (v295 != v265)
        {
          ++v264;
          log_warn((uint64_t)"%s:%d: %s last reap list object 0x%llx doesn't match tail 0x%llx\n", v277, v278, v279, v280, v281, v282, v283, (uint64_t)"nx_check_reaper");
          uint64_t v295 = *(void *)(v263 + 56);
          unint64_t v294 = *(void *)(v275 + 32);
          goto LABEL_279;
        }
LABEL_283:
        unint64_t v265 = 0;
      }
      obj_release(v533[0]);
      if (*(_DWORD *)(v263 + 68))
      {
        --v266;
        if (v265 && !v266)
        {
          ++v264;
          log_warn((uint64_t)"%s:%d: %s reap list expected %u objects, but haven't seen last reap list object yet\n", v296, v297, v298, v299, v300, v301, v302, (uint64_t)"nx_check_reaper");
          goto LABEL_374;
        }
        if (!v265 && v266)
        {
          ++v264;
          log_warn((uint64_t)"%s:%d: %s reap list expected %u objects, but got last reap list object with %u more objects left\n", v296, v297, v298, v299, v300, v301, v302, (uint64_t)"nx_check_reaper");
          goto LABEL_374;
        }
      }
      if (!v265) {
        goto LABEL_374;
      }
      continue;
    }
  }
LABEL_375:
  uint64_t v346 = v511;
  unint64_t v347 = *(void *)(v511 + 160);
  if (!v347) {
    goto LABEL_383;
  }
  uint64_t v348 = obj_get(*(void *)(v3 + 392), 0x40000000, v347, (int *)&om_desc, 0, 0, 0, 0, (uint64_t *)&v523);
  if (v348)
  {
    uint64_t v13 = v348;
    log_err((uint64_t)"%s:%d: %s unable to get omap: %d\n", v349, v350, v351, v352, v353, v354, v355, (uint64_t)"nx_check");
    goto LABEL_382;
  }
  if (obj_xid((uint64_t)v523) > v82)
  {
    ++v530;
    obj_xid((uint64_t)v523);
    uint64_t v3 = v514;
    log_warn((uint64_t)"%s:%d: %s omap xid %lld > spaceman xid %lld\n", v356, v357, v358, v359, v360, v361, v362, (uint64_t)"nx_check");
  }
  uint64_t v13 = sub_100040830(v3, (uint64_t)v523, v82, &v530);
  obj_release(v523);
  uint64_t v346 = v511;
  if (!v13)
  {
LABEL_383:
    v533[0] = 0;
    uint64_t v519 = 0;
    if (!*(_DWORD *)(v346 + 180))
    {
LABEL_444:
      obj_release(v532);
      if (v530) {
        return 22;
      }
      else {
        return 0;
      }
    }
    uint64_t v370 = 0;
    while (1)
    {
      unint64_t v371 = *(void *)(v511 + 184 + 8 * v370);
      if (v371)
      {
        if (obj_get(*(void *)(v3 + 392), 0, v371, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)v533))
        {
          log_err((uint64_t)"%s:%d: %s unable to get fs[%d] oid %lld, %d\n", v372, v373, v374, v375, v376, v377, v378, (uint64_t)"nx_check");
        }
        else
        {
          uint64_t v379 = v533[0];
          uint64_t v380 = v533[0][47];
          unint64_t v381 = *(void *)(v380 + 128);
          if (!v381) {
            goto LABEL_394;
          }
          if (obj_get(*(void *)(v3 + 392), 0x40000000, v381, (int *)&om_desc, 0, (uint64_t)v533[0], 0, 0, (uint64_t *)&v523))
          {
            log_err((uint64_t)"%s:%d: %s unable to get omap %lld: %d\n", v382, v383, v384, v385, v386, v387, v388, (uint64_t)"nx_check");
            goto LABEL_442;
          }
          int v389 = sub_100040830((uint64_t)v533[0], (uint64_t)v523, v508, &v530);
          obj_release(v523);
          uint64_t v379 = v533[0];
          if (!v389)
          {
            uint64_t v380 = v533[0][47];
LABEL_394:
            if (*(void *)(v380 + 136))
            {
              if (*(unsigned char *)(v380 + 264) & 1) != 0 || (v497)
              {
                uint64_t v519 = 0;
                if (apfs_get_fsroot_tree((uint64_t)v379, 0, 0, &v519))
                {
                  log_err((uint64_t)"%s:%d: %s unable to get fs root tree: %d\n", v390, v391, v392, v393, v394, v395, v396, (uint64_t)"nx_check");
                }
                else
                {
                  if (obj_xid((uint64_t)v519) > v508)
                  {
                    ++v530;
                    obj_xid((uint64_t)v519);
                    uint64_t v3 = v514;
                    log_warn((uint64_t)"%s:%d: %s fs root tree xid %lld > spaceman xid %lld\n", v397, v398, v399, v400, v401, v402, v403, (uint64_t)"nx_check");
                  }
                  if (btree_check(v519, 0, 0, 0))
                  {
                    ++v530;
                    log_warn((uint64_t)"%s:%d: %s fs root tree sanity check failed: %d\n", v404, v405, v406, v407, v408, v409, v410, (uint64_t)"nx_check");
                  }
                }
                if (v519) {
                  obj_release(v519);
                }
              }
              else
              {
                log_err((uint64_t)"%s:%d: %s skipping check of fs[%d] oid %lld fs root tree because it's encrypted\n", v372, v381, v374, v375, (uint64_t)v379, v377, v378, (uint64_t)"nx_check");
              }
            }
            unint64_t v411 = *(void *)(v533[0][47] + 144);
            if (v411)
            {
              uint64_t v519 = 0;
              if (apfs_get_extentref_tree((uint64_t)v533[0], v411, 0, &v519))
              {
                log_err((uint64_t)"%s:%d: %s unable to get fs extentref tree: %d\n", v412, v413, v414, v415, v416, v417, v418, (uint64_t)"nx_check");
              }
              else
              {
                if (obj_xid((uint64_t)v519) > v508)
                {
                  ++v530;
                  obj_xid((uint64_t)v519);
                  uint64_t v3 = v514;
                  log_warn((uint64_t)"%s:%d: %s fs extentref tree xid %lld > spaceman xid %lld\n", v419, v420, v421, v422, v423, v424, v425, (uint64_t)"nx_check");
                }
                if (btree_check(v519, 0, 0, 0))
                {
                  ++v530;
                  log_warn((uint64_t)"%s:%d: %s fs extentref tree sanity check failed: %d\n", v426, v427, v428, v429, v430, v431, v432, (uint64_t)"nx_check");
                }
              }
              if (v519) {
                obj_release(v519);
              }
            }
            if (*(void *)(v533[0][47] + 152))
            {
              uint64_t v519 = 0;
              if (apfs_get_snap_meta_tree((uint64_t)v533[0], 0, &v519))
              {
                log_err((uint64_t)"%s:%d: %s unable to get fs snap meta tree: %d\n", v433, v434, v435, v436, v437, v438, v439, (uint64_t)"nx_check");
              }
              else
              {
                if (obj_xid((uint64_t)v519) > v508)
                {
                  ++v530;
                  obj_xid((uint64_t)v519);
                  uint64_t v3 = v514;
                  log_warn((uint64_t)"%s:%d: %s fs snap meta tree xid %lld > spaceman xid %lld\n", v440, v441, v442, v443, v444, v445, v446, (uint64_t)"nx_check");
                }
                if (btree_check(v519, 0, 0, 0))
                {
                  ++v530;
                  log_warn((uint64_t)"%s:%d: %s fs snap meta tree sanity check failed: %d\n", v447, v448, v449, v450, v451, v452, v453, (uint64_t)"nx_check");
                }
              }
              if (v519) {
                obj_release(v519);
              }
            }
            if (*(void *)(v533[0][47] + 1072))
            {
              uint64_t v519 = 0;
              if (apfs_get_doc_id_tree((uint64_t)v533[0], 0, 0, 0, &v519))
              {
                log_err((uint64_t)"%s:%d: %s unable to get doc-id tree: %d\n", v454, v455, v456, v457, v458, v459, v460, (uint64_t)"nx_check");
              }
              else
              {
                if (obj_xid((uint64_t)v519) > v508)
                {
                  ++v530;
                  obj_xid((uint64_t)v519);
                  uint64_t v3 = v514;
                  log_warn((uint64_t)"%s:%d: %s doc-id tree xid %lld > spaceman xid %lld\n", v461, v462, v463, v464, v465, v466, v467, (uint64_t)"nx_check");
                }
                if (btree_check(v519, 0, 0, 0))
                {
                  ++v530;
                  log_warn((uint64_t)"%s:%d: %s doc-id tree sanity check failed: %d\n", v468, v469, v470, v471, v472, v473, v474, (uint64_t)"nx_check");
                }
              }
              if (v519) {
                obj_release(v519);
              }
            }
            if (*(void *)(v533[0][47] + 1080))
            {
              uint64_t v519 = 0;
              if (apfs_get_doc_id_tree((uint64_t)v533[0], 1, 0, 0, &v519))
              {
                log_err((uint64_t)"%s:%d: %s unable to get prev doc-id tree: %d\n", v475, v476, v477, v478, v479, v480, v481, (uint64_t)"nx_check");
              }
              else
              {
                if (obj_xid((uint64_t)v519) > v508)
                {
                  ++v530;
                  obj_xid((uint64_t)v519);
                  uint64_t v3 = v514;
                  log_warn((uint64_t)"%s:%d: %s prev doc-id tree xid %lld > spaceman xid %lld\n", v482, v483, v484, v485, v486, v487, v488, (uint64_t)"nx_check");
                }
                if (btree_check(v519, 0, 0, 0))
                {
                  ++v530;
                  log_warn((uint64_t)"%s:%d: %s prev doc-id tree sanity check failed: %d\n", v489, v490, v491, v492, v493, v494, v495, (uint64_t)"nx_check");
                }
              }
              if (v519) {
                obj_release(v519);
              }
            }
LABEL_442:
            obj_release(v533[0]);
            goto LABEL_443;
          }
          log_err((uint64_t)"%s:%d: %s omap check failed for omap %lld: %d\n", v372, v381, v374, v375, (uint64_t)v533[0], v377, v378, (uint64_t)"nx_check");
          obj_release(v533[0]);
        }
      }
LABEL_443:
      if (++v370 >= (unint64_t)*(unsigned int *)(v511 + 180)) {
        goto LABEL_444;
      }
    }
  }
  log_err((uint64_t)"%s:%d: %s omap check failed with error: %d\n", v363, v364, v365, v366, v367, v368, v369, (uint64_t)"nx_check");
LABEL_382:
  obj_release(v532);
  return v13;
}

uint64_t sub_100040830(uint64_t a1, uint64_t a2, unint64_t a3, int *a4)
{
  uint64_t v167 = 0;
  uint64_t v8 = (void *)a1;
  if (obj_type(a1) == 13) {
    uint64_t v8 = *(void **)(a1 + 392);
  }
  uint64_t v165 = 0;
  uint64_t v166 = 0;
  memset(v164, 0, sizeof(v164));
  uint64_t v9 = v8[47];
  unsigned int v10 = *(_DWORD *)(v9 + 36);
  if (*(unsigned char *)(v9 + 65))
  {
    uint64_t v11 = spaceman_get(v8, &v167);
    if (v11)
    {
      uint64_t extended = v11;
      obj_type(a1);
      log_err((uint64_t)"%s:%d: %s unable to get spaceman: %d\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"nx_check_omap");
      return extended;
    }
  }
  if (*(_DWORD *)(*(void *)(a2 + 376) + 36) >= 0x400u)
  {
    obj_type(a1);
    log_warn((uint64_t)"%s:%d: %s omap snapshot count %d seems excessive\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"nx_check_omap");
  }
  uint64_t v20 = *(void *)(a2 + 376);
  int v21 = *(_DWORD *)(v20 + 40);
  if (v21 != 1073741826 && v21 != -2147483646)
  {
    obj_type(a1);
    log_warn((uint64_t)"%s:%d: %s omap tree type 0x%x is bad\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"nx_check_omap");
    int v46 = 1;
    goto LABEL_56;
  }
  unint64_t v23 = *(void *)(v20 + 48);
  long long v169 = 0u;
  uint64_t v174 = 0;
  long long v173 = 0u;
  long long v172 = 0u;
  long long v171 = 0u;
  long long v170 = 0u;
  uint64_t v168 = omap_key_cmp;
  DWORD2(v169) = 11;
  if ((unsigned __int16)v21 != 2)
  {
    uint64_t extended = 22;
    goto LABEL_18;
  }
  uint64_t extended = btree_get_extended(a1, v21 & 0xFFFF0000, v23, 0, 0, (uint64_t)&v168, 0, &v166);
  if (extended)
  {
LABEL_18:
    obj_type(a1);
    log_warn((uint64_t)"%s:%d: %s unable to get omap tree: %d\n", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"nx_check_omap");
    int v31 = *a4 + 1;
    goto LABEL_64;
  }
  if (obj_xid((uint64_t)v166) <= a3)
  {
    int v46 = 0;
  }
  else
  {
    obj_type(a1);
    obj_xid((uint64_t)v166);
    log_warn((uint64_t)"%s:%d: %s omap tree xid %lld > spaceman xid %lld\n", v47, v48, v49, v50, v51, v52, v53, (uint64_t)"nx_check_omap");
    int v46 = 1;
  }
  if (!btree_check(v166, 0, 0, 0))
  {
    unint64_t v162 = 0;
    uint64_t v163 = 0;
    uint64_t v168 = 0;
    *(void *)&long long v169 = 0;
    bt_iterator_init_with_hint((uint64_t)v164, v166, 0, 0, (unint64_t *)&v168, 16, 0x10u, &v162, 0x10u, 0);
    if (bt_iterator_ended((uint64_t)v164)) {
      goto LABEL_55;
    }
    uint64_t v54 = 0;
    *(_DWORD *)&v161[8] = 0;
    *(void *)uint64_t v161 = v10 - 1;
    uint64_t v55 = -1;
    while (1)
    {
      if ((unint64_t)v168 >= (unint64_t)v54)
      {
        unint64_t v56 = v169;
        if (v168 != v54)
        {
          *(void *)&v161[4] = 0;
          uint64_t v55 = -1;
          uint64_t v54 = v168;
          goto LABEL_31;
        }
        if ((unint64_t)v169 <= *(void *)&v161[4])
        {
          ++v46;
          obj_type(a1);
          log_warn((uint64_t)"%s:%d: %s omap tree entries out of order: oid %lld xid %lld <= lastxid %lld\n", v64, v65, v66, v67, v68, v69, v70, (uint64_t)"nx_check_omap");
        }
      }
      else
      {
        obj_type(a1);
        log_warn((uint64_t)"%s:%d: %s omap tree entries out of order: oid %lld < %lld\n", v57, v58, v59, v60, v61, v62, v63, (uint64_t)"nx_check_omap");
        ++v46;
        uint64_t v55 = -1;
        uint64_t v54 = v168;
      }
      unint64_t v56 = v169;
      *(void *)&v161[4] = v169;
LABEL_31:
      if (v56 > a3)
      {
        ++v46;
        obj_type(a1);
        log_warn((uint64_t)"%s:%d: %s omap entry %lld:%lld xid > spaceman xid %lld\n", v71, v72, v73, v74, v75, v76, v77, (uint64_t)"nx_check_omap");
      }
      if (v162 >= 0x800)
      {
        ++v46;
        obj_type(a1);
        log_warn((uint64_t)"%s:%d: %s omap entry %lld:%lld unknown flags are set: 0x%x\n", v78, v79, v80, v81, v82, v83, v84, (uint64_t)"nx_check_omap");
      }
      if ((v162 & 1) != 0 && v55 == -1)
      {
        ++v46;
        obj_type(a1);
        log_warn((uint64_t)"%s:%d: %s omap entry %lld:%lld marks deletion of object with no earlier mappings\n", v85, v86, v87, v88, v89, v90, v91, (uint64_t)"nx_check_omap");
      }
      else if (v55 != -1)
      {
        if (v55)
        {
          ++v46;
          obj_type(a1);
          log_warn((uint64_t)"%s:%d: %s omap entry %lld:%lld beyond deletion entry @ xid %lld\n", v92, v93, v94, v95, v96, v97, v98, (uint64_t)"nx_check_omap");
        }
        else if (v162)
        {
          uint64_t v55 = v169;
        }
        else
        {
          uint64_t v55 = 0;
        }
        goto LABEL_47;
      }
      if (v162) {
        uint64_t v55 = v169;
      }
      else {
        uint64_t v55 = 0;
      }
LABEL_47:
      if (HIDWORD(v162) >= 0x100000)
      {
        ++v46;
        obj_type(a1);
        log_warn((uint64_t)"%s:%d: %s omap entry %lld:%lld size %d seems excessive\n", v99, v100, v101, v102, v103, v104, v105, (uint64_t)"nx_check_omap");
      }
      if (v167) {
        uint64_t v106 = v167[47];
      }
      else {
        uint64_t v106 = 0;
      }
      if (nx_superblock_sanity_check_extent(v8[47], v106, v163, (*(_DWORD *)v161 + HIDWORD(v162)) / v10, 0))
      {
        ++v46;
        obj_type(a1);
        log_warn((uint64_t)"%s:%d: %s omap entry %lld:%lld addr %lld size %d is bad\n", v107, v108, v109, v110, v111, v112, v113, (uint64_t)"nx_check_omap");
      }
      bt_iterator_next((uint64_t)v164);
      if (bt_iterator_ended((uint64_t)v164)) {
        goto LABEL_55;
      }
    }
  }
  ++v46;
  obj_type(a1);
  log_warn((uint64_t)"%s:%d: %s omap tree sanity check failed: %d\n", v114, v115, v116, v117, v118, v119, v120, (uint64_t)"nx_check_omap");
LABEL_55:
  obj_release(v166);
LABEL_56:
  uint64_t v121 = *(void *)(a2 + 376);
  unint64_t v122 = *(void *)(v121 + 56);
  if (!v122)
  {
LABEL_74:
    *a4 += v46;
    if (v167) {
      obj_release(v167);
    }
    return 0;
  }
  int v123 = *(_DWORD *)(v121 + 44);
  if (v123 != 1073741826 && v123 != -2147483646)
  {
    ++v46;
    obj_type(a1);
    log_warn((uint64_t)"%s:%d: %s omap snapshot tree type 0x%x is bad\n", v131, v132, v133, v134, v135, v136, v137, (uint64_t)"nx_check_omap");
    goto LABEL_74;
  }
  long long v169 = 0u;
  uint64_t v174 = 0;
  long long v173 = 0u;
  long long v172 = 0u;
  long long v171 = 0u;
  long long v170 = 0u;
  uint64_t v168 = omap_snapshot_key_cmp;
  DWORD2(v169) = 19;
  uint64_t extended = btree_get_extended(a1, v123 & 0xFFFF0000, v122, 0, 0, (uint64_t)&v168, 0, &v166);
  if (!extended)
  {
    if (obj_xid((uint64_t)v166) > a3)
    {
      ++v46;
      obj_type(a1);
      obj_xid((uint64_t)v166);
      log_warn((uint64_t)"%s:%d: %s omap snapshot tree xid %lld > spaceman xid %lld\n", v138, v139, v140, v141, v142, v143, v144, (uint64_t)"nx_check_omap");
    }
    if (btree_check(v166, 0, 0, 0))
    {
      ++v46;
      obj_type(a1);
      log_warn((uint64_t)"%s:%d: %s omap snapshot tree sanity check failed: %d\n", v146, v147, v148, v149, v150, v151, v152, (uint64_t)"nx_check_omap");
    }
    else
    {
      uint64_t v168 = 0;
      *(void *)&long long v169 = 0;
      unint64_t v162 = 0;
      bt_iterator_init_with_hint((uint64_t)v164, v166, 0, 0, &v162, 8, 8u, &v168, 0x10u, 0);
      uint64_t v145 = 0;
      if (!bt_iterator_ended((uint64_t)v164))
      {
        uint64_t v145 = 0;
        do
        {
          ++v145;
          bt_iterator_next((uint64_t)v164);
        }
        while (!bt_iterator_ended((uint64_t)v164));
      }
      if (v145 != *(_DWORD *)(*(void *)(a2 + 376) + 36))
      {
        ++v46;
        obj_type(a1);
        log_warn((uint64_t)"%s:%d: %s omap snapshot count %d doesn't match snapshot tree record count %lld\n", v153, v154, v155, v156, v157, v158, v159, (uint64_t)"nx_check_omap");
      }
    }
    obj_release(v166);
    goto LABEL_74;
  }
  obj_type(a1);
  log_warn((uint64_t)"%s:%d: %s unable to get omap snapshot tree: %d\n", v124, v125, v126, v127, v128, v129, v130, (uint64_t)"nx_check_omap");
  int v31 = v46 + 1 + *a4;
LABEL_64:
  *a4 = v31;
  if (v167) {
    obj_release(v167);
  }
  return extended;
}

uint64_t omap_recent_sanity_callback(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t *a4, int a5, int *a6, int a7)
{
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  int v13 = obj_type(a1);
  uint64_t v14 = 0;
  uint64_t v15 = a1;
  if (v13 == 13)
  {
    uint64_t v15 = *(void *)(a1 + 392);
    uint64_t v14 = a1;
  }
  uint64_t v16 = 22;
  if (a5 == 16 && a7 == 16)
  {
    unint64_t v17 = a4[1];
    if (v17 <= a3) {
      return 0;
    }
    int v18 = *a6;
    if ((*a6 & 5) != 0)
    {
      return 0;
    }
    else
    {
      uint64_t v30 = 0;
      if ((v18 & 8) != 0) {
        uint64_t v20 = 536870936;
      }
      else {
        uint64_t v20 = 24;
      }
      LODWORD(v29) = a6[1];
      uint64_t v16 = obj_get(*(void *)(v15 + 392), v20, *a4, (int *)&v28, 0, v14, v17, 0, (uint64_t *)&v30);
      if (v16)
      {
        obj_type(a1);
        log_err((uint64_t)"%s:%d: %s check of oid:xid %lld:%lld  size %d paddr 0x%llx flags 0x%x failed: %d\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"omap_recent_sanity_callback");
      }
      else
      {
        obj_release(v30);
      }
    }
  }
  return v16;
}

uint64_t nx_check_recent_sanity(void *a1)
{
  uint64_t v134 = 0;
  uint64_t v135 = 0;
  uint64_t v133 = 0;
  uint64_t v132 = 0;
  uint64_t v2 = spaceman_get(a1, &v135);
  if (v2)
  {
    uint64_t v10 = v2;
    log_err((uint64_t)"%s:%d: %s unable to get spaceman: %d\n", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"nx_check_recent_sanity");
    return v10;
  }
  uint64_t v11 = v135[47];
  unint64_t v12 = obj_xid((uint64_t)v135);
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  unint64_t v15 = v12 - 3;
  if (v12 < 3) {
    unint64_t v15 = 0;
  }
  unint64_t v125 = v15;
  uint64_t v126 = 0;
  uint64_t v130 = 0;
  uint64_t v131 = 0;
  uint64_t v128 = 0;
  unint64_t v129 = 0;
  unint64_t v127 = 0;
  do
  {
    uint64_t v16 = v11 + 48 * v13;
    int v18 = *(_DWORD *)(v16 + 64);
    unint64_t v17 = (unsigned int *)(v16 + 64);
    if (!v18)
    {
      uint64_t v10 = 0;
      goto LABEL_30;
    }
    unint64_t v19 = 0;
    LODWORD(v20) = -1;
    while (1)
    {
      if (!*(_DWORD *)(v11 + 48 * v13 + 68))
      {
        uint64_t v32 = (unint64_t *)(v135[v13 + 111] + 8 * v19);
        goto LABEL_22;
      }
      unint64_t v21 = *(unsigned int *)(v11 + 44);
      if (v19 / v21 != v20 || v14 == 0) {
        break;
      }
LABEL_20:
      uint64_t v32 = (unint64_t *)(v14 + 8 * (v19 - (v21 * v20)) + 40);
LABEL_22:
      unint64_t v33 = *v32;
      uint64_t v126 = v11;
      unint64_t v127 = __PAIR64__(v19, v13);
      uint64_t v34 = obj_get(a1[49], 0x40000000, v33, (int *)&sm_cib_desc, &v126, 0, 0, 0, (uint64_t *)&v130);
      if (v34)
      {
        uint64_t v43 = v34;
        log_err((uint64_t)"%s:%d: %s unable to read cib %lld @ %lld: %d\n", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"nx_check_recent_sanity");
        uint64_t v10 = v43;
        goto LABEL_30;
      }
      obj_release(v130);
      uint64_t v42 = 1;
LABEL_24:
      v19 += v42;
      if (v19 >= *v17)
      {
        uint64_t v10 = 0;
        goto LABEL_30;
      }
    }
    unint64_t v20 = v19 / v21;
    unint64_t v23 = *(void *)(v135[v13 + 111] + 8 * (v19 / v21));
    if (v131)
    {
      obj_release(v131);
      uint64_t v131 = 0;
    }
    uint64_t v128 = v11;
    unint64_t v129 = __PAIR64__(v20, v13);
    uint64_t v24 = obj_get(a1[49], 0x40000000, v23, (int *)&sm_cab_desc, &v128, 0, 0, 0, (uint64_t *)&v131);
    if (!v24)
    {
      uint64_t v14 = v131[7];
      if (obj_xid((uint64_t)v131) <= v125)
      {
        uint64_t v42 = *(unsigned int *)(v14 + 36);
        goto LABEL_24;
      }
      LODWORD(v21) = *(_DWORD *)(v11 + 44);
      goto LABEL_20;
    }
    uint64_t v10 = v24;
    log_err((uint64_t)"%s:%d: %s unable to read cab %d @ %lld: %d\n", v25, v26, v27, v28, v29, v30, v31, (uint64_t)"nx_check_recent_sanity");
LABEL_30:
    if (v131)
    {
      obj_release(v131);
      uint64_t v131 = 0;
    }
  }
  while (!(v10 | v13++));
  obj_release(v135);
  if (v10) {
    return v10;
  }
  unint64_t v46 = *(void *)(a1[47] + 160);
  if (v46)
  {
    uint64_t v47 = obj_get(a1[49], 0x40000000, v46, (int *)&om_desc, 0, 0, 0, 0, (uint64_t *)&v134);
    if (v47)
    {
      uint64_t v10 = v47;
      log_err((uint64_t)"%s:%d: %s unable to get omap: %d\n", v48, v49, v50, v51, v52, v53, v54, (uint64_t)"nx_check_recent_sanity");
      return v10;
    }
    if (obj_xid((uint64_t)v134) <= v125)
    {
      obj_release(v134);
    }
    else
    {
      uint64_t v10 = nx_check_recent_sanity_omap((uint64_t)a1, (uint64_t)v134, v125);
      obj_release(v134);
      if (v10)
      {
        log_err((uint64_t)"%s:%d: %s omap check failed with error: %d\n", v55, v56, v57, v58, v59, v60, v61, (uint64_t)"nx_check_recent_sanity");
        return v10;
      }
    }
  }
  uint64_t v62 = a1[47];
  if (!*(_DWORD *)(v62 + 180)) {
    return 0;
  }
  unint64_t v63 = 0;
  while (2)
  {
    unint64_t v64 = *(void *)(v62 + 8 * v63 + 184);
    if (!v64) {
      goto LABEL_75;
    }
    uint64_t v65 = obj_get(a1[49], 0, v64, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v133);
    if (v65)
    {
      uint64_t v123 = v65;
      log_err((uint64_t)"%s:%d: %s unable to get fs[%d] oid %lld, %d\n", v66, v67, v68, v69, v70, v71, v72, (uint64_t)"nx_check_recent_sanity");
      return v123;
    }
    unint64_t v73 = obj_xid((uint64_t)v133);
    uint64_t v74 = v133;
    if (v73 <= v125) {
      goto LABEL_74;
    }
    unint64_t v75 = *(void *)(v133[47] + 128);
    if (!v75) {
      goto LABEL_53;
    }
    uint64_t v76 = obj_get(a1[49], 0x40000000, v75, (int *)&om_desc, 0, (uint64_t)v133, 0, 0, (uint64_t *)&v134);
    if (!v76)
    {
      if (obj_xid((uint64_t)v134) <= v125)
      {
        obj_release(v134);
        uint64_t v74 = v133;
      }
      else
      {
        uint64_t v84 = nx_check_recent_sanity_omap((uint64_t)v133, (uint64_t)v134, v125);
        obj_release(v134);
        uint64_t v74 = v133;
        if (v84)
        {
          log_err((uint64_t)"%s:%d: %s omap check failed for omap %lld: %d\n", v85, v86, v87, v88, (uint64_t)v133, v89, v90, (uint64_t)"nx_check_recent_sanity");
          goto LABEL_80;
        }
      }
LABEL_53:
      uint64_t v91 = v74[47];
      unint64_t v92 = *(void *)(v91 + 144);
      if (v92)
      {
        uint64_t v132 = 0;
        extentref_uint64_t tree = apfs_get_extentref_tree((uint64_t)v74, v92, 0, &v132);
        if (extentref_tree)
        {
          uint64_t v84 = extentref_tree;
          log_err((uint64_t)"%s:%d: %s unable to get extentref tree %lld: %d\n", v94, v95, v96, v97, v98, v99, v100, (uint64_t)"nx_check_recent_sanity");
        }
        else if (obj_xid((uint64_t)v132) <= v125)
        {
          uint64_t v84 = 0;
        }
        else
        {
          uint64_t v84 = btree_check_recent_sanity(v132, v125, 0, 0);
          if (v84) {
            log_err((uint64_t)"%s:%d: %s extentref tree %lld: %d\n", v101, v102, v103, v104, v105, v106, v107, (uint64_t)"nx_check_recent_sanity");
          }
        }
        if (v132) {
          obj_release(v132);
        }
        uint64_t v74 = v133;
        if (v84)
        {
LABEL_78:
          uint64_t v124 = v74;
          goto LABEL_81;
        }
        uint64_t v91 = v133[47];
      }
      if (*(void *)(v91 + 152))
      {
        uint64_t v132 = 0;
        snap_meta_uint64_t tree = apfs_get_snap_meta_tree((uint64_t)v74, 0, &v132);
        if (snap_meta_tree)
        {
          uint64_t v84 = snap_meta_tree;
          log_err((uint64_t)"%s:%d: %s unable to get snap meta tree %lld: %d\n", v109, v110, v111, v112, v113, v114, v115, (uint64_t)"nx_check_recent_sanity");
        }
        else if (obj_xid((uint64_t)v132) <= v125)
        {
          uint64_t v84 = 0;
        }
        else
        {
          uint64_t v84 = btree_check_recent_sanity(v132, v125, 0, 0);
          if (v84) {
            log_err((uint64_t)"%s:%d: %s snap meta tree %lld: %d\n", v116, v117, v118, v119, v120, v121, v122, (uint64_t)"nx_check_recent_sanity");
          }
        }
        if (v132) {
          obj_release(v132);
        }
        uint64_t v74 = v133;
        if (v84) {
          goto LABEL_78;
        }
      }
LABEL_74:
      obj_release(v74);
LABEL_75:
      ++v63;
      uint64_t v62 = a1[47];
      if (v63 >= *(unsigned int *)(v62 + 180)) {
        return 0;
      }
      continue;
    }
    break;
  }
  uint64_t v84 = v76;
  log_err((uint64_t)"%s:%d: %s unable to get omap %lld: %d\n", v77, v78, v79, v80, v81, v82, v83, (uint64_t)"nx_check_recent_sanity");
LABEL_80:
  uint64_t v124 = v133;
LABEL_81:
  obj_release(v124);
  return v84;
}

uint64_t nx_check_recent_sanity_omap(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v28 = 0;
  uint64_t v6 = *(void *)(a2 + 376);
  unint64_t v7 = *(void *)(v6 + 48);
  if (!v7) {
    goto LABEL_10;
  }
  int v8 = *(_DWORD *)(v6 + 40);
  long long v30 = 0u;
  long long v31 = 0u;
  uint64_t v35 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  uint64_t v29 = omap_key_cmp;
  DWORD2(v30) = 11;
  if ((unsigned __int16)v8 != 2)
  {
    uint64_t extended = 22;
    goto LABEL_8;
  }
  uint64_t extended = btree_get_extended(a1, v8 & 0xFFFF0000, v7, 0, 0, (uint64_t)&v29, 0, &v28);
  if (extended)
  {
LABEL_8:
    obj_type(a1);
    log_err((uint64_t)"%s:%d: %s unable to get omap tree: %d\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"nx_check_recent_sanity_omap");
    return extended;
  }
  if (obj_xid((uint64_t)v28) <= a3)
  {
    obj_release(v28);
  }
  else
  {
    uint64_t extended = btree_check_recent_sanity(v28, a3, (uint64_t (*)(uint64_t, uint64_t, unint64_t, uint64_t, void, uint64_t, void))omap_recent_sanity_callback, 0);
    obj_release(v28);
    if (extended) {
      return extended;
    }
  }
LABEL_10:
  uint64_t v17 = *(void *)(a2 + 376);
  unint64_t v18 = *(void *)(v17 + 56);
  if (!v18) {
    return 0;
  }
  int v19 = *(_DWORD *)(v17 + 44);
  long long v30 = 0u;
  long long v31 = 0u;
  uint64_t v35 = 0;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v32 = 0u;
  uint64_t v29 = omap_snapshot_key_cmp;
  DWORD2(v30) = 19;
  if ((unsigned __int16)v19 != 2)
  {
    uint64_t extended = 22;
    goto LABEL_17;
  }
  uint64_t extended = btree_get_extended(a1, v19 & 0xFFFF0000, v18, 0, 0, (uint64_t)&v29, 0, &v28);
  if (extended)
  {
LABEL_17:
    obj_type(a1);
    log_err((uint64_t)"%s:%d: %s unable to get omap snapshot tree: %d\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"nx_check_recent_sanity_omap");
    return extended;
  }
  if (obj_xid((uint64_t)v28) <= a3) {
    uint64_t extended = 0;
  }
  else {
    uint64_t extended = btree_check_recent_sanity(v28, a3, 0, 0);
  }
  obj_release(v28);
  return extended;
}

uint64_t parse_str_to_role(const char *a1)
{
  if (strnlen(a1, 2uLL) > 1) {
    return -1;
  }
  int v3 = *a1;
  switch(*a1)
  {
    case 'S':
      return 448;
    case 'T':
    case 'U':
    case 'V':
    case 'W':
    case 'X':
    case 'Y':
    case 'Z':
    case '[':
    case '\\':
    case ']':
    case '^':
    case '_':
    case 'c':
    case 'f':
    case 'g':
    case 'j':
    case 'l':
    case 'm':
    case 'q':
    case 't':
    case 'w':
      return -1;
    case 'a':
      return 128;
    case 'b':
      return 16;
    case 'd':
      return 64;
    case 'e':
      return 576;
    case 'h':
      return 320;
    case 'i':
      return 32;
    case 'k':
      return 384;
    case 'n':
      return 512;
    case 'o':
      return 704;
    case 'p':
      return 192;
    case 'r':
      return 4;
    case 's':
      return 1;
    case 'u':
      return 2;
    case 'v':
      return 8;
    case 'x':
      return 256;
    default:
      if (v3 == 48)
      {
        uint64_t result = 0;
      }
      else
      {
        if (v3 != 68) {
          return -1;
        }
        uint64_t result = 640;
      }
      break;
  }
  return result;
}

uint64_t file_type_to_dirent_type(unsigned int a1)
{
  unsigned int v1 = (a1 >> 12) ^ 8;
  if (v1 == 15) {
    return 0;
  }
  else {
    return word_10007EBD8[v1];
  }
}

unint64_t calc_overlap_range(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t *a5)
{
  unint64_t v5 = a2 + a1;
  unint64_t v6 = a4 + a3;
  if (a2 + a1 > a3)
  {
    BOOL v7 = v6 >= a1;
    BOOL v8 = v6 == a1;
  }
  else
  {
    BOOL v7 = 0;
    BOOL v8 = 0;
  }
  BOOL v9 = !v8 && v7 && v5 >= a1;
  if (!v9 || v6 < a3) {
    return 0;
  }
  if (a1 <= a3) {
    unint64_t v11 = a3;
  }
  else {
    unint64_t v11 = a1;
  }
  if (v5 >= v6) {
    unint64_t v5 = a4 + a3;
  }
  if (a5) {
    *a5 = v11;
  }
  return v5 - v11;
}

uint64_t apfs_update_dev_name(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = *(void *)(result + 496);
    uint64_t v2 = (char *)(result + 4000);
    if (v1) {
      return snprintf(v2, 0x20uLL, "%ss%d:%lld");
    }
    else {
      return snprintf(v2, 0x20uLL, "%ss%d");
    }
  }
  return result;
}

uint64_t sub_100042078(uint64_t a1)
{
  *(_DWORD *)(a1 + 32) = 1112756289;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 116) = 0x4000000200000002;
  *(_DWORD *)(a1 + 124) = 1073741826;
  *(int32x2_t *)(a1 + 1040) = vdup_n_s32(0x40000002u);
  *(_DWORD *)(a1 + 1068) = 2;
  *(_DWORD *)(a1 + 1104) = 2;
  return 0;
}

uint64_t sub_1000420C0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = sub_100042DD8(a1, *(_DWORD *)(v2 + 116));
  if (!v3)
  {
    uint64_t v3 = sub_100042DD8(a1, *(_DWORD *)(v2 + 120));
    if (!v3)
    {
      uint64_t v3 = sub_100042DD8(a1, *(_DWORD *)(v2 + 124));
      if (!v3)
      {
        uint64_t v5 = *(void *)(v2 + 56);
        if ((v5 & 0x20) != 0)
        {
          uint64_t v3 = sub_100042DD8(a1, *(_DWORD *)(v2 + 1040));
          if (v3) {
            return v3;
          }
          uint64_t v5 = *(void *)(v2 + 56);
        }
        if ((v5 & 0x40) == 0 || (uint64_t v3 = sub_100042DD8(a1, *(_DWORD *)(v2 + 1044)), !v3))
        {
          uint64_t v3 = sub_100042D30(a1 + 3296, (uint64_t)"apfs-stream-id-lock", 0x100u);
          if (!v3)
          {
            uint64_t v6 = sub_100042D30(a1 + 3424, (uint64_t)"apfs-dir-stats-id-lock", 0x10u);
            if (v6)
            {
              uint64_t v3 = v6;
LABEL_15:
              sub_100042D8C(a1 + 3296);
              return v3;
            }
            uint64_t v7 = initialize_phys_range_lock_state(a1 + 3632, 0x20u);
            if (v7)
            {
              uint64_t v3 = v7;
              sub_100042D8C(a1 + 3424);
              goto LABEL_15;
            }
            *(void *)(a1 + 376) = v2;
            *(void *)(a1 + 392) = *(void *)(*(void *)a1 + 392);
            new_lock((pthread_mutex_t *)(a1 + 1216));
            new_lock((pthread_mutex_t *)(a1 + 1280));
            new_lock((pthread_mutex_t *)(a1 + 1344));
            new_lock((pthread_mutex_t *)(a1 + 1408));
            new_lock((pthread_mutex_t *)(a1 + 1472));
            new_lock((pthread_mutex_t *)(a1 + 1664));
            new_lock((pthread_mutex_t *)(a1 + 1536));
            new_lock((pthread_mutex_t *)(a1 + 1600));
            new_lock((pthread_mutex_t *)(a1 + 1152));
            new_lock((pthread_mutex_t *)(a1 + 3232));
            new_lock((pthread_mutex_t *)(a1 + 1728));
            new_lock((pthread_mutex_t *)(a1 + 3912));
            new_rwlock((pthread_rwlock_t *)(a1 + 1792));
            new_rwlock((pthread_rwlock_t *)(a1 + 3008));
            new_rwlock((pthread_rwlock_t *)(a1 + 1992));
            rolling_stats_init(a1 + 3792, 0xE10u, 0x18u);
            apfs_update_dev_name(a1);
            *(void *)(a1 + 592) = 0;
            if ((*(unsigned char *)(*(void *)(a1 + 376) + 57) & 1) != 0 && !fs_is_fully_unencrypted(a1))
            {
              uint64_t v3 = 0;
              *(void *)(a1 + 688) = 1;
            }
            else
            {
              return 0;
            }
          }
        }
      }
    }
  }
  return v3;
}

uint64_t sub_100042320(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 3616);
  if (v2 && !*(_DWORD *)(*(void *)a1 + 912)) {
    obj_release(v2);
  }
  sub_100042D8C(a1 + 3424);
  sub_100042D8C(a1 + 3296);
  rolling_stats_destroy(a1 + 3792);
  free_rwlock((pthread_rwlock_t *)(a1 + 2808));
  free_rwlock((pthread_rwlock_t *)(a1 + 2600));
  free_rwlock((pthread_rwlock_t *)(a1 + 2400));
  free_rwlock((pthread_rwlock_t *)(a1 + 2192));
  free_rwlock((pthread_rwlock_t *)(a1 + 1992));
  free_rwlock((pthread_rwlock_t *)(a1 + 3008));
  free_rwlock((pthread_rwlock_t *)(a1 + 1792));
  free_lock((pthread_mutex_t *)(a1 + 3232));
  free_lock((pthread_mutex_t *)(a1 + 1152));
  free_lock((pthread_mutex_t *)(a1 + 1216));
  free_lock((pthread_mutex_t *)(a1 + 1536));
  free_lock((pthread_mutex_t *)(a1 + 1600));
  free_lock((pthread_mutex_t *)(a1 + 1408));
  free_lock((pthread_mutex_t *)(a1 + 1472));
  free_lock((pthread_mutex_t *)(a1 + 1664));
  free_lock((pthread_mutex_t *)(a1 + 1280));
  free_lock((pthread_mutex_t *)(a1 + 1344));
  free_lock((pthread_mutex_t *)(a1 + 1728));
  free_lock((pthread_mutex_t *)(a1 + 3912));
  release_phys_range_lock_state(a1 + 3632);
  apfs_keybag_free(*(void *)(a1 + 3736));
  return 0;
}

uint64_t sub_10004241C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v72 = 0;
  if (a4 < 0x14) {
    return 28;
  }
  if (*(_DWORD *)(a3 + 16) < 5u)
  {
    char v12 = a2;
    uint64_t v13 = obj_modify((void *)a1, 0, a5, a4, a5, a6, a7, a8);
    if (v13)
    {
      uint64_t v8 = v13;
      log_err((uint64_t)"%s:%d: %s failed to modify the apfs_t before reaping (error %d).\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"apfs_reap");
    }
    else if (v12)
    {
      spaceman_fs_bounds_clear(*(void **)(a1 + 392), a1, a5);
      obj_delete_and_free((uint64_t *)a1, a5);
      return 0;
    }
    else
    {
      switch(*(_DWORD *)(a3 + 16))
      {
        case 0:
          *(_DWORD *)(a3 + 16) = 1;
          goto LABEL_11;
        case 1:
LABEL_11:
          uint64_t v8 = sub_100042E10((void *)a1, a5, &v72, a3, v17, v18, v19, v20);
          if (v8) {
            return v8;
          }
          *(void *)a3 = 0;
          *(_DWORD *)(a3 + 16) = 2;
LABEL_13:
          uint64_t v8 = sub_100042FE4((void *)a1, a5, *(void *)(*(void *)(a1 + 376) + 144), &v72, (uint64_t *)a3);
          if (v8) {
            return v8;
          }
          uint64_t v28 = *(void *)(a1 + 376);
          if (*(void *)(v28 + 232) != *(void *)(v28 + 224))
          {
            log_err((uint64_t)"%s:%d: %s freed != alloced (%llu freed, %llu alloced)\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"apfs_reap");
            uint64_t v28 = *(void *)(a1 + 376);
          }
          uint64_t v29 = *(void *)(v28 + 56);
          if ((v29 & 0x20) == 0) {
            goto LABEL_23;
          }
          uint64_t v30 = supplemental_tree_destroy(a1, *(unsigned int *)(v28 + 1040), 5, a5, 0, 0, v26, v27);
          if (v30)
          {
            uint64_t v8 = v30;
            strerror(v30);
            log_err((uint64_t)"%s:%d: %s supplemental_tree_destroy(fext_tree) failed: %d (%s)\n", v31, v32, v33, v34, v35, v36, v37, (uint64_t)"apfs_reap");
          }
          else
          {
            uint64_t v28 = *(void *)(a1 + 376);
            uint64_t v29 = *(void *)(v28 + 56);
LABEL_23:
            if ((v29 & 0x40) != 0
              && (uint64_t v39 = supplemental_tree_destroy(a1, *(unsigned int *)(v28 + 1044), 6, a5, 0, 0, v26, v27),
                  v39))
            {
              uint64_t v8 = v39;
              strerror(v39);
              log_err((uint64_t)"%s:%d: %s supplemental_tree_destroy(pfkur_tree) failed: %d (%s)\n", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"apfs_reap");
            }
            else
            {
              *(_DWORD *)(a3 + 16) = 3;
LABEL_27:
              obj_cache_remove_new_fs_objects(*(void *)(*(void *)(a1 + 392) + 392), a1);
              uint64_t v47 = *(uint64_t **)(a1 + 3552);
              if (v47)
              {
                obj_release(v47);
                *(void *)(a1 + 3552) = 0;
              }
              uint64_t v48 = *(uint64_t **)(a1 + 3600);
              if (v48)
              {
                obj_release(v48);
                *(void *)(a1 + 3600) = 0;
              }
              uint64_t v49 = omap_destroy(a1, *(void *)(*(void *)(a1 + 376) + 128), a5, 0);
              if (v49)
              {
                uint64_t v8 = v49;
                log_err((uint64_t)"%s:%d: %s omap_destroy returned %d!\n", v50, v51, v52, v53, v54, v55, v56, (uint64_t)"apfs_reap");
              }
              else
              {
                uint64_t v8 = apfs_remove_volume_key(a1, a5);
                if (!v8)
                {
                  log_debug((uint64_t)"%s:%d: %s removed key for volume\n", v57, v58, v59, v60, v61, v62, v63, (uint64_t)"apfs_reap");
                  uint64_t v8 = apfs_keybag_purge(a1, a5);
                  if ((v8 & 0xFFFFFFFD) != 0)
                  {
                    log_err((uint64_t)"%s:%d: %s failed to delete unlock records, error = %d\n", v64, v65, v66, v67, v68, v69, v70, (uint64_t)"apfs_reap");
                  }
                  else
                  {
                    log_debug((uint64_t)"%s:%d: %s removed unlock records for volume\n", v64, v65, v66, v67, v68, v69, v70, (uint64_t)"apfs_reap");
                    uint64_t v71 = *(void *)(a1 + 376);
                    *(void *)(v71 + 976) = 0;
                    *(void *)(v71 + 1032) = 0;
                    *(void *)(v71 + 1048) = 0;
                    *(_OWORD *)(v71 + 128) = 0u;
                    *(_OWORD *)(v71 + 144) = 0u;
                    *(_OWORD *)(v71 + 1072) = 0u;
                    fs_sb_dirty(a1, a5);
                    *(_DWORD *)(a3 + 16) = 4;
                  }
                }
              }
            }
          }
          break;
        case 2:
          goto LABEL_13;
        case 3:
          goto LABEL_27;
        default:
          return 0;
      }
    }
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s bogus phase, %u\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"apfs_reap");
    return 5;
  }
  return v8;
}

uint64_t apfs_checkpoint_traverse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(unsigned char *)(a3 + 20) & 0x40) != 0) {
    return 0;
  }
  uint64_t v29 = 0;
  unint64_t v5 = *(void *)(*(void *)(a3 + 376) + 128);
  if (!v5) {
    goto LABEL_13;
  }
  uint64_t v9 = obj_get(*(void *)(a1 + 392), 0x40000000, v5, (int *)&om_desc, 0, a3, 0, 0, (uint64_t *)&v29);
  if (v9)
  {
    uint64_t v17 = v9;
    uint64_t v18 = *(void *)(a1 + 400);
    if (!v18 || !*(_DWORD *)(v18 + 76)) {
      log_err((uint64_t)"%s:%d: %s failed to get omap %lld: %d\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"apfs_checkpoint_traverse");
    }
    return v17;
  }
  uint64_t v17 = omap_checkpoint_traverse(a3, a2, (uint64_t)v29, a4);
  uint64_t v19 = v29[2];
  obj_release(v29);
  if (!v17)
  {
    if ((v19 & 0x4000000000) == 0) {
      return 0;
    }
LABEL_13:
    obj_set_skip_checkpoint_traverse(a3, 1);
    return 0;
  }
  uint64_t v27 = *(void *)(a1 + 400);
  if (!v27 || !*(_DWORD *)(v27 + 76)) {
    log_err((uint64_t)"%s:%d: %s omap checkpoint traverse (op %d) failed: %d\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"apfs_checkpoint_traverse");
  }
  return v17;
}

uint64_t get_vol_crypto(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 496);
  if (!v1) {
    uint64_t v1 = a1;
  }
  uint64_t v2 = *(void *)(*(void *)(v1 + 376) + 264) & 0x109;
  if (v2 > 7)
  {
    if (v2 == 8)
    {
      return 2;
    }
    else
    {
      if (v2 != 256) {
        goto LABEL_13;
      }
      return 3;
    }
  }
  else
  {
    if (v2)
    {
      if (v2 == 1) {
        return 0;
      }
LABEL_13:
      sub_100060068();
    }
    return 1;
  }
}

uint64_t apfs_get_fsroot_tree_ext(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t **a5)
{
  if (a2) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = a1;
  }
  uint64_t v10 = *(void *)(v9 + 376);
  int v11 = *(_DWORD *)(v10 + 116);
  unint64_t v12 = *(void *)(v10 + 136);
  memset(&v14[2], 0, 64);
  v14[0] = *(_OWORD *)off_100080888;
  v14[1] = unk_100080898;
  if ((*(unsigned char *)(v10 + 56) & 0x20) == 0 || (uint64_t result = authapfs_get_hash_args(a1, v14), !result))
  {
    if ((unsigned __int16)v11 == 2) {
      return btree_get_extended(a1, v11 & 0xFFFF0000, v12, a3, a4 != 0, (uint64_t)v14, a4, a5);
    }
    else {
      return 22;
    }
  }
  return result;
}

BOOL sub_100042A84(uint64_t a1, void *a2, unsigned int a3)
{
  return a3 >= 8 && (*a2 & 0xFFFFFFFFFFFFFFFLL) == *(void *)(*(void *)(a1 + 376) + 176) - 1;
}

BOOL apfs_has_secondary_fsroot(uint64_t a1)
{
  return (*(unsigned char *)(*(void *)(a1 + 376) + 57) & 1) != 0 && !fs_is_fully_unencrypted(a1);
}

uint64_t apfs_get_secondary_fsroot_tree_ext(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t **a5)
{
  if (a2) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = a1;
  }
  if ((*(unsigned char *)(*(void *)(a1 + 376) + 57) & 1) == 0) {
    return 45;
  }
  uint64_t v10 = *(void *)(v5 + 376);
  int v11 = *(_DWORD *)(v10 + 1104);
  unint64_t v12 = *(void *)(v10 + 1096);
  if (fs_is_fully_unencrypted(a1)) {
    return 45;
  }
  if ((unsigned __int16)v11 != 2) {
    return 22;
  }

  return btree_get_extended(a1, v11 & 0xFFFF0000, v12, a3, a4 != 0, (uint64_t)off_1000808E8, a4, a5);
}

uint64_t apfs_get_fsroot_tree(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t **a4)
{
  return apfs_get_fsroot_tree_ext(a1, 0, a2, a3, a4);
}

uint64_t apfs_get_secondary_fsroot_tree(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t **a4)
{
  return apfs_get_secondary_fsroot_tree_ext(a1, 0, a2, a3, a4);
}

uint64_t apfs_get_extentref_tree(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t **a4)
{
  if ((unsigned __int16)*(_DWORD *)(*(void *)(a1 + 376) + 120) == 2) {
    return btree_get_extended(a1, *(_DWORD *)(*(void *)(a1 + 376) + 120) & 0xFFFF0000, a2, 0, a3 != 0, (uint64_t)&off_100080948, a3, a4);
  }
  else {
    return 22;
  }
}

uint64_t apfs_get_snap_meta_tree(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v3 = *(void *)(a1 + 376);
  if ((unsigned __int16)*(_DWORD *)(v3 + 124) == 2) {
    return btree_get_extended(a1, *(_DWORD *)(v3 + 124) & 0xFFFF0000, *(void *)(v3 + 152), 0, a2 != 0, (uint64_t)&off_1000809A8, a2, a3);
  }
  else {
    return 22;
  }
}

uint64_t apfs_get_doc_id_tree_ext(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t **a6)
{
  if (a3) {
    uint64_t v6 = a3;
  }
  else {
    uint64_t v6 = a1;
  }
  uint64_t v7 = *(void *)(v6 + 376);
  if ((unsigned __int16)*(_DWORD *)(v7 + 1068) != 2) {
    return 22;
  }
  uint64_t v8 = 1072;
  if (a2) {
    uint64_t v8 = 1080;
  }
  return btree_get_extended(a1, *(_DWORD *)(v7 + 1068) & 0xFFFF0000, *(void *)(v7 + v8), a4, a5 != 0, (uint64_t)off_100080A08, a5, a6);
}

BOOL sub_100042CB4(uint64_t a1, _DWORD *a2, unsigned int a3)
{
  return a3 >= 4 && *a2 == *(_DWORD *)(*(void *)(a1 + 376) + 960) - 1;
}

uint64_t apfs_get_doc_id_tree(uint64_t a1, int a2, unint64_t a3, uint64_t a4, uint64_t **a5)
{
  return apfs_get_doc_id_tree_ext(a1, a2, 0, a3, a4, a5);
}

uint64_t apfs_doc_id_index_supported(uint64_t a1)
{
  int v1 = *(unsigned __int16 *)(*(void *)(a1 + 376) + 964);
  uint64_t result = 1;
  if (v1 > 63)
  {
    if (v1 != 64 && v1 != 576) {
      return 0;
    }
  }
  else
  {
    if (v1) {
      BOOL v3 = v1 == 2;
    }
    else {
      BOOL v3 = 1;
    }
    if (!v3) {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100042D30(uint64_t a1, uint64_t a2, unsigned int a3)
{
  *(_DWORD *)(a1 + 120) = a3;
  uint64_t v4 = _apfs_calloc(a3, 0x10uLL);
  *(void *)(a1 + 112) = v4;
  if (!v4) {
    return 12;
  }
  new_lock((pthread_mutex_t *)a1);
  new_cv((pthread_cond_t *)(a1 + 64));
  return 0;
}

void sub_100042D8C(uint64_t a1)
{
  free_cv((pthread_cond_t *)(a1 + 64));
  free_lock((pthread_mutex_t *)a1);
  uint64_t v2 = *(void **)(a1 + 112);
  uint64_t v3 = 16 * *(unsigned int *)(a1 + 120);

  _apfs_free(v2, v3);
}

uint64_t sub_100042DD8(uint64_t a1, int a2)
{
  if ((a2 | 0x40000000u) >> 30 == 1 && (unsigned __int16)a2 == 2) {
    return 0;
  }
  else {
    return nx_corruption_detected_int(*(void *)(*(void *)a1 + 392));
  }
}

uint64_t sub_100042E10(void *a1, uint64_t a2, unint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v12 = *(void *)(a4 + 8);
  if (!v12)
  {
    uint64_t next_snapshot_xid = omap_find_next_snapshot_xid((uint64_t)a1, 0, &v38);
    if (next_snapshot_xid)
    {
      uint64_t v20 = next_snapshot_xid;
      if (next_snapshot_xid == 2)
      {
LABEL_13:
        fs_delete_snapshot_metadata_tree((uint64_t)a1, a2, 0);
        return 0;
      }
      else
      {
        log_err((uint64_t)"%s:%d: %s Hit %d looking up first snapshot\n", v35, v36, a4, a5, a6, a7, a8, (uint64_t)"apfs_reap_snapshots");
      }
      return v20;
    }
    uint64_t v12 = v38;
    *(void *)(a4 + 8) = v38;
  }
  uint64_t v20 = fs_lookup_snapshot_metadata_by_xid((uint64_t)a1, v12, &v39, a4, a5, a6, a7, a8);
  if (v20)
  {
LABEL_3:
    log_err((uint64_t)"%s:%d: %s Couldn't find snapshot metadata for xid %llu\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"apfs_reap_snapshots");
  }
  else
  {
    while (1)
    {
      uint64_t v23 = v39;
      unint64_t v24 = *((void *)v39 + 2);
      if (v24)
      {
        uint64_t v25 = sub_100042FE4(a1, a2, v24, a3, (uint64_t *)a4);
        if (v25) {
          return v25;
        }
        uint64_t v23 = v39;
      }
      fs_delete_supplemental_tree((uint64_t)a1, 5, *((void *)v23 + 3), a2, 0);
      fs_delete_supplemental_tree((uint64_t)a1, 6, *((void *)v39 + 3), a2, 0);
      fs_delete_clone_superblock((uint64_t)a1, *((void *)v39 + 3), a2);
      uint64_t v26 = omap_find_next_snapshot_xid((uint64_t)a1, *(void *)(a4 + 8), &v38);
      if (v26) {
        break;
      }
      uint64_t v21 = v38;
      *(void *)a4 = 0;
      *(void *)(a4 + 8) = v21;
      uint64_t v22 = fs_lookup_snapshot_metadata_by_xid((uint64_t)a1, v21, &v39, v29, v30, v31, v32, v33);
      if (v22)
      {
        uint64_t v20 = v22;
        goto LABEL_3;
      }
    }
    uint64_t v20 = v26;
    if (v26 == 2) {
      goto LABEL_13;
    }
    log_err((uint64_t)"%s:%d: %s lookup_next_snapshot() returned %d\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"apfs_reap_snapshots");
  }
  return v20;
}

uint64_t sub_100042FE4(void *a1, uint64_t a2, unint64_t a3, unint64_t *a4, uint64_t *a5)
{
  uint64_t v60 = 0;
  memset(v59, 0, sizeof(v59));
  uint64_t v57 = 0;
  uint64_t v58 = 0;
  unint64_t v54 = 0;
  unint64_t v55 = 0;
  int v56 = 0;
  extentref_uint64_t tree = apfs_get_extentref_tree((uint64_t)a1, a3, 0, &v58);
  if (extentref_tree)
  {
    uint64_t v17 = extentref_tree;
    log_err((uint64_t)"%s:%d: apfs_get_extentref_tree(oid=%llu) returned %d\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"apfs_reap_extentref_blocks");
  }
  else
  {
    uint64_t v57 = *a5 & 0xFFFFFFFFFFFFFFFLL | 0x2000000000000000;
    bt_iterator_init_with_hint((uint64_t)v59, v58, 0, 4, (unint64_t *)&v57, 8, 8u, &v54, 0x14u, 0);
    if ((v18 & 0xFFFFFFFD) != 0)
    {
      uint64_t v17 = v18;
      log_err((uint64_t)"%s:%d: %s tree_iter_init() returned %d\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"apfs_reap_extentref_blocks");
    }
    else
    {
      while (1)
      {
        if (bt_iterator_ended((uint64_t)v59))
        {
          btree_delete((uint64_t)v58, a2, 0);
          uint64_t v17 = 0;
          goto LABEL_5;
        }
        unint64_t v34 = v57 & 0xFFFFFFFFFFFFFFFLL;
        *a5 = v57 & 0xFFFFFFFFFFFFFFFLL;
        if (v54 >> 60 == 1 && v55 <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v36 = v54 & 0xFFFFFFFFFFFFFFFLL;
          if ((v54 & 0xFFFFFFFFFFFFFFFLL) != 0)
          {
            if (apfs_free_data_blocks(a1, a2, v34, v54 & 0xFFFFFFFFFFFFFFFLL)) {
              log_err((uint64_t)"%s:%d: %s extent at lba %llu len %llu couldn't be freed: %d\n", v37, v38, v39, v40, v41, v42, v43, (uint64_t)"apfs_reap_extentref_blocks");
            }
          }
          else
          {
            log_err((uint64_t)"%s:%d: %s found bogus 0-length extent at lba %llu, ignoring\n", v27, v28, v29, v30, v31, v32, v33, (uint64_t)"apfs_reap_extentref_blocks");
          }
          unint64_t v44 = *a4 + v36;
          *a4 = v44;
          if (v44 > 0x4000) {
            break;
          }
        }
        uint64_t v45 = bt_iterator_next((uint64_t)v59);
        if ((v45 & 0xFFFFFFFD) != 0)
        {
          uint64_t v53 = v45;
          log_err((uint64_t)"%s:%d: %s iter_next returned %d\n", v46, v47, v48, v49, v50, v51, v52, (uint64_t)"apfs_reap_extentref_blocks");
          uint64_t v17 = v53;
          goto LABEL_5;
        }
      }
      uint64_t v17 = 36;
    }
  }
LABEL_5:
  if (v58) {
    obj_release(v58);
  }
  return v17;
}

uint64_t userfs_volume_is_mountable(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *a2 = 0;
  uint64_t v10 = *(void *)(a1 + 376);
  unsigned int v11 = *(unsigned __int16 *)(v10 + 964);
  if (v11 >= 3 && v11 != 64 && v11 != 576)
  {
    log_warn((uint64_t)"%s:%d: Refusing to mount volume with role: %u\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"userfs_volume_is_mountable");
    return 0;
  }
  if ((*(unsigned char *)(v10 + 48) & 2) != 0)
  {
    log_warn((uint64_t)"%s:%d: Refusing to mount conformance volume.\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"userfs_volume_is_mountable");
    return 0;
  }
  uint64_t v12 = *(void *)(v10 + 56);
  if ((v12 & 9) == 0)
  {
    log_warn((uint64_t)"%s:%d: Refusing to mount fully sensitive volume.\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"userfs_volume_is_mountable");
    return 0;
  }
  if ((v12 & 0x10) != 0)
  {
    log_warn((uint64_t)"%s:%d: Refusing to mount incomplete volume.\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"userfs_volume_is_mountable");
    return 0;
  }
  if (v11 == 1 && !uuid_is_null((const unsigned __int8 *)(v10 + 1008)))
  {
    log_warn((uint64_t)"%s:%d: Allowing read-only mount of read-only system volume.\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"userfs_volume_is_mountable");
    *a2 = 1;
  }
  if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 0x20) != 0)
  {
    log_warn((uint64_t)"%s:%d: Refusing to mount sealed volume.\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"userfs_volume_is_mountable");
    return 0;
  }
  if (apfs_has_secondary_fsroot(a1))
  {
    log_warn((uint64_t)"%s:%d: Refusing to mount a volume formatted with a secondary fs_root tree.\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"userfs_volume_is_mountable");
    return 0;
  }
  uint64_t v22 = *(void *)(a1 + 376);
  if ((*(unsigned char *)(v22 + 57) & 2) != 0)
  {
    log_warn((uint64_t)"%s:%d: Refusing to mount a volume formatted with expanded records.\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"userfs_volume_is_mountable");
    return 0;
  }
  uint64_t v20 = 1;
  if ((*(unsigned char *)(v22 + 48) & 8) != 0)
  {
    log_warn((uint64_t)"%s:%d: Allowing read-only mount of a volume with attribution tag records.\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"userfs_volume_is_mountable");
    *a2 = 1;
  }
  return v20;
}

void *_apfs_obj_zalloc(size_t size, uint64_t a2)
{
  if (size == 0x2000)
  {
    size_t v2 = qword_1000846B8;
  }
  else
  {
    size_t v2 = size;
    if (size == 4096) {
      size_t v2 = *(void *)((char *)&apfs_zone_infos + ((a2 << 63 >> 63) & 0x78) + 8);
    }
  }
  uint64_t result = malloc_type_calloc(1uLL, v2, 0x284387B2uLL);
  if (result) {
    atomic_fetch_add_explicit(&apfs_allocated_mem_total, v2, memory_order_relaxed);
  }
  return result;
}

void *_apfs_zalloc(unsigned int a1)
{
  size_t v1 = *((void *)&apfs_zone_infos + 3 * a1 + 1);
  uint64_t result = malloc_type_calloc(1uLL, v1, 0x284387B2uLL);
  if (result) {
    atomic_fetch_add_explicit(&apfs_allocated_mem_total, v1, memory_order_relaxed);
  }
  return result;
}

void *_apfs_calloc(size_t a1, size_t a2)
{
  uint64_t result = malloc_type_calloc(a1, a2, 0x284387B2uLL);
  if (result) {
    atomic_fetch_add_explicit(&apfs_allocated_mem_total, a2 * a1, memory_order_relaxed);
  }
  return result;
}

void _apfs_obj_zfree(void *a1, uint64_t a2, uint64_t a3)
{
  if (a2 == 0x2000)
  {
    if (!a1) {
      return;
    }
    uint64_t v4 = &qword_1000846B8;
  }
  else
  {
    uint64_t v3 = a2;
    if (a2 != 4096)
    {
      if (!a1) {
        return;
      }
      goto LABEL_9;
    }
    if (!a1) {
      return;
    }
    uint64_t v4 = (uint64_t *)((char *)&apfs_zone_infos + ((a3 << 63 >> 63) & 0x78) + 8);
  }
  uint64_t v3 = *v4;
LABEL_9:
  free(a1);
  atomic_fetch_add_explicit(&apfs_allocated_mem_total, -v3, memory_order_relaxed);
}

void _apfs_zfree(void *a1, unsigned int a2)
{
  if (a1)
  {
    uint64_t v2 = *((void *)&apfs_zone_infos + 3 * a2 + 1);
    free(a1);
    atomic_fetch_add_explicit(&apfs_allocated_mem_total, -v2, memory_order_relaxed);
  }
}

void _apfs_free(void *a1, uint64_t a2)
{
  if (a1)
  {
    free(a1);
    atomic_fetch_add_explicit(&apfs_allocated_mem_total, -a2, memory_order_relaxed);
  }
}

void *_apfs_malloc(size_t a1)
{
  uint64_t result = malloc_type_malloc(a1, 0x1CC27423uLL);
  if (result) {
    atomic_fetch_add_explicit(&apfs_allocated_mem_total, a1, memory_order_relaxed);
  }
  return result;
}

void *_apfs_realloc(void *a1, uint64_t a2, size_t size)
{
  uint64_t result = malloc_type_realloc(a1, size, 0x71D828B6uLL);
  if (result) {
    atomic_fetch_add_explicit(&apfs_allocated_mem_total, size - a2, memory_order_relaxed);
  }
  return result;
}

void update_size_tracking(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v15 = a4;
  if ((*(unsigned char *)(a2 + 64) & 2) != 0)
  {
    if (a4)
    {
      sub_100043764(a1, a2, a3, a4);
    }
    else
    {
      int v7 = fs_tx_enter(a1, 4, 2, 0, &v15);
      if (v7)
      {
        strerror(v7);
        log_err((uint64_t)"%s:%d: %s failed to enter tx to update size tracking for ino %llu: %s (%d); size tracking may go out of sync\n",
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v14,
          (uint64_t)"update_size_tracking");
      }
      else
      {
        sub_100043764(a1, a2, a3, v15);
        fs_tx_leave(a1, 4, 2, 0, v15);
      }
    }
  }
}

void sub_100043764(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  if ((*(unsigned char *)(a2 + 64) & 2) != 0)
  {
    uint64_t __dst = 0;
    if (xf_get((unsigned __int16 *)(a2 + 408), 10, 0, (char *)&__dst, 8uLL) || !__dst)
    {
      if (nx_ratelimit_log_allowed(*(void *)(a1 + 392))) {
        log_err((uint64_t)"%s:%d: %s ino %llu is flagged to maintain dir-stats but has no dir-stats key\n", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"update_dir_stats");
      }
    }
    else
    {
      sub_100043820(a1, __dst, a3, 0, 0, a4);
    }
  }
}

uint64_t sub_100043820(uint64_t a1, uint64_t a2, void *a3, unsigned int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v48 = 0;
  if ((*(void *)(*(void *)(a1 + 376) + 56) & 0x200) != 0) {
    char v9 = 18;
  }
  else {
    char v9 = 10;
  }
  LOBYTE(v48) = v9;
  WORD1(v48) = 0;
  uint64_t v49 = a2;
  uint64_t v50 = 0;
  long long v51 = *(_OWORD *)a3;
  uint64_t v52 = a3[4];
  long long v55 = 0u;
  long long v54 = 0u;
  long long v53 = 0u;
  xf_init((uint64_t)&v54, 0);
  if (a3[2])
  {
    HIDWORD(v55) |= 4u;
    xf_set((unsigned __int16 *)&v54, 1, 0, a3 + 2, 8uLL);
  }
  if (a3[3])
  {
    HIDWORD(v55) |= 8u;
    xf_set((unsigned __int16 *)&v54, 3, 0, a3 + 3, 8uLL);
  }
  int v14 = (a4 >> 5) & 1;
  unsigned int v15 = a4 & 0xFFFFFFDF;
  if (a3[5])
  {
    HIDWORD(v55) |= 0x800u;
    xf_set((unsigned __int16 *)&v54, 4, 0, a3 + 5, 8uLL);
  }
  uint64_t v16 = 0;
  LOBYTE(v17) = 0;
  unsigned int v18 = 0;
  int v19 = v14;
  while (1)
  {
    BYTE1(v48) = 4;
    DWORD2(v55) = v15;
    *(void *)&long long v53 = a3[6];
    if (v14) {
      int v20 = 32;
    }
    else {
      int v20 = 0;
    }
    int v21 = v15 | v20;
    if (v17) {
      v21 |= 0x100000u;
    }
    if (v14 & 1) != 0 || (v17) {
      DWORD2(v55) = v21;
    }
    if (v19 == 1)
    {
      int v22 = 0x4000;
      goto LABEL_24;
    }
    if (v19 == 2)
    {
      DWORD2(v55) = v21 | 0x40;
      if (v49 == v16)
      {
        int v22 = 16448;
LABEL_24:
        DWORD2(v55) = v21 | v22;
      }
    }
    int inserted = insert_jobj(a1, 1, (unsigned __int8 *)&v48, a6, v10, v11, v12, v13);
    if ((inserted & 0xFFFFFFFD) != 0)
    {
      strerror(inserted);
      log_err((uint64_t)"%s:%d: %s failed to update dir-stats %llu: %s (%d)\n", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"update_dir_stats_by_key_ext");
    }
    if ((DWORD2(v55) & 0x400000) == 0) {
      break;
    }
    char v33 = 0;
    if (!v49) {
      goto LABEL_51;
    }
LABEL_48:
    if (v33) {
      goto LABEL_51;
    }
    if (++v18 == 1025) {
      goto LABEL_52;
    }
  }
  if (v19)
  {
    uint64_t v31 = v49;
    int v32 = BYTE8(v55) & 0x20;
  }
  else
  {
    int v32 = BYTE8(v55) & 0x20;
    uint64_t v31 = v49;
    if ((BYTE8(v55) & 0x40) != 0) {
      uint64_t v34 = v49;
    }
    else {
      uint64_t v34 = v16;
    }
    if ((BYTE8(v55) & 0x20) != 0)
    {
      int v19 = 1;
    }
    else
    {
      int v32 = 0;
      uint64_t v16 = v34;
      int v19 = (BYTE8(v55) & 0x40) >> 5;
    }
  }
  LOBYTE(v14) = v32 != 0;
  int v17 = (DWORD2(v55) >> 20) & 1;
  if (a5) {
    BOOL v35 = v31 == a5;
  }
  else {
    BOOL v35 = 0;
  }
  uint64_t v36 = *((void *)&v53 + 1);
  char v33 = v35 || v31 == *((void *)&v53 + 1);
  uint64_t v49 = *((void *)&v53 + 1);
  *((void *)&v53 + 1) = 0;
  if (v36) {
    goto LABEL_48;
  }
LABEL_51:
  if (v18 < 0x400) {
    return xf_release((uint64_t)&v54);
  }
LABEL_52:
  if (nx_ratelimit_log_allowed(*(void *)(a1 + 392))) {
    log_err((uint64_t)"%s:%d: %s stopped updating dir-stats due to chain being too long\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"update_dir_stats_by_key_ext");
  }
  return xf_release((uint64_t)&v54);
}

uint64_t needs_ctx()
{
  return 0;
}

uint64_t crypto_cache_create(uint64_t a1)
{
  *(void *)(a1 + 1008) = 0;
  return 0;
}

uint64_t crypto_obj_release(void *a1)
{
  uint64_t v2 = (unsigned __int16 *)*((void *)a1 + 9);
  if (v2) {
    cpx_free(v2);
  }
  *((_OWORD *)a1 + 4) = 0u;
  *((_OWORD *)a1 + 5) = 0u;
  *((_OWORD *)a1 + 2) = 0u;
  *((_OWORD *)a1 + 3) = 0u;
  *(_OWORD *)a1 = 0u;
  *((_OWORD *)a1 + 1) = 0u;
  _apfs_free(a1, 96);
  return 0;
}

uint64_t parse_os_version(char *a1)
{
  int v1 = *a1;
  if ((v1 - 48) > 9) {
    return 0;
  }
  int v2 = 0;
  do
  {
    uint64_t v3 = a1;
    int v2 = v1 + 10 * v2 - 48;
    int v4 = *++a1;
    int v1 = v4;
  }
  while ((v4 - 48) < 0xA);
  if (!v2 || v1 == 0) {
    return 0;
  }
  int v6 = v3[2];
  if ((v6 - 48) > 9) {
    return 0;
  }
  int v7 = 0;
  uint64_t v8 = 2;
  do
  {
    int v7 = v6 + 10 * v7 - 48;
    int v6 = a1[v8++];
  }
  while ((v6 - 48) < 0xA);
  unsigned int v9 = (v1 << 16) | (v2 << 24) | (unsigned __int16)v7;
  if (v7) {
    return v9;
  }
  else {
    return 0;
  }
}

uint64_t cp_os_version()
{
  uint64_t result = dword_100084A38;
  if (!dword_100084A38)
  {
    memset(v9, 0, sizeof(v9));
    size_t v8 = 63;
    sysctlbyname("kern.osversion", v9, &v8, 0, 0);
    *((unsigned char *)v9 + v8) = 0;
    if (LOBYTE(v9[0]))
    {
      uint64_t result = parse_os_version((char *)v9);
      dword_100084A38 = result;
      if (!result)
      {
        uint64_t result = 1;
        dword_100084A38 = 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t wrap_crypto_state(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(a3 + 20) = *(void *)(a2 + 48);
  int v3 = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(a2 + 12);
  *(_DWORD *)(a3 + 32) = v3;
  *(_WORD *)(a3 + 36) = *(_WORD *)(a2 + 60);
  return 0;
}

uint64_t crypto_state_init()
{
  return 45;
}

uint64_t crypto_state_disable(uint64_t result)
{
  *(_DWORD *)(result + 52) |= 1u;
  return result;
}

uint64_t meta_crypto_state_init(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  *(void *)a5 = 0;
  *(void *)(a5 + 8) = 0;
  *(_DWORD *)(a5 + 16) = 0;
  *(_DWORD *)a5 = 5;
  *(_DWORD *)(a5 + 8) = 6;
  uint64_t update_record = 0;
  *(_DWORD *)(a5 + 12) = cp_os_version();
  *(_WORD *)(a5 + 16) = 1;
  if (!*(unsigned char *)(a1[49] + 625))
  {
    if (a6) {
      *(void *)(a6 + 64) = 0;
    }
    if (a7) {
      *(void *)(a7 + 64) = 1;
    }
    if (apfs_has_secondary_fsroot((uint64_t)a1))
    {
      return 45;
    }
    else
    {
      int v17 = (void *)a1[62];
      if (!v17) {
        int v17 = a1;
      }
      if (*(unsigned char *)(v17[47] + 264))
      {
        return 0;
      }
      else if (*(_WORD *)(a1[47] + 964) == 1)
      {
        return 22;
      }
      else
      {
        memset(uu, 0, sizeof(uu));
        memset(dst, 0, sizeof(dst));
        uuid_clear(uu);
        if (a3)
        {
          uint64_t v25 = apfs_keybag_create((uint64_t)a1, a2);
          if (v25)
          {
            uint64_t update_record = v25;
            log_err((uint64_t)"%s:%d: %s unable to create apfs volume keybag (%d)\n", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"apfs_appex_meta_crypto_state_init");
          }
          else
          {
            v41[0] = a3;
            v41[1] = a4;
            uuid_copy(dst, (const unsigned __int8 *)(a1[47] + 240));
            uint64_t update_record = apfs_keybag_set_create_update_record(a1, a2, dst, (uint64_t)v41, uu, 0, 2, a9, 0);
            if (update_record) {
              log_err((uint64_t)"%s:%d: %s unable to create KEK/VEK in apfs volume keybag (%d)\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"apfs_appex_meta_crypto_state_init");
            }
            else {
              log_debug((uint64_t)"%s:%d: %s created apfs volume KEK/VEK\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"apfs_appex_meta_crypto_state_init");
            }
          }
        }
        else
        {
          uint64_t update_record = 22;
          log_err((uint64_t)"%s:%d: %s password is null (%d)\n", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"apfs_appex_meta_crypto_state_init");
        }
      }
    }
  }
  return update_record;
}

uint64_t apfs_kb_supports_class(uint64_t a1, unsigned int a2)
{
  if (a2 > 0x40) {
    return 0;
  }
  char v3 = a2;
  int vol_crypto = get_vol_crypto(a1);
  if (vol_crypto == 1)
  {
    int v9 = get_vol_crypto(a1);
    unint64_t v7 = 255;
    if (v9 != 1)
    {
      size_t v8 = "get_vol_crypto(apfs) == VOL_CPROTECTED";
LABEL_9:
      panic("assertion failed: %s", v8);
    }
    return (v7 >> v3) & 1;
  }
  if (vol_crypto == 3)
  {
    int v6 = get_vol_crypto(a1);
    unint64_t v7 = 223;
    if (v6 != 3)
    {
      size_t v8 = "get_vol_crypto(apfs) == VOL_PFKEY";
      goto LABEL_9;
    }
    return (v7 >> v3) & 1;
  }
  return 0;
}

void jobj_release(uint64_t a1, unsigned char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
  {
    switch(*a2)
    {
      case 1:
        _apfs_free(*((void **)a2 + 9), *((unsigned __int16 *)a2 + 32));
        goto LABEL_30;
      case 2:
        int v9 = a2;
        unint64_t v10 = 40;
        goto LABEL_36;
      case 3:
        if ((*((_WORD *)a2 + 48) & 0xF000) == 0xA000)
        {
          uint64_t v11 = (void *)*((void *)a2 + 44);
          if (v11)
          {
            _apfs_free(v11, *((int *)a2 + 90));
            *((void *)a2 + 44) = 0;
          }
        }
        xf_release((uint64_t)(a2 + 408));
        if ((a2[117] & 0x10) != 0)
        {
          free_rwlock((pthread_rwlock_t *)(a2 + 448));
          free_rwlock((pthread_rwlock_t *)(a2 + 120));
          *((void *)a2 + 14) &= ~0x100000000000uLL;
        }
        _apfs_zfree(a2, 2u);
        return;
      case 4:
        unint64_t v10 = *((unsigned __int16 *)a2 + 1);
        if (v10 <= 0x17) {
          sub_100060118();
        }
        goto LABEL_28;
      case 5:
        unint64_t v10 = *((unsigned __int16 *)a2 + 1);
        if (v10 <= 0x27) {
          sub_1000600C0();
        }
        goto LABEL_28;
      case 6:
      case 0xC:
        int v9 = a2;
        unint64_t v10 = 24;
        goto LABEL_36;
      case 7:
        unint64_t v10 = *((unsigned __int16 *)a2 + 1);
        if (v10 <= 0x27) {
          sub_100060094();
        }
        goto LABEL_28;
      case 8:
        int v9 = a2;
        unint64_t v10 = 56;
        goto LABEL_36;
      case 9:
        xf_release((uint64_t)(a2 + 32));
        _apfs_free(*((void **)a2 + 8), *((unsigned __int16 *)a2 + 31));
        goto LABEL_35;
      case 0xA:
      case 0x12:
        xf_release((uint64_t)(a2 + 64));
        int v9 = a2;
        unint64_t v10 = 96;
        goto LABEL_36;
      case 0xB:
        unint64_t v10 = *((unsigned __int16 *)a2 + 1);
        if (v10 <= 0x1F) {
          sub_1000600EC();
        }
        goto LABEL_28;
      case 0xD:
        int v12 = a2[16];
        if (v12 == 2) {
          goto LABEL_29;
        }
        if (v12 != 1) {
          return;
        }
        unint64_t v10 = *((unsigned __int16 *)a2 + 1);
        if (v10 <= 0x1F) {
          sub_100060144();
        }
LABEL_28:
        int v9 = a2;
LABEL_36:
        _apfs_free(v9, v10);
        break;
      case 0x10:
LABEL_29:
        xf_release((uint64_t)(a2 + 56));
LABEL_30:
        int v9 = a2;
        unint64_t v10 = 80;
        goto LABEL_36;
      case 0x11:
        int v9 = a2;
        unint64_t v10 = 32;
        goto LABEL_36;
      case 0x13:
        xf_release((uint64_t)(a2 + 48));
LABEL_35:
        int v9 = a2;
        unint64_t v10 = 72;
        goto LABEL_36;
      default:
        log_err((uint64_t)"%s:%d: *** Can't release unknown obj type %d\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_release");
        return;
    }
  }
}

void make_jkey_from_jobj(uint64_t a1, unsigned __int8 *a2, uint64_t a3, int *a4)
{
  uint64_t v8 = *a2;
  unsigned int v9 = *a2;
  unint64_t v10 = v8 << 60;
  BOOL v11 = (v8 & 0xF0) == 0;
  unint64_t v12 = 0xE000000000000000;
  if (v11) {
    unint64_t v12 = v10;
  }
  *(void *)a3 = v12 & 0xF000000000000000 | *((void *)a2 + 1) & 0xFFFFFFFFFFFFFFFLL;
  if (v9 >= 0x10)
  {
    if ((*(unsigned char *)(*(void *)(a1 + 376) + 57) & 2) == 0)
    {
      BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
      log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s ***: expanded obj type %d (obj_id %llu) found on unsupported volume\n", v14, v15, v16, v17, v18, v19, (uint64_t)"make_jkey_from_jobj");
      *a4 = 0;
      return;
    }
    if ((v9 & 0xFC) == 0x10)
    {
      *(_DWORD *)(a3 + 8) = v9;
    }
    else
    {
      BOOL v20 = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
      log_corrupt(v20, (uint64_t)"%s:%d: %s Cannot make large jkey from unknown type %d (obj_id %llu)\n", v21, v22, v23, v24, v25, v26, (uint64_t)"make_large_jkey_header_from_jobj");
      unsigned int v9 = *a2;
    }
  }
  switch(v9)
  {
    case 4u:
      size_t v28 = *((unsigned __int16 *)a2 + 10);
      *(_WORD *)(a3 + 8) = v28;
      memcpy((void *)(a3 + 10), a2 + 24, v28);
      int v29 = *((unsigned __int16 *)a2 + 10);
      goto LABEL_19;
    case 5u:
    case 8u:
      *(void *)(a3 + 8) = *((void *)a2 + 2);
      int v27 = 16;
      goto LABEL_26;
    case 9u:
      unsigned int v30 = *((unsigned __int16 *)a2 + 31);
      if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 9) != 0)
      {
        *(_DWORD *)(a3 + 8) = *((_WORD *)a2 + 31) & 0x3FF | (*((_DWORD *)a2 + 14) << 10);
        uint64_t v31 = (void *)(a3 + 12);
        int v32 = 12;
      }
      else
      {
        *(_WORD *)(a3 + 8) = v30;
        uint64_t v31 = (void *)(a3 + 10);
        int v32 = 10;
      }
      memcpy(v31, *((const void **)a2 + 8), v30);
      int v27 = v32 + *((unsigned __int16 *)a2 + 31);
      goto LABEL_26;
    case 0xAu:
      int v27 = 96;
      goto LABEL_26;
    case 0xBu:
      size_t v33 = *((unsigned __int16 *)a2 + 12);
      *(_WORD *)(a3 + 8) = v33;
      memcpy((void *)(a3 + 10), a2 + 26, v33);
      int v29 = *((unsigned __int16 *)a2 + 12);
LABEL_19:
      int v27 = v29 + 10;
      goto LABEL_26;
    case 0xDu:
      *a4 = 16;
      *(void *)(a3 + 8) = __ROR8__(*((void *)a2 + 2), 8);
      return;
    case 0xEu:
      *a4 = 0;
      BOOL v34 = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
      log_corrupt(v34, (uint64_t)"%s:%d: %s ***: expanded type seen on in-memory obj!\n", v35, v36, v37, v38, v39, v40, (uint64_t)"make_jkey_from_jobj");
      return;
    case 0x10u:
    case 0x13u:
      *(_OWORD *)(a3 + 12) = *((_OWORD *)a2 + 1);
      int v27 = 28;
      goto LABEL_26;
    case 0x11u:
      *(void *)(a3 + 12) = *((void *)a2 + 2);
      int v27 = 20;
      goto LABEL_26;
    case 0x12u:
      int v27 = 12;
      goto LABEL_26;
    default:
      int v27 = 8;
LABEL_26:
      *a4 = v27;
      break;
  }
}

uint64_t jobj_to_key_val(uint64_t a1, unsigned __int16 *__src, uint64_t a3, int *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = *((void *)__src + 1);
  unsigned int v9 = *(unsigned __int8 *)__src;
  if (v9 <= 0xF) {
    unsigned __int8 v10 = *(unsigned char *)__src;
  }
  else {
    unsigned __int8 v10 = 14;
  }
  *(void *)a3 = v8 & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v10 << 60);
  unint64_t v11 = *a4;
  if ((v11 - 4096) < 0xFFFFF001) {
    return 22;
  }
  unsigned int v12 = a6;
  if (v9 < 0x10)
  {
    switch(v9)
    {
      case 1u:
        *(_OWORD *)a5 = *((_OWORD *)__src + 1);
        *(_OWORD *)(a5 + 16) = *((_OWORD *)__src + 2);
        *(void *)(a5 + 32) = *((void *)__src + 6);
        *(void *)(a5 + 40) = *((void *)__src + 7);
        size_t v17 = __src[32];
        *(_WORD *)(a5 + 48) = v17;
        strlcpy((char *)(a5 + 50), *((const char **)__src + 9), v17);
        goto LABEL_31;
      case 2u:
        int v48 = *((unsigned __int8 *)__src + 1);
        uint64_t v49 = *((void *)__src + 3);
        *(void *)a5 = *((void *)__src + 2) & 0xFFFFFFFFFFFFFFFLL | ((unint64_t)v48 << 60);
        *(void *)(a5 + 8) = v49;
        int v50 = *((_DWORD *)__src + 8);
        *(_DWORD *)(a5 + 16) = v50;
        if (v50 < 0 && v48 == 1)
        {
          log_debug((uint64_t)"%s:%d: inserting bad phy ext @ %p : kind %d refcnt %d\n", (uint64_t)__src, a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"jobj_to_key_val");
          panic("bad pext.\n");
        }
        goto LABEL_31;
      case 3u:
        *a4 = 8;
        *(void *)a5 = *((void *)__src + 2);
        *(void *)(a5 + 8) = *((void *)__src + 3);
        *(void *)(a5 + 16) = *((void *)__src + 4);
        *(void *)(a5 + 24) = *((void *)__src + 5);
        *(void *)(a5 + 32) = *((void *)__src + 6);
        *(void *)(a5 + 40) = *((void *)__src + 7);
        *(_DWORD *)(a5 + 56) = *((_DWORD *)__src + 18);
        *(void *)(a5 + 48) = *((void *)__src + 8);
        *(_DWORD *)(a5 + 60) = *((_DWORD *)__src + 19);
        *(_DWORD *)(a5 + 64) = *((_DWORD *)__src + 20);
        *(_DWORD *)(a5 + 68) = *((_DWORD *)__src + 21);
        *(_DWORD *)(a5 + 72) = *((_DWORD *)__src + 22);
        *(_DWORD *)(a5 + 76) = *((_DWORD *)__src + 23);
        *(_WORD *)(a5 + 80) = __src[48];
        *(_WORD *)(a5 + 82) = __src[49];
        *(void *)(a5 + 84) = *((void *)__src + 13);
        if (!__src[204]) {
          return 0;
        }
        uint64_t result = xf_serialize(__src + 204, (_WORD *)(a5 + 92), a6 - 92);
        if (!result) {
          return result;
        }
        log_debug((uint64_t)"%s:%d: %s failed to serialize ino %lld into jval of size %u\n", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"jobj_to_key_val");
        return 7;
      case 4u:
        size_t v41 = __src[10];
        *(_WORD *)(a3 + 8) = v41;
        if (v41 + 10 > v11) {
          return 7;
        }
        strlcpy((char *)(a3 + 10), (const char *)__src + 24, v41);
        *a4 = *(unsigned __int16 *)(a3 + 8) + 10;
        *(_WORD *)a5 = *((_DWORD *)__src + 4);
        size_t v42 = __src[11];
        *(_WORD *)(a5 + 2) = v42;
        memcpy((void *)(a5 + 4), (char *)__src + __src[10] + 24, v42);
        return 0;
      case 5u:
        uint64_t v43 = *((void *)__src + 3);
        *(void *)(a3 + 8) = *((void *)__src + 2);
        *a4 = 16;
        *(void *)a5 = v43;
        size_t v44 = __src[16];
        *(_WORD *)(a5 + 8) = v44;
        strlcpy((char *)(a5 + 10), (const char *)__src + 34, v44);
        return 0;
      case 6u:
        uint64_t result = 0;
        *(_DWORD *)a5 = *((_DWORD *)__src + 4);
        goto LABEL_33;
      case 7u:
        *a4 = 8;
        sub_100044D4C(__src, (_DWORD *)a5);
        return 0;
      case 8u:
        uint64_t v52 = *((void *)__src + 2);
        *(void *)(a3 + 8) = v52;
        *a4 = 16;
        unint64_t v53 = *((void *)__src + 5);
        if (HIBYTE(v53))
        {
          log_debug((uint64_t)"%s:%d: %s File extent too large (%llu > %llu): laddr %llu, paddr %llu\n", (uint64_t)__src, a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"jobj_to_key_val");
          __assert_rtn("jobj_to_key_val", "jobj.c", 1554, "0");
        }
        uint64_t v54 = *((void *)__src + 4);
        if (v54 == -1) {
          panic("fext %lld (pos %lld len %lld flags %x can not have crypto-id -1\n", v8, v52, *((void *)__src + 5), *((unsigned __int8 *)__src + 48));
        }
        uint64_t result = 0;
        uint64_t v55 = *((void *)__src + 3);
        *(void *)a5 = v53 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)__src + 48) << 56);
        *(void *)(a5 + 8) = v55;
        *(void *)(a5 + 16) = v54;
        return result;
      case 9u:
        size_t v56 = __src[31];
        if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 9) != 0)
        {
          if (v56 + 12 <= v11)
          {
            *(_DWORD *)(a3 + 8) = v56 & 0x3FF | (*((_DWORD *)__src + 14) << 10);
            uint64_t v57 = (char *)(a3 + 12);
            int v58 = 12;
            goto LABEL_62;
          }
        }
        else if (v56 + 10 <= v11)
        {
          *(_WORD *)(a3 + 8) = v56;
          uint64_t v57 = (char *)(a3 + 10);
          int v58 = 10;
LABEL_62:
          strlcpy(v57, *((const char **)__src + 8), v56);
          *a4 = v58 + __src[31];
          *(_WORD *)(a5 + 16) = __src[30];
          int v84 = __src[16];
          *(void *)a5 = *((void *)__src + 2);
          *(void *)(a5 + 8) = *((void *)__src + 3);
          if (v84)
          {
            uint64_t result = xf_serialize(__src + 16, (_WORD *)(a5 + 18), v12 - 18);
            if (!result) {
              return result;
            }
            log_debug((uint64_t)"%s:%d: failed to serialize drec %lld/%s into jval of size %u\n", v85, v86, v87, v88, v89, v90, v91, (uint64_t)"jobj_to_key_val");
          }
          return 0;
        }
        return 7;
      case 0xAu:
        uint64_t result = 0;
        *(_OWORD *)a5 = *(_OWORD *)(__src + 12);
        *(int8x16_t *)(a5 + 16) = vextq_s8(*((int8x16_t *)__src + 3), *((int8x16_t *)__src + 3), 8uLL);
        goto LABEL_33;
      case 0xBu:
        size_t v59 = __src[12];
        *(_WORD *)(a3 + 8) = v59;
        if (v59 + 10 > v11) {
          return 7;
        }
        strlcpy((char *)(a3 + 10), (const char *)__src + 26, v59);
        uint64_t result = 0;
        int v45 = *(unsigned __int16 *)(a3 + 8) + 10;
LABEL_46:
        *a4 = v45;
        *(void *)a5 = *((void *)__src + 2);
        return result;
      case 0xCu:
        uint64_t result = 0;
        int v45 = 8;
        goto LABEL_46;
      case 0xDu:
        int v46 = *((unsigned __int8 *)__src + 16);
        if (v46 == 2)
        {
          if (__src[28] && xf_serialize(__src + 28, (_WORD *)(a5 + 26), a6 - 26))
          {
            log_debug((uint64_t)"%s:%d: %s failed to serialize file info with obj_id <%lld> into jval of size <%u>\n", v92, v93, v94, v95, v96, v97, v98, (uint64_t)"jobj_to_key_val");
            return 7;
          }
          *(_WORD *)(a5 + 24) = __src[24];
          *(void *)a5 = *((void *)__src + 3);
          *(void *)(a5 + 8) = *((void *)__src + 4);
          *(void *)(a5 + 16) = *((void *)__src + 5);
        }
        else
        {
          if (v46 != 1) {
            return 22;
          }
          size_t v47 = *((unsigned __int8 *)__src + 26);
          if (v47 + 3 > a6) {
            return 7;
          }
          *(unsigned char *)(a5 + 2) = v47;
          *(_WORD *)a5 = __src[12];
          memcpy((void *)(a5 + 3), (char *)__src + 27, v47);
        }
        uint64_t result = 0;
        *(void *)(a3 + 8) = __ROR8__(*((void *)__src + 2), 8);
        int v51 = 16;
        goto LABEL_34;
      case 0xEu:
        *a4 = 0;
        BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
        log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s ***: expanded type seen on in-memory obj!\n", v61, v62, v63, v64, v65, v66, (uint64_t)"jobj_to_key_val");
        return 22;
      default:
LABEL_31:
        uint64_t result = 0;
LABEL_33:
        int v51 = 8;
        goto LABEL_34;
    }
  }
  if ((*(unsigned char *)(*(void *)(a1 + 376) + 57) & 2) == 0)
  {
    log_err((uint64_t)"%s:%d: %s expanded obj type %hhu found on unsupported volume\n", (uint64_t)__src, a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"jobj_to_key_val");
    return 22;
  }
  if (v11 <= 0xB)
  {
    BOOL v18 = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
    log_corrupt(v18, (uint64_t)"%s:%d: %s large key size (%u) on record (%llu) is too small\n", v19, v20, v21, v22, v23, v24, (uint64_t)"jobj_to_key_val");
    return 22;
  }
  *(_DWORD *)(a3 + 8) = v9;
  switch(v9)
  {
    case 0x10u:
      int v25 = __src[28];
      *(_OWORD *)(a3 + 12) = *((_OWORD *)__src + 1);
      *(void *)a5 = *((void *)__src + 4);
      *(void *)(a5 + 8) = *((void *)__src + 5);
      *(_DWORD *)(a5 + 16) = *((_DWORD *)__src + 12);
      *(_DWORD *)(a5 + 20) = *((_DWORD *)__src + 13);
      if (!v25 || !xf_serialize(__src + 28, (_WORD *)(a5 + 24), a6 - 24)) {
        goto LABEL_59;
      }
      log_err((uint64_t)"%s:%d: %s failed to serialize purgeable %llu into jval of size %u\n", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"jobj_to_large_key_val");
      return 7;
    case 0x11u:
      uint64_t result = 0;
      uint64_t v67 = *((void *)__src + 3);
      *(void *)(a3 + 12) = *((void *)__src + 2);
      *(void *)a5 = v67;
      int v51 = 20;
      break;
    case 0x12u:
      int v68 = __src[32];
      *(void *)(a5 + 24) = *((void *)__src + 2);
      *(void *)a5 = *((void *)__src + 3);
      *(void *)(a5 + 8) = *((void *)__src + 4);
      *(void *)(a5 + 16) = *((void *)__src + 5);
      *(void *)(a5 + 32) = *((void *)__src + 7);
      *(void *)(a5 + 40) = *((void *)__src + 6);
      *(_DWORD *)(a5 + 48) = *((_DWORD *)__src + 23);
      if (!v68 || !xf_serialize(__src + 32, (_WORD *)(a5 + 52), a6 - 52)) {
        goto LABEL_54;
      }
      log_err((uint64_t)"%s:%d: %s failed to serialize dir-stats %lld into jval of size %u\n", v69, v70, v71, v72, v73, v74, v75, (uint64_t)"jobj_to_large_key_val");
      return 7;
    case 0x13u:
      int v76 = __src[24];
      *(_OWORD *)(a3 + 12) = *((_OWORD *)__src + 1);
      *(void *)a5 = *((void *)__src + 4) & 0xFFFFFFFFFFFFFFLL | ((unint64_t)*((_DWORD *)__src + 10) << 56);
      if (v76 && xf_serialize(__src + 24, (_WORD *)(a5 + 8), a6 - 8))
      {
        log_err((uint64_t)"%s:%d: %s failed to serialize clone mapping <%llu/%llu> into jval of size %u\n", v77, v78, v79, v80, v81, v82, v83, (uint64_t)"jobj_to_large_key_val");
        return 7;
      }
LABEL_59:
      uint64_t result = 0;
      int v51 = 28;
      break;
    default:
LABEL_54:
      uint64_t result = 0;
      int v51 = 12;
      break;
  }
LABEL_34:
  *a4 = v51;
  return result;
}

void *sub_100044D4C(_DWORD *__src, _DWORD *a2)
{
  int v2 = *((unsigned __int16 *)__src + 10);
  *a2 = __src[4];
  char v3 = a2 + 1;
  if (v2 == 6) {
    uint64_t v4 = HIBYTE(*((unsigned __int16 *)__src + 19)) + *((_WORD *)__src + 19);
  }
  else {
    uint64_t v4 = *((unsigned __int16 *)__src + 19);
  }
  return memcpy(v3, __src + 5, v4 + 20);
}

uint64_t key_size_for_jobj(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*a2 < 0xFu || (*(unsigned char *)(*(void *)(a1 + 376) + 57) & 2) != 0)
  {
    uint64_t result = 8;
    switch(*a2)
    {
      case 1u:
      case 2u:
      case 3u:
      case 6u:
      case 7u:
      case 0xAu:
      case 0xCu:
        return result;
      case 4u:
        uint64_t v17 = *((unsigned __int16 *)a2 + 10);
        goto LABEL_12;
      case 5u:
      case 8u:
      case 0xDu:
        return 16;
      case 9u:
        uint64_t v17 = *((unsigned __int16 *)a2 + 31);
        if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 9) == 0) {
          goto LABEL_12;
        }
        uint64_t result = v17 + 12;
        break;
      case 0xBu:
        uint64_t v17 = *((unsigned __int16 *)a2 + 12);
LABEL_12:
        uint64_t result = v17 + 10;
        break;
      case 0xEu:
        BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
        log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s ***: expanded type seen on in-memory obj!\n", v19, v20, v21, v22, v23, v24, (uint64_t)"key_size_for_jobj");
        return 0;
      case 0x10u:
      case 0x13u:
        uint64_t result = 28;
        break;
      case 0x11u:
        uint64_t result = 20;
        break;
      case 0x12u:
        uint64_t result = 12;
        break;
      default:
        log_err((uint64_t)"%s:%d: ***: unknown obj type %d\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"key_size_for_jobj");
        return 0;
    }
  }
  else
  {
    BOOL v9 = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
    log_corrupt(v9, (uint64_t)"%s:%d: %s ***: expanded obj type %d found on unsupported volume\n", v10, v11, v12, v13, v14, v15, (uint64_t)"key_size_for_jobj");
    return 0;
  }
  return result;
}

uint64_t val_size_for_jobj(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned __int8 *)a2 < 0xFu || (*(unsigned char *)(*(void *)(a1 + 376) + 57) & 2) != 0)
  {
    uint64_t result = 20;
    switch(*(unsigned char *)a2)
    {
      case 1:
        return a2[32] + 50;
      case 2:
        return result;
      case 3:
        if (a2[204]) {
          return (int)xf_get_size(a2 + 204) + 92;
        }
        else {
          return 92;
        }
      case 4:
        return a2[11] + 4;
      case 5:
        return a2[16] + 10;
      case 6:
        return 4;
      case 7:
        if (a2[10] == 6) {
          uint64_t size = HIBYTE(a2[19]) + a2[19];
        }
        else {
          uint64_t size = a2[19];
        }
        return size + 24;
      case 8:
        return 24;
      case 9:
        if (a2[16]) {
          return (int)xf_get_size(a2 + 16) + 18;
        }
        else {
          return 18;
        }
      case 0xA:
        return 32;
      case 0xB:
      case 0xC:
      case 0x11:
        return 8;
      case 0xD:
        int v17 = *((void *)a2 + 2);
        if (v17 == 2)
        {
          if (a2[28]) {
            return (int)xf_get_size(a2 + 28) + 26;
          }
          else {
            return 26;
          }
        }
        if (v17 == 1) {
          return *((unsigned __int8 *)a2 + 26) + 3;
        }
        log_err((uint64_t)"%s:%d: Unknown subtype %d for file info object %lld\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"val_size_for_jobj");
        break;
      case 0xE:
        log_err((uint64_t)"%s:%d: %s ***: expanded type seen on in-memory obj\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"val_size_for_jobj");
        return 0;
      case 0x10:
        if (!a2[28]) {
          return 24;
        }
        uint64_t size = (int)xf_get_size(a2 + 28);
        return size + 24;
      case 0x12:
        if (a2[32]) {
          return (int)xf_get_size(a2 + 32) + 52;
        }
        else {
          return 52;
        }
      case 0x13:
        if (a2[24]) {
          return (int)xf_get_size(a2 + 24) + 8;
        }
        else {
          return 8;
        }
      default:
        log_err((uint64_t)"%s:%d: ***: unknown obj type %d\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"val_size_for_jobj");
        return 0;
    }
  }
  else
  {
    BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
    log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s ***: expanded obj type %d found on unsupported volume\n", v9, v10, v11, v12, v13, v14, (uint64_t)"val_size_for_jobj");
  }
  return 0;
}

uint64_t jobj_validate_key_val(uint64_t a1, uint64_t a2, unint64_t a3, unsigned __int16 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!a2) {
    return 22;
  }
  switch(*(void *)a2 >> 60)
  {
    case 1:
      if (a3 < 8) {
        return 22;
      }
      if (!a4) {
        return 0;
      }
      unint64_t v9 = a5 - 50;
      if (a5 < 0x32) {
        return 22;
      }
      unint64_t v10 = a4[24];
      goto LABEL_35;
    case 2:
      if (a3 < 8 || a4 && a5 < 0x14) {
        return 22;
      }
      return 0;
    case 3:
      if (a3 < 8 || a4 && a5 < 0x5C) {
        return 22;
      }
      return 0;
    case 4:
      if (a3 < 0xA || a3 - 10 < *(unsigned __int16 *)(a2 + 8)) {
        return 22;
      }
      if (!a4) {
        return 0;
      }
      unint64_t v9 = a5 - 4;
      if (a5 < 4) {
        return 22;
      }
      unint64_t v10 = a4[1];
      goto LABEL_35;
    case 5:
      if (a3 < 0x10) {
        return 22;
      }
      if (!a4) {
        return 0;
      }
      unint64_t v9 = a5 - 10;
      if (a5 < 0xA) {
        return 22;
      }
      unint64_t v10 = a4[4];
      goto LABEL_35;
    case 6:
      if (a3 < 8 || a4 && a5 < 4) {
        return 22;
      }
      return 0;
    case 7:
      if (a3 < 8) {
        return 22;
      }
      if (!a4) {
        return 0;
      }
      unint64_t v9 = a5 - 24;
      if (a5 < 0x18) {
        return 22;
      }
      if (a4[2] == 6) {
        unint64_t v10 = HIBYTE(a4[11]) + a4[11];
      }
      else {
        unint64_t v10 = a4[11];
      }
LABEL_35:
      if (v9 < v10) {
        return 22;
      }
      return 0;
    case 8:
      if (a3 < 0x10 || a4 && a5 < 0x18) {
        return 22;
      }
      return 0;
    case 9:
      if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 9) != 0)
      {
        unint64_t v11 = a3 - 12;
        if (a3 < 0xC) {
          return 22;
        }
        unint64_t v12 = *(_DWORD *)(a2 + 8) & 0x3FF;
      }
      else
      {
        unint64_t v11 = a3 - 10;
        if (a3 < 0xA) {
          return 22;
        }
        unint64_t v12 = *(unsigned __int16 *)(a2 + 8);
      }
      if (v11 >= v12 && (!a4 || a5 >= 0x12)) {
        return 0;
      }
      return 22;
    case 0xALL:
      if (a3 < 8 || a4 && a5 < 0x20) {
        return 22;
      }
      return 0;
    case 0xBLL:
      if (a3 < 0xA || a3 - 10 < *(unsigned __int16 *)(a2 + 8)) {
        return 22;
      }
      goto LABEL_52;
    case 0xCLL:
      if (a3 < 8) {
        return 22;
      }
LABEL_52:
      if (!a4 || a5 >= 8) {
        return 0;
      }
      return 22;
    case 0xDLL:
      if (a3 < 0x10) {
        return 22;
      }
      if (*(unsigned char *)(a2 + 15) != 1)
      {
        if (a4 && a5 < 0x1A) {
          return 22;
        }
        return 0;
      }
      if (!a4 || (unint64_t)*((unsigned __int8 *)a4 + 2) + 3 <= a5) {
        return 0;
      }
      return 22;
    case 0xELL:
      if (a3 <= 0xB)
      {
        log_err((uint64_t)"%s:%d: %s key size (%zu) on expanded record (%llu) is too small\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_key_val");
        return 22;
      }
      return sub_10004547C(a1, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
    default:
      return 0;
  }
}

uint64_t sub_10004547C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(unsigned char *)(*(void *)(a1 + 376) + 57) & 2) != 0)
  {
    switch(*(unsigned char *)(a2 + 8))
    {
      case 0x10:
        if (a3 <= 0x1B)
        {
          log_err((uint64_t)"%s:%d: %s key size (%zu) on purgeable record (%llu) is too small\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
          return 22;
        }
        uint64_t result = 0;
        if (a4 && a5 <= 0x17)
        {
          log_err((uint64_t)"%s:%d: %s value size (%zu) on purgeable record (%llu) is too small\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
          return 22;
        }
        break;
      case 0x11:
        if (a3 <= 0x13)
        {
          log_err((uint64_t)"%s:%d: %s key size (%zu) on purgeable tombstone (%llu) is too small\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
          return 22;
        }
        uint64_t result = 0;
        if (a4 && a5 <= 7)
        {
          log_err((uint64_t)"%s:%d: %s value size (%zu) on purgeable tombstone (%llu) is too small\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
          return 22;
        }
        break;
      case 0x12:
        uint64_t result = 0;
        if (a4 && a5 <= 0x33)
        {
          log_err((uint64_t)"%s:%d: %s value size (%zu) on dir stats (%llu) is too small\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
          return 22;
        }
        break;
      case 0x13:
        if (a3 <= 0x1B)
        {
          log_err((uint64_t)"%s:%d: %s key size (%zu) on clone mapping (%llu) is too small\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
          return 22;
        }
        uint64_t result = 0;
        if (a4 && a5 <= 7)
        {
          log_err((uint64_t)"%s:%d: %s value size (%zu) on clone mapping (%llu) is too small\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
          return 22;
        }
        break;
      default:
        uint64_t result = 0;
        if (a4 && a5 <= 3)
        {
          log_err((uint64_t)"%s:%d: %s value size (%zu) on unknown record (%llu) is too small\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
          return 22;
        }
        break;
    }
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s ***: expanded obj type found on unsupported volume\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"jobj_validate_large_key_val");
    return 22;
  }
  return result;
}

uint64_t apfs_key_compare(uint64_t a1, void *a2, unsigned int a3, void *a4, unsigned int a5, int *a6)
{
  uint64_t v6 = 22;
  if (a3 >= 8 && a5 >= 8)
  {
    unint64_t v11 = *a2 & 0xFFFFFFFFFFFFFFFLL;
    unint64_t v12 = *a4 & 0xFFFFFFFFFFFFFFFLL;
    if (v11 < v12)
    {
LABEL_4:
      int v13 = -1;
LABEL_24:
      uint64_t v6 = 0;
      *a6 = v13;
      return v6;
    }
    if (v11 > v12) {
      goto LABEL_6;
    }
    uint64_t v14 = *a2 >> 60;
    uint64_t v15 = *a4 >> 60;
    if (!v14)
    {
      BOOL v25 = v15 == 0;
LABEL_21:
      if (v25) {
        int v13 = 0;
      }
      else {
        int v13 = -1;
      }
      goto LABEL_24;
    }
    if (!v15) {
      goto LABEL_6;
    }
    if (v14 < v15) {
      goto LABEL_4;
    }
    if (v14 > v15) {
      goto LABEL_6;
    }
    if (v14 != 14)
    {
LABEL_16:
      if (obj_type(a1) != 13) {
        return 22;
      }
      if (jobj_validate_key_val(a1, (uint64_t)a2, a3, 0, 0, v19, v20, v21)) {
        return 22;
      }
      int v13 = jobj_validate_key_val(a1, (uint64_t)a4, a5, 0, 0, v22, v23, v24);
      if (v13) {
        return 22;
      }
      switch((int)v14)
      {
        case 4:
        case 11:
          goto LABEL_27;
        case 5:
          unint64_t v31 = a2[1];
          unint64_t v32 = a4[1];
          if (!v31) {
            goto LABEL_60;
          }
          if (!v32) {
            break;
          }
          BOOL v33 = v31 >= v32;
          BOOL v34 = v31 > v32;
          goto LABEL_57;
        case 8:
          unint64_t v35 = a2[1];
          unint64_t v36 = a4[1];
          if (v35 == -1)
          {
            BOOL v25 = v36 == -1;
            goto LABEL_21;
          }
          if (v36 == -1) {
            break;
          }
          BOOL v37 = v35 > v36;
          if (v35 >= v36) {
            goto LABEL_73;
          }
          goto LABEL_4;
        case 9:
          if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 9) == 0)
          {
LABEL_27:
            uint64_t v27 = (unsigned __int8 *)a2 + 10;
            uint64_t v28 = (unsigned __int8 *)a4 + 10;
            unint64_t v29 = *((unsigned __int16 *)a2 + 4);
            unint64_t v30 = *((unsigned __int16 *)a4 + 4);
LABEL_28:
            int v13 = apfs_cstrncmp(v27, v28, v29, v30);
            goto LABEL_24;
          }
          unsigned int v38 = *((_DWORD *)a2 + 2);
          unsigned int v39 = *((_DWORD *)a4 + 2);
          if (v38 >> 10 < v39 >> 10) {
            goto LABEL_4;
          }
          if (v38 >> 10 <= v39 >> 10)
          {
            unint64_t v29 = v38 & 0x3FF;
            unint64_t v30 = v39 & 0x3FF;
            uint64_t v27 = (unsigned __int8 *)a2 + 12;
            uint64_t v28 = (unsigned __int8 *)a4 + 12;
            goto LABEL_28;
          }
          break;
        case 13:
          unint64_t v40 = a2[1];
          unint64_t v41 = HIBYTE(v40);
          unint64_t v42 = a4[1];
          unint64_t v43 = HIBYTE(v42);
          if (!HIBYTE(v40))
          {
            BOOL v25 = v43 == 0;
            goto LABEL_21;
          }
          if (!v43) {
            break;
          }
          if (v41 != v43)
          {
            if (v41 < v43) {
              int v13 = -1;
            }
            else {
              int v13 = 1;
            }
            goto LABEL_24;
          }
          unint64_t v52 = v40 & 0xFFFFFFFFFFFFFFLL;
          unint64_t v53 = v42 & 0xFFFFFFFFFFFFFFLL;
          if (v52 == 0xFFFFFFFFFFFFFFLL)
          {
            BOOL v25 = v53 == 0xFFFFFFFFFFFFFFLL;
            goto LABEL_21;
          }
          if (v53 == 0xFFFFFFFFFFFFFFLL) {
            break;
          }
          BOOL v33 = v52 >= v53;
          BOOL v47 = v52 == v53;
LABEL_54:
          BOOL v34 = !v47;
LABEL_57:
          if (v33) {
            int v13 = v34;
          }
          else {
            int v13 = -1;
          }
          goto LABEL_24;
        case 16:
          unint64_t v44 = *(void *)((char *)a2 + 12);
          unint64_t v32 = *(void *)((char *)a4 + 12);
          if (!v44) {
            goto LABEL_60;
          }
          if (!v32) {
            break;
          }
          if (v44 < v32) {
            goto LABEL_4;
          }
          if (v44 != v32)
          {
            BOOL v37 = v44 > v32;
LABEL_73:
            int v13 = v37;
            goto LABEL_24;
          }
          unint64_t v45 = *(void *)((char *)a2 + 20);
          unint64_t v32 = *(void *)((char *)a4 + 20);
          if (!v45)
          {
LABEL_60:
            BOOL v25 = v32 == 0;
            goto LABEL_21;
          }
          if (!v32) {
            break;
          }
          if (v45 >= v32)
          {
            int v13 = v45 != v32;
            goto LABEL_24;
          }
          goto LABEL_4;
        case 17:
          unint64_t v46 = *(void *)((char *)a2 + 12);
          unint64_t v32 = *(void *)((char *)a4 + 12);
          if (!v46) {
            goto LABEL_60;
          }
          if (!v32) {
            break;
          }
          BOOL v33 = v46 >= v32;
          BOOL v47 = v46 == v32;
          goto LABEL_54;
        case 19:
          unint64_t v48 = *(void *)((char *)a2 + 12);
          unint64_t v49 = *(void *)((char *)a4 + 12);
          if (v48 < v49) {
            goto LABEL_4;
          }
          if (v48 > v49) {
            break;
          }
          unint64_t v50 = *(void *)((char *)a2 + 20);
          unint64_t v51 = *(void *)((char *)a4 + 20);
          BOOL v37 = v50 > v51;
          if (v50 < v51) {
            goto LABEL_4;
          }
          goto LABEL_73;
        default:
          goto LABEL_24;
      }
LABEL_6:
      int v13 = 1;
      goto LABEL_24;
    }
    uint64_t v6 = 22;
    if (a3 >= 0xC && a5 >= 0xC)
    {
      LODWORD(v14) = *((unsigned __int8 *)a2 + 8);
      unsigned int v18 = *((unsigned __int8 *)a4 + 8);
      if (v14 < v18) {
        goto LABEL_4;
      }
      if (v14 > v18) {
        goto LABEL_6;
      }
      goto LABEL_16;
    }
  }
  return v6;
}

uint64_t create_or_modify_jobj(uint64_t a1, uint64_t *a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  uint64_t v13 = val_size_for_jobj(a1, (unsigned __int16 *)a3, (uint64_t)a3, a4, a5, a6, a7, a8);
  uint64_t v20 = key_size_for_jobj(a1, a3, v14, v15, v16, v17, v18, v19);
  unsigned int v47 = v20;
  uint64_t v21 = 22;
  if (v13 && v20)
  {
    if ((v20 & 7) != 0) {
      uint64_t v22 = (v20 & 0x1FFF8) + 8;
    }
    else {
      uint64_t v22 = v20;
    }
    uint64_t v23 = (v22 + v13);
    __chkstk_darwin();
    BOOL v25 = (unint64_t *)((char *)&v40 - v24);
    bzero((char *)&v40 - v24, v26);
    if (v23 < 0x251 || (BOOL v25 = (unint64_t *)_apfs_malloc((v22 + v13))) != 0)
    {
      uint64_t v40 = (uint64_t)&v40;
      unint64_t v29 = (char *)v25 + v22;
      uint64_t v21 = jobj_to_key_val(a1, (unsigned __int16 *)a3, (uint64_t)v25, (int *)&v47, (uint64_t)v25 + v22, v13, v27, v28);
      if (!v21)
      {
        switch(v8)
        {
          case 1:
            goto LABEL_14;
          case 2:
            if (*a3 == 3) {
              unint64_t v30 = (uint64_t *)(a3 + 320);
            }
            else {
              unint64_t v30 = 0;
            }
            uint64_t v21 = bt_update_with_hint((uint64_t)a2, *(void *)(a1 + 432), v25, v47, v29, v13, a4, v30);
            if (v21 != 28) {
              goto LABEL_24;
            }
LABEL_14:
            uint64_t v31 = bt_insert(a2, *(void *)(a1 + 432), v25, v47, v29, v13, a4);
LABEL_23:
            uint64_t v21 = v31;
            goto LABEL_24;
          case 3:
            uint64_t v46 = 0;
            long long v45 = 0u;
            long long v44 = 0u;
            memset(&v43[2], 0, 32);
            v43[0] = a1;
            v43[1] = a4;
            int v32 = *a3;
            if (v32 == 18 || v32 == 10)
            {
              HIDWORD(v46) = *((_DWORD *)a3 + 22);
              *((void *)&v45 + 1) = *((void *)a3 + 6);
            }
            break;
          case 4:
            uint64_t v31 = bt_remove(a2, *(void *)(a1 + 432), v25, v47, a4);
            goto LABEL_23;
          default:
            uint64_t v21 = 22;
            goto LABEL_24;
        }
        uint64_t v21 = bt_update_via_callback((uint64_t)a2, *(void *)(a1 + 432), v25, v47, (uint64_t)v29, v13, 1, a4, (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))sub_100046C5C, (uint64_t)v43);
        switch(*a3)
        {
          case 2u:
            *((_DWORD *)a3 + 8) = v43[2];
            break;
          case 3u:
          case 4u:
          case 5u:
          case 8u:
          case 9u:
          case 0xBu:
          case 0xCu:
            break;
          case 6u:
          case 7u:
            *((_DWORD *)a3 + 4) = v43[2];
            break;
          case 0xAu:
            goto LABEL_28;
          case 0xDu:
            if (a3[16] == 2) {
              *((void *)a3 + 3) = v43[2];
            }
            break;
          default:
            if (*a3 != 18) {
              break;
            }
LABEL_28:
            int v34 = *((_DWORD *)a3 + 22);
            if ((v34 & 8) != 0)
            {
              *(_OWORD *)(a3 + 24) = *(_OWORD *)&v43[3];
              uint64_t v39 = *((void *)&v45 + 1);
              *((void *)a3 + 5) = v43[5];
              *((void *)a3 + 6) = v39;
              *((_DWORD *)a3 + 23) = v46;
              unint64_t v35 = (unsigned __int16 *)(a3 + 64);
              xf_set((unsigned __int16 *)a3 + 32, 1, 0, &v44, 8uLL);
              xf_set((unsigned __int16 *)a3 + 32, 3, 0, (char *)&v44 + 8, 8uLL);
              unsigned int v38 = (uint64_t *)&v45;
              goto LABEL_42;
            }
            if ((v34 & 0x200) != 0)
            {
              *((void *)a3 + 6) = *((void *)&v45 + 1);
              *((_DWORD *)a3 + 23) = v46;
            }
            if ((v46 & 0x80000000000) != 0)
            {
              uint64_t v41 = 0;
              uint64_t __dst = 0;
              unint64_t v35 = (unsigned __int16 *)(a3 + 64);
              if (xf_get((unsigned __int16 *)a3 + 32, 3, 0, (char *)&__dst, 8uLL)) {
                uint64_t __dst = 0;
              }
              int v36 = xf_get((unsigned __int16 *)a3 + 32, 4, 0, (char *)&v41, 8uLL);
              uint64_t v37 = v41;
              if (v36) {
                uint64_t v37 = 0;
              }
              uint64_t v41 = v37 - v45;
              __dst -= *((void *)&v44 + 1);
              *((_DWORD *)a3 + 23) |= 8u;
              xf_set((unsigned __int16 *)a3 + 32, 3, 0, &__dst, 8uLL);
              if (v41)
              {
                *((_DWORD *)a3 + 23) |= 0x800u;
                unsigned int v38 = &v41;
LABEL_42:
                xf_set(v35, 4, 0, v38, 8uLL);
              }
            }
            *((void *)a3 + 7) = v43[2];
            *((_DWORD *)a3 + 22) = HIDWORD(v46);
            break;
        }
      }
LABEL_24:
      if (v23 >= 0x251) {
        _apfs_free(v25, v23);
      }
    }
    else
    {
      return 12;
    }
  }
  return v21;
}

uint64_t fs_obj_create_name_checked(uint64_t a1, uint64_t a2, uint64_t a3, char *__s, size_t a5, uint64_t a6, unsigned int a7, int a8, int a9, int a10, int a11, uint64_t a12, int a13, void *a14, uint64_t a15, int a16, unsigned int a17)
{
  BOOL v25 = a14;
  int v27 = a16;
  int v26 = a17;
  uint64_t v150 = 0;
  uint64_t v149 = a17;
  *a14 = 0;
  if (v27)
  {
    uint64_t v143 = v25;
    uint64_t v28 = a2;
    if (a3) {
      uint64_t v29 = *(void *)(a3 + 8);
    }
    else {
      uint64_t v29 = 1;
    }
LABEL_10:
    uint64_t v31 = dir_rec_alloc_with_hash(a1, 1, __s, a5, v26, v29, a6, &v150);
    HIDWORD(v149) = v31;
    if (!v31)
    {
      int v32 = _apfs_zalloc(2u);
      if (!v32)
      {
        jobj_release(0, v150, v33, v34, v35, v36, v37, v38);
        return 12;
      }
      uint64_t v39 = v32;
      uint64_t v142 = v29;
      uint64_t v40 = a15;
      uint64_t timestamp = get_timestamp();
      *((void *)v150 + 3) = timestamp;
      __int16 v42 = file_type_to_dirent_type(a7);
      unint64_t v43 = v150;
      *((_WORD *)v150 + 30) = v42;
      int inserted = insert_jobj(a1, v28, v43, v40, v44, v45, v46, v47);
      if (inserted)
      {
        strerror(inserted);
        log_err((uint64_t)"%s:%d: %s %s: could not insert dir rec for obj-id %lld (name: %s)\n", v49, v50, v51, v52, v53, v54, v55, (uint64_t)"fs_obj_create_name_checked");
        jobj_release(v56, v150, v57, v58, v59, v60, v61, v62);
        _apfs_zfree(v39, 2u);
        return 22;
      }
      *uint64_t v39 = 42467587;
      *((void *)v39 + 1) = a6;
      *((void *)v39 + 2) = v142;
      *((void *)v39 + 6) = timestamp;
      *((void *)v39 + 7) = timestamp;
      *((void *)v39 + 4) = timestamp;
      *((void *)v39 + 5) = timestamp;
      *((void *)v39 + 3) = a6;
      *((_WORD *)v39 + 48) = a7;
      v39[22] = a8;
      v39[23] = a9;
      v39[20] = 1;
      v39[21] = a10;
      if ((a7 & 0xF000) != 0x4000) {
        v39[18] = 1;
      }
      new_rwlock((pthread_rwlock_t *)(v39 + 112));
      new_rwlock((pthread_rwlock_t *)(v39 + 30));
      *((void *)v39 + 14) |= 0x100000000000uLL;
      uint64_t v63 = 48;
      if ((a7 & 0xF000) != 0x8000) {
        uint64_t v63 = 0;
      }
      xf_init((uint64_t)(v39 + 102), v63 + *((unsigned __int16 *)v150 + 31));
      xf_set((unsigned __int16 *)v39 + 204, 4, 2, *((void **)v150 + 8), *((unsigned __int16 *)v150 + 31));
      if ((v39[24] & 0xB000 | 0x4000) == 0x6000)
      {
        if ((*(unsigned char *)(*(void *)(a1 + 376) + 57) & 2) != 0)
        {
          v39[26] = a11;
        }
        else
        {
          uint64_t v68 = xf_set((unsigned __int16 *)v39 + 204, 14, 34, &a11, 4uLL);
          if (v68)
          {
            uint64_t v31 = v68;
            log_err((uint64_t)"%s:%d: %s *** failed to set rdev as an extended field of ino %lld (ret %d)\n", v69, v70, v71, v64, v65, v66, v67, (uint64_t)"fs_obj_create_name_checked");
            jobj_release(v72, v39, v73, v74, v75, v76, v77, v78);
            uint64_t v39 = 0;
            goto LABEL_64;
          }
        }
      }
      if (a3)
      {
        *((void *)v39 + 8) = *(void *)(a3 + 64) & 0x20400002;
        if ((*(unsigned char *)(a3 + 64) & 2) != 0)
        {
          uint64_t __dst = 0;
          if (xf_get((unsigned __int16 *)(a3 + 408), 10, 0, (char *)&__dst, 8uLL))
          {
            if (nx_ratelimit_log_allowed(*(void *)(a1 + 392))) {
              log_err((uint64_t)"%s:%d: %s ino %llu is flagged to maintain dir-stats but has no dir-stats key\n", v86, v87, v88, v64, v65, v66, v67, (uint64_t)"fs_obj_create_name_checked");
            }
          }
          else
          {
            xf_set((unsigned __int16 *)v39 + 204, 10, 34, &__dst, 8uLL);
          }
        }
        if ((v39[24] & 0xF000) == 0x8000 && (*(unsigned char *)(a3 + 67) & 2) != 0)
        {
          *((void *)v39 + 8) |= 0x100000uLL;
          uint64_t __dst = get_pending_purgeable_flags_from_ino(a3);
          xf_set((unsigned __int16 *)v39 + 204, 15, 2, &__dst, 8uLL);
        }
      }
      int v97 = a13;
      uint64_t v98 = a12;
      __int16 v99 = *((_WORD *)v39 + 48);
      if ((v99 & 0xF000) == 0x4000)
      {
        uint64_t v100 = *(void *)(a1 + 376);
        if ((*(unsigned char *)(v100 + 57) & 2) != 0)
        {
          v39[26] = 0;
        }
        else if ((*(unsigned char *)(v100 + 48) & 2) != 0)
        {
          uint64_t __dst = 0;
          xf_set((unsigned __int16 *)v39 + 204, 17, 0, &__dst, 8uLL);
          __int16 v99 = *((_WORD *)v39 + 48);
        }
      }
      *((void *)v39 + 14) |= 0x200000000uLL;
      *((void *)v39 + 8) |= v98 | 0x8000;
      v39[19] = v97;
      if ((v99 & 0xF000) == 0x8000 && get_vol_crypto(a1) == 3)
      {
        LODWORD(__dst) = 0;
        if (ino_get_class_check(a1, (uint64_t)v39, (int *)&__dst))
        {
          if (__dst == 6) {
            panic("assertion failed: %s", "ino_poison_vnode(apfs, inode)");
          }
        }
      }
      uint64_t v79 = insert_jobj(a1, v28, (unsigned __int8 *)v39, v40, v64, v65, v66, v67);
      if (v79)
      {
        uint64_t v31 = v79;
        strerror(v79);
        log_err((uint64_t)"%s:%d: %s %s: could not insert inode obj-id %lld (name: %s)\n", v101, v102, v103, v104, v105, v106, v107, (uint64_t)"fs_obj_create_name_checked");
        uint64_t v108 = v150;
        v150[1] = 3;
        uint64_t v113 = remove_jobj(a1, v28, v108, v40, v109, v110, v111, v112);
        uint64_t v120 = v143;
        if (v113)
        {
          strerror(v113);
          log_err((uint64_t)"%s:%d: %s %s: could not remove dir rec for obj-id %lld (name: %s)\n", v121, v122, v123, v124, v125, v126, v127, (uint64_t)"fs_obj_create_name_checked");
        }
        jobj_release(v113, v39, v114, v115, v116, v117, v118, v119);
        uint64_t v39 = 0;
        goto LABEL_65;
      }
      if (a3)
      {
        uint64_t v128 = v28;
        if (v28 != 4 || v142 != 2)
        {
          update_time(a1, (void *)a3, 3);
          long long v146 = 0u;
          long long v147 = 0u;
          long long v145 = 0u;
          uint64_t v144 = 1;
          update_size_tracking(a1, a3, &v144, v40);
          uint64_t v120 = v143;
          if ((v39[24] & 0xF000) == 0x4000) {
            apfs_inc_parent_nlink(a1, a3);
          }
          ++*(_DWORD *)(a3 + 72);
          ++*(_DWORD *)(a3 + 80);
          *(unsigned char *)(a3 + 1) = 2;
          uint64_t v79 = insert_jobj(a1, v128, (unsigned __int8 *)a3, v40, v130, v131, v132, v133);
          uint64_t v31 = v79;
          if (v79)
          {
            log_err((uint64_t)"%s:%d: %s failed to update parent ino %lld nchildren field on create of %s (err %d)\n", v134, v80, v81, v82, v83, v84, v85, (uint64_t)"fs_obj_create_name_checked");
            jobj_release(v135, v39, v136, v137, v138, v139, v140, v141);
            uint64_t v39 = 0;
          }
          goto LABEL_65;
        }
      }
      uint64_t v31 = 0;
LABEL_64:
      uint64_t v120 = v143;
LABEL_65:
      jobj_release(v79, v150, v80, v81, v82, v83, v84, v85);
      *uint64_t v120 = v39;
      return v31;
    }
    return v31;
  }
  if (!a5) {
    a5 = strlen(__s);
  }
  if (a5 > 0x2FD) {
    return 63;
  }
  unint64_t v30 = utf8_strlen_with_ascii_status((uint64_t)__s, a5, 1u, 0, (int *)&v149 + 1);
  if (v30 > 0xFF) {
    return 63;
  }
  if (!v30 && HIDWORD(v149)) {
    return 22;
  }
  uint64_t v143 = v25;
  uint64_t v28 = a2;
  if (a3) {
    uint64_t v29 = *(void *)(a3 + 8);
  }
  else {
    uint64_t v29 = 1;
  }
  if (a3) {
    uint64_t v89 = (uint64_t *)(a3 + 336);
  }
  else {
    uint64_t v89 = 0;
  }
  uint64_t v90 = fs_lookup_name_with_parent_id(a1, v29, __s, a5, v89, (int *)&v149, 0);
  HIDWORD(v149) = v90;
  if (!v90)
  {
    jobj_release(v90, v150, v91, v92, v93, v94, v95, v96);
    return 17;
  }
  uint64_t v31 = v90;
  if (v90 == 2)
  {
    int v26 = v149;
    goto LABEL_10;
  }
  return v31;
}

uint64_t jfs_get_tree(uint64_t a1, int a2, uint64_t a3, uint64_t **a4)
{
  return jfs_get_tree_in_snap(a1, a2, a3, *(void *)(a1 + 432), a4);
}

uint64_t jfs_get_tree_in_snap(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t **a5)
{
  if (*(void *)(a1 + 384) && !*(_DWORD *)(a1 + 1100)) {
    sub_100060170();
  }
  extentref_uint64_t tree = 0;
  switch(a2)
  {
    case 1:
      goto LABEL_61;
    case 2:
      unint64_t v10 = (pthread_mutex_t *)(a1 + 1408);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1408));
      uint64_t v11 = *(void *)(a1 + 3576);
      if (v11)
      {
        obj_retain(v11);
        if (a3)
        {
          extentref_uint64_t tree = obj_modify(*(void **)(a1 + 3576), 2, a3, v12, v13, v14, v15, v16);
          uint64_t v17 = *(uint64_t **)(a1 + 3576);
          if (extentref_tree)
          {
            obj_release(v17);
            goto LABEL_95;
          }
          *(void *)(*(void *)(a1 + 376) + 144) = obj_oid((uint64_t)v17);
        }
        extentref_uint64_t tree = 0;
        *a5 = *(uint64_t **)(a1 + 3576);
      }
      else
      {
        extentref_uint64_t tree = apfs_get_extentref_tree(a1, *(void *)(*(void *)(a1 + 376) + 144), a3, a5);
        if (!extentref_tree)
        {
          if (a3) {
            *(void *)(*(void *)(a1 + 376) + 144) = obj_oid((uint64_t)*a5);
          }
          uint64_t v55 = *a5;
          *(void *)(a1 + 3576) = *a5;
          obj_retain(v55);
          extentref_uint64_t tree = 0;
        }
      }
LABEL_95:
      uint64_t v70 = v10;
      goto LABEL_115;
    case 3:
      unint64_t v10 = (pthread_mutex_t *)(a1 + 1472);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1472));
      extentref_uint64_t tree = apfs_get_snap_meta_tree(a1, a3, a5);
      if (!extentref_tree) {
        *(void *)(*(void *)(a1 + 376) + 152) = obj_oid((uint64_t)*a5);
      }
      goto LABEL_95;
    case 4:
      uint64_t v18 = *(uint64_t **)(a1 + 3568);
      if (v18)
      {
        obj_retain(*(void *)(a1 + 3568));
        if (!a3) {
          goto LABEL_80;
        }
        uint64_t v24 = obj_modify(v18, 0, a3, v19, v20, v21, v22, v23);
        if (!v24) {
          goto LABEL_80;
        }
        extentref_uint64_t tree = v24;
        obj_release(v18);
      }
      else
      {
        extentref_uint64_t tree = 0;
      }
LABEL_61:
      uint64_t v18 = *(uint64_t **)(a1 + 3552);
      if (*(void *)(a1 + 432) != a4 || v18 == 0)
      {
        extentref_uint64_t tree = apfs_get_fsroot_tree(a1, a4, a3, a5);
        if (extentref_tree) {
          return extentref_tree;
        }
        uint64_t v57 = *(void *)(a1 + 432);
        if (v57) {
          BOOL v58 = *(void *)(a1 + 496) == 0;
        }
        else {
          BOOL v58 = 0;
        }
        if (!v58 && v57 == a4)
        {
          uint64_t v69 = *a5;
          obj_retain(v69);
          extentref_uint64_t tree = 0;
          *(void *)(a1 + 3552) = v69;
          return extentref_tree;
        }
        return 0;
      }
      obj_retain(*(void *)(a1 + 3552));
      if (a3) {
        goto LABEL_76;
      }
      if (extentref_tree) {
        return extentref_tree;
      }
      goto LABEL_80;
    case 5:
      uint64_t v25 = *(void *)(a1 + 376);
      if ((*(unsigned char *)(v25 + 56) & 0x20) == 0) {
        return 45;
      }
      int v26 = *(_DWORD *)(v25 + 1040);
      if (a3 && *(void *)(a1 + 440)) {
        return 30;
      }
      int v27 = (pthread_mutex_t *)(a1 + 1536);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1536));
      uint64_t v61 = *(void *)(a1 + 3584);
      if (!v61) {
        goto LABEL_102;
      }
      if ((v26 & 0xC0000000) == 0)
      {
        if (*(void *)(a1 + 432) == a4) {
          goto LABEL_98;
        }
LABEL_102:
        unint64_t v62 = *(void *)(a1 + 440);
        uint64_t v63 = *(void *)(a1 + 376);
        if (!v62) {
          unint64_t v62 = *(void *)(v63 + 1032);
        }
        goto LABEL_104;
      }
      if ((v26 & 0xC0000000) != 0x40000000) {
        goto LABEL_102;
      }
      unint64_t v62 = *(void *)(a1 + 440);
      if (!v62)
      {
LABEL_98:
        obj_retain(v61);
        if (a3)
        {
          extentref_uint64_t tree = obj_modify(*(void **)(a1 + 3584), 2, a3, v71, v72, v73, v74, v75);
          __int16 v42 = *(uint64_t **)(a1 + 3584);
          if (extentref_tree) {
            goto LABEL_53;
          }
          *(void *)(*(void *)(a1 + 376) + 1032) = obj_oid((uint64_t)v42);
        }
        extentref_uint64_t tree = 0;
        unint64_t v43 = *(uint64_t **)(a1 + 3584);
        goto LABEL_49;
      }
      uint64_t v63 = *(void *)(a1 + 376);
LABEL_104:
      int v76 = *(_DWORD *)(v63 + 1040);
      *(void *)&long long v94 = 0;
      long long v95 = 0u;
      uint64_t v99 = 0;
      long long v97 = 0u;
      long long v98 = 0u;
      long long v96 = 0u;
      uint64_t v93 = fext_tree_key_cmp;
      *((void *)&v94 + 1) = 0x20000001FLL;
      if ((unsigned __int16)v76 != 2)
      {
        extentref_uint64_t tree = 22;
LABEL_110:
        strerror(extentref_tree);
        log_err((uint64_t)"%s:%d: %s Failed to get fext tree w/oid %llu (modify_xid %llu): %d (%s)\n", v78, v79, v80, v81, v82, v83, v84, (uint64_t)"jfs_get_tree_in_snap");
        goto LABEL_114;
      }
      uint64_t extended = btree_get_extended(a1, v76 & 0xFFFF0000, v62, a4, a3 != 0, (uint64_t)&v93, a3, a5);
      extentref_uint64_t tree = extended;
      if (a3 && !extended)
      {
        *(void *)(*(void *)(a1 + 376) + 1032) = obj_oid((uint64_t)*a5);
        goto LABEL_114;
      }
      if (extended) {
        goto LABEL_110;
      }
LABEL_114:
      uint64_t v70 = v27;
LABEL_115:
      pthread_mutex_unlock(v70);
      return extentref_tree;
    case 6:
      if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 0x40) == 0) {
        return 45;
      }
      int v27 = (pthread_mutex_t *)(a1 + 1600);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1600));
      uint64_t v36 = *(void *)(a1 + 3592);
      if (!v36)
      {
        uint64_t v64 = *(void *)(a1 + 384);
        if (!v64) {
          uint64_t v64 = *(void *)(a1 + 376);
        }
        int v65 = *(_DWORD *)(v64 + 1044);
        unint64_t v66 = *(void *)(v64 + 1048);
        long long v94 = 0u;
        long long v95 = 0u;
        uint64_t v99 = 0;
        long long v97 = 0u;
        long long v98 = 0u;
        long long v96 = 0u;
        uint64_t v93 = pfkur_tree_key_cmp;
        DWORD2(v94) = 32;
        if ((unsigned __int16)v65 == 2)
        {
          uint64_t v67 = btree_get_extended(a1, v65 & 0xFFFF0000, v66, a4, a3 != 0, (uint64_t)&v93, a3, a5);
          uint64_t v68 = v67;
          if (a3 && !v67)
          {
            extentref_uint64_t tree = 0;
            *(void *)(*(void *)(a1 + 376) + 1048) = obj_oid((uint64_t)*a5);
            goto LABEL_114;
          }
          if (!v67)
          {
LABEL_113:
            extentref_uint64_t tree = 0;
            goto LABEL_114;
          }
        }
        else
        {
          uint64_t v68 = 22;
        }
        strerror(v68);
        log_err((uint64_t)"%s:%d: %s Failed to get pfkur tree w/oid %llu (modify_xid %llu): %d (%s)\n", v85, v86, v87, v88, v89, v90, v91, (uint64_t)"jfs_get_tree_in_snap");
        extentref_uint64_t tree = v68;
        goto LABEL_114;
      }
      obj_retain(v36);
      if (a3)
      {
        extentref_uint64_t tree = obj_modify(*(void **)(a1 + 3592), 2, a3, v37, v38, v39, v40, v41);
        __int16 v42 = *(uint64_t **)(a1 + 3592);
        if (extentref_tree) {
          goto LABEL_53;
        }
        *(void *)(*(void *)(a1 + 376) + 1048) = obj_oid((uint64_t)v42);
      }
      extentref_uint64_t tree = 0;
      unint64_t v43 = *(uint64_t **)(a1 + 3592);
LABEL_49:
      *a5 = v43;
      goto LABEL_114;
    case 7:
      int v27 = (pthread_mutex_t *)(a1 + 1664);
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 1664));
      uint64_t v28 = *(uint64_t **)(a1 + 3600);
      if (*(void *)(a1 + 432) == a4 && v28 != 0)
      {
        obj_retain(*(void *)(a1 + 3600));
        if (a3 && (uint64_t v49 = obj_modify(v28, 0, a3, v44, v45, v46, v47, v48), v49))
        {
          extentref_uint64_t tree = v49;
          __int16 v42 = v28;
LABEL_53:
          obj_release(v42);
        }
        else
        {
          extentref_uint64_t tree = 0;
          *a5 = v28;
        }
        goto LABEL_114;
      }
      extentref_uint64_t tree = apfs_get_doc_id_tree(a1, 0, a4, a3, a5);
      if (extentref_tree) {
        goto LABEL_114;
      }
      if (*(void *)(a1 + 432) == a4)
      {
        unint64_t v30 = *a5;
        obj_retain(v30);
        extentref_uint64_t tree = 0;
        *(void *)(a1 + 3600) = v30;
        goto LABEL_114;
      }
      goto LABEL_113;
    case 8:
      uint64_t v18 = *(uint64_t **)(a1 + 3560);
      if (*(void *)(a1 + 432) != a4 || v18 == 0)
      {
        extentref_uint64_t tree = apfs_get_secondary_fsroot_tree(a1, a4, a3, a5);
        if (!extentref_tree)
        {
          uint64_t v32 = *(void *)(a1 + 432);
          if (v32) {
            BOOL v33 = *(void *)(a1 + 496) == 0;
          }
          else {
            BOOL v33 = 0;
          }
          if (!v33 && v32 == a4)
          {
            uint64_t v35 = *a5;
            obj_retain(v35);
            extentref_uint64_t tree = 0;
            *(void *)(a1 + 3560) = v35;
          }
          else
          {
            return 0;
          }
        }
      }
      else
      {
        obj_retain(*(void *)(a1 + 3560));
        if (a3)
        {
LABEL_76:
          uint64_t v60 = obj_modify(v18, 0, a3, v50, v51, v52, v53, v54);
          if (v60)
          {
            extentref_uint64_t tree = v60;
            obj_release(v18);
            return extentref_tree;
          }
        }
LABEL_80:
        extentref_uint64_t tree = 0;
        *a5 = v18;
      }
      return extentref_tree;
    default:
      return 22;
  }
}

uint64_t sub_100046C5C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, unsigned int a6, int *a7, unsigned int a8, uint64_t a9)
{
  int v14 = jobj_type_from_possibly_large_key(*(void *)a9, (uint64_t)a1);
  if (a6 < a8 && v14 != 18) {
    return 22;
  }
  uint64_t v23 = *a1 & 0xFFFFFFFFFFFFFFFLL;
  switch(*a1 >> 60)
  {
    case 2:
      uint64_t result = 0;
      *(_DWORD *)(a9 + 16) = *((_DWORD *)a5 + 4);
      *((_DWORD *)a5 + 4) += a7[4];
      return result;
    case 6:
      *(_DWORD *)(a9 + 16) = *(_DWORD *)a5;
      uint64_t v24 = *(unsigned int *)a5 + (uint64_t)*a7;
      uint64_t v25 = v24 << 31 >> 31;
      if (v25 == v24 && (v25 & 0x8000000000000000) == 0)
      {
        uint64_t result = 0;
        *(_DWORD *)a5 = v25;
        return result;
      }
      BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(*(void *)a9 + 392));
      log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s dstream id %llu refcnt %u (delta: %d) would overflow\n", v100, v101, v102, v103, v104, v105, (uint64_t)"jobj_refcnt_merge");
      return 0;
    case 7:
      *(_DWORD *)(a9 + 16) = *(_DWORD *)a5;
      int v26 = *(_DWORD *)a5 + *a7;
      *(_DWORD *)a5 = v26;
      if (v26 < 0) {
        panic("can't have a negative refcnt on crypto state %llu refcnt %d\n", v23, v26);
      }
      return 0;
    case 9:
      a5[1] = *((void *)a7 + 1);
      if (!*((_WORD *)a7 + 8)) {
        return 0;
      }
      uint64_t result = 0;
      *((_WORD *)a5 + 8) = *((_WORD *)a7 + 8);
      return result;
    case 0xALL:
      int v27 = *(_DWORD *)(a9 + 84);
      if ((v27 & 2) != 0)
      {
        if ((v27 & 4) != 0) {
          goto LABEL_33;
        }
      }
      else
      {
        uint64_t v28 = *a5;
        uint64_t v29 = *a5 + *(void *)a7;
        if (__CFADD__(*a5, *(void *)a7)) {
          uint64_t v30 = (*(uint64_t *)a7 >> 63) + 1;
        }
        else {
          uint64_t v30 = *(uint64_t *)a7 >> 63;
        }
        uint64_t v31 = v30 << 63 >> 63;
        if (v31 != v30 || v31 < 0)
        {
          if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
            log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"jobj_merge_maybe_clamp_64");
          }
          uint64_t v29 = v28;
        }
        *a5 = v29;
        uint64_t v39 = a5[1];
        uint64_t v40 = *((void *)a7 + 1);
        uint64_t v41 = v39 + v40;
        if (__CFADD__(v39, v40)) {
          uint64_t v42 = (v40 >> 63) + 1;
        }
        else {
          uint64_t v42 = v40 >> 63;
        }
        uint64_t v43 = v42 << 63 >> 63;
        if (v43 != v42 || v43 < 0)
        {
          if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
            log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v44, v45, v46, v47, v48, v49, v50, (uint64_t)"jobj_merge_maybe_clamp_64");
          }
          uint64_t v41 = v39;
        }
        a5[1] = v41;
        int v27 = *(_DWORD *)(a9 + 84);
        if ((v27 & 4) != 0)
        {
LABEL_33:
          a5[2] = *((void *)a7 + 2);
          if (*(_DWORD *)(a9 + 84)) {
            goto LABEL_85;
          }
          goto LABEL_82;
        }
      }
      if (v27) {
        goto LABEL_85;
      }
LABEL_82:
      unint64_t v98 = *((void *)a7 + 3);
      if (v98 <= 1) {
        unint64_t v98 = 1;
      }
      a5[3] += v98;
LABEL_85:
      if ((*(unsigned char *)(a9 + 84) & 8) != 0)
      {
        *(void *)(a9 + 24) = *a5;
        *(void *)(a9 + 32) = a5[1];
      }
      uint64_t result = 0;
      *(void *)(a9 + 16) = a5[2];
      return result;
    case 0xDLL:
      if (HIBYTE(a1[1]) != 2)
      {
        log_err((uint64_t)"%s:%d: don't know how to merge refcounts on objects of file info type %llu\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"jobj_refcnt_merge");
        return 22;
      }
      unsigned int v51 = *((unsigned __int16 *)a5 + 12);
      if (v51 >= 2) {
        *((_WORD *)a5 + 12) = v51 | 1;
      }
      *(void *)(a9 + 16) = *a5;
      uint64_t v52 = a5[1];
      uint64_t v53 = *((void *)a7 + 1);
      uint64_t v54 = v52 + v53;
      if (__CFADD__(v52, v53)) {
        uint64_t v55 = (v53 >> 63) + 1;
      }
      else {
        uint64_t v55 = v53 >> 63;
      }
      uint64_t v56 = v55 << 63 >> 63;
      if (v56 != v55 || v56 < 0)
      {
        if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
          log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v57, v58, v59, v60, v61, v62, v63, (uint64_t)"jobj_merge_maybe_clamp_64");
        }
        uint64_t v54 = v52;
      }
      a5[1] = v54;
      uint64_t v64 = a5[2];
      uint64_t v65 = *((void *)a7 + 2);
      uint64_t v66 = v64 + v65;
      if (__CFADD__(v64, v65)) {
        uint64_t v67 = (v65 >> 63) + 1;
      }
      else {
        uint64_t v67 = v65 >> 63;
      }
      uint64_t v68 = v67 << 63 >> 63;
      if (v68 != v67 || v68 < 0)
      {
        if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
          log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v69, v70, v71, v72, v73, v74, v75, (uint64_t)"jobj_merge_maybe_clamp_64");
        }
        uint64_t v66 = v64;
      }
      a5[2] = v66;
      uint64_t v76 = *a5;
      uint64_t v77 = *(void *)a7;
      uint64_t v78 = *a5 + v77;
      if (__CFADD__(*a5, v77)) {
        uint64_t v79 = (v77 >> 63) + 1;
      }
      else {
        uint64_t v79 = v77 >> 63;
      }
      uint64_t v80 = v79 << 63 >> 63;
      if (v80 != v79 || v80 < 0)
      {
        if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
          log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v81, v82, v83, v84, v85, v86, v87, (uint64_t)"jobj_merge_maybe_clamp_64");
        }
        uint64_t v78 = v76;
      }
      uint64_t result = 0;
      *a5 = v78;
      return result;
    case 0xELL:
      int v88 = *((unsigned __int8 *)a1 + 8);
      if (v88 != 19)
      {
        if (v88 != 18)
        {
          log_err((uint64_t)"%s:%d: don't know how to merge refcounts on objects of expanded type %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"jobj_refcnt_merge");
          return 22;
        }
        unsigned int v89 = *(_DWORD *)(a9 + 84);
        *(_DWORD *)(a9 + 84) = 0;
        if ((v89 & 0x800000) != 0)
        {
          uint64_t result = 0;
          int v112 = a7[12];
          a5[3] = *((void *)a7 + 3);
          *((_DWORD *)a5 + 12) = v112 | 0x80;
          a5[4] = *((void *)a7 + 4);
          return result;
        }
        int v90 = *((_DWORD *)a5 + 12);
        if ((~v90 & 0x30) == 0) {
          sub_10006019C();
        }
        uint64_t v91 = a5[4];
        BOOL v92 = (a5[6] & 0x20) == 0;
        if ((v89 & 0x4000) == 0) {
          BOOL v92 = 1;
        }
        if ((v89 & 0x100) != 0 && (a5[6] & 0x10) != 0 || !v92) {
          char v95 = 1;
        }
        else {
          char v95 = ((v89 & 0x40) == 0) & ((a5[6] & v89) >> 5) | ((a5[6] & 0x20) == 0) & (v89 >> 12);
        }
        unint64_t v96 = a6 - 52;
        uint64_t v263 = a5[1];
        uint64_t v262 = a5[2];
        if ((v90 & 8) != 0)
        {
          v269[0] = 0;
          LODWORD(v268) = 0;
          uint64_t v264 = 0;
          if (!xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 3, 0, v269, &v268)
            && v268 == 8)
          {
            uint64_t v264 = *(void *)v269[0];
          }
          unsigned int v97 = *((_DWORD *)a5 + 12);
        }
        else
        {
          uint64_t v264 = 0;
          unsigned int v97 = *((_DWORD *)a5 + 12);
        }
        if ((v97 & 0x800) != 0)
        {
          v269[0] = 0;
          LODWORD(v268) = 0;
          int v114 = xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 4, 0, v269, &v268);
          uint64_t v113 = 0;
          if (!v114 && v268 == 8) {
            uint64_t v113 = *(void *)v269[0];
          }
          unsigned int v97 = *((_DWORD *)a5 + 12);
        }
        else
        {
          uint64_t v113 = 0;
        }
        if ((v97 & 0x200) != 0 && (v89 & 2) == 0)
        {
          uint64_t result = 0;
          *(void *)(a9 + 16) = *a1 & 0xFFFFFFFFFFFFFFFLL;
          int v115 = *(_DWORD *)(a9 + 84) | 0x400000;
LABEL_297:
          *(_DWORD *)(a9 + 84) = v115;
          return result;
        }
        uint64_t v260 = v113;
        if (v97 >= 0x1000)
        {
          v97 |= 0x100u;
          *((_DWORD *)a5 + 12) = v97;
        }
        if (a5[4] == (*a1 & 0xFFFFFFFFFFFFFFFLL))
        {
          *((_DWORD *)a5 + 12) = v97 | 0x400;
          a5[4] = 0;
        }
        int v261 = (v89 >> 1) & 1;
        if (!(v261 | v95 & 1))
        {
          uint64_t v259 = v91;
          uint64_t v116 = *a5;
          uint64_t v117 = *a5 + *(void *)a7;
          if (__CFADD__(*a5, *(void *)a7)) {
            uint64_t v118 = (*(uint64_t *)a7 >> 63) + 1;
          }
          else {
            uint64_t v118 = *(uint64_t *)a7 >> 63;
          }
          uint64_t v119 = v118 << 63 >> 63;
          if (v119 != v118 || v119 < 0)
          {
            if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
              log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v120, v121, v122, v123, v124, v125, v126, (uint64_t)"jobj_merge_maybe_clamp_64");
            }
            uint64_t v117 = v116;
          }
          *a5 = v117;
          uint64_t v127 = a5[1];
          uint64_t v128 = *((void *)a7 + 1);
          uint64_t v129 = v127 + v128;
          if (__CFADD__(v127, v128)) {
            uint64_t v130 = (v128 >> 63) + 1;
          }
          else {
            uint64_t v130 = v128 >> 63;
          }
          uint64_t v131 = v130 << 63 >> 63;
          if (v131 != v130 || v131 < 0)
          {
            if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
              log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v132, v133, v134, v135, v136, v137, v138, (uint64_t)"jobj_merge_maybe_clamp_64");
            }
            uint64_t v129 = v127;
          }
          unint64_t v258 = a8 - 52;
          a5[1] = v129;
          int v139 = *((_DWORD *)a5 + 12);
          if (v139)
          {
            uint64_t v140 = a5[2];
            uint64_t v141 = *((void *)a7 + 2);
            uint64_t v142 = v140 + v141;
            if (__CFADD__(v140, v141)) {
              uint64_t v143 = (v141 >> 63) + 1;
            }
            else {
              uint64_t v143 = v141 >> 63;
            }
            uint64_t v144 = v143 << 63 >> 63;
            if (v144 != v143 || v144 < 0)
            {
              if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
                log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v145, v146, v147, v148, v149, v150, v151, (uint64_t)"jobj_merge_maybe_clamp_64");
              }
              uint64_t v142 = v140;
            }
            a5[2] = v142;
            int v139 = *((_DWORD *)a5 + 12);
          }
          uint64_t v91 = v259;
          if ((v139 & 4) != 0 && (a7[12] & 4) != 0)
          {
            uint64_t v266 = 0;
            uint64_t v152 = *(void *)a9;
            uint64_t v268 = 0;
            v269[0] = 0;
            int v267 = 0;
            int v153 = xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 1, 0, v269, &v267);
            uint64_t v154 = 0;
            if (!v153)
            {
              uint64_t v255 = v152;
              if (v267 == 8)
              {
                int v267 = 0;
                if (!xf_get_from_blob((unsigned __int16 *)a7 + 26, v258, 1, 0, &v268, &v267)
                  && v267 == 8
                  && (uint64_t v155 = *v268) != 0)
                {
                  uint64_t v254 = *(void *)v269[0];
                  uint64_t v154 = *(void *)v269[0] + v155;
                  if (__CFADD__(*(void *)v269[0], v155)) {
                    uint64_t v156 = (v155 >> 63) + 1;
                  }
                  else {
                    uint64_t v156 = v155 >> 63;
                  }
                  uint64_t v157 = v156 << 63 >> 63;
                  if (v157 != v156 || v157 < 0)
                  {
                    if (nx_ratelimit_log_allowed(*(void *)(v255 + 392))) {
                      log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v158, v159, v160, v161, v162, v163, v164, (uint64_t)"jobj_merge_maybe_clamp_64");
                    }
                    uint64_t v154 = v254;
                    uint64_t v91 = v259;
                  }
                }
                else
                {
                  uint64_t v154 = *(void *)v269[0];
                }
              }
            }
            uint64_t v266 = v154;
            int v180 = xf_set_in_blob((unsigned __int16 *)a5 + 26, v96, 1, &v266, 8);
            if (v180)
            {
              int v181 = v180;
              if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392)))
              {
                strerror(v181);
                log_err((uint64_t)"%s:%d: %s could not update clone size for dir-stats %llu: %s (%d)\n", v182, v183, v184, v185, v186, v187, v188, (uint64_t)"exp_dir_stats_refcnt_merge");
              }
            }
            int v139 = *((_DWORD *)a5 + 12);
          }
          if ((v139 & 8) != 0 && (a7[12] & 8) != 0)
          {
            uint64_t v266 = 0;
            uint64_t v256 = *(void *)a9;
            uint64_t v268 = 0;
            v269[0] = 0;
            int v267 = 0;
            uint64_t v189 = 0;
            if (!xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 3, 0, v269, &v267) && v267 == 8)
            {
              int v267 = 0;
              if (!xf_get_from_blob((unsigned __int16 *)a7 + 26, v258, 3, 0, &v268, &v267)
                && v267 == 8
                && (uint64_t v190 = *v268) != 0)
              {
                uint64_t v189 = *(void *)v269[0] + v190;
                if (__CFADD__(*(void *)v269[0], v190)) {
                  uint64_t v191 = (v190 >> 63) + 1;
                }
                else {
                  uint64_t v191 = v190 >> 63;
                }
                uint64_t v192 = v191 << 63 >> 63;
                if (v192 != v191 || v192 < 0)
                {
                  if (nx_ratelimit_log_allowed(*(void *)(v256 + 392))) {
                    log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v193, v194, v195, v196, v197, v198, v199, (uint64_t)"jobj_merge_maybe_clamp_64");
                  }
                  uint64_t v91 = v259;
                }
              }
              else
              {
                uint64_t v189 = *(void *)v269[0];
              }
            }
            uint64_t v266 = v189;
            int v200 = xf_set_in_blob((unsigned __int16 *)a5 + 26, v96, 3, &v266, 8);
            if (v200)
            {
              int v201 = v200;
              if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392)))
              {
                strerror(v201);
                log_err((uint64_t)"%s:%d: %s could not update purgeable size for dir-stats %llu: %s (%d)\n", v202, v203, v204, v205, v206, v207, v208, (uint64_t)"exp_dir_stats_refcnt_merge");
              }
            }
            int v139 = *((_DWORD *)a5 + 12);
          }
          if ((v139 & 0x800) != 0 && (*((unsigned char *)a7 + 49) & 8) != 0)
          {
            uint64_t v266 = 0;
            uint64_t v257 = *(void *)a9;
            uint64_t v268 = 0;
            v269[0] = 0;
            int v267 = 0;
            uint64_t v209 = 0;
            if (!xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 4, 0, v269, &v267) && v267 == 8)
            {
              int v267 = 0;
              if (!xf_get_from_blob((unsigned __int16 *)a7 + 26, v258, 4, 0, &v268, &v267)
                && v267 == 8
                && (uint64_t v210 = *v268) != 0)
              {
                uint64_t v209 = *(void *)v269[0] + v210;
                if (__CFADD__(*(void *)v269[0], v210)) {
                  uint64_t v211 = (v210 >> 63) + 1;
                }
                else {
                  uint64_t v211 = v210 >> 63;
                }
                uint64_t v212 = v211 << 63 >> 63;
                if (v212 != v211 || v212 < 0)
                {
                  if (nx_ratelimit_log_allowed(*(void *)(v257 + 392))) {
                    log_err((uint64_t)"%s:%d: %s %s overflowed on %s <%llu> %s %llu (delta: %lld)\n", v213, v214, v215, v216, v217, v218, v219, (uint64_t)"jobj_merge_maybe_clamp_64");
                  }
                  uint64_t v91 = v259;
                }
              }
              else
              {
                uint64_t v209 = *(void *)v269[0];
              }
            }
            uint64_t v266 = v209;
            int v220 = xf_set_in_blob((unsigned __int16 *)a5 + 26, v96, 4, &v266, 8);
            if (v220)
            {
              int v221 = v220;
              if (nx_ratelimit_log_allowed(*(void *)(**(void **)a9 + 392)))
              {
                obj_type(*(void *)a9);
                strerror(v221);
                log_err((uint64_t)"%s:%d: %s could not update purgeable rsrc size for dir-stats %llu: %s (%d)\n", v222, v223, v224, v225, v226, v227, v228, (uint64_t)"exp_dir_stats_refcnt_merge");
              }
            }
          }
        }
        if ((v89 & 0x8000) != 0) {
          *((_DWORD *)a5 + 12) |= 2u;
        }
        if ((v89 & 4) != 0) {
          a5[4] = *((void *)a7 + 4);
        }
        int v229 = *((_DWORD *)a5 + 12);
        if ((v229 & 8) != 0)
        {
          if ((v89 & 0x400) != 0 && (v90 & 0x40) == 0)
          {
            unsigned int v230 = v229 | 0x40;
            int v231 = 1024;
LABEL_229:
            *((_DWORD *)a5 + 12) = v230;
            *(_DWORD *)(a9 + 84) |= v231;
            goto LABEL_230;
          }
          if ((v89 & 0x800) != 0 && (v90 & 0x40) != 0)
          {
            unsigned int v230 = v229 & 0xFFFFFFBF;
            int v231 = 2048;
            goto LABEL_229;
          }
        }
LABEL_230:
        if ((v89 & 1) == 0)
        {
          unint64_t v232 = *((void *)a7 + 5);
          if (v232 <= 1) {
            unint64_t v232 = 1;
          }
          a5[5] += v232;
          char v233 = v261;
          if ((v90 & 0x40) == 0) {
            char v233 = 1;
          }
          if ((v233 & 1) == 0)
          {
            *((_DWORD *)a5 + 12) &= ~0x40u;
            *(_DWORD *)(a9 + 84) |= 0x800u;
          }
        }
        if ((v89 & 8) == 0)
        {
          if ((v89 & 0x200) != 0)
          {
            *(void *)(a9 + 72) = a5[5];
            *(_DWORD *)(a9 + 80) = *((_DWORD *)a5 + 12);
          }
          int v234 = *(_DWORD *)(a9 + 84);
          if ((v90 & 0x20) == 0 && (v234 & 0x800) != 0)
          {
            *(void *)(a9 + 56) = v263 - v264;
            if ((*((unsigned char *)a5 + 49) & 8) != 0) {
              *(void *)(a9 + 64) = v262 - v260;
            }
          }
LABEL_261:
          *(void *)(a9 + 16) = a5[4];
          if ((v90 & 0x20) == 0
            || (v89 & 0x80) != 0
            || (v89 & 0x20) != 0
            || (v89 & 0x100) != 0
            || (v269[0] = 0,
                LODWORD(v268) = 0,
                xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 2, 0, v269, &v268))
            || v268 != 8
            || !*(void *)v269[0])
          {
            if ((v89 & 0x2000) != 0 && (v90 & 0x40) != 0 && (v234 & 0xC00) == 0) {
              *(void *)(a9 + 16) = 0;
            }
          }
          else
          {
            *(void *)(a9 + 16) = *(void *)v269[0];
            *(_DWORD *)(a9 + 84) |= 0x100000u;
          }
          if ((v89 & 0x10) != 0)
          {
            int v242 = *((_DWORD *)a5 + 12);
            a5[3] = 0;
            *((_DWORD *)a5 + 12) = v242 & 0xFFFFFF6F | 0x10;
            v269[0] = 0;
            xf_set_in_blob((unsigned __int16 *)a5 + 26, v96, 2, v269, 8);
            int v243 = *((_DWORD *)a5 + 12);
            *((_DWORD *)a5 + 12) = v243 & 0xFFFFFFDF;
            if ((v89 & 4) == 0) {
              sub_1000601C8();
            }
            *((_DWORD *)a5 + 12) = v243 & 0xFFFFFBDF;
            *(void *)(a9 + 16) = v91;
          }
          if ((v89 & 0x80) != 0)
          {
            v269[0] = 0;
            xf_set_in_blob((unsigned __int16 *)a5 + 26, v96, 2, v269, 8);
            *((_DWORD *)a5 + 12) &= ~0x20u;
          }
          if ((v89 & 0x10000) != 0)
          {
            unsigned int v245 = *((_DWORD *)a5 + 12) | 0x100;
          }
          else
          {
            if ((v89 & 0x20000) == 0)
            {
              if ((v89 & 0x200000) == 0) {
                goto LABEL_281;
              }
              goto LABEL_287;
            }
            unsigned int v245 = a5[6] & 0xFFFFFEFF;
          }
          *((_DWORD *)a5 + 12) = v245;
          if ((v89 & 0x200000) == 0)
          {
LABEL_281:
            if ((v89 & 0x40000) == 0)
            {
LABEL_282:
              if ((v89 & 0x80000) == 0) {
                goto LABEL_290;
              }
              unsigned int v244 = a5[6] & 0xFFFFFDFF;
LABEL_289:
              *((_DWORD *)a5 + 12) = v244;
LABEL_290:
              if ((v89 & 0x100000) != 0 && (v90 & 0x10) == 0)
              {
                if (nx_ratelimit_log_allowed(*(void *)(*(void *)a9 + 392))) {
                  log_err((uint64_t)"%s:%d: %s fixing DIR_STATS_IS_SHADOW flag for dir-stats %llu\n", v247, v248, v249, v250, v251, v252, v253, (uint64_t)"exp_dir_stats_refcnt_merge");
                }
                *((_DWORD *)a5 + 12) |= 0x110u;
                goto LABEL_296;
              }
              if (v90 & 0x10 | v89 & 0x100000)
              {
LABEL_296:
                uint64_t result = 0;
                int v115 = *(_DWORD *)(a9 + 84) | 0x20;
                goto LABEL_297;
              }
              if ((v90 & 0x20) != 0)
              {
                uint64_t result = 0;
                int v115 = *(_DWORD *)(a9 + 84) | 0x40;
                goto LABEL_297;
              }
              return 0;
            }
LABEL_288:
            unsigned int v244 = *((_DWORD *)a5 + 12) | 0x200;
            goto LABEL_289;
          }
LABEL_287:
          int v246 = *((_DWORD *)a5 + 12);
          a5[3] = 0;
          *((_DWORD *)a5 + 12) = v246 & 0xFFFFFE4F | 0x100;
          if ((v89 & 0x40000) == 0) {
            goto LABEL_282;
          }
          goto LABEL_288;
        }
        *(void *)(a9 + 24) = *a5;
        *(void *)(a9 + 32) = a5[1];
        *(void *)(a9 + 40) = a5[2];
        int v235 = *((_DWORD *)a5 + 12);
        if ((v235 & 4) != 0)
        {
          v269[0] = 0;
          LODWORD(v268) = 0;
          int v236 = xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 1, 0, v269, &v268);
          uint64_t v237 = 0;
          if (!v236 && v268 == 8) {
            uint64_t v237 = *(void *)v269[0];
          }
          *(void *)(a9 + 48) = v237;
          int v235 = *((_DWORD *)a5 + 12);
          if ((v235 & 8) == 0)
          {
LABEL_246:
            if ((v235 & 0x800) == 0)
            {
LABEL_260:
              *(void *)(a9 + 72) = a5[5];
              *(_DWORD *)(a9 + 80) = *((_DWORD *)a5 + 12);
              int v234 = *(_DWORD *)(a9 + 84);
              goto LABEL_261;
            }
LABEL_256:
            v269[0] = 0;
            LODWORD(v268) = 0;
            int v240 = xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 4, 0, v269, &v268);
            uint64_t v241 = 0;
            if (!v240 && v268 == 8) {
              uint64_t v241 = *(void *)v269[0];
            }
            *(void *)(a9 + 64) = v241;
            goto LABEL_260;
          }
        }
        else if ((v235 & 8) == 0)
        {
          goto LABEL_246;
        }
        v269[0] = 0;
        LODWORD(v268) = 0;
        int v238 = xf_get_from_blob((unsigned __int16 *)a5 + 26, v96, 3, 0, v269, &v268);
        uint64_t v239 = 0;
        if (!v238 && v268 == 8) {
          uint64_t v239 = *(void *)v269[0];
        }
        *(void *)(a9 + 56) = v239;
        if ((a5[6] & 0x800) == 0) {
          goto LABEL_260;
        }
        goto LABEL_256;
      }
      *a5 |= (unint64_t)*((unsigned __int8 *)a7 + 7) << 56;
      uint64_t v106 = (unsigned __int16 *)(a5 + 1);
      unint64_t v107 = a6 - 8;
      unint64_t v108 = a8 - 8;
      uint64_t v109 = (unsigned __int16 *)(a7 + 2);
      v269[0] = 0;
      LODWORD(v266) = 0;
      if (xf_get_from_blob(v109, v108, 2, 0, v269, &v266)) {
        goto LABEL_163;
      }
      if (v266 != 8) {
        goto LABEL_163;
      }
      uint64_t v110 = *(uint64_t **)v269[0];
      uint64_t v268 = v110;
      if (!v110) {
        goto LABEL_163;
      }
      v269[0] = 0;
      LODWORD(v266) = 0;
      if (xf_get_from_blob(v106, a6 - 8, 2, 0, v269, &v266)
        || v266 != 8
        || !*(void *)v269[0])
      {
        int v111 = 22;
LABEL_162:
        BOOL v265 = nx_is_panic_on_corruption_enabled(*(void *)(*(void *)a9 + 392));
        strerror(v111);
        log_corrupt(v265, (uint64_t)"%s:%d: %s clone mapping <%llu, %llu>: failed to update dir-stats key: %s (%d)\n", v165, v166, v167, v168, v169, v170, (uint64_t)"jobj_refcnt_merge");
        goto LABEL_163;
      }
      if (*(uint64_t **)v269[0] != v110)
      {
        int v111 = xf_set_in_blob(v106, a6 - 8, 2, &v268, 8);
        if (v111) {
          goto LABEL_162;
        }
      }
LABEL_163:
      v269[0] = 0;
      LODWORD(v266) = 0;
      if (xf_get_from_blob(v109, v108, 1, 0, v269, &v266)) {
        return 0;
      }
      if (v266 != 8) {
        return 0;
      }
      long long v171 = *(uint64_t **)v269[0];
      uint64_t v268 = v171;
      if (!v171) {
        return 0;
      }
      v269[0] = 0;
      LODWORD(v266) = 0;
      if (xf_get_from_blob(v106, v107, 1, 0, v269, &v266) || v266 != 8 || !*(void *)v269[0])
      {
        int v172 = 22;
        goto LABEL_173;
      }
      if (*(uint64_t **)v269[0] == v171) {
        return 0;
      }
      uint64_t result = xf_set_in_blob(v106, v107, 1, &v268, 8);
      int v172 = result;
      if (result)
      {
LABEL_173:
        BOOL v173 = nx_is_panic_on_corruption_enabled(*(void *)(*(void *)a9 + 392));
        strerror(v172);
        log_corrupt(v173, (uint64_t)"%s:%d: %s clone mapping <%llu, %llu>: failed to update attribution tag: %s (%d)\n", v174, v175, v176, v177, v178, v179, (uint64_t)"jobj_refcnt_merge");
        return 0;
      }
      return result;
    default:
      log_err((uint64_t)"%s:%d: don't know how to merge refcounts on objects of type %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"jobj_refcnt_merge");
      return 22;
  }
}

uint64_t match_jobj_type_to_tree_type(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a2;
  if (a2 < 0x10)
  {
    int v10 = a3;
    unsigned __int8 v9 = 3;
    switch((int)a2)
    {
      case 1:
      case 11:
        return v9;
      case 2:
        return 2;
      case 6:
      case 7:
        goto LABEL_5;
      case 8:
        if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 0x20) == 0)
        {
LABEL_5:
          if (a3 == 100) {
            return 1;
          }
          if (a3 == 101)
          {
            if ((*(unsigned char *)(*(void *)(a1 + 376) + 57) & 1) == 0) {
              panic("Requested forced secondary_fs_root but the tree is missing\n");
            }
          }
          else
          {
            if (!apfs_has_secondary_fsroot(a1)) {
              return v10;
            }
            if (v10 != 1) {
              panic("type = %u, req_tree != fs_root\n", v8);
            }
          }
          return 8;
        }
        if (a3 != 1) {
          panic("sealed, fext, req_tree != fs_root");
        }
        unsigned __int8 v9 = 5;
        break;
      default:
        return v10;
    }
  }
  else if ((*(unsigned char *)(*(void *)(a1 + 376) + 57) & 2) != 0)
  {
    if ((a2 & 0xFC) == 0x10)
    {
      if (apfs_has_secondary_fsroot(a1)) {
        return 8;
      }
      else {
        return 1;
      }
    }
    else
    {
      log_warn((uint64_t)"%s:%d: %s Warning: attempting to place unknown expanded type %hhu into fsroot.\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"match_jobj_expanded_type_to_tree_type");
      return 1;
    }
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s expanded obj type %hhu found on unsupported volume\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"match_jobj_expanded_type_to_tree_type");
    return 0;
  }
  return v9;
}

uint64_t insert_jobj(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*((void *)a3 + 1)) {
    sub_1000601F4();
  }
  uint64_t matched = match_jobj_type_to_tree_type(a1, *a3, a2, a4, a5, a6, a7, a8);
  if (matched != 5)
  {
    uint64_t v20 = matched;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
    uint64_t tree_in_snap = jfs_get_tree_in_snap(a1, matched, a4, *(void *)(a1 + 432), &v35);
    if (tree_in_snap) {
      return tree_in_snap;
    }
    int v28 = a3[1];
    if ((v28 - 1) >= 2)
    {
      if (v28 != 4)
      {
        log_err((uint64_t)"%s:%d: %s X %d\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"insert_jobj");
        uint64_t tree_in_snap = 22;
LABEL_15:
        obj_release(v35);
        return tree_in_snap;
      }
      uint64_t v29 = 3;
    }
    else
    {
      uint64_t v29 = 1;
    }
    uint64_t tree_in_snap = sub_1000483E4(a1, (uint64_t)a3, v20, &v34, (uint64_t)"addition", v25, v26, v27);
    if (!tree_in_snap)
    {
      uint64_t tree_in_snap = create_or_modify_jobj(a1, v35, a3, a4, v29, v30, v31, v32);
      if (!tree_in_snap)
      {
        sub_100048488(a1, v20, v35, (uint64_t)a3, a4, v29);
        uint64_t tree_in_snap = 0;
        if (*a3 == 3) {
          *((void *)a3 + 14) &= 0xFFFFFFFFFBFBFFFFLL;
        }
      }
    }
    goto LABEL_15;
  }
  uint64_t tree_in_snap = fext_tree_insert(a1, a4, (uint64_t)a3);
  if (tree_in_snap) {
    log_err((uint64_t)"%s:%d: %s failed to insert fext in fext_tree: %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"insert_jobj");
  }
  return tree_in_snap;
}

uint64_t sub_1000483E4(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(unsigned char *)a2 == 3) {
    uint64_t v8 = *(void *)(a2 + 16);
  }
  else {
    uint64_t v8 = 0;
  }
  *a4 = v8;
  if ((~*(void *)(a2 + 8) & 0xFFFFFFFFFFF0000) != 0 && (v8 & 0xFFFFFFFFFFF0000) != 0xFFFFFFFFFFF0000) {
    return 0;
  }
  uint64_t v10 = *(unsigned int *)(a1 + 1100);
  if (v10) {
    return 0;
  }
  if (a3 == 1 && *(void *)(a1 + 3568))
  {
    log_err((uint64_t)"%s:%d: %s Preventing %s of objects to synthetic folder (id %lld, parent %lld)\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"prevent_synthetic_object_operation");
    return 45;
  }
  return v10;
}

void sub_100048488(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (*(void *)(a4 + 8) == 2 && !*(_DWORD *)(a1 + 1100) && a2 == 1)
  {
    if (*(void *)(a1 + 3568))
    {
      uint64_t v21 = 0;
      if (!jfs_get_tree_in_snap(a1, 4, a5, *(void *)(a1 + 432), &v21))
      {
        if (v21 != a3 && create_or_modify_jobj(a1, v21, (unsigned __int8 *)a4, a5, a6, v11, v12, v13))
        {
          if (nx_ratelimit_log_allowed(*(void *)(a1 + 392))) {
            log_err((uint64_t)"%s:%d: %s Shadow create_or_modify_jobj(jobj %p id %lld xid %lld op %d) failed with error %d\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"duplicate_jobj_op_to_shadow_fs_root");
          }
        }
        obj_release(v21);
      }
    }
  }
}

uint64_t remove_jobj(uint64_t a1, uint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t matched = match_jobj_type_to_tree_type(a1, *a3, a2, a4, a5, a6, a7, a8);
  if (matched == 5)
  {
    uint64_t tree_in_snap = fext_tree_remove(a1, a4, *((void *)a3 + 1), *((void *)a3 + 2));
    if (tree_in_snap) {
      log_err((uint64_t)"%s:%d: %s fext_tree_remove returned %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"remove_jobj");
    }
  }
  else
  {
    uint64_t v20 = matched;
    uint64_t v28 = 0;
    uint64_t v29 = 0;
    uint64_t tree_in_snap = jfs_get_tree_in_snap(a1, matched, a4, *(void *)(a1 + 432), &v29);
    if (!tree_in_snap)
    {
      uint64_t tree_in_snap = sub_1000483E4(a1, (uint64_t)a3, v20, &v28, (uint64_t)"removal", v21, v22, v23);
      if (!tree_in_snap)
      {
        uint64_t tree_in_snap = create_or_modify_jobj(a1, v29, a3, a4, 4, v24, v25, v26);
        if (!tree_in_snap) {
          sub_100048488(a1, v20, v29, (uint64_t)a3, a4, 4);
        }
      }
      obj_release(v29);
    }
  }
  return tree_in_snap;
}

unsigned __int16 *key_val_to_jobj(uint64_t a1, uint64_t a2, unint64_t a3, unsigned __int16 *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (jobj_validate_key_val(a1, a2, a3, a4, a5, a6, a7, a8)) {
    return 0;
  }
  uint64_t v22 = *(void *)a2 >> 60;
  LODWORD(v23) = 40;
  switch((int)v22)
  {
    case 1:
      if (!a4) {
        return 0;
      }
      uint64_t v24 = a4[24];
      uint64_t v25 = 80;
      goto LABEL_32;
    case 2:
      goto LABEL_36;
    case 3:
      LODWORD(v23) = 648;
      goto LABEL_36;
    case 4:
      if (!a4) {
        return 0;
      }
      uint64_t v24 = *(unsigned __int16 *)(a2 + 8) + 24;
      uint64_t v25 = a4[1];
      goto LABEL_32;
    case 5:
      if (!a4) {
        return 0;
      }
      uint64_t v24 = a4[4];
      goto LABEL_18;
    case 6:
    case 12:
      LODWORD(v23) = 24;
      goto LABEL_36;
    case 7:
      if (!a4) {
        return 0;
      }
      if (a4[2] == 6) {
        uint64_t v24 = HIBYTE(a4[11]) + a4[11];
      }
      else {
        uint64_t v24 = a4[11];
      }
LABEL_18:
      uint64_t v25 = 40;
      goto LABEL_32;
    case 8:
      LODWORD(v23) = 56;
      goto LABEL_36;
    case 9:
      if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 9) != 0)
      {
        LODWORD(v23) = (*(_DWORD *)(a2 + 8) & 0x3FF) + 72;
        goto LABEL_36;
      }
      uint64_t v24 = *(unsigned __int16 *)(a2 + 8);
      uint64_t v25 = 72;
LABEL_32:
      unint64_t v35 = v24 + v25;
      LODWORD(v23) = (unsigned __int16)v35;
      if (v35 >> 16) {
        BOOL v36 = 1;
      }
      else {
        BOOL v36 = (unsigned __int16)v35 == 0;
      }
      if (!v36) {
        goto LABEL_36;
      }
      return 0;
    case 10:
      LODWORD(v23) = 96;
      goto LABEL_36;
    case 11:
      uint64_t v24 = *(unsigned __int16 *)(a2 + 8);
      uint64_t v25 = 32;
      goto LABEL_32;
    case 13:
      if (!a4) {
        return 0;
      }
      int v26 = *(unsigned __int8 *)(a2 + 15);
      if (v26 == 2)
      {
        LODWORD(v23) = 80;
      }
      else
      {
        if (v26 != 1) {
          return 0;
        }
        LODWORD(v23) = *((unsigned __int8 *)a4 + 2) + 32;
      }
      goto LABEL_36;
    case 14:
      int v27 = *(_DWORD *)(a2 + 8);
      if ((v27 - 16) >= 4u)
      {
        BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
        log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s *** unknown expanded obj type %hhu\n", v29, v30, v31, v32, v33, v34, (uint64_t)"jobj_size_for_large_key_val");
        return 0;
      }
      unint64_t v23 = (0x48006000200050uLL >> (16 * (v27 - 16))) & 0x78;
LABEL_36:
      if (v22 == 14)
      {
        LODWORD(v37) = *(unsigned __int8 *)(a2 + 8);
        if (v37 <= 0xF)
        {
          log_err((uint64_t)"%s:%d: unknown expanded type (%hhu) on record (%u)\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"jobj_allocate");
          return 0;
        }
      }
      else
      {
        uint64_t v37 = *(void *)a2 >> 60;
      }
      switch((int)v37)
      {
        case 1:
          uint64_t v20 = (unsigned __int16 *)_apfs_calloc(1uLL, 0x50uLL);
          if (!v20) {
            return v20;
          }
          if (v23 <= 0x4F) {
            sub_1000602A4();
          }
          uint64_t v39 = _apfs_calloc(1uLL, v23 - 80);
          *((void *)v20 + 9) = v39;
          if (v39) {
            goto LABEL_74;
          }
          uint64_t v47 = v20;
          uint64_t v48 = 80;
          goto LABEL_61;
        case 2:
          size_t v38 = 40;
          goto LABEL_72;
        case 3:
          uint64_t v49 = (unsigned __int16 *)_apfs_zalloc(2u);
          goto LABEL_73;
        case 4:
          if (v23 <= 0x17) {
            sub_1000602FC();
          }
          goto LABEL_67;
        case 5:
          if (v23 <= 0x27) {
            sub_100060328();
          }
          goto LABEL_67;
        case 6:
        case 12:
          size_t v38 = 24;
          goto LABEL_72;
        case 7:
          if (v23 <= 0x27) {
            sub_10006024C();
          }
          goto LABEL_67;
        case 8:
          size_t v38 = 56;
          goto LABEL_72;
        case 9:
          uint64_t v20 = (unsigned __int16 *)_apfs_calloc(1uLL, 0x48uLL);
          if (!v20) {
            return v20;
          }
          if (v23 <= 0x47) {
            sub_100060278();
          }
          uint64_t v50 = _apfs_malloc(v23 - 72);
          *((void *)v20 + 8) = v50;
          if (v50) {
            goto LABEL_74;
          }
          uint64_t v47 = v20;
          uint64_t v48 = 72;
LABEL_61:
          _apfs_free(v47, v48);
          return 0;
        case 10:
        case 18:
          size_t v38 = 96;
          goto LABEL_72;
        case 11:
          if (v23 <= 0x1F) {
            sub_1000602D0();
          }
          goto LABEL_67;
        case 13:
          uint64_t v51 = HIBYTE(*(void *)(a2 + 8));
          if (v51 == 2) {
            goto LABEL_68;
          }
          if (v51 != 1)
          {
            log_err((uint64_t)"%s:%d: *** Unknown file info type %llu\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"jobj_allocate");
            return 0;
          }
          if (v23 <= 0x1F) {
            sub_100060354();
          }
LABEL_67:
          uint64_t v49 = (unsigned __int16 *)_apfs_malloc(v23);
LABEL_73:
          uint64_t v20 = v49;
          if (!v49) {
            return v20;
          }
LABEL_74:
          unint64_t v52 = *(void *)a2;
          *((void *)v20 + 1) = *(void *)a2 & 0xFFFFFFFFFFFFFFFLL;
          v52 >>= 60;
          *(unsigned char *)uint64_t v20 = v52;
          *((unsigned char *)v20 + 1) = 1;
          v20[1] = v23;
          switch((int)v52)
          {
            case 1:
              *((_OWORD *)v20 + 1) = *(_OWORD *)a4;
              *((_OWORD *)v20 + 2) = *((_OWORD *)a4 + 1);
              *((void *)v20 + 6) = *((void *)a4 + 4);
              *((void *)v20 + 7) = *((void *)a4 + 5);
              size_t v53 = a4[24];
              v20[32] = v53;
              uint64_t v54 = (char *)*((void *)v20 + 9);
              uint64_t v55 = (const char *)(a4 + 25);
              goto LABEL_82;
            case 2:
              uint64_t v56 = *((void *)a4 + 1);
              uint64_t v57 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
              *((unsigned char *)v20 + 1) = *(void *)a4 >> 60;
              *((_DWORD *)v20 + 8) = *((_DWORD *)a4 + 4);
              *((void *)v20 + 2) = v57;
              *((void *)v20 + 3) = v56;
              return v20;
            case 3:
              *((void *)v20 + 2) = *(void *)a4;
              *((void *)v20 + 3) = *((void *)a4 + 1);
              *((void *)v20 + 4) = *((void *)a4 + 2);
              *((void *)v20 + 5) = *((void *)a4 + 3);
              *((void *)v20 + 6) = *((void *)a4 + 4);
              *((void *)v20 + 7) = *((void *)a4 + 5);
              *((_DWORD *)v20 + 18) = *((_DWORD *)a4 + 14);
              *((void *)v20 + 8) = *((void *)a4 + 6);
              *((_DWORD *)v20 + 19) = *((_DWORD *)a4 + 15);
              *((_DWORD *)v20 + 20) = *((_DWORD *)a4 + 16);
              *((_DWORD *)v20 + 21) = *((_DWORD *)a4 + 17);
              *((_DWORD *)v20 + 22) = *((_DWORD *)a4 + 18);
              *((_DWORD *)v20 + 23) = *((_DWORD *)a4 + 19);
              v20[48] = a4[40];
              v20[49] = a4[41];
              *((void *)v20 + 13) = *(void *)(a4 + 42);
              if (a5 < 0x5D) {
                return v20;
              }
              if (xf_init_with_blob(v20 + 204, a4 + 46, a5 - 92))
              {
                log_debug((uint64_t)"%s:%d: failed to init extended fields on inode %lld from blob (xfret %d).\n", v58, v59, v60, v61, v62, v63, v64, (uint64_t)"key_val_to_jobj");
                return v20;
              }
              uint64_t v111 = v20[204];
              if (!v20[204]) {
                return v20;
              }
              int v112 = 0;
              uint64_t v113 = (_WORD *)(*((void *)v20 + 52) + 2);
              break;
            case 4:
              size_t v65 = *(unsigned __int16 *)(a2 + 8);
              v20[10] = v65;
              strlcpy((char *)v20 + 24, (const char *)(a2 + 10), v65);
              *((_DWORD *)v20 + 4) = *a4;
              size_t v66 = a4[1];
              v20[11] = v66;
              uint64_t v67 = (char *)v20 + v20[10] + 24;
              uint64_t v68 = a4 + 2;
              goto LABEL_98;
            case 5:
              uint64_t v69 = *(void *)a4;
              *((void *)v20 + 2) = *(void *)(a2 + 8);
              *((void *)v20 + 3) = v69;
              size_t v53 = a4[4];
              v20[16] = v53;
              uint64_t v54 = (char *)(v20 + 17);
              uint64_t v55 = (const char *)(a4 + 5);
LABEL_82:
              strlcpy(v54, v55, v53);
              return v20;
            case 6:
              *((_DWORD *)v20 + 4) = *(_DWORD *)a4;
              return v20;
            case 7:
              *((_DWORD *)v20 + 4) = *(_DWORD *)a4;
              LODWORD(v70) = a4[11];
              int v72 = a4[2];
              uint64_t v71 = a4 + 2;
              uint64_t v67 = (char *)(v20 + 10);
              if (v72 == 6) {
                uint64_t v70 = (v70 >> 8) + v70;
              }
              else {
                uint64_t v70 = v70;
              }
              size_t v66 = v70 + 20;
              uint64_t v68 = v71;
              goto LABEL_98;
            case 8:
              *((void *)v20 + 2) = *(void *)(a2 + 8);
              uint64_t v73 = *(void *)a4;
              *((void *)v20 + 5) = *(void *)a4 & 0xFFFFFFFFFFFFFFLL;
              *(_OWORD *)(v20 + 12) = *(_OWORD *)(a4 + 4);
              *((unsigned char *)v20 + 48) = HIBYTE(v73);
              return v20;
            case 9:
              if ((*(unsigned char *)(*(void *)(a1 + 376) + 56) & 9) != 0)
              {
                unsigned int v74 = *(_DWORD *)(a2 + 8);
                *((_DWORD *)v20 + 14) = v74 >> 10;
                v20[31] = v74 & 0x3FF;
                uint64_t v75 = (char *)*((void *)v20 + 8);
                uint64_t v76 = (const char *)(a2 + 12);
                size_t v77 = v74 & 0x3FF;
              }
              else
              {
                *((_DWORD *)v20 + 14) = 0;
                size_t v77 = *(unsigned __int16 *)(a2 + 8);
                v20[31] = v77;
                uint64_t v75 = (char *)*((void *)v20 + 8);
                uint64_t v76 = (const char *)(a2 + 10);
              }
              strlcpy(v75, v76, v77);
              *((void *)v20 + 2) = *(void *)a4;
              *((void *)v20 + 3) = *((void *)a4 + 1);
              v20[30] = a4[8];
              int v88 = v20 + 16;
              if (a5 < 0x13)
              {
                xf_init((uint64_t)v88, 0);
              }
              else if (xf_init_with_blob(v88, a4 + 9, a5 - 18))
              {
                log_debug((uint64_t)"%s:%d: failed to init extended fields on drec %lld from blob.\n", v89, v90, v91, v92, v93, v94, v95, (uint64_t)"key_val_to_jobj");
              }
              return v20;
            case 10:
              *(_OWORD *)(v20 + 12) = *(_OWORD *)a4;
              *((int8x16_t *)v20 + 3) = vextq_s8(*((int8x16_t *)a4 + 1), *((int8x16_t *)a4 + 1), 8uLL);
              return v20;
            case 11:
              size_t v78 = *(unsigned __int16 *)(a2 + 8);
              if (v78 + 32 > v23) {
                sub_100060220();
              }
              v20[12] = v78;
              strlcpy((char *)v20 + 26, (const char *)(a2 + 10), v78);
              goto LABEL_94;
            case 12:
LABEL_94:
              *((void *)v20 + 2) = *(void *)a4;
              return v20;
            case 13:
              unint64_t v79 = *(void *)(a2 + 8);
              *((unsigned char *)v20 + 16) = HIBYTE(v79);
              *((void *)&v80 + 1) = *(void *)(a2 + 8);
              *(void *)&long long v80 = v79;
              *((void *)v20 + 2) = v80 >> 56;
              if (HIBYTE(v79) == 2)
              {
                *((void *)v20 + 3) = *(void *)a4;
                *((void *)v20 + 4) = *((void *)a4 + 1);
                *((void *)v20 + 5) = *((void *)a4 + 2);
                v20[24] = a4[12];
                if (a5 < 0x1B)
                {
                  log_err((uint64_t)"%s:%d: %s s_hash <%llu> finfo attribution tag value <%zu> is less than sizeof(j_file_attribution_tag_val_t) <%lu\n", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"key_val_to_jobj");
                  return v20;
                }
                int v96 = xf_init_with_blob(v20 + 28, a4 + 13, a5 - 26);
                if (v96)
                {
                  strerror(v96);
                  log_debug((uint64_t)"%s:%d: failed to init extended fields on attribution tag record with objid <%lld> from blob due to error <%d> %s\n", v104, v105, v106, v107, v108, v109, v110, (uint64_t)"key_val_to_jobj");
                  return v20;
                }
                uint64_t v115 = v20[28];
                if (v20[28])
                {
                  int v116 = 0;
                  for (uint64_t i = (unsigned __int16 *)(*((void *)v20 + 8) + 2); ; i += 2)
                  {
                    int v118 = *i;
                    if (*((unsigned char *)i - 2) == 1) {
                      break;
                    }
                    v116 += (v118 + 7) & 0x1FFF8;
                    if (!--v115) {
                      return v20;
                    }
                  }
                  if ((__int16)*i <= 0) {
                    log_err((uint64_t)"%s:%d: %s size (%d) of FILE_INFO_TAG_EXT_TYPE_SIGNING_ID in attribution tag record with s_hash <%llu> <= 0 \n", v97, v98, v99, v100, v101, v102, v103, (uint64_t)"key_val_to_jobj");
                  }
                  else {
                    *(unsigned char *)(*((void *)v20 + 9) + v116 + v118 - 1) = 0;
                  }
                }
              }
              else if (HIBYTE(v79) == 1)
              {
                v20[12] = *a4;
                size_t v66 = *((unsigned __int8 *)a4 + 2);
                *((unsigned char *)v20 + 26) = v66;
                uint64_t v67 = (char *)v20 + 27;
                uint64_t v68 = (unsigned __int16 *)((char *)a4 + 3);
LABEL_98:
                memcpy(v67, v68, v66);
              }
              return v20;
            case 14:
              if (a3 >= 0xC && sub_1000490BC(a1, (uint64_t)v20, a2, (uint64_t)a4, a5, v44, v45, v46)) {
                return v20;
              }
              log_err((uint64_t)"%s:%d: %s cannot translate key-val (%llu) into valid jobj\n", v40, v41, v42, v43, v44, v45, v46, (uint64_t)"key_val_to_jobj");
              jobj_release(v81, v20, v82, v83, v84, v85, v86, v87);
              return 0;
            default:
              return v20;
          }
          break;
        case 16:
LABEL_68:
          size_t v38 = 80;
          goto LABEL_72;
        case 17:
          size_t v38 = 32;
          goto LABEL_72;
        case 19:
          size_t v38 = 72;
LABEL_72:
          uint64_t v49 = (unsigned __int16 *)_apfs_calloc(1uLL, v38);
          goto LABEL_73;
        default:
          log_err((uint64_t)"%s:%d: *** Can't allocate unknown obj type %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"jobj_allocate");
          return 0;
      }
      break;
    default:
      log_err((uint64_t)"%s:%d: *** unknown obj type %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"jobj_size_for_key_val");
      return 0;
  }
  while (1)
  {
    int v114 = (unsigned __int16)*v113;
    if (*((unsigned char *)v113 - 2) == 4)
    {
      if (*v113) {
        break;
      }
    }
    v113 += 2;
    v112 += (v114 + 7) & 0x1FFF8;
    if (!--v111) {
      return v20;
    }
  }
  *(unsigned char *)(*((void *)v20 + 53) + v112 + v114 - 1) = 0;
  return v20;
}

uint64_t sub_1000490BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8 = *(unsigned __int8 *)(a3 + 8);
  if (v8 > 0xF)
  {
    uint64_t v9 = a2;
    *(unsigned char *)a2 = v8;
    switch(v8)
    {
      case 0x10u:
        *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 12);
        *(void *)(a2 + 32) = *(void *)a4;
        *(void *)(a2 + 40) = *(void *)(a4 + 8);
        *(_DWORD *)(a2 + 48) = *(_DWORD *)(a4 + 16);
        *(_DWORD *)(a2 + 52) = *(_DWORD *)(a4 + 20);
        uint64_t v10 = (unsigned __int16 *)(a2 + 56);
        if (a5 < 0x19) {
          goto LABEL_15;
        }
        if (xf_init_with_blob(v10, (unsigned __int16 *)(a4 + 24), a5 - 24)) {
          log_err((uint64_t)"%s:%d: %s failed to init extended fields on purgeable %llu from blob\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"large_key_val_to_jobj");
        }
        break;
      case 0x11u:
        uint64_t v18 = *(void *)a4;
        *(void *)(a2 + 16) = *(void *)(a3 + 12);
        *(void *)(a2 + 24) = v18;
        break;
      case 0x12u:
        *(void *)(a2 + 16) = *(void *)(a4 + 24);
        *(void *)(a2 + 24) = *(void *)a4;
        *(void *)(a2 + 32) = *(void *)(a4 + 8);
        *(void *)(a2 + 40) = *(void *)(a4 + 16);
        *(void *)(a2 + 56) = *(void *)(a4 + 32);
        *(void *)(a2 + 48) = *(void *)(a4 + 40);
        *(_DWORD *)(a2 + 92) = *(_DWORD *)(a4 + 48);
        uint64_t v10 = (unsigned __int16 *)(a2 + 64);
        if (a5 < 0x35) {
          goto LABEL_15;
        }
        if (xf_init_with_blob(v10, (unsigned __int16 *)(a4 + 52), a5 - 52)) {
          log_err((uint64_t)"%s:%d: %s failed to init extended fields on dir-stats %llu from blob\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"large_key_val_to_jobj");
        }
        break;
      case 0x13u:
        *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 12);
        *(void *)(a2 + 32) = *(void *)a4 & 0xFFFFFFFFFFFFFFLL;
        *(_DWORD *)(a2 + 40) = *(unsigned __int8 *)(a4 + 7);
        uint64_t v10 = (unsigned __int16 *)(a2 + 48);
        if (a5 < 9)
        {
LABEL_15:
          xf_init((uint64_t)v10, 0);
        }
        else if (xf_init_with_blob(v10, (unsigned __int16 *)(a4 + 8), a5 - 8))
        {
          log_err((uint64_t)"%s:%d: %s failed to init extended fields on clone mapping <%llu/%llu> from blob\n", v26, v27, v28, v29, v30, v31, v32, (uint64_t)"large_key_val_to_jobj");
        }
        break;
      default:
        return v9;
    }
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s unknown expanded type (%hhu) on record (%u)\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"large_key_val_to_jobj");
    return 0;
  }
  return v9;
}

uint64_t lookup_jobj(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned __int8 *a4, unsigned __int16 **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return lookup_jobj_in_snap(a1, a2, a3, a4, *(void *)(a1 + 432), a5, a7, a8);
}

uint64_t lookup_jobj_in_snap(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned __int8 *a4, unint64_t a5, unsigned __int16 **a6, uint64_t a7, uint64_t a8)
{
  int matched = match_jobj_type_to_tree_type(a1, *a4, a2, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  uint64_t v14 = _apfs_zalloc(3u);
  if (!v14) {
    return 12;
  }
  uint64_t v15 = (uint64_t)v14;
  unsigned int v23 = 832;
  unsigned int v24 = 3808;
  make_jkey_from_jobj(a1, a4, (uint64_t)v14, (int *)&v23);
  uint64_t v22 = 0;
  uint64_t tree_in_snap = jfs_get_tree_in_snap(a1, matched, 0, a5, &v22);
  if (tree_in_snap)
  {
    uint64_t v17 = tree_in_snap;
LABEL_6:
    _apfs_zfree((void *)v15, 3u);
    return v17;
  }
  uint64_t v17 = bt_lookup_variant(v22, a5, (unint64_t *)v15, &v23, 0x340u, (void *)(v15 + 832), &v24, 0, 0, a3);
  obj_release(v22);
  if (v17) {
    goto LABEL_6;
  }
  *a6 = key_val_to_jobj(a1, v15, v23, (unsigned __int16 *)(v15 + 832), v24, v18, v19, v20);
  _apfs_zfree((void *)v15, 3u);
  if (*a6) {
    return 0;
  }
  else {
    return nx_corruption_detected_int(*(void *)(a1 + 392));
  }
}

uint64_t initialize_phys_range_lock_state(uint64_t a1, unsigned int a2)
{
  *(void *)(a1 + 96) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v4 = a2;
  *(_DWORD *)(a1 + 92) = a2;
  uint64_t v5 = _apfs_calloc(a2, 0x10uLL);
  *(void *)a1 = v5;
  if (v5)
  {
    size_t v6 = (a2 + 63) >> 6;
    *(_DWORD *)(a1 + 88) = v6;
    unint64_t v7 = _apfs_calloc(v6, 8uLL);
    *(void *)(a1 + 72) = v7;
    if (v7)
    {
      unsigned int v8 = _apfs_calloc(*(unsigned int *)(a1 + 88), 8uLL);
      *(void *)(a1 + 80) = v8;
      if (v8)
      {
        new_lock((pthread_mutex_t *)(a1 + 8));
        return 0;
      }
      _apfs_free(*(void **)a1, 16 * v4);
      uint64_t v10 = *(void **)(a1 + 72);
      uint64_t v11 = 8 * *(unsigned int *)(a1 + 88);
    }
    else
    {
      uint64_t v10 = *(void **)a1;
      uint64_t v11 = 16 * v4;
    }
    _apfs_free(v10, v11);
  }
  return 12;
}

uint64_t release_phys_range_lock_state(uint64_t a1)
{
  _apfs_free(*(void **)a1, 16 * *(unsigned int *)(a1 + 92));
  _apfs_free(*(void **)(a1 + 72), 8 * *(unsigned int *)(a1 + 88));
  _apfs_free(*(void **)(a1 + 80), 8 * *(unsigned int *)(a1 + 88));

  return free_lock((pthread_mutex_t *)(a1 + 8));
}

uint64_t jobj_type_from_possibly_large_key(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)a2 >> 60;
  if (v2 == 14)
  {
    if (!a1 || (*(unsigned char *)(*(void *)(a1 + 376) + 57) & 2) != 0)
    {
      LODWORD(v2) = *(_DWORD *)(a2 + 8);
    }
    else
    {
      BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(*(void *)(a1 + 392));
      log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: %s expanded record found on unsupported volume\n", v4, v5, v6, v7, v8, v9, (uint64_t)"jobj_type_from_possibly_large_key");
      LOBYTE(v2) = 15;
    }
  }
  return v2;
}

uint64_t iterate_jobjs_with_hint_and_snap(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, uint64_t (*a6)(long long *, uint64_t), uint64_t a7, _OWORD *a8, unsigned int a9)
{
  int matched = match_jobj_type_to_tree_type(a1, *a5, a2, a4, (uint64_t)a5, (uint64_t)a6, a7, (uint64_t)a8);
  if (matched == 5)
  {
    uint64_t v17 = *((void *)a5 + 2);
    if (v17 == -1) {
      uint64_t v18 = 0;
    }
    else {
      uint64_t v18 = *((void *)a5 + 2);
    }
    if (v17 == -1 && (unsigned __int16)a9 == 4) {
      unsigned int v20 = a9 & 0xFFFF0000;
    }
    else {
      unsigned int v20 = a9;
    }
    return fext_tree_iterate_fexts_with_flags(a1, a3, a4, *((void *)a5 + 1), v18, a8, v20, a6, a7);
  }
  int v22 = matched;
  unsigned int v23 = (unint64_t *)_apfs_zalloc(3u);
  if (!v23) {
    return 12;
  }
  unsigned int v24 = v23;
  int v49 = 832;
  uint64_t v47 = a6;
  if (!*((void *)a5 + 1) && !*a5)
  {
    if ((a9 & 0x10000) == 0 && a5[1]) {
      goto LABEL_16;
    }
LABEL_20:
    int v25 = 1;
    goto LABEL_21;
  }
  if ((a9 & 0x10000) != 0) {
    goto LABEL_20;
  }
LABEL_16:
  int v25 = 0;
LABEL_21:
  uint64_t v52 = 0;
  long long v51 = 0u;
  memset(v50, 0, sizeof(v50));
  uint64_t v48 = 0;
  if ((a9 & 0x20000) != 0) {
    char v27 = v25;
  }
  else {
    char v27 = 1;
  }
  char v46 = v27;
  make_jkey_from_jobj(a1, a5, (uint64_t)v23, &v49);
  if (v22 == 1)
  {
    uint64_t v28 = *((void *)a5 + 1);
    if ((~v28 & 0xFFFFFFFFFFF0000) == 0 || v28 == 2) {
      int v22 = 4;
    }
    else {
      int v22 = 1;
    }
  }
  uint64_t tree_in_snap = jfs_get_tree_in_snap(a1, v22, a3, a4, &v48);
  if (tree_in_snap)
  {
    uint64_t v26 = tree_in_snap;
    goto LABEL_37;
  }
  bt_iterator_init_with_hint((uint64_t)v50, v48, a4, (unsigned __int16)a9, v24, v49, 0x340u, v24 + 104, 0xEE0u, a8);
  uint64_t v26 = v31;
  if ((v31 & 0xFFFFFFFD) != 0) {
    goto LABEL_36;
  }
  if (bt_iterator_ended((uint64_t)v50))
  {
LABEL_35:
    uint64_t v26 = 0;
    goto LABEL_36;
  }
  unsigned int v35 = v25 | ((a9 & 0x20000) >> 17);
  while (1)
  {
    if (v35)
    {
      if ((v46 & 1) == 0)
      {
        if (*a5)
        {
          int v36 = *a5;
          if (v36 != jobj_type_from_possibly_large_key(a1, (uint64_t)v24)) {
            goto LABEL_53;
          }
        }
      }
    }
    else if ((*v24 & 0xFFFFFFFFFFFFFFFLL) != *((void *)a5 + 1) {
           || *a5 && jobj_type_from_possibly_large_key(a1, (uint64_t)v24) != *a5)
    }
    {
      goto LABEL_35;
    }
    uint64_t v37 = key_val_to_jobj(a1, (uint64_t)v24, v51, (unsigned __int16 *)v24 + 416, DWORD1(v51), v32, v33, v34);
    if (!v37) {
      break;
    }
    size_t v38 = v37;
    uint64_t v26 = v47((long long *)v37, a7);
    jobj_release(v26, v38, v39, v40, v41, v42, v43, v44);
    if (v26) {
      goto LABEL_36;
    }
LABEL_53:
    uint64_t v45 = bt_iterator_next((uint64_t)v50);
    if ((a9 & 0x40000) == 0)
    {
      uint64_t v26 = v45;
      if (v45) {
        goto LABEL_36;
      }
    }
    if (bt_iterator_ended((uint64_t)v50)) {
      goto LABEL_35;
    }
  }
  if ((a9 & 0x40000) != 0) {
    goto LABEL_53;
  }
  uint64_t v26 = 12;
LABEL_36:
  obj_release(v48);
LABEL_37:
  _apfs_zfree(v24, 3u);
  return v26;
}

uint64_t iterate_raw_jobjs_with_hint(uint64_t a1, int a2, uint64_t a3, unsigned __int8 *a4, size_t a5, uint64_t a6, uint64_t a7, _DWORD *a8, uint64_t *a9, int a10)
{
  v28[0] = a1;
  v28[1] = a6;
  unint64_t v14 = *(void *)a4;
  uint64_t v15 = *(void *)a4 & 0xFFFFFFFFFFFFFFFLL;
  v28[2] = a7;
  unint64_t v28[3] = v15;
  unint64_t v16 = v14 >> 60;
  if (v14 >> 60 == 14) {
    LODWORD(v16) = a4[8];
  }
  uint64_t v29 = v16;
  BYTE2(v29) = 0;
  *(void *)char v27 = 0;
  if (a8) {
    *a8 = 0;
  }
  if (v15 || v16)
  {
    if ((a10 & 0x20000) != 0) {
      BYTE2(v29) = 1;
    }
  }
  else
  {
    BYTE1(v29) = 1;
  }
  if ((~v14 & 0xFFFFFFFFFFF0000) == 0 || v15 == 2) {
    int v18 = 4;
  }
  else {
    int v18 = 1;
  }
  if (a2 == 1) {
    a2 = v18;
  }
  uint64_t result = jfs_get_tree_in_snap(a1, a2, a3, *(void *)(a1 + 432), (uint64_t **)v27);
  if (!result)
  {
    if ((a10 & 0x800) != 0)
    {
      unsigned int v20 = (char *)_apfs_zalloc(3u);
      if (!v20) {
        return 12;
      }
    }
    else
    {
      unsigned int v20 = 0;
    }
    uint64_t v21 = *(void *)(a1 + 432);
    int v22 = a10 & 0xF1FF;
    int v23 = a10 & 0xE00;
    switch(v23)
    {
      case 2048:
        unsigned int v24 = bt_iterate_individual(*(uint64_t **)v27, v21, v22, a4, a5, a9, (uint64_t (*)(void, void, void, void, uint64_t, __n128))sub_100049A94, (uint64_t)v28, v20, v20 + 832);
        break;
      case 1024:
        unsigned int v24 = bt_iterate_bulk(*(uint64_t **)v27, v21, v22, (unint64_t *)a4, a5, a9, (uint64_t (*)(void, uint64_t, void, void, uint64_t))sub_100049A94, (uint64_t)v28);
        break;
      case 512:
        unsigned int v24 = bt_iterate_per_node(*(uint64_t **)v27, v21, v22, (unint64_t *)a4, a5, a9, (uint64_t (*)(const void *, void, uint64_t, void, uint64_t))sub_100049A94, (uint64_t)v28);
        break;
      default:
        unsigned int v25 = 22;
        if ((a10 & 0x800) == 0) {
          goto LABEL_31;
        }
        goto LABEL_30;
    }
    unsigned int v25 = v24;
    if ((a10 & 0x800) == 0)
    {
LABEL_31:
      obj_release(*(uint64_t **)v27);
      if (v25 == 2 || v25 == 0x80000000) {
        uint64_t result = 0;
      }
      else {
        uint64_t result = v25;
      }
      if (a8) {
        *a8 = result == 0;
      }
      return result;
    }
LABEL_30:
    _apfs_zfree(v20, 3u);
    goto LABEL_31;
  }
  return result;
}

uint64_t sub_100049A94(void *a1, unsigned int a2, unsigned __int16 *a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11 = a2;
  uint64_t v12 = a4;
  uint64_t result = jobj_validate_key_val(*(void *)a5, (uint64_t)a1, a2, a3, a4, a6, a7, a8);
  if (result) {
    return result;
  }
  if (!*(unsigned char *)(a5 + 33))
  {
    if (!*(unsigned char *)(a5 + 34))
    {
      if ((*a1 & 0xFFFFFFFFFFFFFFFLL) != *(void *)(a5 + 24)
        || *(unsigned char *)(a5 + 32)
        && jobj_type_from_possibly_large_key(*(void *)a5, (uint64_t)a1) != *(unsigned __int8 *)(a5 + 32))
      {
        return 0x80000000;
      }
      goto LABEL_8;
    }
    goto LABEL_6;
  }
  if (*(unsigned char *)(a5 + 34))
  {
LABEL_6:
    if (*(unsigned char *)(a5 + 32)
      && jobj_type_from_possibly_large_key(*(void *)a5, (uint64_t)a1) != *(unsigned __int8 *)(a5 + 32))
    {
      return 0;
    }
  }
LABEL_8:
  uint64_t v15 = *(uint64_t (**)(void *, uint64_t, unsigned __int16 *, uint64_t, uint64_t))(a5 + 8);
  uint64_t v14 = *(void *)(a5 + 16);

  return v15(a1, v11, a3, v12, v14);
}

uint64_t apfs_cstrncmp(unsigned __int8 *a1, unsigned __int8 *a2, unint64_t a3, unint64_t a4)
{
  if (a3 >= a4) {
    unint64_t v4 = a4;
  }
  else {
    unint64_t v4 = a3;
  }
  unint64_t v5 = v4 - 2;
  if (v4 < 2)
  {
LABEL_11:
    if (a3 < a4) {
      LODWORD(v7) = -1;
    }
    else {
      LODWORD(v7) = 1;
    }
    if (a3 == a4) {
      return 0;
    }
    else {
      return v7;
    }
  }
  else
  {
    while (1)
    {
      int v6 = *a1;
      uint64_t v7 = v6 - *a2;
      if (v7) {
        break;
      }
      ++a1;
      ++a2;
      if (v6) {
        BOOL v8 = v5 == 0;
      }
      else {
        BOOL v8 = 1;
      }
      --v5;
      if (v8) {
        goto LABEL_11;
      }
    }
  }
  return v7;
}

uint64_t create_new_crypto_state_for_id(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 != 4) {
    panic("assertion failed: %s", "crypto_id == 4");
  }
  unint64_t v5 = _apfs_calloc(1uLL, 0x60uLL);
  if (v5)
  {
    int v6 = v5;
    uint64_t v7 = (unsigned __int8 *)_apfs_malloc(0xA8uLL);
    if (v7)
    {
      BOOL v8 = v7;
      *int v6 = 4;
      *(_DWORD *)uint64_t v7 = 2621703;
      *((void *)v7 + 1) = 4;
      *((_DWORD *)v7 + 4) = 1;
      wrap_crypto_state(a1, (uint64_t)v6, (uint64_t)v7);
      uint64_t inserted = insert_jobj(a1, 1, v8, a2, v9, v10, v11, v12);
      crypto_obj_release(v6);
      _apfs_free(v8, 168);
      return inserted;
    }
    crypto_obj_release(v6);
  }
  return 12;
}

uint64_t get_new_crypto_id(uint64_t a1, unsigned int a2, char a3, uint64_t a4, unint64_t *a5, uint64_t a6)
{
  switch(get_vol_crypto(a1))
  {
    case 1u:
      uint64_t v15 = *(void *)(a1 + 496);
      if (!v15) {
        uint64_t v15 = a1;
      }
      if ((*(unsigned char *)(*(void *)(v15 + 376) + 264) & 9) != 0) {
        panic("assertion failed: %s", "fs_is_content_protected(apfs)");
      }
      if (*(_DWORD *)(a1 + 1100)) {
        panic("assertion failed: %s", "!apfs->apfs_readonly");
      }
      unint64_t v16 = (unint64_t *)_apfs_calloc(1uLL, 0x60uLL);
      if (!v16) {
        return 12;
      }
      uint64_t v17 = v16;
      if ((*a5 & 0xFFFFFFFFFFFFFFFELL) == 4) {
        panic("invalid crypto id");
      }
      int v18 = _apfs_malloc(0xA8uLL);
      if (v18)
      {
        uint64_t v19 = v18;
        unint64_t add_explicit = *a5;
        if (!*a5)
        {
          if (!a4) {
            sub_100060380();
          }
          unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)(a1 + 376) + 176), 1uLL, memory_order_relaxed);
          *a5 = add_explicit;
        }
        *uint64_t v17 = add_explicit;
        *(_DWORD *)int v18 = 2621703;
        *((void *)v18 + 1) = *a5;
        *((_DWORD *)v18 + 4) = 1;
        if (crypto_state_init())
        {
          crypto_obj_release(v17);
          _apfs_free(v19, 168);
          return 1;
        }
        else
        {
          wrap_crypto_state(a1, (uint64_t)v17, (uint64_t)v19);
          v19[1] += v19[19];
          uint64_t inserted = insert_jobj(a1, 1, (unsigned __int8 *)v19, a4, v22, v23, v24, v25);
          if (!inserted)
          {
            _apfs_free(v19, 168);
            if (*a5) {
              return 0;
            }
            goto LABEL_3;
          }
          uint64_t v13 = inserted;
          *a5 = 0;
          crypto_obj_release(v17);
          _apfs_free(v19, 168);
        }
      }
      else
      {
        _apfs_free(v17, 96);
        return 12;
      }
      return v13;
    case 2u:
      goto LABEL_15;
    case 3u:
      if (*(_DWORD *)(a1 + 1100)) {
        panic("assertion failed: %s", "!apfs->apfs_readonly");
      }
      if ((a3 & 2) != 0 || a2 <= 6 && ((1 << a2) & 0x46) != 0 || (int v14 = apfs_kb_supports_class(a1, 4u), a2 == 4) && v14)
      {
        if (!a6) {
          panic("assertion failed: %s", "ino");
        }
        panic("assertion failed: %s", "ino_has_vnode(ino)");
      }
LABEL_15:
      uint64_t v13 = 0;
      *a5 = 4;
      return v13;
    default:
      *a5 = 0;
LABEL_3:
      uint64_t v12 = *(void *)(a1 + 496);
      if (!v12) {
        uint64_t v12 = a1;
      }
      if ((*(unsigned char *)(*(void *)(v12 + 376) + 264) & 9) == 0) {
        panic("assertion failed: %s", "!((err == 0) && (*crypto_id == 0) && fs_is_content_protected(apfs))");
      }
      return 0;
  }
}

#error "10004A060: call analysis failed (funcsize=25)"

BOOL is_sw_crypto(uint64_t a1)
{
  return (*(unsigned char *)(*(void *)(a1 + 376) + 1264) & 4) != 0
      || dev_crypto_type(*(void *)(a1 + 384)) == 0;
}

uint64_t cp_dec_ref(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3) {
    panic("assertion failed: %s", "xid");
  }
  if ((get_vol_crypto(a1) | 2) != 3) {
    return 0;
  }

  return sub_10004DB84(a1, a2, a3, v6, v7, v8, v9, v10);
}

uint64_t fs_reset_dstream(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5, uint64_t a6)
{
  unint64_t v13 = a5;
  *(_OWORD *)a4 = 0u;
  *(_OWORD *)(a4 + 16) = 0u;
  *(void *)(a4 + 32) = 0;
  unsigned int v9 = *(_DWORD *)(a2 + 76);
  if ((*(void *)(a2 + 64) & 8) != 0) {
    char v10 = 2;
  }
  else {
    char v10 = 1;
  }
  uint64_t new_crypto_id = get_new_crypto_id(a1, v9, v10, a6, &v13, a2);
  if (!new_crypto_id)
  {
    *(void *)(a4 + 16) = v13;
    sub_10004B1CC(a1, a2);
    sub_10004B1CC(a1, a2);
    if ((*(unsigned char *)(a2 + 114) & 2) != 0) {
      sub_1000603AC();
    }
    get_vol_crypto(a1);
  }
  return new_crypto_id;
}

uint64_t fs_create_dstream(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  uint64_t v40 = 0;
  memset(__src, 0, sizeof(__src));
  uint64_t v38 = 0;
  if ((*(_WORD *)(a2 + 96) & 0xF000) != 0x8000)
  {
    unint64_t add_explicit = 0;
    int v10 = 0;
    int v11 = 0;
    int inserted = 22;
    if (!a4) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  uint64_t v8 = *(void *)(a1 + 376);
  if ((*(unsigned char *)(v8 + 57) & 2) == 0 || (~*(_DWORD *)(a2 + 84) & 0x40000020) != 0)
  {
    unint64_t add_explicit = *(void *)(a2 + 8);
  }
  else
  {
    if (!a3) {
      sub_100060380();
    }
    unint64_t add_explicit = atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 176), 1uLL, memory_order_relaxed);
  }
  int v13 = fs_reset_dstream(a1, a2, a3, (uint64_t)__src, add_explicit, a3);
  if (v13)
  {
    int inserted = v13;
    int v10 = 0;
    int v11 = 0;
    if (!a4) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  if (xf_set((unsigned __int16 *)(a2 + 408), 8, 32, __src, 0x28uLL))
  {
    log_err((uint64_t)"%s:%d: %s *** failed to set dstream as an extended field of ino %lld (ret %d)\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"fs_create_dstream");
    int v11 = 0;
    int v10 = 1;
    int inserted = 12;
    if (!a4) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  int v37 = 0;
  if (xf_get_ptr_and_size((unsigned __int16 *)(a2 + 408), 8, 0, &v38, &v37) || v37 != 40)
  {
    log_err((uint64_t)"%s:%d: %s *** failed to fetch the dstream pointer for %lld (ret %d)\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"fs_create_dstream");
    uint64_t v38 = 0;
    int v10 = 1;
    int inserted = 2;
  }
  else
  {
    v36[1] = *(void *)(a2 + 24);
    v36[0] = 1573126;
    int v10 = 1;
    void v36[2] = 1;
    int inserted = insert_jobj(a1, 1, (unsigned __int8 *)v36, a3, v25, v26, v27, v28);
    if (inserted)
    {
      log_err((uint64_t)"%s:%d: %s failed to insert new dstream_id %llu (ret %d)", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"fs_create_dstream");
      uint64_t v38 = 0;
    }
  }
  int v11 = 1;
  if (a4) {
LABEL_14:
  }
    *a4 = inserted;
LABEL_15:
  if (inserted)
  {
    if (v10) {
      cp_dec_ref(a1, add_explicit, a3);
    }
    if (v11) {
      xf_remove((unsigned __int16 *)(a2 + 408), 8);
    }
  }
  return v38;
}

uint64_t dir_rec_alloc_with_hash(uint64_t a1, char a2, const char *a3, size_t a4, int a5, uint64_t a6, uint64_t a7, void *a8)
{
  size_t v25 = a4;
  if (!a8) {
    return 22;
  }
  *a8 = 0;
  uint64_t v15 = sub_10004A618(a3, &v25);
  if (!v15)
  {
    uint64_t v16 = _apfs_calloc(1uLL, 0x48uLL);
    if (v16)
    {
      uint64_t v17 = v16;
      size_t v18 = v25;
      uint64_t v19 = _apfs_malloc(v25);
      *((void *)v17 + 8) = v19;
      if (v19)
      {
        *(unsigned char *)uint64_t v17 = 9;
        *((unsigned char *)v17 + 1) = a2;
        *((_WORD *)v17 + 1) = v18 + 72;
        *((void *)v17 + 1) = a6;
        memcpy(v19, a3, v18 - 1);
        *(unsigned char *)(*((void *)v17 + 8) + v18 - 1) = 0;
        *((_WORD *)v17 + 31) = v18;
        uint64_t v20 = *(void *)(*(void *)(a1 + 376) + 56);
        if (v20)
        {
          if (a5 == -1)
          {
            uint64_t v21 = *(void *)(*(void *)(a1 + 376) + 56) & 8;
            goto LABEL_17;
          }
        }
        else
        {
          uint64_t v21 = *(void *)(*(void *)(a1 + 376) + 56) & 8;
          if (a5 == -1 || (v20 & 8) == 0)
          {
            if ((v20 & 9) == 0)
            {
              v17[14] = 0;
LABEL_15:
              *((_WORD *)v17 + 30) = 0;
              *((void *)v17 + 2) = a7;
              *((void *)v17 + 3) = 0;
              xf_init((uint64_t)(v17 + 8), 0);
              uint64_t v15 = 0;
              *a8 = v17;
              return v15;
            }
LABEL_17:
            int v24 = -1;
            uint64_t v22 = utf8_normalizeOptCaseFoldAndHash(*((void *)v17 + 8), (unsigned __int16)v18 - 1, v21 != 0, (void (*)(_OWORD *, uint64_t, uint64_t))sub_10004A684, (uint64_t)&v24);
            if (v22)
            {
              uint64_t v15 = v22;
              _apfs_free(*((void **)v17 + 8), *((unsigned __int16 *)v17 + 31));
              _apfs_free(v17, 72);
              return v15;
            }
            v17[14] = v24 & 0x3FFFFF;
            goto LABEL_15;
          }
        }
        v17[14] = a5;
        goto LABEL_15;
      }
      _apfs_free(v17, 72);
    }
    return 12;
  }
  return v15;
}

uint64_t sub_10004A618(const char *a1, size_t *a2)
{
  size_t v3 = *a2;
  if (*a2)
  {
    if (a1[v3 - 1])
    {
      ++v3;
      goto LABEL_7;
    }
  }
  else
  {
    size_t v3 = strlen(a1) + 1;
  }
  if (v3 == 1) {
    return 22;
  }
LABEL_7:
  if (v3 > 0x2FE) {
    return 7;
  }
  uint64_t result = 0;
  *a2 = v3;
  return result;
}

uint64_t sub_10004A684(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result = crc32c(*a3, a1, a2);
  *a3 = result;
  return result;
}

uint64_t update_time(uint64_t a1, void *a2, int a3)
{
  if (!a1) {
    sub_1000603D8();
  }
  if (!a2) {
    sub_100060404();
  }
  char v4 = a3;
  if (!a3) {
    sub_100060430();
  }
  if (*(_DWORD *)(a1 + 1100)) {
    sub_10006045C();
  }
  uint64_t result = get_timestamp();
  if (v4) {
    a2[5] = result;
  }
  if ((v4 & 2) != 0) {
    a2[6] = result;
  }
  a2[14] |= 0x40000uLL;
  return result;
}

uint64_t apfs_inc_parent_nlink(uint64_t a1, uint64_t a2)
{
  uint64_t __dst = 0;
  uint64_t v2 = *(void *)(a1 + 376);
  if ((*(unsigned char *)(v2 + 57) & 2) != 0)
  {
    uint64_t result = 0;
    ++*(_DWORD *)(a2 + 104);
  }
  else if ((*(unsigned char *)(v2 + 48) & 2) != 0)
  {
    char v4 = (unsigned __int16 *)(a2 + 408);
    uint64_t result = xf_get((unsigned __int16 *)(a2 + 408), 17, 0, (char *)&__dst, 8uLL);
    if (!result)
    {
      ++__dst;
      return xf_set(v4, 17, 0, &__dst, 8uLL);
    }
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t fs_tx_enter(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t *a5)
{
  *a5 = 0;
  return sub_10004B2D0(a1, a2, a3, a4, 0, a5);
}

uint64_t fs_tx_leave(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  return fs_tx_leave_ext(a1, a2, a3, a4, a5, 0);
}

uint64_t utf8_strlen_with_ascii_status(uint64_t a1, unint64_t a2, unsigned __int8 a3, _DWORD *a4, int *a5)
{
  if (!a1) {
    sub_100060488();
  }
  if (a4) {
    *a4 = 0;
  }
  uint64_t v10 = 0;
  unint64_t v11 = 0;
  unsigned int v18 = 0;
  if (!a2) {
    goto LABEL_7;
  }
LABEL_5:
  uint64_t v12 = a2 - v11;
  if (a2 > v11)
  {
    int v13 = (char *)(a1 + v11);
    while (1)
    {
      uint64_t v14 = sub_10004A954(v13, v12, (int *)&v18);
      unsigned int v15 = v18;
      if ((v18 & 0x80000000) != 0) {
        break;
      }
      if (!v18) {
        goto LABEL_26;
      }
      if (a4 && v18 >= 0x80) {
        *a4 = 1;
      }
      if (v15 >= 0x2000)
      {
        if ((a3 & 2) != 0
          && (v15 - 8206 <= 0x21 && ((1 << (v15 - 14)) & 0x3F0000003) != 0
           || v15 - 8298 < 6
           || (~v15 & 0xFFFE) == 0
           || v15 == 65279
           || v15 - 64976 <= 0x1F))
        {
          uint64_t v10 = 0;
          if (!a5) {
            return v10;
          }
          int v16 = 1;
          goto LABEL_30;
        }
        v10 += a3 & ((v15 & 0xFFFF0000) != 0);
      }
      v11 += v14;
      ++v10;
      if (a2) {
        goto LABEL_5;
      }
LABEL_7:
      int v13 = (char *)(a1 + v11);
      uint64_t v12 = -1;
    }
    uint64_t v10 = 0;
    if (!a5) {
      return v10;
    }
    int v16 = 92;
    goto LABEL_30;
  }
LABEL_26:
  if (a5)
  {
    int v16 = 0;
LABEL_30:
    *a5 = v16;
  }
  return v10;
}

uint64_t sub_10004A954(char *a1, uint64_t a2, int *a3)
{
  *a3 = -1;
  if (!a2) {
    return 0;
  }
  if (a2 > 4 || a2 == -1) {
    uint64_t v4 = 4;
  }
  else {
    uint64_t v4 = a2;
  }
  int v5 = *a1;
  if ((*a1 & 0x80000000) == 0)
  {
    uint64_t v6 = 1;
LABEL_10:
    *a3 = v5;
    return v6;
  }
  if ((v5 + 62) <= 0x1Du)
  {
    if (v4 != 1)
    {
      unsigned __int8 v7 = a1[1];
      if ((v7 & 0xC0) == 0x80)
      {
        int v8 = v7 & 0x3F | ((v5 & 0x1F) << 6);
        uint64_t v6 = 2;
        int v5 = v8;
        goto LABEL_10;
      }
    }
    return 0;
  }
  if ((v5 & 0xF0) == 0xE0)
  {
    if (v4 < 3) {
      return 0;
    }
    if (v5 == 224)
    {
      if ((a1[1] + 64) < 0xE0u) {
        return 0;
      }
      goto LABEL_40;
    }
    if ((v5 + 31) > 0xBu)
    {
      if (v5 == 237)
      {
        if (a1[1] > -97) {
          return 0;
        }
        goto LABEL_40;
      }
    }
    else if ((a1[1] & 0xC0) != 0x80)
    {
      return 0;
    }
    if ((v5 & 0xFE) == 0xEE && (a1[1] & 0xC0) != 0x80) {
      return 0;
    }
LABEL_40:
    unsigned __int8 v12 = a1[2];
    if ((v12 & 0xC0) == 0x80)
    {
      int v5 = ((v5 & 0xF) << 12) | ((a1[1] & 0x3F) << 6) | v12 & 0x3F;
      uint64_t v6 = 3;
      goto LABEL_10;
    }
    return 0;
  }
  uint64_t v6 = 0;
  if (v4 >= 4 && (v5 + 11) >= 0xFBu)
  {
    if (v5 == 240)
    {
      LOBYTE(v9) = a1[1];
      if ((v9 + 64) < 0xD0u) {
        return 0;
      }
    }
    else
    {
      int v9 = a1[1];
      if ((v5 + 15) > 2u)
      {
        if (v9 > -113) {
          return 0;
        }
      }
      else if ((v9 & 0xFFFFFFC0) != 0xFFFFFF80)
      {
        return 0;
      }
    }
    unsigned __int8 v10 = a1[2];
    if ((v10 & 0xC0) == 0x80)
    {
      unsigned __int8 v11 = a1[3];
      if ((v11 & 0xC0) == 0x80)
      {
        int v5 = ((v5 & 7) << 18) | ((v9 & 0x3F) << 12) | ((v10 & 0x3F) << 6) | v11 & 0x3F;
        uint64_t v6 = 4;
        goto LABEL_10;
      }
    }
    return 0;
  }
  return v6;
}

uint64_t fs_lookup_name_with_parent_id(uint64_t a1, uint64_t a2, const char *a3, size_t a4, uint64_t *a5, int *a6, void *a7)
{
  uint64_t v43 = 0;
  size_t v44 = a4;
  unint64_t v13 = *(void *)(*(void *)(a1 + 376) + 56);
  if ((v13 & 9) == 0)
  {
    v37[0] = 0;
    uint64_t v15 = dir_rec_alloc_with_hash(a1, 0, a3, a4, -1, a2, 0, v37);
    if (!v15)
    {
      uint64_t v15 = lookup_jobj_in_snap(a1, 1, a5, v37[0], *(void *)(a1 + 432), &v43, v16, v17);
      jobj_release(v15, v37[0], v18, v19, v20, v21, v22, v23);
    }
    goto LABEL_12;
  }
  uint64_t v14 = sub_10004A618(a3, &v44);
  if (v14)
  {
    uint64_t v15 = v14;
LABEL_12:
    int v27 = 0;
    goto LABEL_13;
  }
  uint64_t v41 = 0;
  long long v39 = 0u;
  long long v40 = 0u;
  v37[0] = (unsigned char *)4718601;
  long long v38 = 0u;
  v37[1] = (unsigned char *)a2;
  int v42 = -1;
  size_t v24 = v44 - 1;
  DWORD2(v40) = 0;
  uint64_t v25 = utf8_normalizeOptCaseFoldAndHash((unint64_t)a3, v44 - 1, (v13 >> 3) & 1, (void (*)(_OWORD *, uint64_t, uint64_t))sub_10004A684, (uint64_t)&v42);
  if (v25)
  {
    uint64_t v15 = v25;
    if (v25 != 92) {
      goto LABEL_12;
    }
    uint64_t v32 = a3;
    long long v33 = v24;
    unsigned int v26 = iterate_jobjs_with_hint_and_snap(a1, 1, 0, *(void *)(a1 + 432), (unsigned __int8 *)v37, (uint64_t (*)(long long *, uint64_t))sub_10004ADD0, (uint64_t)&v32, a5, 4u);
    if (v26 == -1)
    {
      uint64_t v15 = 0;
      if (*((void *)&v33 + 1)) {
        uint64_t v43 = (unsigned __int16 *)*((void *)&v33 + 1);
      }
    }
    else if (v26)
    {
      uint64_t v15 = v26;
    }
    else
    {
      uint64_t v15 = 2;
    }
    int v27 = -1;
  }
  else
  {
    int v27 = v42 & 0x3FFFFF;
    uint64_t v34 = 0;
    uint64_t v32 = a3;
    *(void *)&long long v33 = v42 & 0x3FFFFFLL;
    *((void *)&v33 + 1) = v24;
    uint64_t v35 = a1;
    BOOL v36 = a7 != 0;
    unint64_t v30 = a2 & 0xFFFFFFFFFFFFFFFLL | 0x9000000000000000;
    int v31 = v42 << 10;
    unsigned int v29 = iterate_raw_jobjs_with_hint(a1, 1, 0, (unsigned __int8 *)&v30, 0xCuLL, (uint64_t)sub_10004AEE0, (uint64_t)&v32, 0, a5, 516);
    if (v29 == -1)
    {
      uint64_t v15 = 0;
      if (v34) {
        uint64_t v43 = v34;
      }
    }
    else if (v29)
    {
      uint64_t v15 = v29;
    }
    else
    {
      uint64_t v15 = 2;
    }
  }
LABEL_13:
  if (a7 && !v15) {
    *a7 = v43;
  }
  if (a6 && (v15 | 2) == 2) {
    *a6 = v27;
  }
  return v15;
}

uint64_t sub_10004ADD0(uint64_t a1, uint64_t a2)
{
  size_t v2 = *(void *)(a2 + 8);
  if (v2 + 1 != *(unsigned __int16 *)(a1 + 62) || memcmp(*(const void **)(a1 + 64), *(const void **)a2, v2)) {
    return 0;
  }
  unsigned __int8 v7 = _apfs_calloc(1uLL, 0x48uLL);
  *(void *)(a2 + 16) = v7;
  if (!v7) {
    return 12;
  }
  int v8 = _apfs_malloc(*(unsigned __int16 *)(a1 + 62));
  int v9 = *(_OWORD **)(a2 + 16);
  *((void *)v9 + 8) = v8;
  if (!v8)
  {
    _apfs_free(v9, 72);
    return 12;
  }
  *int v9 = *(_OWORD *)a1;
  long long v10 = *(_OWORD *)(a1 + 16);
  long long v11 = *(_OWORD *)(a1 + 32);
  long long v12 = *(_OWORD *)(a1 + 48);
  *((void *)v9 + 8) = *(void *)(a1 + 64);
  unint64_t v9[2] = v11;
  v9[3] = v12;
  v9[1] = v10;
  memcpy(*(void **)(*(void *)(a2 + 16) + 64), *(const void **)(a1 + 64), *(unsigned __int16 *)(a1 + 62));
  uint64_t v13 = xf_deep_copy(*(void *)(a2 + 16) + 32, (unsigned __int16 *)(a1 + 32));
  if (!v13) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v5 = v13;
  _apfs_free(*(void **)(*(void *)(a2 + 16) + 64), *(unsigned __int16 *)(a1 + 62));
  _apfs_free(*(void **)(a2 + 16), 72);
  *(void *)(a2 + 16) = 0;
  return v5;
}

uint64_t sub_10004AEE0(uint64_t a1, unint64_t a2, unsigned __int16 *a3, unint64_t a4, uint64_t a5)
{
  uint64_t result = 0;
  char v21 = 0;
  unsigned int v7 = *(_DWORD *)(a1 + 8);
  unsigned int v8 = *(_DWORD *)(a5 + 8);
  if (v7 >> 10 >= v8)
  {
    if (v7 >> 10 != v8) {
      return 2;
    }
    int v13 = *(_DWORD *)(a1 + 8) & 0x3FF;
    uint64_t v14 = *(void *)(a5 + 16);
    uint64_t v15 = *(const char **)a5;
    if (v14 == (v7 & 0x3FF) && !strncmp((const char *)(a1 + 12), *(const char **)a5, v7 & 0x3FF))
    {
      char v21 = 1;
    }
    else
    {
      if (utf8_normalizeOptCaseFoldAndCompare(a1 + 12, (v13 - 1), (unint64_t)v15, v14, (*(void *)(*(void *)(*(void *)(a5 + 32) + 376) + 56) >> 3) & 1, (BOOL *)&v21))BOOL v19 = 1; {
      else
      }
        BOOL v19 = v21 == 0;
      if (v19) {
        return 0;
      }
    }
    if (*(_DWORD *)(a5 + 40)
      && (uint64_t v20 = key_val_to_jobj(*(void *)(a5 + 32), a1, a2, a3, a4, v16, v17, v18), (*(void *)(a5 + 24) = v20) == 0))
    {
      return 12;
    }
    else
    {
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

uint64_t apfs_get_nx_dev(uint64_t a1)
{
  return *(void *)(*(void *)(a1 + 392) + 384);
}

uint64_t apfs_check_for_spillover()
{
  return 0;
}

void fs_sb_dirty(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a1 + 476) & 4) != 0)
  {
    uint64_t v4 = *(void *)(a1 + 376);
    if ((*(unsigned char *)(v4 + 264) & 4) == 0) {
      atomic_fetch_or_explicit((atomic_ullong *volatile)(v4 + 264), 4uLL, memory_order_relaxed);
    }
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 1280));
    *(void *)(a1 + 472) &= ~0x400000000uLL;
    pthread_mutex_unlock((pthread_mutex_t *)(a1 + 1280));
  }
  *(void *)(*(void *)(a1 + 376) + 1056) = a2;
  if (apfs_doc_id_index_supported(a1)) {
    *(_DWORD *)(*(void *)(a1 + 376) + 1064) |= 0x10u;
  }

  obj_dirty(a1, a2, 0);
}

uint64_t ino_is_class_v(uint64_t a1, uint64_t a2)
{
  if ((*(_WORD *)(a2 + 96) & 0xF000) != 0x8000
    || get_vol_crypto(a1) != 3
    || (*(unsigned char *)(a2 + 64) & 8) != 0)
  {
    return 0;
  }
  int v4 = *(_DWORD *)(a2 + 76) & 0x1F;
  if (v4 == 3) {
    return 1;
  }
  else {
    return (v4 == 4) & ~apfs_kb_supports_class(a1, 4u);
  }
}

uint64_t ino_get_class_check(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v3 = *(void *)(a1 + 496);
  if (!v3) {
    uint64_t v3 = a1;
  }
  if ((*(unsigned char *)(*(void *)(v3 + 376) + 264) & 9) != 0) {
    sub_1000604B4();
  }
  if (ino_is_class_v(a1, a2))
  {
    int v6 = 5;
LABEL_6:
    *a3 = v6;
    return 1;
  }
  uint64_t v8 = *(_DWORD *)(a2 + 76) & 0x1F;
  if (*(_DWORD *)(a2 + 76) & 0x1Fu) <= 7 && ((0xDFu >> v8))
  {
    int v6 = dword_10007EC10[v8];
    goto LABEL_6;
  }
  return 0;
}

uint64_t sub_10004B1CC(uint64_t result, uint64_t a2)
{
  if (!result) {
    sub_1000604E0();
  }
  if (!a2) {
    sub_10006050C();
  }
  return result;
}

uint64_t evict_mapping_key_compare(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, int *a6)
{
  int v6 = *a2 > *a4;
  if (*a2 < *a4) {
    int v6 = -1;
  }
  *a6 = v6;
  return 0;
}

uint64_t fs_tx_can_log(uint64_t a1)
{
  v5.int tv_sec = 0;
  v5.uint64_t tv_nsec = 0;
  clock_gettime(_CLOCK_UPTIME_RAW_APPROX, &v5);
  __darwin_time_t v2 = 1000000 * v5.tv_sec + SLODWORD(v5.tv_nsec) / 1000;
  atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 3776), 1u, memory_order_relaxed);
  unint64_t v3 = v2 - *(void *)(a1 + 3768);
  if (*(int *)(a1 + 3776) >= 17)
  {
    if (v3 < 0xF4240)
    {
      uint64_t result = 0;
      *(void *)(a1 + 3768) = v2;
      return result;
    }
    goto LABEL_5;
  }
  if (v3 > 0xF423F)
  {
LABEL_5:
    *(void *)(a1 + 3768) = v2;
    uint64_t result = 1;
    *(_DWORD *)(a1 + 3776) = 1;
    return result;
  }
  return 1;
}

uint64_t sub_10004B2D0(uint64_t a1, int a2, uint64_t a3, unint64_t a4, int a5, uint64_t *a6)
{
  int v8 = a2;
  long long v10 = (atomic_ullong *)(*(void *)(a1 + 392) + 488);
  uint64_t v11 = *(void *)(a1 + 376);
  uint64_t v12 = *(void *)(v11 + 72);
  if (v12 && v12 == *(void *)(v11 + 80)) {
    long long v10 = (atomic_ullong *)(a1 + 416);
  }
  unint64_t v67 = 0;
  unint64_t v68 = 0;
  unint64_t v65 = 0;
  unint64_t v66 = 0;
  unint64_t v64 = 0;
  __int16 v63 = 0;
  uint64_t v13 = 10;
  uint64_t v14 = 1;
  if (a2 != 2 && a2 != 4)
  {
    if (a2 == 5)
    {
      unint64_t v15 = a4 + 6 * a3 + 25;
      spaceman_currently_available_space(a1, &v68, 0, 0, 0);
      goto LABEL_13;
    }
    uint64_t v13 = 80;
    if (((a4 > 4) & ((*(unsigned char *)(v11 + 48) & 2) >> 1)) == 0) {
      uint64_t v13 = 100;
    }
    uint64_t v14 = 3;
  }
  unint64_t v15 = 3 * a3 * v14 + a4 + v13;
  spaceman_currently_available_space(a1, &v68, 0, 0, 0);
  uint64_t v61 = 0;
  if (v8 != 2 && v8 != 4)
  {
LABEL_13:
    LODWORD(v16) = v68 / 0x64;
    if (v68 / 0x64 <= 0x64) {
      uint64_t v16 = 100;
    }
    else {
      uint64_t v16 = v16;
    }
    if (v68 <= 0x61AE3) {
      uint64_t v17 = v16;
    }
    else {
      uint64_t v17 = 4000;
    }
    uint64_t v61 = v17;
  }
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504));
  uint64_t v18 = spaceman_compare_currently_available_space(a1, v15, v61, 0, v10, &v67, &v66, (BOOL *)&v63 + 1, &v65, &v64, (BOOL *)&v63);
  if (v18 != 28)
  {
    uint64_t v20 = v18;
    int v60 = a5;
    if (!v18) {
      goto LABEL_59;
    }
    goto LABEL_25;
  }
  uint64_t v19 = *a6;
  if (*a6 && !(_BYTE)v63)
  {
    uint64_t v20 = 28;
LABEL_25:
    *a6 = 0;
    if (fs_tx_can_log(a1) || v8 == 2 && v15 <= 0x31 && *(int *)(a1 + 3780) <= 9)
    {
      if (v20 == 28)
      {
        memset(&v69, 0, 32);
        __strlcpy_chk();
        log_debug((uint64_t)"%s:%d: %s %s: ENOSPC: ttype %s (r %lld d %lld tx %d) blocks %lld free %lld txn %lld # %d th %lld rr %lld sh %lld fq %lld lim %d %d freeup %d wait %d\n", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"fs_tx_enter_internal");
        if (v8 == 2 && v15 <= 0x31) {
          ++*(_DWORD *)(a1 + 3780);
        }
      }
      else
      {
        log_err((uint64_t)"%s:%d: %s failed to compare currently available space: error %d\n", v21, v22, v23, v24, v25, v26, v27, (uint64_t)"fs_tx_enter_internal");
      }
    }
    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504));
    return v20;
  }
  int v60 = a5;
  int v58 = v8;
  uint64_t v59 = a6;
  uint64_t v35 = v10;
  unint64_t v36 = 0;
  unsigned __int8 v37 = 0;
  int v38 = 0;
  int v39 = 0;
  unint64_t v62 = 0;
  if (v19) {
    uint64_t v40 = 10000000;
  }
  else {
    uint64_t v40 = 250000000;
  }
  while (1)
  {
    if (!HIBYTE(v63) || v19 || v65 < v67) {
      goto LABEL_47;
    }
    if (v36) {
      break;
    }
    if (v39 <= 31) {
      goto LABEL_42;
    }
LABEL_47:
    if (!(_BYTE)v63)
    {
      uint64_t v20 = 28;
      goto LABEL_58;
    }
    uint64_t v20 = 28;
    if (*(_DWORD *)(a1 + 1116) <= (v19 != 0) || ((v19 != 0) & v37) != 0) {
      goto LABEL_58;
    }
    v69.int tv_sec = 0;
    v69.uint64_t tv_nsec = v40;
    ++v38;
    uint64_t v42 = *(void *)(a1 + 392);
    *(void *)(v42 + 496) += v15;
    int v43 = cv_wait((pthread_cond_t *)(v42 + 568), (pthread_mutex_t *)(v42 + 504), 8, (uint64_t)"blocks_in_txn", &v69);
    *(void *)(*(void *)(a1 + 392) + 496) -= v15;
    v37 |= v43 == 35;
LABEL_51:
    uint64_t v44 = spaceman_compare_currently_available_space(a1, v15, v61, 0, v35, &v67, &v66, (BOOL *)&v63 + 1, &v65, &v64, (BOOL *)&v63);
    if (v44 != 28)
    {
      uint64_t v20 = v44;
      goto LABEL_58;
    }
  }
  if (v64 > v36 || v39 >= 32) {
    goto LABEL_47;
  }
LABEL_42:
  ++v39;
  pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504));
  unint64_t v62 = 0;
  uint64_t v41 = tx_enter(*(void *)(a1 + 392), (uint64_t *)&v62);
  if (!v41)
  {
    if (!v36) {
      unint64_t v36 = v62;
    }
    spaceman_free_up_some_blocks(*(pthread_mutex_t ***)(a1 + 392), &v65, v62);
    tx_leave(*(void *)(a1 + 392), v62, 4);
    pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504));
    goto LABEL_51;
  }
  uint64_t v20 = v41;
  pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504));
LABEL_58:
  long long v10 = v35;
  a6 = v59;
  int v8 = v58;
  if (v20) {
    goto LABEL_25;
  }
LABEL_59:
  atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 1116), 1u, memory_order_relaxed);
  pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504));
  uint64_t v45 = *(void *)(a1 + 392);
  if (v60)
  {
    uint64_t v46 = tx_enter_frozen(v45, a6);
    if (v46)
    {
      uint64_t v20 = v46;
      log_err((uint64_t)"%s:%d: %s tx_enter_frozen() failed: %d\n", v47, v48, v49, v50, v51, v52, v53, (uint64_t)"fs_tx_enter_internal");
      goto LABEL_68;
    }
LABEL_64:
    if (*(_DWORD *)(a1 + 3780)) {
      *(_DWORD *)(a1 + 3780) = 0;
    }
    uint64_t v20 = obj_modify((void *)a1, 0, *a6, v49, v50, v51, v52, v53);
    if (v20)
    {
      tx_leave(*(void *)(a1 + 392), *a6, 0);
      goto LABEL_68;
    }
  }
  else
  {
    uint64_t v54 = tx_enter(v45, a6);
    if (!v54) {
      goto LABEL_64;
    }
    uint64_t v20 = v54;
    log_err((uint64_t)"%s:%d: %s tx_enter() failed: %d\n", v55, v56, v49, v50, v51, v52, v53, (uint64_t)"fs_tx_enter_internal");
LABEL_68:
    pthread_mutex_lock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504));
    atomic_fetch_add_explicit(v10, -(uint64_t)v15, memory_order_relaxed);
    atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 1116), 0xFFFFFFFF, memory_order_relaxed);
    pthread_mutex_unlock((pthread_mutex_t *)(*(void *)(a1 + 392) + 504));
    *a6 = 0;
  }
  return v20;
}

uint64_t fs_tx_leave_ext(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, char a6)
{
  uint64_t v12 = *(void *)(a1 + 392);
  uint64_t v13 = (atomic_ullong *)(v12 + 488);
  uint64_t v14 = *(void *)(a1 + 376);
  uint64_t v15 = *(void *)(v14 + 72);
  if (v15 && v15 == *(void *)(v14 + 80)) {
    uint64_t v13 = (atomic_ullong *)(a1 + 416);
  }
  pthread_mutex_lock((pthread_mutex_t *)(v12 + 504));
  atomic_fetch_add_explicit((atomic_uint *volatile)(a1 + 1116), 0xFFFFFFFF, memory_order_relaxed);
  uint64_t v23 = 10;
  uint64_t v24 = 1;
  if (a2 != 2 && a2 != 4)
  {
    if (a2 == 5)
    {
      uint64_t v23 = 25;
      uint64_t v24 = 2;
    }
    else
    {
      uint64_t v23 = 100;
      if (((a4 > 4) & ((*(unsigned char *)(*(void *)(a1 + 376) + 48) & 2) >> 1)) != 0) {
        uint64_t v23 = 80;
      }
      uint64_t v24 = 3;
    }
  }
  unint64_t v25 = 3 * a3 * v24 + a4 + v23;
  unint64_t add_explicit = atomic_fetch_add_explicit(v13, -(uint64_t)v25, memory_order_relaxed);
  if ((uint64_t)(add_explicit - v25) < 0)
  {
    log_err((uint64_t)"%s:%d: %s old reserve was %lld, num_blocks %lld. blocks_in_txn_counter %lld num_active_txns=%d\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"fs_tx_leave_ext");
    if (add_explicit < v25) {
      sub_100060538();
    }
  }
  *(void *)(*(void *)(a1 + 376) + 256) = get_timestamp();
  fs_sb_dirty(a1, a5);
  uint64_t v27 = *(void *)(a1 + 392);
  if (*(void *)(v27 + 496))
  {
    cv_wakeup((pthread_cond_t *)(v27 + 568));
    uint64_t v27 = *(void *)(a1 + 392);
  }
  pthread_mutex_unlock((pthread_mutex_t *)(v27 + 504));
  unint64_t v48 = 0;
  unint64_t v49 = 0;
  spaceman_currently_available_space(a1, &v49, &v48, 0, 0);
  if (add_explicit) {
    BOOL v35 = (*(void *)(*(void *)(a1 + 376) + 48) & 2) == 0;
  }
  else {
    BOOL v35 = 1;
  }
  if (!v35 && v49 >= 0xA01 && add_explicit + 4000 >= v48) {
    a6 |= 4u;
  }
  LODWORD(v36) = v49 / 0x64;
  if (v49 / 0x64 <= 0x64) {
    uint64_t v36 = 100;
  }
  else {
    uint64_t v36 = v36;
  }
  if (v49 <= 0x61AE3) {
    uint64_t v37 = v36;
  }
  else {
    uint64_t v37 = 4000;
  }
  int v38 = *(_DWORD *)(a1 + 3784);
  if (v37 + add_explicit - v25 >= v48)
  {
    *(_DWORD *)(a1 + 3784) = v38 + 1;
    if (v38 <= 99) {
      log_info((uint64_t)"%s:%d: %s gettin' low on space: ttype %s num_blocks %lld blocks_in_txn %lld free_blocks %lld xid %lld\n", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"fs_tx_leave_ext");
    }
  }
  else if (v38 >= 100)
  {
    *(_DWORD *)(a1 + 3784) = 0;
  }
  if (!a5) {
    return 0;
  }
  ++*(void *)(a1 + 424);
  uint64_t v46 = tx_leave(*(void *)(a1 + 392), a5, a6);
  if (v46) {
    log_err((uint64_t)"%s:%d: %s tx_leave failed: %d\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"fs_tx_leave_ext");
  }
  return v46;
}

uint64_t apfs_deletefs(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v58 = 0;
  uint64_t v59 = 0;
  char v57 = 0;
  if (*(unsigned char *)(a1 + 627)) {
    return 30;
  }
  uint64_t v6 = *(void *)(a1 + 376);
  if (*(_DWORD *)(v6 + 180) <= a2) {
    return 22;
  }
  int v60 = 0;
  unint64_t v8 = *(void *)(v6 + 8 * a2 + 184);
  if (!v8) {
    return 22;
  }
  uint64_t v9 = a2;
  uint64_t v10 = obj_get(*(void *)(a1 + 392), 0, v8, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v60);
  if (v10)
  {
    uint64_t v3 = v10;
    log_err((uint64_t)"%s:%d: %s failed to get fsys idx=%u oid=%llu: %d\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"apfs_deletefs");
  }
  else if (userfs_volume_is_mountable((uint64_t)v60, &v57, v12, v13, v14, v15, v16, v17))
  {
    if (*(_DWORD *)(*(void *)&v60[5].__opaque[48] + 36) == a2)
    {
      if (!*(unsigned char *)(a1 + 629)) {
        goto LABEL_18;
      }
      uint64_t v26 = *(pthread_mutex_t **)&v60[7].__opaque[40];
      if (!v26) {
        uint64_t v26 = v60;
      }
      if (*(unsigned char *)(*(void *)&v26[5].__opaque[48] + 264))
      {
LABEL_18:
        pthread_mutex_lock(v60 + 20);
        uint64_t v28 = v60;
        uint64_t v29 = *(void *)&v60[7].__opaque[16];
        if ((v29 & 0x20000004460) != 0
          || *(int *)&v60[17].__opaque[16] > 0
          || *(int *)&v60[17].__opaque[8] > 0
          || *(int *)&v60[17].__opaque[12] >= 1)
        {
          pthread_mutex_unlock(v60 + 20);
          log_err((uint64_t)"%s:%d: %s can not delete a volume that is already mounted/deleting/replicating\n", v30, v31, v32, v33, v34, v35, v36, (uint64_t)"apfs_deletefs");
          int v27 = 0;
          uint64_t v3 = 16;
        }
        else
        {
          *(void *)&v60[7].__opaque[16] = v29 | 0x400;
          pthread_mutex_unlock(v28 + 20);
          uint64_t v38 = tx_enter(a1, &v59);
          if (v38)
          {
            uint64_t v3 = v38;
            log_err((uint64_t)"%s:%d: %s failed to enter transaction, error = %d\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"apfs_deletefs");
            int v27 = 0;
          }
          else
          {
            int v46 = obj_type_and_flags((uint64_t)v60);
            int v47 = obj_size_phys((uint64_t)v60);
            uint64_t v48 = obj_oid((uint64_t)v60);
            uint64_t v49 = nx_reaper_add(a1, v46, v47, 0, v48, v59, 1, &v58);
            if (v49)
            {
              uint64_t v3 = v49;
              log_err((uint64_t)"%s:%d: %s failed to add file system to reaper: %d\n", v50, v51, v52, v53, v54, v55, v56, (uint64_t)"apfs_deletefs");
              int v27 = 1;
            }
            else
            {
              *(void *)(*(void *)(a1 + 376) + 8 * v9 + 184) = 0;
              uint64_t v3 = 0;
              if (a3) {
                *a3 = v58;
              }
              int v27 = 1;
            }
          }
        }
      }
      else
      {
        log_err((uint64_t)"%s:%d: %s cannot delete encrypted volume in demo mode\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"apfs_deletefs");
        int v27 = 0;
        uint64_t v3 = 1;
      }
    }
    else
    {
      log_err((uint64_t)"%s:%d: %s nx and apfs superblock disagree on fs_idx, nx_idx=%u, nx_oid=%llu, apfs_idx=%u\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"apfs_deletefs");
      int v27 = 0;
      uint64_t v3 = 5;
    }
    if (v60) {
      obj_release(&v60->__sig);
    }
    if (v27)
    {
      if (v3) {
        char v37 = 0;
      }
      else {
        char v37 = 5;
      }
      tx_leave(a1, v59, v37);
    }
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s Volume is not mountable, it can't be deleted (volume role %d) \n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"apfs_deletefs");
    return 45;
  }
  return v3;
}

uint64_t apfs_is_volume_fsindex_allowed(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8 = 0;
  if (a2 != -1 && (int)a2 <= 1)
  {
    uint64_t v8 = 0;
    if (a1 == 1)
    {
      if (a2)
      {
        uint64_t v8 = 1;
        log_err((uint64_t)"%s:%d: Volume role %d is not allowed at fs index %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"apfs_is_volume_fsindex_allowed");
      }
    }
  }
  return v8;
}

uint64_t apfs_is_volume_role_allowed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a5;
  int v9 = a3;
  if (a3 == 576 && (a5 & 1) == 0)
  {
    log_err((uint64_t)"%s:%d: Volume role 0x%x is not allowed for an unencrypted volume\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"apfs_is_volume_role_allowed");
    return 1;
  }
  if (a2 == a3) {
    goto LABEL_5;
  }
  if ((int)a2 <= 255)
  {
    if ((int)a2 > 127)
    {
      if (a2 != 128 && a2 != 192) {
        goto LABEL_5;
      }
    }
    else if (a2 != 4 && a2 != 16)
    {
      goto LABEL_5;
    }
    goto LABEL_82;
  }
  if ((int)a2 > 383)
  {
    if (a2 == 384)
    {
      log_err((uint64_t)"%s:%d: cannot change role of Backup volume\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"apfs_is_volume_role_allowed");
      return 1;
    }
    if (a2 == 448)
    {
      log_err((uint64_t)"%s:%d: cannot change role of SideCar volume\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"apfs_is_volume_role_allowed");
      return 1;
    }
    if (a2 != 704) {
      goto LABEL_5;
    }
LABEL_82:
    log_err((uint64_t)"%s:%d: cannot change role of system-unique volume\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"apfs_is_volume_role_allowed");
    return 1;
  }
  if (a2 == 256)
  {
    log_err((uint64_t)"%s:%d: cannot change role of xART volume\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"apfs_is_volume_role_allowed");
    return 1;
  }
  if (a2 == 320) {
    goto LABEL_82;
  }
LABEL_5:
  if (a3)
  {
    if (apfs_is_volume_fsindex_allowed(a3, a4, a3, a4, a5, a6, a7, a8)) {
      return 1;
    }
    BOOL v18 = v9 == 704;
    if (v9 <= 191)
    {
      if (((v9 - 1) > 0x3F || ((1 << (v9 - 1)) & 0x800000008000800BLL) == 0)
        && v9 != 128)
      {
        goto LABEL_101;
      }
      goto LABEL_23;
    }
    if (v9 <= 511)
    {
      if (v9 != 192 && v9 != 256 && v9 != 320) {
        goto LABEL_101;
      }
    }
    else if (v9 > 639)
    {
      if (v9 != 640 && v9 != 704) {
        goto LABEL_101;
      }
    }
    else if (v9 != 512 && v9 != 576)
    {
LABEL_101:
      log_err((uint64_t)"%s:%d: Volume role 0x%x is not supported in container\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"apfs_is_volume_role_allowed");
      return 45;
    }
  }
  else
  {
    BOOL v18 = 0;
  }
LABEL_23:
  uint64_t v19 = *(void *)(a1 + 376);
  if (!*(_DWORD *)(v19 + 180)) {
    return 0;
  }
  BOOL v50 = v18;
  unint64_t v20 = 0;
  memset(out, 0, 37);
  while (1)
  {
    uint64_t v51 = 0;
    unint64_t v21 = *(void *)(v19 + 8 * v20 + 184);
    if (v21) {
      break;
    }
LABEL_72:
    ++v20;
    uint64_t v19 = *(void *)(a1 + 376);
    if (v20 >= *(unsigned int *)(v19 + 180)) {
      return 0;
    }
  }
  uint64_t v22 = obj_get(*(void *)(a1 + 392), 0, v21, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v51);
  uint64_t v30 = v22;
  if (v22)
  {
    strerror(v22);
    log_err((uint64_t)"%s:%d: %s Failed to get fsys oid %lld - %s\n", v43, v44, v45, v46, v47, v48, v49, (uint64_t)"apfs_is_volume_role_allowed");
    return v30;
  }
  char v31 = 1;
  if (v9 > 191)
  {
    if (v9 <= 511)
    {
      if (v9 == 192)
      {
        uint64_t v32 = v51;
        if (*(_WORD *)(v51[47] + 964) == 192) {
          goto LABEL_62;
        }
        goto LABEL_74;
      }
      if (v9 != 256)
      {
        uint64_t v32 = v51;
        if (*(_WORD *)(v51[47] + 964) == 320) {
          goto LABEL_62;
        }
LABEL_74:
        obj_release(v32);
        goto LABEL_72;
      }
      if (*(_WORD *)(v51[47] + 964) != 256) {
        goto LABEL_60;
      }
      goto LABEL_62;
    }
    switch(v9)
    {
      case 512:
        uint64_t v32 = v51;
        int v33 = *(unsigned __int16 *)(v51[47] + 964);
        if (v33 == 512) {
          goto LABEL_62;
        }
        if (v50) {
          goto LABEL_57;
        }
        goto LABEL_74;
      case 640:
        if (*(_WORD *)(v51[47] + 964) == 640) {
          goto LABEL_62;
        }
        goto LABEL_60;
      case 704:
        int v33 = *(unsigned __int16 *)(v51[47] + 964);
LABEL_57:
        if (v33 != 704)
        {
          uint64_t v30 = 0;
          goto LABEL_63;
        }
LABEL_62:
        uuid_unparse((const unsigned __int8 *)(*(void *)(a1 + 376) + 72), out);
        log_err((uint64_t)"%s:%d: %s Volume role 0x%x already exists in container uuid %s\n", v34, v35, v36, v37, v38, v39, v40, (uint64_t)"apfs_is_volume_role_allowed");
        char v31 = 0;
        uint64_t v30 = 17;
        goto LABEL_63;
    }
    goto LABEL_63;
  }
  if (v9 > 15)
  {
    switch(v9)
    {
      case 16:
        if (*(_WORD *)(v51[47] + 964) != 16) {
          goto LABEL_60;
        }
        break;
      case 32:
        if (*(_WORD *)(v51[47] + 964) != 32) {
          goto LABEL_60;
        }
        break;
      case 128:
        uint64_t v32 = v51;
        if (*(_WORD *)(v51[47] + 964) == 128) {
          goto LABEL_62;
        }
        goto LABEL_74;
      default:
        goto LABEL_63;
    }
    goto LABEL_62;
  }
  if (v9 == 1)
  {
    uint64_t v32 = v51;
    if (*(_WORD *)(v51[47] + 964) == 1) {
      goto LABEL_62;
    }
    goto LABEL_74;
  }
  if (v9 != 4)
  {
LABEL_63:
    if (v9 > 255)
    {
      if (v9 == 256 || v9 == 640 || v9 == 704) {
        goto LABEL_70;
      }
    }
    else if (v9 <= 0x20 && ((1 << v9) & 0x100010110) != 0)
    {
      goto LABEL_70;
    }
    uint64_t v41 = v51;
LABEL_71:
    obj_release(v41);
    if ((v31 & 1) == 0) {
      return v30;
    }
    goto LABEL_72;
  }
  if (*(_WORD *)(v51[47] + 964) == 4) {
    goto LABEL_62;
  }
LABEL_60:
  uint64_t v30 = 0;
LABEL_70:
  uint64_t v41 = v51;
  if (!v8) {
    goto LABEL_71;
  }
  log_err((uint64_t)"%s:%d: %s Encrypted volume is not allowed with special role = 0X%x\n", v23, v24, v25, v26, v27, v28, v29, (uint64_t)"apfs_is_volume_role_allowed");
  return 1;
}

uint64_t apfs_newfs(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, void *a5)
{
  unint64_t v310 = 0;
  *(void *)uint64_t v311 = 0;
  uint64_t v308 = 0;
  unint64_t v309 = 0;
  memset(uu, 0, sizeof(uu));
  uint64_t v306 = 0;
  uint64_t v307 = 0;
  unint64_t v304 = 0;
  uint64_t v305 = 0;
  uuid_clear(uu);
  *a5 = 0;
  if (!a2)
  {
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 0;
    int v16 = 0;
    int v17 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    LODWORD(v20) = 0;
    int v21 = 0;
    int v22 = 0;
    unsigned int v23 = 0;
    int v24 = 0;
    int v25 = 0;
    int v26 = 0;
    int v27 = 0;
    uint64_t v28 = 0;
    int v29 = 8;
    LODWORD(v30) = -1;
    uint64_t v31 = 1073741826;
    uint64_t v32 = 1073741826;
    goto LABEL_5;
  }
  unint64_t v10 = *(int *)(*(void *)(a1 + 376) + 36);
  if (strnlen((const char *)(a2 + 56), 0x100uLL) > 0xFF) {
    return 63;
  }
  if (!utf8_strlen_with_ascii_status(a2 + 56, 0, 0, 0, 0)) {
    return 92;
  }
  unint64_t v36 = *(void *)(a2 + 16);
  unint64_t v37 = *(void *)(a2 + 24);
  if (v36 % v10) {
    uint64_t v38 = v36 / v10 + 1;
  }
  else {
    uint64_t v38 = v36 / v10;
  }
  if (v37 % v10) {
    uint64_t v39 = v37 / v10 + 1;
  }
  else {
    uint64_t v39 = v37 / v10;
  }
  uint64_t v30 = *(unsigned int *)(a2 + 48);
  unsigned int v40 = *(unsigned __int16 *)(a2 + 52);
  unsigned int v41 = (v30 == 1) << 6;
  if (!v30) {
    unsigned int v41 = 1;
  }
  if (*(_WORD *)(a2 + 54)) {
    BOOL v42 = 1;
  }
  else {
    BOOL v42 = v30 == -1;
  }
  if (v42) {
    uint64_t v20 = *(unsigned __int16 *)(a2 + 54);
  }
  else {
    uint64_t v20 = v41;
  }
  BOOL v43 = v20 == 64 || v20 == 1;
  if (v43 && *(int *)(a2 + 452) > 0) {
    return 45;
  }
  int v279 = *(_DWORD *)(a2 + 36);
  int v283 = *(_DWORD *)(a2 + 40);
  int v285 = *(_DWORD *)(a2 + 44);
  uint64_t v287 = *(unsigned int *)(a2 + 492);
  uint64_t v294 = v39;
  uint64_t v296 = v38;
  int v290 = *(_DWORD *)(a2 + 444);
  unsigned int v292 = *(_DWORD *)(a2 + 32);
  int v288 = *(_DWORD *)(a2 + 448);
  int v298 = v40 & 1;
  unsigned int v302 = (v40 >> 9) & 1;
  uint64_t v46 = v298 | v302;
  uint64_t v47 = a1;
  BOOL v48 = v46 != 0;
  uint64_t v300 = v47;
  uint64_t is_volume_role_allowed = apfs_is_volume_role_allowed(v47, 0, v20, v30, v46, v33, v34, v35);
  if (is_volume_role_allowed) {
    return is_volume_role_allowed;
  }
  uint64_t v18 = (v40 >> 6) & 1;
  if (v48)
  {
    if (v302)
    {
      if ((*(unsigned char *)(*(void *)(v300 + 376) + 1264) & 4) != 0) {
        return 22;
      }
      int v55 = dev_crypto_type(*(void *)(v300 + 384));
      LODWORD(v18) = (v40 >> 6) & 1;
      if (!v55) {
        return 22;
      }
    }
    uint64_t v13 = (const char *)(a2 + 312);
    unsigned int v23 = *(_DWORD *)(a2 + 440);
    if (v18)
    {
      if (v23 > 0x80) {
        return 22;
      }
      uint64_t v18 = 1;
    }
    else
    {
      uint64_t v56 = *(unsigned int *)(a2 + 440);
      size_t v57 = strnlen(v13, 0x80uLL);
      uint64_t is_volume_role_allowed = 22;
      if (v57 > 0x7F) {
        return is_volume_role_allowed;
      }
      BOOL v42 = v57 == v56;
      uint64_t v13 = (const char *)(a2 + 312);
      if (!v42) {
        return is_volume_role_allowed;
      }
      unsigned int v23 = v56;
      uint64_t v18 = 0;
    }
    goto LABEL_131;
  }
  if ((*(unsigned char *)(*(void *)(v300 + 376) + 1264) & 4) != 0)
  {
    uint64_t v13 = 0;
    int v298 = 0;
    unsigned int v302 = 0;
    unsigned int v23 = 0;
  }
  else if (dev_crypto_type(*(void *)(v300 + 384)))
  {
    uint64_t v18 = (v40 >> 6) & 1;
    if (a3)
    {
      uint64_t v13 = 0;
      uint64_t is_volume_role_allowed = 22;
      int v298 = 0;
      if ((int)v20 <= 191)
      {
        if (v20 > 0x20) {
          return is_volume_role_allowed;
        }
        unsigned int v302 = 0;
        unsigned int v23 = 0;
        if (((1 << v20) & 0x100010112) == 0) {
          return is_volume_role_allowed;
        }
        goto LABEL_131;
      }
      if ((int)v20 <= 319)
      {
        if (v20 != 192)
        {
          unsigned int v302 = 0;
          unsigned int v23 = 0;
          if (v20 != 256) {
            return is_volume_role_allowed;
          }
          goto LABEL_131;
        }
      }
      else if (v20 != 320 && v20 != 704)
      {
        unsigned int v302 = 0;
        unsigned int v23 = 0;
        if (v20 != 640) {
          return is_volume_role_allowed;
        }
        goto LABEL_131;
      }
      unsigned int v302 = 0;
      unsigned int v23 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      unsigned int v302 = 0;
      unsigned int v23 = 0;
      int v298 = 1;
    }
  }
  else
  {
    uint64_t v13 = 0;
    int v298 = 0;
    unsigned int v302 = 0;
    unsigned int v23 = 0;
    uint64_t v18 = (v40 >> 6) & 1;
  }
LABEL_131:
  a1 = v300;
  uint64_t v274 = v18;
  unsigned int v276 = v23;
  uint64_t v278 = v13;
  if (v279 != 2)
  {
    log_warn((uint64_t)"%s:%d: %s fs tree type 0x%x invalid, using virtual btree instead\n", v49, v50, v51, v52, v53, v18, v54, (uint64_t)"apfs_newfs");
    unsigned int v23 = v276;
    uint64_t v13 = v278;
    uint64_t v18 = v274;
  }
  if (v283 != 1073741826)
  {
    log_warn((uint64_t)"%s:%d: %s extentref tree type 0x%x invalid, using physical btree instead\n", v49, v50, v51, v52, v53, v18, v54, (uint64_t)"apfs_newfs");
    unsigned int v23 = v276;
    uint64_t v13 = v278;
    uint64_t v18 = v274;
  }
  int v29 = (v40 >> 2) & 3;
  int v17 = (v40 >> 4) & 3;
  int v24 = (v40 >> 8) & 1;
  int v26 = (a3 >> 5) & 1;
  int v27 = (a3 >> 7) & 1;
  uint64_t v28 = (a3 >> 8) & 1;
  int v25 = (v40 >> 10) & 1;
  int v272 = v25;
  int v281 = v29;
  int v284 = v24;
  if (v285 != 1073741826)
  {
    log_warn((uint64_t)"%s:%d: %s snapmeta tree type 0x%x invalid, using physical btree instead\n", v49, v50, v51, v52, v28, v18, v54, (uint64_t)"apfs_newfs");
    int v24 = (v40 >> 8) & 1;
    int v29 = (v40 >> 2) & 3;
    int v26 = (a3 >> 5) & 1;
    int v25 = (v40 >> 10) & 1;
    unsigned int v23 = v276;
    uint64_t v13 = v278;
    int v27 = (a3 >> 7) & 1;
    uint64_t v18 = v274;
    uint64_t v28 = (a3 >> 8) & 1;
  }
  uint64_t v12 = (v40 >> 7) & 1;
  uint64_t v15 = v294;
  uint64_t v14 = v296;
  if ((v40 & 0x80) != 0)
  {
    uint64_t v32 = v287;
    if (v287 != 1073741826)
    {
      uint64_t v103 = v28;
      log_warn((uint64_t)"%s:%d: %s fext tree type 0x%x invalid, using physical btree instead\n", v49, v12, v296, v294, v28, v18, v54, (uint64_t)"apfs_newfs");
      int v24 = v284;
      int v29 = v281;
      int v26 = (a3 >> 5) & 1;
      int v25 = v272;
      unsigned int v23 = v276;
      uint64_t v13 = v278;
      int v27 = (a3 >> 7) & 1;
      uint64_t v18 = v274;
      uint64_t v28 = v103;
      uint64_t v15 = v294;
      uint64_t v14 = v296;
      uint64_t v12 = 1;
      uint64_t v32 = 1073741826;
    }
  }
  else
  {
    uint64_t v32 = v287;
  }
  int v16 = v298;
  int v22 = v288;
  int v21 = v290;
  uint64_t v19 = v302;
  uint64_t v31 = v292;
LABEL_5:
  if (*(unsigned char *)(a1 + 629) && v16 | v19) {
    return 1;
  }
  if (v17) {
    return 22;
  }
  if (v20 == 704 && (!v14 || v14 != v15))
  {
    log_err((uint64_t)"%s:%d: %s bad overprovisioning volume configuration: reserve %lld quota %lld\n", v31, v12, v14, v15, v28, v18, v19, (uint64_t)"apfs_newfs");
    return 22;
  }
  uint64_t v44 = *(void *)(a1 + 376);
  if (v30 != -1)
  {
    if ((v30 & 0x80000000) != 0)
    {
LABEL_101:
      log_err((uint64_t)"%s:%d: %s no space for a new file system (slot %d, max %d)\n", v31, v12, v14, v15, v28, v18, v19, (uint64_t)"apfs_newfs");
      return 34;
    }
    goto LABEL_38;
  }
  int v282 = v24;
  int v280 = v29;
  if (v20 == 64) {
    int v58 = 1;
  }
  else {
    int v58 = -1;
  }
  BOOL v59 = v20 == 64 || v20 == 1;
  uint64_t v45 = *(unsigned int *)(v44 + 180);
  if (v20 == 1) {
    LODWORD(v30) = 0;
  }
  else {
    LODWORD(v30) = v58;
  }
  unsigned int v60 = v30;
  if (v20 != 1)
  {
    unsigned int v60 = v30;
    if (v20 != 64)
    {
      if (v45 < 3)
      {
        unsigned int v60 = 2;
      }
      else
      {
        uint64_t v61 = 0;
        while (*(void *)(v44 + 200 + 8 * v61))
        {
          if (v45 - 2 == ++v61)
          {
            unsigned int v60 = *(_DWORD *)(v44 + 180);
            goto LABEL_80;
          }
        }
        unsigned int v60 = v61 + 2;
LABEL_80:
        if ((v60 & 0x80000000) != 0) {
          goto LABEL_90;
        }
      }
    }
  }
  if (v60 < v45)
  {
    int v62 = v25;
    if (!*(void *)(v44 + 8 * v60 + 184))
    {
      BOOL v59 = 1;
      LODWORD(v30) = v60;
    }
    if (!v59) {
      goto LABEL_85;
    }
LABEL_92:
    int v25 = v62;
    goto LABEL_93;
  }
LABEL_90:
  if (v20 != 1)
  {
    int v62 = v25;
    if (v20 != 64)
    {
LABEL_85:
      if (!v45) {
        goto LABEL_101;
      }
      uint64_t v30 = 0;
      int v25 = v62;
      while (*(void *)(v44 + 184 + 8 * v30))
      {
        if (v45 == ++v30)
        {
          LODWORD(v30) = *(_DWORD *)(v44 + 180);
          break;
        }
      }
      int v29 = v280;
      int v24 = v282;
      if ((v30 & 0x80000000) != 0) {
        goto LABEL_101;
      }
LABEL_38:
      int v282 = v24;
      LODWORD(v45) = *(_DWORD *)(v44 + 180);
      goto LABEL_94;
    }
    goto LABEL_92;
  }
LABEL_93:
  int v29 = v280;
LABEL_94:
  if (v30 >= v45) {
    goto LABEL_101;
  }
  if (*(void *)(v44 + 8 * v30 + 184))
  {
    log_err((uint64_t)"%s:%d: %s existing file system (slot %d)\n", v31, v12, v14, v15, v28, v18, v19, (uint64_t)"apfs_newfs");
    return 16;
  }
  int v63 = v29;
  int v270 = v26;
  int v271 = v25;
  unsigned int v275 = v23;
  uint64_t v277 = (uint64_t)v13;
  char v273 = v18;
  int v286 = v28;
  unint64_t v295 = v15;
  unint64_t v297 = v14;
  int v299 = v16;
  int v301 = v12;
  int v291 = v21;
  int v293 = v31;
  int v303 = v19;
  int v289 = v22;
  uint64_t v64 = tx_enter(a1, &v308);
  if (v64)
  {
    uint64_t is_volume_role_allowed = v64;
    log_err((uint64_t)"%s:%d: %s tx_enter() failed: %d\n", v65, v66, v67, v68, v69, v70, v71, (uint64_t)"apfs_newfs");
    return is_volume_role_allowed;
  }
  if (v299 | v303)
  {
    uint64_t v73 = *(void *)(a1 + 376);
    uint64_t v74 = *(void *)(v73 + 1264);
    if ((v74 & 4) == 0)
    {
      if (dev_crypto_type(*(void *)(a1 + 384))) {
        goto LABEL_108;
      }
      uint64_t v73 = *(void *)(a1 + 376);
      uint64_t v74 = *(void *)(v73 + 1264);
    }
    *(void *)(v73 + 1264) = v74 | 4;
  }
LABEL_108:
  uint64_t v75 = obj_create(*(pthread_mutex_t **)(a1 + 392), 0, 0, (unsigned int *)&apfs_desc, 0, 0, v308, (uint64_t *)v311);
  if (v75)
  {
    uint64_t is_volume_role_allowed = v75;
    log_err((uint64_t)"%s:%d: %s failed to create fs: %d\n", v76, v77, v78, v79, v80, v81, v82, (uint64_t)"apfs_newfs");
    goto LABEL_160;
  }
  BOOL v90 = (v299 | v303) == 0;
  uint64_t v91 = *(void *)v311;
  if (!a4) {
    BOOL v90 = 1;
  }
  if (!v90) {
    *(void *)(*(void *)v311 + 1144) = a4;
  }
  *(unsigned char *)(v91 + 3901) = (a3 & 8) != 0;
  *(_DWORD *)(*(void *)(v91 + 376) + 36) = v30;
  apfs_update_dev_name(v91);
  uint64_t v92 = *(void *)(*(void *)v311 + 376);
  *(_WORD *)(v92 + 964) = v20;
  uuid_copy((unsigned __int8 *)(v92 + 1008), uu);
  uint64_t v93 = *(void *)v311;
  *(void *)(*(void *)v311 + 3888) = 0;
  apfs_set_formatted_by(*(void *)(v93 + 376), (const char *)(a2 + 456), v308);
  if (a2 && !uuid_is_null((const unsigned __int8 *)a2))
  {
    uuid_copy((unsigned __int8 *)(*(void *)(*(void *)v311 + 376) + 240), (const unsigned __int8 *)a2);
    uint64_t v119 = *(void *)v311;
    uint64_t v120 = *(void *)(*(void *)v311 + 376);
    if (!strncmp((const char *)(v120 + 240), "apfsuuid", 8uLL))
    {
      *(unsigned char *)(v120 + 255) = v30;
      uint64_t v120 = *(void *)(v119 + 376);
    }
    uint64_t v121 = sub_10004D97C(a1, (const unsigned __int8 *)(v120 + 240));
    if (v121)
    {
      uint64_t v122 = v121;
      memset(out, 0, 37);
      uuid_unparse((const unsigned __int8 *)a2, (char *)out);
      log_err((uint64_t)"%s:%d: %s UUID %s is not allowed, error %d\n", v123, v124, v125, v126, v127, v128, v129, (uint64_t)"apfs_newfs");
      uint64_t is_volume_role_allowed = v122;
      goto LABEL_160;
    }
  }
  else
  {
    uuid_generate((unsigned __int8 *)(*(void *)(*(void *)v311 + 376) + 240));
  }
  uint64_t v100 = *(void *)v311;
  uint64_t v101 = *(void *)(*(void *)v311 + 376);
  *(void *)(v101 + 176) = 16;
  *(_DWORD *)(v101 + 960) = 3;
  *(_WORD *)(v101 + 966) = 0;
  if (v282) {
    *(void *)(v101 + 40) |= 0x10uLL;
  }
  if (v63 == 1)
  {
    uint64_t v102 = 1;
  }
  else
  {
    if (v63 != 2) {
      goto LABEL_144;
    }
    uint64_t v102 = 8;
  }
  *(void *)(v101 + 56) |= v102;
LABEL_144:
  if (v301) {
    *(void *)(v101 + 56) |= 0x20uLL;
  }
  if (v271)
  {
    *(void *)(v101 + 56) |= 0x80uLL;
    log_debug((uint64_t)"%s:%d: %s allocated unwritten file extents are now supported\n", v100, v94, v95, v96, v97, v98, v99, (uint64_t)"apfs_newfs");
    uint64_t v100 = *(void *)v311;
    uint64_t v101 = *(void *)(*(void *)v311 + 376);
  }
  *(void *)(v101 + 40) |= 2uLL;
  uint64_t is_volume_role_allowed = spaceman_fs_bounds_set((void *)a1, v100, v297, v295, v308);
  if (is_volume_role_allowed)
  {
    log_err((uint64_t)"%s:%d: %s Could not set fs bounds for guarantee %lld and quota %lld: %d\n", v104, v105, v106, v107, v108, v109, v110, (uint64_t)"apfs_newfs");
    goto LABEL_160;
  }
  if (v299 | v303)
  {
    crypto_cache_create(*(uint64_t *)v311);
    uint64_t v111 = meta_crypto_state_init(*(void **)v311, v308, v277, v275, *(void *)(*(void *)v311 + 376) + 96, *(void *)v311 + 528, *(void *)v311 + 624, *(void *)v311 + 912, 2 * v273);
    if (v111)
    {
      uint64_t is_volume_role_allowed = v111;
      log_err((uint64_t)"%s:%d: %s unable to create/store metadata crypto (%d)\n", v112, v113, v114, v115, v116, v117, v118, (uint64_t)"apfs_newfs");
      goto LABEL_160;
    }
  }
  else
  {
    log_debug((uint64_t)"%s:%d: %s FS will NOT be encrypted.\n", v104, v105, v106, v107, v108, v109, v110, (uint64_t)"apfs_newfs");
    uint64_t v130 = *(void **)v311;
    uint64_t v131 = *(void *)(*(void *)v311 + 376);
    *(void *)(v131 + 264) |= 1uLL;
    meta_crypto_state_init(v130, 0, 0, 0, v131 + 96, (uint64_t)(v130 + 66), (uint64_t)(v130 + 78), (uint64_t)(v130 + 114), 0);
    crypto_state_disable(*(void *)v311 + 528);
  }
  uint64_t v132 = *(pthread_mutex_t ***)v311;
  uint64_t v133 = *(void *)(*(void *)v311 + 376);
  *(void *)(v133 + 116) = 0x4000000200000002;
  *(_DWORD *)(v133 + 124) = 1073741826;
  *(_DWORD *)(v133 + 1104) = 2;
  uint64_t v134 = omap_create(v132, 0x40000000u, 0, v293, v308, &v310);
  if (v134)
  {
    uint64_t is_volume_role_allowed = v134;
    log_err((uint64_t)"%s:%d: %s fs omap initialization failed: %d\n", v135, v136, v137, v138, v139, v140, v141, (uint64_t)"apfs_newfs");
    goto LABEL_160;
  }
  uint64_t v196 = obj_oid((uint64_t)v310);
  *(void *)(*(void *)(*(void *)v311 + 376) + 128) = v196;
  obj_release(v310);
  long long v314 = xmmword_100080A88;
  long long v315 = unk_100080A98;
  long long v316 = xmmword_100080AA8;
  long long v317 = unk_100080AB8;
  long long v312 = off_100080A68;
  long long v313 = unk_100080A78;
  if (v301)
  {
    uint64_t is_volume_role_allowed = authapfs_integrity_meta_create(*(uint64_t *)v311, *(_DWORD *)(a2 + 488), v308, 0, v200, v201, v202, v203);
    if (is_volume_role_allowed) {
      goto LABEL_160;
    }
    HIDWORD(v313) = authapfs_hash_size(*(_DWORD *)(a2 + 488));
    DWORD2(v313) = *(_DWORD *)(a2 + 488);
    DWORD1(v313) |= 0x180u;
  }
  if ((unsigned __int16)*(_DWORD *)(*(void *)(*(void *)v311 + 376) + 116) != 2)
  {
    uint64_t is_volume_role_allowed = 22;
    goto LABEL_201;
  }
  uint64_t extended = btree_create_extended(*(pthread_mutex_t ***)v311, *(_DWORD *)(*(void *)(*(void *)v311 + 376) + 116) & 0xFFFF0000, 0, 0, 0, (uint64_t *)&v312, v308, (uint64_t *)&v305);
  if (extended)
  {
    uint64_t is_volume_role_allowed = extended;
LABEL_201:
    log_err((uint64_t)"%s:%d: %s fs root tree creation failed: %d\n", v197, v198, v199, v200, v201, v202, v203, (uint64_t)"apfs_newfs");
    goto LABEL_160;
  }
  uint64_t v212 = obj_oid((uint64_t)v305);
  uint64_t v213 = *(void *)v311;
  uint64_t v214 = *(void *)(*(void *)v311 + 376);
  *(void *)(v214 + 136) = v212;
  if (v270)
  {
    *(void *)(v214 + 56) |= 0x200uLL;
    log_debug((uint64_t)"%s:%d: %s expanded records are now supported\n", v205, v206, v207, v208, v209, v210, v211, (uint64_t)"apfs_newfs");
    uint64_t v213 = *(void *)v311;
    if (v27)
    {
      *(void *)(*(void *)(*(void *)v311 + 376) + 48) |= 4uLL;
      log_debug((uint64_t)"%s:%d: %s clone mapping is enabled for this volume\n", v205, v206, v207, v208, v209, v210, v211, (uint64_t)"apfs_newfs");
      uint64_t v213 = *(void *)v311;
    }
  }
  if (v286)
  {
    *(void *)(*(void *)(v213 + 376) + 48) |= 8uLL;
    log_debug((uint64_t)"%s:%d: %s attribution tags are supported on this volume\n", v205, v206, v207, v208, v209, v210, v211, (uint64_t)"apfs_newfs");
    uint64_t v213 = *(void *)v311;
  }
  int v215 = *(_DWORD *)(*(void *)(v213 + 376) + 120);
  uint64_t v216 = v308;
  out[1] = 0;
  uint64_t v323 = 0;
  long long v322 = 0u;
  long long v321 = 0u;
  long long v320 = 0u;
  *(_OWORD *)&out[3] = 0u;
  out[0] = (uint64_t)apfs_key_compare;
  out[2] = 0x420000000FLL;
  if ((unsigned __int16)v215 != 2)
  {
    uint64_t is_volume_role_allowed = 22;
    goto LABEL_211;
  }
  uint64_t v217 = btree_create_extended((pthread_mutex_t **)v213, v215 & 0xBFFF0000 | 0x40000000, 0, 0, 0, out, v308, (uint64_t *)&v307);
  if (v217)
  {
    uint64_t is_volume_role_allowed = v217;
LABEL_211:
    log_err((uint64_t)"%s:%d: %s fs extentref tree creation failed: %d\n", v205, v206, v207, v208, v209, v216, v211, (uint64_t)"apfs_newfs");
    goto LABEL_160;
  }
  uint64_t v224 = obj_oid((uint64_t)v307);
  uint64_t v225 = *(pthread_mutex_t ***)v311;
  uint64_t v226 = *(void *)(*(void *)v311 + 376);
  *(void *)(v226 + 144) = v224;
  int v227 = *(_DWORD *)(v226 + 124);
  uint64_t v228 = v308;
  out[1] = 0;
  uint64_t v323 = 0;
  long long v322 = 0u;
  long long v321 = 0u;
  long long v320 = 0u;
  *(_OWORD *)&out[3] = 0u;
  out[0] = (uint64_t)apfs_key_compare;
  out[2] = 0x4200000010;
  if ((unsigned __int16)v227 != 2)
  {
    uint64_t is_volume_role_allowed = 22;
    goto LABEL_216;
  }
  uint64_t v229 = btree_create_extended(v225, v227 & 0xBFFF0000 | 0x40000000, 0, 0, 0, out, v308, (uint64_t *)&v306);
  if (v229)
  {
    uint64_t is_volume_role_allowed = v229;
LABEL_216:
    log_err((uint64_t)"%s:%d: %s fs snapshot metadata tree creation failed: %d\n", v218, v219, v220, v221, v222, v228, v223, (uint64_t)"apfs_newfs");
    goto LABEL_160;
  }
  uint64_t v233 = obj_oid((uint64_t)v306);
  uint64_t v234 = *(void *)v311;
  *(void *)(*(void *)(*(void *)v311 + 376) + 152) = v233;
  if (v301)
  {
    uint64_t v235 = supplemental_tree_create((pthread_mutex_t **)v234, v32, 5, v308, (uint64_t *)&v304, v230, v231, v232);
    if (v235)
    {
      uint64_t is_volume_role_allowed = v235;
      log_err((uint64_t)"%s:%d: %s fs fext tree creation failed: %d\n", v236, v237, v238, v239, v240, v241, v242, (uint64_t)"apfs_newfs");
      goto LABEL_160;
    }
    uint64_t v234 = *(void *)v311;
    *(void *)(*(void *)(*(void *)v311 + 376) + 1032) = v304;
  }
  uint64_t name_checked = fs_obj_create_name_checked(v234, 1, 0, "root", 0, 2, 0x41EDu, v291, v289, 0, -1, 0, 0, (void *)(v234 + 480), v308, 0, 0xFFFFFFFF);
  if (name_checked)
  {
    uint64_t is_volume_role_allowed = name_checked;
    log_err((uint64_t)"%s:%d: %s fs root dir creation failed: %d\n", v244, v245, v246, v247, v248, v249, v250, (uint64_t)"apfs_newfs");
  }
  else
  {
    __strlcpy_chk();
    uint64_t v251 = fs_obj_create_name_checked(*(uint64_t *)v311, 1, 0, "private-dir", 0, 3, 0x41A4u, 0, 0, 0, -1, 0, 0, (void *)(*(void *)v311 + 488), v308, 0, 0xFFFFFFFF);
    if (!v251)
    {
      if (v299 | v303)
      {
        if (v303) {
          return 22;
        }
        uint64_t new_crypto_state_for_id = create_new_crypto_state_for_id(*(uint64_t *)v311, v308, 4);
        if (new_crypto_state_for_id)
        {
          uint64_t is_volume_role_allowed = new_crypto_state_for_id;
          log_err((uint64_t)"%s:%d: %s unable to create/store data sw crypto (%d)\n", v260, v261, v262, v263, v264, v265, v266, (uint64_t)"apfs_newfs");
          goto LABEL_160;
        }
        if (!v299) {
          sub_100060564();
        }
        uint64_t v267 = *(void *)v311;
        *(void *)(*(void *)(*(void *)v311 + 376) + 264) |= 8uLL;
      }
      else
      {
        uint64_t v267 = *(void *)v311;
      }
      *(void *)(*(void *)(a1 + 376) + 8 * v30 + 184) = obj_oid(v267);
      uint64_t timestamp = get_timestamp();
      uint64_t v269 = *(void *)v311;
      *(void *)(*(void *)(*(void *)v311 + 376) + 256) = timestamp;
      fs_sb_dirty(v269, v308);
      obj_release(v306);
      obj_release(v307);
      obj_release(v305);
      tx_leave(a1, v308, 5);
      uint64_t is_volume_role_allowed = 0;
      *a5 = *(void *)v311;
      return is_volume_role_allowed;
    }
    uint64_t is_volume_role_allowed = v251;
    log_err((uint64_t)"%s:%d: %s fs private dir creation failed: %d\n", v252, v253, v254, v255, v256, v257, v258, (uint64_t)"apfs_newfs");
  }
LABEL_160:
  log_err((uint64_t)"%s:%d: %s fs creation failed: %d ... cleaning up...\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"apfs_newfs");
  unint64_t v309 = 0;
  if (*(void *)v311)
  {
    if (v305)
    {
      if (btree_delete((uint64_t)v305, v308, &v309)) {
        log_err((uint64_t)"%s:%d: %s failed to delete fs root tree after fs creation failed: %d\n", v147, v148, v149, v150, v151, v152, v153, (uint64_t)"apfs_newfs");
      }
      obj_release(v305);
    }
    if (v306)
    {
      if (btree_delete((uint64_t)v306, v308, &v309)) {
        log_err((uint64_t)"%s:%d: %s failed to delete fs snap metadata tree after fs creation failed: %d\n", v154, v155, v156, v157, v158, v159, v160, (uint64_t)"apfs_newfs");
      }
      obj_release(v306);
    }
    if (v307)
    {
      if (btree_delete((uint64_t)v307, v308, &v309)) {
        log_err((uint64_t)"%s:%d: %s failed to delete fs extentref tree after fs creation failed: %d\n", v161, v162, v163, v164, v165, v166, v167, (uint64_t)"apfs_newfs");
      }
      obj_release(v307);
    }
    uint64_t v168 = v304;
    uint64_t v169 = *(void *)v311;
    if (v304)
    {
      int v171 = supplemental_tree_destroy(*(uint64_t *)v311, v32, 5, v308, v304, &v309, v145, v146);
      uint64_t v169 = *(void *)v311;
      if (v171)
      {
        log_err((uint64_t)"%s:%d: %s failed to delete fs fext tree after fs creation failed: %d\n", v170, v142, v143, v168, v144, v145, v146, (uint64_t)"apfs_newfs");
        uint64_t v169 = *(void *)v311;
      }
    }
    unint64_t v172 = *(void *)(*(void *)(v169 + 376) + 128);
    if (v172)
    {
      int v174 = omap_destroy(v169, v172, v308, &v309);
      uint64_t v169 = *(void *)v311;
      if (v174)
      {
        log_err((uint64_t)"%s:%d: %s failed to destroy omap after fs creation failed: %d\n", v173, v142, v143, v168, v144, v145, v146, (uint64_t)"apfs_newfs");
        uint64_t v169 = *(void *)v311;
      }
    }
    if (*(void *)(v169 + 3576))
    {
      obj_release(*(uint64_t **)(v169 + 3576));
      uint64_t v169 = *(void *)v311;
    }
    if (*(void *)(v169 + 3552))
    {
      obj_release(*(uint64_t **)(v169 + 3552));
      uint64_t v169 = *(void *)v311;
    }
    jobj_release(v169, *(unsigned char **)(v169 + 480), v142, v143, v168, v144, v145, v146);
    jobj_release(v175, *(unsigned char **)(*(void *)v311 + 488), v176, v177, v178, v179, v180, v181);
  }
  if (v308)
  {
    tx_leave(a1, v308, 0);
    uint64_t v308 = 0;
  }
  if (v309 && nx_reaper_wait((uint64_t *)a1, v309)) {
    log_err((uint64_t)"%s:%d: %s failed to wait on reaper: %d\n", v182, v183, v184, v185, v186, v187, v188, (uint64_t)"apfs_newfs");
  }
  if (*(void *)v311)
  {
    if (tx_enter(a1, &v308))
    {
      log_err((uint64_t)"%s:%d: %s Couldn't reopen transaction to clean up: %d\n", v189, v190, v191, v192, v193, v194, v195, (uint64_t)"apfs_newfs");
    }
    else
    {
      spaceman_fs_bounds_clear((void *)a1, *(uint64_t *)v311, v308);
      obj_delete_and_free(*(uint64_t **)v311, v308);
      tx_leave(a1, v308, 0);
      uint64_t v308 = 0;
    }
    obj_release(*(uint64_t **)v311);
  }
  return is_volume_role_allowed;
}

uint64_t sub_10004D97C(uint64_t a1, const unsigned __int8 *a2)
{
  uint64_t v2 = *(void *)(a1 + 376);
  if (*(_DWORD *)(v2 + 180))
  {
    for (unint64_t i = 0; i < *(unsigned int *)(v2 + 180); ++i)
    {
      uint64_t v18 = 0;
      unint64_t v6 = *(void *)(v2 + 8 * i + 184);
      if (v6)
      {
        uint64_t v7 = obj_get(*(void *)(a1 + 392), 0, v6, (int *)&apfs_desc, 0, 0, 0, 0, (uint64_t *)&v18);
        if (v7)
        {
          uint64_t v9 = v7;
          strerror(v7);
          log_err((uint64_t)"%s:%d: %s Failed to get fsys oid %lld - %s\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"apfs_is_volume_uuid_allowed");
          return v9;
        }
        int v8 = uuid_compare(a2, (const unsigned __int8 *)(v18[47] + 240));
        obj_release(v18);
        if (!v8) {
          return 17;
        }
        uint64_t v2 = *(void *)(a1 + 376);
      }
    }
  }
  return 0;
}

uint64_t apfs_free_data_blocks(void *a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a1[62]) {
    unint64_t v6 = (void *)a1[62];
  }
  else {
    unint64_t v6 = a1;
  }
  uint64_t v7 = spaceman_free(v6, 0, a3, a4, a2);
  uint64_t v8 = v7;
  if (v7)
  {
    strerror(v7);
    log_err((uint64_t)"%s:%d: %s spaceman_free failed for LBA %llx, size %llu : %d %s\n", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"apfs_free_data_blocks");
  }
  else
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6[47] + 232), a4, memory_order_relaxed);
    fs_sb_dirty((uint64_t)v6, a2);
  }
  return v8;
}

BOOL fs_is_fully_unencrypted(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 496);
  if (!v1) {
    uint64_t v1 = a1;
  }
  return (*(unsigned char *)(*(void *)(v1 + 376) + 264) & 1) != 0 && *(void *)(*(void *)(a1 + 376) + 976) == 0;
}

uint64_t sub_10004DB84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void *)(a1 + 496);
  if (!v10) {
    uint64_t v10 = a1;
  }
  if ((*(unsigned char *)(*(void *)(v10 + 376) + 264) & 9) != 0) {
    panic("assertion failed: %s", "fs_is_content_protected(apfs)");
  }
  uint64_t v23 = 0;
  long long v21 = 0u;
  long long v22 = 0u;
  if (unint64_t)(a2 + 1) < 7 && ((0x63u >> (a2 + 1))) {
    return 0;
  }
  LODWORD(v21) = 2622471;
  *((void *)&v21 + 1) = a2;
  LODWORD(v22) = -1;
  uint64_t inserted = insert_jobj(a1, 1, (unsigned __int8 *)&v21, a3, a5, a6, a7, a8);
  if (!inserted)
  {
    if (v22 == 1)
    {
LABEL_12:
      BYTE1(v21) = 3;
      return remove_jobj(a1, 1, (unsigned __int8 *)&v21, a3, v15, v16, v17, v18);
    }
    if (!v22)
    {
      log_debug((uint64_t)"%s:%d: %s danger - crypto id %lld had refcnt %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"icp_dec_ref");
      LODWORD(v22) = 1;
      goto LABEL_12;
    }
    return 0;
  }
  uint64_t v19 = inserted;
  log_debug((uint64_t)"%s:%d: %s was NOT able to update/decrement crypto state %lld, err = %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"icp_dec_ref");
  return v19;
}

uint64_t sub_10004DCE8(uint64_t a1, const void *a2, size_t a3, uint64_t a4, uint64_t a5, char a6)
{
  needs_ctx();
  uint64_t v11 = cpx_alloc(a3);
  uint64_t v12 = (uint64_t)v11;
  if (v11)
  {
    cpx_set_key_len((uint64_t)v11, (unsigned __int16)a3);
    uint64_t v13 = (void *)cpx_key(v12);
    memcpy(v13, a2, a3);
    cpx_set_use_offset_for_iv(v12, 1);
    if (a5) {
      cpx_set_aes_iv_key(v12, a4);
    }
    cpx_set_is_sep_wrapped_key(v12, a6 & 1);
  }
  return v12;
}

uint64_t cst_from_fvkey(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v4 = sub_10004DCE8(a1, *(const void **)a3, *(void *)(a3 + 8), 0, 0, *(_DWORD *)(a3 + 16));
  *(void *)(a2 + 72) = v4;
  if (v4) {
    return 0;
  }
  else {
    return 12;
  }
}

uint64_t load_wrapping_key(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  __int16 v17 = 0;
  char v16 = 0;
  if (*(void *)(a1 + 96)) {
    return v3;
  }
  uint64_t v3 = sub_10004DFE8(a1, (unsigned char *)&v17 + 1, &v17, &v16, &v19, &v18);
  if (v3) {
    return v3;
  }
  uint64_t v8 = v18;
  uint64_t v9 = v19;
  uint64_t v21 = 0;
  uint64_t v3 = 22;
  v20[0] = v22;
  v20[1] = 64;
  if (!HIBYTE(v17) || !v19 || !v18) {
    return v3;
  }
  uint64_t v10 = *(void **)(a1 + 96);
  if (v10) {
    goto LABEL_8;
  }
  memset(v22, 0, sizeof(v22));
  void v20[2] = 0;
  uint64_t v3 = (*(uint64_t (**)(void, uint64_t, uint64_t *))(a1 + 80))(*(void *)(a1 + 88), 2, &v21);
  if (v3) {
    return v3;
  }
  if (!v21) {
    return 6;
  }
  uint64_t v12 = ((uint64_t (*)(uint64_t, void *, uint64_t, uint64_t))v9)(a1, v20, 1, 1);
  if (v12)
  {
    uint64_t v3 = v12;
    if (v12 != 2) {
      return v3;
    }
    if (!a2) {
      return 2;
    }
    int v13 = 1;
    uint64_t v3 = ((uint64_t (*)(uint64_t, void *, void, uint64_t, uint64_t))v8)(a1, v20, 0, a3, 1);
    if (v3) {
      return v3;
    }
  }
  else
  {
    int v13 = 0;
  }
  uint64_t v14 = _apfs_calloc(1uLL, 0x60uLL);
  if (v14)
  {
    uint64_t v10 = v14;
    uint64_t v15 = cst_from_fvkey(v21, (uint64_t)v14, (uint64_t)v20);
    if (!v15)
    {
      *(void *)(a1 + 96) = v10;
LABEL_8:
      uint64_t v11 = v10[9];
      if (!v11) {
        return 1;
      }
      if (!v16) {
        cpx_set_is_composite_key(v11, 1);
      }
      return 0;
    }
    uint64_t v3 = v15;
    _apfs_free(v10, 96);
  }
  else
  {
    uint64_t v3 = 12;
  }
  if (v13) {
    ((void (*)(uint64_t, void, void, uint64_t, uint64_t))v8)(a1, 0, 0, a3, 1);
  }
  return v3;
}

uint64_t sub_10004DFE8(uint64_t a1, unsigned char *a2, unsigned char *a3, unsigned char *a4, uint64_t (**a5)(uint64_t a1, uint64_t a2), uint64_t (**a6)())
{
  uint64_t result = 22;
  if (a4 && a3 && a1 && a2 && a5 && a6)
  {
    uint64_t v14 = 0;
    uint64_t result = (*(uint64_t (**)(void, void, uint64_t *))(a1 + 80))(*(void *)(a1 + 88), 0, &v14);
    if (result == 45)
    {
LABEL_11:
      uint64_t result = 0;
      *a4 = 0;
      *a3 = 0;
      *a2 = 1;
      *a5 = sub_1000517A8;
      *a6 = sub_1000517F8;
      return result;
    }
    if (result) {
      return result;
    }
    BOOL v13 = is_sw_crypto(v14);
    if (v14)
    {
      if (is_sw_crypto(v14) && v13) {
        goto LABEL_11;
      }
    }
    else if (v13)
    {
      goto LABEL_11;
    }
    return 45;
  }
  return result;
}

uint64_t unload_wrapping_key(uint64_t a1, int a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v12 = 0;
    BOOL v13 = 0;
    __int16 v11 = 0;
    char v10 = 0;
    uint64_t v5 = sub_10004DFE8(a1, (unsigned char *)&v11 + 1, &v11, &v10, &v13, &v12);
    if (!v5)
    {
      __int16 v14 = 1;
      unsigned int v6 = ((uint64_t (*)(uint64_t, void, __int16 *, uint64_t, void))v12)(a1, 0, &v14, a3, HIBYTE(v11));
      if ((v6 & 0xFFFFFFFD) != 0) {
        uint64_t v5 = v6;
      }
      else {
        uint64_t v5 = 0;
      }
    }
  }
  else
  {
    uint64_t v5 = 0;
  }
  uint64_t v7 = *(void *)(a1 + 96);
  if (v7)
  {
    uint64_t v8 = *(unsigned __int16 **)(v7 + 72);
    if (v8)
    {
      cpx_free(v8);
      uint64_t v7 = *(void *)(a1 + 96);
    }
    *(_OWORD *)(v7 + 64) = 0u;
    *(_OWORD *)(v7 + 80) = 0u;
    *(_OWORD *)(v7 + 32) = 0u;
    *(_OWORD *)(v7 + 48) = 0u;
    *(_OWORD *)uint64_t v7 = 0u;
    *(_OWORD *)(v7 + 16) = 0u;
    _apfs_free(*(void **)(a1 + 96), 96);
    *(void *)(a1 + 96) = 0;
  }
  return v5;
}

pthread_mutex_t *container_keybag_alloc(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_mutex_t *)_apfs_calloc(1uLL, 0x68uLL);
  uint64_t v5 = v4;
  if (v4)
  {
    new_lock(v4);
    uuid_clear((unsigned __int8 *)&v5[1]);
    *(void *)&v5[1].__opaque[16] = a1;
    *(void *)&v5[1].__opaque[24] = 0;
    *(void *)&v5[1].__opaque[8] = a2;
  }
  return v5;
}

void container_keybag_free(pthread_mutex_t *a1)
{
  if (a1)
  {
    unload_wrapping_key((uint64_t)a1, 0, 0);
    free_lock(a1);
    _apfs_free(a1, 104);
  }
}

uint64_t nx_container_keybag_helper(uint64_t a1, int a2, uuid_t dst)
{
  switch(a2)
  {
    case 0:
      *(void *)uuid_t dst = a1;
      break;
    case 1:
      uuid_copy(dst, (const unsigned __int8 *)(*(void *)(a1 + 376) + 72));
      break;
    case 2:
      *(void *)uuid_t dst = *(void *)(a1 + 384);
      break;
    case 3:
      *(_OWORD *)uuid_t dst = *(_OWORD *)(*(void *)(a1 + 376) + 1296);
      break;
    case 4:
      *(_OWORD *)(*(void *)(a1 + 376) + 1296) = *(_OWORD *)dst;
      break;
    case 5:
      *(_DWORD *)uuid_t dst = 1801812339;
      break;
    default:
      return 0;
  }
  return 0;
}

pthread_mutex_t *nx_keybag_init(uint64_t a1)
{
  return container_keybag_alloc(a1, (uint64_t)nx_container_keybag_helper);
}

uint64_t akserror_to_errno(uint64_t result)
{
  if ((int)result <= -536870161)
  {
    if ((int)result <= -536870188)
    {
      switch(result)
      {
        case 0xE00002BD:
          return 12;
        case 0xE00002C2:
          return 22;
        case 0xE00002CA:
          return 5;
        default:
          return 1;
      }
    }
    else
    {
      switch(result)
      {
        case 0xE00002D5:
        case 0xE00002D8:
          uint64_t result = 16;
          break;
        case 0xE00002D6:
          uint64_t result = 60;
          break;
        case 0xE00002D7:
        case 0xE00002D9:
        case 0xE00002DA:
          return 1;
        case 0xE00002DB:
          uint64_t result = 28;
          break;
        default:
          if (result != -536870170) {
            return 1;
          }
LABEL_16:
          uint64_t result = 45;
          break;
      }
    }
  }
  else
  {
    switch(result)
    {
      case 0xE007C006:
      case 0xE007C007:
      case 0xE007C009:
      case 0xE007C010:
      case 0xE007C022:
        return 22;
      case 0xE007C008:
        return 13;
      case 0xE007C00A:
      case 0xE007C00D:
      case 0xE007C00F:
      case 0xE007C01A:
        return 5;
      case 0xE007C00B:
      case 0xE007C00C:
      case 0xE007C011:
      case 0xE007C012:
      case 0xE007C014:
      case 0xE007C015:
      case 0xE007C016:
      case 0xE007C017:
      case 0xE007C01B:
      case 0xE007C01C:
      case 0xE007C01D:
      case 0xE007C01E:
      case 0xE007C020:
        return 1;
      case 0xE007C00E:
        return 36;
      case 0xE007C013:
      case 0xE007C018:
      case 0xE007C019:
        return 92;
      case 0xE007C01F:
        return 30;
      case 0xE007C021:
        goto LABEL_16;
      default:
        if (result == -536870160)
        {
          uint64_t result = 2;
        }
        else if (result)
        {
          return 1;
        }
        break;
    }
  }
  return result;
}

uint64_t sub_10004E508(pthread_mutex_t *a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, int a5, uint64_t a6)
{
  uint64_t v6 = a6;
  if (a4) {
    BOOL v11 = a4[9] != 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (a4) {
    BOOL v12 = 0;
  }
  else {
    BOOL v12 = a5 == 2;
  }
  int v14 = v12 && a3 == 0;
  if (a6) {
    pthread_mutex_lock(a1);
  }
  uint64_t v83 = 0;
  uint64_t v84 = 0;
  uint64_t v82 = 0;
  long long v75 = 0u;
  *(_OWORD *)uint64_t v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  uint64_t v81 = 0;
  uint64_t v72 = 0;
  uint64_t v73 = 0;
  uint64_t v71 = 0;
  int v70 = 0;
  if (v11)
  {
    if (a3)
    {
      int v15 = 0;
    }
    else
    {
      uint64_t v18 = a4[9];
      int v15 = v18 + 24;
      if (((v18 + 24) & 0xF) != 0) {
        int v15 = v18 - ((v18 + 24) & 0xF) + 40;
      }
    }
  }
  else
  {
    unsigned int v16 = (*(uint64_t (**)(void, uint64_t, uint64_t *))&a1[1].__opaque[8])(*(void *)&a1[1].__opaque[16], 3, &v72);
    if (v16 || !v73 || !v72)
    {
      if (v16) {
        uint64_t wrapping_key = v16;
      }
      else {
        uint64_t wrapping_key = 2 * (a3 != 0);
      }
      if (!v6) {
        return wrapping_key;
      }
LABEL_33:
      pthread_mutex_unlock(a1);
      return wrapping_key;
    }
    if (a3) {
      int v15 = 0;
    }
    else {
      int v15 = -1;
    }
  }
  uint64_t v74 = 0;
  uint64_t wrapping_key = sub_10004F18C((uint64_t)a1, v15, &v82, (uint64_t)&v72, &v83, &v84, (size_t *)&v74, (uint64_t)&v70);
  if (wrapping_key)
  {
    if (!v6) {
      return wrapping_key;
    }
    goto LABEL_33;
  }
  uint64_t v20 = 0;
  if (a3 == 0 && v83 != 0) {
    uint64_t v21 = a2;
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v71 = v21;
  BOOL v67 = a3 == 0 && v83 != 0;
  if (v67)
  {
    uint64_t wrapping_key = tx_enter(v83, &v71);
    if (wrapping_key) {
      goto LABEL_52;
    }
    uint64_t v20 = v71;
  }
  uint64_t wrapping_key = load_wrapping_key((uint64_t)a1, v11, v20);
  if (wrapping_key) {
    goto LABEL_42;
  }
  int v25 = v84;
  *(void *)&long long v75 = "APFS/container";
  *((void *)&v75 + 1) = v84 + 32;
  uint64_t v68 = v84 + 32;
  v76[0] = v74 - 32;
  v76[1] = (size_t)sub_10004F36C;
  *(void *)&long long v77 = sub_100051800;
  uint64_t v26 = v83;
  *((void *)&v77 + 1) = sub_100051954;
  *(void *)&long long v78 = v82;
  if (!v67) {
    uint64_t v26 = 0;
  }
  *((void *)&v78 + 1) = *(void *)&a1[1].__opaque[24];
  *(void *)&long long v79 = v26;
  *((void *)&v79 + 1) = v71;
  *((void *)&v80 + 1) = &v72;
  uint64_t v81 = v84;
  LODWORD(v80) = v70;
  if (a4) {
    int v27 = a4;
  }
  else {
    int v27 = a3;
  }
  v85[0] = 0;
  BOOL v66 = a4 && !a4[8] && a4[9] == 0;
  if (v27) {
    int v28 = 1;
  }
  else {
    int v28 = v14;
  }
  char v62 = v28;
  if (v28 != 1) {
    goto LABEL_70;
  }
  if (sub_10004F36C((uint64_t)&v75, v85)) {
    goto LABEL_153;
  }
  if (v85[0]) {
    goto LABEL_71;
  }
  if (!(void)v79)
  {
LABEL_153:
    if (a4 && a4[9]) {
      goto LABEL_70;
    }
LABEL_149:
    if (!v85[0])
    {
LABEL_150:
      uint64_t wrapping_key = 2;
      goto LABEL_42;
    }
    goto LABEL_71;
  }
  if (!a4 || !a4[9])
  {
    log_err((uint64_t)"%s:%d: malformed %s keybag%s\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"keybag_operation");
    goto LABEL_149;
  }
  log_err((uint64_t)"%s:%d: malformed %s keybag%s\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"keybag_operation");
LABEL_70:
  bzero(v68, v76[0]);
  *((void *)v25 + 4) = 0x1000000002;
LABEL_71:
  uint64_t v69 = v25;
  if (!v27)
  {
LABEL_110:
    if ((v62 & 1) == 0) {
      goto LABEL_141;
    }
    if (!a4)
    {
      if (!v14)
      {
        uint64_t wrapping_key = 0;
LABEL_144:
        if (wrapping_key == 0 && v67) {
          uint64_t wrapping_key = (*(uint64_t (**)(void, uint64_t, uint64_t *))&a1[1].__opaque[8])(*(void *)&a1[1].__opaque[16], 4, &v72);
        }
        goto LABEL_42;
      }
LABEL_127:
      if ((void)v77)
      {
        uint64_t wrapping_key = ((uint64_t (*)(long long *))v77)(&v75);
        if (!wrapping_key)
        {
          log_debug((uint64_t)"%s:%d: wrote %s keybag (v%d, %d keys, %d bytes)\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"keybag_operation");
          goto LABEL_144;
        }
      }
      else
      {
        uint64_t wrapping_key = 45;
      }
      log_err((uint64_t)"%s:%d: unable to write %d-byte %s keybag (%d)\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"keybag_operation");
      goto LABEL_42;
    }
LABEL_112:
    if (!*((_WORD *)v25 + 17)) {
      goto LABEL_141;
    }
    goto LABEL_127;
  }
  char v61 = 0;
  uu2 = (unsigned __int8 *)(v25 + 48);
  uint64_t v64 = a2;
  int v65 = v14;
  while (1)
  {
    uint64_t v36 = *((unsigned int *)v25 + 9);
    if (v36 >= 0x11) {
      break;
    }
    uint64_t v39 = 0;
    if (a4) {
      goto LABEL_83;
    }
LABEL_91:
    if (!v39) {
      goto LABEL_150;
    }
    uint64_t v50 = a3[9];
    unint64_t v51 = v50 + 24;
    uint64_t v52 = v39[9];
    unint64_t v53 = v50 - ((v50 + 24) & 0xF) + 40;
    if ((v51 & 0xF) == 0) {
      unint64_t v53 = v51;
    }
    if ((((_BYTE)v52 + 24) & 0xF) != 0) {
      size_t v54 = v52 - (((_BYTE)v52 + 24) & 0xF) + 40;
    }
    else {
      size_t v54 = v52 + 24;
    }
    if (v54 > v53)
    {
      uint64_t wrapping_key = 40;
      goto LABEL_42;
    }
    memcpy(a3, v39, v54);
LABEL_109:
    if (!v66) {
      goto LABEL_110;
    }
  }
  int v37 = v27[8];
  uint64_t v38 = &v68[v36];
  uint64_t v39 = (unsigned __int16 *)uu2;
  while (uuid_compare((const unsigned __int8 *)v27, (const unsigned __int8 *)v39) || v37 && v39[8] != v37)
  {
    uint64_t v40 = v39[9];
    uint64_t v41 = v40 + 24;
    uint64_t v42 = v40 - ((v40 + 24) & 0xF) + 40;
    if ((v41 & 0xF) == 0) {
      uint64_t v42 = v41;
    }
    uint64_t v39 = (unsigned __int16 *)((char *)v39 + v42);
    if (v39 >= (unsigned __int16 *)v38)
    {
      uint64_t v39 = 0;
      break;
    }
  }
  int v14 = v65;
  int v25 = v69;
  if (!a4) {
    goto LABEL_91;
  }
LABEL_83:
  if (v39)
  {
    uint64_t v43 = v6;
    uint64_t v44 = v39[9];
    size_t v45 = v44 + 24;
    uint64_t v46 = v44 - ((v44 + 24) & 0xF) + 40;
    if ((v45 & 0xF) != 0) {
      size_t v47 = v46;
    }
    else {
      size_t v47 = v45;
    }
    uint64_t v48 = a4[9];
    if (a4[9])
    {
      size_t v49 = v48 + 24;
      if (((v48 + 24) & 0xF) != 0) {
        size_t v49 = v48 - ((v48 + 24) & 0xF) + 40;
      }
    }
    else
    {
      size_t v49 = 0;
    }
    uint64_t v55 = *((unsigned int *)v25 + 9);
    if (v49 - v47 + v55 > v76[0])
    {
      uint64_t wrapping_key = 28;
      LODWORD(v6) = v43;
      a2 = v64;
      goto LABEL_42;
    }
    if (v49 == v47)
    {
      memcpy(v39, a4, v47);
      uint64_t v6 = v43;
      a2 = v64;
      int v25 = v69;
    }
    else
    {
      memmove(v39, (char *)v39 + v47, v68 - ((char *)v39 + v47) + v55);
      if (v49 < v47) {
        bzero(&v68[*((unsigned int *)v69 + 9) + v49 - v47], v47 - v49);
      }
      if (a4[9])
      {
        memcpy(&v68[*((unsigned int *)v69 + 9) - v47], a4, v49);
        int v25 = v69;
        *((_DWORD *)v69 + 9) += v49 - v47;
      }
      else
      {
        int v25 = v69;
        --*((_WORD *)v69 + 17);
        *((_DWORD *)v69 + 9) -= v47;
        char v61 = 1;
      }
      uint64_t v6 = v43;
      a2 = v64;
      int v14 = v65;
    }
    goto LABEL_109;
  }
  uint64_t v56 = a4[9];
  if (!a4[9])
  {
    if (v66) {
      uint64_t wrapping_key = 0;
    }
    else {
      uint64_t wrapping_key = 2;
    }
    if (v66 & v61) {
      goto LABEL_140;
    }
    goto LABEL_144;
  }
  size_t v57 = v56 + 24;
  uint64_t v58 = v56 - ((v56 + 24) & 0xF) + 40;
  if ((v57 & 0xF) != 0) {
    size_t v59 = v58;
  }
  else {
    size_t v59 = v57;
  }
  uint64_t v60 = *((unsigned int *)v25 + 9);
  if (v59 + v60 > v76[0])
  {
    uint64_t wrapping_key = 28;
    goto LABEL_42;
  }
  memcpy(&v68[v60], a4, v59);
  ++*((_WORD *)v25 + 17);
  *((_DWORD *)v25 + 9) += v59;
LABEL_140:
  int v25 = v69;
  if (v62) {
    goto LABEL_112;
  }
LABEL_141:
  if (*((void *)&v77 + 1))
  {
    uint64_t wrapping_key = (*((uint64_t (**)(long long *))&v77 + 1))(&v75);
    if (!wrapping_key)
    {
      log_debug((uint64_t)"%s:%d: wiped %s keybag\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"keybag_operation");
      goto LABEL_144;
    }
  }
  else
  {
    uint64_t wrapping_key = 45;
  }
  log_err((uint64_t)"%s:%d: unable to wipe %s keybag (%d)\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"keybag_operation");
LABEL_42:
  if (v67)
  {
    if (v71 == a2) {
      char v22 = 0;
    }
    else {
      char v22 = 5;
    }
    unsigned int v23 = tx_leave(v83, v71, v22);
    if (wrapping_key) {
      BOOL v24 = 1;
    }
    else {
      BOOL v24 = v23 == 0;
    }
    if (v24) {
      uint64_t wrapping_key = wrapping_key;
    }
    else {
      uint64_t wrapping_key = v23;
    }
  }
LABEL_52:
  _apfs_free(v84, v74);
  if (v6) {
    goto LABEL_33;
  }
  return wrapping_key;
}

uint64_t nx_keybag_delete(pthread_mutex_t *a1, uint64_t a2, unsigned __int8 *src, unsigned __int16 a4)
{
  uint64_t v10 = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  uuid_copy((unsigned __int8 *)&v8, src);
  LODWORD(v9) = a4;
  if (a1) {
    return sub_10004E508(a1, a2, 0, (unsigned __int16 *)&v8, 0, 1);
  }
  else {
    return 12;
  }
}

uint64_t apfs_container_keybag_helper(uint64_t a1, int a2, unsigned __int8 *a3)
{
  switch(a2)
  {
    case 0:
      uint64_t v5 = *(void *)(a1 + 392);
      goto LABEL_6;
    case 1:
      if (is_sw_crypto(*(void *)(a1 + 392))) {
        uint64_t v6 = (const unsigned __int8 *)(*(void *)(a1 + 376) + 240);
      }
      else {
        uint64_t v6 = (const unsigned __int8 *)(*(void *)(*(void *)(a1 + 392) + 376) + 72);
      }
      uuid_copy(a3, v6);
      break;
    case 2:
      uint64_t v5 = *(void *)(*(void *)(a1 + 392) + 384);
LABEL_6:
      *(void *)a3 = v5;
      break;
    case 3:
      *(_OWORD *)a3 = *(_OWORD *)(a1 + 3744);
      break;
    case 4:
      *(_OWORD *)(a1 + 3744) = *(_OWORD *)a3;
      break;
    case 5:
      *(_DWORD *)a3 = 1919247219;
      break;
    default:
      return 0;
  }
  return 0;
}

void apfs_keybag_init(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  *(_OWORD *)uuid_t dst = 0u;
  if (!a1) {
    sub_100060590();
  }
  uint64_t v3 = *(void *)(a1 + 376);
  if (!v3) {
    sub_1000605BC();
  }
  uint64_t v4 = *(void *)(a1 + 392);
  if (!v4) {
    sub_1000605E8();
  }
  uint64_t v5 = *(pthread_mutex_t **)(v4 + 912);
  if (!v5) {
    sub_100060614();
  }
  uuid_copy(dst, (const unsigned __int8 *)(v3 + 240));
  LODWORD(v16[0]) = 1048579;
  int v7 = sub_10004E508(v5, 0, (unsigned __int16 *)dst, 0, 0, 1);
  if (v7 != 2)
  {
    if (!v7)
    {
      *(_OWORD *)(a1 + 3744) = *(_OWORD *)((char *)v16 + 8);
      *(void *)(a1 + 3736) = container_keybag_alloc(a1, (uint64_t)apfs_container_keybag_helper);
      return;
    }
    log_err((uint64_t)"%s:%d: failed to get apfs volume keybag, err = %d\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"apfs_keybag_get");
    goto LABEL_12;
  }
  if (!a2 || apfs_keybag_create(a1, a2))
  {
LABEL_12:
    *(void *)(a1 + 3736) = 0;
    log_err((uint64_t)"%s:%d: failed to initialize volume keybag, err = %d\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"apfs_keybag_init");
  }
}

uint64_t apfs_keybag_create(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 1128);
  if (v3) {
    long long v4 = *(_OWORD *)(v3 + 280);
  }
  else {
    long long v4 = xmmword_10007EC30;
  }
  *(_OWORD *)(a1 + 3744) = v4;
  uint64_t v5 = sub_10004F96C((void *)a1, a2);
  if (v5)
  {
    uint64_t v13 = v5;
    log_err((uint64_t)"%s:%d: failed to add apfs unlock records range in nx keybag, err = %d\n", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"apfs_keybag_create");
  }
  else
  {
    uint64_t v14 = container_keybag_alloc(a1, (uint64_t)apfs_container_keybag_helper);
    *(void *)(a1 + 3736) = v14;
    if (v14) {
      return 0;
    }
    else {
      return 12;
    }
  }
  return v13;
}

uint64_t apfs_keybag_iter_setup(uint64_t a1, void *a2)
{
  char v9 = 0;
  uint64_t result = 22;
  if (a1 && a2)
  {
    unint64_t v14 = 0;
    uint64_t v15 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = 0;
    int v11 = 0;
    v10[0] = 0;
    v10[1] = 0;
    if (!sub_10004F18C(a1, 0, &v15, (uint64_t)v10, &v14, &v13, (size_t *)&v12, (uint64_t)&v11))
    {
      int wrapping_key = load_wrapping_key(a1, 0, 0);
      uint64_t v6 = v12;
      if (!wrapping_key)
      {
        uint64_t v20 = 0;
        long long v18 = 0u;
        long long v19 = 0u;
        uint64_t v17 = 0;
        v16[0] = "APFS/container";
        v16[1] = v13 + 32;
        _OWORD v16[2] = v12 - 32;
        v16[3] = sub_10004F36C;
        v16[4] = 0;
        v16[5] = 0;
        v16[6] = v15;
        uint64_t v17 = *(void *)(a1 + 96);
        long long v18 = v14;
        *((void *)&v19 + 1) = v10;
        uint64_t v20 = v13;
        LODWORD(v19) = v11;
        if (!sub_10004F36C((uint64_t)v16, &v9))
        {
          if (v9)
          {
            uint64_t result = 0;
            uint64_t v7 = v13;
            uint64_t v8 = v13 + 48;
            a2[1] = v6;
            a2[2] = v7;
            *a2 = v8;
            return result;
          }
        }
      }
      _apfs_free(v13, v6);
    }
    return 2;
  }
  return result;
}

uint64_t sub_10004F18C(uint64_t a1, int a2, uint64_t *a3, uint64_t a4, void *a5, void *a6, size_t *a7, uint64_t a8)
{
  uint64_t v9 = *(void *)(a1 + 88);
  if (!v9) {
    return 22;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 80))(v9, 1, a1 + 64);
  if (!result)
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t *))(a1 + 80))(*(void *)(a1 + 88), 2, a3);
    if (!result)
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 80))(*(void *)(a1 + 88), 3, a4);
      if (!result)
      {
        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(a1 + 80))(*(void *)(a1 + 88), 5, a8);
        if (!result)
        {
          *a5 = 0;
          int v18 = (*(uint64_t (**)(void, void, void *))(a1 + 80))(*(void *)(a1 + 88), 0, a5);
          if (v18 && v18 != 45)
          {
            if (!*(void *)(a4 + 8))
            {
              if (a2) {
                return 30;
              }
              else {
                return 2;
              }
            }
            *a5 = 0;
          }
          uint64_t v19 = *(void *)(a4 + 8);
          size_t v20 = v19 * dev_block_size(*a3);
          *a7 = v20;
          if (a2 >= 1 && *a5)
          {
            if (*(void *)(a4 + 8)) {
              int v21 = 0;
            }
            else {
              int v21 = 48;
            }
            unsigned int v22 = (v21 + a2) % dev_block_size(*a3);
            if (*(void *)(a4 + 8)) {
              uint64_t v23 = 0;
            }
            else {
              uint64_t v23 = 48;
            }
            if (v22)
            {
              unsigned int v24 = dev_block_size(*a3);
              if (*(void *)(a4 + 8)) {
                int v25 = 0;
              }
              else {
                int v25 = 48;
              }
              uint64_t v26 = v23 + a2 + v24 - (v25 + a2) % dev_block_size(*a3);
            }
            else
            {
              uint64_t v26 = v23 + a2;
            }
            size_t v20 = *a7 + v26;
            *a7 = v20;
          }
          if (!a6) {
            return 0;
          }
          int v27 = _apfs_malloc(v20);
          *a6 = v27;
          if (v27) {
            uint64_t result = 0;
          }
          else {
            uint64_t result = 12;
          }
          if (a2 >= 1 && v27)
          {
            bzero(v27, *a7);
            return 0;
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_10004F36C(uint64_t a1, char *a2)
{
  uint64_t v4 = *(void *)(a1 + 96);
  uint64_t v5 = *(void *)(*(void *)(a1 + 88) + 8);
  unsigned int v6 = dev_block_size(*(void *)(a1 + 48));
  uint64_t v7 = *(uint64_t **)(a1 + 88);
  if (!*v7 || !v7[1]) {
    return 2;
  }
  unsigned int v8 = v6;
  cpx_setcpoff(*(void *)(*(void *)(a1 + 56) + 72), *v7);
  uint64_t data = dev_read_data(*(void *)(a1 + 48), **(void **)(a1 + 88));
  if (data)
  {
    uint64_t v17 = data;
    log_err((uint64_t)"%s:%d: dev_read_data failed with error %d\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"container_kb_get");
    return v17;
  }
  uint64_t v19 = *(void *)(*(void *)(a1 + 88) + 8);
  unsigned int v20 = dev_block_size(*(void *)(a1 + 48));
  if (fletcher64_verify_cksum((void *)v4, (uint32x4_t *)(v4 + 8), v19 * v20 - 8, 0, v21, v22))
  {
    log_err((uint64_t)"%s:%d: Checksum failure\n", v23, v24, v25, v26, v27, v28, v29, (uint64_t)"container_kb_get");
LABEL_25:
    uint64_t v17 = 0;
    *a2 = 0;
    return v17;
  }
  int v30 = *(_DWORD *)(v4 + 24);
  if (v30 != 1801812339 && v30 != 1835754873 && v30 != 1919247219
    || *(_WORD *)(v4 + 32) != 2 && (**(_WORD **)(a1 + 8) != 2 || v5 * v8 == 32))
  {
    log_err((uint64_t)"%s:%d: %s: version error, bag->mk_obj.o_type %u != %u and %u, or locker->kl_version %u != %u, or size %lu != keybag_version_upgrade %lu\n", v23, v24, v25, v26, v27, v28, v29, (uint64_t)"container_kb_get");
    goto LABEL_25;
  }
  unint64_t v31 = *(unsigned int *)(v4 + 36);
  BOOL v32 = v31 > 0xF && v5 * (unint64_t)v8 - 32 >= v31;
  char v33 = v32;
  *a2 = v33;
  if (!v32) {
    log_err((uint64_t)"%s:%d: %d >= %lu && %d <= %lu\n", v23, v24, v25, v26, v27, v28, v29, (uint64_t)"container_kb_get");
  }
  return 0;
}

uint64_t apfs_keybag_iter_alloc(uint64_t a1, void *a2)
{
  if (!a1) {
    sub_100060640();
  }
  apfs_keybag_init(a1, 0);
  if (!*(void *)(a1 + 3736)) {
    return 2;
  }
  uint64_t v4 = _apfs_calloc(1uLL, 0x18uLL);
  if (!v4) {
    return 12;
  }
  uint64_t v5 = v4;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 3736));
  uint64_t v6 = apfs_keybag_iter_setup(*(void *)(a1 + 3736), v5);
  if (v6)
  {
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 3736));
    _apfs_free(v5, 24);
  }
  else
  {
    *a2 = v5;
  }
  return v6;
}

uint64_t apfs_keybag_iter_next(unint64_t *a1, uuid_t dst, void *a3, int a4)
{
  unint64_t v4 = a1[2] + *(unsigned int *)(a1[2] + 36) + 32;
  unint64_t v5 = *a1;
  if (*a1 >= v4) {
    return 0;
  }
  while (a4 && *(unsigned __int16 *)(v5 + 16) != a4)
  {
    uint64_t v8 = *(unsigned __int16 *)(v5 + 18);
    uint64_t v9 = v8 + 24;
    uint64_t v10 = v8 - ((v8 + 24) & 0xF) + 40;
    if ((v9 & 0xF) == 0) {
      uint64_t v10 = v9;
    }
    v5 += v10;
    if (v5 >= v4) {
      return 0;
    }
  }
  uuid_copy(dst, (const unsigned __int8 *)v5);
  uint64_t v12 = *(unsigned __int16 *)(v5 + 18);
  if (a3)
  {
    *a3 = v5 + 24;
    a3[1] = v12;
  }
  uint64_t v13 = v12 + 24;
  uint64_t v14 = v12 - ((v12 + 24) & 0xF) + 40;
  if ((v13 & 0xF) == 0) {
    uint64_t v14 = v13;
  }
  *a1 = v5 + v14;
  return 1;
}

uint64_t apfs_keybag_iter_free(uint64_t a1, uint64_t a2)
{
  _apfs_free(*(void **)(a2 + 16), *(void *)(a2 + 8));
  _apfs_free((void *)a2, 24);
  unint64_t v4 = *(pthread_mutex_t **)(a1 + 3736);

  return pthread_mutex_unlock(v4);
}

uint64_t apfs_keybag_lookup_record(uint64_t a1, unsigned __int8 *uu, __int16 a3, uint64_t a4)
{
  if (!a1) {
    sub_10006066C();
  }
  if (uuid_is_null(uu)) {
    sub_100060698();
  }
  apfs_keybag_init(a1, 0);
  uint64_t v8 = *(pthread_mutex_t **)(a1 + 3736);
  if (!v8) {
    return 2;
  }

  return sub_10004F7E0(v8, uu, a3, a4);
}

uint64_t sub_10004F7E0(pthread_mutex_t *a1, const unsigned __int8 *a2, __int16 a3, uint64_t a4)
{
  bzero(dst, 0x228uLL);
  if (!a1) {
    return 2;
  }
  uuid_copy(dst, a2);
  __int16 v16 = a3;
  unsigned __int16 __n = 512;
  uint64_t result = sub_10004E508(a1, 0, (unsigned __int16 *)dst, 0, 0, 1);
  if (!result)
  {
    if (a4)
    {
      if (*(void *)(a4 + 8) >= (unint64_t)__n)
      {
        memcpy(*(void **)a4, &__n_6, __n);
        uint64_t result = 0;
        *(void *)(a4 + 8) = __n;
      }
      else
      {
        log_err((uint64_t)"%s:%d: output buffer too small: len %zu, must be at least %d\n", v9, __n, v10, v11, v12, v13, v14, (uint64_t)"container_keybag_lookup_record");
        return 22;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t nx_keybag_lookup_record(uint64_t a1, unsigned __int8 *uu, __int16 a3, uint64_t a4)
{
  if (!a1) {
    sub_1000606C4();
  }
  if (uuid_is_null(uu)) {
    sub_1000606F0();
  }
  uint64_t v8 = *(pthread_mutex_t **)(a1 + 912);

  return sub_10004F7E0(v8, uu, a3, a4);
}

uint64_t sub_10004F96C(void *a1, uint64_t a2)
{
  uint64_t v17 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  if (!a1) {
    sub_10006071C();
  }
  uint64_t v4 = a1[468];
  uint64_t v5 = a1[469];
  uint64_t v6 = a1[141];
  if (v6)
  {
    uint64_t v7 = (const unsigned __int8 *)(v6 + 32);
    uint64_t v8 = *(pthread_mutex_t **)(v6 + 8);
    uint64_t v9 = (uint64_t *)a1[141];
    if (!*(_DWORD *)(v6 + 300))
    {
LABEL_6:
      unint64_t v10 = *(void *)(v6 + 256);
      v4 -= v10 / dev_block_size(*v9);
      goto LABEL_11;
    }
    if (((*(void *)(v6 + 280) << __clz(__rbit64(dev_block_size(*(void *)v6)))) & 0x4000000000000000) != 0)
    {
      uint64_t v9 = (uint64_t *)a1[141];
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v11 = a1[47];
    if (!v11) {
      sub_100060748();
    }
    uint64_t v12 = a1[49];
    if (!v12) {
      sub_100060774();
    }
    uint64_t v8 = *(pthread_mutex_t **)(v12 + 912);
    if (!v8) {
      sub_1000607A0();
    }
    uint64_t v7 = (const unsigned __int8 *)(v11 + 240);
  }
LABEL_11:
  uuid_copy((unsigned __int8 *)&v14, v7);
  LODWORD(v15) = 1048579;
  *((void *)&v15 + 1) = v4;
  *(void *)&long long v16 = v5;
  return sub_10004E508(v8, a2, 0, (unsigned __int16 *)&v14, 0, 1);
}

uint64_t apfs_keybag_aks_remove_unlock_records(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)size_t v49 = 0;
  uint64_t v6 = *(void *)(a1 + 376);
  BOOL v7 = *(_WORD *)(v6 + 964) == 1 && uuid_is_null((const unsigned __int8 *)(v6 + 1008)) == 0;
  if (!*(void *)(a1 + 3736) || is_sw_crypto(*(void *)(a1 + 392))) {
    return 0;
  }
  uint64_t v9 = AKS_FV_service();
  if (!v9) {
    return 6;
  }
  uint64_t v10 = v9;
  if (!*(void *)(v9 + 64)) {
    return 6;
  }
  uint64_t v11 = _apfs_calloc(1uLL, 0x58uLL);
  if (!v11) {
    return 12;
  }
  uint64_t v12 = v11;
  *(void *)src = 0;
  uint64_t v54 = 0;
  v48[0] = 0;
  v48[1] = 0;
  int v13 = apfs_keybag_iter_alloc(a1, v49);
  long long v14 = *(unint64_t **)v49;
  if (v13 || !apfs_keybag_iter_next(*(unint64_t **)v49, src, v48, (unsigned __int16)a3))
  {
    uint64_t v8 = 0;
    goto LABEL_32;
  }
  BOOL v15 = a3 == 3 && v7;
  do
  {
    bzero(dst, 0x228uLL);
    memset(v47, 0, sizeof(v47));
    if (!v15) {
      goto LABEL_18;
    }
    if ((*(unsigned int (**)(void *, void *, _DWORD *))(v10 + 56))(v47, v48, v12))
    {
      log_err((uint64_t)"%s:%d: failed to get unlock record's aks state, err = 0x%x\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"apfs_keybag_aks_remove_unlock_records");
LABEL_18:
      BOOL v23 = 1;
      goto LABEL_19;
    }
    BOOL v23 = v12[20] != 1;
LABEL_19:
    uuid_copy(dst, src);
    __int16 v51 = a3;
    __int16 v52 = 0;
    uint64_t v24 = sub_10004E508(*(pthread_mutex_t **)(a1 + 3736), a2, 0, (unsigned __int16 *)dst, 0, 0);
    if (v24)
    {
      uint64_t v8 = v24;
      log_err((uint64_t)"%s:%d: failed to delete unlock record in apfs keybag, err = %d\n", v25, v26, v27, v28, v29, v30, v31, (uint64_t)"apfs_keybag_aks_remove_unlock_records");
      goto LABEL_32;
    }
    if (v23
      && (*(unsigned int (**)(void *, uint64_t, void, void, void *, void, void))(v10 + 64))(v47, 11, 0, 0, v48, 0, 0))
    {
      log_err((uint64_t)"%s:%d: failed to remove unlock record's aks state, err = 0x%x\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"apfs_keybag_aks_remove_unlock_records");
    }
  }
  while ((apfs_keybag_iter_next(v14, src, v48, (unsigned __int16)a3) & 1) != 0);
  uint64_t v8 = sub_10004F96C((void *)a1, a2);
  if (v8) {
    log_err((uint64_t)"%s:%d: failed to update nx keybag, err = %d\n", v39, v40, v41, v42, v43, v44, v45, (uint64_t)"apfs_keybag_aks_remove_unlock_records");
  }
LABEL_32:
  if (v14) {
    apfs_keybag_iter_free(a1, (uint64_t)v14);
  }
  _apfs_free(v12, 88);
  return v8;
}

uint64_t apfs_keybag_set_create_update_record(void *a1, uint64_t a2, unsigned __int8 *uu, uint64_t a4, unsigned __int8 *a5, uint64_t a6, int a7, char a8, uint64_t a9)
{
  size_t v273 = 0;
  size_t v274 = 0;
  int v271 = 0;
  size_t v272 = 0;
  uint64_t v269 = 0;
  size_t v270 = 0;
  uint64_t __dst = 0;
  size_t v268 = 0;
  uint64_t v264 = 0;
  uint64_t v265 = 0;
  uint64_t v266 = 0;
  int is_null = uuid_is_null(uu);
  int v18 = uuid_is_null(a5);
  bzero(v279, 0x228uLL);
  uint64_t v261 = 0;
  uint64_t v262 = 0;
  uint64_t v263 = 0;
  if (!a1) {
    sub_1000607CC();
  }
  if (!a2) {
    sub_1000607F8();
  }
  if (a4 && *(void *)(a4 + 8) >= 0x201uLL)
  {
    log_err((uint64_t)"%s:%d: Invalid data1 key length %lu\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"apfs_keybag_set_create_update_record");
    return 22;
  }
  if (a6 && *(void *)(a6 + 8) >= 0x201uLL)
  {
    uint64_t v26 = "%s:%d: Invalid data2 key length %lu\n";
LABEL_9:
    log_err((uint64_t)v26, v19, v20, v21, v22, v23, v24, v25, (uint64_t)"apfs_keybag_set_create_update_record");
    return 22;
  }
  uint64_t v260 = a2;
  uint64_t v28 = 0;
  memset(dst, 0, sizeof(dst));
  BOOL v29 = is_null != 0;
  memset(src, 0, sizeof(src));
  uint64_t v27 = 22;
  if ((a4 != 0) == v29 || (a6 != 0) == (v18 != 0)) {
    goto LABEL_253;
  }
  if ((a7 - 6) < 0xFFFFFFFB)
  {
    uint64_t v28 = 0;
    uint64_t v27 = 22;
    goto LABEL_253;
  }
  if (!a1[141])
  {
    uint64_t v31 = a1[49];
    if (!v31) {
      sub_100060824();
    }
    if (!*(void *)(v31 + 912)) {
      sub_100060850();
    }
    if (!*(void *)(v31 + 376)) {
      sub_10006087C();
    }
    uint64_t v32 = a1[47];
    if (!v32) {
      sub_1000608A8();
    }
    uint64_t v33 = *(unsigned __int16 *)(v32 + 964);
    if (a7 == 2)
    {
      if (v33 == 1) {
        goto LABEL_23;
      }
    }
    else if (*(unsigned __int16 *)(v32 + 964) > 0xFFu)
    {
      if (v33 == 256 || v33 == 704 || v33 == 640) {
        goto LABEL_34;
      }
    }
    else if (v33 <= 0x20)
    {
      if (((1 << v33) & 0x100010110) != 0) {
        goto LABEL_34;
      }
      if (v33 == 1)
      {
LABEL_23:
        uint64_t v34 = a1[486];
        BOOL v30 = v34 != 0;
        if ((*(unsigned char *)(v32 + 264) & 1) == 0)
        {
          if (v34)
          {
            BOOL v30 = 1;
LABEL_41:
            uint64_t v36 = v260;
LABEL_42:
            apfs_keybag_init((uint64_t)a1, v36);
            goto LABEL_43;
          }
LABEL_39:
          BOOL v35 = is_sw_crypto(v31);
          uint64_t v36 = 0;
          BOOL v30 = 0;
          if (!a4 || v35) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
LABEL_37:
        if (!*(void *)(v32 + 976) || v30) {
          goto LABEL_41;
        }
        goto LABEL_39;
      }
    }
    if ((*(unsigned char *)(v32 + 264) & 1) == 0) {
      goto LABEL_39;
    }
    BOOL v30 = 0;
    goto LABEL_37;
  }
  BOOL v30 = 0;
LABEL_43:
  uint64_t v259 = (pthread_mutex_t *)a1[467];
  if (!v259)
  {
    if (a1[141])
    {
      uint64_t v28 = 0;
      uint64_t v27 = 92;
      goto LABEL_253;
    }
    BOOL v39 = is_sw_crypto(a1[49]);
    uint64_t v28 = 0;
    uint64_t v27 = 92;
    if (a4 || v39) {
      goto LABEL_253;
    }
  }
  unsigned int v37 = a7 & 0xFFFFFFFE;
  if ((a7 & 0xFFFFFFFE) == 2 && (a8 & 2) != 0) {
    uint64_t v262 = 4;
  }
  switch(a7)
  {
    case 1:
      if (a4)
      {
        size_t v38 = *(void *)(a4 + 8);
        int v271 = *(void **)a4;
        size_t v272 = v38;
        uuid_copy(dst, uu);
        if (!a6) {
          goto LABEL_69;
        }
      }
      else if (!a6)
      {
        uint64_t v28 = 0;
        uint64_t v27 = 13;
        goto LABEL_253;
      }
      size_t v96 = *(void *)(a6 + 8);
      uint64_t v269 = *(void **)a6;
      size_t v270 = v96;
      uuid_copy(src, a5);
      uint64_t v97 = a1[141];
      uint64_t v28 = 0;
      if (v97) {
        BOOL v66 = *(pthread_mutex_t **)(v97 + 8);
      }
      else {
        BOOL v66 = *(pthread_mutex_t **)(a1[49] + 912);
      }
      BOOL v67 = 1;
      if (a4) {
        goto LABEL_70;
      }
      int v106 = 0;
      uint64_t v27 = 13;
      if (!v66) {
        goto LABEL_252;
      }
      goto LABEL_105;
    case 2:
      uint64_t v86 = (void *)AKS_FV_service();
      int v87 = uuid_is_null(a5);
      uint64_t v27 = 22;
      if (a6 || !v87) {
        return v27;
      }
      if (!is_sw_crypto(a1[49])) {
        goto LABEL_125;
      }
      if (*(_WORD *)(a1[47] + 964) == 1)
      {
        if (!(a4 | a1[486]))
        {
LABEL_88:
          log_err((uint64_t)"%s:%d: can not create kek and vek without a secret\n", v88, v89, v90, v91, v92, v93, v94, (uint64_t)"apfs_keybag_set_create_update_record");
          return 22;
        }
      }
      else if (!a4)
      {
        goto LABEL_88;
      }
LABEL_125:
      if (!v86) {
        goto LABEL_162;
      }
      uint64_t v128 = (unsigned int (*)(uint64_t *, uint64_t, size_t *))v86[4];
      if (!v128 || !v86[2] || !*v86) {
        goto LABEL_162;
      }
      if (v128(&v261, 2, &v274) || !v274)
      {
        log_err((uint64_t)"%s:%d: failed to get wkek len from AKS (%ld): %d\n", v129, v130, v131, v132, v133, v134, v135, (uint64_t)"apfs_keybag_set_create_update_record");
LABEL_162:
        uint64_t v28 = 0;
        uint64_t v27 = 6;
        goto LABEL_253;
      }
      if (((unsigned int (*)(uint64_t *, uint64_t, size_t *))v86[4])(&v261, 1, &v273) || !v273)
      {
        log_err((uint64_t)"%s:%d: failed to get wvek len from AKS (%ld): %d\n", v136, v137, v138, v139, v140, v141, v142, (uint64_t)"apfs_keybag_set_create_update_record");
        goto LABEL_162;
      }
      uint64_t v143 = v86;
      if (is_sw_crypto(a1[49]))
      {
        if (!a4 && v30) {
          goto LABEL_136;
        }
      }
      else if (!a4)
      {
LABEL_136:
        char v144 = 1;
        goto LABEL_137;
      }
      uint64_t v161 = a1[47];
      unsigned int v162 = *(unsigned __int16 *)(v161 + 964);
      if (v162 > 0xFF)
      {
        if (v162 != 256 && v162 != 704 && v162 != 640) {
          goto LABEL_184;
        }
LABEL_34:
        uint64_t v26 = "%s:%d: %s invalid operation (%d) on volume role (0x%x)\n";
        goto LABEL_9;
      }
      if (v162 <= 0x20 && ((1 << v162) & 0x100010110) != 0) {
        goto LABEL_34;
      }
LABEL_184:
      if (!uuid_compare(uu, (const unsigned __int8 *)(v161 + 240)))
      {
        int v190 = *(unsigned __int16 *)(a1[47] + 964);
        uint64_t v27 = 22;
        if (v190 == 1 || v190 == 64) {
          return v27;
        }
      }
      int v271 = _apfs_calloc(1uLL, v274);
      if (!v271) {
        goto LABEL_187;
      }
      char v144 = 0;
      size_t v272 = v274;
LABEL_137:
      uint64_t v269 = _apfs_calloc(1uLL, v273);
      if (!v269) {
        goto LABEL_187;
      }
      size_t v270 = v273;
      if (!is_sw_crypto(a1[49]))
      {
        uint64_t __dst = _apfs_calloc(1uLL, v273);
        if (!__dst) {
          goto LABEL_187;
        }
        size_t v268 = v273;
        uint64_t v163 = nx_keybag_lookup_record(a1[49], (unsigned __int8 *)(a1[47] + 240), 2, (uint64_t)&__dst);
        if (!v163)
        {
          if (!nx_keybag_lookup_record(a1[49], (unsigned __int8 *)(a1[47] + 240), 5, (uint64_t)&__dst))
          {
            uint64_t v214 = sub_100050F64((uint64_t)a1, v260, 0);
            if (v214)
            {
              uint64_t v27 = v214;
              log_err((uint64_t)"%s:%d: failed to fix-up and replace stale-invalid wvek with committed-proposed wvek, err = %d\n", v215, v216, v217, v218, v219, v220, v221, (uint64_t)"apfs_keybag_set_create_update_record");
              goto LABEL_220;
            }
          }
          if (v144) {
            sub_100060AE4();
          }
          int v180 = 0;
          char v181 = 1;
          goto LABEL_198;
        }
        uint64_t v27 = v163;
        if (v163 != 2)
        {
          *(_OWORD *)uuid_t uua = 0u;
          memset(v277, 0, 21);
          uuid_unparse((const unsigned __int8 *)(a1[47] + 240), (char *)uua);
          log_err((uint64_t)"%s:%d: failed to lookup existing wvek for uuid = %s, err = %d\n", v164, v165, v166, v167, v168, v169, v170, (uint64_t)"apfs_keybag_set_create_update_record");
          goto LABEL_220;
        }
      }
      uint64_t v28 = 64;
      uint64_t v264 = _apfs_calloc(1uLL, 0x40uLL);
      if (!v264)
      {
        uint64_t v27 = 12;
        goto LABEL_253;
      }
      uint64_t v265 = 64;
      if (v30)
      {
        if ((v144 & 1) == 0) {
          sub_100060A60();
        }
        if (!*(void *)(a1[486] + 600)) {
          sub_1000609B0();
        }
        if (__dst) {
          sub_100060A34();
        }
        uint64_t __dst = _apfs_calloc(1uLL, v273);
        if (__dst)
        {
          size_t v268 = v273;
          uint64_t v145 = nx_keybag_lookup_record(*(void *)(a1[486] + 392), (unsigned __int8 *)(*(void *)(a1[486] + 376) + 240), 2, (uint64_t)&__dst);
          if (v145)
          {
            uint64_t v27 = v145;
            *(_OWORD *)uuid_t uua = 0u;
            memset(v277, 0, 21);
            uuid_unparse((const unsigned __int8 *)(*(void *)(a1[486] + 376) + 240), (char *)uua);
            log_err((uint64_t)"%s:%d: failed to lookup sibling wvek for uuid = %s, err = %d\n", v146, v147, v148, v149, v150, v151, v152, (uint64_t)"apfs_keybag_set_create_update_record");
LABEL_220:
            uint64_t v28 = 64;
            goto LABEL_253;
          }
          if (!*(void *)(a1[486] + 600)) {
            sub_1000609DC();
          }
          if (!__dst) {
            sub_100060A08();
          }
          uint64_t v198 = ((uint64_t (*)(uint64_t *, void **, uint64_t, void **, void **))v143[10])(&v261, &__dst, a1[47] + 240, &v269, &v264);
          if (v198)
          {
            uint64_t v179 = v198;
            log_err((uint64_t)"%s:%d: failed to generate new sibling vek, err = 0x%x\n", v199, v200, v201, v202, v203, v204, v205, (uint64_t)"apfs_keybag_set_create_update_record");
LABEL_233:
            uint64_t v27 = akserror_to_errno(v179);
            goto LABEL_188;
          }
          goto LABEL_212;
        }
LABEL_187:
        uint64_t v27 = 12;
LABEL_188:
        uint64_t v28 = 64;
        goto LABEL_253;
      }
      if (v144)
      {
        if (is_sw_crypto(a1[49])) {
          sub_100060A8C();
        }
        uint64_t v171 = ((uint64_t (*)(uint64_t *, void, void, uint64_t, void **, void **))*v143)(&v261, 0, 0, a1[47] + 240, &v269, &v264);
        if (!v171)
        {
LABEL_212:
          if (!is_sw_crypto(a1[49]))
          {
            uint64_t v206 = ((uint64_t (*)(uint64_t *, uint64_t, void, void, void, void **, void))v143[8])(&v261, 5, 0, 0, 0, &v269, 0);
            if (v206)
            {
              uint64_t v179 = v206;
              log_err((uint64_t)"%s:%d: failed to commit new sys bound vek, err = 0x%x\n", v207, v208, v209, v210, v211, v212, v213, (uint64_t)"apfs_keybag_set_create_update_record");
              goto LABEL_233;
            }
          }
          int v180 = 1;
          goto LABEL_218;
        }
        uint64_t v179 = v171;
LABEL_232:
        log_err((uint64_t)"%s:%d: failed to generate new vek, err = 0x%x\n", v172, v173, v174, v175, v176, v177, v178, (uint64_t)"apfs_keybag_set_create_update_record");
        goto LABEL_233;
      }
      char v181 = 0;
      int v180 = 1;
LABEL_198:
      uint64_t v182 = sub_10005127C((uint64_t)a1, a9, uu, (uint64_t)&v271);
      if (v182)
      {
        uint64_t v27 = v182;
        if (v182 != 2)
        {
          *(_OWORD *)uuid_t uua = 0u;
          memset(v277, 0, 21);
          uuid_unparse(uu, (char *)uua);
          log_err((uint64_t)"%s:%d: failed to lookup existing wkek for uuid = %s, err = %d\n", v191, v192, v193, v194, v195, v196, v197, (uint64_t)"apfs_keybag_set_create_update_record");
          goto LABEL_220;
        }
        if (uuid_compare(uu, (const unsigned __int8 *)(a1[47] + 240)))
        {
          uint64_t v27 = 2;
          log_err((uint64_t)"%s:%d: failed to find existing wkek, err = %d\n", v183, v184, v185, v186, v187, v188, v189, (uint64_t)"apfs_keybag_set_create_update_record");
          goto LABEL_220;
        }
        uint64_t v231 = is_sw_crypto(a1[49]) ? 2 : 0;
        uint64_t v232 = ((uint64_t (*)(uint64_t *, uint64_t, uint64_t, unsigned __int8 *, void **))v143[2])(&v261, v231, a4, uu, &v271);
        if (v232)
        {
          uint64_t v179 = v232;
          log_err((uint64_t)"%s:%d: failed to generate new kek, err = 0x%x\n", v233, v234, v235, v236, v237, v238, v239, (uint64_t)"apfs_keybag_set_create_update_record");
          goto LABEL_233;
        }
      }
      if ((v181 & 1) == 0)
      {
        uint64_t v240 = ((uint64_t (*)(uint64_t *, uint64_t, void **, uint64_t, void **, void **))*v143)(&v261, a4, &v271, a1[47] + 240, &v269, &v264);
        if (!v240)
        {
          if (!is_sw_crypto(a1[49]))
          {
            uint64_t v241 = ((uint64_t (*)(uint64_t *, uint64_t, void, void, void, void **, void))v143[8])(&v261, 5, 0, 0, 0, &v269, 0);
            if (v241)
            {
              uint64_t v179 = v241;
              log_err((uint64_t)"%s:%d: failed to commit new kek bound vek, err = 0x%x\n", v242, v243, v244, v245, v246, v247, v248, (uint64_t)"apfs_keybag_set_create_update_record");
              goto LABEL_233;
            }
          }
          uuid_copy(dst, uu);
LABEL_218:
          uint64_t nx_dev = apfs_get_nx_dev((uint64_t)a1);
          uint64_t v223 = cst_from_fvkey(nx_dev, (uint64_t)(a1 + 66), (uint64_t)&v264);
          if (v223)
          {
            uint64_t v27 = v223;
            log_err((uint64_t)"%s:%d: failed to store vek into crypto state, err = %d\n", v224, v225, v226, v227, v228, v229, v230, (uint64_t)"apfs_keybag_set_create_update_record");
            goto LABEL_220;
          }
          if (is_sw_crypto(a1[49]))
          {
            cpx_set_is_composite_key(a1[75], 1);
          }
          else if ((cpx_is_sep_wrapped_key() & 1) == 0)
          {
            panic("HW CRYPTO: [create]: CP_RAW_KEY_WRAPPEDKEY is NOT set");
          }
          goto LABEL_250;
        }
        uint64_t v179 = v240;
        goto LABEL_232;
      }
      if (is_sw_crypto(a1[49])) {
        sub_100060AB8();
      }
      uint64_t v278 = 0;
      memset(v277, 0, sizeof(v277));
      *(_OWORD *)uuid_t uua = 0u;
      if (((unsigned int (*)(uint64_t *, void **, unsigned __int8 *))v143[7])(&v261, &__dst, uua)) {
        return 1;
      }
      if ((BYTE4(v277[1]) & 8) == 0) {
        return 13;
      }
      if ((BYTE4(v277[1]) & 4) == 0)
      {
        uint64_t v249 = ((uint64_t (*)(uint64_t *, uint64_t, void, uint64_t, void **, void **, void **))v143[8])(&v261, 3, 0, a4, &v271, &__dst, &v269);
        if (v249)
        {
LABEL_248:
          uint64_t v179 = v249;
          log_err((uint64_t)"%s:%d: can not bind kek to vek, err = 0x%x\n", v250, v251, v252, v253, v254, v255, v256, (uint64_t)"apfs_keybag_set_create_update_record");
          goto LABEL_233;
        }
        memcpy(__dst, v269, v270);
        size_t v268 = v270;
      }
      uint64_t v249 = ((uint64_t (*)(uint64_t *, uint64_t, void, uint64_t, void **, void **, void **))v143[8])(&v261, 2, 0, a4, &v271, &__dst, &v269);
      if (v249) {
        goto LABEL_248;
      }
      uuid_copy(dst, uu);
LABEL_250:
      uuid_copy(src, (const unsigned __int8 *)(a1[47] + 240));
      BOOL v66 = *(pthread_mutex_t **)(a1[49] + 912);
      BOOL v67 = v180 != 0;
      uint64_t v28 = 64;
      if (v144)
      {
        int v106 = 0;
        uint64_t v27 = 0;
        if (!v66) {
          goto LABEL_252;
        }
        goto LABEL_105;
      }
      unsigned int v37 = a7 & 0xFFFFFFFE;
LABEL_70:
      memset(uua, 0, sizeof(uua));
      memset(uu2, 0, sizeof(uu2));
      if (!v259) {
        sub_1000608D4();
      }
      if (!v271) {
        sub_100060900();
      }
      if (!v272) {
        sub_10006092C();
      }
      pthread_mutex_lock(v259);
      uuid_copy(v279, dst);
      if (v37 == 4) {
        __int16 v68 = 4;
      }
      else {
        __int16 v68 = 3;
      }
      __int16 v280 = v68;
      __int16 v69 = v272;
      if (v271) {
        __memcpy_chk();
      }
      __int16 v281 = v69;
      uint64_t v70 = sub_10004E508(v259, v260, 0, (unsigned __int16 *)v279, 0, 0);
      if (v70)
      {
        uint64_t v27 = v70;
        log_err((uint64_t)"%s:%d: failed to add/update unlock record in apfs keybag, err = %d\n", v71, v72, v73, v74, v75, v76, v77, (uint64_t)"apfs_keybag_set_create_update_record");
        goto LABEL_82;
      }
      uint64_t v78 = sub_10004F96C(a1, v260);
      if (v78)
      {
        uint64_t v27 = v78;
        log_err((uint64_t)"%s:%d: failed to apfs update unlock records range in nx keybag, err = %d\n", v79, v80, v81, v82, v83, v84, v85, (uint64_t)"apfs_keybag_set_create_update_record");
        goto LABEL_82;
      }
      uuid_parse("64C0C6EB-0000-11AA-AA11-00306543ECAC", uua);
      uuid_parse("C064EBC6-0000-11AA-AA11-00306543ECAC", uu2);
      BOOL v95 = !uuid_compare(dst, uua) || !uuid_compare(dst, uu2);
      if (!a1[141])
      {
        BOOL v117 = is_sw_crypto(a1[49]);
        if (v37 != 4 && !v95 && !v117)
        {
          uint64_t v118 = AKS_FV_service();
          int v119 = (*(uint64_t (**)(uint64_t *, uint64_t, void, void, void **, void, void))(v118 + 64))(&v261, 22, 0, 0, &v271, 0, 0);
          if (v119)
          {
            int v127 = 2;
            do
            {
              if (!v127) {
                panic("failed to commit updated wkek record, err = 0x%x\n", v119);
              }
              log_err((uint64_t)"%s:%d: failed to commit updated wkek record, err = 0x%x (%d more retries)\n", v120, v121, v122, v123, v124, v125, v126, (uint64_t)"apfs_keybag_set_create_update_record");
              --v127;
              int v119 = (*(uint64_t (**)(uint64_t *, uint64_t, void, void, void **, void, void))(v118 + 64))(&v261, 22, 0, 0, &v271, 0, 0);
            }
            while (v119);
          }
        }
      }
      uint64_t v27 = 0;
      int v106 = 1;
      if (!v66)
      {
LABEL_252:
        if (!v106) {
          goto LABEL_253;
        }
LABEL_82:
        pthread_mutex_unlock(v259);
        goto LABEL_253;
      }
LABEL_105:
      if (!v269) {
        sub_100060958();
      }
      if (!v270) {
        sub_100060984();
      }
      if (a1[141]) {
        char v107 = 1;
      }
      else {
        char v107 = v67;
      }
      if ((v107 & 1) != 0 || ((v106 ^ 1) & 1) != 0 || is_sw_crypto(a1[49]))
      {
        uuid_copy(v279, src);
        __int16 v280 = 2;
        __int16 v108 = v270;
        if (v269) {
          __memcpy_chk();
        }
        __int16 v281 = v108;
        uint64_t v109 = sub_10004E508(v66, v260, 0, (unsigned __int16 *)v279, 0, 1);
      }
      else
      {
        uint64_t v109 = sub_100050F64((uint64_t)a1, v260, &v269);
      }
      uint64_t v27 = v109;
      if (!v109) {
        goto LABEL_252;
      }
      log_err((uint64_t)"%s:%d: failed to add/update wvek record in nx keybag, err = %d\n", v110, v111, v112, v113, v114, v115, v116, (uint64_t)"apfs_keybag_set_create_update_record");
      if (v106) {
        goto LABEL_82;
      }
LABEL_253:
      if (v274 && v271) {
        _apfs_free(v271, v274);
      }
      uint64_t v257 = v273;
      if (v273 && v269)
      {
        _apfs_free(v269, v273);
        uint64_t v257 = v273;
      }
      if (v257 && __dst) {
        _apfs_free(__dst, v257);
      }
      if (v28 && v264) {
        _apfs_free(v264, v28);
      }
      return v27;
    case 3:
      memset(uua, 0, sizeof(uua));
      uint64_t v48 = AKS_FV_service();
      if (!v48) {
        goto LABEL_148;
      }
      uint64_t v49 = v48;
      uint64_t v50 = *(unsigned int (**)(uint64_t *, uint64_t, size_t *))(v48 + 32);
      if (!v50 || !*(void *)(v48 + 24)) {
        goto LABEL_148;
      }
      if (v50(&v261, 2, &v274) || !v274)
      {
        log_err((uint64_t)"%s:%d: %s failed to get wkek len from AKS (%ld): %d\n", v274, v51, v52, v53, v54, v55, v56, (uint64_t)"apfs_keybag_set_create_update_record");
LABEL_148:
        uint64_t v27 = 6;
      }
      else
      {
        int v271 = _apfs_calloc(1uLL, v274);
        if (v271 && (size_t v272 = v274, (*(void *)uua = _apfs_calloc(1uLL, v274)) != 0))
        {
          *(void *)&uua[8] = v274;
          uint64_t v57 = apfs_keybag_lookup_record((uint64_t)a1, uu, 3, (uint64_t)uua);
          if (v57)
          {
            uint64_t v27 = v57;
            _apfs_free(*(void **)uua, v274);
            log_err((uint64_t)"%s:%d: failed to lookup rec to re-wrap, err = %d\n", v58, v59, v60, v61, v62, v63, v64, (uint64_t)"apfs_keybag_set_create_update_record");
          }
          else
          {
            uint64_t v153 = (*(uint64_t (**)(uint64_t *, uint64_t, unsigned __int8 *, unsigned __int8 *, uint64_t, void **))(v49 + 24))(&v261, a4, uua, a5, a6, &v271);
            _apfs_free(*(void **)uua, v274);
            if (!v153)
            {
              uuid_copy(dst, a5);
              BOOL v66 = 0;
              uint64_t v28 = 0;
              BOOL v67 = 1;
              goto LABEL_70;
            }
            log_err((uint64_t)"%s:%d: failed to re-wrap, err = 0x%x\n", v154, v155, v156, v157, v158, v159, v160, (uint64_t)"apfs_keybag_set_create_update_record");
            uint64_t v27 = akserror_to_errno(v153);
          }
        }
        else
        {
          uint64_t v27 = 12;
        }
      }
      uint64_t v28 = 0;
      goto LABEL_253;
    case 4:
      size_t v65 = *(void *)(a4 + 8);
      int v271 = *(void **)a4;
      size_t v272 = v65;
      uuid_copy(dst, uu);
      goto LABEL_69;
    case 5:
      uint64_t v40 = apfs_keybag_lookup_record((uint64_t)a1, a5, 3, 0);
      if (!v40)
      {
        size_t v98 = *(void *)(a6 + 8);
        int v271 = *(void **)a6;
        size_t v272 = v98;
        uuid_copy(dst, a5);
        BOOL v66 = 0;
        uint64_t v28 = 0;
        BOOL v67 = 1;
        goto LABEL_70;
      }
      uint64_t v27 = v40;
      if (v40 == 2)
      {
        uint64_t v27 = 2;
        log_err((uint64_t)"%s:%d: Cannot add a hint, there is no wkek associated to it, err = %d\n", v41, v42, v43, v44, v45, v46, v47, (uint64_t)"apfs_keybag_set_create_update_record");
      }
      else
      {
        *(_OWORD *)uuid_t uua = 0u;
        memset(v277, 0, 21);
        uuid_unparse(a5, (char *)uua);
        log_err((uint64_t)"%s:%d: failed to lookup existing wkek for uuid = %s, err = %d\n", v99, v100, v101, v102, v103, v104, v105, (uint64_t)"apfs_keybag_set_create_update_record");
      }
      uint64_t v28 = 0;
      goto LABEL_253;
    default:
LABEL_69:
      BOOL v66 = 0;
      uint64_t v28 = 0;
      BOOL v67 = 1;
      goto LABEL_70;
  }
}

uint64_t sub_100050F64(uint64_t a1, uint64_t a2, void *a3)
{
  memset(v42, 0, sizeof(v42));
  bzero(dst, 0x228uLL);
  uint64_t v6 = AKS_FV_service();
  if (!v6) {
    return 6;
  }
  uint64_t v7 = v6;
  if (!*(void *)(v6 + 64)) {
    return 6;
  }
  uuid_copy(dst, (const unsigned __int8 *)(*(void *)(a1 + 376) + 240));
  __int16 v44 = 11;
  if (a3)
  {
    uint64_t v8 = a3[1];
    if (*a3) {
      __memcpy_chk();
    }
    unsigned __int16 v45 = v8;
    uint64_t v9 = sub_10004E508(*(pthread_mutex_t **)(*(void *)(a1 + 392) + 912), a2, 0, (unsigned __int16 *)dst, 0, 1);
    int v18 = a3;
    if (v9) {
      goto LABEL_11;
    }
LABEL_15:
    uint64_t v9 = (*(uint64_t (**)(void *, uint64_t, void, void, void, void *, void))(v7 + 64))(v42, 5, 0, 0, 0, v18, 0);
    if (v9)
    {
      int v27 = 2;
      do
      {
        if (!v27) {
          panic("failed to commit proposed wvek record, err = 0x%x\n", v9);
        }
        log_err((uint64_t)"%s:%d: failed to commit proposed wvek record, err = 0x%x (%d more retries)\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"apfs_commit_update_volume_key");
        --v27;
        uint64_t v9 = (*(uint64_t (**)(void *, uint64_t, void, void, void, void *, void))(v7 + 64))(v42, 5, 0, 0, 0, v18, 0);
      }
      while (v9);
    }
    uuid_copy(dst, (const unsigned __int8 *)(*(void *)(a1 + 376) + 240));
    __int16 v44 = 10;
    if (*v18) {
      __memcpy_chk();
    }
    unsigned __int16 v45 = v18[1];
    if (sub_10004E508(*(pthread_mutex_t **)(*(void *)(a1 + 392) + 912), a2, 0, (unsigned __int16 *)dst, 0, 1))
    {
      log_err((uint64_t)"%s:%d: failed to update wvek record in nx keybag, err = %d\n", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"apfs_commit_update_volume_key");
      uint64_t v9 = 0;
    }
    else if (nx_keybag_delete(*(pthread_mutex_t **)(*(void *)(a1 + 392) + 912), a2, (unsigned __int8 *)(*(void *)(a1 + 376) + 240), 0xBu))
    {
      log_err((uint64_t)"%s:%d: failed to clean-up proposed wvek record in nx keybag, err = %d\n", v35, v36, v37, v38, v39, v40, v41, (uint64_t)"apfs_commit_update_volume_key");
    }
    goto LABEL_12;
  }
  unsigned __int16 v45 = 512;
  uint64_t v9 = sub_10004E508(*(pthread_mutex_t **)(*(void *)(a1 + 392) + 912), 0, (unsigned __int16 *)dst, 0, 0, 1);
  if (!v9)
  {
    uint64_t v17 = _apfs_calloc(1uLL, 0x10uLL);
    if (v17)
    {
      int v18 = v17;
      *uint64_t v17 = &v46;
      v17[1] = v45;
      goto LABEL_15;
    }
    uint64_t v9 = 12;
  }
LABEL_11:
  log_err((uint64_t)"%s:%d: failed to add proposed wvek record in nx keybag, err = %d\n", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"apfs_commit_update_volume_key");
  int v18 = a3;
LABEL_12:
  if (v18 != a3) {
    _apfs_free(v18, 16);
  }
  return v9;
}

uint64_t sub_10005127C(uint64_t a1, uint64_t a2, unsigned __int8 *uu, uint64_t a4)
{
  if (a2)
  {
    if (**(unsigned char **)(a2 + 40))
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 32);
      while (1)
      {
        uint64_t result = apfs_keybag_lookup_record(*(void *)(v8 + 8 * v7), uu, 3, a4);
        if (result != 2) {
          break;
        }
        if (++v7 >= (unint64_t)**(unsigned __int8 **)(a2 + 40)) {
          return 2;
        }
      }
    }
    else
    {
      return 2;
    }
  }
  else
  {
    return apfs_keybag_lookup_record(a1, uu, 3, a4);
  }
  return result;
}

uint64_t apfs_vek_remove_aks_state(uint64_t a1, uint64_t a2)
{
  memset(v15, 0, sizeof(v15));
  if ((*(unsigned char *)(*(void *)(a1 + 376) + 264) & 1) != 0 || is_sw_crypto(*(void *)(a1 + 392))) {
    return 22;
  }
  uint64_t v4 = AKS_FV_service();
  if (!v4) {
    return 6;
  }
  uint64_t v5 = *(uint64_t (**)(void *, uint64_t, void, void, void, uint64_t, void))(v4 + 64);
  if (!v5) {
    return 6;
  }
  uint64_t v6 = v5(v15, 6, 0, 0, 0, a2, 0);
  if (v6)
  {
    uint64_t v14 = v6;
    log_err((uint64_t)"%s:%d: failed to remove vek state, error = 0x%x\n", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"apfs_vek_remove_aks_state");
    return akserror_to_errno(v14);
  }
  else
  {
    log_debug((uint64_t)"%s:%d: removed vek state\n", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"apfs_vek_remove_aks_state");
    return 0;
  }
}

uint64_t apfs_keybag_purge(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    sub_100060B10();
  }
  if (!a2) {
    sub_100060B3C();
  }
  if (!*(void *)(a1 + 376)) {
    sub_100060B68();
  }
  apfs_keybag_init(a1, 0);
  if (!*(void *)(a1 + 3736)) {
    return 2;
  }
  if (!is_sw_crypto(*(void *)(a1 + 392)))
  {
    if (apfs_keybag_aks_remove_unlock_records(a1, a2, 3)) {
      log_err((uint64_t)"%s:%d: failed to aks remove unlock records, err = %d\n", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"apfs_keybag_purge");
    }
    if (apfs_keybag_aks_remove_unlock_records(a1, a2, 6)) {
      log_err((uint64_t)"%s:%d: failed to aks remove marked unlock records, err = %d\n", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"apfs_keybag_purge");
    }
  }
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 3736));
  uint64_t v18 = sub_10004E508(*(pthread_mutex_t **)(a1 + 3736), a2, 0, 0, 3, 0);
  if (v18)
  {
    uint64_t v26 = v18;
    log_err((uint64_t)"%s:%d: failed to wipe unlock records in apfs keybag, err = %d\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"apfs_keybag_purge");
  }
  else
  {
    uint64_t v42 = 0;
    *(_OWORD *)uuid_t dst = 0u;
    long long v41 = 0u;
    uint64_t v27 = *(void *)(a1 + 1128);
    if (v27)
    {
      uint64_t v28 = (const unsigned __int8 *)(v27 + 32);
      uint64_t v29 = *(pthread_mutex_t **)(v27 + 8);
    }
    else
    {
      uint64_t v30 = *(void *)(a1 + 376);
      if (!v30) {
        sub_100060B94();
      }
      uint64_t v31 = *(void *)(a1 + 392);
      if (!v31) {
        sub_100060BC0();
      }
      uint64_t v29 = *(pthread_mutex_t **)(v31 + 912);
      if (!v29) {
        sub_100060BEC();
      }
      uint64_t v28 = (const unsigned __int8 *)(v30 + 240);
    }
    uuid_copy(dst, v28);
    LODWORD(v41) = 3;
    uint64_t v26 = sub_10004E508(v29, a2, 0, (unsigned __int16 *)dst, 0, 1);
    if (v26) {
      log_err((uint64_t)"%s:%d: failed to destroy apfs unlock records range in nx keybag, err = %d\n", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"apfs_keybag_purge");
    }
    else {
      *(_OWORD *)(a1 + 3744) = 0u;
    }
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 3736));
  return v26;
}

uint64_t apfs_remove_volume_key(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 392);
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  memset(v26, 0, sizeof(v26));
  BOOL v5 = is_sw_crypto(v4);
  if (!v5)
  {
    uint64_t v24 = v26;
    uint64_t v25 = 512;
    uint64_t v6 = nx_keybag_lookup_record(*(void *)(a1 + 392), (unsigned __int8 *)(*(void *)(a1 + 376) + 240), 2, (uint64_t)&v24);
    if ((v6 & 0xFFFFFFFD) != 0)
    {
      uint64_t v14 = v6;
      log_err((uint64_t)"%s:%d: %s failed to get volume key, error = %d, tag %d\n", v7, v8, v9, v10, v11, v12, v13, (uint64_t)"apfs_remove_volume_key");
      return v14;
    }
    if (!v24 || !v25) {
      sub_100060C18();
    }
  }
  uint64_t v15 = nx_keybag_delete(*(pthread_mutex_t **)(v4 + 912), a2, (unsigned __int8 *)(*(void *)(a1 + 376) + 240), 2u);
  if ((v15 & 0xFFFFFFFD) != 0)
  {
    uint64_t v14 = v15;
    log_err((uint64_t)"%s:%d: %s failed to delete volume key, error = %d, tag %d\n", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"apfs_remove_volume_key");
  }
  else
  {
    if (!v5) {
      apfs_vek_remove_aks_state(a1, (uint64_t)&v24);
    }
    return 0;
  }
  return v14;
}

uint64_t sub_1000517A8(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (const unsigned __int8 *)(a1 + 64);
  uuid_copy(*(unsigned __int8 **)a2, (const unsigned __int8 *)(a1 + 64));
  uuid_copy((unsigned __int8 *)(*(void *)a2 + 16), v3);
  *(void *)(a2 + 8) = 32;
  return 0;
}

uint64_t sub_1000517F8()
{
  return 0;
}

uint64_t sub_100051800(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 96);
  unint64_t v3 = *(unsigned int *)(v2 + 36) + 32;
  unint64_t v4 = v3 % dev_block_size(*(void *)(a1 + 48));
  uint64_t v5 = *(unsigned int *)(v2 + 36);
  unsigned int v6 = dev_block_size(*(void *)(a1 + 48));
  if (v4) {
    unint64_t v7 = (v5 + 32) / (unint64_t)v6 + 1;
  }
  else {
    unint64_t v7 = (v5 + 32) / (unint64_t)v6;
  }
  unint64_t v16 = 0;
  uint64_t v8 = *(void **)(a1 + 64);
  if (v8)
  {
    if (!spaceman_alloc(v8, 8, v7, *(void *)(a1 + 72), &v16, 0))
    {
      uint64_t v9 = *(unint64_t **)(a1 + 88);
      uint64_t v10 = v9[1];
      if (v10)
      {
        if (*v9)
        {
          spaceman_free(*(void **)(a1 + 64), 0, *v9, v10, *(void *)(a1 + 72));
          uint64_t v9 = *(unint64_t **)(a1 + 88);
        }
      }
      *uint64_t v9 = v16;
      *(void *)(*(void *)(a1 + 88) + 8) = v7;
      goto LABEL_12;
    }
    return 28;
  }
  if (*(void *)(*(void *)(a1 + 88) + 8) < v7) {
    return 28;
  }
LABEL_12:
  *(void *)(v2 + 8) = 0;
  *(void *)(v2 + 16) = *(void *)(a1 + 72);
  *(_DWORD *)(v2 + 24) = *(_DWORD *)(a1 + 80);
  *(_DWORD *)(v2 + 28) = 0;
  uint64_t v12 = *(void *)(*(void *)(a1 + 88) + 8);
  unsigned int v13 = dev_block_size(*(void *)(a1 + 48));
  fletcher64_set_cksum((unint64_t *)v2, (uint32x4_t *)(v2 + 8), v12 * v13 - 8, 0, v14, v15);
  *(void *)(*(void *)(*(void *)(a1 + 56) + 72) + 12) = **(void **)(a1 + 88);
  return dev_write_data(*(void **)(a1 + 48), **(void **)(a1 + 88));
}

uint64_t sub_100051954(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 88);
  if (v1[1] && *v1)
  {
    unsigned int v3 = dev_block_size(*(void *)(a1 + 48));
    unint64_t v4 = _apfs_calloc(1uLL, v3);
    if (v4)
    {
      uint64_t v5 = v4;
      unsigned int v6 = *(void **)(a1 + 88);
      if (v6[1])
      {
        unint64_t v7 = 0;
        do
        {
          dev_write_data(*(void **)(a1 + 48), v7 + *v6);
          ++v7;
          unsigned int v6 = *(void **)(a1 + 88);
        }
        while (v7 < v6[1]);
      }
      unsigned int v8 = dev_block_size(*(void *)(a1 + 48));
      _apfs_free(v5, v8);
      uint64_t v9 = *(void **)(a1 + 64);
      if (!v9)
      {
        dev_barrier(*(void *)(a1 + 48), 1);
        return 0;
      }
    }
    else
    {
      uint64_t v9 = *(void **)(a1 + 64);
      if (!v9) {
        return 0;
      }
    }
    spaceman_free(v9, 0, **(void **)(a1 + 88), *(void *)(*(void *)(a1 + 88) + 8), *(void *)(a1 + 72));
    **(void **)(a1 + 88) = 0;
    *(void *)(*(void *)(a1 + 88) + 8) = 0;
  }
  return 0;
}

_WORD *cpx_alloc(uint64_t a1)
{
  __int16 v1 = a1;
  uint64_t result = _apfs_calloc(1uLL, a1 + 24);
  if (result) {
    result[4] = v1;
  }
  return result;
}

uint64_t userfs_data_cryptor(uint64_t a1, uint64_t a2, uint64_t a3, int64_t a4, uint64_t a5, unsigned int a6, int a7)
{
  uint64_t v7 = 22;
  if (!a2) {
    return v7;
  }
  if (!a3) {
    return v7;
  }
  int64_t v9 = a4;
  if (a4 < 0) {
    return v7;
  }
  if (!a4) {
    return 0;
  }
  if (!a5) {
    panic("Can't read/write encrypted data to/from block 0!");
  }
  if (!a1 || !*(void *)(a1 + 72)) {
    return 13;
  }
  int8x16_t v15 = &v47;
  __chkstk_darwin();
  uint64_t v17 = (unint64_t *)((char *)&v47 - v16);
  bzero((char *)&v47 - v16, v18);
  timespec __rqtp = (timespec)xmmword_10007EC40;
  pthread_mutex_lock(&stru_100084A40);
  int v19 = dword_100084728;
  if (!dword_100084728)
  {
    uint64_t v48 = v17;
    uint64_t v49 = &v47;
    int v20 = 200;
    int v21 = 200;
    while (1)
    {
      pthread_mutex_unlock(&stru_100084A40);
      nanosleep(&__rqtp, 0);
      if (!--v20)
      {
        if (__rqtp.tv_nsec < 3126) {
          return 60;
        }
        __rqtp.tv_nsec *= 4;
        v21 >>= 2;
        int v20 = v21;
      }
      pthread_mutex_lock(&stru_100084A40);
      int v19 = dword_100084728;
      if (dword_100084728) {
        BOOL v22 = 1;
      }
      else {
        BOOL v22 = v20 == 0;
      }
      if (v22)
      {
        uint64_t v17 = v48;
        int8x16_t v15 = v49;
        break;
      }
    }
  }
  dword_100084728 = v19 - 1;
  pthread_mutex_unlock(&stru_100084A40);
  if (a2 != a3)
  {
    uint64_t v23 = 0;
    goto LABEL_26;
  }
  uint64_t v23 = _apfs_malloc(0x200uLL);
  if (v23)
  {
LABEL_26:
    CCCryptorRef v50 = 0;
    uint64_t v24 = *(void *)(a1 + 72);
    if (CCCryptorCreateWithMode(a7 ^ 1, 8u, 0, 0, 0, (const void *)(v24 + 20), (unint64_t)*(unsigned __int16 *)(v24 + 10) >> 1, (const void *)(v24 + 20 + ((unint64_t)*(unsigned __int16 *)(v24 + 10) >> 1)), (unint64_t)*(unsigned __int16 *)(v24 + 10) >> 1, 0, 0, &v50))
    {
      log_err((uint64_t)"%s:%d: CCCryptorCreateWithMode failed (E%d)\n", v25, v26, v27, v28, v29, v30, v31, (uint64_t)"userfs_data_cryptor");
      uint64_t v7 = 13;
    }
    else
    {
      uint64_t v49 = v15;
      uint64_t v32 = *(void *)(a1 + 72);
      bzero(v17, *(unsigned __int16 *)(v32 + 10));
      if (v9 >= 512)
      {
        uint64_t v40 = 0;
        uint64_t v41 = *(void *)(v32 + 12);
        if (v41) {
          uint64_t v42 = v41 * a6;
        }
        else {
          uint64_t v42 = a5;
        }
        uint64_t v43 = v9;
        while (1)
        {
          *uint64_t v17 = (unint64_t)(v42 + v40) >> 9;
          if (a2 == a3) {
            memcpy(v23, (const void *)(a2 + v40), 0x200uLL);
          }
          else {
            uint64_t v23 = (void *)(a2 + v40);
          }
          if (a7 ? CCCryptorEncryptDataBlock() : CCCryptorDecryptDataBlock()) {
            break;
          }
          v40 += 512;
          int64_t v9 = v43 - 512;
          BOOL v45 = v43 <= 1023;
          v43 -= 512;
          if (v45) {
            goto LABEL_43;
          }
        }
        log_err((uint64_t)"%s:%d: %s failed (E%d)\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"userfs_data_cryptor");
        uint64_t v7 = 5;
      }
      else
      {
        uint64_t v40 = 0;
LABEL_43:
        if (v9)
        {
          log_debug((uint64_t)"%s:%d: Zero'ing excess data to %s: paddr %lld, completed %lld, remaining %zu\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"userfs_data_cryptor");
          bzero((void *)(a3 + v40), v9);
        }
        uint64_t v7 = 0;
      }
      CCCryptorRelease(v50);
    }
    if (a2 != a3) {
      goto LABEL_52;
    }
    goto LABEL_51;
  }
  uint64_t v7 = 12;
LABEL_51:
  _apfs_free(v23, 512);
LABEL_52:
  pthread_mutex_lock(&stru_100084A40);
  if (dword_100084728 >= 4) {
    sub_100060C44();
  }
  ++dword_100084728;
  pthread_mutex_unlock(&stru_100084A40);
  return v7;
}

uint64_t AKS_FV_service()
{
  uint64_t v0 = qword_100084A80;
  if (!qword_100084A80 && (sub_100059980(&qword_100084A80) || (uint64_t v0 = qword_100084A80) == 0))
  {
    log_err((uint64_t)"%s:%d: lib_get_file_vault_services failed (E%d)\n", v1, v2, v3, v4, v5, v6, v7, (uint64_t)"AKS_FV_service");
    return 0;
  }
  return v0;
}

uint64_t cpx_set_use_offset_for_iv(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 4;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 4) = *(_DWORD *)(result + 4) & 0xFFFFFFFB | v2;
  return result;
}

uint64_t cpx_set_is_sep_wrapped_key(uint64_t result, int a2)
{
  *(_DWORD *)(result + 4) = *(_DWORD *)(result + 4) & 0xFFFFFFFE | a2;
  return result;
}

uint64_t cpx_is_sep_wrapped_key()
{
  return 0;
}

uint64_t cpx_set_is_composite_key(uint64_t result, int a2)
{
  if (a2) {
    int v2 = 32;
  }
  else {
    int v2 = 0;
  }
  *(_DWORD *)(result + 4) = *(_DWORD *)(result + 4) & 0xFFFFFFDF | v2;
  return result;
}

uint64_t cpx_key(uint64_t a1)
{
  return a1 + 20;
}

void cpx_free(unsigned __int16 *a1)
{
  size_t v2 = a1[4];
  bzero(a1 + 10, v2);

  _apfs_free(a1, v2 + 24);
}

uint64_t cpx_set_key_len(uint64_t result, unsigned int a2)
{
  unsigned int v2 = *(unsigned __int16 *)(result + 8);
  if (v2 >= a2) {
    LOWORD(v2) = a2;
  }
  *(_WORD *)(result + 10) = v2;
  return result;
}

uint64_t cpx_setcpoff(uint64_t result, uint64_t a2)
{
  *(void *)(result + 12) = a2;
  return result;
}

uint64_t io_get_device_block_size(int a1)
{
  unsigned int v12 = 0;
  memset(&v11, 0, sizeof(v11));
  bzero(&v13, 0x878uLL);
  if (!ioctl(a1, 0x40046418uLL, &v12)) {
    return v12;
  }
  if (!fstatfs(a1, &v13)) {
    return v13.f_bsize;
  }
  if (!fstat(a1, &v11)) {
    return v11.st_blksize;
  }
  unsigned int v2 = __error();
  strerror(*v2);
  log_err((uint64_t)"%s:%d: can't get the device block size (%s). assuming 512\n", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"io_get_device_block_size");
  return 512;
}

uint64_t dev_block_size(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 72))();
}

uint64_t dev_block_count(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    uint64_t v2 = dev_block_count();
  }
  else {
    uint64_t v2 = 0;
  }
  return (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 8))(a1) + v2;
}

uint64_t dev_barrier(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 80);
  if (v4) {
    unsigned int v5 = dev_barrier(v4, a2);
  }
  else {
    unsigned int v5 = 0;
  }
  LODWORD(result) = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)(a1 + 72) + 80))(a1, a2);
  if (result) {
    return result;
  }
  else {
    return v5;
  }
}

uint64_t dev_unmap(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 88))();
      }
    }
  }
  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 88))();
}

uint64_t dev_unmap_flush(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    unsigned int v2 = dev_unmap_flush();
  }
  else {
    unsigned int v2 = 0;
  }
  LODWORD(result) = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 104))(a1);
  if (result) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t dev_close(uint64_t a1)
{
  if (*(void *)(a1 + 80)) {
    unsigned int v2 = dev_close();
  }
  else {
    unsigned int v2 = 0;
  }
  LODWORD(result) = (*(uint64_t (**)(uint64_t))(*(void *)(a1 + 72) + 112))(a1);
  if (result) {
    return result;
  }
  else {
    return v2;
  }
}

uint64_t dev_real_block_size(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 120))();
}

uint64_t dev_set_block_size(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 128))();
}

uint64_t dev_is_writable(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 136))();
}

uint64_t dev_is_external(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 144))();
}

BOOL dev_is_solidstate(uint64_t a1)
{
  return *(_DWORD *)(a1 + 116) != 0;
}

uint64_t dev_crypto_type(uint64_t result)
{
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)(result + 72) + 152))();
  }
  return result;
}

uint64_t dev_read(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24))();
      }
    }
  }
  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24))();
}

uint64_t dev_read_data(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24))();
      }
    }
  }
  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 24))();
}

uint64_t dev_read_async(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v7 + 88);
      if ((v10 & a2) == 0) {
        break;
      }
      a2 &= ~v10;
      uint64_t v8 = *(void *)(v9 + 80);
      uint64_t v7 = v9;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }
  uint64_t v9 = v7;
LABEL_6:
  uint64_t v11 = *(void *)(v9 + 72);
  unsigned int v12 = *(uint64_t (**)(void))(v11 + 32);
  if (v12)
  {
    return v12();
  }
  else
  {
    uint64_t v14 = (*(uint64_t (**)(void))(v11 + 24))();
    uint64_t v15 = v14;
    uint64_t v16 = *(void (**)(uint64_t))a6;
    if (*(void *)a6)
    {
      *(_DWORD *)(a6 + 96) = v14;
      v16(a6);
    }
    return v15;
  }
}

uint64_t dev_read_extended(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, int a9)
{
  uint64_t v9 = a1;
  uint64_t v10 = *(void *)(a1 + 80);
  if (v10)
  {
    while (1)
    {
      uint64_t v11 = v10;
      uint64_t v12 = *(void *)(v9 + 88);
      if ((v12 & a2) == 0) {
        break;
      }
      a2 &= ~v12;
      uint64_t v10 = *(void *)(v11 + 80);
      uint64_t v9 = v11;
      if (!v10)
      {
        if (!a9) {
          goto LABEL_8;
        }
        goto LABEL_5;
      }
    }
  }
  uint64_t v11 = v9;
  if (a9)
  {
LABEL_5:
    statfs v13 = *(uint64_t (**)(void))(*(void *)(v11 + 72) + 40);
    if (v13) {
      return v13();
    }
    else {
      return 45;
    }
  }
  else
  {
LABEL_8:
    if (a6) {
      return dev_read_async(v11, a2, a3, a4, a5, a7);
    }
    else {
      return (*(uint64_t (**)(void))(*(void *)(v11 + 72) + 24))();
    }
  }
}

uint64_t dev_read_finish(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 48))();
}

uint64_t dev_read_poll(uint64_t a1)
{
  uint64_t v1 = *(uint64_t (**)(void))(*(void *)(a1 + 72) + 56);
  if (v1) {
    return v1();
  }
  else {
    return 45;
  }
}

uint64_t dev_write(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v3 = *(void *)(a1 + 80);
  if (v3)
  {
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v5 = *(void *)(v2 + 88);
      if ((v5 & a2) == 0) {
        break;
      }
      a2 &= ~v5;
      uint64_t v3 = *(void *)(v4 + 80);
      uint64_t v2 = v4;
      if (!v3) {
        return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 64))();
      }
    }
  }
  uint64_t v4 = v2;
  return (*(uint64_t (**)(void))(*(void *)(v4 + 72) + 64))();
}

uint64_t dev_write_extended(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7 = a1;
  uint64_t v8 = *(void *)(a1 + 80);
  if (v8)
  {
    while (1)
    {
      uint64_t v9 = v8;
      uint64_t v10 = *(void *)(v7 + 88);
      if ((v10 & a2) == 0) {
        break;
      }
      a2 &= ~v10;
      uint64_t v8 = *(void *)(v9 + 80);
      uint64_t v7 = v9;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }
  uint64_t v9 = v7;
LABEL_6:
  uint64_t v11 = *(void *)(v9 + 72);
  if (!a7) {
    return (*(uint64_t (**)(void))(v11 + 64))();
  }
  uint64_t v12 = *(uint64_t (**)(void))(v11 + 72);
  if (v12) {
    return v12();
  }
  else {
    return 45;
  }
}

uint64_t dev_write_data(void *a1, uint64_t a2)
{
  if (a2)
  {
    while (a1[10])
    {
      uint64_t v2 = a1[11];
      if ((v2 & a2) == 0) {
        break;
      }
      a1 = (void *)a1[10];
      a2 &= ~v2;
      if (!a2) {
        goto LABEL_5;
      }
    }
    uint64_t v11 = *(uint64_t (**)(void))(a1[9] + 64);
    return v11();
  }
  else
  {
LABEL_5:
    BOOL is_panic_on_corruption_enabled = nx_is_panic_on_corruption_enabled(0);
    log_corrupt(is_panic_on_corruption_enabled, (uint64_t)"%s:%d: data write (%zu blocks) over superblock!\n", v4, v5, v6, v7, v8, v9, (uint64_t)"dev_write_data");
    return 5;
  }
}

uint64_t dev_features(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 72) + 16))();
}

uint64_t fd_dev_read_poll(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    sub_100060C70();
  }
  uint64_t result = aio_error((const aiocb *)(a2 + 8));
  if (result == -1) {
    return *__error();
  }
  return result;
}

uint64_t sub_100052618(uint64_t a1)
{
  return *(unsigned int *)(a1 + 100);
}

uint64_t sub_100052620(uint64_t a1)
{
  return *(void *)(a1 + 128);
}

uint64_t sub_100052628(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  if (a2) {
    *a2 = a1[26];
  }
  if (a3) {
    *a3 = a1[27];
  }
  if (a4) {
    *a4 = a1[28];
  }
  if (a5) {
    *a5 = a1[29];
  }
  return 0;
}

uint64_t sub_100052668(int *a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  if ((a9 & 0xFFFFFFFA) != 0)
  {
    uint64_t v9 = 45;
LABEL_9:
    log_err((uint64_t)"%s:%d: failed to read blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n", a2, a3, (uint64_t)a4, a5, a9, a7, a8, (uint64_t)"fd_dev_read_extended");
    return v9;
  }
  if (((a9 >> 2) ^ 1) != (a8 == 0))
  {
    uint64_t v9 = 22;
    goto LABEL_9;
  }
  if (a6)
  {
    return sub_100053484(a1, a2, a3, (uint64_t)a4, a5, a9, a7, a8);
  }
  else
  {
    return sub_1000531B8(a1, a2, a3, a4, a5, a9, a7, a8);
  }
}

uint64_t sub_100052738(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    sub_100060C9C();
  }
  uint64_t v4 = (aiocb *)(a2 + 8);
  aiocblist = (aiocb *)(a2 + 8);
  if (aio_suspend((const aiocb *const *)&aiocblist, 1, 0) || (unint64_t v8 = aio_return(v4), v8 == -1))
  {
    uint64_t v5 = *__error();
  }
  else
  {
    int64_t v9 = v8;
    if (v8 >= *(void *)(a2 + 32)) {
      uint64_t v5 = 0;
    }
    else {
      uint64_t v5 = 5;
    }
    uint64_t v10 = *(void *)(a2 + 88);
    if (v10) {
      userfs_data_cryptor(v10, *(void *)(a2 + 24), *(void *)(a2 + 24), v9, *(void *)(a2 + 16), *(_DWORD *)(a1 + 100), 0);
    }
  }
  uint64_t v6 = *(void (**)(uint64_t))a2;
  if (*(void *)a2)
  {
    *(_DWORD *)(a2 + 96) = v5;
    v6(a2);
  }
  return v5;
}

uint64_t sub_1000527F8(uint64_t a1, unint64_t a2, unint64_t a3, char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a7 & 0xFFFFFFFA) != 0)
  {
    uint64_t v8 = 45;
LABEL_8:
    log_err((uint64_t)"%s:%d: failed to write blknum 0x%llx size %zu flags 0x%x error %d dev_name = %s\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (uint64_t)"fd_dev_write_extended");
    return v8;
  }
  if (((a7 >> 2) ^ 1) != (a6 == 0))
  {
    uint64_t v8 = 22;
    goto LABEL_8;
  }

  return sub_100053588(a1, a2, a3, a4, a5, a7, a7, a8);
}

uint64_t sub_1000528A0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10 = *(void **)(a1 + 24);
  if (v10)
  {
    unint64_t v11 = *(unsigned int *)(a1 + 36);
    if (v11)
    {
      uint64_t result = sub_1000533AC(a1, *(void *)(a1 + 40), v11, v10, *(void *)(a1 + 48), a6, a7, a8);
      if (result) {
        return result;
      }
      *(_DWORD *)(a1 + 36) = 0;
    }
  }
  fsync(*(_DWORD *)a1);
  int v13 = *(_DWORD *)(a1 + 4);
  if ((v13 & 0x80000000) == 0) {
    fsync(v13);
  }
  if (!a2 && (*(unsigned char *)(a1 + 104) & 2) != 0)
  {
    long long v16 = xmmword_10007EC50;
    uint64_t v17 = 2;
    int v15 = ioctl(*(_DWORD *)a1, 0x80186416uLL, &v16);
  }
  else
  {
    int v14 = *(_DWORD *)a1;
    if ((*(_WORD *)(a1 + 64) & 0xF000) == 0x8000) {
      int v15 = fcntl(v14, 51, 0);
    }
    else {
      int v15 = ioctl(v14, 0x20006416uLL, 0);
    }
  }
  if (v15 == -1) {
    return *__error();
  }
  else {
    return 0;
  }
}

uint64_t sub_10005298C()
{
  return 0;
}

uint64_t sub_100052994()
{
  return 0;
}

uint64_t sub_10005299C(uint64_t a1)
{
  size_t v5 = strlen((const char *)(a1 + 208));
  uint64_t v6 = *(void **)(a1 + 24);
  if (!v6)
  {
    uint64_t v15 = 0;
    goto LABEL_10;
  }
  unint64_t v7 = *(unsigned int *)(a1 + 36);
  if (!v7)
  {
    uint64_t v15 = 0;
LABEL_9:
    _apfs_free(v6, (*(_DWORD *)(a1 + 100) * *(_DWORD *)(a1 + 32)));
    *(void *)(a1 + 24) = 0;
    goto LABEL_10;
  }
  uint64_t v15 = sub_1000533AC(a1, *(void *)(a1 + 40), v7, v6, *(void *)(a1 + 48), v2, v3, v4);
  if (v15) {
    log_err((uint64_t)"%s:%d: Hit an error flushing the cache, %d dev_name = %s\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"fd_dev_close");
  }
  *(_DWORD *)(a1 + 36) = 0;
  uint64_t v6 = *(void **)(a1 + 24);
  if (v6) {
    goto LABEL_9;
  }
LABEL_10:
  _apfs_free((void *)a1, v5 + 216);
  return v15;
}

uint64_t sub_100052A64(uint64_t a1)
{
  return *(unsigned int *)(a1 + 96);
}

uint64_t sub_100052A6C(uint64_t a1, unsigned int a2)
{
  unint64_t v2 = *(void *)(a1 + 128) * (unint64_t)*(unsigned int *)(a1 + 100) / a2;
  *(_DWORD *)(a1 + 100) = a2;
  *(void *)(a1 + 128) = v2;
  return 0;
}

BOOL sub_100052A90(uint64_t a1)
{
  return *(_DWORD *)(a1 + 108) != 0;
}

BOOL sub_100052AA0(uint64_t a1)
{
  return *(_DWORD *)(a1 + 112) != 0;
}

uint64_t sub_100052AB0(uint64_t a1)
{
  return *(unsigned int *)(a1 + 120);
}

uint64_t sub_100052AB8(uint64_t a1)
{
  dev_t v28 = 0;
  int v27 = 0;
  uint64_t v26 = 0;
  memset(&v25, 0, sizeof(v25));
  if (fstat(*(_DWORD *)a1, &v25))
  {
    uint64_t v2 = *__error();
    log_err((uint64_t)"%s:%d: Couldn't fstat dev_fd (%d), err %d dev_name = %s\n", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"dev_init_common");
  }
  else
  {
    *(void *)(a1 + 72) = apfs_userspace_io;
    device_block_uint64_t size = io_get_device_block_size(*(_DWORD *)a1);
    *(_DWORD *)(a1 + 96) = device_block_size;
    *(_DWORD *)(a1 + 100) = device_block_size;
    int v11 = *(_DWORD *)a1;
    off_t v30 = 0;
    memset(&v29, 0, sizeof(v29));
    if (ioctl(v11, 0x40086419uLL, &v30))
    {
      if (fstat(v11, &v29))
      {
        uint64_t v12 = __error();
        strerror(*v12);
        log_err((uint64_t)"%s:%d: can't get block count (%s)\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"io_get_num_device_blocks");
        off_t v20 = 0;
      }
      else
      {
        st_uint64_t size = v29.st_size;
        off_t v20 = st_size / (int)io_get_device_block_size(v11);
      }
    }
    else
    {
      off_t v20 = v30;
    }
    *(void *)(a1 + 128) = v20;
    io_get_device_features(*(_DWORD *)a1, &v28, &v27, (int *)&v26 + 1, (dev_t *)&v26);
    uint64_t v2 = 0;
    int v22 = v27;
    *(_DWORD *)(a1 + 104) = v28;
    *(_DWORD *)(a1 + 108) = v22;
    int v23 = v26;
    *(_DWORD *)(a1 + 112) = HIDWORD(v26);
    *(_DWORD *)(a1 + 116) = v23;
    *(_WORD *)(a1 + 64) = v25.st_mode;
    *(_DWORD *)(a1 + 120) = 0;
  }
  return v2;
}

uint64_t dev_init(char *a1, int a2, int **a3)
{
  if (!strncmp(a1, "/dev/", 5uLL)) {
    uint64_t v6 = 5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = &a1[v6];
  size_t v8 = strlen(&a1[v6]);
  *a3 = 0;
  uint64_t v9 = (int *)_apfs_calloc(1uLL, v8 + 216);
  if (v9)
  {
    uint64_t v10 = v9;
    memset(&v57, 0, sizeof(v57));
    v9[17] = 0;
    if (stat(a1, &v57) || (v57.st_mode & 0xF000) != 0x4000)
    {
      unint64_t v13 = device_container_path(a1, 0);
      if (v13)
      {
        uint64_t v14 = (char *)v13;
        unsigned int v15 = a2 & 0xFFFFFFCF | 0x10;
        void v10[2] = -1;
        int v16 = open(a1, v15);
        v10[1] = v16;
        if (v16 < 0)
        {
          uint64_t v37 = __error();
          uint64_t v12 = *v37;
          strerror(*v37);
          log_err((uint64_t)"%s:%d: failed to open volume device %s: %s\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"dev_init");
        }
        else
        {
          int v17 = open(v14, v15);
          int *v10 = v17;
          if ((v17 & 0x80000000) == 0)
          {
LABEL_30:
            uint64_t v47 = sub_100052AB8((uint64_t)v10);
            if (v47)
            {
              uint64_t v12 = v47;
              free(v14);
LABEL_38:
              _apfs_free(v10, v8 + 216);
              return v12;
            }
            strlcpy((char *)v10 + 208, v7, v8 + 1);
            free(v14);
LABEL_39:
            uint64_t v12 = 0;
            *a3 = v10;
            return v12;
          }
          uint64_t v18 = __error();
          uint64_t v12 = *v18;
          strerror(*v18);
          log_err((uint64_t)"%s:%d: failed to open container device %s: %s\n", v19, v20, v21, v22, v23, v24, v25, (uint64_t)"dev_init");
          close(v10[1]);
        }
      }
      else
      {
        *(void *)(v10 + 1) = -1;
        int v26 = open(a1, a2);
        int *v10 = v26;
        if ((v26 & 0x80000000) == 0)
        {
LABEL_29:
          uint64_t v14 = 0;
          goto LABEL_30;
        }
        uint64_t v56 = a3;
        int v27 = 30;
        while (*__error() == 16 && v27 != 0)
        {
          log_err((uint64_t)"%s:%d: open %s hit EBUSY, attempts remaining: %u dev_name = %s\n", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"dev_init");
          sleep(1u);
          int v36 = open(a1, a2);
          int *v10 = v36;
          --v27;
          if ((v36 & 0x80000000) == 0)
          {
            uint64_t v14 = 0;
            a3 = v56;
            goto LABEL_30;
          }
        }
        uint64_t v14 = 0;
        uint64_t v12 = *__error();
        a3 = v56;
      }
    }
    else
    {
      bzero(__str, 0x400uLL);
      bzero(v59, 0x400uLL);
      bzero(v58, 0x400uLL);
      snprintf(__str, 0x400uLL, "%s/apfs", a1);
      snprintf(v58, 0x400uLL, "%s/apfs_data", a1);
      snprintf(v59, 0x400uLL, "%s/nx", a1);
      int v11 = open(__str, a2);
      v10[1] = v11;
      if (v11 < 0) {
        uint64_t v12 = *__error();
      }
      else {
        uint64_t v12 = 0;
      }
      int v45 = open(v58, a2);
      void v10[2] = v45;
      if (v45 < 0) {
        uint64_t v12 = *__error();
      }
      int v46 = open(v59, a2);
      int *v10 = v46;
      if ((v10[1] & 0x80000000) == 0 && (v10[2] & 0x80000000) == 0 && (v46 & 0x80000000) == 0) {
        goto LABEL_29;
      }
      if (!v12) {
        uint64_t v12 = *__error();
      }
      strerror(v12);
      log_err((uint64_t)"%s:%d: failed to open apfs/nx special devices ['%s'(%d) / '%s'(%d) / '%s'(%d)] - err %d (%s) dev_name = '%s'\n", v48, v49, v50, v51, v52, v53, v54, (uint64_t)"dev_init");
      close(*v10);
      close(v10[1]);
      close(v10[2]);
      uint64_t v14 = 0;
    }
    free(v14);
    if (v12) {
      goto LABEL_38;
    }
    goto LABEL_39;
  }
  return 12;
}

uint64_t dev_set_tier2_device(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 == a1) {
    return 22;
  }
  uint64_t result = 0;
  *(void *)(a1 + 80) = a2;
  *(void *)(a1 + 88) = a3;
  return result;
}

uint64_t fskit_dev_init(uint64_t a1, uint64_t a2, void *a3)
{
  if (!a1) {
    return 22;
  }
  if ((*(_DWORD *)(a1 + 28) & 0x80000000) != 0) {
    return 22;
  }
  if (!*(_DWORD *)(a1 + 8)) {
    return 22;
  }
  if (!*(_DWORD *)(a1 + 12)) {
    return 22;
  }
  uint64_t v4 = *(const char **)a1;
  if (!*(void *)a1 || !*(_DWORD *)(a1 + 16) || !*(unsigned char *)(a1 + 24)) {
    return 22;
  }
  if (!strncmp(*(const char **)a1, "/dev/", 5uLL)) {
    uint64_t v6 = 5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = &v4[v6];
  size_t v8 = strlen(v7);
  *a3 = 0;
  uint64_t v9 = (char *)_apfs_calloc(1uLL, v8 + 216);
  if (!v9) {
    return 12;
  }
  uint64_t v10 = v9;
  *((_DWORD *)v9 + 17) = 0;
  *(_DWORD *)uint64_t v9 = *(_DWORD *)(a1 + 28);
  *(void *)(v9 + 4) = -1;
  *((_WORD *)v9 + 32) = 0x8000;
  *((void *)v9 + 16) = *(unsigned int *)(a1 + 8);
  *((int32x2_t *)v9 + 12) = vrev64_s32(*(int32x2_t *)(a1 + 12));
  int v11 = *(unsigned __int8 *)(a1 + 24);
  *((_DWORD *)v9 + 30) = 0;
  *((_DWORD *)v9 + 26) = 0;
  *((_DWORD *)v9 + 27) = v11;
  *((void *)v9 + 14) = 1;
  *((void *)v9 + 9) = apfs_userspace_io;
  strlcpy(v9 + 208, v7, v8 + 1);
  uint64_t result = 0;
  *a3 = v10;
  return result;
}

uint64_t sub_1000531B8(int *a1, unint64_t a2, unint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8 = a6;
  uint64_t v21 = sub_10005331C((uint64_t)a1, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (!v21)
  {
    unint64_t v22 = a1[25];
    if ((a2 & 0x8000000000000000) == 0
      && is_mul_ok(a2, v22)
      && (uint64_t v23 = a2 * v22, ((a2 * v22) & 0x8000000000000000) == 0)
      && is_mul_ok(a3, v22))
    {
      unint64_t v25 = a3 * v22;
      if (!a5 || (int v26 = a1[1], v26 < 0)) {
        int v26 = *a1;
      }
      ssize_t v27 = pread(v26, a4, a3 * v22, a2 * v22);
      if (v27 < 0)
      {
        uint64_t v21 = *__error();
        if (v21 == 6) {
          return 6;
        }
        else {
          log_err((uint64_t)"%s:%d: blknum 0x%llx size %zu, error %d dev_name = %s\n", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"fd_dev_read_helper");
        }
      }
      else
      {
        if (v27 == v25) {
          uint64_t v21 = 0;
        }
        else {
          uint64_t v21 = 5;
        }
        if (a5 && v27)
        {
          if (v8) {
            *(void *)(*(void *)(a5 + 72) + 12) = a2;
          }
          userfs_data_cryptor(a5, (uint64_t)a4, (uint64_t)a4, v27, v23, a1[25], 0);
        }
      }
    }
    else
    {
      log_err((uint64_t)"%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"fd_dev_read_helper");
      return 22;
    }
  }
  return v21;
}

uint64_t sub_10005331C(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11 = *(void **)(a1 + 24);
  if (v11)
  {
    unint64_t v12 = *(unsigned int *)(a1 + 36);
    if (v12)
    {
      unint64_t v13 = *(void *)(a1 + 40);
      BOOL v14 = a3 + a2 > v13 && v13 + v12 > a2;
      if (v14)
      {
        uint64_t result = sub_1000533AC(a1, v13, v12, v11, *(void *)(a1 + 48), a6, a7, a8);
        if (result) {
          return result;
        }
        *(_DWORD *)(a1 + 36) = 0;
      }
    }
  }
  unint64_t v15 = *(void *)(a1 + 128);
  BOOL v14 = v15 > a2;
  unint64_t v16 = v15 - a2;
  if (!v14) {
    sub_100060CF4();
  }
  if (v16 < a3) {
    sub_100060CC8();
  }
  return 0;
}

uint64_t sub_1000533AC(uint64_t a1, unint64_t a2, unint64_t a3, void *__buf, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8 = *(void *)(a1 + 128);
  BOOL v9 = v8 > a2;
  unint64_t v10 = v8 - a2;
  if (!v9) {
    sub_100060D4C();
  }
  if (v10 < a3) {
    sub_100060D20();
  }
  unint64_t v11 = *(unsigned int *)(a1 + 100);
  if ((a2 & 0x8000000000000000) == 0
    && is_mul_ok(a2, v11)
    && (off_t v12 = a2 * v11, ((a2 * v11) & 0x8000000000000000) == 0)
    && is_mul_ok(a3, v11))
  {
    size_t v14 = a3 * v11;
    if (!a5 || (int v15 = *(_DWORD *)(a1 + 4), v15 < 0)) {
      int v15 = *(_DWORD *)a1;
    }
    ssize_t v16 = pwrite(v15, __buf, v14, v12);
    if (v16 < 0)
    {
      return *__error();
    }
    else if (v16 == v14)
    {
      return 0;
    }
    else
    {
      return 5;
    }
  }
  else
  {
    log_err((uint64_t)"%s:%d: blknum %lld size %zu blksize %u invalid, dev_name = %s\n", a2, a3, (uint64_t)__buf, a5, a6, a7, a8, (uint64_t)"_fd_dev_write");
    return 22;
  }
}

uint64_t sub_100053484(int *a1, unint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9 = a6;
  uint64_t v15 = sub_10005331C((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if (!v15)
  {
    if (!a7) {
      sub_100060D78();
    }
    *(_OWORD *)(a7 + 8) = 0u;
    uint64_t v17 = (aiocb *)(a7 + 8);
    *(void *)(a7 + 88) = a5;
    *(_OWORD *)(a7 + 24) = 0u;
    *(_OWORD *)(a7 + 40) = 0u;
    *(_OWORD *)(a7 + 56) = 0u;
    *(_OWORD *)(a7 + 72) = 0u;
    uint64_t v18 = a1[25];
    *(void *)(a7 + 16) = v18 * a2;
    *(void *)(a7 + 24) = a4;
    *(void *)(a7 + 32) = v18 * a3;
    if (!a5 || (int v19 = a1[1], v19 < 0)) {
      int v19 = *a1;
    }
    v17->aio_fildes = v19;
    if (a5 && (v9 & 1) != 0) {
      *(void *)(*(void *)(a5 + 72) + 12) = a2;
    }
    if (!aio_read(v17)) {
      return 0;
    }
    if (*__error() == 35)
    {
      uint64_t v15 = 16;
    }
    else
    {
      uint64_t v15 = *__error();
      if (!v15) {
        return v15;
      }
    }
  }
  ssize_t v16 = *(void (**)(uint64_t))a7;
  if (*(void *)a7)
  {
    *(_DWORD *)(a7 + 96) = v15;
    v16(a7);
  }
  return v15;
}

uint64_t sub_100053588(uint64_t a1, unint64_t a2, unint64_t a3, char *__buf, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a6;
  if (*(_DWORD *)(a1 + 60) && !*(void *)(a1 + 24))
  {
    unsigned int v14 = *(_DWORD *)(a1 + 100);
    unsigned int v15 = v14 <= 0x100000 ? 0x100000 / v14 : 1;
    *(_DWORD *)(a1 + 32) = v15;
    ssize_t v16 = _apfs_malloc(v15 * v14);
    *(void *)(a1 + 24) = v16;
    *(_DWORD *)(a1 + 36) = 0;
    if (!v16) {
      return 12;
    }
  }
  if (a5 && (v8 & 1) != 0) {
    *(void *)(*(void *)(a5 + 72) + 12) = a2;
  }
  if (*(void *)(a1 + 24))
  {
    if (!a3) {
      return 0;
    }
    unsigned int v17 = *(_DWORD *)(a1 + 36);
    while (1)
    {
      while (1)
      {
        unint64_t v18 = a3 >= *(_DWORD *)(a1 + 32) - v17 ? *(_DWORD *)(a1 + 32) - v17 : a3;
        if ((v8 & 4) != 0 || ((*(_DWORD *)(a1 + 56) ^ v8) & 1) != 0 || a2 != *(void *)(a1 + 40) + v17) {
          break;
        }
        if (!v18 || *(void *)(a1 + 48) != a5) {
          break;
        }
        uint64_t v21 = *(void *)(a1 + 24);
        uint64_t v22 = *(unsigned int *)(a1 + 100);
        uint64_t v23 = v22 * v17;
        if (a5)
        {
          userfs_data_cryptor(a5, (uint64_t)__buf, v21 + v23, (v22 * v18), a2 * v22, v22, 1);
          *(void *)(*(void *)(a5 + 72) + 12) += v18;
        }
        else
        {
          memcpy((void *)(v21 + v23), __buf, (v22 * v18));
        }
        unsigned int v17 = *(_DWORD *)(a1 + 36) + v18;
        *(_DWORD *)(a1 + 36) = v17;
        a2 += v18;
        a3 -= v18;
        __buf += (*(_DWORD *)(a1 + 100) * v18);
        if (!a3) {
          return 0;
        }
      }
      if (v17)
      {
        uint64_t v20 = sub_1000533AC(a1, *(void *)(a1 + 40), v17, *(void **)(a1 + 24), *(void *)(a1 + 48), a6, a7, a8);
        if (v20) {
          break;
        }
      }
      unsigned int v17 = 0;
      *(_DWORD *)(a1 + 36) = 0;
      *(void *)(a1 + 40) = a2;
      *(void *)(a1 + 48) = a5;
      *(_DWORD *)(a1 + 56) = v8;
    }
    return v20;
  }
  if (a5)
  {
    unint64_t v25 = _apfs_malloc(*(unsigned int *)(a1 + 100));
    if (v25)
    {
      int v26 = v25;
      uint64_t v27 = *(unsigned int *)(a1 + 100);
      if (a3)
      {
        unint64_t v28 = a3 - 1;
        do
        {
          userfs_data_cryptor(a5, (uint64_t)__buf, (uint64_t)v26, v27, a2 * v27, v27, 1);
          ++*(void *)(*(void *)(a5 + 72) + 12);
          uint64_t v32 = sub_1000533AC(a1, a2, 1uLL, v26, a5, v29, v30, v31);
          uint64_t v24 = v32;
          uint64_t v27 = *(unsigned int *)(a1 + 100);
          BOOL v34 = v28-- != 0;
          if (v32) {
            break;
          }
          ++a2;
          __buf += v27;
        }
        while (v34);
      }
      else
      {
        uint64_t v24 = 0;
      }
      _apfs_free(v26, v27);
      return v24;
    }
    return 12;
  }

  return sub_1000533AC(a1, a2, a3, __buf, 0, a6, a7, a8);
}

uint64_t spaceman_metazone_get_size(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4, void *a5, void *a6)
{
  if (!a4) {
    return 28;
  }
  unint64_t v6 = a1;
  if (a1 <= a2 || a4 < a1)
  {
    if (0x180000000 * (a2 >> 12) > a4) {
      return 28;
    }
    if (a4 >> 34)
    {
      uint64_t v9 = 0x1000000000;
      if (a4 >= 0x1000000000) {
        unint64_t v10 = 0x1000000000;
      }
      else {
        unint64_t v10 = a4;
      }
      uint64_t v8 = v10 >> 5;
      if (a4 >= 0x1000000001)
      {
        if (a4 - 0x1000000000 < 0x1000000000) {
          uint64_t v9 = a4 - 0x1000000000;
        }
        v8 += ((unint64_t)v9 * (unsigned __int128)0x666666666666667uLL) >> 64;
        if (a4 >= 0x2000000001)
        {
          unint64_t v11 = a4 - 0x2000000000;
          if (a4 - 0x2000000000 >= 0x2000000000) {
            unint64_t v11 = 0x2000000000;
          }
          v8 += v11 >> 7;
          if (a4 >= 0x4000000001) {
            v8 += (a4 - 0x4000000000) / 0xA0;
          }
        }
      }
    }
    else
    {
      uint64_t v8 = 0x20000000;
    }
    unint64_t v6 = v8 * (a2 >> 12);
    if (v6 >= a4 >> 2) {
      unint64_t v6 = a4 >> 2;
    }
  }
  uint64_t result = 0;
  unint64_t v12 = v6 / a2;
  *a5 = v12 * a2;
  *a6 = a3 - v12;
  return result;
}

unint64_t spaceman_metazone_get_partitions(unint64_t result, unint64_t a2, uint64_t a3, uint64_t a4, void *a5, void *a6)
{
  if (a5) {
    *a5 = (a2 >> 1) / result + a3;
  }
  if (a6)
  {
    unint64_t v6 = (a2 >> 4) / result;
    if (v6 >= 0x8000000 / result) {
      unint64_t v6 = 0x8000000 / result;
    }
    *a6 = a4 - v6;
  }
  return result;
}

double nx_obj_cache_reset(uint64_t a1)
{
  obj_cache_reset(*(pthread_mutex_t **)(a1 + 392), 0);
  *(void *)(a1 + 408) = 0;
  *(void *)(a1 + 720) = 0;
  *(void *)(a1 + 920) = 0;
  *(void *)(a1 + 1128) = 0;
  *(void *)(a1 + 1336) = 0;
  *(unsigned char *)(a1 + 635) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 424) = 0u;
  *(_OWORD *)(a1 + 440) = 0u;
  *(_OWORD *)(a1 + 456) = 0u;
  return result;
}

uint64_t nx_checkpoint_find_highest_xid(uint64_t a1, int *a2, unint64_t *a3)
{
  unint64_t v6 = _apfs_malloc(*(unsigned int *)(*(void *)(a1 + 376) + 36));
  if (!v6) {
    return 12;
  }
  uint64_t v7 = (uint64_t)v6;
  uint64_t v33 = 0;
  uint64_t v8 = *(void *)(a1 + 376);
  if ((*(_DWORD *)(v8 + 104) & 0x7FFFFFFF) != 0)
  {
    unint64_t v9 = 0;
    BOOL v32 = 0;
    unint64_t v10 = 0;
    int v11 = -1;
    while (1)
    {
      *(_DWORD *)(v7 + 24) = 0;
      if (nx_checkpoint_desc_block_address(a1, v9, &v33)
        || dev_read(*(void *)(a1 + 384), v33))
      {
        log_err((uint64_t)"%s:%d: %s couldn't read checkpoint descriptor block %d @ 0x%llx: %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"nx_checkpoint_find_highest_xid");
      }
      else
      {
        int v21 = *(_DWORD *)(v7 + 24);
        if (v21 == -2147483647) {
          goto LABEL_12;
        }
        if (v21)
        {
          if (v21 == 1073741836)
          {
LABEL_12:
            if (obj_checksum_verify_phys(v7, *(_DWORD *)(*(void *)(a1 + 376) + 36), v19, v20))
            {
              log_err((uint64_t)"%s:%d: %s invalid checksum for object type 0x%x @ checkpoint descriptor block %d @ 0x%llx\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_checkpoint_find_highest_xid");
            }
            else if (*(_DWORD *)(v7 + 28))
            {
              log_err((uint64_t)"%s:%d: %s found unexpected subtype 0x%x for object type 0x%x @ checkpoint descriptor block %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_checkpoint_find_highest_xid");
            }
            else
            {
              unint64_t v29 = *(void *)(v7 + 16);
              if (v29)
              {
                if (v29 >= v10)
                {
                  int v30 = *(_DWORD *)(v7 + 24);
                  if (v29 == v10 && v32 && v30 != -2147483647)
                  {
                    BOOL v32 = 1;
                  }
                  else
                  {
                    BOOL v32 = v30 == -2147483647;
                    unint64_t v10 = *(void *)(v7 + 16);
                    int v11 = v9;
                  }
                }
              }
              else
              {
                log_err((uint64_t)"%s:%d: %s found unexpected xid %lld @ checkpoint descriptor block %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_checkpoint_find_highest_xid");
              }
            }
            goto LABEL_7;
          }
          log_err((uint64_t)"%s:%d: %s found unexpected object type 0x%x @ checkpoint descriptor block %d\n", v12, v13, v14, v15, v16, v17, v18, (uint64_t)"nx_checkpoint_find_highest_xid");
        }
      }
LABEL_7:
      ++v9;
      uint64_t v8 = *(void *)(a1 + 376);
      if (v9 >= (*(_DWORD *)(v8 + 104) & 0x7FFFFFFFu)) {
        goto LABEL_27;
      }
    }
  }
  unint64_t v10 = 0;
  int v11 = -1;
LABEL_27:
  _apfs_free((void *)v7, *(unsigned int *)(v8 + 36));
  *a2 = v11;
  *a3 = v10;
  return 2 * (v10 == 0);
}

uint64_t nx_check_checkpoint_map_block(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int8x16_t a5, int8x16_t a6)
{
  int v10 = obj_checksum_verify_phys(a2, *(_DWORD *)(a1 + 36), a5, a6);
  unint64_t v11 = *(unsigned int *)(a2 + 36);
  if (!v11) {
    goto LABEL_19;
  }
  if (v10) {
    int v12 = 2;
  }
  else {
    int v12 = 1;
  }
  if (*(_DWORD *)(a2 + 24) == 1073741836) {
    int v13 = v10 != 0;
  }
  else {
    int v13 = v12;
  }
  if (*(_DWORD *)(a2 + 28)) {
    ++v13;
  }
  if (*(void *)(a2 + 16) != *(void *)(a1 + 16)) {
    ++v13;
  }
  int v14 = *(void *)(a2 + 8) == a3 ? v13 : v13 + 1;
  uint64_t v15 = *(unsigned int *)(a1 + 36);
  if (v11 <= (v15 - 40) / 0x28uLL && v14 == -(*(_DWORD *)(a2 + 32) & 1 ^ (a4 != 0)))
  {
    uint64_t v18 = 0;
    uint64_t v19 = *(unsigned int *)(a1 + 108);
    uint64_t v20 = a2 + 40;
    while (v11 != v18)
    {
      int v21 = *(_DWORD *)(v20 + 4);
      if ((*(_DWORD *)v20 & 0xC0000000) == 0x80000000) {
        int v22 = 1;
      }
      else {
        int v22 = 2;
      }
      if ((unsigned __int16)*(_DWORD *)v20 > 0x17u || ((1 << *(_DWORD *)v20) & 0xC6002C) == 0) {
        int v24 = v22;
      }
      else {
        int v24 = (*(_DWORD *)v20 & 0xC0000000) != 0x80000000;
      }
      if ((v21 & 0xC0000000) != 0) {
        ++v24;
      }
      if (((unsigned __int16)*(_DWORD *)(v20 + 4) > 0x24u || ((1 << v21) & 0x100029CA01) == 0)
        && (unsigned __int16)*(_DWORD *)(v20 + 4) != 255)
      {
        ++v24;
      }
      if (!*(void *)(v20 + 24)) {
        ++v24;
      }
      if ((v19 & 0x80000000) != 0)
      {
        unsigned int v30 = v18;
      }
      else
      {
        unint64_t v25 = *(void *)(v20 + 32);
        unint64_t v26 = *(void *)(a1 + 120);
        if (v25 < v26) {
          ++v24;
        }
        if (v25 >= v26 + v19) {
          ++v24;
        }
        unsigned int v27 = v25 - v26;
        unsigned int v28 = *(_DWORD *)(a1 + 144);
        if (v28 <= v27) {
          int v29 = 0;
        }
        else {
          int v29 = *(_DWORD *)(a1 + 108);
        }
        unsigned int v30 = v29 - v28 + v27;
        if (v30 >= *(_DWORD *)(a1 + 148)) {
          ++v24;
        }
      }
      unsigned int v31 = *(_DWORD *)(v20 + 8);
      if (v31) {
        int v32 = v24;
      }
      else {
        int v32 = v24 + 1;
      }
      unsigned int v33 = v31 / v15;
      if (v31 % v15) {
        int v34 = -1;
      }
      else {
        int v34 = 0;
      }
      if (v32 == v34)
      {
        ++v18;
        v20 += 40;
        if (v33 <= *(_DWORD *)(a1 + 148) - v30) {
          continue;
        }
      }
      goto LABEL_19;
    }
    return 0;
  }
  else
  {
LABEL_19:
    return nx_corruption_detected_int(0);
  }
}

BOOL nx_superblock_agrees_with_main_superblock(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8 = a4;
  if (*(void *)(a1 + 72) == *(void *)(a2 + 72) && *(void *)(a1 + 80) == *(void *)(a2 + 80))
  {
    int v12 = 0;
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s<->superblock mismatch on uuid\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
    int v12 = 1;
  }
  BOOL v13 = *(void *)(a1 + 1280) == *(void *)(a2 + 1280) && *(void *)(a1 + 1287) == *(void *)(a2 + 1287);
  if (!v13 || (*(unsigned __int8 *)(a2 + 1295) ^ *(unsigned __int8 *)(a1 + 1295)) != v8)
  {
    log_err((uint64_t)"%s:%d: %s<->superblock mismatch on fusion uuid, tier2=%d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
    ++v12;
  }
  if (*(void *)(a1 + 16) > *(void *)(a2 + 16)) {
    log_err((uint64_t)"%s:%d: the %s superblock has a lower XID %lld than the main superblock %lld\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
  }
  if (*(_DWORD *)(a1 + 36) != *(_DWORD *)(a2 + 36))
  {
    log_err((uint64_t)"%s:%d: %s<->superblock mismatch on block size: %d %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
    ++v12;
  }
  if (*(void *)(a1 + 40) != *(void *)(a2 + 40))
  {
    log_err((uint64_t)"%s:%d: %s<->superblock mismatch on block count: %lld %lld\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
    ++v12;
  }
  if (*(_DWORD *)(a1 + 104) != *(_DWORD *)(a2 + 104))
  {
    log_err((uint64_t)"%s:%d: %s<->superblock mismatch on checkpoint descriptor block count: %d %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
    ++v12;
  }
  if (*(_DWORD *)(a1 + 108) != *(_DWORD *)(a2 + 108))
  {
    log_err((uint64_t)"%s:%d: %s<->superblock mismatch on checkpoint data block count: %d %d\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
    ++v12;
  }
  if (*(void *)(a1 + 112) != *(void *)(a2 + 112))
  {
    log_err((uint64_t)"%s:%d: %s<->superblock mismatch on checkpoint descriptor base address: %lld %lld\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
    ++v12;
  }
  if (*(void *)(a1 + 120) != *(void *)(a2 + 120))
  {
    log_err((uint64_t)"%s:%d: %s<->superblock mismatch on checkpoint data base address: %lld %lld\n", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"nx_superblock_agrees_with_main_superblock");
    int v12 = 1;
  }
  return v12 == 0;
}

uint64_t nx_checkpoint_find_valid_checkpoint(uint64_t a1, uint64_t a2, int a3, uint64_t a4, unsigned int *a5)
{
  uint64_t v92 = 0;
  unint64_t v93 = 0;
  uint64_t v91 = 0;
  *a5 = -1;
  unsigned int v5 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  if (!v5) {
    return 2;
  }
  int v10 = 0;
  unsigned int v11 = 0;
  uint64_t v89 = (_OWORD *)(a1 + 424);
  while (1)
  {
    if (v10 && (*(unsigned char *)(a2 + 1264) & 2) != 0) {
      return 35;
    }
    unsigned int v12 = (a3 + v5 + v10) % v5;
    uint64_t v94 = -1;
    if (nx_checkpoint_desc_block_address(a1, v12, &v94)
      || dev_read(*(void *)(a1 + 384), v94))
    {
      log_err((uint64_t)"%s:%d: %s couldn't read checkpoint descriptor block %d @ %lld: %d\n", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
      goto LABEL_8;
    }
    if (*(_DWORD *)(a4 + 24) == -2147483647)
    {
      if (nx_check_superblock(a4, *(_DWORD *)(a2 + 36), 1, v20, v21))
      {
        log_err((uint64_t)"%s:%d: %s checkpoint superblock %d @ %lld: failed sanity check: %d\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
        goto LABEL_8;
      }
      if ((*(void *)(a2 + 64) & 0xFFFFFFFFFFFFFEFDLL) != 0)
      {
        log_err((uint64_t)"%s:%d: %s unsupported nx_incompatible_features (0x%llx): unable to mount\n", v22, v23, v24, v25, v26, v27, v28, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
        return 75;
      }
      if (nx_superblock_agrees_with_main_superblock(a2, a4, (uint64_t)"checkpoint", 0, v25, v26, v27, v28)) {
        break;
      }
    }
LABEL_8:
    ++v11;
    unsigned int v5 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
    --v10;
    if (v11 >= v5) {
      return 2 * (*a5 == -1);
    }
  }
  unsigned int v36 = *(_DWORD *)(a4 + 140);
  unsigned int v37 = *(_DWORD *)(a2 + 104) & 0x7FFFFFFF;
  if (v12 != (*(_DWORD *)(a4 + 136) + v36 - 1) % v37)
  {
    log_err((uint64_t)"%s:%d: %s xid %lld checkpoint superblock index %d doesn't match index block was found at: %d\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
    goto LABEL_8;
  }
  if (v36 > v10 + v37)
  {
    log_err((uint64_t)"%s:%d: %s xid %lld checkpoint superblock index %d doesn't fit in blocks remaining: %d > %d\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
    goto LABEL_8;
  }
  if (nx_metadata_range_add(a1, 0, 1, 0, 1)
    || (*(unsigned char *)(a4 + 65) & 1) != 0
    && (nx_metadata_range_add(a1, 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(*(void *)(a1 + 376) + 36))), 1, 0, 1)|| (*(unsigned char *)(a4 + 65) & 1) != 0&& nx_metadata_range_add(a1, *(void *)(*(void *)(a1 + 376) + 1368), *(void *)(*(void *)(a1 + 376) + 1376) & 0x7FFFFFFF, (*(void *)(*(void *)(a1 + 376) + 1376) & 0x80000000) != 0, 0))|| nx_metadata_range_add(a1, *(void *)(a4 + 112), *(_DWORD *)(a4 + 104) & 0x7FFFFFFF, *(int *)(a4 + 104) < 0, 0)|| nx_metadata_range_add(
                       a1,
                       *(void *)(a4 + 120),
                       *(_DWORD *)(a4 + 108) & 0x7FFFFFFF,
                       *(int *)(a4 + 108) < 0,
                       0))
  {
    log_err((uint64_t)"%s:%d: %s xid %lld at index %d failed to load checkpoint metadata ranges (overlap?): %d\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
LABEL_21:
    obj_cache_reset(*(pthread_mutex_t **)(a1 + 392), 0);
    *(void *)(a1 + 408) = 0;
    *(void *)(a1 + 720) = 0;
    *(void *)(a1 + 920) = 0;
    *(void *)(a1 + 1128) = 0;
    *(void *)(a1 + 1336) = 0;
    *(unsigned char *)(a1 + 635) = 0;
    *uint64_t v89 = 0u;
    v89[1] = 0u;
    v89[2] = 0u;
    goto LABEL_8;
  }
  if (sub_100054730(a1, (unsigned int *)a4))
  {
    log_err((uint64_t)"%s:%d: %s xid %lld validation failed for checkpoint at index %d: %d\n", v45, v46, v47, v48, v49, v50, v51, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
    goto LABEL_21;
  }
  if (sub_100054834(a1, a4, &v93, &v92))
  {
    log_err((uint64_t)"%s:%d: %s xid %lld data for checkpoint at index %d couldn't be loaded: %d\n", v52, v53, v54, v55, v56, v57, v58, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
    nx_obj_cache_reset(a1);
    goto LABEL_8;
  }
  memcpy(*(void **)(a1 + 376), (const void *)a4, *(unsigned int *)(a2 + 36));
  *(void *)(*(void *)(a1 + 392) + 400) = *(void *)(*(void *)(a1 + 376) + 88);
  if (nx_checkpoint_traverse(a1, 0, 2))
  {
    log_err((uint64_t)"%s:%d: %s xid %lld failed to fix up checkpoint data: %d\n", v59, v60, v61, v62, v63, v64, v65, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
LABEL_46:
    nx_obj_cache_reset(a1);
    memcpy(*(void **)(a1 + 376), (const void *)a2, *(unsigned int *)(a2 + 36));
    *(void *)(*(void *)(a1 + 392) + 400) = *(void *)(*(void *)(a1 + 376) + 88);
    goto LABEL_8;
  }
  if (*(unsigned char *)(a1 + 628))
  {
    if (*(unsigned char *)(a1 + 631))
    {
      log_info((uint64_t)"%s:%d: %s probe of external device... skipping recent sanity checks.\n", v59, v60, v61, v62, v63, v64, v65, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
    }
    else
    {
      log_info((uint64_t)"%s:%d: %s sanity checking all recently-changed container state... please be patient.\n", v59, v60, v61, v62, v63, v64, v65, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
      if (nx_check_recent_sanity((void *)a1))
      {
        log_err((uint64_t)"%s:%d: %s xid %lld sanity check of recently-changed structures failed: %d\n", v80, v81, v82, v83, v84, v85, v86, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
        goto LABEL_46;
      }
    }
  }
  if (spaceman_get((void *)a1, &v91))
  {
    log_err((uint64_t)"%s:%d: %s xid %lld failed to get spaceman: %d\n", v66, v67, v68, v69, v70, v71, v72, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
    goto LABEL_46;
  }
  if (nx_metadata_range_add(a1, *(void *)(v91[47] + 168), *(_DWORD *)(v91[47] + 164) & 0x7FFFFFFF, *(int *)(v91[47] + 164) < 0, 0))
  {
    obj_release(v91);
LABEL_45:
    log_err((uint64_t)"%s:%d: %s xid %lld failed to load spaceman metadata ranges (overlap?): %d\n", v73, v74, v75, v76, v77, v78, v79, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
    goto LABEL_46;
  }
  int v88 = nx_metadata_range_add(a1, *(void *)(v91[47] + 176), *(void *)(v91[47] + 152), *(uint64_t *)(v91[47] + 152) < 0, 0);
  obj_release(v91);
  if (v88) {
    goto LABEL_45;
  }
  if (*(void *)(*(void *)(a1 + 376) + 16) < v93) {
    log_err((uint64_t)"%s:%d: %s warning: best valid checkpoint xid %lld is less than max free queue oldest xid %lld seen in checkpoint %lld\n", v73, v74, v75, v76, v77, v78, v79, (uint64_t)"nx_checkpoint_find_valid_checkpoint");
  }
  uint64_t result = 0;
  *a5 = v12;
  return result;
}

uint64_t sub_100054730(uint64_t a1, unsigned int *a2)
{
  uint64_t v4 = _apfs_malloc(a2[9]);
  if (!v4) {
    return 12;
  }
  unsigned int v5 = v4;
  uint64_t v12 = 0;
  if (a2[35] == 1)
  {
LABEL_3:
    uint64_t v6 = 0;
  }
  else
  {
    int v7 = 0;
    while (1)
    {
      uint64_t v8 = nx_checkpoint_desc_block_address(a1, (v7 + a2[34]) % (a2[26] & 0x7FFFFFFF), &v12);
      if (v8) {
        break;
      }
      uint64_t v8 = dev_read(*(void *)(a1 + 384), v12);
      if (v8) {
        break;
      }
      uint64_t v8 = nx_check_checkpoint_map_block((uint64_t)a2, (uint64_t)v5, v12, v7 == a2[35] - 2, v9, v10);
      if (v8) {
        break;
      }
      if (++v7 >= a2[35] - 1) {
        goto LABEL_3;
      }
    }
    uint64_t v6 = v8;
  }
  _apfs_free(v5, a2[9]);
  return v6;
}

uint64_t sub_100054834(uint64_t a1, uint64_t a2, unint64_t *a3, void *a4)
{
  size_t v6 = *(unsigned int *)(*(void *)(a1 + 376) + 36);
  uint64_t v69 = 0;
  int v7 = _apfs_malloc(v6);
  if (v7)
  {
    uint64_t v15 = v7;
    v72[0] = 0;
    uint64_t v70 = 0;
    uint64_t v71 = 0;
    unint64_t v67 = 0;
    uint64_t v68 = 0;
    if (*(_DWORD *)(a2 + 140) - 1 < 1)
    {
LABEL_28:
      _apfs_free(v15, v6);
      return 0;
    }
    else
    {
      int v16 = 0;
      unsigned int v17 = *(_DWORD *)(a2 + 144);
      unsigned int v18 = *(_DWORD *)(a2 + 136);
      uint64_t v62 = (char *)(v7 + 10);
      int v61 = *(_DWORD *)(a2 + 140) - 1;
      while (1)
      {
        uint64_t v68 = 0;
        unint64_t v19 = nx_checkpoint_desc_block_address(a1, v18, &v68);
        if (v19
          || (unint64_t v19 = dev_read(*(void *)(a1 + 384), v68), v19)
          || (unint64_t v19 = obj_checksum_verify_phys((uint64_t)v15, v6, v27, v28), v19))
        {
          uint64_t v59 = v19;
          log_err((uint64_t)"%s:%d: %s couldn't read checkpoint descriptor map block %d @ %lld: %d\n", v20, v21, v22, v23, v24, v25, v26, (uint64_t)"nx_checkpoint_load_data");
LABEL_39:
          _apfs_free(v15, v6);
LABEL_40:
          obj_cache_reset(*(pthread_mutex_t **)(a1 + 392), 0);
          *(void *)(a1 + 408) = 0;
          *(void *)(a1 + 720) = 0;
          *(void *)(a1 + 920) = 0;
          *(void *)(a1 + 1128) = 0;
          *(void *)(a1 + 1336) = 0;
          *(unsigned char *)(a1 + 635) = 0;
          *(_OWORD *)(a1 + 424) = 0u;
          *(_OWORD *)(a1 + 440) = 0u;
          *(_OWORD *)(a1 + 456) = 0u;
          return v59;
        }
        unsigned int v64 = v18;
        int v63 = v16;
        if (v15[9]) {
          break;
        }
LABEL_27:
        unsigned int v18 = (v64 + 1) % (*(_DWORD *)(a2 + 104) & 0x7FFFFFFFu);
        int v16 = v63 + 1;
        if (v63 + 1 == v61) {
          goto LABEL_28;
        }
      }
      unint64_t v29 = 0;
      uint64_t v30 = v62;
      while (1)
      {
        int v31 = *((_DWORD *)v30 + 2);
        uint64_t v68 = 0;
        uint64_t v32 = nx_checkpoint_data_block_address(a1, v17, &v68, &v67);
        if (v32)
        {
          uint64_t v59 = v32;
          log_err((uint64_t)"%s:%d: %s couldn't read checkpoint data block %d @ %lld: %d\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"nx_checkpoint_load_data");
          goto LABEL_39;
        }
        if (v68 != *((void *)v30 + 4)) {
          break;
        }
        unsigned int v40 = *(_DWORD *)(a2 + 144);
        unsigned int v41 = v17;
        if (v17 < v40) {
          unsigned int v41 = (*(_DWORD *)(a2 + 108) & 0x7FFFFFFF) + v17;
        }
        unsigned int v42 = v41 - v40;
        unsigned int v43 = *(_DWORD *)(a2 + 148);
        unsigned int v44 = ((int)v6 - 1 + v31) / v6;
        if (v42 >= v43 || v42 + v44 > v43)
        {
          log_err((uint64_t)"%s:%d: %s checkpoint mapping (%d,%d) extends beyond checkpoint data range: %d,%d\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"nx_checkpoint_load_data");
          goto LABEL_34;
        }
        v72[0] = 0x80000000;
        uint64_t v45 = obj_descriptor_and_flags_for_type(*(_DWORD *)v30, v72, (uint64_t)&v70);
        HIDWORD(v70) = *((_DWORD *)v30 + 1);
        LODWORD(v71) = v31;
        if (v45)
        {
          uint64_t v59 = v45;
LABEL_38:
          log_err((uint64_t)"%s:%d: %s failed to load checkpoint data of type 0x%x:0x%x @ %lld\n", v46, v47, v48, v49, v50, v51, v52, (uint64_t)"nx_checkpoint_load_data");
          goto LABEL_39;
        }
        uint64_t v53 = obj_checkpoint_get(*(pthread_mutex_t **)(a1 + 392), v72[0], *((void *)v30 + 3), (unsigned int *)&v70, v68, v17, v67, *(void *)(a2 + 16), (uint64_t *)&v69);
        if (v53)
        {
          uint64_t v59 = v53;
          goto LABEL_38;
        }
        if (a3)
        {
          uint64_t v54 = v69;
          if (!*a4)
          {
            int v55 = obj_type((uint64_t)v69);
            uint64_t v54 = v69;
            if (v55 == 5)
            {
              uint64_t v56 = (void *)v69[7];
              unint64_t v57 = v56[32];
              if (v57 <= v56[27]) {
                unint64_t v57 = v56[27];
              }
              *a3 = v57;
              unint64_t v58 = v56[37];
              if (v58 <= v57) {
                unint64_t v58 = v57;
              }
              *a3 = v58;
              *a4 = *(void *)(a2 + 16);
            }
          }
        }
        else
        {
          uint64_t v54 = v69;
        }
        obj_release(v54);
        unsigned int v17 = (v44 + v17) % (*(_DWORD *)(a2 + 108) & 0x7FFFFFFFu);
        ++v29;
        v30 += 40;
        if (v29 >= v15[9]) {
          goto LABEL_27;
        }
      }
      log_err((uint64_t)"%s:%d: %s unexpected checkpoint map entry address: 0x%llx, expected 0x%llx\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"nx_checkpoint_load_data");
LABEL_34:
      uint64_t v59 = nx_corruption_detected_int(0);
      _apfs_free(v15, v6);
      if (v59) {
        goto LABEL_40;
      }
    }
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s couldn't allocate memory for checkpoint map block\n", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"nx_checkpoint_load_data");
    return 12;
  }
  return v59;
}

uint64_t nx_dev_init(uint64_t a1, char *a2, int a3, int a4, char a5, uint64_t a6, char a7, void *a8, void *a9)
{
  uint64_t v102 = 0;
  uint64_t v103 = 0;
  if (a4)
  {
    uint64_t v101 = a8;
    uint64_t v11 = 0;
    unsigned int v12 = 0;
    uint64_t v103 = a1;
    goto LABEL_3;
  }
  if (a5) {
    return 45;
  }
  uint64_t v53 = fskit_dev_init(a1, 2, &v103);
  if (v53)
  {
    uint64_t v49 = v53;
    log_err((uint64_t)"%s:%d: device initialization failed: %d\n", v54, v55, v56, v57, v58, v59, v60, (uint64_t)"nx_dev_init");
LABEL_43:
    if (v103) {
      dev_close(v103);
    }
    if (v102) {
      dev_close((uint64_t)v102);
    }
    return v49;
  }
  if (a2)
  {
    uint64_t v61 = dev_init(a2, a3, &v102);
    if (v61)
    {
      uint64_t v49 = v61;
      log_err((uint64_t)"%s:%d: tier2 device initialization failed: %d\n", v62, v63, v64, v65, v66, v67, v68, (uint64_t)"nx_dev_init");
      goto LABEL_43;
    }
  }
  uint64_t v101 = a8;
  if (v102)
  {
    unsigned int v12 = dev_block_size((uint64_t)v102);
    if (v102) {
      uint64_t v11 = dev_block_count((uint64_t)v102);
    }
    else {
      uint64_t v11 = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
    unsigned int v12 = 0;
  }
LABEL_3:
  unsigned int v13 = dev_block_size(v103);
  uint64_t v14 = dev_block_count(v103);
  if (v13 <= 0x1000) {
    unsigned int v22 = 4096;
  }
  else {
    unsigned int v22 = v13;
  }
  unint64_t v23 = v11 * v12 + v14 * v13;
  while (1)
  {
    if (v22 % v13)
    {
      log_err((uint64_t)"%s:%d: %s block size %d is not an even multiple of device block size %d\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_dev_init");
LABEL_42:
      uint64_t v49 = 22;
      goto LABEL_43;
    }
    if (v22 > v13) {
      dev_set_block_size(v103);
    }
    int v31 = (unsigned int *)_apfs_malloc(v22);
    if (!v31)
    {
      log_err((uint64_t)"%s:%d: %s couldn't allocate memory for superblock of size %d\n", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"nx_dev_init");
      uint64_t v49 = 12;
      goto LABEL_43;
    }
    uint64_t v32 = dev_read(v103, 0);
    if (v32)
    {
      uint64_t v49 = v32;
      log_err((uint64_t)"%s:%d: %s couldn't read superblock of size %d\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"nx_dev_init");
LABEL_37:
      _apfs_free(v31, v22);
      goto LABEL_43;
    }
    uint64_t v49 = nx_check_superblock((uint64_t)v31, v22, 0, v40, v41);
    if (v49) {
      goto LABEL_13;
    }
    if (v31[9] % v13)
    {
      log_err((uint64_t)"%s:%d: %s superblock block size %d not an even multiple of device block size %d\n", v42, v43, v44, v45, v46, v47, v48, (uint64_t)"nx_dev_init");
      uint64_t v49 = nx_corruption_detected_int(0);
      if (a7) {
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v49 = 0;
      if (a7) {
        goto LABEL_13;
      }
    }
    if (!v49)
    {
      uint64_t v50 = v31[9];
      if (*((void *)v31 + 5) * v50 <= v23) {
        goto LABEL_15;
      }
      log_err((uint64_t)"%s:%d: %s superblock container size %lld greater than device size(s) %lld\n", v42, v43, v44, v45, v46, v47, v48, (uint64_t)"nx_dev_init");
      uint64_t v49 = nx_corruption_detected_int(0);
    }
LABEL_13:
    if (v49)
    {
      if (v49 != 79) {
        log_err((uint64_t)"%s:%d: %s superblock failed sanity checks: %d\n", v42, v43, v44, v45, v46, v47, v48, (uint64_t)"nx_dev_init");
      }
      goto LABEL_37;
    }
    LODWORD(v50) = v31[9];
LABEL_15:
    if (v50 == v22) {
      break;
    }
    _apfs_free(v31, v22);
    dev_set_block_size(v103);
    unsigned int v22 = v50;
    if (v50 < v13)
    {
      log_err((uint64_t)"%s:%d: %s container block size too small for device block size (%d < %d)\n", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"nx_dev_init");
      goto LABEL_42;
    }
  }
  if (v102)
  {
    if (v22 < v12)
    {
      log_err((uint64_t)"%s:%d: %s container block size too small for tier2 device block size (%d < %d)\n", v42, v43, v44, v45, v46, v47, v48, (uint64_t)"nx_dev_init");
LABEL_41:
      uint64_t v49 = 22;
      goto LABEL_37;
    }
    if (v22 > dev_block_size((uint64_t)v102)) {
      dev_set_block_size((uint64_t)v102);
    }
    uint64_t v70 = dev_set_tier2_device(v103, (uint64_t)v102, 0x4000000000000000uLL >> __clz(__rbit64(v22)));
    if (v70)
    {
      uint64_t v49 = v70;
      log_err((uint64_t)"%s:%d: %s failed to set tier2 device: %d\n", v71, v72, v73, v74, v75, v76, v77, (uint64_t)"nx_dev_init");
      goto LABEL_37;
    }
    uint64_t v102 = 0;
  }
  if ((*((unsigned char *)v31 + 65) & 1) != 0 && (a7 & 1) == 0)
  {
    uint64_t v85 = _apfs_malloc(v22);
    if (!v85)
    {
      log_err((uint64_t)"%s:%d: %s couldn't allocate memory for superblock of size %d\n", v78, v79, v80, v81, v82, v83, v84, (uint64_t)"nx_dev_init");
      uint64_t v49 = 12;
      goto LABEL_37;
    }
    uint64_t v86 = dev_read(v103, 0x4000000000000000uLL >> __clz(__rbit64(v22)));
    if (v86)
    {
      uint64_t v49 = v86;
      log_err((uint64_t)"%s:%d: %s couldn't read tier2 device superblock of size %d\n", v87, v88, v89, v90, v91, v92, v93, (uint64_t)"nx_dev_init");
      _apfs_free(v85, v22);
      goto LABEL_37;
    }
    if (!nx_superblock_agrees_with_main_superblock((uint64_t)v31, (uint64_t)v85, (uint64_t)"tier2", 1, v90, v91, v92, v93))
    {
      log_err((uint64_t)"%s:%d: %s tier2 device superblock doesn't agree with main superblock\n", v94, v95, v96, v97, v98, v99, v100, (uint64_t)"nx_dev_init");
      _apfs_free(v85, v22);
      goto LABEL_41;
    }
    _apfs_free(v85, v22);
  }
  uint64_t v49 = 0;
  *a9 = v31;
  *uint64_t v101 = v103;
  return v49;
}

uint64_t nx_mount(uint64_t a1, uint64_t a2, uint64_t **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v309 = 0;
  uint64_t v310 = 0;
  memset(v311, 0, sizeof(v311));
  uint64_t v307 = 0;
  uint64_t v308 = 0;
  uint64_t v306 = 0;
  uint64_t v302 = 0;
  *a3 = 0;
  if (a2)
  {
    unsigned int v9 = *(unsigned __int16 *)(a2 + 8);
    uint64_t v10 = *(unsigned int *)(a2 + 4);
    int v11 = *(_DWORD *)a2 & 1;
    int16x4_t v12 = vdup_n_s16(v9);
    int16x4_t v13 = (int16x4_t)vand_s8((int8x8_t)v12, (int8x8_t)0x2000100001000004);
    if ((v9 & 8) != 0)
    {
      uint64_t v15 = *(char **)(a2 + 16);
      int v14 = (v9 >> 6) & 1;
    }
    else
    {
      LOBYTE(v14) = 0;
      uint64_t v15 = 0;
    }
    BOOL v22 = (v9 & 0x4000 | v11) != 0;
    if ((vtst_s16(v13, v13).i8[6] & 1) != 0 && (v10 & 0x80000000) == 0)
    {
      log_err((uint64_t)"%s:%d: conflicting mount options: load from temporary checkpoint AND checkpoint descriptor index %d\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"nx_mount");
LABEL_11:
      unsigned int v23 = 0;
      uint64_t v24 = 0;
      uint64_t v25 = 22;
      goto LABEL_12;
    }
    if ((v9 & 0xC00) == 0x800)
    {
      log_err((uint64_t)"%s:%d: conflicting mount options: is_system_graft but not is_graft\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"nx_mount");
      goto LABEL_11;
    }
    unint64_t v295 = a3;
    char v293 = v9 & 1;
    int v18 = (v9 >> 1) & 1;
    int8x8_t __n = (int8x8_t)vtst_s16(v12, (int16x4_t)0x2000100001000004);
    int v296 = (v9 >> 5) & 1;
    int v19 = (v9 >> 9) & 1;
    BOOL v27 = (v9 & 0xC00) != 0;
    int v298 = (v9 >> 11) & 1;
    crc32c_init();
    BOOL v17 = v27;
    if (v22) {
      int v28 = 16;
    }
    else {
      int v28 = 32;
    }
    int v20 = (v28 | (2 * v11)) ^ 2;
    uint64_t v29 = v10;
    char v16 = v293;
    uint64_t v21 = v29;
  }
  else
  {
    unint64_t v295 = a3;
    crc32c_init();
    int v11 = 0;
    char v16 = 0;
    int v296 = 0;
    BOOL v17 = 0;
    int v298 = 0;
    int v18 = 0;
    LOBYTE(v14) = 0;
    int v19 = 0;
    uint64_t v15 = 0;
    int8x8_t __n = 0;
    int v20 = 34;
    uint64_t v21 = 0xFFFFFFFFLL;
  }
  unsigned int v305 = 0;
  unint64_t v304 = 0;
  unsigned int v303 = 0;
  uint64_t v30 = a1;
  BOOL v31 = v17;
  uint64_t v32 = nx_dev_init(v30, v15, v20, v18, v17, 0, v14, &v310, &v307);
  if (v32)
  {
    uint64_t v25 = v32;
    if (v32 != 79) {
      log_err((uint64_t)"%s:%d: device initialization failed: %d\n", v33, v34, v35, v36, v37, v38, v39, (uint64_t)"nx_mount");
    }
    return v25;
  }
  BOOL v288 = v31;
  char v294 = v16;
  uint64_t v41 = v310;
  if (dev_is_writable(v310)) {
    int v42 = v11;
  }
  else {
    int v42 = 1;
  }
  int v290 = v42;
  int is_external = dev_is_external(v41);
  unsigned int v51 = dev_real_block_size(v41);
  uint64_t v52 = v307;
  size_t v53 = v307[9];
  BOOL v54 = v19 == 0;
  if (v19) {
    unsigned int v55 = 128;
  }
  else {
    unsigned int v55 = 0x8000;
  }
  if (v54) {
    int v56 = 0x10000;
  }
  else {
    int v56 = 128;
  }
  log_debug((uint64_t)"%s:%d: %s initializing cache w/hash_size %u and cache size %u\n", v44, v45, v46, v47, v48, v49, v50, (uint64_t)"nx_mount");
  unsigned int v57 = v56;
  unsigned int v23 = v53;
  uint64_t v58 = obj_cache_create(v55, v57, v53, &v309);
  if (v58)
  {
    uint64_t v66 = v58;
    log_err((uint64_t)"%s:%d: %s object cache initialization failed: %d\n", v59, v60, v61, v62, v63, v64, v65, (uint64_t)"nx_mount");
    uint64_t v24 = 0;
    uint64_t v25 = v66;
    goto LABEL_12;
  }
  uint64_t v67 = (uint64_t)v52;
  uint64_t v68 = v309;
  if (v298) {
    *(void *)&v309[14].__opaque[16] = 1;
  }
  memset((char *)&v311[3] + 8, 0, 40);
  *(_OWORD *)((char *)&v311[2] + 8) = 0u;
  memset((char *)v311 + 8, 0, 32);
  *(void *)&v311[0] = __PAIR64__(v53, v51);
  *((void *)&v311[0] + 1) = v52[5];
  *((void *)&v311[1] + 1) = v41;
  *(void *)&int v311[2] = 1;
  DWORD2(v311[2]) = v290;
  HIDWORD(v311[2]) = is_external != 0;
  v311[3] = vmovl_u16((uint16x4_t)vand_s8(__n, (int8x8_t)0x1000100010001));
  uint64_t bootstrap = obj_create_bootstrap(v68, 0x80000000, 1uLL, (unsigned int *)&nx_desc, (uint64_t)v311, v53, 1, (uint64_t *)&v308);
  uint64_t v77 = v21;
  if (bootstrap)
  {
    uint64_t v25 = bootstrap;
    log_err((uint64_t)"%s:%d: %s object cache bootstrap failed: %d\n", v70, v71, v72, v73, v74, v75, v76, (uint64_t)"nx_mount");
LABEL_45:
    uint64_t v24 = 0;
    goto LABEL_12;
  }
  uint64_t v78 = v308;
  if (v296) {
    *((unsigned char *)v308 + 642) = 1;
  }
  memcpy((void *)v78[47], v52, v53);
  uint64_t v79 = (int64x2_t *)v309;
  uint64_t v80 = v308[47];
  *(void *)v309[6].__opaque = v308;
  v79[25].i64[0] = *(void *)(v80 + 88);
  __strlcpy_chk();
  obj_mem_mgr_register((int64x2_t *)v309, v288 & (v298 ^ 1));
  unint64_t v309 = 0;
  uint64_t v310 = 0;
  int v81 = *(_DWORD *)(v80 + 104);
  if (v81 < 0
    && (uint64_t v25 = nx_metadata_fragmented_sanity_check((uint64_t)v308, *(void *)(v80 + 112), v81 & 0x7FFFFFFF), v25)
    || (int v82 = *(_DWORD *)(v80 + 108), v82 < 0)
    && (uint64_t v25 = nx_metadata_fragmented_sanity_check((uint64_t)v308, *(void *)(v80 + 120), v82 & 0x7FFFFFFF), v25))
  {
    log_err((uint64_t)"%s:%d: %s fragmented checkpoint area failed sanity check: %d\n", v210, v211, v212, v213, v214, v215, v216, (uint64_t)"nx_mount");
    goto LABEL_45;
  }
  uint64_t v24 = _apfs_malloc(v53);
  if (!v24)
  {
    log_err((uint64_t)"%s:%d: %s failed to allocate buffer for checkpoint superblock\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
    uint64_t v25 = 12;
    goto LABEL_12;
  }
  __int8 v90 = __n.i8[2];
  if ((*(unsigned char *)(v80 + 1264) & 2) == 0) {
    goto LABEL_55;
  }
  uint64_t v91 = v308;
  *((unsigned char *)v308 + 626) = 1;
  if (*((unsigned char *)v91 + 628))
  {
    log_err((uint64_t)"%s:%d: %s storage is untrusted. Container cleanly-unmounted flag ignored\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
  }
  else if (*(_DWORD *)(v80 + 140))
  {
    if (*(_DWORD *)(v80 + 148)) {
      goto LABEL_55;
    }
    log_err((uint64_t)"%s:%d: %s checkpoint data length is bad.  Container cleanly-unmounted flag ignored\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
  }
  else
  {
    log_err((uint64_t)"%s:%d: %s checkpoint descriptor length is bad.  Container cleanly-unmounted flag ignored\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
  }
  *(void *)(v80 + 1264) &= ~2uLL;
  v52[158] &= ~2uLL;
  __int8 v90 = __n.i8[2];
LABEL_55:
  int v299 = 0;
  uint64_t __na = v53;
  char v92 = 0;
  int v297 = 0;
  __int8 v289 = v90;
  char v291 = 0;
  while ((*(unsigned char *)(v80 + 1264) & 2) == 0)
  {
    if (((*((unsigned char *)v308 + 633) != 0) & v92) != 0)
    {
      int v93 = 1;
      goto LABEL_60;
    }
    uint64_t highest_xid = nx_checkpoint_find_highest_xid((uint64_t)v308, (int *)&v303, &v304);
    if (highest_xid)
    {
      uint64_t v25 = highest_xid;
      log_err((uint64_t)"%s:%d: %s failed to scan checkpoint descriptor area for largest xid: %d\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
      goto LABEL_145;
    }
LABEL_64:
    if ((v77 & 0x80000000) == 0)
    {
      uint64_t v97 = v77;
      uint64_t v98 = (const void *)v67;
      goto LABEL_73;
    }
    uint64_t v100 = (const void *)v67;
    uint64_t valid_checkpoint = nx_checkpoint_find_valid_checkpoint((uint64_t)v308, v67, v303, (uint64_t)v24, &v305);
    uint64_t v25 = valid_checkpoint;
    if (valid_checkpoint == 35)
    {
      if ((*(unsigned char *)(v80 + 1264) & 2) == 0) {
        goto LABEL_122;
      }
      log_err((uint64_t)"%s:%d: %s Couldn't load checkpoint from cleanly-unmounted state.  Falling back to descriptor scan.\n", v102, v103, v104, v105, v106, v107, v108, (uint64_t)"nx_mount");
      *(void *)(v80 + 1264) &= ~2uLL;
      *(void *)(v67 + 1264) &= ~2uLL;
    }
    else
    {
      if (valid_checkpoint)
      {
LABEL_122:
        log_err((uint64_t)"%s:%d: %s failed to find valid checkpoint: %d\n", v102, v103, v104, v105, v106, v107, v108, (uint64_t)"nx_mount");
        goto LABEL_145;
      }
      uint64_t v292 = v24[2];
      log_debug((uint64_t)"%s:%d: %s checkpoint search: largest xid %lld, best xid %lld @ %d\n", v102, v103, v104, v105, v106, v107, v108, (uint64_t)"nx_mount");
      uint64_t v116 = v308;
      if (*(void *)(v67 + 16) != v24[2])
      {
        log_err((uint64_t)"%s:%d: %s reloading after unclean unmount, checkpoint xid %lld, superblock xid %lld\n", v109, v110, v111, v112, v113, v114, v115, (uint64_t)"nx_mount");
        uint64_t v116 = v308;
        if (!*((unsigned char *)v308 + 633))
        {
          char v291 = 1;
          *((unsigned char *)v308 + 645) = 1;
        }
      }
LABEL_111:
      if (*(void *)(v116[47] + 56))
      {
        log_debug((uint64_t)"%s:%d: %s unsupported nx_readonly_compatible_features (0x%llx): mount r/o\n", v109, v110, v111, v112, v113, v114, v115, (uint64_t)"nx_mount");
        uint64_t v116 = v308;
        *((unsigned char *)v308 + 627) = 1;
      }
      obj_checkpoint_check_for_unknown(v116[49]);
      uint64_t v208 = v308;
      if (((*((unsigned char *)v308 + 633) != 0) & v92) != 0)
      {
        int v209 = 1;
      }
      else
      {
        int v297 = *((_DWORD *)v24 + 36);
        int v299 = *((_DWORD *)v24 + 34);
        log_debug((uint64_t)"%s:%d: %s stable checkpoint indices: desc %d data %d\n", v201, v202, v203, v204, v205, v206, v207, (uint64_t)"nx_mount");
        uint64_t v208 = v308;
        int v209 = *((unsigned __int8 *)v308 + 633);
      }
      if ((v209 == 0) | v92 & 1)
      {
        *(void *)(v80 + 136) = 0;
        *(void *)(v80 + 144) = 0;
        *(void *)(v80 + 1264) &= ~2uLL;
        nx_metadata_range_optimize(v208);
        uint64_t v218 = v308;
        if (*((unsigned char *)v308 + 629))
        {
          uint64_t v25 = spaceman_get(v308, &v306);
          if (v25)
          {
LABEL_136:
            log_err((uint64_t)"%s:%d: %s failed to set up spaceman for demo mode: %d\n", v219, v220, v221, v222, v223, v224, v225, (uint64_t)"nx_mount");
            goto LABEL_145;
          }
          uint64_t v226 = (pthread_mutex_t *)v308[49];
          if (!v226) {
            sub_100060DA4();
          }
          obj_cache_lock_write(v226);
          uint64_t v227 = v308 + 52;
          v308[52] = 0;
          uint64_t v25 = obj_clone(v306, 0, v227, 0, v228, v229, v230, v231);
          obj_cache_unlock_write(v308[49]);
          if (v25)
          {
            obj_release((uint64_t *)v306);
            goto LABEL_136;
          }
          obj_ephemeral_set_persistent(v308[52], 0);
          obj_release((uint64_t *)v306);
          uint64_t v218 = v308;
        }
        uint64_t v25 = tx_mgr_init((uint64_t)v218, v292 + 1, v218 + 50);
        uint64_t v239 = v308;
        if (v25)
        {
          log_err((uint64_t)"%s:%d: %s tx manager initialization failed: %d\n", v232, v233, v234, v235, v236, v237, v238, (uint64_t)"nx_mount");
          goto LABEL_145;
        }
        uint64_t v240 = v308[50];
        *(_DWORD *)(v240 + 104) = v299;
        *(_DWORD *)(v240 + 108) = v297;
        if ((v294 & 1) == 0)
        {
          log_info((uint64_t)"%s:%d: %s sanity checking all container state... please be patient.\n", v232, v233, v234, v235, v236, v237, v238, (uint64_t)"nx_mount");
          uint64_t v25 = nx_check(v308, 0);
          uint64_t v239 = v308;
          if (v25)
          {
            log_err((uint64_t)"%s:%d: %s failed nx_check sanity: %d\n", v232, v233, v234, v235, v236, v237, v238, (uint64_t)"nx_mount");
            goto LABEL_145;
          }
        }
        if (*((unsigned char *)v239 + 627))
        {
LABEL_179:
          _apfs_free(v24, __na);
          __int16 v280 = v308;
          if (*(void *)(v308[47] + 1248))
          {
            if (!*((unsigned char *)v308 + 627))
            {
              uint64_t v25 = nx_unblock_physical_range(v308);
              __int16 v280 = v308;
              if (v25)
              {
                log_err((uint64_t)"%s:%d: %s nx_unblock_physical_range failed with error: %d\n", v281, v282, v283, v284, v285, v286, v287, (uint64_t)"nx_mount");
                uint64_t v24 = 0;
                goto LABEL_145;
              }
            }
          }
          *unint64_t v295 = v280;
          if (v307) {
            _apfs_free(v307, v307[9]);
          }
          return 0;
        }
        if (*((unsigned char *)v239 + 633)
          || *((unsigned char *)v239 + 632)
          && (log_info((uint64_t)"%s:%d: %s Enabling temporary checkpoints starting with xid %lld.\n", v232, v233, v234, v235, v236, v237, v238, (uint64_t)"nx_mount"), uint64_t v239 = v308, *(void *)(v308[47] + 1408) = v292 + 1, *((unsigned char *)v239 + 633)))
        {
          if (!*((unsigned char *)v239 + 632))
          {
            log_info((uint64_t)"%s:%d: %s Making temporary checkpoint %lld permanent (start %lld).\n", v232, v233, v234, v235, v236, v237, v238, (uint64_t)"nx_mount");
            v24[176] = 0;
            obj_checksum_set_phys((uint64_t)v308, v24, v53, v241, v242);
            uint64_t v249 = v302;
            if (v302)
            {
              uint64_t v25 = dev_write(v308[48], v302);
              if (!v25)
              {
                uint64_t v25 = tx_barrier((uint64_t)v308, 0x10u);
                if (!v25)
                {
                  uint64_t v239 = v308;
                  *(void *)(v308[47] + 1408) = 0;
                  char v291 = 1;
                  goto LABEL_168;
                }
              }
            }
            else
            {
              uint64_t v25 = 22;
            }
            log_err((uint64_t)"%s:%d: %s failed to write superblock to block %lld: %d\n", v249, v243, v244, v245, v246, v247, v248, (uint64_t)"nx_mount");
            goto LABEL_145;
          }
        }
LABEL_168:
        if (spaceman_allocation_init(v239)) {
          log_err((uint64_t)"%s:%d: %s failed to set up sm allocation metadata: %d\n", v250, v251, v252, v253, v254, v255, v256, (uint64_t)"nx_mount");
        }
        uint64_t v259 = v308;
        if (v291)
        {
          obj_checksum_set((uint64_t)v308, v257, v258);
          uint64_t v260 = dev_write(v308[48], 0);
          uint64_t v259 = v308;
          if (v260)
          {
            uint64_t v25 = v260;
            log_err((uint64_t)"%s:%d: %s failed to write superblock to block 0: %d\n", v261, v262, v263, v264, v265, v266, v267, (uint64_t)"nx_mount");
            goto LABEL_145;
          }
          size_t v268 = (unsigned char *)v308[47];
          if (v268[65])
          {
            uint64_t v269 = nx_fusion_superblock_write((uint64_t)v308, v268);
            uint64_t v259 = v308;
            if (v269)
            {
              uint64_t v25 = v269;
              log_err((uint64_t)"%s:%d: %s failed to write superblock to fusion tier2 device block 0: %d\n", v270, v271, v272, v273, v274, v275, v276, (uint64_t)"nx_mount");
              goto LABEL_145;
            }
          }
        }
        uint64_t v277 = v259[47];
        unint64_t v278 = *(void *)(v277 + 1384);
        unint64_t v279 = apfs_source_version_val_full();
        if (v278 < v279) {
          *(void *)(v277 + 1384) = v279;
        }
        sub_100056628(v259);
        nx_reaper_check_for_work(v308);
        goto LABEL_179;
      }
      nx_obj_cache_reset((uint64_t)v208);
      memcpy((void *)v308[47], v100, v53);
      char v92 = 1;
    }
  }
  log_info((uint64_t)"%s:%d: %s container cleanly-unmounted flag set.\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
  int v93 = *((unsigned __int8 *)v308 + 633);
LABEL_60:
  unsigned int v94 = *(_DWORD *)(v80 + 136) + *(_DWORD *)(v80 + 140) - 1;
  unsigned int v95 = *(_DWORD *)(v80 + 104) & 0x7FFFFFFF;
  uint64_t v96 = v94 % v95;
  unsigned int v303 = v94 % v95;
  unint64_t v304 = *(void *)(v80 + 16);
  if (v93 == 0 || (v92 & 1) == 0) {
    goto LABEL_64;
  }
  log_info((uint64_t)"%s:%d: %s Attempting to load from temporary checkpoint (start xid %lld).\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
  uint64_t v97 = v96;
  uint64_t v98 = (const void *)v67;
  if (!*(void *)(v80 + 1408))
  {
    log_err((uint64_t)"%s:%d: %s No temporary checkpoint start xid!  Aborting!\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
    uint64_t v25 = 100;
LABEL_145:
    unsigned int v23 = __na;
    goto LABEL_12;
  }
LABEL_73:
  if (v97 >= (*(_DWORD *)(v80 + 104) & 0x7FFFFFFFu))
  {
    log_err((uint64_t)"%s:%d: %s checkpoint descriptor index %d out of range [0...%d]\n", v83, v84, v85, v86, v87, v88, v89, (uint64_t)"nx_mount");
    uint64_t v217 = v308;
LABEL_144:
    uint64_t v25 = nx_corruption_detected_int((uint64_t)v217);
    goto LABEL_145;
  }
  uint64_t v77 = v97;
  uint64_t v117 = nx_checkpoint_desc_block_address((uint64_t)v308, v97, &v302);
  if (v117)
  {
    uint64_t v25 = v117;
LABEL_139:
    log_err((uint64_t)"%s:%d: %s couldn't read checkpoint descriptor block %d @ %lld: %d\n", v118, v119, v120, v121, v122, v123, v124, (uint64_t)"nx_mount");
    goto LABEL_12;
  }
  uint64_t v125 = dev_read(v308[48], v302);
  uint64_t v25 = v125;
  if (*((unsigned char *)v308 + 633))
  {
    if (!v125 && v53)
    {
      uint64_t v128 = 0;
      while (!*((unsigned char *)v24 + v128))
      {
        if (v53 == ++v128)
        {
          uint64_t v25 = 0;
          goto LABEL_83;
        }
      }
      log_err((uint64_t)"%s:%d: %s Attempt to load temporary checkpoint found unexpected data (0x%02x @ %d), checkpoint descriptor block %d @ %lld\n", v118, v119, v120, v121, v122, v123, v124, (uint64_t)"nx_mount");
      uint64_t v25 = 22;
    }
LABEL_83:
    memcpy(v24, v98, v53);
    obj_checksum_set_phys((uint64_t)v308, v24, v53, v129, v130);
  }
  if (v25) {
    goto LABEL_139;
  }
  if (*((_DWORD *)v24 + 7) || *((_DWORD *)v24 + 6) != -2147483647)
  {
    log_err((uint64_t)"%s:%d: %s checkpoint descriptor block %d is not a valid superblock\n", v118, v119, v120, v121, v122, v123, v124, (uint64_t)"nx_mount");
    uint64_t v217 = v308;
    goto LABEL_144;
  }
  unint64_t v131 = nx_check_superblock((uint64_t)v24, *(_DWORD *)(v80 + 36), 1, v126, v127);
  if (v131)
  {
    uint64_t v25 = v131;
    log_err((uint64_t)"%s:%d: %s checkpoint descriptor block %d superblock failed sanity checks: %d\n", v132, v133, v134, v135, v136, v137, v138, (uint64_t)"nx_mount");
    goto LABEL_145;
  }
  if ((*(void *)(v80 + 64) & 0xFFFFFFFFFFFFFEFDLL) != 0)
  {
    log_err((uint64_t)"%s:%d: %s unsupported nx_incompatible_features (0x%llx): unable to mount\n", v132, v133, v134, v135, v136, v137, v138, (uint64_t)"nx_mount");
    uint64_t v25 = 75;
    goto LABEL_145;
  }
  uint64_t v100 = (const void *)v67;
  if (!nx_superblock_agrees_with_main_superblock(v67, (uint64_t)v24, (uint64_t)"checkpoint", 0, v135, v136, v137, v138))
  {
    log_err((uint64_t)"%s:%d: %s checkpoint descriptor block %d doesn't agree with main superblock\n", v139, v140, v141, v142, v143, v144, v145, (uint64_t)"nx_mount");
    uint64_t v25 = 22;
    goto LABEL_145;
  }
  if (v77 != (*((_DWORD *)v24 + 34) + *((_DWORD *)v24 + 35) - 1) % (*(_DWORD *)(v80 + 104) & 0x7FFFFFFFu))
  {
    log_err((uint64_t)"%s:%d: %s checkpoint superblock index %d doesn't match index block was found at: %d\n", v139, v140, v141, v142, v143, v144, v145, (uint64_t)"nx_mount");
    uint64_t v217 = v308;
    goto LABEL_144;
  }
  uint64_t v146 = nx_metadata_range_add((uint64_t)v308, 0, 1, 0, 1);
  if (v146
    || (*((unsigned char *)v24 + 65) & 1) != 0
    && ((uint64_t v146 = nx_metadata_range_add((uint64_t)v308, 0x4000000000000000uLL >> __clz(__rbit64(*(unsigned int *)(v308[47] + 36))), 1, 0, 1), v146)|| (*((unsigned char *)v24 + 65) & 1) != 0&& (uint64_t v146 = nx_metadata_range_add((uint64_t)v308, *(void *)(v308[47] + 1368), *(void *)(v308[47] + 1376) & 0x7FFFFFFF, (*(void *)(v308[47] + 1376) & 0x80000000) != 0, 0), v146))|| (uint64_t v146 = nx_metadata_range_add((uint64_t)v308, v24[14], v24[13] & 0x7FFFFFFF, *((int *)v24 + 26) < 0, 0), v146)|| (uint64_t v146 = nx_metadata_range_add((uint64_t)v308, v24[15],
                 *((_DWORD *)v24 + 27) & 0x7FFFFFFF,
                 *((int *)v24 + 27) < 0,
                 0),
        v146))
  {
    uint64_t v25 = v146;
    log_err((uint64_t)"%s:%d: %s xid %lld at index %d failed to load checkpoint metadata ranges (overlap?): %d\n", v147, v148, v149, v150, v151, v152, v153, (uint64_t)"nx_mount");
    goto LABEL_12;
  }
  uint64_t v154 = sub_100054730((uint64_t)v308, (unsigned int *)v24);
  if (v154)
  {
    uint64_t v25 = v154;
    log_err((uint64_t)"%s:%d: %s validation failed for checkpoint at index %d: %d\n", v155, v156, v157, v158, v159, v160, v161, (uint64_t)"nx_mount");
    goto LABEL_145;
  }
  unsigned int v305 = v77;
  uint64_t v292 = v24[2];
  log_debug((uint64_t)"%s:%d: %s checkpoint: largest xid %lld, given checkpoint xid %lld @ %d\n", v155, v156, v157, v158, v159, v160, v161, (uint64_t)"nx_mount");
  uint64_t v169 = v308;
  if (*(void *)(v67 + 16) != v24[2])
  {
    log_err((uint64_t)"%s:%d: %s loading older checkpoint, checkpoint xid %lld, superblock xid %lld\n", v162, v163, v164, v165, v166, v167, v168, (uint64_t)"nx_mount");
    uint64_t v169 = v308;
    char v291 = 1;
    *((unsigned char *)v308 + 645) = 1;
  }
  uint64_t v170 = sub_100054834((uint64_t)v169, (uint64_t)v24, 0, 0);
  if (v170)
  {
    uint64_t v25 = v170;
    log_err((uint64_t)"%s:%d: %s data for checkpoint at index %d couldn't be loaded: %d\n", v171, v172, v173, v174, v175, v176, v177, (uint64_t)"nx_mount");
    goto LABEL_145;
  }
  memcpy((void *)v308[47], v24, v53);
  uint64_t v178 = v308;
  *(void *)(v308[49] + 400) = *(void *)(v308[47] + 88);
  uint64_t v25 = nx_checkpoint_traverse((uint64_t)v178, 0, 2);
  uint64_t v186 = v308;
  if (v25)
  {
    log_err((uint64_t)"%s:%d: %s failed to fix up checkpoint data: %d\n", v179, v180, v181, v182, v183, v184, v185, (uint64_t)"nx_mount");
    goto LABEL_145;
  }
  if (*((unsigned char *)v308 + 628))
  {
    if (v289)
    {
      log_info((uint64_t)"%s:%d: %s probe of external device... skipping recent sanity checks.\n", v179, v180, v181, v182, v183, v184, v185, (uint64_t)"nx_mount");
      uint64_t v186 = v308;
    }
    else
    {
      log_info((uint64_t)"%s:%d: %s sanity checking all recently-changed container state... please be patient.\n", v179, v180, v181, v182, v183, v184, v185, (uint64_t)"nx_mount");
      uint64_t v25 = nx_check_recent_sanity(v308);
      uint64_t v186 = v308;
      if (v25)
      {
        log_err((uint64_t)"%s:%d: %s sanity check of recently-changed structures failed: %d\n", v187, v188, v189, v190, v191, v192, v193, (uint64_t)"nx_mount");
        goto LABEL_145;
      }
    }
  }
  uint64_t v25 = spaceman_get(v186, &v306);
  if (v25)
  {
    log_err((uint64_t)"%s:%d: %s checkpoint xid %lld failed to get spaceman: %d\n", v194, v195, v196, v197, v198, v199, v200, (uint64_t)"nx_mount");
    goto LABEL_145;
  }
  uint64_t v25 = nx_metadata_range_add((uint64_t)v308, *(void *)&v306[47][3].__opaque[16], *(_DWORD *)&v306[47][3].__opaque[12] & 0x7FFFFFFF, *(int *)&v306[47][3].__opaque[12] < 0, 0);
  if (!v25)
  {
    uint64_t v25 = nx_metadata_range_add((uint64_t)v308, *(void *)&v306[47][3].__opaque[24], *(void *)v306[47][3].__opaque, *(uint64_t *)v306[47][3].__opaque < 0, 0);
    obj_release((uint64_t *)v306);
    if (v25) {
      goto LABEL_151;
    }
    uint64_t v116 = v308;
    goto LABEL_111;
  }
  obj_release((uint64_t *)v306);
LABEL_151:
  log_err((uint64_t)"%s:%d: %s checkpoint xid %lld failed to load spaceman metadata ranges (overlap?): %d\n", v109, v110, v111, v112, v113, v114, v115, (uint64_t)"nx_mount");
LABEL_12:
  if (v307) {
    _apfs_free(v307, v307[9]);
  }
  if (v24) {
    _apfs_free(v24, v23);
  }
  uint64_t v26 = v308;
  if (v308)
  {
    *((unsigned char *)v308 + 627) = 1;
    nx_unmount((uint64_t)v26);
  }
  if (v309) {
    obj_cache_destroy((uint64_t)v309);
  }
  if (v310) {
    dev_close(v310);
  }
  return v25;
}

void sub_100056628(void *a1)
{
  if (spaceman_scan_free_blocks(a1, 0, 1)) {
    log_err((uint64_t)"%s:%d: %s *** trim'ing free blocks returned: %d\n", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"nx_mount_initiate_free_space_trims");
  }

  spaceman_free_extent_cache_print_stats(a1);
}

void nx_unmount(uint64_t a1)
{
  nx_reaper_shut_down((void *)a1);
  uint64_t v7 = *(void *)(a1 + 400);
  if (v7)
  {
    if (!*(unsigned char *)(a1 + 627))
    {
      tx_unmount(a1);
      uint64_t v7 = *(void *)(a1 + 400);
    }
    tx_mgr_destroy(a1, v7, *(unsigned int *)(*(void *)(a1 + 376) + 36), v2, v3, v4, v5, v6);
  }
  uint64_t v8 = *(uint64_t **)(a1 + 408);
  if (v8)
  {
    obj_release(v8);
    *(void *)(a1 + 408) = 0;
  }
  for (uint64_t i = 0; i != 32; i += 8)
  {
    uint64_t v10 = *(uint64_t **)(a1 + 432 + i);
    if (v10) {
      obj_release(v10);
    }
  }
  uint64_t v11 = *(void *)(a1 + 464);
  if (v11)
  {
    btree_delete(v11, 0, 0);
    obj_release(*(uint64_t **)(a1 + 464));
  }
  uint64_t v12 = *(void *)(a1 + 1824);
  if (v12)
  {
    btree_delete(v12, 0, 0);
    obj_release(*(uint64_t **)(a1 + 1824));
    *(void *)(a1 + 1824) = 0;
  }
  uint64_t v13 = *(void *)(a1 + 384);
  if (v13) {
    dev_close(v13);
  }
  uint64_t v14 = *(void *)(a1 + 392);
  if (v14)
  {
    obj_cache_destroy(v14);
  }
}

void log_debug(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (apfs_log_level >= 5) {
    appexPrint((uint64_t)&a9, a1);
  }
}

void log_info(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (apfs_log_level >= 4) {
    appexPrint((uint64_t)&a9, a1);
  }
}

void log_warn(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (apfs_log_level >= 3) {
    appexPrint((uint64_t)&a9, a1);
  }
}

void log_err(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (apfs_log_level >= 2) {
    appexPrint((uint64_t)&a9, a1);
  }
}

void log_corrupt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (apfs_log_level >= 1) {
    appexPrint((uint64_t)&a9, a2);
  }
}

uint64_t nx_format(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v195 = 0;
  uint64_t v196 = 0;
  uint64_t v193 = 0;
  uint64_t v194 = 0;
  *a4 = 0;
  if (a2)
  {
    uint64_t v7 = *(unsigned int *)(a2 + 16);
    int v8 = *(_DWORD *)(a2 + 20);
    unsigned int v9 = *(unsigned __int8 *)(a2 + 34);
    __int16 v10 = *(_WORD *)(a2 + 32);
    int v11 = v10 & 3;
    if ((v10 & 3) == 0)
    {
      *(_WORD *)(a2 + 32) = v10 & 0xFFFC | 1;
      int v11 = 1;
    }
    BOOL v12 = v11 == 2;
  }
  else
  {
    unsigned int v9 = 0;
    uint64_t v7 = 0;
    BOOL v12 = 0;
    int v8 = 1073741826;
  }
  uint64_t v199 = 0;
  long long v198 = 0u;
  memset(v197, 0, sizeof(v197));
  long long v200 = 0u;
  long long v201 = 0u;
  memset(v202, 0, 64);
  uint64_t v191 = 0;
  uint64_t v192 = 0;
  uint64_t v190 = 0;
  crc32c_init();
  uint64_t v13 = fskit_dev_init(*(void *)(a2 + 48), 2, &v195);
  if (v13)
  {
    uint64_t v188 = v13;
    strerror(v13);
    log_err((uint64_t)"%s:%d: device initialization failed: %d - %s\n", v14, v15, v16, v17, v18, v19, v20, (uint64_t)"nx_format");
    uint64_t v26 = v188;
    goto LABEL_8;
  }
  if (!dev_is_writable(v195))
  {
    log_err((uint64_t)"%s:%d: error: device is not writable!\n", v29, v30, v31, v32, v33, v34, v35, (uint64_t)"nx_format");
    uint64_t v26 = 30;
    goto LABEL_8;
  }
  unsigned int v36 = dev_block_size(v195);
  uint64_t v37 = dev_block_count(v195);
  if (*(void *)(a2 + 24))
  {
    log_err((uint64_t)"%s:%d: apfs.appex doesn't support fusion\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"nx_format");
    uint64_t v26 = 45;
    goto LABEL_8;
  }
  unint64_t v45 = v37;
  if (!v7)
  {
    unint64_t v46 = v37 * v36;
    if (v46 >> 50) {
      int v47 = 0x4000;
    }
    else {
      int v47 = 4096;
    }
    if (v46 >> 59) {
      unsigned int v48 = 0x10000;
    }
    else {
      unsigned int v48 = v47;
    }
    if (v36 <= v48) {
      uint64_t v7 = v48;
    }
    else {
      uint64_t v7 = v36;
    }
  }
  if ((int)v7 <= 4095)
  {
    log_warn((uint64_t)"%s:%d: warning: fs block size too small (%d < %d)\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"nx_format");
LABEL_34:
    uint64_t v26 = 22;
    goto LABEL_8;
  }
  if (v7 < v36)
  {
    log_warn((uint64_t)"%s:%d: warning: fs block size too small for device block size (%d < %d)\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"nx_format");
    goto LABEL_34;
  }
  unint64_t v49 = v7 / v36;
  if (v7 % v36)
  {
    log_err((uint64_t)"%s:%d: error: block size %d is not an even multiple of device block size %d\n", v38, v39, v40, v41, v42, v43, v44, (uint64_t)"nx_format");
    goto LABEL_34;
  }
  if (v7 > v36)
  {
    dev_set_block_size(v195);
    unint64_t v49 = v7 / v36;
  }
  unint64_t v50 = v45 / v49;
  uint64_t v51 = nx_calculate_metadata_parameters(v7, v50, 0, v9, (uint64_t)v197);
  if (v51)
  {
    uint64_t v52 = v51;
    strerror(v51);
    log_err((uint64_t)"%s:%d: metadata space calculation failed: %d - %s\n", v53, v54, v55, v56, v57, v58, v59, (uint64_t)"nx_format");
LABEL_43:
    uint64_t v26 = v52;
    goto LABEL_8;
  }
  uint64_t v60 = obj_cache_create(0xC800u, 0xC350u, v7, &v196);
  if (v60)
  {
    uint64_t v52 = v60;
    strerror(v60);
    log_err((uint64_t)"%s:%d: object cache initialization failed: %d - %s\n", v61, v62, v63, v64, v65, v66, v67, (uint64_t)"nx_format");
    goto LABEL_43;
  }
  uint64_t v192 = 1;
  memset(&v202[1], 0, 56);
  *(void *)&long long v200 = __PAIR64__(v7, v36);
  *((void *)&v201 + 1) = v195;
  v202[0] = 1;
  *((void *)&v200 + 1) = v50;
  *(void *)&long long v201 = v12;
  if (uuid_is_null((const unsigned __int8 *)a2)) {
    uuid_generate((unsigned __int8 *)&v202[4]);
  }
  else {
    uuid_copy((unsigned __int8 *)&v202[4], (const unsigned __int8 *)a2);
  }
  uint64_t bootstrap = obj_create_bootstrap(v196, 0x80000000, 1uLL, (unsigned int *)&nx_desc, (uint64_t)&v200, v7, v192, (uint64_t *)&v194);
  if (bootstrap)
  {
    uint64_t v189 = bootstrap;
    strerror(bootstrap);
    log_err((uint64_t)"%s:%d: object cache bootstrap failed: %d - %s\n", v69, v70, v71, v72, v73, v74, v75, (uint64_t)"nx_format");
    uint64_t v26 = v189;
    goto LABEL_8;
  }
  uint64_t v76 = v194;
  *((unsigned char *)v194 + 624) = 1;
  uint64_t v77 = (int32x2_t *)v76[47];
  v77[22].i32[1] = v197[11].i32[2];
  v77[13] = vmovn_s64(*(int64x2_t *)((char *)&v197[10] + 8));
  v77[164] = (int32x2_t)((v198 << 16) | (*((void *)&v198 + 1) << 32) | 1);
  *((unsigned char *)v76 + 625) = a3 != 0;
  uint64_t v78 = v196;
  *(void *)v196[6].__opaque = v76;
  *(int32x2_t *)&v78[6].__opaque[8] = v77[11];
  uint64_t v79 = spaceman_create((uint64_t)v76, (uint64_t)v197, a3, v192, &v77[19]);
  if (v79)
  {
    uint64_t v26 = v79;
    strerror(v79);
    log_err((uint64_t)"%s:%d: spaceman initialization failed: %d - %s\n", v80, v81, v82, v83, v84, v85, v86, (uint64_t)"nx_format");
    goto LABEL_8;
  }
  uint64_t v87 = spaceman_get(v194, &v193);
  if (!v87)
  {
    if (spaceman_allocation_init(v194)) {
      log_err((uint64_t)"%s:%d: failed to set up sm allocation metadata: %d\n", v95, v96, v97, v98, v99, v100, v101, (uint64_t)"nx_format");
    }
    uint64_t v102 = tx_mgr_init((uint64_t)v194, v192, v194 + 50);
    if (v102)
    {
      uint64_t v26 = v102;
      strerror(v102);
      log_err((uint64_t)"%s:%d: tx manager initialization failed: %d - %s\n", v103, v104, v105, v106, v107, v108, v109, (uint64_t)"nx_format");
LABEL_60:
      obj_release(v193);
      goto LABEL_8;
    }
    uint64_t v192 = 0;
    uint64_t v110 = tx_enter((uint64_t)v194, &v192);
    if (v110)
    {
      uint64_t v26 = v110;
      strerror(v110);
      log_err((uint64_t)"%s:%d: tx_enter for initialization failed: %d - %s\n", v111, v112, v113, v114, v115, v116, v117, (uint64_t)"nx_format");
      goto LABEL_60;
    }
    uint64_t v118 = v194;
    uint64_t v119 = v194[47];
    if ((*(_DWORD *)(v119 + 104) & 0x80000000) != 0)
    {
      uint64_t v26 = nx_metadata_fragmented_extent_list_tree_store((uint64_t)v194, (uint64_t *)(v119 + 112), v192);
      if (v26) {
        goto LABEL_79;
      }
      uint64_t v118 = v194;
      uint64_t v119 = v194[47];
    }
    if ((*(_DWORD *)(v119 + 108) & 0x80000000) != 0)
    {
      uint64_t v26 = nx_metadata_fragmented_extent_list_tree_store((uint64_t)v118, (uint64_t *)(v119 + 120), v192);
      if (v26) {
        goto LABEL_79;
      }
      uint64_t v118 = v194;
    }
    uint64_t v120 = v193[47];
    if ((*(_DWORD *)(v120 + 164) & 0x80000000) != 0)
    {
      uint64_t v26 = nx_metadata_fragmented_extent_list_tree_store((uint64_t)v118, (uint64_t *)(v120 + 168), v192);
      if (v26) {
        goto LABEL_79;
      }
      uint64_t v118 = v194;
      uint64_t v120 = v193[47];
    }
    if ((*(void *)(v120 + 152) & 0x8000000000000000) == 0)
    {
LABEL_65:
      uint64_t v26 = nx_metadata_range_add((uint64_t)v118, 0, 1, 0, 1);
      if (v26
        || (uint64_t v26 = nx_metadata_range_add((uint64_t)v194, *(void *)(v194[47] + 112), *(_DWORD *)(v194[47] + 104) & 0x7FFFFFFF, *(int *)(v194[47] + 104) < 0, 0), v26)|| (uint64_t v26 = nx_metadata_range_add((uint64_t)v194, *(void *)(v194[47] + 120), *(_DWORD *)(v194[47] + 108) & 0x7FFFFFFF, *(int *)(v194[47] + 108) < 0, 0), v26)|| (uint64_t v26 = nx_metadata_range_add((uint64_t)v194, *(void *)(v193[47] + 168), *(_DWORD *)(v193[47] + 164) & 0x7FFFFFFF, *(int *)(v193[47] + 164) < 0, 0),
            v26))
      {
        obj_release(v193);
      }
      else
      {
        uint64_t v26 = nx_metadata_range_add((uint64_t)v194, *(void *)(v193[47] + 176), *(void *)(v193[47] + 152), *(uint64_t *)(v193[47] + 152) < 0, 0);
        obj_release(v193);
        if (!v26)
        {
          nx_metadata_range_optimize(v194);
          uint64_t v135 = tx_checkpoint_desc_zero(v194, *(_DWORD *)(v194[47] + 104) & 0x7FFFFFFF);
          if (v135)
          {
            uint64_t v26 = v135;
            strerror(v135);
            log_err((uint64_t)"%s:%d: tx checkpoint descriptor area initialization failed: %d - %s\n", v136, v137, v138, v139, v140, v141, v142, (uint64_t)"nx_format");
          }
          else
          {
            uint64_t v143 = obj_create((pthread_mutex_t *)v194[49], 0x80000000, 0, (unsigned int *)&nx_reaper_desc, 0, 0, v192, (uint64_t *)&v191);
            if (v143)
            {
              uint64_t v26 = v143;
              strerror(v143);
              log_err((uint64_t)"%s:%d: reaper initialization failed: %d - %s\n", v144, v145, v146, v147, v148, v149, v150, (uint64_t)"nx_format");
            }
            else
            {
              uint64_t v151 = obj_oid((uint64_t)v191);
              *(void *)(v194[47] + 168) = v151;
              obj_release(v191);
              uint64_t v152 = omap_create((pthread_mutex_t **)v194, 0x40000000u, 1u, v8, v192, &v190);
              if (!v152)
              {
                uint64_t v160 = obj_oid((uint64_t)v190);
                *(void *)(v194[47] + 160) = v160;
                obj_release(v190);
                uint64_t v161 = tx_leave((uint64_t)v194, v192, 0);
                if (v161)
                {
                  uint64_t v26 = v161;
                  strerror(v161);
                  log_err((uint64_t)"%s:%d: tx_leave for omap initialization failed: %d - %s\n", v162, v163, v164, v165, v166, v167, v168, (uint64_t)"nx_format");
                  goto LABEL_8;
                }
                uint64_t v169 = tx_finish((uint64_t)v194, 0);
                if (v169)
                {
                  uint64_t v26 = v169;
                  strerror(v169);
                  log_err((uint64_t)"%s:%d: failed to finish first transaction: %d - %s\n", v172, v173, v174, v175, v176, v177, v178, (uint64_t)"nx_format");
                  goto LABEL_8;
                }
                uint64_t v179 = v194;
                if (!*((unsigned char *)v194 + 625))
                {
                  obj_checksum_set((uint64_t)v194, v170, v171);
                  uint64_t v180 = dev_write(v194[48], 0);
                  if (v180)
                  {
                    uint64_t v26 = v180;
                    strerror(v180);
                    log_err((uint64_t)"%s:%d: failed to write superblock to block 0: %d - %s\n", v181, v182, v183, v184, v185, v186, v187, (uint64_t)"nx_format");
                    goto LABEL_8;
                  }
                  uint64_t v179 = v194;
                }
                uint64_t v26 = 0;
                *((unsigned char *)v179 + 624) = 0;
                *a4 = v179;
                return v26;
              }
              uint64_t v26 = v152;
              strerror(v152);
              log_err((uint64_t)"%s:%d: omap initialization failed: %d - %s\n", v153, v154, v155, v156, v157, v158, v159, (uint64_t)"nx_format");
            }
          }
LABEL_71:
          tx_leave((uint64_t)v194, v192, 0);
          goto LABEL_8;
        }
      }
      log_err((uint64_t)"%s:%d: failed load container metadata ranges (overlap?): %d\n", v121, v122, v123, v124, v125, v126, v127, (uint64_t)"nx_format");
      goto LABEL_71;
    }
    uint64_t v26 = nx_metadata_fragmented_extent_list_tree_store((uint64_t)v118, (uint64_t *)(v120 + 176), v192);
    if (!v26)
    {
      uint64_t v118 = v194;
      goto LABEL_65;
    }
LABEL_79:
    strerror(v26);
    log_err((uint64_t)"%s:%d: creation of fragmented metadata physical extent list tree(s) failed: %d - %s\n", v128, v129, v130, v131, v132, v133, v134, (uint64_t)"nx_format");
    obj_release(v193);
    goto LABEL_8;
  }
  uint64_t v26 = v87;
  log_err((uint64_t)"%s:%d: failed to get spaceman: %d\n", v88, v89, v90, v91, v92, v93, v94, (uint64_t)"nx_format");
LABEL_8:
  if (v194)
  {
    uint64_t v27 = v194[50];
    if (v27) {
      tx_mgr_destroy((uint64_t)v194, v27, v7, v21, v22, v23, v24, v25);
    }
  }
  if (v196) {
    obj_cache_destroy((uint64_t)v196);
  }
  if (v195) {
    dev_close(v195);
  }
  return v26;
}

void appexPrint(uint64_t a1, uint64_t a2)
{
  if (!qword_100084A88)
  {
    int v8 = fskit_std_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100060DD0(v8);
    }
    goto LABEL_12;
  }
  if (!*(void *)qword_100084A88)
  {
    int v8 = fskit_std_log();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR)) {
      sub_100060E54(v8);
    }
LABEL_12:

    return;
  }
  id v9 = *(id *)qword_100084A88;
  id v4 = objc_alloc((Class)NSString);
  uint64_t v5 = +[NSString stringWithUTF8String:a2];
  id v6 = [v4 initWithFormat:v5 arguments:a1];

  if ([v6 hasSuffix:@"\n"])
  {
    uint64_t v7 = objc_msgSend(v6, "substringToIndex:", (char *)objc_msgSend(v6, "length") - 1);

    id v6 = (id)v7;
  }
  [v9 logMessage:v6];
}

void sub_1000575F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100057608(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100057618(uint64_t a1)
{
}

void sub_100057620(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    id v6 = fskit_std_log();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR)) {
      sub_100060F74((uint64_t)v5, v6);
    }

    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    id v8 = v5;
    id v9 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v8;
LABEL_9:

    goto LABEL_10;
  }
  if (*(void *)(a1 + 40) != a2)
  {
    __int16 v10 = fskit_std_log();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
      sub_100060ED8((uint64_t *)(a1 + 40), a2, v10);
    }

    uint64_t v11 = fs_errorForPOSIXError();
    uint64_t v12 = *(void *)(*(void *)(a1 + 32) + 8);
    id v9 = *(void **)(v12 + 40);
    *(void *)(v12 + 40) = v11;
    goto LABEL_9;
  }
LABEL_10:
}

uint64_t sub_100058234()
{
  return 8;
}

uint64_t sub_10005823C(uint64_t result)
{
  int v1 = *(_DWORD *)(result + 120);
  if ((v1 & 0x20) == 0)
  {
    uint64_t v2 = result;
    if (*(void *)(result + 8) == 0xAA11000064C0C6EBLL && *(void *)(result + 16) == 0xACEC4365300011AALL)
    {
      uint64_t result = fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s personal recovery key%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "fv_kek_global_policy_eval");
    }
    else if (*(void *)(result + 8) == 0xD64E18B6D92A1CECLL && *(void *)(result + 16) == 0x775C261F3508DBDLL)
    {
      uint64_t result = fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s icloud recovery key%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "fv_kek_global_policy_eval");
    }
    else
    {
      if (*(void *)(result + 8) != 0xE74DFFBA0014A32FLL || *(void *)(result + 16) != 0x40D31F6EAAC32AAELL) {
        goto LABEL_19;
      }
      uint64_t result = fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s institutional recovery key%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "fv_kek_global_policy_eval");
    }
    int v1 = *(_DWORD *)(v2 + 120) | 0x10;
LABEL_19:
    *(_DWORD *)(v2 + 120) = v1 | 0x20;
  }
  return result;
}

uint64_t sub_1000583FC(uint64_t *a1, uint64_t a2)
{
  long long v8 = 0u;
  memset(v7, 0, sizeof(v7));
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  if (*(unsigned char *)(a2 + 37)) {
    sub_1000593B0((uint64_t)&v8 + 8, 8u);
  }
  else {
    *((void *)&v8 + 1) = *(void *)a2;
  }
  if (*(void *)(a2 + 8) || *(unsigned char *)(a2 + 37))
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s error %d%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "fv_encode_vek_blob", ":", 765, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, -12, (const char *)&unk_100062362);
    return 0;
  }
  else
  {
    uint64_t result = ccder_blob_encode_implicit_raw_octet_string();
    if (result)
    {
      uint64_t result = ccder_blob_encode_implicit_raw_octet_string();
      if (result)
      {
        uint64_t result = ccder_blob_encode_implicit_raw_octet_string();
        if (result)
        {
          uint64_t result = ccder_blob_encode_implicit_uint64();
          if (result)
          {
            uint64_t result = ccder_blob_encode_tl();
            if (result)
            {
              uint64_t result = sub_1000585C8((uint64_t)a1, v7, *(_DWORD *)(a2 + 32), v5 + a1[1] - *a1, v4 - a1[1]);
              if (result) {
                return ccder_blob_encode_tl();
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_1000585C8(uint64_t a1, void *a2, char a3, uint64_t a4, uint64_t a5)
{
  if (*a2) {
    return 0;
  }
  a2[1] = a4;
  a2[2] = a5;
  if (!sub_100058FC8(a2, a3)
    || !ccder_blob_encode_implicit_raw_octet_string()
    || !ccder_blob_encode_implicit_raw_octet_string())
  {
    return 0;
  }

  return ccder_blob_encode_implicit_uint64();
}

uint64_t sub_10005866C(uint64_t a1, uint64_t a2, int *a3, _OWORD *a4, void *a5, _OWORD *a6, void *a7, int a8)
{
  *(void *)&long long v22 = a1;
  *((void *)&v22 + 1) = a2;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  if (a1 == a2) {
    return 4294967277;
  }
  uint64_t v21 = 0;
  long long v25 = 0uLL;
  if (!ccder_blob_decode_range()) {
    return 4294967277;
  }
  if (sub_10005926C(&v22, 0x8000000000000000, &v26))
  {
    if ((void)v26) {
      return 4294967277;
    }
  }
  else
  {
    *(void *)&long long v26 = 0;
  }
  if (!sub_1000591DC(&v22, 0x8000000000000001, (uint64_t)&v27 + 8, 32)) {
    return 4294967277;
  }
  if (!sub_1000591DC(&v22, 0x8000000000000002, (uint64_t)&v29 + 8, 8)) {
    return 4294967277;
  }
  uint64_t v14 = v22;
  __src[0] = 0;
  unint64_t v24 = 0;
  if (!ccder_blob_decode_tag()) {
    return 4294967277;
  }
  if (!ccder_blob_decode_len()) {
    return 4294967277;
  }
  if ((v24 & 0xFFFFFFFFFFFFFFEFLL) != 0xA000000000000003) {
    return 4294967277;
  }
  *((void *)&v26 + 1) = v14;
  *(void *)&long long v27 = (char *)__src[0] + v22 - v14;
  if (!sub_10005926C(&v22, 0x8000000000000000, &v21)) {
    return 4294967277;
  }
  if (!sub_1000591DC(&v22, 0x8000000000000001, (uint64_t)&v25, 16)) {
    return 4294967277;
  }
  unint64_t v24 = 0;
  *(_OWORD *)__uuid_t src = v22;
  if (!ccder_blob_decode_tl()) {
    return 4294967277;
  }
  unint64_t v15 = v24;
  if (v24 > 4)
  {
    uint64_t v16 = (char *)__src[0];
    if (v24 >= 0x16) {
      size_t v17 = 22;
    }
    else {
      size_t v17 = v24;
    }
    memcpy(a3, __src[0], v17);
    *(void *)&long long v22 = &v16[v15];
  }
  else
  {
    uint64_t v23 = 0;
    if (sub_10005926C(&v22, 0x8000000000000002, &v23)) {
      *a3 = v23;
    }
  }
  int v18 = *a3;
  *(_OWORD *)__uuid_t src = 0u;
  long long v31 = 0u;
  if ((void)v26)
  {
    uint64_t result = 4294967284;
  }
  else
  {
    int v20 = sub_100058FC8(&v26, v18);
    uint64_t result = 4294967290;
    if (v20)
    {
      if ((uint64_t)__src[0] ^ *((void *)&v27 + 1) | (unint64_t)__src[1] ^ (unint64_t)v28 | (unint64_t)v31 ^ *((void *)&v28 + 1) | *((void *)&v31 + 1) ^ (unint64_t)v29) {
        uint64_t result = 4294967290;
      }
      else {
        uint64_t result = 0;
      }
    }
  }
  if (((result == -6) & ~a8) != 0 || !result)
  {
    if (a5) {
      *a5 = v21;
    }
    if (a6) {
      *a6 = v25;
    }
    if (a4) {
      *a4 = v22;
    }
    if (a7)
    {
      if ((void)v26)
      {
        return 4294967284;
      }
      else
      {
        uint64_t result = 0;
        *a7 = *((void *)&v29 + 1);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100058958(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  long long v8 = 0uLL;
  if (a1 == a2) {
    return 4294967277;
  }
  uint64_t v5 = (unsigned char *)(a3 + 32);
  id v6 = (void *)(a3 + 8);
  uint64_t result = sub_10005866C(a1, a2, (int *)(a3 + 32), &v8, (void *)(a3 + 8), (_OWORD *)(a3 + 16), (void *)a3, a4);
  if (result) {
    return result;
  }
  if (*(unsigned char *)(a3 + 36))
  {
    if (*(unsigned char *)(a3 + 36) == 1) {
      goto LABEL_7;
    }
    return 4294967277;
  }
  if ((*v5 & 4) != 0) {
    return 4294967277;
  }
  *(unsigned char *)(a3 + 36) = 1;
LABEL_7:
  if (*v6 || *(unsigned char *)(a3 + 37)) {
    return 4294967284;
  }
  if (sub_1000591DC(&v8, 0x8000000000000003, a3 + 56, 40)) {
    return 0;
  }
  return 4294967277;
}

uint64_t sub_100058A20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100058958(a1, a2, a3, 1);
}

uint64_t sub_100058A2C(uint64_t *a1, uint64_t a2)
{
  uint64_t v11 = 0;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v8 = 0u;
  uint64_t v5 = *a1;
  uint64_t v4 = a1[1];
  uint64_t v7 = 0;
  sub_1000593B0((uint64_t)&v11, 8u);
  if (*(void *)a2) {
    return 0;
  }
  if ((*(unsigned char *)(a2 + 24) & 0x80) == 0 || (uint64_t result = ccder_blob_encode_implicit_uint64(), result))
  {
    if (*(unsigned char *)(a2 + 29) == 1)
    {
      uint64_t result = ccder_blob_encode_implicit_raw_octet_string();
      if (!result) {
        return result;
      }
      goto LABEL_12;
    }
    if (*(unsigned char *)(a2 + 29)) {
      return 0;
    }
    uint64_t result = ccder_blob_encode_implicit_raw_octet_string();
    if (result)
    {
      uint64_t result = ccder_blob_encode_implicit_uint64();
      if (result)
      {
        if ((ccder_blob_encode_implicit_raw_octet_string() & 1) == 0) {
          return 0;
        }
LABEL_12:
        uint64_t result = ccder_blob_encode_implicit_raw_octet_string();
        if (result)
        {
          uint64_t result = ccder_blob_encode_implicit_raw_octet_string();
          if (result)
          {
            uint64_t result = ccder_blob_encode_implicit_uint64();
            if (result)
            {
              uint64_t result = ccder_blob_encode_tl();
              if (result)
              {
                uint64_t result = sub_1000585C8((uint64_t)a1, &v7, *(_DWORD *)(a2 + 24), v5 + a1[1] - *a1, v4 - a1[1]);
                if (result) {
                  return ccder_blob_encode_tl();
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t sub_100058C04(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  long long v9 = 0uLL;
  if (a1 == a2) {
    return 4294967277;
  }
  uint64_t v5 = (int *)(a3 + 24);
  uint64_t result = sub_10005866C(a1, a2, (int *)(a3 + 24), &v9, (void *)a3, (_OWORD *)(a3 + 8), 0, a4);
  if (result) {
    return result;
  }
  if (*(unsigned char *)(a3 + 28))
  {
    if (*(unsigned char *)(a3 + 28) != 2) {
      return 4294967277;
    }
  }
  else
  {
    *(unsigned char *)(a3 + 28) = 2;
    int v7 = *(_DWORD *)(a3 + 24);
    if (!*(unsigned char *)(a3 + 29) && (v7 & 4) != 0) {
      *(unsigned char *)(a3 + 29) = 1;
    }
    if ((v7 & 2) == 0) {
      *(_DWORD *)(a3 + 120) |= 1u;
    }
  }
  if (*(void *)a3) {
    return 4294967284;
  }
  if (*(unsigned char *)(a3 + 29) == 1)
  {
    if (!sub_1000591DC(&v9, 0x8000000000000003, a3 + 48, 40)) {
      return 4294967277;
    }
  }
  else
  {
    if (*(unsigned char *)(a3 + 29)) {
      return 4294967284;
    }
    if (!sub_1000591DC(&v9, 0x8000000000000003, a3 + 48, 40)
      || !sub_10005926C(&v9, 0x8000000000000004, (void *)(a3 + 88))
      || (sub_1000591DC(&v9, 0x8000000000000005, a3 + 96, 16) & 1) == 0)
    {
      return 4294967277;
    }
  }
  int v8 = *v5;
  if ((*v5 & 0x80) != 0)
  {
    if (!sub_10005926C(&v9, 0x8000000000000006, (void *)(a3 + 112))) {
      return 4294967277;
    }
    int v8 = *v5;
  }
  if ((v8 & 0x100) != 0)
  {
    if ((v8 & 2) != 0)
    {
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s kek constraint violation 1%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "fv_decode_kek_blob_opts");
    }
    else
    {
      if (v8) {
        goto LABEL_25;
      }
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s kek constraint violation 2%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "fv_decode_kek_blob_opts");
    }
    return 4294967277;
  }
LABEL_25:
  sub_10005823C(a3);
  return 0;
}

uint64_t sub_100058E20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_100058C04(a1, a2, a3, 1);
}

uint64_t sub_100058E2C(uint64_t a1, int a2, uint64_t *a3)
{
  if ((a2 - 2) >= 2)
  {
    if (a2 != 1) {
      return 0xFFFFFFFFLL;
    }
    uint64_t v4 = qword_100084A90;
    if (!qword_100084A90)
    {
      ccder_sizeof_implicit_uint64();
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_implicit_uint64();
      ccder_sizeof_raw_octet_string();
      ccder_sizeof();
      ccder_sizeof_raw_octet_string();
      uint64_t v4 = sub_10005916C();
      qword_100084A90 = v4;
    }
  }
  else
  {
    uint64_t v4 = qword_100084A98;
    if (!qword_100084A98)
    {
      ccder_sizeof_implicit_uint64();
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_raw_octet_string();
      ccder_sizeof_implicit_uint64();
      ccder_sizeof_implicit_uint64();
      uint64_t v4 = sub_10005916C();
      qword_100084A98 = v4;
    }
  }
  uint64_t v5 = 0xFFFFFFFFLL;
  if (a3 && v4)
  {
    uint64_t v5 = 0;
    *a3 = v4;
  }
  return v5;
}

uint64_t sub_100058FC8(void *a1, char a2)
{
  __int16 v11 = 1301;
  void v10[2] = 387978753;
  memset(__s, 0, sizeof(__s));
  uint64_t v4 = ccsha256_di();
  __chkstk_darwin();
  id v6 = (char *)v10 - v5;
  bzero((char *)v10 - v5, v7);
  if (*a1
    || (ccdigest_init(),
        ccdigest_update(),
        ccdigest_update(),
        (*(void (**)(uint64_t, char *, _OWORD *))(v4 + 56))(v4, v6, __s),
        cc_clear(),
        (a2 & 1) != 0)
    && !sub_100059C18())
  {
    uint64_t v8 = 0;
  }
  else
  {
    cchmac();
    uint64_t v8 = 1;
  }
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v8;
}

uint64_t sub_10005916C()
{
  ccder_sizeof();
  ccder_sizeof_implicit_uint64();
  ccder_sizeof_raw_octet_string();
  ccder_sizeof_raw_octet_string();

  return ccder_sizeof();
}

uint64_t sub_1000591DC(long long *a1, uint64_t a2, uint64_t a3, int a4)
{
  long long v8 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0 || a3 && a4) {
    return 0;
  }
  *a1 = v8;
  return 1;
}

uint64_t sub_10005926C(long long *a1, uint64_t a2, void *a3)
{
  if (a3) {
    *a3 = 0;
  }
  long long v6 = *a1;
  uint64_t result = ccder_blob_decode_range();
  if (result)
  {
    if (ccn_read_uint())
    {
      return 0;
    }
    else
    {
      *a1 = v6;
      if (a3) {
        *a3 = 0;
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_1000592F8()
{
  sub_1000598F0(&unk_100080B58 != 0, 62, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  sub_1000598F0(sub_100059480 != 0, 63, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");

  return sub_100059480();
}

uint64_t sub_1000593B0(uint64_t a1, unsigned int a2)
{
  sub_1000598F0(&unk_100080B58 != 0, 70, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");
  sub_1000598F0(sub_1000594F0 != 0, 71, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform.c");

  return sub_1000594F0(a1, a2);
}

uint64_t sub_100059480()
{
  uint64_t v0 = ccrng();
  sub_1000598F0(v0 != 0, 22, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
  sub_1000598F0(0, 23, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
  return v0;
}

uint64_t sub_1000594F0(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(unsigned int (**)(uint64_t, void, uint64_t))sub_1000592F8();
  uint64_t v5 = sub_1000592F8();
  BOOL v6 = v4(v5, a2, a1) == 0;

  return sub_1000598F0(v6, 31, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/platform/platform_lib.c");
}

unint64_t sub_10005955C(uint64_t a1)
{
  mach_timebase_info info = 0;
  mach_timebase_info(&info);
  return (unint64_t)info.numer * a1 / info.denom;
}

BOOL sub_10005959C(unsigned __int8 *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  int v2 = 0;
  do
  {
    int v3 = *a1++;
    v2 |= v3;
    --a2;
  }
  while (a2);
  return v2 != 0;
}

uint64_t sub_1000595C8(const char *a1, uint64_t a2, unint64_t a3)
{
  unint64_t v3 = a3;
  uint64_t v4 = a1;
  char v24 = 0;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  *(_OWORD *)__str = 0u;
  long long v17 = 0u;
  uint64_t v5 = &__stdoutp;
  if (a3 >= 0x41)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s %sdump %s (len = %zd)%s%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "dump_bytes_internal", ":", 786, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, (const char *)&unk_100062362, a1, a3, (const char *)&unk_100062362, (const char *)&unk_100062362);
    uint64_t v4 = (const char *)&unk_100062362;
  }
  else if (!a3)
  {
    return memset_s(__str, 0x81uLL, 0, 0x81uLL);
  }
  unint64_t v6 = 0;
  unint64_t v15 = v3;
  do
  {
    size_t v7 = v5;
    if (v3 - v6 >= 0x40) {
      uint64_t v8 = 64;
    }
    else {
      uint64_t v8 = v3 - v6;
    }
    if (v8)
    {
      long long v9 = (unsigned __int8 *)(a2 + v6);
      long long v10 = __str;
      uint64_t v11 = v8;
      do
      {
        int v12 = *v9++;
        snprintf(v10, 3uLL, "%02x", v12);
        v10 += 2;
        --v11;
      }
      while (v11);
    }
    uint64_t v5 = v7;
    fprintf(*v7, "%s%s:%s%s%s%s%u:%s%u:%s %s%s%s[%04zu,%04zu): %s%s%s%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "dump_bytes_internal", ":", 796, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, (const char *)&unk_100062362, v4, (const char *)&unk_100062362, v6, v8 + v6, (const char *)&unk_100062362, __str,
      (const char *)&unk_100062362,
      (const char *)&unk_100062362);
    v6 += v8;
    unint64_t v3 = v15;
  }
  while (v6 < v15);
  return memset_s(__str, 0x81uLL, 0, 0x81uLL);
}

unsigned char *sub_1000597A8(unsigned __int8 *a1, unint64_t a2)
{
  if (a2 >= 0x10) {
    uint64_t v2 = 16;
  }
  else {
    uint64_t v2 = a2;
  }
  if (v2)
  {
    uint64_t v4 = byte_100084AA0;
    uint64_t v5 = v2;
    do
    {
      int v6 = *a1++;
      snprintf(v4, 3uLL, "%02x", v6);
      v4 += 2;
      --v5;
    }
    while (v5);
  }
  byte_100084AA0[2 * v2] = 0;
  return byte_100084AA0;
}

uint64_t sub_10005983C(uint64_t result)
{
  if (result == 0 || result >= 0xFFFFFFDA) {
    return dword_10007EC98[(int)result + 38];
  }
  return result;
}

uint64_t sub_100059858(void *a1, uint64_t a2, char a3)
{
  memset_s(a1, 0x10uLL, 0, 0x10uLL);
  if (a3) {
    return 4294967285;
  }
  if (a2 && *(void *)a2 && (size_t v7 = *(void *)(a2 + 8)) != 0)
  {
    uint64_t v8 = calloc(v7, 1uLL);
    if (v8)
    {
      *a1 = v8;
      long long v9 = *(const void **)a2;
      a1[1] = *(void *)(a2 + 8);
      memcpy(v8, v9, *(void *)(a2 + 8));
      return 0;
    }
    else
    {
      return 4294967279;
    }
  }
  else
  {
    uint64_t result = 0;
    *a1 = 0;
    a1[1] = 0;
  }
  return result;
}

uint64_t sub_1000598F0(uint64_t result, int a2, const char *a3)
{
  if ((result & 1) == 0)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s failed REQUIRE condition (%s:%d)\n%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "REQUIRE_func", ":", 1047, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, a3, a2, (const char *)&unk_100062362);
    abort();
  }
  return result;
}

uint64_t sub_100059964()
{
  return 3758097126;
}

uint64_t sub_100059970()
{
  return 0;
}

uint64_t sub_100059978()
{
  return 4294967284;
}

uint64_t sub_100059980(void *a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0;
  *a1 = off_1000849B8;
  return result;
}

uint64_t sub_1000599A4(uint64_t a1, void *a2, uint64_t *a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6)
{
  if (a1) {
    uint64_t v6 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v6 = 0;
  }
  v9[0] = v6;
  v9[1] = 0;
  if (!a2) {
    a2 = &unk_10007ED38;
  }
  uint64_t v7 = sub_10005B284(v9, (uint64_t)a2, a3, a4, a5, a6);
  return sub_10005983C(v7);
}

uint64_t sub_1000599F0(uint64_t a1, void *a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  if (a1) {
    uint64_t v8 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v8 = 0;
  }
  v12[0] = v8;
  v12[1] = 0;
  if (a2) {
    long long v9 = a2;
  }
  else {
    long long v9 = &unk_10007ED38;
  }
  uint64_t v10 = sub_10005B74C(v12, 0, (uint64_t)v9, a3, a4, 0, a5);
  return sub_10005983C(v10);
}

uint64_t sub_100059A50(uint64_t a1, unsigned int a2, void *a3, const unsigned __int8 *a4, uint64_t a5)
{
  if (a1) {
    uint64_t v5 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v5 = 0;
  }
  v8[0] = v5;
  v8[1] = 0;
  if (!a3) {
    a3 = &unk_10007ED38;
  }
  uint64_t v6 = sub_10005BADC(v8, a2, (uint64_t)a3, a4, a5);
  return sub_10005983C(v6);
}

uint64_t sub_100059A9C(uint64_t a1, void *a2, uint64_t *a3, const unsigned __int8 *a4, uint64_t a5, uint64_t a6)
{
  if (a1) {
    uint64_t v6 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v6 = 0;
  }
  v9[0] = v6;
  v9[1] = 0;
  if (!a2) {
    a2 = &unk_10007ED38;
  }
  uint64_t v7 = sub_10005C0E0(v9, (uint64_t)a2, a3, a4, a5, a6);
  return sub_10005983C(v7);
}

uint64_t sub_100059AE8(uint64_t a1, int a2, uint64_t *a3)
{
  if (a1) {
    uint64_t v3 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  v6[0] = v3;
  v6[1] = 0;
  uint64_t v4 = sub_100058E2C((uint64_t)v6, a2, a3);
  return sub_10005983C(v4);
}

uint64_t sub_100059B24()
{
  return 3758097126;
}

uint64_t sub_100059B30()
{
  return 3758097126;
}

uint64_t sub_100059B3C(uint64_t a1, uint64_t *a2, char *a3)
{
  if (a1) {
    uint64_t v3 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v3 = 0;
  }
  v6[0] = v3;
  v6[1] = 0;
  uint64_t v4 = sub_10005AD98((int)v6, a2, a3);
  return sub_10005983C(v4);
}

uint64_t sub_100059B78(uint64_t a1, int a2, uint64_t a3, void *a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  if (a1) {
    uint64_t v7 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v7 = 0;
  }
  v10[0] = v7;
  v10[1] = 0;
  if (!a4) {
    a4 = &unk_10007ED38;
  }
  uint64_t v8 = sub_10005A3C0(v10, a2, a3, (uint64_t)a4, a5, a6, a7);
  return sub_10005983C(v8);
}

uint64_t sub_100059BC4(uint64_t a1, unsigned int a2, void *a3, uint64_t *a4, uint64_t *a5, uint64_t a6)
{
  if (a1) {
    uint64_t v6 = *(void *)(a1 + 8);
  }
  else {
    uint64_t v6 = 0;
  }
  v9[0] = v6;
  v9[1] = 0;
  if (!a3) {
    a3 = &unk_10007ED38;
  }
  uint64_t v7 = sub_10005B74C(v9, a2, (uint64_t)a3, a4, a5, 0, a6);
  return sub_10005983C(v7);
}

uint64_t sub_100059C1C(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(v32, 0, sizeof(v32));
  int v31 = 32;
  int v4 = *(_DWORD *)(a3 + 32);
  if ((v4 & 2) != 0) {
    uint64_t v5 = 24;
  }
  else {
    uint64_t v5 = 40;
  }
  if (*(void *)(a3 + 8)) {
    goto LABEL_5;
  }
  if (*(unsigned char *)(a3 + 37) == 1)
  {
    *(double *)&long long v12 = ((double (*)(void))__chkstk_darwin)();
    uint64_t v29 = 0;
    long long v27 = v12;
    long long v28 = v12;
    LODWORD(__s) = 0;
    uint64_t v6 = 4294967285;
    if (!sub_10005D25C(0x28u, (unsigned int *)&__s) || __s > 0x20) {
      goto LABEL_44;
    }
    if (a1)
    {
      long long v13 = *(_OWORD *)(a3 + 112);
      long long v27 = *(_OWORD *)(a3 + 96);
      long long v28 = v13;
      uint64_t v29 = *(void *)(a3 + 128);
      if (*(unsigned char *)(a3 + 32))
      {
        char v14 = sub_100059970();
        uint64_t v6 = 0xFFFFFFFFLL;
        if (HIDWORD(a2) || (v14 & 1) == 0) {
          goto LABEL_44;
        }
LABEL_28:
        if (a1) {
          unsigned int v19 = a2;
        }
        else {
          unsigned int v19 = 0;
        }
        if (a1) {
          long long v20 = 0;
        }
        else {
          long long v20 = sub_10005A190;
        }
        if (sub_10005D1C4(a1, v19, 0xA6A6A6A6A6A6A6A6, (uint64_t (*)(void, void *, unint64_t *, unint64_t *, uint64_t))v20, &v27, 0x28u, (void *)a4, &v31))
        {
          fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s kek failed to unwrap vek; mix-n-match?%s\n",
            "aks",
            (const char *)&unk_100062362,
            (const char *)&unk_100062362,
            (const char *)&unk_100062362,
            "fv_decrypt_vek",
            ":",
            568,
            (const char *)&unk_100062362,
            0,
            (const char *)&unk_100062362,
            (const char *)&unk_100062362);
          uint64_t v6 = 4294967294;
          goto LABEL_44;
        }
        goto LABEL_40;
      }
    }
    else
    {
      long long v18 = *(_OWORD *)(a3 + 72);
      long long v27 = *(_OWORD *)(a3 + 56);
      long long v28 = v18;
      uint64_t v29 = *(void *)(a3 + 88);
    }
    if (HIDWORD(a2))
    {
      uint64_t v6 = 0xFFFFFFFFLL;
      goto LABEL_44;
    }
    goto LABEL_28;
  }
  if (*(unsigned char *)(a3 + 37))
  {
LABEL_5:
    uint64_t v6 = 4294967284;
    goto LABEL_44;
  }
  if ((v4 & 0x1000) != 0)
  {
    unint64_t v30 = 0;
    uint64_t v6 = 4294967285;
    if (sub_10005D270(v5, &v30) && v30 <= 0x20)
    {
      long long v15 = *(_OWORD *)(a3 + 72);
      long long __s = *(_OWORD *)(a3 + 56);
      long long v34 = v15;
      uint64_t v35 = *(void *)(a3 + 88);
      if (sub_10005A060(a3, v32)) {
        goto LABEL_45;
      }
      uint64_t v16 = v32;
      unsigned int v17 = 32;
LABEL_39:
      if (!sub_10005D1C4((uint64_t)v16, v17, 0xA6A6A6A6A6A6A6A6, 0, &__s, v5, (void *)a4, &v31))
      {
LABEL_40:
        if ((*(unsigned char *)(a3 + 32) & 2) == 0)
        {
LABEL_43:
          uint64_t v6 = 0;
          goto LABEL_44;
        }
        if (v31 == 16)
        {
          uint64_t v22 = ccsha256_di();
          __chkstk_darwin();
          char v24 = (char *)&v30 - v23;
          bzero((char *)&v30 - v23, v25);
          long long __s = 0u;
          long long v34 = 0u;
          ccdigest_init();
          ccdigest_update();
          ccdigest_update();
          (*(void (**)(uint64_t, char *, long long *))(v22 + 56))(v22, v24, &__s);
          cc_clear();
          *(_OWORD *)(a4 + 16) = __s;
          memset_s(&__s, 0x20uLL, 0, 0x20uLL);
          goto LABEL_43;
        }
LABEL_45:
        uint64_t v6 = 0xFFFFFFFFLL;
        goto LABEL_44;
      }
LABEL_46:
      uint64_t v6 = 4294967294;
    }
  }
  else
  {
    if (!a1) {
      goto LABEL_46;
    }
    LODWORD(v30) = 0;
    uint64_t v6 = 4294967285;
    if (sub_10005D25C(v5, (unsigned int *)&v30) && v30 <= 0x20)
    {
      long long v11 = *(_OWORD *)(a3 + 72);
      long long __s = *(_OWORD *)(a3 + 56);
      long long v34 = v11;
      uint64_t v35 = *(void *)(a3 + 88);
      if ((v4 & 1) == 0)
      {
        if (HIDWORD(a2)) {
          goto LABEL_45;
        }
        goto LABEL_38;
      }
      char v21 = sub_100059970();
      uint64_t v6 = 0xFFFFFFFFLL;
      if (!HIDWORD(a2) && (v21 & 1) != 0)
      {
LABEL_38:
        uint64_t v16 = (_OWORD *)a1;
        unsigned int v17 = a2;
        goto LABEL_39;
      }
    }
  }
LABEL_44:
  memset_s(v32, 0x20uLL, 0, 0x20uLL);
  return v6;
}

uint64_t sub_10005A060(uint64_t a1, _OWORD *a2)
{
  int v14 = 0;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  memset(v9, 0, sizeof(v9));
  long long __s = 0u;
  long long v8 = 0u;
  if (*(unsigned char *)(a1 + 37))
  {
    uint64_t v2 = 4294967284;
  }
  else
  {
    DWORD1(v10) = 32;
    *(void *)&v9[0] = *(void *)a1;
    ccsha256_di();
    if (cchkdf() || (*(unsigned char *)(a1 + 32) & 1) != 0 && !sub_100059970())
    {
      uint64_t v2 = 0xFFFFFFFFLL;
    }
    else
    {
      uint64_t v2 = 0;
      long long v5 = v8;
      *a2 = __s;
      a2[1] = v5;
    }
  }
  memset_s(&__s, 0x20uLL, 0, 0x20uLL);
  memset_s(v9, 0x20uLL, 0, 0x20uLL);
  return v2;
}

uint64_t sub_10005A194(char a1, int a2, uint64_t a3, uint64_t *a4, void *a5, size_t *a6, _DWORD *a7, unsigned __int8 *a8, unsigned __int8 *a9, void **a10)
{
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v10 = 4294967285;
  memset(v24, 0, sizeof(v24));
  if (a4)
  {
    if (a9)
    {
      if (a3)
      {
        if (a5)
        {
          if (a6)
          {
            if (a7)
            {
              if (a8)
              {
                if (*a4)
                {
                  uint64_t v17 = a4[1];
                  if (v17)
                  {
                    uint64_t v19 = sub_100058E20(*a4, *a4 + v17, (uint64_t)v24);
                    if (!v19)
                    {
                      uuid_copy(a8, (const unsigned __int8 *)v24 + 8);
                      uuid_copy(a9, (const unsigned __int8 *)&v24[1] + 14);
                      int v20 = DWORD2(v25);
                      *a7 = DWORD2(v24[1]);
                      unsigned int v21 = v20 & 0xFFFFFFF7;
                      if (a2) {
                        int v22 = 0;
                      }
                      else {
                        int v22 = 8;
                      }
                      DWORD2(v25) = v21 | v22;
                      uint64_t v19 = sub_10005C420(a3, (uint64_t)v24, a5, a6, a1, a10);
                    }
                    uint64_t v10 = v19;
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  memset_s(v24, 0xB0uLL, 0, 0xB0uLL);
  return v10;
}

uint64_t sub_10005A300(int a1, unsigned __int8 *uu)
{
  memset(out, 0, 37);
  j__uuid_unparse(uu, out);
  return fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s purging %s%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "filevault_purge_group", ":", 2957, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, out, (const char *)&unk_100062362);
}

uint64_t sub_10005A3C0(uint64_t *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v7 = 4294967284;
  switch(a2)
  {
    case 1:
    case 2:
    case 3:
    case 4:
    case 12:
      uint64_t v13 = *a1;
      size_t v38 = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      *(_OWORD *)__smax = 0u;
      long long v44 = 0u;
      uint64_t v61 = 0;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      memset(v47, 0, sizeof(v47));
      long long __s = 0u;
      memset(v42, 0, sizeof(v42));
      unsigned int v36 = 0;
      rsize_t __n = 0;
      size_t __count = 0;
      memset(dst, 0, sizeof(dst));
      long long v40 = 0uLL;
      int v34 = 0;
      uint64_t v14 = sub_100058E2C(0, 1, (uint64_t *)&__count);
      if (v14) {
        goto LABEL_99;
      }
      if (!__count) {
        goto LABEL_111;
      }
      if (!a6 || !*a6) {
        goto LABEL_50;
      }
      uint64_t v7 = 4294967285;
      if (!a7) {
        goto LABEL_51;
      }
      uint64_t v15 = a6[1];
      if (!v15) {
        goto LABEL_51;
      }
      uint64_t v14 = sub_100058A20(*a6, *a6 + v15, (uint64_t)&__s);
      if (v14) {
        goto LABEL_99;
      }
      if ((v13 & 0x40) != 0)
      {
        if (!a5 || *(void *)(a5 + 8) != 16)
        {
LABEL_50:
          uint64_t v7 = 4294967285;
          goto LABEL_51;
        }
        uuid_copy(dst, *(const unsigned __int8 **)a5);
        goto LABEL_49;
      }
      uint64_t v14 = sub_10005A194(v13, 1, a4, (uint64_t *)a5, &v62, &v38, &v34, dst, (unsigned __int8 *)&v40, &v36);
      if (v14) {
        goto LABEL_99;
      }
      if (a2 != 3)
      {
        if (a2 == 2)
        {
          if (BYTE5(v47[0]) != 1) {
            fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s unsupported vek type for sys disable%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "_cmd_handle_vek");
          }
        }
        else if (a2 == 1 && BYTE5(v47[0]) != 1)
        {
          fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s unsupported vek type for sys enable%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "_cmd_handle_vek");
        }
        goto LABEL_49;
      }
      if (BYTE5(v47[0]) != 1)
      {
        if (BYTE5(v47[0])) {
          goto LABEL_49;
        }
        if ((v47[0] & 0x1000) != 0)
        {
          if ((v47[0] & 2) == 0)
          {
            if (((v34 ^ LODWORD(v47[0])) & 1) == 0)
            {
              uint64_t v14 = sub_100059C1C(0, 0, (uint64_t)&__s, (uint64_t)__smax);
              if (!v14)
              {
                uint64_t v14 = sub_10005C910((uint64_t)&__s, (unsigned __int8 *)&v62, v38, (unsigned __int8 *)__smax);
                if (!v14)
                {
                  *(_OWORD *)((char *)v47 + 6) = v40;
                  goto LABEL_74;
                }
              }
LABEL_99:
              uint64_t v7 = v14;
              goto LABEL_51;
            }
            fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s kek and unmanaged vek device protection mismatch%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "_cmd_handle_vek", ":", 2678, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, (const char *)&unk_100062362);
LABEL_108:
            uint64_t v7 = 4294967287;
            goto LABEL_51;
          }
LABEL_49:
          uint64_t v7 = 4294967284;
LABEL_51:
          fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s cmd: %d, result: %d%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "_cmd_handle_vek", ":", 2873, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, a2, v7, (const char *)&unk_100062362);
          goto LABEL_52;
        }
LABEL_104:
        uint64_t v7 = 4294967288;
        goto LABEL_51;
      }
      if ((v61 & 2) != 0) {
        goto LABEL_104;
      }
      if ((v34 & 1) == 0) {
        goto LABEL_108;
      }
      uint64_t v14 = sub_100059C1C(0, 0, (uint64_t)&__s, (uint64_t)__smax);
      if (v14) {
        goto LABEL_99;
      }
      LODWORD(v32) = 0;
      if (!sub_10005959C((unsigned __int8 *)&v62, 32))
      {
        fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Internal Error: Null KEK, file radar%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "_enable_user_kek");
LABEL_111:
        uint64_t v7 = 4294967286;
        goto LABEL_51;
      }
      if (!sub_10005959C((unsigned __int8 *)__smax, 32))
      {
        fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Internal Error: Null VEK, file radar%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "_enable_user_kek");
        goto LABEL_111;
      }
      if (*((void *)&__s + 1)) {
        goto LABEL_49;
      }
      LODWORD(v61) = v61 | 2;
      int v39 = 40;
      uint64_t v7 = 4294967285;
      if (!sub_10005D230(0x20u, &v32) || v32 > 0x28) {
        goto LABEL_51;
      }
      if (sub_10005CDF0((uint64_t)&v62, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, (uint64_t *)__smax, 0x20u, &v50, &v39)|| (v47[0] & 1) != 0 && (sub_100059970() & 1) == 0)
      {
        uint64_t v7 = 0xFFFFFFFFLL;
        goto LABEL_51;
      }
      *(_OWORD *)((char *)v47 + 6) = v40;
      if (*((void *)&__s + 1)) {
        goto LABEL_49;
      }
      LODWORD(v61) = v61 & 0xFFFFFFFE;
LABEL_74:
      long long v26 = (char *)calloc(__count, 1uLL);
      if (!v26)
      {
        uint64_t v7 = 4294967279;
        goto LABEL_51;
      }
      long long v27 = v26;
      uint64_t v32 = v26;
      uint64_t v33 = &v26[__count];
      if (!sub_1000583FC((uint64_t *)&v32, (uint64_t)&__s))
      {
        uint64_t v31 = 4294967273;
        goto LABEL_98;
      }
      long long v28 = v33;
      size_t v29 = &v27[__count] - v33;
      unint64_t v30 = *(void **)a7;
      if (!*(void *)a7)
      {
        unint64_t v30 = calloc(&v27[__count] - v33, 1uLL);
        if (!v30)
        {
          uint64_t v31 = 4294967279;
          goto LABEL_98;
        }
        *(void *)a7 = v30;
        long long v28 = v33;
        goto LABEL_97;
      }
      if (v29 <= *(void *)(a7 + 8))
      {
LABEL_97:
        *(void *)(a7 + 8) = v29;
        memcpy(v30, &v27[v28 - v32], v29);
        uint64_t v31 = 0;
        goto LABEL_98;
      }
      uint64_t v31 = 0xFFFFFFFFLL;
LABEL_98:
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s cmd: %d, result: %d%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "_cmd_handle_vek", ":", 2873, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, 3, v31, (const char *)&unk_100062362);
      memset_s(v27, __count, 0, __count);
      free(v27);
      uint64_t v7 = v31;
LABEL_52:
      memset_s(&v62, 0x20uLL, 0, 0x20uLL);
      memset_s(__smax, 0x20uLL, 0, 0x20uLL);
      memset_s(v42, 0x20uLL, 0, 0x20uLL);
      if (v36)
      {
        memset_s(v36, __n, 0, __n);
        free(v36);
      }
      return v7;
    case 5:
      uint64_t v61 = 0;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      memset(v47, 0, sizeof(v47));
      long long __s = 0u;
      if (!a6) {
        return 4294967285;
      }
      if (!*a6) {
        return 4294967285;
      }
      uint64_t v18 = a6[1];
      if (!v18) {
        return 4294967285;
      }
      uint64_t v19 = sub_100058A20(*a6, *a6 + v18, (uint64_t)&__s);
      if (v19) {
        return v19;
      }
      if (BYTE5(v47[0]) == 1) {
        return 0;
      }
      else {
        return 4294967285;
      }
    case 6:
      uint64_t v61 = 0;
      long long v59 = 0u;
      long long v60 = 0u;
      long long v57 = 0u;
      long long v58 = 0u;
      long long v55 = 0u;
      long long v56 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      memset(v47, 0, sizeof(v47));
      long long __s = 0u;
      if (!a6) {
        return 4294967285;
      }
      if (!*a6) {
        return 4294967285;
      }
      uint64_t v20 = a6[1];
      if (!v20) {
        return 4294967285;
      }
      return sub_100058958(*a6, *a6 + v20, (uint64_t)&__s, 1);
    case 7:
      uint64_t v21 = *a1;
      *(void *)&v42[0] = 0;
      long long v62 = 0u;
      long long v63 = 0u;
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      memset(v47, 0, sizeof(v47));
      long long __s = 0u;
      __smax[0] = 0;
      __smax[1] = 0;
      if (a4 && *(void *)a4 && *(void *)(a4 + 8))
      {
        if (!a5) {
          goto LABEL_40;
        }
        const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v22 = *(const unsigned __int8 **)a5;
        if (!*(void *)a5) {
          goto LABEL_40;
        }
        uint64_t v23 = *(void *)(a5 + 8);
        if (!v23) {
          goto LABEL_40;
        }
      }
      else
      {
        if (!a5) {
          goto LABEL_63;
        }
        const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v22 = *(const unsigned __int8 **)a5;
        if (!*(void *)a5) {
          goto LABEL_63;
        }
        uint64_t v23 = *(void *)(a5 + 8);
        if (!v23) {
          goto LABEL_63;
        }
        if (!a4)
        {
LABEL_40:
          uint64_t v7 = 4294967285;
          goto LABEL_64;
        }
      }
      uint64_t v25 = sub_100058E20((uint64_t)v22, (uint64_t)&v22[v23], (uint64_t)&__s);
      if (v25
        || (uint64_t v25 = sub_10005C420(a4, (uint64_t)&__s, &v62, (size_t *)v42, v21, (void **)__smax), v25)
        || (v21 & 8) != 0 && (uint64_t v25 = sub_100059978(), v25))
      {
        uint64_t v7 = v25;
LABEL_64:
        memset_s(&v62, 0x20uLL, 0, 0x20uLL);
        if (__smax[0])
        {
          memset_s((void *)__smax[0], __smax[1], 0, __smax[1]);
          free((void *)__smax[0]);
        }
        goto LABEL_21;
      }
LABEL_63:
      uint64_t v7 = 0;
      goto LABEL_64;
    case 10:
      return 0;
    case 11:
    case 15:
    case 22:
      long long v53 = 0u;
      long long v54 = 0u;
      long long v51 = 0u;
      long long v52 = 0u;
      long long v49 = 0u;
      long long v50 = 0u;
      long long v48 = 0u;
      long long v46 = 0u;
      memset(v47, 0, sizeof(v47));
      long long __s = 0u;
      if (a5)
      {
        if (*(void *)a5
          && (uint64_t v16 = *(void *)(a5 + 8)) != 0
          && (uint64_t v17 = sub_100058C04(*(void *)a5, *(void *)a5 + v16, (uint64_t)&__s, 1), v17))
        {
          uint64_t v7 = v17;
        }
        else
        {
          uint64_t v7 = 0;
        }
      }
      else
      {
        uint64_t v7 = 0xFFFFFFFFLL;
      }
LABEL_21:
      memset_s(&__s, 0xB0uLL, 0, 0xB0uLL);
      return v7;
    case 28:
      if (!a4 || !*(void *)a4 || *(void *)(a4 + 8) != 16) {
        return 4294967285;
      }
      long long __s = *(_OWORD *)*(void *)a4;
      sub_10005A300(0, (unsigned __int8 *)&__s);
      return 0;
    default:
      return v7;
  }
}

uint64_t sub_10005AD98(int a1, uint64_t *a2, char *__s)
{
  uint64_t v44 = 0;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v29 = 0u;
  long long v27 = 0u;
  memset(v28, 0, sizeof(v28));
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  long long __sa = 0u;
  memset(v16, 0, 22);
  if (!a2 || !*a2)
  {
    uint64_t v5 = 4294967285;
    goto LABEL_13;
  }
  uint64_t v5 = 4294967285;
  if (__s && a2[1])
  {
    memset_s(__s, 0x58uLL, 0, 0x58uLL);
    uint64_t v6 = sub_10005866C(*a2, *a2 + a2[1], v16, 0, 0, __s + 4, 0, 1);
    int v7 = v6;
    uint64_t v5 = v6;
    if (v6 == -6)
    {
      *((_DWORD *)__s + 9) |= 0x2000000u;
      uint64_t v5 = sub_10005866C(*a2, *a2 + a2[1], v16, 0, 0, __s + 4, 0, 0);
    }
    if (v5)
    {
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s failed to decode blob%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "fv_get_blob_state");
      goto LABEL_13;
    }
    *(_OWORD *)(__s + 20) = *(_OWORD *)((char *)&v16[1] + 2);
    __int16 v8 = v16[0];
    int v9 = LOBYTE(v16[1]);
    if (!LOBYTE(v16[1]))
    {
      if (!sub_100058C04(*a2, *a2 + a2[1], (uint64_t)&__sa, v7 != -6))
      {
        LOBYTE(v16[1]) = 2;
LABEL_18:
        uint64_t v11 = sub_100058C04(*a2, *a2 + a2[1], (uint64_t)&__sa, v7 != -6);
        if (v11)
        {
          uint64_t v5 = v11;
          fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s failed to decode kek%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "fv_get_blob_state");
          goto LABEL_13;
        }
        *(_DWORD *)long long __s = 2;
        *((_DWORD *)__s + 10) = __sa;
        __s[65] = BYTE13(v18);
LABEL_31:
        if ((v8 & 0x40) != 0)
        {
          *((_DWORD *)__s + 9) |= 0x80u;
          if ((v8 & 0x20) == 0)
          {
LABEL_33:
            if ((v8 & 0x800) == 0) {
              goto LABEL_34;
            }
            goto LABEL_46;
          }
        }
        else if ((v8 & 0x20) == 0)
        {
          goto LABEL_33;
        }
        *((_DWORD *)__s + 9) |= 0x40u;
        if ((v8 & 0x800) == 0)
        {
LABEL_34:
          if ((v8 & 2) == 0) {
            goto LABEL_35;
          }
          goto LABEL_47;
        }
LABEL_46:
        *((_DWORD *)__s + 9) |= 0x1000000u;
        if ((v8 & 2) == 0)
        {
LABEL_35:
          if ((v8 & 1) == 0) {
            goto LABEL_36;
          }
          goto LABEL_48;
        }
LABEL_47:
        *((_DWORD *)__s + 9) |= 0x10u;
        if ((v8 & 1) == 0)
        {
LABEL_36:
          if ((v8 & 8) == 0) {
            goto LABEL_37;
          }
          goto LABEL_49;
        }
LABEL_48:
        *((_DWORD *)__s + 9) |= 1u;
        if ((v8 & 8) == 0)
        {
LABEL_37:
          if ((v8 & 0x80) == 0) {
            goto LABEL_38;
          }
          goto LABEL_50;
        }
LABEL_49:
        *((_DWORD *)__s + 9) |= 0x20u;
        if ((v8 & 0x80) == 0)
        {
LABEL_38:
          if ((v8 & 0x10) == 0) {
            goto LABEL_39;
          }
          goto LABEL_51;
        }
LABEL_50:
        *((_DWORD *)__s + 9) |= 0x400u;
        *((void *)__s + 9) = v24;
        if ((v8 & 0x10) == 0)
        {
LABEL_39:
          if ((v8 & 4) == 0) {
            goto LABEL_40;
          }
          goto LABEL_52;
        }
LABEL_51:
        __s[64] |= 1u;
        if ((v8 & 4) == 0)
        {
LABEL_40:
          if ((v8 & 0x400) == 0) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
LABEL_52:
        __s[64] |= 2u;
        if ((v8 & 0x400) == 0)
        {
LABEL_42:
          uint64_t v5 = 0;
          if ((v8 & 0x200) != 0) {
            *((_DWORD *)__s + 9) |= 0x80000u;
          }
          goto LABEL_13;
        }
LABEL_41:
        *((_DWORD *)__s + 9) |= 0x100000u;
        goto LABEL_42;
      }
      if (!sub_100058958(*a2, *a2 + a2[1], (uint64_t)v28, v7 != -6))
      {
        LOBYTE(v16[1]) = 1;
        goto LABEL_21;
      }
      int v9 = LOBYTE(v16[1]);
    }
    if (v9 != 1)
    {
      if (v9 != 2)
      {
        fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s unknown blob type %i%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "fv_get_blob_state", ":", 3483, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, v9, (const char *)&unk_100062362);
        uint64_t v5 = 0xFFFFFFFFLL;
        goto LABEL_13;
      }
      goto LABEL_18;
    }
LABEL_21:
    uint64_t v12 = sub_100058958(*a2, *a2 + a2[1], (uint64_t)v28, v7 != -6);
    if (v12)
    {
      uint64_t v5 = v12;
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s failed to decode vek%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "fv_get_blob_state");
      goto LABEL_13;
    }
    *(_DWORD *)long long __s = 1;
    int v13 = BYTE5(v29);
    __s[65] = BYTE5(v29);
    *((_DWORD *)__s + 10) = v28[1];
    if (v13)
    {
      if (v13 != 1) {
        goto LABEL_31;
      }
      char v14 = v44;
      if (v44) {
        *((_DWORD *)__s + 9) |= 8u;
      }
      if ((v14 & 2) == 0) {
        goto LABEL_31;
      }
      int v15 = *((_DWORD *)__s + 9) | 4;
    }
    else
    {
      if ((BYTE1(v29) & 0x10) == 0) {
        goto LABEL_31;
      }
      int v15 = *((_DWORD *)__s + 9) | 0x8000000;
    }
    *((_DWORD *)__s + 9) = v15;
    goto LABEL_31;
  }
LABEL_13:
  memset_s(&__sa, 0xB0uLL, 0, 0xB0uLL);
  return v5;
}

uint64_t sub_10005B284(void *a1, uint64_t a2, uint64_t *a3, unsigned __int8 *a4, uint64_t a5, uint64_t a6)
{
  memset(v35, 0, sizeof(v35));
  size_t v27 = 32;
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  memset(__s, 0, sizeof(__s));
  size_t __count = 0;
  BOOL v12 = a3 && *a3 && a3[1] != 0;
  long long v33 = 0uLL;
  long long v34 = 0uLL;
  long long v31 = 0uLL;
  long long v32 = 0uLL;
  uint64_t v13 = sub_100058E2C(0, 1, (uint64_t *)&__count);
  if (v13)
  {
LABEL_30:
    uint64_t v14 = v13;
    goto LABEL_20;
  }
  if (!__count)
  {
    uint64_t v14 = 4294967286;
    goto LABEL_20;
  }
  uint64_t v14 = 4294967285;
  if (!a4 || !a5 || !*(void *)a5 || __count > *(void *)(a5 + 8)) {
    goto LABEL_20;
  }
  if (v12)
  {
    if (!a3) {
      goto LABEL_20;
    }
    if (!*a3) {
      goto LABEL_20;
    }
    uint64_t v15 = a3[1];
    if (!v15) {
      goto LABEL_20;
    }
    uint64_t v13 = sub_100058E20(*a3, *a3 + v15, (uint64_t)__s);
    if (!v13)
    {
      uint64_t v13 = sub_10005C420(a2, (uint64_t)__s, v35, &v27, *a1, 0);
      if (!v13)
      {
        uint64_t v13 = sub_10005B584(a4, BYTE8(__s[1]) & 9, (unsigned __int8 *)v35, v27, (uint64_t)v29, (unsigned __int8 *)&v31);
        if (!v13)
        {
          *(_OWORD *)((char *)&v29[2] + 6) = *(_OWORD *)((char *)&__s[1] + 14);
          goto LABEL_21;
        }
      }
    }
    goto LABEL_30;
  }
  uint64_t v14 = sub_10005B584(a4, 0, 0, 0, (uint64_t)v29, (unsigned __int8 *)&v31);
  if (v14)
  {
LABEL_20:
    memset_s(__s, 0xB0uLL, 0, 0xB0uLL);
    goto LABEL_29;
  }
LABEL_21:
  uint64_t v16 = (char *)calloc(__count, 1uLL);
  if (!v16)
  {
    uint64_t v14 = 4294967279;
    goto LABEL_20;
  }
  uint64_t v17 = v16;
  uint64_t v24 = (uint64_t)v16;
  long long v25 = &v16[__count];
  if (sub_1000583FC(&v24, (uint64_t)v29))
  {
    long long v18 = v25;
    uint64_t v19 = v24;
    size_t v20 = &v17[__count] - v25;
    *(void *)(a5 + 8) = v20;
    memcpy(*(void **)a5, &v18[(void)v17 - v19], v20);
    if (a6)
    {
      long long v21 = *(_OWORD **)a6;
      if (*(void *)a6 && *(void *)(a6 + 8) >= 0x20uLL)
      {
        uint64_t v14 = 0;
        *(void *)(a6 + 8) = 32;
        long long v22 = v32;
        *long long v21 = v31;
        v21[1] = v22;
      }
      else
      {
        uint64_t v14 = 0xFFFFFFFFLL;
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
  }
  else
  {
    uint64_t v14 = 4294967273;
  }
  memset_s(__s, 0xB0uLL, 0, 0xB0uLL);
  memset_s(v17, __count, 0, __count);
  free(v17);
LABEL_29:
  memset_s(v35, 0x20uLL, 0, 0x20uLL);
  memset_s(&v31, 0x40uLL, 0, 0x40uLL);
  return v14;
}

uint64_t sub_10005B584(unsigned __int8 *src, int a2, unsigned __int8 *a3, unsigned int a4, uint64_t a5, unsigned __int8 *a6)
{
  memset(v16, 0, sizeof(v16));
  unsigned int v14 = 0;
  memset(__s, 0, sizeof(__s));
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 128) = 0u;
  *(_OWORD *)(a5 + 144) = 0u;
  *(_OWORD *)(a5 + 160) = 0u;
  *(_OWORD *)(a5 + 176) = 0u;
  *(_OWORD *)(a5 + 192) = 0u;
  *(_OWORD *)(a5 + 208) = 0u;
  *(_OWORD *)(a5 + 224) = 0u;
  *(_OWORD *)(a5 + 240) = 0u;
  *(_OWORD *)(a5 + 256) = 0u;
  *(void *)(a5 + 272) = 0;
  *(_OWORD *)(a5 + 16) = 0u;
  *(unsigned char *)(a5 + 36) = 1;
  *(_DWORD *)(a5 + 32) = a2 & 0xFFFFFFFD;
  uuid_copy((unsigned __int8 *)(a5 + 16), src);
  sub_1000593B0(a5, 8u);
  sub_1000593B0((uint64_t)a6, 0x20u);
  if (*(void *)(a5 + 8) || *(unsigned char *)(a5 + 37))
  {
    uint64_t v10 = 4294967284;
    goto LABEL_4;
  }
  if (a3)
  {
    if (sub_10005C910(a5, a3, a4, a6))
    {
LABEL_14:
      uint64_t v10 = 0xFFFFFFFFLL;
      goto LABEL_4;
    }
LABEL_13:
    uint64_t v10 = 0;
    goto LABEL_4;
  }
  int v13 = 40;
  uint64_t v10 = 4294967285;
  if (sub_10005D230(0x20u, &v14) && v14 <= 0x28)
  {
    uint64_t v12 = sub_10005A060(a5, __s);
    if (v12)
    {
      uint64_t v10 = v12;
      goto LABEL_4;
    }
    if (sub_10005CDF0((uint64_t)__s, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, (uint64_t *)a6, 0x20u, (void *)(a5 + 56), &v13))goto LABEL_14; {
    *(_DWORD *)(a5 + 32) |= 0x1000u;
    }
    goto LABEL_13;
  }
LABEL_4:
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  memset_s(v16, 0x20uLL, 0, 0x20uLL);
  return v10;
}

uint64_t sub_10005B74C(uint64_t *a1, unsigned int a2, uint64_t a3, uint64_t *a4, uint64_t *a5, uint64_t a6, uint64_t a7)
{
  memset(__s, 0, 32);
  size_t v29 = 32;
  uint64_t v35 = 0;
  long long v33 = 0u;
  memset(v34, 0, sizeof(v34));
  long long v32 = 0u;
  BOOL v9 = a4 && *a4 && a4[1] != 0;
  long long v38 = 0uLL;
  long long v39 = 0uLL;
  long long v36 = 0uLL;
  long long v37 = 0uLL;
  size_t v27 = 0;
  rsize_t __n = 0;
  memset(dst, 0, sizeof(dst));
  memset(v30, 0, sizeof(v30));
  int v26 = 0;
  if (!a5) {
    goto LABEL_48;
  }
  if (!*a5) {
    goto LABEL_48;
  }
  uint64_t v10 = a5[1];
  if (!v10) {
    goto LABEL_48;
  }
  if (v9)
  {
    uint64_t v11 = *a1;
    if ((v11 & 0x40) == 0)
    {
      uint64_t v12 = sub_10005A194(v11, (a2 >> 1) & 1, a3, a4, __s, &v29, &v26, v30, dst, &v27);
      if (!v12)
      {
        uint64_t v12 = sub_100058A20(*a5, *a5 + a5[1], (uint64_t)&v32);
        if (!v12)
        {
          int v13 = __s;
          goto LABEL_15;
        }
      }
LABEL_49:
      uint64_t v17 = v12;
      goto LABEL_39;
    }
    if (a4 && a4[1] == 16)
    {
      uuid_copy(v30, (const unsigned __int8 *)*a4);
      uint64_t v17 = 4294967284;
      goto LABEL_39;
    }
LABEL_48:
    uint64_t v17 = 4294967285;
    goto LABEL_39;
  }
  uint64_t v12 = sub_100058A20(*a5, *a5 + v10, (uint64_t)&v32);
  if (v12) {
    goto LABEL_49;
  }
  uuid_copy(dst, (const unsigned __int8 *)v34 + 6);
  int v13 = 0;
LABEL_15:
  if (v9) {
    unint64_t v14 = v29;
  }
  else {
    unint64_t v14 = 0;
  }
  uint64_t v12 = sub_100059C1C((uint64_t)v13, v14, (uint64_t)&v32, (uint64_t)&v36);
  if (v12) {
    goto LABEL_49;
  }
  if (!a7)
  {
LABEL_23:
    uint64_t v17 = 0;
    int v18 = 1;
LABEL_24:
    long long v43 = v33;
    goto LABEL_25;
  }
  uint64_t v15 = *(_OWORD **)a7;
  if (*(void *)a7 && *(void *)(a7 + 8) >= 0x20uLL)
  {
    *(void *)(a7 + 8) = 32;
    long long v16 = v37;
    *uint64_t v15 = v36;
    v15[1] = v16;
    goto LABEL_23;
  }
  uint64_t v17 = 0xFFFFFFFFLL;
LABEL_39:
  long long v43 = 0uLL;
  if ((byte_100084EE0 & 1) == 0)
  {
    int v18 = 0;
    goto LABEL_24;
  }
  uint64_t v41 = 0;
  v42[0] = 0;
  *(void *)((char *)v42 + 6) = 0;
  if (v9) {
    sub_1000595C8("kek group", (uint64_t)dst, 0x10uLL);
  }
  if (a5)
  {
    if (*a5)
    {
      uint64_t v25 = a5[1];
      if (v25)
      {
        sub_10005866C(*a5, *a5 + v25, (int *)&v41, 0, 0, &v43, 0, 1);
        sub_1000595C8("vek group", (uint64_t)&v41 + 6, 0x10uLL);
      }
    }
  }
  int v18 = 0;
LABEL_25:
  uint64_t v19 = __stdoutp;
  if (v9) {
    size_t v20 = v30;
  }
  else {
    size_t v20 = (unsigned __int8 *)&v43;
  }
  if (v9) {
    long long v21 = "user";
  }
  else {
    long long v21 = "volume";
  }
  long long v22 = sub_1000597A8(v20, 0x10uLL);
  long long v23 = "failed";
  if (v18) {
    long long v23 = "successful";
  }
  fprintf(v19, "%s%s:%s%s%s%s%u:%s%u:%s %s %s unlock %s (%d)%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "_unlock_result", ":", 3849, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, v21, v22, v23, v17, (const char *)&unk_100062362);
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  memset_s(&v36, 0x40uLL, 0, 0x40uLL);
  if (v27)
  {
    memset_s(v27, __n, 0, __n);
    free(v27);
  }
  return v17;
}

uint64_t sub_10005BADC(unsigned char *a1, unsigned int a2, uint64_t a3, const unsigned __int8 *a4, uint64_t a5)
{
  return sub_10005BAF0(a1, a2, a3, a4, byte_10007ED48, 0, a5);
}

uint64_t sub_10005BAF0(unsigned char *a1, unsigned int a2, uint64_t a3, const unsigned __int8 *a4, const unsigned __int8 *a5, long long *a6, uint64_t a7)
{
  memset(__s, 0, sizeof(__s));
  size_t __count = 0;
  uint64_t v14 = sub_100058E2C(0, 2, (uint64_t *)&__count);
  if (v14) {
    goto LABEL_13;
  }
  if (!__count)
  {
    uint64_t v20 = 4294967286;
    goto LABEL_16;
  }
  if (!a7 || !*(void *)a7 || __count > *(void *)(a7 + 8))
  {
    uint64_t v20 = 4294967285;
LABEL_16:
    memset_s(__s, 0xB0uLL, 0, 0xB0uLL);
    return v20;
  }
  uint64_t v14 = sub_10005BCCC(a5, a4, a2 & 1 | (((a2 >> 2) & 1) << 11), a3, a6, (uint64_t)__s, *a1 & 4);
  if (v14)
  {
LABEL_13:
    uint64_t v20 = v14;
    goto LABEL_16;
  }
  uint64_t v15 = (char *)calloc(__count, 1uLL);
  if (!v15)
  {
    uint64_t v20 = 4294967279;
    goto LABEL_16;
  }
  long long v16 = v15;
  uint64_t v22 = (uint64_t)v15;
  long long v23 = &v15[__count];
  if (sub_100058A2C(&v22, (uint64_t)__s))
  {
    uint64_t v17 = v23;
    uint64_t v18 = v22;
    size_t v19 = &v16[__count] - v23;
    *(void *)(a7 + 8) = v19;
    memcpy(*(void **)a7, &v17[(void)v16 - v18], v19);
    uint64_t v20 = 0;
  }
  else
  {
    uint64_t v20 = 4294967273;
  }
  memset_s(__s, 0xB0uLL, 0, 0xB0uLL);
  memset_s(v16, __count, 0, __count);
  free(v16);
  return v20;
}

uint64_t sub_10005BCCC(const unsigned __int8 *a1, const unsigned __int8 *a2, int a3, uint64_t a4, long long *a5, uint64_t a6, char a7)
{
  memset(v32, 0, sizeof(v32));
  rsize_t __n = 0;
  size_t v29 = 32;
  long long v30 = 0u;
  long long v31 = 0u;
  size_t v27 = 0;
  unsigned int v26 = 0;
  if (!a2)
  {
    uint64_t v16 = 0xFFFFFFFFLL;
    goto LABEL_39;
  }
  if (!a6)
  {
    uint64_t v16 = 4294967285;
    goto LABEL_37;
  }
  uint64_t v12 = sub_100059858(&v27, a4, (a7 & 4) != 0);
  if (v12) {
    goto LABEL_40;
  }
  if (a5)
  {
    long long v13 = a5[1];
    long long v30 = *a5;
    long long v31 = v13;
  }
  else
  {
    sub_1000593B0((uint64_t)&v30, 0x20u);
  }
  *(_OWORD *)a6 = 0u;
  *(_OWORD *)(a6 + 16) = 0u;
  *(_DWORD *)(a6 + 24) = (8 * a3) & 0x10 | a3 & 0xFFFFF9BD;
  uint64_t v14 = (unsigned char *)(a6 + 24);
  *(_OWORD *)(a6 + 144) = 0u;
  *(_OWORD *)(a6 + 160) = 0u;
  *(_OWORD *)(a6 + 112) = 0u;
  *(_OWORD *)(a6 + 128) = 0u;
  *(_OWORD *)(a6 + 80) = 0u;
  *(_OWORD *)(a6 + 96) = 0u;
  *(_OWORD *)(a6 + 48) = 0u;
  *(_OWORD *)(a6 + 64) = 0u;
  *(_OWORD *)(a6 + 32) = 0u;
  *(unsigned char *)(a6 + 28) = 2;
  uint64_t v15 = (_OWORD *)(a6 + 30);
  if (uuid_compare(byte_10007ED48, a1))
  {
    *uint64_t v15 = *(_OWORD *)a1;
  }
  else
  {
    uint64_t v17 = 16;
    while (1)
    {
      uuid_generate((unsigned __int8 *)(a6 + 30));
      if (*(unsigned char *)v15 || *(unsigned char *)(a6 + 31)) {
        break;
      }
      if (!--v17)
      {
        fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s failed to generate valid kek group uuid after 16 attempts%s\n", "aks", (const char *)&unk_100062362, (const char *)&unk_100062362, (const char *)&unk_100062362, "_create_kek_data", ":", 4174, (const char *)&unk_100062362, 0, (const char *)&unk_100062362, (const char *)&unk_100062362);
        uint64_t v16 = 4294967286;
        goto LABEL_37;
      }
    }
  }
  uuid_copy((unsigned __int8 *)(a6 + 8), a2);
  sub_10005823C(a6);
  if (*(void *)a6) {
    goto LABEL_10;
  }
  if (*(unsigned char *)(a6 + 29) != 1)
  {
    if (*(unsigned char *)(a6 + 29))
    {
LABEL_10:
      uint64_t v16 = 4294967284;
      goto LABEL_37;
    }
    sub_1000593B0(a6 + 96, 0x10u);
    memset(__s, 0, sizeof(__s));
    uint64_t v18 = mach_continuous_time();
    ccsha256_di();
    if (ccpbkdf2_hmac())
    {
      unint64_t v21 = 0;
    }
    else
    {
      uint64_t v19 = mach_continuous_time();
      memset_s(__s, 0x20uLL, 0, 0x20uLL);
      unint64_t v20 = sub_10005955C(v19 - v18);
      unint64_t v21 = 100000;
      if (v20) {
        unint64_t v21 = 0x174876E800 / v20;
      }
    }
    if (v21 <= 0x186A0) {
      unint64_t v21 = 100000;
    }
    *(void *)(a6 + 88) = v21;
    uint64_t v12 = sub_10005C5C4(a6, v27, __n, v32, &v29);
    if (!v12)
    {
      LODWORD(__s[0]) = 40;
      uint64_t v16 = 4294967285;
      if (sub_10005D230(0x20u, &v26) && v26 <= 0x28)
      {
        uint64_t v22 = (void *)(a6 + 48);
        unsigned int v23 = v29;
LABEL_31:
        if (sub_10005CDF0((uint64_t)v32, v23, 0xA6A6A6A6A6A6A6A6, 0, (uint64_t *)&v30, 0x20u, v22, __s)
          || (*v14 & 1) != 0 && (sub_100059970() & 1) == 0)
        {
          uint64_t v16 = 0xFFFFFFFFLL;
        }
        else
        {
          unsigned int v24 = sub_100058234();
          if (v24 <= 0x15) {
            bzero(&v14[v24], 22 - v24);
          }
          uint64_t v16 = 0;
        }
        goto LABEL_37;
      }
      goto LABEL_37;
    }
LABEL_40:
    uint64_t v16 = v12;
    goto LABEL_37;
  }
  uint64_t v12 = sub_10005C5C4(a6, v27, __n, v32, &v29);
  if (v12) {
    goto LABEL_40;
  }
  LODWORD(__s[0]) = 40;
  uint64_t v16 = 4294967285;
  if (sub_10005D230(0x20u, &v26) && v26 <= 0x28)
  {
    unsigned int v23 = v29;
    uint64_t v22 = (void *)(a6 + 48);
    goto LABEL_31;
  }
LABEL_37:
  if (v27)
  {
    memset_s(v27, __n, 0, __n);
    free(v27);
  }
LABEL_39:
  memset_s(v32, 0x20uLL, 0, 0x20uLL);
  memset_s(&v30, 0x20uLL, 0, 0x20uLL);
  return v16;
}

uint64_t sub_10005C0E0(void *a1, uint64_t a2, uint64_t *a3, const unsigned __int8 *a4, uint64_t a5, uint64_t a6)
{
  memset(v45, 0, sizeof(v45));
  memset(v44, 0, sizeof(v44));
  size_t __count = 0;
  size_t v27 = 32;
  long long v42 = 0u;
  long long v43 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v38 = 0u;
  memset(__s, 0, sizeof(__s));
  long long v36 = 0u;
  long long v37 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  uint64_t v12 = sub_100058E2C(0, 2, (uint64_t *)&__count);
  if (v12) {
    goto LABEL_26;
  }
  if (!__count)
  {
    uint64_t v14 = 0;
    int v13 = 0;
    uint64_t v15 = 4294967286;
    goto LABEL_21;
  }
  int v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 4294967285;
  if (a4 && a5 && a6)
  {
    if (!*(void *)a6) {
      goto LABEL_27;
    }
    size_t v16 = *(void *)(a6 + 8);
    if (!v16) {
      goto LABEL_27;
    }
    int v13 = 0;
    uint64_t v14 = 0;
    uint64_t v15 = 4294967285;
    if (a3 && __count <= v16)
    {
      if (*a3)
      {
        uint64_t v17 = a3[1];
        if (v17)
        {
          uint64_t v12 = sub_100058E20(*a3, *a3 + v17, (uint64_t)__s);
          if (!v12)
          {
            if ((BYTE8(__s[1]) & 0x80) != 0 && (void)v40)
            {
              uint64_t v14 = 0;
              int v13 = 0;
              uint64_t v15 = 4294967263;
              goto LABEL_21;
            }
            uint64_t v12 = sub_10005C420(a2, (uint64_t)__s, v45, &v27, *a1, 0);
            if (!v12)
            {
              int v13 = DWORD2(__s[1]);
              uint64_t v18 = sub_10005BCCC((const unsigned __int8 *)&__s[1] + 14, a4, SDWORD2(__s[1]), a5, v45, (uint64_t)&v28, *a1);
              if (v18)
              {
                uint64_t v15 = v18;
                uint64_t v14 = 0;
              }
              else
              {
                uint64_t v19 = (char *)calloc(__count, 1uLL);
                uint64_t v14 = v19;
                if (v19)
                {
                  uint64_t v24 = (uint64_t)v19;
                  uint64_t v25 = &v19[__count];
                  if (sub_100058A2C(&v24, (uint64_t)&v28))
                  {
                    unint64_t v20 = v25;
                    uint64_t v21 = v24;
                    size_t v22 = &v14[__count] - v25;
                    *(void *)(a6 + 8) = v22;
                    memcpy(*(void **)a6, &v20[(void)v14 - v21], v22);
                    uint64_t v15 = 0;
                  }
                  else
                  {
                    uint64_t v15 = 4294967273;
                  }
                }
                else
                {
                  uint64_t v15 = 4294967279;
                }
              }
              goto LABEL_21;
            }
          }
LABEL_26:
          uint64_t v15 = v12;
          uint64_t v14 = 0;
          int v13 = 0;
          goto LABEL_21;
        }
      }
LABEL_27:
      uint64_t v14 = 0;
      int v13 = 0;
      uint64_t v15 = 4294967285;
    }
  }
LABEL_21:
  if (byte_100084EE0) {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s %sresult: %d; passcode_change: %d; cf: 0x%x; of: 0x%x; nf: 0x%x%s\n",
  }
      "aks",
      (const char *)&unk_100062362,
      (const char *)&unk_100062362,
      (const char *)&unk_100062362,
      "fv_rewrap_kek",
      ":",
      4586,
      (const char *)&unk_100062362,
      0,
      (const char *)&unk_100062362,
      (const char *)&unk_100062362,
      v15,
      0,
      v13,
      DWORD2(__s[1]),
      DWORD2(v29),
      (const char *)&unk_100062362);
  memset_s(__s, 0xB0uLL, 0, 0xB0uLL);
  memset_s(&v28, 0xB0uLL, 0, 0xB0uLL);
  if (v14)
  {
    memset_s(v14, __count, 0, __count);
    free(v14);
  }
  memset_s(v45, 0x20uLL, 0, 0x20uLL);
  memset_s(v44, 0x20uLL, 0, 0x20uLL);
  return v15;
}

uint64_t sub_10005C420(uint64_t a1, uint64_t a2, void *a3, size_t *a4, char a5, void **a6)
{
  memset(__s, 0, sizeof(__s));
  *(void *)&__n[1] = 32;
  __uuid_t src = 0u;
  long long v19 = 0u;
  __n[0] = 32;
  uint64_t v15 = 0;
  rsize_t __smax = 0;
  uint64_t v6 = 4294967285;
  if (a1 && a2)
  {
    uint64_t v11 = sub_100059858(&v15, a1, (a5 & 4) != 0);
    if (v11
      || (uint64_t v11 = sub_10005C5C4(a2, v15, __smax, __s, (size_t *)&__n[1]), v11)
      || (uint64_t v11 = sub_10005C76C(a2, (uint64_t)__s, __n[1], &__src, __n), v11))
    {
      uint64_t v6 = v11;
    }
    else
    {
      if (a3 && a4)
      {
        if ((*(unsigned char *)(a2 + 120) & 1) != 0 && !sub_10005959C((unsigned __int8 *)&v19, 16)) {
          *(_DWORD *)(a2 + 24) |= 0x10u;
        }
        if ((*(unsigned char *)(a2 + 24) & 0x10) != 0)
        {
          size_t v12 = 16;
          __n[0] = 16;
        }
        else
        {
          size_t v12 = __n[0];
        }
        memcpy(a3, &__src, v12);
        *a4 = v12;
      }
      uint64_t v6 = 0;
      if (a6)
      {
        rsize_t v13 = __smax;
        *a6 = v15;
        a6[1] = (void *)v13;
        uint64_t v15 = 0;
        rsize_t __smax = 0;
      }
    }
  }
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  memset_s(&__src, 0x20uLL, 0, 0x20uLL);
  if (v15)
  {
    memset_s(v15, __smax, 0, __smax);
    free(v15);
  }
  return v6;
}

uint64_t sub_10005C5C4(uint64_t a1, void *__src, size_t __n, void *a4, size_t *a5)
{
  memset(v14, 0, sizeof(v14));
  if (*(unsigned char *)(a1 + 28) != 2 || *a5 != 32)
  {
    uint64_t v12 = 4294967285;
    goto LABEL_18;
  }
  int v10 = *(_DWORD *)(a1 + 24);
  if ((v10 & 2) != 0) {
    size_t v11 = 16;
  }
  else {
    size_t v11 = 32;
  }
  if (v10)
  {
    ccsha256_di();
    if (j__ccpbkdf2_hmac()) {
      goto LABEL_14;
    }
    if (!sub_100059970()) {
      goto LABEL_20;
    }
  }
  if (!*(void *)a1)
  {
    if (*(unsigned char *)(a1 + 29) != 1)
    {
      if (*(unsigned char *)(a1 + 29)) {
        goto LABEL_10;
      }
      ccsha256_di();
      if (j__ccpbkdf2_hmac())
      {
LABEL_14:
        uint64_t v12 = 4294967274;
        goto LABEL_18;
      }
LABEL_17:
      memcpy(a4, v14, v11);
      uint64_t v12 = 0;
      *a5 = v11;
      goto LABEL_18;
    }
    if (__n <= 0x20)
    {
      memcpy(v14, __src, __n);
      size_t v11 = __n;
      goto LABEL_17;
    }
LABEL_20:
    uint64_t v12 = 0xFFFFFFFFLL;
    goto LABEL_18;
  }
LABEL_10:
  uint64_t v12 = 4294967284;
LABEL_18:
  memset_s(v14, 0x20uLL, 0, 0x20uLL);
  return v12;
}

uint64_t sub_10005C76C(uint64_t a1, uint64_t a2, unsigned int a3, void *a4, _DWORD *a5)
{
  if (*a5 != 32) {
    return 4294967285;
  }
  if (*(void *)a1 || *(unsigned __int8 *)(a1 + 29) > 1u) {
    return 4294967284;
  }
  if ((*(unsigned char *)(a1 + 24) & 2) != 0)
  {
    *a5 = 16;
    unsigned int v10 = 24;
  }
  else
  {
    unsigned int v10 = 40;
  }
  size_t v12 = v10;
  unsigned int v13 = __chkstk_darwin();
  uint64_t v15 = (char *)&v16 - v14;
  HIDWORD(v16) = 0;
  if (!sub_10005D25C(v13, (unsigned int *)&v16 + 1) || HIDWORD(v16) > *a5) {
    return 4294967285;
  }
  memcpy(v15, (const void *)(a1 + 48), v12);
  if ((*(unsigned char *)(a1 + 24) & 1) != 0 && !sub_100059970()) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = sub_10005D1C4(a2, a3, 0xA6A6A6A6A6A6A6A6, 0, v15, v12, a4, a5);
  if (result) {
    return 4294967291;
  }
  return result;
}

uint64_t sub_10005C910(uint64_t a1, unsigned __int8 *a2, unsigned int a3, unsigned __int8 *a4)
{
  unsigned int v11 = 0;
  if (!sub_10005959C(a2, 32))
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Internal Error: Null KEK, file radar%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "_bind_unmanaged_vek");
    return 4294967286;
  }
  if (!sub_10005959C(a4, 32))
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Internal Error: Null VEK, file radar%s\n", "aks", &unk_100062362, &unk_100062362, &unk_100062362, "_bind_unmanaged_vek");
    return 4294967286;
  }
  if (*(void *)(a1 + 8)) {
    return 4294967284;
  }
  int v9 = sub_10005D230(0x20u, &v11);
  uint64_t result = 4294967285;
  if (v9 && v11 <= 0x28)
  {
    if (!sub_10005CDF0((uint64_t)a2, a3, 0xA6A6A6A6A6A6A6A6, 0, (uint64_t *)a4, 0x20u, (void *)(a1 + 56), &v11))
    {
      int v10 = *(_DWORD *)(a1 + 32);
      if ((v10 & 1) == 0)
      {
LABEL_11:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 32) = v10 & 0xFFFFEFFF;
        return result;
      }
      if (sub_100059970())
      {
        int v10 = *(_DWORD *)(a1 + 32);
        goto LABEL_11;
      }
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_10005CACC(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return _cccbc_update(a1, a2, a3, a4 >> 4);
}

uint64_t sub_10005CAD8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), uint64_t *a5, unint64_t a6, void *a7, unint64_t *a8)
{
  uint64_t v41 = a1;
  uint64_t v42 = a3;
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = ccaes_cbc_encrypt_mode();
  __chkstk_darwin();
  uint64_t v43 = (uint64_t)&v36 - v15;
  bzero((char *)&v36 - v15, v15);
  __chkstk_darwin();
  uint64_t v17 = (char *)&v36 - v16;
  bzero((char *)&v36 - v16, v16);
  uint64_t v18 = 0xFFFFFFFFLL;
  if (HIDWORD(a6) || (a6 - 40) < 0xFFFFFFE0) {
    goto LABEL_30;
  }
  long long v39 = &v36;
  long long v40 = a8;
  long long v38 = a7;
  if (!a4)
  {
    BOOL v20 = (a2 & 0xFFFFFFFFFFFFFFF7) == 0x10 || a2 == 32;
    if (!v20 || !a8 || *a8 < a6 + 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_31;
    }
    unint64_t v37 = a6 + 8;
    cccbc_init();
    goto LABEL_15;
  }
  if (a8)
  {
    unint64_t v19 = *v40;
    unint64_t v37 = a6 + 8;
    if (v19 >= a6 + 8)
    {
LABEL_15:
      uint64_t v21 = 0;
      unsigned int v22 = a6 >> 3;
      if (a6 >> 3 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = v22;
      }
      do
      {
        uint64_t v24 = *a5++;
        *((void *)&__s[v21++] + 1) = v24;
      }
      while (v23 != v21);
      uint64_t v25 = 0;
      *(void *)&__s[0] = v42;
      uint64_t v26 = 1;
      uint64_t v41 = v22;
      do
      {
        uint64_t v42 = v25;
        uint64_t v27 = 0;
        long long v28 = (uint64_t *)__s;
        do
        {
          if (a4)
          {
            if ((a4(1, &unk_100084EE8, v28, v28, 16) & 1) == 0) {
              goto LABEL_6;
            }
          }
          else
          {
            cccbc_clear_iv();
            sub_10005CACC(v14, v43, (uint64_t)v17, 0x10uLL);
          }
          uint64_t v29 = *v28;
          v28 += 2;
          unint64_t v30 = v29 ^ bswap64(v26 + v27++);
          *(void *)&__s[v27 % v22] = v30;
        }
        while (v23 != v27);
        uint64_t v25 = v42 + 1;
        v26 += v41;
      }
      while (v42 != 5);
      long long v31 = v38;
      *long long v38 = *(void *)&__s[0];
      long long v32 = v31 + 1;
      long long v33 = (uint64_t *)__s + 1;
      do
      {
        uint64_t v34 = *v33;
        v33 += 2;
        *v32++ = v34;
        --v23;
      }
      while (v23);
      uint64_t v18 = 0;
      *long long v40 = v37 & 0xFFFFFFF8;
LABEL_30:
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      if (a4) {
        return v18;
      }
LABEL_31:
      cc_clear();
      return v18;
    }
  }
LABEL_6:
  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10005CDF0(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(uint64_t, void *, uint64_t *, uint64_t *, uint64_t), uint64_t *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  unint64_t v11 = *a8;
  uint64_t v9 = sub_10005CAD8(a1, a2, a3, a4, a5, a6, a7, &v11);
  sub_1000598F0(HIDWORD(v11) == 0, 171, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t sub_10005CE5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, void *, unint64_t *, unint64_t *, uint64_t), void *a5, unint64_t a6, void *a7, void *a8)
{
  unint64_t v45 = a5;
  uint64_t v43 = a1;
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = ccaes_cbc_decrypt_mode();
  __chkstk_darwin();
  uint64_t v46 = (uint64_t)&v37 - v15;
  bzero((char *)&v37 - v15, v15);
  __chkstk_darwin();
  uint64_t v17 = (char *)&v37 - v16;
  bzero((char *)&v37 - v16, v16);
  uint64_t v18 = 0xFFFFFFFFLL;
  if (HIDWORD(a6)) {
    goto LABEL_33;
  }
  uint64_t v39 = a3;
  unsigned int v19 = a6 >> 3;
  if ((a6 >> 3) - 6 < 0xFFFFFFFC) {
    goto LABEL_33;
  }
  long long v40 = &v37;
  uint64_t v41 = a8;
  long long v38 = a7;
  unint64_t v44 = a6;
  if (!a4)
  {
    BOOL v20 = (a2 & 0xFFFFFFFFFFFFFFF7) == 0x10 || a2 == 32;
    if (!v20 || !a8 || *a8 < a6 - 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_34;
    }
    cccbc_init();
    goto LABEL_15;
  }
  if (a8 && *v41 >= v44 - 8)
  {
LABEL_15:
    *(void *)&__s[0] = *v45;
    uint64_t v21 = v19 - 1;
    if (v19 != 1)
    {
      unsigned int v22 = (void *)__s + 1;
      uint64_t v23 = v45 + 1;
      uint64_t v24 = v19 - 1;
      do
      {
        uint64_t v25 = *v23++;
        *unsigned int v22 = v25;
        v22 += 2;
        --v24;
      }
      while (v24);
    }
    int v26 = 6 * v19 - 6;
    LODWORD(v43) = 1 - v19;
    int v27 = 5;
    uint64_t v42 = (unint64_t *)&__s[v19 - 2];
    do
    {
      LODWORD(v45) = v27;
      if (v44 >= 0x10)
      {
        long long v28 = v42;
        int v29 = v21;
        unsigned int v30 = v26;
        do
        {
          *long long v28 = *(void *)&__s[v29 % v21] ^ bswap64(v30);
          if (a4)
          {
            if ((a4(0, &unk_100084EE8, v28, v28, 16) & 1) == 0) {
              goto LABEL_6;
            }
          }
          else
          {
            cccbc_clear_iv();
            sub_10005CACC(v14, v46, (uint64_t)v17, 0x10uLL);
          }
          --v30;
          v28 -= 2;
          BOOL v31 = __OFSUB__(v29--, 1);
        }
        while (!((v29 < 0) ^ v31 | (v29 == 0)));
      }
      int v27 = v45 - 1;
      v26 += v43;
    }
    while (v45);
    if (*(void *)&__s[0] == v39)
    {
      long long v32 = v38;
      if (v21)
      {
        long long v33 = (uint64_t *)__s + 1;
        uint64_t v34 = v21;
        do
        {
          uint64_t v35 = *v33;
          v33 += 2;
          *v32++ = v35;
          --v34;
        }
        while (v34);
      }
      uint64_t v18 = 0;
      *uint64_t v41 = (8 * v21);
    }
    else
    {
      uint64_t v18 = 0xFFFFFFFFLL;
    }
LABEL_33:
    memset_s(__s, 0x40uLL, 0, 0x40uLL);
    if (a4) {
      return v18;
    }
LABEL_34:
    cc_clear();
    return v18;
  }
LABEL_6:
  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10005D1C4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(void, void *, unint64_t *, unint64_t *, uint64_t), void *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  uint64_t v11 = *a8;
  uint64_t v9 = sub_10005CE5C(a1, a2, a3, a4, a5, a6, a7, &v11);
  sub_1000598F0(HIDWORD(v11) == 0, 261, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t sub_10005D230(unsigned int a1, _DWORD *a2)
{
  uint64_t v2 = a1 + 15;
  uint64_t v3 = v2 << 31 >> 31;
  BOOL v4 = v3 != v2 || v3 < 0;
  int v5 = v4;
  if (!v4) {
    *a2 = v3 & 0xFFFFFFF8;
  }
  return v5 ^ 1u;
}

BOOL sub_10005D25C(unsigned int a1, unsigned int *a2)
{
  unsigned int v2 = a1 - 8;
  BOOL result = a1 > 7;
  *a2 = v2;
  return result;
}

BOOL sub_10005D270(unint64_t a1, unint64_t *a2)
{
  unint64_t v2 = a1 - 8;
  BOOL result = a1 > 7;
  *a2 = v2;
  return result;
}

void sub_10005D284()
{
  __assert_rtn("spaceman_free_extent_cache_insert", "spaceman_fxc.c", 1868, "FXTP_INDEX(fxtp, fxtp->fxtp_end_level) == index");
}

void sub_10005D2B0()
{
  __assert_rtn("spaceman_free_extent_cache_insert", "spaceman_fxc.c", 1857, "succ_length == fxc->fxc_smallest.pr_block_count");
}

void sub_10005D2DC()
{
  __assert_rtn("spaceman_free_extent_cache_insert", "spaceman_fxc.c", 1803, "FXTP_INDEX(fxtp, fxtp->fxtp_end_level) == new_index");
}

void sub_10005D308()
{
  __assert_rtn("spaceman_fxc_tree_node_recycle_smallest", "spaceman_fxc.c", 603, "smallest_index == FXTP_INDEX(fxtp, fxtp->fxtp_end_level)");
}

void sub_10005D334()
{
  __assert_rtn("spaceman_fxc_tree_balance_factor_get", "spaceman_fxc.h", 113, "whichtree == SM_FXC_PADDR_TREE || whichtree == SM_FXC_LENGTH_TREE");
}

void sub_10005D360()
{
  __assert_rtn("spaceman_fxc_tree_insert_at_path", "spaceman_fxc.c", 1075, "fxc->fxc_tree_root[whichtree] == SM_FXC_TREE_NODE_INVALID");
}

void sub_10005D38C()
{
  __assert_rtn("spaceman_fxc_tree_balance_factor_set", "spaceman_fxc.h", 129, "whichtree == SM_FXC_PADDR_TREE || whichtree == SM_FXC_LENGTH_TREE");
}

void sub_10005D3B8()
{
  __assert_rtn("spaceman_fxc_tree_node_alloc", "spaceman_fxc.c", 681, "!fxc->fxc_nx || (length <= fxc->fxc_sm->sm_phys->sm_dev[fxc->fxc_dev].sm_block_count)");
}

void sub_10005D3E4()
{
  __assert_rtn("spaceman_fxc_tree_node_alloc", "spaceman_fxc.c", 682, "!fxc->fxc_nx || ((fxc->fxc_block_count + length) <= fxc->fxc_sm->sm_phys->sm_dev[fxc->fxc_dev].sm_block_count)");
}

void sub_10005D410()
{
  __assert_rtn("spaceman_fxc_tree_insert_at_path", "spaceman_fxc.c", 1062, "length == spaceman_fxc_tree_node_length_get(n)");
}

void sub_10005D43C()
{
  __assert_rtn("spaceman_fxc_tree_insert_at_path", "spaceman_fxc.c", 1061, "paddr == spaceman_fxc_tree_node_paddr_get(n)");
}

void sub_10005D468()
{
  __assert_rtn("spaceman_fxc_tree_insert", "spaceman_fxc.c", 1171, "length == spaceman_fxc_tree_node_length_get(&SM_FXC_NODE(fxc, FXTP_INDEX(fxtp, fxtp->fxtp_end_level)))");
}

void sub_10005D494()
{
  __assert_rtn("spaceman_fxc_tree_insert", "spaceman_fxc.c", 1170, "paddr == spaceman_fxc_tree_node_paddr_get(&SM_FXC_NODE(fxc, FXTP_INDEX(fxtp, fxtp->fxtp_end_level)))");
}

void sub_10005D4C0()
{
  __assert_rtn("spaceman_fxc_tree_node_free", "spaceman_fxc.c", 708, "fxc->fxc_block_count >= length");
}

void sub_10005D4EC()
{
}

void sub_10005D518()
{
}

void sub_10005D544()
{
  __assert_rtn("spaceman_fxc_tree_delete_at_path", "spaceman_fxc.c", 1297, "bf == 0");
}

void sub_10005D570()
{
  __assert_rtn("spaceman_fxc_tree_delete_at_path", "spaceman_fxc.c", 1316, "spaceman_fxc_tree_balance_factor_get(nchild, whichtree) == direction");
}

void sub_10005D59C()
{
  __assert_rtn("spaceman_fxc_tree_delete_at_path", "spaceman_fxc.c", 1315, "spaceman_fxc_tree_balance_factor_get(n, whichtree) == opposite_direction");
}

void sub_10005D5C8()
{
  __assert_rtn("spaceman_fxc_tree_delete_at_path", "spaceman_fxc.c", 1320, "spaceman_fxc_tree_balance_factor_get(nchild, whichtree) == 0");
}

void sub_10005D5F4()
{
  __assert_rtn("spaceman_fxc_tree_delete_at_path", "spaceman_fxc.c", 1319, "spaceman_fxc_tree_balance_factor_get(n, whichtree) == 0");
}

void sub_10005D620()
{
  __assert_rtn("spaceman_free_extent_cache_remove", "spaceman_fxc.c", 2021, "paddr2_length == fxc->fxc_smallest.pr_block_count");
}

void sub_10005D64C()
{
  __assert_rtn("spaceman_free_extent_cache_search", "spaceman_fxc.c", 2853, "length == desired_length");
}

void sub_10005D678()
{
  __assert_rtn("spaceman_free_extent_cache_search", "spaceman_fxc.c", 2852, "paddr == paddr_hint");
}

void sub_10005D6A4()
{
  __assert_rtn("spaceman_fxc_tree_single_rotate", "spaceman_fxc.c", 941, "root != SM_FXC_TREE_NODE_INVALID");
}

void sub_10005D6D0()
{
  __assert_rtn("spaceman_fxc_tree_single_rotate", "spaceman_fxc.c", 945, "pivot != SM_FXC_TREE_NODE_INVALID");
}

void sub_10005D6FC()
{
  __assert_rtn("spaceman_fxc_tree_double_rotate", "spaceman_fxc.c", 984, "root != SM_FXC_TREE_NODE_INVALID");
}

void sub_10005D728()
{
  __assert_rtn("spaceman_fxc_tree_double_rotate", "spaceman_fxc.c", 985, "pivot != SM_FXC_TREE_NODE_INVALID");
}

void sub_10005D754()
{
  __assert_rtn("spaceman_fxc_tree_double_rotate", "spaceman_fxc.c", 989, "pivot2 != SM_FXC_TREE_NODE_INVALID");
}

void sub_10005D780()
{
  __assert_rtn("spaceman_fxc_tree_double_rotate", "spaceman_fxc.c", 1019, "bf == opposite_direction");
}

void sub_10005D7AC()
{
  __assert_rtn("tx_checkpoint_write", "tx.c", 655, "o == STAILQ_FIRST(&nx->nx_oc->oc_ephemeral_flush_list)");
}

void sub_10005D7D8()
{
}

void sub_10005D804()
{
  __assert_rtn("tx_transition", "tx.c", 353, "(new_flags == 0) || !(tx->tx_flags & new_flags)");
}

void sub_10005D830()
{
}

void sub_10005D85C()
{
  __assert_rtn("tx_transition", "tx.c", 349, "(old_flags == 0) || (tx->tx_flags & old_flags)");
}

void sub_10005D888()
{
}

void sub_10005D8B4()
{
}

void sub_10005D8E0()
{
}

void sub_10005D90C()
{
  __assert_rtn("tx_leave", "tx.c", 2460, "xid == tx->tx_xid");
}

void sub_10005D938()
{
  __assert_rtn("tx_flush", "tx.c", 1033, "tx->tx_xp_data_len == ((tm_xp_data_next > tx->tx_sb->nx_xp_data_index) ? (tm_xp_data_next - tx->tx_sb->nx_xp_data_index) : (tm_xp_data_next + tm->tm_xp_data_blocks - tx->tx_sb->nx_xp_data_index))");
}

void sub_10005D964()
{
  __assert_rtn("tx_flush", "tx.c", 1030, "tx->tx_xp_desc_len == ((tm_xp_desc_next > tx->tx_sb->nx_xp_desc_index) ? (tm_xp_desc_next - tx->tx_sb->nx_xp_desc_index) : (tm_xp_desc_next + tm->tm_xp_desc_blocks - tx->tx_sb->nx_xp_desc_index))");
}

void sub_10005D990()
{
  __assert_rtn("spaceman_init_phys", "spaceman.c", 85, "size == args->smia_nmp->nxmp_sm_phys_size");
}

void sub_10005D9BC()
{
}

void sub_10005D9E8()
{
}

void sub_10005DA14()
{
  __assert_rtn("spaceman_get", "spaceman.c", 1870, "nx != NULL");
}

void sub_10005DA40()
{
  __assert_rtn("spaceman_free_completed", "spaceman.c", 6198, "(q == SFQ_IP) || (sm->sm_fq_inflight[SFQ_TO_SMDEV(q)] == 0)");
}

void sub_10005DA6C()
{
  __assert_rtn("spaceman_iterate_free_extents_internal", "spaceman.c", 3696, "cib->cib_chunk_info_count <= smp->sm_chunks_per_cib");
}

void sub_10005DA98()
{
  __assert_rtn("spaceman_iterate_free_extents_internal", "spaceman.c", 3697, "num_chunks_to_process <= smp->sm_chunks_per_cib");
}

void sub_10005DAC4()
{
  __assert_rtn("spaceman_iterate_free_extents_internal", "spaceman.c", 3813, "flen == 0");
}

void sub_10005DAF0()
{
  __assert_rtn("spaceman_iterate_free_extents_internal", "spaceman.c", 3812, "faddr == 0");
}

void sub_10005DB1C()
{
  __assert_rtn("spaceman_iterate_free_extents_internal", "spaceman.c", 3811, "i == num_chunks_to_process - 1");
}

void sub_10005DB48()
{
}

void sub_10005DB74()
{
}

void sub_10005DBA0()
{
}

void sub_10005DBCC()
{
  __assert_rtn("spaceman_alloc", "spaceman.c", 7760, "bmo || (bcount == 0)");
}

void sub_10005DBF8()
{
  __assert_rtn("spaceman_alloc", "spaceman.c", 7599, "erbcount == bcount");
}

void sub_10005DC24()
{
  __assert_rtn("spaceman_alloc", "spaceman.c", 7582, "bmoffset == 0");
}

void sub_10005DC50()
{
}

void sub_10005DC7C()
{
  __assert_rtn("spaceman_set_bits_in_bm", "spaceman.c", 5421, "(fs->apfs_sb->apfs_fs_quota_block_count == 0) || (fs->apfs_sb->apfs_fs_alloc_count <= fs->apfs_sb->apfs_fs_quota_block_count)");
}

void sub_10005DCA8()
{
  __assert_rtn("spaceman_set_bits_in_bm", "spaceman.c", 5428, "smp->sm_fs_reserve_alloc_count <= smp->sm_fs_reserve_block_count");
}

void sub_10005DCD4()
{
  __assert_rtn("spaceman_set_bits_in_bm", "spaceman.c", 5407, "sm->sm_reserved_space[dev] <= smp->sm_dev[dev].sm_free_count");
}

void sub_10005DD00()
{
  __assert_rtn("spaceman_reserve", "spaceman.c", 8612, "sm->sm_reserved_space[dev] <= smp->sm_dev[dev].sm_free_count");
}

void sub_10005DD2C()
{
}

void sub_10005DD58()
{
  __assert_rtn("spaceman_fs_bounds_clear", "spaceman.c", 8853, "(apfs->apfs_sb->apfs_fs_quota_block_count == 0) || (fs_alloc_count <= apfs->apfs_sb->apfs_fs_quota_block_count)");
}

void sub_10005DD84()
{
}

void sub_10005DDB0()
{
  __assert_rtn("omap_map_tree_get", "omap.c", 265, "error || (obj_oid(*tree) == omap->om_phys->om_tree_oid)");
}

void sub_10005DDDC()
{
  __assert_rtn("omap_cleanup", "omap.c", 1498, "cleanupstate->omc_cleaning == 0");
}

void sub_10005DE08()
{
}

void sub_10005DE34()
{
  __assert_rtn("omap_cleanup", "omap.c", 1736, "vlen == sizeof(ovnext)");
}

void sub_10005DE60()
{
  __assert_rtn("omap_cleanup", "omap.c", 1735, "klen == sizeof(oknext)");
}

void sub_10005DE8C()
{
  __assert_rtn("omap_cleanup", "omap.c", 1662, "vlen == sizeof(ovnext)");
}

void sub_10005DEB8()
{
  __assert_rtn("omap_cleanup", "omap.c", 1661, "klen == sizeof(oknext)");
}

void sub_10005DEE4()
{
}

void sub_10005DF10()
{
  __assert_rtn("omap_cleanup", "omap.c", 1624, "vlen == sizeof(ov)");
}

void sub_10005DF3C()
{
  __assert_rtn("omap_cleanup", "omap.c", 1623, "klen == sizeof(ok)");
}

void sub_10005DF68()
{
}

void sub_10005DF94()
{
  __assert_rtn("omap_create", "omap.c", 436, "nx != NULL");
}

void sub_10005DFC0()
{
}

void sub_10005DFEC()
{
  __assert_rtn("omap_destroy", "omap.c", 501, "nx != NULL");
}

void sub_10005E018()
{
  __assert_rtn("omap_destroy", "omap.c", 502, "fs == NULL || fs->apfs_main_apfs == NULL");
}

void sub_10005E044()
{
  __assert_rtn("omap_set", "omap.c", 755, "nx != NULL");
}

void sub_10005E070()
{
}

void sub_10005E09C()
{
  __assert_rtn("omap_set", "omap.c", 756, "fs == NULL || fs->apfs_main_apfs == NULL");
}

void sub_10005E0C8()
{
  __assert_rtn("omap_delete", "omap.c", 829, "nx != NULL");
}

void sub_10005E0F4()
{
  __assert_rtn("omap_delete", "omap.c", 830, "fs == NULL || fs->apfs_main_apfs == NULL");
}

void sub_10005E120()
{
  __assert_rtn("omap_obj_modify", "omap.c", 637, "fs == NULL || fs->apfs_main_apfs == NULL");
}

void sub_10005E14C()
{
}

void sub_10005E178()
{
}

void sub_10005E1A4()
{
  __assert_rtn("obj_cache_ephemeral_adjust", "obj.c", 271, "(adjustment == -1) || (adjustment == 1)");
}

void sub_10005E1D0()
{
}

void sub_10005E1FC()
{
  __assert_rtn("obj_cache_ephemeral_adjust", "obj.c", 286, "adjustment == 1");
}

void sub_10005E228()
{
}

void sub_10005E254()
{
  __assert_rtn("obj_cache_lock_by_state", "obj.c", 334, "oc_lock_state == OC_LOCK_STATE_READ || oc_lock_state == OC_LOCK_STATE_WRITE");
}

void sub_10005E280()
{
  __assert_rtn("obj_cache_unlock_by_state", "obj.c", 347, "oc_lock_state == OC_LOCK_STATE_READ || oc_lock_state == OC_LOCK_STATE_WRITE");
}

void sub_10005E2AC()
{
}

void sub_10005E2D8()
{
}

void sub_10005E304()
{
}

void sub_10005E330()
{
  __assert_rtn("obj_cache_stats_destroy", "obj.c", 6956, "stats->ocs_np_ephemeral_mem.oms_current == 0");
}

void sub_10005E35C()
{
  __assert_rtn("obj_cache_stats_destroy", "obj.c", 6955, "stats->ocs_ephemeral_mem.oms_current == 0");
}

void sub_10005E388()
{
  __assert_rtn("obj_cache_stats_destroy", "obj.c", 6954, "stats->ocs_mem.oms_current == 0");
}

void sub_10005E3B4()
{
  __assert_rtn("obj_cache_destroy", "obj.c", 630, "oc->oc_deferred_update_objs[i] == NULL");
}

void sub_10005E3E0()
{
  __assert_rtn("obj_cache_destroy", "obj.c", 624, "oc->oc_cache_size == 0");
}

void sub_10005E40C()
{
  __assert_rtn("obj_cache_destroy", "obj.c", 623, "oc->oc_np_ephemeral_cache_size == 0");
}

void sub_10005E438()
{
  __assert_rtn("obj_cache_destroy", "obj.c", 622, "oc->oc_ephemeral_cache_size == 0");
}

void sub_10005E464()
{
  __assert_rtn("obj_cache_destroy", "obj.c", 621, "oc->oc_ephemeral_block_count == 0");
}

void sub_10005E490()
{
}

void sub_10005E4BC()
{
}

void sub_10005E4E8()
{
}

void sub_10005E514()
{
}

void sub_10005E540()
{
}

void sub_10005E56C()
{
}

void sub_10005E598()
{
}

void sub_10005E5C4()
{
}

void sub_10005E5F0()
{
}

void sub_10005E61C()
{
}

void sub_10005E648()
{
  __assert_rtn("obj_reference_release_wait", "obj.c", 3947, "OBJ_REFS_VAL_REFCOUNT(orefs) <= 100000");
}

void sub_10005E674()
{
}

void sub_10005E6A0()
{
  __assert_rtn("obj_write_prepare", "obj.c", 6511, "(o->o_flags & OBJ_STORAGETYPE_MASK) || (o->o_flags & OBJ_NEW) || (o->o_oid == o->o_phys->o_oid)");
}

void sub_10005E6CC()
{
  __assert_rtn("obj_cache_flush_unprepare", "obj.c", 1357, "o->o_list.tqe_next == OBJ_NOLIST");
}

void sub_10005E6F8()
{
}

void sub_10005E724()
{
  __assert_rtn("obj_cache_flush_write", "obj.c", 1516, "(oc->oc_flush_count == 0) || error");
}

void sub_10005E750()
{
}

void sub_10005E77C()
{
}

void sub_10005E7A8()
{
}

void sub_10005E7D4()
{
}

void sub_10005E800()
{
}

void sub_10005E82C()
{
}

void sub_10005E858()
{
}

void sub_10005E884()
{
}

void sub_10005E8B0()
{
}

void sub_10005E8DC()
{
}

void sub_10005E908()
{
}

void sub_10005E934()
{
  __assert_rtn("obj_alloc", "obj.c", 2215, "!o2 || (obj_refcount(o2) == 0)");
}

void sub_10005E960()
{
  __assert_rtn("obj_alloc", "obj.c", 2214, "!o1 || (obj_refcount(o1) == 0)");
}

void sub_10005E98C()
{
  __assert_rtn("obj_type_alloc", "obj.c", 6017, "sizeof(obj_t) == size");
}

void sub_10005E9B8()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5961, "sizeof(nx_t) == size");
}

void sub_10005E9E4()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5965, "sizeof(btree_node_t) == size");
}

void sub_10005EA10()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5968, "sizeof(spaceman_t) == size");
}

void sub_10005EA3C()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5974, "sizeof(btree_node_t) == size");
}

void sub_10005EA68()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5977, "sizeof(omap_t) == size");
}

void sub_10005EA94()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5980, "sizeof(apfs_t) == size");
}

void sub_10005EAC0()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5983, "sizeof(nx_reaper_t) == size");
}

void sub_10005EAEC()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5986, "sizeof(nx_reap_list_t) == size");
}

void sub_10005EB18()
{
  __assert_rtn("obj_type_alloc", "obj.c", 5997, "sizeof(gbitmap_t) == size");
}

void sub_10005EB44()
{
  __assert_rtn("obj_type_alloc", "obj.c", 6000, "sizeof(gbitmap_block_t) == size");
}

void sub_10005EB70()
{
  __assert_rtn("obj_type_alloc", "obj.c", 6003, "sizeof(snap_meta_ext_obj_t) == size");
}

void sub_10005EB9C()
{
  __assert_rtn("obj_type_alloc", "obj.c", 6006, "sizeof(integrity_meta_t) == size");
}

void sub_10005EBC8()
{
  __assert_rtn("obj_ref_count_increment_internal", "obj.c", 3837, "OBJ_REFS_VAL_REFCOUNT(orefs) <= 100000");
}

void sub_10005EBF4()
{
}

void sub_10005EC20()
{
  __assert_rtn("obj_delete_and_free_by_oid", "obj.c", 3172, "size == mapsize");
}

void sub_10005EC4C()
{
}

void sub_10005EC78()
{
  __assert_rtn("obj_get", "obj.c", 4602, "oc_lock_state == OC_LOCK_STATE_WRITE");
}

void sub_10005ECA4()
{
  __assert_rtn("obj_get", "obj.c", 4503, "obj_refcount(o) == 0");
}

void sub_10005ECD0()
{
  __assert_rtn("obj_get", "obj.c", 4460, "oc_lock_state == OC_LOCK_STATE_WRITE");
}

void sub_10005ECFC()
{
  __assert_rtn("obj_get", "obj.c", 4343, "((o->o_flags & (OBJ_CURRENT_REF | OBJ_SNAPSHOT_REF)) == OBJ_CURRENT_REF) || ((o->o_flags & (OBJ_CURRENT_REF | OBJ_SNAPSHOT_REF)) == OBJ_SNAPSHOT_REF)");
}

void sub_10005ED28()
{
}

void sub_10005ED54()
{
}

void sub_10005ED80()
{
}

void sub_10005EDAC()
{
}

void sub_10005EDD8()
{
}

void sub_10005EE04()
{
  __assert_rtn("obj_read", "obj.c", 6325, "(o->o_size_phys % o->o_oc->oc_nx->nx_sb->nx_block_size) == 0");
}

void sub_10005EE30()
{
  __assert_rtn("obj_get_finish", "obj.c", 3322, "o->o_xid <= (oxid ? oxid : XID_LARGEST)");
}

void sub_10005EE5C()
{
  __assert_rtn("obj_get_finish", "obj.c", 3321, "(o->o_flags & (OBJ_NOHEADER | OBJ_CIPHERTEXT)) || (o->o_flags & OBJ_STORAGETYPE_MASK) || (o->o_flags & OBJ_NEW) || (o->o_oid == o->o_phys->o_oid)");
}

void sub_10005EE88()
{
  __assert_rtn("obj_get_finish", "obj.c", 3320, "(o->o_oid == oid) || (o->o_oid == o->o_paddr) || (o->o_oid == o->o_naddr)");
}

void sub_10005EEB4()
{
  __assert_rtn("obj_get_finish", "obj.c", 3319, "(o->o_flags & (OBJ_NOHEADER | OBJ_CIPHERTEXT)) || (o->o_flags & OBJ_NEW) || ((!(type & OBJECT_TYPE_MASK) || ((o->o_phys->o_type & ~OBJ_ENCRYPTED) == (type & ~OBJ_ENCRYPTED))) && (!subtype || (o->o_phys->o_subtype == subtype)))");
}

void sub_10005EEE0()
{
  __assert_rtn("obj_get_finish", "obj.c", 3317, "(!(type & OBJECT_TYPE_MASK) || ((o->o_type & ~OBJ_ENCRYPTED) == (type & ~OBJ_ENCRYPTED))) && (!subtype || (o->o_subtype == subtype))");
}

void sub_10005EF0C()
{
  __assert_rtn("obj_get_finish", "obj.c", 3316, "(o->o_flags & (OBJ_STORAGETYPE_MASK | OBJ_NONPERSISTENT)) == storagetype");
}

void sub_10005EF38()
{
}

void sub_10005EF64()
{
}

void sub_10005EF90()
{
  __assert_rtn("obj_destroy_internal", "obj.c", 2943, "oc->oc_destroy_list_last != NULL");
}

void sub_10005EFBC()
{
}

void sub_10005EFE8()
{
}

void sub_10005F014()
{
}

void sub_10005F040()
{
}

void sub_10005F06C()
{
}

void sub_10005F098()
{
}

void sub_10005F0C4()
{
}

void sub_10005F0F0()
{
}

void sub_10005F11C()
{
  __assert_rtn("obj_checkpoint_traverse", "obj.c", 5929, "obj_type(nxapfs) == OBJECT_TYPE_NX_SUPERBLOCK");
}

void sub_10005F148()
{
}

void sub_10005F174()
{
}

void sub_10005F1A0()
{
}

void sub_10005F1CC()
{
}

void sub_10005F1F8()
{
  __assert_rtn("obj_cache_perform_deferred_updates", "obj.c", 407, "(aflags >> OBJ_AFLAG_DEFERRED_LIST_UPDATE_INDEX_SHIFT) == i");
}

void sub_10005F224()
{
}

void sub_10005F250()
{
}

void sub_10005F27C()
{
  __assert_rtn("obj_get_callback", "obj.c", 3526, "error != EAGAIN");
}

void sub_10005F2A8()
{
  __assert_rtn("obj_get_callback", "obj.c", 3548, "arg->oia_size >= sizeof(obj_init_async_args_t)");
}

void sub_10005F2D4()
{
  __assert_rtn("obj_cache_dequeue_deferred_update", "obj.c", 512, "oc->oc_deferred_update_objs[aflags >> OBJ_AFLAG_DEFERRED_LIST_UPDATE_INDEX_SHIFT] == o");
}

void sub_10005F300()
{
  __assert_rtn("fext_tree_insert_with_tree", "fext_tree.c", 128, "obj_subtype(tree) == OBJECT_TYPE_FEXT_TREE");
}

void sub_10005F32C()
{
}

void sub_10005F358()
{
  __assert_rtn("bitmap_range_find_desired_or_first_clear_range", "bm.c", 268, "index + findcount <= search_end");
}

void sub_10005F384()
{
  __assert_rtn("bitmap_range_find_desired_or_first_clear_range", "bm.c", 273, "(longest_index + longest_len) <= search_end");
}

void sub_10005F3B0()
{
  __assert_rtn("bitmap_range_find_desired_or_first_clear_range", "bm.c", 297, "(longest_index + longest_len) <= search_end");
}

void sub_10005F3DC()
{
  __assert_rtn("bitmap_range_find_desired_or_first_clear_range", "bm.c", 280, "index + longest_len + findcount <= search_end");
}

void sub_10005F408()
{
  __assert_rtn("bitmap_range_find_desired_or_first_clear_range", "bm.c", 286, "(longest_index + longest_len) <= search_end");
}

void sub_10005F434()
{
  __assert_rtn("integrity_meta_init_phys", "authapfs.c", 108, "size >= NX_DEFAULT_BLOCK_SIZE");
}

void sub_10005F460()
{
}

void sub_10005F48C()
{
}

void sub_10005F4B8()
{
  __assert_rtn("authapfs_validate_node", "authapfs_hash.c", 296, "(obj_subtype(btn) == OBJECT_TYPE_TEST) || apfs");
}

void sub_10005F4E4()
{
  __assert_rtn("apfs_set_formatted_by", "version.c", 52, "bcnt >= 0");
}

void sub_10005F510()
{
  __assert_rtn("apfs_set_formatted_by", "version.c", 56, "bcnt <= bufsize");
}

void sub_10005F53C()
{
  __assert_rtn("nx_init_phys", "nx.c", 561, "size == args->nxia_block_size");
}

void sub_10005F568()
{
  __assert_rtn("nx_reaper_get", "nx.c", 1104, "nx != NULL");
}

void sub_10005F594()
{
  __assert_rtn("nx_reaper_checkpoint_traverse", "nx.c", 1314, "(nrp->nr_rlcount == 0) || (rlcount == 0)");
}

void sub_10005F5C0()
{
  __assert_rtn("nx_reaper_add", "nx.c", 1439, "nrlp->nrl_count == 0");
}

void sub_10005F5EC()
{
}

void sub_10005F618()
{
  __assert_rtn("btree_node_get", "bt.c", 586, "error || (flags & (BT_ASYNC | BT_PREFETCH)) || (btn && (btn->btn_o.o_oid == binv->binv_child_oid)) || ((oflags & OBJ_PHYSICAL) && (oflags & OBJ_MODIFY))");
}

void sub_10005F644()
{
}

void sub_10005F670()
{
}

void sub_10005F69C()
{
}

void sub_10005F6C8()
{
}

void sub_10005F6F4()
{
  __assert_rtn("bt_insert", "bt.c", 3843, "!rightmost_path || bt->bt_last_leaf == 0 || bt->bt_last_leaf == n[0].btn->btn_o.o_oid");
}

void sub_10005F720()
{
  __assert_rtn("bt_insert", "bt.c", 3790, "minkey_update_node == n[0].btn");
}

void sub_10005F74C()
{
  __assert_rtn("bt_insert", "bt.c", 3704, "!minkeyup || (minkey_update_node == n[0].btn)");
}

void sub_10005F778()
{
  __assert_rtn("btree_node_insert_internal", "bt.c", 2168, "kvspace <= BTNODE_PHYS(btn)->btn_free_space.len");
}

void sub_10005F7A4()
{
  __assert_rtn("bt_shift_or_split", "bt.c", 3037, "insertindex == (BTNODE_KEY_COUNT(child) - 1)");
}

void sub_10005F7D0()
{
  __assert_rtn("btree_node_insert", "bt.c", 2261, "vlen == BTNODE_NONLEAF_VAL_SIZE(btn)");
}

void sub_10005F7FC()
{
}

void sub_10005F828()
{
}

void sub_10005F854()
{
}

void sub_10005F880()
{
}

void sub_10005F8AC()
{
}

void sub_10005F8D8()
{
}

void sub_10005F904()
{
}

void sub_10005F930()
{
}

void sub_10005F95C()
{
  __assert_rtn("bt_remove_internal", "bt.c", 5106, "BTNODE_LEVEL(minkey_update_node) == 1");
}

void sub_10005F988()
{
  __assert_rtn("bt_remove_internal", "bt.c", 5117, "index == 0");
}

void sub_10005F9B4()
{
  __assert_rtn("bt_remove_internal", "bt.c", 5023, "!minkeyup || (n[0].found && (n[0].index == 0))");
}

void sub_10005F9E0()
{
  __assert_rtn("bt_remove_internal", "bt.c", 4955, "minkey_update_node == n[0].btn");
}

void sub_10005FA0C()
{
  __assert_rtn("bt_remove_internal", "bt.c", 4807, "!minkeyup || (n[0].found && (n[0].index == 0))");
}

void sub_10005FA38()
{
}

void sub_10005FA64()
{
}

void sub_10005FA90()
{
}

void sub_10005FABC()
{
}

void sub_10005FAE8()
{
}

void sub_10005FB14()
{
}

void sub_10005FB40()
{
  __assert_rtn("btree_node_create", "bt.c", 470, "!(btnargs->btnia_bt_config.btc_flags & BTREE_NOHEADER) == !(btnargs->btnia_flags & BTNODE_NOHEADER)");
}

void sub_10005FB6C()
{
  __assert_rtn("btree_node_create", "bt.c", 469, "!(btnargs->btnia_bt_config.btc_flags & BTREE_HASHED) == !(btnargs->btnia_flags & BTNODE_HASHED)");
}

void sub_10005FB98()
{
}

void sub_10005FBC4()
{
}

void sub_10005FBF0()
{
}

void sub_10005FC1C()
{
}

void sub_10005FC48()
{
  __assert_rtn("btree_get_extended", "bt.c", 6316, "error || (btn && (btn->btn_o.o_oid == oid)) || ((oflags & OBJ_PHYSICAL) && (oflags & OBJ_MODIFY))");
}

void sub_10005FC74()
{
}

void sub_10005FCA0()
{
}

void sub_10005FCCC()
{
}

void sub_10005FCF8()
{
}

void sub_10005FD24()
{
  __assert_rtn("btree_iterate_nodes", "bt.c", 6459, "btn == NULL");
}

void sub_10005FD50()
{
  __assert_rtn("btree_checkpoint_traverse", "bt.c", 6581, "(BT_FLAGS(bt) & (BTREE_EPHEMERAL | BTREE_NONPERSISTENT)) == BTREE_EPHEMERAL");
}

void sub_10005FD7C()
{
}

void sub_10005FDA8()
{
  __assert_rtn("btree_node_space_dealloc", "bt.c", 1292, "(off != BTOFF_INVALID) && (off != BTOFF_MT_GHOST)");
}

void sub_10005FDD4()
{
  __assert_rtn("btree_node_space_dealloc", "bt.c", 1293, "(len != 0) && (len != BTLEN_MT_GHOST)");
}

void sub_10005FE00()
{
  __assert_rtn("btree_node_toc_set", "bt.c", 980, "voff <= vsize");
}

void sub_10005FE2C()
{
  __assert_rtn("btree_node_toc_set", "bt.c", 981, "voff >= vlen");
}

void sub_10005FE58()
{
  __assert_rtn("btree_node_toc_set", "bt.c", 972, "vlen == 0");
}

void sub_10005FE84()
{
  __assert_rtn("btree_node_toc_set", "bt.c", 974, "vlen == BTLEN_MT_GHOST");
}

void sub_10005FEB0()
{
  __assert_rtn("btree_node_toc_set", "bt.c", 964, "klen == 0");
}

void sub_10005FEDC()
{
  __assert_rtn("btree_node_toc_set", "bt.c", 967, "(koff + klen) <= BTNODE_PHYS(btn)->btn_free_space.off");
}

void sub_10005FF08()
{
}

void sub_10005FF34()
{
}

void sub_10005FF60()
{
  __assert_rtn("btree_node_space_free_list_alloc", "bt.c", 1427, "fl->len || (fl->off == BTOFF_INVALID)");
}

void sub_10005FF8C()
{
  __assert_rtn("btree_node_space_common_alloc", "bt.c", 1441, "(space == BTNODE_SPACE_KEY) || (space == BTNODE_SPACE_VAL)");
}

void sub_10005FFB8()
{
  __assert_rtn("btree_node_toc_resize", "bt.c", 932, "addedspace <= BTNODE_PHYS(btn)->btn_free_space.len");
}

void sub_10005FFE4()
{
  __assert_rtn("btree_node_toc_resize", "bt.c", 940, "BTNODE_KEY_COUNT(btn) <= (tocspace / btree_node_toc_entry_size(btn))");
}

void sub_100060010()
{
  __assert_rtn("btree_node_toc_resize", "bt.c", 943, "!BTNODE_HAS_FIXED_KV_SIZE(btn) || (tocspace >= sizeof(kvoff_t) * FIXED_TOC_COUNT_MINIMUM(BTNODE_SIZE(btn), btn->btn_bt_config.btc_key_size, BTNODE_IS_LEAF(btn) ? btn->btn_bt_config.btc_val_size : BTNODE_NONLEAF_VAL_SIZE(btn)))");
}

void sub_10006003C()
{
}

void sub_100060068()
{
}

void sub_100060094()
{
  __assert_rtn("jobj_release", "jobj.c", 2717, "jobj->size >= sizeof(j_crypto_state_t)");
}

void sub_1000600C0()
{
  __assert_rtn("jobj_release", "jobj.c", 2732, "jobj->size >= sizeof(j_sibling_link_t)");
}

void sub_1000600EC()
{
  __assert_rtn("jobj_release", "jobj.c", 2735, "jobj->size >= sizeof(j_snap_name_t)");
}

void sub_100060118()
{
  __assert_rtn("jobj_release", "jobj.c", 2752, "jobj->size >= sizeof(j_xattr_t)");
}

void sub_100060144()
{
  __assert_rtn("jobj_release", "jobj.c", 2765, "jobj->size >= sizeof(j_finfo_data_hash_t)");
}

void sub_100060170()
{
}

void sub_10006019C()
{
}

void sub_1000601C8()
{
}

void sub_1000601F4()
{
}

void sub_100060220()
{
  __assert_rtn("key_val_to_jobj", "jobj.c", 4848, "sn->hdr.size >= (sizeof(j_snap_name_t) + snk->name_len)");
}

void sub_10006024C()
{
  __assert_rtn("jobj_allocate", "jobj.c", 2625, "sz >= sizeof(j_crypto_state_t)");
}

void sub_100060278()
{
  __assert_rtn("jobj_allocate", "jobj.c", 2630, "sz >= sizeof(j_dir_rec_t)");
}

void sub_1000602A4()
{
  __assert_rtn("jobj_allocate", "jobj.c", 2640, "sz >= sizeof(j_snap_metadata_t)");
}

void sub_1000602D0()
{
  __assert_rtn("jobj_allocate", "jobj.c", 2648, "sz >= sizeof(j_snap_name_t)");
}

void sub_1000602FC()
{
  __assert_rtn("jobj_allocate", "jobj.c", 2651, "sz >= sizeof(j_xattr_t)");
}

void sub_100060328()
{
  __assert_rtn("jobj_allocate", "jobj.c", 2654, "sz >= sizeof(j_sibling_link_t)");
}

void sub_100060354()
{
  __assert_rtn("jobj_allocate", "jobj.c", 2677, "sz >= sizeof(j_finfo_data_hash_t)");
}

void sub_100060380()
{
}

void sub_1000603AC()
{
}

void sub_1000603D8()
{
}

void sub_100060404()
{
}

void sub_100060430()
{
  __assert_rtn("update_time", "jobj.c", 23317, "which != 0");
}

void sub_10006045C()
{
}

void sub_100060488()
{
  __assert_rtn("utf8_strlen_with_ascii_status", "jobj.c", 13156, "s != 0");
}

void sub_1000604B4()
{
}

void sub_1000604E0()
{
}

void sub_10006050C()
{
}

void sub_100060538()
{
  __assert_rtn("fs_tx_leave_ext", "jobj.c", 28033, "old_reserve >= num_blocks");
}

void sub_100060564()
{
}

void sub_100060590()
{
}

void sub_1000605BC()
{
}

void sub_1000605E8()
{
}

void sub_100060614()
{
}

void sub_100060640()
{
}

void sub_10006066C()
{
}

void sub_100060698()
{
}

void sub_1000606C4()
{
}

void sub_1000606F0()
{
}

void sub_10006071C()
{
}

void sub_100060748()
{
}

void sub_100060774()
{
}

void sub_1000607A0()
{
}

void sub_1000607CC()
{
}

void sub_1000607F8()
{
}

void sub_100060824()
{
}

void sub_100060850()
{
}

void sub_10006087C()
{
}

void sub_1000608A8()
{
}

void sub_1000608D4()
{
}

void sub_100060900()
{
}

void sub_10006092C()
{
}

void sub_100060958()
{
}

void sub_100060984()
{
}

void sub_1000609B0()
{
}

void sub_1000609DC()
{
}

void sub_100060A08()
{
}

void sub_100060A34()
{
}

void sub_100060A60()
{
}

void sub_100060A8C()
{
}

void sub_100060AB8()
{
}

void sub_100060AE4()
{
}

void sub_100060B10()
{
}

void sub_100060B3C()
{
}

void sub_100060B68()
{
}

void sub_100060B94()
{
}

void sub_100060BC0()
{
}

void sub_100060BEC()
{
}

void sub_100060C18()
{
}

void sub_100060C44()
{
}

void sub_100060C70()
{
}

void sub_100060C9C()
{
}

void sub_100060CC8()
{
  __assert_rtn("fd_dev_read_common", "io_user.c", 452, "count <= dev->dev_block_count - blknum");
}

void sub_100060CF4()
{
}

void sub_100060D20()
{
  __assert_rtn("_fd_dev_write", "io_user.c", 713, "count <= dev->dev_block_count - blknum");
}

void sub_100060D4C()
{
}

void sub_100060D78()
{
}

void sub_100060DA4()
{
}

void sub_100060DD0(os_log_t log)
{
  int v1 = 136315138;
  unint64_t v2 = "appexPrint";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: Context is null, can't log message", (uint8_t *)&v1, 0xCu);
}

void sub_100060E54(os_log_t log)
{
  int v1 = 136315138;
  unint64_t v2 = "appexPrint";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: No message connection object, can't log message", (uint8_t *)&v1, 0xCu);
}

void sub_100060ED8(uint64_t *a1, uint64_t a2, os_log_t log)
{
  uint64_t v3 = *a1;
  int v4 = 136315650;
  int v5 = "-[APFSFileSystem syncRead:into:startingAt:length:]_block_invoke";
  __int16 v6 = 2048;
  uint64_t v7 = v3;
  __int16 v8 = 2048;
  uint64_t v9 = a2;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: Expected to read %lu bytes, read %lu", (uint8_t *)&v4, 0x20u);
}

void sub_100060F74(uint64_t a1, NSObject *a2)
{
  int v2 = 136315394;
  uint64_t v3 = "-[APFSFileSystem syncRead:into:startingAt:length:]_block_invoke";
  __int16 v4 = 2112;
  uint64_t v5 = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: Failed to read, error %@", (uint8_t *)&v2, 0x16u);
}

CCCryptorStatus CCCryptorCreateWithMode(CCOperation op, CCMode mode, CCAlgorithm alg, CCPadding padding, const void *iv, const void *key, size_t keyLength, const void *tweak, size_t tweakLength, int numRounds, CCModeOptions options, CCCryptorRef *cryptorRef)
{
  return _CCCryptorCreateWithMode(op, mode, alg, padding, iv, key, keyLength, tweak, tweakLength, numRounds, options, cryptorRef);
}

uint64_t CCCryptorDecryptDataBlock()
{
  return _CCCryptorDecryptDataBlock();
}

uint64_t CCCryptorEncryptDataBlock()
{
  return _CCCryptorEncryptDataBlock();
}

CCCryptorStatus CCCryptorRelease(CCCryptorRef cryptorRef)
{
  return _CCCryptorRelease(cryptorRef);
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

CFMutableDictionaryRef IOBSDNameMatching(mach_port_t mainPort, uint32_t options, const char *bsdName)
{
  return _IOBSDNameMatching(mainPort, options, bsdName);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return _IOIteratorNext(iterator);
}

BOOLean_t IOObjectConformsTo(io_object_t object, const io_name_t className)
{
  return _IOObjectConformsTo(object, className);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

kern_return_t IOObjectRetain(io_object_t object)
{
  return _IOObjectRetain(object);
}

kern_return_t IORegistryEntryGetParentEntry(io_registry_entry_t entry, const io_name_t plane, io_registry_entry_t *parent)
{
  return _IORegistryEntryGetParentEntry(entry, plane, parent);
}

kern_return_t IORegistryEntryGetParentIterator(io_registry_entry_t entry, const io_name_t plane, io_iterator_t *iterator)
{
  return _IORegistryEntryGetParentIterator(entry, plane, iterator);
}

CFTypeRef IORegistryEntrySearchCFProperty(io_registry_entry_t entry, const io_name_t plane, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntrySearchCFProperty(entry, plane, key, allocator, options);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return _IOServiceGetMatchingService(mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return _IOServiceMatching(name);
}

uint64_t NSExtensionMain()
{
  return _NSExtensionMain();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int *__error(void)
{
  return ___error();
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

uint64_t _get_cpu_capabilities()
{
  return __get_cpu_capabilities();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

int aio_error(const aiocb *aiocbp)
{
  return _aio_error(aiocbp);
}

int aio_read(aiocb *aiocbp)
{
  return _aio_read(aiocbp);
}

ssize_t aio_return(aiocb *aiocbp)
{
  return _aio_return(aiocbp);
}

int aio_suspend(const aiocb *const aiocblist[], int nent, const timespec *timeoutp)
{
  return _aio_suspend(aiocblist, nent, timeoutp);
}

int backtrace(void **a1, int a2)
{
  return _backtrace(a1, a2);
}

char **__cdecl backtrace_symbols(void *const *a1, int a2)
{
  return _backtrace_symbols(a1, a2);
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return _calloc(__count, __size);
}

uint64_t cc_clear()
{
  return _cc_clear();
}

uint64_t ccaes_cbc_decrypt_mode()
{
  return _ccaes_cbc_decrypt_mode();
}

uint64_t ccaes_cbc_encrypt_mode()
{
  return _ccaes_cbc_encrypt_mode();
}

uint64_t cccbc_clear_iv()
{
  return _cccbc_clear_iv();
}

uint64_t cccbc_init()
{
  return _cccbc_init();
}

uint64_t ccder_blob_decode_len()
{
  return _ccder_blob_decode_len();
}

uint64_t ccder_blob_decode_range()
{
  return _ccder_blob_decode_range();
}

uint64_t ccder_blob_decode_tag()
{
  return _ccder_blob_decode_tag();
}

uint64_t ccder_blob_decode_tl()
{
  return _ccder_blob_decode_tl();
}

uint64_t ccder_blob_encode_implicit_raw_octet_string()
{
  return _ccder_blob_encode_implicit_raw_octet_string();
}

uint64_t ccder_blob_encode_implicit_uint64()
{
  return _ccder_blob_encode_implicit_uint64();
}

uint64_t ccder_blob_encode_tl()
{
  return _ccder_blob_encode_tl();
}

uint64_t ccder_sizeof()
{
  return _ccder_sizeof();
}

uint64_t ccder_sizeof_implicit_uint64()
{
  return _ccder_sizeof_implicit_uint64();
}

uint64_t ccder_sizeof_raw_octet_string()
{
  return _ccder_sizeof_raw_octet_string();
}

uint64_t ccdigest()
{
  return _ccdigest();
}

uint64_t ccdigest_init()
{
  return _ccdigest_init();
}

uint64_t ccdigest_update()
{
  return _ccdigest_update();
}

uint64_t cchkdf()
{
  return _cchkdf();
}

uint64_t cchmac()
{
  return _cchmac();
}

uint64_t ccn_read_uint()
{
  return _ccn_read_uint();
}

uint64_t ccpbkdf2_hmac()
{
  return _ccpbkdf2_hmac();
}

uint64_t ccrng()
{
  return _ccrng();
}

uint64_t ccsha256_di()
{
  return _ccsha256_di();
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return _clock_gettime(__clock_id, __tp);
}

int close(int a1)
{
  return _close(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

void free(void *a1)
{
}

uint64_t fs_errorForPOSIXError()
{
  return _fs_errorForPOSIXError();
}

uint64_t fskit_std_log()
{
  return _fskit_std_log();
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

int fstatfs(int a1, statfs *a2)
{
  return _fstatfs(a1, a2);
}

int fsync(int a1)
{
  return _fsync(a1);
}

gid_t getgid(void)
{
  return _getgid();
}

uid_t getuid(void)
{
  return _getuid();
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

uint64_t mach_continuous_time(void)
{
  return _mach_continuous_time();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_realloc(ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return _memset_s(__s, __smax, __c, __n);
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  return _nanosleep(__rqtp, __rmtp);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_enumerationMutation(id obj)
{
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

void objc_release(id a1)
{
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

void objc_storeStrong(id *location, id obj)
{
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

uint64_t os_variant_has_internal_content()
{
  return _os_variant_has_internal_content();
}

void panic(const char *a1, ...)
{
}

ssize_t pread(int __fd, void *__buf, size_t __nbyte, off_t a4)
{
  return _pread(__fd, __buf, __nbyte, a4);
}

int pthread_cond_broadcast(pthread_cond_t *a1)
{
  return _pthread_cond_broadcast(a1);
}

int pthread_cond_destroy(pthread_cond_t *a1)
{
  return _pthread_cond_destroy(a1);
}

int pthread_cond_init(pthread_cond_t *a1, const pthread_condattr_t *a2)
{
  return _pthread_cond_init(a1, a2);
}

int pthread_cond_timedwait(pthread_cond_t *a1, pthread_mutex_t *a2, const timespec *a3)
{
  return _pthread_cond_timedwait(a1, a2, a3);
}

int pthread_cond_wait(pthread_cond_t *a1, pthread_mutex_t *a2)
{
  return _pthread_cond_wait(a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_destroy(a1);
}

int pthread_rwlock_init(pthread_rwlock_t *a1, const pthread_rwlockattr_t *a2)
{
  return _pthread_rwlock_init(a1, a2);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_rdlock(a1);
}

int pthread_rwlock_trywrlock(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_trywrlock(a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_unlock(a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_wrlock(a1);
}

ssize_t pwrite(int __fd, const void *__buf, size_t __nbyte, off_t a4)
{
  return _pwrite(__fd, __buf, __nbyte, a4);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  return _strcpy(__dst, __src);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return _strncasecmp(a1, a2, a3);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  return _strndup(__s1, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return _strrchr(__s, __c);
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  return _strtok_r(__str, __sep, __lasts);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  return _strtoull(__str, __endptr, __base);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

void uuid_clear(uuid_t uu)
{
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return _uuid_compare(uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

void uuid_generate(uuid_t out)
{
}

int uuid_is_null(const uuid_t uu)
{
  return _uuid_is_null(uu);
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return _uuid_parse(in, uu);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_blockCount(void *a1, const char *a2, ...)
{
  return [a1 blockCount];
}

id objc_msgSend_blockSize(void *a1, const char *a2, ...)
{
  return [a1 blockSize];
}

id objc_msgSend_bsdName(void *a1, const char *a2, ...)
{
  return [a1 bsdName];
}

id objc_msgSend_devicePath(void *a1, const char *a2, ...)
{
  return [a1 devicePath];
}

id objc_msgSend_fileDescriptor(void *a1, const char *a2, ...)
{
  return [a1 fileDescriptor];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_isWritable(void *a1, const char *a2, ...)
{
  return [a1 isWritable];
}

id objc_msgSend_kind(void *a1, const char *a2, ...)
{
  return [a1 kind];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_mutableBytes(void *a1, const char *a2, ...)
{
  return [a1 mutableBytes];
}

id objc_msgSend_option(void *a1, const char *a2, ...)
{
  return [a1 option];
}

id objc_msgSend_optionValue(void *a1, const char *a2, ...)
{
  return [a1 optionValue];
}

id objc_msgSend_options(void *a1, const char *a2, ...)
{
  return [a1 options];
}

id objc_msgSend_partitionBase(void *a1, const char *a2, ...)
{
  return [a1 partitionBase];
}

id objc_msgSend_physicalBlockSize(void *a1, const char *a2, ...)
{
  return [a1 physicalBlockSize];
}

id objc_msgSend_state(void *a1, const char *a2, ...)
{
  return [a1 state];
}