int sigaltstack(const stack_t *a1, stack_t *a2)
{
  if (!a1 || a1->ss_size >= 0x8000) {
    return __sigaltstack();
  }
  *__error() = 12;
  return -1;
}

int sigvec(int a1, sigvec *a2, sigvec *a3)
{
  return sigvec__(a1, (const sigaction *)a2, (sigaction *)a3, 1);
}

uint64_t sigvec__(int a1, const sigaction *a2, sigaction *a3, int a4)
{
  if (a2) {
    a2->sa_flags ^= 2u;
  }
  if (a4) {
    unsigned int v5 = sigaction(a1, a2, a3);
  }
  else {
    unsigned int v5 = _sigaction_nobind(a1, a2, a3);
  }
  if (!v5 && a3) {
    a3->sa_flags ^= 2u;
  }
  return v5;
}

uint64_t _sigvec_nobind(int a1, const sigaction *a2, sigaction *a3)
{
  return sigvec__(a1, a2, a3, 0);
}

int sigsetmask(int a1)
{
  sigset_t v4 = a1;
  sigset_t v3 = 0;
  int v2 = sigprocmask(3, &v4, &v3);
  if (v2) {
    return v2;
  }
  else {
    return v3;
  }
}

int sigblock(int a1)
{
  sigset_t v4 = a1;
  sigset_t v3 = 0;
  int v2 = sigprocmask(1, &v4, &v3);
  if (v2) {
    return v2;
  }
  else {
    return v3;
  }
}

uint64_t sigpause_NOCANCEL(int a1)
{
  int v4 = a1;
  sigset_t v3 = 0;
  if (!__unix_conforming) {
    __unix_conforming = 1;
  }
  if (v4 > 0 && v4 < 32)
  {
    if (sigprocmask(1, 0, &v3) >= 0)
    {
      int v6 = v4;
      if (v4 <= 32) {
        int v2 = 1 << (v6 - 1);
      }
      else {
        int v2 = 0;
      }
      v3 &= ~v2;
      return sigsuspend_NOCANCEL();
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sighold(int a1)
{
  int v4 = a1;
  sigset_t v3 = 0;
  if (a1 > 0 && v4 < 32)
  {
    sigset_t v3 = 0;
    int v6 = v4;
    int v2 = 1 << (v6 - 1);
    v3 |= v2;
    return sigprocmask(1, &v3, 0);
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sigrelse(int a1)
{
  int v4 = a1;
  sigset_t v3 = 0;
  if (a1 > 0 && v4 < 32)
  {
    sigset_t v3 = 0;
    int v6 = v4;
    int v2 = 1 << (v6 - 1);
    v3 |= v2;
    return sigprocmask(2, &v3, 0);
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sigignore(int a1)
{
  if (signal(a1, (void (__cdecl *)(int))((char *)&def_1F2C + 1)) == (void (__cdecl *)(int))-1) {
    return -1;
  }
  else {
    return 0;
  }
}

void (__cdecl *__cdecl sigset(int a1, void (__cdecl *a2)(int)))(int)
{
  int v10 = a1;
  v9 = a2;
  sigset_t v8 = 0;
  BOOL v7 = 0;
  v6.__sigaction_u.__sa_handler = 0;
  *(void *)&v6.sa_mask = 0;
  if (a1 > 0 && v10 < 32)
  {
    if (sigprocmask(0, 0, &v8) == -1)
    {
      return (void (__cdecl *)(int))-1;
    }
    else
    {
      int v12 = v10;
      if (v10 <= 32) {
        int v4 = 1 << (v12 - 1);
      }
      else {
        int v4 = 0;
      }
      BOOL v7 = (v8 & v4) != 0;
      if (v9 == (void (__cdecl *)(int))((char *)&dword_4 + 1))
      {
        if (v7)
        {
          return (void (__cdecl *)(int))(&dword_4 + 1);
        }
        else if (sigaction(v10, 0, &v6) == -1 || sighold(v10) == -1)
        {
          return (void (__cdecl *)(int))-1;
        }
        else
        {
          return v6.__sigaction_u.__sa_handler;
        }
      }
      else if (v7 && sigrelse(v10) == -1)
      {
        return (void (__cdecl *)(int))-1;
      }
      else
      {
        unsigned int v5 = signal(v10, v9);
        if (v5 == (void (__cdecl *)(int))-1)
        {
          return (void (__cdecl *)(int))-1;
        }
        else if (v7)
        {
          return (void (__cdecl *)(int))(&dword_4 + 1);
        }
        else
        {
          return v5;
        }
      }
    }
  }
  else
  {
    *__error() = 22;
    return (void (__cdecl *)(int))-1;
  }
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  clockid_t v13 = __clock_id;
  if (__clock_id)
  {
    if (__clock_id == _CLOCK_MONOTONIC)
    {
      v10.tv_sec = 0;
      *(void *)&v10.tv_usec = 0;
      uint64_t v9 = 0;
      int v8 = 0;
      if (_mach_boottime_usec(&v9, &v10))
      {
        return 0;
      }
      else
      {
        v9 *= 1000;
        return 1000000000 * v10.tv_sec + 1000 * v10.tv_usec - v9;
      }
    }
    else if (__clock_id == _CLOCK_PROCESS_CPUTIME_ID)
    {
      memset(&__b, 0, sizeof(__b));
      if (getrusage(0, &__b)) {
        return 0;
      }
      else {
        return 1000000000 * __b.ru_utime.tv_sec
      }
             + 1000 * __b.ru_utime.tv_usec
             + 1000000000 * __b.ru_stime.tv_sec
             + 1000 * __b.ru_stime.tv_usec;
    }
    else
    {
      mach_timebase_info info = 0;
      if (mach_timebase_info(&info) == 0)
      {
        if (v13 <= _CLOCK_MONOTONIC_RAW)
        {
          uint64_t v3 = v13 - 4;
          char v2 = 0;
        }
        else
        {
          uint64_t v3 = v13 - 4;
          char v2 = 1;
        }
        if (v2)
        {
LABEL_26:
          *__error() = 22;
          return 0;
        }
        else
        {
          switch(v3)
          {
            case 0:
              uint64_t v5 = mach_continuous_time();
              goto LABEL_27;
            case 1:
              uint64_t v5 = mach_continuous_approximate_time();
              goto LABEL_27;
            case 2:
            case 3:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
              goto LABEL_26;
            case 4:
              uint64_t v5 = mach_absolute_time();
              goto LABEL_27;
            case 5:
              uint64_t v5 = mach_approximate_time();
              goto LABEL_27;
            case 12:
              uint64_t v5 = __thread_selfusage();
LABEL_27:
              __uint64_t v14 = v5 * info.numer / info.denom;
              break;
            default:
              JUMPOUT(0);
          }
        }
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    v12.tv_sec = 0;
    *(void *)&v12.tv_usec = 0;
    int v11 = 0;
    if (gettimeofday(&v12, 0)) {
      return 0;
    }
    else {
      return 1000000000 * v12.tv_sec + 1000 * v12.tv_usec;
    }
  }
  return v14;
}

uint64_t _mach_boottime_usec(uint64_t *a1, timeval *a2)
{
  do
  {
    uint64_t v5 = mach_boottime_usec();
    if (!v5) {
      uint64_t v5 = _boottime_fallback_usec();
    }
    __dmb(0xBu);
    unsigned int v3 = gettimeofday(a2, 0);
    if (v3) {
      return v3;
    }
    __dmb(0xBu);
    uint64_t v4 = mach_boottime_usec();
    if (!v4) {
      uint64_t v4 = _boottime_fallback_usec();
    }
  }
  while (v5 != v4);
  *a1 = v5;
  return 0;
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  clockid_t v14 = __clock_id;
  clockid_t v13 = __tp;
  if (__clock_id)
  {
    uint64_t v3 = __clock_id;
    char v2 = 1;
  }
  else
  {
    uint64_t v3 = 0;
    char v2 = 0;
  }
  if ((v2 & 1) == 0)
  {
    switch(v3)
    {
      case 0:
        v12.tv_sec = 0;
        *(void *)&v12.tv_usec = 0;
        int v11 = gettimeofday(&v12, 0);
        v13->tv_sec = v12.tv_sec;
        v13->tv_nsec = 1000 * v12.tv_usec;
        return v11;
      case 1:
      case 2:
      case 3:
      case 7:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
        break;
      case 4:
      case 5:
      case 8:
      case 9:
      case 16:
        __uint64_t v5 = clock_gettime_nsec_np(v14);
        if (!v5) {
          return -1;
        }
        v13->tv_sec = v5 / 0x3B9ACA00;
        v13->tv_nsec = v5 % 0x3B9ACA00;
        return 0;
      case 6:
        v10.tv_sec = 0;
        *(void *)&v10.tv_usec = 0;
        unint64_t v9 = 0;
        int v8 = _mach_boottime_usec((uint64_t *)&v9, &v10);
        v10.tv_sec -= v9 / 0xF4240;
        v10.tv_usec -= v9 % 0xF4240;
        if (v10.tv_usec < 0)
        {
          --v10.tv_sec;
          v10.tv_usec += 1000000;
        }
        v13->tv_sec = v10.tv_sec;
        v13->tv_nsec = 1000 * v10.tv_usec;
        return v8;
      case 12:
        memset(&__b, 0, sizeof(__b));
        int v6 = getrusage(0, &__b);
        __b.ru_utime.tv_sec += __b.ru_stime.tv_sec;
        __b.ru_utime.tv_usec += __b.ru_stime.tv_usec;
        if (__b.ru_utime.tv_usec >= 1000000)
        {
          ++__b.ru_utime.tv_sec;
          __b.ru_utime.tv_usec -= 1000000;
        }
        v13->tv_sec = __b.ru_utime.tv_sec;
        v13->tv_nsec = 1000 * __b.ru_utime.tv_usec;
        return v6;
      default:
        JUMPOUT(0);
    }
  }
  *__error() = 22;
  return -1;
}

int clock_getres(clockid_t __clock_id, timespec *__res)
{
  clockid_t v7 = __clock_id;
  int v6 = __res;
  if (__clock_id == _CLOCK_REALTIME) {
    goto LABEL_14;
  }
  if (__clock_id == _CLOCK_MONOTONIC_RAW_APPROX || __clock_id == _CLOCK_MONOTONIC_RAW) {
    goto LABEL_15;
  }
  if (__clock_id == _CLOCK_MONOTONIC) {
    goto LABEL_14;
  }
  if (__clock_id == _CLOCK_UPTIME_RAW_APPROX || __clock_id == _CLOCK_UPTIME_RAW) {
    goto LABEL_15;
  }
  if (__clock_id == _CLOCK_PROCESS_CPUTIME_ID)
  {
LABEL_14:
    v6->tv_nsec = 1000;
    v6->tv_sec = 0;
    return 0;
  }
  if (__clock_id != _CLOCK_THREAD_CPUTIME_ID)
  {
    *__error() = 22;
    return -1;
  }
LABEL_15:
  mach_timebase_info info = 0;
  if (mach_timebase_info(&info)) {
    return -1;
  }
  v6->tv_nsec = info.numer / info.denom + (info.numer % info.denom != 0);
  v6->tv_sec = 0;
  return 0;
}

int clock_settime(clockid_t __clock_id, const timespec *__tp)
{
  clockid_t v5 = __clock_id;
  uint64_t v4 = __tp;
  if (__clock_id)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    v3.tv_sec = 0;
    *(void *)&v3.tv_usec = 0;
    v3.tv_sec = v4->tv_sec;
    v3.tv_usec = v4->tv_nsec / 1000;
    return settimeofday(&v3, 0);
  }
}

uint64_t _boottime_fallback_usec()
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  size_t v1 = 16;
  if (sysctlbyname("kern.boottime", &v2, &v1, 0, 0) == -1) {
    return 0;
  }
  else {
    return 1000000 * v2 + (int)v3;
  }
}

void *__cdecl sbrk(int a1)
{
  if (!sbrk_needs_init
    || (sbrk_needs_init = 0, !vm_allocate(mach_task_self_, (vm_address_t *)&sbrk_curbrk, sbrk_region_size, 83886081)))
  {
    if (a1 <= 0) {
      return (void *)sbrk_curbrk;
    }
    if (a1 <= (unint64_t)sbrk_region_size)
    {
      sbrk_curbrk += a1;
      sbrk_region_size -= a1;
      return (void *)(sbrk_curbrk - a1);
    }
  }
  *__error() = 12;
  return (void *)-1;
}

void *__cdecl brk(const void *a1)
{
  *__error() = 12;
  return (void *)-1;
}

void (__cdecl *__cdecl bsd_signal(int a1, void (__cdecl *a2)(int)))(int)
{
  int v7 = a1;
  int v6 = a2;
  v5.sa_mask = 0;
  v4.__sigaction_u.__sa_handler = 0;
  *(void *)&v4.sa_mask = 0;
  v5.__sigaction_u.__sa_handler = a2;
  v5.sa_flags = 2;
  int v9 = a1;
  if (a1 <= 32) {
    int v3 = 1 << (v9 - 1);
  }
  else {
    int v3 = 0;
  }
  v5.sa_mask |= v3;
  if (sigaction(v7, &v5, &v4) == -1) {
    return (void (__cdecl *)(int))-1;
  }
  else {
    return v4.__sigaction_u.__sa_handler;
  }
}

void strtoencf16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    int v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    _ffpp_strtoencf16_l(a1, a2, a3, (uint64_t)v8);
  }
  else {
    _ffpp_strtoencf16_l(a1, a2, a3, (uint64_t)__global_locale);
  }
}

void _ffpp_strtoencf16_l(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  uint64_t v7 = a3;
  uint64_t v6 = a4;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0xFFFFFFF20000000BLL;
  __b[1] = 0x200000010;
  __b[2] = 0x5FFFFFFF9;
  LODWORD(__b[3]) = 22;
  __b[4] = v9;
  __b[5] = v8;
  __b[6] = v7;
  __b[7] = v6;
  __b[8] = 0;
  LODWORD(__b[9]) = 0;
  memset(&__b[10], 0, 17);
  if (fastParse64((uint64_t)__b))
  {
    int v4 = fegetround();
    generalSlowpath((uint64_t)__b, v4, v10, 8, 0);
  }
}

void strtoencf32(float *a1, uint64_t a2, uint64_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    uint64_t v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    uint64_t v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    _ffpp_strtoencf32_l(a1, a2, a3, (uint64_t)v8);
  }
  else {
    _ffpp_strtoencf32_l(a1, a2, a3, (uint64_t)__global_locale);
  }
}

void _ffpp_strtoencf32_l(float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v32 = a1;
  uint64_t v31 = a2;
  uint64_t v30 = a3;
  uint64_t v29 = a4;
  uint64_t v28 = 0;
  long long v24 = 0u;
  v19[0] = 0xFFFFFF8200000018;
  v19[1] = 0x400000080;
  v19[2] = 0x28FFFFFFD2;
  v19[3] = 113;
  v20 = a1;
  uint64_t v21 = a2;
  uint64_t v22 = a3;
  uint64_t v23 = a4;
  *(void *)&long long v24 = 0;
  DWORD2(v24) = 0;
  uint64_t v25 = 0;
  int v26 = 0;
  int v27 = 0;
  if (!fastParse64((uint64_t)v19)) {
    return;
  }
  if (v27 >= -10 && v27 <= 10 && SDWORD2(v24) <= 7)
  {
    if (v28) {
      int v7 = -(int)v24;
    }
    else {
      int v7 = v24;
    }
    if (v27 < 0) {
      float *v20 = (float)v7 / _ffpp_strtoencf32_l_floatPowerOf10[-v27];
    }
    else {
      float *v20 = (float)v7 * _ffpp_strtoencf32_l_floatPowerOf10[v27];
    }
    return;
  }
  int v18 = fegetround();
  if (SDWORD2(v24) > 19)
  {
    __int16 v17 = v27 + WORD4(v24) - 19;
    unsigned int v16 = 36;
  }
  else
  {
    __int16 v17 = v27;
    unsigned int v16 = 4;
  }
  int v15 = __clz(v24);
  BOOL v6 = 1;
  if (v15 >= 5) {
    BOOL v6 = SDWORD2(v24) < 20;
  }
  if (!v6) {
    __assert_rtn("_ffpp_strtoencf32_l", "strtofp.c", 2901, "normalizeDigits <= 4 || info.digitCount < 20");
  }
  unint64_t v12 = (*((unint64_t *)&powersOf10_Float + v17 + 70) * (unsigned __int128)(unint64_t)((void)v24 << v15)) >> 64;
  int v11 = __clz(v12);
  if (v11 >= 2) {
    __assert_rtn("_ffpp_strtoencf32_l", "strtofp.c", 2919, "normalizeProduct <= 1");
  }
  unint64_t v13 = v12 << v11;
  int v14 = ((unint64_t)(55732705 * v17) >> 24) + 1 - v15 + 64 - v11;
  unint64_t v10 = v13 + v16;
  switch(v18)
  {
    case 0:
LABEL_31:
      int v9 = (v13 + 0x7FFFFFFFFFLL) >> 40;
      int v8 = (v10 + 0x8000000000) >> 40;
      break;
    case 4194304:
      if (v28)
      {
        int v9 = v13 >> 40;
        int v8 = v10 >> 40;
      }
      else
      {
        int v9 = (v13 + 0xFFFFFFFFFFLL) >> 40;
        int v8 = (v10 + 0x10000000000) >> 40;
      }
      break;
    case 8388608:
      if (v28)
      {
        int v9 = (v13 + 0xFFFFFFFFFFLL) >> 40;
        int v8 = (v10 + 0x10000000000) >> 40;
      }
      else
      {
        int v9 = v13 >> 40;
        int v8 = (v13 + 4) >> 40;
      }
      break;
    case 12582912:
      int v9 = v13 >> 40;
      int v8 = v10 >> 40;
      break;
    default:
      goto LABEL_31;
  }
  if (!v9) {
    ++v14;
  }
  if (v14 >= 129)
  {
    overflow((uint64_t)v19);
    return;
  }
  if (v14 <= -126)
  {
    if (v14 <= -150)
    {
      underflow((uint64_t)v19);
      return;
    }
    goto LABEL_44;
  }
  if (v8 != v9)
  {
LABEL_44:
    int v5 = fegetround();
    generalSlowpath((uint64_t)v19, v5, v33, 32, 0);
    return;
  }
  unsigned int v4 = 0x80000000;
  if ((v28 & 1) == 0) {
    unsigned int v4 = 0;
  }
  *(_DWORD *)v20 = v4 | ((v14 << 23) + 1056964608) | v9 & 0x7FFFFF;
}

float strtof(const char *a1, char **a2)
{
  int v9 = a1;
  int v8 = a2;
  float v7 = 0.0;
  unint64_t v10 = 0;
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    unint64_t v10 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v11 = __locale_key;
    uint64_t v12 = __locale_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    unint64_t v10 = *(void **)(StatusReg + 8 * v12);
  }
  if (v10) {
    _ffpp_strtoencf32_l(&v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)v10);
  }
  else {
    _ffpp_strtoencf32_l(&v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)__global_locale);
  }
  return v7;
}

float strtof_l(const char *a1, char **a2, locale_t a3)
{
  float v7 = a1;
  BOOL v6 = a2;
  locale_t v5 = a3;
  float v4 = 0.0;
  _ffpp_strtoencf32_l(&v4, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  return v4;
}

void strtoencf64(double *a1, uint64_t a2, uint64_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    int v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    _ffpp_strtoencf64_l(a1, a2, a3, (uint64_t)v8);
  }
  else {
    _ffpp_strtoencf64_l(a1, a2, a3, (uint64_t)__global_locale);
  }
}

void _ffpp_strtoencf64_l(double *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v43 = a1;
  uint64_t v42 = a2;
  uint64_t v41 = a3;
  uint64_t v40 = a4;
  uint64_t v39 = 0;
  v32[0] = 0xFFFFFC0200000035;
  v32[1] = 0x800000400;
  v32[2] = 0x136FFFFFEBBLL;
  v32[3] = 768;
  v33 = a1;
  uint64_t v34 = a2;
  uint64_t v35 = a3;
  uint64_t v36 = a4;
  long long v37 = 0uLL;
  long long v38 = 0uLL;
  if (!fastParse64((uint64_t)v32)) {
    return;
  }
  if (SHIDWORD(v38) >= -22 && SHIDWORD(v38) <= 18)
  {
    if ((HIDWORD(v38) & 0x80000000) != 0)
    {
      if (SDWORD2(v37) <= 15)
      {
        if (v39) {
          uint64_t v8 = -(uint64_t)v37;
        }
        else {
          uint64_t v8 = v37;
        }
        double *v33 = (double)v8 / _ffpp_strtoencf64_l_doublePowerOf10[-HIDWORD(v38)];
        return;
      }
    }
    else if (HIDWORD(v38))
    {
      if (SDWORD2(v37) <= 19)
      {
        double v31 = _ffpp_strtoencf64_l_doublePowerOf10[SHIDWORD(v38)];
        if (v39) {
          double v31 = -v31;
        }
        double *v33 = (double)(v37 & 0x7FF) * v31 + (double)((unint64_t)v37 & 0xFFFFFFFFFFFFF800) * v31;
        return;
      }
    }
    else if (SDWORD2(v37) <= 19)
    {
      if ((v39 & 1) == 0)
      {
        double *v33 = (double)(unint64_t)v37;
        return;
      }
      if ((v37 & 0x8000000000000000) == 0)
      {
        double *v33 = (double)-(uint64_t)v37;
        return;
      }
    }
  }
  int v30 = fegetround();
  if (SDWORD2(v37) > 19)
  {
    __int16 v29 = WORD6(v38) + WORD4(v37) - 19;
    unsigned int v28 = 80;
  }
  else
  {
    __int16 v29 = WORD6(v38);
    unsigned int v28 = 12;
  }
  __int16 v27 = (585 * v29 + 256) >> 14;
  __int16 v26 = v29 - 28 * v27;
  unint64_t v25 = (powersOf10_CoarseBinary64[v27 + 15] * (unsigned __int128)*((unint64_t *)powersOf10_Exact64 + v26)) >> 64;
  int v23 = __clz(v37);
  BOOL v7 = 1;
  if (v23 >= 5) {
    BOOL v7 = SDWORD2(v37) < 20;
  }
  if (!v7) {
    __assert_rtn("_ffpp_strtoencf64_l", "strtofp.c", 3156, "normalizeDigits <= 4 || info.digitCount < 20");
  }
  int v20 = __clz((v25 * (unsigned __int128)(unint64_t)((void)v37 << v23)) >> 64);
  if (v20 >= 3) {
    __assert_rtn("_ffpp_strtoencf64_l", "strtofp.c", 3176, "normalizeProduct <= 2");
  }
  uint64_t v21 = (v25 * (unsigned __int128)(unint64_t)((void)v37 << v23)) >> 64 << v20;
  int v24 = ((unint64_t)(55732705 * (__int16)(28 * v27)) >> 24) + ((unint64_t)(55732705 * v26) >> 24) + 2;
  int v22 = v24 - v23 + 64 - v20;
  BOOL v17 = v39 & 1;
  switch(v30)
  {
    case 0:
      goto LABEL_40;
    case 4194304:
      BOOL v17 = (v39 & 1) == 0;
      break;
    case 8388608:
      break;
    case 12582912:
      goto LABEL_39;
    default:
LABEL_40:
      unsigned int v19 = 1023;
      unsigned int v18 = v28 + 1024;
      goto LABEL_41;
  }
  if (!v17)
  {
LABEL_39:
    unsigned int v19 = 0;
    unsigned int v18 = v28;
    goto LABEL_41;
  }
  unsigned int v19 = 2047;
  unsigned int v18 = v28 + 2048;
LABEL_41:
  unint64_t v15 = (v21 + (unint64_t)v19) >> 11;
  int v14 = v24 - v23 + 64 - v20;
  if (!v15) {
    int v14 = v22 + 1;
  }
  if (v14 >= 1025)
  {
    overflow((uint64_t)v32);
    return;
  }
  if (v14 <= -1022)
  {
    if (v14 <= -1075)
    {
      underflow((uint64_t)v32);
      return;
    }
    int v13 = -1010 - v22;
    if (-1010 - v22 >= 63 && v22 != -1073) {
      goto LABEL_77;
    }
    BOOL v6 = 0;
    if (v13 >= 1) {
      BOOL v6 = v13 < 64;
    }
    if (!v6) {
      __assert_rtn("_ffpp_strtoencf64_l", "strtofp.c", 3240, "0 < shift && shift < 64");
    }
    BOOL v10 = v39 & 1;
    switch(v30)
    {
      case 0:
        goto LABEL_63;
      case 4194304:
        BOOL v10 = (v39 & 1) == 0;
        break;
      case 8388608:
        break;
      case 12582912:
LABEL_62:
        uint64_t v12 = 0;
        uint64_t v11 = v28;
        goto LABEL_64;
      default:
LABEL_63:
        uint64_t v12 = (1 << (13 - v22)) - 1;
        uint64_t v11 = (1 << (13 - v22)) + v28;
LABEL_64:
        uint64_t v16 = (unint64_t)(v21 + v12) >> v13;
        if ((unint64_t)(v21 + v11) >> v13 == v16)
        {
          if (!v16) {
            uint64_t v16 = 1 << (v22 - 14);
          }
          unint64_t v4 = 0x8000000000000000;
          if ((v39 & 1) == 0) {
            unint64_t v4 = 0;
          }
          unint64_t v9 = v4 | v16;
          if ((v4 | v16) != 0x10000000000000) {
            *__error() = 34;
          }
          *(void *)v33 = v9;
          return;
        }
LABEL_77:
        generalSlowpath((uint64_t)v32, v30, v44, 164, 0);
        return;
    }
    if (v10)
    {
      uint64_t v12 = (1 << v13) - 1;
      uint64_t v11 = v12 + v28;
      goto LABEL_64;
    }
    goto LABEL_62;
  }
  if ((v21 + (unint64_t)v18) >> 11 != v15) {
    goto LABEL_77;
  }
  unint64_t v5 = 0x8000000000000000;
  if ((v39 & 1) == 0) {
    unint64_t v5 = 0;
  }
  *(void *)v33 = v5 | ((unint64_t)(v14 + 1022) << 52) | v15 & 0xFFFFFFFFFFFFFLL;
}

void strtoencf64x(double *a1, uint64_t a2, uint64_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    uint64_t v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    uint64_t v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    _ffpp_strtoencf64_l(a1, a2, a3, (uint64_t)v8);
  }
  else {
    _ffpp_strtoencf64_l(a1, a2, a3, (uint64_t)__global_locale);
  }
}

double strtod(const char *a1, char **a2)
{
  *(void *)&v7[2] = a1;
  *(void *)&v7[1] = a2;
  v7[0] = 0.0;
  uint64_t v8 = 0;
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    uint64_t v10 = __locale_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    uint64_t v8 = *(void **)(StatusReg + 8 * v10);
  }
  if (v8) {
    _ffpp_strtoencf64_l(v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)v8);
  }
  else {
    _ffpp_strtoencf64_l(v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)__global_locale);
  }
  return v7[0];
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  *(void *)&v4[3] = a1;
  *(void *)&v4[2] = a2;
  *(void *)&v4[1] = a3;
  v4[0] = 0.0;
  _ffpp_strtoencf64_l(v4, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  return v4[0];
}

long double strtold(const char *a1, char **a2)
{
  *(void *)&v7[2] = a1;
  *(void *)&v7[1] = a2;
  v7[0] = 0.0;
  uint64_t v8 = 0;
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    uint64_t v10 = __locale_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    uint64_t v8 = *(void **)(StatusReg + 8 * v10);
  }
  if (v8) {
    _ffpp_strtoencf64_l(v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)v8);
  }
  else {
    _ffpp_strtoencf64_l(v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)__global_locale);
  }
  return v7[0];
}

long double strtold_l(const char *a1, char **a2, locale_t a3)
{
  *(void *)&v4[3] = a1;
  *(void *)&v4[2] = a2;
  *(void *)&v4[1] = a3;
  v4[0] = 0.0;
  _ffpp_strtoencf64_l(v4, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  return v4[0];
}

uint64_t fastParse64(uint64_t a1)
{
  v32 = *(unsigned __int8 **)(a1 + 40);
  uint64_t v31 = 0;
  int v30 = 0;
  int v29 = 0;
  *(unsigned char *)(a1 + 96) = 0;
  while (*v32 < 0x30u || *v32 > 0x39u)
  {
    if (*v32 == 45)
    {
      *(unsigned char *)(a1 + 96) = 1;
      ++v32;
      break;
    }
    if (*v32 == 43)
    {
      ++v32;
      break;
    }
    if (*v32 != 32 && !isspace(*v32)) {
      break;
    }
    ++v32;
  }
  switch(*v32)
  {
    case '0':
      if (v32[1] == 120 || v32[1] == 88)
      {
        hexFloat((uint64_t)v32, a1);
        return 0;
      }
      while (*v32 == 48)
        ++v32;
LABEL_67:
      int v24 = v32;
      unsigned __int8 v22 = *v32 - 48;
      if (v22 < 0xAu)
      {
        uint64_t v31 = v22;
        for (unsigned __int8 i = *++v32 - 48; i < 0xAu; unsigned __int8 i = *v32 - 48)
        {
          uint64_t v31 = 10 * v31 + i;
          ++v32;
        }
        int v30 = v32 - v24;
      }
      if (*(void *)(a1 + 56))
      {
        if (*v32 != 32 && *v32 && *v32 != 101 && *v32 != 69)
        {
          size_t v1 = localeconv_l(*(locale_t *)(a1 + 56));
          if (!v1->decimal_point[1])
          {
            if (*(unsigned __int8 *)v1->decimal_point == *v32) {
              ++v32;
            }
            goto LABEL_90;
          }
          uint64_t v21 = v32;
          int v20 = 1;
          for (j = v1->decimal_point; *j; ++j)
            int v20 = v20 & (*v32++ == *j);
          if (v20)
          {
LABEL_90:
            int v18 = (int)v32;
            if (v30)
            {
              unsigned int v14 = *v32 - 48;
              if (v14 < 0xA)
              {
                ++v32;
                uint64_t v31 = 10 * v31 + v14;
                for (unsigned int k = *v32 - 48; k < 0xA; unsigned int k = *v32 - 48)
                {
                  ++v32;
                  uint64_t v31 = 10 * v31 + k;
                }
              }
              v30 += v32 - v18;
            }
            else
            {
              while (*v32 == 48)
                ++v32;
              int v24 = v32;
              unsigned int v16 = *v32 - 48;
              if (v16 < 0xA)
              {
                ++v32;
                uint64_t v31 = v16;
                for (unsigned int m = *v32 - 48; m < 0xA; unsigned int m = *v32 - 48)
                {
                  uint64_t v31 = 10 * v31 + m;
                  ++v32;
                }
              }
              int v30 = v32 - v24;
            }
            int v29 = v18 - v32;
            goto LABEL_104;
          }
          v32 = v21;
        }
      }
      else if (*v32 == 46)
      {
        ++v32;
        goto LABEL_90;
      }
LABEL_104:
      if (*v32 == 101 || *v32 == 69)
      {
        int v13 = v32;
        uint64_t v34 = v32 + 1;
        int v12 = 1;
        if (*v34 == 45)
        {
          int v12 = -1;
          ++v34;
        }
        else if (*v34 == 43)
        {
          ++v34;
        }
        unsigned __int8 v10 = *v34 - 48;
        if (v10 >= 0xAu)
        {
          v32 = v13;
        }
        else
        {
          int v9 = v10;
          v32 = v34 + 1;
          for (unsigned __int8 n = *v32 - 48; n < 0xAu; unsigned __int8 n = *v32 - 48)
          {
            ++v32;
            int v9 = 10 * v9 + n;
          }
          if (v32 - v13 > 9)
          {
            uint64_t v8 = v13 + 1;
            if (v13[1] == 45 || *v8 == 43) {
              uint64_t v8 = v13 + 2;
            }
            while (*v8 == 48)
              ++v8;
            if (v32 - v8 > 8) {
              int v9 = 99999999;
            }
          }
          v29 += v9 * v12;
        }
      }
      if (*(void *)(a1 + 48)) {
        **(void **)(a1 + 48) = v32;
      }
      if (v30)
      {
        if (v29 + v30 >= *(_DWORD *)(a1 + 16))
        {
          if (v29 + v30 <= *(_DWORD *)(a1 + 20))
          {
            int v7 = 0;
            if (v30 <= 19)
            {
              unint64_t v25 = 0;
            }
            else
            {
              uint64_t v31 = 0;
              int v6 = 0;
              unint64_t v5 = v24;
              while (v6 < 19)
              {
                unsigned int v4 = *v5 - 48;
                if (v4 < 0xA)
                {
                  uint64_t v31 = 10 * v31 + v4;
                  ++v6;
                }
                ++v5;
              }
              unint64_t v25 = v5;
              int v7 = v30 - 19;
            }
            *(_DWORD *)(a1 + 72) = v30;
            *(void *)(a1 + 80) = v25;
            *(_DWORD *)(a1 + 88) = v7;
            *(void *)(a1 + 64) = v31;
            *(_DWORD *)(a1 + 92) = v29;
            return 1;
          }
          else
          {
            overflow(a1);
            return 0;
          }
        }
        else
        {
          underflow(a1);
          return 0;
        }
      }
      else
      {
        bzero(*(void **)(a1 + 32), *(int *)(a1 + 12));
        if (*(unsigned char *)(a1 + 96)) {
          char v2 = 0x80;
        }
        else {
          char v2 = 0;
        }
        *(unsigned char *)(*(void *)(a1 + 32) + *(_DWORD *)(a1 + 12) - 1) = v2;
        return 0;
      }
    case 'i':
    case 'I':
      if ((v32[1] == 110 || v32[1] == 78) && (v32[2] == 102 || v32[2] == 70))
      {
        if ((v32[3] == 105 || v32[3] == 73)
          && (v32[4] == 110 || v32[4] == 78)
          && (v32[5] == 105 || v32[5] == 73)
          && (v32[6] == 116 || v32[6] == 84)
          && (v32[7] == 121 || v32[7] == 89))
        {
          v33 = v32 + 8;
        }
        else
        {
          v33 = v32 + 3;
        }
        if (*(void *)(a1 + 48)) {
          **(void **)(a1 + 48) = v33;
        }
        infinity(a1);
        return 0;
      }
      break;
    case 'n':
    case 'N':
      if ((v32[1] == 97 || v32[1] == 65) && (v32[2] == 110 || v32[2] == 78))
      {
        parseNan((uint64_t)v32, a1);
        return 0;
      }
      break;
    default:
      if (*v32 >= 0x30u && *v32 <= 0x39u) {
        goto LABEL_67;
      }
      if (*(void *)(a1 + 56))
      {
        decimal_point = localeconv_l(*(locale_t *)(a1 + 56))->decimal_point;
        if (decimal_point[1])
        {
          int v27 = 1;
          for (iunsigned __int8 i = decimal_point; *ii; ++ii)
            int v27 = v27 & (*v32++ == *ii);
          if (v27 && *v32 >= 0x30u && *v32 <= 0x39u) {
            goto LABEL_90;
          }
        }
        else if (*decimal_point == *v32 && *++v32 >= 0x30u && *v32 <= 0x39u)
        {
          goto LABEL_90;
        }
      }
      else if (*v32 == 46 && *++v32 >= 0x30u && *v32 <= 0x39u)
      {
        goto LABEL_90;
      }
      break;
  }
  if (*(void *)(a1 + 48)) {
    **(void **)(a1 + 48) = *(void *)(a1 + 40);
  }
  bzero(*(void **)(a1 + 32), *(int *)(a1 + 12));
  return 0;
}

void generalSlowpath(uint64_t a1, int a2, void *a3, int a4, char a5)
{
  uint64_t v65 = a1;
  int v64 = a2;
  v63 = a3;
  int v62 = a4;
  unsigned __int8 v61 = a5 & 1;
  long long v60 = 0uLL;
  int v59 = 0;
  v58 = 0;
  int v57 = 0;
  int v57 = *(_DWORD *)(a1 + 72);
  if (v57 > *(_DWORD *)(a1 + 24)) {
    int v57 = *(_DWORD *)(v65 + 24) + 1;
  }
  int v56 = 0;
  int v56 = *(_DWORD *)(v65 + 92) - v57 + *(_DWORD *)(v65 + 72);
  int v55 = (1701 * v57) >> 9;
  int v54 = (v55 + 31) / 32;
  int v53 = 0;
  if (v56 >= 0) {
    int v22 = v56;
  }
  else {
    int v22 = -v56;
  }
  int v53 = (1189 * (v22 + 1)) >> 9;
  int v52 = (v53 + 31) / 32;
  if (v56 >= 0)
  {
    int v51 = v54 + v52;
    v49 = 0;
    v50 = 0;
    if (v54 + v52 <= v62)
    {
      bzero(v63, 4 * v62);
      v50 = (unsigned int *)v63;
      v49 = (unsigned int *)v63;
      goto LABEL_14;
    }
    if ((v61 ^ 1)) {
      __assert_rtn("generalSlowpath", "strtofp.c", 1867, "heapAllocOK");
    }
    v58 = (unsigned int *)calloc(v51, 4uLL);
    if (v58)
    {
      v50 = v58;
      v49 = v58;
LABEL_14:
      initMPFromDigits((uint64_t)&v49, v65);
      multiplyByFiveToTheN(&v49, v56);
      if (v50 - v49 > v51) {
        __assert_rtn("generalSlowpath", "strtofp.c", 1879, "(workMP.msw - workMP.lsw) <= totalWordsNeeded");
      }
      int v48 = bitCountMP((uint64_t)v49, (uint64_t)v50);
      int v59 = v48 + v56;
      *(void *)&long long v47 = shiftRightMPWithRounding((uint64_t)v49, (uint64_t)v50, v48 - *(_DWORD *)v65, 0, *(unsigned char *)(v65 + 96) & 1, v64);
      *((void *)&v47 + 1) = v5;
      long long v60 = v47;
      int v6 = bitCountMP(v47, v5);
      if (v6 > *(_DWORD *)v65)
      {
        ++v59;
        *(void *)&long long v46 = shiftRightMPWithTruncation(v60, *((uint64_t *)&v60 + 1), 1);
        *((void *)&v46 + 1) = v7;
        long long v60 = v46;
      }
      if (v59 > *(_DWORD *)(v65 + 8))
      {
        free(v58);
        overflow(v65);
        return;
      }
      goto LABEL_53;
    }
LABEL_12:
    bzero(*(void **)(v65 + 32), *(int *)(v65 + 12));
    return;
  }
  int v45 = v55;
  if (v55 < v53 + *(_DWORD *)v65 + 2) {
    int v45 = v53 + *(_DWORD *)v65 + 2;
  }
  int v44 = (v45 + 31) / 32 + 2;
  int v43 = v52;
  int v42 = v44 + v52;
  uint64_t v41 = 0;
  if (v44 + v52 > v62)
  {
    if ((v61 ^ 1)) {
      __assert_rtn("generalSlowpath", "strtofp.c", 1925, "heapAllocOK");
    }
    v58 = (unsigned int *)calloc(v42, 4uLL);
    if (!v58) {
      goto LABEL_12;
    }
    uint64_t v41 = v58;
  }
  else
  {
    bzero(v63, 4 * v62);
    uint64_t v41 = (unsigned int *)v63;
  }
  unint64_t v39 = (unint64_t)v41;
  unint64_t v40 = (unint64_t)v41;
  long long v37 = &v41[v44];
  long long v38 = v37;
  fiveToTheN((uint64_t)&v37, -v56);
  if (v38 - v37 > v43) {
    __assert_rtn("generalSlowpath", "strtofp.c", 1940, "(denominator.msw - denominator.lsw) <= denominatorWordsNeeded");
  }
  if (!*(v38 - 1)) {
    __assert_rtn("generalSlowpath", "strtofp.c", 1941, "denominator.msw[-1] != 0");
  }
  initMPFromDigits((uint64_t)&v39, v65);
  if (!*(_DWORD *)(v40 - 4)) {
    __assert_rtn("generalSlowpath", "strtofp.c", 1946, "numerator.msw[-1] != 0");
  }
  int v36 = 0;
  int v21 = bitCountMP((uint64_t)v37, (uint64_t)v38);
  int v8 = bitCountMP(v39, v40);
  int v36 = v21 - v8 + *(_DWORD *)v65 + 2;
  if (v36 <= 0)
  {
    int v36 = 0;
  }
  else
  {
    shiftLeftMP((uint64_t)&v39, v36);
    if (!*(_DWORD *)(v40 - 4)) {
      __assert_rtn("generalSlowpath", "strtofp.c", 1950, "numerator.msw[-1] != 0");
    }
    if ((uint64_t)(v40 - v39) / 4 >= v44) {
      __assert_rtn("generalSlowpath", "strtofp.c", 1951, "(numerator.msw - numerator.lsw) < numeratorWordsNeeded");
    }
  }
  int v35 = 0;
  uint64_t v33 = divideMPByMP(v39, v40, v37, (unint64_t)v38, &v35);
  uint64_t v34 = v9;
  int v32 = bitCountMP(v33, v9);
  int v59 = v32 + v56 - v36;
  if (v59 <= *(_DWORD *)(v65 + 4))
  {
    if (v59 <= *(_DWORD *)(v65 + 4) - *(_DWORD *)v65)
    {
      free(v58);
      underflow(v65);
      return;
    }
    int v29 = v59 - (*(_DWORD *)(v65 + 4) - *(_DWORD *)v65 + 1);
    int v59 = *(_DWORD *)(v65 + 4);
    *(void *)&long long v28 = shiftRightMPWithRounding(v33, v34, v32 - v29, v35, *(unsigned char *)(v65 + 96) & 1, v64);
    *((void *)&v28 + 1) = v13;
    long long v60 = v28;
    int v14 = bitCountMP(v28, v13);
    if (v14 < *(_DWORD *)v65) {
      *__error() = 34;
    }
    else {
      ++v59;
    }
  }
  else
  {
    *(void *)&long long v31 = shiftRightMPWithRounding(v33, v34, v32 - *(_DWORD *)v65, v35, *(unsigned char *)(v65 + 96) & 1, v64);
    *((void *)&v31 + 1) = v10;
    long long v60 = v31;
    int v11 = bitCountMP(v31, v10);
    if (v11 > *(_DWORD *)v65)
    {
      ++v59;
      *(void *)&long long v30 = shiftRightMPWithTruncation(v60, *((uint64_t *)&v60 + 1), 1);
      *((void *)&v30 + 1) = v12;
      long long v60 = v30;
    }
    if (v59 > *(_DWORD *)(v65 + 8))
    {
      free(v58);
      overflow(v65);
      return;
    }
  }
LABEL_53:
  unint64_t v27 = (*((void *)&v60 + 1) - (void)v60) / 4;
  unint64_t v26 = (*(_DWORD *)v65 + 31) / 32;
  if (v27 < v26) {
    bzero((void *)(v60 + 4 * v27), 4 * (v26 - v27));
  }
  memcpy(*(void **)(v65 + 32), (const void *)v60, (*(_DWORD *)v65 + 7) / 8u);
  free(v58);
  unsigned __int16 v24 = v59 - *(_DWORD *)(v65 + 4);
  if (*(int *)(v65 + 12) <= 8) {
    v24 <<= 15 - (8 * *(unsigned char *)(v65 + 12) - *(unsigned char *)v65);
  }
  if (*(unsigned char *)(v65 + 96)) {
    __int16 v15 = 0x8000;
  }
  else {
    __int16 v15 = 0;
  }
  __int16 v25 = v24 | v15;
  uint64_t v23 = *(void *)(v65 + 32) + *(int *)(v65 + 12);
  unsigned int v16 = *(_DWORD *)(v65 + 12);
  BOOL v17 = v16 > 2;
  uint64_t v18 = v16 - 2;
  if (v17)
  {
    uint64_t v20 = v18;
    char v19 = 1;
  }
  else
  {
    uint64_t v20 = v18;
    char v19 = 0;
  }
  if ((v19 & 1) == 0)
  {
    switch(v20)
    {
      case 0:
        *(unsigned char *)(v23 - 1) = *(unsigned char *)(*(void *)(v65 + 32) + 1) & 3 | HIBYTE(v25);
        return;
      case 1:
      case 3:
      case 4:
      case 5:
      case 7:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
        break;
      case 2:
        *(unsigned char *)(v23 - 2) = *(unsigned char *)(*(void *)(v65 + 32) + 2) & 0x7F | v25;
        break;
      case 6:
        *(unsigned char *)(v23 - 2) = *(unsigned char *)(*(void *)(v65 + 32) + 6) & 0xF | v25;
        break;
      case 8:
      case 14:
        *(unsigned char *)(v23 - 2) = v25;
        break;
      default:
        JUMPOUT(0);
    }
  }
  *(unsigned char *)(v23 - 1) = HIBYTE(v25);
}

void hexFloat(uint64_t a1, uint64_t a2)
{
  int v29 = (unsigned char *)(a1 + 2);
  unint64_t v28 = 0;
  unint64_t v26 = 0;
  int v25 = 0;
  int v23 = 0;
  while (1)
  {
    BOOL v11 = 0;
    if (hexdigit[*v29] < 0x10u) {
      BOOL v11 = v28 < 0x1000000000000000;
    }
    if (!v11) {
      break;
    }
    unint64_t v28 = 16 * v28 + hexdigit[*v29++];
  }
  while (1)
  {
    BOOL v10 = 0;
    if (hexdigit[*v29] < 0x10u) {
      BOOL v10 = v26 < 0x800000000000000;
    }
    if (!v10) {
      break;
    }
    unint64_t v26 = (16 * v26) | (v28 >> 60);
    unint64_t v28 = 16 * v28 + hexdigit[*v29++];
  }
  while (hexdigit[*v29] < 0x10u)
  {
    v25 |= hexdigit[*v29];
    v23 += 4;
    ++v29;
  }
  int v22 = v29 - (a1 + 2);
  if (*(void *)(a2 + 56))
  {
    int v21 = v29;
    for (unsigned __int8 i = localeconv_l(*(locale_t *)(a2 + 56))->decimal_point; *i; ++i)
    {
      if (*v29 != *i)
      {
        int v29 = v21;
        goto LABEL_34;
      }
      ++v29;
    }
  }
  else
  {
    if (*v29 != 46) {
      goto LABEL_34;
    }
    ++v29;
  }
  int v19 = (int)v29;
  if (!v26)
  {
    while (1)
    {
      BOOL v9 = 0;
      if (hexdigit[*v29] < 0x10u) {
        BOOL v9 = v28 < 0x1000000000000000;
      }
      if (!v9) {
        break;
      }
      unint64_t v28 = 16 * v28 + hexdigit[*v29++];
    }
  }
  while (1)
  {
    BOOL v8 = 0;
    if (hexdigit[*v29] < 0x10u) {
      BOOL v8 = v26 < 0x800000000000000;
    }
    if (!v8) {
      break;
    }
    unint64_t v26 = (16 * v26) | (v28 >> 60);
    unint64_t v28 = 16 * v28 + hexdigit[*v29++];
  }
  v23 -= 4 * (v29 - v19);
  while (hexdigit[*v29] < 0x10u)
    v25 |= hexdigit[*v29++];
  v22 += v29 - v19;
LABEL_34:
  if (*v29 == 112 || *v29 == 80)
  {
    uint64_t v18 = v29++;
    int v17 = 0;
    if (*v29 == 45)
    {
      int v17 = 1;
      ++v29;
    }
    else if (*v29 == 43)
    {
      ++v29;
    }
    if (*v29 >= 0x30u && *v29 <= 0x39u)
    {
      int v16 = 0;
      for (unsigned int j = *v29 - 48; j < 0xA; unsigned int j = *v29 - 48)
      {
        if (v16 <= 99999999) {
          int v16 = 10 * v16 + j;
        }
        else {
          int v16 = 99999999;
        }
        ++v29;
      }
      if (v17) {
        int v16 = -v16;
      }
      v23 += v16;
    }
    else
    {
      int v29 = v18;
    }
  }
  if (!v28 && !v26)
  {
    if (!v22) {
      int v29 = (unsigned char *)(a1 + 1);
    }
    int v24 = *(_DWORD *)(a2 + 4);
    goto LABEL_111;
  }
  if (!v26)
  {
    if ((v28 & 0x8000000000000000) != 0)
    {
      unint64_t v26 = v28 >> 1;
      v28 <<= 63;
      v23 -= 63;
    }
    else
    {
      unint64_t v26 = v28;
      unint64_t v28 = 0;
      v23 -= 64;
    }
  }
  int v14 = __clz(v26) - 1;
  if (v14 > 0)
  {
    unint64_t v26 = (v26 << v14) | (v28 >> (64 - v14));
    v28 <<= v14;
    v23 -= v14;
  }
  int v24 = v23 + 127;
  if (v25) {
    v28 |= 1uLL;
  }
  if (v24 <= *(_DWORD *)(a2 + 8) && v24 >= *(_DWORD *)(a2 + 4) - *(_DWORD *)a2 + 1)
  {
    if (v24 <= *(_DWORD *)(a2 + 4))
    {
      int v13 = 128 - (v24 - *(_DWORD *)(a2 + 4) + *(_DWORD *)a2);
      int v24 = *(_DWORD *)(a2 + 4);
    }
    else
    {
      int v13 = 127 - *(_DWORD *)a2;
    }
    if (v13 >= 64)
    {
      unint64_t v12 = (v26 << (0x80 - v13)) | (v28 >> (v13 - 64));
      if (v28 << (0x80 - v13)) {
        v12 |= 1uLL;
      }
      unint64_t v28 = v26 >> (v13 - 64);
      unint64_t v27 = 0;
    }
    else
    {
      unint64_t v12 = v28 << (64 - v13);
      unint64_t v28 = (v28 >> v13) | (v26 << (64 - v13));
      unint64_t v27 = v26 >> v13;
    }
    int v7 = fegetround();
    switch(v7)
    {
      case 0:
        goto LABEL_133;
      case 0x400000:
        if ((*(unsigned char *)(a2 + 96) & 1) == 0)
        {
          if (v12)
          {
            if (!++v28) {
              ++v27;
            }
          }
        }
        goto LABEL_95;
      case 0x800000:
        if (*(unsigned char *)(a2 + 96))
        {
          if (v12)
          {
            if (!++v28) {
              ++v27;
            }
          }
        }
        goto LABEL_95;
    }
    if (v7 != 12582912)
    {
LABEL_133:
      if (v12 > 0x8000000000000000 || v12 == 0x8000000000000000 && (v28) && !++v28) {
        ++v27;
      }
    }
LABEL_95:
    if (v24 == *(_DWORD *)(a2 + 4)) {
      int v6 = *(_DWORD *)a2 - 1;
    }
    else {
      int v6 = *(_DWORD *)a2;
    }
    if (v6 > 64 && v27 >> (v6 - 64) || v6 == 64 && v27 || v6 < 64 && (v27 || v28 >> v6))
    {
      if (v24 > *(_DWORD *)(a2 + 4)) {
        unint64_t v28 = (v28 >> 1) | (v27 << 63);
      }
      ++v24;
    }
    else if (v24 == *(_DWORD *)(a2 + 4) && v12)
    {
      *__error() = 34;
    }
  }
LABEL_111:
  if (*(void *)(a2 + 48)) {
    **(void **)(a2 + 48) = v29;
  }
  if (v24 <= *(_DWORD *)(a2 + 8))
  {
    if (v24 >= *(_DWORD *)(a2 + 4) - *(_DWORD *)a2 + 1)
    {
      int v5 = *(_DWORD *)(a2 + 12);
      switch(v5)
      {
        case 2:
          if (*(unsigned char *)(a2 + 96)) {
            __int16 v2 = 0x8000;
          }
          else {
            __int16 v2 = 0;
          }
          **(_WORD **)(a2 + 32) = v2 | (((_WORD)v24 - (unsigned __int16)*(_DWORD *)(a2 + 4)) << 10) | v28 & 0x3FF;
          break;
        case 4:
          unsigned int v3 = 0x80000000;
          if ((*(unsigned char *)(a2 + 96) & 1) == 0) {
            unsigned int v3 = 0;
          }
          **(_DWORD **)(a2 + 32) = v3 | ((v24 - *(_DWORD *)(a2 + 4)) << 23) | v28 & 0x7FFFFF;
          break;
        case 8:
          unint64_t v4 = 0x8000000000000000;
          if ((*(unsigned char *)(a2 + 96) & 1) == 0) {
            unint64_t v4 = 0;
          }
          **(void **)(a2 + 32) = v4 | ((uint64_t)(v24 - *(_DWORD *)(a2 + 4)) << 52) | v28 & 0xFFFFFFFFFFFFFLL;
          break;
      }
    }
    else
    {
      underflow(a2);
    }
  }
  else
  {
    overflow(a2);
  }
}

void infinity(uint64_t a1)
{
  int v4 = *(_DWORD *)(a1 + 12);
  switch(v4)
  {
    case 2:
      if (*(unsigned char *)(a1 + 96)) {
        __int16 v1 = -1024;
      }
      else {
        __int16 v1 = 31744;
      }
      **(_WORD **)(a1 + 32) = v1;
      break;
    case 4:
      int v2 = -8388608;
      if ((*(unsigned char *)(a1 + 96) & 1) == 0) {
        int v2 = 2139095040;
      }
      **(_DWORD **)(a1 + 32) = v2;
      break;
    case 8:
      unint64_t v3 = 0xFFF0000000000000;
      if ((*(unsigned char *)(a1 + 96) & 1) == 0) {
        unint64_t v3 = 0x7FF0000000000000;
      }
      **(void **)(a1 + 32) = v3;
      break;
    default:
      bzero(*(void **)(a1 + 32), *(int *)(a1 + 12));
      break;
  }
}

void *parseNan(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  unint64_t v12 = (unsigned char *)(a1 + 3);
  uint64_t __src = 0;
  uint64_t v16 = 0;
  int v17 = 0;
  BOOL v11 = (unsigned char *)(a1 + 3);
  if (*(unsigned char *)(a1 + 3) == 40)
  {
    ++v12;
    unsigned int v10 = 10;
    if (*v12 == 48)
    {
      if (*++v12 == 120)
      {
        unsigned int v10 = 16;
        ++v12;
      }
      else
      {
        unsigned int v10 = 8;
      }
    }
    *(void *)&long long v9 = &__src;
    *((void *)&v9 + 1) = &v17;
    long long v8 = v9;
    while (hexdigit[*v12] < v10)
    {
      multiplyMPByN((uint64_t)&v8, v10);
      addToMP((uint64_t)&v8, hexdigit[*v12]);
      *((void *)&v8 + 1) = *((void *)&v9 + 1);
      ++v12;
    }
    if (*v12 == 41)
    {
      ++v12;
    }
    else
    {
      uint64_t __src = 0;
      uint64_t v16 = 0;
      int v17 = 0;
      while (1)
      {
        BOOL v7 = 0;
        if (*v12) {
          BOOL v7 = *v12 != 41;
        }
        if (!v7) {
          break;
        }
        ++v12;
      }
      if (*v12 == 41) {
        ++v12;
      }
      else {
        unint64_t v12 = v11;
      }
    }
  }
  result = memcpy(*(void **)(v13 + 32), &__src, *(int *)(v13 + 12));
  int v6 = *(_DWORD *)(v13 + 12);
  switch(v6)
  {
    case 2:
      if (*(unsigned char *)(v13 + 96)) {
        char v3 = -2;
      }
      else {
        char v3 = 126;
      }
      *(unsigned char *)(*(void *)(v13 + 32) + 1) |= v3;
      break;
    case 4:
      *(unsigned char *)(*(void *)(v13 + 32) + 2) |= 0xC0u;
      if (*(unsigned char *)(v13 + 96)) {
        char v4 = -1;
      }
      else {
        char v4 = 127;
      }
      *(unsigned char *)(*(void *)(v13 + 32) + 3) = v4;
      break;
    case 8:
      *(unsigned char *)(*(void *)(v13 + 32) + 6) |= 0xF8u;
      if (*(unsigned char *)(v13 + 96)) {
        char v5 = -1;
      }
      else {
        char v5 = 127;
      }
      *(unsigned char *)(*(void *)(v13 + 32) + 7) = v5;
      break;
  }
  if (*(void *)(v13 + 48)) {
    **(void **)(v13 + 48) = v12;
  }
  return result;
}

uint64_t underflow(uint64_t a1)
{
  *__error() = 34;
  unsigned __int8 v6 = 0;
  uint64_t result = fegetround();
  if (result == 0x800000 && (*(unsigned char *)(a1 + 96) & 1) != 0
    || result == 0x400000 && (*(unsigned char *)(a1 + 96) & 1) == 0)
  {
    unsigned __int8 v6 = 1;
  }
  int v5 = *(_DWORD *)(a1 + 12);
  switch(v5)
  {
    case 2:
      if (*(unsigned char *)(a1 + 96)) {
        __int16 v2 = 0x8000;
      }
      else {
        __int16 v2 = 0;
      }
      **(_WORD **)(a1 + 32) = v2 | v6;
      break;
    case 4:
      unsigned int v3 = 0x80000000;
      if ((*(unsigned char *)(a1 + 96) & 1) == 0) {
        unsigned int v3 = 0;
      }
      **(_DWORD **)(a1 + 32) = v3 | v6;
      break;
    case 8:
      unint64_t v4 = 0x8000000000000000;
      if ((*(unsigned char *)(a1 + 96) & 1) == 0) {
        unint64_t v4 = 0;
      }
      **(void **)(a1 + 32) = v4 | v6;
      break;
  }
  return result;
}

void overflow(uint64_t a1)
{
  *__error() = 34;
  int v1 = fegetround();
  if (v1 == 12582912
    || v1 == 0x800000 && (*(unsigned char *)(a1 + 96) & 1) == 0
    || v1 == 0x400000 && (*(unsigned char *)(a1 + 96) & 1) != 0)
  {
    max_value((int *)a1);
  }
  else
  {
    infinity(a1);
  }
}

uint64_t multiplyMPByN(uint64_t result, unsigned int a2)
{
  unint64_t v3 = 0;
  for (unsigned __int8 i = *(_DWORD **)result; (unint64_t)i < *(void *)(result + 8); ++i)
  {
    unint64_t v4 = v3 + *i * (unint64_t)a2;
    *unsigned __int8 i = v4;
    unint64_t v3 = HIDWORD(v4);
  }
  while (v3)
  {
    **(_DWORD **)(result + 8) = v3;
    v3 >>= 32;
    *(void *)(result + 8) += 4;
  }
  return result;
}

uint64_t addToMP(uint64_t result, unint64_t a2)
{
  for (unsigned __int8 i = *(_DWORD **)result; ; ++i)
  {
    BOOL v2 = 0;
    if (a2) {
      BOOL v2 = (unint64_t)i < *(void *)(result + 8);
    }
    if (!v2) {
      break;
    }
    unint64_t v5 = a2 + *i;
    *unsigned __int8 i = v5;
    a2 = HIDWORD(v5);
  }
  while (a2)
  {
    *unsigned __int8 i = a2;
    a2 >>= 32;
    ++i;
  }
  if ((unint64_t)i > *(void *)(result + 8)) {
    *(void *)(result + 8) = i;
  }
  return result;
}

int *max_value(int *result)
{
  int v4 = result[3];
  switch(v4)
  {
    case 2:
      if (result[24]) {
        __int16 v1 = -1025;
      }
      else {
        __int16 v1 = 31743;
      }
      **((_WORD **)result + 4) = v1;
      break;
    case 4:
      int v2 = -8388609;
      if ((result[24] & 1) == 0) {
        int v2 = 2139095039;
      }
      **((_DWORD **)result + 4) = v2;
      break;
    case 8:
      unint64_t v3 = 0xFFEFFFFFFFFFFFFFLL;
      if ((result[24] & 1) == 0) {
        unint64_t v3 = 0x7FEFFFFFFFFFFFFFLL;
      }
      **((void **)result + 4) = v3;
      break;
    default:
      return (int *)memset(*((void **)result + 4), -1, result[3]);
  }
  return result;
}

uint64_t initMPFromDigits(uint64_t result, uint64_t a2)
{
  uint64_t v11 = result;
  unsigned int v10 = *(_DWORD **)result;
  for (unint64_t i = *(void *)(a2 + 64); i; i >>= 32)
    *v10++ = i;
  *(void *)(result + 8) = v10;
  uint64_t v8 = *(unsigned int *)(a2 + 88);
  int v7 = 0;
  if (*(_DWORD *)(a2 + 72) > *(_DWORD *)(a2 + 24))
  {
    LODWORD(v8) = *(_DWORD *)(a2 + 24) - (*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 88));
    int v7 = *(_DWORD *)(a2 + 88) - v8;
  }
  unsigned __int8 v6 = *(unsigned char **)(a2 + 80);
  while ((int)v8 > 0)
  {
    if ((int)v8 <= 9) {
      int v2 = v8;
    }
    else {
      int v2 = 9;
    }
    unint64_t v5 = 0;
    for (int j = 0; j < v2; ++j)
    {
      for (unsigned int k = *v6 - 48; k > 9; unsigned int k = *v6 - 48)
        ++v6;
      unint64_t v5 = 10 * v5 + k;
      ++v6;
    }
    multiplyMPByN(v11, initMPFromDigits_powersOfTen[v2]);
    uint64_t result = addToMP(v11, v5);
    LODWORD(v8) = v8 - v2;
  }
  if (v7 > 0)
  {
    uint64_t result = multiplyMPByN(v11, 0xAu);
    while (v7 > 0)
    {
      if (*v6 == 48)
      {
        --v7;
      }
      else if (*v6 >= 0x31u && *v6 <= 0x39u)
      {
        return addToMP(v11, 1uLL);
      }
      ++v6;
    }
  }
  return result;
}

unsigned int **multiplyByFiveToTheN(unsigned int **result, int a2)
{
  while (a2 > 40)
  {
    unsigned long long v21 = 0u;
    uint64_t v20 = *result;
    while (v20 < result[1])
    {
      unsigned int v2 = v21 - 1413876383 * *v20;
      BOOL v3 = __CFADD__((void)v21, 0xC35CA4BFABB9F561 * *v20);
      *(void *)&long long v4 = v21 - 0x3CA35B4054460A9FLL * *v20;
      *((void *)&v4 + 1) = ((__PAIR128__(493038065, 0xC35CA4BFABB9F561) * *v20) >> 64)
                           + v3
                           + *((void *)&v21 + 1);
      unint64_t v5 = v20++;
      *unint64_t v5 = v2;
      *(void *)&long long v4 = v4 >> 32;
      *((void *)&v4 + 1) >>= 32;
      unsigned long long v21 = v4;
    }
    while (1)
    {
      BOOL v6 = (void)v21 == 0;
      if (*((void *)&v21 + 1)) {
        BOOL v6 = 0;
      }
      if (v6) {
        break;
      }
      int v7 = v20++;
      *int v7 = v21;
      v21 >>= 32;
    }
    result[1] = v20;
    a2 -= 40;
  }
  while (a2 > 0)
  {
    unsigned long long v19 = 0u;
    if (a2 <= 27) {
      int v16 = a2;
    }
    else {
      int v16 = 27;
    }
    long long v18 = powersOfFive[v16];
    int v17 = *result;
    while (v17 < result[1])
    {
      uint64_t v8 = *v17 * (void)v18;
      BOOL v9 = __CFADD__((void)v19, v8);
      uint64_t v10 = v19 + v8;
      char v11 = v9;
      *(void *)&long long v12 = v10;
      *((void *)&v12 + 1) = ((v18 * (unsigned __int128)*v17) >> 64) + ((v11 & 1) != 0) + *((void *)&v19 + 1);
      uint64_t v13 = v17++;
      *uint64_t v13 = v10;
      *(void *)&long long v12 = v12 >> 32;
      *((void *)&v12 + 1) >>= 32;
      unsigned long long v19 = v12;
    }
    while (1)
    {
      BOOL v14 = (void)v19 == 0;
      if (*((void *)&v19 + 1)) {
        BOOL v14 = 0;
      }
      if (v14) {
        break;
      }
      __int16 v15 = v17++;
      *__int16 v15 = v19;
      v19 >>= 32;
    }
    result[1] = v17;
    a2 -= 27;
  }
  return result;
}

uint64_t bitCountMP(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    return 0;
  }
  else
  {
    if (!*(_DWORD *)(a2 - 4)) {
      __assert_rtn("bitCountMP", "strtofp.c", 1056, "work.msw[-1] != 0");
    }
    return (32 - __clz(*(_DWORD *)(a2 - 4)) + 32 * ((a2 - a1) / 4 - 1));
  }
}

uint64_t shiftRightMPWithRounding(uint64_t a1, uint64_t a2, int a3, int a4, char a5, int a6)
{
  *(void *)&long long v21 = a1;
  *((void *)&v21 + 1) = a2;
  int v19 = a4;
  char v18 = a5 & 1;
  if (!a3) {
    return v21;
  }
  if (a3 < 0)
  {
    shiftLeftMP((uint64_t)&v21, -a3);
    return v21;
  }
  long long v22 = v21;
  int v17 = a3 / 32;
  int v16 = a3 % 32;
  if (a3 % 32)
  {
    *(void *)&long long v22 = v22 + 4 * v17;
    unsigned int v13 = *(_DWORD *)v22 & ((1 << v16) - 1);
    long long v12 = (unsigned int *)(v22 + 4);
    unint64_t v10 = (*(_DWORD *)v22 >> v16);
    while ((unint64_t)v12 < *((void *)&v22 + 1))
    {
      unint64_t v11 = v10 | ((unint64_t)*v12 << (32 - v16));
      *(v12 - 1) = v11;
      unint64_t v10 = HIDWORD(v11);
      ++v12;
    }
    if (v10) {
      *(v12 - 1) = v10;
    }
    else {
      *((void *)&v22 + 1) -= 4;
    }
    if (!a6) {
      goto LABEL_49;
    }
    if (a6 != 0x400000)
    {
      if (a6 != 0x800000)
      {
        if (a6 == 12582912) {
          return v22;
        }
LABEL_49:
        unsigned int v8 = 1 << (v16 - 1);
        if (v13 >= v8)
        {
          if (v13 > v8) {
            goto LABEL_59;
          }
          for (unint64_t i = (_DWORD *)v21; (unint64_t)i < (unint64_t)v22; ++i)
            v19 |= *i;
          if (v19 || *((void *)&v22 + 1) > (unint64_t)v22 && (*(_DWORD *)v22 & 1) != 0) {
            goto LABEL_59;
          }
        }
        return v22;
      }
      char v18 = !(a5 & 1);
    }
    int v20 = a4 | v13;
    for (int j = (_DWORD *)v21; (unint64_t)j < (unint64_t)v22; ++j)
      v20 |= *j;
    if ((v18 & 1) == 0 && v20) {
      goto LABEL_59;
    }
    return v22;
  }
  *(void *)&long long v22 = v22 + 4 * v17;
  switch(a6)
  {
    case 0:
      break;
    case 4194304:
LABEL_12:
      for (unsigned int k = (_DWORD *)v21; (unint64_t)k < (unint64_t)v22; ++k)
        v19 |= *k;
      if ((v18 & 1) == 0 && v19) {
        goto LABEL_59;
      }
      return v22;
    case 8388608:
      char v18 = !(a5 & 1);
      goto LABEL_12;
    case 12582912:
      return v22;
  }
  if (*(_DWORD *)(v22 - 4) >= 0x80000000)
  {
    if (*(_DWORD *)(v22 - 4) > 0x80000000) {
      goto LABEL_59;
    }
    for (unsigned int m = (_DWORD *)v21; (unint64_t)m < (uint64_t)v22 - 4; ++m)
      v19 |= *m;
    if (v19 || *((void *)&v22 + 1) > (unint64_t)v22 && (*(_DWORD *)v22 & 1) != 0) {
LABEL_59:
    }
      addToMP((uint64_t)&v22, 1uLL);
  }
  return v22;
}

uint64_t shiftRightMPWithTruncation(uint64_t a1, uint64_t a2, int a3)
{
  return shiftRightMPWithRounding(a1, a2, a3, 0, 0, 12582912);
}

unsigned int **fiveToTheN(uint64_t a1, int a2)
{
  if (a2 <= 27) {
    int v4 = a2;
  }
  else {
    int v4 = 27;
  }
  unint64_t v6 = powersOfFive[v4];
  unint64_t v5 = *(unsigned int **)a1;
  while (v6)
  {
    unsigned int v2 = v5++;
    *unsigned int v2 = v6;
    v6 >>= 32;
  }
  *(void *)(a1 + 8) = v5;
  return multiplyByFiveToTheN((unsigned int **)a1, a2 - v4);
}

void shiftLeftMP(uint64_t a1, int a2)
{
  int v6 = a2 / 32;
  int v5 = a2 % 32;
  if (a2 / 32 > 0)
  {
    memmove((void *)(*(void *)a1 + 4 * v6), *(const void **)a1, 4 * ((*(void *)(a1 + 8) - *(void *)a1) / 4));
    bzero(*(void **)a1, 4 * v6);
    *(void *)(a1 + 8) += 4 * v6;
  }
  if (v5 > 0)
  {
    unint64_t v3 = 0;
    for (unint64_t i = *(_DWORD **)a1; (unint64_t)i < *(void *)(a1 + 8); ++i)
    {
      unint64_t v4 = v3 | ((unint64_t)*i << v5);
      *unint64_t i = v4;
      unint64_t v3 = HIDWORD(v4);
    }
    if (v3)
    {
      *unint64_t i = v3;
      *(void *)(a1 + 8) = i + 1;
    }
  }
}

uint64_t divideMPByMP(unint64_t a1, unint64_t a2, unsigned int *a3, unint64_t a4, _DWORD *a5)
{
  *(void *)&long long v32 = a1;
  *((void *)&v32 + 1) = a2;
  long long v30 = a3;
  unint64_t v31 = a4;
  if (a2 <= a1) {
    __assert_rtn("divideMPByMP", "strtofp.c", 1343, "numerator.msw > numerator.lsw");
  }
  if (v31 <= (unint64_t)v30) {
    __assert_rtn("divideMPByMP", "strtofp.c", 1344, "denominator.msw > denominator.lsw");
  }
  if (!*(_DWORD *)(*((void *)&v32 + 1) - 4)) {
    __assert_rtn("divideMPByMP", "strtofp.c", 1345, "numerator.msw[-1] != 0");
  }
  if (!*(_DWORD *)(v31 - 4)) {
    __assert_rtn("divideMPByMP", "strtofp.c", 1346, "denominator.msw[-1] != 0");
  }
  if ((uint64_t)(v31 - (void)v30) / 4 == 1)
  {
    unint64_t v28 = *v30;
    unint64_t v26 = 0;
    int v25 = (unsigned int *)*((void *)&v32 + 1);
    while ((unint64_t)v25 > (unint64_t)v32)
    {
      unint64_t v27 = (v26 << 32) + *--v25;
      unsigned int v24 = v27 / v28;
      *int v25 = v24;
      unint64_t v26 = v27 - v24 * v28;
    }
    *a5 = v26 != 0;
    while (!*(_DWORD *)(*((void *)&v32 + 1) - 4))
      *((void *)&v32 + 1) -= 4;
    return v32;
  }
  else
  {
    int v23 = __clz(*(_DWORD *)(v31 - 4));
    shiftLeftMP((uint64_t)&v30, v23);
    shiftLeftMP((uint64_t)&v32, v23);
    if (*(_DWORD *)(*((void *)&v32 + 1) - 4) >= *(_DWORD *)(v31 - 4))
    {
      **((_DWORD **)&v32 + 1) = 0;
      *((void *)&v32 + 1) += 4;
    }
    BOOL v8 = 1;
    if (*((void *)&v32 + 1) >= (unint64_t)v30) {
      BOOL v8 = v31 < (unint64_t)v32;
    }
    if (!v8) {
      __assert_rtn("divideMPByMP", "strtofp.c", 1390, "(numerator.msw < denominator.lsw) || (denominator.msw < numerator.lsw)");
    }
    *(void *)&long long v33 = *((void *)&v32 + 1) + 4;
    *((void *)&v33 + 1) = *((void *)&v32 + 1) + 4;
    int v22 = (*((void *)&v32 + 1) - (void)v32) / 4 - (uint64_t)(v31 - (void)v30) / 4;
    for (int i = 0; i < v22; ++i)
    {
      unint64_t v19 = *(unsigned int *)(*((void *)&v32 + 1) - 8)
          + ((unint64_t)*(unsigned int *)(*((void *)&v32 + 1) - 4) << 32);
      if (*(_DWORD *)(*((void *)&v32 + 1) - 4) == *(_DWORD *)(v31 - 4)) {
        unsigned int v20 = -1;
      }
      else {
        unsigned int v20 = v19 / *(unsigned int *)(v31 - 4);
      }
      while (1)
      {
        unint64_t v18 = v19 - v20 * (unint64_t)*(unsigned int *)(v31 - 4);
        if (v18 > 0xFFFFFFFF
          || *(unsigned int *)(v31 - 8) * (unint64_t)v20 <= *(unsigned int *)(*((void *)&v32 + 1) - 12)
                                                                 + (v18 << 32))
        {
          break;
        }
        --v20;
      }
      unint64_t v15 = 0;
      BOOL v14 = v30;
      unsigned int v13 = (_DWORD *)(*((void *)&v32 + 1) + 4 * ((uint64_t)(v31 - (void)v30) / -4) - 4);
      while ((unint64_t)v14 < v31)
      {
        unint64_t v5 = v15 + v20 * (unint64_t)*v14;
        BOOL v6 = *v13 < v5;
        *v13 -= v5;
        unint64_t v15 = HIDWORD(v5) + v6;
        ++v13;
        ++v14;
      }
      if (*(unsigned int *)(*((void *)&v32 + 1) - 4) < v15)
      {
        --v20;
        unint64_t v16 = 0;
        long long v12 = v30;
        unint64_t v11 = (_DWORD *)(*((void *)&v32 + 1) + 4 * ((uint64_t)(v31 - (void)v30) / -4) - 4);
        while ((unint64_t)v12 < v31)
        {
          unint64_t v17 = v16 + *v11 + (unint64_t)*v12;
          *unint64_t v11 = v17;
          unint64_t v16 = HIDWORD(v17);
          ++v11;
          ++v12;
        }
      }
      *(void *)&long long v33 = v33 - 4;
      *(_DWORD *)long long v33 = v20;
      *((void *)&v32 + 1) -= 4;
    }
    int v10 = 0;
    for (int j = (_DWORD *)v32; (unint64_t)j < *((void *)&v32 + 1); ++j)
      v10 |= *j;
    *a5 = v10 != 0;
    while (!*(_DWORD *)(*((void *)&v33 + 1) - 4))
      *((void *)&v33 + 1) -= 4;
  }
  return v33;
}

int lchflags(const char *a1, __uint32_t a2)
{
  BOOL v6 = a1;
  __uint32_t v5 = a2;
  long long v3 = xmmword_D54A8;
  uint64_t v4 = 0;
  return setattrlist(a1, &v3, &v5, 4uLL, 1u);
}

int lchmod(const char *a1, mode_t a2)
{
  BOOL v6 = a1;
  mode_t v5 = a2;
  v4[1] = 0;
  v4[2] = 0;
  v4[0] = 0x2000000000005;
  int v3 = a2;
  return setattrlist(a1, v4, &v3, 4uLL, 1u);
}

int lutimes(const char *a1, const timeval *a2)
{
  unint64_t v11 = a1;
  int v10 = a2;
  memset(&__b, 0, sizeof(__b));
  uint64_t v6 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  unsigned long long v4 = 0u;
  long long v5 = 0u;
  if (lstat(v11, &__b) < 0) {
    return -1;
  }
  if ((__b.st_mode & 0xF000) == 0xA000)
  {
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    uint64_t v6 = 0x140000000005;
    if (v10)
    {
      *(void *)&long long v5 = v10->tv_sec;
      *((void *)&v5 + 1) = 1000 * v10->tv_usec;
      *(void *)&unsigned long long v4 = v10[1].tv_sec;
      *((void *)&v4 + 1) = 1000 * v10[1].tv_usec;
    }
    else
    {
      v3.tv_sec = 0;
      *(void *)&v3.tv_usec = 0;
      if (gettimeofday(&v3, 0) < 0) {
        return -1;
      }
      *(void *)&long long v5 = v3.tv_sec;
      *((void *)&v5 + 1) = 1000 * v3.tv_usec;
      unsigned long long v4 = __PAIR128__(*((unint64_t *)&v5 + 1), v3.tv_sec);
    }
    return setattrlist(v11, &v6, &v4, 0x20uLL, 1u);
  }
  return utimes(v11, v10);
}

int fstatvfs(int a1, statvfs *a2)
{
  bzero(&v6, 0x200uLL);
  int v3 = fstatfs(a1, &v6);
  if (!v3) {
    cvt_statfs_to_statvfs(&v6.f_bsize, (uint64_t)a2);
  }
  return v3;
}

unsigned int *cvt_statfs_to_statvfs(unsigned int *result, uint64_t a2)
{
  *(void *)a2 = (int)result[1];
  *(void *)(a2 + 8) = *result;
  *(_DWORD *)(a2 + 16) = *((void *)result + 1);
  *(_DWORD *)(a2 + 20) = *((void *)result + 2);
  *(_DWORD *)(a2 + 24) = *((void *)result + 3);
  *(_DWORD *)(a2 + 28) = *((void *)result + 4);
  *(_DWORD *)(a2 + 32) = *((void *)result + 5);
  *(_DWORD *)(a2 + 36) = *((void *)result + 5);
  *(void *)(a2 + 40) = (int)result[12];
  *(void *)(a2 + 56) = 255;
  *(void *)(a2 + 48) = 0;
  if (result[16]) {
    *(void *)(a2 + 48) |= 1uLL;
  }
  if ((result[16] & 8) != 0) {
    *(void *)(a2 + 48) |= 2uLL;
  }
  return result;
}

int statvfs(const char *a1, statvfs *a2)
{
  bzero(&v6, 0x200uLL);
  int v3 = statfs(a1, &v6);
  if (!v3) {
    cvt_statfs_to_statvfs(&v6.f_bsize, (uint64_t)a2);
  }
  return v3;
}

uint64_t (*backtrace_set_pcs_func(uint64_t (*result)(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5)))(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5)
{
  if (result) {
    __int16 v1 = result;
  }
  else {
    __int16 v1 = _thread_stack_pcs;
  }
  backtrace_get_pcs_func = (uint64_t (*)(void, void, void, void, void))v1;
  return result;
}

int backtrace(void **a1, int a2)
{
  long long v5 = a1;
  v4[1] = a2;
  v4[0] = 0;
  backtrace_get_pcs_func(a1, a2, v4, 1, 0);
  while (1)
  {
    BOOL v3 = 0;
    if (v4[0]) {
      BOOL v3 = v5[v4[0] - 1] == 0;
    }
    if (!v3) {
      break;
    }
    --v4[0];
  }
  return v4[0];
}

uint64_t backtrace_async(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  uint64_t v7 = a3;
  unsigned int v6 = 0;
  int v5 = _thread_stack_async_pcs(a1, a2, &v6, 1, 0);
  while (1)
  {
    BOOL v4 = 0;
    if (v6) {
      BOOL v4 = *(void *)(v9 + 8 * (v6 - 1)) == 0;
    }
    if (!v4) {
      break;
    }
    --v6;
  }
  if (v7) {
    *uint64_t v7 = v5;
  }
  return v6;
}

int backtrace_from_fp(void *startfp, void **array, int size)
{
  uint64_t v7 = startfp;
  unsigned int v6 = array;
  v5[1] = size;
  v5[0] = 0;
  _thread_stack_pcs((uint64_t)array, size, v5, 1, (unint64_t)startfp);
  while (1)
  {
    BOOL v4 = 0;
    if (v5[0]) {
      BOOL v4 = v6[v5[0] - 1] == 0;
    }
    if (!v4) {
      break;
    }
    --v5[0];
  }
  return v5[0];
}

void backtrace_image_offsets(void *const *array, image_offset *image_offsets, int size)
{
  unint64_t v11 = array;
  int v10 = image_offsets;
  int v9 = size;
  uint64_t v8 = &v3;
  int v5 = (char *)&v3 - ((32 * size + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = size;
  _dyld_images_for_addresses();
  for (int i = 0; i < v9; ++i)
  {
    uint64_t v4 = 20;
    uuid_copy(v10[i].uuid, (const unsigned __int8 *)&v5[32 * i]);
    *(_DWORD *)&v10->uuid[i * v4 + 16] = *(void *)&v5[32 * i + 16];
  }
}

uint64_t __confstr_init(uint64_t result)
{
  __dirhelper_func = *(_UNKNOWN **)(result + 32);
  return result;
}

uint64_t __dirhelper(unsigned int a1, uint64_t a2, uint64_t a3)
{
  if (__dirhelper_func) {
    return __dirhelper_func(a1, a2, a3);
  }
  else {
    return 0;
  }
}

size_t confstr(int a1, char *a2, size_t a3)
{
  int v24 = a1;
  int v23 = a2;
  size_t v22 = a3;
  size_t v21 = 0;
  int v20 = 0;
  unint64_t v19 = 0;
  int v17 = a1;
  if (a1 != 1)
  {
    if ((v17 - 2) <= 2) {
      goto LABEL_58;
    }
    if (v17 != 6 && v17 != 5)
    {
      if (v17 == 7) {
        goto LABEL_58;
      }
      if (v17 == 9 || v17 == 8) {
        goto LABEL_60;
      }
      if (v17 == 10) {
        goto LABEL_58;
      }
      if (v17 == 12 || v17 == 11) {
        goto LABEL_60;
      }
      if (v17 == 13) {
        goto LABEL_58;
      }
      if (v17 == 14)
      {
        unint64_t v19 = "_POSIX_V6_LP64_OFF64";
        goto LABEL_62;
      }
      if ((v17 - 20) <= 3)
      {
LABEL_58:
        unint64_t v19 = (char *)&unk_D793D;
        goto LABEL_62;
      }
      if (v17 != 25 && v17 != 24)
      {
        if (v17 == 27 || v17 == 26) {
          goto LABEL_58;
        }
        if (v17 != 29 && v17 != 28)
        {
          if (v17 == 31 || v17 == 30) {
            goto LABEL_58;
          }
          if (v17 != 33 && v17 != 32)
          {
            if (v17 != 35 && v17 != 34)
            {
              if (v17 != 0x10000)
              {
                if (v17 == 65537)
                {
                  unint64_t v15 = v13;
                  bzero(v13, 0x400uLL);
                  unint64_t v19 = v15;
                  if (!v15) {
                    goto LABEL_84;
                  }
                  if (!__dirhelper(1u, (uint64_t)v19, 1024))
                  {
                    int v18 = 0;
                    int v18 = *__error();
                    unint64_t v19 = getenv("TMPDIR");
                    if (!v19 || access(v19, 2))
                    {
                      unint64_t v19 = "/var/tmp/";
                      if (access("/var/tmp/", 2))
                      {
                        if (v18 == 12) {
                          *__error() = 12;
                        }
                        else {
                          *__error() = 5;
                        }
                        return 0;
                      }
                    }
                  }
                }
                else
                {
                  if (v17 != 65538)
                  {
                    *__error() = 22;
                    return 0;
                  }
                  BOOL v14 = v13;
                  bzero(v13, 0x400uLL);
                  unint64_t v19 = v14;
                  if (!v14)
                  {
LABEL_84:
                    *__error() = 12;
                    return 0;
                  }
                  if (!__dirhelper(2u, (uint64_t)v19, 1024))
                  {
                    if (*__error() != 12) {
                      *__error() = 5;
                    }
                    return 0;
                  }
                }
                goto LABEL_62;
              }
              unint64_t v16 = v13;
              bzero(v13, 0x400uLL);
              unint64_t v19 = v16;
              if (!v16) {
                goto LABEL_84;
              }
              if (!__dirhelper(0, (uint64_t)v19, 1024))
              {
                if (*__error() != 12) {
                  *__error() = 5;
                }
                return 0;
              }
LABEL_62:
              if (v22 && v23) {
                strlcpy(v23, v19, v22);
              }
              return strlen(v19) + 1;
            }
            goto LABEL_58;
          }
        }
LABEL_60:
        unint64_t v19 = "-W 64";
        goto LABEL_62;
      }
    }
    unint64_t v19 = "-W 32";
    goto LABEL_62;
  }
  v26[0] = 8;
  v26[1] = 1;
  if (sysctl(v26, 2u, 0, &v21, 0, 0) != -1)
  {
    if (v22 && v23)
    {
      unint64_t v19 = (char *)malloc_type_malloc();
      if (!v19) {
        return 0;
      }
      if (sysctl(v26, 2u, v19, &v21, 0, 0) == -1)
      {
        int v20 = *__error();
        free(v19);
        *__error() = v20;
        return 0;
      }
      strncpy(v23, v19, v22 - 1);
      v23[v22 - 1] = 0;
      free(v19);
    }
    return v21;
  }
  return 0;
}

char *__cdecl devname_r(dev_t a1, mode_t a2, char *buf, int len)
{
  dev_t v11 = a1;
  mode_t v10 = a2;
  int v9 = buf;
  int v8 = len;
  uint64_t v7 = 0;
  unsigned int v6 = 0;
  memset(&__b, 0, sizeof(__b));
  strcpy(__dst, "/dev/");
  uint64_t v7 = opendir("/dev/");
  if (!v7) {
    return 0;
  }
  while (1)
  {
    unsigned int v6 = readdir(v7);
    if (!v6) {
      break;
    }
    bcopy(v6->d_name, &__dst[5], v6->d_namlen + 1);
    if (!lstat(__dst, &__b) && v11 == __b.st_rdev && v10 == (__b.st_mode & 0xF000))
    {
      if (v6->d_namlen + 1 <= v8)
      {
        strcpy(v9, v6->d_name);
        closedir(v7);
        return v9;
      }
      break;
    }
  }
  closedir(v7);
  return 0;
}

char *__cdecl devname(dev_t a1, mode_t a2)
{
  if (devname_buf) {
    return devname_r(a1, a2, (char *)devname_buf, 255);
  }
  devname_buf = malloc_type_malloc();
  if (devname_buf) {
    return devname_r(a1, a2, (char *)devname_buf, 255);
  }
  else {
    return 0;
  }
}

uint64_t getdiskbyname(const char *a1)
{
  int v48 = a1;
  long long v47 = 0;
  long long v46 = 0;
  *(_OWORD *)v50 = off_DC020;
  int i = 0;
  int v44 = 0;
  char v43 = 0;
  char v42 = 0;
  int v36 = 0;
  if (cgetent(&v46, v50, a1) < 0) {
    return 0;
  }
  if (!getdiskbyname_dp)
  {
    getdiskbyname_dp = malloc_type_malloc();
    if (!getdiskbyname_dp) {
      return 0;
    }
  }
  bzero((void *)getdiskbyname_dp, 0x118uLL);
  int v44 = (char *)(getdiskbyname_dp + 8);
  for (int i = v46; ; ++i)
  {
    BOOL v19 = 0;
    if ((unint64_t)v44 < getdiskbyname_dp + 23)
    {
      int v1 = *i;
      *int v44 = v1;
      BOOL v19 = 0;
      if (v1)
      {
        BOOL v19 = 0;
        if (*v44 != 124) {
          BOOL v19 = *v44 != 58;
        }
      }
    }
    if (!v19) {
      break;
    }
    ++v44;
  }
  *int v44 = 0;
  cgetstr(v46, "b0", (char **)(getdiskbyname_dp + 24));
  cgetstr(v46, "b1", (char **)(getdiskbyname_dp + 32));
  if (cgetstr(v46, "ty", &v44) > 0 && !strcmp(v44, "removable"))
  {
    *(_DWORD *)(getdiskbyname_dp + 88) |= 1u;
  }
  else if (v44 && !strcmp(v44, "simulated"))
  {
    *(_DWORD *)(getdiskbyname_dp + 88) |= 8u;
  }
  if (cgetcap(v46, "sf", 58)) {
    *(_DWORD *)(getdiskbyname_dp + 88) |= 4u;
  }
  uint64_t v35 = 0;
  if (cgetnum(v46, "se", &v35) == -1) {
    int v18 = 512;
  }
  else {
    int v18 = v35;
  }
  *(_DWORD *)(getdiskbyname_dp + 40) = v18;
  cgetnum(v46, "nt", (uint64_t *)(getdiskbyname_dp + 48));
  cgetnum(v46, "ns", (uint64_t *)(getdiskbyname_dp + 44));
  cgetnum(v46, "nc", (uint64_t *)(getdiskbyname_dp + 52));
  if (cgetstr(v46, "dt", &v44) <= 0)
  {
    uint64_t v34 = 0;
    if (cgetnum(v46, "dt", &v34) == -1) {
      __int16 v17 = 0;
    }
    else {
      __int16 v17 = v34;
    }
    *(_WORD *)(getdiskbyname_dp + 4) = v17;
  }
  else
  {
    *(_WORD *)(getdiskbyname_dp + 4) = gettype(v44, (const char **)dktypenames);
  }
  uint64_t v33 = 0;
  if (cgetnum(v46, "sc", &v33) == -1) {
    int v16 = *(_DWORD *)(getdiskbyname_dp + 44) * *(_DWORD *)(getdiskbyname_dp + 48);
  }
  else {
    int v16 = v33;
  }
  *(_DWORD *)(getdiskbyname_dp + 56) = v16;
  uint64_t v32 = 0;
  if (cgetnum(v46, "su", &v32) == -1) {
    int v15 = *(_DWORD *)(getdiskbyname_dp + 56) * *(_DWORD *)(getdiskbyname_dp + 52);
  }
  else {
    int v15 = v32;
  }
  *(_DWORD *)(getdiskbyname_dp + 60) = v15;
  uint64_t v31 = 0;
  if (cgetnum(v46, "rm", &v31) == -1) {
    __int16 v14 = 3600;
  }
  else {
    __int16 v14 = v31;
  }
  *(_WORD *)(getdiskbyname_dp + 72) = v14;
  uint64_t v30 = 0;
  if (cgetnum(v46, "il", &v30) == -1) {
    __int16 v13 = 1;
  }
  else {
    __int16 v13 = v30;
  }
  *(_WORD *)(getdiskbyname_dp + 74) = v13;
  uint64_t v29 = 0;
  if (cgetnum(v46, "sk", &v29) == -1) {
    __int16 v12 = 0;
  }
  else {
    __int16 v12 = v29;
  }
  *(_WORD *)(getdiskbyname_dp + 76) = v12;
  uint64_t v28 = 0;
  if (cgetnum(v46, "cs", &v28) == -1) {
    __int16 v11 = 0;
  }
  else {
    __int16 v11 = v28;
  }
  *(_WORD *)(getdiskbyname_dp + 78) = v11;
  uint64_t v27 = 0;
  if (cgetnum(v46, "hs", &v27) == -1) {
    int v10 = 0;
  }
  else {
    int v10 = v27;
  }
  *(_DWORD *)(getdiskbyname_dp + 80) = v10;
  uint64_t v26 = 0;
  if (cgetnum(v46, "ts", &v26) == -1) {
    int v9 = 0;
  }
  else {
    int v9 = v26;
  }
  *(_DWORD *)(getdiskbyname_dp + 84) = v9;
  uint64_t v25 = 0;
  if (cgetnum(v46, "bs", &v25) == -1) {
    int v8 = 0x2000;
  }
  else {
    int v8 = v25;
  }
  *(_DWORD *)(getdiskbyname_dp + 140) = v8;
  uint64_t v24 = 0;
  if (cgetnum(v46, "sb", &v24) == -1) {
    int v7 = 0x2000;
  }
  else {
    int v7 = v24;
  }
  *(_DWORD *)(getdiskbyname_dp + 144) = v7;
  strcpy(__dst, "px");
  strcpy(v40, "bx");
  strcpy(v39, "fx");
  strcpy(v38, "ox");
  strcpy(v37, "tx");
  char v42 = 96;
  long long v47 = (uint64_t *)(getdiskbyname_dp + 148);
  char v43 = 97;
  while (v43 < 105)
  {
    v37[1] = v43;
    v38[1] = v43;
    v39[1] = v43;
    v40[1] = v43;
    __dst[1] = v43;
    if (cgetnum(v46, __dst, v47) == -1)
    {
      *(_DWORD *)long long v47 = 0;
    }
    else
    {
      cgetnum(v46, v38, (uint64_t *)((char *)v47 + 4));
      uint64_t v23 = 0;
      if (cgetnum(v46, v39, &v23) == -1) {
        int v6 = 0;
      }
      else {
        int v6 = v23;
      }
      *((_DWORD *)v47 + 2) = v6;
      if (*((_DWORD *)v47 + 2))
      {
        uint64_t v22 = 0;
        if (cgetnum(v46, v40, &v22)) {
          *((unsigned char *)v47 + 13) = 8;
        }
        else {
          *((unsigned char *)v47 + 13) = v22 / *((unsigned int *)v47 + 2);
        }
      }
      uint64_t v21 = 0;
      if (cgetnum(v46, v37, &v21) == -1) {
        char v5 = 0;
      }
      else {
        char v5 = v21;
      }
      *((unsigned char *)v47 + 12) = v5;
      if (!*((unsigned char *)v47 + 12) && cgetstr(v46, v37, &v44) > 0)
      {
        char v2 = gettype(v44, (const char **)fstypenames);
        *((unsigned char *)v47 + 12) = v2;
      }
      char v42 = v43;
    }
    ++v43;
    v47 += 2;
  }
  *(_WORD *)(getdiskbyname_dp + 138) = v42 - 96;
  strcpy(__dst, "dx");
  int v36 = (_DWORD *)(getdiskbyname_dp + 92);
  char v43 = 48;
  while (v43 < 53)
  {
    __dst[1] = v43;
    uint64_t v20 = 0;
    if (cgetnum(v46, __dst, &v20) == -1) {
      int v4 = 0;
    }
    else {
      int v4 = v20;
    }
    *int v36 = v4;
    ++v43;
    ++v36;
  }
  *(_DWORD *)getdiskbyname_dp = -2108275369;
  *(_DWORD *)(getdiskbyname_dp + 132) = -2108275369;
  free(v46);
  return getdiskbyname_dp;
}

uint64_t gettype(const char *a1, const char **a2)
{
  for (int i = a2; *i; ++i)
  {
    if (!strcasecmp(a1, *i)) {
      return (i - a2);
    }
  }
  if (isdigit(*a1)) {
    return atoi(a1);
  }
  else {
    return 0;
  }
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  int v6 = a2;
  if ((a2 & 0xFFFFF300) != 0)
  {
    *__error() = 22;
    return 0;
  }
  else
  {
    if ((a2 & 0x800) != 0) {
      int v6 = a2 | 8;
    }
    uint64_t v4 = malloc_type_calloc();
    if (v4)
    {
      *(void *)(v4 + 56) = a3;
      *(_DWORD *)(v4 + 64) = v6;
      return (FTS *)__fts_open((const char **)a1, v4);
    }
    else
    {
      return 0;
    }
  }
}

uint64_t __fts_open(const char **a1, uint64_t a2)
{
  int v15 = a1;
  uint64_t v9 = 0;
  if ((*(_DWORD *)(a2 + 64) & 2) != 0) {
    *(_DWORD *)(a2 + 64) |= 4u;
  }
  if (fts_maxarglen(a1) <= 0x400)
  {
    int v2 = fts_palloc(a2, 1024);
  }
  else
  {
    int v7 = fts_maxarglen(v15);
    int v2 = fts_palloc(a2, v7);
  }
  if (v2) {
    goto LABEL_38;
  }
  uint64_t v10 = fts_alloc(a2, &unk_D793D, 0);
  if (!v10)
  {
LABEL_37:
    free(*(void **)(a2 + 32));
LABEL_38:
    free((void *)a2);
    return 0;
  }
  *(_WORD *)(v10 + 86) = -1;
  uint64_t v12 = 0;
  int v11 = 0;
  while (*v15)
  {
    size_t v8 = strlen(*v15);
    uint64_t v13 = fts_alloc(a2, *v15, v8);
    if (!v13) {
      goto LABEL_36;
    }
    *(_WORD *)(v13 + 86) = 0;
    *(void *)(v13 + 8) = v10;
    *(void *)(v13 + 40) = v13 + 104;
    if ((*(_DWORD *)(a2 + 64) & 0x400) != 0) {
      __int16 v3 = fts_stat(a2, v13, -1, -1);
    }
    else {
      __int16 v3 = fts_stat(a2, v13, *(_DWORD *)(a2 + 64) & 1, -1);
    }
    *(_WORD *)(v13 + 88) = v3;
    if (*(_WORD *)(v13 + 88) == 5) {
      *(_WORD *)(v13 + 88) = 1;
    }
    if (*(void *)(a2 + 56))
    {
      *(void *)(v13 + 16) = v12;
      uint64_t v12 = v13;
    }
    else
    {
      *(void *)(v13 + 16) = 0;
      if (v12) {
        *(void *)(v9 + 16) = v13;
      }
      else {
        uint64_t v12 = v13;
      }
      uint64_t v9 = v13;
    }
    ++v15;
    ++v11;
  }
  if (*(void *)(a2 + 56) && v11 > 1) {
    uint64_t v12 = fts_sort(a2, v12, v11);
  }
  uint64_t v4 = fts_alloc(a2, &unk_D793D, 0);
  *(void *)a2 = v4;
  if (!v4)
  {
LABEL_36:
    fts_lfree(v12);
    fts_free((int *)v10);
    goto LABEL_37;
  }
  *(void *)(*(void *)a2 + 16) = v12;
  *(_WORD *)(*(void *)a2 + 88) = 9;
  if ((*(_DWORD *)(a2 + 64) & 4) == 0)
  {
    int v5 = open_NOCANCEL();
    *(_DWORD *)(a2 + 40) = v5;
    if (v5 < 0) {
      *(_DWORD *)(a2 + 64) |= 4u;
    }
  }
  if ((*(_DWORD *)(a2 + 64) & 4) == 0 && getenv("FTS_USE_THREAD_FCHDIR")) {
    *(_DWORD *)(a2 + 64) |= 0x400u;
  }
  if (!v11) {
    fts_free((int *)v10);
  }
  return a2;
}

FTS *__cdecl fts_open_b(char *const *a1, int a2, void *a3)
{
  int v6 = a2;
  if ((a2 & 0xFFFFF300) != 0)
  {
    *__error() = 22;
    return 0;
  }
  else
  {
    if ((a2 & 0x800) != 0) {
      int v6 = a2 | 8;
    }
    uint64_t v4 = malloc_type_calloc();
    if (v4)
    {
      *(void *)(v4 + 56) = _Block_copy(a3);
      *(_DWORD *)(v4 + 64) = v6 | 0x80000000;
      return (FTS *)__fts_open((const char **)a1, v4);
    }
    else
    {
      return 0;
    }
  }
}

int fts_close(FTS *a1)
{
  int v5 = 0;
  if (a1->fts_cur)
  {
    fts_cur = a1->fts_cur;
    while (fts_cur->fts_level >= 0)
    {
      int v7 = (int *)fts_cur;
      if (fts_cur->fts_link) {
        fts_linunsigned int k = fts_cur->fts_link;
      }
      else {
        fts_linunsigned int k = fts_cur->fts_parent;
      }
      fts_cur = fts_link;
      fts_free(v7);
    }
    fts_free((int *)fts_cur);
  }
  if ((a1->fts_options & 4) != 0) {
    int fts_rfd = -1;
  }
  else {
    int fts_rfd = a1->fts_rfd;
  }
  if (a1->fts_child) {
    fts_lfree((uint64_t)a1->fts_child);
  }
  free(a1->fts_array);
  a1->fts_array = 0;
  free(a1->fts_path);
  a1->fts_path = 0;
  if (a1->fts_options < 0 && a1->fts_compar) {
    _Block_release(a1->fts_compar);
  }
  if (fts_rfd != -1)
  {
    int v4 = *__error();
    if (fts_fchdir((uint64_t)a1, fts_rfd))
    {
      int v5 = -1;
      int v4 = *__error();
    }
    if (close_NOCANCEL())
    {
      int v5 = -1;
      int v4 = *__error();
    }
    *__error() = v4;
  }
  free(a1);
  return v5;
}

void fts_free(int *a1)
{
  if (a1[15] >= 0)
  {
    int v1 = *__error();
    close_NOCANCEL();
    *__error() = v1;
  }
  free(a1);
}

void fts_lfree(uint64_t a1)
{
  while (1)
  {
    int v1 = (int *)a1;
    if (!a1) {
      break;
    }
    a1 = *(void *)(a1 + 16);
    fts_free(v1);
  }
}

uint64_t fts_fchdir(uint64_t a1, int a2)
{
  if ((*(_DWORD *)(a1 + 64) & 0x400) != 0) {
    return pthread_fchdir_np();
  }
  else {
    return fchdir(a2);
  }
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  if (!a1->fts_cur || (a1->fts_options & 0x200) != 0) {
    return 0;
  }
  fts_cur = a1->fts_cur;
  int fts_instr = a1->fts_cur->fts_instr;
  a1->fts_cur->int fts_instr = 3;
  if (fts_instr == 1)
  {
    fts_cur->fts_mach_timebase_info info = fts_stat((uint64_t)a1, (uint64_t)fts_cur, 0, -1);
    return fts_cur;
  }
  if (fts_instr == 2 && (fts_cur->fts_info == 12 || fts_cur->fts_info == 13))
  {
    fts_cur->fts_mach_timebase_info info = fts_stat((uint64_t)a1, (uint64_t)fts_cur, 1, -1);
    if (fts_cur->fts_info == 1 && (a1->fts_options & 4) == 0)
    {
      int v1 = open_NOCANCEL();
      fts_cur->fts_symfd = v1;
      if (v1 >= 0)
      {
        fts_cur->fts_flags |= 2u;
      }
      else
      {
        fts_cur->fts_errno = *__error();
        fts_cur->fts_mach_timebase_info info = 7;
      }
    }
    return fts_cur;
  }
  else if (fts_cur->fts_info == 1)
  {
    if (fts_instr == 4 || (a1->fts_options & 0x40) != 0 && fts_cur->fts_dev != a1->fts_dev)
    {
      if ((fts_cur->fts_flags & 2) != 0)
      {
        close_NOCANCEL();
        fts_cur->fts_symfd = -1;
      }
      if (a1->fts_child)
      {
        fts_lfree((uint64_t)a1->fts_child);
        a1->fts_child = 0;
      }
      fts_cur->fts_mach_timebase_info info = 6;
      return fts_cur;
    }
    else
    {
      if (a1->fts_child && (a1->fts_options & 0x100) != 0)
      {
        a1->fts_options &= ~0x100u;
        fts_lfree((uint64_t)a1->fts_child);
        a1->fts_child = 0;
      }
      if (a1->fts_child)
      {
        if (fts_safe_changedir((uint64_t)a1, (uint64_t)fts_cur, -1, fts_cur->fts_accpath))
        {
          fts_cur->fts_errno = *__error();
          fts_cur->fts_flags |= 1u;
          for (int i = a1->fts_child; i; int i = i->fts_link)
            i->fts_accpath = i->fts_parent->fts_accpath;
        }
      }
      else
      {
        int v2 = fts_build((uint64_t)a1, 3);
        a1->fts_child = (_ftsent *)v2;
        if (!v2)
        {
          if ((a1->fts_options & 0x200) != 0) {
            return 0;
          }
          else {
            return fts_cur;
          }
        }
      }
      fts_cur = a1->fts_child;
      a1->fts_child = 0;
LABEL_52:
      if (!fts_cur->fts_parent->fts_level
        && fts_cur->fts_parent->fts_pathlen == 1
        && *fts_cur->fts_parent->fts_path == 47)
      {
        fts_pathleunsigned __int8 n = 0;
      }
      else
      {
        fts_pathleunsigned __int8 n = fts_cur->fts_parent->fts_pathlen;
      }
      int v4 = &a1->fts_path[fts_pathlen];
      *int v4 = 47;
      memmove(v4 + 1, fts_cur->fts_name, fts_cur->fts_namelen + 1);
      a1->fts_cur = fts_cur;
      return fts_cur;
    }
  }
  else
  {
    while (1)
    {
      uint64_t v10 = fts_cur;
      fts_cur = fts_cur->fts_link;
      if (!fts_cur) {
        break;
      }
      fts_free((int *)v10);
      if (!fts_cur->fts_level)
      {
        a1->fts_cur = fts_cur;
        if ((a1->fts_options & 4) != 0 || !fts_fchdir((uint64_t)a1, a1->fts_rfd))
        {
          fts_load((uint64_t)a1, (uint64_t)fts_cur);
          return a1->fts_cur;
        }
        else
        {
          a1->fts_options |= 0x200u;
          return 0;
        }
      }
      if (fts_cur->fts_instr != 4)
      {
        if (fts_cur->fts_instr == 2)
        {
          fts_cur->fts_mach_timebase_info info = fts_stat((uint64_t)a1, (uint64_t)fts_cur, 1, -1);
          if (fts_cur->fts_info == 1 && (a1->fts_options & 4) == 0)
          {
            int v3 = open_NOCANCEL();
            fts_cur->fts_symfd = v3;
            if (v3 >= 0)
            {
              fts_cur->fts_flags |= 2u;
            }
            else
            {
              fts_cur->fts_errno = *__error();
              fts_cur->fts_mach_timebase_info info = 7;
            }
          }
          fts_cur->int fts_instr = 3;
        }
        goto LABEL_52;
      }
    }
    fts_parent = v10->fts_parent;
    fts_free((int *)v10);
    if (fts_parent->fts_level == -1)
    {
      fts_free((int *)fts_parent);
      *__error() = 0;
      a1->fts_cur = 0;
      return 0;
    }
    a1->fts_path[fts_parent->fts_pathlen] = 0;
    if (fts_parent->fts_level)
    {
      if ((fts_parent->fts_flags & 2) != 0)
      {
        if ((a1->fts_options & 4) == 0 && fts_fchdir((uint64_t)a1, fts_parent->fts_symfd))
        {
          int v8 = *__error();
          close_NOCANCEL();
          fts_parent->fts_symfd = -1;
          *__error() = v8;
          a1->fts_options |= 0x200u;
          a1->fts_cur = fts_parent;
          return 0;
        }
        close_NOCANCEL();
        fts_parent->fts_symfd = -1;
      }
      else if ((fts_parent->fts_flags & 1) == 0 {
             && fts_safe_changedir((uint64_t)a1, (uint64_t)fts_parent, -1, ".."))
      }
      {
        a1->fts_options |= 0x200u;
        a1->fts_cur = fts_parent;
        return 0;
      }
    }
    else if ((a1->fts_options & 4) == 0 && fts_fchdir((uint64_t)a1, a1->fts_rfd))
    {
      a1->fts_options |= 0x200u;
      a1->fts_cur = fts_parent;
      return 0;
    }
    if (fts_parent->fts_errno) {
      __int16 v5 = 7;
    }
    else {
      __int16 v5 = 6;
    }
    fts_parent->fts_mach_timebase_info info = v5;
    a1->fts_cur = fts_parent;
    return fts_parent;
  }
}

uint64_t fts_stat(uint64_t a1, uint64_t a2, int a3, int a4)
{
  return (unsigned __int16)fts_stat2(a1, a2, a3, a4, 0);
}

uint64_t fts_safe_changedir(uint64_t a1, uint64_t a2, int a3, const char *a4)
{
  uint64_t v16 = a1;
  uint64_t v15 = a2;
  int v14 = a3;
  uint64_t v13 = a4;
  unsigned int v12 = 0;
  int v11 = 0;
  memset(&__b, 0, sizeof(__b));
  int v10 = v14;
  if ((*(_DWORD *)(v16 + 64) & 4) != 0) {
    return 0;
  }
  if (v14 < 0)
  {
    int v10 = open_NOCANCEL();
    if (v10 < 0) {
      return -1;
    }
  }
  if (!fstat(v10, &__b))
  {
    if (v14 == -1)
    {
      if (!strcmp(v13, "..") && (*(_WORD *)(v15 + 90) & 8) != 0)
      {
        close_NOCANCEL();
        int v10 = *(_DWORD *)(v15 + 60);
        *(_DWORD *)(v15 + 60) = -1;
        *(_WORD *)(v15 + 90) &= ~8u;
      }
    }
    else
    {
      memset(&v8, 0, sizeof(v8));
      int v7 = open_NOCANCEL();
      if (v7 < 0)
      {
        unsigned int v12 = -1;
        goto LABEL_20;
      }
      if (fstat(v7, &v8))
      {
        int v11 = *__error();
        close_NOCANCEL();
        int v6 = v11;
        *__error() = v6;
        unsigned int v12 = -1;
        goto LABEL_20;
      }
      if (__b.st_dev == v8.st_dev)
      {
        close_NOCANCEL();
      }
      else
      {
        *(_DWORD *)(v15 + 60) = v7;
        *(_WORD *)(v15 + 90) |= 8u;
      }
    }
    unsigned int v12 = fts_fchdir(v16, v10);
    goto LABEL_20;
  }
  unsigned int v12 = -1;
LABEL_20:
  int v11 = *__error();
  if (v14 < 0) {
    close_NOCANCEL();
  }
  int v5 = v11;
  *__error() = v5;
  return v12;
}

int *fts_build(uint64_t a1, int a2)
{
  uint64_t v38 = a1;
  int v37 = a2;
  memset(__b, 0, 0xA8uLL);
  uint64_t v35 = __b;
  uint64_t v34 = 0;
  uint64_t v33 = 0;
  int v32 = 0;
  uint64_t v31 = 0;
  uint64_t v30 = 0;
  memset(v29, 0, sizeof(v29));
  __dst = 0;
  uint64_t v31 = *(void *)v38;
  if (!open_directory(v38, v29, *(const char **)(v31 + 40)))
  {
    if (v37 == 3)
    {
      *(_WORD *)(v31 + 88) = 4;
      *(_DWORD *)(v31 + 56) = *__error();
    }
    return 0;
  }
  if (v37 == 2)
  {
    int v22 = 0;
  }
  else if ((*(_DWORD *)(v38 + 64) & 0x800) != 0)
  {
    if ((*(_DWORD *)(v38 + 64) & 0x10) != 0) {
      int v2 = 64;
    }
    else {
      int v2 = 80;
    }
    int v22 = v2;
  }
  else if ((*(_DWORD *)(v38 + 64) & 8) != 0)
  {
    if ((*(_DWORD *)(v38 + 64) & 0x10) != 0) {
      int v3 = 48;
    }
    else {
      int v3 = 16;
    }
    int v22 = v3;
  }
  else
  {
    int v22 = 32;
  }
  int v25 = 0;
  if (v22 || v37 == 3)
  {
    uint64_t v18 = v38;
    uint64_t v17 = v31;
    int v4 = dir_fd((uint64_t)v29);
    if (fts_safe_changedir(v18, v17, v4, 0))
    {
      if (v22 && v37 == 3) {
        *(_DWORD *)(v31 + 56) = *__error();
      }
      *(_WORD *)(v31 + 90) |= 1u;
      int v24 = 0;
      int v25 = *__error();
      close_directory((uint64_t)v29);
    }
    else
    {
      int v24 = 1;
    }
  }
  else
  {
    int v24 = 0;
  }
  if (!*(_WORD *)(v31 + 86) && *(_WORD *)(v31 + 64) == 1 && **(unsigned char **)(v31 + 48) == 47) {
    int v16 = 0;
  }
  else {
    int v16 = *(unsigned __int16 *)(v31 + 64);
  }
  if ((*(_DWORD *)(v38 + 64) & 4) != 0)
  {
    int v5 = (unsigned char *)(*(void *)(v38 + 32) + v16);
    __dst = v5 + 1;
    *int v5 = 47;
  }
  int v27 = v16 + 1;
  int v26 = *(_DWORD *)(v38 + 44) - (v16 + 1);
  __int16 v23 = *(_WORD *)(v31 + 86) + 1;
  int v21 = 0;
  uint64_t v30 = 0;
  uint64_t v33 = 0;
  int v32 = 0;
  while ((read_dirent((uint64_t)v29, (uint64_t)v35) & 1) != 0)
  {
    if ((*(_DWORD *)(v38 + 64) & 0x20) != 0
      || **(unsigned char **)v35 != 46
      || *(unsigned char *)(*(void *)v35 + 1)
      && (*(unsigned char *)(*(void *)v35 + 1) != 46 || *(unsigned char *)(*(void *)v35 + 2)))
    {
      uint64_t v34 = (int *)fts_alloc(v38, *(const void **)v35, (int)*((void *)v35 + 1));
      if (!v34) {
        goto LABEL_45;
      }
      if (*((void *)v35 + 1) >= (unint64_t)v26)
      {
        uint64_t v28 = *(void *)(v38 + 32);
        if (fts_palloc(v38, *((_DWORD *)v35 + 2) + v27 + 1))
        {
LABEL_45:
          int v20 = *__error();
          fts_free(v34);
          fts_lfree((uint64_t)v33);
          close_directory((uint64_t)v29);
          *(_WORD *)(v31 + 88) = 7;
          *(_DWORD *)(v38 + 64) |= 0x200u;
          *__error() = v20;
          return 0;
        }
        if (v28 != *(void *)(v38 + 32))
        {
          int v21 = 1;
          if ((*(_DWORD *)(v38 + 64) & 4) != 0) {
            __dst = (unsigned char *)(*(void *)(v38 + 32) + v27);
          }
        }
        int v26 = *(_DWORD *)(v38 + 44) - v27;
      }
      if ((unint64_t)(v27 + *((void *)v35 + 1)) >= 0xFFFF)
      {
        fts_free(v34);
        fts_lfree((uint64_t)v33);
        close_directory((uint64_t)v29);
        *(_WORD *)(v31 + 88) = 7;
        *(_DWORD *)(v38 + 64) |= 0x200u;
        *__error() = 63;
        return 0;
      }
      *((_WORD *)v34 + 43) = v23;
      *((void *)v34 + 1) = *(void *)v38;
      *((_WORD *)v34 + 32) = v27 + *((void *)v35 + 1);
      if (v25)
      {
        if (v22)
        {
          *((_WORD *)v34 + 44) = 10;
          v34[14] = v25;
        }
        else
        {
          *((_WORD *)v34 + 44) = 11;
        }
        *((void *)v34 + 5) = *(void *)(v31 + 40);
      }
      else
      {
        unsigned int v6 = *((_DWORD *)v35 + 40);
        if ((v22 | v6) <= 0x10)
        {
          uint64_t v8 = (v22 | v6) - 16;
          char v7 = 0;
        }
        else
        {
          uint64_t v8 = (v22 | v6) - 16;
          char v7 = 1;
        }
        if ((v7 & 1) == 0)
        {
          switch(v8)
          {
            case 0:
            case 4:
            case 10:
            case 16:
            case 17:
            case 18:
            case 20:
            case 22:
            case 24:
            case 26:
            case 28:
            case 30:
            case 32:
            case 36:
            case 48:
            case 52:
            case 64:
            case 68:
            case 74:
              if ((*(_DWORD *)(v38 + 64) & 4) != 0)
              {
                *((void *)v34 + 5) = *((void *)v34 + 6);
                memmove(__dst, v34 + 26, *((unsigned __int16 *)v34 + 33) + 1);
                uint64_t v13 = v38;
                int v14 = v34;
                int v15 = dir_fd((uint64_t)v29);
                if (v35[164]) {
                  __int16 v9 = fts_stat2(v13, (uint64_t)v14, 0, v15, (_WORD *)v35 + 8);
                }
                else {
                  __int16 v9 = fts_stat2(v13, (uint64_t)v14, 0, v15, 0);
                }
                *((_WORD *)v34 + 44) = v9;
              }
              else
              {
                *((void *)v34 + 5) = v34 + 26;
                if (v35[164]) {
                  __int16 v10 = fts_stat2(v38, (uint64_t)v34, 0, -1, (_WORD *)v35 + 8);
                }
                else {
                  __int16 v10 = fts_stat2(v38, (uint64_t)v34, 0, -1, 0);
                }
                *((_WORD *)v34 + 44) = v10;
              }
              goto LABEL_80;
            case 1:
            case 2:
            case 3:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 19:
            case 21:
            case 23:
            case 25:
            case 27:
            case 29:
            case 31:
            case 33:
            case 34:
            case 35:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 44:
            case 45:
            case 46:
            case 47:
            case 51:
            case 53:
            case 55:
            case 57:
            case 59:
            case 61:
            case 63:
            case 67:
            case 69:
            case 71:
            case 73:
            case 75:
            case 77:
              break;
            case 49:
            case 50:
            case 54:
            case 60:
            case 65:
            case 66:
            case 70:
            case 76:
              *((_WORD *)v34 + 44) = 3;
              goto LABEL_76;
            case 56:
            case 72:
              *((_WORD *)v34 + 44) = 8;
              goto LABEL_76;
            case 58:
              *((_WORD *)v34 + 44) = 12;
              goto LABEL_76;
            case 62:
            case 78:
              *((_WORD *)v34 + 44) = 14;
              goto LABEL_76;
            default:
              JUMPOUT(0);
          }
        }
        *((_WORD *)v34 + 44) = 11;
LABEL_76:
        if ((*(_DWORD *)(v38 + 64) & 4) != 0) {
          unsigned int v12 = (int *)*((void *)v34 + 6);
        }
        else {
          unsigned int v12 = v34 + 26;
        }
        *((void *)v34 + 5) = v12;
      }
LABEL_80:
      *((void *)v34 + 2) = 0;
      if (v33)
      {
        *((void *)v30 + 2) = v34;
        uint64_t v30 = v34;
      }
      else
      {
        uint64_t v30 = v34;
        uint64_t v33 = v34;
      }
      ++v32;
    }
  }
  close_directory((uint64_t)v29);
  if (v21) {
    fts_padjust(v38, (uint64_t)v33);
  }
  if ((*(_DWORD *)(v38 + 64) & 4) != 0)
  {
    if (v27 == *(_DWORD *)(v38 + 44) || !v32) {
      --__dst;
    }
    unsigned char *__dst = 0;
  }
  if (v24 && (v37 == 1 || !v32))
  {
    if (*(_WORD *)(v31 + 86))
    {
      if (!fts_safe_changedir(v38, v31, -1, "..")) {
        goto LABEL_100;
      }
    }
    else if ((*(_DWORD *)(v38 + 64) & 4) != 0 || !fts_fchdir(v38, *(_DWORD *)(v38 + 40)))
    {
      goto LABEL_100;
    }
    *(_WORD *)(v31 + 88) = 7;
    *(_DWORD *)(v38 + 64) |= 0x200u;
    return 0;
  }
LABEL_100:
  if (v32)
  {
    if (*(void *)(v38 + 56) && v32 > 1) {
      return (int *)fts_sort(v38, (uint64_t)v33, v32);
    }
    return v33;
  }
  else
  {
    if (v37 == 3) {
      *(_WORD *)(v31 + 88) = 6;
    }
    return 0;
  }
}

const char *fts_load(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int16 *)(a2 + 66);
  *(_WORD *)(a2 + 64) = *(_WORD *)(a2 + 66);
  memmove(*(void **)(a1 + 32), (const void *)(a2 + 104), v2 + 1);
  uint64_t result = strrchr((const char *)(a2 + 104), 47);
  if (result && (result != (const char *)(a2 + 104) || result[1]))
  {
    uint64_t __src = (void *)(result + 1);
    size_t v6 = strlen(result + 1);
    uint64_t result = (const char *)memmove((void *)(a2 + 104), __src, v6 + 1);
    *(_WORD *)(a2 + 66) = v6;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  *(void *)(a2 + 48) = v4;
  *(void *)(a2 + 40) = v4;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 80);
  return result;
}

int fts_set(FTS *a1, FTSENT *a2, int a3)
{
  if (a3 <= 4)
  {
    a2->int fts_instr = a3;
    return 0;
  }
  else
  {
    *__error() = 22;
    return 1;
  }
}

FTSENT *__cdecl fts_children(FTS *a1, int a2)
{
  if (!a2 || a2 == 256)
  {
    fts_cur = a1->fts_cur;
    *__error() = 0;
    if ((a1->fts_options & 0x200) != 0)
    {
      return 0;
    }
    else if (fts_cur->fts_info == 9)
    {
      return fts_cur->fts_link;
    }
    else if (fts_cur->fts_info == 1)
    {
      if (a1->fts_child) {
        fts_lfree((uint64_t)a1->fts_child);
      }
      if (a2 == 256)
      {
        a1->fts_options |= 0x100u;
        int v6 = 2;
      }
      else
      {
        int v6 = 1;
      }
      if (fts_cur->fts_level || *fts_cur->fts_accpath == 47 || (a1->fts_options & 4) != 0)
      {
        a1->fts_child = (_ftsent *)fts_build((uint64_t)a1, v6);
        if (*__error()) {
          fts_cur->fts_errno = *__error();
        }
        return a1->fts_child;
      }
      else
      {
        int v3 = open_NOCANCEL();
        if (v3 >= 0)
        {
          a1->fts_child = (_ftsent *)fts_build((uint64_t)a1, v6);
          if (*__error()) {
            fts_cur->fts_errno = *__error();
          }
          if (fts_fchdir((uint64_t)a1, v3))
          {
            close_NOCANCEL();
            return 0;
          }
          else
          {
            close_NOCANCEL();
            return a1->fts_child;
          }
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t fts_palloc(uint64_t a1, int a2)
{
  *(_DWORD *)(a1 + 44) += a2 + 256;
  if (*(_DWORD *)(a1 + 44) <= 0xFFFEu)
  {
    uint64_t v3 = malloc_type_realloc();
    if (v3)
    {
      *(void *)(a1 + 32) = v3;
      return 0;
    }
    else
    {
      free(*(void **)(a1 + 32));
      *(void *)(a1 + 32) = 0;
      return 1;
    }
  }
  else
  {
    free(*(void **)(a1 + 32));
    *(void *)(a1 + 32) = 0;
    *__error() = 63;
    return 1;
  }
}

size_t fts_maxarglen(const char **a1)
{
  size_t v2 = 0;
  while (*a1)
  {
    size_t v3 = strlen(*a1);
    if (v3 > v2) {
      size_t v2 = v3;
    }
    ++a1;
  }
  return v2 + 1;
}

uint64_t fts_alloc(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v4 = malloc_type_calloc();
  if (!v4) {
    return 0;
  }
  *(_DWORD *)(v4 + 60) = -1;
  *(void *)(v4 + 48) = *(void *)(a1 + 32);
  *(_WORD *)(v4 + 66) = a3;
  *(_WORD *)(v4 + 92) = 3;
  if ((*(_DWORD *)(a1 + 64) & 8) == 0) {
    *(void *)(v4 + 96) = (v4 + 104 + a3 + 9) & 0xFFFFFFFFFFFFFFF8;
  }
  memcpy((void *)(v4 + 104), a2, a3);
  return v4;
}

uint64_t fts_sort(uint64_t a1, uint64_t a2, int a3)
{
  int v10 = a3;
  if (a3 > *(_DWORD *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 48) = a3 + 40;
    uint64_t v6 = reallocarray_DARWIN_EXTSN();
    if (!v6)
    {
      free(*(void **)(a1 + 16));
      *(void *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 48) = 0;
      return a2;
    }
    *(void *)(a1 + 16) = v6;
  }
  uint64_t v8 = *(void **)(a1 + 16);
  for (uint64_t i = a2; i; uint64_t i = *(void *)(i + 16))
  {
    size_t v3 = v8++;
    *size_t v3 = i;
  }
  if (*(int *)(a1 + 64) >= 0)
  {
    __compar = 0;
    if (*(void *)(a1 + 56)) {
      __compar = *(int (__cdecl **)(const void *, const void *))(a1 + 56);
    }
    qsort(*(void **)(a1 + 16), v10, 8uLL, __compar);
  }
  else
  {
    qsort_b(*(void **)(a1 + 16), v10, 8uLL, *(void **)(a1 + 56));
  }
  __int16 v9 = *(void **)(a1 + 16);
  uint64_t v12 = *v9;
  while (--v10)
  {
    *(void *)(*v9 + 16) = v9[1];
    ++v9;
  }
  *(void *)(*v9 + 16) = 0;
  return v12;
}

BOOL open_directory(uint64_t a1, DIR **a2, const char *a3)
{
  memset(a2, 0, 0x40uLL);
  *((unsigned char *)a2 + 53) = (*(_DWORD *)(a1 + 64) & 8) != 0;
  BOOL v3 = (*(_DWORD *)(a1 + 64) & 0x20) != 0;
  *((unsigned char *)a2 + 55) = v3;
  *((unsigned char *)a2 + 54) = v3;
  *((_DWORD *)a2 + 12) = open_NOCANCEL();
  if (*((_DWORD *)a2 + 12) != -1
    && (a2[4] = (DIR *)malloc_type_malloc()) != 0
    && ((*((_WORD *)a2 + 4) = 5, (*((unsigned char *)a2 + 53) & 1) != 0)
      ? (*((_DWORD *)a2 + 3) = -2113929205, *((_DWORD *)a2 + 6) = 1)
      : (*((_DWORD *)a2 + 3) = -2113430005, *((_DWORD *)a2 + 6) = 557),
        (advance_directory((uint64_t)a2) & 1) != 0))
  {
    return 1;
  }
  else
  {
    if (*((_DWORD *)a2 + 12) != -1) {
      close_NOCANCEL();
    }
    *((_DWORD *)a2 + 12) = -1;
    free(a2[4]);
    a2[4] = 0;
    *a2 = opendir(a3);
    return *a2 != 0;
  }
}

uint64_t dir_fd(uint64_t a1)
{
  if (*(void *)a1) {
    return dirfd(*(DIR **)a1);
  }
  else {
    return *(unsigned int *)(a1 + 48);
  }
}

void close_directory(uint64_t a1)
{
  if (*(void *)a1)
  {
    closedir(*(DIR **)a1);
    *(void *)a1 = 0;
  }
  if (*(_DWORD *)(a1 + 48) != -1)
  {
    close_NOCANCEL();
    *(_DWORD *)(a1 + 48) = -1;
  }
  free(*(void **)(a1 + 32));
  *(void *)(a1 + 32) = 0;
}

uint64_t read_dirent(uint64_t a1, uint64_t a2)
{
  if (*(void *)a1)
  {
    int v20 = readdir(*(DIR **)a1);
    if (v20)
    {
      *(void *)a2 = v20->d_name;
      *(void *)(a2 + 8) = v20->d_namlen;
      *(_DWORD *)(a2 + 160) = v20->d_type;
      *(unsigned char *)(a2 + 164) = 0;
      char v23 = 1;
    }
    else
    {
      char v23 = 0;
    }
  }
  else if (*(_DWORD *)(a1 + 48) == -1)
  {
    char v23 = 0;
  }
  else if (*(unsigned char *)(a1 + 54))
  {
    *(unsigned char *)(a1 + 54) = 0;
    *(void *)a2 = ".";
    *(void *)(a2 + 8) = 1;
    *(_DWORD *)(a2 + 160) = 4;
    *(unsigned char *)(a2 + 164) = 0;
    char v23 = 1;
  }
  else if (*(unsigned char *)(a1 + 55))
  {
    *(unsigned char *)(a1 + 55) = 0;
    *(void *)a2 = "..";
    *(void *)(a2 + 8) = 2;
    *(_DWORD *)(a2 + 160) = 4;
    *(unsigned char *)(a2 + 164) = 0;
    char v23 = 1;
  }
  else
  {
    if (*(_DWORD *)(a1 + 60) == *(_DWORD *)(a1 + 56))
    {
      if (*(unsigned char *)(a1 + 52))
      {
        char v23 = 0;
        return v23 & 1;
      }
      if ((advance_directory(a1) & 1) == 0)
      {
        char v23 = 0;
        return v23 & 1;
      }
      if (*(unsigned char *)(a1 + 52))
      {
        char v23 = 0;
        return v23 & 1;
      }
    }
    memset((void *)a2, 0, 0xA8uLL);
    BOOL v19 = 0;
    uint64_t v18 = 0;
    if (*(unsigned char *)(a1 + 53))
    {
      uint64_t v18 = *(int **)(a1 + 40);
      ++*(_DWORD *)(a1 + 60);
      *(void *)(a1 + 40) = (char *)v18 + *v18;
      BOOL v7 = 1;
      if (*(_DWORD *)(a1 + 60) != *(_DWORD *)(a1 + 56)) {
        BOOL v7 = *(void *)(a1 + 40) + (unint64_t)**(unsigned int **)(a1 + 40) <= *(void *)(a1 + 32) + 0x8000;
      }
      if (!v7)
      {
        int v14 = _os_assert_log(v7);
        _os_crash((uint64_t)v14);
        __break(1u);
      }
      if (!v18[7])
      {
        uint64_t v13 = _os_assert_log(v18[7] != 0);
        _os_crash((uint64_t)v13);
        __break(1u);
      }
      *(void *)a2 = (char *)v18 + v18[6] + 24;
      *(void *)(a2 + 8) = (v18[7] - 1);
      if (*(void *)a2 + (unint64_t)v18[7] > *(void *)(a1 + 32) + 0x8000)
      {
        uint64_t v12 = _os_assert_log(0);
        _os_crash((uint64_t)v12);
        __break(1u);
      }
    }
    else
    {
      BOOL v19 = *(unsigned int **)(a1 + 40);
      ++*(_DWORD *)(a1 + 60);
      *(void *)(a1 + 40) = (char *)v19 + *v19;
      BOOL v8 = 1;
      if (*(_DWORD *)(a1 + 60) != *(_DWORD *)(a1 + 56)) {
        BOOL v8 = *(void *)(a1 + 40) + (unint64_t)**(unsigned int **)(a1 + 40) <= *(void *)(a1 + 32) + 0x8000;
      }
      if (!v8)
      {
        uint64_t v17 = _os_assert_log(0);
        _os_crash((uint64_t)v17);
        __break(1u);
      }
      if (!v19[7])
      {
        int v16 = _os_assert_log(v19[7] != 0);
        _os_crash((uint64_t)v16);
        __break(1u);
      }
      *(void *)a2 = (char *)v19 + (int)v19[6] + 24;
      *(void *)(a2 + 8) = v19[7] - 1;
      if (*(void *)a2 + (unint64_t)v19[7] > *(void *)(a1 + 32) + 0x8000)
      {
        int v15 = _os_assert_log(0);
        _os_crash((uint64_t)v15);
        __break(1u);
      }
    }
    int v11 = 0;
    if (*(unsigned char *)(a1 + 53)) {
      unsigned int v6 = v18[9];
    }
    else {
      unsigned int v6 = v19[9];
    }
    if (v6 <= 1)
    {
      uint64_t v3 = v6 - 1;
      char v2 = 0;
    }
    else
    {
      uint64_t v3 = v6 - 1;
      char v2 = 1;
    }
    if (v2)
    {
      *(_DWORD *)(a2 + 160) = 0;
    }
    else
    {
      switch(v3)
      {
        case 0:
          *(_DWORD *)(a2 + 160) = 8;
          int v11 = 0x8000;
          break;
        case 1:
          *(_DWORD *)(a2 + 160) = 4;
          break;
        case 2:
          *(_DWORD *)(a2 + 160) = 6;
          int v11 = 24576;
          break;
        case 3:
          *(_DWORD *)(a2 + 160) = 2;
          int v11 = 0x2000;
          break;
        case 4:
          *(_DWORD *)(a2 + 160) = 10;
          int v11 = 40960;
          break;
        case 5:
          *(_DWORD *)(a2 + 160) = 12;
          int v11 = 49152;
          break;
        case 6:
          *(_DWORD *)(a2 + 160) = 1;
          int v11 = 4096;
          break;
        default:
          JUMPOUT(0);
      }
    }
    if ((*(unsigned char *)(a1 + 53) & 1) != 0 || !v11)
    {
      *(unsigned char *)(a2 + 164) = 0;
    }
    else
    {
      *(unsigned char *)(a2 + 164) = 1;
      int v10 = *(_DWORD *)(a1 + 12);
      int v9 = *(_DWORD *)(a1 + 24);
      if (*(_DWORD *)(a2 + 160) != 6 && *(_DWORD *)(a2 + 160) != 2)
      {
        v19[36] = 0;
        v9 &= ~0x20u;
      }
      if ((v19[1] & 0x200) == 0)
      {
        *((void *)v19 + 6) = 0;
        *((void *)v19 + 5) = 0;
        v10 &= ~0x200u;
      }
      if ((v19[1] & v10) != v10 || (v19[4] & v9) != v9) {
        *(unsigned char *)(a2 + 164) = 0;
      }
    }
    if (*(unsigned char *)(a2 + 164))
    {
      *(_DWORD *)(a2 + 16) = v19[8];
      *(_WORD *)(a2 + 22) = v19[32];
      *(void *)(a2 + 24) = *((void *)v19 + 15);
      *(_DWORD *)(a2 + 32) = v19[26];
      *(_DWORD *)(a2 + 36) = v19[27];
      *(_DWORD *)(a2 + 40) = v19[36];
      *(_OWORD *)(a2 + 48) = *(_OWORD *)(v19 + 22);
      *(_OWORD *)(a2 + 64) = *(_OWORD *)(v19 + 14);
      *(_OWORD *)(a2 + 80) = *(_OWORD *)(v19 + 18);
      *(_OWORD *)(a2 + 96) = *(_OWORD *)(v19 + 10);
      *(void *)(a2 + 112) = *(void *)(v19 + 37);
      *(_DWORD *)(a2 + 128) = v19[35];
      *(_DWORD *)(a2 + 132) = v19[29];
      *(_WORD *)(a2 + 20) = v19[28] & 0xFFF | v11;
      if (*(void *)(v19 + 33) % 512) {
        uint64_t v5 = *(void *)(v19 + 33) / 512 + 1;
      }
      else {
        uint64_t v5 = *(void *)(v19 + 33) / 512;
      }
      *(void *)(a2 + 120) = v5;
    }
    char v23 = 1;
  }
  return v23 & 1;
}

uint64_t fts_stat2(uint64_t a1, uint64_t a2, int a3, int a4, _WORD *a5)
{
  uint64_t v20 = a1;
  uint64_t v19 = a2;
  int v18 = a3;
  int v17 = a4;
  int v16 = a5;
  uint64_t i = 0;
  dev_t v14 = 0;
  __darwin_ino64_t v13 = 0;
  uint64_t v12 = 0;
  memset(__b, 0, sizeof(__b));
  if (v17 == -1)
  {
    int v9 = *(char **)(v19 + 40);
    int v17 = -2;
  }
  else
  {
    int v9 = (char *)(v19 + 104);
  }
  if ((*(_DWORD *)(v20 + 64) & 8) != 0) {
    BOOL v8 = (stat *)__b;
  }
  else {
    BOOL v8 = *(stat **)(v19 + 96);
  }
  uint64_t v12 = v8;
  if (v18)
  {
    int v16 = 0;
  }
  else if (v16 && (*(_DWORD *)(v20 + 64) & 2) != 0 && (v16[2] & 0xA000) == 0xA000)
  {
    int v16 = 0;
  }
  if (v16)
  {
    memcpy(v12, v16, sizeof(stat));
    goto LABEL_30;
  }
  if ((*(_DWORD *)(v20 + 64) & 2) == 0 && !v18)
  {
    if (!fstatat(v17, v9, v12, 32)) {
      goto LABEL_30;
    }
LABEL_28:
    *(_DWORD *)(v19 + 56) = *__error();
    goto LABEL_29;
  }
  if (fstatat(v17, v9, v12, 0))
  {
    int v10 = *__error();
    if (!fstatat(v17, v9, v12, 32))
    {
      if (v10 == 62) {
        *(_DWORD *)(v19 + 56) = 62;
      }
      *__error() = 0;
      return 13;
    }
    *(_DWORD *)(v19 + 56) = v10;
LABEL_29:
    memset(v12, 0, sizeof(stat));
    return 10;
  }
  if (v18 == -1 && (v12->st_mode & 0xF000) != 0x4000 && fstatat(v17, v9, v12, 32)) {
    goto LABEL_28;
  }
LABEL_30:
  switch(v12->st_mode & 0xF000)
  {
    case 16384:
      dev_t st_dev = v12->st_dev;
      *(_DWORD *)(v19 + 80) = v12->st_dev;
      dev_t v14 = st_dev;
      __darwin_ino64_t st_ino = v12->st_ino;
      *(void *)(v19 + 72) = st_ino;
      __darwin_ino64_t v13 = st_ino;
      *(_WORD *)(v19 + 84) = v12->st_nlink;
      if (*(unsigned char *)(v19 + 104) != 46
        || *(unsigned char *)(v19 + 105) && (*(unsigned char *)(v19 + 105) != 46 || *(unsigned char *)(v19 + 106)))
      {
        for (uint64_t i = *(void *)(v19 + 8); *(__int16 *)(i + 86) >= 0; uint64_t i = *(void *)(i + 8))
        {
          if (v13 == *(void *)(i + 72) && v14 == *(_DWORD *)(i + 80))
          {
            *(void *)uint64_t v19 = i;
            return 2;
          }
        }
        return 1;
      }
      else
      {
        return 5;
      }
    case 40960:
      return 12;
    case 32768:
      return 8;
    default:
      return 3;
  }
}

uint64_t fts_padjust(uint64_t result, uint64_t a2)
{
  uint64_t v3 = *(void *)(result + 32);
  for (uint64_t i = *(void **)(result + 8); i; uint64_t i = (void *)i[2])
  {
    if ((void *)i[5] != i + 13) {
      i[5] = v3 + i[5] - i[6];
    }
    i[6] = v3;
  }
  while (*(__int16 *)(a2 + 86) >= 0)
  {
    if (*(void *)(a2 + 40) != a2 + 104) {
      *(void *)(a2 + 40) = v3 + *(void *)(a2 + 40) - *(void *)(a2 + 48);
    }
    *(void *)(a2 + 48) = v3;
    if (*(void *)(a2 + 16)) {
      uint64_t v2 = *(void *)(a2 + 16);
    }
    else {
      uint64_t v2 = *(void *)(a2 + 8);
    }
    a2 = v2;
  }
  return result;
}

uint64_t advance_directory(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 52))
  {
    char v5 = 1;
  }
  else
  {
    if (*(_DWORD *)(a1 + 48) == -1)
    {
      uint64_t v3 = _os_assert_log(*(_DWORD *)(a1 + 48) != -1);
      _os_crash((uint64_t)v3);
      __break(1u);
    }
    *(_DWORD *)(a1 + 56) = getattrlistbulk(*(_DWORD *)(a1 + 48), (void *)(a1 + 8), *(void **)(a1 + 32), 0x8000uLL, 8uLL);
    if (*(_DWORD *)(a1 + 56) == -1)
    {
      int v2 = *__error();
      close_NOCANCEL();
      *(_DWORD *)(a1 + 48) = -1;
      *__error() = v2;
      char v5 = 0;
    }
    else
    {
      if (!*(_DWORD *)(a1 + 56)) {
        *(unsigned char *)(a1 + 52) = 1;
      }
      *(_DWORD *)(a1 + 60) = 0;
      *(void *)(a1 + 40) = *(void *)(a1 + 32);
      char v5 = 1;
    }
  }
  return v5 & 1;
}

BOOL compat_mode(const char *function, const char *mode)
{
  if ((parsed & 1) == 0 && (bootstrapping & 1) == 0)
  {
    pthread_once(&threadsafe, (void (*)(void))check_env_var);
    parsed = 1;
  }
  if (!strcasecmp("unix2003", mode))
  {
    char v12 = unix2003_mode & 1;
    return v12 & 1;
  }
  if (!strcasecmp("legacy", mode))
  {
    char v12 = (unix2003_mode ^ 1) & 1;
    return v12 & 1;
  }
  if (!strcasecmp("bootstrap", mode))
  {
    char v12 = bootstrapping & 1;
    return v12 & 1;
  }
  if (!strcasecmp("error", mode))
  {
    char v12 = parse_error & 1;
    return v12 & 1;
  }
  int v9 = strpbrk(mode, "!^&|");
  if (!v9)
  {
LABEL_27:
    fprintf(__stderrp, "invalid mode %s (while checking for %s)\n", mode, function);
    char v12 = 0;
    return v12 & 1;
  }
  if (*v9 == 33)
  {
    if (v9 == mode)
    {
      char v12 = !compat_mode(function, mode + 1);
      return v12 & 1;
    }
    goto LABEL_27;
  }
  __dst = (char *)malloc_type_malloc();
  strlcpy(__dst, mode, v9 - mode + 1);
  BOOL v7 = compat_mode(function, __dst);
  free(__dst);
  BOOL v6 = compat_mode(function, v9 + 1);
  int v5 = *v9;
  switch(v5)
  {
    case '&':
      BOOL v4 = 0;
      if (v7) {
        BOOL v4 = v6;
      }
      char v12 = v4;
      break;
    case '^':
      char v12 = v7 != v6;
      return v12 & 1;
    case '|':
      char v3 = 1;
      if (!v7) {
        char v3 = v6;
      }
      char v12 = v3 & 1;
      break;
    default:
      goto LABEL_27;
  }
  return v12 & 1;
}

char *check_env_var()
{
  uint64_t result = getenv("COMMAND_MODE");
  int v1 = result;
  if (result)
  {
    uint64_t result = (char *)strcasecmp(result, "legacy");
    if (result)
    {
      uint64_t result = (char *)strcasecmp(v1, "unix2003");
      if (result) {
        parse_error = 1;
      }
      unix2003_mode = 1;
    }
    else
    {
      unix2003_mode = 0;
    }
  }
  return result;
}

int getloadavg(double a1[], int a2)
{
  double *__attribute__((__org_arrdim(0,0))) v10 = a1;
  int v9 = a2;
  v7[0] = 0;
  v7[1] = 0;
  uint64_t v8 = 0;
  int i = 0;
  v12[0] = 2;
  v12[1] = 2;
  size_t v5 = 24;
  if (sysctl(v12, 2u, v7, &v5, 0, 0) < 0) {
    return -1;
  }
  if ((unint64_t)v9 >= 3) {
    int v4 = 3;
  }
  else {
    int v4 = v9;
  }
  int v9 = v4;
  for (int i = 0; i < v9; ++i)
  {
    LODWORD(v2) = *((_DWORD *)v7 + i);
    double v2 = (double)*(unint64_t *)&v2 / (double)v8;
    v10[i] = v2;
  }
  return v9;
}

ttyent *__cdecl getttynam(const char *a1)
{
  setttyent();
  do
    double v2 = getttyent();
  while (v2 && strcmp(a1, v2->ty_name));
  endttyent();
  return v2;
}

int setttyent(void)
{
  if (!seq)
  {
    if (regcomp(&brapreg, brapat[0], 1)) {
      return 0;
    }
    if (regcomp(&decpreg, decpat[0], 1))
    {
      regfree(&brapreg);
      return 0;
    }
    if (regcomp(&hexpreg, hexpat[0], 3))
    {
      regfree(&decpreg);
      regfree(&brapreg);
      return 0;
    }
    seq = malloc_type_malloc();
    if (!seq)
    {
      regfree(&hexpreg);
      regfree(&decpreg);
      regfree(&brapreg);
      return 0;
    }
  }
  *(_DWORD *)(seq + 4) = 0;
  *(_DWORD *)seq = 0;
  slot = 1;
  if (tf)
  {
    rewind((FILE *)tf);
    return 1;
  }
  else
  {
    tf = (uint64_t)fopen("/etc/ttys", "r");
    return tf != 0;
  }
}

ttyent *getttyent(void)
{
  if (v0) {
    char v1 = 1;
  }
  else {
    char v1 = 0;
  }
  if (v1)
  {
    char v23 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v24 = __locale_key;
    char v23 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v24);
  }
  if (v23) {
    int v9 = v23;
  }
  else {
    int v9 = (_xlocale *)__global_locale;
  }
  if (getttyent_line || (getttyent_line = malloc_type_malloc()) != 0)
  {
    if (!tf && !setttyent()) {
      return 0;
    }
    while (1)
    {
      while (1)
      {
        if (slot < *(_DWORD *)seq)
        {
          ++slot;
          return (ttyent *)&getttyent_nonexistent;
        }
        if (*(int *)(seq + 4) > 0)
        {
          double v2 = (char *)getttyent_tty;
          char v3 = (const char *)(seq + 12);
          uint64_t v4 = (*(_DWORD *)(seq + 8))++;
          sprintf(v2, v3, v4);
          ++slot;
          --*(_DWORD *)(seq + 4);
          return (ttyent *)&getttyent_tty;
        }
        if (slot == *(_DWORD *)seq)
        {
          ++slot;
          return (ttyent *)&getttyent_tty;
        }
        do
        {
          while (1)
          {
            int v17 = (char *)getttyent_line;
            if (!fgets((char *)getttyent_line, 1024, (FILE *)tf)) {
              return 0;
            }
            if (index(v17, 10)) {
              break;
            }
            do
            {
              int v20 = getc((FILE *)tf);
              BOOL v8 = 0;
              if (v20 != 10) {
                BOOL v8 = v20 != -1;
              }
            }
            while (v8);
          }
          while (isspace_l(*v17, v9))
            ++v17;
        }
        while (!*v17 || *v17 == 35);
        zapchar = 0;
        getttyent_tty = (uint64_t)v17;
        int v18 = skip(v17);
        qword_EA588 = (uint64_t)v18;
        if (*v18)
        {
          int v18 = skip(v18);
          qword_EA590 = (uint64_t)v18;
          if (*v18) {
            int v18 = skip(v18);
          }
          else {
            qword_EA590 = 0;
          }
        }
        else
        {
          qword_EA590 = 0;
          qword_EA588 = 0;
        }
        dword_EA598 = 0;
        qword_EA5A0 = 0;
        qword_EA5A8 = 0;
        qword_EA5B0 = 0;
        int v16 = -1;
        while (*v18)
        {
          if (!strncmp(v18, "off", 3uLL) && isspace_l(v18[3], v9))
          {
            dword_EA598 &= ~1u;
          }
          else if (!strncmp(v18, "on", 2uLL) && isspace_l(v18[2], v9))
          {
            dword_EA598 |= 1u;
          }
          else if (!strncmp(v18, "secure", 6uLL) && isspace_l(v18[6], v9))
          {
            dword_EA598 |= 2u;
          }
          else if (!strncmp(v18, "window", 6uLL) && v18[6] == 61)
          {
            qword_EA5A0 = (uint64_t)value(v18);
          }
          else if (!strncmp(v18, "onerror", 7uLL) && v18[7] == 61)
          {
            qword_EA5A8 = (uint64_t)value(v18);
          }
          else if (!strncmp(v18, "onoption", 8uLL) && v18[8] == 61)
          {
            qword_EA5B0 = (uint64_t)value(v18);
          }
          else
          {
            if (strncmp(v18, "slot", 4uLL) || v18[4] != 61) {
              break;
            }
            double *__attribute__((__org_arrdim(0,0))) v10 = value(v18);
            if (v10) {
              int v16 = atoi(v10);
            }
          }
          int v18 = skip(v18);
        }
        if (zapchar == 35 || *v18 == 35)
        {
          do
          {
            int v21 = *++v18;
            BOOL v7 = 1;
            if (v21 != 32) {
              BOOL v7 = v21 == 9;
            }
          }
          while (v7);
        }
        qword_EA5B8 = (uint64_t)v18;
        if (!*v18) {
          qword_EA5B8 = 0;
        }
        uint64_t v19 = index(v18, 10);
        if (v19) {
          *uint64_t v19 = 0;
        }
        if (regexec(&brapreg, (const char *)getttyent_tty, 3uLL, &__pmatch, 0)) {
          goto LABEL_87;
        }
        regmatch_t v11 = __pmatch;
        regmatch_t v12 = v26;
        regmatch_t __pmatch = v26;
        if (regexec(&decpreg, (const char *)getttyent_tty, 3uLL, &__pmatch, 4)) {
          break;
        }
        uint64_t v14 = strtol((const char *)(getttyent_tty + v26.rm_so), 0, 10);
        uint64_t v13 = strtol((const char *)(getttyent_tty + v27), 0, 10);
        int v15 = 0;
LABEL_82:
        if (v14 <= v13)
        {
          *(_DWORD *)(seq + 4) = v13 - v14 + 1;
          *(_DWORD *)(seq + 8) = v14;
          if (v15) {
            uint64_t v5 = 120;
          }
          else {
            uint64_t v5 = 100;
          }
          sprintf((char *)(seq + 12), "%.*s%%0%d%c%s", SLODWORD(v11.rm_so), (const char *)getttyent_tty, LODWORD(v26.rm_eo) - LODWORD(v26.rm_so), v5, (const char *)(getttyent_tty + v11.rm_eo));
          goto LABEL_87;
        }
      }
      regmatch_t __pmatch = v12;
      if (!regexec(&hexpreg, (const char *)getttyent_tty, 3uLL, &__pmatch, 4))
      {
        uint64_t v14 = strtol((const char *)(getttyent_tty + v26.rm_so), 0, 16);
        uint64_t v13 = strtol((const char *)(getttyent_tty + v27), 0, 16);
        int v15 = 1;
        goto LABEL_82;
      }
LABEL_87:
      if (v16 <= slot)
      {
        if (*(int *)(seq + 4) <= 0)
        {
          ++slot;
          return (ttyent *)&getttyent_tty;
        }
      }
      else
      {
        *(_DWORD *)seq = v16;
      }
    }
  }
  return 0;
}

int endttyent(void)
{
  if (!tf) {
    return 1;
  }
  int v0 = fclose((FILE *)tf);
  tf = 0;
  return v0 != -1;
}

char *skip(char *a1)
{
  int v9 = a1;
  int v5 = 0;
  BOOL v8 = a1;
  while (1)
  {
    int v6 = *v9;
    if (!*v9) {
      break;
    }
    if (v6 == 34)
    {
      v5 ^= 1u;
    }
    else
    {
      if (v5 == 1 && *v9 == 92 && v9[1] == 34) {
        ++v9;
      }
      char v1 = v8++;
      *char v1 = *v9;
      if (v5 != 1)
      {
        if (v6 == 35)
        {
          zapchar = 35;
          *int v9 = 0;
          break;
        }
        if (v6 == 9 || v6 == 32 || v6 == 10)
        {
          zapchar = v6;
          double v2 = v9++;
          *double v2 = 0;
          while (1)
          {
            int v7 = *v9;
            BOOL v4 = 1;
            if (v7 != 9)
            {
              BOOL v4 = 1;
              if (v7 != 32) {
                BOOL v4 = v7 == 10;
              }
            }
            if (!v4) {
              break;
            }
            ++v9;
          }
          break;
        }
      }
    }
    ++v9;
  }
  *(v8 - 1) = 0;
  return v9;
}

char *value(const char *a1)
{
  char v3 = index(a1, 61);
  if (v3) {
    return v3 + 1;
  }
  else {
    return 0;
  }
}

char *getusershell(void)
{
  if (!curshell) {
    curshell = (uint64_t)initshells();
  }
  char v1 = *(char **)curshell;
  if (*(void *)curshell) {
    curshell += 8;
  }
  return v1;
}

char **initshells()
{
  regmatch_t v12 = 0;
  regmatch_t v11 = 0;
  double *__attribute__((__org_arrdim(0,0))) v10 = 0;
  memset(&__b, 0, sizeof(__b));
  uint64_t v14 = 0;
  if (v0) {
    char v1 = 1;
  }
  else {
    char v1 = 0;
  }
  if (v1)
  {
    uint64_t v14 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v15 = __locale_key;
    uint64_t v16 = __locale_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    uint64_t v14 = *(_xlocale **)(StatusReg + 8 * v16);
  }
  if (v14) {
    BOOL v8 = v14;
  }
  else {
    BOOL v8 = (_xlocale *)__global_locale;
  }
  if (shells) {
    free((void *)shells);
  }
  shells = 0;
  if (strings) {
    free((void *)strings);
  }
  strings = 0;
  double *__attribute__((__org_arrdim(0,0))) v10 = fopen("/etc/shells", "r");
  if (!v10) {
    return okshells;
  }
  int v2 = fileno(v10);
  if (fstat(v2, &__b) == -1 || (strings = malloc_type_malloc()) == 0)
  {
    fclose(v10);
    return okshells;
  }
  else
  {
    shells = malloc_type_calloc();
    if (shells)
    {
      regmatch_t v12 = (void *)shells;
      regmatch_t v11 = (char *)strings;
      while (fgets(v11, 1025, v10))
      {
        while (1)
        {
          BOOL v7 = 0;
          if (*v11 != 35)
          {
            BOOL v7 = 0;
            if (*v11 != 47) {
              BOOL v7 = *v11 != 0;
            }
          }
          if (!v7) {
            break;
          }
          ++v11;
        }
        if (*v11 != 35 && *v11)
        {
          char v3 = v12++;
          *char v3 = v11;
          while (1)
          {
            BOOL v6 = 0;
            if (!isspace_l(*v11, v8))
            {
              BOOL v6 = 0;
              if (*v11 != 35) {
                BOOL v6 = *v11 != 0;
              }
            }
            if (!v6) {
              break;
            }
            ++v11;
          }
          BOOL v4 = v11++;
          *BOOL v4 = 0;
        }
      }
      *regmatch_t v12 = 0;
      fclose(v10);
      return (char **)shells;
    }
    else
    {
      fclose(v10);
      free((void *)strings);
      strings = 0;
      return okshells;
    }
  }
}

void endusershell(void)
{
  if (shells) {
    free((void *)shells);
  }
  shells = 0;
  if (strings) {
    free((void *)strings);
  }
  strings = 0;
  curshell = 0;
}

void setusershell(void)
{
  curshell = (uint64_t)initshells();
}

int getvfsbyname(const char *a1, vfsconf *a2)
{
  __s1 = (char *)a1;
  BOOL v6 = a2;
  int v5 = 0;
  int i = 0;
  uint64_t v9 = 3;
  int v10 = 1;
  size_t v3 = 4;
  if (sysctl((int *)&v9, 3u, &v5, &v3, 0, 0) < 0) {
    return -1;
  }
  int v10 = 2;
  size_t v3 = 40;
  for (int i = 0; i < v5; ++i)
  {
    int v11 = i;
    if (sysctl((int *)&v9, 4u, v6, &v3, 0, 0) >= 0)
    {
      if (!strcmp(__s1, (const char *)v6 + 4)) {
        return 0;
      }
    }
    else if (*__error() != 45)
    {
      return -1;
    }
  }
  *__error() = 2;
  return -1;
}

uint64_t _init_clock_port()
{
  mach_port_t host = mach_host_self();
  if (host_get_clock_service(host, 0, (clock_serv_t *)&clock_port)) {
    abort();
  }
  if (semaphore_create(mach_task_self_, (semaphore_t *)&clock_sem, 0, 0)) {
    abort();
  }
  return mach_port_deallocate(mach_task_self_, host);
}

uint64_t nanosleep_NOCANCEL(void *a1, void *a2)
{
  uint64_t v16 = a1;
  uint64_t v15 = a2;
  mach_error_t v14 = 0;
  mach_error_t time = 0;
  mach_timespec_t v12 = 0;
  mach_timespec_t cur_time = 0;
  if (!__unix_conforming) {
    __unix_conforming = 1;
  }
  if (v16 && (uint64_t)*v16 >= 0 && v16[1] < 0x3B9ACA00uLL)
  {
    if (!v15 || (mach_error_t v14 = clock_get_time(clock_port, &cur_time)) == 0)
    {
      mach_error_t time = __semwait_signal_nocancel();
      if (time < 0)
      {
        if (*__error() == 60) {
          return 0;
        }
        if (*__error() == 4)
        {
          if (v15)
          {
            mach_error_t time = clock_get_time(clock_port, &v12);
            if (time)
            {
              uint64_t v9 = __stderrp;
              size_t v3 = mach_error_string(time);
              fprintf(v9, "clock_get_time() failed: %s\n", v3);
              return -1;
            }
            uint64_t v4 = cur_time.tv_nsec + v16[1];
            cur_time.tv_nsec += *((_DWORD *)v16 + 2);
            if ((int)v4 >= 1000000000)
            {
              cur_time.tv_nsec -= 1000000000;
              ++cur_time.tv_sec;
            }
            cur_time.tv_sec += *v16;
            if (cur_time.tv_sec <= v12.tv_sec)
            {
              if (cur_time.tv_sec >= v12.tv_sec) {
                uint64_t v7 = cur_time.tv_nsec - v12.tv_nsec;
              }
              else {
                uint64_t v7 = -1000000000;
              }
              uint64_t v8 = v7;
            }
            else
            {
              uint64_t v8 = 1000000000;
            }
            if (v8 <= 0)
            {
              int v5 = v15;
              *uint64_t v15 = 0;
              v5[1] = 0;
            }
            else
            {
              cur_time.tv_nsec -= v12.tv_nsec;
              if (cur_time.tv_nsec < 0)
              {
                cur_time.tv_nsec += 1000000000;
                --cur_time.tv_sec;
              }
              cur_time.tv_sec -= v12.tv_sec;
              *uint64_t v15 = cur_time.tv_sec;
              v15[1] = cur_time.tv_nsec;
            }
          }
        }
        else
        {
          *__error() = 22;
        }
      }
      return -1;
    }
    int v10 = __stderrp;
    int v2 = mach_error_string(v14);
    fprintf(v10, "clock_get_time() failed: %s\n", v2);
    *__error() = 22;
    return -1;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int ftw(const char *a1, int (__cdecl *a2)(const char *, const stat *, int), int a3)
{
  return both_ftw(a1, (uint64_t (*)(char *, stat *, void))a2, 0, a3, 1);
}

uint64_t both_ftw(const char *a1, uint64_t (*a2)(char *, stat *, void), uint64_t (*a3)(char *, stat *, void, uint64_t *), int a4, int a5)
{
  int v32 = (char *)a1;
  uint64_t v31 = a2;
  uint64_t v30 = a3;
  int v29 = a4;
  int v28 = a5;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v27 = 0;
  regmatch_t v26 = 0;
  int v25 = 0;
  int v24 = 0;
  unsigned int v23 = 0;
  unsigned int v22 = 0;
  BOOL v21 = 0;
  int v20 = 0;
  int v19 = -1;
  if (a4 < 1 || v29 > 10240)
  {
    *__error() = 22;
    unsigned int v22 = -1;
    goto LABEL_81;
  }
  int v24 = 1;
  if ((v28 & 8) == 0) {
    v24 |= 4u;
  }
  if ((v28 & 2) != 0) {
    v24 |= 0x40u;
  }
  if (v28) {
    v24 |= 0x10u;
  }
  else {
    v24 |= 2u;
  }
  BOOL v21 = (v28 & 4) != 0;
  if ((v28 & 8) != 0)
  {
    int v19 = open_NOCANCEL();
    if (v19 < 0)
    {
      unsigned int v22 = -1;
      goto LABEL_81;
    }
    v24 |= 4u;
  }
  memset(&__b, 0, sizeof(__b));
  int v17 = stat(v32, &__b);
  if (v17 < 0 && (*__error() == 62 || *__error() == 63 || *__error() == 2 || *__error() == 20 || *__error() == 13))
  {
    unsigned int v22 = -1;
    goto LABEL_81;
  }
  if (v17 >= 0 && v30 && (__b.st_mode & 0xF000) != 0x4000)
  {
    *__error() = 20;
    unsigned int v22 = -1;
    goto LABEL_81;
  }
  uint64_t v33 = v32;
  uint64_t v34 = 0;
  int v25 = fts_open(&v33, v24, 0);
  if (!v25)
  {
    unsigned int v22 = -1;
    goto LABEL_81;
  }
  unsigned int v22 = 0;
  while (2)
  {
    regmatch_t v26 = fts_read(v25);
    if (!v26) {
      goto LABEL_81;
    }
    fts_mach_timebase_info info = v26->fts_info;
    BOOL v6 = fts_info > 1;
    uint64_t v7 = fts_info - 1;
    if (v6)
    {
      uint64_t v9 = v7;
      char v8 = 1;
    }
    else
    {
      uint64_t v9 = v7;
      char v8 = 0;
    }
    if (v8) {
      goto LABEL_62;
    }
    switch(v9)
    {
      case 0:
        if (v21 || (v28 & 2) != 0 && v26->fts_statp->st_dev != __b.st_dev || access(v26->fts_path, 4)) {
          continue;
        }
        unsigned int v23 = 1;
        goto LABEL_63;
      case 1:
        if (v30 && (v28 & 1) == 0)
        {
          if (!v21)
          {
            unsigned int v23 = 1;
LABEL_63:
            if (v19 >= 0)
            {
              mach_error_t v14 = 0;
              if (v23 == 1)
              {
                fts_path = v26->fts_path;
              }
              else
              {
                mach_error_t v14 = strdup(v26->fts_path);
                fts_path = v14;
                v14[v26->fts_pathlen - v26->fts_namelen] = 0;
              }
              int v13 = chdir(fts_path);
              if (v14) {
                free(v14);
              }
              if (v13 < 0)
              {
                if (v26->fts_pathlen == v26->fts_namelen && v23 == 2) {
                  *__error() = 24;
                }
                unsigned int v22 = -1;
                goto LABEL_81;
              }
            }
            if (v30)
            {
              LODWORD(v27) = v26->fts_pathlen - v26->fts_namelen;
              HIDWORD(v27) = v26->fts_level;
              unsigned int v22 = v30(v26->fts_path, v26->fts_statp, v23, &v27);
            }
            else
            {
              unsigned int v22 = v31(v26->fts_path, v26->fts_statp, v23);
            }
            if (v19 >= 0 && fchdir(v19) < 0)
            {
              unsigned int v22 = -1;
              goto LABEL_81;
            }
            if (v22) {
              goto LABEL_81;
            }
          }
          continue;
        }
        *__error() = 62;
LABEL_62:
        unsigned int v22 = -1;
LABEL_81:
        int v20 = *__error();
        if (v25) {
          fts_close(v25);
        }
        if (v19 >= 0) {
          close_NOCANCEL();
        }
        int v12 = v20;
        *__error() = v12;
        return v22;
      case 2:
      case 7:
        if ((v28 & 2) != 0 && v26->fts_statp->st_dev != __b.st_dev) {
          continue;
        }
        unsigned int v23 = 0;
        goto LABEL_63;
      case 3:
        unsigned int v23 = 2;
        goto LABEL_63;
      case 4:
      case 6:
      case 8:
        goto LABEL_62;
      case 5:
        if (!v21 || (v28 & 2) != 0 && v26->fts_statp->st_dev != __b.st_dev) {
          continue;
        }
        unsigned int v23 = 3;
        goto LABEL_63;
      case 9:
      case 10:
        unsigned int v23 = 4;
        goto LABEL_63;
      case 11:
        unsigned int v23 = 5;
        goto LABEL_63;
      case 12:
        if (v30) {
          int v10 = 6;
        }
        else {
          int v10 = 5;
        }
        unsigned int v23 = v10;
        memset(&v16, 0, sizeof(v16));
        if (stat(v26->fts_path, &v16) >= 0 || *__error() != 62) {
          goto LABEL_63;
        }
        unsigned int v22 = -1;
        goto LABEL_81;
      default:
        JUMPOUT(0);
    }
  }
}

int nftw(const char *a1, int (__cdecl *a2)(const char *, const stat *, int, FTW *), int a3, int a4)
{
  return both_ftw(a1, 0, (uint64_t (*)(char *, stat *, void, uint64_t *))a2, a3, a4);
}

int sigemptyset(sigset_t *a1)
{
  int result = 0;
  *a1 = 0;
  return result;
}

int sigfillset(sigset_t *a1)
{
  *a1 = -1;
  return 0;
}

int sigaddset(sigset_t *a1, int a2)
{
  if (a2 <= 0x20)
  {
    if (a2) {
      *a1 |= 1 << (a2 - 1);
    }
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sigdelset(sigset_t *a1, int a2)
{
  if (a2 <= 0x20)
  {
    if (a2) {
      *a1 &= ~(1 << (a2 - 1));
    }
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sigismember(const sigset_t *a1, int a2)
{
  if (a2 <= 0x20)
  {
    return a2 && (*a1 & (1 << (a2 - 1))) != 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

char *__cdecl fflagstostr(unint64_t a1)
{
  int v10 = (char *)malloc_type_malloc();
  if (!v10) {
    return 0;
  }
  unint64_t v7 = a1;
  char v8 = v10;
  for (int i = 0; (unint64_t)i < 0x15; ++i)
  {
    if ((v7 & (unint64_t)(&mapping)[3 * i + 1]) != 0)
    {
      if (v8 > v10)
      {
        char v1 = v8++;
        *char v1 = 44;
      }
      if (LODWORD((&mapping)[3 * i + 2])) {
        int v5 = (&mapping)[3 * i];
      }
      else {
        int v5 = (&mapping)[3 * i] + 2;
      }
      uint64_t v9 = v5;
      while (*v9)
      {
        int v2 = v9++;
        size_t v3 = v8++;
        *size_t v3 = *v2;
      }
      v7 &= ~(unint64_t)(&mapping)[3 * i + 1];
    }
  }
  *char v8 = 0;
  return v10;
}

int strtofflags(char **a1, unint64_t *a2, unint64_t *a3)
{
  uint64_t v9 = a1;
  char v8 = a2;
  unint64_t v7 = a3;
  __stringp = 0;
  if (a2) {
    *char v8 = 0;
  }
  if (v7) {
    *unint64_t v7 = 0;
  }
  __stringp = *v9;
  while (1)
  {
    __s1 = strsep(&__stringp, "\t ,");
    if (!__s1) {
      return 0;
    }
    *uint64_t v9 = (char *)__s1;
    if (*__s1)
    {
      for (int i = 0; (unint64_t)i < 0x15; ++i)
      {
        if (!strcmp(__s1, (&mapping)[3 * i] + 2))
        {
          if (LODWORD((&mapping)[3 * i + 2]))
          {
            if (v7) {
              *v7 |= (unint64_t)(&mapping)[3 * i + 1];
            }
          }
          else if (v8)
          {
            *v8 |= (unint64_t)(&mapping)[3 * i + 1];
          }
          break;
        }
        if (!strcmp(__s1, (&mapping)[3 * i]))
        {
          if (LODWORD((&mapping)[3 * i + 2]))
          {
            if (v8) {
              *v8 |= (unint64_t)(&mapping)[3 * i + 1];
            }
          }
          else if (v7)
          {
            *v7 |= (unint64_t)(&mapping)[3 * i + 1];
          }
          break;
        }
      }
      if (i == 21) {
        return 1;
      }
    }
  }
}

uint64_t _thread_stack_pcs(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5)
{
  return __thread_stack_pcs(a1, a2, a3, a4 + 1, a5, 0);
}

uint64_t __thread_stack_pcs(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5, char a6)
{
  char v19 = a6 & 1;
  uint64_t v15 = pthread_self();
  stackaddr_np = pthread_get_stackaddr_np(v15);
  unint64_t v13 = (unint64_t)stackaddr_np - pthread_get_stacksize_np(v15);
  unsigned int v12 = 0;
  *a3 = 0;
  int v18 = &vars0;
  unint64_t v16 = pthread_stack_frame_decode_np();
  unint64_t v14 = (unint64_t)stackaddr_np - (v16 - (void)&vars0);
  if (unint64_t)&vars0 < v13 || (unint64_t)&vars0 > v14 || ((unint64_t)&vars0)
  {
    return 0;
  }
  else
  {
    while (1)
    {
      BOOL v9 = 1;
      if (!a5)
      {
        int v6 = a4--;
        BOOL v9 = v6 != 0;
      }
      if (!v9 || a5 && a5 < v16) {
        break;
      }
      if (v16 < v13 || v16 > v14 || (v16 & 1) != 0 || v16 <= (unint64_t)v18) {
        return 0;
      }
      int v18 = (uint64_t *)v16;
      unint64_t v16 = pthread_stack_frame_decode_np();
    }
    while (a2--)
    {
      *(_DWORD *)&v11[8] = 0;
      *(void *)int v11 = __is_async_frame(v18);
      if (*(_DWORD *)v11)
      {
        if (v19)
        {
          __thread_stack_async_pcs();
          return *(unsigned int *)v11;
        }
        unsigned int v12 = 1;
      }
      unint64_t v17 = pthread_stack_frame_decode_np();
      *(void *)(a1 + 8 * (*a3)++) = *(void *)&v11[4];
      if (v17 < v13 || v17 > v14 || (v17 & 1) != 0 || v17 <= (unint64_t)v18) {
        return v12;
      }
      int v18 = (uint64_t *)v17;
    }
    return v12;
  }
}

uint64_t _thread_stack_async_pcs(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5)
{
  return __thread_stack_pcs(a1, a2, a3, a4 + 1, a5, 1);
}

uint64_t thread_stack_pcs(uint64_t a1, int a2, _DWORD *a3)
{
  return __thread_stack_pcs(a1, a2, a3, 0, 0, 0);
}

uint64_t thread_stack_async_pcs(uint64_t a1, int a2, _DWORD *a3)
{
  return __thread_stack_pcs(a1, a2, a3, 0, 0, 1);
}

uint64_t __is_async_frame(void *a1)
{
  if (*a1 >> 60 == 1)
  {
    uint64_t v2 = *(void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 824);
    if (v2) {
      return *(unsigned int *)(v2 + 36);
    }
    else {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __thread_stack_async_pcs()
{
  return pthread_stack_frame_decode_np();
}

int uname(utsname *a1)
{
  int v6 = a1;
  int v5 = 0;
  int v7 = 1;
  int v8 = 1;
  size_t v4 = 256;
  if (sysctl(&v7, 2u, a1, &v4, 0, 0) == -1) {
    int v5 = -1;
  }
  int v7 = 1;
  int v8 = 10;
  size_t v4 = 256;
  if (sysctl(&v7, 2u, v6->nodename, &v4, 0, 0) == -1) {
    int v5 = -1;
  }
  int v7 = 1;
  int v8 = 2;
  size_t v4 = 256;
  if (sysctl(&v7, 2u, v6->release, &v4, 0, 0) == -1) {
    int v5 = -1;
  }
  int v7 = 1;
  int v8 = 4;
  size_t v4 = 256;
  if (sysctl(&v7, 2u, v6->version, &v4, 0, 0) == -1)
  {
    int v5 = -1;
  }
  else
  {
    for (int i = v6->version; v4--; ++i)
    {
      if (*i == 10 || *i == 9)
      {
        if (v4 <= 1) {
          *int i = 0;
        }
        else {
          *int i = 32;
        }
      }
    }
  }
  int v7 = 6;
  int v8 = 1;
  size_t v4 = 256;
  if (sysctl(&v7, 2u, v6->machine, &v4, 0, 0) == -1) {
    return -1;
  }
  return v5;
}

int isascii(int a1)
{
  return (a1 & 0xFFFFFF80) == 0;
}

int isalnum(int a1)
{
  return __istype(a1, 0x500u);
}

int isalpha(int a1)
{
  return __istype(a1, 0x100u);
}

int isblank(int a1)
{
  return __istype(a1, 0x20000u);
}

int iscntrl(int a1)
{
  return __istype(a1, 0x200u);
}

int isdigit(int a1)
{
  return __isctype(a1, 1024);
}

int isgraph(int a1)
{
  return __istype(a1, 0x800u);
}

int islower(int a1)
{
  return __istype(a1, 0x1000u);
}

int isprint(int a1)
{
  return __istype(a1, 0x40000u);
}

int ispunct(int a1)
{
  return __istype(a1, 0x2000u);
}

int isspace(int a1)
{
  return __istype(a1, 0x4000u);
}

int isupper(int a1)
{
  return __istype(a1, 0x8000u);
}

int isxdigit(int a1)
{
  return __isctype(a1, 0x10000);
}

int toascii(int a1)
{
  return a1 & 0x7F;
}

int tolower(int a1)
{
  return __tolower(a1);
}

int toupper(int a1)
{
  return __toupper(a1);
}

int digittoint(int a1)
{
  return __maskrune(a1, 0xFu);
}

int ishexnumber(int a1)
{
  return __istype(a1, 0x10000u);
}

int isideogram(int a1)
{
  return __istype(a1, 0x80000u);
}

int isnumber(int a1)
{
  return __istype(a1, 0x400u);
}

int isphonogram(int a1)
{
  return __istype(a1, 0x200000u);
}

int isrune(int a1)
{
  return __istype(a1, 0xFFFFFFF0);
}

int isspecial(int a1)
{
  return __istype(a1, 0x100000u);
}

int digittoint_l(int a1, locale_t a2)
{
  return __maskrune_l(a1, 0xFu, a2);
}

int isalnum_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x500u, a2);
}

int isalpha_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x100u, a2);
}

int isblank_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x20000u, a2);
}

int iscntrl_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x200u, a2);
}

int isdigit_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x400u, a2);
}

int isgraph_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x800u, a2);
}

int ishexnumber_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x10000u, a2);
}

int isideogram_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x80000u, a2);
}

int islower_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x1000u, a2);
}

int isnumber_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x400u, a2);
}

int isphonogram_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x200000u, a2);
}

int isprint_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x40000u, a2);
}

int ispunct_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x2000u, a2);
}

int isrune_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0xFFFFFFF0, a2);
}

int isspace_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x4000u, a2);
}

int isspecial_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x100000u, a2);
}

int isupper_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x8000u, a2);
}

int isxdigit_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x10000u, a2);
}

int tolower_l(int a1, locale_t a2)
{
  return __tolower_l(a1, a2);
}

int toupper_l(int a1, locale_t a2)
{
  return __toupper_l(a1, a2);
}

void bcopy(const void *a1, void *a2, size_t a3)
{
}

int iswalnum(wint_t a1)
{
  return __istype(a1, 0x500u);
}

int iswalpha(wint_t a1)
{
  return __istype(a1, 0x100u);
}

int iswcntrl(wint_t a1)
{
  return __istype(a1, 0x200u);
}

int iswctype(wint_t a1, wctype_t a2)
{
  return __istype(a1, a2);
}

int iswdigit(wint_t a1)
{
  return __isctype(a1, 1024);
}

int iswgraph(wint_t a1)
{
  return __istype(a1, 0x800u);
}

int iswlower(wint_t a1)
{
  return __istype(a1, 0x1000u);
}

int iswprint(wint_t a1)
{
  return __istype(a1, 0x40000u);
}

int iswpunct(wint_t a1)
{
  return __istype(a1, 0x2000u);
}

int iswspace(wint_t a1)
{
  return __istype(a1, 0x4000u);
}

int iswupper(wint_t a1)
{
  return __istype(a1, 0x8000u);
}

int iswxdigit(wint_t a1)
{
  return __isctype(a1, 0x10000);
}

wint_t towlower(wint_t a1)
{
  return __tolower(a1);
}

wint_t towupper(wint_t a1)
{
  return __toupper(a1);
}

int iswalnum_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x500u, a2);
}

int iswalpha_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x100u, a2);
}

int iswcntrl_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x200u, a2);
}

int iswctype_l(wint_t a1, wctype_t a2, locale_t a3)
{
  return __istype_l(a1, a2, a3);
}

int iswdigit_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x400u, a2);
}

int iswgraph_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x800u, a2);
}

int iswlower_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x1000u, a2);
}

int iswprint_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x40000u, a2);
}

int iswpunct_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x2000u, a2);
}

int iswspace_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x4000u, a2);
}

int iswupper_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x8000u, a2);
}

int iswxdigit_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x10000u, a2);
}

wint_t towlower_l(wint_t a1, locale_t a2)
{
  return __tolower_l(a1, a2);
}

wint_t towupper_l(wint_t a1, locale_t a2)
{
  return __toupper_l(a1, a2);
}

int iswblank(wint_t a1)
{
  return __istype(a1, 0x20000u);
}

wint_t iswascii(wint_t a1)
{
  return (a1 & 0xFFFFFF80) == 0;
}

wint_t iswhexnumber(wint_t a1)
{
  return __istype(a1, 0x10000u);
}

wint_t iswideogram(wint_t a1)
{
  return __istype(a1, 0x80000u);
}

wint_t iswnumber(wint_t a1)
{
  return __istype(a1, 0x400u);
}

wint_t iswphonogram(wint_t a1)
{
  return __istype(a1, 0x200000u);
}

wint_t iswrune(wint_t a1)
{
  return __istype(a1, 0xFFFFFFF0);
}

wint_t iswspecial(wint_t a1)
{
  return __istype(a1, 0x100000u);
}

int iswblank_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x20000u, a2);
}

wint_t iswhexnumber_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x10000u, a2);
}

wint_t iswideogram_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x80000u, a2);
}

wint_t iswnumber_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x400u, a2);
}

wint_t iswphonogram_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x200000u, a2);
}

wint_t iswrune_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0xFFFFFFF0, a2);
}

wint_t iswspecial_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x100000u, a2);
}

locale_t duplocale(locale_t a1)
{
  if (a1)
  {
    BOOL v3 = 1;
    if (a1 != (locale_t)-1) {
      BOOL v3 = *((void *)a1 + 163) == 0x786C6F63616C6530;
    }
    if (v3) {
      int v1 = 0;
    }
    else {
      int v1 = -1;
    }
    int v5 = v1;
  }
  else
  {
    int v5 = 0;
  }
  if (v5 >= 0) {
    return (locale_t)_duplocale((os_unfair_lock_s *)a1);
  }
  *__error() = 22;
  return 0;
}

char *_duplocale(os_unfair_lock_s *a1)
{
  __dst = (char *)malloc_type_malloc();
  if (!__dst) {
    return 0;
  }
  *(_DWORD *)__dst = 1;
  *((void *)__dst + 1) = destruct_locale;
  *((_DWORD *)__dst + 324) = 0;
  if (a1)
  {
    if (a1 == (os_unfair_lock_s *)-1)
    {
      a1 = (os_unfair_lock_s *)__global_locale;
    }
    else if (a1 == (os_unfair_lock_s *)&__c_locale)
    {
      memcpy(__dst, &__c_locale, 0x5C0uLL);
      *(_DWORD *)__dst = 1;
      *((void *)__dst + 1) = destruct_locale;
      *((_DWORD *)__dst + 324) = 0;
      return __dst;
    }
  }
  else
  {
    int v7 = (os_unfair_lock_s *)pthread_getspecific(__locale_key);
    if (v7) {
      uint64_t v2 = v7;
    }
    else {
      uint64_t v2 = (os_unfair_lock_s *)__global_locale;
    }
    a1 = v2;
  }
  os_unfair_lock_lock(a1 + 324);
  memcpy(__dst + 1304, &a1[326], 0xA8uLL);
  os_unfair_lock_unlock(a1 + 324);
  bzero(__dst + 16, 0x508uLL);
  for (int i = 0; i < 6; ++i)
    xlocale_retain(*(atomic_uint **)&__dst[8 * i + 1320]);
  xlocale_retain(*((atomic_uint **)__dst + 171));
  return __dst;
}

int freelocale(locale_t a1)
{
  if (!a1) {
    goto LABEL_11;
  }
  BOOL v3 = 1;
  if (a1 != (locale_t)-1) {
    BOOL v3 = *((void *)a1 + 163) == 0x786C6F63616C6530;
  }
  int v1 = v3 ? 0 : -1;
  if (v1 < 0 || a1 == (locale_t)__global_locale || a1 == (locale_t)-1 || a1 == (locale_t)&__c_locale)
  {
LABEL_11:
    *__error() = 22;
    return -1;
  }
  else
  {
    xlocale_release((uint64_t)a1);
    return 0;
  }
}

uint64_t xlocale_release(uint64_t result)
{
  if (result && atomic_fetch_add((atomic_uint *volatile)result, 0xFFFFFFFF) == 1)
  {
    if (*(void *)(result + 8)) {
      return (*(uint64_t (**)(uint64_t))(result + 8))(result);
    }
  }
  return result;
}

locale_t newlocale(int a1, const char *a2, locale_t a3)
{
  uint64_t v10 = a1 & 0x3F;
  BOOL v9 = 0;
  if (a2)
  {
    BOOL v8 = 1;
    if (strlen(a2) <= 0x1F)
    {
      if (*a2 != 46 || (BOOL v8 = 1, a2[1]) && (a2[1] != 46 || (BOOL v8 = 1, a2[2]))) {
        BOOL v8 = strchr(a2, 47) != 0;
      }
    }
    BOOL v9 = v8;
  }
  if (v9) {
    int v3 = -1;
  }
  else {
    int v3 = 0;
  }
  if (v3 < 0) {
    goto LABEL_13;
  }
  if (v10 == 63)
  {
    size_t v4 = _duplocale((os_unfair_lock_s *)&__c_locale);
  }
  else
  {
    if (a3)
    {
      BOOL v7 = 1;
      if (a3 != (locale_t)-1) {
        BOOL v7 = *((void *)a3 + 163) == 0x786C6F63616C6530;
      }
      if (v7) {
        int v5 = 0;
      }
      else {
        int v5 = -1;
      }
      int v15 = v5;
    }
    else
    {
      int v15 = 0;
    }
    if (v15 < 0)
    {
LABEL_13:
      *__error() = 22;
      return 0;
    }
    size_t v4 = _duplocale((os_unfair_lock_s *)a3);
  }
  int v11 = (_xlocale *)v4;
  if (!v4) {
    return 0;
  }
  if (!v10 || v10 == 63 && !a2) {
    return (locale_t)v4;
  }
  if ((int)_modifylocale((uint64_t)v4, v10, (char *)a2) >= 0) {
    return v11;
  }
  freelocale(v11);
  return 0;
}

uint64_t _modifylocale(uint64_t a1, int a2, char *a3)
{
  int v32 = a3;
  locale_env = 0;
  if (!a3) {
    int v32 = (char *)&C;
  }
  int v30 = __detect_path_locale();
  if (!v30)
  {
    if (*v32) {
      locale_env = v32;
    }
    for (int i = 1; ; i *= 2)
    {
      if (i > 32) {
        return 0;
      }
      if ((i & a2) != 0)
      {
        if (i <= 1)
        {
          uint64_t v4 = (i - 1);
          char v3 = 0;
        }
        else
        {
          uint64_t v4 = (i - 1);
          char v3 = 1;
        }
        if ((v3 & 1) == 0)
        {
          switch(v4)
          {
            case 0:
              if (!*v32)
              {
                locale_env = (char *)__get_locale_env(1);
                BOOL v28 = 0;
                if (locale_env)
                {
                  BOOL v27 = 1;
                  if (strlen(locale_env) <= 0x1F)
                  {
                    if (*locale_env != 46
                      || (BOOL v27 = 1, locale_env[1]) && (locale_env[1] != 46 || (BOOL v27 = 1, locale_env[2])))
                    {
                      BOOL v27 = strchr(locale_env, 47) != 0;
                    }
                  }
                  BOOL v28 = v27;
                }
                int v5 = v28 ? -1 : 0;
                if (v5 < 0) {
                  goto LABEL_129;
                }
              }
              if (*(unsigned char *)(*(void *)(a1 + 1320) + 64)) {
                regmatch_t v26 = (const char *)&C;
              }
              else {
                regmatch_t v26 = (const char *)(*(void *)(a1 + 1320) + 16);
              }
              if (strcmp(locale_env, v26) && __collate_load_tables(locale_env, (void *)a1) == -1) {
                return -1;
              }
              xlocale_fill_name(*(void *)(a1 + 1320), locale_env);
              break;
            case 1:
              if (!*v32)
              {
                locale_env = (char *)__get_locale_env(2);
                BOOL v25 = 0;
                if (locale_env)
                {
                  BOOL v24 = 1;
                  if (strlen(locale_env) <= 0x1F)
                  {
                    if (*locale_env != 46
                      || (BOOL v24 = 1, locale_env[1]) && (locale_env[1] != 46 || (BOOL v24 = 1, locale_env[2])))
                    {
                      BOOL v24 = strchr(locale_env, 47) != 0;
                    }
                  }
                  BOOL v25 = v24;
                }
                int v6 = v25 ? -1 : 0;
                if (v6 < 0) {
                  goto LABEL_129;
                }
              }
              if (!strcmp(locale_env, (const char *)(*(void *)(a1 + 1328) + 16))) {
                continue;
              }
              int v30 = __setrunelocale(locale_env, (void *)a1);
              if (v30) {
                goto LABEL_4;
              }
              xlocale_fill_name(*(void *)(a1 + 1328), locale_env);
              if (*(unsigned char *)(a1 + 1318) == 1) {
                *(unsigned char *)(a1 + 1318) = 0;
              }
              continue;
            case 2:
            case 4:
            case 5:
            case 6:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
              continue;
            case 3:
              if (!*v32)
              {
                locale_env = (char *)__get_locale_env(6);
                BOOL v23 = 0;
                if (locale_env)
                {
                  BOOL v22 = 1;
                  if (strlen(locale_env) <= 0x1F)
                  {
                    if (*locale_env != 46
                      || (BOOL v22 = 1, locale_env[1]) && (locale_env[1] != 46 || (BOOL v22 = 1, locale_env[2])))
                    {
                      BOOL v22 = strchr(locale_env, 47) != 0;
                    }
                  }
                  BOOL v23 = v22;
                }
                int v7 = v23 ? -1 : 0;
                if (v7 < 0) {
                  goto LABEL_129;
                }
              }
              if (*(unsigned char *)(a1 + 1312)) {
                BOOL v21 = *(const char **)(*(void *)(a1 + 1360) + 64);
              }
              else {
                BOOL v21 = (const char *)&C;
              }
              if (strcmp(locale_env, v21) && __messages_load_locale(locale_env, a1) == -1) {
                return -1;
              }
              xlocale_fill_name(*(void *)(a1 + 1360), locale_env);
              continue;
            case 7:
              if (!*v32)
              {
                locale_env = (char *)__get_locale_env(3);
                BOOL v20 = 0;
                if (locale_env)
                {
                  BOOL v19 = 1;
                  if (strlen(locale_env) <= 0x1F)
                  {
                    if (*locale_env != 46
                      || (BOOL v19 = 1, locale_env[1]) && (locale_env[1] != 46 || (BOOL v19 = 1, locale_env[2])))
                    {
                      BOOL v19 = strchr(locale_env, 47) != 0;
                    }
                  }
                  BOOL v20 = v19;
                }
                int v8 = v20 ? -1 : 0;
                if (v8 < 0) {
                  goto LABEL_129;
                }
              }
              if (*(unsigned char *)(a1 + 1313)) {
                int v18 = *(const char **)(*(void *)(a1 + 1336) + 64);
              }
              else {
                int v18 = (const char *)&C;
              }
              if (strcmp(locale_env, v18) && __monetary_load_locale(locale_env, a1) == -1) {
                return -1;
              }
              xlocale_fill_name(*(void *)(a1 + 1336), locale_env);
              continue;
            case 15:
              if (!*v32)
              {
                locale_env = (char *)__get_locale_env(4);
                BOOL v17 = 0;
                if (locale_env)
                {
                  BOOL v16 = 1;
                  if (strlen(locale_env) <= 0x1F)
                  {
                    if (*locale_env != 46
                      || (BOOL v16 = 1, locale_env[1]) && (locale_env[1] != 46 || (BOOL v16 = 1, locale_env[2])))
                    {
                      BOOL v16 = strchr(locale_env, 47) != 0;
                    }
                  }
                  BOOL v17 = v16;
                }
                int v9 = v17 ? -1 : 0;
                if (v9 < 0) {
                  goto LABEL_129;
                }
              }
              if (*(unsigned char *)(a1 + 1314)) {
                int v15 = *(const char **)(*(void *)(a1 + 1344) + 64);
              }
              else {
                int v15 = (const char *)&C;
              }
              if (!strcmp(locale_env, v15)) {
                continue;
              }
              if (__numeric_load_locale(locale_env, a1) == -1) {
                return -1;
              }
              xlocale_fill_name(*(void *)(a1 + 1344), locale_env);
              *(unsigned char *)(a1 + 1318) = 0;
              xlocale_release(*(void *)(a1 + 1368));
              *(void *)(a1 + 1368) = 0;
              continue;
            case 31:
              if (!*v32)
              {
                locale_env = (char *)__get_locale_env(5);
                BOOL v14 = 0;
                if (locale_env)
                {
                  BOOL v13 = 1;
                  if (strlen(locale_env) <= 0x1F)
                  {
                    if (*locale_env != 46
                      || (BOOL v13 = 1, locale_env[1]) && (locale_env[1] != 46 || (BOOL v13 = 1, locale_env[2])))
                    {
                      BOOL v13 = strchr(locale_env, 47) != 0;
                    }
                  }
                  BOOL v14 = v13;
                }
                int v10 = v14 ? -1 : 0;
                if (v10 < 0)
                {
LABEL_129:
                  *__error() = 22;
                  return -1;
                }
              }
              if (*(unsigned char *)(a1 + 1315)) {
                unsigned int v12 = *(const char **)(*(void *)(a1 + 1352) + 64);
              }
              else {
                unsigned int v12 = (const char *)&C;
              }
              if (strcmp(locale_env, v12) && __time_load_locale(locale_env, a1) == -1) {
                return -1;
              }
              xlocale_fill_name(*(void *)(a1 + 1352), locale_env);
              continue;
            default:
              JUMPOUT(0);
          }
        }
      }
    }
  }
LABEL_4:
  *__error() = v30;
  return -1;
}

uint64_t __numeric_ctype(uint64_t a1)
{
  int v3 = *(unsigned __int8 *)(a1 + 1318);
  if (*(unsigned char *)(a1 + 1318))
  {
    if (v3 == 1)
    {
      return a1;
    }
    else if (v3 == 2)
    {
      return *(void *)(a1 + 1368);
    }
    else
    {
      return a1;
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 1314)) {
      uint64_t v2 = *(const char **)(*(void *)(a1 + 1344) + 64);
    }
    else {
      uint64_t v2 = (const char *)&C;
    }
    if (!strcmp((const char *)(*(void *)(a1 + 1328) + 16), v2))
    {
      *(unsigned char *)(a1 + 1318) = 1;
      return a1;
    }
    else
    {
      *(void *)(a1 + 1368) = newlocale(2, v2, (locale_t)&__c_locale);
      if (*(void *)(a1 + 1368))
      {
        *(unsigned char *)(a1 + 1318) = 2;
        return *(void *)(a1 + 1368);
      }
      else
      {
        *(unsigned char *)(a1 + 1318) = 1;
        return a1;
      }
    }
  }
}

const char *__cdecl querylocale(int a1, locale_t a2)
{
  locale_t v9 = a2;
  if (a2)
  {
    BOOL v5 = 1;
    if (a2 != (locale_t)-1) {
      BOOL v5 = *((void *)a2 + 163) == 0x786C6F63616C6530;
    }
    if (v5) {
      int v2 = 0;
    }
    else {
      int v2 = -1;
    }
    int v12 = v2;
  }
  else
  {
    int v12 = 0;
  }
  if (v12 < 0 || (a1 & 0x3F) == 0) {
    goto LABEL_20;
  }
  if (a2)
  {
    if (a2 == (locale_t)-1) {
      locale_t v9 = (locale_t)__global_locale;
    }
  }
  else
  {
    BOOL v13 = pthread_getspecific(__locale_key);
    uint64_t v4 = (_xlocale *)(v13 ? v13 : __global_locale);
    locale_t v9 = v4;
  }
  int v7 = ffs(a1) - 1;
  if ((unint64_t)v7 < 6)
  {
    int v8 = querylocale_mapping[v7];
    if (v8 >= 6) {
      __assert_rtn("querylocale", "xlocale.c", 437, "type < XLC_LAST");
    }
    os_unfair_lock_lock((os_unfair_lock_t)v9 + 324);
    if (*((void *)v9 + v8 + 165)) {
      int v6 = (const char *)(*((void *)v9 + v8 + 165) + 16);
    }
    else {
      int v6 = (const char *)&C;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v9 + 324);
    return v6;
  }
  else
  {
LABEL_20:
    *__error() = 22;
    return 0;
  }
}

locale_t uselocale(locale_t a1)
{
  int v6 = a1;
  if (a1)
  {
    BOOL v4 = 1;
    if (a1 != (locale_t)-1) {
      BOOL v4 = *((void *)a1 + 163) == 0x786C6F63616C6530;
    }
    if (v4) {
      int v1 = 0;
    }
    else {
      int v1 = -1;
    }
    if (v1 < 0)
    {
      *__error() = 22;
      return 0;
    }
    if (a1 == (locale_t)-1 || a1 == (locale_t)__global_locale) {
      int v6 = 0;
    }
    xlocale_retain(v6);
    BOOL v5 = (_xlocale *)pthread_getspecific(__locale_key);
    pthread_setspecific(__locale_key, v6);
    xlocale_release((uint64_t)v5);
  }
  else
  {
    BOOL v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  if (v5) {
    return v5;
  }
  else {
    return (locale_t)-1;
  }
}

atomic_uint *xlocale_retain(atomic_uint *a1)
{
  if (!a1) {
    return 0;
  }
  atomic_fetch_add(a1, 1u);
  return a1;
}

int ___mb_cur_max(void)
{
  if (v0) {
    char v1 = 1;
  }
  else {
    char v1 = 0;
  }
  if (v1)
  {
    BOOL v4 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v5 = __locale_key;
    BOOL v4 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
  }
  if (v4) {
    int v3 = v4;
  }
  else {
    int v3 = __global_locale;
  }
  return *(_DWORD *)(v3[166] + 64);
}

int ___mb_cur_max_l(locale_t a1)
{
  locale_t v2 = a1;
  if (a1)
  {
    if (a1 == (locale_t)-1) {
      locale_t v2 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v2 = (locale_t)&__c_locale;
  }
  return *(_DWORD *)(*((void *)v2 + 166) + 64);
}

uint64_t __xlocale_init()
{
  if (__locale_key == -1)
  {
    __locale_key = 10;
    return pthread_key_init_np();
  }
  return result;
}

uint64_t __xlocale_release(uint64_t a1)
{
  return xlocale_release(a1);
}

void destruct_locale(uint64_t *a1)
{
  for (int i = 0; i < 6; ++i)
    xlocale_release(a1[i + 165]);
  xlocale_release(a1[171]);
  free(a1);
}

size_t xlocale_fill_name(size_t result, const char *a2)
{
  if (result) {
    return strlcpy((char *)(result + 16), a2, 0x20uLL);
  }
  return result;
}

const char *_subsystem_init()
{
  uint64_t result = (const char *)_simple_getenv();
  if (result)
  {
    subsystem_root_path = (uint64_t)result;
    uint64_t result = (const char *)strnlen(result, 0x400uLL);
    subsystem_root_path_leunsigned __int8 n = (uint64_t)result;
  }
  return result;
}

uint64_t open_with_subsystem(const char *a1, __int16 a2)
{
  if ((a2 & 0x200) != 0)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    int v4 = open_NOCANCEL();
    if (v4 < 0 && *__error() == 2 && subsystem_root_path)
    {
      next_subsystem_root_path = (const char *)subsystem_root_path;
      while (1)
      {
        next_subsystem_root_path = extract_next_subsystem_root_path(v7, 1024, next_subsystem_root_path);
        if (!append_path_to_subsystem_root(v7, 0x400uLL, a1)) {
          break;
        }
        int v4 = open_NOCANCEL();
        if (v4 < 0)
        {
          __error();
          if (next_subsystem_root_path) {
            continue;
          }
        }
        return v4;
      }
      *__error() = 63;
    }
    return v4;
  }
}

const char *extract_next_subsystem_root_path(void *a1, uint64_t a2, const char *a3)
{
  char v6 = 0;
  __unsigned __int8 n = strlen(a3);
  if (!a2) {
    return a3;
  }
  int v4 = memchr(a3, 58, __n);
  if (v4)
  {
    __unsigned __int8 n = v4 - a3;
    char v6 = 1;
  }
  if (__n > a2 - 1) {
    return 0;
  }
  memcpy(a1, a3, __n);
  *((unsigned char *)a1 + __n) = 0;
  if (v6) {
    return v4 + 1;
  }
  else {
    return 0;
  }
}

BOOL append_path_to_subsystem_root(char *a1, size_t a2, const char *a3)
{
  return strlcat(a1, a3, a2) < a2;
}

uint64_t stat_with_subsystem(const char *a1, stat *a2)
{
  int v4 = stat(a1, a2);
  if (v4 < 0 && *__error() == 2 && subsystem_root_path)
  {
    next_subsystem_root_path = (const char *)subsystem_root_path;
    while (1)
    {
      next_subsystem_root_path = extract_next_subsystem_root_path(v7, 1024, next_subsystem_root_path);
      if (!append_path_to_subsystem_root(v7, 0x400uLL, a1)) {
        break;
      }
      int v4 = stat(v7, a2);
      if (v4 < 0)
      {
        __error();
        if (next_subsystem_root_path) {
          continue;
        }
      }
      return v4;
    }
    *__error() = 63;
  }
  return v4;
}

tm *__cdecl getdate(const char *a1)
{
  BOOL v25 = a1;
  BOOL v24 = 0;
  BOOL v23 = 0;
  time_t v22 = 0;
  BOOL v21 = 0;
  int v20 = 0;
  int i = 0;
  int v18 = 0;
  unsigned int v17 = 0;
  unsigned int v16 = 0;
  int v15 = 0;
  int v14 = 0;
  int v13 = 0;
  int v12 = 0;
  memset(&__b, 0, sizeof(__b));
  __filename = getenv("DATEMSK");
  if (!__filename || !*__filename)
  {
    getdate_err = 1;
    return 0;
  }
  int v15 = *__error();
  BOOL v21 = fopen(__filename, "r");
  if (!v21)
  {
    getdate_err = 2;
    int v8 = v15;
    *__error() = v8;
    return 0;
  }
  int v1 = fileno(v21);
  if (fstat(v1, &__b) < 0)
  {
    getdate_err = 3;
    goto LABEL_90;
  }
  if ((__b.st_mode & 0xF000) != 0x8000)
  {
    getdate_err = 4;
    goto LABEL_90;
  }
  int v20 = 1024;
  int v12 = (char *)malloc_type_malloc();
  if (!v12)
  {
    getdate_err = 6;
    goto LABEL_90;
  }
  for (int i = 0; ; int i = 0)
  {
    while (fgets(&v12[i], v20 - i, v21))
    {
      int v18 = strlen(v12);
      if (v18 != v20 - 1 || v12[v18 - 1] == 10) {
        goto LABEL_24;
      }
      v20 += 1024;
      locale_t v9 = (char *)malloc_type_realloc();
      if (!v9)
      {
        getdate_err = 6;
        goto LABEL_89;
      }
      int v12 = v9;
      int i = v18;
    }
    if (ferror(v21))
    {
      getdate_err = 5;
      goto LABEL_89;
    }
    if (!i)
    {
      getdate_err = 7;
      goto LABEL_89;
    }
    int v18 = strlen(v12);
LABEL_24:
    if (v12[v18 - 1] == 10) {
      v12[v18 - 1] = 0;
    }
    memcpy(&getdate_tm, &tmundef, 0x38uLL);
    if (strptime(v25, v12, (tm *)&getdate_tm)) {
      break;
    }
  }
  time(&v22);
  BOOL v24 = localtime(&v22);
  unsigned int v16 = 0;
  unsigned int v17 = 0;
  if (getdate_tm != -1) {
    v16 |= 1u;
  }
  if (dword_EA674 != -1) {
    v16 |= 2u;
  }
  if (dword_EA678 != -1) {
    v16 |= 4u;
  }
  if (dword_EA67C != -1) {
    v17 |= 1u;
  }
  if (dword_EA680 != -1) {
    v17 |= 2u;
  }
  if (dword_EA684 != -1) {
    v17 |= 4u;
  }
  int v14 = dword_EA688;
  if (v16)
  {
    uint64_t v3 = v16;
    char v2 = 1;
  }
  else
  {
    uint64_t v3 = 0;
    char v2 = 0;
  }
  if ((v2 & 1) == 0)
  {
    switch(v3)
    {
      case 0:
        getdate_tunsigned int m = v24->tm_sec;
        dword_EA674 = v24->tm_min;
        dword_EA678 = v24->tm_hour;
        break;
      case 1:
        dword_EA678 = v24->tm_hour;
        dword_EA674 = v24->tm_min;
        if (getdate_tm < v24->tm_sec) {
          ++dword_EA674;
        }
        break;
      case 2:
        dword_EA678 = v24->tm_hour;
        if (dword_EA674 < v24->tm_min) {
          ++dword_EA678;
        }
        getdate_tunsigned int m = 0;
        break;
      case 3:
        dword_EA678 = v24->tm_hour;
        if (60 * dword_EA674 + getdate_tm < 60 * v24->tm_min + v24->tm_sec) {
          ++dword_EA678;
        }
        break;
      case 4:
        dword_EA674 = 0;
        getdate_tunsigned int m = 0;
        break;
      case 5:
        dword_EA674 = 0;
        break;
      case 6:
        getdate_tunsigned int m = 0;
        break;
      default:
LABEL_92:
        JUMPOUT(0);
    }
  }
  if (v17)
  {
    uint64_t v5 = v17;
    char v4 = 1;
  }
  else
  {
    uint64_t v5 = 0;
    char v4 = 0;
  }
  if ((v4 & 1) == 0)
  {
    switch(v5)
    {
      case 0:
        dword_EA67C = v24->tm_mday;
        if (dword_EA678 < v24->tm_hour) {
          ++dword_EA67C;
        }
        dword_EA680 = v24->tm_mon;
        dword_EA684 = v24->tm_year;
        break;
      case 1:
        dword_EA684 = v24->tm_year;
        dword_EA680 = v24->tm_mon;
        if (dword_EA67C < v24->tm_mday) {
          ++dword_EA680;
        }
        break;
      case 2:
      case 3:
        dword_EA684 = v24->tm_year;
        if (dword_EA680 < v24->tm_mon) {
          ++dword_EA684;
        }
        if ((v17 & 1) == 0) {
          dword_EA67C = 1;
        }
        break;
      case 4:
      case 6:
        if ((v17 & 2) == 0) {
          dword_EA680 = 0;
        }
        dword_EA67C = 1;
        break;
      case 5:
        dword_EA680 = v24->tm_mon;
        if (dword_EA67C < v24->tm_mday) {
          ++dword_EA680;
        }
        break;
      default:
        goto LABEL_92;
    }
  }
  dword_EA688 = v24->tm_wday;
  qword_EA698 = v24->tm_gmtoff;
  dword_EA690 = -1;
  int v13 = dword_EA680;
  if (mktime((tm *)&getdate_tm) == -1)
  {
    getdate_err = 8;
  }
  else if ((v17 & 2) == 0 || dword_EA680 == v13)
  {
    if (v14 == -1
      || v17 == 7
      || (dword_EA67C += v14 - dword_EA688 + (v14 - dword_EA688 < 0 ? 7 : 0), mktime((tm *)&getdate_tm) != -1))
    {
      BOOL v23 = (tm *)&getdate_tm;
    }
    else
    {
      getdate_err = 8;
    }
  }
  else
  {
    getdate_err = 8;
  }
LABEL_89:
  free(v12);
LABEL_90:
  fclose(v21);
  int v7 = v15;
  *__error() = v7;
  return v23;
}

uint64_t _st_get_timezone()
{
  return timezone;
}

uint64_t _st_set_timezone(uint64_t result)
{
  timezone = result;
  return result;
}

int asxprintf(char **__ret, printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_start(va, __format);
  return _vasprintf(0, (pthread_rwlock_t *)__domain, __ret, __loc, (char *)__format, (int *)va);
}

int dxprintf(int __fd, printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_start(va, __format);
  return _vdprintf(0, (pthread_rwlock_t *)__domain, __fd, __loc, (char *)__format, (int *)va);
}

int fxprintf(FILE *__stream, printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_start(va, __format);
  return __xvprintf(0, (uint64_t)__domain, (uint64_t)__stream, (uint64_t)__loc, (uint64_t)__format, (uint64_t)va);
}

int sxprintf(char *__str, size_t __size, printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_start(va, __format);
  return _vsnprintf(0, (pthread_rwlock_t *)__domain, __str, __size, __loc, (char *)__format, (int *)va);
}

int xprintf(printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_start(va, __format);
  return __xvprintf(0, (uint64_t)__domain, (uint64_t)__stdoutp, (uint64_t)__loc, (uint64_t)__format, (uint64_t)va);
}

int vasxprintf(char **__ret, printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return _vasprintf(0, (pthread_rwlock_t *)__domain, __ret, __loc, (char *)__format, (int *)__ap);
}

int vdxprintf(int __fd, printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return _vdprintf(0, (pthread_rwlock_t *)__domain, __fd, __loc, (char *)__format, (int *)__ap);
}

int vfxprintf(FILE *__stream, printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return __xvprintf(0, (uint64_t)__domain, (uint64_t)__stream, (uint64_t)__loc, (uint64_t)__format, (uint64_t)__ap);
}

int vsxprintf(char *__str, size_t __size, printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return _vsnprintf(0, (pthread_rwlock_t *)__domain, __str, __size, __loc, (char *)__format, (int *)__ap);
}

int vxprintf(printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return __xvprintf(0, (uint64_t)__domain, (uint64_t)__stdoutp, (uint64_t)__loc, (uint64_t)__format, (uint64_t)__ap);
}

void free_printf_comp(printf_comp_t __pc)
{
  if (__pc)
  {
    xlocale_release(*((void *)__pc + 10));
    free(*((void **)__pc + 11));
    free(*((void **)__pc + 13));
    free(*((void **)__pc + 14));
    pthread_mutex_destroy((pthread_mutex_t *)__pc);
    free(__pc);
  }
}

printf_comp_t new_printf_comp(printf_domain_t __domain, locale_t __loc, const char *__fmt)
{
  if (__domain)
  {
    strlen(__fmt);
    stat __b = (char *)malloc_type_malloc();
    if (__b)
    {
      memset(__b, 0, 0x80uLL);
      memset(v13, 0, sizeof(v13));
      v13[0] = 850045863;
      memcpy(__b, v13, 0x40uLL);
      *((void *)__b + 8) = __b + 128;
      strcpy(*((char **)__b + 8), __fmt);
      if (__loc)
      {
        if (__loc == (locale_t)-1) {
          __loc = (locale_t)__global_locale;
        }
        xlocale_retain(__loc);
      }
      else
      {
        int v12 = (_xlocale *)pthread_getspecific(__locale_key);
        if (v12) {
          char v4 = v12;
        }
        else {
          char v4 = (_xlocale *)__global_locale;
        }
        __loc = v4;
        xlocale_retain(v4);
      }
      *((void *)__b + 10) = __loc;
      pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
      pthread_rwlock_rdlock((pthread_rwlock_t *)__domain);
      int v7 = __printf_comp((uint64_t)__b, (uint64_t)__domain);
      int v6 = *__error();
      pthread_rwlock_unlock((pthread_rwlock_t *)__domain);
      if (v7 >= 0)
      {
        return (printf_comp_t)__b;
      }
      else
      {
        xlocale_release((uint64_t)__loc);
        pthread_mutex_destroy((pthread_mutex_t *)__b);
        free(__b);
        *__error() = v6;
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

void *__xprintf_domain_init()
{
  xprintf_domain_default = malloc_type_calloc();
  if (!xprintf_domain_default) {
    abort_report_np((uint64_t)"%s:%s:%u: No memory");
  }
  memset(__b, 0, sizeof(__b));
  __b[0] = 766030772;
  uint64_t result = memcpy((void *)xprintf_domain_default, __b, 0xC8uLL);
  for (int i = "#$'*+,-.0123456789:;L_hjlqtvz"; *i; ++i)
    *(unsigned char *)(xprintf_domain_default + 200 + *i - 33) = 3;
  int v12 = &_printf_tbl_defaults_fbsd;
  for (int j = 6; j > 0; --j)
  {
    for (unsigned int k = *v12; *k; ++k)
    {
      *(unsigned char *)(xprintf_domain_default + 200 + *k - 33) = 2;
      uint64_t v3 = xprintf_domain_default + 296 + 24 * (*k - 33);
      char v4 = 0;
      if (v12[2]) {
        char v4 = v12[2];
      }
      *((void *)&v9 + 1) = v4;
      *(void *)&long long v9 = v12[1];
      *(_OWORD *)uint64_t v3 = v9;
      *(void *)(v3 + 16) = 0;
    }
    v12 += 3;
  }
  int v8 = &_printf_tbl_defaults_glibc;
  for (int m = 1; m > 0; --m)
  {
    for (unsigned __int8 n = *v8; *n; ++n)
    {
      *(unsigned char *)(xprintf_domain_default + 200 + *n - 33) = 1;
      uint64_t v1 = xprintf_domain_default + 296 + 24 * (*n - 33);
      char v2 = 0;
      if (v8[2]) {
        char v2 = v8[2];
      }
      *((void *)&v5 + 1) = v2;
      *(void *)&long long v5 = v8[1];
      *(_OWORD *)uint64_t v1 = v5;
      *(void *)(v1 + 16) = 0;
    }
    v8 += 3;
  }
  return result;
}

printf_domain_t copy_printf_domain(printf_domain_t __domain)
{
  if (__domain)
  {
    __dst = (void *)malloc_type_malloc();
    if (__dst)
    {
      pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
      pthread_rwlock_rdlock((pthread_rwlock_t *)__domain);
      memcpy(__dst, __domain, 0x9F8uLL);
      pthread_rwlock_unlock((pthread_rwlock_t *)__domain);
      memset(__b, 0, sizeof(__b));
      __b[0] = 766030772;
      memcpy(__dst, __b, 0xC8uLL);
      return (printf_domain_t)__dst;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

void free_printf_domain(printf_domain_t __domain)
{
  if (__domain)
  {
    pthread_rwlock_destroy((pthread_rwlock_t *)__domain);
    free(__domain);
  }
}

printf_domain_t new_printf_domain(void)
{
  pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
  __dst = (void *)malloc_type_malloc();
  if (!__dst) {
    return 0;
  }
  memcpy(__dst, (const void *)xprintf_domain_default, 0x9F8uLL);
  return (printf_domain_t)__dst;
}

int register_printf_domain_function(printf_domain_t __domain, int __spec, printf_function *__render, printf_arginfo_function *__arginfo, void *__context)
{
  *((void *)&v8 + 1) = __render;
  *(void *)&long long v8 = __arginfo;
  pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
  if (__domain
    && __spec >= 33
    && __spec <= 126
    && (pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init),
        *((unsigned char *)__domain + __spec + 167) != 3))
  {
    pthread_rwlock_wrlock((pthread_rwlock_t *)__domain);
    if (*((void *)&v8 + 1) && (void)v8)
    {
      *((unsigned char *)__domain + __spec + 167) = 1;
      int v6 = (char *)__domain + 24 * __spec - 496;
      *(_OWORD *)int v6 = v8;
      *((void *)v6 + 2) = __context;
    }
    else
    {
      *((unsigned char *)__domain + __spec + 167) = 0;
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)__domain);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t register_printf_domain_render(pthread_rwlock_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  *((void *)&v6 + 1) = a3;
  *(void *)&long long v6 = a4;
  pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
  if (a1
    && a2 >= 33
    && a2 <= 126
    && (pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init), a1->__opaque[a2 + 159] != 3))
  {
    pthread_rwlock_wrlock(a1);
    if (*((void *)&v6 + 1) && (void)v6)
    {
      a1->__opaque[a2 + 159] = 2;
      uint64_t v5 = (uint64_t)&a1[-2] + 24 * a2 - 96;
      *(_OWORD *)uint64_t v5 = v6;
      *(void *)(v5 + 16) = 0;
    }
    else
    {
      a1->__opaque[a2 + 159] = 0;
    }
    pthread_rwlock_unlock(a1);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int register_printf_domain_render_std(printf_domain_t __domain, const char *__specs)
{
  while (1)
  {
    if (!*__specs) {
      return 0;
    }
    unsigned int v2 = *__specs;
    BOOL v3 = v2 > 0x48;
    uint64_t v4 = v2 - 72;
    if (v3)
    {
      uint64_t v6 = v4;
      char v5 = 1;
    }
    else
    {
      uint64_t v6 = v4;
      char v5 = 0;
    }
    if (v5) {
      break;
    }
    switch(v6)
    {
      case 0:
        int v8 = register_printf_domain_render((pthread_rwlock_t *)__domain, *__specs, (uint64_t)__printf_render_hexdump, (uint64_t)__printf_arginfo_hexdump);
        goto LABEL_13;
      case 1:
      case 2:
      case 3:
      case 4:
      case 6:
      case 7:
      case 8:
      case 10:
      case 11:
      case 13:
        goto LABEL_12;
      case 5:
        int v8 = register_printf_domain_render((pthread_rwlock_t *)__domain, *__specs, (uint64_t)__printf_render_errno, (uint64_t)__printf_arginfo_errno);
        goto LABEL_13;
      case 9:
        int v8 = register_printf_domain_render((pthread_rwlock_t *)__domain, *__specs, (uint64_t)__printf_render_quote, (uint64_t)__printf_arginfo_quote);
        goto LABEL_13;
      case 12:
        int v8 = register_printf_domain_render((pthread_rwlock_t *)__domain, *__specs, (uint64_t)__printf_render_time, (uint64_t)__printf_arginfo_time);
        goto LABEL_13;
      case 14:
        int v8 = register_printf_domain_render((pthread_rwlock_t *)__domain, *__specs, (uint64_t)__printf_render_vis, (uint64_t)__printf_arginfo_vis);
LABEL_13:
        if (v8 < 0) {
          return v8;
        }
        ++__specs;
        break;
      default:
        JUMPOUT(0);
    }
  }
LABEL_12:
  *__error() = 22;
  return -1;
}

int asxprintf_exec(char **__ret, printf_comp_t __pc, ...)
{
  va_start(va, __pc);
  if (__pc) {
    return _vasprintf((uint64_t)__pc, 0, __ret, 0, 0, (int *)va);
  }
  *__error() = 22;
  return -1;
}

int dxprintf_exec(int __fd, printf_comp_t __pc, ...)
{
  va_start(va, __pc);
  if (__pc) {
    return _vdprintf((uint64_t)__pc, 0, __fd, 0, 0, (int *)va);
  }
  *__error() = 22;
  return -1;
}

int fxprintf_exec(FILE *__stream, printf_comp_t __pc, ...)
{
  va_start(va, __pc);
  if (__pc) {
    return __xvprintf((uint64_t)__pc, 0, (uint64_t)__stream, 0, 0, (uint64_t)va);
  }
  *__error() = 22;
  return -1;
}

int sxprintf_exec(char *__str, size_t __size, printf_comp_t __pc, ...)
{
  va_start(va, __pc);
  if (__pc) {
    return _vsnprintf((uint64_t)__pc, 0, __str, __size, 0, 0, (int *)va);
  }
  *__error() = 22;
  return -1;
}

int xprintf_exec(printf_comp_t __pc, ...)
{
  va_start(va, __pc);
  if (__pc) {
    return __xvprintf((uint64_t)__pc, 0, (uint64_t)__stdoutp, 0, 0, (uint64_t)va);
  }
  *__error() = 22;
  return -1;
}

int vasxprintf_exec(char **__ret, printf_comp_t __pc, va_list __ap)
{
  if (__pc) {
    return _vasprintf((uint64_t)__pc, 0, __ret, 0, 0, (int *)__ap);
  }
  *__error() = 22;
  return -1;
}

int vdxprintf_exec(int __fd, printf_comp_t __pc, va_list __ap)
{
  if (__pc) {
    return _vdprintf((uint64_t)__pc, 0, __fd, 0, 0, (int *)__ap);
  }
  *__error() = 22;
  return -1;
}

int vfxprintf_exec(FILE *__stream, printf_comp_t __pc, va_list __ap)
{
  if (__pc) {
    return __xvprintf((uint64_t)__pc, 0, (uint64_t)__stream, 0, 0, (uint64_t)__ap);
  }
  *__error() = 22;
  return -1;
}

int vsxprintf_exec(char *__str, size_t __size, printf_comp_t __pc, va_list __ap)
{
  if (__pc) {
    return _vsnprintf((uint64_t)__pc, 0, __str, __size, 0, 0, (int *)__ap);
  }
  *__error() = 22;
  return -1;
}

int vxprintf_exec(printf_comp_t __pc, va_list __ap)
{
  if (__pc) {
    return __xvprintf((uint64_t)__pc, 0, (uint64_t)__stdoutp, 0, 0, (uint64_t)__ap);
  }
  *__error() = 22;
  return -1;
}

int login_tty(int a1)
{
  int v2 = a1;
  setsid();
  if (ioctl(v2, 0x20007461uLL, 0) == -1) {
    return -1;
  }
  dup2(v2, 0);
  dup2(v2, 1);
  dup2(v2, 2);
  if (v2 > 2) {
    close_NOCANCEL();
  }
  return 0;
}

uint64_t _mkpath_np(const char *a1, mode_t a2, char **a3)
{
  return _mkpath(-2, a1, a2, a3);
}

uint64_t _mkpath(int a1, const char *a2, mode_t a3, char **a4)
{
  int v25 = a1;
  BOOL v24 = a2;
  mode_t v23 = a3;
  time_t v22 = a4;
  BOOL v21 = 0;
  int v20 = 0;
  BOOL v19 = 0;
  int v18 = 0;
  unsigned int v17 = 0;
  unsigned int v16 = 0;
  mode_t v15 = 0;
  unsigned int v14 = 0;
  int v13 = 0;
  int v13 = *__error();
  memset(&__b, 0, sizeof(__b));
  if (mkdirat(v25, v24, v23))
  {
    int v10 = *__error();
    switch(v10)
    {
      case 2:
        BOOL v21 = strdup(v24);
        if (v21)
        {
          BOOL v19 = &v21[strlen(v21) - 1];
          unsigned int v17 = v19;
          do
          {
            int v18 = v19;
            if (v19 - 1 > v21 && *v19 == 46 && *(v19 - 1) == 47) {
              v19 -= 2;
            }
            if (v19 > v21 && *v19 == 47) {
              --v19;
            }
          }
          while (v19 < v18);
          if (v19 >= v17 || (v19[1] = 0, v20 = strdup(v21), (BOOL v24 = v20) != 0))
          {
            if (mkdirat(v25, v24, v23))
            {
              while (1)
              {
                BOOL v19 = strrchr(v21, 47);
                if (!v19)
                {
                  unsigned int v14 = 2;
                  goto LABEL_67;
                }
                *BOOL v19 = 0;
                ++v16;
                if (!mkdirat(v25, v21, 0x1FFu))
                {
                  memset(&v11, 0, sizeof(v11));
                  if (fstatat(v25, v21, &v11, 0) == -1)
                  {
                    unsigned int v14 = 2;
                  }
                  else
                  {
                    if ((v11.st_mode & 0xC0) == 0xC0
                      || (mode_t v15 = v11.st_mode | 0xC0, fchmodat(v25, v21, v11.st_mode | 0xC0, 0) != -1))
                    {
                      if (v22)
                      {
                        uint64_t v6 = strdup(v21);
                        *time_t v22 = v6;
                      }
                      goto LABEL_54;
                    }
                    unsigned int v14 = 2;
                  }
                  goto LABEL_67;
                }
                if (*__error() == 17) {
                  break;
                }
                if (*__error() != 2) {
                  goto LABEL_8;
                }
              }
              if (fstatat(v25, v21, &__b, 0) || (__b.st_mode & 0xF000) != 0x4000)
              {
                unsigned int v14 = 20;
              }
              else
              {
                if (v22)
                {
                  int v7 = strdup(v21);
                  *time_t v22 = v7;
                }
LABEL_54:
                while (v16 > 1)
                {
                  BOOL v19 = strrchr(v21, 0);
                  *BOOL v19 = 47;
                  --v16;
                  if (mkdirat(v25, v21, 0x1FFu) == -1)
                  {
                    if (*__error() != 17)
                    {
                      unsigned int v14 = *__error();
                      goto LABEL_67;
                    }
                  }
                  else if (v15 && fchmodat(v25, v21, v15, 0) == -1)
                  {
                    unsigned int v14 = 2;
                    goto LABEL_67;
                  }
                }
                if (mkdirat(v25, v24, v23) == -1)
                {
                  unsigned int v14 = *__error();
                  if (*__error() == 17 && !fstatat(v25, v24, &__b, 0) && (__b.st_mode & 0xF000) != 0x4000) {
                    unsigned int v14 = 20;
                  }
                }
              }
            }
            else if (v22)
            {
              char v5 = strdup(v24);
              *time_t v22 = v5;
            }
          }
          else
          {
            unsigned int v14 = 12;
          }
        }
        else
        {
          unsigned int v14 = 12;
        }
        break;
      case 17:
        if (fstatat(v25, v24, &__b, 0))
        {
          unsigned int v14 = 5;
        }
        else if ((__b.st_mode & 0xF000) == 0x4000)
        {
          unsigned int v14 = 17;
        }
        else
        {
          unsigned int v14 = 20;
        }
        break;
      case 21:
        unsigned int v14 = 17;
        break;
      default:
LABEL_8:
        unsigned int v14 = *__error();
        break;
    }
  }
  else if (v22)
  {
    uint64_t v4 = strdup(v24);
    *time_t v22 = v4;
  }
LABEL_67:
  free(v21);
  free(v20);
  int v9 = v13;
  *__error() = v9;
  return v14;
}

int mkpath_np(const char *path, mode_t omode)
{
  return _mkpath(-2, path, omode, 0);
}

int mkpathat_np(int dfd, const char *path, mode_t omode)
{
  return _mkpath(dfd, path, omode, 0);
}

int raise(int a1)
{
  uint64_t v1 = pthread_self();
  int v4 = pthread_kill(v1, a1);
  if (!v4) {
    return 0;
  }
  if (v4 == 45)
  {
    pid_t v2 = getpid();
    return kill(v2, a1);
  }
  else
  {
    *__error() = v4;
    return -1;
  }
}

void uuid_clear(uuid_t uu)
{
  *(void *)uu = 0;
  *((void *)uu + 1) = 0;
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v12 = uu1;
  stat v11 = (unsigned __int8 *)uu2;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uuid_unpack((unsigned __int8 *)uu1, (uint64_t)&v9);
  uuid_unpack(v11, (uint64_t)&v7);
  if (v9 == v7)
  {
    if (WORD2(v9) == WORD2(v7))
    {
      if (HIWORD(v9) == HIWORD(v7))
      {
        if ((unsigned __int16)v10 == (unsigned __int16)v8)
        {
          return memcmp((char *)&v10 + 2, (char *)&v8 + 2, 6uLL);
        }
        else if ((unsigned __int16)v10 < (int)(unsigned __int16)v8)
        {
          return -1;
        }
        else
        {
          return 1;
        }
      }
      else if (HIWORD(v9) < (int)HIWORD(v7))
      {
        return -1;
      }
      else
      {
        return 1;
      }
    }
    else if (WORD2(v9) < (int)WORD2(v7))
    {
      return -1;
    }
    else
    {
      return 1;
    }
  }
  else if (v9 < v7)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
  for (int i = 0; i < 16; ++i)
  {
    const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v2 = src++;
    unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3 = dst++;
    *unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3 = *v2;
  }
}

void uuid_generate_time(uuid_t out)
{
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v4 = out;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  int v1 = 0;
  if (!uuid_generate_time_has_init)
  {
    if ((int)get_node_id(&uuid_generate_time_node_id) <= 0)
    {
      arc4random_buf(&uuid_generate_time_node_id, 6uLL);
      LOBYTE(uuid_generate_time_node_id) = uuid_generate_time_node_id | 1;
    }
    uuid_generate_time_has_init = 1;
  }
  get_clock(&v1, (int *)&v2, &v3);
  LOWORD(v3) = v3 | 0x8000;
  WORD2(v2) = v1;
  HIWORD(v2) = HIWORD(v1) & 0xFFF | 0x1000;
  *(_DWORD *)((char *)&v3 + 2) = uuid_generate_time_node_id;
  HIWORD(v3) = word_EA6B4;
  uuid_pack((int *)&v2, (uint64_t)v4);
}

uint64_t get_node_id(_DWORD *a1)
{
  uint64_t v10 = a1;
  memset(__dst, 0, sizeof(__dst));
  uint64_t __src = 0;
  memset(v7, 0, 12);
  int v9 = socket(2, 2, 0);
  if (v9 >= 0)
  {
    bzero(v12, 0x400uLL);
    LODWORD(v7[0]) = 1024;
    *(void *)((char *)v7 + 4) = v12;
    if (ioctl(v9, 0xC00C6924uLL, v7) >= 0)
    {
      int v6 = v7[0];
      for (int i = 0; i < v6; i += v3)
      {
        uint64_t __src = (char *)(*(void *)((char *)v7 + 4) + i);
        strncpy((char *)__dst, __src, 0x10uLL);
        if (__src[17] == 18 && __src[22] == 6)
        {
          if ((unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v4 = &__src[__src[21] + 24], *v4) && *v4 != 2
            || v4[1]
            || v4[2]
            || v4[3]
            || v4[4]
            || v4[5])
          {
            if (v10)
            {
              int v1 = v10;
              *uint64_t v10 = *(_DWORD *)v4;
              *((_WORD *)v1 + 2) = *((_WORD *)v4 + 2);
              close_NOCANCEL();
              return 1;
            }
          }
        }
        if ((unint64_t)__src[16] + 16 >= 0x20) {
          int v3 = __src[16] + 16;
        }
        else {
          int v3 = 32;
        }
      }
      close_NOCANCEL();
      return 0;
    }
    else
    {
      close_NOCANCEL();
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t get_clock(_DWORD *a1, int *a2, _WORD *a3)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  int v6 = a3;
  v5.tv_sec = 0;
  *(void *)&v5.tv_usec = 0;
  while (1)
  {
    gettimeofday(&v5, 0);
    if (!(void)get_clock_last && !DWORD2(get_clock_last))
    {
      arc4random_buf(&get_clock_clock_seq, 2uLL);
      get_clock_clock_seq &= 0x3FFFu;
      get_clock_last = (__int128)v5;
      *(void *)&get_clock_last = v5.tv_sec - 1;
    }
    if (v5.tv_sec < (uint64_t)get_clock_last
      || v5.tv_sec == (void)get_clock_last && v5.tv_usec < SDWORD2(get_clock_last))
    {
      get_clock_clock_seq = (get_clock_clock_seq + 1) & 0x3FFF;
      get_clock_adjustment = 0;
      get_clock_last = (__int128)v5;
      goto LABEL_14;
    }
    if (v5.tv_sec != (void)get_clock_last || v5.tv_usec != DWORD2(get_clock_last)) {
      break;
    }
    if (get_clock_adjustment < 10)
    {
      ++get_clock_adjustment;
      goto LABEL_14;
    }
  }
  get_clock_adjustment = 0;
  get_clock_last = (__int128)v5;
LABEL_14:
  int v4 = 10 * v5.tv_usec + get_clock_adjustment + 10000000 * LODWORD(v5.tv_sec) + 327237632;
  *uint64_t v8 = (unint64_t)(10 * v5.tv_usec + get_clock_adjustment + 10000000 * v5.tv_sec + 122192928000000000) >> 32;
  *uint64_t v7 = v4;
  *int v6 = get_clock_clock_seq;
  return 0;
}

void uuid_generate_random(uuid_t out)
{
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3 = out;
  __buf[0] = 0;
  __buf[1] = 0;
  uint64_t v1 = 0;
  uint64_t v2 = 0;
  arc4random_buf(__buf, 0x10uLL);
  uuid_unpack((unsigned __int8 *)__buf, (uint64_t)&v1);
  LOWORD(v2) = v2 & 0x3FFF | 0x8000;
  HIWORD(v1) = HIWORD(v1) & 0xFFF | 0x4000;
  uuid_pack((int *)&v1, (uint64_t)v3);
}

void uuid_generate(uuid_t out)
{
}

int uuid_is_null(const uuid_t uu)
{
  for (int i = 0; i < 16; ++i)
  {
    const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v1 = uu++;
    if (*v1) {
      return 0;
    }
  }
  return 1;
}

int *uuid_pack(int *result, uint64_t a2)
{
  unsigned int v2 = *result;
  *(unsigned char *)(a2 + 3) = *result;
  v2 >>= 8;
  *(unsigned char *)(a2 + 2) = v2;
  v2 >>= 8;
  *(unsigned char *)(a2 + 1) = v2;
  *(unsigned char *)a2 = BYTE1(v2);
  LOWORD(v2) = *((_WORD *)result + 2);
  *(unsigned char *)(a2 + 5) = v2;
  *(unsigned char *)(a2 + 4) = BYTE1(v2);
  LOWORD(v2) = *((_WORD *)result + 3);
  *(unsigned char *)(a2 + 7) = v2;
  *(unsigned char *)(a2 + 6) = BYTE1(v2);
  LOWORD(v2) = *((_WORD *)result + 4);
  *(unsigned char *)(a2 + 9) = v2;
  *(unsigned char *)(a2 + 8) = BYTE1(v2);
  *(_DWORD *)(a2 + 10) = *(int *)((char *)result + 10);
  *(_WORD *)(a2 + 14) = *((_WORD *)result + 7);
  return result;
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v12 = in;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v11 = uu;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  int i = 0;
  uint64_t v7 = 0;
  if (strlen(in) != 36) {
    return -1;
  }
  int i = 0;
  uint64_t v7 = v12;
  while (i <= 36)
  {
    if (i == 8 || i == 13 || i == 18 || i == 23)
    {
      if (*v7 != 45) {
        return -1;
      }
    }
    else if ((i != 36 || *v7) && !isxdigit(*v7))
    {
      return -1;
    }
    ++i;
    ++v7;
  }
  LODWORD(v9) = strtoul(v12, 0, 16);
  WORD2(v9) = strtoul(v12 + 9, 0, 16);
  HIWORD(v9) = strtoul(v12 + 14, 0, 16);
  LOWORD(v10) = strtoul(v12 + 19, 0, 16);
  uint64_t v7 = v12 + 24;
  __str[2] = 0;
  for (int i = 0; i < 6; ++i)
  {
    unsigned int v2 = (char *)v7++;
    __str[0] = *v2;
    unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3 = (char *)v7++;
    __str[1] = *v3;
    char v4 = strtoul(__str, 0, 16);
    *((unsigned char *)&v10 + i + 2) = v4;
  }
  uuid_pack((int *)&v9, (uint64_t)v11);
  return 0;
}

unsigned __int8 *uuid_unpack(unsigned __int8 *result, uint64_t a2)
{
  *(_DWORD *)a2 = result[3] | ((result[2] | ((result[1] | (*result << 8)) << 8)) << 8);
  *(_WORD *)(a2 + 4) = _byteswap_ushort(*((_WORD *)result + 2));
  *(_WORD *)(a2 + 6) = _byteswap_ushort(*((_WORD *)result + 3));
  *(_WORD *)(a2 + 8) = _byteswap_ushort(*((_WORD *)result + 4));
  *(_DWORD *)(a2 + 10) = *(_DWORD *)(result + 10);
  *(_WORD *)(a2 + 14) = *((_WORD *)result + 7);
  return result;
}

void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
{
}

unsigned __int8 *uuid_unparse_x(unsigned __int8 *result, unsigned char *a2, uint64_t a3)
{
  uint64_t v8 = result;
  for (int i = 0; (unint64_t)i < 0x10; ++i)
  {
    if (i == 4 || i == 6 || i == 8 || i == 10)
    {
      unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3 = a2++;
      *unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3 = 45;
    }
    *a2 = *(unsigned char *)(a3 + ((int)*v8 >> 4));
    char v4 = v8++;
    char v5 = *(unsigned char *)(a3 + (*v4 & 0xF));
    int v6 = a2 + 1;
    a2 += 2;
    *int v6 = v5;
  }
  *a2 = 0;
  return result;
}

void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
{
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
}

pid_t tcgetsid(int a1)
{
  v2[1] = a1;
  v2[0] = 0;
  if (ioctl(a1, 0x40047463uLL, v2) >= 0) {
    return v2[0];
  }
  else {
    return -1;
  }
}

uint64_t _libc_initializer(void *a1, uint64_t a2, const char **a3, uint64_t *a4)
{
  _program_vars_init(a4);
  _libc_fork_init(a1);
  __confstr_init((uint64_t)a1);
  __atexit_init();
  uint64_t inited = _init_clock_port();
  _arc4_fork_child(inited);
  __xlocale_init();
  __guard_setup(a3);
  char v5 = _subsystem_init();
  return _arc4_fork_child(v5);
}

uint64_t __libc_init(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, const char **a5)
{
  __b[11] = a2;
  __b[10] = a3;
  __b[9] = a4;
  __b[0] = 1;
  __b[1] = a2;
  __b[2] = a3;
  __b[3] = a4;
  memset(&__b[4], 0, 32);
  return _libc_initializer(__b, 0, a5, a1);
}

void _libc_fork_prepare()
{
}

void _libc_fork_parent()
{
}

void _libc_fork_child(uint64_t a1)
{
  qword_E9898 = (uint64_t)"crashed on child side of fork pre-exec";
  _arc4_fork_child(a1);
  _init_clock_port();
  __environ_lock_fork_child();
  _locale_lock_fork_child();
}

char ***_NSGetArgv(void)
{
  return (char ***)NXArgv_pointer;
}

int *_NSGetArgc(void)
{
  return (int *)NXArgc_pointer;
}

char ***_NSGetEnviron(void)
{
  return (char ***)environ_pointer;
}

char **_NSGetProgname(void)
{
  return (char **)__progname_pointer;
}

mach_header_64 *_NSGetMachExecuteHeader(void)
{
  return (mach_header_64 *)_mh_execute_header_pointer;
}

uint64_t *_program_vars_init(uint64_t *result)
{
  NXArgv_pointer = result[2];
  NXArgc_pointer = result[1];
  environ_pointer = result[3];
  __progname_pointer = result[4];
  _mh_execute_header_pointer = *result;
  return result;
}

void *_libc_fork_init(void *result)
{
  if (*result < 2uLL)
  {
    _libSystem_atfork_prepare = (_UNKNOWN *)result[1];
    _libSystem_atfork_parent = (_UNKNOWN *)result[2];
    _libSystem_atfork_child = (_UNKNOWN *)result[3];
  }
  else
  {
    _libSystem_atfork_prepare_unsigned int v2 = (_UNKNOWN *)result[5];
    _libSystem_atfork_parent_unsigned int v2 = (_UNKNOWN *)result[6];
    _libSystem_atfork_child_unsigned int v2 = (_UNKNOWN *)result[7];
  }
  return result;
}

pid_t fork(void)
{
  if (_libSystem_atfork_prepare_v2) {
    _libSystem_atfork_prepare_v2(0);
  }
  else {
    _libSystem_atfork_prepare();
  }
  pid_t v1 = __fork();
  if (v1 == -1)
  {
    if (_libSystem_atfork_parent_v2) {
      _libSystem_atfork_parent_v2(0);
    }
    else {
      _libSystem_atfork_parent();
    }
    return -1;
  }
  else if (v1)
  {
    if (_libSystem_atfork_parent_v2) {
      _libSystem_atfork_parent_v2(0);
    }
    else {
      _libSystem_atfork_parent();
    }
    return v1;
  }
  else
  {
    if (_libSystem_atfork_child_v2) {
      _libSystem_atfork_child_v2(0);
    }
    else {
      _libSystem_atfork_child();
    }
    return 0;
  }
}

pid_t vfork(void)
{
  if (_libSystem_atfork_prepare_v2) {
    _libSystem_atfork_prepare_v2(1);
  }
  else {
    ((void (*)())_libSystem_atfork_prepare)();
  }
  pid_t v1 = __fork();
  if (v1 == -1)
  {
    if (_libSystem_atfork_parent_v2) {
      _libSystem_atfork_parent_v2(1);
    }
    else {
      _libSystem_atfork_parent();
    }
    return -1;
  }
  else if (v1)
  {
    if (_libSystem_atfork_parent_v2) {
      _libSystem_atfork_parent_v2(1);
    }
    else {
      _libSystem_atfork_parent();
    }
    return v1;
  }
  else
  {
    if (_libSystem_atfork_child_v2) {
      _libSystem_atfork_child_v2(1);
    }
    else {
      _libSystem_atfork_child();
    }
    return 0;
  }
}

int gettimeofday(timeval *a1, void *a2)
{
  uint64_t v7 = a1;
  int v6 = a2;
  char v5 = a2;
  v4[0] = 0;
  v4[1] = 0;
  if (!a1)
  {
    if (!v5) {
      return 0;
    }
    uint64_t v7 = (timeval *)v4;
  }
  if (__commpage_gettimeofday() && (int)__gettimeofday() < 0) {
    return -1;
  }
  if (v5)
  {
    if (!gettimeofday_validtz)
    {
      unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3 = localtime(&v7->tv_sec);
      dword_EA738 = v3->tm_isdst;
      gettimeofday_cached_tz = -v3->tm_gmtoff / 60 + 60 * v3->tm_isdst;
      gettimeofday_validtz = 1;
    }
    v5[1] = dword_EA738;
    *char v5 = gettimeofday_cached_tz;
  }
  return 0;
}

int posix_spawnp(pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  uint64_t v33 = a1;
  int v32 = a2;
  uint64_t v31 = a3;
  int v30 = a4;
  char *const *__attribute__((__org_arrdim(0,0))) v29 = __argv;
  char *const *__attribute__((__org_arrdim(0,0))) v28 = __envp;
  BOOL v27 = 0;
  regmatch_t v26 = 0;
  int v25 = 0;
  BOOL v24 = 0;
  mode_t v23 = 0;
  int v22 = 0;
  int v21 = 0;
  int i = 0;
  int v19 = 0;
  int v18 = 0;
  memset(&v17, 0, sizeof(v17));
  BOOL v27 = getenv("PATH");
  if (!v27) {
    BOOL v27 = "/usr/bin:/bin";
  }
  if (!strchr(v32, 47))
  {
    regmatch_t v26 = v35;
    if (!*v32) {
      return 2;
    }
    size_t v6 = strlen(v27);
    unsigned int v16 = &v11[-((v6 + 16) & 0xFFFFFFFFFFFFFFF0)];
    bzero(v16, v6 + 1);
    int v25 = v16;
    if (v16)
    {
      strcpy(v25, v27);
      goto LABEL_10;
    }
    return 12;
  }
  regmatch_t v26 = v32;
  int v25 = 0;
  while (1)
  {
    int v19 = posix_spawn(v33, v26, v31, v30, v29, v28);
    int v14 = v19;
    if (v19 == 2) {
      goto LABEL_10;
    }
    if (v14 == 7) {
      return v19;
    }
    if (v14 == 8) {
      break;
    }
    if (v14 == 12) {
      return v19;
    }
    if (v14 != 20)
    {
      if (v14 == 26) {
        return v19;
      }
      if (v14 != 63 && v14 != 62 && stat(v26, &v17) == 0)
      {
        if (v19 != 13) {
          return v19;
        }
        int v18 = 1;
      }
    }
LABEL_10:
    BOOL v24 = strsep(&v25, ":");
    if (!v24)
    {
      if (v18) {
        return 13;
      }
      else {
        return 2;
      }
    }
    if (*v24)
    {
      int v22 = strlen(v24);
    }
    else
    {
      BOOL v24 = ".";
      int v22 = 1;
    }
    int v21 = strlen(v32);
    if ((unint64_t)(v22 + v21 + 2) > 0x400) {
      return 63;
    }
    mode_t v15 = v35;
    bcopy(v24, v35, v22);
    uint64_t v7 = v15;
    v15[v22] = 47;
    bcopy(v32, &v7[v22 + 1], v21);
    v15[v22 + 1 + v21] = 0;
  }
  for (int i = 0; v29[i]; ++i)
    ;
  if (i + 2 >= 3) {
    int v13 = i + 2;
  }
  else {
    int v13 = 3;
  }
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v12 = &v11[-((8 * v13 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v12, 8 * v13);
  mode_t v23 = (char **)v12;
  if (v12)
  {
    if (i <= 0)
    {
      *mode_t v23 = "sh";
      v23[1] = (char *)v26;
      v23[2] = 0;
    }
    else
    {
      *mode_t v23 = *v29;
      v23[1] = (char *)v26;
      bcopy(v29 + 1, v23 + 2, 8 * i);
    }
    return posix_spawn(v33, "/bin/sh", v31, v30, v23, v28);
  }
  return v19;
}

int settimeofday(const timeval *a1, const timezone *a2)
{
  size_t v6 = a1;
  char v5 = a2;
  int v4 = __settimeofday();
  if (v6)
  {
    unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3 = 0;
    asprintf(&v3, "settimeofday({%#lx,%#x}) == %d", v6->tv_sec, v6->tv_usec, v4);
    _simple_asl_log();
    free(v3);
  }
  return v4;
}

int sigaction(int a1, const sigaction *a2, sigaction *a3)
{
  return __platform_sigaction();
}

uint64_t _sigaction_nobind(int a1, const sigaction *a2, sigaction *a3)
{
  return sigaction(a1, a2, a3);
}

char *__cdecl stpcpy(char *__dst, const char *__src)
{
  size_t v3 = strlen(__src);
  memcpy(__dst, __src, v3 + 1);
  return &__dst[v3];
}

char *__cdecl stpncpy(char *__dst, const char *__src, size_t __n)
{
  size_t v4 = strnlen(__src, __n);
  if (v4 >= __n)
  {
    memcpy(__dst, __src, __n);
    return &__dst[__n];
  }
  else
  {
    memcpy(__dst, __src, v4);
    bzero(&__dst[v4], __n - v4);
    return &__dst[v4];
  }
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  size_t v4 = strlen(__s1);
  size_t v3 = strlen(__s2);
  memcpy(&__s1[v4], __s2, v3 + 1);
  return __s1;
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  size_t v6 = strlen(__s1);
  size_t v5 = strnlen(__s2, __n);
  if (v5 >= __n) {
    size_t v4 = __n;
  }
  else {
    size_t v4 = v5;
  }
  memcpy(&__s1[v6], __s2, v4);
  __s1[v6 + v4] = 0;
  return __s1;
}

int sync_volume_np(const char *a1, int a2)
{
  uint64_t v7 = a1;
  int v6 = a2;
  int v5 = 0;
  if (a2) {
    v5 |= 1u;
  }
  if ((v6 & 2) != 0) {
    v5 |= 2u;
  }
  int v4 = *__error();
  if (fsctl(v7, 0x80044101uLL, &v5, 0) == -1) {
    int v3 = *__error();
  }
  else {
    int v3 = 0;
  }
  *__error() = v4;
  return v3;
}

int fsync_volume_np(int a1, int a2)
{
  int v7 = a1;
  int v6 = a2;
  int v5 = 0;
  if (a2) {
    v5 |= 1u;
  }
  if ((v6 & 2) != 0) {
    v5 |= 2u;
  }
  int v4 = *__error();
  if (ffsctl(v7, 0x80004101uLL, &v5, 0) == -1) {
    int v3 = *__error();
  }
  else {
    int v3 = 0;
  }
  *__error() = v4;
  return v3;
}

void *libc_set_introspection_hooks(void *result, void *a2, unint64_t a3)
{
  int v5 = result;
  if (a3 < 8) {
    __assert_rtn("libc_set_introspection_hooks", "libc_hooks.c", 33, "size >= sizeof(libc_hooks_version)");
  }
  if (a2)
  {
    if (a3 < 0x28) {
      __assert_rtn("libc_set_introspection_hooks", "libc_hooks.c", 37, "size >= sizeof(libc_hooks)");
    }
    if (a3 > 0x28) {
      bzero(a2 + 200, a3 - 40);
    }
    uint64_t result = __copy_assignment_8_8_t0w8_pa0_28660_8_pa0_36689_16_pa0_31171_24_pa0_29245_32(a2, &libc_hooks);
  }
  if (v5)
  {
    if (!*v5) {
      __assert_rtn("libc_set_introspection_hooks", "libc_hooks.c", 50, "new_hooks->version >= libc_hooks_version");
    }
    if (a3 < 0x28) {
      __assert_rtn("libc_set_introspection_hooks", "libc_hooks.c", 54, "size >= sizeof(libc_hooks)");
    }
    uint64_t result = __copy_assignment_8_8_t0w8_pa0_28660_8_pa0_36689_16_pa0_31171_24_pa0_29245_32(&libc_hooks, v5);
    libc_hooks = 1;
  }
  return result;
}

void *__copy_assignment_8_8_t0w8_pa0_28660_8_pa0_36689_16_pa0_31171_24_pa0_29245_32(void *result, void *a2)
{
  void *result = *a2;
  uint64_t v5 = 0;
  if (a2[1]) {
    uint64_t v5 = a2[1];
  }
  result[1] = v5;
  uint64_t v4 = 0;
  if (a2[2]) {
    uint64_t v4 = a2[2];
  }
  result[2] = v4;
  uint64_t v3 = 0;
  if (a2[3]) {
    uint64_t v3 = a2[3];
  }
  result[3] = v3;
  uint64_t v2 = 0;
  if (a2[4]) {
    uint64_t v2 = a2[4];
  }
  result[4] = v2;
  return result;
}

int dirfd(DIR *dirp)
{
  if (dirp && dirp->__dd_fd >= 0) {
    return dirp->__dd_fd;
  }
  *__error() = 22;
  return -1;
}

uint64_t _os_log_redirect(uint64_t a1, uint64_t a2)
{
  char v4 = 0;
  log_redirect_func = (uint64_t (*)(uint64_t))_os_find_log_redirect_func();
  if (log_redirect_func) {
    char v4 = log_redirect_func(a2) & 1;
  }
  return v4 & 1;
}

BOOL _os_abort_on_assumes()
{
  if (getpid() == 1) {
    return getenv("OS_ASSUMES_FATAL_PID1") != 0;
  }
  else {
    return getenv("OS_ASSUMES_FATAL") != 0;
  }
}

size_t _os_get_build(char *a1, size_t a2)
{
  __dst = a1;
  size_t v4 = a2;
  *(void *)int v6 = 0x4100000001;
  size_t result = sysctl(v6, 2u, a1, &v4, 0, 0);
  if (!result && v4 == 1) {
    return strlcpy(__dst, "99Z999", a2);
  }
  return result;
}

uint64_t _os_find_log_redirect_func()
{
  return 0;
}

uint64_t creat_NOCANCEL()
{
  return __open_nocancel();
}

uint64_t gethostid(void)
{
  int v1 = 0;
  v4[0] = 1;
  v4[1] = 11;
  size_t v2 = 4;
  if (sysctl(v4, 2u, &v1, &v2, 0, 0) == -1) {
    return -1;
  }
  else {
    return v1;
  }
}

char *__cdecl getwd(char *a1)
{
  uint64_t v3 = getcwd(a1, 0x400uLL);
  if (v3) {
    return v3;
  }
  int v1 = __error();
  strerror_r(*v1, a1, 0x400uLL);
  return 0;
}

int killpg(pid_t a1, int a2)
{
  if (a1 != 1) {
    return __kill();
  }
  *__error() = 1;
  return -1;
}

void sethostid(uint64_t a1)
{
  uint64_t v1 = a1;
  v2[0] = 1;
  v2[1] = 11;
  sysctl(v2, 2u, 0, 0, &v1, 8uLL);
}

pid_t setpgrp(void)
{
  pid_t v2 = getpgrp();
  pid_t v1 = getpid();
  if (v2 != v1) {
    setpgid(v1, v1);
  }
  return v1;
}

int setrgid(gid_t a1)
{
  return setregid(a1, 0xFFFFFFFF);
}

int setruid(uid_t a1)
{
  return setreuid(a1, 0xFFFFFFFF);
}

uint64_t __bt_close(void *a1)
{
  uint64_t v3 = (void *)a1[7];
  if (*((void *)v3 + 4))
  {
    mpool_put(*(MPOOL **)v3, *((void **)v3 + 4), 0);
    *((void *)v3 + 4) = 0;
  }
  if (__bt_sync((uint64_t)a1, 0) == -1)
  {
    return -1;
  }
  else if (mpool_close(*(MPOOL **)v3) == -1)
  {
    return -1;
  }
  else
  {
    if (*((void *)v3 + 6))
    {
      free(*((void **)v3 + 6));
      *((void *)v3 + 7) = 0;
      *((void *)v3 + 6) = 0;
    }
    if (*((void *)v3 + 60))
    {
      free(*((void **)v3 + 60));
      *((void *)v3 + 61) = 0;
      *((void *)v3 + 60) = 0;
    }
    if (*((void *)v3 + 62))
    {
      free(*((void **)v3 + 62));
      *((void *)v3 + 63) = 0;
      *((void *)v3 + 62) = 0;
    }
    free(v3);
    free(a1);
    if (close_NOCANCEL()) {
      return -1;
    }
    else {
      return 0;
    }
  }
}

uint64_t __bt_sync(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (*(void *)(v4 + 32))
  {
    mpool_put(*(MPOOL **)v4, *(void **)(v4 + 32), 0);
    *(void *)(v4 + 32) = 0;
  }
  if (a2)
  {
    *__error() = 22;
    return -1;
  }
  else if ((*(_DWORD *)(v4 + 636) & 0x11) == 0 && (*(_DWORD *)(v4 + 636) & 4) != 0)
  {
    if ((*(_DWORD *)(v4 + 636) & 2) != 0 && bt_meta(v4) == -1)
    {
      return -1;
    }
    else
    {
      unsigned int v3 = mpool_sync(*(MPOOL **)v4);
      if (!v3) {
        *(_DWORD *)(v4 + 636) &= ~4u;
      }
      return v3;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t bt_meta(uint64_t a1)
{
  pid_t v2 = mpool_get(*(MPOOL **)a1, 0, 0);
  if (v2)
  {
    *(void *)&long long v3 = 0x300053162;
    DWORD2(v3) = *(_DWORD *)(a1 + 520);
    HIDWORD(v3) = *(_DWORD *)(a1 + 516);
    LODWORD(v4) = *(_DWORD *)(a1 + 616);
    HIDWORD(v4) = *(_DWORD *)(a1 + 636) & 0xA0;
    *(_OWORD *)pid_t v2 = v3;
    int v2[2] = v4;
    mpool_put(*(MPOOL **)a1, v2, 1u);
    return 0;
  }
  else
  {
    return -1;
  }
}

unsigned int *__bt_pgin(unsigned int *result, int a2, uint64_t a3)
{
  if ((result[159] & 8) != 0)
  {
    if (a2)
    {
      unsigned int v20 = *(_DWORD *)a3;
      *(unsigned char *)a3 = HIBYTE(*(_DWORD *)a3);
      *(unsigned char *)(a3 + 1) = BYTE2(v20);
      *(unsigned char *)(a3 + 2) = BYTE1(v20);
      *(unsigned char *)(a3 + 3) = v20;
      int v19 = *(_DWORD *)(a3 + 4);
      *(unsigned char *)(a3 + 4) = HIBYTE(v19);
      *(unsigned char *)(a3 + 5) = BYTE2(v19);
      *(unsigned char *)(a3 + 6) = BYTE1(v19);
      *(unsigned char *)(a3 + 7) = v19;
      int v18 = *(_DWORD *)(a3 + 8);
      *(unsigned char *)(a3 + 8) = HIBYTE(v18);
      *(unsigned char *)(a3 + 9) = BYTE2(v18);
      *(unsigned char *)(a3 + 10) = BYTE1(v18);
      *(unsigned char *)(a3 + 11) = v18;
      int v17 = *(_DWORD *)(a3 + 12);
      *(unsigned char *)(a3 + 12) = HIBYTE(v17);
      *(unsigned char *)(a3 + 13) = BYTE2(v17);
      *(unsigned char *)(a3 + 14) = BYTE1(v17);
      *(unsigned char *)(a3 + 15) = v17;
      __int16 v16 = *(_WORD *)(a3 + 16);
      *(unsigned char *)(a3 + 16) = HIBYTE(v16);
      *(unsigned char *)(a3 + 17) = v16;
      __int16 v15 = *(_WORD *)(a3 + 18);
      *(unsigned char *)(a3 + 18) = HIBYTE(v15);
      *(unsigned char *)(a3 + 19) = v15;
      unsigned __int16 v29 = ((unint64_t)*(unsigned __int16 *)(a3 + 16) - 20) / 2;
      if ((*(_DWORD *)(a3 + 12) & 0x1F) == 1)
      {
        for (unsigned __int16 i = 0; i < (int)v29; ++i)
        {
          __int16 v14 = *(_WORD *)(a3 + 20 + 2 * i);
          *(unsigned char *)(a3 + 20 + 2 * i) = HIBYTE(v14);
          *(unsigned char *)(a3 + 20 + 2 * i + 1) = v14;
          int v21 = (int *)(a3 + *(unsigned __int16 *)(a3 + 20 + 2 * i));
          unsigned int v13 = *v21;
          *(unsigned char *)int v21 = HIBYTE(*v21);
          *((unsigned char *)v21 + 1) = BYTE2(v13);
          *((unsigned char *)v21 + 2) = BYTE1(v13);
          *((unsigned char *)v21++ + 3) = v13;
          unsigned int v12 = *v21;
          *(unsigned char *)int v21 = HIBYTE(*v21);
          *((unsigned char *)v21 + 1) = BYTE2(v12);
          *((unsigned char *)v21 + 2) = BYTE1(v12);
          *((unsigned char *)v21 + 3) = v12;
          int v22 = v21 + 1;
          if ((*v22 & 2) != 0)
          {
            mode_t v23 = v22 + 1;
            int v11 = *(_DWORD *)v23;
            *mode_t v23 = HIBYTE(*(_DWORD *)v23);
            v23[1] = BYTE2(v11);
            v23[2] = BYTE1(v11);
            v23[3] = v11;
            v23 += 4;
            int v10 = *(_DWORD *)v23;
            *mode_t v23 = HIBYTE(*(_DWORD *)v23);
            v23[1] = BYTE2(v10);
            v23[2] = BYTE1(v10);
            v23[3] = v10;
          }
        }
      }
      else if ((*(_DWORD *)(a3 + 12) & 0x1F) == 2)
      {
        for (unsigned __int16 j = 0; j < (int)v29; ++j)
        {
          __int16 v9 = *(_WORD *)(a3 + 20 + 2 * j);
          *(unsigned char *)(a3 + 20 + 2 * j) = HIBYTE(v9);
          *(unsigned char *)(a3 + 20 + 2 * j + 1) = v9;
          BOOL v24 = (int *)(a3 + *(unsigned __int16 *)(a3 + 20 + 2 * j));
          unsigned int v8 = *v24;
          *(unsigned char *)BOOL v24 = HIBYTE(*v24);
          *((unsigned char *)v24 + 1) = BYTE2(v8);
          *((unsigned char *)v24 + 2) = BYTE1(v8);
          *((unsigned char *)v24++ + 3) = v8;
          unsigned int v7 = *v24;
          *(unsigned char *)BOOL v24 = HIBYTE(*v24);
          *((unsigned char *)v24 + 1) = BYTE2(v7);
          *((unsigned char *)v24 + 2) = BYTE1(v7);
          *((unsigned char *)v24 + 3) = v7;
          int v25 = (char *)(v24 + 1);
          char v28 = *v25;
          if ((*v25 & 3) != 0)
          {
            regmatch_t v26 = v25 + 1;
            if ((v28 & 2) != 0)
            {
              int v6 = *(_DWORD *)v26;
              *regmatch_t v26 = HIBYTE(*(_DWORD *)v26);
              v26[1] = BYTE2(v6);
              int v26[2] = BYTE1(v6);
              v26[3] = v6;
              v26 += 4;
              int v5 = *(_DWORD *)v26;
              *regmatch_t v26 = HIBYTE(*(_DWORD *)v26);
              v26[1] = BYTE2(v5);
              int v26[2] = BYTE1(v5);
              v26[3] = v5;
            }
            if (v28)
            {
              BOOL v27 = v26 + 4;
              int v4 = *(_DWORD *)v27;
              *BOOL v27 = HIBYTE(*(_DWORD *)v27);
              v27[1] = BYTE2(v4);
              v27[2] = BYTE1(v4);
              v27[3] = v4;
              v27 += 4;
              int v3 = *(_DWORD *)v27;
              *BOOL v27 = HIBYTE(*(_DWORD *)v27);
              v27[1] = BYTE2(v3);
              v27[2] = BYTE1(v3);
              v27[3] = v3;
            }
          }
        }
      }
    }
    else
    {
      return mswap((unsigned int *)a3);
    }
  }
  return result;
}

unsigned int *mswap(unsigned int *result)
{
  unsigned int v6 = *result;
  *(unsigned char *)size_t result = HIBYTE(*result);
  *((unsigned char *)result + 1) = BYTE2(v6);
  *((unsigned char *)result + 2) = BYTE1(v6);
  *((unsigned char *)result + 3) = v6;
  int v5 = result[1];
  *((unsigned char *)result + 4) = HIBYTE(v5);
  *((unsigned char *)result + 5) = BYTE2(v5);
  *((unsigned char *)result + 6) = BYTE1(v5);
  *((unsigned char *)result + 7) = v5;
  int v4 = result[2];
  *((unsigned char *)result + 8) = HIBYTE(v4);
  *((unsigned char *)result + 9) = BYTE2(v4);
  *((unsigned char *)result + 10) = BYTE1(v4);
  *((unsigned char *)result + 11) = v4;
  int v3 = result[3];
  *((unsigned char *)result + 12) = HIBYTE(v3);
  *((unsigned char *)result + 13) = BYTE2(v3);
  *((unsigned char *)result + 14) = BYTE1(v3);
  *((unsigned char *)result + 15) = v3;
  int v2 = result[4];
  *((unsigned char *)result + 16) = HIBYTE(v2);
  *((unsigned char *)result + 17) = BYTE2(v2);
  *((unsigned char *)result + 18) = BYTE1(v2);
  *((unsigned char *)result + 19) = v2;
  int v1 = result[5];
  *((unsigned char *)result + 20) = HIBYTE(v1);
  *((unsigned char *)result + 21) = BYTE2(v1);
  *((unsigned char *)result + 22) = BYTE1(v1);
  *((unsigned char *)result + 23) = v1;
  return result;
}

unsigned int *__bt_pgout(unsigned int *result, int a2, uint64_t a3)
{
  if ((result[159] & 8) != 0)
  {
    if (a2)
    {
      unsigned __int16 v29 = ((unint64_t)*(unsigned __int16 *)(a3 + 16) - 20) / 2;
      if ((*(_DWORD *)(a3 + 12) & 0x1F) == 1)
      {
        for (unsigned __int16 i = 0; i < (int)v29; ++i)
        {
          int v21 = (int *)(a3 + *(unsigned __int16 *)(a3 + 20 + 2 * i));
          unsigned int v20 = *v21;
          *(unsigned char *)int v21 = HIBYTE(*v21);
          *((unsigned char *)v21 + 1) = BYTE2(v20);
          *((unsigned char *)v21 + 2) = BYTE1(v20);
          *((unsigned char *)v21++ + 3) = v20;
          unsigned int v19 = *v21;
          *(unsigned char *)int v21 = HIBYTE(*v21);
          *((unsigned char *)v21 + 1) = BYTE2(v19);
          *((unsigned char *)v21 + 2) = BYTE1(v19);
          *((unsigned char *)v21 + 3) = v19;
          int v22 = v21 + 1;
          if ((*v22 & 2) != 0)
          {
            mode_t v23 = v22 + 1;
            int v18 = *(_DWORD *)v23;
            *mode_t v23 = HIBYTE(*(_DWORD *)v23);
            v23[1] = BYTE2(v18);
            v23[2] = BYTE1(v18);
            v23[3] = v18;
            v23 += 4;
            int v17 = *(_DWORD *)v23;
            *mode_t v23 = HIBYTE(*(_DWORD *)v23);
            v23[1] = BYTE2(v17);
            v23[2] = BYTE1(v17);
            v23[3] = v17;
          }
          __int16 v16 = *(_WORD *)(a3 + 20 + 2 * i);
          *(unsigned char *)(a3 + 20 + 2 * i) = HIBYTE(v16);
          *(unsigned char *)(a3 + 20 + 2 * i + 1) = v16;
        }
      }
      else if ((*(_DWORD *)(a3 + 12) & 0x1F) == 2)
      {
        for (unsigned __int16 j = 0; j < (int)v29; ++j)
        {
          BOOL v24 = (int *)(a3 + *(unsigned __int16 *)(a3 + 20 + 2 * j));
          unsigned int v15 = *v24;
          *(unsigned char *)BOOL v24 = HIBYTE(*v24);
          *((unsigned char *)v24 + 1) = BYTE2(v15);
          *((unsigned char *)v24 + 2) = BYTE1(v15);
          *((unsigned char *)v24++ + 3) = v15;
          unsigned int v14 = *v24;
          *(unsigned char *)BOOL v24 = HIBYTE(*v24);
          *((unsigned char *)v24 + 1) = BYTE2(v14);
          *((unsigned char *)v24 + 2) = BYTE1(v14);
          *((unsigned char *)v24 + 3) = v14;
          int v25 = (char *)(v24 + 1);
          char v28 = *v25;
          if ((*v25 & 3) != 0)
          {
            regmatch_t v26 = v25 + 1;
            if ((v28 & 2) != 0)
            {
              int v13 = *(_DWORD *)v26;
              *regmatch_t v26 = HIBYTE(*(_DWORD *)v26);
              v26[1] = BYTE2(v13);
              int v26[2] = BYTE1(v13);
              v26[3] = v13;
              v26 += 4;
              int v12 = *(_DWORD *)v26;
              *regmatch_t v26 = HIBYTE(*(_DWORD *)v26);
              v26[1] = BYTE2(v12);
              int v26[2] = BYTE1(v12);
              v26[3] = v12;
            }
            if (v28)
            {
              BOOL v27 = v26 + 4;
              int v11 = *(_DWORD *)v27;
              *BOOL v27 = HIBYTE(*(_DWORD *)v27);
              v27[1] = BYTE2(v11);
              v27[2] = BYTE1(v11);
              v27[3] = v11;
              v27 += 4;
              int v10 = *(_DWORD *)v27;
              *BOOL v27 = HIBYTE(*(_DWORD *)v27);
              v27[1] = BYTE2(v10);
              v27[2] = BYTE1(v10);
              v27[3] = v10;
            }
          }
          __int16 v9 = *(_WORD *)(a3 + 20 + 2 * j);
          *(unsigned char *)(a3 + 20 + 2 * j) = HIBYTE(v9);
          *(unsigned char *)(a3 + 20 + 2 * j + 1) = v9;
        }
      }
      unsigned int v8 = *(_DWORD *)a3;
      *(unsigned char *)a3 = HIBYTE(*(_DWORD *)a3);
      *(unsigned char *)(a3 + 1) = BYTE2(v8);
      *(unsigned char *)(a3 + 2) = BYTE1(v8);
      *(unsigned char *)(a3 + 3) = v8;
      int v7 = *(_DWORD *)(a3 + 4);
      *(unsigned char *)(a3 + 4) = HIBYTE(v7);
      *(unsigned char *)(a3 + 5) = BYTE2(v7);
      *(unsigned char *)(a3 + 6) = BYTE1(v7);
      *(unsigned char *)(a3 + 7) = v7;
      int v6 = *(_DWORD *)(a3 + 8);
      *(unsigned char *)(a3 + 8) = HIBYTE(v6);
      *(unsigned char *)(a3 + 9) = BYTE2(v6);
      *(unsigned char *)(a3 + 10) = BYTE1(v6);
      *(unsigned char *)(a3 + 11) = v6;
      int v5 = *(_DWORD *)(a3 + 12);
      *(unsigned char *)(a3 + 12) = HIBYTE(v5);
      *(unsigned char *)(a3 + 13) = BYTE2(v5);
      *(unsigned char *)(a3 + 14) = BYTE1(v5);
      *(unsigned char *)(a3 + 15) = v5;
      __int16 v4 = *(_WORD *)(a3 + 16);
      *(unsigned char *)(a3 + 16) = HIBYTE(v4);
      *(unsigned char *)(a3 + 17) = v4;
      __int16 v3 = *(_WORD *)(a3 + 18);
      *(unsigned char *)(a3 + 18) = HIBYTE(v3);
      *(unsigned char *)(a3 + 19) = v3;
    }
    else
    {
      return mswap((unsigned int *)a3);
    }
  }
  return result;
}

void *__bt_dump(uint64_t a1)
{
  uint64_t v6 = *(void *)(a1 + 56);
  if (*(_DWORD *)(v6 + 636)) {
    int v1 = "memory";
  }
  else {
    int v1 = "disk";
  }
  fprintf(__stderrp, "%s: pgsz %u", v1, *(_DWORD *)(v6 + 520));
  if ((*(_DWORD *)(v6 + 636) & 0x80) != 0) {
    fprintf(__stderrp, " keys %u", *(_DWORD *)(v6 + 616));
  }
  if (*(_DWORD *)(v6 + 636))
  {
    __int16 v3 = " flags (";
    if ((*(_DWORD *)(v6 + 636) & 0x200) != 0)
    {
      fprintf(__stderrp, "%s%s", " flags (", "FIXLEN");
      __int16 v3 = ", ";
    }
    if (*(_DWORD *)(v6 + 636))
    {
      fprintf(__stderrp, "%s%s", v3, "INMEM");
      __int16 v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 0x20) != 0)
    {
      fprintf(__stderrp, "%s%s", v3, "NODUPS");
      __int16 v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 0x10) != 0)
    {
      fprintf(__stderrp, "%s%s", v3, "RDONLY");
      __int16 v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 0x80) != 0)
    {
      fprintf(__stderrp, "%s%s", v3, "RECNO");
      __int16 v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 2) != 0) {
      fprintf(__stderrp, "%s%s", v3, "METADIRTY");
    }
    fprintf(__stderrp, ")\n");
  }
  for (pgno_t i = 1; ; ++i)
  {
    size_t result = mpool_get(*(MPOOL **)v6, i, 0);
    int v5 = result;
    if (!result) {
      break;
    }
    __bt_dpage((uint64_t)result);
    mpool_put(*(MPOOL **)v6, v5, 0);
  }
  return result;
}

uint64_t __bt_dpage(uint64_t a1)
{
  fprintf(__stderrp, "    page %u: (", *(_DWORD *)a1);
  int v7 = (const char *)&unk_D793D;
  if (*(_DWORD *)(a1 + 12))
  {
    fprintf(__stderrp, "%s%s", (const char *)&unk_D793D, "BINTERNAL");
    int v7 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 2) != 0)
  {
    fprintf(__stderrp, "%s%s", v7, "BLEAF");
    int v7 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 8) != 0)
  {
    fprintf(__stderrp, "%s%s", v7, "RINTERNAL");
    int v7 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 0x10) != 0)
  {
    fprintf(__stderrp, "%s%s", v7, "RLEAF");
    int v7 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 4) != 0)
  {
    fprintf(__stderrp, "%s%s", v7, "OVERFLOW");
    int v7 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 0x20) != 0) {
    fprintf(__stderrp, "%s%s", v7, "PRESERVE");
  }
  fprintf(__stderrp, ")\n");
  uint64_t result = fprintf(__stderrp, "\tprev %2u next %2u", *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
  if ((*(_DWORD *)(a1 + 12) & 4) == 0)
  {
    unsigned __int16 v8 = ((unint64_t)*(unsigned __int16 *)(a1 + 16) - 20) / 2;
    uint64_t result = fprintf(__stderrp, " lower %3d upper %3d nextind %d\n", *(unsigned __int16 *)(a1 + 16), *(unsigned __int16 *)(a1 + 18), v8);
    for (unsigned __int16 i = 0; i < (int)v8; ++i)
    {
      fprintf(__stderrp, "\t[%03d] %4d ", i, *(unsigned __int16 *)(a1 + 20 + 2 * i));
      unsigned int v2 = *(_DWORD *)(a1 + 12) & 0x1F;
      BOOL v3 = v2 > 1;
      uint64_t v4 = v2 - 1;
      if (v3)
      {
        uint64_t v6 = v4;
        char v5 = 1;
      }
      else
      {
        uint64_t v6 = v4;
        char v5 = 0;
      }
      if ((v5 & 1) == 0)
      {
        switch(v6)
        {
          case 0:
            int v13 = (const char *)(a1 + *(unsigned __int16 *)(a1 + 20 + 2 * i));
            fprintf(__stderrp, "size %03d pgno %03d", *(_DWORD *)v13, *((_DWORD *)v13 + 1));
            if ((v13[8] & 2) != 0)
            {
              fprintf(__stderrp, " (indirect)");
            }
            else if (*(_DWORD *)v13)
            {
              fprintf(__stderrp, " {%.*s}", *(_DWORD *)v13, v13 + 9);
            }
            break;
          case 1:
            int v12 = (unsigned int *)(a1 + *(unsigned __int16 *)(a1 + 20 + 2 * i));
            if ((v12[2] & 2) != 0)
            {
              fprintf(__stderrp, "big key page %u size %u/", *(unsigned int *)((char *)v12 + 9), *(unsigned int *)((char *)v12 + 13));
            }
            else if (*v12)
            {
              fprintf(__stderrp, "%.*s/", *v12, (const char *)v12 + 9);
            }
            if (v12[2])
            {
              fprintf(__stderrp, "big data page %u size %u", *(unsigned int *)((char *)v12 + *v12 + 9), *(unsigned int *)((char *)v12 + *v12 + 13));
            }
            else if (v12[1])
            {
              fprintf(__stderrp, "%.*s", v12[1], (const char *)v12 + *v12 + 9);
            }
            break;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
          case 7:
            int v11 = (_DWORD *)(a1 + *(unsigned __int16 *)(a1 + 20 + 2 * i));
            fprintf(__stderrp, "entries %03d pgno %03d", *v11, v11[1]);
            break;
          case 15:
            uint64_t v10 = a1 + *(unsigned __int16 *)(a1 + 20 + 2 * i);
            if (*(unsigned char *)(v10 + 4))
            {
              fprintf(__stderrp, "big data page %u size %u", *(_DWORD *)(v10 + 5), *(_DWORD *)(v10 + 9));
            }
            else if (*(_DWORD *)v10)
            {
              fprintf(__stderrp, "%.*s", *(_DWORD *)v10, (const char *)(v10 + 5));
            }
            break;
          default:
            JUMPOUT(0);
        }
      }
      uint64_t result = fprintf(__stderrp, "\n");
    }
  }
  return result;
}

uint64_t __bt_dmpage(_DWORD *a1)
{
  fprintf(__stderrp, "magic %x\n", *a1);
  fprintf(__stderrp, "version %u\n", a1[1]);
  fprintf(__stderrp, "psize %u\n", a1[2]);
  fprintf(__stderrp, "free %u\n", a1[3]);
  fprintf(__stderrp, "nrecs %u\n", a1[4]);
  uint64_t result = fprintf(__stderrp, "flags %u", a1[5]);
  if (a1[5])
  {
    unsigned int v2 = " (";
    if ((a1[5] & 0x20) != 0)
    {
      fprintf(__stderrp, "%s%s", " (", "NODUPS");
      unsigned int v2 = ", ";
    }
    if ((a1[5] & 0x80) != 0) {
      fprintf(__stderrp, "%s%s", v2, "RECNO");
    }
    return fprintf(__stderrp, ")");
  }
  return result;
}

void *__bt_dnpage(uint64_t a1, pgno_t a2)
{
  uint64_t v4 = *(MPOOL ***)(a1 + 56);
  uint64_t result = mpool_get(*v4, a2, 0);
  BOOL v3 = result;
  if (result)
  {
    __bt_dpage((uint64_t)result);
    return (void *)mpool_put(*v4, v3, 0);
  }
  return result;
}

uint64_t __bt_delete(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v10 = a1;
  uint64_t v9 = a2;
  int v8 = a3;
  int v7 = 0;
  uint64_t v6 = 0;
  char v5 = 0;
  int v7 = *(MPOOL ***)(a1 + 56);
  if (v7[4])
  {
    mpool_put(*v7, v7[4], 0);
    v7[4] = 0;
  }
  if ((*((_DWORD *)v7 + 159) & 0x10) != 0)
  {
    *__error() = 1;
    return -1;
  }
  else
  {
    if (v8)
    {
      if (v8 != 1 || (uint64_t v6 = v7 + 5, (*((unsigned char *)v7 + 68) & 8) == 0))
      {
        *__error() = 22;
        return -1;
      }
      if ((*((unsigned char *)v6 + 28) & 7) != 0) {
        return 1;
      }
      char v5 = mpool_get(*v7, *(_DWORD *)v6, 0);
      if (!v5) {
        return -1;
      }
      if (((unint64_t)*((unsigned __int16 *)v5 + 8) - 20) / 2 == 1
        && __bt_stkacq(v7, (pgno_t **)&v5, (pgno_t *)v7 + 10))
      {
        return -1;
      }
      unsigned int v4 = __bt_dleaf((uint64_t)v7, 0, (unsigned __int16 *)v5, *((unsigned __int16 *)v6 + 2));
      if (((unint64_t)*((unsigned __int16 *)v5 + 8) - 20) / 2 || v4)
      {
        mpool_put(*v7, v5, v4 == 0);
      }
      else if (__bt_pdelete((uint64_t)v7, v5))
      {
        return -1;
      }
    }
    else
    {
      unsigned int v4 = __bt_bdelete((uint64_t)v7, v9);
    }
    if (!v4) {
      *((_DWORD *)v7 + 159) |= 4u;
    }
    return v4;
  }
}

uint64_t __bt_bdelete(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  uint64_t v10 = 0;
  uint64_t v9 = 0;
  int v7 = 0;
  int v8 = 0;
  while (2)
  {
    uint64_t v10 = (void **)__bt_search(v12, v11, &v7);
    if (v10)
    {
      if (v7)
      {
        int v6 = 0;
        uint64_t v9 = *v10;
        do
        {
          if (__bt_dleaf(v12, v11, (unsigned __int16 *)v9, *((unsigned __int16 *)v10 + 4)))
          {
LABEL_11:
            mpool_put(*(MPOOL **)v12, v9, 0);
            return -1;
          }
          if ((*(_DWORD *)(v12 + 636) & 0x20) != 0)
          {
            if (((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2)
            {
              mpool_put(*(MPOOL **)v12, v9, 1u);
            }
            else if (__bt_pdelete(v12, v9))
            {
              return -1;
            }
            return 0;
          }
          int v8 = 1;
          BOOL v5 = 0;
          if (*((unsigned __int16 *)v10 + 4) < ((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2) {
            BOOL v5 = __bt_cmp(v12, v11, (uint64_t *)v10) == 0;
          }
        }
        while (v5);
        if (*((unsigned __int16 *)v10 + 4) == ((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2) {
          int v6 = 1;
        }
        while (1)
        {
          int v3 = *((unsigned __int16 *)v10 + 4);
          *((_WORD *)v10 + 4) = v3 - 1;
          if (v3 <= 0 || __bt_cmp(v12, v11, (uint64_t *)v10)) {
            break;
          }
          if (__bt_dleaf(v12, v11, (unsigned __int16 *)v9, *((unsigned __int16 *)v10 + 4)) == -1) {
            goto LABEL_11;
          }
          if (!*((_WORD *)v10 + 4)) {
            int v6 = 1;
          }
        }
        if (((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2)
        {
          mpool_put(*(MPOOL **)v12, v9, 1u);
          if (v6) {
            continue;
          }
          return 0;
        }
        else
        {
          if (!__bt_pdelete(v12, v9)) {
            continue;
          }
          return -1;
        }
      }
      else
      {
        mpool_put(*(MPOOL **)v12, *v10, 0);
        return v8 == 0;
      }
    }
    else if (v8)
    {
      return 0;
    }
    else
    {
      return -1;
    }
  }
}

BOOL __bt_stkacq(MPOOL **a1, pgno_t **a2, pgno_t *a3)
{
  BOOL v24 = a1;
  mode_t v23 = a2;
  int v22 = a3;
  int v21 = 0;
  unsigned int v20 = 0;
  uint64_t v19 = 0;
  int v18 = 0;
  unsigned __int16 v17 = 0;
  pgno_t v16 = 0;
  pgno_t v15 = 0;
  pgno_t v14 = 0;
  int v13 = 0;
  int v18 = *a2;
  mpool_put(*a1, v18, 0);
  unsigned int v20 = (pgno_t **)__bt_search((uint64_t)v24, (uint64_t)(v22 + 2), &v13);
  if (v20)
  {
    int v18 = *v20;
    if (*v18 != *v22)
    {
      while (*v18 != *v22)
      {
        pgno_t v15 = v18[2];
        if (!v15) {
          break;
        }
        mpool_put(*v24, v18, 0);
        for (int i = 0; ; ++i)
        {
          if (v24[59] == (MPOOL *)(v24 + 9))
          {
            uint64_t v10 = 0;
          }
          else
          {
            uint64_t p_pgcookie = (uint64_t)&v24[59][-1].pgcookie;
            v24[59] = (MPOOL *)p_pgcookie;
            uint64_t v10 = p_pgcookie;
          }
          uint64_t v19 = v10;
          if (!v10) {
            break;
          }
          int v18 = (pgno_t *)mpool_get(*v24, *(_DWORD *)v19, 0);
          if (!v18) {
            return 1;
          }
          if (*(unsigned __int16 *)(v19 + 4) != ((unint64_t)*((unsigned __int16 *)v18 + 8) - 20) / 2 - 1)
          {
            unsigned __int16 v17 = *(_WORD *)(v19 + 4) + 1;
            LODWORD(v24[59]->lqh.tqh_first) = *v18;
            WORD2(v24[59]->lqh.tqh_first) = v17;
            v24[59] = (MPOOL *)((char *)v24[59] + 8);
            break;
          }
          mpool_put(*v24, v18, 0);
        }
        while (i--)
        {
          int v21 = (char *)v18 + *((unsigned __int16 *)v18 + v17 + 10);
          pgno_t v16 = *((_DWORD *)v21 + 1);
          LODWORD(v24[59]->lqh.tqh_first) = v16;
          WORD2(v24[59]->lqh.tqh_first) = 0;
          v24[59] = (MPOOL *)((char *)v24[59] + 8);
          mpool_put(*v24, v18, 0);
          int v18 = (pgno_t *)mpool_get(*v24, v16, 0);
          if (!v18) {
            return 1;
          }
          unsigned __int16 v17 = 0;
        }
        mpool_put(*v24, v18, 0);
        int v18 = (pgno_t *)mpool_get(*v24, v15, 0);
        if (!v18) {
          return 1;
        }
      }
      if (*v18 != *v22)
      {
        mpool_put(*v24, v18, 0);
        unsigned int v20 = (pgno_t **)__bt_search((uint64_t)v24, (uint64_t)(v22 + 2), &v13);
        if (!v20) {
          return 1;
        }
        int v18 = *v20;
        while (*v18 != *v22)
        {
          pgno_t v14 = v18[1];
          if (!v14) {
            break;
          }
          mpool_put(*v24, v18, 0);
          for (int j = 0; ; ++j)
          {
            if (v24[59] == (MPOOL *)(v24 + 9))
            {
              uint64_t v9 = 0;
            }
            else
            {
              uint64_t v5 = (uint64_t)&v24[59][-1].pgcookie;
              v24[59] = (MPOOL *)v5;
              uint64_t v9 = v5;
            }
            uint64_t v19 = v9;
            if (!v9) {
              break;
            }
            int v18 = (pgno_t *)mpool_get(*v24, *(_DWORD *)v19, 0);
            if (!v18) {
              return 1;
            }
            if (*(_WORD *)(v19 + 4))
            {
              unsigned __int16 v17 = *(_WORD *)(v19 + 4) - 1;
              LODWORD(v24[59]->lqh.tqh_first) = *v18;
              WORD2(v24[59]->lqh.tqh_first) = v17;
              v24[59] = (MPOOL *)((char *)v24[59] + 8);
              break;
            }
            mpool_put(*v24, v18, 0);
          }
          while (j--)
          {
            int v21 = (char *)v18 + *((unsigned __int16 *)v18 + v17 + 10);
            pgno_t v16 = *((_DWORD *)v21 + 1);
            mpool_put(*v24, v18, 0);
            int v18 = (pgno_t *)mpool_get(*v24, v16, 0);
            if (!v18) {
              return 1;
            }
            unsigned __int16 v17 = ((unint64_t)*((unsigned __int16 *)v18 + 8) - 20) / 2 - 1;
            LODWORD(v24[59]->lqh.tqh_first) = v16;
            WORD2(v24[59]->lqh.tqh_first) = v17;
            v24[59] = (MPOOL *)((char *)v24[59] + 8);
          }
          mpool_put(*v24, v18, 0);
          int v18 = (pgno_t *)mpool_get(*v24, v14, 0);
          if (!v18) {
            return 1;
          }
        }
      }
    }
    mpool_put(*v24, v18, 0);
    int v7 = (pgno_t *)mpool_get(*v24, *v22, 0);
    *mode_t v23 = v7;
    return v7 == 0;
  }
  return 1;
}

uint64_t __bt_dleaf(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4)
{
  if ((*(unsigned char *)(a1 + 68) & 8) != 0
    && (*(unsigned char *)(a1 + 68) & 1) == 0
    && *(_DWORD *)(a1 + 40) == *(_DWORD *)a3
    && *(unsigned __int16 *)(a1 + 44) == a4
    && __bt_curdel(a1, a2, a3, a4))
  {
    return -1;
  }
  else
  {
    uint64_t v12 = (unsigned int *)((char *)a3 + a3[a4 + 10]);
    if ((v12[2] & 2) != 0 && __ovfl_delete(a1, (unsigned int *)((char *)v12 + 9)) == -1)
    {
      return -1;
    }
    else if ((v12[2] & 1) != 0 && __ovfl_delete(a1, (unsigned int *)((char *)v12 + *v12 + 9)) == -1)
    {
      return -1;
    }
    else
    {
      unsigned int v7 = (*v12 + 9 + v12[1] + 3) & 0xFFFFFFFC;
      memmove((char *)a3 + a3[9] + v7, (char *)a3 + a3[9], (char *)v12 - ((char *)a3 + a3[9]));
      a3[9] += v7;
      unsigned __int16 v8 = a3[a4 + 10];
      __int16 v10 = a4;
      for (int i = a3 + 10; v10--; ++i)
      {
        if (*i < (int)v8) {
          *i += v7;
        }
      }
      __int16 v11 = ((unint64_t)a3[8] - 20) / 2 - a4;
      while (--v11)
      {
        if (i[1] >= (int)v8) {
          unsigned __int16 v6 = i[1];
        }
        else {
          unsigned __int16 v6 = i[1] + v7;
        }
        *i++ = v6;
      }
      a3[8] -= 2;
      if ((*(unsigned char *)(a1 + 68) & 8) != 0
        && (*(unsigned char *)(a1 + 68) & 1) == 0
        && *(_DWORD *)(a1 + 40) == *(_DWORD *)a3
        && *(unsigned __int16 *)(a1 + 44) > a4)
      {
        --*(_WORD *)(a1 + 44);
      }
      return 0;
    }
  }
}

uint64_t __bt_pdelete(uint64_t a1, _DWORD *a2)
{
  while (1)
  {
    if (*(void *)(a1 + 472) == a1 + 72)
    {
      uint64_t v7 = 0;
    }
    else
    {
      uint64_t v2 = *(void *)(a1 + 472) - 8;
      *(void *)(a1 + 472) = v2;
      uint64_t v7 = v2;
    }
    if (!v7) {
      break;
    }
    pgno_t v14 = (unsigned __int16 *)mpool_get(*(MPOOL **)a1, *(_DWORD *)v7, 0);
    if (!v14) {
      return -1;
    }
    unsigned __int16 v11 = *(_WORD *)(v7 + 4);
    pgno_t v15 = (char *)v14 + v14[v11 + 10];
    if ((v15[8] & 2) != 0 && __ovfl_delete(a1, (pgno_t *)(v15 + 9)) == -1)
    {
      mpool_put(*(MPOOL **)a1, v14, 0);
      return -1;
    }
    if (((unint64_t)v14[8] - 20) / 2 != 1)
    {
      unsigned int v8 = (*(_DWORD *)v15 + 12) & 0xFFFFFFFC;
      memmove((char *)v14 + v14[9] + v8, (char *)v14 + v14[9], v15 - ((char *)v14 + v14[9]));
      v14[9] += v8;
      unsigned __int16 v9 = v14[v11 + 10];
      unsigned __int16 v12 = v11;
      for (int i = v14 + 10; v12--; ++i)
      {
        if (*i < (int)v9) {
          *i += v8;
        }
      }
      __int16 v13 = ((unint64_t)v14[8] - 20) / 2 - v11;
      while (--v13)
      {
        if (i[1] >= (int)v9) {
          unsigned __int16 v6 = i[1];
        }
        else {
          unsigned __int16 v6 = i[1] + v8;
        }
        *i++ = v6;
      }
      v14[8] -= 2;
      goto LABEL_29;
    }
    if (*(_DWORD *)v14 == 1)
    {
      v14[8] = 20;
      v14[9] = *(_DWORD *)(a1 + 520);
      *((_DWORD *)v14 + 3) = 2;
LABEL_29:
      mpool_put(*(MPOOL **)a1, v14, 1u);
      break;
    }
    if (__bt_relink((MPOOL **)a1, (uint64_t)v14) || __bt_free(a1, v14)) {
      return -1;
    }
  }
  if (*a2 == 1)
  {
    mpool_put(*(MPOOL **)a1, a2, 1u);
    return 0;
  }
  else
  {
    BOOL v5 = 1;
    if (!__bt_relink((MPOOL **)a1, (uint64_t)a2)) {
      return __bt_free(a1, a2) != 0;
    }
    return v5;
  }
}

uint64_t __bt_curdel(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  __int16 v13 = a3;
  unsigned int v12 = a4;
  unsigned __int16 v9 = 0;
  uint64_t v10 = 0;
  uint64_t v11 = a1 + 40;
  *(unsigned char *)(a1 + 68) &= 0xF8u;
  int v7 = 0;
  if ((*(_DWORD *)(v15 + 636) & 0x20) == 0)
  {
    if (!v14)
    {
      unsigned __int16 v9 = v13;
      LOWORD(v10) = v12;
      unsigned int v5 = __bt_ret(v15, (uint64_t)&v9, (void *)(v11 + 8), v11 + 8, 0, 0, 1);
      if (v5) {
        return v5;
      }
      int v7 = 1;
      uint64_t v14 = v11 + 8;
    }
    if (v12)
    {
      unsigned __int16 v9 = v13;
      LOWORD(v10) = v12 - 1;
      if (!__bt_cmp(v15, v14, (uint64_t *)&v9))
      {
        *(unsigned char *)(v11 + 28) |= 4u;
LABEL_26:
        *(_DWORD *)uint64_t v11 = *(_DWORD *)v9;
        *(_WORD *)(v11 + 4) = v10;
        return 0;
      }
    }
    if (v12 < ((unint64_t)v13[8] - 20) / 2 - 1)
    {
      unsigned __int16 v9 = v13;
      LOWORD(v10) = v12 + 1;
      if (!__bt_cmp(v15, v14, (uint64_t *)&v9))
      {
        *(unsigned char *)(v11 + 28) |= 2u;
        goto LABEL_26;
      }
    }
    if (!v12 && *((_DWORD *)v13 + 1))
    {
      unsigned int v8 = (unsigned __int16 *)mpool_get(*(MPOOL **)v15, *((_DWORD *)v13 + 1), 0);
      if (!v8) {
        return -1;
      }
      unsigned __int16 v9 = v8;
      LOWORD(v10) = ((unint64_t)v8[8] - 20) / 2 - 1;
      if (!__bt_cmp(v15, v14, (uint64_t *)&v9))
      {
        *(unsigned char *)(v11 + 28) |= 4u;
LABEL_25:
        mpool_put(*(MPOOL **)v15, v8, 0);
        goto LABEL_26;
      }
      mpool_put(*(MPOOL **)v15, v8, 0);
    }
    if (v12 == ((unint64_t)v13[8] - 20) / 2 - 1 && *((_DWORD *)v13 + 2))
    {
      unsigned int v8 = (unsigned __int16 *)mpool_get(*(MPOOL **)v15, *((_DWORD *)v13 + 2), 0);
      if (!v8) {
        return -1;
      }
      unsigned __int16 v9 = v8;
      LOWORD(v10) = 0;
      if (!__bt_cmp(v15, v14, (uint64_t *)&v9))
      {
        *(unsigned char *)(v11 + 28) |= 2u;
        goto LABEL_25;
      }
      mpool_put(*(MPOOL **)v15, v8, 0);
    }
  }
  unsigned __int16 v9 = v13;
  LOWORD(v10) = v12;
  if (!v7 && (unsigned int v6 = __bt_ret(v15, (uint64_t)&v9, (void *)(v11 + 8), v11 + 8, 0, 0, 1)) != 0)
  {
    return v6;
  }
  else
  {
    *(unsigned char *)(v11 + 28) |= 1u;
    return 0;
  }
}

uint64_t __bt_relink(MPOOL **a1, uint64_t a2)
{
  if (!*(_DWORD *)(a2 + 8))
  {
LABEL_5:
    if (*(_DWORD *)(a2 + 4))
    {
      unsigned int v4 = mpool_get(*a1, *(_DWORD *)(a2 + 4), 0);
      if (!v4) {
        return -1;
      }
      int v4[2] = *(_DWORD *)(a2 + 8);
      mpool_put(*a1, v4, 1u);
    }
    return 0;
  }
  int v3 = mpool_get(*a1, *(_DWORD *)(a2 + 8), 0);
  if (v3)
  {
    v3[1] = *(_DWORD *)(a2 + 4);
    mpool_put(*a1, v3, 1u);
    goto LABEL_5;
  }
  return -1;
}

uint64_t __bt_get(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  uint64_t v10 = a3;
  int v9 = a4;
  uint64_t v8 = 0;
  int v7 = 0;
  int v6 = 0;
  uint64_t v8 = *(void *)(a1 + 56);
  if (*(void *)(v8 + 32))
  {
    mpool_put(*(MPOOL **)v8, *(void **)(v8 + 32), 0);
    *(void *)(v8 + 32) = 0;
  }
  if (v9)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    int v7 = (void **)__bt_search(v8, v11, &v6);
    if (v7)
    {
      if (v6)
      {
        unsigned int v5 = __bt_ret(v8, (uint64_t)v7, 0, 0, v10, v8 + 496, 0);
        if ((*(_DWORD *)(v8 + 636) & 0x4000) != 0) {
          mpool_put(*(MPOOL **)v8, *v7, 0);
        }
        else {
          *(void *)(v8 + 32) = *v7;
        }
        return v5;
      }
      else
      {
        mpool_put(*(MPOOL **)v8, *v7, 0);
        return 1;
      }
    }
    else
    {
      return -1;
    }
  }
}

uint64_t __bt_open(uint64_t a1, int a2, int a3, const void *a4, int a5)
{
  uint64_t v30 = a1;
  int v29 = a2;
  int v28 = a3;
  BOOL v27 = a4;
  int v26 = a5;
  memset(&__b, 0, sizeof(__b));
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  memset(__dst, 0, sizeof(__dst));
  int v21 = 0;
  uint64_t v16 = byteorder();
  if (v27)
  {
    memcpy(__dst, v27, sizeof(__dst));
    if ((__dst[0] & 0xFFFFFFFFFFFFFFFELL) != 0
      || HIDWORD(__dst[2])
      && (HIDWORD(__dst[2]) < 0x200 || HIDWORD(__dst[2]) > 0x10000 || (__dst[2] & 0x100000000) != 0))
    {
      goto LABEL_76;
    }
    if (LODWORD(__dst[2]))
    {
      if (SLODWORD(__dst[2]) < 2) {
        goto LABEL_76;
      }
    }
    else
    {
      LODWORD(__dst[2]) = 2;
    }
    if (!__dst[3])
    {
      char __dst[3] = __bt_defcmp;
      if (!__dst[4]) {
        __dst[4] = __bt_defpfx;
      }
    }
    if (!LODWORD(__dst[5])) {
      LODWORD(__dst[5]) = v16;
    }
  }
  else
  {
    char __dst[3] = __bt_defcmp;
    LODWORD(__dst[1]) = 0;
    __dst[0] = 0;
    LODWORD(__dst[5]) = v16;
    _OWORD __dst[2] = 2;
    __dst[4] = __bt_defpfx;
  }
  if (LODWORD(__dst[5]) != 4321 && LODWORD(__dst[5]) != 1234) {
    goto LABEL_76;
  }
  int v21 = (void *)malloc_type_calloc();
  if (!v21) {
    goto LABEL_78;
  }
  *((_DWORD *)v21 + 128) = -1;
  *((_DWORD *)v21 + 132) = __dst[5];
  *((_DWORD *)v21 + 133) = 0;
  *((void *)v21 + 68) = __dst[3];
  *((void *)v21 + 69) = __dst[4];
  *((_DWORD *)v21 + 144) = -1;
  uint64_t v19 = malloc_type_calloc();
  *((void *)v21 + 1) = v19;
  if (!v19) {
    goto LABEL_78;
  }
  if (*((_DWORD *)v21 + 132) != v16) {
    *((_DWORD *)v21 + 159) |= 8u;
  }
  *(_DWORD *)uint64_t v19 = 0;
  *(void *)(v19 + 56) = v21;
  *(void *)(v19 + 8) = __bt_close;
  *(void *)(v19 + 16) = __bt_delete;
  *(void *)(v19 + 64) = __bt_fd;
  *(void *)(v19 + 24) = __bt_get;
  *(void *)(v19 + 32) = __bt_put;
  *(void *)(v19 + 40) = __bt_seq;
  *(void *)(v19 + 48) = __bt_sync;
  if (!v30)
  {
    if ((v29 & 3) == 2)
    {
      int v6 = tmp();
      *((_DWORD *)v21 + 128) = v6;
      if (v6 == -1) {
        goto LABEL_78;
      }
      *((_DWORD *)v21 + 159) |= 1u;
      goto LABEL_35;
    }
LABEL_76:
    *__error() = 22;
    goto LABEL_78;
  }
  if ((v29 & 3) != 0)
  {
    if ((v29 & 3) != 2) {
      goto LABEL_76;
    }
  }
  else
  {
    *((_DWORD *)v21 + 159) |= 0x10u;
  }
  int v5 = open_NOCANCEL();
  *((_DWORD *)v21 + 128) = v5;
  if (v5 < 0) {
    goto LABEL_78;
  }
LABEL_35:
  if (fcntl_NOCANCEL() == -1 || fstat(*((_DWORD *)v21 + 128), &__b)) {
    goto LABEL_78;
  }
  if (!__b.st_size)
  {
    if (!HIDWORD(__dst[2]))
    {
      HIDWORD(__dst[2]) = __b.st_blksize;
      if (__b.st_blksize < 0x200u) {
        HIDWORD(__dst[2]) = 512;
      }
      if (HIDWORD(__dst[2]) > 0x10000) {
        HIDWORD(__dst[2]) = 0x10000;
      }
    }
    if ((__dst[0] & 1) == 0) {
      *((_DWORD *)v21 + 159) |= 0x20u;
    }
    *((_DWORD *)v21 + 129) = 0;
    *((_DWORD *)v21 + 154) = 0;
    *((_DWORD *)v21 + 159) |= 2u;
    goto LABEL_58;
  }
  uint64_t NOCANCEL = read_NOCANCEL();
  if (NOCANCEL < 0)
  {
LABEL_78:
    int v15 = *__error();
    if (v21)
    {
      if (*((void *)v21 + 1)) {
        free(*((void **)v21 + 1));
      }
      if (*((_DWORD *)v21 + 128) != -1) {
        close_NOCANCEL();
      }
      free(v21);
    }
    *__error() = v15;
    return 0;
  }
  if (NOCANCEL != 24) {
    goto LABEL_77;
  }
  if (v22 == 340322)
  {
    *((_DWORD *)v21 + 159) &= ~8u;
  }
  else
  {
    *((_DWORD *)v21 + 159) |= 8u;
    int v14 = v22;
    LOBYTE(v22) = BYTE3(v22);
    BYTE1(v22) = BYTE2(v14);
    BYTE2(v22) = BYTE1(v14);
    BYTE3(v22) = v14;
    int v13 = HIDWORD(v22);
    BYTE4(v22) = HIBYTE(v22);
    BYTE5(v22) = BYTE2(v13);
    BYTE6(v22) = BYTE1(v13);
    HIBYTE(v22) = v13;
    int v12 = v23;
    LOBYTE(v23) = BYTE3(v23);
    BYTE1(v23) = BYTE2(v12);
    BYTE2(v23) = BYTE1(v12);
    BYTE3(v23) = v12;
    int v11 = HIDWORD(v23);
    BYTE4(v23) = HIBYTE(v23);
    BYTE5(v23) = BYTE2(v11);
    BYTE6(v23) = BYTE1(v11);
    HIBYTE(v23) = v11;
    int v10 = v24;
    LOBYTE(v24) = BYTE3(v24);
    BYTE1(v24) = BYTE2(v10);
    BYTE2(v24) = BYTE1(v10);
    BYTE3(v24) = v10;
    int v9 = HIDWORD(v24);
    BYTE4(v24) = HIBYTE(v24);
    BYTE5(v24) = BYTE2(v9);
    BYTE6(v24) = BYTE1(v9);
    HIBYTE(v24) = v9;
  }
  if (v22 != 0x300053162
    || v23 < 0x200
    || v23 > 0x10000
    || (v23 & 1) != 0
    || (v24 & 0xFFFFFF5F00000000) != 0)
  {
LABEL_77:
    *__error() = 79;
    goto LABEL_78;
  }
  HIDWORD(__dst[2]) = v23;
  *((_DWORD *)v21 + 159) |= HIDWORD(v24);
  *((_DWORD *)v21 + 129) = HIDWORD(v23);
  *((_DWORD *)v21 + 154) = v24;
LABEL_58:
  *((_DWORD *)v21 + 130) = HIDWORD(__dst[2]);
  if (LODWORD(__dst[1]) && (__dst[1] & (HIDWORD(__dst[2]) - 1)) != 0) {
    LODWORD(__dst[1]) += ((HIDWORD(__dst[2]) - 1) & ~LODWORD(__dst[1])) + 1;
  }
  if (LODWORD(__dst[1]) < 5 * HIDWORD(__dst[2])) {
    LODWORD(__dst[1]) = 5 * HIDWORD(__dst[2]);
  }
  unsigned int v18 = (LODWORD(__dst[1]) + *((_DWORD *)v21 + 130) - 1) / *((_DWORD *)v21 + 130);
  *((_WORD *)v21 + 262) = ((unint64_t)*((unsigned int *)v21 + 130) - 20) / SLODWORD(__dst[2]) - 14;
  if (*((unsigned __int16 *)v21 + 262) < 0x1EuLL) {
    *((_WORD *)v21 + 262) = 30;
  }
  int v7 = mpool_open(0, *((_DWORD *)v21 + 128), *((_DWORD *)v21 + 130), v18);
  *(void *)int v21 = v7;
  if (!v7) {
    goto LABEL_78;
  }
  if ((*((_DWORD *)v21 + 159) & 1) == 0) {
    mpool_filter(*(MPOOL **)v21, (void (__cdecl *)(void *, pgno_t, void *))__bt_pgin, (void (__cdecl *)(void *, pgno_t, void *))__bt_pgout, v21);
  }
  if (nroot((MPOOL **)v21) == -1) {
    goto LABEL_78;
  }
  if ((v26 & 0x20000000) != 0) {
    *((_DWORD *)v21 + 159) |= 0x4000u;
  }
  if ((v26 & 0x40000000) != 0) {
    *((_DWORD *)v21 + 159) |= 0x8000u;
  }
  if (v26 < 0) {
    *((_DWORD *)v21 + 159) |= 0x10000u;
  }
  return v19;
}

uint64_t byteorder()
{
  return 1234;
}

uint64_t __bt_fd(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(void *)(v2 + 32))
  {
    mpool_put(*(MPOOL **)v2, *(void **)(v2 + 32), 0);
    *(void *)(v2 + 32) = 0;
  }
  if (*(_DWORD *)(v2 + 636))
  {
    *__error() = 2;
    return -1;
  }
  else
  {
    return *(unsigned int *)(v2 + 512);
  }
}

uint64_t tmp()
{
  sigset_t v5 = 0;
  sigset_t v4 = 0;
  uint64_t v2 = 0;
  if (!issetugid()) {
    uint64_t v2 = getenv("TMPDIR");
  }
  if (v2) {
    unsigned int v0 = snprintf(__str, 0x400uLL, "%s/bt.XXXXXXXXXX", v2);
  }
  else {
    unsigned int v0 = snprintf(__str, 0x400uLL, "%s/bt.XXXXXXXXXX", "/tmp");
  }
  if (v0 < 0x400)
  {
    sigset_t v5 = -1;
    sigprocmask(1, &v5, &v4);
    unsigned int v3 = mkstemp(__str);
    if (v3 != -1) {
      unlink(__str);
    }
    sigprocmask(3, &v4, 0);
    return v3;
  }
  else
  {
    *__error() = 63;
    return -1;
  }
}

uint64_t nroot(MPOOL **a1)
{
  sigset_t v5 = a1;
  sigset_t v4 = 0;
  unsigned int v3 = 0;
  pgno_t v2 = 0;
  sigset_t v4 = mpool_get(*a1, 0, 0);
  if (v4)
  {
    mpool_put(*v5, v4, 0);
    return 0;
  }
  else if (*__error() == 22)
  {
    *__error() = 0;
    sigset_t v4 = mpool_new(*v5, &v2);
    if (v4)
    {
      unsigned int v3 = mpool_new(*v5, &v2);
      if (v3)
      {
        if (v2 == 1)
        {
          *(_DWORD *)unsigned int v3 = 1;
          *((_DWORD *)v3 + 2) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_WORD *)v3 + 8) = 20;
          *((_WORD *)v3 + 9) = *((_DWORD *)v5 + 130);
          *((_DWORD *)v3 + 3) = 2;
          bzero(v4, *((unsigned int *)v5 + 130));
          mpool_put(*v5, v4, 1u);
          mpool_put(*v5, v3, 1u);
          return 0;
        }
        else
        {
          return -1;
        }
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __ovfl_get(uint64_t a1, pgno_t *a2, void *a3, void **a4, void *a5)
{
  pgno_t v10 = *a2;
  pgno_t __size = a2[1];
  *a3 = __size;
  if (*a5 < (unint64_t)__size)
  {
    *a4 = reallocf(*a4, __size);
    if (!*a4) {
      return -1;
    }
    *a5 = __size;
  }
  size_t __size_4 = *(unsigned int *)(a1 + 520) - 20;
  int v14 = (char *)*a4;
  for (int i = (pgno_t *)mpool_get(*(MPOOL **)a1, v10, 0); ; int i = (pgno_t *)mpool_get(*(MPOOL **)a1, v11[2], 0))
  {
    int v11 = i;
    if (!i) {
      return -1;
    }
    size_t v7 = __size >= __size_4 ? __size_4 : __size;
    memmove(v14, i + 5, v7);
    mpool_put(*(MPOOL **)a1, v11, 0);
    __size -= v7;
    if (!__size) {
      break;
    }
    v14 += v7;
  }
  return 0;
}

uint64_t __ovfl_put(MPOOL **a1, uint64_t a2, _DWORD *a3)
{
  int v13 = a1;
  uint64_t v12 = a2;
  int v11 = a3;
  pgno_t v10 = 0;
  int v9 = 0;
  uint64_t __src = 0;
  pgno_t v7 = 0;
  unint64_t v6 = *((unsigned int *)a1 + 130) - 20;
  int v9 = 0;
  uint64_t __src = *(void **)a2;
  unsigned int v5 = *(void *)(a2 + 8);
  while (1)
  {
    pgno_t v10 = __bt_new((uint64_t)v13, &v7);
    if (!v10) {
      return -1;
    }
    *pgno_t v10 = v7;
    v10[1] = 0;
    v10[2] = 0;
    v10[3] = 4;
    *((_WORD *)v10 + 9) = 0;
    *((_WORD *)v10 + 8) = 0;
    size_t v4 = v5 >= v6 ? v6 : v5;
    memmove(v10 + 5, __src, v4);
    if (v9)
    {
      *((_DWORD *)v9 + 2) = *v10;
      mpool_put(*v13, v9, 1u);
    }
    else
    {
      *int v11 = *v10;
    }
    v5 -= v4;
    if (!v5) {
      break;
    }
    uint64_t __src = (char *)__src + v6;
    int v9 = v10;
  }
  mpool_put(*v13, v10, 1u);
  return 0;
}

uint64_t __ovfl_delete(uint64_t a1, pgno_t *a2)
{
  pgno_t v3 = a2[1];
  unint64_t v6 = mpool_get(*(MPOOL **)a1, *a2, 0);
  if (v6)
  {
    if ((v6[3] & 0x20) != 0)
    {
      mpool_put(*(MPOOL **)a1, v6, 0);
      return 0;
    }
    else
    {
      for (unint64_t i = *(unsigned int *)(a1 + 520) - 20; ; v3 -= i)
      {
        pgno_t v5 = v6[2];
        __bt_free(a1, v6);
        if (v3 <= i) {
          return 0;
        }
        unint64_t v6 = mpool_get(*(MPOOL **)a1, v5, 0);
        if (!v6) {
          break;
        }
      }
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __bt_free(uint64_t a1, _DWORD *a2)
{
  a2[1] = 0;
  a2[2] = *(_DWORD *)(a1 + 516);
  *(_DWORD *)(a1 + 516) = *a2;
  *(_DWORD *)(a1 + 636) |= 2u;
  return mpool_put(*(MPOOL **)a1, a2, 1u);
}

_DWORD *__bt_new(uint64_t a1, pgno_t *a2)
{
  if (!*(_DWORD *)(a1 + 516)) {
    return mpool_new(*(MPOOL **)a1, a2);
  }
  pgno_t v3 = mpool_get(*(MPOOL **)a1, *(_DWORD *)(a1 + 516), 0);
  if (!v3) {
    return mpool_new(*(MPOOL **)a1, a2);
  }
  *a2 = *(_DWORD *)(a1 + 516);
  *(_DWORD *)(a1 + 516) = v3[2];
  *(_DWORD *)(a1 + 636) |= 2u;
  return v3;
}

uint64_t __bt_put(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v26 = a1;
  int v25 = (const void **)a2;
  uint64_t v24 = (const void **)a3;
  int v23 = a4;
  uint64_t v22 = 0;
  unsigned int v20 = 0;
  uint64_t v21 = 0;
  unsigned int v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  uint64_t v16 = 0;
  unsigned __int16 v15 = 0;
  unsigned __int16 v14 = 0;
  int v13 = 0;
  unsigned int v12 = 0;
  unsigned int v11 = 0;
  int v10 = 0;
  int v9 = 0;
  uint64_t v22 = *(MPOOL ***)(a1 + 56);
  if (v22[4])
  {
    mpool_put(*v22, v22[4], 0);
    v22[4] = 0;
  }
  if ((*((_DWORD *)v22 + 159) & 0x10) != 0)
  {
    *__error() = 1;
    return -1;
  }
  if (v23)
  {
    if (v23 != 1)
    {
      if (v23 == 8) {
        goto LABEL_12;
      }
LABEL_11:
      *__error() = 22;
      return -1;
    }
    if ((*((unsigned char *)v22 + 68) & 8) == 0 || (*((unsigned char *)v22 + 68) & 7) != 0) {
      goto LABEL_11;
    }
  }
LABEL_12:
  int v10 = 0;
  if ((char *)v24[1] + (unint64_t)v25[1] > (char *)*((unsigned __int16 *)v22 + 262))
  {
    if ((unint64_t)v25[1] <= *((unsigned __int16 *)v22 + 262)) {
      goto LABEL_17;
    }
    do
    {
      if (__ovfl_put(v22, (uint64_t)v25, &v13) == -1) {
        return -1;
      }
      unsigned int v20 = v28;
      uint64_t v21 = 8;
      v28[0] = v13;
      unsigned int v11 = v25[1];
      v28[1] = v11;
      v10 |= 2u;
      int v25 = (const void **)&v20;
LABEL_17:
      if ((char *)v24[1] + (unint64_t)v25[1] > (char *)*((unsigned __int16 *)v22 + 262))
      {
        if (__ovfl_put(v22, (uint64_t)v24, &v13) == -1) {
          return -1;
        }
        unsigned int v18 = v29;
        uint64_t v19 = 8;
        v29[0] = v13;
        unsigned int v11 = v24[1];
        v29[1] = v11;
        v10 |= 1u;
        uint64_t v24 = (const void **)&v18;
      }
    }
    while ((char *)v24[1] + (unint64_t)v25[1] > (char *)*((unsigned __int16 *)v22 + 262));
  }
  if (v23 == 1)
  {
    uint64_t v16 = mpool_get(*v22, *((_DWORD *)v22 + 10), 0);
    if (!v16) {
      return -1;
    }
    unsigned __int16 v15 = *((_WORD *)v22 + 22);
LABEL_36:
    if (__bt_dleaf((uint64_t)v22, (uint64_t)v25, (unsigned __int16 *)v16, v15) == -1)
    {
      mpool_put(*v22, v16, 0);
      return -1;
    }
    goto LABEL_38;
  }
  if (!*((_DWORD *)v22 + 133) || (uint64_t v17 = bt_fast((uint64_t)v22, (uint64_t)v25, (uint64_t)v24, &v9)) == 0)
  {
    uint64_t v17 = __bt_search((uint64_t)v22, (uint64_t)v25, &v9);
    if (!v17) {
      return -1;
    }
  }
  uint64_t v16 = *(void **)v17;
  unsigned __int16 v15 = *(_WORD *)(v17 + 8);
  if (v23 == 8)
  {
    if (v9)
    {
      mpool_put(*v22, v16, 0);
      return 1;
    }
    goto LABEL_38;
  }
  if (v9 && (*((_DWORD *)v22 + 159) & 0x20) != 0) {
    goto LABEL_36;
  }
LABEL_38:
  unsigned int v12 = (v25[1] + 9 + v24[1] + 3) & 0xFFFFFFFC;
  if (*((unsigned __int16 *)v16 + 9) - *((unsigned __int16 *)v16 + 8) >= (unint64_t)v12 + 2)
  {
    unint64_t v4 = ((unint64_t)*((unsigned __int16 *)v16 + 8) - 20) / 2;
    unsigned __int16 v14 = v4;
    if (v15 < (int)(unsigned __int16)v4) {
      memmove((char *)v16 + 2 * v15 + 22, (char *)v16 + 2 * v15 + 20, 2 * (v14 - v15));
    }
    *((_WORD *)v16 + 8) += 2;
    __int16 v5 = *((_WORD *)v16 + 9) - v12;
    *((_WORD *)v16 + 9) = v5;
    *((_WORD *)v16 + v15 + 10) = v5;
    __dst = (char *)v16 + *((unsigned __int16 *)v16 + 9);
    *(_DWORD *)__dst = v25[1];
    __dst += 4;
    *(_DWORD *)__dst = v24[1];
    __dst[4] = v10;
    __dst += 5;
    memmove(__dst, *v25, (size_t)v25[1]);
    memmove((char *)v25[1] + (void)__dst, *v24, (size_t)v24[1]);
    if ((*((unsigned char *)v22 + 68) & 8) != 0
      && (*((unsigned char *)v22 + 68) & 1) == 0
      && *((_DWORD *)v22 + 10) == *(_DWORD *)v16
      && *((unsigned __int16 *)v22 + 22) >= (int)v15)
    {
      ++*((_WORD *)v22 + 22);
    }
    if (!*((_DWORD *)v22 + 133))
    {
      if (*((_DWORD *)v16 + 2))
      {
        if (!*((_DWORD *)v16 + 1) && !v15)
        {
          *((_DWORD *)v22 + 133) = 1;
          *((_WORD *)v22 + 270) = 0;
          *((_DWORD *)v22 + 134) = *(_DWORD *)v16;
        }
      }
      else if (v15 == ((unint64_t)*((unsigned __int16 *)v16 + 8) - 20) / 2 - 1)
      {
        *((_DWORD *)v22 + 133) = 2;
        *((_WORD *)v22 + 270) = v15;
        *((_DWORD *)v22 + 134) = *(_DWORD *)v16;
      }
    }
    mpool_put(*v22, v16, 1u);
  }
  else
  {
    unsigned int v8 = __bt_split(v22, v16, (uint64_t)v25, (uint64_t)v24, v10, v12, v15);
    if (v8) {
      return v8;
    }
  }
  if (v23 == 10) {
    __bt_setcur((uint64_t)v22, **(_DWORD **)v17, *(_WORD *)(v17 + 8));
  }
  *((_DWORD *)v22 + 159) |= 4u;
  return 0;
}

uint64_t bt_fast(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  unsigned int v8 = (unsigned __int16 *)mpool_get(*(MPOOL **)a1, *(_DWORD *)(a1 + 536), 0);
  if (v8)
  {
    *(void *)(a1 + 16) = v8;
    *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 540);
    if (v8[9] - v8[8] >= (unint64_t)((*(void *)(a2 + 8)
                                                          + 9
                                                          + *(void *)(a3 + 8)
                                                          + 3) & 0xFFFFFFFC)
                                      + 2)
    {
      if (*(_DWORD *)(a1 + 532) == 2)
      {
        if (!*(_DWORD *)(*(void *)(a1 + 16) + 8)
          && *(unsigned __int16 *)(a1 + 24) == ((unint64_t)v8[8] - 20) / 2 - 1)
        {
          int v7 = __bt_cmp(a1, a2, (uint64_t *)(a1 + 16));
          if (v7 >= 0)
          {
            if (v7)
            {
              __int16 v4 = *(_WORD *)(a1 + 24) + 1;
              *(_WORD *)(a1 + 24) = v4;
              __int16 v6 = v4;
            }
            else
            {
              __int16 v6 = *(_WORD *)(a1 + 24);
            }
            *(_WORD *)(a1 + 540) = v6;
            goto LABEL_16;
          }
        }
      }
      else if (!*(_DWORD *)(*(void *)(a1 + 16) + 4) && !*(_WORD *)(a1 + 24))
      {
        int v7 = __bt_cmp(a1, a2, (uint64_t *)(a1 + 16));
        if (v7 <= 0)
        {
          *(_WORD *)(a1 + 540) = 0;
LABEL_16:
          *a4 = v7 == 0;
          return a1 + 16;
        }
      }
    }
    *(_DWORD *)(a1 + 532) = 0;
    mpool_put(*(MPOOL **)a1, v8, 0);
    return 0;
  }
  *(_DWORD *)(a1 + 532) = 0;
  return 0;
}

uint64_t __bt_search(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  *(void *)(a1 + 472) = a1 + 72;
  pgno_t v6 = 1;
  while (2)
  {
    int v10 = mpool_get(*(MPOOL **)a1, v6, 0);
    if (!v10) {
      return 0;
    }
    *(void *)(a1 + 16) = v10;
    unsigned __int16 v9 = 0;
    for (unsigned __int16 i = ((unint64_t)*((unsigned __int16 *)v10 + 8) - 20) / 2; i; unsigned __int16 i = (int)i >> 1)
    {
      unsigned __int16 v8 = v9 + ((int)i >> 1);
      *(_WORD *)(a1 + 24) = v8;
      int v5 = __bt_cmp(a1, a2, (uint64_t *)(a1 + 16));
      if (!v5)
      {
        if ((v10[3] & 2) != 0)
        {
          *a3 = 1;
          return a1 + 16;
        }
        goto LABEL_28;
      }
      if (v5 > 0)
      {
        unsigned __int16 v9 = v8 + 1;
        --i;
      }
    }
    if ((v10[3] & 2) == 0)
    {
      if (v9) {
        unsigned __int16 v4 = v9 - 1;
      }
      else {
        unsigned __int16 v4 = 0;
      }
      unsigned __int16 v8 = v4;
LABEL_28:
      **(_DWORD **)(a1 + 472) = *v10;
      *(_WORD *)(*(void *)(a1 + 472) + 4) = v8;
      *(void *)(a1 + 472) += 8;
      pgno_t v6 = *(_DWORD *)((char *)v10 + *((unsigned __int16 *)v10 + v8 + 10) + 4);
      mpool_put(*(MPOOL **)a1, v10, 0);
      continue;
    }
    break;
  }
  if ((*(_DWORD *)(a1 + 636) & 0x20) != 0) {
    goto LABEL_23;
  }
  if (!v9 && v10[1] && __bt_sprev((MPOOL **)a1, v10, a2, a3)) {
    return a1 + 16;
  }
  if (v9 == ((unint64_t)*((unsigned __int16 *)v10 + 8) - 20) / 2
    && v10[2]
    && __bt_snext((MPOOL **)a1, v10, a2, a3))
  {
    return a1 + 16;
  }
LABEL_23:
  *a3 = 0;
  *(_WORD *)(a1 + 24) = v9;
  return a1 + 16;
}

uint64_t __bt_sprev(MPOOL **a1, pgno_t *a2, uint64_t a3, _DWORD *a4)
{
  unsigned __int16 v9 = a1;
  unsigned __int16 v8 = a2;
  uint64_t v7 = a3;
  pgno_t v6 = a4;
  v5[0] = 0;
  v5[1] = 0;
  v5[0] = mpool_get(*a1, a2[1], 0);
  if (v5[0])
  {
    LOWORD(v5[1]) = ((unint64_t)*((unsigned __int16 *)v5[0] + 8) - 20) / 2 - 1;
    if (__bt_cmp((uint64_t)v9, v7, (uint64_t *)v5))
    {
      mpool_put(*v9, v5[0], 0);
      return 0;
    }
    else
    {
      mpool_put(*v9, v8, 0);
      *((_OWORD *)v9 + 1) = *(_OWORD *)v5;
      *pgno_t v6 = 1;
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __bt_snext(MPOOL **a1, pgno_t *a2, uint64_t a3, _DWORD *a4)
{
  unsigned __int16 v9 = a1;
  unsigned __int16 v8 = a2;
  uint64_t v7 = a3;
  pgno_t v6 = a4;
  v5[0] = 0;
  v5[1] = 0;
  v5[0] = mpool_get(*a1, a2[2], 0);
  if (v5[0])
  {
    LOWORD(v5[1]) = 0;
    if (__bt_cmp((uint64_t)v9, v7, (uint64_t *)v5))
    {
      mpool_put(*v9, v5[0], 0);
      return 0;
    }
    else
    {
      mpool_put(*v9, v8, 0);
      *((_OWORD *)v9 + 1) = *(_OWORD *)v5;
      *pgno_t v6 = 1;
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __bt_seq(uint64_t a1, void *a2, void *a3, unsigned int a4)
{
  uint64_t v11 = a1;
  int v10 = a2;
  unsigned __int16 v9 = a3;
  unsigned int v8 = a4;
  uint64_t v7 = 0;
  long long v6 = 0uLL;
  uint64_t v7 = *(MPOOL ***)(a1 + 56);
  if (v7[4])
  {
    mpool_put(*v7, v7[4], 0);
    v7[4] = 0;
  }
  if (v8 == 1 || v8 == 3 || v8 == 6) {
    goto LABEL_10;
  }
  if (v8 != 7 && v8 != 9)
  {
    *__error() = 22;
    return -1;
  }
  if ((*((unsigned char *)v7 + 68) & 8) == 0) {
LABEL_10:
  }
    unsigned int v5 = __bt_seqset(v7, &v6, v10, v8);
  else {
    unsigned int v5 = __bt_seqadv(v7, &v6, v8);
  }
  if (!v5)
  {
    __bt_setcur((uint64_t)v7, *(_DWORD *)v6, SWORD4(v6));
    unsigned int v5 = __bt_ret((uint64_t)v7, (uint64_t)&v6, v10, (uint64_t)(v7 + 60), v9, (uint64_t)(v7 + 62), 0);
    if ((*((_DWORD *)v7 + 159) & 0x4000) != 0) {
      mpool_put(*v7, (void *)v6, 0);
    }
    else {
      v7[4] = (MPOOL *)v6;
    }
  }
  return v5;
}

uint64_t __bt_seqadv(MPOOL **a1, _OWORD *a2, int a3)
{
  uint64_t v11 = a1;
  int v10 = a2;
  int v9 = a3;
  uint64_t v7 = 0;
  unsigned __int16 v6 = 0;
  pgno_t v5 = 0;
  int v4 = 0;
  unsigned int v8 = a1 + 5;
  if ((*((unsigned char *)a1 + 68) & 1) == 0)
  {
    uint64_t v7 = mpool_get(*v11, *(_DWORD *)v8, 0);
    if (!v7) {
      return -1;
    }
    if (v9 == 7)
    {
      if ((*((unsigned char *)v8 + 28) & 2) != 0) {
        goto LABEL_17;
      }
      unsigned __int16 v6 = *((_WORD *)v8 + 2) + 1;
      if (((unint64_t)*((unsigned __int16 *)v7 + 8) - 20) / 2 == v6)
      {
        pgno_t v5 = *((_DWORD *)v7 + 2);
        mpool_put(*v11, v7, 0);
        if (!v5) {
          return 1;
        }
        uint64_t v7 = mpool_get(*v11, v5, 0);
        if (!v7) {
          return -1;
        }
        unsigned __int16 v6 = 0;
      }
    }
    else
    {
      if (v9 != 9) {
        goto LABEL_25;
      }
      if ((*((unsigned char *)v8 + 28) & 4) != 0)
      {
LABEL_17:
        *((unsigned char *)v8 + 28) &= 0xF9u;
        *(void *)int v10 = v7;
        *((_WORD *)v10 + 4) = *((_WORD *)v8 + 2);
        return 0;
      }
      unsigned __int16 v6 = *((_WORD *)v8 + 2);
      if (v6)
      {
        --v6;
      }
      else
      {
        pgno_t v5 = *((_DWORD *)v7 + 1);
        mpool_put(*v11, v7, 0);
        if (!v5) {
          return 1;
        }
        uint64_t v7 = mpool_get(*v11, v5, 0);
        if (!v7) {
          return -1;
        }
        unsigned __int16 v6 = ((unint64_t)*((unsigned __int16 *)v7 + 8) - 20) / 2 - 1;
      }
    }
LABEL_25:
    *(void *)int v10 = v7;
    *((_WORD *)v10 + 4) = v6;
    return 0;
  }
  return __bt_first((uint64_t)v11, (uint64_t)(v8 + 1), v10, &v4);
}

uint64_t __bt_seqset(MPOOL **a1, _OWORD *a2, void *a3, unsigned int a4)
{
  int v13 = a1;
  unsigned int v12 = a2;
  uint64_t v11 = a3;
  unsigned int v10 = a4;
  int v9 = 0;
  pgno_t v8 = 0;
  int v7 = 0;
  if (a4 <= 1)
  {
    uint64_t v5 = a4 - 1;
    char v4 = 0;
  }
  else
  {
    uint64_t v5 = a4 - 1;
    char v4 = 1;
  }
  if ((v4 & 1) == 0)
  {
    switch(v5)
    {
      case 0:
        if (*v11 && v11[1])
        {
          return __bt_first((uint64_t)v13, (uint64_t)v11, v12, &v7);
        }
        else
        {
          *__error() = 22;
          return -1;
        }
      case 1:
      case 3:
      case 4:
      case 7:
        return 0;
      case 2:
      case 6:
        pgno_t v8 = 1;
        while (2)
        {
          int v9 = mpool_get(*v13, v8, 0);
          if (!v9) {
            return -1;
          }
          if (!(((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2)) {
            goto LABEL_14;
          }
          if ((*((_DWORD *)v9 + 3) & 0x12) == 0)
          {
            pgno_t v8 = *(_DWORD *)((char *)v9 + *((unsigned __int16 *)v9 + 10) + 4);
            mpool_put(*v13, v9, 0);
            continue;
          }
          break;
        }
        *(void *)unsigned int v12 = v9;
        *((_WORD *)v12 + 4) = 0;
        return 0;
      case 5:
      case 8:
        pgno_t v8 = 1;
        break;
      default:
        JUMPOUT(0);
    }
    while (1)
    {
      int v9 = mpool_get(*v13, v8, 0);
      if (!v9) {
        return -1;
      }
      if (!(((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2))
      {
LABEL_14:
        mpool_put(*v13, v9, 0);
        return 1;
      }
      if ((*((_DWORD *)v9 + 3) & 0x12) != 0) {
        break;
      }
      pgno_t v8 = *(_DWORD *)((char *)v9
                     + *((unsigned __int16 *)v9 + ((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2 + 9)
                     + 4);
      mpool_put(*v13, v9, 0);
    }
    *(void *)unsigned int v12 = v9;
    *((_WORD *)v12 + 4) = ((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2 - 1;
  }
  return 0;
}

void __bt_setcur(uint64_t a1, int a2, __int16 a3)
{
  if (*(void *)(a1 + 48))
  {
    free(*(void **)(a1 + 48));
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 48) = 0;
  }
  *(unsigned char *)(a1 + 68) &= 0xF8u;
  *(_DWORD *)(a1 + 40) = a2;
  *(_WORD *)(a1 + 44) = a3;
  *(unsigned char *)(a1 + 68) |= 8u;
}

uint64_t __bt_first(uint64_t a1, uint64_t a2, _OWORD *a3, _DWORD *a4)
{
  uint64_t v8 = __bt_search(a1, a2, a4);
  if (v8)
  {
    if (!*a4)
    {
      if (*(unsigned __int16 *)(v8 + 8) == ((unint64_t)*(unsigned __int16 *)(*(void *)v8 + 16) - 20) / 2)
      {
        pgno_t v6 = *(_DWORD *)(*(void *)v8 + 8);
        mpool_put(*(MPOOL **)a1, *(void **)v8, 0);
        if (!v6) {
          return 1;
        }
        unsigned int v10 = mpool_get(*(MPOOL **)a1, v6, 0);
        if (!v10) {
          return -1;
        }
        *(_WORD *)(v8 + 8) = 0;
        *(void *)uint64_t v8 = v10;
      }
      *a3 = *(_OWORD *)v8;
      return 0;
    }
    if ((*(_DWORD *)(a1 + 636) & 0x20) != 0)
    {
      *a3 = *(_OWORD *)v8;
      return 0;
    }
    else
    {
      *(_OWORD *)int v7 = *(_OWORD *)v8;
      int v9 = *(pgno_t **)v8;
      do
      {
        if (*(_DWORD *)v7[0] == **(_DWORD **)v8)
        {
          LOWORD(v7[1]) = *(_WORD *)(v8 + 8);
        }
        else
        {
          mpool_put(*(MPOOL **)a1, v7[0], 0);
          *(_OWORD *)int v7 = *(_OWORD *)v8;
        }
        if (!*(_WORD *)(v8 + 8))
        {
          if (!v9[1]) {
            break;
          }
          if (*v9 != *(_DWORD *)v7[0]) {
            mpool_put(*(MPOOL **)a1, v9, 0);
          }
          uint64_t v5 = (pgno_t *)mpool_get(*(MPOOL **)a1, v9[1], 0);
          if (!v5)
          {
            if (*v9 == *(_DWORD *)v7[0]) {
              mpool_put(*(MPOOL **)a1, v7[0], 0);
            }
            return -1;
          }
          int v9 = v5;
          *(void *)uint64_t v8 = v5;
          *(_WORD *)(v8 + 8) = ((unint64_t)*((unsigned __int16 *)v5 + 8) - 20) / 2;
        }
        --*(_WORD *)(v8 + 8);
      }
      while (!__bt_cmp(a1, a2, (uint64_t *)v8));
      if (*v9 != *(_DWORD *)v7[0]) {
        mpool_put(*(MPOOL **)a1, v9, 0);
      }
      *a3 = *(_OWORD *)v7;
      return 0;
    }
  }
  else
  {
    return 1;
  }
}

uint64_t __bt_split(MPOOL **a1, _DWORD *a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7)
{
  int v64 = a1;
  v63 = a2;
  uint64_t v62 = a3;
  uint64_t v61 = a4;
  int v60 = a5;
  uint64_t v59 = a6;
  int v58 = a7;
  int v57 = 0;
  int v56 = 0;
  int v55 = 0;
  int v53 = 0;
  uint64_t v54 = 0;
  int v51 = 0;
  uint64_t v52 = 0;
  v50 = 0;
  v49 = 0;
  int v48 = 0;
  long long v47 = 0;
  long long v46 = 0;
  int v45 = 0;
  unsigned __int16 v44 = 0;
  unsigned int v41 = 0;
  unsigned __int16 v43 = a7;
  if (*a2 == 1) {
    uint64_t v30 = (_WORD *)bt_root((uint64_t)v64, (uint64_t)v63, &v48, &v47, &v43, v59);
  }
  else {
    uint64_t v30 = bt_page((uint64_t)v64, v63, &v48, &v47, &v43, v59);
  }
  v49 = v30;
  if (!v30) {
    return -1;
  }
  __int16 v7 = v49[9] - v59;
  v49[9] = v7;
  v49[v43 + 10] = v7;
  __dst = (char *)v49 + (unsigned __int16)v49[9];
  if ((*((_DWORD *)v64 + 159) & 0x80) != 0)
  {
    *(_DWORD *)__dst = *(void *)(v61 + 8);
    __dst[4] = v60;
    memmove(__dst + 5, *(const void **)v61, *(void *)(v61 + 8));
  }
  else
  {
    *(_DWORD *)__dst = *(void *)(v62 + 8);
    __dste = __dst + 4;
    *(_DWORD *)__dste = *(void *)(v61 + 8);
    __dste[4] = v60;
    __dste += 5;
    memmove(__dste, *(const void **)v62, *(void *)(v62 + 8));
    memmove(&__dste[*(void *)(v62 + 8)], *(const void **)v61, *(void *)(v61 + 8));
  }
  if (*v63 == 1)
  {
    int v29 = (*((_DWORD *)v64 + 159) & 0x80) != 0
        ? bt_rroot((uint64_t)v64, (uint64_t)v63, (uint64_t)v48, (uint64_t)v47)
        : bt_broot((uint64_t)v64, (uint64_t)v63, v48, (uint64_t)v47);
    if (v29 == -1) {
      goto LABEL_78;
    }
  }
  while (2)
  {
    if (v64[59] == (MPOOL *)(v64 + 9))
    {
      int v28 = 0;
    }
    else
    {
      uint64_t v8 = (MPOOL *)((char *)v64[59] - 8);
      v64[59] = v8;
      int v28 = v8;
    }
    v50 = v28;
    if (!v28) {
      goto LABEL_76;
    }
    long long v46 = v48;
    int v45 = v47;
    v49 = mpool_get(*v64, (pgno_t)v50->lqh.tqh_first, 0);
    if (!v49) {
      goto LABEL_78;
    }
    unsigned __int16 v43 = WORD2(v50->lqh.tqh_first) + 1;
    unsigned int v9 = *((_DWORD *)v45 + 3) & 0x1F;
    BOOL v10 = v9 > 1;
    uint64_t v11 = v9 - 1;
    if (v10)
    {
      uint64_t v13 = v11;
      char v12 = 1;
    }
    else
    {
      uint64_t v13 = v11;
      char v12 = 0;
    }
    if (v12) {
LABEL_34:
    }
      abort_report_np((uint64_t)"%s:%s:%u: illegal rchild->flags & P_TYPE (0x%x)");
    switch(v13)
    {
      case 0:
        int v57 = (char *)v45 + *((unsigned __int16 *)v45 + 10);
        __leunsigned __int8 n = (*v57 + 12) & 0xFFFFFFFC;
        goto LABEL_35;
      case 1:
        int v56 = (unsigned int *)((char *)v45 + *((unsigned __int16 *)v45 + 10));
        __leunsigned __int8 n = (*v56 + 12) & 0xFFFFFFFC;
        if (v64[69] && (v56[2] & 2) == 0 && (*((_DWORD *)v49 + 1) || v43 > 1u))
        {
          int v55 = (unsigned int *)((char *)v46
                               + *((unsigned __int16 *)v46
                                 + ((unint64_t)*((unsigned __int16 *)v46 + 8) - 20) / 2
                                 + 9));
          uint64_t v54 = *v55;
          int v53 = (char *)v55 + 9;
          uint64_t v52 = *v56;
          int v51 = (char *)v56 + 9;
          unsigned int v41 = ((uint64_t (*)(char **, char **))v64[69])(&v53, &v51);
          if (((v41 + 12) & 0xFFFFFFFC) >= __len) {
            unsigned int v41 = 0;
          }
          else {
            __leunsigned __int8 n = (v41 + 12) & 0xFFFFFFFC;
          }
        }
        else
        {
          unsigned int v41 = 0;
        }
        goto LABEL_35;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
        goto LABEL_34;
      case 7:
      case 15:
        __leunsigned __int8 n = 8;
LABEL_35:
        if ((unsigned __int16)v49[9] - (unsigned __int16)v49[8] < (unint64_t)__len + 2)
        {
          v63 = v49;
          if (*(_DWORD *)v49 == 1) {
            BOOL v27 = (_WORD *)bt_root((uint64_t)v64, (uint64_t)v49, &v48, &v47, &v43, __len);
          }
          else {
            BOOL v27 = bt_page((uint64_t)v64, v49, &v48, &v47, &v43, __len);
          }
          v49 = v27;
          if (v27)
          {
            int v40 = 1;
            goto LABEL_44;
          }
LABEL_77:
          mpool_put(*v64, v46, 1u);
          mpool_put(*v64, v45, 1u);
LABEL_78:
          mpool_put(*v64, v48, 0);
          mpool_put(*v64, v47, 0);
          __dbpanic(v64[1]);
          return -1;
        }
        unint64_t v14 = ((unint64_t)(unsigned __int16)v49[8] - 20) / 2;
        unsigned __int16 v44 = v14;
        if (v43 < (int)(unsigned __int16)v14) {
          memmove(&v49[v43 + 11], &v49[v43 + 10], 2 * (v44 - v43));
        }
        v49[8] += 2;
        int v40 = 0;
LABEL_44:
        unsigned int v15 = *((_DWORD *)v45 + 3) & 0x1F;
        BOOL v10 = v15 > 1;
        uint64_t v16 = v15 - 1;
        if (v10)
        {
          uint64_t v18 = v16;
          char v17 = 1;
        }
        else
        {
          uint64_t v18 = v16;
          char v17 = 0;
        }
        if (v17) {
LABEL_67:
        }
          abort_report_np((uint64_t)"%s:%s:%u: illegal rchild->flags & P_TYPE (0x%x)");
        return result;
      default:
LABEL_80:
        JUMPOUT(0);
    }
    switch(v18)
    {
      case 0:
        __int16 v19 = v49[9] - __len;
        v49[9] = v19;
        v49[v43 + 10] = v19;
        __dstf = (_DWORD *)((char *)v49 + (unsigned __int16)v49[v43 + 10]);
        memmove(__dstf, v57, __len);
        __dstf[1] = *(_DWORD *)v45;
        goto LABEL_68;
      case 1:
        __int16 v20 = v49[9] - __len;
        v49[9] = v20;
        v49[v43 + 10] = v20;
        __dsta = (unsigned int *)((char *)v49 + (unsigned __int16)v49[v43 + 10]);
        if (v41) {
          unsigned int v26 = v41;
        }
        else {
          unsigned int v26 = *v56;
        }
        unsigned int *__dsta = v26;
        __dstb = (char *)(__dsta + 1);
        *(_DWORD *)__dstb = *(_DWORD *)v45;
        __dstb[4] = v56[2] & 2;
        if (v41) {
          unsigned int v25 = v41;
        }
        else {
          unsigned int v25 = *v56;
        }
        memmove(__dstb + 5, (char *)v56 + 9, v25);
        if ((v56[2] & 2) == 0 || bt_preserve(v64, *(unsigned int *)((char *)v56 + 9)) != -1) {
          goto LABEL_68;
        }
        goto LABEL_77;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
        goto LABEL_67;
      case 7:
        if (v43) {
          __dstc = (char *)v49 + (unsigned __int16)v49[v43 + 9];
        }
        else {
          __dstc = (char *)v48
        }
                 + *((unsigned __int16 *)v48 + ((unint64_t)*((unsigned __int16 *)v48 + 8) - 20) / 2 + 9);
        *(_DWORD *)__dstc = rec_total((uint64_t)v46);
        *((_DWORD *)__dstc + 1) = *(_DWORD *)v46;
        __int16 v21 = v49[9] - __len;
        v49[9] = v21;
        v49[v43 + 10] = v21;
        __dstg = (_DWORD *)((char *)v49 + (unsigned __int16)v49[v43 + 10]);
        _DWORD *__dstg = rec_total((uint64_t)v45);
        __dstg[1] = *(_DWORD *)v45;
        goto LABEL_68;
      case 15:
        if (v43) {
          __dstd = (char *)v49 + (unsigned __int16)v49[v43 + 9];
        }
        else {
          __dstd = (char *)v48
        }
                 + *((unsigned __int16 *)v48 + ((unint64_t)*((unsigned __int16 *)v48 + 8) - 20) / 2 + 9);
        *(_DWORD *)__dstd = ((unint64_t)*((unsigned __int16 *)v46 + 8) - 20) / 2;
        *((_DWORD *)__dstd + 1) = *(_DWORD *)v46;
        __int16 v22 = v49[9] - __len;
        v49[9] = v22;
        v49[v43 + 10] = v22;
        __dsth = (_DWORD *)((char *)v49 + (unsigned __int16)v49[v43 + 10]);
        _DWORD *__dsth = ((unint64_t)*((unsigned __int16 *)v45 + 8) - 20) / 2;
        __dsth[1] = *(_DWORD *)v45;
LABEL_68:
        if (v40)
        {
          if (*v63 == 1)
          {
            int v24 = (*((_DWORD *)v64 + 159) & 0x80) != 0
                ? bt_rroot((uint64_t)v64, (uint64_t)v63, (uint64_t)v48, (uint64_t)v47)
                : bt_broot((uint64_t)v64, (uint64_t)v63, v48, (uint64_t)v47);
            if (v24 == -1) {
              goto LABEL_77;
            }
          }
          mpool_put(*v64, v46, 1u);
          mpool_put(*v64, v45, 1u);
          continue;
        }
        mpool_put(*v64, v49, 1u);
LABEL_76:
        mpool_put(*v64, v48, 1u);
        mpool_put(*v64, v47, 1u);
        return 0;
      default:
        goto LABEL_80;
    }
  }
}

uint64_t bt_root(uint64_t a1, uint64_t a2, void *a3, void *a4, unsigned __int16 *a5, uint64_t a6)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  char v17 = a3;
  uint64_t v16 = a4;
  unsigned int v15 = a5;
  uint64_t v14 = a6;
  uint64_t v13 = 0;
  char v12 = 0;
  uint64_t v11 = 0;
  pgno_t v10 = 0;
  pgno_t v9 = 0;
  uint64_t v13 = __bt_new(a1, &v10);
  if (!v13) {
    return 0;
  }
  char v12 = __bt_new(v19, &v9);
  if (!v12) {
    return 0;
  }
  *uint64_t v13 = v10;
  *char v12 = v9;
  v13[2] = *v12;
  v12[1] = *v13;
  int v12[2] = 0;
  v13[1] = 0;
  *((_WORD *)v12 + 8) = 20;
  *((_WORD *)v13 + 8) = 20;
  __int16 v6 = *(_DWORD *)(v19 + 520);
  *((_WORD *)v12 + 9) = v6;
  *((_WORD *)v13 + 9) = v6;
  int v7 = *(_DWORD *)(v18 + 12) & 0x1F;
  v12[3] = v7;
  v13[3] = v7;
  uint64_t v11 = bt_psplit(v19, v18, (uint64_t)v13, (uint64_t)v12, v15, v14);
  *char v17 = v13;
  *uint64_t v16 = v12;
  return v11;
}

void *bt_page(uint64_t a1, _DWORD *a2, void *a3, void **a4, unsigned __int16 *a5, uint64_t a6)
{
  uint64_t v16 = a1;
  unsigned int v15 = a2;
  uint64_t v14 = a3;
  uint64_t v13 = a4;
  char v12 = a5;
  uint64_t v11 = a6;
  uint64_t __src = 0;
  pgno_t v9 = 0;
  uint64_t v8 = 0;
  pgno_t v7 = 0;
  pgno_t v9 = __bt_new(a1, &v7);
  if (!v9) {
    return 0;
  }
  *(_DWORD *)pgno_t v9 = v7;
  *((_WORD *)v9 + 8) = 20;
  *((_WORD *)v9 + 9) = *(_DWORD *)(v16 + 520);
  *((_DWORD *)v9 + 2) = v15[2];
  *((_DWORD *)v9 + 1) = *v15;
  *((_DWORD *)v9 + 3) = v15[3] & 0x1F;
  if (v15[2] || *v12 != ((unint64_t)*((unsigned __int16 *)v15 + 8) - 20) / 2)
  {
    uint64_t __src = (void *)malloc_type_calloc();
    if (__src)
    {
      *(_DWORD *)uint64_t __src = *v15;
      *((_DWORD *)__src + 2) = *(_DWORD *)v9;
      *((_DWORD *)__src + 1) = v15[1];
      *((_WORD *)__src + 8) = 20;
      *((_WORD *)__src + 9) = *(_DWORD *)(v16 + 520);
      *((_DWORD *)__src + 3) = v15[3] & 0x1F;
      if (v15[2])
      {
        uint64_t v8 = mpool_get(*(MPOOL **)v16, v15[2], 0);
        if (!v8)
        {
          free(__src);
          return 0;
        }
        *((_DWORD *)v8 + 1) = *(_DWORD *)v9;
        mpool_put(*(MPOOL **)v16, v8, 1u);
      }
      uint64_t v8 = (void *)bt_psplit(v16, (uint64_t)v15, (uint64_t)__src, (uint64_t)v9, v12, v11);
      memmove(v15, __src, *(unsigned int *)(v16 + 520));
      if (v8 == __src) {
        uint64_t v8 = v15;
      }
      free(__src);
      *uint64_t v14 = v15;
      *uint64_t v13 = v9;
      return v8;
    }
    else
    {
      mpool_put(*(MPOOL **)v16, v9, 0);
      return 0;
    }
  }
  else
  {
    v15[2] = *(_DWORD *)v9;
    *((_WORD *)v9 + 8) = 22;
    *char v12 = 0;
    *uint64_t v14 = v15;
    *uint64_t v13 = v9;
    return v9;
  }
}

uint64_t bt_rroot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 v4 = *(_DWORD *)(a1 + 520) - 8;
  *(_WORD *)(a2 + 18) = v4;
  *(_WORD *)(a2 + 20) = v4;
  pgno_t v9 = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 18));
  if ((*(_DWORD *)(a3 + 12) & 0x10) != 0) {
    unint64_t v8 = ((unint64_t)*(unsigned __int16 *)(a3 + 16) - 20) / 2;
  }
  else {
    LODWORD(v8) = rec_total(a3);
  }
  *pgno_t v9 = v8;
  v9[1] = *(_DWORD *)a3;
  __int16 v5 = *(_WORD *)(a2 + 18) - 8;
  *(_WORD *)(a2 + 18) = v5;
  *(_WORD *)(a2 + 22) = v5;
  pgno_t v10 = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 18));
  if ((*(_DWORD *)(a4 + 12) & 0x10) != 0) {
    unint64_t v7 = ((unint64_t)*(unsigned __int16 *)(a4 + 16) - 20) / 2;
  }
  else {
    LODWORD(v7) = rec_total(a4);
  }
  *pgno_t v10 = v7;
  v10[1] = *(_DWORD *)a4;
  *(_WORD *)(a2 + 16) = 24;
  *(_DWORD *)(a2 + 12) &= 0xFFFFFFE0;
  *(_DWORD *)(a2 + 12) |= 8u;
  mpool_put(*(MPOOL **)a1, (void *)a2, 1u);
  return 0;
}

uint64_t bt_broot(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  __int16 v4 = *(_DWORD *)(a1 + 520) - 12;
  *(_WORD *)(a2 + 18) = v4;
  *(_WORD *)(a2 + 20) = v4;
  __dst = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 18));
  _DWORD *__dst = 0;
  __dst[1] = *a3;
  *((unsigned char *)__dst + 8) = 0;
  int v8 = *(_DWORD *)(a2 + 12) & 0x1F;
  if (v8 == 1)
  {
    uint64_t v14 = (_DWORD *)(a4 + *(unsigned __int16 *)(a4 + 20));
    __leunsigned __int8 n = (*v14 + 12) & 0xFFFFFFFC;
    __int16 v6 = *(_WORD *)(a2 + 18) - __len;
    *(_WORD *)(a2 + 18) = v6;
    *(_WORD *)(a2 + 22) = v6;
    __dstb = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 18));
    memmove(__dstb, v14, __len);
    __dstb[1] = *(_DWORD *)a4;
LABEL_9:
    *(_WORD *)(a2 + 16) = 24;
    *(_DWORD *)(a2 + 12) &= 0xFFFFFFE0;
    *(_DWORD *)(a2 + 12) |= 1u;
    mpool_put(*(MPOOL **)a1, (void *)a2, 1u);
    return 0;
  }
  if (v8 != 2) {
    abort_report_np((uint64_t)"%s:%s:%u: illegal h->flags & P_TYPE (0x%x)");
  }
  __len_4 = (unsigned int *)(a4 + *(unsigned __int16 *)(a4 + 20));
  __int16 v5 = *(_WORD *)(a2 + 18) - ((*(_WORD *)__len_4 + 12) & 0xFFFC);
  *(_WORD *)(a2 + 18) = v5;
  *(_WORD *)(a2 + 22) = v5;
  __dsta = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 18));
  _DWORD *__dsta = *__len_4;
  __dsta[1] = *(_DWORD *)a4;
  __dsta += 2;
  *(unsigned char *)__dsta = 0;
  memmove((char *)__dsta + 1, (char *)__len_4 + 9, *__len_4);
  if ((__len_4[2] & 2) == 0 || bt_preserve((MPOOL **)a1, *(unsigned int *)((char *)__len_4 + 9)) != -1) {
    goto LABEL_9;
  }
  return -1;
}

uint64_t bt_preserve(MPOOL **a1, pgno_t a2)
{
  pgno_t v3 = mpool_get(*a1, a2, 0);
  if (v3)
  {
    v3[3] |= 0x20u;
    mpool_put(*a1, v3, 1u);
    return 0;
  }
  else
  {
    return -1;
  }
}

uint64_t rec_total(uint64_t a1)
{
  unsigned int v3 = 0;
  for (unsigned __int16 i = 0; i < (int)(unsigned __int16)(((unint64_t)*(unsigned __int16 *)(a1 + 16) - 20) / 2); ++i)
    v3 += *(_DWORD *)(a1 + *(unsigned __int16 *)(a1 + 20 + 2 * i));
  return v3;
}

uint64_t bt_psplit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, unsigned int a6)
{
  *(_WORD *)&v28[8] = 0;
  int v19 = 0;
  unsigned __int16 v24 = *a5;
  *(void *)int v28 = (unsigned __int16)(*(_DWORD *)(a1 + 520) - 20);
  unsigned __int16 __len_6 = 0;
  unsigned __int16 v25 = 0;
  unsigned __int16 v27 = 0;
  unsigned __int16 v23 = ((unint64_t)*(unsigned __int16 *)(a2 + 16) - 20) / 2;
  while (v27 < (int)v23)
  {
    if (v24 != v25)
    {
      unsigned int v6 = *(_DWORD *)(a2 + 12) & 0x1F;
      BOOL v7 = v6 > 1;
      uint64_t v8 = v6 - 1;
      if (v7)
      {
        uint64_t v10 = v8;
        char v9 = 1;
      }
      else
      {
        uint64_t v10 = v8;
        char v9 = 0;
      }
      if ((v9 & 1) == 0)
      {
        switch(v10)
        {
          case 0:
            *(void *)&_DWORD v28[2] = a2 + *(unsigned __int16 *)(a2 + 20 + 2 * v27);
            __leunsigned __int8 n = (**(_DWORD **)&v28[2] + 12) & 0xFFFFFFFC;
            int v18 = *(unsigned char *)(*(void *)&v28[2] + 8) & 2;
            goto LABEL_15;
          case 1:
            *(void *)&_DWORD v28[2] = a2 + *(unsigned __int16 *)(a2 + 20 + 2 * v27);
            __leunsigned __int8 n = (**(_DWORD **)&v28[2] + 9 + *(_DWORD *)(*(void *)&v28[2] + 4) + 3) & 0xFFFFFFFC;
            int v18 = *(unsigned char *)(*(void *)&v28[2] + 8) & 2;
            goto LABEL_15;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
          case 7:
            *(void *)&_DWORD v28[2] = a2 + *(unsigned __int16 *)(a2 + 20 + 2 * v27);
            __leunsigned __int8 n = 8;
            int v18 = 0;
            goto LABEL_15;
          case 15:
            *(void *)&_DWORD v28[2] = a2 + *(unsigned __int16 *)(a2 + 20 + 2 * v27);
            __leunsigned __int8 n = (**(_DWORD **)&v28[2] + 8) & 0xFFFFFFFC;
            int v18 = 0;
            goto LABEL_15;
          default:
LABEL_55:
            JUMPOUT(0);
        }
      }
      abort_report_np((uint64_t)"%s:%s:%u: illegal h->flags & P_TYPE (0x%x)");
    }
    __leunsigned __int8 n = a6;
    int v18 = 0;
LABEL_15:
    if (v24 <= (int)v25 && (unint64_t)(__len_6 + __len) + 2 >= *(unsigned __int16 *)v28 || v27 == v23 - 1)
    {
      --v25;
      break;
    }
    if (v24 != v25)
    {
      ++v27;
      __int16 v11 = *(_WORD *)(a3 + 18) - __len;
      *(_WORD *)(a3 + 18) = v11;
      *(_WORD *)(a3 + 20 + 2 * v25) = v11;
      memmove((void *)(a3 + *(unsigned __int16 *)(a3 + 18)), *(const void **)&v28[2], __len);
    }
    __len_6 += __len + 2;
    if (__len_6 >= *(unsigned __int16 *)v28 / 2)
    {
      if (!v18 || v19 == 3) {
        break;
      }
      ++v19;
    }
    ++v25;
  }
  *(_WORD *)(a3 + 16) += 2 * (v25 + 1);
  uint64_t v31 = (_DWORD *)(a1 + 40);
  if ((*(unsigned char *)(a1 + 68) & 8) != 0 && *v31 == *(_DWORD *)a2)
  {
    if (*(unsigned __int16 *)(a1 + 44) >= (int)v24) {
      ++*(_WORD *)(a1 + 44);
    }
    if (*(unsigned __int16 *)(a1 + 44) >= (int)v27)
    {
      *uint64_t v31 = *(_DWORD *)a4;
      *(_WORD *)(a1 + 44) -= v27;
    }
    else
    {
      *uint64_t v31 = *(_DWORD *)a3;
    }
  }
  if (v24 > (int)v25)
  {
    uint64_t v30 = a4;
    *a5 -= v27;
  }
  else
  {
    unsigned __int16 v24 = -1;
    uint64_t v30 = a3;
  }
  unsigned __int16 v26 = 0;
  while (2)
  {
    if (v27 < (int)v23)
    {
      if (v24 == v27)
      {
        ++v26;
        unsigned __int16 v24 = -1;
      }
      unsigned int v12 = *(_DWORD *)(a2 + 12) & 0x1F;
      BOOL v7 = v12 > 1;
      uint64_t v13 = v12 - 1;
      if (v7)
      {
        uint64_t v15 = v13;
        char v14 = 1;
      }
      else
      {
        uint64_t v15 = v13;
        char v14 = 0;
      }
      if ((v14 & 1) == 0)
      {
        switch(v15)
        {
          case 0:
            uint64_t __src = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 20 + 2 * v27));
            unsigned int __lena = (*__src + 12) & 0xFFFFFFFC;
            goto LABEL_51;
          case 1:
            uint64_t __src = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 20 + 2 * v27));
            unsigned int __lena = (*__src + 9 + __src[1] + 3) & 0xFFFFFFFC;
            goto LABEL_51;
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
            break;
          case 7:
            uint64_t __src = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 20 + 2 * v27));
            unsigned int __lena = 8;
            goto LABEL_51;
          case 15:
            uint64_t __src = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 20 + 2 * v27));
            unsigned int __lena = (*__src + 8) & 0xFFFFFFFC;
LABEL_51:
            ++v27;
            __int16 v16 = *(_WORD *)(a4 + 18) - __lena;
            *(_WORD *)(a4 + 18) = v16;
            *(_WORD *)(a4 + 20 + 2 * v26) = v16;
            memmove((void *)(a4 + *(unsigned __int16 *)(a4 + 18)), __src, __lena);
            ++v26;
            continue;
          default:
            goto LABEL_55;
        }
      }
      abort_report_np((uint64_t)"%s:%s:%u: illegal h->flags & P_TYPE (0x%x)");
    }
    break;
  }
  *(_WORD *)(a4 + 16) += 2 * v26;
  if (v24 == v23) {
    *(_WORD *)(a4 + 16) += 2;
  }
  return v30;
}

uint64_t __bt_ret(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t a6, int a7)
{
  uint64_t v10 = (unsigned int *)(*(void *)a2
                       + *(unsigned __int16 *)(*(void *)a2 + 20 + 2 * *(unsigned __int16 *)(a2 + 8)));
  if (a3)
  {
    if ((v10[2] & 2) != 0)
    {
      if (__ovfl_get(a1, (unsigned int *)((char *)v10 + 9), a3 + 1, (void **)a4, (void *)(a4 + 8))) {
        return -1;
      }
      *a3 = *(void *)a4;
    }
    else if (a7 || (*(_DWORD *)(a1 + 636) & 0x4000) != 0)
    {
      if ((unint64_t)*v10 > *(void *)(a4 + 8))
      {
        uint64_t v8 = malloc_type_realloc();
        if (!v8) {
          return -1;
        }
        *(void *)a4 = v8;
        *(void *)(a4 + 8) = *v10;
      }
      memmove(*(void **)a4, (char *)v10 + 9, *v10);
      a3[1] = *v10;
      *a3 = *(void *)a4;
    }
    else
    {
      a3[1] = *v10;
      *a3 = (char *)v10 + 9;
    }
  }
  if (a5)
  {
    if (v10[2])
    {
      if (__ovfl_get(a1, (unsigned int *)((char *)v10 + *v10 + 9), a5 + 1, (void **)a6, (void *)(a6 + 8)))return -1; {
      *a5 = *(void *)a6;
      }
    }
    else if (a7 || (*(_DWORD *)(a1 + 636) & 0x4000) != 0)
    {
      if ((unint64_t)(v10[1] + 1) > *(void *)(a6 + 8))
      {
        uint64_t v9 = malloc_type_realloc();
        if (!v9) {
          return -1;
        }
        *(void *)a6 = v9;
        *(void *)(a6 + 8) = v10[1] + 1;
      }
      memmove(*(void **)a6, (char *)v10 + *v10 + 9, v10[1]);
      a5[1] = v10[1];
      *a5 = *(void *)a6;
    }
    else
    {
      a5[1] = v10[1];
      *a5 = (char *)v10 + *v10 + 9;
    }
    return 0;
  }
  return 0;
}

uint64_t __bt_cmp(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v12 = a1;
  uint64_t v11 = a2;
  uint64_t v10 = a3;
  uint64_t v9 = 0;
  uint64_t v8 = 0;
  unsigned int v6 = 0;
  uint64_t v7 = 0;
  uint64_t v5 = *a3;
  if (*((_WORD *)a3 + 4) || *(_DWORD *)(v5 + 4) || (*(_DWORD *)(v5 + 12) & 2) != 0)
  {
    __int16 v4 = 0;
    if ((*(_DWORD *)(v5 + 12) & 2) != 0)
    {
      uint64_t v8 = (unsigned int *)(v5 + *(unsigned __int16 *)(v5 + 20 + 2 * *((unsigned __int16 *)v10 + 4)));
      if ((v8[2] & 2) != 0)
      {
        __int16 v4 = (unsigned int *)((char *)v8 + 9);
      }
      else
      {
        unsigned int v6 = (char *)v8 + 9;
        uint64_t v7 = *v8;
      }
    }
    else
    {
      uint64_t v9 = (unsigned int *)(v5 + *(unsigned __int16 *)(v5 + 20 + 2 * *((unsigned __int16 *)v10 + 4)));
      if ((v9[2] & 2) != 0)
      {
        __int16 v4 = (unsigned int *)((char *)v9 + 9);
      }
      else
      {
        unsigned int v6 = (char *)v9 + 9;
        uint64_t v7 = *v9;
      }
    }
    if (v4)
    {
      if (__ovfl_get(v12, v4, &v7, (void **)(v12 + 496), (void *)(v12 + 504))) {
        return -1;
      }
      unsigned int v6 = *(char **)(v12 + 496);
    }
    return (*(uint64_t (**)(uint64_t, char **))(v12 + 544))(v11, &v6);
  }
  return 1;
}

uint64_t __bt_defcmp(unsigned __int8 **a1, unsigned __int8 **a2)
{
  if (a1[1] >= a2[1]) {
    __int16 v4 = a2[1];
  }
  else {
    __int16 v4 = a1[1];
  }
  uint64_t v7 = v4;
  unsigned int v6 = *a1;
  for (unsigned __int16 i = *a2; v7--; ++i)
  {
    if (*v6 != *i) {
      return (*v6 - *i);
    }
    ++v6;
  }
  return a1[1] - a2[1];
}

uint64_t __bt_defpfx(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v7 = 1;
  if (a1[1] >= a2[1]) {
    uint64_t v5 = a2[1];
  }
  else {
    uint64_t v5 = a1[1];
  }
  unsigned int v6 = v5;
  uint64_t v9 = *a1;
  for (unsigned __int16 i = *a2; v6--; ++i)
  {
    if (*v9 != *i) {
      return v7;
    }
    ++v9;
    ++v7;
  }
  if (a1[1] >= a2[1]) {
    return (uint64_t)a1[1];
  }
  else {
    return (uint64_t)(a1[1] + 1);
  }
}

DB *__cdecl dbopen(const char *a1, int a2, int a3, DBTYPE a4, const void *a5)
{
  if ((a2 & 0x1FFFF1C9) != 0) {
    goto LABEL_9;
  }
  if (a4 == DB_BTREE) {
    return (DB *)__bt_open((uint64_t)a1, a2 & 0xE36, a3, a5, a2 & 0xE0000000);
  }
  if (a4 == DB_HASH) {
    return (DB *)__hash_open(a1, a2 & 0xE36, a3, (uint64_t)a5, a2 & 0xE0000000);
  }
  if (a4 != DB_RECNO)
  {
LABEL_9:
    *__error() = 22;
    return 0;
  }
  return (DB *)__rec_open((uint64_t)a1, a2 & 0xE36, a3, (uint64_t)a5, a2 & 0xE0000000);
}

void *__dbpanic(void *result)
{
  result[2] = __dberr;
  result[8] = __dberr;
  result[3] = __dberr;
  result[4] = __dberr;
  result[5] = __dberr;
  result[6] = __dberr;
  return result;
}

uint64_t __dberr()
{
  return 0xFFFFFFFFLL;
}

uint64_t __hash_open(const char *a1, int a2, int a3, uint64_t a4, int a5)
{
  unsigned __int16 v23 = a1;
  int v22 = a2;
  int v21 = a3;
  uint64_t v20 = a4;
  int v19 = a5;
  uint64_t inited = 0;
  memset(&__b, 0, sizeof(__b));
  if ((v22 & 3) == 1) {
    ++v22;
  }
  uint64_t inited = (int *)malloc_type_calloc();
  if (!inited) {
    return 0;
  }
  inited[71] = -1;
  inited[70] = v22;
  if (v23)
  {
    int v5 = open_NOCANCEL();
    inited[71] = v5;
    if (v5 == -1)
    {
      int v11 = *__error();
LABEL_47:
      free(inited);
      *__error() = v11;
      return 0;
    }
    uint64_t v7 = 1;
    fcntl_NOCANCEL();
    BOOL v10 = 0;
    if (!fstat(inited[71], &__b))
    {
      BOOL v10 = 0;
      if (!__b.st_size)
      {
        BOOL v9 = 1;
        if ((v22 & 3) == 0) {
          BOOL v9 = (v22 & 0x200) != 0;
        }
        BOOL v10 = v9;
      }
    }
    int v13 = v10;
  }
  else
  {
    int v13 = 1;
  }
  if (!v13)
  {
    if (v20 && *(void *)(v20 + 16)) {
      *((void *)inited + 34) = *(void *)(v20 + 16);
    }
    else {
      *((void *)inited + 34) = __default_hash;
    }
    int NOCANCEL = read_NOCANCEL();
    swap_header((unsigned int *)inited);
    if (NOCANCEL == -1) {
      goto LABEL_17;
    }
    if (NOCANCEL == 260)
    {
      if (*inited == 398689)
      {
        if (inited[1] == 2 || inited[1] == 1)
        {
          if ((*((unsigned int (**)(const char *, ...))inited + 34))("%$sniglet^&", 12, v7) == inited[16])
          {
            if (alloc_segs((uint64_t)inited, (inited[10] + inited[6]) / inited[6])) {
              return 0;
            }
            int v15 = (inited[inited[8] + 17] + 8 * inited[3] - 1) >> (inited[4] + 3);
            inited[148] = v15;
            bzero(inited + 84, 8 * v15);
            goto LABEL_36;
          }
          int v11 = 79;
        }
        else
        {
          int v11 = 79;
        }
      }
      else
      {
        int v11 = 79;
      }
    }
    else
    {
      int v11 = 79;
    }
LABEL_45:
    if (inited) {
      close_NOCANCEL();
    }
    goto LABEL_47;
  }
  uint64_t inited = init_hash(inited, v23, v20);
  if (!inited)
  {
LABEL_17:
    int v11 = *__error();
    goto LABEL_45;
  }
LABEL_36:
  if (v20 && *(_DWORD *)(v20 + 12)) {
    __buf_init((uint64_t)inited, *(_DWORD *)(v20 + 12));
  }
  else {
    __buf_init((uint64_t)inited, 0x10000);
  }
  inited[81] = v13;
  BOOL v8 = 0;
  if (v23) {
    BOOL v8 = (inited[70] & 2) != 0;
  }
  inited[82] = v8;
  inited[78] = -1;
  uint64_t v16 = malloc_type_malloc();
  if (v16)
  {
    *(void *)(v16 + 56) = inited;
    *(void *)(v16 + 8) = hash_close;
    *(void *)(v16 + 16) = hash_delete;
    *(void *)(v16 + 64) = hash_fd;
    *(void *)(v16 + 24) = hash_get;
    *(void *)(v16 + 32) = hash_put;
    *(void *)(v16 + 40) = hash_seq;
    *(void *)(v16 + 48) = hash_sync;
    *(_DWORD *)uint64_t v16 = 1;
    return v16;
  }
  else
  {
    int v12 = *__error();
    hdestroy();
    *__error() = v12;
    return 0;
  }
}

_DWORD *init_hash(_DWORD *a1, const char *a2, uint64_t a3)
{
  BOOL v8 = a1;
  uint64_t v7 = a2;
  uint64_t v6 = a3;
  memset(&__b, 0, sizeof(__b));
  int v4 = 1;
  v8[14] = 0;
  v8[2] = 1234;
  v8[3] = 4096;
  v8[4] = 12;
  v8[6] = 256;
  v8[7] = 8;
  v8[5] = 256;
  v8[13] = 0x10000;
  *((void *)v8 + 34) = __default_hash;
  memset(v8 + 17, 0, 0x80uLL);
  memset(v8 + 49, 0, 0x40uLL);
  if (v7)
  {
    if (stat(v7, &__b)) {
      return 0;
    }
    v8[3] = __b.st_blksize;
    v8[4] = __log2(v8[3]);
  }
  if (v6)
  {
    if (*(_DWORD *)v6)
    {
      v8[4] = __log2(*(_DWORD *)v6);
      v8[3] = 1 << v8[4];
      if ((int)v8[3] > 0x10000) {
        goto LABEL_8;
      }
    }
    if (*(_DWORD *)(v6 + 4)) {
      v8[13] = *(_DWORD *)(v6 + 4);
    }
    if (*(void *)(v6 + 16)) {
      *((void *)v8 + 34) = *(void *)(v6 + 16);
    }
    if (*(_DWORD *)(v6 + 8)) {
      int v4 = *(_DWORD *)(v6 + 8);
    }
    if (*(_DWORD *)(v6 + 24))
    {
      if (*(_DWORD *)(v6 + 24) != 4321 && *(_DWORD *)(v6 + 24) != 1234)
      {
LABEL_8:
        *__error() = 22;
        return 0;
      }
      v8[2] = *(_DWORD *)(v6 + 24);
    }
  }
  if (init_htab(v8, v4)) {
    return 0;
  }
  else {
    return v8;
  }
}

unsigned int *swap_header(unsigned int *result)
{
  unsigned int v19 = *result;
  *(unsigned char *)uint64_t result = HIBYTE(*result);
  *((unsigned char *)result + 1) = BYTE2(v19);
  *((unsigned char *)result + 2) = BYTE1(v19);
  *((unsigned char *)result + 3) = v19;
  unsigned int v18 = result[1];
  *((unsigned char *)result + 4) = HIBYTE(v18);
  *((unsigned char *)result + 5) = BYTE2(v18);
  *((unsigned char *)result + 6) = BYTE1(v18);
  *((unsigned char *)result + 7) = v18;
  unsigned int v17 = result[2];
  *((unsigned char *)result + 8) = HIBYTE(v17);
  *((unsigned char *)result + 9) = BYTE2(v17);
  *((unsigned char *)result + 10) = BYTE1(v17);
  *((unsigned char *)result + 11) = v17;
  unsigned int v16 = result[3];
  *((unsigned char *)result + 12) = HIBYTE(v16);
  *((unsigned char *)result + 13) = BYTE2(v16);
  *((unsigned char *)result + 14) = BYTE1(v16);
  *((unsigned char *)result + 15) = v16;
  unsigned int v15 = result[4];
  *((unsigned char *)result + 16) = HIBYTE(v15);
  *((unsigned char *)result + 17) = BYTE2(v15);
  *((unsigned char *)result + 18) = BYTE1(v15);
  *((unsigned char *)result + 19) = v15;
  unsigned int v14 = result[5];
  *((unsigned char *)result + 20) = HIBYTE(v14);
  *((unsigned char *)result + 21) = BYTE2(v14);
  *((unsigned char *)result + 22) = BYTE1(v14);
  *((unsigned char *)result + 23) = v14;
  unsigned int v13 = result[6];
  *((unsigned char *)result + 24) = HIBYTE(v13);
  *((unsigned char *)result + 25) = BYTE2(v13);
  *((unsigned char *)result + 26) = BYTE1(v13);
  *((unsigned char *)result + 27) = v13;
  unsigned int v12 = result[7];
  *((unsigned char *)result + 28) = HIBYTE(v12);
  *((unsigned char *)result + 29) = BYTE2(v12);
  *((unsigned char *)result + 30) = BYTE1(v12);
  *((unsigned char *)result + 31) = v12;
  unsigned int v11 = result[8];
  *((unsigned char *)result + 32) = HIBYTE(v11);
  *((unsigned char *)result + 33) = BYTE2(v11);
  *((unsigned char *)result + 34) = BYTE1(v11);
  *((unsigned char *)result + 35) = v11;
  unsigned int v10 = result[9];
  *((unsigned char *)result + 36) = HIBYTE(v10);
  *((unsigned char *)result + 37) = BYTE2(v10);
  *((unsigned char *)result + 38) = BYTE1(v10);
  *((unsigned char *)result + 39) = v10;
  unsigned int v9 = result[10];
  *((unsigned char *)result + 40) = HIBYTE(v9);
  *((unsigned char *)result + 41) = BYTE2(v9);
  *((unsigned char *)result + 42) = BYTE1(v9);
  *((unsigned char *)result + 43) = v9;
  unsigned int v8 = result[11];
  *((unsigned char *)result + 44) = HIBYTE(v8);
  *((unsigned char *)result + 45) = BYTE2(v8);
  *((unsigned char *)result + 46) = BYTE1(v8);
  *((unsigned char *)result + 47) = v8;
  unsigned int v7 = result[12];
  *((unsigned char *)result + 48) = HIBYTE(v7);
  *((unsigned char *)result + 49) = BYTE2(v7);
  *((unsigned char *)result + 50) = BYTE1(v7);
  *((unsigned char *)result + 51) = v7;
  unsigned int v6 = result[13];
  *((unsigned char *)result + 52) = HIBYTE(v6);
  *((unsigned char *)result + 53) = BYTE2(v6);
  *((unsigned char *)result + 54) = BYTE1(v6);
  *((unsigned char *)result + 55) = v6;
  unsigned int v5 = result[14];
  *((unsigned char *)result + 56) = HIBYTE(v5);
  *((unsigned char *)result + 57) = BYTE2(v5);
  *((unsigned char *)result + 58) = BYTE1(v5);
  *((unsigned char *)result + 59) = v5;
  unsigned int v4 = result[15];
  *((unsigned char *)result + 60) = HIBYTE(v4);
  *((unsigned char *)result + 61) = BYTE2(v4);
  *((unsigned char *)result + 62) = BYTE1(v4);
  *((unsigned char *)result + 63) = v4;
  unsigned int v3 = result[16];
  *((unsigned char *)result + 64) = HIBYTE(v3);
  *((unsigned char *)result + 65) = BYTE2(v3);
  *((unsigned char *)result + 66) = BYTE1(v3);
  *((unsigned char *)result + 67) = v3;
  for (int i = 0; i < 32; ++i)
  {
    unsigned int v2 = result[i + 17];
    LOBYTE(result[i + 17]) = HIBYTE(v2);
    BYTE1(result[i + 17]) = BYTE2(v2);
    BYTE2(result[i + 17]) = BYTE1(v2);
    HIBYTE(result[i + 17]) = v2;
    __int16 v1 = *((_WORD *)result + i + 98);
    *((unsigned char *)result + 2 * i + 196) = HIBYTE(v1);
    *((unsigned char *)result + 2 * i + 197) = v1;
  }
  return result;
}

uint64_t alloc_segs(uint64_t a1, int a2)
{
  uint64_t v2 = malloc_type_calloc();
  *(void *)(a1 + 648) = v2;
  if (v2)
  {
    *(_DWORD *)(a1 + 260) = a2;
    if (a2)
    {
      uint64_t v6 = malloc_type_calloc();
      if (v6)
      {
        for (int i = 0; i < a2; ++i)
          *(void *)(*(void *)(a1 + 648) + 8 * i) = v6 + 8 * (i << *(_DWORD *)(a1 + 28));
        return 0;
      }
      else
      {
        uint64_t v5 = *__error();
        hdestroy();
        *__error() = v5;
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    int v4 = *__error();
    hdestroy();
    *__error() = v4;
    return -1;
  }
}

void hdestroy(void)
{
  uint64_t v6 = (unsigned char *)v0;
  int v4 = 0;
  if (__buf_free(v0, 1, *(_DWORD *)(v0 + 328))) {
    int v4 = *__error();
  }
  if (*((void *)v6 + 81))
  {
    free(**((void ***)v6 + 81));
    while (1)
    {
      int v1 = *((_DWORD *)v6 + 66);
      *((_DWORD *)v6 + 66) = v1 - 1;
      if (!v1) {
        break;
      }
      uint64_t v2 = *((void *)v6 + 81);
      int v3 = *((_DWORD *)v6 + 65) - 1;
      *((_DWORD *)v6 + 65) = v3;
      free(*(void **)(v2 + 8 * v3));
    }
    free(*((void **)v6 + 81));
  }
  if (flush_meta(v6) && !v4) {
    int v4 = *__error();
  }
  for (int i = 0; i < *((_DWORD *)v6 + 148); ++i)
  {
    if (*(void *)&v6[8 * i + 336]) {
      free(*(void **)&v6[8 * i + 336]);
    }
  }
  if (*((void *)v6 + 37)) {
    free(*((void **)v6 + 37));
  }
  if (*((void *)v6 + 36)) {
    free(*((void **)v6 + 36));
  }
  if (*((_DWORD *)v6 + 71) != -1) {
    close_NOCANCEL();
  }
  free(v6);
  if (v4) {
    *__error() = v4;
  }
}

uint64_t hash_close(void *a1)
{
  if (a1)
  {
    hdestroy();
    unsigned int v3 = v1;
    free(a1);
    return v3;
  }
  else
  {
    return -1;
  }
}

uint64_t hash_delete(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  int v4 = *(_DWORD **)(a1 + 56);
  if (a3 < 2)
  {
    if ((v4[70] & 3) != 0)
    {
      return hash_access(v4, 3u, a2, 0);
    }
    else
    {
      *__error() = 1;
      v4[80] = 1;
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    v4[80] = 22;
    return -1;
  }
}

uint64_t hash_fd(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 56);
    if (*(_DWORD *)(v2 + 284) == -1)
    {
      *__error() = 2;
      return -1;
    }
    else
    {
      return *(unsigned int *)(v2 + 284);
    }
  }
  else
  {
    return -1;
  }
}

uint64_t hash_get(uint64_t a1, uint64_t *a2, void *a3, int a4)
{
  uint64_t v5 = *(_DWORD **)(a1 + 56);
  if (a4)
  {
    *__error() = 22;
    v5[80] = 22;
    return -1;
  }
  else
  {
    return hash_access(v5, 0, a2, a3);
  }
}

uint64_t hash_put(uint64_t a1, uint64_t *a2, void *a3, int a4)
{
  uint64_t v6 = *(_DWORD **)(a1 + 56);
  if (!a4 || a4 == 8)
  {
    if ((v6[70] & 3) != 0)
    {
      if (a4 == 8) {
        unsigned int v4 = 2;
      }
      else {
        unsigned int v4 = 1;
      }
      return hash_access(v6, v4, a2, a3);
    }
    else
    {
      *__error() = 1;
      v6[80] = 1;
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    v6[80] = 22;
    return -1;
  }
}

uint64_t hash_seq(uint64_t a1, void *a2, void *a3, int a4)
{
  unint64_t buf = 0;
  uint64_t v10 = *(void *)(a1 + 56);
  if (!a4 || a4 == 3 || a4 == 7)
  {
    if (*(int *)(v10 + 312) < 0 || a4 == 3)
    {
      *(_DWORD *)(v10 + 312) = 0;
      *(_DWORD *)(v10 + 316) = 1;
      *(void *)(v10 + 304) = 0;
    }
LABEL_8:
    unsigned int v9 = 0;
    while (1)
    {
      BOOL v7 = 1;
      if (v9) {
        BOOL v7 = *v9 == 0;
      }
      if (!v7) {
        break;
      }
      unint64_t buf = *(void *)(v10 + 304);
      if (!buf)
      {
        for (unsigned int i = *(_DWORD *)(v10 + 312); i <= *(_DWORD *)(v10 + 40); ++i)
        {
          unint64_t buf = __get_buf(v10, i, 0, 0);
          if (!buf) {
            return -1;
          }
          *(void *)(v10 + 304) = buf;
          unsigned int v9 = *(_WORD **)(buf + 32);
          if (*v9) {
            break;
          }
          *(_DWORD *)(v10 + 316) = 1;
        }
        *(_DWORD *)(v10 + 312) = i;
        if (*(_DWORD *)(v10 + 312) <= *(_DWORD *)(v10 + 40)) {
          goto LABEL_25;
        }
        *(_DWORD *)(v10 + 312) = -1;
        return 1;
      }
      unsigned int v9 = *(_WORD **)(*(void *)(v10 + 304) + 32);
      if (a4 == 7)
      {
        *(_DWORD *)(v10 + 316) += 2;
        if (*(_DWORD *)(v10 + 316) > (int)(unsigned __int16)*v9)
        {
          *(void *)(v10 + 304) = 0;
          ++*(_DWORD *)(v10 + 312);
          *(_DWORD *)(v10 + 316) = 1;
          goto LABEL_8;
        }
      }
LABEL_25:
      while (!v9[*(_DWORD *)(v10 + 316) + 1])
      {
        unint64_t v4 = __get_buf(v10, (unsigned __int16)v9[*(int *)(v10 + 316)], buf, 0);
        *(void *)(v10 + 304) = v4;
        unint64_t buf = v4;
        if (!v4) {
          return -1;
        }
        unsigned int v9 = *(_WORD **)(v4 + 32);
        *(_DWORD *)(v10 + 316) = 1;
      }
      if (!*v9)
      {
        *(void *)(v10 + 304) = 0;
        ++*(_DWORD *)(v10 + 312);
      }
    }
    unsigned __int16 v8 = *(_DWORD *)(v10 + 316);
    if ((unsigned __int16)v9[v8 + 1] >= 4u)
    {
      if (!*(void *)(v10 + 304)) {
        return -1;
      }
      *a2 = *(void *)(*(void *)(v10 + 304) + 32) + (unsigned __int16)v9[v8];
      if (v8 <= 1u) {
        int v6 = *(_DWORD *)(v10 + 12);
      }
      else {
        int v6 = (unsigned __int16)v9[v8 - 1];
      }
      a2[1] = v6 - (unsigned __int16)v9[v8];
      *a3 = *(void *)(*(void *)(v10 + 304) + 32) + (unsigned __int16)v9[v8 + 1];
      a3[1] = (unsigned __int16)v9[v8] - (unsigned __int16)v9[v8 + 1];
    }
    else if (__big_keydata(v10, buf, a2, a3, 1u))
    {
      return -1;
    }
    return 0;
  }
  else
  {
    *__error() = 22;
    *(_DWORD *)(v10 + 320) = 22;
    return -1;
  }
}

uint64_t hash_sync(uint64_t a1, int a2)
{
  if (a2)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 56);
    if (*(_DWORD *)(v3 + 328))
    {
      if (__buf_free(v3, 0, 1) || flush_meta((unsigned char *)v3))
      {
        return -1;
      }
      else
      {
        *(_DWORD *)(v3 + 324) = 0;
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __expand_table(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 40) + 1;
  *(_DWORD *)(a1 + 40) = v1;
  unsigned int v7 = v1;
  unsigned int v8 = *(_DWORD *)(a1 + 40) & *(_DWORD *)(a1 + 48);
  signed int v5 = v1 >> *(_DWORD *)(a1 + 28);
  if (v5 >= *(_DWORD *)(a1 + 260))
  {
    if (v5 >= *(_DWORD *)(a1 + 20))
    {
      int v6 = 8 * *(_DWORD *)(a1 + 20);
      if (!hash_realloc((const void **)(a1 + 648), v6, 16 * *(_DWORD *)(a1 + 20))) {
        return -1;
      }
      *(_DWORD *)(a1 + 20) = 2 * v6;
    }
    uint64_t v2 = malloc_type_calloc();
    *(void *)(*(void *)(a1 + 648) + 8 * v5) = v2;
    if (!v2) {
      return -1;
    }
    ++*(_DWORD *)(a1 + 264);
    ++*(_DWORD *)(a1 + 260);
  }
  int v4 = __log2(*(_DWORD *)(a1 + 40) + 1);
  if (v4 > *(_DWORD *)(a1 + 32))
  {
    *(_DWORD *)(a1 + 68 + 4 * v4) = *(_DWORD *)(a1 + 68 + 4 * *(int *)(a1 + 32));
    *(_DWORD *)(a1 + 32) = v4;
  }
  if (v7 > *(_DWORD *)(a1 + 44))
  {
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 44) = v7 | *(_DWORD *)(a1 + 48);
  }
  return __split_page((_DWORD *)a1, v8, v7);
}

char *hash_realloc(const void **a1, int a2, int a3)
{
  __dst = (char *)malloc_type_malloc();
  if (__dst)
  {
    memmove(__dst, *a1, a2);
    bzero(&__dst[a2], a3 - a2);
    free((void *)*a1);
    *a1 = __dst;
  }
  return __dst;
}

uint64_t __call_hash(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4 = (*(uint64_t (**)(uint64_t, void))(a1 + 272))(a2, a3) & *(_DWORD *)(a1 + 44);
  if (v4 > *(_DWORD *)(a1 + 40)) {
    v4 &= *(_DWORD *)(a1 + 48);
  }
  return v4;
}

uint64_t init_htab(_DWORD *a1, int a2)
{
  signed int v6 = (a2 - 1) / a1[13] + 1;
  if (v6 <= 2) {
    int v2 = __log2(2u);
  }
  else {
    int v2 = __log2(v6);
  }
  int v5 = 1 << v2;
  a1[v2 + 17] = v2 + 1;
  a1[v2 + 18] = v2 + 1;
  a1[8] = v2;
  a1[9] = 2;
  if (__ibitmap((uint64_t)a1, ((_WORD)v2 << 11) + 1, v2 + 1, 0))
  {
    return -1;
  }
  else
  {
    a1[12] = v5 - 1;
    a1[10] = v5 - 1;
    a1[11] = 2 * v5 - 1;
    a1[15] = (0x1FFuLL >> a1[4]) + 1;
    int v4 = 1 << __log2((v5 - 1) / a1[6] + 1);
    if (v4 > a1[5]) {
      a1[5] = v4;
    }
    return alloc_segs((uint64_t)a1, v4);
  }
}

uint64_t flush_meta(unsigned char *a1)
{
  unsigned int v7 = a1;
  signed int v6 = 0;
  bzero(v5, 0x104uLL);
  if (*((_DWORD *)v7 + 82))
  {
    *(_DWORD *)unsigned int v7 = 398689;
    *((_DWORD *)v7 + 1) = 2;
    int v1 = (*((uint64_t (**)(const char *, ...))v7 + 34))("%$sniglet^&", 12);
    *((_DWORD *)v7 + 16) = v1;
    signed int v6 = v5;
    swap_header_copy(v7, v5);
    int v3 = pwrite_NOCANCEL();
    if (v3 == -1)
    {
      return -1;
    }
    else if (v3 == 260)
    {
      for (int i = 0; i < 32; ++i)
      {
        if (*(void *)&v7[8 * i + 336]
          && __put_page(v7, *(unsigned __int16 **)&v7[8 * i + 336], *(unsigned __int16 *)&v7[2 * i + 196], 0, 1))
        {
          return -1;
        }
      }
      return 0;
    }
    else
    {
      *__error() = 79;
      *((_DWORD *)v7 + 80) = *__error();
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

unsigned char *swap_header_copy(unsigned char *result, unsigned char *a2)
{
  *a2 = result[3];
  a2[1] = result[2];
  a2[2] = result[1];
  a2[3] = *result;
  a2[4] = result[7];
  a2[5] = result[6];
  a2[6] = result[5];
  a2[7] = result[4];
  a2[8] = result[11];
  a2[9] = result[10];
  a2[10] = result[9];
  a2[11] = result[8];
  a2[12] = result[15];
  a2[13] = result[14];
  a2[14] = result[13];
  a2[15] = result[12];
  a2[16] = result[19];
  a2[17] = result[18];
  a2[18] = result[17];
  a2[19] = result[16];
  a2[20] = result[23];
  a2[21] = result[22];
  a2[22] = result[21];
  a2[23] = result[20];
  a2[24] = result[27];
  a2[25] = result[26];
  a2[26] = result[25];
  a2[27] = result[24];
  a2[28] = result[31];
  a2[29] = result[30];
  a2[30] = result[29];
  a2[31] = result[28];
  a2[32] = result[35];
  a2[33] = result[34];
  a2[34] = result[33];
  a2[35] = result[32];
  a2[36] = result[39];
  a2[37] = result[38];
  a2[38] = result[37];
  a2[39] = result[36];
  a2[40] = result[43];
  a2[41] = result[42];
  a2[42] = result[41];
  a2[43] = result[40];
  a2[44] = result[47];
  a2[45] = result[46];
  a2[46] = result[45];
  a2[47] = result[44];
  a2[48] = result[51];
  a2[49] = result[50];
  a2[50] = result[49];
  a2[51] = result[48];
  a2[52] = result[55];
  a2[53] = result[54];
  a2[54] = result[53];
  a2[55] = result[52];
  a2[56] = result[59];
  a2[57] = result[58];
  a2[58] = result[57];
  a2[59] = result[56];
  a2[60] = result[63];
  a2[61] = result[62];
  a2[62] = result[61];
  a2[63] = result[60];
  a2[64] = result[67];
  a2[65] = result[66];
  a2[66] = result[65];
  a2[67] = result[64];
  for (int i = 0; i < 32; ++i)
  {
    a2[4 * i + 68] = result[4 * i + 71];
    a2[4 * i + 69] = result[4 * i + 70];
    a2[4 * i + 70] = result[4 * i + 69];
    a2[4 * i + 71] = result[4 * i + 68];
    a2[2 * i + 196] = result[2 * i + 197];
    a2[2 * i + 197] = result[2 * i + 196];
  }
  return result;
}

uint64_t hash_access(_DWORD *a1, unsigned int a2, uint64_t *a3, void *a4)
{
  unsigned __int16 v27 = a1;
  unsigned int v26 = a2;
  unsigned __int16 v25 = a3;
  unsigned __int16 v24 = a4;
  unint64_t buf = 0;
  uint64_t v22 = 0;
  int __n_4 = a1[3];
  __unsigned __int8 n = a3[1];
  __s1 = (char *)*a3;
  unsigned int v4 = __call_hash((uint64_t)a1, *a3, __n);
  unint64_t buf = __get_buf((uint64_t)a1, v4, 0, 0);
  if (buf)
  {
    unint64_t v21 = buf;
    *(unsigned char *)(buf + 40) |= 8u;
    int v5 = *(unsigned __int16 **)(buf + 32);
    unsigned int v19 = v5 + 1;
    int v18 = *v5;
    for (int i = 1; ; i += 2)
    {
      while (1)
      {
        if (i >= v18) {
          goto LABEL_23;
        }
        if (v19[1] >= 4u) {
          break;
        }
        if (v19[1])
        {
          if (v19[1] < 4u)
          {
            int i = __find_bigpair((uint64_t)v27, buf, i, __s1, __n);
            if (i > 0) {
              goto LABEL_32;
            }
            if (i != -2)
            {
              *(unsigned char *)(v21 + 40) &= ~8u;
              return -1;
            }
            uint64_t v22 = buf;
            unsigned __int16 last_page = __find_last_page((uint64_t)v27, (unint64_t *)&v22);
            if (!last_page)
            {
              unint64_t buf = v22;
LABEL_23:
              if (v26 && (v26 != 2 && v26 != 1 ? (char v9 = 0) : (char v9 = 1), (v9 & 1) != 0))
              {
                if (__addel(v27, buf, (uint64_t)v25, (uint64_t)v24))
                {
                  *(unsigned char *)(v21 + 40) &= ~8u;
                  return -1;
                }
                else
                {
                  *(unsigned char *)(v21 + 40) &= ~8u;
                  return 0;
                }
              }
              else
              {
                *(unsigned char *)(v21 + 40) &= ~8u;
                return 1;
              }
            }
            unint64_t buf = __get_buf((uint64_t)v27, last_page, v22, 0);
            if (!buf)
            {
              *(unsigned char *)(v21 + 40) &= ~8u;
              return -1;
            }
            unsigned int v8 = *(unsigned __int16 **)(buf + 32);
            unsigned int v19 = v8 + 1;
            int v18 = *v8;
            int i = 1;
            int __n_4 = v27[3];
          }
        }
        else
        {
          unint64_t buf = __get_buf((uint64_t)v27, *v19, buf, 0);
          if (!buf)
          {
            *(unsigned char *)(v21 + 40) &= ~8u;
            return -1;
          }
          signed int v6 = *(unsigned __int16 **)(buf + 32);
          unsigned int v19 = v6 + 1;
          int v18 = *v6;
          int i = 1;
          int __n_4 = v27[3];
        }
      }
      if (__n == __n_4 - *v19 && !memcmp(__s1, (const void *)(*(void *)(buf + 32) + *v19), __n)) {
        break;
      }
      int __n_4 = v19[1];
      v19 += 2;
    }
LABEL_32:
    if (v26)
    {
      uint64_t v11 = v26;
      char v10 = 1;
    }
    else
    {
      uint64_t v11 = 0;
      char v10 = 0;
    }
    if (v10) {
      abort_report_np((uint64_t)"%s:%s:%u: illegal action (%d)");
    }
    switch(v11)
    {
      case 0:
        uint64_t v20 = *(void *)(buf + 32);
        if (*(unsigned __int16 *)(v20 + 2 * (i + 1)) >= 4u)
        {
          *unsigned __int16 v24 = *(void *)(buf + 32) + *(unsigned __int16 *)(v20 + 2 * (i + 1));
          v24[1] = *(unsigned __int16 *)(v20 + 2 * i) - *(unsigned __int16 *)(v20 + 2 * (i + 1));
        }
        else if (__big_return((uint64_t)v27, buf, i, v24, 0))
        {
          return -1;
        }
LABEL_51:
        *(unsigned char *)(v21 + 40) &= ~8u;
        unsigned int v28 = 0;
        break;
      case 1:
        if (!__delpair(v27, buf, i) && !__addel(v27, buf, (uint64_t)v25, (uint64_t)v24)) {
          goto LABEL_51;
        }
        *(unsigned char *)(v21 + 40) &= ~8u;
        return -1;
      case 2:
        *(unsigned char *)(v21 + 40) &= ~8u;
        return 1;
      case 3:
        if (!__delpair(v27, buf, i)) {
          goto LABEL_51;
        }
        return -1;
      default:
        JUMPOUT(0);
    }
  }
  else
  {
    return -1;
  }
  return v28;
}

uint64_t __big_insert(_DWORD *a1, uint64_t a2, char **a3, char **a4)
{
  uint64_t v26 = a2;
  char v10 = *(unsigned __int16 **)(a2 + 32);
  unsigned __int16 v24 = v10;
  uint64_t __src = *a3;
  int v23 = a3[1];
  unsigned int v8 = *a4;
  unsigned int __len_4 = a4[1];
  unsigned __int16 __len_2 = v10[*v10 + 1] - 8;
  while (v23)
  {
    if (__len_2 >= v23) {
      unsigned __int16 v7 = v23;
    }
    else {
      unsigned __int16 v7 = __len_2;
    }
    unsigned __int16 v11 = v24[*v24 + 2] - v7;
    memmove((char *)v10 + v11, __src, v7);
    v23 -= v7;
    __src += v7;
    int v19 = *v24 + 1;
    v24[v19++] = v11;
    *unsigned __int16 v24 = v19;
    v24[*v24 + 1] = v11 - 2 * (v19 + 3);
    v24[*v24 + 2] = v11;
    v24[v19] = 1;
    uint64_t v26 = __add_ovflpage(a1, v26);
    if (!v26) {
      return -1;
    }
    int v20 = *v24;
    if (!v23)
    {
      unsigned __int16 __len_2a = v24[*v24 + 1];
      if (!__len_2a
        || (__len_2a >= __len_4 ? (unsigned __int16 v6 = __len_4) : (unsigned __int16 v6 = v24[*v24 + 1]), __len_2a == __len_4 && (char *)__len_4 == a4[1]))
      {
        v24[v20 - 2] = 2;
      }
      else
      {
        unsigned __int16 v12 = v24[*v24 + 2] - v6;
        memmove((char *)v10 + v12, v8, v6);
        v8 += v6;
        __len_4 -= v6;
        v24[v20] = v12;
        v24[v20 - 2] = 3;
        v24[*v24 + 1] -= v6;
        v24[*v24 + 2] = v12;
      }
    }
    unsigned __int16 v24 = *(unsigned __int16 **)(v26 + 32);
    char v10 = v24;
    *(unsigned char *)(v26 + 40) |= 1u;
    unsigned __int16 __len_2 = v24[*v24 + 1] - 8;
  }
  unsigned __int16 __len_2b = v24[*v24 + 1] - 8;
  while (__len_4)
  {
    if (__len_2b >= __len_4) {
      unsigned __int16 v5 = __len_4;
    }
    else {
      unsigned __int16 v5 = __len_2b;
    }
    __leunsigned __int8 n = v5;
    if (__len_2b == __len_4 && (char *)__len_4 == a4[1]) {
      __leunsigned __int8 n = v5 - 1;
    }
    unsigned __int16 v13 = v24[*v24 + 2] - __len;
    memmove((char *)v10 + v13, v8, __len);
    __len_4 -= __len;
    v8 += __len;
    int v21 = *v24 + 1;
    v24[v21] = v13;
    int v22 = v21 + 1;
    *unsigned __int16 v24 = v22;
    v24[*v24 + 1] = v13 - 2 * (v22 + 3);
    v24[*v24 + 2] = v13;
    if (__len_4)
    {
      v24[v22] = 2;
      uint64_t v26 = __add_ovflpage(a1, v26);
      if (!v26) {
        return -1;
      }
      char v10 = *(unsigned __int16 **)(v26 + 32);
      unsigned __int16 v24 = v10;
    }
    else
    {
      v24[v22] = 3;
    }
    *(unsigned char *)(v26 + 40) |= 1u;
    unsigned __int16 __len_2b = v24[*v24 + 1] - 8;
  }
  return 0;
}

uint64_t __big_delete(_DWORD *a1, unint64_t a2)
{
  unint64_t buf = a2;
  uint64_t v12 = 0;
  char v9 = *(unsigned __int16 **)(a2 + 32);
  int v6 = 0;
  while (1)
  {
    BOOL v3 = 1;
    if (v6) {
      BOOL v3 = v9[2] != 3;
    }
    if (!v3) {
      break;
    }
    if (v9[2] == 2 || v9[2] == 3) {
      int v6 = 1;
    }
    if (v9[2] == 3 && v9[*v9 + 1]) {
      break;
    }
    unsigned __int16 v7 = v9[*v9 - 1];
    *(unsigned char *)(buf + 40) |= 1u;
    unint64_t buf = __get_buf((uint64_t)a1, v7, buf, 0);
    if (v12) {
      __free_ovflpage(a1, v12);
    }
    uint64_t v12 = buf;
    if (!buf) {
      return -1;
    }
    char v9 = *(unsigned __int16 **)(buf + 32);
  }
  int v4 = *v9;
  unsigned __int16 v8 = v9[v4 - 1];
  char v10 = *(unsigned __int16 **)(a2 + 32);
  if (v4 <= 2)
  {
    *(void *)(a2 + 16) = 0;
  }
  else
  {
    v10[1] = v8;
    v10[2] = 0;
    *(void *)(a2 + 16) = *(void *)(buf + 16);
  }
  unsigned __int16 v5 = v4 - 2;
  *char v10 = v5;
  v10[*v10 + 1] = a1[3] - 2 * (v5 + 3);
  v10[*v10 + 2] = a1[3];
  *(unsigned char *)(a2 + 40) |= 1u;
  if (buf) {
    __free_ovflpage(a1, buf);
  }
  if (v12 && v12 != buf) {
    __free_ovflpage(a1, v12);
  }
  --a1[14];
  return 0;
}

uint64_t __find_bigpair(uint64_t a1, unint64_t a2, unsigned int a3, char *a4, int a5)
{
  unint64_t buf = a2;
  unsigned int v13 = a3;
  size_t v11 = *(void *)(a2 + 32);
  size_t __n_6 = v11;
  int __n_2 = a5;
  for (__unsigned __int8 n = *(_DWORD *)(a1 + 12) - *(_WORD *)(v11 + 2 * (int)a3); ; __unsigned __int8 n = *(_DWORD *)(a1 + 12)
                                                                            - *(_WORD *)(__n_6 + 2))
  {
    BOOL v6 = 0;
    if (__n <= a5) {
      BOOL v6 = *(unsigned __int16 *)(v11 + 2 * (int)(v13 + 1)) == 1;
    }
    if (!v6) {
      break;
    }
    if (memcmp((const void *)(__n_6 + *(unsigned __int16 *)(v11 + 2 * (int)v13)), a4, __n)) {
      return -2;
    }
    a4 += __n;
    __n_2 -= __n;
    unint64_t buf = __get_buf(a1, *(unsigned __int16 *)(v11 + 2 * (int)(v13 + 2)), buf, 0);
    if (!buf) {
      return -3;
    }
    size_t __n_6 = *(void *)(buf + 32);
    size_t v11 = __n_6;
    unsigned int v13 = 1;
  }
  if (__n == __n_2 && !memcmp((const void *)(__n_6 + *(unsigned __int16 *)(v11 + 2 * (int)v13)), a4, __n)) {
    return v13;
  }
  else {
    return -2;
  }
}

uint64_t __find_last_page(uint64_t a1, unint64_t *a2)
{
  unint64_t buf = *a2;
  for (int i = *(unsigned __int16 **)(*a2 + 32); ; int i = *(unsigned __int16 **)(buf + 32))
  {
    int v3 = *i;
    if (i[2] == 3 && (v3 == 2 || !i[*i] || i[*i + 1])) {
      break;
    }
    unint64_t buf = __get_buf(a1, i[v3 - 1], buf, 0);
    if (!buf) {
      return 0;
    }
  }
  *a2 = buf;
  if (*i <= 2u) {
    return 0;
  }
  else {
    return i[3];
  }
}

uint64_t __big_return(uint64_t a1, unint64_t a2, int a3, void *a4, unsigned int a5)
{
  unint64_t buf = a2;
  unsigned __int16 __len_2 = *(unsigned __int16 **)(a2 + 32);
  while (__len_2[a3 + 1] == 1)
  {
    unint64_t buf = __get_buf(a1, __len_2[*__len_2 - 1], buf, 0);
    if (!buf) {
      return -1;
    }
    unsigned __int16 __len_2 = *(unsigned __int16 **)(buf + 32);
    a3 = 1;
  }
  if (__len_2[a3 + 1] == 2)
  {
    unint64_t v16 = __get_buf(a1, __len_2[*__len_2 - 1], buf, 0);
    if (!v16) {
      return -1;
    }
    unint64_t v11 = v16;
    unsigned __int16 v6 = *(_DWORD *)(v16 + 24);
    unsigned __int16 v7 = *(_WORD *)(*(void *)(v16 + 32) + 2);
    __leunsigned __int8 n = 0;
  }
  else
  {
    if (__len_2[*__len_2 + 1])
    {
      unsigned __int16 v8 = __len_2[*__len_2];
      *a4 = (char *)__len_2 + v8;
      a4[1] = __len_2[1] - v8;
      if (a5)
      {
        if (*__len_2 == 2)
        {
          *(void *)(a1 + 304) = 0;
          ++*(_DWORD *)(a1 + 312);
          *(_DWORD *)(a1 + 316) = 1;
        }
        else
        {
          *(void *)(a1 + 304) = __get_buf(a1, __len_2[*__len_2 - 1], buf, 0);
          if (!*(void *)(a1 + 304)) {
            return -1;
          }
          *(_DWORD *)(a1 + 316) = 1;
          if (!**(_WORD **)(*(void *)(a1 + 304) + 32))
          {
            ++*(_DWORD *)(a1 + 312);
            *(void *)(a1 + 304) = 0;
          }
        }
      }
      return 0;
    }
    unsigned __int16 v7 = __len_2[*__len_2];
    __leunsigned __int8 n = __len_2[1] - v7;
    unint64_t v11 = buf;
    unsigned __int16 v6 = *(_DWORD *)(buf + 24);
    unint64_t v16 = __get_buf(a1, __len_2[*__len_2 - 1], buf, 0);
    if (!v16) {
      return -1;
    }
  }
  a4[1] = (int)collect_data(a1, v16, __len, a5);
  if (a4[1] == -1)
  {
    return -1;
  }
  else if (*(_DWORD *)(v11 + 24) == v6)
  {
    memmove(*(void **)(a1 + 288), (const void *)(*(void *)(v11 + 32) + v7), __len);
    *a4 = *(void *)(a1 + 288);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t collect_data(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  char v10 = *(unsigned __int16 **)(a2 + 32);
  __leunsigned __int8 n = *(_DWORD *)(a1 + 12) - v10[1];
  unsigned __int16 __len_6 = *(_DWORD *)(a2 + 24);
  if (v10[2] == 3)
  {
    int v6 = a3 + __len;
    if (*(void *)(a1 + 288)) {
      free(*(void **)(a1 + 288));
    }
    uint64_t v4 = malloc_type_malloc();
    *(void *)(a1 + 288) = v4;
    if (!v4) {
      return -1;
    }
    if (a4)
    {
      *(_DWORD *)(a1 + 316) = 1;
      if (*v10 == 2)
      {
        *(void *)(a1 + 304) = 0;
        ++*(_DWORD *)(a1 + 312);
      }
      else
      {
        *(void *)(a1 + 304) = __get_buf(a1, v10[*v10 - 1], a2, 0);
        if (!*(void *)(a1 + 304)) {
          return -1;
        }
        if (!**(_WORD **)(*(void *)(a1 + 304) + 32))
        {
          ++*(_DWORD *)(a1 + 312);
          *(void *)(a1 + 304) = 0;
        }
      }
    }
  }
  else
  {
    unint64_t buf = __get_buf(a1, v10[*v10 - 1], a2, 0);
    if (!buf) {
      return -1;
    }
    int v6 = collect_data(a1, buf, (a3 + __len), a4);
    if (v6 < 1) {
      return -1;
    }
  }
  if (*(_DWORD *)(a2 + 24) == __len_6)
  {
    memmove((void *)(*(void *)(a1 + 288) + a3), (const void *)(*(void *)(a2 + 32) + v10[1]), __len);
    return v6;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t __big_keydata(uint64_t a1, unint64_t a2, void *a3, void *a4, unsigned int a5)
{
  a3[1] = (int)collect_key(a1, a2, 0, a4, a5);
  if (a3[1] == -1)
  {
    return -1;
  }
  else
  {
    *a3 = *(void *)(a1 + 296);
    return 0;
  }
}

uint64_t collect_key(uint64_t a1, unint64_t a2, int a3, void *a4, unsigned int a5)
{
  unsigned __int16 v8 = *(unsigned __int16 **)(a2 + 32);
  __leunsigned __int8 n = *(_DWORD *)(a1 + 12) - v8[1];
  unsigned __int16 v7 = *(_DWORD *)(a2 + 24);
  int v9 = a3 + __len;
  if (v8[2] == 2 || v8[2] == 3)
  {
    if (*(void *)(a1 + 296)) {
      free(*(void **)(a1 + 296));
    }
    uint64_t v5 = malloc_type_malloc();
    *(void *)(a1 + 296) = v5;
    if (!v5) {
      return -1;
    }
    if (__big_return(a1, a2, 1, a4, a5)) {
      return -1;
    }
  }
  else
  {
    unint64_t buf = __get_buf(a1, v8[*v8 - 1], a2, 0);
    if (!buf) {
      return -1;
    }
    int v9 = collect_key(a1, buf, v9, a4, a5);
    if (v9 < 1) {
      return -1;
    }
  }
  if (*(_DWORD *)(a2 + 24) == v7)
  {
    memmove((void *)(*(void *)(a1 + 296) + a3), (const void *)(*(void *)(a2 + 32) + v8[1]), __len);
    return v9;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t __big_split(_DWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5, int a6, uint64_t a7)
{
  uint64_t v31 = a1;
  uint64_t v30 = a2;
  uint64_t v29 = a3;
  uint64_t v28 = a4;
  int v27 = a5;
  int v26 = a6;
  uint64_t v25 = a7;
  uint64_t v23 = 0;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  v20[0] = 0;
  v20[1] = 0;
  unint64_t v24 = a4;
  if (__big_keydata((uint64_t)a1, a4, &v21, v20, 0))
  {
    return -1;
  }
  else
  {
    int v7 = __call_hash((uint64_t)v31, v21, v22);
    BOOL v19 = v7 != v26;
    __int16 last_page = __find_last_page((uint64_t)v31, (unint64_t *)&v28);
    *(_WORD *)(v25 + 24) = last_page;
    if (last_page)
    {
      unint64_t buf = __get_buf((uint64_t)v31, *(unsigned __int16 *)(v25 + 24), v28, 0);
      *(void *)(v25 + 16) = buf;
      if (!buf) {
        return -1;
      }
    }
    else
    {
      *(void *)(v25 + 16) = 0;
    }
    if (v19) {
      uint64_t v23 = v29;
    }
    else {
      uint64_t v23 = v30;
    }
    *(unsigned char *)(v23 + 40) |= 1u;
    *(void *)(v23 + 16) = v24;
    unint64_t v11 = *(_WORD **)(v23 + 32);
    __int16 v13 = v11[(unsigned __int16)*v11 + 2];
    __int16 v17 = v11[(unsigned __int16)*v11 + 1];
    unsigned __int16 v15 = *v11 + 1;
    v11[v15] = v27;
    v11[(unsigned __int16)(v15 + 1)] = 0;
    *unint64_t v11 = v15 + 1;
    v11[(unsigned __int16)*v11 + 2] = v13;
    v11[(unsigned __int16)*v11 + 1] = v17 - 4;
    *(void *)uint64_t v25 = v29;
    *(void *)(v25 + 8) = v30;
    uint64_t v12 = *(unsigned __int16 **)(v28 + 32);
    *(unsigned char *)(v28 + 40) |= 1u;
    if (*v12 <= 2u)
    {
      uint64_t v23 = v28;
    }
    else
    {
      unsigned __int16 v16 = v12[4];
      unsigned __int16 v18 = v12[*v12 + 1];
      unsigned __int16 v14 = v12[*v12 + 2];
      *v12 -= 2;
      v12[*v12 + 1] = v18 + 4;
      v12[*v12 + 2] = v14;
      uint64_t v23 = __add_ovflpage(v31, v28);
      if (!v23) {
        return -1;
      }
      v12[4] = v16;
    }
    if (v19) {
      *(void *)uint64_t v25 = v23;
    }
    else {
      *(void *)(v25 + 8) = v23;
    }
    return 0;
  }
}

unint64_t __get_buf(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  int v7 = 0;
  uint64_t v6 = 0;
  int v8 = 0;
  unsigned int v9 = 0;
  if (a3)
  {
    unint64_t v10 = *(void *)(a3 + 16);
    if (!v10 || *(_DWORD *)(v10 + 24) != a2) {
      unint64_t v10 = 0;
    }
    if (!a4) {
      int v8 = 2;
    }
  }
  else
  {
    int v7 = a2 & (*(_DWORD *)(a1 + 24) - 1);
    uint64_t v6 = *(void *)(*(void *)(a1 + 648) + 8 * (a2 >> *(_DWORD *)(a1 + 28)));
    unint64_t v10 = *(void *)(v6 + 8 * v7) & 0xFFFFFFFFFFFFFFFCLL;
    unsigned int v9 = *(void *)(v6 + 8 * v7) & 2;
    BOOL v5 = 1;
    if (!v9) {
      BOOL v5 = *(_DWORD *)(a1 + 324) == 0;
    }
    int v8 = v5;
  }
  if (v10)
  {
    *(void *)(*(void *)v10 + 8) = *(void *)(v10 + 8);
    **(void **)(v10 + 8) = *(void *)v10;
    *(void *)(v10 + 8) = *(void *)(a1 + 608);
    *(void *)unint64_t v10 = a1 + 600;
    *(void *)(a1 + 608) = v10;
    **(void **)(v10 + 8) = v10;
    return v10;
  }
  unint64_t v10 = (unint64_t)newbuf(a1, a2, a3);
  if (v10 && !__get_page((_DWORD *)a1, *(unsigned __int16 **)(v10 + 32), a2, a3 == 0, v8, 0))
  {
    if (!a3) {
      *(void *)(v6 + 8 * v7) = v10 | v9;
    }
    return v10;
  }
  return 0;
}

unsigned int *newbuf(uint64_t a1, unsigned int a2, uint64_t a3)
{
  unsigned __int16 v8 = 0;
  __int16 v13 = *(unsigned int **)(a1 + 600);
  if (v13 == *(unsigned int **)(a1 + 304))
  {
    *(void *)(*(void *)v13 + 8) = *((void *)v13 + 1);
    **((void **)v13 + 1) = *(void *)v13;
    *((void *)v13 + 1) = *(void *)(a1 + 608);
    *(void *)__int16 v13 = a1 + 600;
    *(void *)(a1 + 608) = v13;
    **((void **)v13 + 1) = v13;
    __int16 v13 = *(unsigned int **)(a1 + 600);
  }
  if (!*(_DWORD *)(a1 + 596) && a3 && *((void *)v13 + 2))
  {
    for (uint64_t i = *((void *)v13 + 2); i; uint64_t i = *(void *)(i + 16))
    {
      if (i == a3)
      {
        ++*(_DWORD *)(a1 + 596);
        break;
      }
    }
  }
  if (*(_DWORD *)(a1 + 596) || (v13[10] & 8) != 0 || v13 == *(unsigned int **)(a1 + 304))
  {
    __int16 v13 = (unsigned int *)malloc_type_calloc();
    if (!v13) {
      return 0;
    }
    uint64_t v3 = malloc_type_calloc();
    *((void *)v13 + 4) = v3;
    if (!v3)
    {
      free(v13);
      return 0;
    }
    if (*(_DWORD *)(a1 + 596)) {
      --*(_DWORD *)(a1 + 596);
    }
  }
  else
  {
    *(void *)(*(void *)v13 + 8) = *((void *)v13 + 1);
    **((void **)v13 + 1) = *(void *)v13;
    if (v13[6] || (v13[10] & 4) != 0)
    {
      uint64_t v6 = (_WORD *)*((void *)v13 + 4);
      if (*v6) {
        unsigned __int16 v8 = v6[(unsigned __int16)*v6 - 1];
      }
      if ((v13[10] & 1) != 0
        && __put_page((_DWORD *)a1, *((unsigned __int16 **)v13 + 4), v13[6], v13[10] & 4, 0))
      {
        return 0;
      }
      if ((v13[10] & 4) != 0)
      {
        int v9 = v13[6] & (*(_DWORD *)(a1 + 24) - 1);
        uint64_t v10 = *(void *)(*(void *)(a1 + 648) + 8 * (v13[6] >> *(_DWORD *)(a1 + 28)));
        if (*(_DWORD *)(a1 + 324) && ((v13[10] & 1) != 0 || (*(_DWORD *)(v10 + 8 * v9) & 2) != 0)) {
          *(void *)(v10 + 8 * v9) = 2;
        }
        else {
          *(void *)(v10 + 8 * v9) = 0;
        }
      }
      uint64_t v12 = v13;
      while (*((void *)v12 + 2))
      {
        uint64_t v11 = *((void *)v12 + 2);
        *((void *)v12 + 2) = 0;
        uint64_t v12 = (unsigned int *)v11;
        if ((*(unsigned char *)(v11 + 40) & 4) != 0 || v8 != *(_DWORD *)(v11 + 24)) {
          break;
        }
        int v7 = *(_WORD **)(v11 + 32);
        if (*v7) {
          unsigned __int16 v8 = v7[(unsigned __int16)*v7 - 1];
        }
        if ((*(unsigned char *)(v11 + 40) & 1) != 0
          && __put_page((_DWORD *)a1, *(unsigned __int16 **)(v11 + 32), *(_DWORD *)(v11 + 24), 0, 0))
        {
          return 0;
        }
        *(_DWORD *)(v11 + 24) = 0;
        *(unsigned char *)(v11 + 40) = 0;
        *(void *)(*(void *)v11 + 8) = *(void *)(v11 + 8);
        **(void **)(v11 + 8) = *(void *)v11;
        *(void *)(v11 + 8) = *(void *)(*(void *)(a1 + 600) + 8);
        *(void *)uint64_t v11 = *(void *)(a1 + 600);
        *(void *)(*(void *)(a1 + 600) + 8) = v11;
        **(void **)(v11 + 8) = v11;
      }
    }
  }
  v13[6] = a2;
  *((void *)v13 + 2) = 0;
  if (a3)
  {
    *(void *)(a3 + 16) = v13;
    *((unsigned char *)v13 + 40) = 0;
  }
  else
  {
    *((unsigned char *)v13 + 40) = 4;
  }
  *((void *)v13 + 1) = *(void *)(a1 + 608);
  *(void *)__int16 v13 = a1 + 600;
  *(void *)(a1 + 608) = v13;
  **((void **)v13 + 1) = v13;
  return v13;
}

uint64_t __buf_init(uint64_t result, int a2)
{
  if ((a2 + *(_DWORD *)(result + 12) - 1) >> *(_DWORD *)(result + 16) <= 6) {
    int v2 = 6;
  }
  else {
    int v2 = (a2 + *(_DWORD *)(result + 12) - 1) >> *(_DWORD *)(result + 16);
  }
  *(_DWORD *)(result + 596) = v2;
  *(void *)(result + 608) = result + 600;
  *(void *)(result + 600) = result + 600;
  return result;
}

uint64_t __buf_free(uint64_t a1, int a2, int a3)
{
  if (*(void *)(a1 + 600))
  {
    uint64_t v4 = *(void **)(a1 + 600);
    while (v4 != (void *)(a1 + 600))
    {
      if ((*((_DWORD *)v4 + 6) || (*((unsigned char *)v4 + 40) & 4) != 0)
        && a3
        && (*((unsigned char *)v4 + 40) & 1) != 0
        && __put_page((_DWORD *)a1, *((unsigned __int16 **)v4 + 4), *((_DWORD *)v4 + 6), *((unsigned char *)v4 + 40) & 4, 0))
      {
        return -1;
      }
      if (a2)
      {
        if (*((void *)v4 + 4))
        {
          bzero(*((void **)v4 + 4), *(int *)(a1 + 12));
          free(*((void **)v4 + 4));
        }
        *(void *)(*(void *)v4 + 8) = *((void *)v4 + 1);
        **((void **)v4 + 1) = *(void *)v4;
        free(v4);
        uint64_t v4 = *(void **)(a1 + 600);
      }
      else
      {
        uint64_t v4 = *(void **)v4;
      }
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

uint64_t __reclaim_buf(uint64_t result, uint64_t a2)
{
  *(void *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(unsigned char *)(a2 + 40) = 0;
  *(void *)(*(void *)a2 + 8) = *(void *)(a2 + 8);
  **(void **)(a2 + 8) = *(void *)a2;
  *(void *)(a2 + 8) = *(void *)(*(void *)(result + 600) + 8);
  *(void *)a2 = *(void *)(result + 600);
  *(void *)(*(void *)(result + 600) + 8) = a2;
  **(void **)(a2 + 8) = a2;
  return result;
}

uint64_t hash4(unsigned __int8 *a1, uint64_t a2)
{
  unsigned int v13 = 0;
  if (a2)
  {
    unint64_t v14 = (unint64_t)(a2 + 7) >> 3;
    if ((a2 & 7) != 0)
    {
      uint64_t v3 = a2 & 7;
      char v2 = 1;
    }
    else
    {
      uint64_t v3 = a2 & 7;
      char v2 = 0;
    }
    if ((v2 & 1) == 0)
    {
      switch(v3)
      {
        case 0:
          goto LABEL_7;
        case 1:
          goto LABEL_14;
        case 2:
          goto LABEL_13;
        case 3:
          goto LABEL_12;
        case 4:
          goto LABEL_11;
        case 5:
          goto LABEL_10;
        case 6:
          goto LABEL_9;
        case 7:
          while (1)
          {
            BOOL v5 = a1++;
            unsigned int v13 = 33 * v13 + *v5;
LABEL_9:
            uint64_t v6 = a1++;
            unsigned int v13 = 33 * v13 + *v6;
LABEL_10:
            int v7 = a1++;
            unsigned int v13 = 33 * v13 + *v7;
LABEL_11:
            unsigned __int16 v8 = a1++;
            unsigned int v13 = 33 * v13 + *v8;
LABEL_12:
            int v9 = a1++;
            unsigned int v13 = 33 * v13 + *v9;
LABEL_13:
            uint64_t v10 = a1++;
            unsigned int v13 = 33 * v13 + *v10;
LABEL_14:
            uint64_t v11 = a1++;
            unsigned int v13 = 33 * v13 + *v11;
            if (!--v14) {
              break;
            }
LABEL_7:
            uint64_t v4 = a1++;
            unsigned int v13 = 33 * v13 + *v4;
          }
          break;
        default:
          JUMPOUT(0);
      }
    }
  }
  return v13;
}

uint64_t __log2(unsigned int a1)
{
  unsigned int v2 = 1;
  unsigned int v3 = 0;
  while (v2 < a1)
  {
    v2 *= 2;
    ++v3;
  }
  return v3;
}

uint64_t __delpair(_DWORD *a1, unint64_t a2, int a3)
{
  unsigned __int16 v8 = *(_WORD **)(a2 + 32);
  int v5 = (unsigned __int16)*v8;
  if ((unsigned __int16)v8[a3 + 1] >= 4u)
  {
    if (a3 == 1) {
      __int16 v7 = a1[3];
    }
    else {
      __int16 v7 = v8[a3 - 1];
    }
    unsigned __int16 v6 = v7 - v8[a3 + 1];
    if (a3 != v5 - 1)
    {
      memmove((void *)(*(void *)(a2 + 32) + (unsigned __int16)v8[(unsigned __int16)*v8 + 2] + v6), (const void *)(*(void *)(a2 + 32) + (unsigned __int16)v8[(unsigned __int16)*v8 + 2]), (unsigned __int16)v8[a3 + 1] - (unsigned __int16)v8[(unsigned __int16)*v8 + 2]);
      for (int i = a3 + 2; i <= v5; i += 2)
      {
        if (v8[i + 1])
        {
          v8[i - 2] = v8[i] + v6;
          v8[i - 1] = v8[i + 1] + v6;
        }
        else
        {
          v8[i - 2] = v8[i];
          v8[i - 1] = v8[i + 1];
        }
      }
      if (a3 == a1[79]) {
        a1[79] -= 2;
      }
    }
    v8[v5] = v8[(unsigned __int16)*v8 + 2] + v6;
    v8[v5 - 1] = v8[v5 + 1] + v6 + 4;
    *unsigned __int16 v8 = v5 - 2;
    --a1[14];
    *(unsigned char *)(a2 + 40) |= 1u;
    return 0;
  }
  else
  {
    return __big_delete(a1, a2);
  }
}

uint64_t __split_page(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  uint64_t v23 = a1;
  unsigned int v22 = a2;
  unsigned int v21 = a3;
  unint64_t v20 = 0;
  unint64_t buf = 0;
  unsigned __int16 v18 = 0;
  __int16 v17 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  unsigned int v13 = 0;
  uint64_t v14 = 0;
  unsigned __int16 v10 = a1[3];
  unsigned __int16 v9 = v10;
  unint64_t buf = __get_buf((uint64_t)a1, a2, 0, 0);
  if (buf)
  {
    unint64_t v20 = __get_buf((uint64_t)v23, v21, 0, 0);
    if (v20)
    {
      *(unsigned char *)(buf + 40) |= 9u;
      *(unsigned char *)(v20 + 40) |= 9u;
      __int16 v7 = *(_WORD **)(buf + 32);
      unsigned __int16 v18 = v7;
      __int16 v17 = *(unsigned __int16 **)(v20 + 32);
      unsigned __int16 v8 = 0;
      int v12 = 1;
      int v11 = 1;
      while (v12 < (unsigned __int16)*v18)
      {
        if ((unsigned __int16)v18[v12 + 1] < 4u)
        {
          unsigned int v3 = ugly_split(v23, v22, buf, v20, v10, v8);
          *(unsigned char *)(buf + 40) &= ~8u;
          *(unsigned char *)(v20 + 40) &= ~8u;
          return v3;
        }
        uint64_t v15 = (uint64_t)v7 + (unsigned __int16)v18[v12];
        int v4 = v9 - (unsigned __int16)v18[v12];
        uint64_t v16 = v4;
        int v5 = __call_hash((uint64_t)v23, v15, v4);
        if (v5 == v22)
        {
          if (v10 == v9)
          {
            unsigned __int16 v10 = v18[v12 + 1];
          }
          else
          {
            unsigned __int16 v10 = v18[v12 + 1] + v10 - v9;
            memmove((char *)v7 + v10, (char *)v7 + (unsigned __int16)v18[v12 + 1], v9 - (unsigned __int16)v18[v12 + 1]);
            v18[v11] = v10 + v18[v12] - v18[v12 + 1];
            v18[v11 + 1] = v10;
          }
          v11 += 2;
        }
        else
        {
          unsigned int v13 = (char *)v7 + (unsigned __int16)v18[v12 + 1];
          uint64_t v14 = (unsigned __int16)v18[v12] - (unsigned __int16)v18[v12 + 1];
          putpair(v17, (uint64_t)&v15, (uint64_t)&v13);
          v8 += 2;
        }
        unsigned __int16 v9 = v18[v12 + 1];
        v12 += 2;
      }
      *v18 -= v8;
      v18[(unsigned __int16)*v18 + 1] = v10 - 2 * (*v18 + 3);
      v18[(unsigned __int16)*v18 + 2] = v10;
      *(unsigned char *)(buf + 40) &= ~8u;
      *(unsigned char *)(v20 + 40) &= ~8u;
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t ugly_split(_DWORD *a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  uint64_t v29 = a1;
  int v28 = a2;
  uint64_t v27 = a3;
  uint64_t v26 = a4;
  int v25 = a5;
  int v24 = a6;
  unsigned int v22 = 0;
  unsigned int v21 = 0;
  unint64_t v20 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = 0;
  long long v13 = 0u;
  long long v14 = 0u;
  uint64_t buf = a3;
  unsigned int v22 = *(unsigned __int16 **)(a3 + 32);
  unsigned int v21 = *(unsigned __int16 **)(a4 + 32);
  unint64_t v20 = *(unsigned __int16 **)(a3 + 32);
  uint64_t v19 = 0;
  unsigned __int16 v9 = a5;
  unsigned __int16 i = *v22 - 1;
  while (i < (int)*v22)
  {
    if (v22[2] < 4u && v22[2])
    {
      if (__big_split(v29, v27, v26, buf, *(_DWORD *)(buf + 24), v28, (uint64_t)&v13)) {
        return -1;
      }
      uint64_t v27 = *((void *)&v13 + 1);
      if (!*((void *)&v13 + 1)) {
        return -1;
      }
      unint64_t v20 = *(unsigned __int16 **)(v27 + 32);
      uint64_t v26 = v13;
      if (!(void)v13) {
        return -1;
      }
      unsigned int v21 = *(unsigned __int16 **)(v26 + 32);
      uint64_t buf = v14;
      if (!(void)v14) {
        return 0;
      }
      unsigned int v22 = *(unsigned __int16 **)(buf + 32);
      uint64_t v19 = v14;
    }
    else if (!v22[i + 1])
    {
      unsigned __int16 v10 = v22[i];
      *v22 -= v24 + 2;
      v22[*v22 + 1] = v9 - 2 * (*v22 + 3);
      v22[*v22 + 2] = v9;
      uint64_t buf = __get_buf((uint64_t)v29, v10, buf, 0);
      if (!buf) {
        return -1;
      }
      unsigned int v22 = *(unsigned __int16 **)(buf + 32);
      unsigned __int16 v9 = v29[3];
      int v24 = 0;
      if (v19) {
        __free_ovflpage(v29, v19);
      }
      uint64_t v19 = buf;
    }
    unsigned __int16 v11 = v29[3];
    for (unsigned __int16 i = 1; ; i += 2)
    {
      BOOL v8 = 0;
      if (i < (int)*v22) {
        BOOL v8 = v22[i + 1] >= 4u;
      }
      if (!v8) {
        break;
      }
      uint64_t v17 = (uint64_t)v22 + v22[i];
      uint64_t v18 = v11 - v22[i];
      uint64_t v15 = (char *)v22 + v22[i + 1];
      uint64_t v16 = v22[i] - v22[i + 1];
      unsigned __int16 v11 = v22[i + 1];
      int v6 = __call_hash((uint64_t)v29, v17, v18);
      if (v6 == v28)
      {
        if (v20[2] < 4u || v18 + 4 + v16 + 4 > (unint64_t)v20[*v20 + 1])
        {
          uint64_t v27 = __add_ovflpage(v29, v27);
          if (!v27) {
            return -1;
          }
          unint64_t v20 = *(unsigned __int16 **)(v27 + 32);
          putpair(v20, (uint64_t)&v17, (uint64_t)&v15);
        }
        else
        {
          putpair(v20, (uint64_t)&v17, (uint64_t)&v15);
        }
        *(unsigned char *)(v27 + 40) |= 1u;
      }
      else
      {
        if (v21[2] < 4u || v18 + 4 + v16 + 4 > (unint64_t)v21[*v21 + 1])
        {
          uint64_t v26 = __add_ovflpage(v29, v26);
          if (!v26) {
            return -1;
          }
          unsigned int v21 = *(unsigned __int16 **)(v26 + 32);
          putpair(v21, (uint64_t)&v17, (uint64_t)&v15);
        }
        else
        {
          putpair(v21, (uint64_t)&v17, (uint64_t)&v15);
        }
        *(unsigned char *)(v26 + 40) |= 1u;
      }
    }
  }
  if (v19) {
    __free_ovflpage(v29, v19);
  }
  return 0;
}

uint64_t putpair(unsigned __int16 *a1, uint64_t a2, uint64_t a3)
{
  unsigned __int16 v7 = *a1;
  unsigned __int16 v5 = a1[*a1 + 2] - *(void *)(a2 + 8);
  memmove((char *)a1 + v5, *(const void **)a2, *(void *)(a2 + 8));
  a1[++v7] = v5;
  unsigned __int16 v6 = v5 - *(void *)(a3 + 8);
  memmove((char *)a1 + v6, *(const void **)a3, *(void *)(a3 + 8));
  uint64_t v3 = v7++ + 1;
  uint64_t result = v3;
  a1[(unsigned __int16)v3] = v6;
  *a1 = v7;
  a1[v7 + 1] = v6 - 2 * (v7 + 3);
  a1[v7 + 2] = v6;
  return result;
}

uint64_t __addel(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t buf = a2;
  unsigned __int16 v9 = *(unsigned __int16 **)(a2 + 32);
  int v7 = 0;
  while (1)
  {
    BOOL v6 = 0;
    if (*v9)
    {
      BOOL v5 = 1;
      if (v9[2] >= 4u) {
        BOOL v5 = v9[*v9] < 4u;
      }
      BOOL v6 = v5;
    }
    if (!v6 || v9[2] == 3 && *v9 == 2) {
      break;
    }
    if (v9[2] < 4u && v9[*v9])
    {
      uint64_t buf = __get_buf((uint64_t)a1, v9[*v9 - 1], buf, 0);
      if (!buf) {
        return -1;
      }
      unsigned __int16 v9 = *(unsigned __int16 **)(buf + 32);
    }
    else
    {
      if (v9[*v9]) {
        break;
      }
      if (v9[2] >= 4u && v9[*v9 + 1] >= (unint64_t)(*(void *)(a3 + 8) + 4 + *(void *)(a4 + 8)))
      {
        squeeze_key(v9, a3, a4);
        goto LABEL_31;
      }
      uint64_t buf = __get_buf((uint64_t)a1, v9[*v9 - 1], buf, 0);
      if (!buf) {
        return -1;
      }
      unsigned __int16 v9 = *(unsigned __int16 **)(buf + 32);
    }
  }
  if (v9[2] < 4u || *(void *)(a3 + 8) + 4 + *(void *)(a4 + 8) + 4 > (unint64_t)v9[*v9 + 1])
  {
    int v7 = 1;
    uint64_t buf = __add_ovflpage(a1, buf);
    if (!buf) {
      return -1;
    }
    BOOL v8 = *(unsigned __int16 **)(buf + 32);
    if (v8[2] < 4u || *(void *)(a3 + 8) + 4 + *(void *)(a4 + 8) + 4 > (unint64_t)v8[*v8 + 1])
    {
      if (__big_insert(a1, buf, (char **)a3, (char **)a4)) {
        return -1;
      }
    }
    else
    {
      putpair(v8, a3, a4);
    }
  }
  else
  {
    putpair(*(unsigned __int16 **)(buf + 32), a3, a4);
  }
LABEL_31:
  *(unsigned char *)(buf + 40) |= 1u;
  ++a1[14];
  if (v7 || a1[14] / (a1[10] + 1) > a1[13]) {
    return __expand_table((uint64_t)a1);
  }
  else {
    return 0;
  }
}

void *squeeze_key(unsigned __int16 *a1, uint64_t a2, uint64_t a3)
{
  unsigned __int16 v7 = *a1;
  unsigned __int16 v8 = a1[*a1 + 1];
  unsigned __int16 v4 = a1[*a1 - 1];
  unsigned __int16 v5 = a1[*a1 + 2] - *(void *)(a2 + 8);
  a1[*a1 - 1] = v5;
  memmove((char *)a1 + v5, *(const void **)a2, *(void *)(a2 + 8));
  unsigned __int16 v6 = v5 - *(void *)(a3 + 8);
  a1[v7] = v6;
  uint64_t result = memmove((char *)a1 + v6, *(const void **)a3, *(void *)(a3 + 8));
  *a1 = v7 + 2;
  a1[v7 + 1] = v4;
  a1[v7 + 2] = 0;
  a1[*a1 + 1] = v8 - (*(_WORD *)(a2 + 8) + 4 + *(_WORD *)(a3 + 8));
  a1[*a1 + 2] = v6;
  return result;
}

uint64_t __add_ovflpage(_DWORD *a1, uint64_t a2)
{
  unsigned __int16 v6 = *(unsigned __int16 **)(a2 + 32);
  if (a1[13] == 0x10000)
  {
    a1[13] = (int)*v6 >> 1;
    if (a1[13] < 4u) {
      a1[13] = 4;
    }
  }
  *(unsigned char *)(a2 + 40) |= 1u;
  unsigned __int16 v4 = overflow_page(a1);
  if (!v4) {
    return 0;
  }
  unint64_t buf = __get_buf((uint64_t)a1, v4, a2, 1);
  *(void *)(a2 + 16) = buf;
  if (!buf) {
    return 0;
  }
  *(unsigned char *)(*(void *)(a2 + 16) + 40) |= 1u;
  unsigned __int16 v5 = *v6;
  v6[v5 + 4] = v6[*v6 + 2];
  v6[v5 + 3] = v6[*v6 + 1] - 4;
  v6[v5 + 1] = v4;
  v6[v5 + 2] = 0;
  *unsigned __int16 v6 = v5 + 2;
  return *(void *)(a2 + 16);
}

uint64_t overflow_page(_DWORD *a1)
{
  *(_DWORD *)&v24[8] = 0;
  int v22 = a1[8];
  *(void *)int v24 = a1[v22 + 17];
  int v15 = (*(_DWORD *)v24 - 1) >> (a1[4] + 3);
  int v17 = (*(_DWORD *)v24 - 1) & (8 * a1[3] - 1);
  int v18 = (int)a1[9] >> (*((unsigned char *)a1 + 16) + 3);
  int v13 = v18;
LABEL_2:
  if (v13 > v15)
  {
    a1[9] = a1[v22 + 17]++;
    int v10 = a1[v22 + 17];
    if (v22) {
      int v9 = a1[v22 + 16];
    }
    else {
      int v9 = 0;
    }
    int v23 = v10 - v9;
    if (v10 - v9 > 2047)
    {
      if (++v22 >= 32) {
        goto LABEL_45;
      }
      a1[8] = v22;
      a1[v22 + 17] = a1[v22 + 16];
      int v1 = &a1[v22 + 16];
      --*v1;
      int v23 = 1;
    }
    if (v17 == 8 * a1[3] - 1)
    {
      int v16 = v15 + 1;
      if (v16 >= 32) {
        goto LABEL_45;
      }
      if (__ibitmap((uint64_t)a1, v23 + ((_WORD)v22 << 11), 1, v16)) {
        return 0;
      }
      ++a1[v22 + 17];
      if (++v23 > 2047)
      {
        if (++v22 >= 32)
        {
LABEL_45:
          write_NOCANCEL();
          *__error() = 27;
          return 0;
        }
        a1[8] = v22;
        a1[v22 + 17] = a1[v22 + 16];
        unsigned int v2 = &a1[v22 + 16];
        --*v2;
        LOWORD(v23) = 0;
      }
    }
    else
    {
      *(_DWORD *)(*(void *)&v24[4] + 4 * ((v17 + 1) / 32)) |= 1 << ((v17 + 1) % 32);
    }
    return (unsigned __int16)(v23 + ((_WORD)v22 << 11));
  }
  *(void *)&v24[4] = *(void *)&a1[2 * v13 + 84];
  if (*(void *)&v24[4] || (*(void *)&v24[4] = fetch_bitmap(a1, v13)) != 0)
  {
    if (v13 == v15) {
      int v12 = v17;
    }
    else {
      int v12 = 8 * a1[3] - 1;
    }
    if (v13 == v18)
    {
      int v19 = a1[9] & (8 * a1[3] - 1);
      int v11 = v19 / 32;
      signed int v20 = v19 & 0xFFFFFFE0;
    }
    else
    {
      signed int v20 = 0;
      int v11 = 0;
    }
    while (1)
    {
      if (v20 > v12)
      {
        ++v13;
        goto LABEL_2;
      }
      if (*(_DWORD *)(*(void *)&v24[4] + 4 * v11) != -1) {
        break;
      }
      ++v11;
      v20 += 32;
    }
    signed int v8 = v20;
    int free = first_free(*(_DWORD *)(*(void *)&v24[4] + 4 * v11));
    unsigned __int16 v4 = (_DWORD *)(*(void *)&v24[4] + 4 * ((v20 + free) / 32));
    *v4 |= 1 << ((v20 + free) % 32);
    int v21 = v20 + free + 1 + v13 * 8 * a1[3];
    if (v8 + free + 1 + v13 * 8 * a1[3] >= a1[9]) {
      a1[9] = v21 - 1;
    }
    for (int i = 0; ; ++i)
    {
      BOOL v7 = 0;
      if (i < v22) {
        BOOL v7 = v21 > a1[i + 17];
      }
      if (!v7) {
        break;
      }
    }
    if (i) {
      int v6 = v21 - a1[i + 16];
    }
    else {
      int v6 = v21;
    }
    if (v6 < 2047) {
      return (unsigned __int16)(v6 + ((_WORD)i << 11));
    }
    goto LABEL_45;
  }
  return 0;
}

uint64_t __get_page(_DWORD *a1, unsigned __int16 *a2, unsigned int a3, int a4, int a5, int a6)
{
  int v15 = a1[3];
  if (a1[71] != -1 && a5)
  {
    if (a4)
    {
      if (a3) {
        __log2(a3 + 1);
      }
    }
    else if (1 << (a3 >> 11) != 1)
    {
      __log2(1 << (a3 >> 11));
    }
    int v14 = pread_NOCANCEL();
    if (v14 == -1)
    {
      return -1;
    }
    else
    {
      if (v14)
      {
        if (v14 != v15)
        {
          *__error() = 79;
          return -1;
        }
      }
      else
      {
        *a2 = 0;
      }
      if (a6 || *a2)
      {
        if (a1[2] != 1234)
        {
          if (a6)
          {
            int v10 = (int)a1[3] >> 2;
            for (int i = 0; i < v10; ++i)
            {
              int v9 = *(_DWORD *)&a2[2 * i];
              LOBYTE(a2[2 * i]) = HIBYTE(v9);
              HIBYTE(a2[2 * i]) = BYTE2(v9);
              LOBYTE(a2[2 * i + 1]) = BYTE1(v9);
              HIBYTE(a2[2 * i + 1]) = v9;
            }
          }
          else
          {
            __int16 v8 = *a2;
            *(unsigned char *)a2 = HIBYTE(*a2);
            *((unsigned char *)a2 + 1) = v8;
            int v11 = *a2 + 2;
            for (int j = 1; j <= v11; ++j)
            {
              unsigned __int16 v7 = a2[j];
              LOBYTE(a2[j]) = HIBYTE(v7);
              HIBYTE(a2[j]) = v7;
            }
          }
        }
      }
      else
      {
        *a2 = 0;
        a2[1] = a1[3] - 6;
        a2[2] = a1[3];
      }
      return 0;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = a1[3] - 6;
    a2[2] = a1[3];
    return 0;
  }
}

uint64_t __put_page(_DWORD *a1, unsigned __int16 *a2, unsigned int a3, int a4, int a5)
{
  int v14 = 0;
  int v16 = a1[3];
  if (a1[71] == -1 && open_temp((uint64_t)a1))
  {
    return -1;
  }
  else
  {
    if (a1[2] != 1234)
    {
      if (a5)
      {
        int v14 = (int)a1[3] >> 2;
        for (int i = 0; i < v14; ++i)
        {
          int v11 = *(_DWORD *)&a2[2 * i];
          LOBYTE(a2[2 * i]) = HIBYTE(v11);
          HIBYTE(a2[2 * i]) = BYTE2(v11);
          LOBYTE(a2[2 * i + 1]) = BYTE1(v11);
          HIBYTE(a2[2 * i + 1]) = v11;
        }
      }
      else
      {
        int v14 = *a2 + 2;
        for (int j = 0; j <= v14; ++j)
        {
          unsigned __int16 v10 = a2[j];
          LOBYTE(a2[j]) = HIBYTE(v10);
          HIBYTE(a2[j]) = v10;
        }
      }
    }
    if (a4)
    {
      if (a3) {
        __log2(a3 + 1);
      }
    }
    else if (1 << (a3 >> 11) != 1)
    {
      __log2(1 << (a3 >> 11));
    }
    int v15 = pwrite_NOCANCEL();
    if (v15 == -1)
    {
      return -1;
    }
    else if (v15 == v16)
    {
      if (a1[2] != 1234)
      {
        if (a5)
        {
          for (int k = 0; k < v14; ++k)
          {
            int v7 = *(_DWORD *)&a2[2 * k];
            LOBYTE(a2[2 * k]) = HIBYTE(v7);
            HIBYTE(a2[2 * k]) = BYTE2(v7);
            LOBYTE(a2[2 * k + 1]) = BYTE1(v7);
            HIBYTE(a2[2 * k + 1]) = v7;
          }
        }
        else
        {
          for (int m = 0; m <= v14; ++m)
          {
            unsigned __int16 v6 = a2[m];
            LOBYTE(a2[m]) = HIBYTE(v6);
            HIBYTE(a2[m]) = v6;
          }
        }
      }
      return 0;
    }
    else
    {
      *__error() = 79;
      return -1;
    }
  }
}

uint64_t open_temp(uint64_t a1)
{
  uint64_t v8 = a1;
  sigset_t v7 = 0;
  sigset_t v6 = 0;
  unsigned __int16 v5 = 0;
  if (!issetugid()) {
    unsigned __int16 v5 = getenv("TMPDIR");
  }
  if (v5) {
    int v1 = snprintf(__str, 0x400uLL, "%s/_hash.XXXXXX", v5);
  }
  else {
    int v1 = snprintf(__str, 0x400uLL, "%s/_hash.XXXXXX", "/tmp");
  }
  if (v1 >= 0 && (unint64_t)v1 < 0x400)
  {
    sigset_t v7 = -1;
    sigprocmask(1, &v7, &v6);
    int v2 = mkstemp(__str);
    *(_DWORD *)(v8 + 284) = v2;
    if (v2 != -1)
    {
      unlink(__str);
      fcntl_NOCANCEL();
    }
    sigprocmask(3, &v6, 0);
    if (*(_DWORD *)(v8 + 284) == -1) {
      return -1;
    }
    else {
      return 0;
    }
  }
  else
  {
    *__error() = 63;
    return -1;
  }
}

uint64_t __ibitmap(uint64_t a1, __int16 a2, int a3, int a4)
{
  sigset_t v6 = (_DWORD *)malloc_type_malloc();
  if (v6)
  {
    ++*(_DWORD *)(a1 + 592);
    int v5 = ((a3 - 1) >> 5) + 1;
    bzero(v6, 4 * v5);
    memset(&v6[v5], -1, *(_DWORD *)(a1 + 12) - 4 * v5);
    v6[v5 - 1] = -1 << (a3 & 0x1F);
    *v6 |= 1u;
    *(_WORD *)(a1 + 196 + 2 * a4) = a2;
    *(void *)(a1 + 336 + 8 * a4) = v6;
    return 0;
  }
  else
  {
    return 1;
  }
}

uint64_t __free_ovflpage(_DWORD *a1, uint64_t a2)
{
  unsigned __int16 v4 = (int)(unsigned __int16)*(_DWORD *)(a2 + 24) >> 11;
  if (v4) {
    int v3 = a1[v4 + 16];
  }
  else {
    int v3 = 0;
  }
  int v7 = v3 + (*(_DWORD *)(a2 + 24) & 0x7FF) - 1;
  if (v7 < a1[9]) {
    a1[9] = v7;
  }
  int v6 = v7 >> (a1[4] + 3);
  int v5 = v7 & (8 * a1[3] - 1);
  uint64_t bitmap = *(void *)&a1[2 * v6 + 84];
  if (!bitmap) {
    uint64_t bitmap = fetch_bitmap(a1, v6);
  }
  *(_DWORD *)(bitmap + 4 * (v5 / 32)) &= ~(1 << (v5 % 32));
  return __reclaim_buf((uint64_t)a1, a2);
}

uint64_t fetch_bitmap(_DWORD *a1, int a2)
{
  if (a2 >= a1[148]) {
    return 0;
  }
  uint64_t v2 = malloc_type_malloc();
  *(void *)&a1[2 * a2 + 84] = v2;
  if (!v2) {
    return 0;
  }
  if (!__get_page(a1, *(unsigned __int16 **)&a1[2 * a2 + 84], *((unsigned __int16 *)a1 + a2 + 98), 0, 1, 1))return *(void *)&a1[2 * a2 + 84]; {
  free(*(void **)&a1[2 * a2 + 84]);
  }
  return 0;
}

uint64_t first_free(int a1)
{
  int v2 = 1;
  for (unsigned int i = 0; i < 0x20; ++i)
  {
    if ((v2 & a1) == 0) {
      return i;
    }
    v2 *= 2;
  }
  return i;
}

DBM *__cdecl dbm_open(const char *a1, int a2, mode_t a3)
{
  __s = (char *)a1;
  int v7 = a2;
  mode_t v6 = a3;
  v4[0] = 0x2800001000;
  v4[1] = 1;
  long long v5 = 0uLL;
  if (strlen(a1) < 0x3FD)
  {
    strcpy(__dst, __s);
    strcat(__dst, ".db");
    return (DBM *)__hash_open(__dst, v7, v6, (uint64_t)v4, 0);
  }
  else
  {
    *__error() = 63;
    return 0;
  }
}

void dbm_close(DBM *a1)
{
}

datum dbm_fetch(DBM *a1, datum a2)
{
  datum v9 = a2;
  uint64_t v8 = a1;
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  int v7 = 0;
  unsigned __int16 v4 = 0;
  size_t v5 = 0;
  datum v6 = a2;
  int v7 = (*(uint64_t (**)(DBM *, datum *, void **, void))&a1->__opaque[24])(a1, &v6, &v4, 0);
  if (v7)
  {
    unsigned __int16 v4 = 0;
    size_t v5 = 0;
  }
  int v2 = v4;
  size_t v3 = v5;
  result.dsize = v3;
  result.dptr = v2;
  return result;
}

datum dbm_firstkey(DBM *a1)
{
  uint64_t v8 = a1;
  int v7 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  size_t v5 = 0;
  size_t v6 = 0;
  v4[0] = 0;
  v4[1] = 0;
  uint64_t v3 = *(void *)&a1->__opaque[56];
  int v7 = (*(uint64_t (**)(DBM *, void **, void *, uint64_t))&a1->__opaque[40])(a1, &v5, v4, 3);
  if (v7)
  {
    size_t v5 = 0;
    *(unsigned char *)(v3 + 656) = *(unsigned char *)(v3 + 656) & 0xFE | 1;
  }
  else
  {
    *(unsigned char *)(v3 + 656) &= ~1u;
  }
  int v1 = v5;
  size_t v2 = v6;
  result.dsize = v2;
  result.dptr = v1;
  return result;
}

datum dbm_nextkey(DBM *a1)
{
  uint64_t v8 = a1;
  int v7 = 1;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  size_t v5 = 0;
  size_t v6 = 0;
  v4[0] = 0;
  v4[1] = 0;
  uint64_t v3 = *(void *)&a1->__opaque[56];
  if (*(unsigned char *)(v3 + 656))
  {
    size_t v5 = 0;
  }
  else
  {
    int v7 = (*(uint64_t (**)(DBM *, void **, void *, uint64_t))&v8->__opaque[40])(v8, &v5, v4, 7);
    if (v7)
    {
      size_t v5 = 0;
      *(unsigned char *)(v3 + 656) = *(unsigned char *)(v3 + 656) & 0xFE | 1;
    }
  }
  int v1 = v5;
  size_t v2 = v6;
  result.dsize = v2;
  result.dptr = v1;
  return result;
}

int dbm_delete(DBM *a1, datum a2)
{
  datum v6 = a2;
  size_t v5 = a1;
  int v4 = 0;
  datum v3 = a2;
  int v4 = (*(uint64_t (**)(DBM *, datum *, void))&a1->__opaque[16])(a1, &v3, 0);
  if (v4) {
    return -1;
  }
  else {
    return 0;
  }
}

int dbm_store(DBM *a1, datum a2, datum a3, int a4)
{
  datum v11 = a2;
  datum v10 = a3;
  uint64_t v9 = a1;
  int v8 = a4;
  datum v7 = a2;
  datum v6 = a3;
  if (a4) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = 8;
  }
  return (*(uint64_t (**)(DBM *, datum *, datum *, uint64_t))&a1->__opaque[32])(a1, &v7, &v6, v4);
}

int dbm_error(DBM *a1)
{
  return *(_DWORD *)(*(void *)&a1->__opaque[56] + 320);
}

int dbm_clearerr(DBM *a1)
{
  uint64_t v1 = *(void *)&a1->__opaque[56];
  int result = 0;
  *(_DWORD *)(v1 + 320) = 0;
  return result;
}

int dbm_dirfno(DBM *a1)
{
  return *(_DWORD *)(*(void *)&a1->__opaque[56] + 284);
}

MPOOL *__cdecl mpool_open(void *a1, int a2, pgno_t a3, pgno_t a4)
{
  datum v11 = a1;
  int v10 = a2;
  pgno_t v9 = a3;
  pgno_t v8 = a4;
  memset(&__b, 0, sizeof(__b));
  if (fstat(v10, &__b)) {
    return 0;
  }
  if ((__b.st_mode & 0xF000) == 0x8000)
  {
    datum v6 = (MPOOL *)malloc_type_calloc();
    if (v6)
    {
      v6->lqh.tqh_first = 0;
      v6->lqh.tqh_last = &v6->lqh.tqh_first;
      for (int i = 0; i < 128; ++i)
      {
        v6->hqh[i].tqh_first = 0;
        v6->hqh[i].tqh_last = &v6->hqh[i].tqh_first;
      }
      v6->maxcache = v8;
      v6->npages = __b.st_size / v9;
      v6->pagesize = v9;
      v6->fd = v10;
      return v6;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 29;
    return 0;
  }
}

void mpool_filter(MPOOL *a1, void (__cdecl *a2)(void *, pgno_t, void *), void (__cdecl *a3)(void *, pgno_t, void *), void *a4)
{
  a1->pgiunsigned __int8 n = a2;
  a1->pgout = a3;
  a1->pgcookie = a4;
}

void *__cdecl mpool_new(MPOOL *a1, pgno_t *a2)
{
  if (a1->npages == -1)
  {
    fprintf(__stderrp, "mpool_new: page allocation overflow.\n");
    abort_report_np((uint64_t)"%s:%s:%u: page allocation overflow");
  }
  size_t v5 = (_bkt *)mpool_bkt((uint64_t)a1);
  if (!v5) {
    return 0;
  }
  pgno_t npages = a1->npages;
  a1->pgno_t npages = npages + 1;
  v5->pgno = npages;
  *a2 = npages;
  v5->flags = 2;
  datum v6 = &a1->hqh[(v5->pgno - 1) % 0x80];
  tqh_first = v6->tqh_first;
  v5->hq.tqe_next = v6->tqh_first;
  if (tqh_first) {
    v6->tqh_first->hq.tqe_prev = &v5->hq.tqe_next;
  }
  else {
    v6->tqh_last = &v5->hq.tqe_next;
  }
  v6->tqh_first = v5;
  v5->hq.tqe_prev = &v6->tqh_first;
  v5->q.tqe_next = 0;
  v5->q.tqe_prev = a1->lqh.tqh_last;
  *a1->lqh.tqh_last = v5;
  a1->lqh.tqh_last = &v5->q.tqe_next;
  return v5->page;
}

uint64_t mpool_bkt(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 2064) >= *(_DWORD *)(a1 + 2068))
  {
    for (uint64_t i = *(void *)a1; i; uint64_t i = *(void *)(i + 16))
    {
      if ((*(unsigned char *)(i + 44) & 2) == 0)
      {
        if ((*(unsigned char *)(i + 44) & 1) != 0 && mpool_write(a1, i) == -1) {
          return 0;
        }
        if (*(void *)i) {
          *(void *)(*(void *)i + 8) = *(void *)(i + 8);
        }
        else {
          *(void *)(a1 + 16 + 16 * ((*(_DWORD *)(i + 40) - 1) % 0x80u) + 8) = *(void *)(i + 8);
        }
        **(void **)(i + 8) = *(void *)i;
        if (*(void *)(i + 16)) {
          *(void *)(*(void *)(i + 16) + 24) = *(void *)(i + 24);
        }
        else {
          *(void *)(a1 + 8) = *(void *)(i + 24);
        }
        **(void **)(i + 24) = *(void *)(i + 16);
        return i;
      }
    }
  }
  uint64_t v3 = malloc_type_calloc();
  if (!v3) {
    return 0;
  }
  *(void *)(v3 + 32) = v3 + 48;
  ++*(_DWORD *)(a1 + 2064);
  return v3;
}

void *__cdecl mpool_get(MPOOL *a1, pgno_t a2, unsigned int a3)
{
  if (a2 < a1->npages)
  {
    datum v7 = (_bkt *)mpool_look((uint64_t)a1, a2);
    if (v7)
    {
      pgno_t v9 = &a1->hqh[(v7->pgno - 1) % 0x80];
      if (v7->hq.tqe_next) {
        v7->hq.tqe_next->hq.tqe_prev = v7->hq.tqe_prev;
      }
      else {
        v9->tqh_last = v7->hq.tqe_prev;
      }
      *v7->hq.tqe_prev = v7->hq.tqe_next;
      tqh_first = v9->tqh_first;
      v7->hq.tqe_next = v9->tqh_first;
      if (tqh_first) {
        v9->tqh_first->hq.tqe_prev = &v7->hq.tqe_next;
      }
      else {
        v9->tqh_last = &v7->hq.tqe_next;
      }
      v9->tqh_first = v7;
      v7->hq.tqe_prev = &v9->tqh_first;
      if (v7->q.tqe_next) {
        v7->q.tqe_next->q.tqe_prev = v7->q.tqe_prev;
      }
      else {
        a1->lqh.tqh_last = v7->q.tqe_prev;
      }
      *v7->q.tqe_prev = v7->q.tqe_next;
      v7->q.tqe_next = 0;
      v7->q.tqe_prev = a1->lqh.tqh_last;
      *a1->lqh.tqh_last = v7;
      a1->lqh.tqh_last = &v7->q.tqe_next;
      v7->flags |= 2u;
      return v7->page;
    }
    else
    {
      pgno_t v8 = (_bkt *)mpool_bkt((uint64_t)a1);
      if (v8)
      {
        int v6 = pread_NOCANCEL();
        if (v6 == a1->pagesize)
        {
          v8->pgno = a2;
          v8->flags = 2;
          int v10 = &a1->hqh[(v8->pgno - 1) % 0x80];
          uint64_t v4 = v10->tqh_first;
          v8->hq.tqe_next = v10->tqh_first;
          if (v4) {
            v10->tqh_first->hq.tqe_prev = &v8->hq.tqe_next;
          }
          else {
            v10->tqh_last = &v8->hq.tqe_next;
          }
          v10->tqh_first = v8;
          v8->hq.tqe_prev = &v10->tqh_first;
          v8->q.tqe_next = 0;
          v8->q.tqe_prev = a1->lqh.tqh_last;
          *a1->lqh.tqh_last = v8;
          a1->lqh.tqh_last = &v8->q.tqe_next;
          if (a1->pgin) {
            ((void (*)(void *, void, void *))a1->pgin)(a1->pgcookie, v8->pgno, v8->page);
          }
          return v8->page;
        }
        else
        {
          if (v6 >= 0) {
            *__error() = 79;
          }
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t *mpool_look(uint64_t a1, int a2)
{
  for (uint64_t i = *(uint64_t **)(a1 + 16 + 16 * ((a2 - 1) % 0x80u)); i; uint64_t i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 10) == a2) {
      return i;
    }
  }
  return 0;
}

int mpool_put(MPOOL *a1, void *a2, unsigned int a3)
{
  *((char *)a2 - 4) &= ~2u;
  *((char *)a2 - 4) |= a3 & 1;
  return 0;
}

int mpool_close(MPOOL *a1)
{
  while (a1->lqh.tqh_first)
  {
    tqh_first = a1->lqh.tqh_first;
    if (a1->lqh.tqh_first->q.tqe_next) {
      tqh_first->q.tqe_next->q.tqe_prev = tqh_first->q.tqe_prev;
    }
    else {
      a1->lqh.tqh_last = tqh_first->q.tqe_prev;
    }
    *tqh_first->q.tqe_prev = tqh_first->q.tqe_next;
    free(tqh_first);
  }
  free(a1);
  return 0;
}

int mpool_sync(MPOOL *a1)
{
  for (uint64_t i = a1->lqh.tqh_first; i; uint64_t i = i->q.tqe_next)
  {
    if (i->flags)
    {
      if (mpool_write((uint64_t)a1, (uint64_t)i) == -1) {
        return -1;
      }
      if (a1->pgin) {
        ((void (*)(void *, void, void *))a1->pgin)(a1->pgcookie, i->pgno, i->page);
      }
    }
  }
  if (fsync_NOCANCEL()) {
    return -1;
  }
  else {
    return 0;
  }
}

uint64_t mpool_write(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 2104)) {
    (*(void (**)(void, void, void))(a1 + 2104))(*(void *)(a1 + 2112), *(unsigned int *)(a2 + 40), *(void *)(a2 + 32));
  }
  if (pwrite_NOCANCEL() == *(void *)(a1 + 2080))
  {
    *(unsigned char *)(a2 + 44) &= ~1u;
    return 0;
  }
  else
  {
    return -1;
  }
}

uint64_t __rec_close(void *a1)
{
  uint64_t v3 = a1[7];
  if (*(void *)(v3 + 32))
  {
    mpool_put(*(MPOOL **)v3, *(void **)(v3 + 32), 0);
    *(void *)(v3 + 32) = 0;
  }
  if (__rec_sync((uint64_t)a1, 0) == -1)
  {
    return -1;
  }
  else
  {
    unsigned int v2 = 0;
    if ((*(_DWORD *)(v3 + 636) & 0x400) != 0 && munmap(*(void **)(v3 + 592), *(void *)(v3 + 608))) {
      unsigned int v2 = -1;
    }
    if ((*(_DWORD *)(v3 + 636) & 0x800) == 0)
    {
      if ((*(_DWORD *)(v3 + 636) & 0x40) != 0)
      {
        if (fclose(*(FILE **)(v3 + 568))) {
          unsigned int v2 = -1;
        }
      }
      else if (close_NOCANCEL())
      {
        unsigned int v2 = -1;
      }
    }
    if (__bt_close(a1) == -1) {
      return -1;
    }
    return v2;
  }
}

uint64_t __rec_sync(uint64_t a1, int a2)
{
  uint64_t v13 = a1;
  int v12 = a2;
  uint64_t v11 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  datum v7 = 0;
  uint64_t v8 = 0;
  off_t v6 = 0;
  int v5 = 0;
  int v4 = 0;
  uint64_t v11 = *(void *)(a1 + 56);
  if (*(void *)(v11 + 32))
  {
    mpool_put(*(MPOOL **)v11, *(void **)(v11 + 32), 0);
    *(void *)(v11 + 32) = 0;
  }
  if (v12 == 11)
  {
    return __bt_sync(v13, 0);
  }
  else if ((*(_DWORD *)(v11 + 636) & 0x2800) == 0 && (*(_DWORD *)(v11 + 636) & 0x1000) != 0)
  {
    if ((*(_DWORD *)(v11 + 636) & 0x100) != 0
      || (*(unsigned int (**)(uint64_t, uint64_t))(v11 + 560))(v11, 0xFFFFFFFFLL) != -1)
    {
      if (lseek(*(_DWORD *)(v11 + 576), 0, 0))
      {
        return -1;
      }
      else
      {
        int v5 = *(_DWORD *)(v11 + 64);
        uint64_t v8 = 4;
        datum v7 = &v4;
        if ((*(_DWORD *)(v11 + 636) & 0x200) != 0)
        {
          for (int i = (*(uint64_t (**)(uint64_t, int **, uint64_t *, uint64_t))(v13 + 40))(v13, &v7, &v9, 3);
                !i;
                int i = (*(uint64_t (**)(uint64_t, int **, uint64_t *, uint64_t))(v13 + 40))(v13, &v7, &v9, 7))
          {
            if (write_NOCANCEL() != v10) {
              return -1;
            }
          }
        }
        else
        {
          uint64_t v17 = v11 + 632;
          uint64_t v18 = 1;
          for (int i = (*(uint64_t (**)(uint64_t, int **, uint64_t *, uint64_t))(v13 + 40))(v13, &v7, &v9, 3);
                !i;
                int i = (*(uint64_t (**)(uint64_t, int **, uint64_t *, uint64_t))(v13 + 40))(v13, &v7, &v9, 7))
          {
            uint64_t v15 = v9;
            uint64_t v16 = v10;
            if (writev_NOCANCEL() != v10 + 1) {
              return -1;
            }
          }
        }
        *(_DWORD *)(v11 + 64) = v5;
        if (i == -1)
        {
          return -1;
        }
        else
        {
          off_t v6 = lseek(*(_DWORD *)(v11 + 576), 0, 1);
          if (v6 == -1)
          {
            return -1;
          }
          else if (ftruncate(*(_DWORD *)(v11 + 576), v6))
          {
            return -1;
          }
          else
          {
            *(_DWORD *)(v11 + 636) &= ~0x1000u;
            return 0;
          }
        }
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __rec_delete(uint64_t a1, unsigned int **a2, int a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  if (*(void *)(v6 + 32))
  {
    mpool_put(*(MPOOL **)v6, *(void **)(v6 + 32), 0);
    *(void *)(v6 + 32) = 0;
  }
  if (a3)
  {
    if (a3 == 1 && (*(unsigned char *)(v6 + 68) & 8) != 0)
    {
      if (!*(_DWORD *)(v6 + 616)) {
        return 1;
      }
      unsigned int v4 = rec_rdelete((MPOOL **)v6, *(_DWORD *)(v6 + 64) - 1);
      if (!v4) {
        --*(_DWORD *)(v6 + 64);
      }
      goto LABEL_17;
    }
LABEL_16:
    *__error() = 22;
    return -1;
  }
  unsigned int v5 = **a2;
  if (!v5) {
    goto LABEL_16;
  }
  if (v5 > *(_DWORD *)(v6 + 616)) {
    return 1;
  }
  unsigned int v4 = rec_rdelete((MPOOL **)v6, v5 - 1);
LABEL_17:
  if (!v4) {
    *(_DWORD *)(v6 + 636) |= 0x1004u;
  }
  return v4;
}

uint64_t rec_rdelete(MPOOL **a1, unsigned int a2)
{
  uint64_t v5 = __rec_search((uint64_t)a1, a2, 0);
  if (v5)
  {
    unsigned int v4 = *(unsigned __int16 **)v5;
    unsigned int v3 = __rec_dleaf((uint64_t)a1, *(unsigned __int16 **)v5, *(unsigned __int16 *)(v5 + 8));
    if (v3)
    {
      mpool_put(*a1, v4, 0);
      return v3;
    }
    else
    {
      mpool_put(*a1, v4, 1u);
      return 0;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __rec_dleaf(uint64_t a1, unsigned __int16 *a2, unsigned int a3)
{
  uint64_t v11 = (char *)a2 + a2[a3 + 10];
  if ((v11[4] & 1) != 0 && __ovfl_delete(a1, (pgno_t *)(v11 + 5)) == -1)
  {
    return -1;
  }
  else
  {
    unsigned int v6 = (*(_DWORD *)v11 + 8) & 0xFFFFFFFC;
    memmove((char *)a2 + a2[9] + v6, (char *)a2 + a2[9], v11 - ((char *)a2 + a2[9]));
    a2[9] += v6;
    unsigned __int16 v7 = a2[a3 + 10];
    uint64_t v10 = a2 + 10;
    __int16 v8 = 2 * a3 / 2;
    while (v8--)
    {
      if (*v10 < (int)v7) {
        *v10 += v6;
      }
      ++v10;
    }
    __int16 v9 = &a2[((unint64_t)a2[8] - 20) / 2 + 10] - v10;
    while (--v9)
    {
      if (v10[1] >= (int)v7) {
        unsigned __int16 v5 = v10[1];
      }
      else {
        unsigned __int16 v5 = v10[1] + v6;
      }
      *v10++ = v5;
    }
    a2[8] -= 2;
    --*(_DWORD *)(a1 + 616);
    return 0;
  }
}

uint64_t __rec_get(uint64_t a1, unsigned int **a2, void *a3, int a4)
{
  uint64_t v9 = *(void *)(a1 + 56);
  if (*(void *)(v9 + 32))
  {
    mpool_put(*(MPOOL **)v9, *(void **)(v9 + 32), 0);
    *(void *)(v9 + 32) = 0;
  }
  if (!a4 && (unsigned int v7 = **a2) != 0)
  {
    if (v7 > *(_DWORD *)(v9 + 616))
    {
      if ((*(_DWORD *)(v9 + 636) & 0x900) != 0) {
        return 1;
      }
      unsigned int v5 = (*(uint64_t (**)(uint64_t, void))(v9 + 560))(v9, v7);
      if (v5) {
        return v5;
      }
    }
    __int16 v8 = (void **)__rec_search(v9, v7 - 1, 2);
    if (v8)
    {
      unsigned int v6 = __rec_ret(v9, (uint64_t)v8, 0, 0, a3);
      if ((*(_DWORD *)(v9 + 636) & 0x4000) != 0) {
        mpool_put(*(MPOOL **)v9, *v8, 0);
      }
      else {
        *(void *)(v9 + 32) = *v8;
      }
      return v6;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t __rec_fpipe(uint64_t a1, unsigned int a2)
{
  uint64_t v11 = a1;
  unsigned int v10 = a2;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if (*(void *)(a1 + 504) < *(void *)(a1 + 624))
  {
    *(void *)(v11 + 496) = reallocf(*(void **)(v11 + 496), *(void *)(v11 + 624));
    if (!*(void *)(v11 + 496)) {
      return -1;
    }
    *(void *)(v11 + 504) = *(void *)(v11 + 624);
  }
  uint64_t v8 = *(void *)(v11 + 496);
  uint64_t v9 = *(void *)(v11 + 624);
  unsigned int v7 = *(_DWORD *)(v11 + 616);
  do
  {
    if (v7 >= v10) {
      break;
    }
    __leunsigned __int8 n = *(void *)(v11 + 624);
    for (stat __b = *(unsigned char **)(v11 + 496); ; ++__b)
    {
      int v5 = getc(*(FILE **)(v11 + 568));
      if (v5 == -1) {
        break;
      }
      if (!--__len) {
        break;
      }
      unsigned int v2 = __b;
      *unsigned int v2 = v5;
    }
    if (v5 != -1) {
      *stat __b = v5;
    }
    if (__len) {
      memset(__b, *(unsigned __int8 *)(v11 + 632), __len);
    }
    if (__rec_iput(v11, v7, (uint64_t)&v8, 0)) {
      return -1;
    }
    ++v7;
  }
  while (v5 != -1);
  if (v7 >= v10)
  {
    return 0;
  }
  else
  {
    *(_DWORD *)(v11 + 636) |= 0x100u;
    return 1;
  }
}

uint64_t __rec_vpipe(uint64_t a1, unsigned int a2)
{
  uint64_t v14 = a1;
  unsigned int v13 = a2;
  uint64_t v11 = 0;
  int v12 = 0;
  int v7 = *(unsigned __int8 *)(a1 + 632);
  for (unsigned int i = *(_DWORD *)(a1 + 616); i < v13; ++i)
  {
    int v5 = *(unsigned char **)(v14 + 496);
    for (uint64_t j = *(void *)(v14 + 504); ; --j)
    {
      int v6 = getc(*(FILE **)(v14 + 568));
      if (v6 == -1 || v6 == v7) {
        break;
      }
      if (!j)
      {
        uint64_t v9 = &v5[-*(void *)(v14 + 496)];
        uint64_t j = 256;
        *(void *)(v14 + 504) += 256;
        unsigned int v2 = reallocf(*(void **)(v14 + 496), *(void *)(v14 + 504));
        *(void *)(v14 + 496) = v2;
        if (!*(void *)(v14 + 496)) {
          return -1;
        }
        int v5 = &v9[*(void *)(v14 + 496)];
      }
      unsigned int v3 = v5++;
      *unsigned int v3 = v6;
    }
    uint64_t v11 = *(void *)(v14 + 496);
    int v12 = &v5[-*(void *)(v14 + 496)];
    if ((v6 != -1 || v12) && __rec_iput(v14, i, (uint64_t)&v11, 0)) {
      return -1;
    }
    if (v6 == -1) {
      break;
    }
  }
  if (i >= v13)
  {
    return 0;
  }
  else
  {
    *(_DWORD *)(v14 + 636) |= 0x100u;
    return 1;
  }
}

uint64_t __rec_fmap(uint64_t a1, unsigned int a2)
{
  uint64_t v14 = a1;
  unsigned int v13 = a2;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (*(void *)(a1 + 504) < *(void *)(a1 + 624))
  {
    *(void *)(v14 + 496) = reallocf(*(void **)(v14 + 496), *(void *)(v14 + 624));
    if (!*(void *)(v14 + 496)) {
      return -1;
    }
    *(void *)(v14 + 504) = *(void *)(v14 + 624);
  }
  uint64_t v11 = *(void *)(v14 + 496);
  uint64_t v12 = *(void *)(v14 + 624);
  uint64_t v9 = *(unsigned char **)(v14 + 584);
  unint64_t v8 = *(void *)(v14 + 600);
  for (unsigned int i = *(_DWORD *)(v14 + 616); i < v13; ++i)
  {
    if ((unint64_t)v9 >= v8)
    {
      *(_DWORD *)(v14 + 636) |= 0x100u;
      return 1;
    }
    __leunsigned __int8 n = *(void *)(v14 + 624);
    for (stat __b = *(char **)(v14 + 496); ; ++__b)
    {
      BOOL v5 = 0;
      if ((unint64_t)v9 < v8) {
        BOOL v5 = __len != 0;
      }
      if (!v5) {
        break;
      }
      unsigned int v2 = v9++;
      unsigned int v3 = __b;
      *unsigned int v3 = *v2;
      --__len;
    }
    if (__len) {
      memset(__b, *(unsigned __int8 *)(v14 + 632), __len);
    }
    if (__rec_iput(v14, i, (uint64_t)&v11, 0)) {
      return -1;
    }
  }
  *(void *)(v14 + 584) = v9;
  return 0;
}

uint64_t __rec_vmap(uint64_t a1, unsigned int a2)
{
  uint64_t v11 = a1;
  unsigned int v10 = a2;
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  int v7 = *(unsigned __int8 **)(a1 + 584);
  unint64_t v6 = *(void *)(a1 + 600);
  int v4 = *(unsigned __int8 *)(a1 + 632);
  for (unsigned int i = *(_DWORD *)(a1 + 616); i < v10; ++i)
  {
    if ((unint64_t)v7 >= v6)
    {
      *(_DWORD *)(v11 + 636) |= 0x100u;
      return 1;
    }
    unint64_t v8 = v7;
    while (1)
    {
      BOOL v3 = 0;
      if ((unint64_t)v7 < v6) {
        BOOL v3 = *v7 != v4;
      }
      if (!v3) {
        break;
      }
      ++v7;
    }
    uint64_t v9 = (unsigned __int8 *)(v7 - v8);
    if (__rec_iput(v11, i, (uint64_t)&v8, 0)) {
      return -1;
    }
    ++v7;
  }
  *(void *)(v11 + 584) = v7;
  return 0;
}

void *__rec_open(uint64_t a1, int a2, int a3, uint64_t a4, int a5)
{
  uint64_t v19 = a1;
  int v18 = a2;
  int v17 = a3;
  uint64_t v16 = a4;
  int v15 = a5;
  uint64_t v14 = 0;
  memset(__b, 0, sizeof(__b));
  uint64_t v12 = 0;
  uint64_t v11 = 0;
  memset(&v10, 0, sizeof(v10));
  int v9 = 0;
  if (v19)
  {
    int v9 = open_NOCANCEL();
    if (v9 < 0) {
      return 0;
    }
  }
  uint64_t v12 = 0;
  if (v16)
  {
    if ((*(void *)v16 & 0xFFFFFFFFFFFFFFF8) != 0) {
      goto LABEL_44;
    }
    __b[0] = 0;
    __b[1] = *(unsigned int *)(v16 + 8);
    LODWORD(__b[2]) = 0;
    HIDWORD(__b[2]) = *(_DWORD *)(v16 + 12);
    __b[3] = 0;
    __b[4] = 0;
    LODWORD(__b[5]) = *(_DWORD *)(v16 + 16);
    uint64_t v12 = (void *)__bt_open(*(void *)(v16 + 40), 2, 384, __b, v15);
  }
  else
  {
    uint64_t v12 = (void *)__bt_open(0, 2, 384, 0, v15);
  }
  if (!v12) {
    goto LABEL_45;
  }
  uint64_t v14 = v12[7];
  if (v16)
  {
    if (*(void *)v16)
    {
      *(_DWORD *)(v14 + 636) |= 0x200u;
      *(void *)(v14 + 624) = *(void *)(v16 + 24);
      if (!*(void *)(v14 + 624)) {
        goto LABEL_44;
      }
    }
    *(unsigned char *)(v14 + 632) = *(unsigned char *)(v16 + 32);
  }
  else
  {
    *(unsigned char *)(v14 + 632) = 10;
  }
  *(_DWORD *)(v14 + 636) |= 0x80u;
  if (v19) {
    *(_DWORD *)(v14 + 576) = v9;
  }
  else {
    *(_DWORD *)(v14 + 636) |= 0x900u;
  }
  if (!v19) {
    goto LABEL_35;
  }
  *__error() = 0;
  if (lseek(v9, 0, 1) != -1 || *__error() != 29)
  {
    if ((v18 & 3) != 0)
    {
      if ((v18 & 3) != 2) {
        goto LABEL_44;
      }
    }
    else
    {
      *(_DWORD *)(v14 + 636) |= 0x2000u;
    }
    if (fstat(v9, &v10)) {
      goto LABEL_45;
    }
    if (!v10.st_size)
    {
      *(_DWORD *)(v14 + 636) |= 0x100u;
      goto LABEL_35;
    }
    goto LABEL_23;
  }
  if ((v18 & 3) != 0)
  {
LABEL_44:
    *__error() = 22;
    goto LABEL_45;
  }
  *(_DWORD *)(v14 + 636) |= 0x2000u;
LABEL_23:
  BOOL v5 = fdopen_DARWIN_EXTSN(v9, "r");
  *(void *)(v14 + 568) = v5;
  if (v5)
  {
    unint64_t v6 = __rec_fpipe;
    *(_DWORD *)(v14 + 636) |= 0x40u;
    if ((*(_DWORD *)(v14 + 636) & 0x200) == 0) {
      unint64_t v6 = __rec_vpipe;
    }
    *(void *)(v14 + 560) = v6;
LABEL_35:
    v12[1] = __rec_close;
    int v12[2] = __rec_delete;
    v12[8] = __rec_fd;
    v12[3] = __rec_get;
    v12[4] = __rec_put;
    v12[5] = __rec_seq;
    v12[6] = __rec_sync;
    uint64_t v11 = mpool_get(*(MPOOL **)v14, 1u, 0);
    if (v11)
    {
      if ((v11[3] & 0x1F) == 2)
      {
        v11[3] &= 0xFFFFFFE0;
        v11[3] |= 0x10u;
        mpool_put(*(MPOOL **)v14, v11, 1u);
      }
      else
      {
        mpool_put(*(MPOOL **)v14, v11, 0);
      }
      if (!v16
        || (*(void *)v16 & 4) == 0
        || (*(_DWORD *)(v14 + 636) & 0x900) != 0
        || (*(unsigned int (**)(uint64_t, uint64_t))(v14 + 560))(v14, 0xFFFFFFFFLL) != -1)
      {
        return v12;
      }
    }
  }
LABEL_45:
  int v8 = *__error();
  if (v12) {
    __bt_close(v12);
  }
  if (v19) {
    close_NOCANCEL();
  }
  *__error() = v8;
  return 0;
}

uint64_t __rec_fd(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(void *)(v2 + 32))
  {
    mpool_put(*(MPOOL **)v2, *(void **)(v2 + 32), 0);
    *(void *)(v2 + 32) = 0;
  }
  if ((*(_DWORD *)(v2 + 636) & 0x800) != 0)
  {
    *__error() = 2;
    return -1;
  }
  else
  {
    return *(unsigned int *)(v2 + 576);
  }
}

uint64_t __rec_put(uint64_t a1, unsigned int **a2, uint64_t a3, unsigned int a4)
{
  uint64_t v17 = a1;
  uint64_t v16 = a2;
  uint64_t v15 = a3;
  unsigned int v14 = a4;
  uint64_t v13 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  stat __b = 0;
  __leunsigned __int8 n = 0;
  uint64_t v13 = *(void *)(a1 + 56);
  if (*(void *)(v13 + 32))
  {
    mpool_put(*(MPOOL **)v13, *(void **)(v13 + 32), 0);
    *(void *)(v13 + 32) = 0;
  }
  if ((*(_DWORD *)(v13 + 636) & 0x200) == 0 || *(void *)(v15 + 8) == *(void *)(v13 + 624))
  {
    uint64_t v11 = *(const void **)v15;
    uint64_t v12 = *(void *)(v15 + 8);
  }
  else
  {
    if (*(void *)(v15 + 8) > *(void *)(v13 + 624))
    {
LABEL_30:
      *__error() = 22;
      return -1;
    }
    if (*(void *)(v13 + 504) < *(void *)(v13 + 624))
    {
      *(void *)(v13 + 496) = reallocf(*(void **)(v13 + 496), *(void *)(v13 + 624));
      if (!*(void *)(v13 + 496)) {
        return -1;
      }
      *(void *)(v13 + 504) = *(void *)(v13 + 624);
    }
    memmove(*(void **)(v13 + 496), *(const void **)v15, *(void *)(v15 + 8));
    memset((void *)(*(void *)(v13 + 496) + *(void *)(v15 + 8)), *(unsigned __int8 *)(v13 + 632), *(void *)(v13 + 624) - *(void *)(v15 + 8));
    uint64_t v11 = *(const void **)(v13 + 496);
    uint64_t v12 = *(void *)(v13 + 624);
  }
  if (v14)
  {
    uint64_t v5 = v14;
    char v4 = 1;
  }
  else
  {
    uint64_t v5 = 0;
    char v4 = 0;
  }
  if (v4) {
    goto LABEL_30;
  }
  switch(v5)
  {
    case 0:
    case 5:
      unsigned int v8 = **v16;
      if (v8) {
        goto LABEL_31;
      }
      goto LABEL_30;
    case 1:
      if ((*(unsigned char *)(v13 + 68) & 8) == 0) {
        goto LABEL_30;
      }
      unsigned int v8 = *(_DWORD *)(v13 + 64);
      goto LABEL_31;
    case 2:
    case 3:
    case 6:
    case 7:
    case 9:
      goto LABEL_30;
    case 4:
      unsigned int v8 = **v16;
      if (!v8)
      {
        unsigned int v8 = 1;
        unsigned int v14 = 5;
      }
      goto LABEL_31;
    case 8:
      unsigned int v8 = **v16;
      if (!v8) {
        goto LABEL_30;
      }
      if (v8 <= *(_DWORD *)(v13 + 616)) {
        return 1;
      }
LABEL_31:
      if (v8 <= *(_DWORD *)(v13 + 616)) {
        goto LABEL_47;
      }
      if ((*(_DWORD *)(v13 + 636) & 0x900) == 0
        && (*(unsigned int (**)(uint64_t, void))(v13 + 560))(v13, v8) == -1)
      {
        return -1;
      }
      if (v8 <= *(_DWORD *)(v13 + 616) + 1) {
        goto LABEL_47;
      }
      if ((*(_DWORD *)(v13 + 636) & 0x200) != 0)
      {
        stat __b = (void *)malloc_type_malloc();
        if (!__b) {
          return -1;
        }
        __leunsigned __int8 n = *(void *)(v13 + 624);
        memset(__b, *(unsigned __int8 *)(v13 + 632), __len);
      }
      else
      {
        stat __b = 0;
        __leunsigned __int8 n = 0;
      }
      break;
    case 10:
      unsigned int v8 = **v16;
      if (v8) {
        goto LABEL_31;
      }
      goto LABEL_30;
    default:
      JUMPOUT(0);
  }
  while (v8 > *(_DWORD *)(v13 + 616) + 1)
  {
    if (__rec_iput(v13, *(_DWORD *)(v13 + 616), (uint64_t)&__b, 0)) {
      return -1;
    }
  }
  if ((*(_DWORD *)(v13 + 636) & 0x200) != 0) {
    free(__b);
  }
LABEL_47:
  unsigned int v7 = __rec_iput(v13, v8 - 1, (uint64_t)&v11, v14);
  if (v7)
  {
    return v7;
  }
  else
  {
    if (v14 == 4)
    {
      ++v8;
    }
    else if (v14 == 10)
    {
      *(_DWORD *)(v13 + 64) = v8;
    }
    *(_DWORD *)(v13 + 636) |= 0x1000u;
    return __rec_ret(v13, 0, v8, v16, 0);
  }
}

uint64_t __rec_iput(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  int v23 = (MPOOL **)a1;
  unsigned int v22 = a2;
  int v21 = (const void **)a3;
  int v20 = a4;
  int v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  uint64_t v16 = 0;
  unsigned __int16 v15 = 0;
  unsigned __int16 v14 = 0;
  int v13 = 0;
  if (*(void *)(a3 + 8) <= (unint64_t)*(unsigned __int16 *)(a1 + 524))
  {
    int v11 = 0;
  }
  else
  {
    if (__ovfl_put(v23, (uint64_t)v21, &v13) == -1) {
      return -1;
    }
    int v18 = v25;
    uint64_t v19 = 8;
    v25[0] = v13;
    v25[1] = v21[1];
    int v11 = 1;
    int v21 = (const void **)&v18;
  }
  BOOL v8 = 1;
  if (v22 <= *((_DWORD *)v23 + 154))
  {
    BOOL v8 = 1;
    if (v20 != 4) {
      BOOL v8 = v20 == 5;
    }
  }
  if (v8) {
    int v4 = 1;
  }
  else {
    int v4 = 2;
  }
  uint64_t v17 = __rec_search((uint64_t)v23, v22, v4);
  if (v17)
  {
    uint64_t v16 = *(void **)v17;
    unsigned __int16 v15 = *(_WORD *)(v17 + 8);
    if (v20 == 4)
    {
      ++v15;
    }
    else if (v20 != 5 {
           && v22 < *((_DWORD *)v23 + 154)
    }
           && __rec_dleaf((uint64_t)v23, (unsigned __int16 *)v16, v15) == -1)
    {
      mpool_put(*v23, v16, 0);
      return -1;
    }
    unsigned int v12 = (v21[1] + 8) & 0xFFFFFFFC;
    if (*((unsigned __int16 *)v16 + 9) - *((unsigned __int16 *)v16 + 8) >= (unint64_t)v12 + 2)
    {
      unint64_t v5 = ((unint64_t)*((unsigned __int16 *)v16 + 8) - 20) / 2;
      unsigned __int16 v14 = v5;
      if (v15 < (int)(unsigned __int16)v5) {
        memmove((char *)v16 + 2 * v15 + 22, (char *)v16 + 2 * v15 + 20, 2 * (v14 - v15));
      }
      *((_WORD *)v16 + 8) += 2;
      __int16 v6 = *((_WORD *)v16 + 9) - v12;
      *((_WORD *)v16 + 9) = v6;
      *((_WORD *)v16 + v15 + 10) = v6;
      __dst = (char *)v16 + *((unsigned __int16 *)v16 + 9);
      *(_DWORD *)__dst = v21[1];
      __dst[4] = v11;
      memmove(__dst + 5, *v21, (size_t)v21[1]);
      ++*((_DWORD *)v23 + 154);
      *((_DWORD *)v23 + 159) |= 4u;
      mpool_put(*v23, v16, 1u);
      return 0;
    }
    else
    {
      unsigned int v10 = __bt_split(v23, v16, 0, (uint64_t)v21, v11, v12, v15);
      if (!v10) {
        ++*((_DWORD *)v23 + 154);
      }
      return v10;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __rec_search(uint64_t a1, unsigned int a2, int a3)
{
  *(void *)(a1 + 472) = a1 + 72;
  pgno_t v11 = 1;
  int v10 = 0;
  while (1)
  {
    int v13 = mpool_get(*(MPOOL **)a1, v11, 0);
    if (!v13) {
      break;
    }
    if ((v13[3] & 0x10) != 0)
    {
      *(void *)(a1 + 16) = v13;
      *(_WORD *)(a1 + 24) = a2 - v10;
      return a1 + 16;
    }
    unsigned __int16 v15 = 0;
    while (1)
    {
      unsigned int v12 = (_DWORD *)((char *)v13 + *((unsigned __int16 *)v13 + v15 + 10));
      if ((unsigned __int16)(((unint64_t)*((unsigned __int16 *)v13 + 8) - 20) / 2) == ++v15 || v10 + *v12 > a2) {
        break;
      }
      v10 += *v12;
    }
    **(_DWORD **)(a1 + 472) = v11;
    *(_WORD *)(*(void *)(a1 + 472) + 4) = v15 - 1;
    *(void *)(a1 + 472) += 8;
    pgno_t v11 = v12[1];
    if (a3)
    {
      if (a3 == 1)
      {
        int v4 = (_DWORD *)((char *)v13 + *((unsigned __int16 *)v13 + v15 + 9));
        ++*v4;
        mpool_put(*(MPOOL **)a1, v13, 1u);
      }
      else if (a3 == 2)
      {
        mpool_put(*(MPOOL **)a1, v13, 0);
      }
    }
    else
    {
      BOOL v3 = (_DWORD *)((char *)v13 + *((unsigned __int16 *)v13 + v15 + 9));
      --*v3;
      mpool_put(*(MPOOL **)a1, v13, 1u);
    }
  }
  int v9 = *__error();
  if (a3 != 2)
  {
    while (1)
    {
      if (*(void *)(a1 + 472) == a1 + 72)
      {
        uint64_t v8 = 0;
      }
      else
      {
        uint64_t v5 = *(void *)(a1 + 472) - 8;
        *(void *)(a1 + 472) = v5;
        uint64_t v8 = v5;
      }
      if (!v8) {
        break;
      }
      unsigned __int16 v14 = (char *)mpool_get(*(MPOOL **)a1, *(_DWORD *)v8, 0);
      if (!v14) {
        break;
      }
      __int16 v6 = &v14[*(unsigned __int16 *)&v14[2 * *(unsigned __int16 *)(v8 + 4) + 20]];
      if (a3 == 1) {
        --*(_DWORD *)v6;
      }
      else {
        ++*(_DWORD *)v6;
      }
      mpool_put(*(MPOOL **)a1, v14, 1u);
    }
  }
  *__error() = v9;
  return 0;
}

uint64_t __rec_seq(uint64_t a1, unsigned int **a2, void *a3, unsigned int a4)
{
  uint64_t v11 = *(void *)(a1 + 56);
  if (*(void *)(v11 + 32))
  {
    mpool_put(*(MPOOL **)v11, *(void **)(v11 + 32), 0);
    *(void *)(v11 + 32) = 0;
  }
  if (a4 <= 1)
  {
    uint64_t v5 = a4 - 1;
    char v4 = 0;
  }
  else
  {
    uint64_t v5 = a4 - 1;
    char v4 = 1;
  }
  if (v4)
  {
LABEL_21:
    *__error() = 22;
    return -1;
  }
  else
  {
    switch(v5)
    {
      case 0:
        unsigned int v9 = **a2;
        if (v9) {
          goto LABEL_22;
        }
        goto LABEL_21;
      case 1:
      case 3:
      case 4:
      case 7:
        goto LABEL_21;
      case 2:
        goto LABEL_12;
      case 5:
        goto LABEL_17;
      case 6:
        if ((*(unsigned char *)(v11 + 68) & 8) != 0) {
          unsigned int v9 = *(_DWORD *)(v11 + 64) + 1;
        }
        else {
LABEL_12:
        }
          unsigned int v9 = 1;
        goto LABEL_22;
      case 8:
        if ((*(unsigned char *)(v11 + 68) & 8) != 0)
        {
          unsigned int v9 = *(_DWORD *)(v11 + 64) - 1;
          if (*(_DWORD *)(v11 + 64) == 1) {
            return 1;
          }
        }
        else
        {
LABEL_17:
          if ((*(_DWORD *)(v11 + 636) & 0x900) == 0
            && (*(unsigned int (**)(uint64_t, uint64_t))(v11 + 560))(v11, 0xFFFFFFFFLL) == -1)
          {
            return -1;
          }
          unsigned int v9 = *(_DWORD *)(v11 + 616);
        }
LABEL_22:
        if (*(_DWORD *)(v11 + 616) && v9 <= *(_DWORD *)(v11 + 616)) {
          goto LABEL_30;
        }
        if ((*(_DWORD *)(v11 + 636) & 0x900) != 0
          || (unsigned int v7 = (*(uint64_t (**)(uint64_t, void))(v11 + 560))(v11, v9)) == 0)
        {
          if (*(_DWORD *)(v11 + 616) && v9 <= *(_DWORD *)(v11 + 616))
          {
LABEL_30:
            int v10 = (void **)__rec_search(v11, v9 - 1, 2);
            if (v10)
            {
              *(unsigned char *)(v11 + 68) |= 8u;
              *(_DWORD *)(v11 + 64) = v9;
              unsigned int v8 = __rec_ret(v11, (uint64_t)v10, v9, a2, a3);
              if ((*(_DWORD *)(v11 + 636) & 0x4000) != 0) {
                mpool_put(*(MPOOL **)v11, *v10, 0);
              }
              else {
                *(void *)(v11 + 32) = *v10;
              }
              unsigned int v15 = v8;
            }
            else
            {
              unsigned int v15 = -1;
            }
          }
          else
          {
            unsigned int v15 = 1;
          }
        }
        else
        {
          unsigned int v15 = v7;
        }
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v15;
}

uint64_t __rec_ret(uint64_t a1, uint64_t a2, int a3, void *a4, void *a5)
{
  if (a4)
  {
    if (*(void *)(a1 + 488) < 4uLL)
    {
      uint64_t v6 = malloc_type_realloc();
      if (!v6) {
        return -1;
      }
      *(void *)(a1 + 480) = v6;
      *(void *)(a1 + 488) = 4;
    }
    **(_DWORD **)(a1 + 480) = a3;
    a4[1] = 4;
    *a4 = *(void *)(a1 + 480);
  }
  if (a5)
  {
    unsigned int v8 = (unsigned int *)(*(void *)a2
                        + *(unsigned __int16 *)(*(void *)a2 + 20 + 2 * *(unsigned __int16 *)(a2 + 8)));
    if (v8[1])
    {
      if (__ovfl_get(a1, (unsigned int *)((char *)v8 + 5), a5 + 1, (void **)(a1 + 496), (void *)(a1 + 504)))return -1; {
      *a5 = *(void *)(a1 + 496);
      }
    }
    else if ((*(_DWORD *)(a1 + 636) & 0x4000) != 0)
    {
      if ((unint64_t)(*v8 + 1) > *(void *)(a1 + 504))
      {
        uint64_t v7 = malloc_type_realloc();
        if (!v7) {
          return -1;
        }
        *(void *)(a1 + 496) = v7;
        *(void *)(a1 + 504) = *v8 + 1;
      }
      memmove(*(void **)(a1 + 496), (char *)v8 + 5, *v8);
      a5[1] = *v8;
      *a5 = *(void *)(a1 + 496);
    }
    else
    {
      a5[1] = *v8;
      *a5 = (char *)v8 + 5;
    }
    return 0;
  }
  return 0;
}

int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
{
  unsigned __int8 v6 = 0;
  while (__len)
  {
    BOOL v3 = __b1;
    __b1 = (char *)__b1 + 1;
    char v4 = __b2;
    __b2 = (char *)__b2 + 1;
    v6 |= *v3 ^ *v4;
    --__len;
  }
  return (v6 + 255) >> 8;
}

_DWORD *__hdtoa(uint64_t a1, int j, _DWORD *a3, _DWORD *a4, void *a5, double a6)
{
  double v16 = a6;
  *a4 = *(void *)&a6 >> 63;
  unsigned int v6 = __fpclassifyd(a6);
  if (v6 <= 1)
  {
    uint64_t v8 = v6 - 1;
    char v7 = 0;
  }
  else
  {
    uint64_t v8 = v6 - 1;
    char v7 = 1;
  }
  if (v7) {
    abort_report_np((uint64_t)"%s:%s:%u: fpclassify returned %d");
  }
  switch(v8)
  {
    case 0:
      *a3 = 0x7FFFFFFF;
      return __nrv_alloc_D2A("NaN", a5, 3);
    case 1:
      *a3 = 0x7FFFFFFF;
      return __nrv_alloc_D2A("Infinity", a5, 8);
    case 2:
      goto LABEL_7;
    case 3:
      *a3 = ((*(void *)&v16 >> 52) & 0x7FF) - 1022;
      goto LABEL_13;
    case 4:
      if (v16 == 0.0)
      {
LABEL_7:
        *a3 = 1;
        return __nrv_alloc_D2A("0", a5, 1);
      }
      else
      {
        double v16 = v16 * 5.36312317e154;
        *a3 = ((*(void *)&v16 >> 52) & 0x7FF) - 1536;
LABEL_13:
        if (!j) {
          uint64_t j = 1;
        }
        if (j >= 14) {
          int v11 = j;
        }
        else {
          int v11 = 14;
        }
        unsigned int v12 = __rv_alloc_D2A(v11);
        for (unsigned int i = &v12[v11 - 1]; i > v12 + 13; --i)
          *unsigned int i = 0;
        while (1)
        {
          BOOL v10 = 0;
          if (i > v12 + 5) {
            BOOL v10 = i > v12;
          }
          if (!v10) {
            break;
          }
          *unsigned int i = LOBYTE(v16) & 0xF;
          *(void *)&double v16 = *(void *)&v16 & 0xFFFFFFFF00000000 | (LODWORD(v16) >> 4);
          --i;
        }
        while (i > v12)
        {
          *unsigned int i = BYTE4(v16) & 0xF;
          *(void *)&double v16 = *(void *)&v16 & 0xFFF00000FFFFFFFFLL | ((unint64_t)(((HIDWORD(v16) & 0xFFFFF) >> 4) & 0xFFFFF) << 32);
          --i;
        }
        *unsigned int i = BYTE4(v16) | 1;
        if (j < 0)
        {
          for (uint64_t j = 14; !v12[j - 1]; --j)
            ;
        }
        if (j < 14 && v12[j]) {
          dorounding(v12, j, *(void *)&v16 >> 63, a3);
        }
        unsigned __int16 v14 = &v12[j];
        if (a5) {
          *a5 = v14;
        }
        unsigned int v15 = v14 - 1;
        v12[j] = 0;
        while (v15 >= v12)
        {
          *unsigned int v15 = *(unsigned char *)(a1 + (char)*v15);
          --v15;
        }
        return v12;
      }
    default:
      JUMPOUT(0);
  }
}

uint64_t dorounding(unsigned char *a1, int a2, int a3, _DWORD *a4)
{
  int v6 = 0;
  unsigned int v4 = ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0)) + 0x400000) >> 22) & 3;
  uint64_t result = v4;
  switch(v4)
  {
    case 1u:
      if (char)a1[a2] > 8 || a1[a2] == 8 && (a1[a2 + 1])
      {
        uint64_t result = roundup(a1, a2);
        int v6 = result;
      }
      break;
    case 2u:
      if (!a3)
      {
        uint64_t result = roundup(a1, a2);
        int v6 = result;
      }
      break;
    case 3u:
      if (a3)
      {
        uint64_t result = roundup(a1, a2);
        int v6 = result;
      }
      break;
    default:
      break;
  }
  if (v6) {
    *a4 += 4;
  }
  return result;
}

_DWORD *__hldtoa(uint64_t a1, int a2, _DWORD *a3, _DWORD *a4, void *a5, double a6)
{
  return __hdtoa(a1, a2, a3, a4, a5, a6);
}

uint64_t roundup(unsigned char *a1, int a2)
{
  for (unsigned int i = &a1[a2 - 1]; *i == 15; --i)
  {
    if (i == a1)
    {
      *unsigned int i = 1;
      return 1;
    }
    *unsigned int i = 0;
  }
  ++*i;
  return 0;
}

_DWORD *__rv_alloc_D2A(int a1)
{
  int v4 = 4;
  int v3 = 0;
  while (v4 + 24 <= (unint64_t)a1)
  {
    ++v3;
    v4 *= 2;
  }
  uint64_t v1 = (_DWORD *)__Balloc_D2A(v3);
  *uint64_t v1 = v3;
  return v1 + 1;
}

_DWORD *__nrv_alloc_D2A(char *a1, void *a2, int a3)
{
  int v6 = __rv_alloc_D2A(a3);
  for (unsigned int i = v6; ; ++i)
  {
    int v3 = a1++;
    LODWORD(v3) = *v3;
    *unsigned int i = (_BYTE)v3;
    if (!v3) {
      break;
    }
  }
  if (a2) {
    *a2 = i;
  }
  return v6;
}

void __freedtoa(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 - 4);
  *(_DWORD *)(a1 + 4) = v1;
  *(_DWORD *)(a1 + 8) = 1 << v1;
  __Bfree_D2A((int *)(a1 - 4));
}

uint64_t __quorem_D2A(uint64_t a1, uint64_t a2)
{
  int v25 = *(_DWORD *)(a2 + 20);
  if (*(_DWORD *)(a1 + 20) > v25)
  {
    fprintf(__stderrp, "%s\n", "oversize b in quorem");
    exit(1);
  }
  if (*(_DWORD *)(a1 + 20) >= v25)
  {
    int v18 = (unsigned int *)(a2 + 24);
    int v26 = v25 - 1;
    uint64_t v17 = (unsigned int *)(a2 + 24 + 4 * v26);
    int v23 = (unsigned int *)(a1 + 24);
    int v21 = (_DWORD *)(a1 + 24 + 4 * v26);
    unsigned int v20 = *v21 / (*v17 + 1);
    if (v20 > 9)
    {
      fprintf(__stderrp, "%s\n", "oversized quotient in quorem");
      exit(1);
    }
    if (v20)
    {
      uint64_t v15 = 0;
      unint64_t v13 = 0;
      do
      {
        uint64_t v2 = v18++;
        unint64_t v9 = *v2 * (unint64_t)v20 + v13;
        unint64_t v13 = HIDWORD(v9);
        unint64_t v11 = *v23 - (unint64_t)v9 - v15;
        uint64_t v15 = HIDWORD(v11) & 1;
        int v3 = v23++;
        *int v3 = v11;
      }
      while (v18 <= v17);
      if (!*v21)
      {
        while (1)
        {
          --v21;
          BOOL v8 = 0;
          if ((unint64_t)v21 > a1 + 24) {
            BOOL v8 = *v21 == 0;
          }
          if (!v8) {
            break;
          }
          --v26;
        }
        *(_DWORD *)(a1 + 20) = v26;
      }
    }
    if ((int)__cmp_D2A(a1, a2) >= 0)
    {
      ++v20;
      uint64_t v16 = 0;
      unint64_t v14 = 0;
      int v24 = (unsigned int *)(a1 + 24);
      uint64_t v19 = (unsigned int *)(a2 + 24);
      do
      {
        int v4 = v19++;
        unint64_t v10 = *v4 + v14;
        unint64_t v14 = HIDWORD(v10);
        unint64_t v12 = *v24 - (unint64_t)v10 - v16;
        uint64_t v16 = HIDWORD(v12) & 1;
        uint64_t v5 = v24++;
        *uint64_t v5 = v12;
      }
      while (v19 <= v17);
      unsigned int v22 = (_DWORD *)(a1 + 24 + 4 * v26);
      if (!*v22)
      {
        while (1)
        {
          --v22;
          BOOL v7 = 0;
          if ((unint64_t)v22 > a1 + 24) {
            BOOL v7 = *v22 == 0;
          }
          if (!v7) {
            break;
          }
          --v26;
        }
        *(_DWORD *)(a1 + 20) = v26;
      }
    }
    return v20;
  }
  else
  {
    return 0;
  }
}

_DWORD *__dtoa(int a1, int a2, _DWORD *a3, _DWORD *a4, void *a5, double a6)
{
  double v100 = a6;
  int v99 = a1;
  int v98 = a2;
  v97 = a3;
  v96 = a4;
  v95 = a5;
  int v94 = 0;
  int v93 = 0;
  int v92 = 0;
  int v91 = 0;
  v50 = 0;
  signed int v30 = ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0)) + 0x400000) >> 22) & 3;
  double v41 = a6;
  if ((HIBYTE(a6) & 0x80) != 0)
  {
    _DWORD *v96 = 1;
    HIDWORD(v41) = HIDWORD(a6) & 0x7FFFFFFF;
  }
  else
  {
    _DWORD *v96 = 0;
  }
  if ((~HIDWORD(v41) & 0x7FF00000) == 0)
  {
    _DWORD *v97 = 9999;
    if (LODWORD(a6) || (HIDWORD(v41) & 0xFFFFF) != 0) {
      return __nrv_alloc_D2A("NaN", v95, 3);
    }
    else {
      return __nrv_alloc_D2A("Infinity", v95, 8);
    }
  }
  if (v41 == 0.0)
  {
    _DWORD *v97 = 1;
    return __nrv_alloc_D2A("0", v95, 1);
  }
  if (v30 >= 2)
  {
    if (*v96)
    {
      signed int v30 = 2 * (v30 != 2);
    }
    else if (v30 != 2)
    {
      signed int v30 = 0;
    }
  }
  int v53 = (int *)__d2b_D2A(&v91, &v94, v41);
  int v78 = (HIDWORD(v41) >> 20) & 0x7FF;
  if (v78)
  {
    LODWORD(v39) = LODWORD(v41);
    HIDWORD(v39) = HIDWORD(v41) & 0xFFFFF | 0x3FF00000;
    int v79 = v78 - 1023;
    int v54 = 0;
  }
  else
  {
    char v80 = v94 + v91 + 50;
    if (v94 + v91 + 1074 < 33) {
      unsigned int v29 = LODWORD(v41) << -v80;
    }
    else {
      unsigned int v29 = (HIDWORD(v41) << -v80) | (LODWORD(v41) >> v80);
    }
    LODWORD(v6) = v29;
    double v7 = (double)v6;
    LODWORD(v39) = LODWORD(v7);
    HIDWORD(v39) = HIDWORD(v7) - 32505856;
    int v79 = v94 + v91 - 1;
    int v54 = 1;
  }
  double v33 = (v39 + -1.5) * 0.289529655 + 0.176091259 + (double)v79 * 0.301029996;
  int v67 = (int)v33;
  if (v33 < 0.0 && v33 != (double)v67) {
    --v67;
  }
  int v65 = 1;
  if ((v67 & 0x80000000) == 0 && v67 <= 22)
  {
    if (v41 < __tens_D2A[v67]) {
      --v67;
    }
    int v65 = 0;
  }
  int v70 = ~v79 + v94;
  if (v70 < 0)
  {
    int v93 = -v70;
    int v61 = 0;
  }
  else
  {
    int v93 = 0;
    int v61 = ~v79 + v94;
  }
  if (v67 < 0)
  {
    v93 -= v67;
    int v92 = -v67;
    int v60 = 0;
  }
  else
  {
    int v92 = 0;
    int v60 = v67;
    v61 += v67;
  }
  if (v99 < 0 || v99 >= 10) {
    int v99 = 0;
  }
  BOOL v58 = v30 == 1;
  if (v99 >= 6)
  {
    v99 -= 4;
    BOOL v58 = 0;
  }
  int v64 = 1;
  int v74 = -1;
  int v76 = -1;
  switch(v99)
  {
    case 0:
    case 1:
      int v98 = 0;
      BOOL v8 = __rv_alloc_D2A(18);
      goto LABEL_51;
    case 2:
      int v64 = 0;
      goto LABEL_44;
    case 3:
      int v64 = 0;
      goto LABEL_48;
    case 4:
LABEL_44:
      if (v98 <= 0) {
        int v98 = 1;
      }
      int v74 = v98;
      int v76 = v98;
      BOOL v8 = __rv_alloc_D2A(v98);
      goto LABEL_51;
    case 5:
LABEL_48:
      int v79 = v98 + v67 + 1;
      int v76 = v79;
      int v74 = v98 + v67;
      if (v79 <= 0) {
        int v79 = 1;
      }
      break;
    default:
      break;
  }
  BOOL v8 = __rv_alloc_D2A(v79);
LABEL_51:
  uint64_t v31 = v8;
  int v32 = v8;
  if (v99 >= 2 && v30 != 1) {
    int v64 = 0;
  }
  if (v76 < 0 || v76 > 14 || !v58)
  {
LABEL_97:
    if (v91 < 0 || v67 > 14)
    {
      int v63 = v93;
      int v62 = v92;
      v50 = 0;
      int v48 = 0;
      if (v64)
      {
        if (v54) {
          int v28 = v91 + 1075;
        }
        else {
          int v28 = 54 - v94;
        }
        v93 += v28;
        v61 += v28;
        int v48 = (int *)__i2b_D2A(1);
      }
      if (v63 >= 1 && v61 >= 1)
      {
        if (v63 < v61) {
          int v27 = v63;
        }
        else {
          int v27 = v61;
        }
        v93 -= v27;
        v63 -= v27;
        v61 -= v27;
      }
      if (v92 >= 1)
      {
        if (v64)
        {
          if (v62 >= 1)
          {
            int v48 = __pow5mult_D2A(v48, v62);
            uint64_t v52 = __mult_D2A(v48, v53);
            __Bfree_D2A(v53);
            int v53 = (int *)v52;
          }
          if (v92 != v62) {
            int v53 = __pow5mult_D2A(v53, v92 - v62);
          }
        }
        else
        {
          int v53 = __pow5mult_D2A(v53, v92);
        }
      }
      long long v47 = (int *)__i2b_D2A(1);
      if (v60 >= 1) {
        long long v47 = __pow5mult_D2A(v47, v60);
      }
      int v59 = 0;
      if ((v99 < 2 || v64) && v30 == 1 && !LODWORD(v41) && (HIDWORD(v41) & 0xFFFFF) == 0 && (HIWORD(v41) & 0x7FE0) != 0)
      {
        ++v93;
        ++v61;
        int v59 = 1;
      }
      if (v60) {
        int v26 = 32 - __hi0bits_D2A(v47[v47[5] + 5]);
      }
      else {
        LOBYTE(v26) = 1;
      }
      int v85 = ((_BYTE)v26 + (_BYTE)v61) & 0x1F;
      if ((((_BYTE)v26 + (_BYTE)v61) & 0x1F) != 0) {
        int v85 = 32 - v85;
      }
      if (v85 < 5)
      {
        if (v85 <= 3)
        {
          int v87 = v85 + 28;
          v93 += v87;
          v63 += v87;
          v61 += v87;
        }
      }
      else
      {
        int v86 = v85 - 4;
        v93 += v86;
        v63 += v86;
        v61 += v86;
      }
      if (v93 >= 1) {
        int v53 = (int *)__lshift_D2A(v53, v93);
      }
      if (v61 >= 1) {
        long long v47 = (int *)__lshift_D2A(v47, v61);
      }
      if (v65 && (__cmp_D2A((uint64_t)v53, (uint64_t)v47) & 0x80000000) != 0)
      {
        --v67;
        int v53 = __multadd_D2A(v53, 10, 0);
        if (v64) {
          int v48 = __multadd_D2A(v48, 10, 0);
        }
        int v76 = v74;
      }
      if (v76 > 0 || v99 != 3 && v99 != 5)
      {
        if (v64)
        {
          if (v63 >= 1) {
            int v48 = (int *)__lshift_D2A(v48, v63);
          }
          v50 = v48;
          if (v59)
          {
            v49 = (int *)__Balloc_D2A(v48[2]);
            memcpy(v49 + 4, v50 + 4, 4 * v50[5] + 8);
            int v48 = (int *)__lshift_D2A(v49, 1);
          }
          for (int i = 1; ; ++i)
          {
            int v90 = __quorem_D2A((uint64_t)v53, (uint64_t)v47) + 48;
            int v73 = __cmp_D2A((uint64_t)v53, (uint64_t)v50);
            int v51 = (int *)__diff_D2A((uint64_t)v47, (uint64_t)v48);
            int v25 = v51[4] ? 1 : __cmp_D2A((uint64_t)v53, (uint64_t)v51);
            __Bfree_D2A(v51);
            if (!v25 && v99 != 1 && (LOBYTE(v41) & 1) == 0 && v30 >= 1) {
              break;
            }
            if (v73 & 0x80000000) == 0 && (v73 || v99 == 1 || (LOBYTE(v41)))
            {
              if (v25 >= 1)
              {
                if (!v30) {
                  goto LABEL_213;
                }
                if (v90 != 57)
                {
                  int v18 = v32++;
                  *int v18 = v90 + 1;
                  goto LABEL_244;
                }
                goto LABEL_217;
              }
            }
            else
            {
              if (!v53[6] && v53[5] <= 1) {
                goto LABEL_213;
              }
              if (v99 < 2) {
                goto LABEL_208;
              }
              if (!v30) {
                goto LABEL_213;
              }
              if (v30 != 2)
              {
LABEL_208:
                if (v25 < 1
                  || (int v53 = (int *)__lshift_D2A(v53, 1), v69 = __cmp_D2A((uint64_t)v53, (uint64_t)v47), v69 <= 0)
                  && (v69 || (v90 & 1) == 0)
                  || (int v15 = v90, LOBYTE(v90) = v90 + 1, v15 != 57))
                {
LABEL_213:
                  uint64_t v16 = v32++;
                  *uint64_t v16 = v90;
                  goto LABEL_244;
                }
LABEL_217:
                uint64_t v17 = v32++;
                *uint64_t v17 = 57;
                goto LABEL_237;
              }
            }
            uint64_t v19 = v32++;
            *uint64_t v19 = v90;
            if (i == v76) {
              goto LABEL_229;
            }
            int v53 = __multadd_D2A(v53, 10, 0);
            if (v50 == v48)
            {
              int v48 = __multadd_D2A(v48, 10, 0);
              v50 = v48;
            }
            else
            {
              v50 = __multadd_D2A(v50, 10, 0);
              int v48 = __multadd_D2A(v48, 10, 0);
            }
          }
          if (v90 == 57) {
            goto LABEL_217;
          }
          if (v73 >= 1) {
            LOBYTE(v90) = v90 + 1;
          }
          unint64_t v14 = v32++;
          *unint64_t v14 = v90;
        }
        else
        {
          for (int j = 1; ; ++j)
          {
            LOBYTE(v90) = __quorem_D2A((uint64_t)v53, (uint64_t)v47) + 48;
            unsigned int v20 = v32++;
            unsigned char *v20 = v90;
            if (!v53[6] && v53[5] <= 1) {
              goto LABEL_244;
            }
            if (j >= v76) {
              break;
            }
            int v53 = __multadd_D2A(v53, 10, 0);
          }
LABEL_229:
          if (v30
            && (v30 == 2
             || (int v53 = (int *)__lshift_D2A(v53, 1),
                 int v21 = __cmp_D2A((uint64_t)v53, (uint64_t)v47),
                 v21 > 0 || !v21 && (v90 & 1) != 0)))
          {
LABEL_237:
            while (*--v32 == 57)
            {
              if (v32 == v31)
              {
                ++v67;
                unsigned int v22 = v32++;
                *unsigned int v22 = 49;
                goto LABEL_244;
              }
            }
            int v23 = v32++;
            ++*v23;
          }
          else
          {
            do
              --v32;
            while (*v32 == 48);
            ++v32;
          }
        }
        goto LABEL_244;
      }
      if (v76 < 0) {
        goto LABEL_177;
      }
      long long v47 = __multadd_D2A(v47, 5, 0);
      if ((int)__cmp_D2A((uint64_t)v53, (uint64_t)v47) <= 0) {
        goto LABEL_177;
      }
    }
    else
    {
      double v35 = __tens_D2A[v67];
      if ((v98 & 0x80000000) == 0 || v76 > 0)
      {
        for (int k = 1; ; ++k)
        {
          int v57 = (int)(v41 / v35);
          double v45 = v41 - (double)v57 * v35;
          if (v45 < 0.0)
          {
            LOBYTE(v57) = v57 - 1;
            double v45 = v45 + v35;
          }
          unint64_t v11 = v32++;
          *unint64_t v11 = v57 + 48;
          if (v45 == 0.0) {
            break;
          }
          if (k == v76)
          {
            if (v99 >= 2)
            {
              if (!v30) {
                goto LABEL_249;
              }
              if (v30 == 2) {
                goto LABEL_119;
              }
            }
            double v46 = v45 + v45;
            if (v46 > v35 || v46 == v35 && (v57 & 1) != 0) {
              goto LABEL_119;
            }
            goto LABEL_249;
          }
          double v41 = v45 * 10.0;
        }
        goto LABEL_249;
      }
      int v48 = 0;
      long long v47 = 0;
      if (v76 < 0 || v41 <= v35 * 5.0) {
        goto LABEL_177;
      }
    }
LABEL_178:
    unint64_t v13 = v32++;
    *unint64_t v13 = 49;
    ++v67;
LABEL_244:
    __Bfree_D2A(v47);
    if (v48)
    {
      if (v50 && v50 != v48) {
        __Bfree_D2A(v50);
      }
      __Bfree_D2A(v48);
    }
    goto LABEL_249;
  }
  int v81 = 0;
  double v40 = v41;
  int v66 = v67;
  int v75 = v76;
  int v77 = 2;
  if (v67 < 1)
  {
    int v68 = -v67;
    if (v67)
    {
      double v41 = v41 * __tens_D2A[v68 & 0xF];
      for (int m = v68 >> 4; m; m >>= 1)
      {
        if (m)
        {
          ++v77;
          double v41 = v41 * __bigtens_D2A[v81];
        }
        ++v81;
      }
    }
  }
  else
  {
    double v34 = __tens_D2A[v67 & 0xF];
    int v71 = v67 >> 4;
    if (((v67 >> 4) & 0x10) != 0)
    {
      int v71 = (v67 >> 4) & 0xF;
      double v41 = v41 / 1.0e256;
      int v77 = 3;
    }
    while (v71)
    {
      if (v71)
      {
        ++v77;
        double v34 = v34 * __bigtens_D2A[v81];
      }
      v71 >>= 1;
      ++v81;
    }
    double v41 = v41 / v34;
  }
  if (v65 && v41 < 1.0 && v76 >= 1)
  {
    if (v74 <= 0) {
      goto LABEL_96;
    }
    int v76 = v74;
    --v67;
    double v41 = v41 * 10.0;
    ++v77;
  }
  double v36 = (double)v77 * v41 + 7.0;
  HIDWORD(v36) -= 54525952;
  if (!v76)
  {
    int v48 = 0;
    long long v47 = 0;
    double v42 = v41 + -5.0;
    if (v42 > v36) {
      goto LABEL_178;
    }
    if (v42 < -v36)
    {
LABEL_177:
      int v67 = ~v98;
      goto LABEL_244;
    }
    goto LABEL_96;
  }
  if (v64)
  {
    double v37 = 0.5 / __tens_D2A[v76 - 1] - v36;
    int v82 = 0;
    while (1)
    {
      int v55 = (int)v41;
      double v43 = v41 - (double)(int)v41;
      unint64_t v9 = v32++;
      *unint64_t v9 = v55 + 48;
      if (v43 < v37) {
        goto LABEL_249;
      }
      if (1.0 - v43 < v37) {
        goto LABEL_119;
      }
      if (++v82 >= v76) {
        goto LABEL_96;
      }
      double v37 = v37 * 10.0;
      double v41 = v43 * 10.0;
    }
  }
  double v38 = v36 * __tens_D2A[v76 - 1];
  for (int n = 1; ; ++n)
  {
    int v56 = (int)v41;
    double v44 = v41 - (double)(int)v41;
    if (v44 == 0.0) {
      int v76 = n;
    }
    unint64_t v10 = v32++;
    *unint64_t v10 = v56 + 48;
    if (n == v76) {
      break;
    }
    double v41 = v44 * 10.0;
  }
  if (v44 > v38 + 0.5)
  {
LABEL_119:
    while (*--v32 == 57)
    {
      if (v32 == (unsigned char *)v8)
      {
        ++v67;
        unsigned char *v32 = 48;
        break;
      }
    }
    unint64_t v12 = v32++;
    ++*v12;
    goto LABEL_249;
  }
  if (v44 >= 0.5 - v38)
  {
LABEL_96:
    int v32 = v8;
    double v41 = v40;
    int v67 = v66;
    int v76 = v75;
    goto LABEL_97;
  }
  do
    --v32;
  while (*v32 == 48);
  ++v32;
LABEL_249:
  __Bfree_D2A(v53);
  unsigned char *v32 = 0;
  _DWORD *v97 = v67 + 1;
  if (v95) {
    void *v95 = v32;
  }
  return v31;
}

_DWORD *__gdtoa(int *a1, int a2, _DWORD *a3, unsigned int *a4, int a5, int a6, _DWORD *a7, void *a8)
{
  int v99 = a1;
  int v98 = a2;
  v97 = a3;
  v96 = a4;
  int v95 = a5;
  int v94 = a6;
  int v93 = a7;
  int v92 = a8;
  int v91 = 0;
  int v90 = 0;
  int v89 = 0;
  int v88 = 0;
  int v87 = 0;
  int i = 0;
  int v53 = 0;
  int v81 = 0;
  unsigned int v8 = *a4 & 0xFFFFFFCF;
  *a4 = v8;
  char v71 = v8;
  uint64_t v9 = v8 & 7;
  if (v9)
  {
    uint64_t v11 = v9;
    char v10 = 1;
  }
  else
  {
    uint64_t v11 = v9;
    char v10 = 0;
  }
  if (v10) {
    return 0;
  }
  switch(v11)
  {
    case 0:
      goto LABEL_13;
    case 1:
    case 2:
      int v66 = *v99;
      int v56 = (int *)bitstob(v97, *v99, &v91);
      int v88 = v98;
      int i = __trailz_D2A((uint64_t)v56);
      if (i)
      {
        __rshift_D2A((uint64_t)v56, i);
        v98 += i;
        v91 -= i;
      }
      if (v56[5])
      {
        double v12 = __b2d_D2A((uint64_t)v56, &i);
        LODWORD(v39) = LODWORD(v12);
        int i = v98 + v91 - 1;
        HIDWORD(v39) = HIDWORD(v12) & 0xFFFFF | 0x3FF00000;
        double v46 = (v39 - 1.5) * 0.289529655 + 0.176091259 + (double)i * 0.301029996;
        int v75 = i;
        if (i < 0) {
          int v75 = 1 - (v98 + v91);
        }
        int v76 = v75 - 1077;
        if (v76 > 0) {
          double v46 = v46 + (double)v76 * 7.0e-17;
        }
        int v73 = (int)v46;
        if (v46 < 0.0 && v46 != (double)v73) {
          --v73;
        }
        int v72 = 1;
        HIDWORD(v39) += (v98 + v91 - 1) << 20;
        if (v73 <= 0x16)
        {
          if (v39 < __tens_D2A[v73]) {
            --v73;
          }
          int v72 = 0;
        }
        if (v91 - i - 1 < 0)
        {
          int v90 = 1 - (v91 - i);
          int v63 = 0;
        }
        else
        {
          int v90 = 0;
          int v63 = v91 - i - 1;
        }
        if (v73 < 0)
        {
          v90 -= v73;
          int v89 = -v73;
          int v62 = 0;
        }
        else
        {
          int v89 = 0;
          int v62 = v73;
          v63 += v73;
        }
        if (v95 >= 0xA) {
          int v95 = 0;
        }
        int v60 = 1;
        if (v95 > 5)
        {
          v95 -= 4;
          int v60 = 0;
        }
        int v70 = 1;
        int v82 = -1;
        int v84 = -1;
        if (v95)
        {
          uint64_t v14 = v95;
          char v13 = 1;
        }
        else
        {
          uint64_t v14 = 0;
          char v13 = 0;
        }
        if ((v13 & 1) == 0)
        {
          switch(v14)
          {
            case 0:
            case 1:
              int i = (int)((double)v66 * 0.30103) + 3;
              int v94 = 0;
              break;
            case 2:
              int v70 = 0;
              goto LABEL_42;
            case 3:
              int v70 = 0;
              goto LABEL_46;
            case 4:
LABEL_42:
              if (v94 <= 0) {
                int v94 = 1;
              }
              int i = v94;
              int v82 = v94;
              int v84 = v94;
              break;
            case 5:
LABEL_46:
              int i = v94 + v73 + 1;
              int v84 = i;
              int v82 = v94 + v73;
              if (i <= 0) {
                int i = 1;
              }
              break;
            default:
              goto LABEL_251;
          }
        }
        double v44 = __rv_alloc_D2A(i);
        double v45 = v44;
        int v65 = v99[3] - 1;
        if (v99[3] != 1)
        {
          if (v65 < 0) {
            int v65 = 2;
          }
          if ((v71 & 8) != 0) {
            int v65 = 3 - v65;
          }
        }
        if (v84 > 0xE || !v60 || v65 || v73) {
          goto LABEL_87;
        }
        int i = 0;
        double v48 = v39;
        int v83 = v84;
        int v85 = 2;
        if (v72 && v39 < 1.0 && v84 > 0)
        {
          if (v82 <= 0)
          {
LABEL_86:
            double v45 = v44;
            double v39 = v48;
            int v73 = 0;
            int v84 = v83;
LABEL_87:
            if (v98 >= 0 && v73 <= 14)
            {
              double v47 = __tens_D2A[v73];
              if (v94 < 0 && v84 <= 0)
              {
                int v51 = 0;
                v49 = 0;
                if (v84 < 0 || v39 <= 5.0 * v47) {
                  goto LABEL_161;
                }
LABEL_162:
                int v81 = 32;
                uint64_t v19 = v45++;
                *uint64_t v19 = 49;
                ++v73;
                goto LABEL_242;
              }
              int i = 1;
              while (1)
              {
                int v59 = (int)(v39 / v47);
                double v42 = v39 - (double)v59 * v47;
                uint64_t v17 = v45++;
                *uint64_t v17 = v59 + 48;
                if (v42 == 0.0) {
                  goto LABEL_247;
                }
                if (i == v84) {
                  break;
                }
                ++i;
                double v39 = v42 * 10.0;
              }
              if (v65)
              {
                if (v65 != 1)
                {
                  int v81 = 16;
                  goto LABEL_247;
                }
                goto LABEL_104;
              }
              double v43 = v42 + v42;
              if (v43 > v47 || v43 == v47 && (v59 & 1) != 0)
              {
LABEL_104:
                int v81 = 32;
                do
                {
                  if (*--v45 != 57) {
                    goto LABEL_109;
                  }
                }
                while (v45 != (unsigned char *)v44);
                ++v73;
                *double v45 = 48;
LABEL_109:
                int v18 = v45++;
                ++*v18;
                goto LABEL_247;
              }
              int v81 = 16;
              do
LABEL_111:
                --v45;
              while (*v45 == 48);
              ++v45;
              goto LABEL_247;
            }
            int v68 = v90;
            int v67 = v89;
            int v53 = 0;
            int v51 = 0;
            if (v70)
            {
              if (v95 >= 2)
              {
                int v77 = v84 - 1;
                if (v89 < v84 - 1)
                {
                  int v78 = v77 - v89;
                  v62 += v78;
                  v89 += v78;
                  int v67 = 0;
                }
                else
                {
                  int v67 = v89 - v77;
                }
                int i = v84;
                if (v84 < 0)
                {
                  int v68 = v90 - i;
                  int i = 0;
                }
              }
              else
              {
                int i = v66 - v91 + 1;
                if (v98 - (v66 - v91) < v99[1]) {
                  int i = v98 - v99[1] + 1;
                }
              }
              v90 += i;
              v63 += i;
              int v51 = (int *)__i2b_D2A(1);
            }
            if (v68 > 0 && v63 > 0)
            {
              if (v68 >= v63) {
                int v35 = v63;
              }
              else {
                int v35 = v68;
              }
              int i = v35;
              v90 -= v35;
              v68 -= v35;
              v63 -= v35;
            }
            if (v89 > 0)
            {
              if (v70)
              {
                if (v67 > 0)
                {
                  int v51 = __pow5mult_D2A(v51, v67);
                  uint64_t v55 = __mult_D2A(v51, v56);
                  __Bfree_D2A(v56);
                  int v56 = (int *)v55;
                }
                if (v89 != v67) {
                  int v56 = __pow5mult_D2A(v56, v89 - v67);
                }
              }
              else
              {
                int v56 = __pow5mult_D2A(v56, v89);
              }
            }
            v49 = (int *)__i2b_D2A(1);
            if (v62 > 0) {
              v49 = __pow5mult_D2A(v49, v62);
            }
            int v61 = 0;
            if (v95 < 2 && v91 == 1 && v88 > v99[1] + 1)
            {
              ++v90;
              ++v63;
              int v61 = 1;
            }
            if (v62) {
              char v34 = __hi0bits_D2A(v49[v49[5] + 5]);
            }
            else {
              char v34 = 31;
            }
            int i = (v34 - (_BYTE)v63 - 4) & 0x1F;
            int v69 = v68 + i;
            v90 += i;
            if (v90 > 0) {
              int v56 = (int *)__lshift_D2A(v56, v90);
            }
            int v64 = v63 + i;
            if (v64 > 0) {
              v49 = (int *)__lshift_D2A(v49, v64);
            }
            if (v72 && (int)__cmp_D2A((uint64_t)v56, (uint64_t)v49) < 0)
            {
              --v73;
              int v56 = __multadd_D2A(v56, 10, 0);
              if (v70) {
                int v51 = __multadd_D2A(v51, 10, 0);
              }
              int v84 = v82;
            }
            if (v84 <= 0 && v95 > 2)
            {
              if (v84 < 0) {
                goto LABEL_161;
              }
              v49 = __multadd_D2A(v49, 5, 0);
              if ((int)__cmp_D2A((uint64_t)v56, (uint64_t)v49) <= 0) {
                goto LABEL_161;
              }
              goto LABEL_162;
            }
            if (v70)
            {
              if (v69 > 0) {
                int v51 = (int *)__lshift_D2A(v51, v69);
              }
              int v53 = v51;
              if (v61)
              {
                uint64_t v52 = (int *)__Balloc_D2A(v51[2]);
                memcpy(v52 + 4, v53 + 4, 4 * v53[5] + 8);
                int v51 = (int *)__lshift_D2A(v52, 1);
              }
              for (int i = 1; ; ++i)
              {
                int v87 = __quorem_D2A((uint64_t)v56, (uint64_t)v49) + 48;
                int v79 = __cmp_D2A((uint64_t)v56, (uint64_t)v53);
                int v54 = (int *)__diff_D2A((uint64_t)v49, (uint64_t)v51);
                if (v54[4]) {
                  int v33 = 1;
                }
                else {
                  int v33 = __cmp_D2A((uint64_t)v56, (uint64_t)v54);
                }
                __Bfree_D2A(v54);
                if (!v33 && !v95 && (*v97 & 1) == 0 && !v65)
                {
                  if (v87 == 57) {
                    goto LABEL_212;
                  }
                  if (v79 > 0)
                  {
                    ++v87;
                    int v81 = 32;
                  }
                  else if (v56[5] > 1 || v56[6])
                  {
                    int v81 = 16;
                  }
                  unsigned int v20 = v45++;
                  unsigned char *v20 = v87;
                  goto LABEL_242;
                }
                if (v79 < 0 || !v79 && !v95 && (*v97 & 1) == 0) {
                  break;
                }
                if (v33 > 0 && v65 != 2)
                {
                  if (v87 == 57) {
                    goto LABEL_212;
                  }
                  int v81 = 32;
                  int v26 = v45++;
                  *int v26 = v87 + 1;
                  goto LABEL_242;
                }
                int v27 = v45++;
                *int v27 = v87;
                if (i == v84) {
                  goto LABEL_222;
                }
                int v56 = __multadd_D2A(v56, 10, 0);
                if (v53 == v51)
                {
                  int v51 = __multadd_D2A(v51, 10, 0);
                  int v53 = v51;
                }
                else
                {
                  int v53 = __multadd_D2A(v53, 10, 0);
                  int v51 = __multadd_D2A(v51, 10, 0);
                }
              }
              if (v65 && (v56[5] > 1 || v56[6]))
              {
                if (v65 == 2)
                {
                  int v81 = 16;
                  goto LABEL_208;
                }
                while ((int)__cmp_D2A((uint64_t)v49, (uint64_t)v51) > 0)
                {
                  int v21 = v45++;
                  *int v21 = v87;
                  v50 = __multadd_D2A(v51, 10, 0);
                  if (v53 == v51) {
                    int v53 = v50;
                  }
                  int v51 = v50;
                  int v56 = __multadd_D2A(v56, 10, 0);
                  int v87 = __quorem_D2A((uint64_t)v56, (uint64_t)v49) + 48;
                }
                int v22 = v87++;
                if (v22 != 57)
                {
                  int v81 = 32;
                  goto LABEL_208;
                }
LABEL_212:
                int v25 = v45++;
                *int v25 = 57;
LABEL_231:
                int v81 = 32;
                do
                {
                  if (*--v45 != 57)
                  {
                    uint64_t v31 = v45++;
                    ++*v31;
                    goto LABEL_242;
                  }
                }
                while (v45 != (unsigned char *)v44);
                ++v73;
                signed int v30 = v45++;
                *signed int v30 = 49;
              }
              else
              {
                if (v33 > 0)
                {
                  int v56 = (int *)__lshift_D2A(v56, 1);
                  int v74 = __cmp_D2A((uint64_t)v56, (uint64_t)v49);
                  if (v74 > 0 || !v74 && (v87 & 1) != 0)
                  {
                    int v23 = v87++;
                    if (v23 == 57) {
                      goto LABEL_212;
                    }
                  }
                  int v81 = 32;
                }
                if (v56[5] > 1 || v56[6]) {
                  int v81 = 16;
                }
LABEL_208:
                int v24 = v45++;
                *int v24 = v87;
              }
            }
            else
            {
              for (int i = 1; ; ++i)
              {
                int v28 = __quorem_D2A((uint64_t)v56, (uint64_t)v49);
                int v87 = v28 + 48;
                unsigned int v29 = v45++;
                *unsigned int v29 = v28 + 48;
                if (i >= v84) {
                  break;
                }
                int v56 = __multadd_D2A(v56, 10, 0);
              }
LABEL_222:
              if (v65)
              {
                if (v65 != 2 && (v56[5] > 1 || v56[6])) {
                  goto LABEL_231;
                }
              }
              else
              {
                int v56 = (int *)__lshift_D2A(v56, 1);
                int v80 = __cmp_D2A((uint64_t)v56, (uint64_t)v49);
                if (v80 > 0 || !v80 && (v87 & 1) != 0) {
                  goto LABEL_231;
                }
              }
              if (v56[5] > 1 || v56[6]) {
                int v81 = 16;
              }
              do
                --v45;
              while (*v45 == 48);
              ++v45;
            }
LABEL_242:
            __Bfree_D2A(v49);
            if (v51)
            {
              if (v53 && v53 != v51) {
                __Bfree_D2A(v53);
              }
              __Bfree_D2A(v51);
            }
LABEL_247:
            __Bfree_D2A(v56);
            *double v45 = 0;
            *int v93 = v73 + 1;
            if (v92) {
              *int v92 = v45;
            }
            *v96 |= v81;
            return v44;
          }
          int v84 = v82;
          int v73 = -1;
          double v39 = v39 * 10.0;
          int v85 = 3;
        }
        double v36 = (double)v85 * v39 + 7.0;
        HIDWORD(v36) -= 54525952;
        if (v84)
        {
          if (v70)
          {
            double v37 = 1.0 * 0.5 / __tens_D2A[v84 - 1] - v36;
            int i = 0;
            while (1)
            {
              int v57 = (int)(v39 / 1.0);
              double v41 = v39 - (double)v57 * 1.0;
              int v15 = v45++;
              *int v15 = v57 + 48;
              if (v41 < v37) {
                break;
              }
              if (1.0 - v41 < v37) {
                goto LABEL_104;
              }
              if (++i >= v84) {
                goto LABEL_86;
              }
              double v37 = v37 * 10.0;
              double v39 = v41 * 10.0;
            }
            if (v41 != 0.0) {
              int v81 = 16;
            }
            goto LABEL_247;
          }
          double v38 = v36 * __tens_D2A[v84 - 1];
          int i = 1;
          while (1)
          {
            int v58 = (int)(v39 / 1.0);
            if (v58) {
              double v39 = v39 - (double)v58 * 1.0;
            }
            uint64_t v16 = v45++;
            *uint64_t v16 = v58 + 48;
            if (i == v84) {
              break;
            }
            ++i;
            double v39 = v39 * 10.0;
          }
          if (v39 > 1.0 * 0.5 + v38) {
            goto LABEL_104;
          }
          if (v39 < 1.0 * 0.5 - v38)
          {
            if (v39 != 0.0) {
              int v81 = 16;
            }
            goto LABEL_111;
          }
        }
        else
        {
          int v51 = 0;
          v49 = 0;
          double v40 = v39 - 5.0;
          if (v40 > v36) {
            goto LABEL_162;
          }
          if (v40 < -v36)
          {
LABEL_161:
            int v73 = -1 - v94;
            int v81 = 16;
            goto LABEL_242;
          }
        }
        goto LABEL_86;
      }
      __Bfree_D2A(v56);
LABEL_13:
      *int v93 = 1;
      return __nrv_alloc_D2A("0", v92, 1);
    case 3:
      *int v93 = -32768;
      return __nrv_alloc_D2A("Infinity", v92, 8);
    case 4:
      *int v93 = -32768;
      return __nrv_alloc_D2A("NaN", v92, 3);
    default:
LABEL_251:
      JUMPOUT(0);
  }
}

uint64_t bitstob(_DWORD *a1, int a2, _DWORD *a3)
{
  int v10 = 32;
  int v9 = 0;
  while (v10 < a2)
  {
    v10 *= 2;
    ++v9;
  }
  uint64_t v8 = __Balloc_D2A(v9);
  double v7 = &a1[(a2 - 1) >> 5];
  uint64_t v5 = v8 + 24;
  unint64_t v6 = (_DWORD *)(v8 + 24);
  do
  {
    int v3 = v6++;
    *int v3 = *a1++;
  }
  while (a1 <= v7);
  int v11 = ((uint64_t)v6 - v5) / 4;
  while (!*(_DWORD *)(v5 + 4 * --v11))
  {
    if (!v11)
    {
      *(_DWORD *)(v8 + 20) = 0;
      *a3 = 0;
      return v8;
    }
  }
  *(_DWORD *)(v8 + 20) = v11 + 1;
  *a3 = 32 * v11 + 32 - __hi0bits_D2A(*(_DWORD *)(v8 + 24 + 4 * v11));
  return v8;
}

uint64_t __rshift_D2A(uint64_t result, int a2)
{
  int v10 = (int *)(result + 24);
  uint64_t v11 = result + 24;
  if (a2 >> 5 < *(_DWORD *)(result + 20))
  {
    unint64_t v9 = v11 + 4 * *(int *)(result + 20);
    double v12 = (int *)(v11 + 4 * (a2 >> 5));
    char v14 = a2 & 0x1F;
    if ((a2 & 0x1F) != 0)
    {
      uint64_t v2 = v12;
      char v13 = v12 + 1;
      int v8 = *v2 >> v14;
      while ((unint64_t)v13 < v9)
      {
        int v3 = v10++;
        *int v3 = v8 | (*v13 << (32 - v14));
        int v4 = v13++;
        int v8 = *v4 >> v14;
      }
      *int v10 = v8;
      if (v8) {
        ++v10;
      }
    }
    else
    {
      while ((unint64_t)v12 < v9)
      {
        uint64_t v5 = v12++;
        unint64_t v6 = v10++;
        *unint64_t v6 = *v5;
      }
    }
  }
  uint64_t v7 = ((uint64_t)v10 - result - 24) / 4;
  *(_DWORD *)(result + 20) = v7;
  if (!v7) {
    *(_DWORD *)(result + 24) = 0;
  }
  return result;
}

uint64_t __trailz_D2A(uint64_t a1)
{
  uint64_t v7 = a1;
  unsigned int v6 = 0;
  uint64_t v5 = (unsigned int *)(a1 + 24);
  unint64_t v4 = v7 + 24 + 4 * *(int *)(v7 + 20);
  for (unsigned int i = 0; ; i += 32)
  {
    BOOL v2 = 0;
    if ((unint64_t)v5 < v4) {
      BOOL v2 = *v5 == 0;
    }
    if (!v2) {
      break;
    }
    ++v5;
  }
  if ((unint64_t)v5 < v4)
  {
    unsigned int v6 = *v5;
    i += __lo0bits_D2A(&v6);
  }
  return i;
}

uint64_t __Balloc_D2A(int a1)
{
  if (gdtoa_tsd_key == -1)
  {
    pthread_mutex_lock(&gdtoa_tsd_lock);
    if (gdtoa_tsd_key == -1)
    {
      gdtoa_tsd_key = 14;
      pthread_key_init_np();
    }
    pthread_mutex_unlock(&gdtoa_tsd_lock);
  }
  stat __b = pthread_getspecific(gdtoa_tsd_key);
  if (!__b)
  {
    stat __b = (void *)malloc_type_malloc();
    memset(__b, 0, 0x50uLL);
    pthread_setspecific(gdtoa_tsd_key, __b);
  }
  if (a1 <= 9 && (uint64_t v3 = *((void *)__b + a1)) != 0)
  {
    *((void *)__b + a1) = *(void *)v3;
  }
  else
  {
    uint64_t v3 = malloc_type_malloc();
    *(_DWORD *)(v3 + 8) = a1;
    *(_DWORD *)(v3 + 12) = 1 << a1;
  }
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  return v3;
}

void gdtoa_freelist_free(void **a1)
{
  int v1 = a1;
  if (a1)
  {
    for (int i = 0; i < 10; ++i)
    {
      if (*v1)
      {
        for (int j = *v1; j; int j = v2)
        {
          BOOL v2 = (void *)*j;
          free(j);
        }
      }
      ++v1;
    }
    free(a1);
  }
}

void __Bfree_D2A(int *a1)
{
  if (a1)
  {
    if (a1[2] <= 9)
    {
      int v1 = pthread_getspecific(gdtoa_tsd_key);
      *(void *)a1 = v1[a1[2]];
      v1[a1[2]] = a1;
    }
    else
    {
      free(a1);
    }
  }
}

uint64_t __lo0bits_D2A(unsigned int *a1)
{
  unsigned int v2 = *a1;
  if ((*a1 & 7) != 0)
  {
    if (v2)
    {
      return 0;
    }
    else if ((v2 & 2) != 0)
    {
      *a1 = v2 >> 1;
      return 1;
    }
    else
    {
      *a1 = v2 >> 2;
      return 2;
    }
  }
  else
  {
    unsigned int v3 = 0;
    if (!(_WORD)v2)
    {
      unsigned int v3 = 16;
      v2 >>= 16;
    }
    if (!(_BYTE)v2)
    {
      v3 += 8;
      v2 >>= 8;
    }
    if ((v2 & 0xF) == 0)
    {
      v3 += 4;
      v2 >>= 4;
    }
    if ((v2 & 3) == 0)
    {
      v3 += 2;
      v2 >>= 2;
    }
    if ((v2 & 1) != 0 || (++v3, (v2 >>= 1) != 0))
    {
      *a1 = v2;
      return v3;
    }
    else
    {
      return 32;
    }
  }
}

int *__multadd_D2A(_DWORD *a1, int a2, int a3)
{
  uint64_t v11 = a1;
  int v9 = a1[5];
  int v8 = a1 + 6;
  int v10 = 0;
  unint64_t v7 = a3;
  do
  {
    unint64_t v6 = *v8 * (uint64_t)a2 + v7;
    unint64_t v7 = HIDWORD(v6);
    unsigned int v3 = v8++;
    *unsigned int v3 = v6;
    ++v10;
  }
  while (v10 < v9);
  if (v7)
  {
    if (v9 >= a1[3])
    {
      uint64_t v5 = __Balloc_D2A(a1[2] + 1);
      memcpy((void *)(v5 + 16), v11 + 4, 4 * v11[5] + 8);
      __Bfree_D2A(v11);
      uint64_t v11 = (int *)v5;
    }
    v11[v9 + 6] = HIDWORD(v6);
    v11[5] = v9 + 1;
  }
  return v11;
}

uint64_t __hi0bits_D2A(int a1)
{
  int v3 = a1;
  unsigned int v2 = 0;
  if ((a1 & 0xFFFF0000) == 0)
  {
    unsigned int v2 = 16;
    int v3 = a1 << 16;
  }
  if ((v3 & 0xFF000000) == 0)
  {
    v2 += 8;
    v3 <<= 8;
  }
  if ((v3 & 0xF0000000) == 0)
  {
    v2 += 4;
    v3 *= 16;
  }
  if ((v3 & 0xC0000000) == 0)
  {
    v2 += 2;
    v3 *= 4;
  }
  if (v3 < 0) {
    return v2;
  }
  ++v2;
  if ((v3 & 0x40000000) != 0) {
    return v2;
  }
  else {
    return 32;
  }
}

uint64_t __i2b_D2A(int a1)
{
  uint64_t result = __Balloc_D2A(1);
  *(_DWORD *)(result + 24) = a1;
  *(_DWORD *)(result + 20) = 1;
  return result;
}

uint64_t __mult_D2A(_DWORD *a1, _DWORD *a2)
{
  int v22 = a1;
  int v21 = a2;
  if (a1[5] < a2[5])
  {
    int v22 = a2;
    int v21 = a1;
  }
  int v19 = v22[2];
  int v18 = v22[5];
  int v17 = v21[5];
  int v16 = v18 + v17;
  if (v18 + v17 > v22[3]) {
    ++v19;
  }
  uint64_t v20 = __Balloc_D2A(v19);
  for (int i = (_DWORD *)(v20 + 24); (unint64_t)i < v20 + 24 + 4 * v16; ++i)
    *int i = 0;
  unint64_t v13 = (unint64_t)(v21 + 6);
  int v10 = (_DWORD *)(v20 + 24);
  while (v13 < (unint64_t)&v21[v17 + 6])
  {
    unsigned int v2 = (unsigned int *)v13;
    v13 += 4;
    unsigned int v9 = *v2;
    if (*v2)
    {
      unint64_t v15 = (unint64_t)(v22 + 6);
      uint64_t v11 = v10;
      unint64_t v8 = 0;
      do
      {
        int v3 = (unsigned int *)v15;
        v15 += 4;
        unint64_t v7 = *v3 * (unint64_t)v9 + *v11 + v8;
        unint64_t v8 = HIDWORD(v7);
        unint64_t v4 = v11++;
        *unint64_t v4 = v7;
      }
      while (v15 < (unint64_t)&v22[v18 + 6]);
      *uint64_t v11 = HIDWORD(v7);
    }
    ++v10;
  }
  double v12 = (_DWORD *)(v20 + 24 + 4 * v16);
  while (1)
  {
    BOOL v6 = 0;
    if (v16 > 0) {
      BOOL v6 = *--v12 == 0;
    }
    if (!v6) {
      break;
    }
    --v16;
  }
  *(_DWORD *)(v20 + 20) = v16;
  return v20;
}

int *__pow5mult_D2A(int *a1, int a2)
{
  unsigned int v9 = a1;
  if ((a2 & 3) != 0) {
    unsigned int v9 = __multadd_D2A(a1, __pow5mult_D2A_p05[(a2 & 3) - 1], 0);
  }
  int v8 = a2 >> 2;
  if (!v8) {
    return v9;
  }
  uint64_t v5 = (_DWORD *)p5s;
  if (!p5s)
  {
    os_unfair_lock_lock(&stru_F544C);
    uint64_t v5 = (_DWORD *)p5s;
    if (!p5s)
    {
      p5s = __i2b_D2A(625);
      uint64_t v5 = (_DWORD *)p5s;
      *(void *)p5s = 0;
    }
    os_unfair_lock_unlock(&stru_F544C);
  }
  while (1)
  {
    if (v8)
    {
      uint64_t v6 = __mult_D2A(v9, v5);
      __Bfree_D2A(v9);
      unsigned int v9 = (int *)v6;
    }
    v8 >>= 1;
    if (!v8) {
      break;
    }
    unint64_t v4 = *(_DWORD **)v5;
    if (!*(void *)v5)
    {
      os_unfair_lock_lock(&stru_F544C);
      unint64_t v4 = *(_DWORD **)v5;
      if (!*(void *)v5)
      {
        unsigned int v2 = (void *)__mult_D2A(v5, v5);
        *(void *)uint64_t v5 = v2;
        unint64_t v4 = v2;
        *unsigned int v2 = 0;
      }
      os_unfair_lock_unlock(&stru_F544C);
    }
    uint64_t v5 = v4;
  }
  return v9;
}

uint64_t __lshift_D2A(int *a1, int a2)
{
  char v18 = a2;
  int v14 = a2 >> 5;
  int v15 = a1[2];
  int v13 = (a2 >> 5) + a1[5] + 1;
  for (int i = a1[3]; v13 > i; i *= 2)
    ++v15;
  uint64_t v12 = __Balloc_D2A(v15);
  int v10 = (int *)(v12 + 24);
  for (int j = 0; j < v14; ++j)
  {
    unsigned int v2 = v10++;
    *unsigned int v2 = 0;
  }
  uint64_t v11 = a1 + 6;
  unint64_t v9 = (unint64_t)&a1[a1[5] + 6];
  char v19 = v18 & 0x1F;
  if (v19)
  {
    int v8 = 0;
    do
    {
      int v3 = v10++;
      *int v3 = (*v11 << v19) | v8;
      unint64_t v4 = v11++;
      int v8 = *v4 >> (32 - v19);
    }
    while ((unint64_t)v11 < v9);
    *int v10 = v8;
    if (v8) {
      ++v13;
    }
  }
  else
  {
    do
    {
      uint64_t v5 = v11++;
      uint64_t v6 = v10++;
      *uint64_t v6 = *v5;
    }
    while ((unint64_t)v11 < v9);
  }
  *(_DWORD *)(v12 + 20) = v13 - 1;
  __Bfree_D2A(a1);
  return v12;
}

uint64_t __cmp_D2A(uint64_t a1, uint64_t a2)
{
  int v5 = *(_DWORD *)(a1 + 20);
  int v4 = *(_DWORD *)(a2 + 20);
  if (v5 > 1 && !*(_DWORD *)(a1 + 24 + 4 * (v5 - 1)))
  {
    fprintf(__stderrp, "%s\n", "cmp called with a->x[a->wds-1] == 0");
    exit(1);
  }
  if (v4 > 1 && !*(_DWORD *)(a2 + 24 + 4 * (v4 - 1)))
  {
    fprintf(__stderrp, "%s\n", "cmp called with b->x[b->wds-1] == 0");
    exit(1);
  }
  unsigned int v6 = v5 - v4;
  if (v6)
  {
    return v6;
  }
  else
  {
    int v8 = (_DWORD *)(a1 + 24 + 4 * v4);
    unint64_t v7 = (_DWORD *)(a2 + 24 + 4 * v4);
    while (*--v8 == *--v7)
    {
      if ((unint64_t)v8 <= a1 + 24) {
        return 0;
      }
    }
    if (*v8 < *v7) {
      return -1;
    }
    else {
      return 1;
    }
  }
}

uint64_t __diff_D2A(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = a1;
  uint64_t v21 = a2;
  uint64_t v17 = __cmp_D2A(a1, a2);
  if (v17)
  {
    if ((int)v17 >= 0)
    {
      int v18 = 0;
    }
    else
    {
      uint64_t v19 = v22;
      uint64_t v22 = v21;
      uint64_t v21 = v19;
      int v18 = 1;
    }
    uint64_t v20 = __Balloc_D2A(*(_DWORD *)(v22 + 8));
    *(_DWORD *)(v20 + 16) = v18;
    int v16 = *(_DWORD *)(v22 + 20);
    unint64_t v15 = v22 + 24;
    int v14 = (unsigned int *)(v21 + 24);
    unint64_t v13 = v21 + 24 + 4 * *(int *)(v21 + 20);
    uint64_t v12 = (_DWORD *)(v20 + 24);
    uint64_t v11 = 0;
    do
    {
      int v3 = (unsigned int *)v15;
      v15 += 4;
      int v4 = v14++;
      unint64_t v9 = *v3 - (unint64_t)*v4 - v11;
      uint64_t v11 = HIDWORD(v9) & 1;
      int v5 = v12++;
      *int v5 = v9;
    }
    while ((unint64_t)v14 < v13);
    while (v15 < v22 + 24 + 4 * v16)
    {
      unsigned int v6 = (unsigned int *)v15;
      v15 += 4;
      unint64_t v10 = *v6 - v11;
      uint64_t v11 = HIDWORD(v10) & 1;
      unint64_t v7 = v12++;
      *unint64_t v7 = v10;
    }
    while (!*--v12)
      --v16;
    *(_DWORD *)(v20 + 20) = v16;
    return v20;
  }
  else
  {
    uint64_t v2 = __Balloc_D2A(0);
    *(_DWORD *)(v2 + 20) = 1;
    *(_DWORD *)(v2 + 24) = 0;
    return v2;
  }
}

double __b2d_D2A(uint64_t a1, _DWORD *a2)
{
  unint64_t v10 = a1 + 24;
  uint64_t v11 = (_DWORD *)(a1 + 24 + 4 * *(int *)(a1 + 20) - 4);
  HIDWORD(v9) = *v11;
  if (!*v11)
  {
    fprintf(__stderrp, "%s\n", "zero y in b2d");
    exit(1);
  }
  int v7 = __hi0bits_D2A(SHIDWORD(v9));
  *a2 = 32 - v7;
  if (v7 >= 11)
  {
    if ((unint64_t)v11 <= v10) {
      unsigned int v4 = 0;
    }
    else {
      unsigned int v4 = *--v11;
    }
    LODWORD(v9) = v4;
    int v8 = v7 - 11;
    if (v8)
    {
      HIDWORD(v6) = (HIDWORD(v9) << v8) | 0x3FF00000 | (v4 >> (32 - v8));
      if ((unint64_t)v11 <= v10) {
        unsigned int v3 = 0;
      }
      else {
        unsigned int v3 = *(v11 - 1);
      }
      LODWORD(v6) = (v4 << v8) | (v3 >> (32 - v8));
    }
    else
    {
      uint64_t v6 = v9 | 0x3FF0000000000000;
    }
  }
  else
  {
    HIDWORD(v6) = (HIDWORD(v9) >> (11 - v7)) | 0x3FF00000;
    if ((unint64_t)v11 <= v10) {
      unsigned int v5 = 0;
    }
    else {
      unsigned int v5 = *(v11 - 1);
    }
    LODWORD(v6) = (HIDWORD(v9) << (v7 + 21)) | (v5 >> (11 - v7));
  }
  return *(double *)&v6;
}

uint64_t __d2b_D2A(_DWORD *a1, _DWORD *a2, double a3)
{
  double v18 = a3;
  uint64_t v17 = a1;
  int v16 = a2;
  int v13 = 0;
  int v11 = 0;
  unsigned int v9 = 0;
  double v14 = a3;
  uint64_t v15 = __Balloc_D2A(1);
  unint64_t v10 = (unsigned int *)(v15 + 24);
  unsigned int v8 = HIDWORD(v14) & 0xFFFFF;
  HIDWORD(v14) &= ~0x80000000;
  int v12 = HIDWORD(v14) >> 20;
  if (HIDWORD(v14) >> 20) {
    v8 |= 0x100000u;
  }
  unsigned int v9 = LODWORD(v14);
  if (LODWORD(v14))
  {
    int v11 = __lo0bits_D2A(&v9);
    if (v11)
    {
      *unint64_t v10 = v9 | (v8 << (32 - v11));
      v8 >>= v11;
    }
    else
    {
      *unint64_t v10 = v9;
    }
    unsigned int v3 = v8;
    v10[1] = v8;
    if (v3) {
      int v4 = 2;
    }
    else {
      int v4 = 1;
    }
    *(_DWORD *)(v15 + 20) = v4;
    int v13 = v4;
  }
  else
  {
    int v11 = __lo0bits_D2A(&v8);
    *unint64_t v10 = v8;
    *(_DWORD *)(v15 + 20) = 1;
    int v13 = 1;
    v11 += 32;
  }
  if (v12)
  {
    *uint64_t v17 = v12 - 1075 + v11;
    *int v16 = 53 - v11;
  }
  else
  {
    *uint64_t v17 = v11 - 1074;
    int v7 = 32 * v13;
    int v5 = __hi0bits_D2A(v10[v13 - 1]);
    *int v16 = v7 - v5;
  }
  return v15;
}

unsigned char *__strcp_D2A(unsigned char *a1, unsigned __int8 *a2)
{
  while (1)
  {
    uint64_t v2 = a2++;
    LODWORD(v2) = *v2;
    *a1 = (_BYTE)v2;
    if (!v2) {
      break;
    }
    ++a1;
  }
  return a1;
}

_DWORD *__s2b_D2A(uint64_t a1, int a2, int a3, int a4, int a5)
{
  int v9 = 0;
  for (int i = 1; (a3 + 8) / 9 > i; i *= 2)
    ++v9;
  int v11 = (_DWORD *)__Balloc_D2A(v9);
  v11[6] = a4;
  v11[5] = 1;
  int v10 = 9;
  if (a2 <= 9)
  {
    double v18 = (char *)(a1 + a5 + 9);
  }
  else
  {
    uint64_t v17 = (char *)(a1 + 9);
    do
    {
      int v5 = v17++;
      int v11 = __multadd_D2A(v11, 10, *v5 - 48);
      ++v10;
    }
    while (v10 < a2);
    double v18 = &v17[a5];
  }
  while (v10 < a3)
  {
    uint64_t v6 = v18++;
    int v11 = __multadd_D2A(v11, 10, *v6 - 48);
    ++v10;
  }
  return v11;
}

double __ratio_D2A(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  double v7 = 0.0;
  double v6 = 0.0;
  int v5 = 0;
  int v4 = 0;
  int v3 = 0;
  double v7 = __b2d_D2A(a1, &v4);
  double v6 = __b2d_D2A(v8, &v3);
  int v5 = v4 - v3 + 32 * (*(_DWORD *)(v9 + 20) - *(_DWORD *)(v8 + 20));
  if (v5 <= 0)
  {
    int v5 = -v5;
    HIDWORD(v6) += v5 << 20;
  }
  else
  {
    HIDWORD(v7) += v5 << 20;
  }
  return v7 / v6;
}

uint64_t __match_D2A(uint64_t *a1, unsigned char *a2)
{
  uint64_t v4 = *a1;
  while (1)
  {
    uint64_t v2 = a2++;
    if (!*v2) {
      break;
    }
    int v5 = *(char *)++v4;
    if (v5 >= 65 && v5 <= 90) {
      v5 += 32;
    }
    if (v5 != (char)*v2) {
      return 0;
    }
  }
  *a1 = v4 + 1;
  return 1;
}

unint64_t __copybits_D2A(unint64_t result, int a2, uint64_t a3)
{
  unint64_t v8 = result;
  double v7 = (_DWORD *)(a3 + 24);
  unint64_t v6 = a3 + 24 + 4 * *(int *)(a3 + 20);
  while ((unint64_t)v7 < v6)
  {
    int v3 = v7++;
    uint64_t v4 = (_DWORD *)v8;
    v8 += 4;
    *uint64_t v4 = *v3;
  }
  while (v8 < result + 4 * ((a2 - 1) >> 5) + 4)
  {
    int v5 = (_DWORD *)v8;
    v8 += 4;
    *int v5 = 0;
  }
  return result;
}

uint64_t __any_on_D2A(uint64_t a1, int a2)
{
  uint64_t v3 = a1 + 24;
  int v5 = *(_DWORD *)(a1 + 20);
  int v6 = a2 >> 5;
  if (a2 >> 5 <= v5)
  {
    if (v6 < v5
      && (a2 & 0x1F) != 0
      && *(_DWORD *)(v3 + 4 * v6) >> (a2 & 0x1F) << (a2 & 0x1F) != *(_DWORD *)(v3 + 4 * v6))
    {
      return 1;
    }
  }
  else
  {
    int v6 = *(_DWORD *)(a1 + 20);
  }
  uint64_t v4 = (_DWORD *)(v3 + 4 * v6);
  while ((unint64_t)v4 > a1 + 24)
  {
    if (*--v4) {
      return 1;
    }
  }
  return 0;
}

int *__sum_D2A(_DWORD *a1, _DWORD *a2)
{
  uint64_t v21 = a1;
  uint64_t v19 = a2;
  if (a1[5] < a2[5])
  {
    uint64_t v19 = a1;
    uint64_t v21 = a2;
  }
  double v18 = (int *)__Balloc_D2A(v21[2]);
  v18[5] = v21[5];
  unsigned int v17 = 0;
  uint64_t v15 = v21 + 6;
  double v14 = (unsigned __int16 *)(v19 + 6);
  int v16 = v18 + 6;
  unint64_t v12 = (unint64_t)&v18[v19[5] + 6];
  do
  {
    unsigned int v10 = *(unsigned __int16 *)v15 + *v14 + v17;
    uint64_t v2 = v15++;
    unsigned int v3 = *v2;
    uint64_t v4 = v14;
    v14 += 2;
    unsigned int v8 = HIWORD(*v4) + HIWORD(v3) + ((v10 & 0x10000) >> 16);
    unsigned int v17 = (v8 & 0x10000) >> 16;
    v16[1] = v8;
    *int v16 = v10;
    v16 += 2;
  }
  while ((unint64_t)v16 < v12);
  unint64_t v13 = v12 + 4 * (v21[5] - v19[5]);
  while ((unint64_t)v16 < v13)
  {
    unsigned int v11 = *(unsigned __int16 *)v15 + v17;
    int v5 = v15++;
    unsigned int v9 = ((v11 & 0x10000) >> 16) + HIWORD(*v5);
    unsigned int v17 = (v9 & 0x10000) >> 16;
    v16[1] = v9;
    *int v16 = v11;
    v16 += 2;
  }
  if (v17)
  {
    if (v18[5] == v18[3])
    {
      uint64_t v20 = __Balloc_D2A(v18[2] + 1);
      memcpy((void *)(v20 + 16), v18 + 4, 4 * v18[5] + 8);
      __Bfree_D2A(v18);
      double v18 = (int *)v20;
    }
    uint64_t v6 = v18[5]++;
    v18[v6 + 6] = 1;
  }
  return v18;
}

double __ulp_D2A(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 4) & 0x7FF00000) - 54525952 <= 0)
  {
    int v4 = (54525952 - (*(_DWORD *)(a1 + 4) & 0x7FF00000)) >> 20;
    if (v4 >= 20)
    {
      HIDWORD(v3) = 0;
      int v5 = v4 - 20;
      if (v5 < 31) {
        int v2 = 1 << (31 - v5);
      }
      else {
        int v2 = 1;
      }
      LODWORD(v3) = v2;
    }
    else
    {
      HIDWORD(v3) = 0x80000 >> v4;
      LODWORD(v3) = 0;
    }
  }
  else
  {
    HIDWORD(v3) = (*(_DWORD *)(a1 + 4) & 0x7FF00000) - 54525952;
    LODWORD(v3) = 0;
  }
  return v3;
}

unsigned int alarm(unsigned int a1)
{
  unsigned int v4 = a1;
  memset(&v3, 0, sizeof(v3));
  memset(&v2, 0, sizeof(v2));
  v3.it_interval.tv_usec = 0;
  v3.it_interval.tv_sec = 0;
  v3.it_value.tv_sec = a1;
  v3.it_value.tv_usec = 0;
  if (setitimer(0, &v3, &v2) < 0) {
    return -1;
  }
  if (v2.it_value.tv_usec) {
    ++v2.it_value.tv_sec;
  }
  return v2.it_value.tv_sec;
}

uint32_t arc4random(void)
{
  __unint64_t buf = 0;
  arc4random_buf(&__buf, 4uLL);
  return __buf;
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

void arc4_init()
{
  if (!rng)
  {
    rng = ccrng();
    if (!rng)
    {
      _os_crash((uint64_t)"arc4random: unable to get ccrng() handle");
      __break(1u);
      JUMPOUT(0x39600);
    }
  }
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return 0;
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  if (a1 && *a1)
  {
    for (int i = &a1[strlen(a1) - 1]; ; --i)
    {
      BOOL v4 = 0;
      if (i > a1) {
        BOOL v4 = *i == 47;
      }
      if (!v4) {
        break;
      }
    }
    if (i == a1 && *i == 47)
    {
      *a2 = 47;
      a2[1] = 0;
      return a2;
    }
    else
    {
      for (uint64_t __src = i; ; --__src)
      {
        BOOL v3 = 0;
        if (__src > a1) {
          BOOL v3 = *(__src - 1) != 47;
        }
        if (!v3) {
          break;
        }
      }
      __int n = i - __src + 1;
      if (__n < 0x400)
      {
        memcpy(a2, __src, __n);
        a2[__n] = 0;
        return a2;
      }
      else
      {
        *__error() = 63;
        return 0;
      }
    }
  }
  else
  {
    *a2 = 46;
    a2[1] = 0;
    return a2;
  }
}

char *__cdecl basename(char *a1)
{
  if (basename_bname) {
    return basename_r(a1, (char *)basename_bname);
  }
  basename_bname = malloc_type_malloc();
  if (basename_bname) {
    return basename_r(a1, (char *)basename_bname);
  }
  else {
    return 0;
  }
}

clock_t clock(void)
{
  memset(&__b, 0, sizeof(__b));
  if (getrusage(0, &__b)) {
    return -1;
  }
  else {
    return 1000000 * __b.ru_utime.tv_sec + __b.ru_utime.tv_usec + 1000000 * __b.ru_stime.tv_sec + __b.ru_stime.tv_usec;
  }
}

int closedir(DIR *a1)
{
  return close_NOCANCEL();
}

uint64_t _fdclosedir(uint64_t a1)
{
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
  unsigned int v2 = *(_DWORD *)a1;
  *(_DWORD *)a1 = -1;
  *(void *)(a1 + 8) = 0;
  free(*(void **)(a1 + 24));
  _reclaim_telldir(a1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 64));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 64));
  free((void *)a1);
  return v2;
}

char *__cdecl ctermid(char *a1)
{
  if (!a1) {
    return ctermid_def;
  }
  bcopy(ctermid_def, a1, 9uLL);
  return a1;
}

char *__cdecl ctermid_r(char *a1)
{
  if (a1) {
    return ctermid(a1);
  }
  else {
    return 0;
  }
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  if (a1 && *a1)
  {
    for (int i = &a1[strlen(a1) - 1]; ; --i)
    {
      BOOL v6 = 0;
      if (i > a1) {
        BOOL v6 = *i == 47;
      }
      if (!v6) {
        break;
      }
    }
    while (1)
    {
      BOOL v5 = 0;
      if (i > a1) {
        BOOL v5 = *i != 47;
      }
      if (!v5) {
        break;
      }
      --i;
    }
    if (i == a1)
    {
      if (*i == 47) {
        char v2 = 47;
      }
      else {
        char v2 = 46;
      }
      *a2 = v2;
      a2[1] = 0;
      return a2;
    }
    else
    {
      do
      {
        --i;
        BOOL v4 = 0;
        if (i > a1) {
          BOOL v4 = *i == 47;
        }
      }
      while (v4);
      __leint n = i - a1 + 1;
      if (__len < 0x400)
      {
        memmove(a2, a1, __len);
        a2[__len] = 0;
        return a2;
      }
      else
      {
        *__error() = 63;
        return 0;
      }
    }
  }
  else
  {
    *a2 = 46;
    a2[1] = 0;
    return a2;
  }
}

char *__cdecl dirname(char *a1)
{
  if (dirname_dname) {
    return dirname_r(a1, (char *)dirname_dname);
  }
  dirname_dname = malloc_type_malloc();
  if (dirname_dname) {
    return dirname_r(a1, (char *)dirname_dname);
  }
  else {
    return 0;
  }
}

double drand48(void)
{
  _rand48_seed = _rand48_seed * _rand48_mult + _rand48_add;
  if ((_rand48_seed & 0xFFFFFFFFFFFFLL) == 0) {
    return 0.0;
  }
  uint64_t v2 = 32 * (_rand48_seed & 0xFFFFFFFFFFFFLL);
  int v1 = 0;
  while ((v2 & 0x10000000000000) == 0)
  {
    ++v1;
    v2 *= 2;
  }
  *(void *)&double v3 = v2 & 0x800FFFFFFFFFFFFFLL | (((1022 - v1) & 0x7FFLL) << 52);
  return v3;
}

double erand48(unsigned __int16 a1[3])
{
  unint64_t v4 = (*a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32)) * _rand48_mult + _rand48_add;
  *(_DWORD *)a1 = (*a1 + (a1[1] << 16)) * _rand48_mult + _rand48_add;
  a1[2] = WORD2(v4);
  if ((v4 & 0xFFFFFFFFFFFFLL) == 0) {
    return 0.0;
  }
  uint64_t v3 = 32 * (v4 & 0xFFFFFFFFFFFFLL);
  int v2 = 0;
  while ((v3 & 0x10000000000000) == 0)
  {
    ++v2;
    v3 *= 2;
  }
  *(void *)&double v5 = v3 & 0x800FFFFFFFFFFFFFLL | (((1022 - v2) & 0x7FFLL) << 52);
  return v5;
}

void _e_visprintf(FILE *a1, const char *a2, va_list a3)
{
  unint64_t v13 = a1;
  unint64_t v12 = a2;
  va_list v11 = a3;
  int v10 = 0;
  unsigned int v9 = 0;
  vasprintf(&v9, a2, a3);
  if (v9)
  {
    strlen(v9);
    unsigned int v8 = (char *)malloc_type_malloc();
    if (v8)
    {
      BOOL v6 = v9;
      double v5 = v8;
      while (*v6)
      {
        if (escape[*v6])
        {
          if (escape[*v6] == 255)
          {
            sprintf(v5, "\\%03o", *v6);
            v5 += 4;
          }
          else
          {
            *double v5 = 92;
            unint64_t v4 = v5 + 1;
            v5 += 2;
            *unint64_t v4 = escape[*v6];
          }
        }
        else
        {
          uint64_t v3 = v5++;
          *uint64_t v3 = *v6;
        }
        ++v6;
      }
      *double v5 = 0;
      fputs(v8, v13);
      free(v8);
    }
    else
    {
      int v10 = 1;
    }
    free(v9);
  }
  else
  {
    int v10 = 1;
  }
  if (v10) {
    vfprintf(v13, v12, a3);
  }
}

void err_set_file(void *a1)
{
  if (a1) {
    _e_err_file = (uint64_t)a1;
  }
  else {
    _e_err_file = (uint64_t)__stderrp;
  }
}

void err_set_exit(void (__cdecl *a1)(int))
{
  if (_e_err_exit == 1)
  {
    _Block_release(off_F5460);
    off_F5460 = 0;
  }
  if (a1) {
    int v1 = 2;
  }
  else {
    int v1 = 0;
  }
  _e_err_exit = v1;
  off_F5460 = (uint64_t (*)(void))a1;
}

void err_set_exit_b(void *a1)
{
  if (_e_err_exit == 1) {
    _Block_release(off_F5460);
  }
  _e_err_exit = a1 != 0;
  off_F5460 = (uint64_t (*)(void))_Block_copy(a1);
}

int execl(const char *__path, const char *__arg0, ...)
{
  va_start(va, __arg0);
  int v16 = __path;
  uint64_t v15 = __arg0;
  unint64_t v13 = 0;
  va_copy(v14, va);
  for (int i = 1; ; ++i)
  {
    int v2 = *(char **)v14;
    v14 += 8;
    va_list v11 = v2;
    if (!v2) {
      break;
    }
  }
  unsigned int v9 = (char *)&v6 - ((8 * (i + 1) + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v9, 8 * (i + 1));
  unint64_t v13 = (char **)v9;
  if (v9)
  {
    va_copy(v14, va);
    int i = 1;
    *unint64_t v13 = (char *)v15;
    while (1)
    {
      uint64_t v3 = *(char **)v14;
      v14 += 8;
      int v10 = v3;
      v13[i] = v3;
      if (!v3) {
        break;
      }
      ++i;
    }
    unsigned int v8 = v16;
    double v7 = v13;
    unint64_t v4 = _NSGetEnviron();
    return execve(v8, v7, *v4);
  }
  else
  {
    *__error() = 12;
    return -1;
  }
}

int execle(const char *__path, const char *__arg0, ...)
{
  va_start(va, __arg0);
  int v16 = __path;
  uint64_t v15 = (char *)__arg0;
  unint64_t v13 = 0;
  unint64_t v12 = 0;
  va_copy(v14, va);
  for (int i = 1; ; ++i)
  {
    int v2 = *(char **)v14;
    v14 += 8;
    int v10 = v2;
    if (!v2) {
      break;
    }
  }
  double v7 = (char *)&v6 - ((8 * (i + 1) + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v7, 8 * (i + 1));
  unint64_t v13 = (char **)v7;
  if (v7)
  {
    va_copy(v14, va);
    int i = 1;
    *unint64_t v13 = v15;
    while (1)
    {
      uint64_t v3 = *(char **)v14;
      v14 += 8;
      unsigned int v9 = v3;
      v13[i] = v3;
      if (!v3) {
        break;
      }
      ++i;
    }
    unint64_t v4 = *(char *const **)v14;
    v14 += 8;
    unsigned int v8 = v4;
    unint64_t v12 = v4;
    return execve(v16, v13, v4);
  }
  else
  {
    *__error() = 12;
    return -1;
  }
}

int execlp(const char *__file, const char *__arg0, ...)
{
  va_start(va, __arg0);
  unint64_t v13 = __file;
  unint64_t v12 = (char *)__arg0;
  int v10 = 0;
  va_copy(v11, va);
  for (int i = 1; ; ++i)
  {
    int v2 = *(char **)v11;
    v11 += 8;
    unsigned int v8 = v2;
    if (!v2) {
      break;
    }
  }
  uint64_t v6 = (char *)&v5 - ((8 * (i + 1) + 15) & 0xFFFFFFFFFFFFFFF0);
  bzero(v6, 8 * (i + 1));
  int v10 = (char **)v6;
  if (v6)
  {
    va_copy(v11, va);
    int i = 1;
    *int v10 = v12;
    while (1)
    {
      uint64_t v3 = *(char **)v11;
      v11 += 8;
      double v7 = v3;
      v10[i] = v3;
      if (!v3) {
        break;
      }
      ++i;
    }
    return execvp(v13, v10);
  }
  else
  {
    *__error() = 12;
    return -1;
  }
}

int execvp(const char *__file, char *const *__argv)
{
  int v2 = _NSGetEnviron();
  return _execvpe((char *)__file, __argv, *v2);
}

int execv(const char *__path, char *const *__argv)
{
  int v2 = _NSGetEnviron();
  execve(__path, __argv, *v2);
  return -1;
}

uint64_t _execvpe(char *a1, char *const *a2, char *const *a3)
{
  unint64_t v4 = getenv("PATH");
  if (!v4) {
    unint64_t v4 = "/usr/bin:/bin";
  }
  return execvPe(a1, v4, a2, a3);
}

int execvP(const char *__file, const char *__searchpath, char *const *__argv)
{
  uint64_t v3 = _NSGetEnviron();
  return execvPe((char *)__file, __searchpath, __argv, *v3);
}

uint64_t execvPe(char *a1, const char *a2, char *const *a3, char *const *a4)
{
  __s = a1;
  int v27 = a2;
  int v26 = a3;
  int v25 = a4;
  int v24 = 0;
  uint64_t i = 0;
  size_t v22 = 0;
  size_t v21 = 0;
  int v19 = 0;
  double v18 = 0;
  unsigned int v17 = 0;
  int v16 = 0;
  memset(&v15, 0, sizeof(v15));
  int v20 = 0;
  if (strchr(__s, 47))
  {
    int v16 = __s;
    double v18 = 0;
LABEL_15:
    execve(v16, v26, v25);
    unint64_t v11 = (*__error() - 2);
    if (v11 > 0x3D)
    {
LABEL_28:
      int v19 = *__error();
      if (stat(v16, &v15)) {
        goto LABEL_8;
      }
      if (v19 == 13)
      {
        int v20 = 1;
LABEL_8:
        while (1)
        {
          unsigned int v17 = strsep(&v18, ":");
          if (!v17) {
            break;
          }
          if (*v17)
          {
            size_t v22 = strlen(v17);
          }
          else
          {
            unsigned int v17 = ".";
            size_t v22 = 1;
          }
          size_t v21 = strlen(__s);
          if (v22 + v21 + 2 <= 0x400)
          {
            unint64_t v12 = v30;
            bcopy(v17, v30, v22);
            uint64_t v5 = v12;
            v12[v22] = 47;
            bcopy(__s, &v5[v22 + 1], v21);
            v12[v22 + 1 + v21] = 0;
            goto LABEL_15;
          }
          int v13 = 2;
          write_NOCANCEL();
          write_NOCANCEL();
          write_NOCANCEL();
        }
        if (v20)
        {
          *__error() = 13;
        }
        else if (v18)
        {
          *__error() = 2;
        }
      }
      else
      {
        int v8 = v19;
        *__error() = v8;
      }
    }
    else
    {
      switch(v11)
      {
        case 1uLL:
        case 2uLL:
        case 3uLL:
        case 4uLL:
        case 7uLL:
        case 8uLL:
        case 9uLL:
        case 0xBuLL:
        case 0xCuLL:
        case 0xDuLL:
        case 0xEuLL:
        case 0xFuLL:
        case 0x10uLL:
        case 0x11uLL:
        case 0x13uLL:
        case 0x14uLL:
        case 0x15uLL:
        case 0x16uLL:
        case 0x17uLL:
        case 0x19uLL:
        case 0x1AuLL:
        case 0x1BuLL:
        case 0x1CuLL:
        case 0x1DuLL:
        case 0x1EuLL:
        case 0x1FuLL:
        case 0x20uLL:
        case 0x21uLL:
        case 0x22uLL:
        case 0x23uLL:
        case 0x24uLL:
        case 0x25uLL:
        case 0x26uLL:
        case 0x27uLL:
        case 0x28uLL:
        case 0x29uLL:
        case 0x2AuLL:
        case 0x2BuLL:
        case 0x2CuLL:
        case 0x2DuLL:
        case 0x2EuLL:
        case 0x2FuLL:
        case 0x30uLL:
        case 0x31uLL:
        case 0x32uLL:
        case 0x33uLL:
        case 0x34uLL:
        case 0x35uLL:
        case 0x36uLL:
        case 0x37uLL:
        case 0x38uLL:
        case 0x39uLL:
        case 0x3AuLL:
        case 0x3BuLL:
          goto LABEL_28;
        case 5uLL:
        case 0xAuLL:
        case 0x18uLL:
          break;
        case 6uLL:
          for (uint64_t i = 0; v26[i]; ++i)
            ;
          if ((unint64_t)(i + 2) >= 3) {
            uint64_t v10 = i + 2;
          }
          else {
            uint64_t v10 = 3;
          }
          unsigned int v9 = &v7[-((8 * v10 + 15) & 0xFFFFFFFFFFFFFFF0)];
          bzero(v9, 8 * v10);
          int v24 = (char **)v9;
          if (v9)
          {
            if (i)
            {
              *int v24 = *v26;
              v24[1] = v16;
              bcopy(v26 + 1, v24 + 2, 8 * i);
            }
            else
            {
              *int v24 = "sh";
              v24[1] = v16;
              v24[2] = 0;
            }
            execve("/bin/sh", v24, v25);
          }
          break;
        default:
          goto LABEL_8;
      }
    }
    return -1;
  }
  else
  {
    int v16 = v30;
    if (*__s)
    {
      size_t v4 = strlen(v27);
      va_list v14 = &v7[-((v4 + 16) & 0xFFFFFFFFFFFFFFF0)];
      bzero(v14, v4 + 1);
      double v18 = v14;
      if (v14)
      {
        strcpy(v18, v27);
        goto LABEL_8;
      }
      *__error() = 12;
      return -1;
    }
    else
    {
      *__error() = 2;
      return -1;
    }
  }
}

const char *__cdecl fmtcheck(const char *a1, const char *a2)
{
  int v8 = (char *)a1;
  double v7 = a2;
  uint64_t v6 = 0;
  uint64_t v5 = 0;
  if (!a1) {
    return v7;
  }
  uint64_t v6 = v8;
  int next_format = 0;
  uint64_t v5 = (char *)v7;
  int v3 = 0;
  while (1)
  {
    int next_format = get_next_format(&v6, next_format);
    if (next_format == 23) {
      break;
    }
    if (next_format == 24) {
      return v7;
    }
    int v3 = get_next_format(&v5, v3);
    if (next_format != v3) {
      return v7;
    }
  }
  return v8;
}

uint64_t get_next_format(char **a1, int a2)
{
  if (a2 == 21)
  {
    ++*a1;
    return get_next_format_from_width(a1);
  }
  else if (a2 == 22)
  {
    ++*a1;
    return get_next_format_from_precision(a1);
  }
  else
  {
    __s = *a1;
    int v6 = 0;
    while (!v6)
    {
      __sa = strchr(__s, 37);
      if (!__sa)
      {
        *a1 = 0;
        return 23;
      }
      __s = __sa + 1;
      if (!*__s)
      {
        *a1 = (char *)__s;
        return 24;
      }
      if (*__s == 37) {
        ++__s;
      }
      else {
        int v6 = 1;
      }
    }
    while (1)
    {
      BOOL v3 = 0;
      if (*__s) {
        BOOL v3 = strchr("#'0- +", *__s) != 0;
      }
      if (!v3) {
        break;
      }
      ++__s;
    }
    if (*__s == 42)
    {
      *a1 = (char *)__s;
      return 21;
    }
    else
    {
      while (isdigit(*__s))
        ++__s;
      if (*__s)
      {
        *a1 = (char *)__s;
        return get_next_format_from_width(a1);
      }
      else
      {
        *a1 = (char *)__s;
        return 24;
      }
    }
  }
}

uint64_t get_next_format_from_width(char **a1)
{
  int v2 = *a1;
  if (**a1 != 46) {
    goto LABEL_8;
  }
  if (*++v2 != 42)
  {
    while (isdigit(*v2))
      ++v2;
    if (!*v2)
    {
      *a1 = v2;
      return 24;
    }
LABEL_8:
    *a1 = v2;
    return get_next_format_from_precision(a1);
  }
  *a1 = v2;
  return 22;
}

uint64_t get_next_format_from_precision(char **a1)
{
  unint64_t v11 = *a1;
  unsigned int v1 = **a1;
  BOOL v2 = v1 > 0x4C;
  uint64_t v3 = v1 - 76;
  if (v2)
  {
    uint64_t v5 = v3;
    char v4 = 1;
  }
  else
  {
    uint64_t v5 = v3;
    char v4 = 0;
  }
  if (v4)
  {
LABEL_21:
    unsigned int v12 = 0;
  }
  else
  {
    switch(v5)
    {
      case 0:
        ++v11;
        unsigned int v12 = 6;
        break;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 29:
      case 31:
      case 33:
      case 34:
      case 35:
      case 36:
      case 38:
      case 39:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
        goto LABEL_21;
      case 28:
        if (!*++v11)
        {
          *a1 = v11;
          return 24;
        }
        if (*v11 == 104)
        {
          ++v11;
          unsigned int v12 = 1;
        }
        else
        {
          unsigned int v12 = 2;
        }
        break;
      case 30:
        ++v11;
        unsigned int v12 = 5;
        break;
      case 32:
        if (!*++v11)
        {
          *a1 = v11;
          return 24;
        }
        if (*v11 == 108)
        {
          ++v11;
          unsigned int v12 = 4;
        }
        else
        {
          unsigned int v12 = 3;
        }
        break;
      case 37:
        ++v11;
        unsigned int v12 = 4;
        break;
      case 40:
        ++v11;
        unsigned int v12 = 7;
        break;
      case 46:
        ++v11;
        unsigned int v12 = 8;
        break;
      default:
LABEL_89:
        JUMPOUT(0);
    }
  }
  if (*v11)
  {
    if (strchr("diouxX", *v11))
    {
      if (v12)
      {
        uint64_t v7 = v12;
        char v6 = 1;
      }
      else
      {
        uint64_t v7 = 0;
        char v6 = 0;
      }
      if ((v6 & 1) == 0)
      {
        switch(v7)
        {
          case 0:
          case 1:
          case 2:
            *a1 = v11;
            return 2;
          case 3:
            *a1 = v11;
            return 4;
          case 4:
            *a1 = v11;
            return 5;
          case 5:
            *a1 = v11;
            return 6;
          case 6:
            break;
          case 7:
            *a1 = v11;
            return 7;
          case 8:
            *a1 = v11;
            return 8;
          default:
            goto LABEL_89;
        }
      }
      *a1 = v11;
      return 24;
    }
    else if (*v11 == 110)
    {
      if (v12)
      {
        uint64_t v9 = v12;
        char v8 = 1;
      }
      else
      {
        uint64_t v9 = 0;
        char v8 = 0;
      }
      if ((v8 & 1) == 0)
      {
        switch(v9)
        {
          case 0:
            *a1 = v11;
            return 11;
          case 1:
            *a1 = v11;
            return 9;
          case 2:
            *a1 = v11;
            return 10;
          case 3:
            *a1 = v11;
            return 12;
          case 4:
            *a1 = v11;
            return 13;
          case 5:
            *a1 = v11;
            return 14;
          case 6:
            break;
          case 7:
            *a1 = v11;
            return 15;
          case 8:
            *a1 = v11;
            return 16;
          default:
            goto LABEL_89;
        }
      }
      *a1 = v11;
      return 24;
    }
    else if (strchr("DOU", *v11))
    {
      *a1 = v11;
      if (v12) {
        return 24;
      }
      else {
        return 4;
      }
    }
    else if (strchr("aAeEfFgG", *v11))
    {
      if (!v12 || v12 == 3)
      {
        *a1 = v11;
        return 17;
      }
      else
      {
        *a1 = v11;
        if (v12 == 6) {
          return 18;
        }
        else {
          return 24;
        }
      }
    }
    else
    {
      switch(*v11)
      {
        case 'c':
          if (v12)
          {
            *a1 = v11;
            if (v12 == 3) {
              return 3;
            }
            else {
              return 24;
            }
          }
          else
          {
            *a1 = v11;
            return 2;
          }
        case 'C':
          *a1 = v11;
          if (v12) {
            return 24;
          }
          else {
            return 3;
          }
        case 's':
          if (v12)
          {
            *a1 = v11;
            if (v12 == 3) {
              return 20;
            }
            else {
              return 24;
            }
          }
          else
          {
            *a1 = v11;
            return 19;
          }
        case 'S':
          *a1 = v11;
          if (v12) {
            return 24;
          }
          else {
            return 20;
          }
        case 'p':
          *a1 = v11;
          if (v12) {
            return 24;
          }
          else {
            return 4;
          }
        default:
          *a1 = v11;
          return 24;
      }
    }
  }
  else
  {
    *a1 = v11;
    return 24;
  }
}

int fmtmsg(uint64_t a1, const char *a2, int a3, const char *a4, const char *a5, const char *a6)
{
  uint64_t v19 = a1;
  double v18 = a2;
  unsigned int v17 = a3;
  int v16 = a4;
  stat v15 = a5;
  va_list v14 = a6;
  int v13 = 0;
  unsigned int v12 = 0;
  unint64_t v11 = 0;
  uint64_t v10 = 0;
  int v9 = 0;
  if (!a5) {
    stat v15 = (const char *)&unk_D793D;
  }
  if ((v19 & 0x100) == 0) {
    goto LABEL_20;
  }
  unsigned int v12 = getenv("MSGVERB");
  if (!v12 || !*v12 || strlen(v12) > 0x1E) {
    goto LABEL_12;
  }
  unint64_t v11 = strdup(v12);
  if (v11)
  {
    if (validmsgverb(v11))
    {
LABEL_14:
      uint64_t v10 = printfmt(v11, v19, v18, v17, v16, v15, v14);
      if (!v10)
      {
        free(v11);
        return 3;
      }
      if (*v10 && fprintf(__stderrp, "%s", v10) < 0) {
        int v9 = 1;
      }
      free(v11);
      free(v10);
LABEL_20:
      if ((v19 & 0x200) != 0)
      {
        uint64_t v10 = printfmt("label:severity:text:action:tag", v19, v18, v17, v16, v15, v14);
        if (!v10) {
          return 2;
        }
        if (*v10)
        {
          memset(&__b, 0, sizeof(__b));
          __filename = "/dev/console";
          if (!stat("/var/log/console", &__b) && (__b.st_mode & 0xF000) == 0x4000) {
            __filename = "/var/log/console";
          }
          int v13 = fopen(__filename, "a");
          if (v13)
          {
            fprintf(v13, "%s", v10);
            fclose(v13);
          }
          else if (v9)
          {
            int v9 = 3;
          }
          else
          {
            int v9 = 2;
          }
        }
        free(v10);
      }
      return v9;
    }
    free(v11);
LABEL_12:
    unint64_t v11 = strdup("label:severity:text:action:tag");
    if (!v11) {
      return 3;
    }
    goto LABEL_14;
  }
  return 3;
}

BOOL validmsgverb(const char *a1)
{
  int v2 = 0;
  while (1)
  {
    __s1 = nextcomp(a1);
    if (!__s1) {
      break;
    }
    --v2;
    for (int i = 0; validlist[i]; ++i)
    {
      if (!strcmp(__s1, validlist[i])) {
        ++v2;
      }
    }
  }
  return v2 == 0;
}

char *printfmt(const char *a1, uint64_t a2, const char *a3, unsigned int a4, const char *a5, const char *a6, const char *a7)
{
  size_t __size = 32;
  if (a3) {
    size_t __size = strlen(a3) + 32;
  }
  __s = (char *)sevinfo(a4);
  if (__s) {
    __size += strlen(__s);
  }
  if (a5) {
    __size += strlen(a5);
  }
  if (a6) {
    __size += strlen(a6);
  }
  if (a7) {
    __size += strlen(a7);
  }
  __dst = (char *)malloc_type_malloc();
  if (!__dst) {
    return 0;
  }
  char *__dst = 0;
  while (1)
  {
    __s1 = nextcomp(a1);
    if (!__s1) {
      break;
    }
    if (!strcmp(__s1, "label") && a3)
    {
      if (*__dst) {
        strlcat(__dst, ": ", __size);
      }
      strlcat(__dst, a3, __size);
    }
    else if (!strcmp(__s1, "severity") && __s)
    {
      if (*__dst) {
        strlcat(__dst, ": ", __size);
      }
      uint64_t v7 = sevinfo(a4);
      strlcat(__dst, v7, __size);
    }
    else if (!strcmp(__s1, "text") && a5)
    {
      if (*__dst) {
        strlcat(__dst, ": ", __size);
      }
      strlcat(__dst, a5, __size);
    }
    else if (!strcmp(__s1, "action") && a6)
    {
      if (*__dst) {
        strlcat(__dst, "\n", __size);
      }
      strlcat(__dst, "TO FIX: ", __size);
      strlcat(__dst, a6, __size);
    }
    else if (!strcmp(__s1, "tag") && a7)
    {
      if (*__dst) {
        strlcat(__dst, " ", __size);
      }
      strlcat(__dst, a7, __size);
    }
  }
  if (*__dst) {
    strlcat(__dst, "\n", __size);
  }
  return __dst;
}

const char *sevinfo(unsigned int a1)
{
  if (a1 <= 1)
  {
    uint64_t v2 = a1 - 1;
    char v1 = 0;
  }
  else
  {
    uint64_t v2 = a1 - 1;
    char v1 = 1;
  }
  if (v1) {
    return 0;
  }
  switch(v2)
  {
    case 0:
      char v4 = "HALT";
      break;
    case 1:
      char v4 = "ERROR";
      break;
    case 2:
      char v4 = "WARNING";
      break;
    case 3:
      char v4 = "INFO";
      break;
    default:
      JUMPOUT(0);
  }
  return v4;
}

char *nextcomp(const char *a1)
{
  if (nextcomp_lmsgverb)
  {
    uint64_t v2 = strtok_r(0, ":", &nextcomp_state);
  }
  else
  {
    strlcpy(&nextcomp_lmsgverb, a1, 0x1FuLL);
    uint64_t v2 = strtok_r(&nextcomp_lmsgverb, ":", &nextcomp_state);
  }
  if (!v2) {
    nextcomp_lmsgverb = 0;
  }
  return v2;
}

int fnmatch(const char *a1, const char *a2, int a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    unsigned int v12 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v5 = __locale_key;
    unsigned int v12 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
  }
  if (v12) {
    uint64_t v7 = v12;
  }
  else {
    uint64_t v7 = (_xlocale *)__global_locale;
  }
  memcpy(&__dst, &fnmatch_initial, sizeof(__dst));
  memcpy(&v13, &fnmatch_initial, sizeof(v13));
  return fnmatch1((char *)a1, (char *)a2, (char *)a2, a3, &__dst, &v13, v7, 64);
}

uint64_t fnmatch1(char *a1, char *a2, char *a3, int a4, mbstate_t *a5, mbstate_t *a6, _xlocale *a7, int a8)
{
  int v33 = a1;
  __s = a2;
  uint64_t v31 = a3;
  int v30 = a4;
  unsigned int v29 = a5;
  int v28 = a6;
  locale_t v27 = a7;
  int v26 = a8;
  memset(__b, 0, sizeof(__b));
  memset(&__dst, 0, sizeof(__dst));
  int v23 = 0;
  size_t v22 = 0;
  char i = 0;
  wint_t v20 = 0;
  wint_t v19 = 0;
  int v24 = 0;
  int v25 = 0;
  int v8 = v26--;
  if (v8 <= 0) {
    return 2;
  }
  while (1)
  {
    while (1)
    {
      size_t v17 = mbrtowc_l(&v20, v33, 6uLL, a5, v27);
      if (v17 >= 0xFFFFFFFFFFFFFFFELL) {
        return 2;
      }
      v33 += v17;
      size_t v15 = mbrtowc_l(&v19, __s, 6uLL, a6, v27);
      if (v15 >= 0xFFFFFFFFFFFFFFFELL)
      {
        wint_t v19 = *__s;
        size_t v15 = 1;
        memset(a6, 0, sizeof(mbstate_t));
      }
      if (!v20)
      {
        if ((v30 & 8) != 0 && v19 == 47) {
          return 0;
        }
        if (!v19) {
          return 0;
        }
        goto LABEL_77;
      }
      if (v20 == 42) {
        break;
      }
      if (v20 == 63)
      {
        if (!v19) {
          return 1;
        }
        if (v19 == 47 && (v30 & 2) != 0
          || v19 == 46 && (v30 & 4) != 0 && (__s == v31 || (v30 & 2) != 0 && *(__s - 1) == 47))
        {
          goto LABEL_77;
        }
        __s += v15;
      }
      else if (v20 == 91)
      {
        if (!v19) {
          return 1;
        }
        if (v19 == 47 && (v30 & 2) != 0
          || v19 == 46 && (v30 & 4) != 0 && (__s == v31 || (v30 & 2) != 0 && *(__s - 1) == 47))
        {
          goto LABEL_77;
        }
        int v11 = rangematch(v33, v19, &__s[v15], v30, &v23, &v22, a5, a6, v27);
        switch(v11)
        {
          case -1:
            return 2;
          case 0:
            goto LABEL_77;
          case 1:
            int v33 = v23;
            __s = v22;
            break;
        }
      }
      else
      {
        if (v20 == 92 && (v30 & 1) == 0)
        {
          size_t v18 = mbrtowc_l(&v20, v33, 6uLL, a5, v27);
          if (v18 >= 0xFFFFFFFFFFFFFFFELL) {
            return 2;
          }
          if (!v18) {
            wint_t v20 = 92;
          }
          v33 += v18;
        }
        __s += v15;
        if (v20 != v19)
        {
          if ((v30 & 0x10) == 0 || (wint_t v10 = towlower_l(v20, v27), v10 != towlower_l(v19, v27)))
          {
LABEL_77:
            if (!v25) {
              return 1;
            }
            size_t v16 = mbrtowc(&v19, v24, 6uLL, &__dst);
            if (v16 >= 0xFFFFFFFFFFFFFFFELL)
            {
              wint_t v19 = *v24;
              size_t v16 = 1;
              memset(&__dst, 0, sizeof(__dst));
            }
            if (!v19) {
              return 1;
            }
            if (v19 == 47 && (v30 & 2) != 0) {
              return 1;
            }
            v24 += v16;
            int v33 = v25;
            memcpy(a5, __b, sizeof(mbstate_t));
            __s = v24;
            memcpy(a6, &__dst, sizeof(mbstate_t));
          }
        }
      }
    }
    for (char i = *v33; i == 42; char i = *v33)
      ++v33;
    if (v19 == 46 && (v30 & 4) != 0 && (__s == v31 || (v30 & 2) != 0 && *(__s - 1) == 47)) {
      goto LABEL_77;
    }
    if (!i) {
      break;
    }
    if (i == 47 && (v30 & 2) != 0)
    {
      __s = strchr(__s, 47);
      if (!__s) {
        return 1;
      }
    }
    else
    {
      int v25 = v33;
      memcpy(__b, a5, sizeof(__b));
      int v24 = __s;
      memcpy(&__dst, a6, sizeof(__dst));
    }
  }
  if ((v30 & 2) != 0)
  {
    BOOL v12 = 1;
    if ((v30 & 8) == 0) {
      BOOL v12 = strchr(__s, 47) == 0;
    }
    return !v12;
  }
  else
  {
    return 0;
  }
}

uint64_t rangematch(char *a1, wint_t a2, char *a3, int a4, void *a5, void *a6, void *a7, void *a8, _xlocale *a9)
{
  double v36 = a1;
  wint_t v35 = a2;
  char v34 = a3;
  int v33 = a4;
  int v32 = a5;
  uint64_t v31 = a6;
  mbstate_t __dst = a7;
  uint64_t __src = a8;
  locale_t v28 = a9;
  int v27 = 0;
  int v26 = 0;
  int __c = 0;
  wint_t v24 = 0;
  wint_t v23 = 0;
  size_t v22 = 0;
  size_t v21 = 0;
  unint64_t v20 = 0;
  wint_t v19 = 0;
  __s = 0;
  size_t v17 = 0;
  memset(__b, 0, sizeof(__b));
  BOOL v12 = 1;
  if (*v36 != 33) {
    BOOL v12 = *v36 == 94;
  }
  int v27 = v12;
  if (v12) {
    ++v36;
  }
  if ((v33 & 0x10) != 0) {
    wint_t v35 = towlower_l(v35, v28);
  }
  int v26 = 0;
  wint_t v19 = v36;
  while (1)
  {
    wint_t v24 = 0;
    if (*v36 == 93 && v36 > v19) {
      break;
    }
    if (!*v36) {
      return -1;
    }
    if (*v36 == 47 && (v33 & 2) != 0) {
      return 0;
    }
    if (*v36 != 92 || (v33 & 1) != 0)
    {
      if (*v36 != 91) {
        goto LABEL_74;
      }
      int __c = v36[1];
      if (__c != 46 && __c != 61 && __c != 58) {
        goto LABEL_74;
      }
      v36 += 2;
      for (__s = v36; ; ++__s)
      {
        __s = strchr(__s, __c);
        if (!__s || __s[1] == 93) {
          break;
        }
      }
      if (!__s) {
        return -1;
      }
      if (__c == 46)
      {
LABEL_29:
        unint64_t v20 = __collate_collating_symbol(&v40, 0x18uLL, v36, __s - v36, (mbstate_t *)__dst, v28);
        if (v20 == -1 || !v20) {
          return -1;
        }
        double v36 = __s + 2;
        if (v20 <= 1)
        {
          wint_t v24 = v40;
          goto LABEL_74;
        }
        size_t v16 = 0;
        __int32 v15 = 0;
        if (__s[2] == 45 && __s[3] && __s[3] != 93) {
          return -1;
        }
        size_t v16 = &v41;
        if (v35 == v40)
        {
          memcpy(__b, __src, sizeof(__b));
          size_t v17 = v34;
          while (--v20)
          {
            size_t v21 = mbrtowc_l(&v15, v34, 6uLL, (mbstate_t *)__src, v28);
            if (v21 >= 0xFFFFFFFFFFFFFFFELL)
            {
              __int32 v15 = *v34;
              size_t v21 = 1;
              uint64_t __src = 0;
            }
            int v9 = v16++;
            if (v15 != *v9)
            {
              memcpy(__src, __b, 0x80uLL);
              char v34 = v17;
              break;
            }
            v34 += v21;
          }
          if (!v20)
          {
            int v26 = 1;
            break;
          }
        }
      }
      else if (__c == 61)
      {
        memcpy(__b, __dst, sizeof(__b));
        int v14 = __collate_equiv_class(v36, __s - v36, (mbstate_t *)__dst, v28);
        if (v14 < 0) {
          return -1;
        }
        if (!v14)
        {
          memcpy(__dst, __b, 0x80uLL);
          goto LABEL_29;
        }
        double v36 = __s + 2;
        if (__s[2] == 45 && __s[3] && __s[3] != 93) {
          return -1;
        }
        size_t v10 = strlen(v34);
        unint64_t v20 = __collate_equiv_match(v14, 0, 0, v35, v34, v10, __src, &v21, v28);
        if (v20 == -1) {
          return -1;
        }
        if (v20)
        {
          int v26 = 1;
          v34 += v21;
          break;
        }
      }
      else
      {
        if (__s[2] == 45 && __s[3] && __s[3] != 93) {
          return -1;
        }
        if (__s - v36 > 14) {
          return -1;
        }
        strlcpy(v38, v36, __s - v36 + 1);
        double v36 = __s + 2;
        wctype_t v13 = wctype(v38);
        if (!v13) {
          return -1;
        }
        if (iswctype_l(v35, v13, v28))
        {
          int v26 = 1;
          break;
        }
      }
    }
    else
    {
      ++v36;
LABEL_74:
      if (!v24)
      {
        size_t v22 = mbrtowc_l(&v24, v36, 6uLL, (mbstate_t *)__dst, v28);
        if (v22 >= 0xFFFFFFFFFFFFFFFELL) {
          return -1;
        }
        v36 += v22;
      }
      if ((v33 & 0x10) != 0) {
        wint_t v24 = towlower_l(v24, v28);
      }
      if (*v36 == 45 && v36[1] && v36[1] != 93)
      {
        if (*++v36 == 92 && (v33 & 1) == 0 && *v36) {
          ++v36;
        }
        size_t v22 = mbrtowc_l(&v23, v36, 6uLL, (mbstate_t *)__dst, v28);
        if (v22 >= 0xFFFFFFFFFFFFFFFELL) {
          return -1;
        }
        v36 += v22;
        if (!v23) {
          return -1;
        }
        if (v23 == 91 && (int __c = *v36, __c == 46) || __c == 61 || __c == 58)
        {
          if (__c == 61 || __c == 58) {
            return -1;
          }
          for (__s = ++v36; ; ++__s)
          {
            __s = strchr(__s, __c);
            if (!__s || __s[1] == 93) {
              break;
            }
          }
          if (!__s) {
            return -1;
          }
          unint64_t v20 = __collate_collating_symbol(&v40, 0x18uLL, v36, __s - v36, (mbstate_t *)__dst, v28);
          if (v20 != 1) {
            return -1;
          }
          double v36 = __s + 2;
          wint_t v23 = v40;
        }
        if ((v33 & 0x10) != 0) {
          wint_t v23 = towlower_l(v23, v28);
        }
        if (*(unsigned char *)(*((void *)v28 + 165) + 64))
        {
          if (v24 <= v35 && v35 <= v23) {
            goto LABEL_115;
          }
        }
        else if ((int)__collate_range_cmp(v24, v35, v28) <= 0 && (int)__collate_range_cmp(v35, v23, v28) <= 0)
        {
LABEL_115:
          int v26 = 1;
          break;
        }
      }
      else if (v24 == v35)
      {
        int v26 = 1;
        break;
      }
    }
  }
  int __c = 0;
  while (*v36 != 93)
  {
    if (!*v36) {
      return -1;
    }
    if (*v36 == __c)
    {
      if (*++v36 == 93)
      {
        int __c = 0;
        ++v36;
      }
    }
    else if (__c || *v36 != 91)
    {
      size_t v22 = mbrtowc_l(&v24, v36, 6uLL, (mbstate_t *)__dst, v28);
      if (v22 >= 0xFFFFFFFFFFFFFFFELL) {
        return -1;
      }
      v36 += v22;
    }
    else
    {
      int __c = *++v36;
      if (__c == 46 || __c == 61 || __c == 58) {
        ++v36;
      }
      else {
        int __c = 0;
      }
    }
  }
  void *v32 = ++v36;
  *uint64_t v31 = v34;
  return v26 != v27;
}

key_t ftok(const char *a1, int a2)
{
  uint64_t v5 = a1;
  int v4 = a2;
  memset(&__b, 0, sizeof(__b));
  if (stat(v5, &__b) >= 0) {
    return (LOBYTE(__b.st_dev) << 16) | (v4 << 24) | LOWORD(__b.st_ino);
  }
  else {
    return -1;
  }
}

char *__cdecl getbsize(int *a1, uint64_t *a2)
{
  wctype_t v13 = a1;
  BOOL v12 = a2;
  uint64_t v11 = 0;
  uint64_t v10 = 0;
  uint64_t v9 = 0;
  uint64_t v8 = 0;
  __endptr = 0;
  uint64_t v5 = (const char *)&unk_D793D;
  __str = getenv("BLOCKSIZE");
  if (!__str || !*__str)
  {
    uint64_t v11 = 512;
    uint64_t v8 = 512;
    goto LABEL_27;
  }
  uint64_t v11 = strtol(__str, &__endptr, 10);
  if (v11 < 0)
  {
LABEL_24:
    warnx("minimum blocksize is 512");
    uint64_t v5 = (const char *)&unk_D793D;
    uint64_t v11 = 512;
    uint64_t v8 = 512;
    goto LABEL_27;
  }
  if (!v11) {
    uint64_t v11 = 1;
  }
  if (*__endptr && __endptr[1]) {
    goto LABEL_20;
  }
  int v4 = *__endptr;
  if (!*__endptr)
  {
    uint64_t v10 = 0x40000000;
    uint64_t v9 = 1;
    goto LABEL_21;
  }
  switch(v4)
  {
    case 'G':
      goto LABEL_16;
    case 'K':
LABEL_17:
      uint64_t v5 = "K";
      uint64_t v10 = 0x100000;
      uint64_t v9 = 1024;
      goto LABEL_21;
    case 'M':
LABEL_18:
      uint64_t v5 = "M";
      uint64_t v10 = 1024;
      uint64_t v9 = 0x100000;
      goto LABEL_21;
    case 'g':
LABEL_16:
      uint64_t v5 = "G";
      uint64_t v10 = 1;
      uint64_t v9 = 0x40000000;
      goto LABEL_21;
    case 'k':
      goto LABEL_17;
    case 'm':
      goto LABEL_18;
  }
LABEL_20:
  warnx("%s: unknown blocksize", __str);
  uint64_t v11 = 512;
  uint64_t v10 = 0x40000000;
  uint64_t v9 = 1;
LABEL_21:
  if (v11 > v10)
  {
    warnx("maximum blocksize is %ldG", 1);
    uint64_t v11 = v10;
  }
  uint64_t v8 = v11 * v9;
  if (v11 * v9 < 512) {
    goto LABEL_24;
  }
LABEL_27:
  snprintf(getbsize_header, 0x14uLL, "%ld%s-blocks", v11, v5);
  int v2 = strlen(getbsize_header);
  uint64_t result = getbsize_header;
  *wctype_t v13 = v2;
  *BOOL v12 = v8;
  return result;
}

int cgetset(const char *a1)
{
  if (a1)
  {
    toprecleint n = strlen(a1);
    toprec = malloc_type_malloc();
    if (toprec)
    {
      gottoprec = 0;
      strcpy((char *)toprec, a1);
      return 0;
    }
    else
    {
      *__error() = 12;
      return -1;
    }
  }
  else
  {
    if (toprec) {
      free((void *)toprec);
    }
    toprec = 0;
    toprecleint n = 0;
    return 0;
  }
}

char *__cdecl cgetcap(char *a1, const char *a2, int a3)
{
  do
  {
    while (1)
    {
      while (1)
      {
        if (!*a1) {
          return 0;
        }
        char v3 = a1++;
        if (*v3 == 58)
        {
          for (char i = a2; ; ++i)
          {
            BOOL v6 = 0;
            if (*i == *a1) {
              BOOL v6 = *a1 != 0;
            }
            if (!v6) {
              break;
            }
            ++a1;
          }
          if (!*i) {
            break;
          }
        }
      }
      if (*a1 == 64) {
        return 0;
      }
      if (a3 != 58) {
        break;
      }
      if (!*a1 || *a1 == 58) {
        return a1;
      }
    }
  }
  while (*a1 != a3);
  uint64_t v9 = a1 + 1;
  if (*v9 == 64) {
    return 0;
  }
  else {
    return v9;
  }
}

int cgetent(char **a1, char **a2, const char *a3)
{
  BOOL v12 = a1;
  uint64_t v11 = a2;
  uint64_t v10 = a3;
  int v9 = 0;
  wctype_t v13 = 0;
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    wctype_t v13 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v14 = __locale_key;
    uint64_t v15 = __locale_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    wctype_t v13 = *(void **)(StatusReg + 8 * v15);
  }
  if (v13) {
    return getent(a1, &v9, (const char **)a2, -1, (char *)a3, 0, 0, (uint64_t)v13);
  }
  else {
    return getent(a1, &v9, (const char **)a2, -1, (char *)a3, 0, 0, (uint64_t)__global_locale);
  }
}

uint64_t getent(char **a1, _DWORD *a2, const char **a3, int a4, char *a5, int a6, const char *a7, uint64_t a8)
{
  uint64_t v52 = a1;
  int v51 = a2;
  v50 = a3;
  int v49 = a4;
  double v48 = a5;
  int v47 = a6;
  double v46 = a7;
  uint64_t v45 = a8;
  double v44 = 0;
  double v43 = 0;
  double v42 = 0;
  int v41 = 0;
  int v40 = 0;
  int v39 = 0;
  int v38 = 0;
  int v37 = 0;
  mbstate_t __dst = 0;
  __s = 0;
  int v34 = 0;
  if (a6 > 32) {
    return -3;
  }
  if (!v47 && toprec && !cgetmatch((const char *)toprec, v48))
  {
    mbstate_t __dst = (char *)malloc_type_malloc();
    if (__dst)
    {
      strcpy(__dst, (const char *)toprec);
      int v40 = 0;
      int v41 = v50;
      double v42 = &__dst[topreclen + 1];
      double v43 = &__dst[topreclen + 1025];
LABEL_59:
      int v27 = 0;
      memset(v26, 0, sizeof(v26));
      int v25 = 0;
      int v24 = 0;
      int v23 = 0;
      size_t v22 = 0;
      int v34 = 0;
      uint64_t v11 = cgetcap(__dst, "tc", 61);
      while (v11)
      {
        v26[1] = v11;
        while (*(unsigned char *)v26[1])
        {
          BOOL v12 = v26[1]++;
          if (*v12 == 58)
          {
            *((unsigned char *)v26[1] - 1) = 0;
            break;
          }
        }
        size_t v21 = v11 - 3;
        int v23 = LODWORD(v26[1]) - (v11 - 3);
        unint64_t v20 = (char *)v26[1];
        int v24 = getent(&v22, v26, v41, v49, v11, (v47 + 1), 0, v45, v15);
        int v27 = v22;
        HIDWORD(v26[0]) = v26[0];
        if (!v24) {
          goto LABEL_75;
        }
        if (v24 < -1)
        {
          if (v40) {
            close_NOCANCEL();
          }
          free(__dst);
          return v24;
        }
        if (v24 == 1) {
          int v34 = 1;
        }
        if (v24 == -1)
        {
          *((unsigned char *)v26[1] - 1) = 58;
          int v34 = 1;
          uint64_t v11 = cgetcap((char *)v26[1] - 1, "tc", 61);
        }
        else
        {
LABEL_75:
          v26[1] = v27;
          do
          {
            if (!*(unsigned char *)v26[1]) {
              break;
            }
            wctype_t v13 = v26[1]++;
          }
          while (*v13 != 58);
          HIDWORD(v26[0]) -= LODWORD(v26[1]) - v27;
          int v27 = v26[1];
          v26[1] = (char *)v26[1] + SHIDWORD(v26[0]);
          if (*((unsigned char *)v26[1] - 1) != 58)
          {
            *(unsigned char *)v26[1] = 58;
            ++HIDWORD(v26[0]);
          }
          int v25 = HIDWORD(v26[0]) - v23;
          if (HIDWORD(v26[0]) - v23 >= v43 - v42)
          {
            int v19 = v42 - __dst;
            uint64_t v16 = v43 - __dst + v25 + 1024;
            int v18 = v21 - __dst;
            int v17 = v20 - __dst;
            mbstate_t __dst = (char *)reallocf(__dst, v16);
            if (!__dst)
            {
              *__error() = 12;
              if (v40) {
                close_NOCANCEL();
              }
              free(v22);
              return -2;
            }
            double v43 = &__dst[v16];
            double v42 = &__dst[v19];
            size_t v21 = &__dst[v18];
            unint64_t v20 = &__dst[v17];
          }
          v26[1] = &v21[SHIDWORD(v26[0])];
          bcopy(v20, v26[1], v42 - v20);
          bcopy(v27, v21, SHIDWORD(v26[0]));
          v42 += v25;
          free(v22);
          uint64_t v11 = cgetcap((char *)v26[1] - 1, "tc", 61);
        }
      }
      if (v40) {
        close_NOCANCEL();
      }
      *int v51 = v42 - __dst - 1;
      if (v43 <= v42 || (mbstate_t __dst = (char *)reallocf(__dst, v42 - __dst)) != 0)
      {
        *uint64_t v52 = __dst;
        return v34 != 0;
      }
      else
      {
        *__error() = 12;
        return -2;
      }
    }
LABEL_7:
    *__error() = 12;
    return -2;
  }
  mbstate_t __dst = (char *)malloc_type_malloc();
  if (!__dst) {
    goto LABEL_7;
  }
  double v43 = __dst + 1024;
  int v38 = 0;
  int v41 = v50;
LABEL_11:
  if (*v41)
  {
    int v39 = 0;
    if (v49 < 0)
    {
      snprintf(__str, 0x100uLL, "%s.db", *v41);
      double v44 = dbopen(__str, 0, 0, DB_HASH, 0);
      if (v44)
      {
        free(__dst);
        int v37 = cdbget((uint64_t)v44, &__dst, v48);
        if (v37 >= 0)
        {
          __s = strdup(__dst);
          if (((int (*)(DB *))v44->close)(v44) >= 0)
          {
            if (__s)
            {
              *int v51 = strlen(__s);
              *uint64_t v52 = __s;
              return v37;
            }
            else
            {
              *__error() = 12;
              return -2;
            }
          }
          else
          {
            free(__s);
            return -2;
          }
        }
        else
        {
          ((void (*)(DB *))v44->close)(v44);
          return v37;
        }
      }
      uint64_t v15 = 0;
      int v49 = open_NOCANCEL();
      if (v49 < 0) {
        goto LABEL_56;
      }
      int v40 = 1;
    }
    else
    {
      lseek(v49, 0, 0);
      int v40 = 0;
    }
    int v31 = 0;
    int v33 = v54;
    int v32 = v54;
LABEL_25:
    double v42 = __dst;
    while (1)
    {
      if (v32 >= v33)
      {
        int NOCANCEL = read_NOCANCEL();
        if (NOCANCEL <= 0)
        {
          if (v40) {
            close_NOCANCEL();
          }
          if (NOCANCEL < 0)
          {
            free(__dst);
            return -2;
          }
          int v49 = -1;
          int v39 = 1;
LABEL_46:
          uint64_t v10 = v42++;
          *uint64_t v10 = 0;
          if (!v39)
          {
            if (!*__dst || *__dst == 35 || cgetmatch(__dst, v48) || v46 && nfcmp(v46, __dst)) {
              goto LABEL_25;
            }
            int v38 = 1;
          }
          if (v38) {
            break;
          }
LABEL_56:
          ++v41;
          goto LABEL_11;
        }
        int v33 = &v54[NOCANCEL];
        int v32 = v54;
      }
      uint64_t v8 = v32++;
      int v31 = *v8;
      if (v31 == 10)
      {
        if (v42 <= __dst || *(v42 - 1) != 92) {
          goto LABEL_46;
        }
        --v42;
      }
      else
      {
        int v9 = v42++;
        *int v9 = v31;
        if (v42 >= v43)
        {
          int v29 = v42 - __dst;
          size_t __size = v43 - __dst + 1024;
          mbstate_t __dst = (char *)reallocf(__dst, __size);
          if (!__dst)
          {
            *__error() = 12;
            if (v40) {
              close_NOCANCEL();
            }
            return -2;
          }
          double v43 = &__dst[__size];
          double v42 = &__dst[v29];
        }
      }
    }
  }
  if (v38) {
    goto LABEL_59;
  }
  free(__dst);
  return -1;
}

int cgetmatch(const char *a1, const char *a2)
{
  if (!a2 || !*a2) {
    return -1;
  }
LABEL_4:
  uint64_t v7 = a2;
  while (*v7)
  {
    int v2 = a1++;
    char v3 = v7++;
    if (*v2 != *v3) {
      goto LABEL_12;
    }
  }
  if (*a1 == 124 || *a1 == 58 || !*a1) {
    return 0;
  }
LABEL_12:
  --a1;
  while (*a1 && *a1 != 58)
  {
    char v4 = a1++;
    if (*v4 == 124) {
      goto LABEL_4;
    }
  }
  return -1;
}

int cgetfirst(char **a1, char **a2)
{
  return cgetnext(a1, a2);
}

int cgetclose(void)
{
  if (pfp)
  {
    fclose((FILE *)pfp);
    pfp = 0;
  }
  dbp = 0;
  int result = 0;
  gottoprec = 0;
  slash = 0;
  return result;
}

int cgetnext(char **a1, char **a2)
{
  size_t v22 = a1;
  size_t v21 = a2;
  size_t v20 = 0;
  int v19 = 0;
  int v18 = 0;
  int v17 = 0;
  int v16 = 0;
  char i = 0;
  uint64_t v14 = 0;
  wctype_t v13 = 0;
  BOOL v12 = 0;
  int v11 = 0;
  int v24 = 0;
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v24 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v25 = __locale_key;
    uint64_t v26 = __locale_key;
    unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    int v24 = *(_xlocale **)(StatusReg + 8 * v26);
  }
  if (v24) {
    uint64_t v10 = v24;
  }
  else {
    uint64_t v10 = (_xlocale *)__global_locale;
  }
  if (!dbp) {
    dbp = (uint64_t)v21;
  }
  if (pfp || (pfp = (uint64_t)fopen(*(const char **)dbp, "r")) != 0)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (toprec && !gottoprec)
          {
            gottoprec = 1;
            uint64_t v14 = (char *)toprec;
            goto LABEL_37;
          }
          uint64_t v14 = fgetln((FILE *)pfp, &v20);
          if (v14 || !pfp) {
            break;
          }
          int v18 = ferror((FILE *)pfp);
          if (v18) {
            int v17 = *__error();
          }
          fclose((FILE *)pfp);
          pfp = 0;
          if (v18)
          {
            cgetclose();
            *__error() = v17;
            return -1;
          }
          dbp += 8;
          if (!*(void *)dbp)
          {
            cgetclose();
            return 0;
          }
          pfp = (uint64_t)fopen(*(const char **)dbp, "r");
          if (!pfp)
          {
            cgetclose();
            return -1;
          }
        }
        v14[v20 - 1] = 0;
        if (v20 != 1) {
          break;
        }
        slash = 0;
      }
      if (!isspace_l(*v14, v10) && *v14 != 58 && *v14 != 35 && !slash) {
        break;
      }
      slash = v14[v20 - 2] == 92;
    }
    slash = v14[v20 - 2] == 92;
LABEL_37:
    int v19 = 0;
    BOOL v12 = v28;
    while (1)
    {
      for (char i = v14; *i; ++i)
      {
        if (*i == 58)
        {
          char v4 = v12++;
          *char v4 = 58;
          int v19 = 1;
          break;
        }
        if (*i == 92) {
          break;
        }
        char v5 = *i;
        BOOL v6 = v12++;
        *BOOL v6 = v5;
      }
      if (v19)
      {
        *BOOL v12 = 0;
        wctype_t v13 = v29;
        for (char i = v28; *i && *i != 124 && *i != 58; ++i)
        {
          char v7 = *i;
          uint64_t v8 = v13++;
          *uint64_t v8 = v7;
        }
        *wctype_t v13 = 0;
        int v16 = getent(v22, &v11, (const char **)v21, -1, v29, 0, 0, (uint64_t)v10);
        if (v16 == -2 || v16 == -3) {
          cgetclose();
        }
        return v16 + 1;
      }
      uint64_t v14 = fgetln((FILE *)pfp, &v20);
      if (!v14)
      {
        if (pfp) {
          break;
        }
      }
      v14[v20 - 1] = 0;
    }
    int v18 = ferror((FILE *)pfp);
    if (v18) {
      int v17 = *__error();
    }
    fclose((FILE *)pfp);
    pfp = 0;
    cgetclose();
    if (v18) {
      *__error() = v17;
    }
    return -1;
  }
  else
  {
    cgetclose();
    return -1;
  }
}

int cgetstr(char *a1, const char *a2, char **a3)
{
  int v34 = cgetcap(a1, a2, 61);
  if (!v34) {
    return -1;
  }
  __ptr = (char *)malloc_type_malloc();
  if (__ptr)
  {
    int v36 = 100;
    int v32 = __ptr;
    while (1)
    {
      BOOL v26 = 0;
      if (*v34 != 58) {
        BOOL v26 = *v34 != 0;
      }
      if (!v26) {
        break;
      }
      if (*v34 == 94)
      {
        wint_t v35 = v34 + 1;
        if (*v35 == 58 || !*v35) {
          break;
        }
        if (*v35 == 63)
        {
          char v3 = v32++;
          *char v3 = 127;
          int v34 = v35 + 1;
        }
        else
        {
          char v4 = v35;
          int v34 = v35 + 1;
          char v5 = v32++;
          *char v5 = *v4 & 0x1F;
        }
      }
      else if (*v34 == 92)
      {
        if (*++v34 == 58 || !*v34) {
          break;
        }
        if (*v34 < 48 || *v34 > 55)
        {
          uint64_t v8 = v34++;
          LODWORD(v8) = *v8;
          BOOL v9 = v8 > 0x42;
          uint64_t v10 = (v8 - 66);
          if (v9)
          {
            uint64_t v12 = v10;
            char v11 = 1;
          }
          else
          {
            uint64_t v12 = v10;
            char v11 = 0;
          }
          if ((v11 & 1) == 0)
          {
            switch(v12)
            {
              case 0:
              case 32:
                wctype_t v13 = v32++;
                *wctype_t v13 = 8;
                goto LABEL_43;
              case 1:
              case 33:
                int v19 = v32++;
                *int v19 = 58;
                goto LABEL_43;
              case 2:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
              case 13:
              case 14:
              case 15:
              case 17:
              case 19:
              case 20:
              case 21:
              case 22:
              case 23:
              case 24:
              case 25:
              case 26:
              case 27:
              case 28:
              case 29:
              case 30:
              case 31:
              case 34:
              case 37:
              case 38:
              case 39:
              case 40:
              case 41:
              case 42:
              case 43:
              case 45:
              case 46:
              case 47:
              case 49:
                break;
              case 3:
              case 35:
                int v18 = v32++;
                *int v18 = 27;
                goto LABEL_43;
              case 4:
              case 36:
                int v16 = v32++;
                *int v16 = 12;
                goto LABEL_43;
              case 12:
              case 44:
                uint64_t v15 = v32++;
                *uint64_t v15 = 10;
                goto LABEL_43;
              case 16:
              case 48:
                int v17 = v32++;
                *int v17 = 13;
                goto LABEL_43;
              case 18:
              case 50:
                uint64_t v14 = v32++;
                *uint64_t v14 = 9;
                goto LABEL_43;
              default:
                JUMPOUT(0);
            }
          }
          size_t v20 = v32++;
          char *v20 = *(v34 - 1);
        }
        else
        {
          char v29 = 0;
          int v28 = 3;
          do
          {
            BOOL v6 = v34++;
            char v29 = *v6 - 48 + 8 * v29;
            --v28;
            BOOL v25 = 0;
            if (v28)
            {
              BOOL v25 = 0;
              if (*v34 >= 48) {
                BOOL v25 = *v34 <= 55;
              }
            }
          }
          while (v25);
          char v7 = v32++;
          *char v7 = v29;
        }
      }
      else
      {
        size_t v21 = v34++;
        size_t v22 = v32++;
        *size_t v22 = *v21;
      }
LABEL_43:
      if (!--v36)
      {
        uint64_t v27 = v32 - __ptr;
        __ptr = (char *)reallocf(__ptr, v32 - __ptr + 100);
        if (!__ptr) {
          return -2;
        }
        int v36 = 100;
        int v32 = &__ptr[v27];
      }
    }
    int v23 = v32;
    int v33 = v32 + 1;
    *int v23 = 0;
    int v31 = v33 - __ptr - 1;
    if (v36 == 1 || (__ptr = (char *)reallocf(__ptr, v33 - __ptr)) != 0)
    {
      *a3 = __ptr;
      return v31;
    }
    else
    {
      return -2;
    }
  }
  else
  {
    *__error() = 12;
    return -2;
  }
}

int cgetustr(char *a1, const char *a2, char **a3)
{
  wctype_t v13 = cgetcap(a1, a2, 61);
  if (!v13) {
    return -1;
  }
  __ptr = (char *)malloc_type_malloc();
  if (__ptr)
  {
    int v14 = 100;
    char v11 = __ptr;
    while (1)
    {
      BOOL v7 = 0;
      if (*v13 != 58) {
        BOOL v7 = *v13 != 0;
      }
      if (!v7) {
        break;
      }
      char v3 = v13++;
      char v4 = v11++;
      *char v4 = *v3;
      if (!--v14)
      {
        uint64_t v8 = v11 - __ptr;
        __ptr = (char *)reallocf(__ptr, v11 - __ptr + 100);
        if (!__ptr) {
          return -2;
        }
        int v14 = 100;
        char v11 = &__ptr[v8];
      }
    }
    char v5 = v11;
    uint64_t v12 = v11 + 1;
    *char v5 = 0;
    int v10 = v12 - __ptr - 1;
    if (v14 == 1 || (__ptr = (char *)reallocf(__ptr, v12 - __ptr)) != 0)
    {
      *a3 = __ptr;
      return v10;
    }
    else
    {
      return -2;
    }
  }
  else
  {
    *__error() = 12;
    return -2;
  }
}

int cgetnum(char *a1, const char *a2, uint64_t *a3)
{
  char v4 = cgetcap(a1, a2, 35);
  if (v4)
  {
    if (*v4 == 48)
    {
      if (*++v4 == 120 || *v4 == 88)
      {
        ++v4;
        int v6 = 16;
      }
      else
      {
        int v6 = 8;
      }
    }
    else
    {
      int v6 = 10;
    }
    uint64_t v7 = 0;
    while (1)
    {
      if (*v4 < 48 || *v4 > 57)
      {
        if (*v4 < 97 || *v4 > 102)
        {
          if (*v4 < 65 || *v4 > 70)
          {
LABEL_22:
            *a3 = v7;
            return 0;
          }
          int v5 = *v4 - 55;
        }
        else
        {
          int v5 = *v4 - 87;
        }
      }
      else
      {
        int v5 = *v4 - 48;
      }
      if (v5 >= v6) {
        goto LABEL_22;
      }
      uint64_t v7 = v7 * v6 + v5;
      ++v4;
    }
  }
  return -1;
}

uint64_t cdbget(uint64_t a1, void *a2, const char *a3)
{
  uint64_t v12 = a1;
  char v11 = a2;
  int v10 = a3;
  uint64_t v8 = 0;
  size_t i = 0;
  int v6 = 0;
  uint64_t v7 = 0;
  __s = strdup(a3);
  if (__s)
  {
    uint64_t v8 = __s;
    for (size_t i = strlen(__s); ; size_t i = v7 - 1)
    {
      int v4 = (*(uint64_t (**)(uint64_t, char **, unsigned char **, void))(v12 + 24))(v12, &v8, &v6, 0);
      if (v4 == -1)
      {
        free(__s);
        return -2;
      }
      if (v4 == 1)
      {
        free(__s);
        return -1;
      }
      if (*v6 != 2) {
        break;
      }
      uint64_t v8 = v6 + 1;
    }
    *char v11 = v6 + 1;
    free(__s);
    return *v6 == 1;
  }
  else
  {
    return -2;
  }
}

uint64_t nfcmp(const char *a1, const char *a2)
{
  for (size_t i = a2; *i != 58; ++i)
    ;
  char v3 = i[1];
  *((unsigned char *)i + 1) = 0;
  LODWORD(result) = strcmp(a1, a2);
  *((unsigned char *)i + 1) = v3;
  return result;
}

char *__private_getcwd(char *a1, uint64_t a2, int a3)
{
  int v28 = a1;
  uint64_t v27 = a2;
  int v26 = a3;
  BOOL v25 = 0;
  int v24 = 0;
  dev_t v23 = 0;
  __darwin_ino64_t v22 = 0;
  int v21 = 0;
  size_t v20 = 0;
  memset(&__b, 0, sizeof(__b));
  if (v28)
  {
    size_t v16 = 0;
    if (!v27)
    {
      *__error() = 22;
      return 0;
    }
    if (v27 == 1)
    {
      *__error() = 34;
      return 0;
    }
    wctype_t v13 = &v28[v27];
  }
  else
  {
    size_t v16 = 1024;
    int v28 = (char *)malloc_type_malloc();
    if (!v28) {
      return 0;
    }
    wctype_t v13 = v28 + 1024;
  }
  if (v26)
  {
    if (!__getcwd(v28, v13 - v28)) {
      return v28;
    }
    if (*__error() == 34) {
      return 0;
    }
  }
  size_t v20 = v13 - 1;
  *(v13 - 1) = 0;
  if (stat("/", &__b)) {
    goto LABEL_79;
  }
  dev_t st_dev = __b.st_dev;
  __darwin_ino64_t st_ino = __b.st_ino;
  *__error() = 0;
  int v21 = 1;
LABEL_17:
  if (v24)
  {
    int v3 = dirfd(v24);
    if (fstat(v3, &__b)) {
      goto LABEL_79;
    }
  }
  else if (lstat(".", &__b))
  {
    goto LABEL_79;
  }
  __darwin_ino64_t v22 = __b.st_ino;
  dev_t v23 = __b.st_dev;
  if (st_dev == __b.st_dev && st_ino == v22)
  {
    *--size_t v20 = 47;
    bcopy(v20, v28, v13 - v20);
    if (v24) {
      closedir(v24);
    }
    return v28;
  }
  if (v24) {
    dirfd(v24);
  }
  int v12 = openat_NOCANCEL();
  if (v12 != -1)
  {
    if (v24) {
      closedir(v24);
    }
    int v24 = fdopendir(v12);
    if (v24 && (int v4 = dirfd(v24), !fstat(v4, &__b)))
    {
      int v14 = 0;
      if (__b.st_dev == v23)
      {
        while (1)
        {
          BOOL v25 = readdir(v24);
          if (!v25) {
            break;
          }
          if (v25->d_ino == v22)
          {
LABEL_63:
            while (1)
            {
              int v7 = v21 ? 1 : 2;
              if (v20 - v28 >= v25->d_namlen + v7) {
                break;
              }
              if (!v16)
              {
                *__error() = 34;
                goto LABEL_79;
              }
              int64_t v10 = v20 - v28;
              size_t v11 = v13 - v20;
              v16 *= 2;
              int v28 = (char *)reallocf(v28, v16);
              if (!v28) {
                goto LABEL_79;
              }
              size_t v20 = &v28[v10];
              wctype_t v13 = &v28[v16];
              bcopy(&v28[v10], &v28[v16 - v11], v11);
              size_t v20 = &v13[-v11];
            }
            if (!v21) {
              *--size_t v20 = 47;
            }
            v20 -= v25->d_namlen;
            bcopy(v25->d_name, v20, v25->d_namlen);
            int v21 = 0;
            goto LABEL_17;
          }
          if ((v25->d_name[0] != 46 || v25->d_name[1] && (v25->d_name[1] != 46 || v25->d_name[2])) && v25->d_type == 4)
          {
            int v5 = dirfd(v24);
            if (fstatat(v5, v25->d_name, &__b, 32))
            {
              if (!v14) {
                int v14 = *__error();
              }
              *__error() = 0;
            }
            else if (__b.st_dev == v23 && __b.st_ino == v22)
            {
              goto LABEL_63;
            }
          }
        }
      }
      else
      {
        while (1)
        {
          BOOL v25 = readdir(v24);
          if (!v25) {
            break;
          }
          if (v25->d_name[0] != 46 || v25->d_name[1] && (v25->d_name[1] != 46 || v25->d_name[2]))
          {
            int v6 = dirfd(v24);
            if (fstatat(v6, v25->d_name, &__b, 32))
            {
              if (!v14) {
                int v14 = *__error();
              }
              *__error() = 0;
            }
            else if (__b.st_dev == v23 && __b.st_ino == v22)
            {
              goto LABEL_63;
            }
          }
        }
      }
      if (!*__error())
      {
        if (v14) {
          int v9 = v14;
        }
        else {
          int v9 = 2;
        }
        *__error() = v9;
      }
    }
    else
    {
      close_NOCANCEL();
    }
  }
LABEL_79:
  int v15 = *__error();
  if (v16) {
    free(v28);
  }
  if (v24) {
    closedir(v24);
  }
  *__error() = v15;
  return 0;
}

uint64_t __getcwd(char *a1, size_t a2)
{
  size_t v16 = a1;
  size_t v15 = a2;
  int __c = 0;
  int v14 = 0;
  unsigned int v13 = 0;
  int v12 = 0;
  __leint n = 144;
  memset(&v11, 0, sizeof(v11));
  memset(&v10, 0, sizeof(v10));
  int v9 = 0;
  int v14 = open_NOCANCEL();
  if (v14 >= 0)
  {
    if (fstat(v14, &v11) >= 0)
    {
      if (v11.st_dev && v11.st_ino)
      {
        if (v15 >= 0x400)
        {
          int v9 = v16;
        }
        else
        {
          int v5 = v3;
          bzero(v3, 0x400uLL);
          int v9 = v5;
          if (!v5)
          {
            close_NOCANCEL();
            *__error() = 12;
            return -1;
          }
        }
        unsigned int v13 = fcntl_NOCANCEL();
        if (v13)
        {
          int v12 = *__error();
          close_NOCANCEL();
          int v4 = v12;
          *__error() = v4;
          return v13;
        }
        else
        {
          close_NOCANCEL();
          if (stat(v9, &v10) >= 0)
          {
            if (v11.st_dev == v10.st_dev && v11.st_ino == v10.st_ino)
            {
              if (v15 < 0x400)
              {
                if (strlen(v9) >= v15)
                {
                  *__error() = 34;
                  return -1;
                }
                strcpy(v16, v9);
              }
              return 0;
            }
            *__error() = 22;
            return -1;
          }
          else
          {
            return -1;
          }
        }
      }
      else
      {
        close_NOCANCEL();
        *__error() = 22;
        return -1;
      }
    }
    else
    {
      int v12 = *__error();
      close_NOCANCEL();
      int v6 = v12;
      *__error() = v6;
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return __private_getcwd(a1, a2, 1);
}

int gethostname(char *a1, size_t a2)
{
  mbstate_t __dst = a1;
  __int n = a2;
  v8[0] = 1;
  v8[1] = 10;
  if (a2 < 0x101)
  {
    size_t v3 = 257;
    if (sysctl(v8, 2u, __src, &v3, 0, 0) == -1)
    {
      if (*__error() == 12) {
        *__error() = 63;
      }
      return -1;
    }
    strncpy(__dst, __src, __n);
    __dst[__n - 1] = 0;
    return 0;
  }
  if (sysctl(v8, 2u, __dst, &__n, 0, 0) != -1) {
    return 0;
  }
  if (*__error() == 12) {
    *__error() = 63;
  }
  return -1;
}

int getmntinfo(statfs **a1, int a2)
{
  int result = getmntinfo_internal((uint64_t)getmntinfo_vars, a2);
  *a1 = (statfs *)getmntinfo_vars[0];
  return result;
}

uint64_t getmntinfo_internal(uint64_t a1, int a2)
{
  if (*(int *)(a1 + 8) > 0 || (int v2 = getfsstat(0, 0, 2), *(_DWORD *)(a1 + 8) = v2, v2 >= 0))
  {
    if (*(uint64_t *)(a1 + 16) <= 0
      || (int v3 = getfsstat(*(statfs **)a1, *(void *)(a1 + 16), a2), *(_DWORD *)(a1 + 8) = v3, v3 >= 0))
    {
      while (*(void *)(a1 + 16) <= (unint64_t)(2168 * *(int *)(a1 + 8)))
      {
        if (*(void *)a1) {
          free(*(void **)a1);
        }
        *(void *)(a1 + 16) = 2168 * (*(_DWORD *)(a1 + 8) + 1);
        uint64_t v4 = malloc_type_malloc();
        *(void *)a1 = v4;
        if (!v4) {
          return 0;
        }
        int v5 = getfsstat(*(statfs **)a1, *(void *)(a1 + 16), a2);
        *(_DWORD *)(a1 + 8) = v5;
        if (v5 < 0) {
          return 0;
        }
      }
      return *(unsigned int *)(a1 + 8);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

int getmntinfo_r_np(statfs **a1, int a2)
{
  int v7 = a1;
  int v6 = a2;
  memset(v5, 0, sizeof(v5));
  int v4 = getmntinfo_internal((uint64_t)v5, a2);
  if (v4)
  {
    *int v7 = (statfs *)v5[0];
  }
  else
  {
    int v3 = *__error();
    free(v5[0]);
    *__error() = v3;
  }
  return v4;
}

int getpagesize(void)
{
  size_t v1 = 0;
  if (getpagesize_value) {
    return getpagesize_value;
  }
  v3[0] = 6;
  v3[1] = 7;
  size_t v1 = 4;
  if (sysctl(v3, 2u, &getpagesize_value, &v1, 0, 0) != -1) {
    return getpagesize_value;
  }
  else {
    return -1;
  }
}

int getpeereid(int a1, uid_t *a2, gid_t *a3)
{
  int v9 = a1;
  uint64_t v8 = a2;
  int v7 = a3;
  memset(__b, 0, sizeof(__b));
  socklen_t v5 = 76;
  int v4 = getsockopt(v9, 0, 1, __b, &v5);
  if (v4) {
    return v4;
  }
  if (__b[0])
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    *uint64_t v8 = __b[1];
    *int v7 = __b[3];
    return 0;
  }
}

const char *getprogname(void)
{
  return *_NSGetProgname();
}

int isatty(int a1)
{
  int v4 = a1;
  BOOL v3 = 0;
  int v2 = 0;
  memset(&__b, 0, sizeof(__b));
  if (ioctl(v4, 0x4004667AuLL, &v2) == -1)
  {
    LOBYTE(v3) = tcgetattr(v4, &__b) != -1;
    return v3;
  }
  else
  {
    BOOL v3 = v2 == 3;
    if (v2 != 3) {
      *__error() = 25;
    }
  }
  return v3;
}

uint64_t jrand48(unsigned __int16 a1[3])
{
  unint64_t v2 = (*a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32)) * _rand48_mult + _rand48_add;
  *(_DWORD *)a1 = (*a1 + (a1[1] << 16)) * _rand48_mult + _rand48_add;
  a1[2] = WORD2(v2);
  return (int)(v2 >> 16);
}

void lcong48(unsigned __int16 a1[7])
{
  _rand48_seed = *a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32);
  _rand48_mult = a1[3] + ((unint64_t)a1[4] << 16) + ((unint64_t)a1[5] << 32);
  _rand48_add = a1[6];
}

uint64_t lockf_NOCANCEL(uint64_t a1, unsigned int a2)
{
  if (a2)
  {
    uint64_t v3 = a2;
    char v2 = 1;
  }
  else
  {
    uint64_t v3 = 0;
    char v2 = 0;
  }
  if (v2)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    switch(v3)
    {
      case 0:
      case 1:
      case 2:
        unsigned int v5 = __fcntl_nocancel();
        break;
      case 3:
        if (__fcntl_nocancel() == -1)
        {
          unsigned int v5 = -1;
        }
        else if (getpid())
        {
          *__error() = 35;
          unsigned int v5 = -1;
        }
        else
        {
          unsigned int v5 = 0;
        }
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v5;
}

uint64_t lrand48(void)
{
  _rand48_seed = _rand48_seed * _rand48_mult + _rand48_add;
  return ((unint64_t)_rand48_seed >> 17) & 0x7FFFFFFF;
}

uint64_t mrand48(void)
{
  _rand48_seed = _rand48_seed * _rand48_mult + _rand48_add;
  return (int)((unint64_t)_rand48_seed >> 16);
}

int nice(int a1)
{
  *__error() = 0;
  int v4 = getpriority(0, 0);
  if (v4 == -1 && *__error()) {
    return -1;
  }
  if (v4 + a1 > 19) {
    a1 = 19 - v4;
  }
  int v3 = setpriority(0, 0, v4 + a1);
  if (v3 == -1 && *__error() == 13) {
    *__error() = 1;
  }
  if (v3 == -1) {
    return -1;
  }
  else {
    return getpriority(0, 0);
  }
}

uint64_t nrand48(unsigned __int16 a1[3])
{
  unint64_t v2 = (*a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32)) * _rand48_mult + _rand48_add;
  *(_DWORD *)a1 = (*a1 + (a1[1] << 16)) * _rand48_mult + _rand48_add;
  a1[2] = WORD2(v2);
  return (v2 >> 17) & 0x7FFFFFFF;
}

DIR *__cdecl opendir(const char *a1)
{
  return __opendir2(a1, 3);
}

DIR *__cdecl __opendir2(const char *a1, int a2)
{
  if ((a2 & 0x18) != 0) {
    return 0;
  }
  int v4 = open_NOCANCEL();
  if (v4 == -1) {
    return 0;
  }
  *(void *)&v3[4] = __opendir_common(v4, a2, 0);
  if (!*(void *)&v3[4])
  {
    *(void *)int v3 = *__error();
    close_NOCANCEL();
    *__error() = *(_DWORD *)v3;
  }
  return *(DIR **)&v3[4];
}

DIR *__cdecl fdopendir(int a1)
{
  int v3 = a1;
  memset(&__b, 0, sizeof(__b));
  if (fstat(v3, &__b)) {
    return 0;
  }
  if ((__b.st_mode & 0xF000) == 0x4000)
  {
    if (fcntl_NOCANCEL() == -1) {
      return 0;
    }
    else {
      return (DIR *)__opendir_common(v3, 3, 1);
    }
  }
  else
  {
    *__error() = 20;
    return 0;
  }
}

char *__opendir_common(int a1, int a2, char a3)
{
  char v8 = a3 & 1;
  int v7 = (char *)malloc_type_malloc();
  if (v7)
  {
    *((void *)v7 + 3) = 0;
    *(_DWORD *)int v7 = a1;
    *((_DWORD *)v7 + 14) = a2;
    *((void *)v7 + 1) = 0;
    memset(__b, 0, sizeof(__b));
    __b[0] = 850045863;
    memcpy(v7 + 64, __b, 0x40uLL);
    *((void *)v7 + 16) = v7 + 136;
    **((void **)v7 + 16) = 0;
    *(void *)(*((void *)v7 + 16) + 8) = 0;
    if ((a2 & 2) != 0 && __kernel_supports_unionfs())
    {
      int v5 = __fd_is_on_union_mount(a1);
      if (v5 < 0) {
        goto LABEL_24;
      }
    }
    else
    {
      int v5 = 0;
    }
    if (v5)
    {
      if (_filldir((uint64_t)v7, v8 & 1))
      {
        *((_DWORD *)v7 + 14) |= 8u;
        return v7;
      }
    }
    else
    {
      *((_DWORD *)v7 + 8) = 2048;
      *((void *)v7 + 3) = malloc_type_malloc();
      if (*((void *)v7 + 3))
      {
        if ((v8 & 1) == 0)
        {
          *((void *)v7 + 2) = 0;
          *(void *)(*((void *)v7 + 16) + 16) = 0;
          return v7;
        }
        int v4 = (_DWORD *)(*((void *)v7 + 3) + *((int *)v7 + 8) - 4);
        *int v4 = 0;
        *((void *)v7 + 2) = __getdirentries64();
        if (*((uint64_t *)v7 + 2) >= 0
          && *((void *)v7 + 2) <= (unint64_t)(*((int *)v7 + 8) - 4)
          && (*v4 & 1) != 0)
        {
          *((_DWORD *)v7 + 14) |= 0x20u;
        }
        if (*((uint64_t *)v7 + 2) >= 0)
        {
          *((_DWORD *)v7 + 14) |= 0x10u;
          return v7;
        }
        if (*__error() == 22) {
          *__error() = 20;
        }
      }
    }
LABEL_24:
    int v6 = *__error();
    free(*((void **)v7 + 3));
    free(v7);
    *__error() = v6;
    return 0;
  }
  return 0;
}

uint64_t _filldir(uint64_t a1, char a2)
{
  char v20 = a2 & 1;
  int __nel_4 = 0;
  int v6 = 0;
  int v18 = 0;
  size_t v16 = 0;
  int v12 = getpagesize();
  if (v12 % 1024) {
    int v12 = 1024;
  }
  int v13 = openat_NOCANCEL();
  if (v13 == -1)
  {
    char v22 = 0;
  }
  else
  {
    if ((v20 & 1) == 0 || (off_t v14 = lseek(*(_DWORD *)a1, 0, 1), v14 != -1) && lseek(v13, v14, 0) != -1)
    {
      while (1)
      {
        if (v6 < 1024)
        {
          v6 += v12;
          __nel_4 += v12;
          int v18 = (char *)reallocf(v18, __nel_4);
          if (!v18) {
            break;
          }
          size_t v16 = &v18[__nel_4 - v6];
        }
        int __nel = __getdirentries64();
        if (__nel > 0)
        {
          v16 += __nel;
          v6 -= __nel;
        }
        if (__nel < 0) {
          break;
        }
        if (__nel <= 0)
        {
          close_NOCANCEL();
          size_t v15 = v16;
          *(void *)(a1 + 24) = v18;
          int v19 = 0;
          while (1)
          {
            int __nela = 0;
            int v17 = v18;
            while (v17 < v15)
            {
              int v5 = v17;
              if ((v17 & 3) != 0
                || !*((_WORD *)v17 + 8)
                || *((unsigned __int16 *)v17 + 8) > v15 + 1 - v17)
              {
                break;
              }
              v17 += *((unsigned __int16 *)v17 + 8);
              if (*v5)
              {
                if (v19) {
                  v19[__nela] = v5;
                }
                ++__nela;
              }
            }
            if (v19) {
              break;
            }
            int v19 = (void *)malloc_type_malloc();
            if (!v19) {
              goto LABEL_42;
            }
          }
          mergesort(v19, __nela, 8uLL, (int (__cdecl *)(const void *, const void *))opendir_compar);
          v19[__nela] = 0;
          uint64_t v4 = 0;
          for (int __nelb = 0; v19[__nelb]; ++__nelb)
          {
            uint64_t v3 = v19[__nelb];
            if (v4 && !strcmp((const char *)(v3 + 21), (const char *)(v4 + 21))) {
              *(void *)uint64_t v3 = 0;
            }
            else {
              uint64_t v4 = v3;
            }
            if (*(unsigned char *)(v3 + 20) == 14 && (*(_DWORD *)(a1 + 56) & 1) != 0) {
              *(void *)uint64_t v3 = 0;
            }
          }
          free(v19);
LABEL_42:
          *(_DWORD *)(a1 + 32) = __nel_4;
          *(void *)(a1 + 16) = &v17[-*(void *)(a1 + 24)];
          char v22 = 1;
          return v22 & 1;
        }
      }
    }
    int v7 = *__error();
    close_NOCANCEL();
    *__error() = v7;
    char v22 = 0;
  }
  return v22 & 1;
}

uint64_t opendir_compar(uint64_t a1, uint64_t a2)
{
  return strcmp((const char *)(*(void *)a1 + 21), (const char *)(*(void *)a2 + 21));
}

BOOL __kernel_supports_unionfs()
{
  if (__kernel_supports_unionfs_kernel_supports_unionfs == -1)
  {
    int v2 = 0;
    size_t v1 = 4;
    sysctlbyname("kern.secure_kernel", &v2, &v1, 0, 0);
    __kernel_supports_unionfs_kernel_supports_unionfs = v2 == 0;
  }
  return __kernel_supports_unionfs_kernel_supports_unionfs != 0;
}

uint64_t __fd_is_on_union_mount(int a1)
{
  bzero(&v5, 0x200uLL);
  int v2 = fstatfs(a1, &v5);
  if (v2 >= 0) {
    return (v5.f_flags & 0x20) != 0;
  }
  else {
    return v2;
  }
}

uint64_t pause_NOCANCEL()
{
  sigset_t v1 = 0;
  sigprocmask(0, 0, &v1);
  return sigsuspend_NOCANCEL();
}

FILE *__cdecl popen(const char *a1, const char *a2)
{
  int v13 = a1;
  int v12 = a2;
  stat v11 = 0;
  stat v10 = 0;
  pid_t v9 = 0;
  int v8 = 0;
  int v7 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t i = 0;
  posix_spawn_file_actions_t v5 = 0;
  libc_hooks_will_read_cstring((uint64_t)a1);
  libc_hooks_will_read_cstring((uint64_t)v12);
  if (!v12)
  {
LABEL_2:
    *__error() = 22;
    return 0;
  }
  if (!strcmp(v12, "r+"))
  {
    int v8 = 1;
    int v12 = "r+";
    if (socketpair(1, 1, 0, &v17) < 0) {
      return 0;
    }
  }
  else
  {
    int v8 = 0;
    if (*v12 != 114 && *v12 != 119 || v12[1]) {
      goto LABEL_2;
    }
    if (pipe(&v17) < 0) {
      return 0;
    }
  }
  if (*v12 == 114)
  {
    stat v10 = fdopen(v17, v12);
    int v7 = v18;
  }
  else
  {
    stat v10 = fdopen(v18, v12);
    int v7 = v17;
  }
  if (v10)
  {
    stat v11 = (void *)malloc_type_malloc();
    if (v11)
    {
      int v4 = posix_spawn_file_actions_init(&v5);
      if (v4) {
        goto LABEL_21;
      }
      if (*v12 == 114)
      {
        posix_spawn_file_actions_addclose(&v5, v17);
        if (v18 == 1)
        {
          if (v8) {
            posix_spawn_file_actions_adddup2(&v5, v18, 0);
          }
        }
        else
        {
          posix_spawn_file_actions_adddup2(&v5, v18, 1);
          posix_spawn_file_actions_addclose(&v5, v18);
          if (v8) {
            posix_spawn_file_actions_adddup2(&v5, 1, 0);
          }
        }
      }
      else
      {
        if (v17)
        {
          posix_spawn_file_actions_adddup2(&v5, v17, 0);
          posix_spawn_file_actions_addclose(&v5, v17);
        }
        posix_spawn_file_actions_addclose(&v5, v18);
      }
      pthread_mutex_lock(&__popen_pidlist_mutex);
      for (uint64_t i = __popen_pidlist; i; uint64_t i = *(void *)i)
        posix_spawn_file_actions_addclose(&v5, *(_DWORD *)(i + 16));
      *(void *)&long long v15 = "sh";
      *((void *)&v15 + 1) = "-c";
      long long v16 = (unint64_t)v13;
      int v2 = _NSGetEnviron();
      int v4 = posix_spawn(&v9, "/bin/sh", &v5, 0, (char *const *)&v15, *v2);
      pthread_mutex_unlock(&__popen_pidlist_mutex);
      posix_spawn_file_actions_destroy(&v5);
      if (v4 == 12 || v4 == 35)
      {
LABEL_21:
        fclose(v10);
        close_NOCANCEL();
        free(v11);
        *__error() = v4;
        return 0;
      }
      else
      {
        if (v4) {
          pid_t v9 = -1;
        }
        if (*v12 == 114) {
          *((_DWORD *)v11 + 4) = v17;
        }
        else {
          *((_DWORD *)v11 + 4) = v18;
        }
        close_NOCANCEL();
        v11[1] = v10;
        *((_DWORD *)v11 + 5) = v9;
        pthread_mutex_lock(&__popen_pidlist_mutex);
        *stat v11 = __popen_pidlist;
        __popen_pidlist = (uint64_t)v11;
        pthread_mutex_unlock(&__popen_pidlist_mutex);
        fwide(v10, -1);
        return v10;
      }
    }
    else
    {
      fclose(v10);
      close_NOCANCEL();
      return 0;
    }
  }
  else
  {
    close_NOCANCEL();
    close_NOCANCEL();
    return 0;
  }
}

uint64_t libc_hooks_will_read_cstring(uint64_t result)
{
  sigset_t v1 = 0;
  if (off_F5428) {
    sigset_t v1 = off_F5428;
  }
  if (v1) {
    return off_F5428(result);
  }
  return result;
}

int pclose(FILE *a1)
{
  int v8 = a1;
  int v6 = 0;
  int v5 = 0;
  libc_hooks_will_read((uint64_t)a1, 152);
  pthread_mutex_lock(&__popen_pidlist_mutex);
  for (uint64_t i = (void *)__popen_pidlist; i && *((FILE **)i + 1) != v8; uint64_t i = *(void **)i)
    int v6 = (void **)i;
  if (i)
  {
    if (v6) {
      *int v6 = (void *)**v6;
    }
    else {
      __popen_pidlist = *(void *)__popen_pidlist;
    }
    pthread_mutex_unlock(&__popen_pidlist_mutex);
    fclose(v8);
    if (*((int *)i + 5) >= 0)
    {
      do
      {
        pid_t v4 = wait4(*((_DWORD *)i + 5), &v5, 0, 0);
        BOOL v3 = 0;
        if (v4 == -1) {
          BOOL v3 = *__error() == 4;
        }
      }
      while (v3);
      free(i);
      if (v4 == -1) {
        return -1;
      }
      else {
        return v5;
      }
    }
    else
    {
      free(i);
      return 32512;
    }
  }
  else
  {
    pthread_mutex_unlock(&__popen_pidlist_mutex);
    return -1;
  }
}

uint64_t libc_hooks_will_read(uint64_t result, uint64_t a2)
{
  int v2 = 0;
  if (off_F5420) {
    int v2 = off_F5420;
  }
  if (v2) {
    return off_F5420(result, a2);
  }
  return result;
}

void psignal(unsigned int a1, const char *a2)
{
  if (a1 >= 0x20) {
    int v2 = "Unknown signal";
  }
  else {
    int v2 = sys_siglist[a1];
  }
  if (a2 && *a2)
  {
    strlen(a2);
    write_NOCANCEL();
    write_NOCANCEL();
  }
  strlen(v2);
  write_NOCANCEL();
  write_NOCANCEL();
}

uint64_t _readdir_unlocked(uint64_t a1, int a2)
{
  uint64_t v5 = 0;
  do
  {
    if (*(void *)(a1 + 8) >= *(void *)(a1 + 16))
    {
      if ((*(_DWORD *)(a1 + 56) & 0x28) != 0) {
        return 0;
      }
      uint64_t v5 = *(void *)(a1 + 8);
      *(_DWORD *)(a1 + 56) &= ~0x10u;
      *(void *)(a1 + 8) = 0;
    }
    if (!*(void *)(a1 + 8) && (*(_DWORD *)(a1 + 56) & 0x38) == 0)
    {
      if (*(_DWORD *)(a1 + 32) == 2048)
      {
        uint64_t v4 = malloc_type_malloc();
        if (v4)
        {
          free(*(void **)(a1 + 24));
          *(void *)(a1 + 24) = v4;
          *(_DWORD *)(a1 + 32) = 0x2000;
        }
      }
      BOOL v3 = (_DWORD *)(*(void *)(a1 + 24) + *(int *)(a1 + 32) - 4);
      *BOOL v3 = 0;
      uint64_t v6 = *(void *)(*(void *)(a1 + 128) + 16);
      *(void *)(a1 + 16) = __getdirentries64();
      if (*(uint64_t *)(a1 + 16) >= 0
        && *(void *)(a1 + 16) <= (unint64_t)(*(int *)(a1 + 32) - 4)
        && (*v3 & 1) != 0)
      {
        *(_DWORD *)(a1 + 56) |= 0x20u;
      }
      if (*(uint64_t *)(a1 + 16) <= 0) {
        return 0;
      }
      _fixtelldir(a1, v6, v5);
    }
    *(_DWORD *)(a1 + 56) &= ~0x10u;
    uint64_t v7 = *(void *)(a1 + 24) + *(void *)(a1 + 8);
    if ((v7 & 3) != 0) {
      return 0;
    }
    if (!*(_WORD *)(v7 + 16) || *(unsigned __int16 *)(v7 + 16) > *(_DWORD *)(a1 + 32) + 1 - *(void *)(a1 + 8)) {
      return 0;
    }
    *(void *)(a1 + 8) += *(unsigned __int16 *)(v7 + 16);
  }
  while (!*(void *)v7 && a2 || *(unsigned char *)(v7 + 20) == 14 && (*(_DWORD *)(a1 + 56) & 1) != 0);
  return v7;
}

dirent *__cdecl readdir(DIR *a1)
{
  pthread_mutex_lock(&a1->__dd_lock);
  int v2 = (dirent *)_readdir_unlocked((uint64_t)a1, 1);
  pthread_mutex_unlock(&a1->__dd_lock);
  return v2;
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  int v4 = *__error();
  *__error() = 0;
  pthread_mutex_lock(&a1->__dd_lock);
  uint64_t __src = (unsigned __int16 *)_readdir_unlocked((uint64_t)a1, 1);
  if (__src) {
    memcpy(a2, __src, (__src[9] + 25) & 0xFFFFFFFFFFFFFFFCLL);
  }
  pthread_mutex_unlock(&a1->__dd_lock);
  if (*__error())
  {
    if (!__src) {
      return *__error();
    }
  }
  else
  {
    *__error() = v4;
  }
  if (__src) {
    *a3 = a2;
  }
  else {
    *a3 = 0;
  }
  return 0;
}

void rewinddir(DIR *a1)
{
  a1->__dd_flags &= 0xFFFFFFCF;
  if ((a1->__dd_flags & 8) != 0)
  {
    _filldir((uint64_t)a1, 0);
  }
  else
  {
    lseek(a1->__dd_fd, 0, 0);
    *((void *)a1->__dd_td + 2) = 0;
  }
  a1->__dd_loc = 0;
  _reclaim_telldir((uint64_t)a1);
  pthread_mutex_unlock(&a1->__dd_lock);
}

int scandir(const char *a1, dirent ***a2, int (__cdecl *a3)(const dirent *), int (__cdecl *a4)(const dirent **, const dirent **))
{
  size_t __nel = 0;
  uint64_t v7 = 0;
  if (a4) {
    uint64_t v7 = a4;
  }
  uint64_t v6 = 0;
  if (v7) {
    uint64_t v6 = (int (__cdecl *)(const void *, const void *))v7;
  }
  pid_t v9 = opendir(a1);
  if (!v9) {
    return -1;
  }
  unint64_t v10 = 32;
  int v12 = (void *)malloc_type_malloc();
  if (v12)
  {
    while (1)
    {
      off_t v14 = readdir(v9);
      if (!v14) {
        break;
      }
      if (!a3 || ((unsigned int (*)(dirent *))a3)(v14))
      {
        int v13 = (char *)malloc_type_malloc();
        if (!v13) {
          goto LABEL_21;
        }
        *(void *)int v13 = v14->d_ino;
        v13[20] = v14->d_type;
        *((_WORD *)v13 + 8) = v14->d_reclen;
        *((_WORD *)v13 + 9) = v14->d_namlen;
        bcopy(v14->d_name, v13 + 21, *((unsigned __int16 *)v13 + 9) + 1);
        if (__nel >= v10)
        {
          uint64_t v8 = malloc_type_realloc();
          if (!v8)
          {
            free(v13);
            goto LABEL_21;
          }
          int v12 = (void *)v8;
          v10 *= 2;
        }
        size_t v4 = __nel++;
        v12[v4] = v13;
      }
    }
    closedir(v9);
    if (__nel && v6) {
      qsort(v12, __nel, 8uLL, v6);
    }
    *a2 = (dirent **)v12;
    return __nel;
  }
  else
  {
LABEL_21:
    while (__nel)
      free((void *)v12[--__nel]);
    free(v12);
    closedir(v9);
    return -1;
  }
}

int alphasort(const dirent **a1, const dirent **a2)
{
  return strcoll((*a1)->d_name, (*a2)->d_name);
}

unsigned __int16 *__cdecl seed48(unsigned __int16 a1[3])
{
  int result = (unsigned __int16 *)&seed48_sseed;
  seed48_sseed = _rand48_seed;
  word_EA7F0 = WORD2(_rand48_seed);
  _rand48_seed = *a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32);
  _rand48_mult = 0x5DEECE66DLL;
  _rand48_add = 11;
  return result;
}

void seekdir(DIR *a1, uint64_t a2)
{
}

int sethostname(const char *a1, int a2)
{
  v4[0] = 1;
  v4[1] = 10;
  if (sysctl(v4, 2u, 0, 0, (void *)a1, a2) == -1) {
    return -1;
  }
  else {
    return 0;
  }
}

mode_t getmode(const void *a1, mode_t a2)
{
  mode_t v6 = a2;
  while (1)
  {
    int v4 = *(char *)a1;
    if (!*(unsigned char *)a1) {
      break;
    }
    switch(v4)
    {
      case '+':
        v6 |= *((_WORD *)a1 + 1);
        break;
      case '-':
        v6 &= ~*((_WORD *)a1 + 1);
        break;
      case 'X':
        if ((a2 & 0x4049) != 0) {
          v6 |= *((_WORD *)a1 + 1);
        }
        break;
      default:
        switch(v4)
        {
          case 'g':
            __int16 v5 = (v6 & 0x38) >> 3;
            break;
          case 'o':
            __int16 v5 = v6 & 7;
            break;
          case 'u':
            __int16 v5 = (v6 & 0x1C0) >> 6;
            break;
          default:
            return v6;
        }
        if (*((unsigned char *)a1 + 1))
        {
          if ((*((unsigned char *)a1 + 1) & 2) != 0) {
            __int16 v3 = 7;
          }
          else {
            __int16 v3 = v5;
          }
          if ((*((unsigned char *)a1 + 1) & 0x10) != 0) {
            v6 &= ~(*((_WORD *)a1 + 1) & (v3 << 6));
          }
          if ((*((unsigned char *)a1 + 1) & 4) != 0) {
            v6 &= ~(*((_WORD *)a1 + 1) & (8 * v3));
          }
          if ((*((unsigned char *)a1 + 1) & 8) != 0) {
            v6 &= ~(v3 & *((_WORD *)a1 + 1));
          }
        }
        if ((*((unsigned char *)a1 + 1) & 2) != 0)
        {
          if ((*((unsigned char *)a1 + 1) & 0x10) != 0) {
            v6 |= *((_WORD *)a1 + 1) & (unsigned __int16)(v5 << 6);
          }
          if ((*((unsigned char *)a1 + 1) & 4) != 0) {
            v6 |= *((_WORD *)a1 + 1) & (unsigned __int16)(8 * v5);
          }
          if ((*((unsigned char *)a1 + 1) & 8) != 0) {
            v6 |= v5 & *((_WORD *)a1 + 1);
          }
        }
        break;
    }
    a1 = (char *)a1 + 4;
  }
  return v6;
}

void *__cdecl setmode(const char *a1)
{
  int v33 = a1;
  int v32 = 0;
  int v31 = 0;
  char v30 = 0;
  __endptr = 0;
  int v28 = 0;
  uint64_t v27 = 0;
  unint64_t v26 = 0;
  sigset_t v25 = 0;
  sigset_t v24 = 0;
  int v21 = 0;
  if (!*a1) {
    return 0;
  }
  sigset_t v25 = -1;
  sigprocmask(1, &v25, &v24);
  mode_t v22 = umask(0);
  umask(v22);
  __int16 v23 = ~v22;
  sigprocmask(3, &v24, 0);
  int v19 = 8;
  int v28 = (char *)malloc_type_malloc();
  if (!v28) {
    return 0;
  }
  uint64_t v27 = v28;
  unint64_t v26 = (unint64_t)(v28 + 24);
  if (isdigit(*(unsigned __int8 *)v33))
  {
    uint64_t v18 = strtol(v33, &__endptr, 8);
    if (!*__endptr && v18 >= 0 && (v18 & 0xFFFFFFFFFFFFF000) == 0)
    {
      int v32 = (unsigned __int16)v18;
      if ((unint64_t)v28 >= v26)
      {
        int v17 = (char *)malloc_type_realloc();
        if (!v17)
        {
          if (v27) {
            free(v27);
          }
          uint64_t v27 = 0;
          return 0;
        }
        int v28 = &v17[4 * ((v28 - v27) / 4)];
        uint64_t v27 = v17;
        unint64_t v26 = (unint64_t)(v17 + 40);
      }
      int v28 = (char *)addcmd((uint64_t)v28, 61, 4095, v32, v23);
      *int v28 = 0;
      return v27;
    }
LABEL_32:
    free(v27);
    return 0;
  }
LABEL_17:
  int v31 = 0;
  while (1)
  {
    unsigned int v1 = *v33;
    BOOL v2 = v1 > 0x61;
    uint64_t v3 = v1 - 97;
    if (v2)
    {
      uint64_t v5 = v3;
      char v4 = 1;
    }
    else
    {
      uint64_t v5 = v3;
      char v4 = 0;
    }
    if (v4) {
      break;
    }
    switch(v5)
    {
      case 0:
        v31 |= 0xFFFu;
        goto LABEL_28;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
        goto LABEL_29;
      case 6:
        v31 |= 0x438u;
        goto LABEL_28;
      case 14:
        v31 |= 7u;
        goto LABEL_28;
      case 20:
        v31 |= 0x9C0u;
LABEL_28:
        ++v33;
        break;
      default:
LABEL_106:
        JUMPOUT(0);
    }
  }
  while (1)
  {
LABEL_29:
    mode_t v6 = v33++;
    LODWORD(v6) = *v6;
    char v30 = (char)v6;
    if (v6 != 43 && v30 != 45 && v30 != 61) {
      goto LABEL_32;
    }
    if (v30 == 61) {
      int v21 = 0;
    }
    int v32 = 0;
    int v20 = 0;
LABEL_36:
    unsigned int v7 = *v33;
    BOOL v2 = v7 > 0x58;
    uint64_t v8 = v7 - 88;
    if (v2)
    {
      uint64_t v10 = v8;
      char v9 = 1;
    }
    else
    {
      uint64_t v10 = v8;
      char v9 = 0;
    }
    if ((v9 & 1) == 0) {
      break;
    }
LABEL_79:
    if (v32 || v30 == 61 && !v21)
    {
      if (v30 == 61) {
        int v21 = 1;
      }
      if ((unint64_t)v28 >= v26)
      {
        v19 += 4;
        int v13 = (char *)malloc_type_realloc();
        if (!v13)
        {
          if (v27) {
            free(v27);
          }
          uint64_t v27 = 0;
          return 0;
        }
        int v28 = &v13[4 * ((v28 - v27) / 4)];
        uint64_t v27 = v13;
        unint64_t v26 = (unint64_t)&v13[4 * v19 - 8];
      }
      int v28 = (char *)addcmd((uint64_t)v28, v30, v31, v32, v23);
      int v32 = 0;
    }
    if (v20)
    {
      if ((unint64_t)v28 >= v26)
      {
        v19 += 4;
        int v12 = (char *)malloc_type_realloc();
        if (!v12)
        {
          if (v27) {
            free(v27);
          }
          uint64_t v27 = 0;
          return 0;
        }
        int v28 = &v12[4 * ((v28 - v27) / 4)];
        uint64_t v27 = v12;
        unint64_t v26 = (unint64_t)&v12[4 * v19 - 8];
      }
      int v28 = (char *)addcmd((uint64_t)v28, 88, v31, v20, v23);
    }
    if (!*v33)
    {
      *int v28 = 0;
      _sm_compress_mode(v27);
      return v27;
    }
    if (*v33 == 44)
    {
      ++v33;
      goto LABEL_17;
    }
  }
  switch(v10)
  {
    case 0:
      int v20 = 73;
      goto LABEL_100;
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 24:
    case 25:
    case 30:
      goto LABEL_79;
    case 15:
    case 23:
    case 29:
      if (!v32) {
        goto LABEL_61;
      }
      if ((unint64_t)v28 < v26) {
        goto LABEL_60;
      }
      v19 += 4;
      long long v16 = (char *)malloc_type_realloc();
      if (!v16)
      {
        if (v27) {
          free(v27);
        }
        uint64_t v27 = 0;
        return 0;
      }
      int v28 = &v16[4 * ((v28 - v27) / 4)];
      uint64_t v27 = v16;
      unint64_t v26 = (unint64_t)&v16[4 * v19 - 8];
LABEL_60:
      int v28 = (char *)addcmd((uint64_t)v28, v30, v31, v32, v23);
      int v32 = 0;
LABEL_61:
      if (v30 == 61) {
        int v21 = 1;
      }
      if (v30 != 43 || !v20) {
        goto LABEL_72;
      }
      if ((unint64_t)v28 < v26) {
        goto LABEL_71;
      }
      v19 += 4;
      long long v15 = (char *)malloc_type_realloc();
      if (!v15)
      {
        if (v27) {
          free(v27);
        }
        uint64_t v27 = 0;
        return 0;
      }
      int v28 = &v15[4 * ((v28 - v27) / 4)];
      uint64_t v27 = v15;
      unint64_t v26 = (unint64_t)&v15[4 * v19 - 8];
LABEL_71:
      int v28 = (char *)addcmd((uint64_t)v28, 88, v31, v20, v23);
      int v20 = 0;
LABEL_72:
      if ((unint64_t)v28 < v26) {
        goto LABEL_78;
      }
      v19 += 4;
      off_t v14 = (char *)malloc_type_realloc();
      if (v14)
      {
        int v28 = &v14[4 * ((v28 - v27) / 4)];
        uint64_t v27 = v14;
        unint64_t v26 = (unint64_t)&v14[4 * v19 - 8];
LABEL_78:
        int v28 = (char *)addcmd((uint64_t)v28, *v33, v31, v30, v23);
LABEL_100:
        ++v33;
        goto LABEL_36;
      }
      if (v27) {
        free(v27);
      }
      uint64_t v27 = 0;
      return 0;
    case 26:
      v32 |= 0x124u;
      goto LABEL_100;
    case 27:
      if (!v31 || (v31 & 0xFFFFFFF8) != 0) {
        v32 |= 0xC00u;
      }
      goto LABEL_100;
    case 28:
      if (!v31 || (v31 & 0xFFFFFFF8) != 0) {
        v32 |= 0x200u;
      }
      goto LABEL_100;
    case 31:
      v32 |= 0x92u;
      goto LABEL_100;
    case 32:
      v32 |= 0x49u;
      goto LABEL_100;
    default:
      goto LABEL_106;
  }
}

uint64_t addcmd(uint64_t a1, int a2, int a3, int a4, __int16 a5)
{
  uint64_t v13 = a1;
  char v12 = a2;
  switch(a2)
  {
    case '+':
    case '-':
      goto LABEL_13;
    case '=':
      *(unsigned char *)a1 = 45;
      if (a3) {
        __int16 v11 = a3;
      }
      else {
        __int16 v11 = 4095;
      }
      *(_WORD *)(a1 + 2) = v11;
      uint64_t v13 = a1 + 4;
      char v12 = 43;
      goto LABEL_13;
    case 'X':
LABEL_13:
      *(unsigned char *)uint64_t v13 = v12;
      if (a3) {
        __int16 v10 = a3;
      }
      else {
        __int16 v10 = a5;
      }
      *(_WORD *)(v13 + 2) = v10 & a4;
      return v13 + 4;
    case 'g':
    case 'o':
    case 'u':
      *(unsigned char *)a1 = a2;
      if (a3)
      {
        if ((a3 & 0x100) != 0) {
          char v5 = 16;
        }
        else {
          char v5 = 0;
        }
        if ((a3 & 0x20) != 0) {
          char v6 = 4;
        }
        else {
          char v6 = 0;
        }
        char v7 = v5 | v6;
        if ((a3 & 4) != 0) {
          char v8 = 8;
        }
        else {
          char v8 = 0;
        }
        *(unsigned char *)(a1 + 1) = v7 | v8;
        *(_WORD *)(a1 + 2) = -1;
      }
      else
      {
        *(unsigned char *)(a1 + 1) = 28;
        *(_WORD *)(a1 + 2) = a5;
      }
      switch(a4)
      {
        case '+':
          *(unsigned char *)(a1 + 1) |= 2u;
          break;
        case '-':
          *(unsigned char *)(a1 + 1) |= 1u;
          break;
        case '=':
          *(unsigned char *)(a1 + 1) |= 3u;
          break;
      }
      break;
  }
  return v13 + 4;
}

char *_sm_compress_mode(char *result)
{
  __int16 v10 = result;
  char v9 = result;
  while (1)
  {
LABEL_2:
    int v4 = *v9;
    BOOL v3 = 0;
    if (v4 != 43)
    {
      BOOL v3 = 0;
      if (v4 != 45) {
        BOOL v3 = v4 != 88;
      }
    }
    if (v3) {
      break;
    }
    int v6 = 0;
    int v7 = 0;
    int v8 = 0;
    while (1)
    {
      int v5 = *v9;
      if (v5 == 45)
      {
        v7 |= *((unsigned __int16 *)v9 + 1);
        v8 &= ~*((unsigned __int16 *)v9 + 1);
        v6 &= ~*((unsigned __int16 *)v9 + 1);
        goto LABEL_16;
      }
      if (v5 == 43)
      {
        v8 |= *((unsigned __int16 *)v9 + 1);
        v7 &= ~*((unsigned __int16 *)v9 + 1);
        v6 &= ~*((unsigned __int16 *)v9 + 1);
        goto LABEL_16;
      }
      if (v5 != 88) {
        break;
      }
      v6 |= *((unsigned __int16 *)v9 + 1) & ~v8;
LABEL_16:
      v9 += 4;
    }
    if (v7)
    {
      *__int16 v10 = 45;
      v10[1] = 0;
      *((_WORD *)v10 + 1) = v7;
      v10 += 4;
    }
    if (v8)
    {
      *__int16 v10 = 43;
      v10[1] = 0;
      *((_WORD *)v10 + 1) = v8;
      v10 += 4;
    }
    if (v6)
    {
      *__int16 v10 = 88;
      v10[1] = 0;
      *((_WORD *)v10 + 1) = v6;
      v10 += 4;
    }
  }
  unsigned int v1 = v10;
  v10 += 4;
  BOOL v2 = v9;
  v9 += 4;
  *unsigned int v1 = *v2;
  if (v4) {
    goto LABEL_2;
  }
  return result;
}

void setprogname(const char *a1)
{
  __source = strrchr(a1, 47);
  if (__source)
  {
    __sourcea = __source + 1;
    *_NSGetProgname() = __sourcea;
  }
  else
  {
    __sourcea = (char *)a1;
    *_NSGetProgname() = (char *)a1;
  }
  strlcpy(__dst, __sourcea, 0x21uLL);
  v5[0] = 1;
  v5[1] = 62;
  size_t v1 = strlen(__dst);
  sysctl(v5, 2u, 0, 0, __dst, v1);
}

int siginterrupt(int a1, int a2)
{
  int v8 = a1;
  int v7 = a2;
  v6.__sigaction_u.__sa_handler = 0;
  *(void *)&v6.sa_masint k = 0;
  int v5 = sigaction(a1, 0, &v6);
  if (v5 < 0) {
    return v5;
  }
  if (v7)
  {
    int v11 = v8;
    if (v8 <= 32) {
      int v4 = 1 << (v11 - 1);
    }
    else {
      int v4 = 0;
    }
    _sigintr |= v4;
    v6.sa_flags &= ~2u;
  }
  else
  {
    int v10 = v8;
    if (v8 <= 32) {
      int v3 = 1 << (v10 - 1);
    }
    else {
      int v3 = 0;
    }
    _sigintr &= ~v3;
    v6.sa_flags |= 2u;
  }
  return sigaction(v8, &v6, 0);
}

void (__cdecl *__cdecl signal(int a1, __sigaction_u a2))(int)
{
  return signal__(a1, a2, 1).__sa_handler;
}

__sigaction_u signal__(int a1, __sigaction_u a2, int a3)
{
  int v9 = a1;
  v8.__sa_handler = a2.__sa_handler;
  int v7 = a3;
  *(void *)&v6.sa_masint k = 0;
  v5.__sigaction_u.__sa_handler = 0;
  *(void *)&v5.sa_masint k = 0;
  v6.__sigaction_u = a2;
  int v11 = a1;
  if (a1 <= 32) {
    int v4 = 1 << (v11 - 1);
  }
  else {
    int v4 = 0;
  }
  if ((_sigintr & v4) == 0) {
    v6.sa_flags |= 2u;
  }
  if (!v7)
  {
    if ((int)_sigaction_nobind(v9, &v6, &v5) < 0) {
      return (__sigaction_u)-1;
    }
    return (__sigaction_u)v5.__sigaction_u.__sa_handler;
  }
  if (sigaction(v9, &v6, &v5) >= 0) {
    return (__sigaction_u)v5.__sigaction_u.__sa_handler;
  }
  return (__sigaction_u)-1;
}

__sigaction_u _signal_nobind(int a1, __sigaction_u a2)
{
  return signal__(a1, a2, 0);
}

uint64_t sleep_NOCANCEL(unsigned int a1)
{
  unsigned int v6 = a1;
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  if (a1 <= 0x7FFFFFFF)
  {
    uint64_t v4 = v6;
    uint64_t v5 = 0;
    if (nanosleep_NOCANCEL(&v4, &v2) == -1)
    {
      if (*__error() == 4) {
        return (v2 + (v3 != 0));
      }
      else {
        return v6;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return (v6 - 0x7FFFFFFF + sleep_NOCANCEL());
  }
}

void srand48(uint64_t a1)
{
  _rand48_seed = ((unint64_t)(unsigned __int16)a1 << 16) + 13070 + ((unint64_t)WORD1(a1) << 32);
  _rand48_mult = 0x5DEECE66DLL;
  _rand48_add = 11;
}

StringList *sl_init(void)
{
  size_t v1 = (StringList *)malloc_type_malloc();
  if (!v1) {
    err(1, "stringlist: %m");
  }
  v1->sl_cur = 0;
  v1->sl_max = 20;
  v1->sl_str = (char **)malloc_type_malloc();
  if (!v1->sl_str) {
    err(1, "stringlist: %m");
  }
  return v1;
}

int sl_add(StringList *a1, char *a2)
{
  if (a1->sl_cur == a1->sl_max - 1)
  {
    a1->sl_max += 20;
    a1->sl_str = (char **)reallocf(a1->sl_str, 8 * a1->sl_max);
    if (!a1->sl_str) {
      return -1;
    }
  }
  sl_str = a1->sl_str;
  size_t sl_cur = a1->sl_cur;
  a1->size_t sl_cur = sl_cur + 1;
  sl_str[sl_cur] = a2;
  return 0;
}

void sl_free(StringList *a1, int a2)
{
  if (a1)
  {
    if (a1->sl_str)
    {
      if (a2)
      {
        for (size_t i = 0; i < a1->sl_cur; ++i)
          free(a1->sl_str[i]);
      }
      free(a1->sl_str);
    }
    free(a1);
  }
}

char *__cdecl sl_find(StringList *a1, char *a2)
{
  for (size_t i = 0; i < a1->sl_cur; ++i)
  {
    if (!strcmp(a1->sl_str[i], a2)) {
      return a1->sl_str[i];
    }
  }
  return 0;
}

uint64_t sysconf(int a1)
{
  int v17 = a1;
  v16.rlim_cur = 0;
  v16.rlim_max = 0;
  uint64_t v15 = 0;
  size_t v14 = 0;
  int v13 = 0;
  int v12 = 0;
  uint64_t v11 = 0;
  int v9 = 0;
  uint64_t v10 = -1;
  if (a1 <= 1)
  {
    uint64_t v2 = (a1 - 1);
    char v1 = 0;
  }
  else
  {
    uint64_t v2 = (a1 - 1);
    char v1 = 1;
  }
  if (v1)
  {
LABEL_154:
    *__error() = 22;
    return -1;
  }
  else
  {
    switch(v2)
    {
      case 0:
        int v19 = 1;
        int v20 = 8;
        goto LABEL_155;
      case 1:
        if (getrlimit(7, &v16)) {
          return -1;
        }
        if (v16.rlim_cur == 0x7FFFFFFFFFFFFFFFLL) {
          return -1;
        }
        if (v16.rlim_cur <= 0x7FFFFFFFFFFFFFFFLL) {
          return v16.rlim_cur;
        }
        *__error() = 84;
        return -1;
      case 2:
        return 100;
      case 3:
        int v19 = 1;
        int v20 = 18;
        goto LABEL_155;
      case 4:
      case 25:
        if (getrlimit(8, &v16)) {
          return -1;
        }
        if (v16.rlim_cur <= 0x7FFFFFFFFFFFFFFFLL) {
          return v16.rlim_cur;
        }
        return -1;
      case 5:
        return 200112;
      case 6:
        int v19 = 1;
        int v20 = 20;
        size_t v14 = 4;
        if (sysctl(&v19, 2u, &v12, &v14, 0, 0) == -1) {
          return -1;
        }
        if (v12) {
          return v12;
        }
        return v10;
      case 7:
        int v19 = 1;
        int v20 = 17;
        goto LABEL_155;
      case 8:
        return 99;
      case 9:
        return 2048;
      case 10:
        return 99;
      case 11:
        return 1000;
      case 12:
        return 2;
      case 13:
        return 32;
      case 14:
        return 2048;
      case 15:
        return 255;
      case 16:
        return 200112;
      case 17:
        return 200112;
      case 18:
        return 200112;
      case 19:
        return 200112;
      case 20:
        return -1;
      case 21:
        return 200112;
      case 22:
        return 200112;
      case 23:
        return 200112;
      case 24:
        return 200112;
      case 26:
        int v9 = "/var/db/timezone/zoneinfo";
        goto LABEL_42;
      case 27:
        return -1;
      case 28:
        int v3 = getpagesize();
        uint64_t v10 = v3;
        return v3;
      case 29:
        return -1;
      case 30:
        return -1;
      case 31:
        return 200112;
      case 32:
        return -1;
      case 33:
        return -1;
      case 34:
        return -1;
      case 35:
        return -1;
      case 36:
        return -1;
      case 37:
        return 200112;
      case 38:
        return -1;
      case 39:
        return -1;
      case 40:
        return -1;
      case 41:
        int v19 = 1;
        int v20 = 46;
        goto LABEL_155;
      case 42:
        int v19 = 1;
        int v20 = 46;
        goto LABEL_155;
      case 43:
        return -1;
      case 44:
        return -1;
      case 45:
        return -1;
      case 46:
        return 200112;
      case 47:
        return -1;
      case 48:
        size_t v14 = 4;
        if (sysctlbyname("kern.sysv.semmns", &v12, &v14, 0, 0) == -1) {
          return -1;
        }
        else {
          return v12;
        }
      case 49:
        return 0x7FFFLL;
      case 50:
        return -1;
      case 51:
        return -1;
      case 52:
      case 53:
      case 54:
      case 116:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 136:
      case 137:
      case 138:
      case 139:
      case 140:
      case 141:
      case 142:
      case 143:
      case 144:
      case 145:
      case 146:
      case 147:
      case 148:
      case 149:
      case 150:
      case 151:
      case 152:
      case 153:
      case 154:
      case 155:
      case 156:
      case 157:
      case 158:
      case 159:
      case 160:
      case 161:
      case 162:
      case 163:
      case 164:
      case 165:
      case 166:
      case 167:
      case 168:
      case 169:
      case 170:
      case 171:
      case 172:
      case 173:
      case 174:
      case 175:
      case 176:
      case 177:
      case 178:
      case 179:
      case 180:
      case 181:
      case 182:
      case 183:
      case 184:
      case 185:
      case 186:
      case 187:
      case 188:
      case 189:
      case 190:
      case 191:
      case 192:
      case 193:
      case 194:
      case 195:
      case 196:
      case 197:
      case 198:
        goto LABEL_154;
      case 55:
        return 1024;
      case 56:
      case 57:
        int v19 = 6;
        int v20 = 3;
LABEL_155:
        size_t v14 = 4;
        if (sysctl(&v19, 2u, &v12, &v14, 0, 0) == -1) {
          int v12 = -1;
        }
        uint64_t v18 = v12;
        break;
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
        uint64_t v18 = -1;
        break;
      case 64:
        uint64_t v18 = -1;
        break;
      case 65:
        uint64_t v18 = -1;
        break;
      case 66:
        uint64_t v18 = -1;
        break;
      case 67:
        uint64_t v18 = -1;
        break;
      case 68:
      case 69:
        uint64_t v18 = 4096;
        break;
      case 70:
        uint64_t v18 = 4096;
        break;
      case 71:
        uint64_t v18 = 255;
        break;
      case 72:
        uint64_t v18 = 255;
        break;
      case 73:
        uint64_t v18 = -1;
        break;
      case 74:
        uint64_t v18 = -1;
        break;
      case 75:
        uint64_t v18 = 200112;
        break;
      case 76:
        uint64_t v18 = 200112;
        break;
      case 77:
        uint64_t v18 = 200112;
        break;
      case 78:
        uint64_t v18 = 200112;
        break;
      case 79:
        uint64_t v18 = -1;
        break;
      case 80:
        uint64_t v18 = -1;
        break;
      case 81:
        uint64_t v18 = 200112;
        break;
      case 82:
        uint64_t v18 = 200112;
        break;
      case 83:
        uint64_t v18 = -1;
        break;
      case 84:
        uint64_t v18 = 4;
        break;
      case 85:
        uint64_t v18 = 512;
        break;
      case 86:
        uint64_t v18 = -1;
        break;
      case 87:
        uint64_t v18 = -1;
        break;
      case 88:
        uint64_t v18 = -1;
        break;
      case 89:
        uint64_t v18 = 200112;
        break;
      case 90:
        uint64_t v18 = 200112;
        break;
      case 91:
        uint64_t v18 = -1;
        break;
      case 92:
        uint64_t v18 = 0x4000;
        break;
      case 93:
        uint64_t v18 = -1;
        break;
      case 94:
        uint64_t v18 = -1;
        break;
      case 95:
        uint64_t v18 = 200112;
        break;
      case 96:
        uint64_t v18 = -1;
        break;
      case 97:
        uint64_t v18 = -1;
        break;
      case 98:
        uint64_t v18 = -1;
        break;
      case 99:
        uint64_t v18 = -1;
        break;
      case 100:
        int v9 = "/";
LABEL_42:
        int v13 = *__error();
        *__error() = 0;
        uint64_t v11 = pathconf(v9, 4);
        if (v11 == -1 && *__error())
        {
          uint64_t v18 = -1;
        }
        else
        {
          *__error() = v13;
          uint64_t v18 = v11;
        }
        break;
      case 101:
        uint64_t v18 = -1;
        break;
      case 102:
        uint64_t v18 = -1;
        break;
      case 103:
        uint64_t v18 = -1;
        break;
      case 104:
        uint64_t v18 = 1;
        break;
      case 105:
        uint64_t v18 = 1;
        break;
      case 106:
        uint64_t v18 = 0x7FFFFFFFLL;
        break;
      case 107:
        uint64_t v18 = 1;
        break;
      case 108:
        uint64_t v18 = 1;
        break;
      case 109:
        uint64_t v18 = -1;
        break;
      case 110:
        uint64_t v18 = -1;
        break;
      case 111:
        uint64_t v18 = -1;
        break;
      case 112:
        int v13 = *__error();
        size_t v14 = 8;
        if (sysctlbyname("kern.sysv.shmmin", &v15, &v14, 0, 0) == -1)
        {
          *__error() = v13;
          uint64_t v18 = -1;
        }
        else
        {
          *__error() = v13;
          uint64_t v18 = 1;
        }
        break;
      case 113:
        uint64_t v18 = -1;
        break;
      case 114:
        uint64_t v18 = 1;
        break;
      case 115:
        uint64_t v18 = 600;
        break;
      case 117:
        uint64_t v18 = 200112;
        break;
      case 118:
        uint64_t v18 = -1;
        break;
      case 119:
        uint64_t v18 = 32;
        break;
      case 120:
        uint64_t v18 = 4;
        break;
      case 121:
        uint64_t v18 = -1;
        break;
      case 122:
        uint64_t v18 = -1;
        break;
      case 123:
        uint64_t v18 = 1;
        break;
      case 124:
        uint64_t v18 = 1;
        break;
      case 125:
        uint64_t v18 = 4;
        break;
      case 126:
        uint64_t v18 = 30;
        break;
      case 127:
        uint64_t v18 = 8;
        break;
      case 128:
        uint64_t v18 = 8;
        break;
      case 129:
        uint64_t v18 = 32;
        break;
      case 130:
        uint64_t v18 = 128;
        break;
      case 199:
        uint64_t v8 = 0;
        uint64_t v7 = 0;
        size_t v14 = 8;
        if (sysctlbyname("hw.memsize", &v8, &v14, 0, 0) == -1)
        {
          uint64_t v18 = -1;
        }
        else
        {
          size_t v14 = 8;
          if (sysctlbyname("hw.pagesize", &v7, &v14, 0, 0) == -1) {
            uint64_t v18 = -1;
          }
          else {
            uint64_t v18 = v8 / v7;
          }
        }
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v18;
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  if (*a1 != 8)
  {
    if (a2 != 2 || *a1 != 1 || a1[1] != 45) {
      return __sysctl();
    }
    if (a5) {
      goto LABEL_6;
    }
    if (!a3)
    {
      if (a4) {
        *a4 = 2;
      }
      return 0;
    }
    if (!a4)
    {
      *__error() = 14;
      return -1;
    }
    if (*a4 >= 2)
    {
      strcpy((char *)a3, "/");
      *a4 = 2;
      return 0;
    }
LABEL_27:
    *__error() = 12;
    return -1;
  }
  if (a5)
  {
LABEL_6:
    *__error() = 1;
    return -1;
  }
  if (a2 != 2) {
    goto LABEL_54;
  }
  if (a1[1] != 1)
  {
    if (a3 && *a4 < 4) {
      goto LABEL_27;
    }
    *a4 = 4;
    if (!a3) {
      return 0;
    }
    unsigned int v6 = a1[1];
    BOOL v7 = v6 > 2;
    uint64_t v8 = v6 - 2;
    if (v7)
    {
      uint64_t v10 = v8;
      char v9 = 1;
    }
    else
    {
      uint64_t v10 = v8;
      char v9 = 0;
    }
    if ((v9 & 1) == 0)
    {
      switch(v10)
      {
        case 0:
          *(_DWORD *)a3 = 99;
          int v12 = 0;
          break;
        case 1:
          *(_DWORD *)a3 = 2048;
          int v12 = 0;
          break;
        case 2:
          *(_DWORD *)a3 = 99;
          int v12 = 0;
          break;
        case 3:
          *(_DWORD *)a3 = 1000;
          int v12 = 0;
          break;
        case 4:
          *(_DWORD *)a3 = 2;
          int v12 = 0;
          break;
        case 5:
          *(_DWORD *)a3 = 32;
          int v12 = 0;
          break;
        case 6:
          *(_DWORD *)a3 = 2048;
          int v12 = 0;
          break;
        case 7:
          *(_DWORD *)a3 = 255;
          int v12 = 0;
          break;
        case 8:
          *(_DWORD *)a3 = 200112;
          int v12 = 0;
          break;
        case 9:
          *(_DWORD *)a3 = 0;
          int v12 = 0;
          break;
        case 10:
          *(_DWORD *)a3 = 0;
          int v12 = 0;
          break;
        case 11:
          *(_DWORD *)a3 = 0;
          int v12 = 0;
          break;
        case 12:
          *(_DWORD *)a3 = 0;
          int v12 = 0;
          break;
        case 13:
          *(_DWORD *)a3 = 0;
          int v12 = 0;
          break;
        case 14:
          *(_DWORD *)a3 = 0;
          int v12 = 0;
          break;
        case 15:
          *(_DWORD *)a3 = 0;
          int v12 = 0;
          break;
        case 16:
          *(_DWORD *)a3 = 0;
          int v12 = 0;
          break;
        case 17:
          *(_DWORD *)a3 = 20;
          int v12 = 0;
          break;
        case 18:
          *(_DWORD *)a3 = 255;
          int v12 = 0;
          break;
        default:
          JUMPOUT(0);
      }
      return v12;
    }
LABEL_54:
    *__error() = 22;
    return -1;
  }
  if (a3 && *a4 < 0x1E) {
    goto LABEL_27;
  }
  *a4 = 30;
  if (a3) {
    strcpy((char *)a3, "/usr/bin:/bin:/usr/sbin:/sbin");
  }
  return 0;
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  strlen(a1);
  int v6 = __sysctl();
  if (v6 >= 0) {
    return __sysctl();
  }
  return v6;
}

int sysctlnametomib(const char *a1, int *a2, size_t *a3)
{
  *a3 *= 4;
  strlen(a1);
  int result = __sysctl();
  *a3 /= 4uLL;
  return result;
}

uint64_t telldir(DIR *a1)
{
  pthread_mutex_lock(&a1->__dd_lock);
  for (size_t i = *(void **)a1->__dd_td; i && (i[3] != *((void *)a1->__dd_td + 2) || i[4] != a1->__dd_loc); size_t i = (void *)*i)
    ;
  if (i)
  {
LABEL_12:
    uint64_t v5 = i[2];
    pthread_mutex_unlock(&a1->__dd_lock);
    return v5;
  }
  size_t i = (void *)malloc_type_malloc();
  if (i)
  {
    dd_td = a1->__dd_td;
    uint64_t v2 = *((void *)dd_td + 1);
    *((void *)dd_td + 1) = v2 + 1;
    i[2] = v2;
    i[3] = *((void *)a1->__dd_td + 2);
    i[4] = a1->__dd_loc;
    uint64_t v3 = *(void *)a1->__dd_td;
    *size_t i = v3;
    if (v3) {
      *(void *)(*(void *)a1->__dd_td + 8) = i;
    }
    *(void *)a1->__dd_td = i;
    i[1] = a1->__dd_td;
    goto LABEL_12;
  }
  pthread_mutex_unlock(&a1->__dd_lock);
  return -1;
}

off_t _seekdir(off_t result, uint64_t a2)
{
  uint64_t v3 = result;
  for (size_t i = **(void ***)(result + 128); i && i[2] != a2; size_t i = (void *)*i)
    ;
  if (i && (i[4] != *(void *)(result + 8) || i[3] != *(void *)(*(void *)(result + 128) + 16)))
  {
    if (i[3] == *(void *)(*(void *)(result + 128) + 16))
    {
      if (!i[4]) {
        *(_DWORD *)(result + 56) |= 0x10u;
      }
      *(void *)(result + 8) = i[4];
    }
    else
    {
      int result = lseek(*(_DWORD *)result, i[3], 0);
      *(void *)(*(void *)(v3 + 128) + 16) = i[3];
      *(void *)(v3 + 8) = 0;
      *(_DWORD *)(v3 + 56) &= 0xFFFFFFCF;
      do
      {
        if (*(void *)(v3 + 8) >= i[4]) {
          break;
        }
        int result = _readdir_unlocked(v3, 0);
      }
      while (result);
    }
  }
  return result;
}

uint64_t _fixtelldir(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = **(void **)(result + 128);
  if (v3 && *(void *)(v3 + 32) == a3 && *(void *)(v3 + 24) == a2)
  {
    *(void *)(v3 + 24) = *(void *)(*(void *)(result + 128) + 16);
    *(void *)(v3 + 32) = *(void *)(result + 8);
  }
  return result;
}

void _reclaim_telldir(uint64_t a1)
{
  uint64_t v2 = **(void ***)(a1 + 128);
  while (v2)
  {
    char v1 = v2;
    uint64_t v2 = (void *)*v2;
    free(v1);
  }
  **(void **)(a1 + 128) = 0;
}

int tcgetattr(int a1, termios *a2)
{
  return ioctl(a1, 0x40487413uLL, a2);
}

int tcsetattr(int a1, int a2, const termios *a3)
{
  memset(__b, 0, sizeof(__b));
  if ((a2 & 0x10) != 0)
  {
    memcpy(__b, a3, sizeof(__b));
    __b[2] |= 1uLL;
    a3 = (const termios *)__b;
  }
  unsigned int v4 = a2 & 0xFFFFFFEF;
  if ((a2 & 0xFFFFFFEF) == 0) {
    return ioctl(a1, 0x80487414uLL, a3);
  }
  if (v4 == 1) {
    return ioctl(a1, 0x80487415uLL, a3);
  }
  if (v4 == 2) {
    return ioctl(a1, 0x80487416uLL, a3);
  }
  *__error() = 22;
  return -1;
}

int tcsetpgrp(int a1, pid_t a2)
{
  int v5 = a1;
  pid_t v4 = a2;
  pid_t v3 = 0;
  if (!isatty(a1)) {
    return -1;
  }
  pid_t v3 = v4;
  return ioctl(v5, 0x80047476uLL, &v3);
}

pid_t tcgetpgrp(int a1)
{
  int v3 = a1;
  pid_t v2 = 0;
  if (!isatty(a1)) {
    return -1;
  }
  if (ioctl(v3, 0x40047477uLL, &v2) >= 0) {
    return v2;
  }
  return -1;
}

speed_t cfgetospeed(const termios *a1)
{
  return a1->c_ospeed;
}

speed_t cfgetispeed(const termios *a1)
{
  return a1->c_ispeed;
}

int cfsetospeed(termios *a1, speed_t a2)
{
  a1->c_ospeed = a2;
  return 0;
}

int cfsetispeed(termios *a1, speed_t a2)
{
  a1->c_ispeed = a2;
  return 0;
}

int cfsetspeed(termios *a1, speed_t a2)
{
  a1->c_ospeed = a2;
  a1->c_ispeed = a2;
  return 0;
}

void cfmakeraw(termios *a1)
{
  a1->c_iflag &= 0xFFFFFFFFFFFFD801;
  a1->c_iflag |= 1uLL;
  a1->c_oflag &= ~1uLL;
  a1->c_lflag &= 0x5FBFFA61uLL;
  a1->c_cflag &= 0xFFFFFFFFFFFFECFFLL;
  a1->c_cflag |= 0xB00uLL;
  a1->c_cc[16] = 1;
  a1->c_cc[17] = 0;
}

int tcsendbreak(int a1, int a2)
{
  int v6 = a1;
  int v5 = a2;
  uint64_t v3 = 0;
  uint64_t v4 = 400000;
  if (ioctl(a1, 0x2000747BuLL, 0) == -1) {
    return -1;
  }
  select_NOCANCEL();
  if (ioctl(v6, 0x2000747AuLL, 0) == -1) {
    return -1;
  }
  else {
    return 0;
  }
}

uint64_t tcdrain_NOCANCEL(int a1)
{
  int v2 = a1;
  return ioctl(a1, 0x2000745EuLL, 0);
}

int tcflush(int a1, int a2)
{
  int v4 = a1;
  v3[1] = a2;
  v3[0] = 0;
  switch(a2)
  {
    case 1:
      v3[0] = 1;
      return ioctl(v4, 0x80047410uLL, v3);
    case 2:
      v3[0] = 2;
      return ioctl(v4, 0x80047410uLL, v3);
    case 3:
      v3[0] = 3;
      return ioctl(v4, 0x80047410uLL, v3);
  }
  *__error() = 22;
  return -1;
}

int tcflow(int a1, int a2)
{
  int v7 = a1;
  int v6 = a2;
  uint64_t v5 = (a2 - 1);
  if (a2 <= 1)
  {
    uint64_t v3 = (a2 - 1);
    char v2 = 0;
  }
  else
  {
    uint64_t v3 = (a2 - 1);
    char v2 = 1;
  }
  if (v2)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    switch(v3)
    {
      case 0:
        int v8 = ioctl(v7, 0x2000746FuLL, 0);
        break;
      case 1:
        int v8 = ioctl(v7, 0x2000746EuLL, 0);
        break;
      case 2:
        int v8 = ioctl(v7, 0x20007480uLL, 0, v5);
        break;
      case 3:
        int v8 = ioctl(v7, 0x20007481uLL, 0);
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v8;
}

time_t time(time_t *a1)
{
  uint64_t v5 = a1;
  v4.time_t tv_sec = 0;
  *(void *)&v4.tv_usec = 0;
  time_t tv_sec = 0;
  v2.__fpsr = 0;
  v2.__fpcr = 0;
  fegetenv(&v2);
  if (gettimeofday(&v4, 0) >= 0) {
    time_t tv_sec = v4.tv_sec;
  }
  else {
    time_t tv_sec = -1;
  }
  if (v5) {
    *uint64_t v5 = tv_sec;
  }
  fesetenv(&v2);
  return tv_sec;
}

clock_t times(tms *a1)
{
  timeval v4 = a1;
  memset(&__b, 0, sizeof(__b));
  v2.time_t tv_sec = 0;
  *(void *)&v2.tv_usec = 0;
  if (getrusage(0, &__b) < 0) {
    return -1;
  }
  v4->tms_umach_error_t time = 100 * __b.ru_utime.tv_sec + __b.ru_utime.tv_usec / 10000;
  v4->tms_smach_error_t time = 100 * __b.ru_stime.tv_sec + __b.ru_stime.tv_usec / 10000;
  if (getrusage(-1, &__b) < 0) {
    return -1;
  }
  v4->tms_cumach_error_t time = 100 * __b.ru_utime.tv_sec + __b.ru_utime.tv_usec / 10000;
  v4->tms_csmach_error_t time = 100 * __b.ru_stime.tv_sec + __b.ru_stime.tv_usec / 10000;
  if (gettimeofday(&v2, 0)) {
    return -1;
  }
  else {
    return 100 * v2.tv_sec + v2.tv_usec / 10000;
  }
}

char *__cdecl ttyname(int a1)
{
  return ttyname_threaded(a1);
}

char *ttyname_threaded(int a1)
{
  if (!ttyname_init)
  {
    pthread_mutex_lock(&ttyname_lock);
    if (!ttyname_init)
    {
      ttyname_key = 16;
      if (pthread_key_init_np())
      {
        int v4 = *__error();
        pthread_mutex_unlock(&ttyname_lock);
        *__error() = v4;
        return 0;
      }
      ttyname_init = 1;
    }
    pthread_mutex_unlock(&ttyname_lock);
  }
  uint64_t v5 = (char *)pthread_getspecific(ttyname_key);
  if (v5) {
    goto LABEL_20;
  }
  uint64_t v5 = (char *)malloc_type_malloc();
  if (!v5) {
    return 0;
  }
  if (!pthread_setspecific(ttyname_key, v5))
  {
LABEL_20:
    if (ttyname_r(a1, v5, 0x105uLL)) {
      return 0;
    }
    else {
      return v5;
    }
  }
  else
  {
    int v3 = *__error();
    free(v5);
    *__error() = v3;
    return 0;
  }
}

int ttyname_r(int a1, char *a2, size_t a3)
{
  int v9 = a1;
  int v8 = a2;
  size_t v7 = a3;
  memset(&__b, 0, sizeof(__b));
  if (fstat(v9, &__b) < 0) {
    return 9;
  }
  if (!isatty(v9)) {
    return 25;
  }
  if ((__b.st_mode & 0xF000) != 0x2000) {
    return 25;
  }
  if (v7 <= 6) {
    return 34;
  }
  strlcpy(v8, "/dev/", v7);
  unint64_t buf = &v8[strlen(v8)];
  int v3 = strlen(v8);
  if (devname_r(__b.st_rdev, 0x2000u, buf, (int)v7 - v3)) {
    return 0;
  }
  else {
    return 34;
  }
}

int ttyslot(void)
{
  return 0;
}

useconds_t ualarm(useconds_t a1, useconds_t a2)
{
  useconds_t v6 = a1;
  useconds_t v5 = a2;
  memset(&v4, 0, sizeof(v4));
  memset(&v3, 0, sizeof(v3));
  v4.it_interval.tv_usec = a2 % 0xF4240;
  v4.it_interval.time_t tv_sec = a2 / 0xF4240;
  v4.it_value.tv_usec = a1 % 0xF4240;
  v4.it_value.time_t tv_sec = a1 / 0xF4240;
  if (setitimer(0, &v4, &v3)) {
    return -1;
  }
  else {
    return 1000000 * LODWORD(v3.it_value.tv_sec) + v3.it_value.tv_usec;
  }
}

uint64_t ulimit(int a1, ...)
{
  va_start(va, a1);
  uint64_t v5 = va_arg(va, void);
  int v3 = a1;
  v2.rlim_cur = 0;
  v2.rlim_max = 0;
  if (a1 == 1)
  {
    if (getrlimit(1, &v2) == -1)
    {
      return -1;
    }
    else
    {
      v2.rlim_cur /= 0x200uLL;
      if (v2.rlim_cur <= 0x7FFFFFFFFFFFFFFFLL) {
        return v2.rlim_cur;
      }
      else {
        return 0x7FFFFFFFFFFFFFFFLL;
      }
    }
  }
  else if (v3 == 2)
  {
    v2.rlim_cur = v5 << 9;
    v2.rlim_max = v5 << 9;
    if (setrlimit(1, &v2) == -1) {
      return -1;
    }
    else {
      return v5;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int unvis(char *a1, int a2, int *a3, int a4)
{
  char v20 = a2;
  unsigned __int8 v18 = a2;
  if (!a1) {
    __assert_rtn("unvis", "unvis.c", 210, "cp != ((void *)0)");
  }
  if (!a3) {
    __assert_rtn("unvis", "unvis.c", 211, "astate != ((void *)0)");
  }
  unsigned __int8 v17 = *(unsigned char *)a3;
  if ((a4 & 0x1000) != 0)
  {
    if (v17)
    {
      BOOL v4 = v17 == 6 || v17 == 5;
      if (v4 || v17 == 9)
      {
        *a3 = 0;
        return 1;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return 3;
    }
  }
  else
  {
    if (v17)
    {
      uint64_t v6 = v17;
      char v5 = 1;
    }
    else
    {
      uint64_t v6 = 0;
      char v5 = 0;
    }
    if (v5)
    {
LABEL_135:
      *a3 = 0;
      return -1;
    }
    else
    {
      switch(v6)
      {
        case 0:
          *a1 = 0;
          if ((a4 & 0x800) != 0 || a2 != 92)
          {
            if ((a4 & 0x80) != 0 && a2 == 37)
            {
              *a3 = 8;
              return 3;
            }
            else if ((a4 & 0x400) != 0 && a2 == 38)
            {
              *a3 = 13;
              return 3;
            }
            else if ((a4 & 0x200) != 0 && a2 == 61)
            {
              *a3 = 10;
              return 3;
            }
            else
            {
              *a1 = a2;
              return 1;
            }
          }
          else
          {
            *a3 = 1;
            return 3;
          }
        case 1:
          if (a2 <= 0xA)
          {
            uint64_t v8 = (a2 - 10);
            char v7 = 0;
          }
          else
          {
            uint64_t v8 = (a2 - 10);
            char v7 = 1;
          }
          if ((v7 & 1) == 0)
          {
            switch(v8)
            {
              case 0:
                *a3 = 0;
                return 3;
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
              case 14:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 22:
              case 23:
              case 24:
              case 25:
              case 27:
              case 28:
              case 29:
              case 30:
              case 31:
              case 32:
              case 33:
              case 34:
              case 35:
              case 36:
              case 37:
              case 46:
              case 47:
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 58:
              case 60:
              case 61:
              case 62:
              case 63:
              case 64:
              case 65:
              case 66:
              case 68:
              case 69:
              case 70:
              case 71:
              case 72:
              case 73:
              case 74:
              case 75:
              case 76:
              case 77:
              case 78:
              case 79:
              case 80:
              case 81:
              case 83:
              case 85:
              case 86:
              case 89:
              case 90:
              case 91:
              case 93:
              case 94:
              case 95:
              case 96:
              case 97:
              case 98:
              case 99:
              case 101:
              case 102:
              case 103:
              case 107:
              case 109:
                break;
              case 26:
                *a3 = 0;
                return 3;
              case 38:
              case 39:
              case 40:
              case 41:
              case 42:
              case 43:
              case 44:
              case 45:
                *a1 = a2 - 48;
                *a3 = 5;
                return 3;
              case 59:
                *a1 = 27;
                *a3 = 0;
                return 1;
              case 67:
                *a1 = 0x80;
                *a3 = 2;
                return 3;
              case 82:
                *a1 = a2;
                *a3 = 0;
                return 1;
              case 84:
                *a3 = 4;
                return 3;
              case 87:
                *a1 = 7;
                *a3 = 0;
                return 1;
              case 88:
                *a1 = 8;
                *a3 = 0;
                return 1;
              case 92:
                *a1 = 12;
                *a3 = 0;
                return 1;
              case 100:
                *a1 = 10;
                *a3 = 0;
                return 1;
              case 104:
                *a1 = 13;
                *a3 = 0;
                return 1;
              case 105:
                *a1 = 32;
                *a3 = 0;
                return 1;
              case 106:
                *a1 = 9;
                *a3 = 0;
                return 1;
              case 108:
                *a1 = 11;
                *a3 = 0;
                return 1;
              case 110:
                *a3 = 7;
                return 3;
              default:
                goto LABEL_137;
            }
          }
          if (!isgraph(a2)) {
            goto LABEL_135;
          }
          *a1 = v20;
          *a3 = 0;
          return 1;
        case 2:
          if (a2 == 45)
          {
            *a3 = 3;
          }
          else
          {
            if (a2 != 94) {
              goto LABEL_135;
            }
            *a3 = 4;
          }
          return 3;
        case 3:
          *a3 = 0;
          *a1 |= a2;
          return 1;
        case 4:
          if (a2 == 63) {
            *a1 |= 0x7Fu;
          }
          else {
            *a1 |= a2 & 0x1F;
          }
          *a3 = 0;
          return 1;
        case 5:
          if (a2 < 0x30u || a2 > 0x37u)
          {
            *a3 = 0;
            return 2;
          }
          else
          {
            *a1 = a2 - 48 + 8 * *a1;
            *a3 = 6;
            return 3;
          }
        case 6:
          *a3 = 0;
          if (a2 < 0x30u || a2 > 0x37u) {
            return 2;
          }
          *a1 = a2 - 48 + 8 * *a1;
          return 1;
        case 7:
          if (isxdigit(a2)) {
            goto LABEL_77;
          }
          goto LABEL_135;
        case 8:
LABEL_77:
          if (isxdigit(v18))
          {
            if (isdigit(v18)) {
              LOBYTE(v14) = v18 - 48;
            }
            else {
              int v14 = tolower(v18) - 87;
            }
            *a1 = v14;
            *a3 = 9;
            return 3;
          }
          else
          {
            *a3 = 0;
            return 2;
          }
        case 9:
          *a3 = 0;
          if (!isxdigit(a2)) {
            return 2;
          }
          if (isdigit(v18)) {
            LOBYTE(v13) = v18 - 48;
          }
          else {
            int v13 = tolower(v18) - 87;
          }
          *a1 = v13 | (16 * *a1);
          return 1;
        case 10:
          if (a2 == 10 || a2 == 13)
          {
            *a3 = 12;
            return 3;
          }
          if (!isxdigit(a2) || !isdigit(v18) && !isupper(v18)) {
            goto LABEL_135;
          }
          if (isdigit(v18)) {
            char v12 = v18 - 48;
          }
          else {
            char v12 = v18 - 55;
          }
          *a1 = v12;
          *a3 = 11;
          return 3;
        case 11:
          if (!isxdigit(a2) || !isdigit(v18) && !isupper(v18)) {
            goto LABEL_135;
          }
          *a3 = 0;
          if (isdigit(v18)) {
            char v11 = v18 - 48;
          }
          else {
            char v11 = v18 - 55;
          }
          *a1 = v11 | (16 * *a1);
          return 1;
        case 12:
          if (a2 == 10 || a2 == 13) {
            return 3;
          }
          if (a2 == 61)
          {
            *a3 = 10;
            return 3;
          }
          else
          {
            *a1 = a2;
            *a3 = 0;
            return 1;
          }
        case 13:
          *a1 = 0;
          if (a2 == 35)
          {
            *a3 = 14;
            return 3;
          }
          *a3 = 15;
LABEL_117:
          unsigned __int8 v16 = *a1;
          unsigned __int8 v15 = HIBYTE(*a3);
          if (v15) {
            unsigned __int8 v10 = nv[8 * v16 - 1 + v15];
          }
          else {
            unsigned __int8 v10 = 0;
          }
          if (a2 == 59) {
            unsigned __int8 v18 = 0;
          }
          while (v16 < 0x64uLL)
          {
            if (v15 && nv[8 * v16 - 1 + v15] != v10) {
              goto LABEL_135;
            }
            if (nv[8 * v16 + v15] != v18)
            {
              ++v16;
              continue;
            }
            break;
          }
          if (v16 == 100) {
            goto LABEL_135;
          }
          if (v18)
          {
            *a1 = v16;
            *a3 = ((v15 + 1) << 24) | 0xF;
            return 3;
          }
          else
          {
            *a1 = nv[8 * v16 + 7];
            *a3 = 0;
            return 1;
          }
        case 14:
          if (a2 == 59) {
            return 1;
          }
          if (!isdigit(a2)) {
            goto LABEL_135;
          }
          *a1 += 10 * *a1 + v18 - 48;
          int v22 = 3;
          break;
        case 15:
          goto LABEL_117;
        default:
LABEL_137:
          JUMPOUT(0);
      }
    }
  }
  return v22;
}

int strnunvisx(char *a1, size_t a2, const char *a3, int a4)
{
  sigset_t v24 = a1;
  size_t v23 = a2;
  int v22 = a3;
  *(_DWORD *)&v21[1] = a4;
  v21[0] = 0;
  char v20 = 0;
  int v19 = a1;
  int v18 = 0;
  if (!a3) {
    __assert_rtn("strnunvisx", "unvis.c", 504, "src != ((void *)0)");
  }
  if (!v24) {
    __assert_rtn("strnunvisx", "unvis.c", 505, "dst != ((void *)0)");
  }
  while (2)
  {
    BOOL v4 = v22++;
    LODWORD(v4) = *v4;
    v21[0] = (_BYTE)v4;
    if (v4)
    {
LABEL_6:
      int v5 = unvis(&v20, v21[0], &v18, *(int *)&v21[1]);
      if (!v7 & v6)
      {
        uint64_t v9 = (v5 + 1);
        char v8 = 1;
      }
      else
      {
        uint64_t v9 = (v5 + 1);
        char v8 = 0;
      }
      if ((v8 & 1) == 0)
      {
        switch(v9)
        {
          case 0:
            *__error() = 22;
            return -1;
          case 1:
          case 4:
            continue;
          case 2:
            if (!v23--) {
              goto LABEL_22;
            }
            char v11 = v24++;
            *char v11 = v20;
            continue;
          case 3:
            if (!v23--) {
              goto LABEL_22;
            }
            int v13 = v24++;
            *int v13 = v20;
            goto LABEL_6;
          default:
            JUMPOUT(0);
        }
      }
      __assert_rtn("strnunvisx", "unvis.c", 532, "0");
    }
    break;
  }
  if (unvis(&v20, v21[0], &v18, 4096) == 1)
  {
    if (!v23--) {
      goto LABEL_22;
    }
    unsigned __int8 v15 = v24++;
    *unsigned __int8 v15 = v20;
  }
  if (v23--)
  {
    *sigset_t v24 = 0;
    return v24 - v19;
  }
LABEL_22:
  *__error() = 28;
  return -1;
}

int strunvisx(char *a1, const char *a2, int a3)
{
  return strnunvisx(a1, 0xFFFFFFFFFFFFFFFFLL, a2, a3);
}

int strunvis(char *a1, const char *a2)
{
  return strnunvisx(a1, 0xFFFFFFFFFFFFFFFFLL, a2, 0);
}

int strnunvis(char *a1, size_t a2, const char *a3)
{
  return strnunvisx(a1, a2, a3, 0);
}

uint64_t usleep_NOCANCEL(unsigned int a1)
{
  unsigned int v3 = a1;
  v2[1] = 1000 * (a1 % 0xF4240);
  v2[0] = a1 / 0xF4240;
  return nanosleep_NOCANCEL(v2, 0);
}

int utime(const char *a1, const utimbuf *a2)
{
  if (!a2) {
    return utimes(a1, 0);
  }
  v3.time_t tv_sec = a2->actime;
  modmach_error_t time = a2->modtime;
  int v5 = 0;
  v3.tv_usec = 0;
  return utimes(a1, &v3);
}

char *__cdecl svis(char *a1, int a2, int a3, int a4, const char *a5)
{
  char v12 = a1;
  int v11 = a2;
  int v10 = a3;
  int v9 = a4;
  char v8 = a5;
  v7[0] = a2;
  v7[1] = a4;
  int v6 = istrsenvisx((uint64_t)&v12, 0, (uint64_t)v7, 1, a3, (uint64_t)a5, 0);
  if (v6 >= 0) {
    return &v12[v6];
  }
  else {
    return 0;
  }
}

uint64_t istrsenvisx(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  uint64_t v45 = v66;
  uint64_t v46 = 0x100004052888210;
  uint64_t v71 = a1;
  uint64_t v70 = a2;
  uint64_t v69 = a3;
  uint64_t v68 = a4;
  int v67 = a5;
  v66[7] = a6;
  v66[6] = a7;
  uint64_t v73 = 0;
  if (v7) {
    char v8 = 1;
  }
  else {
    char v8 = 0;
  }
  if (v8)
  {
    v45[15] = (uint64_t)pthread_getspecific(__locale_key);
  }
  else
  {
    int v9 = v45;
    v45[16] = __locale_key;
    v9[19] = v9[16];
    v9[20] = 0;
    v9[20] = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v9[15] = *(void *)(v9[20] + 8 * v9[19]);
  }
  if (v45[15]) {
    double v44 = (void *)v45[15];
  }
  else {
    double v44 = __global_locale;
  }
  int v10 = v45;
  uint64_t v11 = *(unsigned int *)(v44[166] + 64);
  v45[5] = (uint64_t)&v29;
  double v43 = (char *)&v29 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10[4] = v11;
  v10[3] = 0;
  v10[2] = 0;
  v10[1] = 0;
  *int v10 = 0;
  int v65 = 0;
  int v64 = 0;
  size_t v63 = 0;
  uint64_t v62 = 0;
  uint64_t v61 = 0;
  unint64_t v60 = 0;
  __int32 v59 = 0;
  int v58 = 0;
  int v57 = 0;
  int v56 = 0;
  int v55 = -1;
  int i = 0;
  int v53 = 0;
  uint64_t v52 = 0;
  int v51 = 0;
  v50 = 0;
  uint64_t v49 = 0;
  unint64_t v48 = 0;
  memset(&__b, 0, sizeof(__b));
  if (!v45[12]) {
    __assert_rtn("istrsenvisx", "vis.c", 394, "mbdstp != ((void *)0)");
  }
  BOOL v12 = v45[10] != 0;
  BOOL v42 = 1;
  if (!v12) {
    BOOL v42 = v45[9] == 0;
  }
  if (!v42) {
    __assert_rtn("istrsenvisx", "vis.c", 395, "mbsrc != ((void *)0) || mblength == 0");
  }
  if (!v45[7]) {
    __assert_rtn("istrsenvisx", "vis.c", 396, "mbextra != ((void *)0)");
  }
  uint64_t v49 = v45[9];
  if (v49 == 1) {
    uint64_t v49 = 2;
  }
  int v13 = v45;
  int v64 = 0;
  v45[1] = 0;
  *int v13 = 0;
  v50 = 0;
  uint64_t v14 = malloc_type_calloc();
  *uint64_t v45 = v14;
  if (!v14)
  {
    unsigned int v72 = -1;
    int v47 = 1;
    return v72;
  }
  uint64_t v15 = malloc_type_calloc();
  v45[1] = v15;
  if (!v15) {
    goto LABEL_96;
  }
  if (!*(void *)v45[12])
  {
    v50 = (void *)malloc_type_calloc();
    if (v50)
    {
      *(void *)v45[12] = v50;
      goto LABEL_26;
    }
LABEL_96:
    free(v64);
    free((void *)v45[1]);
    free((void *)*v45);
    free(v50);
    unsigned int v72 = v55;
    int v47 = 1;
    return v72;
  }
LABEL_26:
  unsigned __int8 v16 = v45;
  uint64_t v52 = *(char **)v45[12];
  v45[3] = v45[1];
  v16[2] = *v16;
  if ((v67 & 0x4000) != 0)
  {
    int v56 = 1;
  }
  else
  {
    if (v45[6]) {
      int v41 = *(_DWORD *)v45[6];
    }
    else {
      int v41 = 0;
    }
    int v56 = v41;
  }
  memset(&__b, 0, sizeof(__b));
  while (v49 > 0)
  {
    if (!v56)
    {
      int v39 = (__int32 *)v45[2];
      int v40 = (const char *)v45[10];
      if (v49 >= 6) {
        size_t v38 = 6;
      }
      else {
        size_t v38 = v49;
      }
      int v57 = mbrtowc(v39, v40, v38, &__b);
    }
    if (v56 || v57 < 0)
    {
      *(_DWORD *)v45[2] = *(unsigned __int8 *)v45[10];
      int v57 = 1;
      int v56 = 1;
    }
    if (!v57) {
      int v57 = 1;
    }
    unsigned __int8 v17 = v45;
    v45[2] += 4;
    v17[10] += v57;
    v49 -= v57;
  }
  int v18 = v45;
  size_t v63 = (v18[2] - *v18) / 4;
  v45[2] = *v45;
  if (v18[9] < v63) {
    size_t v63 = v45[9];
  }
  int v64 = makeextralist(v67, (char *)v45[7]);
  if (!v64)
  {
    if (!v45[11] || *(void *)v45[11])
    {
      *uint64_t v52 = 0;
      int v55 = 0;
    }
    else
    {
LABEL_85:
      *__error() = 28;
    }
    goto LABEL_96;
  }
  int v58 = getvisfun(v67);
  int v65 = (const __int32 *)v45[3];
  while (v63)
  {
    int v19 = v45;
    char v20 = (__int32 *)v45[2];
    v45[2] = (uint64_t)(v20 + 1);
    __int32 v59 = *v20;
    int v34 = v58;
    wint_t v35 = (__int32 *)v19[3];
    __int32 v36 = v59;
    unsigned int v37 = v67;
    if (v63) {
      int v33 = *(_DWORD *)v45[2];
    }
    else {
      int v33 = 0;
    }
    uint64_t v21 = (uint64_t)v34(v35, v36, v37, v33, v64);
    int v22 = v45;
    v45[3] = v21;
    if (!v22[3]) {
      goto LABEL_85;
    }
    --v63;
  }
  *(_DWORD *)v45[3] = 0;
  size_t v63 = wcslen(v65);
  if (v45[11]) {
    size_t v32 = *(void *)v45[11];
  }
  else {
    size_t v32 = 6 * wcslen(v65) + 1;
  }
  unint64_t v48 = v32;
  uint64_t v62 = 0;
  memset(&__b, 0, sizeof(__b));
  v45[3] = (uint64_t)v65;
  while (v63)
  {
    if (!v56)
    {
      uint64_t v23 = v48 - v62;
      unint64_t v31 = v48 - v62;
      v45[14] = 0;
      if (v23)
      {
        sigset_t v24 = v45;
        v45[17] = __locale_key;
        v24[18] = v24[17];
        v24[21] = 0;
        v24[21] = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        v24[14] = *(void *)(v24[21] + 8 * v24[18]);
      }
      else
      {
        sigset_t v25 = pthread_getspecific(__locale_key);
        v45[14] = (uint64_t)v25;
      }
      char v30 = v45[14] ? (void *)v45[14] : __global_locale;
      int v51 = v31 <= *(int *)(v30[166] + 64) ? v43 : v52;
      int v57 = wcrtomb(v51, *(_DWORD *)v45[3], &__b);
      if (v57 > 0 && v51 != v52)
      {
        if (v62 + v57 >= v48) {
          goto LABEL_85;
        }
        memcpy(v52, v51, v57);
      }
    }
    if (v56 || v57 < 0)
    {
      int v57 = 0;
      unint64_t v60 = 0;
      for (int i = 7; i >= 0; --i)
      {
        int v53 = 8 * i;
        uint64_t v61 = 255 << (8 * i);
        v60 |= v61;
        if ((*(int *)v45[3] & v60) != 0 || !i)
        {
          if (v62 + v57 + 1 >= v48) {
            goto LABEL_85;
          }
          unint64_t v26 = (*(int *)v45[3] & (unint64_t)v61) >> v53;
          uint64_t v27 = v57++;
          v52[v27] = v26;
        }
      }
      int v56 = 1;
    }
    if (v62 + v57 >= v48) {
      __assert_rtn("istrsenvisx", "vis.c", 590, "olen + clen < maxolen");
    }
    v52 += v57;
    v45[3] += 4;
    v62 += v57;
    --v63;
  }
  *uint64_t v52 = 0;
  if ((v67 & 0x4000) != 0 && v45[6]) {
    *(_DWORD *)v45[6] = v56;
  }
  free(v64);
  free((void *)v45[1]);
  free((void *)*v45);
  unsigned int v72 = v62;
  int v47 = 1;
  return v72;
}

char *__cdecl snvis(char *a1, size_t a2, int a3, int a4, int a5, const char *a6)
{
  uint64_t v14 = a1;
  size_t v13 = a2;
  int v12 = a3;
  int v11 = a4;
  int v10 = a5;
  int v9 = a6;
  v8[0] = a3;
  v8[1] = a5;
  int v7 = istrsenvisx((uint64_t)&v14, (uint64_t)&v13, (uint64_t)v8, 1, a4, (uint64_t)a6, 0);
  if (v7 >= 0) {
    return &v14[v7];
  }
  else {
    return 0;
  }
}

int strsvis(char *a1, const char *a2, int a3, const char *a4)
{
  int v5 = a1;
  return istrsenvisxl((uint64_t)&v5, 0, a2, a3, (uint64_t)a4, 0);
}

uint64_t istrsenvisxl(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5, uint64_t a6)
{
  if (!a3) {
    return istrsenvisx(a1, a2, 0, 0, a4, a5, a6);
  }
  size_t v7 = strlen(a3);
  return istrsenvisx(a1, a2, (uint64_t)a3, v7, a4, a5, a6);
}

int strsnvis(char *a1, size_t a2, const char *a3, int a4, const char *a5)
{
  size_t v7 = a1;
  size_t v6 = a2;
  return istrsenvisxl((uint64_t)&v7, (uint64_t)&v6, a3, a4, (uint64_t)a5, 0);
}

int strsvisx(char *a1, const char *a2, size_t a3, int a4, const char *a5)
{
  size_t v6 = a1;
  return istrsenvisx((uint64_t)&v6, 0, (uint64_t)a2, a3, a4, (uint64_t)a5, 0);
}

int strsnvisx(char *a1, size_t a2, const char *a3, size_t a4, int a5, const char *a6)
{
  char v8 = a1;
  size_t v7 = a2;
  return istrsenvisx((uint64_t)&v8, (uint64_t)&v7, (uint64_t)a3, a4, a5, (uint64_t)a6, 0);
}

int strsenvisx(char *a1, size_t a2, const char *a3, size_t a4, int a5, const char *a6, int *a7)
{
  int v9 = a1;
  size_t v8 = a2;
  return istrsenvisx((uint64_t)&v9, (uint64_t)&v8, (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7);
}

char *__cdecl vis(char *a1, int a2, int a3, int a4)
{
  int v10 = a1;
  int v9 = a2;
  int v8 = a3;
  int v7 = a4;
  v6[0] = a2;
  v6[1] = a4;
  int v5 = istrsenvisx((uint64_t)&v10, 0, (uint64_t)v6, 1, a3, (uint64_t)&unk_D793D, 0);
  if (v5 >= 0) {
    return &v10[v5];
  }
  else {
    return 0;
  }
}

char *__cdecl nvis(char *a1, size_t a2, int a3, int a4, int a5)
{
  int v12 = a1;
  size_t v11 = a2;
  int v10 = a3;
  int v9 = a4;
  int v8 = a5;
  v7[0] = a3;
  v7[1] = a5;
  int v6 = istrsenvisx((uint64_t)&v12, (uint64_t)&v11, (uint64_t)v7, 1, a4, (uint64_t)&unk_D793D, 0);
  if (v6 >= 0) {
    return &v12[v6];
  }
  else {
    return 0;
  }
}

int strvis(char *a1, const char *a2, int a3)
{
  BOOL v4 = a1;
  return istrsenvisxl((uint64_t)&v4, 0, a2, a3, (uint64_t)&unk_D793D, 0);
}

int strnvis(char *a1, size_t a2, const char *a3, int a4)
{
  int v6 = a1;
  size_t v5 = a2;
  return istrsenvisxl((uint64_t)&v6, (uint64_t)&v5, a3, a4, (uint64_t)&unk_D793D, 0);
}

uint64_t stravis(void *a1, const char *a2, int a3)
{
  *a1 = 0;
  return istrsenvisxl((uint64_t)a1, 0, a2, a3, (uint64_t)&unk_D793D, 0);
}

int strvisx(char *a1, const char *a2, size_t a3, int a4)
{
  size_t v5 = a1;
  return istrsenvisx((uint64_t)&v5, 0, (uint64_t)a2, a3, a4, (uint64_t)&unk_D793D, 0);
}

int strnvisx(char *a1, size_t a2, const char *a3, size_t a4, int a5)
{
  int v7 = a1;
  size_t v6 = a2;
  return istrsenvisx((uint64_t)&v7, (uint64_t)&v6, (uint64_t)a3, a4, a5, (uint64_t)&unk_D793D, 0);
}

int strenvisx(char *a1, size_t a2, const char *a3, size_t a4, int a5, int *a6)
{
  int v8 = a1;
  size_t v7 = a2;
  return istrsenvisx((uint64_t)&v8, (uint64_t)&v7, (uint64_t)a3, a4, a5, (uint64_t)&unk_D793D, (uint64_t)a6);
}

__int32 *makeextralist(int a1, char *a2)
{
  int v19 = a1;
  __s = a2;
  memset(&__b, 0, sizeof(__b));
  size_t v15 = strlen(__s);
  unsigned __int8 v17 = (__int32 *)malloc_type_calloc();
  if (!v17) {
    return 0;
  }
  if ((v19 & 0x4000) != 0 || mbsrtowcs(v17, (const char **)&__s, v15, &__b) == -1)
  {
    for (size_t i = 0; i < v15; ++i)
      v17[i] = __s[i];
    unsigned __int8 v16 = &v17[v15];
  }
  else
  {
    unsigned __int8 v16 = &v17[wcslen(v17)];
  }
  if ((v19 & 0x100) != 0)
  {
    size_t v13 = (__int32 *)&char_glob;
    while (*v13)
    {
      rlimit v2 = v13++;
      timeval v3 = v16++;
      *timeval v3 = *v2;
    }
  }
  if ((v19 & 0x2000) != 0)
  {
    uint64_t v14 = (__int32 *)&char_shell;
    while (*v14)
    {
      BOOL v4 = v14++;
      size_t v5 = v16++;
      *size_t v5 = *v4;
    }
  }
  if ((v19 & 4) != 0)
  {
    size_t v6 = v16++;
    *size_t v6 = 32;
  }
  if ((v19 & 8) != 0)
  {
    size_t v7 = v16++;
    *size_t v7 = 9;
  }
  if ((v19 & 0x10) != 0)
  {
    int v8 = v16++;
    *int v8 = 10;
  }
  if ((v19 & 0x8000u) != 0)
  {
    int v9 = v16++;
    *int v9 = 34;
  }
  if ((v19 & 0x40) == 0)
  {
    int v10 = v16++;
    *int v10 = 92;
  }
  *unsigned __int8 v16 = 0;
  return v17;
}

__int32 *(*getvisfun(__int16 a1))(__int32 *a1, __int32 a2, __int16 a3, unsigned __int8 a4, const __int32 *a5)
{
  if ((a1 & 0x80u) != 0) {
    return do_hvis;
  }
  if ((a1 & 0x200) != 0) {
    return (__int32 *(*)(__int32 *, __int32, __int16, unsigned __int8, const __int32 *))do_mvis;
  }
  return do_svis;
}

__int32 *do_hvis(__int32 *a1, __int32 a2, __int16 a3, unsigned __int8 a4, const __int32 *a5)
{
  if (iswalnum(a2)
    || a2 == 36
    || a2 == 45
    || a2 == 95
    || a2 == 46
    || a2 == 43
    || a2 == 33
    || a2 == 42
    || a2 == 39
    || a2 == 40
    || a2 == 41
    || a2 == 44)
  {
    return do_svis(a1, a2, a3, a4, a5);
  }
  *a1 = 37;
  a1[1] = dword_D5BA8[a2 >> 4];
  size_t v5 = a1 + 2;
  int v12 = a1 + 3;
  *size_t v5 = dword_D5BA8[a2 & 0xF];
  return v12;
}

__int32 *do_mvis(__int32 *a1, __int32 a2, __int16 a3, int a4, const __int32 *a5)
{
  if (a2 == 10
    || (!iswspace(a2) || a4 != 13 && a4 != 10)
    && (iswspace(a2) || a2 >= 33 && a2 != 61 && a2 <= 126)
    && !wcschr(dword_D5BEC, a2))
  {
    return do_svis(a1, a2, a3, a4, a5);
  }
  *a1 = 61;
  a1[1] = dword_D5C20[a2 >> 4];
  size_t v5 = a1 + 2;
  int v12 = a1 + 3;
  *size_t v5 = dword_D5C20[a2 & 0xF];
  return v12;
}

__int32 *do_svis(__int32 *a1, __int32 a2, __int16 a3, unsigned __int8 a4, const __int32 *a5)
{
  BOOL v8 = wcschr(a5, a2) != 0;
  if (v8) {
    goto LABEL_17;
  }
  if ((a3 & 0x4000) == 0)
  {
    if (!iswgraph(a2)) {
      goto LABEL_6;
    }
LABEL_16:
    *a1 = a2;
    return a1 + 1;
  }
  if (isgraph_l(a2, 0)) {
    goto LABEL_16;
  }
LABEL_6:
  if (a2 == 32
    || a2 == 9
    || a2 == 10
    || (a3 & 0x4000) == 0 && a2 > 127 && iswspace(a2)
    || (a3 & 0x20) != 0 && (a2 == 8 || a2 == 7 || a2 == 13))
  {
    goto LABEL_16;
  }
LABEL_17:
  unint64_t v6 = 0;
  for (int i = 7; i >= 0; --i)
  {
    v6 |= 255 << (8 * i);
    if ((a2 & v6) != 0 || !i) {
      a1 = do_mbyte(a1, (a2 & (unint64_t)(255 << (8 * i))) >> (8 * i), a3, a4, v8);
    }
  }
  return a1;
}

_DWORD *do_mbyte(_DWORD *a1, unsigned int a2, __int16 a3, unsigned __int8 a4, int a5)
{
  unsigned __int8 v16 = a1;
  wint_t v15 = a2;
  char v14 = a3;
  if ((a3 & 2) == 0) {
    goto LABEL_26;
  }
  if (a2)
  {
    uint64_t v6 = a2;
    char v5 = 1;
  }
  else
  {
    uint64_t v6 = 0;
    char v5 = 0;
  }
  if ((v5 & 1) == 0)
  {
    switch(v6)
    {
      case 0:
        *a1 = 92;
        unsigned __int8 v17 = a1 + 2;
        a1[1] = 48;
        if (a4 >= 0x30u && a4 <= 0x37u)
        {
          *unsigned __int8 v17 = 48;
          unsigned __int8 v17 = a1 + 4;
          a1[3] = 48;
        }
        return v17;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 33:
      case 34:
      case 35:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 91:
      case 92:
      case 93:
      case 95:
      case 96:
      case 99:
      case 100:
      case 101:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 111:
      case 112:
      case 113:
      case 117:
        break;
      case 7:
        *a1 = 92;
        a1[1] = 97;
        return a1 + 2;
      case 8:
        *a1 = 92;
        a1[1] = 98;
        return a1 + 2;
      case 9:
        *a1 = 92;
        a1[1] = 116;
        return a1 + 2;
      case 10:
        *a1 = 92;
        a1[1] = 110;
        return a1 + 2;
      case 11:
        *a1 = 92;
        a1[1] = 118;
        return a1 + 2;
      case 12:
        *a1 = 92;
        a1[1] = 102;
        return a1 + 2;
      case 13:
        *a1 = 92;
        a1[1] = 114;
        return a1 + 2;
      case 32:
        *a1 = 92;
        a1[1] = 115;
        return a1 + 2;
      case 36:
      case 48:
      case 77:
      case 94:
      case 97:
      case 98:
      case 102:
      case 110:
      case 114:
      case 115:
      case 116:
      case 118:
        goto LABEL_26;
      default:
        JUMPOUT(0);
    }
  }
  if ((a3 & 0x4000) != 0)
  {
    if (!isgraph_l(a2, 0)) {
      goto LABEL_26;
    }
  }
  else if (!iswgraph(a2))
  {
    goto LABEL_26;
  }
  if (v15 < 0x30u || v15 > 0x37u)
  {
    *unsigned __int8 v16 = 92;
    v16[1] = v15;
    return v16 + 2;
  }
LABEL_26:
  if (a5 || (v15 & 0x7F) == 0x20 || (v14 & 1) != 0)
  {
    *unsigned __int8 v16 = 92;
    v16[1] = (v15 >> 6) + 48;
    v16[2] = ((v15 >> 3) & 7) + 48;
    size_t v7 = v16 + 3;
    int v18 = v16 + 4;
    *size_t v7 = (v15 & 7) + 48;
  }
  else
  {
    if ((v14 & 0x40) == 0)
    {
      BOOL v8 = v16++;
      *BOOL v8 = 92;
    }
    if ((v15 & 0x80) != 0)
    {
      v15 &= 0x7Fu;
      int v9 = v16++;
      *int v9 = 77;
    }
    if (iswcntrl(v15))
    {
      *unsigned __int8 v16 = 94;
      int v10 = v16 + 1;
      int v18 = v16 + 2;
      if (v15 == 127) {
        *int v10 = 63;
      }
      else {
        *int v10 = v15 + 64;
      }
    }
    else
    {
      *unsigned __int8 v16 = 45;
      size_t v11 = v16 + 1;
      int v18 = v16 + 2;
      *size_t v11 = v15;
    }
  }
  return v18;
}

uint64_t wait_NOCANCEL()
{
  return __wait4_nocancel();
}

pid_t wait3(int *a1, int a2, rusage *a3)
{
  return wait4(-1, a1, a2, a3);
}

uint64_t waitpid_NOCANCEL(uint64_t a1, uint64_t a2, int a3)
{
  if ((a3 & 0x13) == a3)
  {
    return __wait4_nocancel();
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t _ascii_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _ascii_mbrtowc;
  *(void *)(a1 + 80) = _ascii_mbsinit;
  *(void *)(a1 + 88) = _ascii_mbsnrtowcs;
  *(void *)(a1 + 96) = _ascii_wcrtomb;
  *(void *)(a1 + 104) = _ascii_wcsnrtombs;
  *(_DWORD *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _ascii_mbrtowc(_DWORD *a1, char *a2, uint64_t a3)
{
  if (!a2) {
    return 0;
  }
  if (!a3) {
    return -2;
  }
  if (*a2 >= 0)
  {
    if (a1) {
      *a1 = *a2;
    }
    return *a2 != 0;
  }
  else
  {
    *__error() = 92;
    return -1;
  }
}

uint64_t _ascii_mbsinit()
{
  return 1;
}

uint64_t _ascii_mbsnrtowcs(_DWORD *a1, char **a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v16 = a1;
  if (a1)
  {
    size_t v13 = *a2;
    for (uint64_t i = 0; ; ++i)
    {
      uint64_t v4 = a4--;
      BOOL v9 = 0;
      if (v4)
      {
        uint64_t v5 = a3--;
        BOOL v9 = v5 != 0;
      }
      if (!v9) {
        break;
      }
      if (*v13 < 0)
      {
        *a2 = v13;
        *__error() = 92;
        return -1;
      }
      uint64_t v6 = v13++;
      LODWORD(v6) = *v6;
      size_t v7 = v16++;
      *size_t v7 = v6;
      if (!v6)
      {
        *a2 = 0;
        return i;
      }
    }
    *a2 = v13;
    return i;
  }
  else
  {
    for (int j = *a2; ; ++j)
    {
      BOOL v10 = 0;
      if (a3) {
        BOOL v10 = *j != 0;
      }
      if (!v10) {
        break;
      }
      if (*j < 0)
      {
        *__error() = 92;
        return -1;
      }
      --a3;
    }
    return j - *a2;
  }
}

uint64_t _ascii_wcrtomb(unsigned char *a1, unsigned int a2)
{
  if (!a1) {
    return 1;
  }
  if (a2 < 0x80)
  {
    *a1 = a2;
    return 1;
  }
  else
  {
    *__error() = 92;
    return -1;
  }
}

uint64_t _ascii_wcsnrtombs(unsigned char *a1, _DWORD **a2, uint64_t a3, uint64_t a4)
{
  unsigned __int8 v16 = a1;
  if (a1)
  {
    size_t v13 = *a2;
    for (uint64_t i = 0; ; ++i)
    {
      uint64_t v4 = a4--;
      BOOL v9 = 0;
      if (v4)
      {
        uint64_t v5 = a3--;
        BOOL v9 = v5 != 0;
      }
      if (!v9) {
        break;
      }
      if (*v13 >= 0x80u)
      {
        *a2 = v13;
        *__error() = 92;
        return -1;
      }
      uint64_t v6 = v13++;
      LOBYTE(v6) = *v6;
      size_t v7 = v16++;
      *size_t v7 = (_BYTE)v6;
      if (!(_BYTE)v6)
      {
        *a2 = 0;
        return i;
      }
    }
    *a2 = v13;
    return i;
  }
  else
  {
    for (int j = *a2; ; ++j)
    {
      BOOL v10 = 0;
      if (a3) {
        BOOL v10 = *j != 0;
      }
      if (!v10) {
        break;
      }
      if (*j >= 0x80u)
      {
        *__error() = 92;
        return -1;
      }
      --a3;
    }
    return j - *a2;
  }
}

uint64_t _BIG5_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _BIG5_mbrtowc;
  *(void *)(a1 + 96) = _BIG5_wcrtomb;
  *(void *)(a1 + 80) = _BIG5_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _BIG5_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4)
{
  size_t v11 = a2;
  if ((*a4 & 0xFFFFFF00) != 0)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    size_t v11 = (unsigned __int8 *)&unk_D793D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3) {
    return -2;
  }
  if (*a4)
  {
    if (!*v11)
    {
LABEL_9:
      *__error() = 92;
      return -1;
    }
    if (a1) {
      *a1 = *v11 | (*a4 << 8);
    }
    *a4 = 0;
    return 1;
  }
  else
  {
    uint64_t v6 = (int)_big5_check(*v11);
    uint64_t v4 = v11;
    int v12 = v11 + 1;
    int v7 = *v4;
    if (v6 == 2)
    {
      if (a3 < 2)
      {
        *a4 = v7;
        return -2;
      }
      if (!*v12) {
        goto LABEL_9;
      }
      int v8 = *v12 | (v7 << 8);
      if (a1) {
        *a1 = v8;
      }
      return 2;
    }
    else
    {
      if (a1) {
        *a1 = v7;
      }
      return v7 != 0;
    }
  }
}

uint64_t _BIG5_wcrtomb(unsigned char *a1, __int16 a2, _DWORD *a3)
{
  if (*a3)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if (a2 < 0)
    {
      *a1 = HIBYTE(a2);
      a1[1] = a2;
      return 2;
    }
    else
    {
      *a1 = a2;
      return 1;
    }
  }
  else
  {
    return 1;
  }
}

BOOL _BIG5_mbsinit(_DWORD *a1)
{
  BOOL v2 = 1;
  if (a1) {
    return *a1 == 0;
  }
  return v2;
}

uint64_t _big5_check(unsigned __int8 a1)
{
  BOOL v2 = 0;
  if (a1 >= 0xA1u) {
    BOOL v2 = a1 != 255;
  }
  if (v2) {
    return 2;
  }
  else {
    return 1;
  }
}

wint_t btowc_l(int a1, locale_t a2)
{
  int v6 = a1;
  locale_t v5 = a2;
  memcpy(__b, &btowc_l_initial, sizeof(__b));
  char v4 = 0;
  wint_t v3 = 0;
  if (v5)
  {
    if (v5 == (locale_t)-1) {
      locale_t v5 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v5 = (locale_t)&__c_locale;
  }
  if (v6 == -1) {
    return -1;
  }
  char v4 = v6;
  if ((unint64_t)(*(uint64_t (**)(wint_t *, char *, uint64_t, unsigned char *, locale_t))(*((void *)v5 + 166)
                                                                                                 + 72))(&v3, &v4, 1, __b, v5) <= 1)return v3;
  else {
    return -1;
  }
}

wint_t btowc(int a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    locale_t v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    locale_t v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return btowc_l(a1, v5);
  }
  else {
    return btowc_l(a1, (locale_t)__global_locale);
  }
}

uint64_t __collate_load_tables(char *a1, void *a2)
{
  __s1 = a1;
  int v12 = a2;
  int v11 = 0;
  int v10 = 0;
  int v9 = 0;
  int i = 0;
  uint64_t v7 = 0;
  uint64_t v6 = 0;
  locale_t v5 = 0;
  char v4 = 0;
  memset(&__b, 0, sizeof(__b));
  if (!strcmp(__s1, "C") || !strcmp(__s1, "POSIX") || !strncmp(__s1, "C.", 2uLL))
  {
    if (v12 == __global_locale) {
      __collate_load_error = 1;
    }
    xlocale_release(v12[165]);
    v12[165] = &__xlocale_C_collate;
    xlocale_retain((atomic_uint *)&__xlocale_C_collate);
    return 1;
  }
  else if (__collate_load_tables_cache && !strcmp(__s1, (const char *)(__collate_load_tables_cache + 16)))
  {
    if (v12 == __global_locale) {
      __collate_load_error = 0;
    }
    xlocale_release(v12[165]);
    v12[165] = __collate_load_tables_cache;
    xlocale_retain((atomic_uint *)__collate_load_tables_cache);
    return 1;
  }
  else
  {
    strcpy(__dst, __s1);
    strcat(__dst, "/LC_COLLATE");
    int v11 = __open_path_locale(__dst);
    if (v11 == -1)
    {
      return -1;
    }
    else if (fstat(v11, &__b) >= 0)
    {
      if (__b.st_size >= 0xA8uLL)
      {
        locale_t v5 = mmap(0, __b.st_size, 3, 2, v11, 0);
        close_NOCANCEL();
        uint64_t v6 = (char *)v5;
        if (v5 == (void *)-1)
        {
          return -1;
        }
        else
        {
          int v9 = 1;
          if (!strncmp(v6, "1.1A\n", 0xCuLL))
          {
            return __collate_load_tables_legacy(__s1, v12, (uint64_t)v6, v5, (uint64_t)&__b, &__collate_load_tables_cache);
          }
          else if (!strncmp(v6, "DARWIN 1.0\n", 0xCuLL) {
                 && (v6 += 12, v6 += 12, char v4 = v6, v6 += 144, v9 = *((_DWORD *)v4 + 14), v9 >= 0))
          }
          {
            if (*((_DWORD *)v4 + 13)) {
              goto LABEL_26;
            }
            int v10 = 136 * v9 + 10240 + 44 * *((_DWORD *)v4 + 15);
            for (int i = 0; i < *v4; v10 += 100 * *(_DWORD *)&v4[4 * i++ + 64])
              ;
            if (v10 != __b.st_size - (v6 - (unsigned char *)v5))
            {
LABEL_26:
              munmap(v5, __b.st_size);
              *__error() = 22;
              return -1;
            }
            else
            {
              uint64_t v7 = malloc_type_malloc();
              if (v7)
              {
                *(void *)(v7 + 72) = v5;
                *(void *)(v7 + 80) = __b.st_size;
                *(_DWORD *)uint64_t v7 = 2;
                *(void *)(v7 + 8) = destruct_collate;
                *(void *)(v7 + 192) = v6;
                v6 += 10240;
                for (int i = 0; i < *v4; ++i)
                {
                  if (*(int *)&v4[4 * i + 64] <= 0)
                  {
                    *(void *)(v7 + 96 + 8 * i) = 0;
                  }
                  else
                  {
                    *(void *)(v7 + 96 + 8 * i) = v6;
                    v6 += 100 * *(int *)&v4[4 * i + 64];
                  }
                }
                if (v9 <= 0)
                {
                  *(void *)(v7 + 176) = 0;
                }
                else
                {
                  *(void *)(v7 + 176) = v6;
                  v6 += 136 * v9;
                }
                if (*((int *)v4 + 15) <= 0) {
                  *(void *)(v7 + 184) = 0;
                }
                else {
                  *(void *)(v7 + 184) = v6;
                }
                strcpy((char *)(v7 + 16), __s1);
                *(void *)(v7 + 88) = v4;
                xlocale_release(__collate_load_tables_cache);
                __collate_load_tables_cache = v7;
                xlocale_release(v12[165]);
                v12[165] = __collate_load_tables_cache;
                *(unsigned char *)(v7 + 64) = 0;
                if (v12 == __global_locale) {
                  __collate_load_error = 0;
                }
                return 0;
              }
              else
              {
                munmap(v5, __b.st_size);
                *__error() = 12;
                return -1;
              }
            }
          }
          else
          {
            munmap(v5, __b.st_size);
            *__error() = 79;
            return -1;
          }
        }
      }
      else
      {
        close_NOCANCEL();
        *__error() = 22;
        return -1;
      }
    }
    else
    {
      close_NOCANCEL();
      return -1;
    }
  }
}

uint64_t __collate_load_tables_legacy(const char *a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v49 = 0;
  v50 = 0;
  uint64_t v40 = a3 + 10;
  uint64_t v44 = a3 + 38;
  for (int i = 0; i < (*(unsigned char *)(v40 + 3) & 0xF); ++i)
  {
    *(_DWORD *)(v40 + 4 + 4 * i) = _OSSwapInt32(*(_DWORD *)(v40 + 4 + 4 * i));
    *(_DWORD *)(v40 + 12 + 4 * i) = _OSSwapInt32(*(_DWORD *)(v40 + 12 + 4 * i));
  }
  *(_DWORD *)(v40 + 20) = _OSSwapInt32(*(_DWORD *)(v40 + 20));
  *(_DWORD *)(v40 + 24) = _OSSwapInt32(*(_DWORD *)(v40 + 24));
  int v27 = *(_DWORD *)(v40 + 20);
  if (v27 >= 0)
  {
    int v28 = 48 * v27 + 2048 + 12 * *(_DWORD *)(v40 + 24);
    for (int j = 0; j < (*(unsigned char *)(v40 + 3) & 0xF); ++j)
      v28 += 44 * *(_DWORD *)(v40 + 12 + 4 * j);
    if (v28 == *(void *)(a5 + 96) - (v44 - (void)a4))
    {
      uint64_t v39 = malloc_type_malloc();
      if (v39)
      {
        *(void *)(v39 + 72) = a4;
        *(void *)(v39 + 80) = *(void *)(a5 + 96);
        int v29 = 136 * v27 + 10384 + 44 * *(_DWORD *)(v40 + 24);
        for (int k = 0; k < (*(unsigned char *)(v40 + 3) & 0xF); ++k)
          v29 += 100 * *(_DWORD *)(v40 + 12 + 4 * k);
        uint64_t v6 = malloc_type_calloc();
        *(void *)(v39 + 88) = v6;
        if (v6)
        {
          uint64_t v34 = *(void *)(v39 + 88) + 144;
          *(_DWORD *)uint64_t v39 = 2;
          *(void *)(v39 + 8) = destruct_collate;
          uint64_t v38 = v44;
          *(void *)(v39 + 192) = v34;
          uint64_t v45 = (unsigned int *)(v44 + 2048);
          uint64_t v35 = v34 + 10240;
          if (*(int *)(v40 + 12) <= 0)
          {
            *(void *)(v39 + 96) = 0;
          }
          else
          {
            uint64_t v49 = v45;
            *(void *)(v39 + 96) = v35;
            v45 += 11 * *(int *)(v40 + 12);
            v35 += 100 * *(int *)(v40 + 12);
          }
          if (*(unsigned char *)(v40 + 2))
          {
            *(void *)(v39 + 104) = *(void *)(v39 + 96);
          }
          else if (*(int *)(v40 + 16) <= 0)
          {
            *(void *)(v39 + 104) = 0;
          }
          else
          {
            v50 = v45;
            *(void *)(v39 + 104) = v35;
            v45 += 11 * *(int *)(v40 + 16);
            v35 += 100 * *(int *)(v40 + 16);
          }
          if (v27 <= 0)
          {
            unsigned int v37 = 0;
            *(void *)(v39 + 176) = 0;
          }
          else
          {
            unsigned int v37 = (char *)v45;
            *(void *)(v39 + 176) = v35;
            v45 += 12 * v27;
            v35 += 136 * v27;
          }
          if (*(int *)(v40 + 24) <= 0)
          {
            __int32 v36 = 0;
            *(void *)(v39 + 184) = 0;
          }
          else
          {
            __int32 v36 = v45;
            *(void *)(v39 + 184) = v35;
          }
          uint64_t v19 = *(void *)(v39 + 192);
          uint64_t v18 = v38;
          int v30 = 256;
          while (1)
          {
            int v7 = v30--;
            if (v7 <= 0) {
              break;
            }
            for (int m = 0; m < (*(unsigned char *)(v40 + 3) & 0xF); ++m)
              *(_DWORD *)(v19 + 4 * m) = _OSSwapInt32(*(_DWORD *)(v18 + 4 * m));
            v19 += 40;
            v18 += 8;
          }
          for (int n = 0; n < (*(unsigned char *)(v40 + 3) & 0xF); ++n)
          {
            if (*(int *)(v40 + 12 + 4 * n) > 0)
            {
              unsigned __int8 v17 = (&v49)[n];
              unsigned __int8 v16 = *(unsigned int **)(v39 + 96 + 8 * n);
              int v31 = *(_DWORD *)(v40 + 12 + 4 * n);
              while (1)
              {
                int v8 = v31--;
                if (v8 <= 0) {
                  break;
                }
                memcpy(v16 + 1, v17 + 1, 0x28uLL);
                *unsigned __int8 v16 = *v17;
                *unsigned __int8 v16 = _OSSwapInt32(*v16);
                wntohl((uint64_t)(v16 + 1), 10);
                v17 += 11;
                v16 += 25;
              }
            }
          }
          mbstate_t __dst = *(char **)(v39 + 176);
          uint64_t __src = v37;
          int v32 = v27;
          while (1)
          {
            int v9 = v32--;
            if (v9 <= 0) {
              break;
            }
            memcpy(__dst, __src, 0x28uLL);
            wntohl((uint64_t)__dst, 10);
            for (iint i = 0; ii < (*(unsigned char *)(v40 + 3) & 0xF); ++ii)
              *(_DWORD *)&__dst[4 * ii + 96] = _OSSwapInt32(*(_DWORD *)&__src[4 * ii + 40]);
            __dst += 136;
            __src += 48;
          }
          if (*(int *)(v40 + 24) > 0)
          {
            size_t v13 = *(unsigned int **)(v39 + 184);
            int v12 = v36;
            int v33 = *(_DWORD *)(v40 + 24);
            while (1)
            {
              int v10 = v33--;
              if (v10 <= 0) {
                break;
              }
              *size_t v13 = *v12;
              *size_t v13 = _OSSwapInt32(*v13);
              for (jint j = 0; jj < (*(unsigned char *)(v40 + 3) & 0xF); ++jj)
                v13[jj + 1] = _OSSwapInt32(v12[jj + 1]);
              v13 += 11;
              v12 += 3;
            }
          }
          strcpy((char *)(v39 + 16), a1);
          __collate_fill_info(v39, v40);
          xlocale_release(*a6);
          *a6 = v39;
          xlocale_release(a2[165]);
          a2[165] = v39;
          *(unsigned char *)(v39 + 64) = 0;
          if (a2 == __global_locale) {
            __collate_load_error = 0;
          }
          return 0;
        }
        else
        {
          munmap(a4, *(void *)(a5 + 96));
          free((void *)v39);
          *__error() = 12;
          return -1;
        }
      }
      else
      {
        munmap(a4, *(void *)(a5 + 96));
        *__error() = 12;
        return -1;
      }
    }
    else
    {
      munmap(a4, *(void *)(a5 + 96));
      *__error() = 22;
      return -1;
    }
  }
  else
  {
    munmap(a4, *(void *)(a5 + 96));
    *__error() = 79;
    return -1;
  }
}

void destruct_collate(uint64_t a1)
{
  if ((*(_DWORD *)(*(void *)(a1 + 88) + 52) & 2) != 0) {
    free(*(void **)(a1 + 88));
  }
  if (*(void *)(a1 + 72) && *(void *)(a1 + 80)) {
    munmap(*(void **)(a1 + 72), *(void *)(a1 + 80));
  }
  free((void *)a1);
}

__int32 *__collate_substitute(const __int32 *a1, int a2, uint64_t a3)
{
  unsigned __int8 v17 = a1;
  if (!a1 || !*a1) {
    return __collate_wcsdup((const __int32 *)&unk_D5CE8);
  }
  int v13 = wcslen(a1);
  int v8 = *(_DWORD *)(*(void *)(*(void *)(a3 + 1320) + 88) + 64 + 4 * a2);
  if (v8 <= 0) {
    return __collate_wcsdup(v17);
  }
  uint64_t v5 = *(void *)(*(void *)(a3 + 1320) + 96 + 8 * a2);
  int v9 = v13 / 4;
  if (v13 / 4 < 2) {
    int v9 = 2;
  }
  int v14 = v13 + v9;
  __ptr = (void *)malloc_type_malloc();
  if (!__ptr) {
    __collate_err(71, "__collate_substitute");
  }
  int v12 = 0;
  while (*v17)
  {
    uint64_t v4 = substsearch(*v17, v5, v8);
    if (v4)
    {
      uint64_t v6 = (__int32 *)(v4 + 4);
      int v10 = __collate_wcsnlen((_DWORD *)(v4 + 4), 24);
    }
    else
    {
      uint64_t v6 = (__int32 *)v17;
      int v10 = 1;
    }
    int v11 = v12 + v10;
    if (v14 <= v12 + v10)
    {
      int v14 = v11 + v9;
      __ptr = reallocf(__ptr, 4 * (v11 + v9));
      if (!__ptr) {
        __collate_err(71, "__collate_substitute");
      }
    }
    wcsncpy((__int32 *)__ptr + v12, v6, v10);
    v12 += v10;
    ++v17;
  }
  *((_DWORD *)__ptr + v12) = 0;
  return (__int32 *)__ptr;
}

__int32 *__collate_wcsdup(const __int32 *a1)
{
  wcslen(a1);
  char v2 = (__int32 *)malloc_type_malloc();
  if (!v2) {
    __collate_err(71, "__collate_wcsdup");
  }
  wcscpy(v2, a1);
  return v2;
}

void __collate_err(int a1, const char *a2)
{
  int v4 = *__error();
  char v2 = getprogname();
  strlen(v2);
  write_NOCANCEL();
  write_NOCANCEL();
  strlen(a2);
  write_NOCANCEL();
  write_NOCANCEL();
  wint_t v3 = strerror(v4);
  strlen(v3);
  write_NOCANCEL();
  write_NOCANCEL();
  exit(a1);
}

uint64_t substsearch(int a1, uint64_t a2, int a3)
{
  int v7 = 0;
  int v6 = a3 - 1;
  while (v7 <= v6)
  {
    int v5 = (v7 + v6) / 2;
    int v3 = *(_DWORD *)(a2 + 100 * v5);
    if (a1 == v3) {
      return a2 + 100 * v5;
    }
    if (a1 - v3 <= 0) {
      int v6 = v5 - 1;
    }
    else {
      int v7 = v5 + 1;
    }
  }
  return 0;
}

uint64_t __collate_wcsnlen(_DWORD *a1, int a2)
{
  for (unsigned int i = 0; ; ++i)
  {
    BOOL v3 = 0;
    if (*a1) {
      BOOL v3 = (int)i < a2;
    }
    if (!v3) {
      break;
    }
    ++a1;
  }
  return i;
}

const __int32 *__collate_lookup_l(const __int32 *result, int *a2, int *a3, int *a4, void *a5)
{
  unsigned __int8 v16 = result;
  wint_t v15 = a2;
  int v14 = a3;
  int v13 = a4;
  int v12 = a5;
  int v11 = 0;
  int v10 = 0;
  uint64_t v9 = 0;
  int v8 = 0;
  int v7 = 0;
  if (!*result)
  {
    *wint_t v15 = 0;
    *int v14 = 0;
    *int v13 = 0;
    return result;
  }
  if (v12)
  {
    if (v12 == (void *)-1) {
      int v12 = __global_locale;
    }
  }
  else
  {
    int v12 = &__c_locale;
  }
  uint64_t v9 = v12[165];
  if (*(unsigned char *)(v9 + 64))
  {
    *wint_t v15 = 1;
    *int v14 = *v16;
    *int v13 = 0;
    return result;
  }
  *wint_t v15 = 1;
  int result = (const __int32 *)chainsearch(v16, &v7, (uint64_t)v12);
  int v11 = result;
  if (result && v11[24] >= 0)
  {
    *wint_t v15 = v7;
    *int v14 = v11[24];
    *int v13 = v11[25];
  }
  else if (*v16 > 255)
  {
    if (*(int *)(*(void *)(v12[165] + 88) + 60) <= 0
      || (result = (const __int32 *)largesearch(*v16, (uint64_t)v12), (int v10 = result) == 0))
    {
      int v7 = *(_DWORD *)(*(void *)(v12[165] + 88) + 104);
      if (v7 < 0) {
        __int32 v6 = *v16 - v7;
      }
      else {
        __int32 v6 = v7;
      }
      *int v14 = v6;
      int v7 = *(_DWORD *)(*(void *)(v12[165] + 88) + 108);
      if (v7 < 0) {
        __int32 v5 = *v16 - v7;
      }
      else {
        __int32 v5 = v7;
      }
      *int v13 = v5;
      return result;
    }
    *int v14 = v10[1];
    *int v13 = v10[2];
  }
  else
  {
    *int v14 = *(_DWORD *)(*(void *)(v12[165] + 192) + 40 * *v16);
    *int v13 = *(_DWORD *)(*(void *)(v12[165] + 192) + 40 * *v16 + 4);
  }
  if (*v14 >= 0)
  {
    int result = lookup_substsearch(v9, *v14, 0);
    int v8 = (int *)result;
    if (result) {
      *int v14 = *v8;
    }
  }
  if (*v13 >= 0)
  {
    int result = lookup_substsearch(v9, *v13, 1);
    int v8 = (int *)result;
    if (result) {
      *int v13 = v8[1];
    }
  }
  return result;
}

uint64_t chainsearch(const __int32 *a1, _DWORD *a2, uint64_t a3)
{
  int v10 = 0;
  int v9 = *(_DWORD *)(*(void *)(*(void *)(a3 + 1320) + 88) + 56) - 1;
  uint64_t v4 = *(void *)(*(void *)(a3 + 1320) + 176);
  while (v10 <= v9)
  {
    int v8 = (v10 + v9) / 2;
    __int32 v5 = (__int32 *)(v4 + 136 * v8);
    int v7 = *a1 - *v5;
    if (*a1 == *v5)
    {
      int v6 = __collate_wcsnlen(v5, 24);
      int v7 = wcsncmp(a1, v5, v6);
      if (!v7)
      {
        *a2 = v6;
        return v4 + 136 * v8;
      }
    }
    if (v7 <= 0) {
      int v9 = v8 - 1;
    }
    else {
      int v10 = v8 + 1;
    }
  }
  return 0;
}

uint64_t largesearch(int a1, uint64_t a2)
{
  int v7 = 0;
  int v6 = *(_DWORD *)(*(void *)(*(void *)(a2 + 1320) + 88) + 60) - 1;
  uint64_t v4 = *(void *)(*(void *)(a2 + 1320) + 184);
  while (v7 <= v6)
  {
    int v5 = (v7 + v6) / 2;
    int v2 = *(_DWORD *)(v4 + 44 * v5);
    if (a1 == v2) {
      return v4 + 44 * v5;
    }
    if (a1 - v2 <= 0) {
      int v6 = v5 - 1;
    }
    else {
      int v7 = v5 + 1;
    }
  }
  return 0;
}

_DWORD *lookup_substsearch(uint64_t a1, int a2, int a3)
{
  if (!*(_DWORD *)(*(void *)(a1 + 88) + 64 + 4 * a3)) {
    return 0;
  }
  if (a3 >= **(unsigned __int8 **)(a1 + 88)) {
    return 0;
  }
  if ((a2 & 0x40000000) == 0) {
    return 0;
  }
  uint64_t v4 = (_DWORD *)(*(void *)(a1 + 96 + 8 * a3) + 100 * (int)(a2 & 0xBFFFFFFF));
  if (*v4 != a2) {
    __assert_rtn("lookup_substsearch", "collate.c", 596, "p->val == key");
  }
  return v4 + 1;
}

char *__collate_lookup(char *result, int *a2, int *a3, int *a4)
{
  int v13 = result;
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    int result = (char *)pthread_getspecific(__locale_key);
    int v14 = result;
  }
  else
  {
    uint64_t v15 = __locale_key;
    int v14 = *(char **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v15);
  }
  if (v14) {
    int v6 = (_xlocale *)v14;
  }
  else {
    int v6 = (_xlocale *)__global_locale;
  }
  int v9 = 0;
  if (*v13)
  {
    if (!*(unsigned char *)(*((void *)v6 + 165) + 64) && (int v9 = __collate_mbstowcs(v13, v6)) != 0)
    {
      __collate_lookup_l(v9, a2, a3, a4, v6);
      int v8 = *__error();
      free(v9);
      int result = (char *)__error();
      *(_DWORD *)int result = v8;
    }
    else
    {
      *a2 = 1;
      *a3 = *v13;
      *a4 = 0;
      int v7 = *__error();
      free(v9);
      int result = (char *)__error();
      *(_DWORD *)int result = v7;
    }
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
    *a4 = 0;
  }
  return result;
}

__int32 *__collate_mbstowcs(char *a1, _xlocale *a2)
{
  int v7 = a1;
  locale_t v6 = a2;
  size_t v5 = 0;
  char v4 = a1;
  memcpy(&__b, &__collate_mbstowcs_initial, sizeof(__b));
  size_t v5 = mbsrtowcs_l(0, (const char **)&v4, 0, &__b, v6);
  if (v5 == -1) {
    return 0;
  }
  BOOL v3 = (__int32 *)malloc_type_malloc();
  if (!v3) {
    __collate_err(71, "__collate_mbstowcs");
  }
  memcpy(&__b, &__collate_mbstowcs_initial, sizeof(__b));
  mbsrtowcs_l(v3, (const char **)&v7, v5, &__b, v6);
  v3[v5] = 0;
  return v3;
}

uint64_t __collate_lookup_which(const __int32 *a1, _DWORD *a2, int *a3, int a4, uint64_t a5)
{
  unsigned __int8 v16 = a1;
  uint64_t v15 = a2;
  int v14 = a3;
  int v13 = a4;
  uint64_t v12 = a5;
  uint64_t v11 = 0;
  uint64_t v10 = 0;
  int v9 = 0;
  uint64_t v8 = 0;
  int v7 = 0;
  int v6 = 0;
  uint64_t v8 = *(void *)(a5 + 1320);
  *a2 = 1;
  uint64_t result = chainsearch(v16, &v6, v12);
  uint64_t v11 = result;
  if (result)
  {
    int v7 = *(_DWORD *)(v11 + 96 + 4 * v13);
    if (v7 >= 0)
    {
      *uint64_t v15 = v6;
      *int v14 = v7;
      goto LABEL_12;
    }
  }
  if (*v16 <= 255)
  {
    *int v14 = *(_DWORD *)(*(void *)(*(void *)(v12 + 1320) + 192) + 40 * *v16 + 4 * v13);
    goto LABEL_12;
  }
  if (*(int *)(*(void *)(*(void *)(v12 + 1320) + 88) + 60) > 0)
  {
    uint64_t result = largesearch(*v16, v12);
    uint64_t v10 = result;
    if (result)
    {
      *int v14 = *(_DWORD *)(v10 + 4 + 4 * v13);
LABEL_12:
      uint64_t result = (uint64_t)lookup_substsearch(v8, *v14, 0);
      int v9 = (int *)result;
      if (result) {
        *int v14 = *v9;
      }
      return result;
    }
  }
  if ((*(unsigned char *)(*(void *)(*(void *)(v12 + 1320) + 88) + 1 + v13) & 8) != 0) {
    *int v14 = *v16 & 0xFFFFFF;
  }
  else {
    *int v14 = *(_DWORD *)(*(void *)(*(void *)(v12 + 1320) + 88) + 104 + 4 * v13);
  }
  return result;
}

int *__collate_xfrm(const __int32 *a1, uint64_t a2, uint64_t a3)
{
  int v29 = a1;
  uint64_t v28 = a2;
  uint64_t v27 = a3;
  int v26 = 0;
  int v25 = 0;
  uint64_t v23 = 0;
  int v22 = 0;
  unsigned __int8 v17 = *(unsigned __int8 **)(*(void *)(a3 + 1320) + 88);
  for (int i = 0; i < 10; ++i)
    *(void *)(v28 + 8 * i) = 0;
  for (int j = 0; j < *v17; ++j)
  {
    unsigned __int8 v21 = v17[j + 1];
    if (!j || (*((_DWORD *)v17 + 13) & 1) == 0)
    {
      int v13 = *__error();
      free(v23);
      *__error() = v13;
      uint64_t v23 = __collate_substitute(v29, j, v27);
    }
    if ((v21 & 2) != 0)
    {
      int v14 = *__error();
      free(v22);
      *__error() = v14;
      if (v23) {
        BOOL v3 = __collate_wcsdup(v23);
      }
      else {
        BOOL v3 = __collate_wcsdup(v29);
      }
      int v22 = v3;
      uint64_t v12 = v3;
      for (int k = &v3[wcslen(v3) - 1]; v12 < k; --k)
      {
        __int32 v10 = *v12;
        char v4 = v12++;
        *char v4 = *k;
        size_t v5 = k;
        *size_t v5 = v10;
      }
      sigset_t v24 = v22;
    }
    else if (v23)
    {
      sigset_t v24 = v23;
    }
    else
    {
      sigset_t v24 = v29;
    }
    int v15 = *__error();
    wcslen(v24);
    uint64_t v6 = malloc_type_malloc();
    *(void *)(v28 + 8 * j) = v6;
    if (!v6)
    {
      *__error() = v15;
      break;
    }
    *__error() = v15;
    uint64_t v18 = *(_DWORD **)(v28 + 8 * j);
    if ((v21 & 4) != 0)
    {
      while (*v24)
      {
        __collate_lookup_which(v24, &v25, &v26, j, v27);
        v24 += v25;
        if (v26 <= 0)
        {
          if (v26 < 0) {
            goto LABEL_26;
          }
          int v26 = 0xFFFFFF;
        }
        int v7 = v18++;
        *int v7 = v26;
      }
    }
    else
    {
      while (*v24)
      {
        __collate_lookup_which(v24, &v25, &v26, j, v27);
        v24 += v25;
        if (v26 > 0)
        {
          uint64_t v8 = v18++;
          *uint64_t v8 = v26;
        }
        else if (v26 < 0)
        {
LABEL_26:
          *__error() = 22;
          goto LABEL_36;
        }
      }
    }
    *uint64_t v18 = 0;
  }
LABEL_36:
  int v16 = *__error();
  free(v23);
  free(v22);
  uint64_t result = __error();
  int *result = v16;
  return result;
}

uint64_t __collate_collating_symbol(__int32 *a1, size_t a2, char *a3, size_t a4, mbstate_t *a5, _xlocale *a6)
{
  char v20 = a1;
  size_t v19 = a2;
  uint64_t v18 = a3;
  size_t v17 = a4;
  int v16 = a5;
  locale_t v15 = a6;
  __int32 v14 = 0;
  int v13 = 0;
  size_t i = 0;
  size_t v11 = 0;
  if (*(unsigned char *)(*((void *)a6 + 165) + 64))
  {
    if (v19)
    {
      if (v17 == 1 && isascii(*v18))
      {
        __int32 *v20 = *v18;
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    int v13 = v22;
    for (size_t i = 0; v17; ++i)
    {
      size_t v11 = mbrtowc_l(&v14, v18, v17, v16, v15);
      if (v11 >= 0xFFFFFFFFFFFFFFFELL) {
        return -1;
      }
      if (!v11) {
        break;
      }
      if (i >= 0x18) {
        return -1;
      }
      uint64_t v6 = v13++;
      *uint64_t v6 = v14;
      v18 += v11;
      v17 -= v11;
    }
    if (i && i <= v19)
    {
      if (i == 1)
      {
        if (v22[0] > 255)
        {
          if (*(int *)(*(void *)(*((void *)v15 + 165) + 88) + 60) > 0
            && (uint64_t v10 = largesearch(v22[0], (uint64_t)v15)) != 0
            && *(int *)(v10 + 4) >= 0)
          {
            if (v19) {
              __int32 *v20 = v22[0];
            }
            return 1;
          }
          else
          {
            return 0;
          }
        }
        else if (*(int *)(*(void *)(*((void *)v15 + 165) + 192) + 40 * v22[0]) < 0)
        {
          return 0;
        }
        else
        {
          if (v19) {
            __int32 *v20 = v22[0];
          }
          return 1;
        }
      }
      else
      {
        *int v13 = 0;
        if (*(int *)(*(void *)(*((void *)v15 + 165) + 88) + 56) > 0
          && (v9 = 0, int v8 = 0, (v9 = chainsearch(v22, &v8, (uint64_t)v15)) != 0))
        {
          if (v8 < v19) {
            size_t v19 = v8;
          }
          wcsncpy(v20, v22, v19);
          return v8;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return -1;
    }
  }
}

uint64_t __collate_equiv_class(char *a1, size_t a2, mbstate_t *a3, _xlocale *a4)
{
  size_t v19 = a1;
  size_t v18 = a2;
  size_t v17 = a3;
  locale_t v16 = a4;
  __int32 v15 = 0;
  __int32 v14 = 0;
  unint64_t i = 0;
  size_t v12 = 0;
  int v11 = 0;
  if (*(unsigned char *)(*((void *)a4 + 165) + 64))
  {
    return 0;
  }
  else
  {
    __int32 v14 = v21;
    for (unint64_t i = 0; v18; ++i)
    {
      size_t v12 = mbrtowc_l(&v15, v19, v18, v17, v16);
      if (v12 >= 0xFFFFFFFFFFFFFFFELL) {
        return -1;
      }
      if (!v12) {
        break;
      }
      if (i >= 0x18) {
        return -1;
      }
      char v4 = v14++;
      *char v4 = v15;
      v19 += v12;
      v18 -= v12;
    }
    if (i)
    {
      if (i == 1)
      {
        int v11 = -1;
        if (v21[0] > 255)
        {
          if (*(int *)(*(void *)(*((void *)v16 + 165) + 88) + 60) > 0)
          {
            uint64_t v10 = largesearch(v21[0], (uint64_t)v16);
            if (v10) {
              int v11 = *(_DWORD *)(v10 + 4);
            }
          }
        }
        else
        {
          int v11 = *(_DWORD *)(*(void *)(*((void *)v16 + 165) + 192) + 40 * v21[0]);
        }
        if (v11)
        {
          if (v11 <= 0) {
            return 0;
          }
          else {
            return v11;
          }
        }
        else
        {
          return 1;
        }
      }
      else
      {
        *__int32 v14 = 0;
        if (*(int *)(*(void *)(*((void *)v16 + 165) + 88) + 56) > 0
          && (v9 = 0, int v8 = 0, (v9 = chainsearch(v21, &v8, (uint64_t)v16)) != 0))
        {
          int v11 = *(_DWORD *)(v9 + 96);
          if (v11)
          {
            if (v11 >= 0) {
              return v11;
            }
            else {
              return -v11;
            }
          }
          else
          {
            return 1;
          }
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return -1;
    }
  }
}

uint64_t __collate_equiv_match(int a1, _DWORD *a2, unint64_t a3, __int32 a4, char *a5, size_t a6, void *a7, void *a8, _xlocale *a9)
{
  int v35 = a1;
  uint64_t v34 = a2;
  unint64_t v33 = a3;
  __int32 v32 = a4;
  int v31 = a5;
  size_t v30 = a6;
  uint64_t __src = a7;
  uint64_t v28 = a8;
  locale_t v27 = a9;
  __int32 v26 = 0;
  unint64_t v25 = 0;
  size_t v24 = 0;
  uint64_t v23 = 0;
  int v22 = 0;
  memset(__b, 0, sizeof(__b));
  size_t v19 = v31;
  size_t v18 = v30;
  if (*(unsigned char *)(*((void *)a9 + 165) + 64)) {
    return -1;
  }
  if (v35 == 1) {
    int v35 = 0;
  }
  if (__src) {
    memcpy(__b, __src, sizeof(__b));
  }
  char v20 = &v38;
  uint64_t v23 = 0;
  unint64_t v25 = 0;
  if (v32)
  {
    char v20 = &v39;
    __int32 v38 = v32;
    unint64_t v25 = 1;
  }
  while (1)
  {
    BOOL v14 = 0;
    if (v18) {
      BOOL v14 = v25 < *(unsigned __int8 *)(*(void *)(*((void *)v27 + 165) + 88) + 11);
    }
    if (!v14) {
      break;
    }
    size_t v24 = mbrtowc_l(&v26, v19, v18, (mbstate_t *)__src, v27);
    if (v24 == -1 || v24 == -2 || !v24) {
      break;
    }
    uint64_t v9 = v20++;
    *uint64_t v9 = v26;
    v19 += v24;
    v23 += v24;
    v18 -= v24;
    ++v25;
  }
  __int32 *v20 = 0;
  if (v25 <= 1) {
    goto LABEL_22;
  }
  uint64_t v17 = chainsearch(&v38, &v22, (uint64_t)v27);
  if (!v17) {
    goto LABEL_22;
  }
  int v16 = *(_DWORD *)(v17 + 96);
  if (v16 < 0) {
    int v16 = -v16;
  }
  if (v16 != v35)
  {
LABEL_22:
    int v22 = 1;
    if (v38 > 255)
    {
      if (*(int *)(*(void *)(*((void *)v27 + 165) + 88) + 60) <= 0) {
        goto LABEL_28;
      }
      uint64_t v15 = largesearch(v38, (uint64_t)v27);
      if (!v15 || v35 != *(_DWORD *)(v15 + 4)) {
        goto LABEL_28;
      }
    }
    else if (v35 != *(_DWORD *)(*(void *)(*((void *)v27 + 165) + 192) + 40 * v38))
    {
LABEL_28:
      if (__src) {
        memcpy(__src, __b, 0x80uLL);
      }
      return 0;
    }
  }
  if (v22 < v25)
  {
    unint64_t v25 = v22;
    if (__src) {
      memcpy(__src, __b, 0x80uLL);
    }
    if (v32) {
      --v22;
    }
    uint64_t v23 = 0;
    while (1)
    {
      int v10 = v22--;
      if (v10 <= 0) {
        break;
      }
      size_t v24 = mbrtowc_l(&v26, v31, v30, (mbstate_t *)__src, v27);
      v31 += v24;
      v23 += v24;
      v30 -= v24;
    }
  }
  if (v34)
  {
    if (v33 < v25)
    {
      if (__src) {
        memcpy(__src, __b, 0x80uLL);
      }
      return -1;
    }
    unsigned __int8 v21 = &v38;
    while (v25)
    {
      int v11 = v21++;
      LODWORD(v11) = *v11;
      size_t v12 = v34++;
      *size_t v12 = v11;
      --v25;
    }
  }
  if (v28) {
    *uint64_t v28 = v23;
  }
  return v25;
}

uint64_t __collate_equiv_value(uint64_t a1, __int32 *a2, size_t a3)
{
  uint64_t v13 = a1;
  size_t v12 = a2;
  size_t v11 = a3;
  int v10 = 0;
  if (a3 && v11 < 0x18)
  {
    if (*(unsigned char *)(*(void *)(v13 + 1320) + 64))
    {
      if (v11 == 1 && *v12 <= 255) {
        return *v12;
      }
      else {
        return -1;
      }
    }
    else if (v11 == 1)
    {
      int v10 = -1;
      if (*v12 > 255)
      {
        if (*(int *)(*(void *)(*(void *)(v13 + 1320) + 88) + 60) > 0)
        {
          uint64_t v9 = 0;
          uint64_t v9 = largesearch(*v12, v13);
          if (v9) {
            int v10 = *(_DWORD *)(v9 + 4);
          }
        }
      }
      else
      {
        int v10 = *(_DWORD *)(*(void *)(*(void *)(v13 + 1320) + 192) + 40 * *v12);
      }
      if (v10)
      {
        if (v10 <= 0) {
          return 0;
        }
        else {
          return v10;
        }
      }
      else
      {
        return 1;
      }
    }
    else if (*(int *)(*(void *)(*(void *)(v13 + 1320) + 88) + 56) > 0 {
           && (v8 = 0, int v7 = 0, wcsncpy(v15, v12, v11), v15[v11] = 0, (v8 = chainsearch(v15, &v7, v13)) != 0))
    }
    {
      int v10 = *(_DWORD *)(v8 + 96);
      if (v10)
      {
        if (v10 >= 0) {
          return v10;
        }
        else {
          return -v10;
        }
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t _OSSwapInt32(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t wntohl(uint64_t result, int a2)
{
  for (unint64_t i = (unsigned int *)result; ; ++i)
  {
    BOOL v2 = 0;
    if (*i) {
      BOOL v2 = a2 > 0;
    }
    if (!v2) {
      break;
    }
    uint64_t result = _OSSwapInt32(*i);
    *unint64_t i = result;
    --a2;
  }
  return result;
}

void *__collate_fill_info(uint64_t a1, uint64_t a2)
{
  mbstate_t __b = *(unsigned char **)(a1 + 88);
  uint64_t result = memset(__b, 0, 0x90uLL);
  *mbstate_t __b = *(unsigned char *)(a2 + 3) & 0xF;
  __b[11] = *(unsigned char *)(a2 + 3) >> 4;
  *((_DWORD *)__b + 13) = *(unsigned __int8 *)(a2 + 2) | 2;
  *((_DWORD *)__b + 14) = *(_DWORD *)(a2 + 20);
  *((_DWORD *)__b + 15) = *(_DWORD *)(a2 + 24);
  *(_WORD *)(__b + 1) = *(_WORD *)a2;
  *((void *)__b + 8) = *(void *)(a2 + 12);
  *((void *)__b + 13) = *(void *)(a2 + 4);
  return result;
}

uint64_t __collate_range_cmp(int a1, int a2, _xlocale *a3)
{
  __collate_range_cmp_s1 = a1;
  __collate_range_cmp_s2 = a2;
  return wcscoll_l(&__collate_range_cmp_s1, &__collate_range_cmp_s2, a3);
}

uint64_t _EUC_CN_init(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  *(void *)(v2 + 3184) = 0;
  uint64_t result = 0;
  *(_DWORD *)(v2 + 3192) = 0;
  *(void *)(a1 + 72) = _EUC_CN_mbrtowc;
  *(void *)(a1 + 96) = _EUC_CN_wcrtomb;
  *(void *)(a1 + 88) = _EUC_CN_mbsnrtowcs;
  *(void *)(a1 + 104) = _EUC_CN_wcsnrtombs;
  *(void *)(a1 + 80) = _EUC_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return result;
}

uint64_t _EUC_CN_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, uint64_t a5)
{
  return _EUC_mbrtowc_impl(a1, a2, a3, a4, 0, 0, 0, 0, a5);
}

uint64_t _EUC_CN_wcrtomb(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  return _EUC_wcrtomb_impl(a1, a2, a3, 0, 0, 0, 0);
}

uint64_t _EUC_CN_mbsnrtowcs(int *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return __mbsnrtowcs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_CN_wcsnrtombs(void *a1, _DWORD **a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6)
{
  return __wcsnrtombs_std(a1, a2, a3, a4, a5, a6);
}

BOOL _EUC_mbsinit(uint64_t a1)
{
  BOOL v2 = 1;
  if (a1) {
    return *(_DWORD *)(a1 + 4) == 0;
  }
  return v2;
}

uint64_t _EUC_KR_init(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  *(void *)(v2 + 3184) = 0;
  uint64_t result = 0;
  *(_DWORD *)(v2 + 3192) = 0;
  *(void *)(a1 + 72) = _EUC_KR_mbrtowc;
  *(void *)(a1 + 96) = _EUC_KR_wcrtomb;
  *(void *)(a1 + 88) = _EUC_KR_mbsnrtowcs;
  *(void *)(a1 + 104) = _EUC_KR_wcsnrtombs;
  *(void *)(a1 + 80) = _EUC_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return result;
}

uint64_t _EUC_KR_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, uint64_t a5)
{
  return _EUC_mbrtowc_impl(a1, a2, a3, a4, 0, 0, 0, 0, a5);
}

uint64_t _EUC_KR_wcrtomb(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  return _EUC_wcrtomb_impl(a1, a2, a3, 0, 0, 0, 0);
}

uint64_t _EUC_KR_mbsnrtowcs(int *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return __mbsnrtowcs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_KR_wcsnrtombs(void *a1, _DWORD **a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6)
{
  return __wcsnrtombs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_JP_init(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  *(void *)(v2 + 3184) = 0;
  uint64_t result = 0;
  *(_DWORD *)(v2 + 3192) = 0;
  *(void *)(a1 + 72) = _EUC_JP_mbrtowc;
  *(void *)(a1 + 96) = _EUC_JP_wcrtomb;
  *(void *)(a1 + 88) = _EUC_JP_mbsnrtowcs;
  *(void *)(a1 + 104) = _EUC_JP_wcsnrtombs;
  *(void *)(a1 + 80) = _EUC_mbsinit;
  *(_DWORD *)(a1 + 64) = 3;
  *(_DWORD *)(a1 + 68) = 128;
  return result;
}

uint64_t _EUC_JP_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, uint64_t a5)
{
  return _EUC_mbrtowc_impl(a1, a2, a3, a4, 0x8Eu, 2u, 0x8Fu, 3u, a5);
}

uint64_t _EUC_JP_wcrtomb(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  return _EUC_wcrtomb_impl(a1, a2, a3, 0x8Eu, 2u, 0x8Fu, 3u);
}

uint64_t _EUC_JP_mbsnrtowcs(int *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return __mbsnrtowcs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_JP_wcsnrtombs(void *a1, _DWORD **a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6)
{
  return __wcsnrtombs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_init(uint64_t a1)
{
  unsigned int v2 = _EUC_JP_init(a1);
  if (!v2) {
    *(_DWORD *)(a1 + 68) = 256;
  }
  return v2;
}

uint64_t _EUC_TW_init(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 120);
  *(void *)(v2 + 3184) = 0;
  uint64_t result = 0;
  *(_DWORD *)(v2 + 3192) = 0;
  *(void *)(a1 + 72) = _EUC_TW_mbrtowc;
  *(void *)(a1 + 96) = _EUC_TW_wcrtomb;
  *(void *)(a1 + 88) = _EUC_TW_mbsnrtowcs;
  *(void *)(a1 + 104) = _EUC_TW_wcsnrtombs;
  *(void *)(a1 + 80) = _EUC_mbsinit;
  *(_DWORD *)(a1 + 64) = 4;
  *(_DWORD *)(a1 + 68) = 128;
  return result;
}

uint64_t _EUC_TW_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, uint64_t a5)
{
  return _EUC_mbrtowc_impl(a1, a2, a3, a4, 0x8Eu, 4u, 0, 0, a5);
}

uint64_t _EUC_TW_wcrtomb(unsigned char *a1, unsigned int a2, uint64_t a3)
{
  return _EUC_wcrtomb_impl(a1, a2, a3, 0x8Eu, 4u, 0, 0);
}

uint64_t _EUC_TW_mbsnrtowcs(int *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return __mbsnrtowcs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_TW_wcsnrtombs(void *a1, _DWORD **a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6)
{
  return __wcsnrtombs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_mbrtowc_impl(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, uint64_t a9)
{
  uint64_t v17 = a2;
  int v13 = 0;
  if (a4[1] < 0 || a4[1] > *(_DWORD *)(*(void *)(a9 + 1328) + 64))
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    uint64_t v17 = (unsigned __int8 *)&unk_D793D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3) {
    return -2;
  }
  if (a4[1])
  {
    int v14 = a4[1];
    int v13 = *a4;
  }
  else
  {
    unsigned __int8 v12 = *v17;
    if ((*v17 & 0x80u) == 0)
    {
      if (a1) {
        *a1 = v12;
      }
      return v12 != 0;
    }
    if (v12 < 0xA1u)
    {
      if (v12 == a5)
      {
        int v14 = a6;
      }
      else
      {
        if (v12 != a7)
        {
          *__error() = 92;
          return -1;
        }
        int v14 = a8;
      }
    }
    else
    {
      int v14 = 2;
    }
    a4[1] = v14;
    *a4 = 0;
  }
  for (int i = 0; ; ++i)
  {
    unint64_t v11 = v14 >= a3 ? a3 : v14;
    if (i >= v11) {
      break;
    }
    int v13 = (v13 << 8) | *v17++;
  }
  if (i >= v14)
  {
    if (a1) {
      *a1 = v13;
    }
    a4[1] = 0;
    if (v13) {
      return v14;
    }
    else {
      return 0;
    }
  }
  else
  {
    a4[1] = v14 - i;
    *a4 = v13;
    *__error() = 92;
    return -2;
  }
}

uint64_t _EUC_wcrtomb_impl(unsigned char *a1, unsigned int a2, uint64_t a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7)
{
  int v18 = a2;
  if (*(_DWORD *)(a3 + 4))
  {
    *__error() = 22;
    return -1;
  }
  if (!a1) {
    return 1;
  }
  if ((a2 & 0xFFFFFF80) == 0)
  {
    *a1 = a2;
    return 1;
  }
  BOOL v7 = a2 == 0xFFFFFF;
  if (a2 <= 0xFFFFFF)
  {
    BOOL v7 = a2 == 0x10000;
    if (a2 < 0x10000)
    {
      BOOL v7 = a2 == 255;
      if (a2 <= 0xFF) {
        int v12 = 1;
      }
      else {
        int v12 = 2;
      }
    }
    else
    {
      int v12 = 3;
    }
  }
  else
  {
    int v12 = 4;
  }
  char v8 = v7;
  if (v8)
  {
    unsigned __int8 v21 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v22 = __locale_key;
    unsigned __int8 v21 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v22);
  }
  if (v21) {
    int v10 = v21;
  }
  else {
    int v10 = __global_locale;
  }
  if (v12 > *(_DWORD *)(v10[166] + 64))
  {
LABEL_32:
    *__error() = 92;
    return -1;
  }
  if (v18 < 41216 || v18 >= 0x10000)
  {
    int v11 = (v18 >> (8 * (v12 - 1)));
    if (v11 == a4)
    {
      if (v12 != a5) {
        goto LABEL_32;
      }
    }
    else if (v11 != a6 || v12 != a7)
    {
      goto LABEL_32;
    }
  }
  for (int i = v12 - 1; i >= 0; --i)
  {
    a1[i] = v18;
    v18 >>= 8;
  }
  return v12;
}

unsigned __int8 *__fix_locale_grouping_str(unsigned __int8 *a1)
{
  if (!a1 || !*a1) {
    return (unsigned __int8 *)&nogrouping;
  }
  uint64_t v6 = a1;
  size_t v5 = a1;
  while (1)
  {
    if (!*v6)
    {
      *size_t v5 = 0;
      return a1;
    }
    if (*v6 != 59) {
      break;
    }
LABEL_20:
    ++v6;
  }
  if (*v6 == 45 && v6[1] == 49)
  {
    char v1 = v5++;
    *char v1 = 127;
    ++v6;
    goto LABEL_20;
  }
  if (!isdigit(*v6)) {
    return (unsigned __int8 *)&nogrouping;
  }
  unsigned __int8 v4 = *v6 - 48;
  if (isdigit(v6[1])) {
    unsigned __int8 v4 = 10 * v4 + *++v6 - 48;
  }
  *size_t v5 = v4;
  if (*v5)
  {
    ++v5;
    goto LABEL_20;
  }
  if (v5 == a1) {
    return (unsigned __int8 *)&nogrouping;
  }
  else {
    return a1;
  }
}

unsigned char *__fix_nogrouping(unsigned char *a1)
{
  if (a1 && *a1) {
    return a1;
  }
  else {
    return &__nogrouping;
  }
}

uint64_t _GB18030_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _GB18030_mbrtowc;
  *(void *)(a1 + 96) = _GB18030_wcrtomb;
  *(void *)(a1 + 80) = _GB18030_mbsinit;
  *(_DWORD *)(a1 + 64) = 4;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _GB18030_mbrtowc(int *a1, const char *a2, unint64_t a3, int *a4)
{
  uint64_t v23 = a2;
  if (*a4 < 0 || (unint64_t)*a4 > 4)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    uint64_t v23 = (const char *)&unk_D793D;
    a3 = 1;
    a1 = 0;
  }
  if (a3 >= 4) {
    unint64_t v11 = 4;
  }
  else {
    unint64_t v11 = a3;
  }
  if (v11 >= 4 - *a4)
  {
    size_t v9 = 4 - *a4;
  }
  else
  {
    if (a3 >= 4) {
      uint64_t v10 = 4;
    }
    else {
      uint64_t v10 = a3;
    }
    size_t v9 = v10;
  }
  strncpy((char *)a4 + *a4 + 4, v23, v9);
  int v12 = *a4;
  *a4 += v9;
  unint64_t v22 = *a4;
  if (!*a4) {
    return -2;
  }
  unsigned __int8 v4 = (unsigned __int8 *)(a4 + 1);
  if (*((unsigned __int8 *)a4 + 4) > 0x7Fu)
  {
    if (*v4 >= 0x81u && *v4 != 255)
    {
      int v17 = *v4;
      if (v22 < 2) {
        return -2;
      }
      size_t v5 = (unsigned __int8 *)a4 + 5;
      unsigned int v14 = *((unsigned __int8 *)a4 + 5);
      if (v14 >= 0x40 && *v5 <= 0x7Eu || *v5 >= 0x80u && *v5 != 255)
      {
        int v16 = v14 | (v17 << 8);
        int v13 = 2;
        goto LABEL_43;
      }
      if (*v5 >= 0x30u && *v5 <= 0x39u)
      {
        int v18 = v14 | ((v17 & 0x7F) << 8);
        if (v22 < 3) {
          return -2;
        }
        uint64_t v6 = (unsigned __int8 *)a4 + 6;
        size_t v24 = (unsigned __int8 *)a4 + 7;
        if (*((unsigned __int8 *)a4 + 6) >= 0x81u && *v6 != 255)
        {
          int v19 = *v6 | (v18 << 8);
          if (v22 < 4) {
            return -2;
          }
          unsigned int v15 = *v24;
          if (v15 >= 0x30 && *v24 <= 0x39u)
          {
            int v16 = v15 | (v19 << 8);
            int v13 = 4;
            goto LABEL_43;
          }
        }
      }
    }
    *__error() = 92;
    return -1;
  }
  int v13 = 1;
  int v16 = *v4;
LABEL_43:
  if (a1) {
    *a1 = v16;
  }
  *a4 = 0;
  if (v16) {
    return v13 - v12;
  }
  else {
    return 0;
  }
}

uint64_t _GB18030_wcrtomb(unsigned char *a1, int a2, _DWORD *a3)
{
  if (!*a3)
  {
    if (!a1) {
      return 1;
    }
    if (a2 >= 0)
    {
      if ((a2 & 0x7F000000) != 0)
      {
        unsigned int v5 = a2 | 0x80000000;
        if ((a2 | 0x80000000) >> 24 < 0x81) {
          goto LABEL_34;
        }
        if (HIBYTE(v5) == 255) {
          goto LABEL_34;
        }
        *a1 = (a2 | 0x80000000) >> 24;
        if (BYTE2(v5) < 0x30u) {
          goto LABEL_34;
        }
        if (BYTE2(v5) > 0x39u) {
          goto LABEL_34;
        }
        a1[1] = BYTE2(v5);
        if (BYTE1(v5) < 0x81u) {
          goto LABEL_34;
        }
        if (BYTE1(v5) == 255) {
          goto LABEL_34;
        }
        a1[2] = BYTE1(v5);
        if (a2 < 0x30u || a2 > 0x39u) {
          goto LABEL_34;
        }
        a1[3] = a2;
        return 4;
      }
      if ((a2 & 0xFF0000) == 0)
      {
        if ((a2 & 0xFF00) != 0)
        {
          if (BYTE1(a2) < 0x81u) {
            goto LABEL_34;
          }
          if (BYTE1(a2) == 255) {
            goto LABEL_34;
          }
          *a1 = BYTE1(a2);
          if (a2 < 0x40u || a2 == 127 || a2 == 255) {
            goto LABEL_34;
          }
          a1[1] = a2;
          return 2;
        }
        if (a2 <= 127)
        {
          *a1 = a2;
          return 1;
        }
      }
    }
LABEL_34:
    *__error() = 92;
    return -1;
  }
  *__error() = 22;
  return -1;
}

BOOL _GB18030_mbsinit(_DWORD *a1)
{
  BOOL v2 = 1;
  if (a1) {
    return *a1 == 0;
  }
  return v2;
}

uint64_t _GB2312_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _GB2312_mbrtowc;
  *(void *)(a1 + 96) = _GB2312_wcrtomb;
  *(void *)(a1 + 80) = _GB2312_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _GB2312_mbrtowc(int *a1, const char *a2, unint64_t a3, char *a4)
{
  int v17 = a2;
  if (*(int *)a4 >= 0 && (unint64_t)*(int *)a4 <= 2)
  {
    if (!a2)
    {
      int v17 = (const char *)&unk_D793D;
      a3 = 1;
      a1 = 0;
    }
    if (a3 >= 2) {
      unint64_t v10 = 2;
    }
    else {
      unint64_t v10 = a3;
    }
    if (v10 >= 2 - *(int *)a4)
    {
      size_t v8 = 2 - *(int *)a4;
    }
    else
    {
      if (a3 >= 2) {
        uint64_t v9 = 2;
      }
      else {
        uint64_t v9 = a3;
      }
      size_t v8 = v9;
    }
    strncpy(&a4[*(int *)a4 + 4], v17, v8);
    int v11 = *(_DWORD *)a4;
    *(_DWORD *)a4 += v8;
    int v18 = (int *)(a4 + 4);
    int v12 = _GB2312_check(a4 + 4, *(int *)a4);
    if (v12 >= 0)
    {
      int v14 = 0;
      int v13 = v12;
      while (1)
      {
        int v4 = v13--;
        if (v4 <= 0) {
          break;
        }
        unsigned int v5 = v18;
        int v18 = (int *)((char *)v18 + 1);
        int v14 = *(unsigned __int8 *)v5 | (v14 << 8);
      }
      if (a1) {
        *a1 = v14;
      }
      *(_DWORD *)a4 = 0;
      if (v14) {
        return v12 - v11;
      }
      else {
        return 0;
      }
    }
    else
    {
      return v12;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t _GB2312_wcrtomb(unsigned char *a1, __int16 a2, _DWORD *a3)
{
  if (*a3)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if (a2 < 0)
    {
      *a1 = HIBYTE(a2);
      a1[1] = a2;
      return 2;
    }
    else
    {
      *a1 = a2;
      return 1;
    }
  }
  else
  {
    return 1;
  }
}

BOOL _GB2312_mbsinit(_DWORD *a1)
{
  BOOL v2 = 1;
  if (a1) {
    return *a1 == 0;
  }
  return v2;
}

uint64_t _GB2312_check(char *a1, unint64_t a2)
{
  if (a2)
  {
    if (*a1 < 0xA1u || *a1 == 255)
    {
      if (*a1 >= 0) {
        return 1;
      }
      else {
        return -1;
      }
    }
    else if (a2 >= 2)
    {
      if (a1[1] < 0xA1u || a1[1] == 255) {
        return -1;
      }
      else {
        return 2;
      }
    }
    else
    {
      return -2;
    }
  }
  else
  {
    return -2;
  }
}

uint64_t _GBK_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _GBK_mbrtowc;
  *(void *)(a1 + 96) = _GBK_wcrtomb;
  *(void *)(a1 + 80) = _GBK_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _GBK_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4)
{
  int v11 = a2;
  if ((*a4 & 0xFFFFFF00) != 0)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    int v11 = (unsigned __int8 *)&unk_D793D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3) {
    return -2;
  }
  if (*a4)
  {
    if (!*v11)
    {
LABEL_9:
      *__error() = 92;
      return -1;
    }
    if (a1) {
      *a1 = *v11 | (*a4 << 8);
    }
    *a4 = 0;
    return 1;
  }
  else
  {
    uint64_t v6 = (int)_gbk_check(*v11);
    int v4 = v11;
    int v12 = v11 + 1;
    int v7 = *v4;
    if (v6 == 2)
    {
      if (a3 < 2)
      {
        *a4 = v7;
        return -2;
      }
      if (!*v12) {
        goto LABEL_9;
      }
      int v8 = *v12 | (v7 << 8);
      if (a1) {
        *a1 = v8;
      }
      return 2;
    }
    else
    {
      if (a1) {
        *a1 = v7;
      }
      return v7 != 0;
    }
  }
}

uint64_t _GBK_wcrtomb(unsigned char *a1, __int16 a2, _DWORD *a3)
{
  if (*a3)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if (a2 < 0)
    {
      *a1 = HIBYTE(a2);
      a1[1] = a2;
      return 2;
    }
    else
    {
      *a1 = a2;
      return 1;
    }
  }
  else
  {
    return 1;
  }
}

BOOL _GBK_mbsinit(_DWORD *a1)
{
  BOOL v2 = 1;
  if (a1) {
    return *a1 == 0;
  }
  return v2;
}

uint64_t _gbk_check(unsigned __int8 a1)
{
  BOOL v2 = 0;
  if (a1 >= 0x81u) {
    BOOL v2 = a1 != 255;
  }
  if (v2) {
    return 2;
  }
  else {
    return 1;
  }
}

uint64_t __part_load_locale(char *a1, unsigned char *a2, void **a3, char *a4, int a5, int a6, uint64_t a7)
{
  __s = a1;
  size_t v24 = a2;
  uint64_t v23 = a3;
  __s2 = a4;
  int v21 = a5;
  int v20 = a6;
  uint64_t v19 = a7;
  int v18 = 0;
  int v17 = 0;
  int i = 0;
  int v15 = 0;
  int v14 = 0;
  int v13 = 0;
  int v12 = 0;
  memset(&__b, 0, sizeof(__b));
  size_t v10 = strlen(__s) + 1;
  strcpy(__dst, __s);
  strcat(__dst, "/");
  strcat(__dst, __s2);
  int v17 = __open_path_locale(__dst);
  if (v17 < 0) {
    return -1;
  }
  if (fstat(v17, &__b))
  {
LABEL_24:
    int v18 = *__error();
    close_NOCANCEL();
    int v8 = v18;
    *__error() = v8;
    return -1;
  }
  if (__b.st_size <= 0)
  {
    *__error() = 79;
    goto LABEL_24;
  }
  int v14 = (char *)malloc_type_malloc();
  if (!v14)
  {
    *__error() = 12;
    goto LABEL_24;
  }
  strcpy(v14, __s);
  int v13 = &v14[v10];
  int v12 = &v14[v10 + __b.st_size];
  if (read_NOCANCEL() != __b.st_size)
  {
LABEL_23:
    int v18 = *__error();
    free(v14);
    int v9 = v18;
    *__error() = v9;
    goto LABEL_24;
  }
  if (*(v12 - 1) != 10)
  {
LABEL_10:
    *__error() = 79;
    goto LABEL_23;
  }
  int v15 = split_lines(v13, (unint64_t)v12);
  if (v15 < v21)
  {
    if (v15 < v20) {
      goto LABEL_10;
    }
  }
  else
  {
    int v15 = v21;
  }
  close_NOCANCEL();
  if (*v23) {
    free(*v23);
  }
  *uint64_t v23 = v14;
  int v13 = (char *)*v23;
  for (int i = 0; i < v15; ++i)
  {
    v13 += strlen(v13) + 1;
    *(void *)(v19 + 8 * i) = v13;
  }
  for (int i = v15; i < v21; ++i)
    *(void *)(v19 + 8 * i) = 0;
  *size_t v24 = 1;
  return 0;
}

uint64_t split_lines(unsigned char *a1, unint64_t a2)
{
  unsigned int v3 = 0;
  while ((unint64_t)a1 < a2)
  {
    if (*a1 == 10)
    {
      *a1 = 0;
      ++v3;
    }
    ++a1;
  }
  return v3;
}

void destruct_ldpart(void **a1)
{
  if (a1) {
    free(a1[8]);
  }
  free(a1);
}

uint64_t __messages_load_locale(char *a1, uint64_t a2)
{
  if (!strcmp(a1, "C") || !strcmp(a1, "POSIX") || !strncmp(a1, "C.", 2uLL))
  {
    *(unsigned char *)(a2 + 1312) = 0;
    xlocale_release(*(void *)(a2 + 1360));
    *(void *)(a2 + 1360) = 0;
    return 1;
  }
  else if (__messages_load_locale_cache {
         && *(void *)(__messages_load_locale_cache + 64)
  }
         && !strcmp(a1, *(const char **)(__messages_load_locale_cache + 64)))
  {
    *(unsigned char *)(a2 + 1312) = 1;
    xlocale_release(*(void *)(a2 + 1360));
    *(void *)(a2 + 1360) = __messages_load_locale_cache;
    xlocale_retain((atomic_uint *)__messages_load_locale_cache);
    return 1;
  }
  else
  {
    unsigned int v3 = (void **)malloc_type_malloc();
    if (v3)
    {
      *(_DWORD *)unsigned int v3 = 1;
      v3[1] = destruct_ldpart;
      v3[8] = 0;
      unsigned int locale = __part_load_locale(a1, (unsigned char *)(a2 + 1312), v3 + 8, "LC_MESSAGES/LC_MESSAGES", 4, 2, (uint64_t)(v3 + 9));
      if (locale)
      {
        if (locale == -1) {
          free(v3);
        }
      }
      else
      {
        if (!v3[11]) {
          v3[11] = &empty;
        }
        if (!v3[12]) {
          unsigned char v3[12] = &empty;
        }
        xlocale_release(*(void *)(a2 + 1360));
        *(void *)(a2 + 1360) = v3;
        xlocale_release(__messages_load_locale_cache);
        __messages_load_locale_cache = (uint64_t)v3;
        xlocale_retain((atomic_uint *)v3);
      }
      return locale;
    }
    else
    {
      return -1;
    }
  }
}

char **__get_current_messages_locale(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1312)) {
    return (char **)(*(void *)(a1 + 1360) + 72);
  }
  else {
    return _C_messages_locale;
  }
}

uint64_t __monetary_load_locale(char *a1, uint64_t a2)
{
  if (!strcmp(a1, "C") || !strcmp(a1, "POSIX") || !strncmp(a1, "C.", 2uLL))
  {
    if (*(unsigned char *)(a2 + 1313))
    {
      *(unsigned char *)(a2 + 1313) = 0;
      xlocale_release(*(void *)(a2 + 1336));
      *(void *)(a2 + 1336) = 0;
      *(unsigned char *)(a2 + 1316) = 1;
    }
    return 1;
  }
  else if (*(unsigned char *)(a2 + 1313) && !strcmp(a1, *(const char **)(*(void *)(a2 + 1336) + 64)))
  {
    return 1;
  }
  else if (__monetary_load_locale_cache {
         && *(void *)(__monetary_load_locale_cache + 64)
  }
         && !strcmp(a1, *(const char **)(__monetary_load_locale_cache + 64)))
  {
    *(unsigned char *)(a2 + 1313) = 1;
    xlocale_release(*(void *)(a2 + 1336));
    *(void *)(a2 + 1336) = __monetary_load_locale_cache;
    xlocale_retain((atomic_uint *)__monetary_load_locale_cache);
    *(unsigned char *)(a2 + 1316) = 1;
    return 1;
  }
  else
  {
    unsigned int v3 = (void *)malloc_type_malloc();
    if (v3)
    {
      *(_DWORD *)unsigned int v3 = 1;
      *((void *)v3 + 1) = destruct_ldpart;
      *((void *)v3 + 8) = 0;
      unsigned int locale = __part_load_locale(a1, (unsigned char *)(a2 + 1313), (void **)v3 + 8, "LC_MONETARY", 21, 15, (uint64_t)v3 + 72);
      if (locale == -1) {
        free(v3);
      }
      else {
        *(unsigned char *)(a2 + 1316) = 1;
      }
      if (!locale)
      {
        *((void *)v3 + 13) = __fix_locale_grouping_str(*((unsigned __int8 **)v3 + 13));
        **((unsigned char **)v3 + 16) = cnv(*((const char **)v3 + 16));
        **((unsigned char **)v3 + 17) = cnv(*((const char **)v3 + 17));
        **((unsigned char **)v3 + 18) = cnv(*((const char **)v3 + 18));
        **((unsigned char **)v3 + 19) = cnv(*((const char **)v3 + 19));
        **((unsigned char **)v3 + 20) = cnv(*((const char **)v3 + 20));
        **((unsigned char **)v3 + 21) = cnv(*((const char **)v3 + 21));
        **((unsigned char **)v3 + 22) = cnv(*((const char **)v3 + 22));
        **((unsigned char **)v3 + 23) = cnv(*((const char **)v3 + 23));
        if (*((void *)v3 + 24)) {
          **((unsigned char **)v3 + 24) = cnv(*((const char **)v3 + 24));
        }
        else {
          *((void *)v3 + 24) = *((void *)v3 + 18);
        }
        if (*((void *)v3 + 25)) {
          **((unsigned char **)v3 + 25) = cnv(*((const char **)v3 + 25));
        }
        else {
          *((void *)v3 + 25) = *((void *)v3 + 20);
        }
        if (*((void *)v3 + 26)) {
          **((unsigned char **)v3 + 26) = cnv(*((const char **)v3 + 26));
        }
        else {
          *((void *)v3 + 26) = *((void *)v3 + 19);
        }
        if (*((void *)v3 + 27)) {
          **((unsigned char **)v3 + 27) = cnv(*((const char **)v3 + 27));
        }
        else {
          *((void *)v3 + 27) = *((void *)v3 + 21);
        }
        if (*((void *)v3 + 28)) {
          **((unsigned char **)v3 + 28) = cnv(*((const char **)v3 + 28));
        }
        else {
          *((void *)v3 + 28) = *((void *)v3 + 22);
        }
        if (*((void *)v3 + 29)) {
          **((unsigned char **)v3 + 29) = cnv(*((const char **)v3 + 29));
        }
        else {
          *((void *)v3 + 29) = *((void *)v3 + 23);
        }
        xlocale_release(*(void *)(a2 + 1336));
        *(void *)(a2 + 1336) = v3;
        xlocale_release(__monetary_load_locale_cache);
        __monetary_load_locale_cache = (uint64_t)v3;
        xlocale_retain((atomic_uint *)v3);
      }
      return locale;
    }
    else
    {
      return -1;
    }
  }
}

uint64_t cnv(const char *a1)
{
  int v2 = strtol(a1, 0, 10);
  if (v2 == -1) {
    LOBYTE(v2) = 127;
  }
  return (char)v2;
}

_UNKNOWN **__get_current_monetary_locale(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1313)) {
    return (_UNKNOWN **)(*(void *)(a1 + 1336) + 72);
  }
  else {
    return &_C_monetary_locale;
  }
}

uint64_t __numeric_load_locale(char *a1, uint64_t a2)
{
  if (!strcmp(a1, "C") || !strcmp(a1, "POSIX") || !strncmp(a1, "C.", 2uLL))
  {
    if (*(unsigned char *)(a2 + 1314))
    {
      *(unsigned char *)(a2 + 1314) = 0;
      xlocale_release(*(void *)(a2 + 1344));
      *(void *)(a2 + 1344) = 0;
      *(unsigned char *)(a2 + 1317) = 1;
    }
    return 1;
  }
  else if (*(unsigned char *)(a2 + 1314) && !strcmp(a1, *(const char **)(*(void *)(a2 + 1344) + 64)))
  {
    return 1;
  }
  else if (__numeric_load_locale_cache {
         && *(void *)(__numeric_load_locale_cache + 64)
  }
         && !strcmp(a1, *(const char **)(__numeric_load_locale_cache + 64)))
  {
    *(unsigned char *)(a2 + 1314) = 1;
    xlocale_release(*(void *)(a2 + 1344));
    *(void *)(a2 + 1344) = __numeric_load_locale_cache;
    xlocale_retain((atomic_uint *)__numeric_load_locale_cache);
    *(unsigned char *)(a2 + 1317) = 1;
    return 1;
  }
  else
  {
    unsigned int v3 = (void *)malloc_type_malloc();
    if (v3)
    {
      *(_DWORD *)unsigned int v3 = 1;
      *((void *)v3 + 1) = destruct_ldpart;
      *((void *)v3 + 8) = 0;
      unsigned int locale = __part_load_locale(a1, (unsigned char *)(a2 + 1314), (void **)v3 + 8, "LC_NUMERIC", 3, 3, (uint64_t)v3 + 72);
      if (locale == -1) {
        free(v3);
      }
      else {
        *(unsigned char *)(a2 + 1317) = 1;
      }
      if (!locale)
      {
        if (!**((unsigned char **)v3 + 9)) {
          *((void *)v3 + 9) = ".";
        }
        *((void *)v3 + 11) = __fix_locale_grouping_str(*((unsigned __int8 **)v3 + 11));
        xlocale_release(*(void *)(a2 + 1344));
        *(void *)(a2 + 1344) = v3;
        xlocale_release(__numeric_load_locale_cache);
        __numeric_load_locale_cache = (uint64_t)v3;
        xlocale_retain((atomic_uint *)v3);
      }
      return locale;
    }
    else
    {
      return -1;
    }
  }
}

char **__get_current_numeric_locale(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1314)) {
    return (char **)(*(void *)(a1 + 1344) + 72);
  }
  else {
    return &_C_numeric_locale;
  }
}

void _locale_lock_fork_prepare()
{
  if (v0) {
    char v1 = 1;
  }
  else {
    char v1 = 0;
  }
  if (v1)
  {
    unsigned int v3 = (os_unfair_lock_s *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v4 = __locale_key;
    unsigned int v3 = *(os_unfair_lock_s **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  }
  if (v3) {
    int v2 = v3;
  }
  else {
    int v2 = (os_unfair_lock_s *)__global_locale;
  }
  os_unfair_lock_lock(v2 + 324);
}

void _locale_lock_fork_parent()
{
  if (v0) {
    char v1 = 1;
  }
  else {
    char v1 = 0;
  }
  if (v1)
  {
    unsigned int v3 = (os_unfair_lock_s *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v4 = __locale_key;
    unsigned int v3 = *(os_unfair_lock_s **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  }
  if (v3) {
    int v2 = v3;
  }
  else {
    int v2 = (os_unfair_lock_s *)__global_locale;
  }
  os_unfair_lock_unlock(v2 + 324);
}

void _locale_lock_fork_child()
{
  if (v0) {
    char v1 = 1;
  }
  else {
    char v1 = 0;
  }
  if (v1)
  {
    unsigned int v3 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v4 = __locale_key;
    unsigned int v3 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  }
  if (v3) {
    int v2 = v3;
  }
  else {
    int v2 = __global_locale;
  }
  *((_DWORD *)v2 + 324) = 0;
}

lconv *__cdecl localeconv_l(locale_t a1)
{
  locale_t v4 = a1;
  if (a1)
  {
    if (a1 == (locale_t)-1) {
      locale_t v4 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v4 = (locale_t)&__c_locale;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v4 + 324);
  if (*((unsigned char *)v4 + 1316))
  {
    current_monetary_unsigned int locale = __get_current_monetary_locale((uint64_t)v4);
    *((void *)v4 + 175) = *current_monetary_locale;
    *((void *)v4 + 176) = current_monetary_locale[1];
    *((void *)v4 + 177) = current_monetary_locale[2];
    *((void *)v4 + 178) = current_monetary_locale[3];
    *((void *)v4 + 179) = current_monetary_locale[4];
    *((void *)v4 + 180) = current_monetary_locale[5];
    *((void *)v4 + 181) = current_monetary_locale[6];
    *((unsigned char *)v4 + 1456) = *(unsigned char *)current_monetary_locale[7];
    *((unsigned char *)v4 + 1457) = *(unsigned char *)current_monetary_locale[8];
    *((unsigned char *)v4 + 1458) = *(unsigned char *)current_monetary_locale[9];
    *((unsigned char *)v4 + 1459) = *(unsigned char *)current_monetary_locale[10];
    *((unsigned char *)v4 + 1460) = *(unsigned char *)current_monetary_locale[11];
    *((unsigned char *)v4 + 1461) = *(unsigned char *)current_monetary_locale[12];
    *((unsigned char *)v4 + 1462) = *(unsigned char *)current_monetary_locale[13];
    *((unsigned char *)v4 + 1463) = *(unsigned char *)current_monetary_locale[14];
    *((unsigned char *)v4 + 1464) = *(unsigned char *)current_monetary_locale[15];
    *((unsigned char *)v4 + 1465) = *(unsigned char *)current_monetary_locale[16];
    *((unsigned char *)v4 + 1466) = *(unsigned char *)current_monetary_locale[17];
    *((unsigned char *)v4 + 1467) = *(unsigned char *)current_monetary_locale[18];
    *((unsigned char *)v4 + 1468) = *(unsigned char *)current_monetary_locale[19];
    *((unsigned char *)v4 + 1469) = *(unsigned char *)current_monetary_locale[20];
    *((unsigned char *)v4 + 1316) = 0;
  }
  if (*((unsigned char *)v4 + 1317))
  {
    current_numeric_unsigned int locale = __get_current_numeric_locale((uint64_t)v4);
    *((void *)v4 + 172) = *current_numeric_locale;
    *((void *)v4 + 173) = current_numeric_locale[1];
    *((void *)v4 + 174) = current_numeric_locale[2];
    *((unsigned char *)v4 + 1317) = 0;
    if (!*((void *)v4 + 172))
    {
      _os_crash((uint64_t)"loc->decimal_point is NULL (nlocale changed)");
      __break(1u);
      JUMPOUT(0x54DE8);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v4 + 324);
  if (!*((void *)v4 + 172))
  {
    _os_crash((uint64_t)"loc->decimal_point is NULL");
    __break(1u);
    JUMPOUT(0x54E24);
  }
  return (lconv *)((char *)v4 + 1376);
}

lconv *localeconv(void)
{
  if (v0) {
    char v1 = 1;
  }
  else {
    char v1 = 0;
  }
  if (v1)
  {
    unsigned int v3 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v4 = __locale_key;
    unsigned int v3 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  }
  if (v3) {
    return localeconv_l(v3);
  }
  else {
    return localeconv_l((locale_t)__global_locale);
  }
}

int mblen_l(const char *a1, size_t a2, locale_t a3)
{
  locale_t v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      locale_t v5 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v5 = (locale_t)&__c_locale;
  }
  if (a1)
  {
    unint64_t v4 = (*(uint64_t (**)(void, const char *, size_t, uint64_t, locale_t))(*((void *)v5 + 166) + 72))(0, a1, a2, (uint64_t)v5 + 16, v5);
    if (v4 < 0xFFFFFFFFFFFFFFFELL) {
      return v4;
    }
    else {
      return -1;
    }
  }
  else
  {
    memcpy((char *)v5 + 16, &mblen_l_initial, 0x80uLL);
    return 0;
  }
}

int mblen(const char *__s, size_t __n)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return mblen_l(__s, __n, v7);
  }
  else {
    return mblen_l(__s, __n, (locale_t)__global_locale);
  }
}

size_t mbrlen_l(const char *a1, size_t a2, mbstate_t *a3, locale_t a4)
{
  uint64_t v6 = a3;
  locale_t v5 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      locale_t v5 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v5 = (locale_t)&__c_locale;
  }
  if (!a3) {
    uint64_t v6 = (mbstate_t *)((char *)v5 + 144);
  }
  return (*(uint64_t (**)(void, const char *, size_t, mbstate_t *, locale_t))(*((void *)v5 + 166) + 72))(0, a1, a2, v6, v5);
}

size_t mbrlen(const char *a1, size_t a2, mbstate_t *a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return mbrlen_l(a1, a2, a3, v9);
  }
  else {
    return mbrlen_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

size_t mbrtowc_l(__int32 *a1, const char *a2, size_t a3, mbstate_t *a4, locale_t a5)
{
  int v7 = a4;
  locale_t v6 = a5;
  if (a5)
  {
    if (a5 == (locale_t)-1) {
      locale_t v6 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v6 = (locale_t)&__c_locale;
  }
  if (!a4) {
    int v7 = (mbstate_t *)((char *)v6 + 272);
  }
  return (*(uint64_t (**)(__int32 *, const char *, size_t, mbstate_t *, locale_t))(*((void *)v6 + 166) + 72))(a1, a2, a3, v7, v6);
}

size_t mbrtowc(__int32 *a1, const char *a2, size_t a3, mbstate_t *a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    int v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    int v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    return mbrtowc_l(a1, a2, a3, a4, v11);
  }
  else {
    return mbrtowc_l(a1, a2, a3, a4, (locale_t)__global_locale);
  }
}

int mbsinit_l(const mbstate_t *a1, locale_t a2)
{
  locale_t v3 = a2;
  if (!a2) {
    return (*((uint64_t (**)(const mbstate_t *, void *))off_E8E40 + 10))(a1, &__c_locale);
  }
  if (a2 == (locale_t)-1) {
    locale_t v3 = (locale_t)&__global_locale;
  }
  return (*(uint64_t (**)(const mbstate_t *, locale_t))(*((void *)v3 + 166) + 80))(a1, v3);
}

int mbsinit(const mbstate_t *a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    char v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    char v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return mbsinit_l(a1, v5);
  }
  else {
    return mbsinit_l(a1, (locale_t)__global_locale);
  }
}

size_t mbsnrtowcs_l(__int32 *a1, const char **a2, size_t a3, size_t a4, mbstate_t *a5, locale_t a6)
{
  uint64_t v8 = a5;
  locale_t v7 = a6;
  if (a6)
  {
    if (a6 == (locale_t)-1) {
      locale_t v7 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v7 = (locale_t)&__c_locale;
  }
  if (!a5) {
    uint64_t v8 = (mbstate_t *)((char *)v7 + 400);
  }
  return (*(uint64_t (**)(__int32 *, const char **, size_t, size_t, mbstate_t *, locale_t))(*((void *)v7 + 166) + 88))(a1, a2, a3, a4, v8, v7);
}

size_t mbsnrtowcs(__int32 *a1, const char **a2, size_t a3, size_t a4, mbstate_t *a5)
{
  if (v5) {
    char v6 = 1;
  }
  else {
    char v6 = 0;
  }
  if (v6)
  {
    int v13 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v14 = __locale_key;
    int v13 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v14);
  }
  if (v13) {
    return mbsnrtowcs_l(a1, a2, a3, a4, a5, v13);
  }
  else {
    return mbsnrtowcs_l(a1, a2, a3, a4, a5, (locale_t)__global_locale);
  }
}

uint64_t __mbsnrtowcs_std(int *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v19 = a1;
  int v18 = a2;
  uint64_t v17 = a3;
  uint64_t v16 = a4;
  uint64_t v15 = a5;
  uint64_t v14 = a6;
  uint64_t v13 = 0;
  uint64_t v12 = 0;
  int v11 = 0;
  uint64_t v8 = *(uint64_t (**)(int *, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a6 + 1328) + 72);
  uint64_t v13 = *a2;
  uint64_t v12 = 0;
  if (a1)
  {
    while (v16--)
    {
      uint64_t v10 = v8(v19, v13, v17, v15, v14);
      switch(v10)
      {
        case -1:
          *int v18 = v13;
          return -1;
        case -2:
          *int v18 = v13 + v17;
          return v12;
        case 0:
          *int v18 = 0;
          return v12;
      }
      v13 += v10;
      v17 -= v10;
      ++v12;
      ++v19;
    }
    *int v18 = v13;
    return v12;
  }
  else
  {
    while (1)
    {
      uint64_t v9 = v8(&v11, v13, v17, v15, v14);
      if (v9 == -1) {
        return -1;
      }
      if (!v9 || v9 == -2) {
        break;
      }
      v13 += v9;
      v17 -= v9;
      ++v12;
    }
    return v12;
  }
}

size_t mbsrtowcs_l(__int32 *a1, const char **a2, size_t a3, mbstate_t *a4, locale_t a5)
{
  locale_t v7 = a4;
  locale_t v6 = a5;
  if (a5)
  {
    if (a5 == (locale_t)-1) {
      locale_t v6 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v6 = (locale_t)&__c_locale;
  }
  if (!a4) {
    locale_t v7 = (mbstate_t *)((char *)v6 + 528);
  }
  return (*(uint64_t (**)(__int32 *, const char **, uint64_t, size_t, mbstate_t *, locale_t))(*((void *)v6 + 166) + 88))(a1, a2, -1, a3, v7, v6);
}

size_t mbsrtowcs(__int32 *a1, const char **a2, size_t a3, mbstate_t *a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    int v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    int v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    return mbsrtowcs_l(a1, a2, a3, a4, v11);
  }
  else {
    return mbsrtowcs_l(a1, a2, a3, a4, (locale_t)__global_locale);
  }
}

size_t mbstowcs_l(__int32 *a1, const char *a2, size_t a3, locale_t a4)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  size_t v7 = a3;
  locale_t v6 = a4;
  memset(__b, 0, sizeof(__b));
  char v5 = 0;
  if (v6)
  {
    if (v6 == (locale_t)-1) {
      locale_t v6 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v6 = (locale_t)&__c_locale;
  }
  memcpy(__b, &mbstowcs_l_initial, sizeof(__b));
  char v5 = v8;
  return (*(uint64_t (**)(__int32 *, const char **, uint64_t, size_t, unsigned char *, locale_t))(*((void *)v6 + 166)
                                                                                                 + 88))(v9, &v5, -1, v7, __b, v6);
}

size_t mbstowcs(__int32 *a1, const char *a2, size_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    uint64_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    uint64_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return mbstowcs_l(a1, a2, a3, v9);
  }
  else {
    return mbstowcs_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

int mbtowc_l(__int32 *a1, const char *a2, size_t a3, locale_t a4)
{
  locale_t v6 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      locale_t v6 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v6 = (locale_t)&__c_locale;
  }
  if (a2)
  {
    unint64_t v5 = (*(uint64_t (**)(__int32 *, const char *, size_t, uint64_t, locale_t))(*((void *)v6 + 166) + 72))(a1, a2, a3, (uint64_t)v6 + 656, v6);
    if (v5 < 0xFFFFFFFFFFFFFFFELL) {
      return v5;
    }
    else {
      return -1;
    }
  }
  else
  {
    memcpy((char *)v6 + 656, &mbtowc_l_initial, 0x80uLL);
    return 0;
  }
}

int mbtowc(__int32 *a1, const char *a2, size_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    uint64_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    uint64_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return mbtowc_l(a1, a2, a3, v9);
  }
  else {
    return mbtowc_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

uint64_t _MSKanji_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _MSKanji_mbrtowc;
  *(void *)(a1 + 96) = _MSKanji_wcrtomb;
  *(void *)(a1 + 80) = _MSKanji_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 256;
  return 0;
}

uint64_t _MSKanji_mbrtowc(_DWORD *a1, unsigned __int8 *a2, unint64_t a3, unsigned int *a4)
{
  uint64_t v9 = a2;
  if ((*a4 & 0xFFFFFF00) != 0)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    uint64_t v9 = (unsigned __int8 *)&unk_D793D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3) {
    return -2;
  }
  if (*a4)
  {
    if (!*v9)
    {
LABEL_9:
      *__error() = 92;
      return -1;
    }
    if (a1) {
      *a1 = *v9 | (*a4 << 8);
    }
    *a4 = 0;
    return 1;
  }
  else
  {
    char v4 = v9;
    uint64_t v10 = v9 + 1;
    unsigned int v6 = *v4;
    if ((v6 <= 0x80 || *v4 >= 0xA0u) && (*v4 < 0xE0u || *v4 >= 0xFDu))
    {
      if (a1) {
        *a1 = v6;
      }
      return v6 != 0;
    }
    else
    {
      if (a3 < 2)
      {
        *a4 = v6;
        return -2;
      }
      if (!*v10) {
        goto LABEL_9;
      }
      int v7 = *v10 | (v6 << 8);
      if (a1) {
        *a1 = v7;
      }
      return 2;
    }
  }
}

uint64_t _MSKanji_wcrtomb(unsigned char *a1, int a2, _DWORD *a3)
{
  uint64_t v9 = a1;
  if (*a3)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if (a2 <= 256) {
      int v3 = 1;
    }
    else {
      int v3 = 2;
    }
    int v8 = v3;
    for (i = v3; ; *unint64_t v5 = a2 >> (8 * i))
    {
      int v4 = i--;
      if (v4 <= 0) {
        break;
      }
      unint64_t v5 = v9++;
    }
    return v8;
  }
  else
  {
    return 1;
  }
}

BOOL _MSKanji_mbsinit(_DWORD *a1)
{
  BOOL v2 = 1;
  if (a1) {
    return *a1 == 0;
  }
  return v2;
}

wint_t nextwctype_l(wint_t a1, wctype_t a2, locale_t a3)
{
  wint_t v9 = a1;
  uint64_t v4 = *(void *)(*((void *)a3 + 166) + 120);
  int v5 = 0;
  if (a1 < 256)
  {
    for (wint_t i = a1 + 1; i < 256; ++i)
    {
      if ((*(_DWORD *)(v4 + 60 + 4 * i) & a2) != 0) {
        return i;
      }
    }
    wint_t v9 = i - 1;
  }
  if (*(void *)(v4 + 3144) && v9 < **(_DWORD **)(v4 + 3144))
  {
    wint_t v9 = **(_DWORD **)(v4 + 3144);
    int v5 = 1;
  }
  unint64_t v7 = *(void *)(v4 + 3144);
  for (unint64_t j = *(int *)(v4 + 3136); ; j >>= 1)
  {
    if (!j) {
      return -1;
    }
    unint64_t v6 = v7 + 24 * (j >> 1);
    if (*(_DWORD *)v6 <= v9 && v9 <= *(_DWORD *)(v6 + 4)) {
      break;
    }
    if (v9 > *(_DWORD *)(v6 + 4))
    {
      unint64_t v7 = v6 + 24;
      --j;
    }
  }
  if (!v5) {
    ++v9;
  }
  if (*(_DWORD *)v6 > v9 || v9 > *(_DWORD *)(v6 + 4))
  {
LABEL_31:
    while (1)
    {
      v6 += 24;
      if (v6 >= *(void *)(v4 + 3144) + 24 * *(int *)(v4 + 3136)) {
        break;
      }
      wint_t v11 = *(_DWORD *)v6;
      if (*(void *)(v6 + 16))
      {
        while (v11 <= *(_DWORD *)(v6 + 4))
        {
          if ((*(_DWORD *)(*(void *)(v6 + 16) + 4 * (v11 - *(_DWORD *)v6)) & a2) != 0) {
            return v11;
          }
          ++v11;
        }
      }
      else if ((*(_DWORD *)(v6 + 8) & a2) != 0)
      {
        return *(_DWORD *)v6;
      }
    }
    return -1;
  }
  else if (*(void *)(v6 + 16))
  {
    while (1)
    {
      if (v9 > *(_DWORD *)(v6 + 4)) {
        goto LABEL_31;
      }
      if ((*(_DWORD *)(*(void *)(v6 + 16) + 4 * (v9 - *(_DWORD *)v6)) & a2) != 0) {
        return v9;
      }
      ++v9;
    }
  }
  else
  {
    if ((*(_DWORD *)(v6 + 8) & a2) == 0) {
      goto LABEL_31;
    }
    return v9;
  }
}

wint_t nextwctype(wint_t a1, wctype_t a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    unint64_t v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    unint64_t v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return nextwctype_l(a1, a2, v7);
  }
  else {
    return nextwctype_l(a1, a2, (locale_t)__global_locale);
  }
}

char *__cdecl nl_langinfo_l(nl_item a1, locale_t a2)
{
  uint64_t v14 = a2;
  if (a2)
  {
    if (a2 == (locale_t)-1) {
      uint64_t v14 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v14 = (_xlocale *)&__c_locale;
  }
  if (a1)
  {
    uint64_t v3 = a1;
    char v2 = 1;
  }
  else
  {
    uint64_t v3 = 0;
    char v2 = 0;
  }
  if (v2) {
    return (char *)&unk_D793D;
  }
  switch(v3)
  {
    case 0:
      uint64_t v13 = (const char *)&unk_D793D;
      __s = (char *)querylocale(2, v14);
      if (__s)
      {
        wint_t v11 = strchr(__s, 46);
        if (v11)
        {
          uint64_t v13 = v11 + 1;
        }
        else if (!strcmp(__s, "C") || !strcmp(__s, "POSIX"))
        {
          uint64_t v13 = "US-ASCII";
        }
        else if (!strcmp(__s, "UTF-8"))
        {
          uint64_t v13 = "UTF-8";
        }
      }
      break;
    case 1:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[40];
      break;
    case 2:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[39];
      break;
    case 3:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[38];
      break;
    case 4:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[57];
      break;
    case 5:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[41];
      break;
    case 6:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[42];
      break;
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[a1 + 24];
      break;
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[a1 + 10];
      break;
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[a1 - 9];
      break;
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[a1 - 33];
      break;
    case 45:
      uint64_t v13 = (const char *)&unk_D793D;
      break;
    case 46:
      uint64_t v13 = (const char *)&unk_D793D;
      break;
    case 47:
      uint64_t v13 = (const char *)&unk_D793D;
      break;
    case 48:
      uint64_t v13 = (const char *)&unk_D793D;
      break;
    case 49:
      uint64_t v13 = (const char *)&unk_D793D;
      break;
    case 50:
      uint64_t v13 = *__get_current_numeric_locale((uint64_t)v14);
      break;
    case 51:
      uint64_t v13 = __get_current_numeric_locale((uint64_t)v14)[1];
      break;
    case 52:
      uint64_t v13 = *__get_current_messages_locale((uint64_t)v14);
      break;
    case 53:
      uint64_t v13 = __get_current_messages_locale((uint64_t)v14)[1];
      break;
    case 54:
      uint64_t v13 = __get_current_messages_locale((uint64_t)v14)[2];
      break;
    case 55:
      uint64_t v13 = __get_current_messages_locale((uint64_t)v14)[3];
      break;
    case 56:
      uint64_t v13 = (const char *)&unk_D793D;
      uint64_t v12 = (const char *)__get_current_monetary_locale((uint64_t)v14)[1];
      if (*v12)
      {
        char p_cs_precedes = localeconv_l(v14)->p_cs_precedes;
        if (p_cs_precedes == localeconv_l(v14)->n_cs_precedes)
        {
          char v8 = 0;
          if (p_cs_precedes == 127)
          {
            current_monetary_unsigned int locale = __get_current_monetary_locale((uint64_t)v14);
            if (!strcmp(v12, (const char *)current_monetary_locale[2])) {
              char v8 = 46;
            }
          }
          else
          {
            if (p_cs_precedes) {
              char v5 = 45;
            }
            else {
              char v5 = 43;
            }
            char v8 = v5;
          }
          if (v8)
          {
            int v7 = strlen(v12);
            nl_langinfo_l_csyint m = (uint64_t)reallocf((void *)nl_langinfo_l_csym, v7 + 2);
            if (nl_langinfo_l_csym)
            {
              *(unsigned char *)nl_langinfo_l_csyint m = v8;
              strcpy((char *)(nl_langinfo_l_csym + 1), v12);
              uint64_t v13 = (const char *)nl_langinfo_l_csym;
            }
          }
        }
      }
      break;
    case 57:
      uint64_t v13 = __get_current_time_locale((uint64_t)v14)[56];
      break;
    default:
      JUMPOUT(0);
  }
  if (v13 && !*v13 && a1 != 57 && a1 && v14 != (_xlocale *)&__c_locale) {
    return nl_langinfo_l(a1, (locale_t)&__c_locale);
  }
  return (char *)v13;
}

char *__cdecl nl_langinfo(nl_item a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    char v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    char v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return nl_langinfo_l(a1, v5);
  }
  else {
    return nl_langinfo_l(a1, (locale_t)__global_locale);
  }
}

uint64_t __maskrune(int a1, unsigned int a2)
{
  if (a1 < 0x100)
  {
    uint64_t v7 = __locale_key;
    uint64_t v6 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
    if (v6) {
      uint64_t v3 = v6;
    }
    else {
      uint64_t v3 = __global_locale;
    }
    int v4 = *(_DWORD *)(*(void *)(v3[166] + 120) + 60 + 4 * a1);
  }
  else
  {
    int v4 = ___runetype(a1);
  }
  return v4 & a2;
}

BOOL __istype(int a1, unsigned int a2)
{
  if (isascii(a1)) {
    return (_DefaultRuneLocale.__runetype[a1] & a2) != 0;
  }
  else {
    return __maskrune(a1, a2) != 0;
  }
}

BOOL __isctype(unsigned int a1, int a2)
{
  return a1 < 0x100 && (_DefaultRuneLocale.__runetype[a1] & a2) != 0;
}

uint64_t __toupper(int a1)
{
  if (a1 < 0x100)
  {
    uint64_t v5 = __locale_key;
    int v4 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
    if (v4) {
      char v2 = v4;
    }
    else {
      char v2 = __global_locale;
    }
    return *(unsigned int *)(*(void *)(v2[166] + 120) + 2108 + 4 * a1);
  }
  else
  {
    return ___toupper(a1);
  }
}

uint64_t __tolower(int a1)
{
  if (a1 < 0x100)
  {
    uint64_t v5 = __locale_key;
    int v4 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
    if (v4) {
      char v2 = v4;
    }
    else {
      char v2 = __global_locale;
    }
    return *(unsigned int *)(*(void *)(v2[166] + 120) + 1084 + 4 * a1);
  }
  else
  {
    return ___tolower(a1);
  }
}

uint64_t __wcwidth(int a1)
{
  if (a1)
  {
    int v3 = __maskrune(a1, 0xE0040000);
    if ((v3 & 0xE0000000) != 0)
    {
      return (uint64_t)(v3 & 0xE0000000) >> 30;
    }
    else if ((v3 & 0x40000) != 0)
    {
      return 1;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __maskrune_l(int a1, unsigned int a2, void *a3)
{
  if (a1 < 0x100)
  {
    uint64_t v6 = a3;
    if (a3)
    {
      if (a3 == (void *)-1) {
        uint64_t v6 = __global_locale;
      }
    }
    else
    {
      uint64_t v6 = &__c_locale;
    }
    int v4 = *(_DWORD *)(*(void *)(v6[166] + 120) + 60 + 4 * a1);
  }
  else
  {
    int v4 = ___runetype_l(a1, a3);
  }
  return v4 & a2;
}

BOOL __istype_l(int a1, unsigned int a2, void *a3)
{
  if (isascii(a1)) {
    uint64_t v4 = _DefaultRuneLocale.__runetype[a1] & a2;
  }
  else {
    uint64_t v4 = (int)__maskrune_l(a1, a2, a3);
  }
  return v4 != 0;
}

uint64_t __toupper_l(int a1, void *a2)
{
  if (isascii(a1)) {
    return _DefaultRuneLocale.__mapupper[a1];
  }
  else {
    return ___toupper_l(a1, a2);
  }
}

uint64_t __tolower_l(int a1, void *a2)
{
  if (isascii(a1)) {
    return _DefaultRuneLocale.__maplower[a1];
  }
  else {
    return ___tolower_l(a1, a2);
  }
}

uint64_t __wcwidth_l(int a1, void *a2)
{
  if (a1)
  {
    int v4 = __maskrune_l(a1, 0xE0040000, a2);
    if ((v4 & 0xE0000000) != 0)
    {
      return (uint64_t)(v4 & 0xE0000000) >> 30;
    }
    else if ((v4 & 0x40000) != 0)
    {
      return 1;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t _none_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _none_mbrtowc;
  *(void *)(a1 + 80) = _none_mbsinit;
  *(void *)(a1 + 88) = _none_mbsnrtowcs;
  *(void *)(a1 + 96) = _none_wcrtomb;
  *(void *)(a1 + 104) = _none_wcsnrtombs;
  *(_DWORD *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 68) = 256;
  return 0;
}

uint64_t _none_mbrtowc(_DWORD *a1, unsigned char *a2, uint64_t a3)
{
  if (!a2) {
    return 0;
  }
  if (!a3) {
    return -2;
  }
  if (a1) {
    *a1 = *a2;
  }
  return *a2 != 0;
}

uint64_t _none_mbsinit()
{
  return 1;
}

int64_t _none_mbsnrtowcs(_DWORD *a1, const void **a2, size_t a3, uint64_t a4)
{
  uint64_t v17 = a1;
  size_t v15 = a3;
  if (a1)
  {
    uint64_t v13 = (unsigned __int8 *)*a2;
    for (uint64_t i = 0; ; ++i)
    {
      uint64_t v4 = a4--;
      BOOL v9 = 0;
      if (v4)
      {
        size_t v5 = v15--;
        BOOL v9 = v5 != 0;
      }
      if (!v9) {
        break;
      }
      uint64_t v6 = v13++;
      LODWORD(v6) = *v6;
      uint64_t v7 = v17++;
      *uint64_t v7 = v6;
      if (!v6)
      {
        *a2 = 0;
        return i;
      }
    }
    *a2 = v13;
    return i;
  }
  else
  {
    uint64_t v12 = memchr(*a2, 0, a3);
    if (v12) {
      return v12 - (unsigned char *)*a2;
    }
    else {
      return v15;
    }
  }
}

uint64_t _none_wcrtomb(unsigned char *a1, unsigned int a2)
{
  if (!a1) {
    return 1;
  }
  if (a2 < 0x100)
  {
    *a1 = a2;
    return 1;
  }
  else
  {
    *__error() = 92;
    return -1;
  }
}

uint64_t _none_wcsnrtombs(unsigned char *a1, _DWORD **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v16 = a1;
  if (a1)
  {
    uint64_t v13 = *a2;
    for (uint64_t i = 0; ; ++i)
    {
      uint64_t v4 = a4--;
      BOOL v9 = 0;
      if (v4)
      {
        uint64_t v5 = a3--;
        BOOL v9 = v5 != 0;
      }
      if (!v9) {
        break;
      }
      if (*v13 >= 0x100u)
      {
        *a2 = v13;
        *__error() = 92;
        return -1;
      }
      uint64_t v6 = v13++;
      LOBYTE(v6) = *v6;
      uint64_t v7 = v16++;
      *uint64_t v7 = (_BYTE)v6;
      if (!(_BYTE)v6)
      {
        *a2 = 0;
        return i;
      }
    }
    *a2 = v13;
    return i;
  }
  else
  {
    for (unint64_t j = *a2; ; ++j)
    {
      BOOL v10 = 0;
      if (a3) {
        BOOL v10 = *j != 0;
      }
      if (!v10) {
        break;
      }
      if (*j >= 0x100u)
      {
        *__error() = 92;
        return -1;
      }
      --a3;
    }
    return j - *a2;
  }
}

uint64_t ___runetype_l(int a1, void *a2)
{
  uint64_t v6 = a2;
  if (a1 < 0) {
    return 0;
  }
  if (a2)
  {
    if (a2 == (void *)-1) {
      uint64_t v6 = &__global_locale;
    }
  }
  else
  {
    uint64_t v6 = &__c_locale;
  }
  uint64_t v4 = *(void *)(*(void *)(v6[166] + 120) + 3144);
  for (unint64_t i = *(int *)(*(void *)(v6[166] + 120) + 3136); ; i >>= 1)
  {
    if (!i) {
      return 0;
    }
    uint64_t v3 = v4 + 24 * (i >> 1);
    if (*(_DWORD *)v3 <= a1 && a1 <= *(_DWORD *)(v3 + 4)) {
      break;
    }
    if (a1 > *(_DWORD *)(v3 + 4))
    {
      uint64_t v4 = v3 + 24;
      --i;
    }
  }
  if (*(void *)(v3 + 16)) {
    return *(unsigned int *)(*(void *)(v3 + 16) + 4 * (a1 - *(_DWORD *)v3));
  }
  else {
    return *(int *)(v3 + 8);
  }
}

uint64_t ___runetype(int a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    uint64_t v5 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    uint64_t v5 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return ___runetype_l(a1, v5);
  }
  else {
    return ___runetype_l(a1, __global_locale);
  }
}

char *__cdecl setlocale(int a1, const char *a2)
{
  uint64_t v17 = a2;
  if (a1 > 6)
  {
    *__error() = 22;
    return 0;
  }
  if (!a2)
  {
    if (a1) {
      return &current_categories[32 * a1];
    }
    else {
      return (char *)currentlocale();
    }
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__global_locale[162]);
  for (int i = 1; i < 7; ++i)
    strcpy(&new_categories[32 * i], &current_categories[32 * i]);
  if (!*v17)
  {
    if (!a1)
    {
      for (int j = 1; j < 7; ++j)
      {
        __s = (char *)__get_locale_env(j);
        if (strlen(__s) > 0x1F) {
          goto LABEL_37;
        }
        strcpy(&new_categories[32 * j], __s);
      }
      goto LABEL_49;
    }
    __sa = (char *)__get_locale_env(a1);
    if (strlen(__sa) <= 0x1F)
    {
      strcpy(&new_categories[32 * a1], __sa);
      goto LABEL_49;
    }
LABEL_37:
    *__error() = 22;
    os_unfair_lock_unlock((os_unfair_lock_t)&__global_locale[162]);
    return 0;
  }
  if (a1)
  {
    if (strlen(v17) > 0x1F) {
      goto LABEL_37;
    }
    strcpy(&new_categories[32 * a1], v17);
  }
  else
  {
    uint64_t v6 = strchr(v17, 47);
    if (v6)
    {
      int v15 = 1;
      while (v6[1] == 47)
        ++v6;
      if (v6[1])
      {
        do
        {
          if (v15 == 7) {
            break;
          }
          if ((int)v6 - (int)v17 > 31) {
            goto LABEL_37;
          }
          strlcpy(&new_categories[32 * v15++], v17, (int)v6 - (int)v17 + 1);
          while (*v6 == 47)
            ++v6;
          uint64_t v17 = v6;
          while (1)
          {
            BOOL v3 = 0;
            if (*v6) {
              BOOL v3 = *v6 != 47;
            }
            if (!v3) {
              break;
            }
            ++v6;
          }
        }
        while (*v17);
        while (v15 < 7)
        {
          strcpy(&new_categories[32 * v15], &new_categories[32 * v15 - 32]);
          ++v15;
        }
        goto LABEL_49;
      }
      goto LABEL_37;
    }
    if (strlen(v17) > 0x1F) {
      goto LABEL_37;
    }
    for (int k = 1; k < 7; ++k)
      strcpy(&new_categories[32 * k], v17);
  }
LABEL_49:
  if (a1)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__global_locale[162]);
    return loadlocale(a1);
  }
  else
  {
    char v9 = byte_E884E;
    uint64_t v5 = qword_E8880;
    xlocale_retain((atomic_uint *)qword_E8880);
    for (signed int m = 1; ; ++m)
    {
      if (m >= 7)
      {
        xlocale_release(v5);
        os_unfair_lock_unlock((os_unfair_lock_t)&__global_locale[162]);
        return (char *)currentlocale();
      }
      strcpy(&saved_categories[32 * m], &current_categories[32 * m]);
      if (!loadlocale(m)) {
        break;
      }
    }
    int v10 = *__error();
    for (signed int n = 1; n < m; ++n)
    {
      strcpy(&new_categories[32 * n], &saved_categories[32 * n]);
      if (!loadlocale(n))
      {
        strcpy(&new_categories[32 * n], "C");
        loadlocale(n);
      }
    }
    byte_E884E = v9;
    qword_E8880 = v5;
    xlocale_release(v5);
    *__error() = v10;
    os_unfair_lock_unlock((os_unfair_lock_t)&__global_locale[162]);
    return 0;
  }
}

uint64_t currentlocale()
{
  if (!currentlocale_current_locale_string)
  {
    currentlocale_current_locale_string = malloc_type_malloc();
    if (!currentlocale_current_locale_string) {
      return 0;
    }
  }
  strlcpy((char *)currentlocale_current_locale_string, "C", 0xE7uLL);
  for (int i = 2; i < 7; ++i)
  {
    if (strcmp("C", &current_categories[32 * i]))
    {
      for (int j = 2; j < 7; ++j)
      {
        strcat((char *)currentlocale_current_locale_string, "/");
        strcat((char *)currentlocale_current_locale_string, &current_categories[32 * j]);
      }
      return currentlocale_current_locale_string;
    }
  }
  return currentlocale_current_locale_string;
}

const char *__get_locale_env(int a1)
{
  char v2 = getenv("LC_ALL");
  if (!v2 || !*v2) {
    char v2 = getenv(categories[a1]);
  }
  if (!v2 || !*v2) {
    char v2 = getenv("LANG");
  }
  if (!v2 || !*v2) {
    return "C";
  }
  return v2;
}

char *loadlocale(unsigned int a1)
{
  char v8 = (char *)&new_categories + 32 * (int)a1;
  uint64_t v7 = &current_categories[32 * a1];
  if (*v8 == 46 && (!v8[1] || v8[1] == 46 && !v8[2]) || strchr(v8, 47)) {
    goto LABEL_6;
  }
  int v5 = *__error();
  int v4 = __detect_path_locale();
  *__error() = v4;
  if (*__error()) {
    return 0;
  }
  *__error() = v5;
  if (a1 <= 1)
  {
    uint64_t v2 = a1 - 1;
    char v1 = 0;
  }
  else
  {
    uint64_t v2 = a1 - 1;
    char v1 = 1;
  }
  if (v1)
  {
LABEL_6:
    *__error() = 22;
    return 0;
  }
  else
  {
    switch(v2)
    {
      case 0:
        uint64_t v6 = (unsigned int (*)(const char *, void *))__collate_load_tables;
        break;
      case 1:
        uint64_t v6 = (unsigned int (*)(const char *, void *))__wrap_setrunelocale;
        break;
      case 2:
        uint64_t v6 = (unsigned int (*)(const char *, void *))__monetary_load_locale;
        break;
      case 3:
        uint64_t v6 = (unsigned int (*)(const char *, void *))__numeric_load_locale;
        break;
      case 4:
        uint64_t v6 = (unsigned int (*)(const char *, void *))__time_load_locale;
        break;
      case 5:
        uint64_t v6 = (unsigned int (*)(const char *, void *))__messages_load_locale;
        break;
      default:
        JUMPOUT(0);
    }
    if (!strcmp(v8, v7))
    {
      return v7;
    }
    else if (v6(v8, __global_locale) == -1)
    {
      return 0;
    }
    else
    {
      strcpy(v7, v8);
      xlocale_fill_name((size_t)*(&off_E8850 + (int)(a1 - 1)), v8);
      if (a1 == 2)
      {
        if (byte_E884E == 1) {
          byte_E884E = 0;
        }
      }
      else if (a1 == 4)
      {
        byte_E884E = 0;
        xlocale_release(qword_E8880);
        qword_E8880 = 0;
      }
      return v7;
    }
  }
}

uint64_t __detect_path_locale()
{
  if (_PathLocale) {
    return 0;
  }
  __s = getenv("PATH_LOCALE");
  if (!__s || issetugid())
  {
    _PathLocale = (uint64_t)"/usr/share/locale";
    return 0;
  }
  if (strlen(__s) + 44 >= 0x400) {
    return 63;
  }
  _PathLocale = (uint64_t)strdup(__s);
  if (_PathLocale) {
    return 0;
  }
  if (*__error()) {
    return *__error();
  }
  else {
    return 12;
  }
}

uint64_t __open_path_locale(const char *a1)
{
  strcpy(__dst, (const char *)_PathLocale);
  strcat(__dst, "/");
  strcat(__dst, a1);
  int v2 = open_NOCANCEL();
  if (v2 < 0)
  {
    strcpy(__dst, "/usr/share/locale");
    strcat(__dst, "/");
    strcat(__dst, a1);
    int v3 = open_NOCANCEL();
    if (v3 < 0)
    {
      strcpy(__dst, "/usr/local/share/locale");
      strcat(__dst, "/");
      strcat(__dst, a1);
      return open_NOCANCEL();
    }
    else
    {
      return v3;
    }
  }
  else
  {
    return v2;
  }
}

uint64_t __setrunelocale(const char *a1, void *a2)
{
  if (!strcmp(a1, "C") || !strcmp(a1, "POSIX"))
  {
    xlocale_release(a2[166]);
    a2[166] = &_DefaultRuneXLocale;
    if (a2 == __global_locale)
    {
      _CurrentRuneLocale = *(_RuneLocale **)(a2[166] + 120);
      __mb_cur_max = *(_DWORD *)(a2[166] + 64);
      __mb_sb_limit = *(_DWORD *)(a2[166] + 68);
    }
    return 0;
  }
  else
  {
    os_unfair_lock_lock(&__setrunelocale_cache_lock);
    if (__setrunelocale_CachedRuneLocale && !strcmp(a1, (const char *)(__setrunelocale_CachedRuneLocale + 16)))
    {
      xlocale_release(a2[166]);
      a2[166] = __setrunelocale_CachedRuneLocale;
      xlocale_retain((atomic_uint *)__setrunelocale_CachedRuneLocale);
      if (a2 == __global_locale)
      {
        _CurrentRuneLocale = *(_RuneLocale **)(a2[166] + 120);
        __mb_cur_max = *(_DWORD *)(a2[166] + 64);
        __mb_sb_limit = *(_DWORD *)(a2[166] + 68);
      }
      os_unfair_lock_unlock(&__setrunelocale_cache_lock);
      return 0;
    }
    else
    {
      os_unfair_lock_unlock(&__setrunelocale_cache_lock);
      strcpy(__dst, a1);
      strcat(__dst, "/LC_CTYPE");
      int v2 = __open_path_locale(__dst);
      char v9 = (FILE *)fdopen_DARWIN_EXTSN(v2, "r");
      if (v9)
      {
        RuneMagint i = _Read_RuneMagi(v9);
        if (RuneMagi)
        {
          fclose(v9);
          *((void *)RuneMagi + 9) = 0;
          *((void *)RuneMagi + 10) = 0;
          *((void *)RuneMagi + 11) = __mbsnrtowcs_std;
          *((void *)RuneMagi + 12) = 0;
          *((void *)RuneMagi + 13) = __wcsnrtombs_std;
          uint64_t v7 = *((void *)RuneMagi + 15);
          *(void *)(v7 + 48) = 0;
          *(void *)(v7 + 40) = 0;
          if (!strcmp((const char *)(v7 + 8), "NONE:US-ASCII") || !strcmp((const char *)(v7 + 8), "ASCII"))
          {
            unsigned int v6 = _ascii_init((uint64_t)RuneMagi);
          }
          else if (!strncmp((const char *)(v7 + 8), "NONE", 4uLL))
          {
            unsigned int v6 = _none_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "UTF-8"))
          {
            unsigned int v6 = _UTF8_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "EUC-CN"))
          {
            unsigned int v6 = _EUC_CN_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "EUC-JP"))
          {
            unsigned int v6 = _EUC_JP_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "EUC-KR"))
          {
            unsigned int v6 = _EUC_KR_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "EUC-TW"))
          {
            unsigned int v6 = _EUC_TW_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "EUC"))
          {
            unsigned int v6 = _EUC_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "GB18030"))
          {
            unsigned int v6 = _GB18030_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "GB2312"))
          {
            unsigned int v6 = _GB2312_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "GBK"))
          {
            unsigned int v6 = _GBK_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "BIG5"))
          {
            unsigned int v6 = _BIG5_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "MSKanji"))
          {
            unsigned int v6 = _MSKanji_init((uint64_t)RuneMagi);
          }
          else if (!strcmp((const char *)(v7 + 8), "UTF2"))
          {
            unsigned int v6 = _UTF2_init((uint64_t)RuneMagi);
          }
          else
          {
            unsigned int v6 = 79;
          }
          if (v6)
          {
            xlocale_release((uint64_t)RuneMagi);
          }
          else
          {
            strcpy(RuneMagi + 16, a1);
            xlocale_release(a2[166]);
            a2[166] = RuneMagi;
            if (a2 == __global_locale)
            {
              _CurrentRuneLocale = *(_RuneLocale **)(a2[166] + 120);
              __mb_cur_max = *(_DWORD *)(a2[166] + 64);
              __mb_sb_limit = *(_DWORD *)(a2[166] + 68);
            }
            os_unfair_lock_lock(&__setrunelocale_cache_lock);
            xlocale_release(__setrunelocale_CachedRuneLocale);
            __setrunelocale_CachedRuneLocale = (uint64_t)RuneMagi;
            xlocale_retain((atomic_uint *)RuneMagi);
            os_unfair_lock_unlock(&__setrunelocale_cache_lock);
          }
          return v6;
        }
        else
        {
          if (*__error()) {
            unsigned int v4 = *__error();
          }
          else {
            unsigned int v4 = 79;
          }
          fclose(v9);
          return v4;
        }
      }
      else if (*__error())
      {
        return *__error();
      }
      else
      {
        return 2;
      }
    }
  }
}

uint64_t __wrap_setrunelocale(const char *a1, void *a2)
{
  int v3 = __setrunelocale(a1, a2);
  if (v3)
  {
    *__error() = v3;
    return -1;
  }
  else
  {
    return 0;
  }
}

uint64_t ___tolower_l(int a1, void *a2)
{
  unsigned int v6 = a2;
  if (a1 >= 0)
  {
    if (a2)
    {
      if (a2 == (void *)-1) {
        unsigned int v6 = &__global_locale;
      }
    }
    else
    {
      unsigned int v6 = &__c_locale;
    }
    if (a1 >= 256)
    {
      unsigned int v4 = *(_DWORD **)(*(void *)(v6[166] + 120) + 3160);
      for (unint64_t i = *(int *)(*(void *)(v6[166] + 120) + 3152); i; i >>= 1)
      {
        int v3 = &v4[6 * (i >> 1)];
        if (*v3 <= a1 && a1 <= v3[1]) {
          return (v3[2] + a1 - *v3);
        }
        if (a1 > v3[1])
        {
          unsigned int v4 = v3 + 6;
          --i;
        }
      }
      return a1;
    }
    else
    {
      return *(unsigned int *)(*(void *)(v6[166] + 120) + 1084 + 4 * a1);
    }
  }
  else
  {
    return a1;
  }
}

uint64_t ___tolower(int a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    int v5 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    int v5 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return ___tolower_l(a1, v5);
  }
  else {
    return ___tolower_l(a1, __global_locale);
  }
}

uint64_t ___toupper_l(int a1, void *a2)
{
  uint64_t v6 = a2;
  if (a1 >= 0)
  {
    if (a2)
    {
      if (a2 == (void *)-1) {
        uint64_t v6 = &__global_locale;
      }
    }
    else
    {
      uint64_t v6 = &__c_locale;
    }
    if (a1 >= 256)
    {
      unsigned int v4 = *(_DWORD **)(*(void *)(v6[166] + 120) + 3176);
      for (unint64_t i = *(int *)(*(void *)(v6[166] + 120) + 3168); i; i >>= 1)
      {
        int v3 = &v4[6 * (i >> 1)];
        if (*v3 <= a1 && a1 <= v3[1]) {
          return (v3[2] + a1 - *v3);
        }
        if (a1 > v3[1])
        {
          unsigned int v4 = v3 + 6;
          --i;
        }
      }
      return a1;
    }
    else
    {
      return *(unsigned int *)(*(void *)(v6[166] + 120) + 2108 + 4 * a1);
    }
  }
  else
  {
    return a1;
  }
}

uint64_t ___toupper(int a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    int v5 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    int v5 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return ___toupper_l(a1, v5);
  }
  else {
    return ___toupper_l(a1, __global_locale);
  }
}

uint64_t _UTF8_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _UTF8_mbrtowc;
  *(void *)(a1 + 96) = _UTF8_wcrtomb;
  *(void *)(a1 + 80) = _UTF8_mbsinit;
  *(void *)(a1 + 88) = _UTF8_mbsnrtowcs;
  *(void *)(a1 + 104) = _UTF8_wcsnrtombs;
  *(_DWORD *)(a1 + 64) = 4;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _UTF8_mbrtowc(int *a1, unsigned char *a2, unint64_t a3, uint64_t a4)
{
  uint64_t v17 = a2;
  char v12 = 0;
  if (*(_DWORD *)(a4 + 4) > 4u)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    uint64_t v17 = &unk_D793D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3) {
    return -2;
  }
  if (!*(_DWORD *)(a4 + 4))
  {
    int v14 = *v17;
    if ((v14 & 0xFFFFFF80) == 0)
    {
      if (a1) {
        *a1 = v14;
      }
      return v14 != 0;
    }
  }
  if (!*(_DWORD *)(a4 + 4))
  {
    int v15 = *v17;
    if ((v15 & 0x80u) == 0)
    {
      char v12 = 127;
      int v11 = 1;
      __int16 v9 = sb_00_00;
      goto LABEL_33;
    }
    if ((v15 & 0xE0) == 0xC0)
    {
      if (*v17 >= 0xC2u)
      {
        char v12 = 31;
        int v11 = 2;
        __int16 v9 = sb_80_BF;
        goto LABEL_33;
      }
    }
    else
    {
      if ((v15 & 0xF0) == 0xE0)
      {
        char v12 = 15;
        int v11 = 3;
        if (v15 == 224)
        {
          __int16 v9 = sb_A0_BF;
        }
        else if (v15 == 237)
        {
          __int16 v9 = sb_80_9F;
        }
        else
        {
          __int16 v9 = sb_80_BF;
        }
        goto LABEL_33;
      }
      if ((v15 & 0xF8) == 0xF0 && *v17 <= 0xF4u)
      {
        char v12 = 7;
        int v11 = 4;
        if (v15 == 240)
        {
          __int16 v9 = sb_90_BF;
        }
        else if (v15 == 244)
        {
          __int16 v9 = sb_80_8F;
        }
        else
        {
          __int16 v9 = sb_80_BF;
        }
        goto LABEL_33;
      }
    }
LABEL_31:
    *__error() = 92;
    return -1;
  }
  int v11 = *(_DWORD *)(a4 + 4);
  __int16 v9 = *(_WORD *)(a4 + 8);
LABEL_33:
  if (*(_DWORD *)(a4 + 4))
  {
    int v10 = *(_DWORD *)a4;
  }
  else
  {
    unsigned int v4 = v17++;
    int v10 = (*v4 & v12);
  }
  for (int i = *(_DWORD *)(a4 + 4) == 0; ; ++i)
  {
    unint64_t v8 = v11 >= a3 ? a3 : v11;
    if (i >= v8) {
      break;
    }
    if ((_BYTE)v9)
    {
      if (*v17 < (int)v9 || *v17 > (int)HIBYTE(v9)) {
        goto LABEL_31;
      }
      __int16 v9 = sb_00_00;
    }
    else if ((*v17 & 0xC0) != 0x80)
    {
      goto LABEL_31;
    }
    int v5 = v17++;
    int v10 = (v10 << 6) | *v5 & 0x3F;
  }
  if (i >= v11)
  {
    if (a1) {
      *a1 = v10;
    }
    *(_DWORD *)(a4 + 4) = 0;
    if (v10) {
      return v11;
    }
    else {
      return 0;
    }
  }
  else
  {
    *(_DWORD *)(a4 + 4) = v11 - i;
    *(_WORD *)(a4 + 8) = v9;
    *(_DWORD *)a4 = v10;
    return -2;
  }
}

uint64_t _UTF8_wcrtomb(unsigned char *a1, int a2, uint64_t a3)
{
  int v7 = a2;
  if (*(_DWORD *)(a3 + 4))
  {
    *__error() = 22;
    return -1;
  }
  if (!a1) {
    return 1;
  }
  if ((a2 & 0xFFFFFF80) == 0)
  {
    *a1 = a2;
    return 1;
  }
  if ((a2 & 0xFFFFF800) == 0)
  {
    char v6 = -64;
    int v4 = 2;
    goto LABEL_17;
  }
  if ((a2 & 0xFFFF0000) == 0)
  {
    if (a2 < 55296 || a2 >= 57344)
    {
      char v6 = -32;
      int v4 = 3;
      goto LABEL_17;
    }
LABEL_16:
    *__error() = 92;
    return -1;
  }
  if ((a2 & 0xFFE00000) != 0 || a2 >= 1114112) {
    goto LABEL_16;
  }
  char v6 = -16;
  int v4 = 4;
LABEL_17:
  for (int i = v4 - 1; i > 0; --i)
  {
    a1[i] = v7 & 0x3F | 0x80;
    v7 >>= 6;
  }
  *a1 = v7 | v6;
  return v4;
}

BOOL _UTF8_mbsinit(uint64_t a1)
{
  BOOL v2 = 1;
  if (a1) {
    return *(_DWORD *)(a1 + 4) == 0;
  }
  return v2;
}

uint64_t _UTF8_mbsnrtowcs(int *a1, char **a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v19 = a1;
  int v18 = a2;
  unint64_t v17 = a3;
  uint64_t v16 = a4;
  uint64_t v15 = a5;
  uint64_t v14 = a6;
  char v12 = 0;
  uint64_t v11 = 0;
  int v10 = 0;
  uint64_t v13 = a5;
  char v12 = *a2;
  uint64_t v11 = 0;
  if (a1)
  {
    if (!v17 || !v16 || *(int *)(v13 + 4) <= 0 || *v12 <= 0)
    {
      while (1)
      {
        if (!v16--)
        {
          *int v18 = v12;
          return v11;
        }
        if (v17 && *v12 > 0)
        {
          *uint64_t v19 = *v12;
          uint64_t v9 = 1;
        }
        else
        {
          uint64_t v9 = _UTF8_mbrtowc(v19, v12, v17, v15);
          switch(v9)
          {
            case -1:
              *int v18 = v12;
              return -1;
            case -2:
              *int v18 = &v12[v17];
              return v11;
            case 0:
              *int v18 = 0;
              return v11;
          }
        }
        v12 += v9;
        v17 -= v9;
        ++v11;
        ++v19;
      }
    }
  }
  else if (!v17 || *(int *)(v13 + 4) <= 0 || *v12 <= 0)
  {
    while (1)
    {
      if (v17 && *v12 > 0)
      {
        uint64_t v8 = 1;
      }
      else
      {
        uint64_t v8 = _UTF8_mbrtowc(&v10, v12, v17, v15);
        if (v8 == -1) {
          return -1;
        }
        if (!v8 || v8 == -2) {
          return v11;
        }
      }
      v12 += v8;
      v17 -= v8;
      ++v11;
    }
  }
  *__error() = 92;
  return -1;
}

uint64_t _UTF8_wcsnrtombs(char *a1, int **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  int v21 = a1;
  int v20 = a2;
  uint64_t v19 = a3;
  unint64_t v18 = a4;
  uint64_t v17 = a5;
  uint64_t v16 = a6;
  uint64_t v15 = a5;
  if (*(_DWORD *)(a5 + 4))
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    uint64_t v13 = *v20;
    uint64_t v12 = 0;
    if (v21)
    {
      while (1)
      {
        BOOL v9 = 0;
        if (v18)
        {
          uint64_t v7 = v19--;
          BOOL v9 = v7 != 0;
        }
        if (!v9) {
          break;
        }
        if (*v13 >= 0x80)
        {
          if (v18 <= 4)
          {
            unint64_t __na = _UTF8_wcrtomb(__src, *v13, v17);
            if (__na == -1)
            {
              __int32 *v20 = v13;
              return -1;
            }
            if (__na > (int)v18) {
              break;
            }
            memcpy(v21, __src, __na);
          }
          else
          {
            unint64_t __na = _UTF8_wcrtomb(v21, *v13, v17);
            if (__na == -1)
            {
              __int32 *v20 = v13;
              return -1;
            }
          }
        }
        else
        {
          unint64_t __na = 1;
          *int v21 = *v13;
        }
        if (!*v13)
        {
          __int32 *v20 = 0;
          return v12 + __na - 1;
        }
        ++v13;
        v21 += __na;
        v18 -= __na;
        v12 += __na;
      }
      __int32 *v20 = v13;
      return v12;
    }
    else
    {
      while (v19--)
      {
        if (*v13 >= 0x80)
        {
          __signed int n = _UTF8_wcrtomb(__src, *v13, v17);
          if (__n == -1) {
            return -1;
          }
        }
        else
        {
          __signed int n = 1;
        }
        if (!*v13) {
          return v12 + __n - 1;
        }
        ++v13;
        v12 += __n;
      }
      return v12;
    }
  }
}

size_t wcrtomb_l(char *a1, __int32 a2, mbstate_t *a3, locale_t a4)
{
  char v6 = a3;
  locale_t v5 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      locale_t v5 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v5 = (locale_t)&__c_locale;
  }
  if (!a3) {
    char v6 = (mbstate_t *)((char *)v5 + 784);
  }
  return (*(uint64_t (**)(char *, void, mbstate_t *, locale_t))(*((void *)v5 + 166) + 96))(a1, a2, v6, v5);
}

size_t wcrtomb(char *a1, __int32 a2, mbstate_t *a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcrtomb_l(a1, a2, a3, v9);
  }
  else {
    return wcrtomb_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

size_t wcsftime_l(__int32 *a1, size_t a2, const __int32 *a3, const tm *a4, locale_t a5)
{
  uint64_t v17 = a1;
  size_t v16 = a2;
  uint64_t v15 = (__int32 *)a3;
  uint64_t v14 = (tm *)a4;
  locale_t v13 = a5;
  memset(&__b, 0, sizeof(__b));
  uint64_t v12 = 0;
  uint64_t v11 = 0;
  uint64_t v10 = 0;
  BOOL v9 = 0;
  if (v13)
  {
    if (v13 == (locale_t)-1) {
      locale_t v13 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v13 = (locale_t)&__c_locale;
  }
  uint64_t v12 = 0;
  uint64_t v11 = 0;
  memcpy(&__b, &wcsftime_l_initial, sizeof(__b));
  BOOL v9 = v15;
  size_t v7 = wcsrtombs_l(0, (const __int32 **)&v9, 0, &__b, v13);
  if (v7 == -1) {
    goto LABEL_16;
  }
  uint64_t v11 = (char *)malloc_type_malloc();
  if (!v11) {
    goto LABEL_16;
  }
  memcpy(&__b, &wcsftime_l_initial, sizeof(__b));
  wcsrtombs_l(v11, (const __int32 **)&v9, v7 + 1, &__b, v13);
  if (0xFFFFFFFFFFFFFFFFLL / *(int *)(*((void *)v13 + 166) + 64) <= v16)
  {
    *__error() = 22;
LABEL_16:
    int v6 = *__error();
    free(v11);
    free(v12);
    *__error() = v6;
    return 0;
  }
  uint64_t v12 = (char *)malloc_type_malloc();
  if (!v12) {
    goto LABEL_16;
  }
  if (!strftime_l(v12, v16, v11, v14, v13)) {
    goto LABEL_16;
  }
  uint64_t v10 = v12;
  memcpy(&__b, &wcsftime_l_initial, sizeof(__b));
  size_t v8 = mbsrtowcs_l(v17, (const char **)&v10, v16, &__b, v13);
  if (v8 == -2 || v8 == -1 || v10) {
    goto LABEL_16;
  }
  free(v11);
  free(v12);
  return v8;
}

size_t wcsftime(__int32 *a1, size_t a2, const __int32 *a3, const tm *a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    uint64_t v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    uint64_t v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    return wcsftime_l(a1, a2, a3, a4, v11);
  }
  else {
    return wcsftime_l(a1, a2, a3, a4, (locale_t)__global_locale);
  }
}

size_t wcsnrtombs_l(char *a1, const __int32 **a2, size_t a3, size_t a4, mbstate_t *a5, locale_t a6)
{
  size_t v8 = a5;
  locale_t v7 = a6;
  if (a6)
  {
    if (a6 == (locale_t)-1) {
      locale_t v7 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v7 = (locale_t)&__c_locale;
  }
  if (!a5) {
    size_t v8 = (mbstate_t *)((char *)v7 + 912);
  }
  return (*(uint64_t (**)(char *, const __int32 **, size_t, size_t, mbstate_t *, locale_t))(*((void *)v7 + 166) + 104))(a1, a2, a3, a4, v8, v7);
}

size_t wcsnrtombs(char *a1, const __int32 **a2, size_t a3, size_t a4, mbstate_t *a5)
{
  if (v5) {
    char v6 = 1;
  }
  else {
    char v6 = 0;
  }
  if (v6)
  {
    locale_t v13 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v14 = __locale_key;
    locale_t v13 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v14);
  }
  if (v13) {
    return wcsnrtombs_l(a1, a2, a3, a4, a5, v13);
  }
  else {
    return wcsnrtombs_l(a1, a2, a3, a4, a5, (locale_t)__global_locale);
  }
}

uint64_t __wcsnrtombs_std(void *a1, _DWORD **a2, uint64_t a3, unint64_t a4, void *a5, uint64_t a6)
{
  mbstate_t __dst = a1;
  unint64_t v22 = a2;
  uint64_t v21 = a3;
  unint64_t v20 = a4;
  uint64_t __src = a5;
  uint64_t v18 = a6;
  memset(__b, 0, sizeof(__b));
  uint64_t v12 = *(void *)(v18 + 1328);
  uint64_t v11 = *(uint64_t (**)(void *, void, void *, uint64_t))(v12 + 96);
  int v10 = *(_DWORD *)(v12 + 64);
  size_t v16 = *v22;
  uint64_t v15 = 0;
  if (__dst)
  {
    while (1)
    {
      BOOL v9 = 0;
      if (v20)
      {
        uint64_t v7 = v21--;
        BOOL v9 = v7 != 0;
      }
      if (!v9) {
        break;
      }
      if (v20 <= v10)
      {
        memcpy(__b, __src, sizeof(__b));
        unint64_t __na = v11(v17, *v16, __src, v18);
        if (__na == -1)
        {
          *unint64_t v22 = v16;
          return -1;
        }
        if (__na > (int)v20)
        {
          memcpy(__src, __b, 0x80uLL);
          break;
        }
        memcpy(__dst, v17, __na);
      }
      else
      {
        unint64_t __na = v11(__dst, *v16, __src, v18);
        if (__na == -1)
        {
          *unint64_t v22 = v16;
          return -1;
        }
      }
      if (!*v16)
      {
        *unint64_t v22 = 0;
        return v15 + __na - 1;
      }
      ++v16;
      mbstate_t __dst = (char *)__dst + __na;
      v20 -= __na;
      v15 += __na;
    }
    *unint64_t v22 = v16;
    return v15;
  }
  else
  {
    while (v21--)
    {
      __signed int n = v11(v17, *v16, __src, v18);
      if (__n == -1) {
        return -1;
      }
      if (!*v16) {
        return v15 + __n - 1;
      }
      ++v16;
      v15 += __n;
    }
    return v15;
  }
}

size_t wcsrtombs_l(char *a1, const __int32 **a2, size_t a3, mbstate_t *a4, locale_t a5)
{
  uint64_t v7 = a4;
  locale_t v6 = a5;
  if (a5)
  {
    if (a5 == (locale_t)-1) {
      locale_t v6 = (locale_t)&__global_locale;
    }
  }
  else
  {
    locale_t v6 = (locale_t)&__c_locale;
  }
  if (!a4) {
    uint64_t v7 = (mbstate_t *)((char *)v6 + 1040);
  }
  return (*(uint64_t (**)(char *, const __int32 **, uint64_t, size_t, mbstate_t *, locale_t))(*((void *)v6 + 166) + 104))(a1, a2, -1, a3, v7, v6);
}

size_t wcsrtombs(char *a1, const __int32 **a2, size_t a3, mbstate_t *a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    uint64_t v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    uint64_t v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    return wcsrtombs_l(a1, a2, a3, a4, v11);
  }
  else {
    return wcsrtombs_l(a1, a2, a3, a4, (locale_t)__global_locale);
  }
}

size_t __wcs_end_offset(const char *a1, uint64_t a2, _xlocale *a3)
{
  __little = localeconv_l(a3)->decimal_point;
  __lesigned int n = a2 - (void)a1;
  if (strnstr(a1, __little, a2 - (void)a1)) {
    __len -= strlen(__little) - 1;
  }
  return __len;
}

double wcstod_l(const __int32 *a1, __int32 **a2, locale_t a3)
{
  size_t v16 = &v34;
  size_t v30 = (wint_t *)a1;
  int v29 = a2;
  uint64_t v28 = a3;
  memset(&__b, 0, sizeof(__b));
  double v27 = 0.0;
  __int32 v26 = 0;
  unint64_t v25 = 0;
  size_t v24 = 0;
  locale_t v23 = 0;
  uint64_t v22 = 0;
  __int32 v32 = 0;
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    __int32 v32 = pthread_getspecific(__locale_key);
  }
  else
  {
    char v5 = v16;
    uint64_t v33 = __locale_key;
    *(void *)size_t v16 = __locale_key;
    *((void *)v5 + 1) = 0;
    *((void *)v5 + 1) = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    __int32 v32 = *(void **)(*((void *)v5 + 1) + 8 * *(void *)v5);
  }
  if (v32) {
    uint64_t v15 = v32;
  }
  else {
    uint64_t v15 = __global_locale;
  }
  uint64_t v6 = (*(_DWORD *)(v15[166] + 64) + 1);
  uint64_t v21 = v10;
  uint64_t v14 = &v10[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v20 = v6;
  uint64_t v19 = v30;
  uint64_t v18 = 0;
  if (v28)
  {
    if (v28 == (_xlocale *)-1) {
      uint64_t v28 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v28 = (_xlocale *)&__c_locale;
  }
  locale_t v23 = (locale_t)__numeric_ctype((uint64_t)v28);
  while (iswspace_l(*v30, v23))
    ++v30;
  uint64_t v22 = _simple_salloc();
  if (v22)
  {
    uint64_t v18 = v30;
    memcpy(&__b, &wcstod_l_initial, sizeof(__b));
    while (1)
    {
      BOOL v7 = *v30 == 0;
      BOOL v13 = 0;
      if (!v7)
      {
        size_t v24 = wcrtomb_l(v14, *v30, &__b, v23);
        BOOL v13 = v24 != -1;
      }
      if (!v13) {
        break;
      }
      v14[v24] = 0;
      if ((int)_simple_sappend() < 0)
      {
        _simple_sfree();
        double v31 = 0.0;
        int v17 = 1;
        return v31;
      }
      ++v30;
    }
    __int32 v26 = (const char *)_simple_string();
    double v27 = strtod_l(v26, &v25, v28);
    if (v29)
    {
      if (v25 == v26)
      {
        uint64_t v12 = v19;
      }
      else
      {
        uint64_t v11 = v18;
        size_t v8 = __wcs_end_offset(v26, (uint64_t)v25, v28);
        uint64_t v12 = &v11[v8];
      }
      *int v29 = v12;
    }
    _simple_sfree();
    double v31 = v27;
    int v17 = 1;
  }
  else
  {
    double v31 = 0.0;
    int v17 = 1;
  }
  return v31;
}

double wcstod(const __int32 *a1, __int32 **a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    BOOL v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    BOOL v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return wcstod_l(a1, a2, v7);
  }
  else {
    return wcstod_l(a1, a2, (locale_t)__global_locale);
  }
}

float wcstof_l(const __int32 *a1, __int32 **a2, locale_t a3)
{
  size_t v16 = &v34;
  size_t v30 = (wint_t *)a1;
  int v29 = a2;
  uint64_t v28 = a3;
  memset(&__b, 0, sizeof(__b));
  float v27 = 0.0;
  __int32 v26 = 0;
  unint64_t v25 = 0;
  size_t v24 = 0;
  locale_t v23 = 0;
  uint64_t v22 = 0;
  __int32 v32 = 0;
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    __int32 v32 = pthread_getspecific(__locale_key);
  }
  else
  {
    char v5 = v16;
    uint64_t v33 = __locale_key;
    *(void *)size_t v16 = __locale_key;
    *((void *)v5 + 1) = 0;
    *((void *)v5 + 1) = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    __int32 v32 = *(void **)(*((void *)v5 + 1) + 8 * *(void *)v5);
  }
  if (v32) {
    uint64_t v15 = v32;
  }
  else {
    uint64_t v15 = __global_locale;
  }
  uint64_t v6 = (*(_DWORD *)(v15[166] + 64) + 1);
  uint64_t v21 = v10;
  uint64_t v14 = &v10[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v20 = v6;
  uint64_t v19 = v30;
  uint64_t v18 = 0;
  if (v28)
  {
    if (v28 == (_xlocale *)-1) {
      uint64_t v28 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v28 = (_xlocale *)&__c_locale;
  }
  locale_t v23 = (locale_t)__numeric_ctype((uint64_t)v28);
  while (iswspace_l(*v30, v23))
    ++v30;
  uint64_t v22 = _simple_salloc();
  if (v22)
  {
    uint64_t v18 = v30;
    memcpy(&__b, &wcstof_l_initial, sizeof(__b));
    while (1)
    {
      BOOL v7 = *v30 == 0;
      BOOL v13 = 0;
      if (!v7)
      {
        size_t v24 = wcrtomb_l(v14, *v30, &__b, v23);
        BOOL v13 = v24 != -1;
      }
      if (!v13) {
        break;
      }
      v14[v24] = 0;
      if ((int)_simple_sappend() < 0)
      {
        _simple_sfree();
        float v31 = 0.0;
        int v17 = 1;
        return v31;
      }
      ++v30;
    }
    __int32 v26 = (const char *)_simple_string();
    float v27 = strtof_l(v26, &v25, v28);
    if (v29)
    {
      if (v25 == v26)
      {
        uint64_t v12 = v19;
      }
      else
      {
        uint64_t v11 = v18;
        size_t v8 = __wcs_end_offset(v26, (uint64_t)v25, v28);
        uint64_t v12 = &v11[v8];
      }
      *int v29 = v12;
    }
    _simple_sfree();
    float v31 = v27;
    int v17 = 1;
  }
  else
  {
    float v31 = 0.0;
    int v17 = 1;
  }
  return v31;
}

float wcstof(const __int32 *a1, __int32 **a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    BOOL v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    BOOL v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return wcstof_l(a1, a2, v7);
  }
  else {
    return wcstof_l(a1, a2, (locale_t)__global_locale);
  }
}

intmax_t wcstoimax_l(const __int32 *nptr, __int32 **endptr, int base, locale_t a4)
{
  uint64_t v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      uint64_t v21 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v21 = (_xlocale *)&__c_locale;
  }
  uint64_t v20 = nptr;
  do
  {
    char v4 = (wint_t *)v20++;
    int v17 = *v4;
  }
  while (iswspace_l(*v4, v21));
  if (v17 == 45)
  {
    int v15 = 1;
    char v5 = (int *)v20++;
    int v17 = *v5;
  }
  else
  {
    int v15 = 0;
    if (v17 == 43)
    {
      uint64_t v6 = (int *)v20++;
      int v17 = *v6;
    }
  }
  if ((!base || base == 16) && v17 == 48 && (*v20 == 120 || *v20 == 88))
  {
    int v17 = v20[1];
    v20 += 2;
    base = 16;
  }
  if (!base)
  {
    if (v17 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    base = v7;
  }
  int v14 = 0;
  unint64_t v19 = 0;
  if (base < 2 || base > 36) {
    goto LABEL_51;
  }
  unint64_t v8 = 0x8000000000000000;
  if (!v15) {
    unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  wint_t v13 = v8 % base;
  unint64_t v16 = v8 / base;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      wint_t v18 = v17 - 48;
      goto LABEL_38;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      wint_t v18 = v17 - 55;
      goto LABEL_38;
    }
    if (v17 < 97 || v17 > 122) {
      break;
    }
    wint_t v18 = v17 - 87;
LABEL_38:
    if (v18 >= base) {
      break;
    }
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      int v14 = -1;
    }
    else
    {
      int v14 = 1;
      unint64_t v19 = v19 * base + v18;
    }
    BOOL v9 = (int *)v20++;
    int v17 = *v9;
  }
  if (v14 < 0)
  {
    unint64_t v10 = 0x8000000000000000;
    if (!v15) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v19 = v10;
    *__error() = 34;
    goto LABEL_54;
  }
  if (!v14)
  {
LABEL_51:
    *__error() = 22;
    goto LABEL_54;
  }
  if (v15) {
    unint64_t v19 = -(uint64_t)v19;
  }
LABEL_54:
  if (endptr)
  {
    if (v14) {
      uint64_t v12 = (__int32 *)(v20 - 1);
    }
    else {
      uint64_t v12 = (__int32 *)nptr;
    }
    *endptr = v12;
  }
  return v19;
}

intmax_t wcstoimax(const __int32 *__nptr, __int32 **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcstoimax_l(__nptr, __endptr, __base, v9);
  }
  else {
    return wcstoimax_l(__nptr, __endptr, __base, (locale_t)__global_locale);
  }
}

uint64_t wcstol_l(const __int32 *a1, __int32 **a2, int a3, locale_t a4)
{
  uint64_t v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      uint64_t v21 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v21 = (_xlocale *)&__c_locale;
  }
  uint64_t v20 = a1;
  do
  {
    char v4 = (wint_t *)v20++;
    int v17 = *v4;
  }
  while (iswspace_l(*v4, v21));
  if (v17 == 45)
  {
    int v15 = 1;
    char v5 = (int *)v20++;
    int v17 = *v5;
  }
  else
  {
    int v15 = 0;
    if (v17 == 43)
    {
      uint64_t v6 = (int *)v20++;
      int v17 = *v6;
    }
  }
  if ((!a3 || a3 == 16) && v17 == 48 && (*v20 == 120 || *v20 == 88))
  {
    int v17 = v20[1];
    v20 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v17 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    a3 = v7;
  }
  int v14 = 0;
  unint64_t v19 = 0;
  if (a3 < 2 || a3 > 36) {
    goto LABEL_51;
  }
  unint64_t v8 = 0x8000000000000000;
  if (!v15) {
    unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  wint_t v13 = v8 % a3;
  unint64_t v16 = v8 / a3;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      wint_t v18 = v17 - 48;
      goto LABEL_38;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      wint_t v18 = v17 - 55;
      goto LABEL_38;
    }
    if (v17 < 97 || v17 > 122) {
      break;
    }
    wint_t v18 = v17 - 87;
LABEL_38:
    if (v18 >= a3) {
      break;
    }
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      int v14 = -1;
    }
    else
    {
      int v14 = 1;
      unint64_t v19 = v19 * a3 + v18;
    }
    BOOL v9 = (int *)v20++;
    int v17 = *v9;
  }
  if (v14 < 0)
  {
    unint64_t v10 = 0x8000000000000000;
    if (!v15) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v19 = v10;
    *__error() = 34;
    goto LABEL_54;
  }
  if (!v14)
  {
LABEL_51:
    *__error() = 22;
    goto LABEL_54;
  }
  if (v15) {
    unint64_t v19 = -(uint64_t)v19;
  }
LABEL_54:
  if (a2)
  {
    if (v14) {
      uint64_t v12 = (__int32 *)(v20 - 1);
    }
    else {
      uint64_t v12 = (__int32 *)a1;
    }
    *a2 = v12;
  }
  return v19;
}

uint64_t wcstol(const __int32 *a1, __int32 **a2, int a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcstol_l(a1, a2, a3, v9);
  }
  else {
    return wcstol_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

long double wcstold_l(const __int32 *a1, __int32 **a2, locale_t a3)
{
  unint64_t v16 = &v34;
  size_t v30 = (wint_t *)a1;
  int v29 = a2;
  uint64_t v28 = a3;
  memset(&__b, 0, sizeof(__b));
  long double v27 = 0.0;
  __int32 v26 = 0;
  unint64_t v25 = 0;
  size_t v24 = 0;
  locale_t v23 = 0;
  uint64_t v22 = 0;
  __int32 v32 = 0;
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    __int32 v32 = pthread_getspecific(__locale_key);
  }
  else
  {
    char v5 = v16;
    uint64_t v33 = __locale_key;
    *(void *)unint64_t v16 = __locale_key;
    *((void *)v5 + 1) = 0;
    *((void *)v5 + 1) = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    __int32 v32 = *(void **)(*((void *)v5 + 1) + 8 * *(void *)v5);
  }
  if (v32) {
    int v15 = v32;
  }
  else {
    int v15 = __global_locale;
  }
  uint64_t v6 = (*(_DWORD *)(v15[166] + 64) + 1);
  uint64_t v21 = v10;
  int v14 = &v10[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  uint64_t v20 = v6;
  unint64_t v19 = v30;
  wint_t v18 = 0;
  if (v28)
  {
    if (v28 == (_xlocale *)-1) {
      uint64_t v28 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v28 = (_xlocale *)&__c_locale;
  }
  locale_t v23 = (locale_t)__numeric_ctype((uint64_t)v28);
  while (iswspace_l(*v30, v23))
    ++v30;
  uint64_t v22 = _simple_salloc();
  if (v22)
  {
    wint_t v18 = v30;
    memcpy(&__b, &wcstold_l_initial, sizeof(__b));
    while (1)
    {
      BOOL v7 = *v30 == 0;
      BOOL v13 = 0;
      if (!v7)
      {
        size_t v24 = wcrtomb_l(v14, *v30, &__b, v23);
        BOOL v13 = v24 != -1;
      }
      if (!v13) {
        break;
      }
      v14[v24] = 0;
      if ((int)_simple_sappend() < 0)
      {
        _simple_sfree();
        double v31 = 0.0;
        int v17 = 1;
        return v31;
      }
      ++v30;
    }
    __int32 v26 = (const char *)_simple_string();
    long double v27 = strtold_l(v26, &v25, v28);
    if (v29)
    {
      if (v25 == v26)
      {
        uint64_t v12 = v19;
      }
      else
      {
        uint64_t v11 = v18;
        size_t v8 = __wcs_end_offset(v26, (uint64_t)v25, v28);
        uint64_t v12 = &v11[v8];
      }
      *int v29 = v12;
    }
    _simple_sfree();
    double v31 = v27;
    int v17 = 1;
  }
  else
  {
    double v31 = 0.0;
    int v17 = 1;
  }
  return v31;
}

long double wcstold(const __int32 *a1, __int32 **a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    BOOL v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    BOOL v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return wcstold_l(a1, a2, v7);
  }
  else {
    return wcstold_l(a1, a2, (locale_t)__global_locale);
  }
}

uint64_t wcstoll_l(const __int32 *a1, __int32 **a2, int a3, locale_t a4)
{
  uint64_t v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      uint64_t v21 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v21 = (_xlocale *)&__c_locale;
  }
  uint64_t v20 = a1;
  do
  {
    char v4 = (wint_t *)v20++;
    int v17 = *v4;
  }
  while (iswspace_l(*v4, v21));
  if (v17 == 45)
  {
    int v15 = 1;
    char v5 = (int *)v20++;
    int v17 = *v5;
  }
  else
  {
    int v15 = 0;
    if (v17 == 43)
    {
      uint64_t v6 = (int *)v20++;
      int v17 = *v6;
    }
  }
  if ((!a3 || a3 == 16) && v17 == 48 && (*v20 == 120 || *v20 == 88))
  {
    int v17 = v20[1];
    v20 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v17 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    a3 = v7;
  }
  int v14 = 0;
  unint64_t v19 = 0;
  if (a3 < 2 || a3 > 36) {
    goto LABEL_51;
  }
  unint64_t v8 = 0x8000000000000000;
  if (!v15) {
    unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  wint_t v13 = v8 % a3;
  unint64_t v16 = v8 / a3;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      wint_t v18 = v17 - 48;
      goto LABEL_38;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      wint_t v18 = v17 - 55;
      goto LABEL_38;
    }
    if (v17 < 97 || v17 > 122) {
      break;
    }
    wint_t v18 = v17 - 87;
LABEL_38:
    if (v18 >= a3) {
      break;
    }
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      int v14 = -1;
    }
    else
    {
      int v14 = 1;
      unint64_t v19 = v19 * a3 + v18;
    }
    BOOL v9 = (int *)v20++;
    int v17 = *v9;
  }
  if (v14 < 0)
  {
    unint64_t v10 = 0x8000000000000000;
    if (!v15) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v19 = v10;
    *__error() = 34;
    goto LABEL_54;
  }
  if (!v14)
  {
LABEL_51:
    *__error() = 22;
    goto LABEL_54;
  }
  if (v15) {
    unint64_t v19 = -(uint64_t)v19;
  }
LABEL_54:
  if (a2)
  {
    if (v14) {
      uint64_t v12 = (__int32 *)(v20 - 1);
    }
    else {
      uint64_t v12 = (__int32 *)a1;
    }
    *a2 = v12;
  }
  return v19;
}

uint64_t wcstoll(const __int32 *a1, __int32 **a2, int a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcstoll_l(a1, a2, a3, v9);
  }
  else {
    return wcstoll_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

size_t wcstombs_l(char *a1, const __int32 *a2, size_t a3, locale_t a4)
{
  BOOL v9 = a1;
  unint64_t v8 = a2;
  size_t v7 = a3;
  locale_t v6 = a4;
  memset(__b, 0, sizeof(__b));
  char v5 = 0;
  if (v6)
  {
    if (v6 == (locale_t)-1) {
      locale_t v6 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v6 = (locale_t)&__c_locale;
  }
  memcpy(__b, &wcstombs_l_initial, sizeof(__b));
  char v5 = v8;
  return (*(uint64_t (**)(char *, const __int32 **, uint64_t, size_t, unsigned char *, locale_t))(*((void *)v6 + 166)
                                                                                                 + 104))(v9, &v5, -1, v7, __b, v6);
}

size_t wcstombs(char *a1, const __int32 *a2, size_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcstombs_l(a1, a2, a3, v9);
  }
  else {
    return wcstombs_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

unint64_t wcstoul_l(const __int32 *a1, __int32 **a2, int a3, locale_t a4)
{
  wint_t v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      wint_t v18 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    wint_t v18 = (_xlocale *)&__c_locale;
  }
  int v17 = a1;
  do
  {
    char v4 = (wint_t *)v17++;
    int v14 = *v4;
  }
  while (iswspace_l(*v4, v18));
  if (v14 == 45)
  {
    int v12 = 1;
    char v5 = (int *)v17++;
    int v14 = *v5;
  }
  else
  {
    int v12 = 0;
    if (v14 == 43)
    {
      locale_t v6 = (int *)v17++;
      int v14 = *v6;
    }
  }
  if ((!a3 || a3 == 16) && v14 == 48 && (*v17 == 120 || *v17 == 88))
  {
    int v14 = v17[1];
    v17 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v14 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    a3 = v7;
  }
  int v11 = 0;
  unint64_t v16 = 0;
  if (a3 < 2 || a3 > 36) {
    goto LABEL_47;
  }
  unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL / a3;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      wint_t v15 = v14 - 48;
      goto LABEL_36;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      wint_t v15 = v14 - 55;
      goto LABEL_36;
    }
    if (v14 < 97 || v14 > 122) {
      break;
    }
    wint_t v15 = v14 - 87;
LABEL_36:
    if (v15 >= a3) {
      break;
    }
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % a3))
    {
      int v11 = -1;
    }
    else
    {
      int v11 = 1;
      unint64_t v16 = v16 * a3 + v15;
    }
    unint64_t v8 = (int *)v17++;
    int v14 = *v8;
  }
  if (v11 < 0)
  {
    unint64_t v16 = -1;
    *__error() = 34;
    goto LABEL_50;
  }
  if (v11)
  {
    if (v12) {
      unint64_t v16 = -(uint64_t)v16;
    }
  }
  else
  {
LABEL_47:
    *__error() = 22;
  }
LABEL_50:
  if (a2)
  {
    if (v11) {
      uint64_t v10 = (__int32 *)(v17 - 1);
    }
    else {
      uint64_t v10 = (__int32 *)a1;
    }
    *a2 = v10;
  }
  return v16;
}

unint64_t wcstoul(const __int32 *a1, __int32 **a2, int a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcstoul_l(a1, a2, a3, v9);
  }
  else {
    return wcstoul_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

unint64_t wcstoull_l(const __int32 *a1, __int32 **a2, int a3, locale_t a4)
{
  wint_t v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      wint_t v18 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    wint_t v18 = (_xlocale *)&__c_locale;
  }
  int v17 = a1;
  do
  {
    char v4 = (wint_t *)v17++;
    int v14 = *v4;
  }
  while (iswspace_l(*v4, v18));
  if (v14 == 45)
  {
    int v12 = 1;
    char v5 = (int *)v17++;
    int v14 = *v5;
  }
  else
  {
    int v12 = 0;
    if (v14 == 43)
    {
      locale_t v6 = (int *)v17++;
      int v14 = *v6;
    }
  }
  if ((!a3 || a3 == 16) && v14 == 48 && (*v17 == 120 || *v17 == 88))
  {
    int v14 = v17[1];
    v17 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v14 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    a3 = v7;
  }
  int v11 = 0;
  unint64_t v16 = 0;
  if (a3 < 2 || a3 > 36) {
    goto LABEL_47;
  }
  unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL / a3;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      wint_t v15 = v14 - 48;
      goto LABEL_36;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      wint_t v15 = v14 - 55;
      goto LABEL_36;
    }
    if (v14 < 97 || v14 > 122) {
      break;
    }
    wint_t v15 = v14 - 87;
LABEL_36:
    if (v15 >= a3) {
      break;
    }
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % a3))
    {
      int v11 = -1;
    }
    else
    {
      int v11 = 1;
      unint64_t v16 = v16 * a3 + v15;
    }
    unint64_t v8 = (int *)v17++;
    int v14 = *v8;
  }
  if (v11 < 0)
  {
    unint64_t v16 = -1;
    *__error() = 34;
    goto LABEL_50;
  }
  if (v11)
  {
    if (v12) {
      unint64_t v16 = -(uint64_t)v16;
    }
  }
  else
  {
LABEL_47:
    *__error() = 22;
  }
LABEL_50:
  if (a2)
  {
    if (v11) {
      uint64_t v10 = (__int32 *)(v17 - 1);
    }
    else {
      uint64_t v10 = (__int32 *)a1;
    }
    *a2 = v10;
  }
  return v16;
}

unint64_t wcstoull(const __int32 *a1, __int32 **a2, int a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcstoull_l(a1, a2, a3, v9);
  }
  else {
    return wcstoull_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

uintmax_t wcstoumax_l(const __int32 *nptr, __int32 **endptr, int base, locale_t a4)
{
  wint_t v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      wint_t v18 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    wint_t v18 = (_xlocale *)&__c_locale;
  }
  int v17 = nptr;
  do
  {
    char v4 = (wint_t *)v17++;
    int v14 = *v4;
  }
  while (iswspace_l(*v4, v18));
  if (v14 == 45)
  {
    int v12 = 1;
    char v5 = (int *)v17++;
    int v14 = *v5;
  }
  else
  {
    int v12 = 0;
    if (v14 == 43)
    {
      locale_t v6 = (int *)v17++;
      int v14 = *v6;
    }
  }
  if ((!base || base == 16) && v14 == 48 && (*v17 == 120 || *v17 == 88))
  {
    int v14 = v17[1];
    v17 += 2;
    base = 16;
  }
  if (!base)
  {
    if (v14 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    base = v7;
  }
  int v11 = 0;
  uintmax_t v16 = 0;
  if (base < 2 || base > 36) {
    goto LABEL_47;
  }
  unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL / base;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      wint_t v15 = v14 - 48;
      goto LABEL_36;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      wint_t v15 = v14 - 55;
      goto LABEL_36;
    }
    if (v14 < 97 || v14 > 122) {
      break;
    }
    wint_t v15 = v14 - 87;
LABEL_36:
    if (v15 >= base) {
      break;
    }
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % base))
    {
      int v11 = -1;
    }
    else
    {
      int v11 = 1;
      uintmax_t v16 = v16 * base + v15;
    }
    unint64_t v8 = (int *)v17++;
    int v14 = *v8;
  }
  if (v11 < 0)
  {
    uintmax_t v16 = -1;
    *__error() = 34;
    goto LABEL_50;
  }
  if (v11)
  {
    if (v12) {
      uintmax_t v16 = -(uint64_t)v16;
    }
  }
  else
  {
LABEL_47:
    *__error() = 22;
  }
LABEL_50:
  if (endptr)
  {
    if (v11) {
      uint64_t v10 = (__int32 *)(v17 - 1);
    }
    else {
      uint64_t v10 = (__int32 *)nptr;
    }
    *endptr = v10;
  }
  return v16;
}

uintmax_t wcstoumax(const __int32 *__nptr, __int32 **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcstoumax_l(__nptr, __endptr, __base, v9);
  }
  else {
    return wcstoumax_l(__nptr, __endptr, __base, (locale_t)__global_locale);
  }
}

int wctob_l(wint_t a1, locale_t a2)
{
  unsigned int v5 = a1;
  locale_t v4 = a2;
  memcpy(__b, &wctob_l_initial, sizeof(__b));
  if (v4)
  {
    if (v4 == (locale_t)-1) {
      locale_t v4 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v4 = (locale_t)&__c_locale;
  }
  if (v5 != -1
    && (*(uint64_t (**)(unsigned char *, void, unsigned char *, locale_t))(*((void *)v4 + 166) + 96))(v3, v5, __b, v4) == 1)
  {
    return v3[0];
  }
  else
  {
    return -1;
  }
}

int wctob(wint_t a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    unsigned int v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    unsigned int v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return wctob_l(a1, v5);
  }
  else {
    return wctob_l(a1, (locale_t)__global_locale);
  }
}

int wctomb_l(char *a1, __int32 a2, locale_t a3)
{
  locale_t v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      locale_t v5 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v5 = (locale_t)&__c_locale;
  }
  if (a1)
  {
    uint64_t v4 = (*(uint64_t (**)(char *, void, uint64_t, locale_t))(*((void *)v5 + 166) + 96))(a1, a2, (uint64_t)v5 + 1168, v5);
    if (v4 == -1) {
      return -1;
    }
    else {
      return v4;
    }
  }
  else
  {
    memcpy((char *)v5 + 1168, &wctomb_l_initial, 0x80uLL);
    return 0;
  }
}

int wctomb(char *a1, __int32 a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return wctomb_l(a1, a2, v7);
  }
  else {
    return wctomb_l(a1, a2, (locale_t)__global_locale);
  }
}

wint_t towctrans_l(wint_t a1, wctrans_t a2, locale_t a3)
{
  wint_t v5 = a1;
  uint64_t v4 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      uint64_t v4 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v4 = (_xlocale *)&__c_locale;
  }
  if (!a2) {
    goto LABEL_11;
  }
  if (a2 == 1) {
    return towlower_l(a1, v4);
  }
  if (a2 != 2)
  {
LABEL_11:
    *__error() = 22;
    return v5;
  }
  return towupper_l(a1, v4);
}

wint_t towctrans(wint_t a1, wctrans_t a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return towctrans_l(a1, a2, v7);
  }
  else {
    return towctrans_l(a1, a2, (locale_t)__global_locale);
  }
}

wctrans_t wctrans(const char *a1)
{
  memcpy(__dst, &off_DC738, sizeof(__dst));
  for (int i = 0; ; ++i)
  {
    BOOL v2 = 0;
    if (*(void *)&__dst[i]) {
      BOOL v2 = strcmp(*(const char **)&__dst[i], a1) != 0;
    }
    if (!v2) {
      break;
    }
  }
  if (!DWORD2(__dst[i])) {
    *__error() = 22;
  }
  return DWORD2(__dst[i]);
}

wctrans_t wctrans_l(const char *a1, locale_t a2)
{
  return wctrans(a1);
}

wctype_t wctype_l(const char *a1, locale_t a2)
{
  for (int i = 0; ; ++i)
  {
    BOOL v4 = 0;
    if ((&wctype_l_props)[2 * i]) {
      BOOL v4 = strcmp((&wctype_l_props)[2 * i], a1) != 0;
    }
    if (!v4) {
      break;
    }
  }
  if (LODWORD((&wctype_l_props)[2 * i + 1])) {
    return (wctype_t)(&wctype_l_props)[2 * i + 1];
  }
  if (a2)
  {
    if (a2 == (locale_t)-1) {
      a2 = (locale_t)__global_locale;
    }
  }
  else
  {
    a2 = (locale_t)&__c_locale;
  }
  uint64_t v8 = *(void *)(*((void *)a2 + 166) + 120);
  int v7 = *(_DWORD *)(v8 + 3196);
  if (v7 > 0)
  {
    for (__s1 = *(char **)(v8 + 3200); ; __s1 += 20)
    {
      int v2 = v7--;
      if (v2 <= 0) {
        break;
      }
      if (!strncmp(__s1, a1, 0xEuLL)) {
        return *((_DWORD *)__s1 + 4);
      }
    }
  }
  return 0;
}

wctype_t wctype(const char *a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    wint_t v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    wint_t v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return wctype_l(a1, v5);
  }
  else {
    return wctype_l(a1, (locale_t)__global_locale);
  }
}

int wcwidth(__int32 a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    wint_t v5 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    wint_t v5 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return __wcwidth_l(a1, v5);
  }
  else {
    return __wcwidth_l(a1, __global_locale);
  }
}

int wcwidth_l(__int32 a1, locale_t a2)
{
  locale_t v3 = a2;
  if (!a2) {
    return __wcwidth_l(a1, __c_locale);
  }
  if (a2 == (locale_t)-1) {
    locale_t v3 = (locale_t)__global_locale;
  }
  return __wcwidth_l(a1, v3);
}

FILE *__cdecl open_memstream(char **__bufp, size_t *__sizep)
{
  if (__bufp && __sizep)
  {
    *__bufp = (char *)malloc_type_calloc();
    if (*__bufp)
    {
      uint64_t v6 = (void *)malloc_type_malloc();
      if (v6)
      {
        *uint64_t v6 = __bufp;
        v6[1] = __sizep;
        unsigned char v6[2] = 0;
        v6[3] = 0;
        memstream_update((uint64_t)v6);
        locale_t v3 = funopen(v6, 0, (int (__cdecl *)(void *, const char *, int))memstream_write, (fpos_t (__cdecl *)(void *, fpos_t, int))memstream_seek, (int (__cdecl *)(void *))memstream_close);
        if (v3)
        {
          fwide(v3, -1);
          return v3;
        }
        else
        {
          int v5 = *__error();
          free(v6);
          free(*__bufp);
          *__bufp = 0;
          *__error() = v5;
          return 0;
        }
      }
      else
      {
        uint64_t v4 = *__error();
        free(*__bufp);
        *__bufp = 0;
        *__error() = v4;
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t memstream_update(uint64_t result)
{
  BOOL v2 = 0;
  if (*(uint64_t *)(result + 16) >= 0) {
    BOOL v2 = *(void *)(result + 24) >= 0;
  }
  if (!v2) {
    __assert_rtn("memstream_update", "open_memstream.c", 96, "ms->len >= 0 && ms->offset >= 0");
  }
  if (*(void *)(result + 16) >= *(void *)(result + 24)) {
    uint64_t v1 = *(void *)(result + 24);
  }
  else {
    uint64_t v1 = *(void *)(result + 16);
  }
  **(void **)(result + 8) = v1;
  return result;
}

uint64_t memstream_write(uint64_t **a1, const void *a2, int a3)
{
  if (memstream_grow(a1, (unint64_t)a1[3] + a3))
  {
    __signed int n = (char *)a1[2] - (char *)a1[3];
    if (a3 < __n) {
      __signed int n = a3;
    }
    memcpy((char *)a1[3] + **a1, a2, __n);
    a1[3] = (uint64_t *)((char *)a1[3] + __n);
    memstream_update((uint64_t)a1);
    fprintf(__stderrp, "MS: write(%p, %d) = %zd\n", a1, a3, __n);
    return __n;
  }
  else
  {
    return -1;
  }
}

uint64_t memstream_seek(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = a1[3];
  if (!a3)
  {
    if (a2 < 0) {
      __assert_rtn("memstream_seek", "open_memstream.c", 136, "pos >= 0");
    }
    a1[3] = a2;
    goto LABEL_18;
  }
  if (a3 == 1)
  {
    if (a2) {
      __assert_rtn("memstream_seek", "open_memstream.c", 141, "pos == 0");
    }
    goto LABEL_18;
  }
  if (a3 != 2)
  {
LABEL_18:
    memstream_update((uint64_t)a1);
    fprintf(__stderrp, "MS: seek(%p, %jd, %d) %jd -> %jd\n", a1, a2, a3, v4, a1[3]);
    return a1[3];
  }
  if (a2 >= 0)
  {
    if (0x7FFFFFFFFFFFFFFFLL - a1[2] < a2)
    {
      fprintf(__stderrp, "MS: bad SEEK_END: pos %jd, len %zd\n", a2, a1[2]);
      *__error() = 84;
      return -1;
    }
LABEL_17:
    a1[3] = a1[2] + a2;
    goto LABEL_18;
  }
  if (a2 + a1[2] >= 0) {
    goto LABEL_17;
  }
  fprintf(__stderrp, "MS: bad SEEK_END: pos %jd, len %zd\n", a2, a1[2]);
  *__error() = 22;
  return -1;
}

uint64_t memstream_close(void *a1)
{
  return 0;
}

uint64_t memstream_grow(uint64_t **a1, unint64_t a2)
{
  if (a2 <= 0x7FFFFFFFFFFFFFFELL) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0x7FFFFFFFFFFFFFFELL;
  }
  if (v6 <= (uint64_t)a1[2])
  {
    return 1;
  }
  else
  {
    BOOL v2 = a1[2];
    if ((unsigned __int128)((uint64_t)v2 * (__int128)15) >> 64 == (15 * (uint64_t)v2) >> 63) {
      uint64_t v5 = 15 * (uint64_t)v2 / 10;
    }
    else {
      uint64_t v5 = 0x7FFFFFFFFFFFFFFELL;
    }
    if (v5 <= v6) {
      uint64_t v4 = (char *)v6;
    }
    else {
      uint64_t v4 = (char *)v5;
    }
    uint64_t v7 = malloc_type_realloc();
    if (v7)
    {
      fprintf(__stderrp, "MS: %p growing from %zd to %zd\n", a1, (size_t)a1[2], (size_t)v4);
      bzero((char *)a1[2] + v7 + 1, v4 - (char *)a1[2]);
      **a1 = v7;
      a1[2] = (uint64_t *)v4;
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

void link_addr(const char *a1, sockaddr_dl *a2)
{
  sdl_data = a2->sdl_data;
  int v11 = (char *)(&a2->sdl_len + a2->sdl_len);
  char v10 = 0;
  unsigned int v9 = 0;
  char v8 = 0;
  bzero(&a2->sdl_family, a2->sdl_len - 1);
  a2->sdl_family = 18;
  do
  {
    v9 &= 0xFFFFFFF3;
    if (*a1 < 48 || *a1 > 57)
    {
      if (*a1 < 97 || *a1 > 102)
      {
        if (*a1 < 65 || *a1 > 70)
        {
          if (*a1)
          {
            if (v9 || (*a1 < 65 || *a1 > 90) && (*a1 < 97 || *a1 > 122)) {
              v9 |= 8u;
            }
            else {
              unsigned int v9 = 12;
            }
          }
          else
          {
            v9 |= 4u;
          }
        }
        else
        {
          char v8 = *a1 - 55;
        }
      }
      else
      {
        char v8 = *a1 - 87;
      }
    }
    else
    {
      char v8 = *a1 - 48;
    }
    ++a1;
    if (v9)
    {
      uint64_t v3 = v9;
      char v2 = 1;
    }
    else
    {
      uint64_t v3 = 0;
      char v2 = 0;
    }
    if ((v2 & 1) == 0)
    {
      switch(v3)
      {
        case 0:
        case 12:
          uint64_t v4 = sdl_data++;
          *uint64_t v4 = *(a1 - 1);
          continue;
        case 1:
          unsigned int v9 = 2;
          char v10 = v8 + 16 * v10;
          continue;
        case 2:
          uint64_t v5 = sdl_data++;
          *uint64_t v5 = v10;
          goto LABEL_28;
        case 3:
LABEL_28:
          unsigned int v9 = 1;
          char v10 = v8;
          continue;
        case 4:
        case 9:
        case 10:
        case 11:
          break;
        case 5:
        case 6:
          uint64_t v7 = sdl_data;
          LODWORD(sdl_data) = sdl_data + 1;
          *uint64_t v7 = v10;
          goto LABEL_33;
        case 7:
          goto LABEL_33;
        case 8:
          unsigned int v9 = 3;
          a2->sdl_nlesigned int n = (_BYTE)sdl_data - ((_BYTE)a2 + 8);
          continue;
        default:
          JUMPOUT(0);
      }
    }
    unsigned int v9 = 3;
    uint64_t v6 = sdl_data++;
    *uint64_t v6 = v10;
    char v10 = 0;
  }
  while (sdl_data < v11);
LABEL_33:
  a2->sdl_alesigned int n = (_BYTE)sdl_data - ((_BYTE)a2 + 8 + a2->sdl_nlen);
  if ((unint64_t)((int)sdl_data - (int)a2) > 0x14) {
    a2->sdl_lesigned int n = (_BYTE)sdl_data - (_BYTE)a2;
  }
}

char *__cdecl link_ntoa(const sockaddr_dl *a1)
{
  unsigned int v9 = link_ntoa_obuf;
  uint64_t v7 = &a1->sdl_data[a1->sdl_nlen];
  uint64_t v6 = &v7[a1->sdl_alen];
  int v5 = 1;
  if ((unint64_t)(a1->sdl_nlen + 3 * a1->sdl_alen) < 0x40)
  {
    if (a1->sdl_nlen)
    {
      bcopy(a1->sdl_data, link_ntoa_obuf, a1->sdl_nlen);
      unsigned int v9 = &link_ntoa_obuf[a1->sdl_nlen];
      if (a1->sdl_alen)
      {
        ++v9;
        link_ntoa_obuf[a1->sdl_nlen] = 58;
      }
    }
    while (v7 < v6)
    {
      if (v5)
      {
        int v5 = 0;
      }
      else
      {
        uint64_t v1 = v9++;
        *uint64_t v1 = 46;
      }
      char v2 = v7++;
      int v8 = *v2;
      if (v8 <= 0xF)
      {
        uint64_t v3 = v9++;
        *uint64_t v3 = hexlist[*v2];
      }
      else
      {
        v9[1] = hexlist[v8 & 0xF];
        *unsigned int v9 = hexlist[v8 >> 4];
        v9 += 2;
      }
    }
  }
  *unsigned int v9 = 0;
  return link_ntoa_obuf;
}

uint64_t recv_NOCANCEL()
{
  return __recvfrom_nocancel();
}

uint64_t send_NOCANCEL()
{
  return __sendto_nocancel();
}

int sockatmark(int a1)
{
  v2[1] = a1;
  v2[0] = 0;
  if (ioctl(a1, 0x40047307uLL, v2) == -1) {
    return -1;
  }
  else {
    return v2[0];
  }
}

nl_catd catopen(const char *a1, int a2)
{
  __s = (char *)a1;
  int __size_4 = a2;
  int __size = 0;
  int v23 = 0;
  uint64_t v22 = 0;
  __s1 = 0;
  uint64_t v20 = 0;
  __stringp = 0;
  mbstate_t __dst = 0;
  __source = 0;
  uintmax_t v16 = 0;
  wint_t v15 = 0;
  int v14 = 0;
  unint64_t v13 = 0;
  memset(&__b, 0, sizeof(__b));
  if (__s && *__s)
  {
    if (strchr(__s, 47)) {
      return (nl_catd)loadCat(__s);
    }
    if (__size_4 == 1) {
      __s1 = (char *)querylocale(4, 0);
    }
    else {
      __s1 = getenv("LANG");
    }
    if (!__s1
      || !*__s1
      || strlen(__s1) > 0x1F
      || *__s1 == 46 && (!__s1[1] || __s1[1] == 46 && !__s1[2])
      || strchr(__s1, 47))
    {
      __s1 = "C";
    }
    uintmax_t v16 = strdup(__s1);
    wint_t v15 = v16;
    if (!v16) {
      return (nl_catd)-1;
    }
    __stringp = strchr(v16, 64);
    if (__stringp) {
      char *__stringp = 0;
    }
    unint64_t v13 = (char *)&unk_D793D;
    int v14 = (char *)&unk_D793D;
    __stringp = strchr(v16, 95);
    if (__stringp)
    {
      char v2 = __stringp++;
      *char v2 = 0;
      uintmax_t v16 = __stringp;
      int v14 = __stringp;
    }
    __stringp = strchr(v16, 46);
    if (__stringp)
    {
      uint64_t v3 = __stringp++;
      *uint64_t v3 = 0;
      unint64_t v13 = __stringp;
    }
    uint64_t v22 = getenv("NLSPATH");
    if (!v22 || issetugid()) {
      uint64_t v22 = "/usr/share/nls/%L/%N.cat:/usr/share/nls/%N/%L:/usr/local/share/nls/%L/%N.cat:/usr/local/share/nls/%N/%L";
    }
    __stringp = strdup(v22);
    uint64_t v20 = __stringp;
    if (!__stringp)
    {
      int v23 = *__error();
      free(v15);
      int v11 = v23;
      *__error() = v11;
      return (nl_catd)-1;
    }
    while (1)
    {
      uint64_t v22 = strsep(&__stringp, ":");
      if (!v22)
      {
        free(v15);
        free(v20);
        *__error() = 2;
        return (nl_catd)-1;
      }
      mbstate_t __dst = v28;
      if (!*v22) {
        break;
      }
      while (*v22)
      {
        if (*v22 == 37)
        {
          int v10 = v22[1];
          switch(v10)
          {
            case '%':
              ++v22;
LABEL_48:
              if ((unint64_t)(__dst - v28) >= 0x3FF) {
                goto LABEL_52;
              }
              char v4 = *v22;
              int v5 = __dst++;
              *int v5 = v4;
              goto LABEL_56;
            case 'L':
              __source = __s1;
              break;
            case 'N':
              __source = __s;
              break;
            case 'c':
              __source = v13;
              break;
            case 'l':
              __source = (char *)v15;
              break;
            case 't':
              __source = v14;
              break;
            default:
              goto LABEL_48;
          }
          ++v22;
          goto LABEL_51;
        }
        if ((unint64_t)(__dst - v28) >= 0x3FF)
        {
LABEL_52:
          free(v15);
          free(v20);
          *__error() = 63;
          return (nl_catd)-1;
        }
        char v7 = *v22;
        int v8 = __dst++;
        *int v8 = v7;
LABEL_56:
        ++v22;
      }
      char *__dst = 0;
      if (!stat(v28, &__b))
      {
        free(v15);
        free(v20);
        return (nl_catd)loadCat(v28);
      }
    }
    __source = __s;
    --v22;
LABEL_51:
    int __size = 1023 - (__dst - v28);
    size_t v6 = strlcpy(__dst, __source, __size);
    if (v6 >= __size) {
      goto LABEL_52;
    }
    __dst += strlen(__source);
    goto LABEL_56;
  }
  *__error() = 22;
  return (nl_catd)-1;
}

uint64_t loadCat(const char *a1)
{
  *(_OWORD *)__s1 = 0u;
  long long v22 = 0u;
  wint_t v18 = (FILE **)malloc_type_malloc();
  if (!v18) {
    return -1;
  }
  int v11 = open_NOCANCEL();
  if (v11 == -1)
  {
    int v12 = *__error();
    free(v18);
    *__error() = v12;
    return -1;
  }
  else
  {
    uint64_t v1 = fdopen(v11, "r");
    *wint_t v18 = v1;
    if (v1)
    {
      if (fread(__s1, 0x20uLL, 1uLL, *v18) == 1 && !strncmp(__s1, "*nazgul*", 8uLL))
      {
        if (_OSSwapInt32(*(unsigned int *)&__s1[8]) == 1)
        {
          if (_OSSwapInt32(DWORD1(v22)))
          {
            *((_DWORD *)v18 + 2) = _OSSwapInt32(DWORD1(v22));
            uint64_t v2 = malloc_type_malloc();
            v18[2] = (FILE *)v2;
            if (v2)
            {
              off_t v15 = _OSSwapInt64(*((unint64_t *)&v22 + 1));
              for (int i = 0; i < *((_DWORD *)v18 + 2); ++i)
              {
                if (fseeko(*v18, v15, 0) == -1
                  || (uint64_t v17 = (uint64_t)v18[2] + 40 * i, fread((void *)v17, 0x28uLL, 1uLL, *v18) != 1))
                {
                  __nls_free_resources((uint64_t)v18, i);
                  fclose(*v18);
                  fprintf(__stderrp, "%s: corrupt file.", _errowner);
                  free(v18);
                  *__error() = 79;
                  return -1;
                }
                if (*(_DWORD *)(v17 + 36)) {
                  --i;
                }
                else {
                  *(_DWORD *)(v17 + 36) = 1;
                }
                off_t v15 = _OSSwapInt64(*(void *)(v17 + 4));
              }
              return (uint64_t)v18;
            }
            else
            {
              int v14 = *__error();
              fclose(*v18);
              fprintf(__stderrp, "%s: no more memory.", _errowner);
              free(v18);
              *__error() = v14;
              return -1;
            }
          }
          else
          {
            fclose(*v18);
            free(v18);
            int v5 = __stderrp;
            size_t v6 = _errowner;
            int v4 = _OSSwapInt32(DWORD1(v22));
            fprintf(v5, "%s: %s has %d sets!\n", v6, a1, v4);
            *__error() = 79;
            return -1;
          }
        }
        else
        {
          fclose(*v18);
          free(v18);
          unsigned int v10 = _OSSwapInt32(*(unsigned int *)&__s1[8]);
          if (_OSSwapInt32(v10) == 1)
          {
            fprintf(__stderrp, "%s: %s is the wrong byte ordering.\n", _errowner, a1);
          }
          else
          {
            int v8 = __stderrp;
            unsigned int v9 = _errowner;
            int v7 = _OSSwapInt32(*(unsigned int *)&__s1[8]);
            fprintf(v8, "%s: %s is version %d, we need %d.\n", v9, a1, v7, 1);
          }
          *__error() = 79;
          return -1;
        }
      }
      else
      {
        fclose(*v18);
        fprintf(__stderrp, "%s: corrupt file.", _errowner);
        free(v18);
        *__error() = 79;
        return -1;
      }
    }
    else
    {
      int v13 = *__error();
      close_NOCANCEL();
      free(v18);
      *__error() = v13;
      return -1;
    }
  }
}

char *__cdecl catgets(nl_catd a1, int a2, int a3, const char *a4)
{
  if (!a1 || a1 == (nl_catd)-1) {
    return (char *)a4;
  }
  int v4 = MCGetSet((uint64_t)a1, a2);
  int v7 = MCGetMsg((uint64_t)v4, a3);
  if (v7) {
    return *(char **)(v7 + 1);
  }
  else {
    return (char *)a4;
  }
}

unsigned int *MCGetMsg(uint64_t a1, int a2)
{
  if (!a1 || *(_DWORD *)(a1 + 36) || a2 <= 0) {
    return 0;
  }
  signed int v6 = 0;
  if (a2 - 1 >= _OSSwapInt32(*(_DWORD *)(a1 + 32)))
  {
    signed int v5 = _OSSwapInt32(*(_DWORD *)(a1 + 32));
    int v4 = v5 / 2;
  }
  else
  {
    int v4 = a2 - 1;
    signed int v5 = a2;
  }
  while (1)
  {
    int v7 = (unsigned int *)(*(void *)(a1 + 12) + 16 * v4);
    if (_OSSwapInt32(*v7) == a2) {
      return v7;
    }
    if (_OSSwapInt32(*v7) >= a2)
    {
      signed int v5 = v4;
      int v3 = -1;
    }
    else
    {
      signed int v6 = v4 + 1;
      if (v5 > v4 + a2 - _OSSwapInt32(*v7) + 1) {
        signed int v5 = v4 + a2 - _OSSwapInt32(*v7) + 1;
      }
      int v3 = 1;
    }
    if (v6 >= v5) {
      break;
    }
    if (v5 - v6 == 1) {
      v4 += v3;
    }
    else {
      v4 += (v5 - v6) / 2 * v3;
    }
  }
  return 0;
}

unsigned int *MCGetSet(uint64_t a1, int a2)
{
  if (!a1 || a2 <= 0) {
    return 0;
  }
  signed int v6 = 0;
  if (a2 - 1 >= *(_DWORD *)(a1 + 8))
  {
    signed int v5 = *(_DWORD *)(a1 + 8);
    int v4 = v5 / 2;
  }
  else
  {
    int v4 = a2 - 1;
    signed int v5 = a2;
  }
  while (1)
  {
    int v7 = (unsigned int *)(*(void *)(a1 + 16) + 40 * v4);
    if (_OSSwapInt32(*v7) == a2) {
      break;
    }
    if (_OSSwapInt32(*v7) >= a2)
    {
      signed int v5 = v4;
      int v3 = -1;
    }
    else
    {
      signed int v6 = v4 + 1;
      if (v5 > v4 + a2 - _OSSwapInt32(*v7) + 1) {
        signed int v5 = v4 + a2 - _OSSwapInt32(*v7) + 1;
      }
      int v3 = 1;
    }
    if (v6 >= v5) {
      return 0;
    }
    if (v5 - v6 == 1) {
      v4 += v3;
    }
    else {
      v4 += (v5 - v6) / 2 * v3;
    }
  }
  if (v7[9] && (int)loadSet((FILE **)a1, (uint64_t)v7) <= 0) {
    return 0;
  }
  else {
    return v7;
  }
}

int catclose(nl_catd a1)
{
  if (a1 && a1 != (nl_catd)-1)
  {
    fclose((FILE *)a1->__data);
    __nls_free_resources((uint64_t)a1, a1->__size);
    free(a1);
    return 0;
  }
  else
  {
    *__error() = 9;
    return -1;
  }
}

void __nls_free_resources(uint64_t a1, int a2)
{
  for (int i = 0; i < a2; ++i)
  {
    uint64_t v3 = *(void *)(a1 + 16) + 40 * i;
    if (!*(_DWORD *)(v3 + 36))
    {
      free(*(void **)(v3 + 20));
      free(*(void **)(v3 + 12));
    }
  }
  free(*(void **)(a1 + 16));
}

uint64_t loadSet(FILE **a1, uint64_t a2)
{
  int v11 = *a1;
  off_t v10 = _OSSwapInt64(*(void *)(a2 + 20));
  if (fseeko(v11, v10, 0) == -1)
  {
    return 0;
  }
  else
  {
    _OSSwapInt32(*(_DWORD *)(a2 + 28));
    uint64_t v2 = malloc_type_malloc();
    *(void *)(a2 + 20) = v2;
    if (v2)
    {
      unsigned int v9 = *(void **)(a2 + 20);
      unsigned int v8 = _OSSwapInt32(*(_DWORD *)(a2 + 28));
      if (fread(v9, v8, 1uLL, *a1) != 1
        || (__streasigned int m = *a1, __offseta = _OSSwapInt64(*(void *)(a2 + 12)), fseeko(__stream, __offseta, 0) == -1))
      {
        int v12 = *__error();
        free(*(void **)(a2 + 20));
        *__error() = v12;
        return 0;
      }
      else
      {
        _OSSwapInt32(*(_DWORD *)(a2 + 32));
        uint64_t v3 = malloc_type_malloc();
        *(void *)(a2 + 12) = v3;
        if (v3)
        {
          for (unsigned int i = 0; i < _OSSwapInt32(*(_DWORD *)(a2 + 32)); ++i)
          {
            uint64_t v16 = *(void *)(a2 + 12) + 16 * (int)i;
            if (fread((void *)v16, 0x10uLL, 1uLL, *a1) != 1)
            {
              int v14 = *__error();
              free(*(void **)(a2 + 12));
              free(*(void **)(a2 + 20));
              *__error() = v14;
              return 0;
            }
            if (*(_DWORD *)(v16 + 12))
            {
              --i;
            }
            else
            {
              uint64_t v5 = *(void *)(a2 + 20);
              *(void *)(v16 + 4) = v5 + _OSSwapInt64(*(void *)(v16 + 4));
            }
          }
          *(_DWORD *)(a2 + 36) = 0;
          return 1;
        }
        else
        {
          int v13 = *__error();
          free(*(void **)(a2 + 20));
          *__error() = v13;
          return -1;
        }
      }
    }
    else
    {
      return -1;
    }
  }
}

unint64_t _OSSwapInt64(unint64_t a1)
{
  return bswap64(a1);
}

void flockfile(FILE *a1)
{
  int v1 = *__error();
  pthread_mutex_lock((pthread_mutex_t *)((char *)a1->_extra + 8));
  *__error() = v1;
}

void _flockfile_debug_stub(FILE *a1)
{
}

int ftrylockfile(FILE *a1)
{
  int v3 = 0;
  int v2 = *__error();
  if (pthread_mutex_trylock((pthread_mutex_t *)((char *)a1->_extra + 8))) {
    int v3 = -1;
  }
  *__error() = v2;
  return v3;
}

void funlockfile(FILE *a1)
{
  int v1 = *__error();
  pthread_mutex_unlock((pthread_mutex_t *)((char *)a1->_extra + 8));
  *__error() = v1;
}

int asprintf(char **a1, const char *a2, ...)
{
  va_start(va, a2);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return vasprintf_l(a1, v7, a2, va);
  }
  else {
    return vasprintf_l(a1, (locale_t)&__global_locale, a2, va);
  }
}

int asprintf_l(char **a1, locale_t a2, const char *a3, ...)
{
  va_start(va, a3);
  return vasprintf_l(a1, a2, a3, va);
}

void clearerr(FILE *a1)
{
  a1->_flags &= 0xFF9Fu;
  funlockfile(a1);
}

uint64_t clearerr_unlocked(uint64_t result)
{
  *(_WORD *)(result + 16) &= 0xFF9Fu;
  return result;
}

int dprintf(int a1, const char *a2, ...)
{
  va_start(va, a2);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return vdprintf_l(a1, v7, a2, va);
  }
  else {
    return vdprintf_l(a1, (locale_t)__global_locale, a2, va);
  }
}

int dprintf_l(int a1, locale_t a2, const char *a3, ...)
{
  va_start(va, a3);
  return vdprintf_l(a1, a2, a3, va);
}

int fclose(FILE *a1)
{
  int v2 = 0;
  libc_hooks_will_write((uint64_t)a1, 152);
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  if (a1)
  {
    if (a1->_flags)
    {
      flockfile(a1);
      int v3 = __sflush((uint64_t)a1);
      if (v3 < 0) {
        int v2 = *__error();
      }
      if (a1->_close && ((int (*)(void *))a1->_close)(a1->_cookie) < 0)
      {
        int v3 = -1;
        int v2 = *__error();
      }
      if ((a1->_flags & 0x80u) != 0) {
        free(a1->_bf._base);
      }
      if (a1->_ub._base)
      {
        if (a1->_ub._base != a1->_ubuf) {
          free(a1->_ub._base);
        }
        a1->_ub._base = 0;
      }
      if (a1->_lb._base)
      {
        free(a1->_lb._base);
        a1->_lb._base = 0;
      }
      a1->_file = -1;
      a1->_w = 0;
      a1->_r = 0;
      funlockfile(a1);
      __sfprelease((uint64_t)a1);
      if (v2) {
        *__error() = v2;
      }
      return v3;
    }
    else
    {
      *__error() = 9;
      return -1;
    }
  }
  else
  {
    *__error() = 14;
    return -1;
  }
}

uint64_t libc_hooks_will_write(uint64_t result, uint64_t a2)
{
  int v2 = 0;
  if (off_F5438) {
    int v2 = off_F5438;
  }
  if (v2) {
    return off_F5438(result, a2);
  }
  return result;
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  int v8 = a1;
  int v7 = (char *)a2;
  signed int v6 = 0;
  int v5 = 0;
  int v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a2);
  if (v8 < 0x8000)
  {
    int v5 = __sflags(v7, &v4);
    if (v5)
    {
      int v3 = fcntl_NOCANCEL();
      if (v3 >= 0)
      {
        if ((v3 & 3) == 2 || (v3 & 3) == (v4 & 3))
        {
          signed int v6 = (FILE *)__sfp(1);
          if (v6)
          {
            v6->_flags = v5;
            if ((v4 & 8) != 0 && (v3 & 8) == 0) {
              v6->_flags |= 0x100u;
            }
            v6->_file = v8;
            v6->_cookie = v6;
            v6->_read = (int (__cdecl *)(void *, char *, int))__sread;
            v6->_write = (int (__cdecl *)(void *, const char *, int))__swrite;
            v6->_seeint k = (fpos_t (__cdecl *)(void *, fpos_t, int))__sseek;
            v6->_close = (int (__cdecl *)(void *))__sclose;
            return v6;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          *__error() = 22;
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 24;
    return 0;
  }
}

int feof(FILE *a1)
{
  flockfile(a1);
  BOOL v2 = (a1->_flags & 0x20) != 0;
  funlockfile(a1);
  return v2;
}

BOOL feof_unlocked(uint64_t a1)
{
  return (*(_WORD *)(a1 + 16) & 0x20) != 0;
}

int ferror(FILE *a1)
{
  flockfile(a1);
  BOOL v2 = (a1->_flags & 0x40) != 0;
  funlockfile(a1);
  return v2;
}

BOOL ferror_unlocked(uint64_t a1)
{
  return (*(_WORD *)(a1 + 16) & 0x40) != 0;
}

int fflush(FILE *a1)
{
  if (!a1) {
    return _fwalk((uint64_t (*)(uint64_t *))sflush_locked);
  }
  libc_hooks_will_write((uint64_t)a1, 152);
  flockfile(a1);
  int v2 = __sflush((uint64_t)a1);
  funlockfile(a1);
  return v2;
}

uint64_t sflush_locked(FILE *a1)
{
  flockfile(a1);
  unsigned int v2 = __sflush((uint64_t)a1);
  funlockfile(a1);
  return v2;
}

uint64_t __sflush(uint64_t a1)
{
  __int16 __len_4 = *(_WORD *)(a1 + 16);
  uint64_t __src = *(char **)(a1 + 24);
  if (!__src) {
    return 0;
  }
  if ((__len_4 & 4) != 0)
  {
    if (!*(void *)(a1 + 72)) {
      return 0;
    }
    __lesigned int n = *(_DWORD *)(a1 + 8);
    if (__len > 0)
    {
      if (_sseek(a1, -__len, 1u) == -1)
      {
        if (*__error() == 29) {
          return 0;
        }
        else {
          return -1;
        }
      }
      if (*(void *)(a1 + 88))
      {
        if (*(void *)(a1 + 88) != a1 + 116) {
          free(*(void **)(a1 + 88));
        }
        *(void *)(a1 + 88) = 0;
      }
      *(void *)a1 = *(void *)(a1 + 24);
      *(_DWORD *)(a1 + 8) = 0;
      *(_WORD *)(a1 + 16) &= ~0x20u;
      memset((void *)(*(void *)(a1 + 104) + 80), 0, 0x80uLL);
    }
    return 0;
  }
  if ((__len_4 & 8) != 0)
  {
    signed int __lena = *(void *)a1 - __src;
    *(void *)a1 = __src;
    if ((__len_4 & 3) != 0) {
      int v2 = 0;
    }
    else {
      int v2 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 12) = v2;
    while (__lena > 0)
    {
      int v3 = _swrite(a1, (uint64_t)__src, __lena);
      if (v3 <= 0)
      {
        if ((unint64_t)__src > *(void *)a1) {
          memmove(*(void **)a1, __src, __lena);
        }
        *(void *)a1 += __lena;
        if ((*(_WORD *)(a1 + 16) & 2) == 0) {
          *(_DWORD *)(a1 + 12) -= __lena;
        }
        *(_WORD *)(a1 + 16) |= 0x40u;
        return -1;
      }
      __lena -= v3;
      __src += v3;
    }
  }
  return 0;
}

uint64_t __fflush(uint64_t a1)
{
  if (a1)
  {
    if ((*(_WORD *)(a1 + 16) & 0x18) != 0) {
      return __sflush(a1);
    }
    else {
      return 0;
    }
  }
  else
  {
    return _fwalk((uint64_t (*)(uint64_t *))sflush_locked);
  }
}

int fgetc(FILE *a1)
{
  flockfile(a1);
  int v1 = a1->_r - 1;
  a1->_r = v1;
  if (v1 >= 0)
  {
    int v2 = a1->_p++;
    int v4 = *v2;
  }
  else
  {
    int v4 = __srget(a1);
  }
  funlockfile(a1);
  return v4;
}

uint64_t __slbexpand(uint64_t a1, unint64_t a2)
{
  int v4 = a2;
  if (*(int *)(a1 + 128) < a2)
  {
    if (a2 <= 0x7FFFFFFF)
    {
      uint64_t v3 = malloc_type_realloc();
      if (v3)
      {
        *(void *)(a1 + 120) = v3;
        *(_DWORD *)(a1 + 128) = v4;
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      *__error() = 12;
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

char *__cdecl fgetln(FILE *a1, size_t *a2)
{
  flockfile(a1);
  if (!((char)(32 * *((unsigned char *)a1->_extra + 72)) >> 5)) {
    *((unsigned char *)a1->_extra + 72) = *((unsigned char *)a1->_extra + 72) & 0xF8 | 7;
  }
  if (a1->_r <= 0 && __srefill((uint64_t)a1))
  {
    *a2 = 0;
    funlockfile(a1);
    return 0;
  }
  else
  {
    int v8 = (char *)memchr(a1->_p, 10, a1->_r);
    if (v8)
    {
      unsigned int v9 = (unsigned __int8 *)(v8 + 1);
      p = a1->_p;
      size_t v6 = v9 - a1->_p;
      *a2 = v6;
      a1->_flags |= 0x2000u;
      a1->_r -= v6;
      a1->_p = v9;
      funlockfile(a1);
      return (char *)p;
    }
    else
    {
      size_t r = a1->_r;
      size_t v5 = 0;
      while (!__slbexpand((uint64_t)a1, r + 80))
      {
        memcpy(&a1->_lb._base[v5], a1->_p, r - v5);
        size_t v5 = r;
        if (__srefill((uint64_t)a1)) {
          goto LABEL_15;
        }
        off_t v10 = (char *)memchr(a1->_p, 10, a1->_r);
        if (v10)
        {
          int v11 = (unsigned __int8 *)(v10 + 1);
          __signed int n = v11 - a1->_p;
          r += __n;
          if (!__slbexpand((uint64_t)a1, r))
          {
            memcpy(&a1->_lb._base[v5], a1->_p, __n);
            a1->_r -= __n;
            a1->_p = v11;
LABEL_15:
            *a2 = r;
            funlockfile(a1);
            return (char *)a1->_lb._base;
          }
          break;
        }
        r += a1->_r;
      }
      *a2 = 0;
      a1->_flags |= 0x40u;
      funlockfile(a1);
      return 0;
    }
  }
}

int fgetpos(FILE *a1, fpos_t *a2)
{
  off_t v2 = ftello(a1);
  *a2 = v2;
  if (v2 == -1) {
    return -1;
  }
  else {
    return 0;
  }
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  if (a2 <= 0) {
    return 0;
  }
  libc_hooks_will_write((uint64_t)a1, a2);
  libc_hooks_will_write((uint64_t)a3, 152);
  flockfile(a3);
  if (!((char)(32 * *((unsigned char *)a3->_extra + 72)) >> 5)) {
    *((unsigned char *)a3->_extra + 72) = *((unsigned char *)a3->_extra + 72) & 0xF8 | 7;
  }
  mbstate_t __dst = a1;
  for (int i = a2 - 1; i; i -= __n)
  {
    __signed int n = a3->_r;
    if (!a3->_r)
    {
      if (__srefill((uint64_t)a3))
      {
        if (__dst == a1)
        {
          funlockfile(a3);
          return 0;
        }
        break;
      }
      __signed int n = a3->_r;
    }
    __s = a3->_p;
    if (__n > i) {
      __signed int n = i;
    }
    int v4 = (char *)memchr(__s, 10, __n);
    if (v4)
    {
      size_t v5 = (unsigned __int8 *)(v4 + 1);
      a3->_r -= v5 - __s;
      a3->_p = v5;
      memcpy(__dst, __s, v5 - __s);
      __dst[v5 - __s] = 0;
      funlockfile(a3);
      return a1;
    }
    a3->_r -= __n;
    a3->_p += __n;
    memcpy(__dst, __s, __n);
    __dst += __n;
  }
  char *__dst = 0;
  funlockfile(a3);
  return a1;
}

wint_t fgetwc(FILE *a1)
{
  flockfile(a1);
  if ((char)(32 * *((unsigned char *)a1->_extra + 72)) >> 5)
  {
    char v1 = 0;
  }
  else
  {
    *((unsigned char *)a1->_extra + 72) = *((unsigned char *)a1->_extra + 72) & 0xF8 | 1;
    char v1 = 1;
  }
  if (v1)
  {
    size_t v6 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v7 = __locale_key;
    size_t v6 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6) {
    wint_t v2 = __fgetwc((uint64_t)a1, (uint64_t)v6);
  }
  else {
    wint_t v2 = __fgetwc((uint64_t)a1, (uint64_t)__global_locale);
  }
  wint_t v4 = v2;
  funlockfile(a1);
  return v4;
}

uint64_t __fgetwc(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a1;
  uint64_t v9 = a2;
  unsigned int v8 = 0;
  uint64_t v6 = *(void *)(a2 + 1328);
  size_t v5 = *(uint64_t (**)(unsigned int *, void, void, uint64_t, uint64_t))(v6 + 72);
  if (*(int *)(a1 + 8) <= 0 && __srefill(v10))
  {
    return -1;
  }
  else if (*(_DWORD *)(v6 + 64) == 1)
  {
    wint_t v2 = (unsigned __int8 *)(*(void *)v10)++;
    unsigned int v8 = *v2;
    --*(_DWORD *)(v10 + 8);
    return v8;
  }
  else
  {
    while (1)
    {
      uint64_t v7 = v5(&v8, *(void *)v10, *(int *)(v10 + 8), *(void *)(v10 + 104) + 80, v9);
      if (v7 == -1)
      {
LABEL_13:
        *(_WORD *)(v10 + 16) |= 0x40u;
        *__error() = 92;
        return -1;
      }
      if (v7 != -2) {
        break;
      }
      if (__srefill(v10) != 0) {
        goto LABEL_13;
      }
    }
    if (v7)
    {
      *(void *)v10 += v7;
      *(_DWORD *)(v10 + 8) -= v7;
      return v8;
    }
    else
    {
      ++*(void *)v10;
      --*(_DWORD *)(v10 + 8);
      return 0;
    }
  }
}

wint_t fgetwc_l(FILE *a1, locale_t a2)
{
  locale_t v4 = a2;
  if (a2)
  {
    if (a2 == (locale_t)-1) {
      locale_t v4 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v4 = (locale_t)&__c_locale;
  }
  flockfile(a1);
  if (!((char)(32 * *((unsigned char *)a1->_extra + 72)) >> 5)) {
    *((unsigned char *)a1->_extra + 72) = *((unsigned char *)a1->_extra + 72) & 0xF8 | 1;
  }
  wint_t v3 = __fgetwc((uint64_t)a1, (uint64_t)v4);
  funlockfile(a1);
  return v3;
}

__int32 *__cdecl fgetwln_l(FILE *a1, size_t *a2, locale_t a3)
{
  flockfile(a1);
  if (!((char)(32 * *((unsigned char *)a1->_extra + 72)) >> 5)) {
    *((unsigned char *)a1->_extra + 72) = *((unsigned char *)a1->_extra + 72) & 0xF8 | 1;
  }
  size_t v5 = 0;
  do
  {
    int v6 = __fgetwc((uint64_t)a1, (uint64_t)a3);
    if (v6 == -1) {
      break;
    }
    if (a1->_lb._size <= 4 * v5 && __slbexpand((uint64_t)a1, 4 * (v5 + 512))) {
      goto LABEL_10;
    }
    size_t v3 = v5++;
    *(_DWORD *)&a1->_lb._base[4 * v3] = v6;
  }
  while (v6 != 10);
  if (v5)
  {
    funlockfile(a1);
    *a2 = v5;
    return (__int32 *)a1->_lb._base;
  }
LABEL_10:
  funlockfile(a1);
  *a2 = 0;
  return 0;
}

__int32 *__cdecl fgetwln(FILE *a1, size_t *a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    uint64_t v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return fgetwln_l(a1, a2, v7);
  }
  else {
    return fgetwln_l(a1, a2, (locale_t)__global_locale);
  }
}

__int32 *__cdecl fgetws_l(__int32 *a1, int a2, FILE *a3, locale_t a4)
{
  uint64_t v17 = a1;
  int v16 = a2;
  off_t v15 = a3;
  locale_t v14 = a4;
  int v13 = 0;
  uint64_t v12 = 0;
  p = 0;
  if (a4)
  {
    if (v14 == (locale_t)-1) {
      locale_t v14 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v14 = (locale_t)&__c_locale;
  }
  uint64_t v9 = *((void *)v14 + 166);
  uint64_t v8 = *(uint64_t (**)(__int32 *, unsigned __int8 **, unint64_t, void, char *, locale_t))(v9 + 88);
  flockfile(v15);
  if (!((char)(32 * *((unsigned char *)v15->_extra + 72)) >> 5)) {
    *((unsigned char *)v15->_extra + 72) = *((unsigned char *)v15->_extra + 72) & 0xF8 | 1;
  }
  if (v16 > 0)
  {
    if (v15->_r > 0 || !__srefill((uint64_t)v15))
    {
      int v13 = v17;
      while (1)
      {
        p = v15->_p;
        uint64_t v10 = memchr(v15->_p, 10, v15->_r);
        unint64_t v7 = v10 ? v10 - v15->_p + 1 : v15->_r;
        uint64_t v12 = v8(v13, &p, v7, v16 - 1, (char *)v15->_extra + 80, v14);
        if (v12 == -1) {
          break;
        }
        if (!p)
        {
          ++v12;
          p = (unsigned __int8 *)memchr(v15->_p, 0, v15->_r) + 1;
        }
        v15->_r -= p - LODWORD(v15->_p);
        v15->_p = p;
        v16 -= v12;
        v13 += v12;
        BOOL v6 = 0;
        if (*(v13 - 1) != 10)
        {
          BOOL v6 = 0;
          if (v16 > 1)
          {
            BOOL v5 = 1;
            if (v15->_r <= 0) {
              BOOL v5 = __srefill((uint64_t)v15) == 0;
            }
            BOOL v6 = v5;
          }
        }
        if (!v6)
        {
          if (v13 != v17 && (*(unsigned int (**)(char *, locale_t))(v9 + 80))((char *)v15->_extra + 80, v14))
          {
            *int v13 = 0;
            funlockfile(v15);
            return v17;
          }
          break;
        }
      }
    }
  }
  else
  {
    *__error() = 22;
  }
  funlockfile(v15);
  return 0;
}

__int32 *__cdecl fgetws(__int32 *a1, int a2, FILE *a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    uint64_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    uint64_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return fgetws_l(a1, a2, a3, v9);
  }
  else {
    return fgetws_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

int fileno(FILE *a1)
{
  flockfile(a1);
  int file = a1->_file;
  funlockfile(a1);
  return file;
}

uint64_t fileno_unlocked(uint64_t a1)
{
  return *(__int16 *)(a1 + 18);
}

uint64_t *__sfp(int a1)
{
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  if (a1)
  {
    uint64_t v3 = atomic_fetch_add_explicit((atomic_ullong *volatile)&__scounted, 1uLL, memory_order_relaxed) + 1;
    if (v3 > sysconf(26))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)&__scounted, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
      *__error() = 24;
      return 0;
    }
    if (v3 < 0)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)&__scounted, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
      *__error() = 84;
      return 0;
    }
  }
  pthread_mutex_lock(&filelist_lock);
  for (int i = &__sglue; i; int i = (uint64_t **)*i)
  {
    unint64_t v7 = i[2];
    int v6 = *((_DWORD *)i + 2);
    while (--v6 >= 0)
    {
      if (!*((_WORD *)v7 + 8)) {
        goto LABEL_18;
      }
      v7 += 19;
    }
  }
  pthread_mutex_unlock(&filelist_lock);
  BOOL v5 = (uint64_t *)moreglue(10);
  if (v5)
  {
    pthread_mutex_lock(&filelist_lock);
    *lastglue = (uint64_t)v5;
    lastglue = v5;
    unint64_t v7 = (uint64_t *)v5[2];
LABEL_18:
    *((_WORD *)v7 + 8) = 1;
    pthread_mutex_unlock(&filelist_lock);
    *unint64_t v7 = 0;
    *((_DWORD *)v7 + 3) = 0;
    *((_DWORD *)v7 + 2) = 0;
    double v7[3] = 0;
    *((_DWORD *)v7 + 8) = 0;
    *((_DWORD *)v7 + 10) = 0;
    *((_WORD *)v7 + 9) = -1;
    v7[11] = 0;
    *((_DWORD *)v7 + 24) = 0;
    v7[15] = 0;
    *((_DWORD *)v7 + 32) = 0;
    *(void *)v7[13] = 0;
    mbstate_t __dst = (void *)(v7[13] + 8);
    memset(__b, 0, sizeof(__b));
    __b[0] = 850045858;
    memcpy(__dst, __b, 0x40uLL);
    *(unsigned char *)(v7[13] + 72) &= 0xF8u;
    memset((void *)(v7[13] + 80), 0, 0x80uLL);
    *(unsigned char *)(v7[13] + 72) &= ~8u;
    *(unsigned char *)(v7[13] + 72) = *(unsigned char *)(v7[13] + 72) & 0xF7 | (8 * (a1 != 0));
    return v7;
  }
  else
  {
    if (a1) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)&__scounted, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    }
    return 0;
  }
}

void *__sinit()
{
  __cleanup = 1;
  __scounted = 3;
  for (int i = 0; i < 17; ++i)
  {
    *((void *)&usual + 19 * i + 13) = (char *)&usual_extra + 208 * i;
    **((void **)&usual + 19 * i + 13) = 0;
    mbstate_t __dst = (void *)(*((void *)&usual + 19 * i + 13) + 8);
    memset(__b, 0, sizeof(__b));
    __b[0] = 850045858;
    memcpy(__dst, __b, 0x40uLL);
    uint64_t v0 = *((void *)&usual + 19 * i + 13);
    *(unsigned char *)(v0 + 72) &= 0xF8u;
    uint64_t result = memset((void *)(*((void *)&usual + 19 * i + 13) + 80), 0, 0x80uLL);
    uint64_t v2 = *((void *)&usual + 19 * i + 13);
    *(unsigned char *)(v2 + 72) &= ~8u;
  }
  return result;
}

uint64_t moreglue(int a1)
{
  uint64_t v6 = malloc_type_malloc();
  if (!v6) {
    return 0;
  }
  if ((v6 + 24) % 8uLL) {
    unint64_t v3 = v6 + 24 + 8 - (v6 + 24) % 8uLL;
  }
  else {
    unint64_t v3 = v6 + 24;
  }
  stat __b = (void *)v3;
  unint64_t v4 = v3 + 152 * a1;
  *(void *)uint64_t v6 = 0;
  *(_DWORD *)(v6 + 8) = a1;
  *(void *)(v6 + 16) = v3;
  while (--a1 >= 0)
  {
    memset(__b, 0, 0x98uLL);
    void __b[13] = v4;
    *(void *)void __b[13] = 0;
    mbstate_t __dst = (void *)(__b[13] + 8);
    memset(v9, 0, sizeof(v9));
    v9[0] = 850045858;
    memcpy(__dst, v9, 0x40uLL);
    *(unsigned char *)(__b[13] + 72) &= 0xF8u;
    memset((void *)(__b[13] + 80), 0, 0x80uLL);
    *(unsigned char *)(__b[13] + 72) &= ~8u;
    __b += 19;
    v4 += 208;
  }
  return v6;
}

uint64_t __sfprelease(uint64_t a1)
{
  if ((*(unsigned char *)(*(void *)(a1 + 104) + 72) & 8) != 0)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)&__scounted, 0xFFFFFFFFFFFFFFFFLL, memory_order_relaxed);
    *(unsigned char *)(*(void *)(a1 + 104) + 72) &= ~8u;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(*(void *)(a1 + 104) + 8));
  pthread_mutex_lock(&filelist_lock);
  *(_WORD *)(a1 + 16) = 0;
  return pthread_mutex_unlock(&filelist_lock);
}

uint64_t f_prealloc()
{
  uint64_t result = getdtablesize();
  int v2 = result;
  for (int i = &__sglue; ; int i = (uint64_t **)*i)
  {
    v2 -= *((_DWORD *)i + 2);
    BOOL v1 = 0;
    if (v2 > 0) {
      BOOL v1 = *i != 0;
    }
    if (!v1) {
      break;
    }
  }
  if (v2 > 0)
  {
    uint64_t result = moreglue(v2);
    unint64_t v4 = (uint64_t *)result;
    if (result)
    {
      pthread_mutex_lock(&filelist_lock);
      *lastglue = (uint64_t)v4;
      lastglue = v4;
      return pthread_mutex_unlock(&filelist_lock);
    }
  }
  return result;
}

uint64_t _cleanup()
{
  return _fwalk((uint64_t (*)(uint64_t *))__sflush);
}

uint64_t __sflags(char *a1, int *a2)
{
  unint64_t v7 = a1 + 1;
  int v3 = *a1;
  switch(v3)
  {
    case 'a':
      unsigned int v6 = 8;
      int v5 = 1;
      int v4 = 520;
      break;
    case 'r':
      unsigned int v6 = 4;
      int v5 = 0;
      int v4 = 0;
      break;
    case 'w':
      unsigned int v6 = 8;
      int v5 = 1;
      int v4 = 1536;
      break;
    default:
      *__error() = 22;
      return 0;
  }
  if (*v7 == 98) {
    unint64_t v7 = a1 + 2;
  }
  if (*v7 == 43)
  {
    unsigned int v6 = 16;
    int v5 = 2;
    if (*++v7 == 98) {
      ++v7;
    }
  }
  if (*v7 == 120) {
    v4 |= 0x800u;
  }
  *a2 = v5 | v4;
  return v6;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  uint64_t v8 = __filename;
  unint64_t v7 = (char *)__mode;
  unsigned int v6 = 0;
  int v5 = 0;
  int v4 = 0;
  int v3 = 0;
  libc_hooks_will_read_cstring((uint64_t)__filename);
  libc_hooks_will_read_cstring((uint64_t)v7);
  int v4 = __sflags(v7, &v3);
  if (!v4) {
    return 0;
  }
  unsigned int v6 = (FILE *)__sfp(1);
  if (!v6) {
    return 0;
  }
  int v5 = open_NOCANCEL();
  if (v5 >= 0)
  {
    if (v5 < 0x8000)
    {
      v6->_int file = v5;
      v6->_flags = v4;
      v6->_cookie = v6;
      v6->_read = (int (__cdecl *)(void *, char *, int))__sread;
      v6->_write = (int (__cdecl *)(void *, const char *, int))__swrite;
      v6->_seeint k = (fpos_t (__cdecl *)(void *, fpos_t, int))__sseek;
      v6->_close = (int (__cdecl *)(void *))__sclose;
      if ((v3 & 8) != 0) {
        _sseek((uint64_t)v6, 0, 2u);
      }
      return v6;
    }
    else
    {
      v6->_flags = 0;
      close_NOCANCEL();
      *__error() = 24;
      return 0;
    }
  }
  else
  {
    __sfprelease((uint64_t)v6);
    return 0;
  }
}

int fprintf(FILE *a1, const char *a2, ...)
{
  va_start(va, a2);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    unint64_t v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    unint64_t v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return vfprintf_l(a1, v7, a2, va);
  }
  else {
    return vfprintf_l(a1, (locale_t)&__global_locale, a2, va);
  }
}

int fprintf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  va_start(va, a3);
  return vfprintf_l(a1, a2, a3, va);
}

int fpurge(FILE *a1)
{
  flockfile(a1);
  if (a1->_flags)
  {
    if (a1->_ub._base)
    {
      if (a1->_ub._base != a1->_ubuf) {
        free(a1->_ub._base);
      }
      a1->_ub._base = 0;
    }
    a1->_p = a1->_bf._base;
    a1->_size_t r = 0;
    if ((a1->_flags & 3) != 0) {
      int size = 0;
    }
    else {
      int size = a1->_bf._size;
    }
    a1->_w = size;
    int v3 = 0;
  }
  else
  {
    *__error() = 9;
    int v3 = -1;
  }
  funlockfile(a1);
  return v3;
}

int fputc(int a1, FILE *a2)
{
  flockfile(a2);
  int v2 = a2->_w - 1;
  a2->_w = v2;
  if (v2 < 0 && (a2->_w < a2->_lbfsize || (char)a1 == 10))
  {
    int v7 = __swbuf(a1, a2);
  }
  else
  {
    int v3 = a2->_p++;
    *int v3 = a1;
    int v7 = a1;
  }
  funlockfile(a2);
  return v7;
}

int fputs(const char *a1, FILE *a2)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  int v7 = 0;
  int v5 = 0;
  uint64_t v6 = 0;
  int v3 = 0;
  uint64_t v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a1);
  libc_hooks_will_write((uint64_t)v8, 152);
  if (!v9) {
    uint64_t v9 = "(null)";
  }
  int v3 = v9;
  HIDWORD(v6) = strlen(v9);
  uint64_t v4 = SHIDWORD(v6);
  int v5 = &v3;
  LODWORD(v6) = 1;
  flockfile(v8);
  if (!((char)(32 * *((unsigned char *)v8->_extra + 72)) >> 5)) {
    *((unsigned char *)v8->_extra + 72) = *((unsigned char *)v8->_extra + 72) & 0xF8 | 7;
  }
  int v7 = __sfvwrite((uint64_t)v8, &v5);
  funlockfile(v8);
  if (v7) {
    return v7;
  }
  else {
    return v4;
  }
}

uint64_t __fputwc(int a1, FILE *a2, uint64_t a3)
{
  int v12 = a1;
  int v11 = a2;
  uint64_t v10 = a3;
  if (*(_DWORD *)(*(void *)(a3 + 1328) + 64) == 1 && v12 > 0 && v12 <= 255)
  {
    v9[0] = v12;
    unint64_t v7 = 1;
  }
  else
  {
    unint64_t v7 = (*(uint64_t (**)(unsigned char *, void, uint64_t, uint64_t))(*(void *)(v10 + 1328) + 96))(v9, v12, (uint64_t)v11->_extra + 80, v10);
    if (v7 == -1)
    {
      v11->_flags |= 0x40u;
      return -1;
    }
  }
  for (unint64_t i = 0; i < v7; ++i)
  {
    int v15 = v9[i];
    locale_t v14 = v11;
    int v3 = v11->_w - 1;
    v11->_w = v3;
    if (v3 < 0 && (v14->_w < v14->_lbfsize || (char)v15 == 10))
    {
      int v16 = __swbuf(v15, v14);
    }
    else
    {
      unsigned __int8 v4 = v15;
      int v5 = v14->_p++;
      *int v5 = v4;
      int v16 = v4;
    }
    if (v16 == -1) {
      return -1;
    }
  }
  return v12;
}

wint_t fputwc(__int32 a1, FILE *a2)
{
  flockfile(a2);
  if ((char)(32 * *((unsigned char *)a2->_extra + 72)) >> 5)
  {
    char v2 = 0;
  }
  else
  {
    *((unsigned char *)a2->_extra + 72) = *((unsigned char *)a2->_extra + 72) & 0xF8 | 1;
    char v2 = 1;
  }
  if (v2)
  {
    uint64_t v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    uint64_t v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    wint_t v3 = __fputwc(a1, a2, (uint64_t)v8);
  }
  else {
    wint_t v3 = __fputwc(a1, a2, (uint64_t)__global_locale);
  }
  wint_t v5 = v3;
  funlockfile(a2);
  return v5;
}

wint_t fputwc_l(__int32 a1, FILE *a2, locale_t a3)
{
  locale_t v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      locale_t v5 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v5 = (locale_t)&__c_locale;
  }
  flockfile(a2);
  if (!((char)(32 * *((unsigned char *)a2->_extra + 72)) >> 5)) {
    *((unsigned char *)a2->_extra + 72) = *((unsigned char *)a2->_extra + 72) & 0xF8 | 1;
  }
  wint_t v4 = __fputwc(a1, a2, (uint64_t)v5);
  funlockfile(a2);
  return v4;
}

int fputws_l(const __int32 *a1, FILE *a2, locale_t a3)
{
  locale_t v14 = a1;
  int v13 = a2;
  locale_t v12 = a3;
  uint64_t v11 = 0;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  unint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v6 = a1;
  if (a3)
  {
    if (v12 == (locale_t)-1) {
      locale_t v12 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v12 = (locale_t)&__c_locale;
  }
  locale_t v5 = *(uint64_t (**)(unsigned char *, const __int32 **, uint64_t, uint64_t, char *, locale_t))(*((void *)v12 + 166)
                                                                                               + 104);
  flockfile(v13);
  if (!((char)(32 * *((unsigned char *)v13->_extra + 72)) >> 5)) {
    *((unsigned char *)v13->_extra + 72) = *((unsigned char *)v13->_extra + 72) & 0xF8 | 1;
  }
  if ((v13->_flags & 8) == 0 || (BOOL v4 = 0, !v13->_bf._base) && (BOOL v4 = 0, (v13->_flags & 0x200) == 0)) {
    BOOL v4 = __swsetup((uint64_t)v13) != 0;
  }
  if (!v4)
  {
    uint64_t v9 = &v7;
    LODWORD(v10) = 1;
    unint64_t v7 = v16;
    while (1)
    {
      uint64_t v11 = v5(v16, &v6, -1, 1024, (char *)v13->_extra + 80, v12);
      if (v11 == -1) {
        break;
      }
      HIDWORD(v10) = v11;
      uint64_t v8 = (int)v11;
      if (__sfvwrite((uint64_t)v13, &v9)) {
        break;
      }
      if (!v6)
      {
        funlockfile(v13);
        return 0;
      }
    }
  }
  funlockfile(v13);
  return -1;
}

int fputws(const __int32 *a1, FILE *a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    unint64_t v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    unint64_t v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return fputws_l(a1, a2, v7);
  }
  else {
    return fputws_l(a1, a2, (locale_t)__global_locale);
  }
}

uint64_t strtonum(const char *__numstr, uint64_t __minval, uint64_t __maxval, const char **__errstrp)
{
  __stsize_t r = (char *)__numstr;
  uint64_t v11 = __minval;
  uint64_t v10 = __maxval;
  uint64_t v9 = __errstrp;
  uint64_t v8 = 0;
  int v7 = 0;
  __endptsize_t r = 0;
  memcpy(__dst, &unk_DC878, sizeof(__dst));
  DWORD2(__dst[0]) = *__error();
  *__error() = 0;
  if (v11 <= v10)
  {
    uint64_t v8 = strtoll(__str, &__endptr, 10);
    if (*__error() == 22 || __str == __endptr || *__endptr)
    {
      int v7 = 1;
    }
    else if (v8 == 0x8000000000000000 && *__error() == 34 || v8 < v11)
    {
      int v7 = 2;
    }
    else if (v8 == 0x7FFFFFFFFFFFFFFFLL && *__error() == 34 || v8 > v10)
    {
      int v7 = 3;
    }
  }
  else
  {
    int v7 = 1;
  }
  if (v9) {
    *uint64_t v9 = *(const char **)&__dst[v7];
  }
  int v5 = DWORD2(__dst[v7]);
  *__error() = v5;
  if (v7) {
    return 0;
  }
  return v8;
}

size_t fread(void *a1, size_t a2, size_t a3, FILE *a4)
{
  libc_hooks_will_write((uint64_t)a4, 152);
  flockfile(a4);
  size_t v5 = __fread((uint64_t)a1, a2, a3, (uint64_t)a4);
  funlockfile(a4);
  return v5;
}

unint64_t __fread(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = (char *)a1;
  uint64_t v9 = a3;
  libc_hooks_will_write(a1, a2 * a3);
  unint64_t v7 = v9 * a2;
  if (!(v9 * a2)) {
    return 0;
  }
  if (!((char)(32 * *(unsigned char *)(*(void *)(a4 + 104) + 72)) >> 5)) {
    *(unsigned char *)(*(void *)(a4 + 104) + 72) = *(unsigned char *)(*(void *)(a4 + 104) + 72) & 0xF8 | 7;
  }
  if (*(int *)(a4 + 8) < 0) {
    *(_DWORD *)(a4 + 8) = 0;
  }
  while (v7)
  {
    if (v7 <= 0x7FFFFFFF) {
      signed int v5 = v7;
    }
    else {
      signed int v5 = 2147482624;
    }
    int v6 = __fread0(v11, v5, a4);
    if (v6 != v5) {
      return (v9 * a2 - v7 + v6) / a2;
    }
    v11 += v5;
    v7 -= v5;
  }
  return v9;
}

uint64_t __fread0(char *a1, unsigned int a2, uint64_t a3)
{
  int v10 = a2;
  while (1)
  {
    __signed int n = *(_DWORD *)(a3 + 8);
    if (v10 <= __n) {
      break;
    }
    memcpy(a1, *(const void **)a3, __n);
    *(void *)a3 += __n;
    a1 += __n;
    v10 -= __n;
    int v6 = __srefill0(a3);
    if (v6 > 0) {
      break;
    }
    if (v6) {
      return a2 - v10;
    }
  }
  if ((*(_WORD *)(a3 + 16) & 0x82) != 0 && v10 > *(_DWORD *)(a3 + 32))
  {
    long long v5 = *(_OWORD *)(a3 + 24);
    *(void *)(a3 + 24) = a1;
    for (*(_DWORD *)(a3 + 32) = v10; *(int *)(a3 + 32) > 0; *(_DWORD *)(a3 + 32) -= *(_DWORD *)(a3 + 8))
    {
      if (__srefill1(a3))
      {
        int v11 = *(_DWORD *)(a3 + 32);
        *(_OWORD *)(a3 + 24) = v5;
        *(void *)a3 = *(void *)(a3 + 24);
        return a2 - v11;
      }
      *(void *)(a3 + 24) += *(int *)(a3 + 8);
    }
    *(_OWORD *)(a3 + 24) = v5;
    uint64_t v4 = *(_DWORD *)(a3 + 32) * ((v10 - 1) / *(_DWORD *)(a3 + 32));
    memcpy(*(void **)(a3 + 24), &a1[v4], v10 - (int)v4);
    *(void *)a3 = *(void *)(a3 + 24) + v10 - (int)v4;
    *(_DWORD *)(a3 + 8) = 0;
  }
  else
  {
    while (1)
    {
      int __na = *(_DWORD *)(a3 + 8);
      if (v10 <= __na) {
        break;
      }
      memcpy(a1, *(const void **)a3, __na);
      *(void *)a3 += __na;
      a1 += __na;
      v10 -= __na;
      if (__srefill1(a3)) {
        return a2 - v10;
      }
    }
    memcpy(a1, *(const void **)a3, v10);
    *(_DWORD *)(a3 + 8) -= v10;
    *(void *)a3 += v10;
  }
  return a2;
}

FILE *__cdecl freopen(const char *a1, const char *a2, FILE *a3)
{
  locale_t v14 = a1;
  int v13 = (char *)a2;
  locale_t v12 = a3;
  int file = 0;
  int v10 = 0;
  int v9 = 0;
  int v8 = 0;
  int v7 = 0;
  int v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a1);
  libc_hooks_will_read_cstring((uint64_t)v13);
  libc_hooks_will_write((uint64_t)v12, 152);
  int v9 = __sflags(v13, &v7);
  if (v9)
  {
    pthread_once(&__sdidinit, (void (*)(void))__sinit);
    flockfile(v12);
    if (v14)
    {
      if (v12->_flags)
      {
        if ((v12->_flags & 8) != 0) {
          __sflush((uint64_t)v12);
        }
        if (v12->_close) {
          ((void (*)(void *))v12->_close)(v12->_cookie);
        }
        int v8 = 0;
      }
      else
      {
        v12->_flags = 32;
        int v8 = 0;
      }
      int file = open_NOCANCEL();
      if (file < 0 && v8 && (*__error() == 23 || *__error() == 24))
      {
        ((void (*)(void *))v12->_close)(v12->_cookie);
        int v8 = 0;
        int file = open_NOCANCEL();
      }
      int v4 = *__error();
    }
    else
    {
      if (!v12->_flags)
      {
        funlockfile(v12);
        *__error() = 22;
        return 0;
      }
      int v10 = fcntl_NOCANCEL();
      if (v10 < 0) {
        goto LABEL_7;
      }
      if ((v10 & 3) != 2 && (v10 & 3) != (v7 & 3))
      {
        fclose(v12);
        funlockfile(v12);
        *__error() = 9;
        return 0;
      }
      if ((v12->_flags & 8) != 0) {
        __sflush((uint64_t)v12);
      }
      if (((v7 ^ v10) & 8) != 0)
      {
        v10 &= ~8u;
        v10 |= v7 & 8;
        if ((int)fcntl_NOCANCEL() < 0)
        {
LABEL_7:
          int v6 = *__error();
          fclose(v12);
          funlockfile(v12);
          *__error() = v6;
          return 0;
        }
      }
      if ((v7 & 0x400) != 0) {
        ftruncate(v12->_file, 0);
      }
      if ((v7 & 8) == 0) {
        _sseek((uint64_t)v12, 0, 0);
      }
      int file = v12->_file;
      int v8 = 0;
    }
    if (v8) {
      ((void (*)(void *))v12->_close)(v12->_cookie);
    }
    if ((v12->_flags & 0x80u) != 0) {
      free(v12->_bf._base);
    }
    v12->_w = 0;
    v12->_size_t r = 0;
    v12->_p = 0;
    v12->_bf._base = 0;
    v12->_bf._int size = 0;
    v12->_lbfint size = 0;
    if (v12->_ub._base)
    {
      if (v12->_ub._base != v12->_ubuf) {
        free(v12->_ub._base);
      }
      v12->_ub._base = 0;
    }
    v12->_ub._int size = 0;
    if (v12->_lb._base)
    {
      free(v12->_lb._base);
      v12->_lb._base = 0;
    }
    v12->_lb._int size = 0;
    *((unsigned char *)v12->_extra + 72) &= 0xF8u;
    memset((char *)v12->_extra + 80, 0, 0x80uLL);
    if (file >= 0)
    {
      if (file < 0x8000)
      {
        v12->_flags = v9;
        v12->_int file = file;
        v12->_cookie = v12;
        v12->_read = (int (__cdecl *)(void *, char *, int))__sread;
        v12->_write = (int (__cdecl *)(void *, const char *, int))__swrite;
        v12->_seeint k = (fpos_t (__cdecl *)(void *, fpos_t, int))__sseek;
        v12->_close = (int (__cdecl *)(void *))__sclose;
        if ((v7 & 8) != 0) {
          _sseek((uint64_t)v12, 0, 2u);
        }
        funlockfile(v12);
        return v12;
      }
      else
      {
        funlockfile(v12);
        __sfprelease((uint64_t)v12);
        *__error() = 24;
        return 0;
      }
    }
    else
    {
      funlockfile(v12);
      __sfprelease((uint64_t)v12);
      *__error() = v4;
      return 0;
    }
  }
  else
  {
    int v5 = *__error();
    fclose(v12);
    *__error() = v5;
    return 0;
  }
}

int fscanf(FILE *a1, const char *a2, ...)
{
  va_start(va, a2);
  libc_hooks_will_write((uint64_t)a1, 152);
  flockfile(a1);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    int v4 = __svfscanf_l((int *)a1, v9, (unsigned __int8 *)a2, (uint64_t *)va);
  }
  else {
    int v4 = __svfscanf_l((int *)a1, (_xlocale *)__global_locale, (unsigned __int8 *)a2, (uint64_t *)va);
  }
  int v6 = v4;
  funlockfile(a1);
  return v6;
}

int fscanf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  va_start(va, a3);
  libc_hooks_will_write((uint64_t)a1, 152);
  if (a2)
  {
    if (a2 == (locale_t)-1) {
      a2 = (locale_t)__global_locale;
    }
  }
  else
  {
    a2 = (locale_t)&__c_locale;
  }
  flockfile(a1);
  int v4 = __svfscanf_l((int *)a1, a2, (unsigned __int8 *)a3, (uint64_t *)va);
  funlockfile(a1);
  return v4;
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  int v4 = *__error();
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  flockfile(a1);
  int v5 = _fseeko((uint64_t)a1, a2, a3, 1);
  funlockfile(a1);
  if (!v5) {
    *__error() = v4;
  }
  return v5;
}

uint64_t _fseeko(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  uint64_t v16 = a1;
  uint64_t v15 = a2;
  unsigned int v14 = a3;
  int v13 = a4;
  locale_t v12 = 0;
  unint64_t v11 = 0;
  uint64_t v10 = 0;
  uint64_t v9 = 0;
  unint64_t v8 = 0;
  memset(&__b, 0, sizeof(__b));
  locale_t v12 = *(off_t (**)(uint64_t, off_t, int))(v16 + 72);
  if (!v12)
  {
LABEL_2:
    *__error() = 29;
    return -1;
  }
  if (!v14)
  {
    if (v15 < 0) {
      goto LABEL_34;
    }
LABEL_16:
    uint64_t v10 = 0;
    int v6 = 0;
    goto LABEL_17;
  }
  if (v14 != 1)
  {
    if (v14 != 2) {
      goto LABEL_34;
    }
    goto LABEL_16;
  }
  if (_ftello(v16, &v10)) {
    return -1;
  }
  if (v10 < 0) {
    goto LABEL_2;
  }
  if (v15 > 0 && v10 > 0x7FFFFFFFFFFFFFFFLL - v15) {
    goto LABEL_32;
  }
  v15 += v10;
  if (v15 < 0) {
    goto LABEL_34;
  }
  unsigned int v14 = 0;
  int v6 = 1;
LABEL_17:
  if (!*(void *)(v16 + 24)) {
    __smakebuf(v16);
  }
  if ((*(_WORD *)(v16 + 16) & 0x81A) != 0) {
    goto LABEL_59;
  }
  if ((*(_WORD *)(v16 + 16) & 0x400) == 0)
  {
    if (v12 != __sseek
      || *(__int16 *)(v16 + 18) < 0
      || fstat(*(__int16 *)(v16 + 18), &__b)
      || (__b.st_mode & 0xF000) != 0x8000)
    {
      *(_WORD *)(v16 + 16) |= 0x800u;
      goto LABEL_59;
    }
    *(_DWORD *)(v16 + 136) = __b.st_blksize;
    *(_WORD *)(v16 + 16) |= 0x400u;
  }
  if (!v14)
  {
    unint64_t v11 = v15;
    goto LABEL_35;
  }
  if (fstat(*(__int16 *)(v16 + 18), &__b)) {
    goto LABEL_59;
  }
  if (v15 > 0 && __b.st_size > 0x7FFFFFFFFFFFFFFFLL - v15)
  {
LABEL_32:
    *__error() = 84;
    return -1;
  }
  unint64_t v11 = __b.st_size + v15;
  if (__b.st_size + v15 < 0)
  {
LABEL_34:
    *__error() = 22;
    return -1;
  }
LABEL_35:
  if (v6 || !_ftello(v16, &v10))
  {
    if ((*(_WORD *)(v16 + 16) & 0x2000) == 0)
    {
      if (*(void *)(v16 + 88))
      {
        v10 += *(int *)(v16 + 8);
        unint64_t v8 = **(void **)(v16 + 104) - *(void *)(v16 + 24);
        v10 -= v8;
        v8 += *(int *)(v16 + 112);
      }
      else
      {
        unint64_t v8 = *(void *)v16 - *(void *)(v16 + 24);
        v10 -= v8;
        v8 += *(int *)(v16 + 8);
      }
      if ((uint64_t)v11 >= v10 && v11 < v10 + v8)
      {
        int v5 = v11 - v10;
        *(void *)uint64_t v16 = *(void *)(v16 + 24) + v11 - v10;
        *(_DWORD *)(v16 + 8) = v8 - v5;
        if (*(void *)(v16 + 88))
        {
          if (*(void *)(v16 + 88) != v16 + 116) {
            free(*(void **)(v16 + 88));
          }
          *(void *)(v16 + 88) = 0;
        }
        goto LABEL_47;
      }
    }
    uint64_t v10 = v11 & ~(*(_DWORD *)(v16 + 136) - 1);
    if (_sseek(v16, v10, 0) == -1) {
      goto LABEL_59;
    }
    *(_DWORD *)(v16 + 8) = 0;
    *(void *)uint64_t v16 = *(void *)(v16 + 24);
    if (*(void *)(v16 + 88))
    {
      if (*(void *)(v16 + 88) != v16 + 116) {
        free(*(void **)(v16 + 88));
      }
      *(void *)(v16 + 88) = 0;
    }
    unint64_t v8 = v11 - v10;
    if (v11 != v10)
    {
      if (__srefill(v16) || *(int *)(v16 + 8) < v8) {
        goto LABEL_59;
      }
      *(void *)v16 += v8;
      *(_DWORD *)(v16 + 8) -= v8;
    }
LABEL_47:
    *(_WORD *)(v16 + 16) &= ~0x20u;
    memset((void *)(*(void *)(v16 + 104) + 80), 0, 0x80uLL);
    return 0;
  }
LABEL_59:
  if (__sflush(v16)) {
    return -1;
  }
  uint64_t v9 = _sseek(v16, v15, v14);
  if (v9 == -1)
  {
    return -1;
  }
  else
  {
    if (*(void *)(v16 + 88))
    {
      if (*(void *)(v16 + 88) != v16 + 116) {
        free(*(void **)(v16 + 88));
      }
      *(void *)(v16 + 88) = 0;
    }
    *(void *)uint64_t v16 = *(void *)(v16 + 24);
    *(_DWORD *)(v16 + 8) = 0;
    *(_WORD *)(v16 + 16) &= ~0x20u;
    memset((void *)(*(void *)(v16 + 104) + 80), 0, 0x80uLL);
    return 0;
  }
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  int v4 = *__error();
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  flockfile(__stream);
  int v5 = _fseeko((uint64_t)__stream, a2, __whence, 0);
  funlockfile(__stream);
  if (!v5) {
    *__error() = v4;
  }
  return v5;
}

int fsetpos(FILE *a1, const fpos_t *a2)
{
  return fseeko(a1, *a2, 0);
}

uint64_t ftell(FILE *a1)
{
  return ftello(a1);
}

off_t ftello(FILE *__stream)
{
  int v4 = __stream;
  off_t v3 = 0;
  flockfile(__stream);
  int v2 = _ftello((uint64_t)v4, &v3);
  funlockfile(v4);
  if (v2) {
    return -1;
  }
  if (v3 >= 0) {
    return v3;
  }
  *__error() = 29;
  return -1;
}

uint64_t _ftello(uint64_t a1, uint64_t *a2)
{
  if (*(void *)(a1 + 72))
  {
    if (__ftell_conformance_fix)
    {
      if ((*(_WORD *)(a1 + 16) & 4) == 0
        && (*(_WORD *)(a1 + 16) & 8) != 0
        && *(void *)a1
        && (uint64_t)(*(void *)a1 - *(void *)(a1 + 24)) > 0
        && (*(_WORD *)(a1 + 16) & 0x100) != 0)
      {
        uint64_t v5 = _sseek(a1, 0, 2u);
        if (v5 == -1) {
          return 1;
        }
      }
      else if ((*(_WORD *)(a1 + 16) & 0x1000) != 0)
      {
        uint64_t v5 = *(void *)(a1 + 144);
      }
      else
      {
        uint64_t v5 = _sseek(a1, 0, 1u);
        if (v5 == -1) {
          return 1;
        }
      }
    }
    else
    {
      if (__sflush(a1)) {
        return 1;
      }
      if ((*(_WORD *)(a1 + 16) & 0x1000) != 0)
      {
        uint64_t v5 = *(void *)(a1 + 144);
      }
      else
      {
        uint64_t v5 = _sseek(a1, 0, 1u);
        if (v5 == -1) {
          return 1;
        }
      }
    }
    if ((*(_WORD *)(a1 + 16) & 4) != 0)
    {
      if (*(void *)(a1 + 88)) {
        int v3 = *(_DWORD *)(a1 + 112);
      }
      else {
        int v3 = *(_DWORD *)(a1 + 8);
      }
      v5 -= v3;
      if (v5 < 0)
      {
        *(_WORD *)(a1 + 16) |= 0x40u;
        *__error() = 5;
        return 1;
      }
      if (*(void *)(a1 + 88)) {
        v5 -= *(int *)(a1 + 8);
      }
    }
    else if ((*(_WORD *)(a1 + 16) & 8) != 0)
    {
      if (*(void *)a1)
      {
        uint64_t v4 = *(void *)a1 - *(void *)(a1 + 24);
        if ((__ftell_conformance_fix & 1) == 0 || v4)
        {
          if (v5 > (unint64_t)(0x7FFFFFFFFFFFFFFFLL - v4))
          {
            *__error() = 84;
            return 1;
          }
          v5 += v4;
        }
      }
    }
    *a2 = v5;
    return 0;
  }
  *__error() = 29;
  return 1;
}

FILE *__cdecl funopen(const void *a1, int (__cdecl *a2)(void *, char *, int), int (__cdecl *a3)(void *, const char *, int), fpos_t (__cdecl *a4)(void *, fpos_t, int), int (__cdecl *a5)(void *))
{
  if (a2)
  {
    if (a3) {
      __int16 v6 = 16;
    }
    else {
      __int16 v6 = 4;
    }
  }
  else
  {
    if (!a3)
    {
      *__error() = 22;
      return 0;
    }
    __int16 v6 = 8;
  }
  int v7 = (FILE *)__sfp(0);
  if (!v7) {
    return 0;
  }
  v7->_flags = v6;
  v7->_int file = -1;
  v7->_cookie = (void *)a1;
  v7->_read = a2;
  v7->_write = a3;
  v7->_seeint k = a4;
  v7->_close = a5;
  return v7;
}

uint64_t __sfvwrite(uint64_t a1, _DWORD *a2)
{
  if (a2[3])
  {
    if ((*(_WORD *)(a1 + 16) & 8) == 0
      || (BOOL v10 = 0, !*(void *)(a1 + 24)) && (BOOL v10 = 0, (*(_WORD *)(a1 + 16) & 0x200) == 0))
    {
      BOOL v10 = __swsetup(a1) != 0;
    }
    if (v10)
    {
      return -1;
    }
    else
    {
      uint64_t v20 = **(char ***)a2;
      unint64_t v21 = *(void *)(*(void *)a2 + 8);
      uint64_t v19 = *(void *)a2 + 16;
      if ((*(_WORD *)(a1 + 16) & 2) != 0)
      {
        while (1)
        {
          while (!v21)
          {
            uint64_t v20 = *(char **)v19;
            unint64_t v21 = *(void *)(v19 + 8);
            v19 += 16;
          }
          int v2 = v21 >= 0x7FFFFFFF ? _swrite(a1, (uint64_t)v20, 0x7FFFFFFFu) : _swrite(a1, (uint64_t)v20, v21);
          if (v2 <= 0) {
            break;
          }
          v20 += v2;
          v21 -= v2;
          int v3 = a2[3] - v2;
          a2[3] = v3;
          if (!v3) {
            return 0;
          }
        }
LABEL_70:
        *(_WORD *)(a1 + 16) |= 0x40u;
        return -1;
      }
      else
      {
        if ((*(_WORD *)(a1 + 16) & 1) == 0)
        {
          while (1)
          {
            while (!v21)
            {
              uint64_t v20 = *(char **)v19;
              unint64_t v21 = *(void *)(v19 + 8);
              v19 += 16;
            }
            if ((*(_WORD *)(a1 + 16) & 0x4200) == 0x4200 && *(int *)(a1 + 12) < v21)
            {
              uint64_t v11 = *(void *)a1 - *(void *)(a1 + 24);
              *(_DWORD *)(a1 + 12) = v21 + 128;
              *(_DWORD *)(a1 + 32) = v11 + v21 + 128;
              *(void *)(a1 + 24) = reallocf(*(void **)(a1 + 24), *(_DWORD *)(a1 + 32) + 1);
              if (!*(void *)(a1 + 24)) {
                goto LABEL_70;
              }
              *(void *)a1 = *(void *)(a1 + 24) + v11;
            }
            int v15 = *(_DWORD *)(a1 + 12);
            if ((*(_WORD *)(a1 + 16) & 0x200) != 0)
            {
              if (v21 < v15) {
                int v15 = v21;
              }
              if (v15 > 0)
              {
                memcpy(*(void **)a1, v20, v15);
                *(_DWORD *)(a1 + 12) -= v15;
                *(void *)a1 += v15;
              }
              int v15 = v21;
            }
            else if (*(void *)a1 <= *(void *)(a1 + 24) || v21 <= v15)
            {
              signed int v16 = *(_DWORD *)(a1 + 32);
              if (v21 < v16)
              {
                int v15 = v21;
                memcpy(*(void **)a1, v20, (int)v21);
                *(_DWORD *)(a1 + 12) -= v21;
                *(void *)a1 += (int)v21;
              }
              else
              {
                if (v16)
                {
                  if (v16 * (v21 / v16) >= 0x7FFFFFFF) {
                    LODWORD(v9) = 0x7FFFFFFF;
                  }
                  else {
                    unint64_t v9 = v16 * (v21 / v16);
                  }
                  signed int v16 = v9;
                }
                int v15 = _swrite(a1, (uint64_t)v20, v16);
                if (v15 <= 0) {
                  goto LABEL_70;
                }
              }
            }
            else
            {
              memcpy(*(void **)a1, v20, v15);
              *(void *)a1 += v15;
              if (__fflush(a1)) {
                goto LABEL_70;
              }
            }
            v20 += v15;
            v21 -= v15;
            int v4 = a2[3] - v15;
            a2[3] = v4;
            if (!v4) {
              return 0;
            }
          }
        }
        int v13 = 0;
        signed int v12 = 0;
        do
        {
          while (!v21)
          {
            int v13 = 0;
            uint64_t v20 = *(char **)v19;
            unint64_t v21 = *(void *)(v19 + 8);
            v19 += 16;
          }
          if (!v13)
          {
            unsigned int v14 = memchr(v20, 10, v21);
            if (v14) {
              int v8 = v14 + 1 - v20;
            }
            else {
              int v8 = v21 + 1;
            }
            signed int v12 = v8;
            int v13 = 1;
          }
          if (v21 >= v12) {
            signed int v7 = v12;
          }
          else {
            signed int v7 = v21;
          }
          int v17 = *(_DWORD *)(a1 + 12) + *(_DWORD *)(a1 + 32);
          if (*(void *)a1 <= *(void *)(a1 + 24) || v7 <= v17)
          {
            signed int v18 = *(_DWORD *)(a1 + 32);
            if (v7 < v18)
            {
              int v17 = v7;
              memcpy(*(void **)a1, v20, v7);
              *(_DWORD *)(a1 + 12) -= v7;
              *(void *)a1 += v7;
            }
            else
            {
              int v17 = _swrite(a1, (uint64_t)v20, v18);
              if (v17 <= 0) {
                goto LABEL_70;
              }
            }
          }
          else
          {
            memcpy(*(void **)a1, v20, v17);
            *(void *)a1 += v17;
            if (__fflush(a1)) {
              goto LABEL_70;
            }
          }
          v12 -= v17;
          if (!v12)
          {
            if (__fflush(a1)) {
              goto LABEL_70;
            }
            int v13 = 0;
          }
          v20 += v17;
          v21 -= v17;
          int v5 = a2[3] - v17;
          a2[3] = v5;
        }
        while (v5);
        return 0;
      }
    }
  }
  else
  {
    return 0;
  }
}

uint64_t _fwalk(uint64_t (*a1)(uint64_t *))
{
  unsigned int v3 = 0;
  for (unint64_t i = &__sglue; i; unint64_t i = (uint64_t **)*i)
  {
    int v5 = i[2];
    int v4 = *((_DWORD *)i + 2);
    while (--v4 >= 0)
    {
      if (*((__int16 *)v5 + 8) > 0) {
        v3 |= a1(v5);
      }
      v5 += 19;
    }
  }
  return v3;
}

int fwide(FILE *a1, int a2)
{
  flockfile(a1);
  if (a2 && !((char)(32 * *((unsigned char *)a1->_extra + 72)) >> 5))
  {
    if (a2 > 0) {
      char v2 = 1;
    }
    else {
      char v2 = -1;
    }
    *((unsigned char *)a1->_extra + 72) = *((unsigned char *)a1->_extra + 72) & 0xF8 | v2 & 7;
  }
  int v4 = (char)(32 * *((unsigned char *)a1->_extra + 72)) >> 5;
  funlockfile(a1);
  return v4;
}

int fwprintf(FILE *a1, const __int32 *a2, ...)
{
  va_start(va, a2);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    signed int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    signed int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return vfwprintf_l(a1, v7, a2, va);
  }
  else {
    return vfwprintf_l(a1, (locale_t)__global_locale, a2, va);
  }
}

int fwprintf_l(FILE *a1, locale_t a2, const __int32 *a3, ...)
{
  va_start(va, a3);
  return vfwprintf_l(a1, a2, a3, va);
}

size_t fwrite(const void *a1, size_t a2, size_t a3, FILE *a4)
{
  int v15 = (char *)a1;
  size_t v14 = a2;
  size_t v13 = a3;
  signed int v12 = a4;
  unint64_t i = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  __int16 v6 = 0;
  uint64_t v7 = 0;
  size_t v11 = a3 * a2;
  if (!(a3 * a2)) {
    return 0;
  }
  uint64_t v8 = &v6;
  LODWORD(v9) = 1;
  libc_hooks_will_write((uint64_t)v12, 152);
  flockfile(v12);
  if (!((char)(32 * *((unsigned char *)v12->_extra + 72)) >> 5)) {
    *((unsigned char *)v12->_extra + 72) = *((unsigned char *)v12->_extra + 72) & 0xF8 | 7;
  }
  for (unint64_t i = v11; i; i -= v5)
  {
    if (i <= 0x7FFFFFFF) {
      int v5 = i;
    }
    else {
      int v5 = 2147482624;
    }
    __int16 v6 = v15;
    uint64_t v7 = v5;
    HIDWORD(v9) = v5;
    libc_hooks_will_read((uint64_t)v15, v5);
    if (__sfvwrite((uint64_t)v12, &v8))
    {
      size_t v13 = (v11 - i + v5 - SHIDWORD(v9)) / v14;
      break;
    }
    v15 += v5;
  }
  funlockfile(v12);
  return v13;
}

int fwscanf(FILE *a1, const __int32 *a2, ...)
{
  va_start(va, a2);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    uint64_t v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return vfwscanf_l(a1, v7, a2, va);
  }
  else {
    return vfwscanf_l(a1, (locale_t)__global_locale, a2, va);
  }
}

int fwscanf_l(FILE *a1, locale_t a2, const __int32 *a3, ...)
{
  va_start(va, a3);
  return vfwscanf_l(a1, a2, a3, va);
}

int getc(FILE *a1)
{
  flockfile(a1);
  int v1 = a1->_r - 1;
  a1->_size_t r = v1;
  if (v1 >= 0)
  {
    char v2 = a1->_p++;
    int v4 = *v2;
  }
  else
  {
    int v4 = __srget(a1);
  }
  funlockfile(a1);
  return v4;
}

int getc_unlocked(FILE *a1)
{
  int v1 = a1->_r - 1;
  a1->_size_t r = v1;
  if (v1 < 0) {
    return __srget(a1);
  }
  char v2 = a1->_p++;
  return *v2;
}

int getchar(void)
{
  flockfile(__stdinp);
  int v0 = __stdinp->_r - 1;
  __stdinp->_size_t r = v0;
  if (v0 >= 0)
  {
    int v1 = __stdinp->_p++;
    int v3 = *v1;
  }
  else
  {
    int v3 = __srget(__stdinp);
  }
  funlockfile(__stdinp);
  return v3;
}

int getchar_unlocked(void)
{
  int v0 = *(int *)((char *)&dword_8 + (void)__stdinp) - 1;
  *(int *)((char *)&dword_8 + (void)__stdinp) = v0;
  if (v0 < 0) {
    return __srget(__stdinp);
  }
  int v1 = __stdinp->_p++;
  return *v1;
}

ssize_t getdelim(char **__linep, size_t *__linecapp, int __delimiter, FILE *__stream)
{
  BOOL v10 = (uint64_t *)__linep;
  uint64_t v9 = (uint64_t *)__linecapp;
  int v8 = __delimiter;
  uint64_t v7 = __stream;
  __int16 v6 = 0;
  ssize_t v5 = 0;
  flockfile(__stream);
  if (!((char)(32 * *((unsigned char *)v7->_extra + 72)) >> 5)) {
    *((unsigned char *)v7->_extra + 72) = *((unsigned char *)v7->_extra + 72) & 0xF8 | 7;
  }
  if (!v10 || !v9)
  {
    *__error() = 22;
LABEL_24:
    v7->_flags |= 0x40u;
    funlockfile(v7);
    return -1;
  }
  if (!*v10) {
    *uint64_t v9 = 0;
  }
  if (v7->_r <= 0 && __srefill((uint64_t)v7))
  {
    if ((v7->_flags & 0x40) != 0 || expandtofit(v10, 1uLL, v9)) {
      goto LABEL_24;
    }
    funlockfile(v7);
    *(unsigned char *)*BOOL v10 = 0;
    return -1;
  }
  else
  {
    ssize_t v5 = 0;
    while (1)
    {
      __int16 v6 = (unsigned __int8 *)memchr(v7->_p, v8, v7->_r);
      if (v6) {
        break;
      }
      if (sappend(v10, &v5, v9, v7->_p, v7->_r)) {
        goto LABEL_24;
      }
      if (__srefill((uint64_t)v7))
      {
        if ((v7->_flags & 0x40) != 0) {
          goto LABEL_24;
        }
        goto LABEL_23;
      }
    }
    if (sappend(v10, &v5, v9, v7->_p, ++v6 - v7->_p)) {
      goto LABEL_24;
    }
    v7->_r -= v6 - LODWORD(v7->_p);
    v7->_p = v6;
LABEL_23:
    *(unsigned char *)(*v10 + v5) = 0;
    funlockfile(v7);
    return v5;
  }
}

uint64_t expandtofit(uint64_t *a1, unint64_t a2, uint64_t *a3)
{
  if (a2 <= 0x8000000000000000)
  {
    if (a2 > *a3)
    {
      if (a2 == 0x8000000000000000) {
        uint64_t v4 = 0x8000000000000000;
      }
      else {
        uint64_t v4 = p2roundup(a2);
      }
      uint64_t v5 = malloc_type_realloc();
      if (!v5) {
        return -1;
      }
      *a3 = v4;
      *a1 = v5;
    }
    return 0;
  }
  *__error() = 84;
  return -1;
}

uint64_t sappend(uint64_t *a1, void *a2, uint64_t *a3, const void *a4, size_t a5)
{
  BOOL v5 = __CFADD__(a5, *a2);
  size_t v7 = a5 + *a2;
  if (v5 || (((uint64_t)((unint64_t)(v7 == -1) << 63) >> 63) | (v7 == -1)) != 0)
  {
    *__error() = 84;
    return -1;
  }
  else if (expandtofit(a1, v7 + 1, a3))
  {
    return -1;
  }
  else
  {
    memcpy((void *)(*a1 + *a2), a4, a5);
    *a2 += a5;
    return 0;
  }
}

uint64_t p2roundup(uint64_t a1)
{
  uint64_t v2 = a1;
  if (((a1 - 1) & a1) != 0)
  {
    unint64_t v3 = (a1 - 1) | ((unint64_t)(a1 - 1) >> 1) | (((a1 - 1) | ((unint64_t)(a1 - 1) >> 1)) >> 2);
    unint64_t v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
    return (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
  }
  return v2;
}

ssize_t getline(char **__linep, size_t *__linecapp, FILE *__stream)
{
  return getdelim(__linep, __linecapp, 10, __stream);
}

char *__cdecl gets(char *a1)
{
  flockfile(__stdinp);
  if (!((char)(32 * *((unsigned char *)&stru_20.fileoff + *(void *)&stru_68.sectname[(void)__stdinp])) >> 5)) {
    *((unsigned char *)&stru_20.fileoff + *(void *)&stru_68.sectname[(void)__stdinp]) = *((unsigned char *)&stru_20.fileoff
  }
                                                                                    + *(void *)&stru_68.sectname[(void)__stdinp]) & 0xF8 | 7;
  if (!gets_warned)
  {
    write_NOCANCEL();
    gets_warned = 1;
  }
  for (unint64_t i = a1; ; ++i)
  {
    int v1 = *(int *)((char *)&dword_8 + (void)__stdinp) - 1;
    *(int *)((char *)&dword_8 + (void)__stdinp) = v1;
    if (v1 >= 0)
    {
      uint64_t v2 = __stdinp->_p++;
      int v5 = *v2;
    }
    else
    {
      int v5 = __srget(__stdinp);
    }
    if (v5 == 10) {
      break;
    }
    if (v5 == -1)
    {
      if (i == a1)
      {
        funlockfile(__stdinp);
        return 0;
      }
      break;
    }
    unint64_t v3 = i;
    *unint64_t v3 = v5;
  }
  *unint64_t i = 0;
  funlockfile(__stdinp);
  return a1;
}

int getw(FILE *a1)
{
  unint64_t v4 = a1;
  int v3 = 0;
  if (fread(&v3, 4uLL, 1uLL, a1) == 1) {
    return v3;
  }
  else {
    return -1;
  }
}

wint_t getwc(FILE *a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    int v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    int v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return fgetwc_l(a1, v5);
  }
  else {
    return fgetwc_l(a1, (locale_t)__global_locale);
  }
}

wint_t getwc_l(FILE *a1, locale_t a2)
{
  return fgetwc_l(a1, a2);
}

wint_t getwchar(void)
{
  int v3 = __stdinp;
  if (v0) {
    char v1 = 1;
  }
  else {
    char v1 = 0;
  }
  if (v1)
  {
    unint64_t v4 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v5 = __locale_key;
    unint64_t v4 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
  }
  if (v4) {
    return fgetwc_l(v3, v4);
  }
  else {
    return fgetwc_l(v3, (locale_t)__global_locale);
  }
}

wint_t getwchar_l(locale_t a1)
{
  return fgetwc_l(__stdinp, a1);
}

uint64_t __smakebuf(uint64_t result)
{
  uint64_t v9 = result;
  uint64_t v8 = 0;
  int v7 = 0;
  unint64_t v6 = 0;
  int v5 = 0;
  if ((*(_WORD *)(result + 16) & 2) != 0)
  {
    uint64_t v1 = v9 + 119;
    *(void *)uint64_t v9 = v9 + 119;
    *(void *)(v9 + 24) = v1;
    *(_DWORD *)(v9 + 32) = 1;
    return result;
  }
  int v7 = __swhatbuf(v9, &v6, &v5);
  if (*(__int16 *)(v9 + 18) >= 0)
  {
    uint64_t result = __senvbuf(v9, (uint64_t *)&v6, &v5);
    v7 |= result;
    if ((v7 & 2) != 0)
    {
      *(_WORD *)(v9 + 16) |= 2u;
      uint64_t v2 = v9 + 119;
      *(void *)uint64_t v9 = v9 + 119;
      *(void *)(v9 + 24) = v2;
      *(_DWORD *)(v9 + 32) = 1;
      return result;
    }
    if (!v6) {
      unint64_t v6 = 1024;
    }
  }
  if (v5)
  {
    if (isatty(*(__int16 *)(v9 + 18)))
    {
      v7 |= 1u;
      if (v6 > 0x1000)
      {
        unint64_t v6 = 4096;
        *(_DWORD *)(v9 + 136) = 4096;
      }
    }
  }
  uint64_t result = malloc_type_malloc();
  uint64_t v8 = result;
  if (result)
  {
    __cleanup = 1;
    v7 |= 0x80u;
    uint64_t v4 = v8;
    *(void *)uint64_t v9 = v8;
    *(void *)(v9 + 24) = v4;
    *(_DWORD *)(v9 + 32) = v6;
    *(_WORD *)(v9 + 16) |= v7;
  }
  else
  {
    *(_WORD *)(v9 + 16) |= 2u;
    uint64_t v3 = v9 + 119;
    *(void *)uint64_t v9 = v9 + 119;
    *(void *)(v9 + 24) = v3;
    *(_DWORD *)(v9 + 32) = 1;
  }
  return result;
}

uint64_t __swhatbuf(uint64_t a1, void *a2, _DWORD *a3)
{
  uint64_t v10 = a1;
  uint64_t v9 = a2;
  uint64_t v8 = a3;
  memset(&__b, 0, sizeof(__b));
  if (*(__int16 *)(v10 + 18) >= 0 && fstat(*(__int16 *)(v10 + 18), &__b) >= 0)
  {
    *uint64_t v8 = (__b.st_mode & 0xF000) == 0x2000;
    if (__b.st_blksize > 0)
    {
      if (__b.st_blksize <= 0x1000000) {
        st_blkint size = __b.st_blksize;
      }
      else {
        st_blkint size = 0x1000000;
      }
      *uint64_t v9 = st_blksize;
      *(_DWORD *)(v10 + 136) = st_blksize;
      BOOL v5 = 0;
      if ((__b.st_mode & 0xF000) == 0x8000) {
        BOOL v5 = *(void *)(v10 + 72) == (void)__sseek;
      }
      if (v5) {
        return 1024;
      }
      else {
        return 2048;
      }
    }
    else
    {
      *uint64_t v9 = 1024;
      return 2048;
    }
  }
  else
  {
    *uint64_t v8 = 0;
    *uint64_t v9 = 1024;
    return 2048;
  }
}

uint64_t __senvbuf(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  unsigned int v12 = 0;
  unint64_t v11 = 0;
  size_t v13 = __getevp(*(__int16 *)(a1 + 18));
  if (!v13 || !*v13) {
    return 0;
  }
  unsigned int v3 = *v13;
  BOOL v4 = v3 > 0x30;
  uint64_t v5 = v3 - 48;
  if (v4)
  {
    uint64_t v7 = v5;
    char v6 = 1;
  }
  else
  {
    uint64_t v7 = v5;
    char v6 = 0;
  }
  if ((v6 & 1) == 0)
  {
    switch(v7)
    {
      case 0:
      case 37:
      case 69:
        ++v13;
        unsigned int v12 = 2;
        break;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 19:
      case 20:
      case 21:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 36:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 55:
      case 56:
      case 57:
      case 58:
      case 59:
      case 61:
      case 62:
      case 63:
      case 64:
      case 65:
      case 66:
      case 67:
      case 68:
        break;
      case 18:
      case 22:
      case 54:
        ++v13;
        break;
      case 28:
      case 60:
        ++v13;
        unsigned int v12 = 1;
        break;
      default:
        JUMPOUT(0);
    }
  }
  if (v12 == 2 && *v13) {
    return 0;
  }
  while (isdigit(*v13))
    unint64_t v11 = 10 * v11 + *v13++ - 48;
  int v10 = *v13;
  if (*v13 && v10 != 66)
  {
    if (v10 == 75)
    {
LABEL_24:
      ++v13;
      v11 <<= 10;
      goto LABEL_25;
    }
    if (v10 != 77)
    {
      if (v10 != 107) {
        return 0;
      }
      goto LABEL_24;
    }
    ++v13;
    v11 <<= 20;
  }
LABEL_25:
  if (*v13 == 66) {
    ++v13;
  }
  if (*v13)
  {
    return 0;
  }
  else
  {
    *a3 = 0;
    if (v11 <= 0x1000000) {
      uint64_t v9 = v11;
    }
    else {
      uint64_t v9 = 0x1000000;
    }
    *a2 = v9;
    return v12;
  }
}

char *__getevp(int a1)
{
  if (__getevp_predicate != -1) {
    _os_once();
  }
  if (a1)
  {
    if (a1 == 1)
    {
      if (__stdout_evp) {
        return &__stdout_evp;
      }
    }
    else if (a1 == 2 && __stderr_evp)
    {
      return &__stderr_evp;
    }
  }
  else if (__stdin_evp)
  {
    return &__stdin_evp;
  }
  if (__fallback_evp) {
    return &__fallback_evp;
  }
  else {
    return 0;
  }
}

char *__evpinit()
{
  return __loadevp("_STDBUF_E", &__stderr_evp);
}

char *__loadevp(const char *a1, char *a2)
{
  uint64_t result = getenv(a1);
  if (result) {
    return (char *)strlcpy(a2, result, 0x10uLL);
  }
  return result;
}

int mkostemps(char *path, int slen, int oflags)
{
  uint64_t v8 = path;
  int v7 = slen;
  int v6 = oflags;
  int v5 = 0;
  if ((oflags & 0xFEFFFFC7) != 0)
  {
    *__error() = 22;
    return -1;
  }
  else if (find_temp_path(-2, v8, v7, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkostemps_action, (uint64_t)&v6, (uint64_t)&v5))
  {
    return v5;
  }
  else
  {
    return -1;
  }
}

uint64_t find_temp_path(int a1, char *a2, int a3, char a4, uint64_t (*a5)(void, char *, uint64_t, uint64_t), uint64_t a6, uint64_t a7)
{
  int v26 = a1;
  unint64_t v25 = a2;
  int v24 = a3;
  char v23 = a4 & 1;
  long long v22 = a5;
  uint64_t v21 = a6;
  uint64_t v20 = a7;
  uint64_t __src = 0;
  unint64_t i = 0;
  __s = 0;
  int j = 0;
  int v15 = 0;
  memset(&__b, 0, sizeof(__b));
  if (v24 < 0) {
    goto LABEL_2;
  }
  for (unint64_t i = v25; *i; ++i)
    ;
  if (i - v25 >= 1024)
  {
    *__error() = 63;
    return 0;
  }
  i -= v24;
  __s = i;
  if (--i < v25 || strchr(__s, 47))
  {
LABEL_2:
    *__error() = 22;
    return 0;
  }
  else
  {
    while (1)
    {
      BOOL v12 = 0;
      if (i >= v25) {
        BOOL v12 = *i == 88;
      }
      if (!v12) {
        break;
      }
      char v7 = padchar[arc4random_uniform(0x3Eu)];
      uint64_t v8 = i--;
      *uint64_t v8 = v7;
    }
    uint64_t __src = i + 1;
    memcpy(__dst, i + 1, __s - (i + 1));
    if (v23)
    {
      while (i > v25)
      {
        if (*i == 47)
        {
          *unint64_t i = 0;
          int v13 = fstatat(v26, v25, &__b, 0);
          *unint64_t i = 47;
          if (v13) {
            return 0;
          }
          if ((__b.st_mode & 0xF000) != 0x4000)
          {
            *__error() = 20;
            return 0;
          }
          break;
        }
        --i;
      }
    }
LABEL_24:
    int v11 = v22(v26, v25, v21, v20);
    if (v11)
    {
      if (v11 == 2)
      {
        return 0;
      }
      else
      {
        unint64_t i = (char *)__src;
        for (int j = __dst; ; ++j)
        {
          if (i == __s)
          {
            *__error() = 17;
            return 0;
          }
          int v15 = strchr("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", *i);
          if (!v15) {
            break;
          }
          if (*++v15) {
            char v10 = *v15;
          }
          else {
            char v10 = padchar[0];
          }
          *unint64_t i = v10;
          if (*i != *j) {
            goto LABEL_24;
          }
          ++i;
        }
        *__error() = 5;
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
}

uint64_t _mkostemps_action(uint64_t a1, uint64_t a2, uint64_t a3, int *a4)
{
  int v6 = openat_NOCANCEL();
  if (v6 < 0)
  {
    if (*__error() == 17) {
      return 1;
    }
    else {
      return 2;
    }
  }
  else
  {
    *a4 = v6;
    return 0;
  }
}

int mkostempsat_np(int dfd, char *path, int slen, int oflags)
{
  int v10 = dfd;
  uint64_t v9 = path;
  int v8 = slen;
  int v7 = oflags;
  int v6 = 0;
  if ((oflags & 0xFEFFFFC7) != 0)
  {
    *__error() = 22;
    return -1;
  }
  else if (find_temp_path(v10, v9, v8, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkostemps_action, (uint64_t)&v7, (uint64_t)&v6))
  {
    return v6;
  }
  else
  {
    return -1;
  }
}

int mkstemps(char *a1, int a2)
{
  int v5 = a1;
  v4[1] = a2;
  v4[0] = 0;
  if (find_temp_path(-2, a1, a2, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkostemps_action, 0, (uint64_t)v4))return v4[0]; {
  else
  }
    return -1;
}

int mkstempsat_np(int dfd, char *path, int slen)
{
  int v7 = dfd;
  int v6 = path;
  v5[1] = slen;
  v5[0] = 0;
  if (find_temp_path(dfd, path, slen, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkostemps_action, 0, (uint64_t)v5))return v5[0]; {
  else
  }
    return -1;
}

int mkostemp(char *path, int oflags)
{
  int v6 = path;
  int v5 = oflags;
  int v4 = 0;
  if ((oflags & 0xFEFFFFC7) != 0)
  {
    *__error() = 22;
    return -1;
  }
  else if (find_temp_path(-2, v6, 0, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkostemps_action, (uint64_t)&v5, (uint64_t)&v4))
  {
    return v4;
  }
  else
  {
    return -1;
  }
}

int mkstemp(char *a1)
{
  int v4 = a1;
  int v3 = 0;
  if (find_temp_path(-2, a1, 0, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkostemps_action, 0, (uint64_t)&v3))return v3; {
  else
  }
    return -1;
}

char *__cdecl mkdtemp(char *a1)
{
  if (find_temp_path(-2, a1, 0, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkdtemp_action, 0, 0))return a1; {
  else
  }
    return 0;
}

uint64_t _mkdtemp_action(int a1, const char *a2)
{
  if (mkdirat(a1, a2, 0x1C0u))
  {
    if (*__error() == 17) {
      return 1;
    }
    else {
      return 2;
    }
  }
  else
  {
    return 0;
  }
}

char *__cdecl mkdtempat_np(int dfd, char *path)
{
  if (find_temp_path(dfd, path, 0, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkdtemp_action, 0, 0))return path; {
  else
  }
    return 0;
}

char *_mktemp(char *a1)
{
  if (find_temp_path(-2, a1, 0, 0, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mktemp_action, 0, 0))return a1; {
  else
  }
    return 0;
}

uint64_t _mktemp_action(int a1, const char *a2, uint64_t a3, uint64_t a4)
{
  int v10 = a1;
  uint64_t v9 = a2;
  uint64_t v8 = a3;
  uint64_t v7 = a4;
  memset(&__b, 0, sizeof(__b));
  if (fstatat(v10, v9, &__b, 32))
  {
    if (*__error() == 2) {
      return 0;
    }
    else {
      return 2;
    }
  }
  else
  {
    return 1;
  }
}

char *__cdecl mktemp(char *a1)
{
  return _mktemp(a1);
}

int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
{
  int v6 = path;
  _DWORD v5[2] = dpclass;
  v5[1] = dpflags;
  v5[0] = 0;
  v7[0] = dpclass;
  v7[1] = dpflags;
  if (find_temp_path(-2, path, 0, 1, (uint64_t (*)(void, char *, uint64_t, uint64_t))_mkstemp_dprotected_np_action, (uint64_t)v7, (uint64_t)v5))return v5[0]; {
  else
  }
    return -1;
}

uint64_t _mkstemp_dprotected_np_action(int a1, const char *a2, int *a3, int *a4)
{
  if (a1 != -2) {
    __assert_rtn("_mkstemp_dprotected_np_action", "mktemp.c", 321, "dfd == AT_FDCWD");
  }
  int v6 = open_dprotected_np(a2, 2562, *a3, a3[1], 384);
  if (v6 < 0)
  {
    if (*__error() == 17) {
      return 1;
    }
    else {
      return 2;
    }
  }
  else
  {
    *a4 = v6;
    return 0;
  }
}

int rpmatch(const char *a1)
{
  uint64_t v7 = a1;
  memset(&v6, 0, sizeof(v6));
  memset(&v5, 0, sizeof(v5));
  uint64_t v1 = nl_langinfo(52);
  if (regcomp(&v6, v1, 5)) {
    return -1;
  }
  uint64_t v2 = nl_langinfo(53);
  if (regcomp(&v5, v2, 5))
  {
    regfree(&v6);
    return -1;
  }
  else
  {
    if (regexec(&v6, v7, 0, 0, 0))
    {
      if (regexec(&v5, v7, 0, 0, 0)) {
        int v4 = -1;
      }
      else {
        int v4 = 0;
      }
    }
    else
    {
      int v4 = 1;
    }
    regfree(&v6);
    regfree(&v5);
    return v4;
  }
}

BOOL __find_arguments(char *a1, _DWORD *a2, uint64_t *a3)
{
  long double v27 = a1;
  int v26 = a2;
  unint64_t v25 = a3;
  unsigned int v23 = 0;
  int v22 = 0;
  int v21 = 0;
  int v20 = 0;
  int v19 = 0;
  memset(__b, 0, sizeof(__b));
  int v24 = v27;
  inittypes((uint64_t)__b);
  int v21 = 0;
  while (1)
  {
    while (1)
    {
LABEL_2:
      unsigned int v23 = *v24;
      BOOL v17 = 0;
      if (v23) {
        BOOL v17 = v23 != 37;
      }
      if (!v17) {
        break;
      }
      ++v24;
    }
    if (!v23) {
      break;
    }
    ++v24;
    int v20 = 0;
    int v19 = 0;
LABEL_8:
    int v3 = v24++;
    unsigned int v23 = *v3;
LABEL_9:
    if (v23 <= 0x20)
    {
      uint64_t v5 = v23 - 32;
      char v4 = 0;
    }
    else
    {
      uint64_t v5 = v23 - 32;
      char v4 = 1;
    }
    if (v4)
    {
LABEL_101:
      if (!v23) {
        break;
      }
    }
    else
    {
      switch(v5)
      {
        case 0:
        case 3:
        case 7:
        case 11:
        case 13:
        case 16:
          goto LABEL_8;
        case 1:
        case 2:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
        case 15:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 34:
        case 40:
        case 41:
        case 42:
        case 43:
        case 45:
        case 46:
        case 48:
        case 49:
        case 50:
        case 52:
        case 54:
        case 55:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 66:
        case 75:
        case 77:
        case 82:
        case 86:
        case 87:
        case 89:
          goto LABEL_101;
        case 10:
          int v21 = addaster(__b, &v24);
          if (!v21) {
            goto LABEL_8;
          }
          goto LABEL_103;
        case 14:
          regex_t v6 = v24++;
          unsigned int v23 = *v6;
          if (v23 != 42)
          {
            while (v23 - 48 <= 9)
            {
              uint64_t v7 = v24++;
              unsigned int v23 = *v7;
            }
            goto LABEL_9;
          }
          int v21 = addaster(__b, &v24);
          if (v21) {
            goto LABEL_103;
          }
          goto LABEL_8;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
          int v22 = 0;
          do
          {
            int v22 = 10 * v22 + v23 - 48;
            uint64_t v8 = v24++;
            unsigned int v23 = *v8;
          }
          while (v23 - 48 <= 9);
          if (v23 == 36)
          {
            LODWORD(__b[6]) = v22;
            goto LABEL_8;
          }
          int v19 = v22;
          goto LABEL_9;
        case 33:
        case 37:
        case 38:
        case 39:
        case 65:
        case 69:
        case 70:
        case 71:
          if ((v20 & 0x4000) != 0)
          {
            int v11 = addtype(__b, 26);
          }
          else
          {
            if ((v20 & 8) != 0) {
              int v12 = 23;
            }
            else {
              int v12 = 22;
            }
            int v11 = addtype(__b, v12);
          }
          int v21 = v11;
          if (!v11) {
            goto LABEL_2;
          }
          goto LABEL_103;
        case 35:
          v20 |= 0x10u;
          goto LABEL_39;
        case 36:
          v20 |= 0x10u;
          goto LABEL_48;
        case 44:
          v20 |= 8u;
          goto LABEL_8;
        case 47:
          v20 |= 0x10u;
          goto LABEL_79;
        case 51:
          v20 |= 0x10u;
          goto LABEL_90;
        case 53:
          v20 |= 0x10u;
          goto LABEL_96;
        case 56:
        case 85:
        case 88:
LABEL_96:
          if ((v20 & 0x4000) != 0)
          {
            int v21 = addtype(__b, 26);
            if (v21) {
              goto LABEL_103;
            }
          }
          else
          {
            int v21 = adduarg(__b, v20);
            if (v21) {
              goto LABEL_103;
            }
          }
          break;
        case 67:
LABEL_39:
          if ((v20 & 0x10) != 0)
          {
            int v9 = addtype(__b, 24);
          }
          else
          {
            if ((v20 & 0x4000) != 0) {
              int v10 = 26;
            }
            else {
              int v10 = 2;
            }
            int v9 = addtype(__b, v10);
          }
          int v21 = v9;
          if (!v9) {
            goto LABEL_2;
          }
          goto LABEL_103;
        case 68:
        case 73:
LABEL_48:
          if ((v20 & 0x4000) != 0)
          {
            int v21 = addtype(__b, 26);
            if (v21) {
              goto LABEL_103;
            }
          }
          else
          {
            int v21 = addsarg(__b, v20);
            if (v21) {
              goto LABEL_103;
            }
          }
          goto LABEL_2;
        case 72:
          if ((v20 & 0x40) != 0)
          {
            v20 &= ~0x40u;
            v20 |= 0x2000u;
          }
          else
          {
            v20 |= 0x40u;
          }
          goto LABEL_8;
        case 74:
          v20 |= 0x1000u;
          goto LABEL_8;
        case 76:
          if ((v20 & 0x10) != 0)
          {
            v20 &= ~0x10u;
            v20 |= 0x20u;
          }
          else
          {
            v20 |= 0x10u;
          }
          goto LABEL_8;
        case 78:
          if ((v20 & 0x1000) != 0)
          {
            int v21 = addtype(__b, 18);
          }
          else if ((v20 & 0x800) != 0)
          {
            int v21 = addtype(__b, 12);
          }
          else if ((v20 & 0x400) != 0)
          {
            int v21 = addtype(__b, 15);
          }
          else if ((v20 & 0x20) != 0)
          {
            int v21 = addtype(__b, 10);
          }
          else if ((v20 & 0x10) != 0)
          {
            int v21 = addtype(__b, 7);
          }
          else if ((v20 & 0x40) != 0)
          {
            int v21 = addtype(__b, 1);
          }
          else if ((v20 & 0x2000) != 0)
          {
            int v21 = addtype(__b, 21);
          }
          else
          {
            int v21 = addtype(__b, 4);
          }
          if (!v21) {
            goto LABEL_2;
          }
          goto LABEL_103;
        case 79:
LABEL_79:
          if ((v20 & 0x4000) != 0)
          {
            int v21 = addtype(__b, 26);
            if (v21) {
              goto LABEL_103;
            }
          }
          else
          {
            int v21 = adduarg(__b, v20);
            if (v21) {
              goto LABEL_103;
            }
          }
          goto LABEL_2;
        case 80:
          if ((v20 & 0x4000) != 0) {
            int v13 = 26;
          }
          else {
            int v13 = 19;
          }
          int v21 = addtype(__b, v13);
          if (!v21) {
            goto LABEL_2;
          }
          goto LABEL_103;
        case 81:
          v20 |= 0x20u;
          goto LABEL_8;
        case 83:
LABEL_90:
          if ((v20 & 0x10) != 0) {
            int v14 = 25;
          }
          else {
            int v14 = 20;
          }
          int v21 = addtype(__b, v14);
          if (!v21) {
            goto LABEL_2;
          }
          goto LABEL_103;
        case 84:
          v20 |= 0x800u;
          goto LABEL_8;
        case 90:
          v20 |= 0x400u;
          goto LABEL_8;
        default:
          JUMPOUT(0);
      }
    }
  }
  build_arg_table((uint64_t)__b, v26, v25);
LABEL_103:
  freetypes(__b);
  BOOL v16 = 1;
  if (!v21) {
    return *v25 == 0;
  }
  return v16;
}

uint64_t inittypes(uint64_t result)
{
  *(void *)uint64_t result = result + 8;
  *(_DWORD *)(result + 40) = 8;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 1;
  for (int i = 0; i < 8; ++i)
    *(_DWORD *)(*(void *)result + 4 * i) = 0;
  return result;
}

uint64_t addaster(_DWORD *a1, unsigned char **a2)
{
  int v4 = 0;
  for (int i = *a2; ((char)*i - 48) <= 9; ++i)
    int v4 = 10 * v4 + (char)*i - 48;
  if (*i != 36)
  {
    if (addtype(a1, 2)) {
      return -1;
    }
    return 0;
  }
  int v3 = a1[12];
  a1[12] = v4;
  if (!addtype(a1, 2))
  {
    a1[12] = v3;
    *a2 = i + 1;
    return 0;
  }
  return -1;
}

uint64_t addtype(_DWORD *a1, int a2)
{
  if (_ensurespace(a1))
  {
    return -1;
  }
  else
  {
    uint64_t v2 = *(void *)a1;
    uint64_t v3 = (int)a1[12]++;
    *(_DWORD *)(v2 + 4 * v3) = a2;
    return 0;
  }
}

uint64_t addsarg(_DWORD *a1, __int16 a2)
{
  if (_ensurespace(a1))
  {
    return -1;
  }
  else
  {
    if ((a2 & 0x1000) != 0)
    {
      uint64_t v2 = *(void *)a1;
      uint64_t v3 = (int)a1[12]++;
      *(_DWORD *)(v2 + 4 * v3) = 16;
    }
    else if ((a2 & 0x400) != 0)
    {
      uint64_t v4 = *(void *)a1;
      uint64_t v5 = (int)a1[12]++;
      *(_DWORD *)(v4 + 4 * v5) = 13;
    }
    else if ((a2 & 0x800) != 0)
    {
      uint64_t v6 = *(void *)a1;
      uint64_t v7 = (int)a1[12]++;
      *(_DWORD *)(v6 + 4 * v7) = 11;
    }
    else if ((a2 & 0x20) != 0)
    {
      uint64_t v8 = *(void *)a1;
      uint64_t v9 = (int)a1[12]++;
      *(_DWORD *)(v8 + 4 * v9) = 8;
    }
    else
    {
      uint64_t v10 = *(void *)a1;
      uint64_t v11 = (int)a1[12]++;
      if ((a2 & 0x10) != 0) {
        *(_DWORD *)(v10 + 4 * v11) = 5;
      }
      else {
        *(_DWORD *)(v10 + 4 * v11) = 2;
      }
    }
    return 0;
  }
}

uint64_t adduarg(_DWORD *a1, __int16 a2)
{
  if (_ensurespace(a1))
  {
    return -1;
  }
  else
  {
    if ((a2 & 0x1000) != 0)
    {
      uint64_t v2 = *(void *)a1;
      uint64_t v3 = (int)a1[12]++;
      *(_DWORD *)(v2 + 4 * v3) = 17;
    }
    else if ((a2 & 0x400) != 0)
    {
      uint64_t v4 = *(void *)a1;
      uint64_t v5 = (int)a1[12]++;
      *(_DWORD *)(v4 + 4 * v5) = 14;
    }
    else if ((a2 & 0x800) != 0)
    {
      uint64_t v6 = *(void *)a1;
      uint64_t v7 = (int)a1[12]++;
      *(_DWORD *)(v6 + 4 * v7) = 14;
    }
    else if ((a2 & 0x20) != 0)
    {
      uint64_t v8 = *(void *)a1;
      uint64_t v9 = (int)a1[12]++;
      *(_DWORD *)(v8 + 4 * v9) = 9;
    }
    else
    {
      uint64_t v10 = *(void *)a1;
      uint64_t v11 = (int)a1[12]++;
      if ((a2 & 0x10) != 0) {
        *(_DWORD *)(v10 + 4 * v11) = 6;
      }
      else {
        *(_DWORD *)(v10 + 4 * v11) = 3;
      }
    }
    return 0;
  }
}

uint64_t build_arg_table(uint64_t result, _DWORD *a2, uint64_t *a3)
{
  uint64_t v33 = result;
  if (*(int *)(result + 44) < 8 || (uint64_t result = malloc_type_malloc(), (*a3 = result) != 0))
  {
    *(_DWORD *)*a3 = 0;
    for (int i = 1; i <= *(_DWORD *)(v33 + 44); ++i)
    {
      uint64_t result = *(unsigned int *)(*(void *)v33 + 4 * i);
      switch((int)result)
      {
        case 0:
          uint64_t v3 = a2;
          a2 += 2;
          *(_DWORD *)(*a3 + 16 * i) = *v3;
          break;
        case 1:
          uint64_t v5 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v5;
          break;
        case 2:
          uint64_t v6 = a2;
          a2 += 2;
          *(_DWORD *)(*a3 + 16 * i) = *v6;
          break;
        case 3:
          uint64_t v7 = a2;
          a2 += 2;
          *(_DWORD *)(*a3 + 16 * i) = *v7;
          break;
        case 4:
          uint64_t v8 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v8;
          break;
        case 5:
          uint64_t v9 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v9;
          break;
        case 6:
          uint64_t v10 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v10;
          break;
        case 7:
          uint64_t v11 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v11;
          break;
        case 8:
          int v12 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v12;
          break;
        case 9:
          int v13 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v13;
          break;
        case 10:
          int v14 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v14;
          break;
        case 11:
          int v15 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v15;
          break;
        case 12:
          BOOL v16 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v16;
          break;
        case 13:
          signed int v18 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v18;
          break;
        case 14:
          BOOL v17 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v17;
          break;
        case 15:
          int v19 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v19;
          break;
        case 16:
          int v20 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v20;
          break;
        case 17:
          int v21 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v21;
          break;
        case 18:
          int v22 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v22;
          break;
        case 19:
          long double v27 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v27;
          break;
        case 20:
          int v26 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v26;
          break;
        case 21:
          uint64_t v4 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v4;
          break;
        case 22:
          unsigned int v23 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v23;
          break;
        case 23:
          int v24 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v24;
          break;
        case 24:
          uint64_t v28 = a2;
          a2 += 2;
          *(_DWORD *)(*a3 + 16 * i) = *v28;
          break;
        case 25:
          int v29 = a2;
          a2 += 2;
          *(void *)(*a3 + 16 * i) = *v29;
          break;
        case 26:
          unint64_t v25 = (_OWORD *)(((unint64_t)a2 + 15) & 0xFFFFFFFFFFFFFFF0);
          a2 = v25 + 1;
          *(_OWORD *)(*a3 + 16 * i) = *v25;
          break;
        default:
          continue;
      }
    }
  }
  return result;
}

void freetypes(void **a1)
{
  if (*a1 != a1 + 1) {
    free(*a1);
  }
}

BOOL __find_warguments(unsigned int *a1, _DWORD *a2, uint64_t *a3)
{
  int v24 = a1;
  unsigned int v23 = a2;
  int v22 = a3;
  unsigned int v20 = 0;
  int v19 = 0;
  int v18 = 0;
  int v17 = 0;
  int v16 = 0;
  memset(__b, 0, sizeof(__b));
  int v21 = v24;
  inittypes((uint64_t)__b);
  int v18 = 0;
  do
  {
    while (1)
    {
LABEL_2:
      unsigned int v20 = *v21;
      BOOL v14 = 0;
      if (v20) {
        BOOL v14 = v20 != 37;
      }
      if (!v14) {
        break;
      }
      ++v21;
    }
    if (!v20) {
      break;
    }
    ++v21;
    int v17 = 0;
    int v16 = 0;
    while (1)
    {
      uint64_t v3 = v21++;
      unsigned int v20 = *v3;
LABEL_9:
      if (v20 <= 0x20)
      {
        uint64_t v5 = v20 - 32;
        char v4 = 0;
      }
      else
      {
        uint64_t v5 = v20 - 32;
        char v4 = 1;
      }
      if (v4) {
        break;
      }
      switch(v5)
      {
        case 0:
        case 3:
        case 7:
        case 11:
        case 13:
        case 16:
          continue;
        case 1:
        case 2:
        case 4:
        case 5:
        case 6:
        case 8:
        case 9:
        case 12:
        case 15:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 34:
        case 40:
        case 41:
        case 42:
        case 43:
        case 45:
        case 46:
        case 48:
        case 49:
        case 50:
        case 52:
        case 54:
        case 55:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 66:
        case 75:
        case 77:
        case 82:
        case 86:
        case 87:
        case 89:
          goto LABEL_83;
        case 10:
          int v18 = addwaster(__b, &v21);
          if (!v18) {
            continue;
          }
          goto LABEL_85;
        case 14:
          uint64_t v6 = v21++;
          unsigned int v20 = *v6;
          if (v20 != 42)
          {
            while (v20 - 48 <= 9)
            {
              uint64_t v7 = v21++;
              unsigned int v20 = *v7;
            }
            goto LABEL_9;
          }
          int v18 = addwaster(__b, &v21);
          if (v18) {
            goto LABEL_85;
          }
          break;
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
          int v19 = 0;
          do
          {
            int v19 = 10 * v19 + v20 - 48;
            uint64_t v8 = v21++;
            unsigned int v20 = *v8;
          }
          while (v20 - 48 <= 9);
          if (v20 == 36)
          {
            LODWORD(__b[6]) = v19;
            continue;
          }
          int v16 = v19;
          goto LABEL_9;
        case 33:
        case 37:
        case 38:
        case 39:
        case 65:
        case 69:
        case 70:
        case 71:
          if ((v17 & 8) != 0) {
            int v10 = 23;
          }
          else {
            int v10 = 22;
          }
          int v18 = addtype(__b, v10);
          if (!v18) {
            goto LABEL_2;
          }
          goto LABEL_85;
        case 35:
          v17 |= 0x10u;
          goto LABEL_39;
        case 36:
          v17 |= 0x10u;
          goto LABEL_45;
        case 44:
          v17 |= 8u;
          continue;
        case 47:
          v17 |= 0x10u;
          goto LABEL_70;
        case 51:
          v17 |= 0x10u;
          goto LABEL_75;
        case 53:
          v17 |= 0x10u;
          goto LABEL_81;
        case 56:
        case 85:
        case 88:
LABEL_81:
          int v18 = adduarg(__b, v17);
          if (!v18) {
            goto LABEL_2;
          }
          goto LABEL_85;
        case 67:
LABEL_39:
          if ((v17 & 0x10) != 0) {
            int v9 = 24;
          }
          else {
            int v9 = 2;
          }
          int v18 = addtype(__b, v9);
          if (!v18) {
            goto LABEL_2;
          }
          goto LABEL_85;
        case 68:
        case 73:
LABEL_45:
          int v18 = addsarg(__b, v17);
          if (!v18) {
            goto LABEL_2;
          }
          goto LABEL_85;
        case 72:
          if ((v17 & 0x40) != 0)
          {
            v17 &= ~0x40u;
            v17 |= 0x2000u;
          }
          else
          {
            v17 |= 0x40u;
          }
          continue;
        case 74:
          v17 |= 0x1000u;
          continue;
        case 76:
          if ((v17 & 0x10) != 0)
          {
            v17 &= ~0x10u;
            v17 |= 0x20u;
          }
          else
          {
            v17 |= 0x10u;
          }
          continue;
        case 78:
          if ((v17 & 0x1000) != 0)
          {
            int v18 = addtype(__b, 18);
          }
          else if ((v17 & 0x800) != 0)
          {
            int v18 = addtype(__b, 12);
          }
          else if ((v17 & 0x400) != 0)
          {
            int v18 = addtype(__b, 15);
          }
          else if ((v17 & 0x20) != 0)
          {
            int v18 = addtype(__b, 10);
          }
          else if ((v17 & 0x10) != 0)
          {
            int v18 = addtype(__b, 7);
          }
          else if ((v17 & 0x40) != 0)
          {
            int v18 = addtype(__b, 1);
          }
          else if ((v17 & 0x2000) != 0)
          {
            int v18 = addtype(__b, 21);
          }
          else
          {
            int v18 = addtype(__b, 4);
          }
          if (!v18) {
            goto LABEL_2;
          }
          goto LABEL_85;
        case 79:
LABEL_70:
          int v18 = adduarg(__b, v17);
          if (!v18) {
            goto LABEL_2;
          }
          goto LABEL_85;
        case 80:
          int v18 = addtype(__b, 19);
          if (!v18) {
            goto LABEL_2;
          }
          goto LABEL_85;
        case 81:
          v17 |= 0x20u;
          continue;
        case 83:
LABEL_75:
          if ((v17 & 0x10) != 0) {
            int v11 = 25;
          }
          else {
            int v11 = 20;
          }
          int v18 = addtype(__b, v11);
          if (!v18) {
            goto LABEL_2;
          }
          goto LABEL_85;
        case 84:
          v17 |= 0x800u;
          continue;
        case 90:
          v17 |= 0x400u;
          continue;
        default:
          JUMPOUT(0);
      }
    }
LABEL_83:
    ;
  }
  while (v20);
  build_arg_table((uint64_t)__b, v23, v22);
LABEL_85:
  freetypes(__b);
  BOOL v13 = 1;
  if (!v18) {
    return *v22 == 0;
  }
  return v13;
}

uint64_t addwaster(_DWORD *a1, _DWORD **a2)
{
  int v4 = 0;
  for (int i = *a2; (*i - 48) <= 9; ++i)
    int v4 = 10 * v4 + *i - 48;
  if (*i != 36)
  {
    if (addtype(a1, 2)) {
      return -1;
    }
    return 0;
  }
  int v3 = a1[12];
  a1[12] = v4;
  if (!addtype(a1, 2))
  {
    a1[12] = v3;
    *a2 = i + 1;
    return 0;
  }
  return -1;
}

uint64_t _ensurespace(_DWORD *a1)
{
  if (a1[12] >= a1[10] && __grow_type_table((uint64_t)a1))
  {
    return -1;
  }
  else
  {
    if (a1[12] > a1[11]) {
      a1[11] = a1[12];
    }
    return 0;
  }
}

uint64_t __grow_type_table(uint64_t a1)
{
  uint64_t v6 = *(const void **)a1;
  int v5 = *(_DWORD *)(a1 + 40);
  int v2 = 2 * v5;
  if (2 * v5 < *(_DWORD *)(a1 + 48) + 1) {
    int v2 = *(_DWORD *)(a1 + 48) + 1;
  }
  if (v5 == 8)
  {
    int v4 = (void *)malloc_type_malloc();
    if (!v4) {
      return -1;
    }
    bcopy(v6, v4, 0x20uLL);
  }
  else
  {
    int v4 = (void *)malloc_type_realloc();
    if (!v4) {
      return -1;
    }
  }
  for (int i = v5; i < v2; ++i)
    *((_DWORD *)v4 + i) = 0;
  *(void *)a1 = v4;
  *(_DWORD *)(a1 + 40) = v2;
  return 0;
}

int printf(const char *a1, ...)
{
  va_start(va, a1);
  int v4 = __stdoutp;
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    uint64_t v6 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v7 = __locale_key;
    uint64_t v6 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6) {
    return vfprintf_l(v4, v6, a1, va);
  }
  else {
    return vfprintf_l(v4, (locale_t)__global_locale, a1, va);
  }
}

int printf_l(locale_t a1, const char *a2, ...)
{
  va_start(va, a2);
  return vfprintf_l(__stdoutp, a1, a2, va);
}

int putc(int a1, FILE *a2)
{
  flockfile(a2);
  int v2 = a2->_w - 1;
  a2->_w = v2;
  if (v2 < 0 && (a2->_w < a2->_lbfsize || (char)a1 == 10))
  {
    int v7 = __swbuf(a1, a2);
  }
  else
  {
    int v3 = a2->_p++;
    *int v3 = a1;
    int v7 = a1;
  }
  funlockfile(a2);
  return v7;
}

int putc_unlocked(int a1, FILE *a2)
{
  int v2 = a2->_w - 1;
  a2->_w = v2;
  if (v2 < 0 && (a2->_w < a2->_lbfsize || (char)a1 == 10)) {
    return __swbuf(a1, a2);
  }
  int v3 = a2->_p++;
  *int v3 = a1;
  return a1;
}

int putchar(int a1)
{
  int v4 = __stdoutp;
  flockfile(__stdoutp);
  int v1 = v4->_w - 1;
  v4->_w = v1;
  if (v1 < 0 && (v4->_w < v4->_lbfsize || (char)a1 == 10))
  {
    int v6 = __swbuf(a1, v4);
  }
  else
  {
    int v2 = v4->_p++;
    *int v2 = a1;
    int v6 = a1;
  }
  funlockfile(v4);
  return v6;
}

int putchar_unlocked(int a1)
{
  int v4 = __stdoutp;
  int v1 = __stdoutp->_w - 1;
  __stdoutp->_w = v1;
  if (v1 < 0 && (v4->_w < v4->_lbfsize || (char)a1 == 10)) {
    return __swbuf(a1, v4);
  }
  int v2 = v4->_p++;
  *int v2 = a1;
  return a1;
}

int puts(const char *a1)
{
  int v7 = a1;
  int v6 = 0;
  size_t v5 = 0;
  int v3 = 0;
  uint64_t v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a1);
  if (!v7) {
    int v7 = "(null)";
  }
  v8[0] = v7;
  size_t v5 = strlen(v7);
  v8[1] = v5;
  unsigned char v8[2] = "\n";
  v8[3] = 1;
  HIDWORD(v4) = v5 + 1;
  int v3 = v8;
  LODWORD(v4) = 2;
  flockfile(__stdoutp);
  if (!((char)(32 * *((unsigned char *)&stru_20.fileoff + *(void *)&stru_68.sectname[(void)__stdoutp])) >> 5)) {
    *((unsigned char *)&stru_20.fileoff + *(void *)&stru_68.sectname[(void)__stdoutp]) = *((unsigned char *)&stru_20.fileoff
  }
                                                                                     + *(void *)&stru_68.sectname[(void)__stdoutp]) & 0xF8 | 7;
  if (__sfvwrite((uint64_t)__stdoutp, &v3)) {
    int v1 = -1;
  }
  else {
    int v1 = 10;
  }
  int v6 = v1;
  funlockfile(__stdoutp);
  return v6;
}

int putw(int a1, FILE *a2)
{
  int v7 = a1;
  int v6 = a2;
  int v5 = 0;
  v3[0] = &v7;
  v3[1] = 4;
  v4[0] = v3;
  v4[1] = 0x400000001;
  flockfile(a2);
  int v5 = __sfvwrite((uint64_t)v6, v4);
  funlockfile(v6);
  return v5;
}

wint_t putwc(__int32 a1, FILE *a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return fputwc_l(a1, a2, v7);
  }
  else {
    return fputwc_l(a1, a2, (locale_t)__global_locale);
  }
}

wint_t putwc_l(__int32 a1, FILE *a2, locale_t a3)
{
  return fputwc_l(a1, a2, a3);
}

wint_t putwchar(__int32 a1)
{
  int v5 = __stdoutp;
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    int v6 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v7 = __locale_key;
    int v6 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6) {
    return fputwc_l(a1, v5, v6);
  }
  else {
    return fputwc_l(a1, v5, (locale_t)__global_locale);
  }
}

wint_t putwchar_l(__int32 a1, locale_t a2)
{
  return fputwc_l(a1, __stdoutp, a2);
}

uint64_t __srefill0(uint64_t a1)
{
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  if (!((char)(32 * *(unsigned char *)(*(void *)(a1 + 104) + 72)) >> 5)) {
    *(unsigned char *)(*(void *)(a1 + 104) + 72) = *(unsigned char *)(*(void *)(a1 + 104) + 72) & 0xF8 | 7;
  }
  *(_DWORD *)(a1 + 8) = 0;
  if ((*(_WORD *)(a1 + 16) & 0x20) != 0)
  {
    return -1;
  }
  else
  {
    if ((*(_WORD *)(a1 + 16) & 4) != 0)
    {
      if (*(void *)(a1 + 88))
      {
        if (*(void *)(a1 + 88) != a1 + 116) {
          free(*(void **)(a1 + 88));
        }
        *(void *)(a1 + 88) = 0;
        int v1 = *(_DWORD *)(a1 + 112);
        *(_DWORD *)(a1 + 8) = v1;
        if (v1)
        {
          *(void *)a1 = **(void **)(a1 + 104);
          return 0;
        }
      }
    }
    else
    {
      if ((*(_WORD *)(a1 + 16) & 0x10) == 0)
      {
        *__error() = 9;
        *(_WORD *)(a1 + 16) |= 0x40u;
        return -1;
      }
      if ((*(_WORD *)(a1 + 16) & 8) != 0)
      {
        if (__sflush(a1)) {
          return -1;
        }
        *(_WORD *)(a1 + 16) &= ~8u;
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 40) = 0;
      }
      *(_WORD *)(a1 + 16) |= 4u;
    }
    if (!*(void *)(a1 + 24)) {
      __smakebuf(a1);
    }
    if ((*(_WORD *)(a1 + 16) & 3) != 0)
    {
      *(_WORD *)(a1 + 16) |= 0x8000u;
      _fwalk((uint64_t (*)(uint64_t *))lflush);
      *(_WORD *)(a1 + 16) &= ~0x8000u;
      if ((*(_WORD *)(a1 + 16) & 9) == 9) {
        __sflush(a1);
      }
    }
    return 1;
  }
}

uint64_t lflush(FILE *a1)
{
  unsigned int v2 = 0;
  if ((a1->_flags & 9) == 9)
  {
    flockfile(a1);
    unsigned int v2 = __sflush((uint64_t)a1);
    funlockfile(a1);
  }
  return v2;
}

uint64_t __srefill1(uint64_t a1)
{
  *(void *)a1 = *(void *)(a1 + 24);
  *(_DWORD *)(a1 + 8) = _sread(a1, *(void *)a1, *(_DWORD *)(a1 + 32));
  *(_WORD *)(a1 + 16) &= ~0x2000u;
  if (*(int *)(a1 + 8) > 0)
  {
    return 0;
  }
  else
  {
    if (*(_DWORD *)(a1 + 8))
    {
      *(_DWORD *)(a1 + 8) = 0;
      *(_WORD *)(a1 + 16) |= 0x40u;
    }
    else
    {
      *(_WORD *)(a1 + 16) |= 0x20u;
    }
    return -1;
  }
}

uint64_t __srefill(uint64_t a1)
{
  int v2 = __srefill0(a1);
  if (v2 > 0) {
    return __srefill1(a1);
  }
  else {
    return v2;
  }
}

int remove(const char *a1)
{
  char v3 = a1;
  memset(&__b, 0, sizeof(__b));
  if (lstat(v3, &__b) < 0) {
    return -1;
  }
  if ((__b.st_mode & 0xF000) == 0x4000) {
    return rmdir(v3);
  }
  return unlink(v3);
}

void rewind(FILE *a1)
{
  int v1 = *__error();
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  flockfile(a1);
  if (!_fseeko((uint64_t)a1, 0, 0, 1)) {
    *__error() = v1;
  }
  a1->_flags &= 0xFF9Fu;
  funlockfile(a1);
}

int __srget(FILE *a1)
{
  if (__srefill((uint64_t)a1)) {
    return -1;
  }
  --a1->_r;
  int v1 = a1->_p++;
  return *v1;
}

int scanf(const char *a1, ...)
{
  va_start(va, a1);
  flockfile(__stdinp);
  int v5 = (int *)__stdinp;
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    uint64_t v8 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    uint64_t v8 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    int v3 = __svfscanf_l(v5, v8, (unsigned __int8 *)a1, (uint64_t *)va);
  }
  else {
    int v3 = __svfscanf_l(v5, (_xlocale *)__global_locale, (unsigned __int8 *)a1, (uint64_t *)va);
  }
  int v6 = v3;
  funlockfile(__stdinp);
  return v6;
}

int scanf_l(locale_t a1, const char *a2, ...)
{
  va_start(va, a2);
  int v5 = a1;
  if (a1)
  {
    if (a1 == (locale_t)-1) {
      int v5 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    int v5 = (_xlocale *)&__c_locale;
  }
  flockfile(__stdinp);
  int v3 = __svfscanf_l((int *)__stdinp, v5, (unsigned __int8 *)a2, (uint64_t *)va);
  funlockfile(__stdinp);
  return v3;
}

void setbuf(FILE *a1, char *a2)
{
  if (a2) {
    int v2 = 0;
  }
  else {
    int v2 = 2;
  }
  setvbuf(a1, a2, v2, 0x400uLL);
}

void setbuffer(FILE *a1, char *a2, int a3)
{
  if (a2) {
    int v3 = 0;
  }
  else {
    int v3 = 2;
  }
  setvbuf(a1, a2, v3, a3);
}

int setlinebuf(FILE *a1)
{
  return setvbuf(a1, 0, 1, 0);
}

int setvbuf(FILE *a1, char *a2, int a3, size_t a4)
{
  int v15 = a1;
  BOOL v14 = (unsigned __int8 *)a2;
  unsigned int v13 = a3;
  size_t v12 = a4;
  int v11 = 0;
  int flags = 0;
  size_t v9 = 0;
  int v8 = 0;
  if (a3 != 2 && (v13 > 1 || (v12 & 0x80000000) != 0)) {
    return -1;
  }
  libc_hooks_will_write((uint64_t)v15, 152);
  libc_hooks_will_write((uint64_t)v14, v12);
  flockfile(v15);
  int v11 = 0;
  __sflush((uint64_t)v15);
  if (v15->_ub._base)
  {
    if (v15->_ub._base != v15->_ubuf) {
      free(v15->_ub._base);
    }
    v15->_ub._base = 0;
  }
  v15->_lbfint size = 0;
  v15->_size_t r = 0;
  int flags = v15->_flags;
  if ((flags & 0x80u) != 0) {
    free(v15->_bf._base);
  }
  flags &= 0xFFFFE35C;
  if (v13 == 2)
  {
LABEL_19:
    v15->_int flags = flags | 2;
    v15->_w = 0;
    nunint64_t buf = v15->_nbuf;
    v15->_p = v15->_nbuf;
    v15->_bf._base = nbuf;
    v15->_bf._int size = 1;
    funlockfile(v15);
    return v11;
  }
  int v4 = __swhatbuf((uint64_t)v15, &v9, &v8);
  flags |= v4;
  if (!v12)
  {
    BOOL v14 = 0;
    size_t v12 = v9;
  }
  if (!v14)
  {
    BOOL v14 = (unsigned __int8 *)malloc_type_malloc();
    if (!v14)
    {
      int v11 = -1;
      if (v12 != v9)
      {
        size_t v12 = v9;
        BOOL v14 = (unsigned __int8 *)malloc_type_malloc();
      }
    }
    if (!v14) {
      goto LABEL_19;
    }
    flags |= 0x80u;
  }
  if (v12 != v9) {
    flags |= 0x800u;
  }
  if (v13 == 1) {
    flags |= 1u;
  }
  v15->_int flags = flags;
  int v6 = v14;
  v15->_p = v14;
  v15->_bf._base = v6;
  v15->_bf._int size = v12;
  if ((flags & 8) != 0)
  {
    if (flags)
    {
      v15->_w = 0;
      v15->_lbfint size = -v15->_bf._size;
    }
    else
    {
      v15->_w = v12;
    }
  }
  else
  {
    v15->_w = 0;
  }
  __cleanup = 1;
  funlockfile(v15);
  return v11;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  va_start(va, __format);
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    size_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    size_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return vsnprintf_l(__str, __size, v9, __format, va);
  }
  else {
    return vsnprintf_l(__str, __size, (locale_t)__global_locale, __format, va);
  }
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  va_start(va, a4);
  return vsnprintf_l(a1, a2, a3, a4, va);
}

int sprintf(char *a1, const char *a2, ...)
{
  va_start(va, a2);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    uint64_t v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return vsprintf_l(a1, v7, a2, va);
  }
  else {
    return vsprintf_l(a1, (locale_t)&__global_locale, a2, va);
  }
}

int sprintf_l(char *a1, locale_t a2, const char *a3, ...)
{
  va_start(va, a3);
  return vsprintf_l(a1, a2, a3, va);
}

int sscanf(const char *a1, const char *a2, ...)
{
  va_start(va, a2);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    uint64_t v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return vsscanf_l(a1, v7, a2, va);
  }
  else {
    return vsscanf_l(a1, (locale_t)__global_locale, a2, va);
  }
}

int sscanf_l(const char *a1, locale_t a2, const char *a3, ...)
{
  va_start(va, a3);
  return vsscanf_l(a1, a2, a3, va);
}

uint64_t __sread()
{
  return read_NOCANCEL();
}

uint64_t __swrite()
{
  return write_NOCANCEL();
}

off_t __sseek(uint64_t a1, off_t a2, int a3)
{
  return lseek(*(__int16 *)(a1 + 18), a2, a3);
}

uint64_t __sclose()
{
  return close_NOCANCEL();
}

uint64_t _sread(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v4 = (*(uint64_t (**)(void, uint64_t, void))(a1 + 64))(*(void *)(a1 + 48), a2, a3);
  if (v4 <= 0)
  {
    if (v4 < 0) {
      *(_WORD *)(a1 + 16) &= ~0x1000u;
    }
  }
  else if ((*(_WORD *)(a1 + 16) & 0x1000) != 0)
  {
    if (*(void *)(a1 + 144) > 0x7FFFFFFFFFFFFFFFLL - v4) {
      *(_WORD *)(a1 + 16) &= ~0x1000u;
    }
    else {
      *(void *)(a1 + 144) += v4;
    }
  }
  return v4;
}

uint64_t _swrite(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if ((*(_WORD *)(a1 + 16) & 0x100) != 0)
  {
    int v4 = *__error();
    if (_sseek(a1, 0, 2u) == -1 && (*(_WORD *)(a1 + 16) & 0x400) != 0) {
      return -1;
    }
    *__error() = v4;
  }
  int v5 = (*(uint64_t (**)(void, uint64_t, void))(a1 + 80))(*(void *)(a1 + 48), a2, a3);
  if (v5 < 0)
  {
    *(_WORD *)(a1 + 16) &= ~0x1000u;
  }
  else if ((*(_WORD *)(a1 + 16) & 0x1100) == 0x1100 && *(void *)(a1 + 144) <= 0x7FFFFFFFFFFFFFFFLL - v5)
  {
    *(void *)(a1 + 144) += v5;
  }
  else
  {
    *(_WORD *)(a1 + 16) &= ~0x1000u;
  }
  return v5;
}

uint64_t _sseek(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v5 = *__error();
  *__error() = 0;
  uint64_t v6 = (*(uint64_t (**)(void, uint64_t, void))(a1 + 72))(*(void *)(a1 + 48), a2, a3);
  int v4 = *__error();
  if (!*__error()) {
    *__error() = v5;
  }
  if (v6 >= 0)
  {
    if ((*(_WORD *)(a1 + 16) & 0x400) != 0)
    {
      *(_WORD *)(a1 + 16) |= 0x1000u;
      *(void *)(a1 + 144) = v6;
    }
  }
  else
  {
    if (v4)
    {
      if (v4 == 29) {
        *(_WORD *)(a1 + 16) &= ~0x100u;
      }
    }
    else
    {
      if (a2 || a3 != 1)
      {
        if (*(void *)(a1 + 88))
        {
          if (*(void *)(a1 + 88) != a1 + 116) {
            free(*(void **)(a1 + 88));
          }
          *(void *)(a1 + 88) = 0;
        }
        *(void *)a1 = *(void *)(a1 + 24);
        *(_DWORD *)(a1 + 8) = 0;
        *(_WORD *)(a1 + 16) &= ~0x20u;
      }
      *(_WORD *)(a1 + 16) |= 0x40u;
      *__error() = 22;
    }
    *(_WORD *)(a1 + 16) &= ~0x1000u;
    return -1;
  }
  return v6;
}

int swprintf(__int32 *a1, size_t a2, const __int32 *a3, ...)
{
  va_start(va, a3);
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    size_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    size_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return vswprintf_l(a1, a2, v9, a3, va);
  }
  else {
    return vswprintf_l(a1, a2, (locale_t)__global_locale, a3, va);
  }
}

int swprintf_l(__int32 *a1, size_t n, locale_t a3, const __int32 *a4, ...)
{
  va_start(va, a4);
  return vswprintf_l(a1, n, a3, a4, va);
}

int swscanf(const __int32 *a1, const __int32 *a2, ...)
{
  va_start(va, a2);
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    uint64_t v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return vswscanf_l(a1, v7, a2, va);
  }
  else {
    return vswscanf_l(a1, (locale_t)__global_locale, a2, va);
  }
}

int swscanf_l(const __int32 *a1, locale_t a2, const __int32 *a3, ...)
{
  va_start(va, a3);
  return vswscanf_l(a1, a2, a3, va);
}

char *__cdecl tempnam(const char *__dir, const char *__prefix)
{
  libc_hooks_will_read_cstring((uint64_t)__dir);
  libc_hooks_will_read_cstring((uint64_t)__prefix);
  int v5 = (char *)malloc_type_malloc();
  if (!v5) {
    return 0;
  }
  if (!__prefix) {
    __prefix = "tmp.";
  }
  if (__dir && !access(__dir, 2))
  {
    char v2 = __dir[strlen(__dir) - 1] == 47 ? (const char *)&unk_D793D : "/";
    snprintf(v5, 0x400uLL, "%s%s%sXXXXXX", __dir, v2, __prefix);
    uint64_t v6 = _mktemp(v5);
    if (v6) {
      return v6;
    }
  }
  if (!access("/var/tmp/", 2))
  {
    snprintf(v5, 0x400uLL, "%s%sXXXXXX", "/var/tmp/", __prefix);
    uint64_t v7 = _mktemp(v5);
    if (v7) {
      return v7;
    }
  }
  if (!issetugid())
  {
    uint64_t v8 = getenv("TMPDIR");
    if (v8)
    {
      if (!access(v8, 2))
      {
        char v3 = v8[strlen(v8) - 1] == 47 ? (const char *)&unk_D793D : "/";
        snprintf(v5, 0x400uLL, "%s%s%sXXXXXX", v8, v3, __prefix);
        size_t v9 = _mktemp(v5);
        if (v9) {
          return v9;
        }
      }
    }
  }
  snprintf(v5, 0x400uLL, "%s%sXXXXXX", "/tmp/", __prefix);
  uint64_t v10 = _mktemp(v5);
  if (v10) {
    return v10;
  }
  int v11 = *__error();
  free(v5);
  *__error() = v11;
  return 0;
}

FILE *tmpfile(void)
{
  sigset_t v10 = 0;
  sigset_t v9 = 0;
  uint64_t v8 = 0;
  int v7 = 0;
  int v6 = 0;
  int v5 = 0;
  __s = 0;
  if (!issetugid()) {
    __s = getenv("TMPDIR");
  }
  if (!__s) {
    __s = "/tmp/";
  }
  if (!*__s) {
    return 0;
  }
  size_t v0 = strlen(__s);
  char v1 = (const char *)&unk_D793D;
  if (__s[v0 - 1] != 47) {
    char v1 = "/";
  }
  asprintf(&v5, "%s%s%s", __s, v1, "tmp.XXXXXX");
  if (!v5) {
    return 0;
  }
  sigset_t v10 = -1;
  sigprocmask(1, &v10, &v9);
  int v7 = mkstemp(v5);
  if (v7 != -1) {
    unlink(v5);
  }
  free(v5);
  sigprocmask(3, &v9, 0);
  if (v7 == -1) {
    return 0;
  }
  uint64_t v8 = fdopen(v7, "w+");
  if (v8) {
    return v8;
  }
  int v6 = *__error();
  close_NOCANCEL();
  int v3 = v6;
  *__error() = v3;
  return 0;
}

char *__cdecl tmpnam(char *a1)
{
  char v2 = a1;
  if (a1) {
    goto LABEL_6;
  }
  if (!pthread_once(&tmpnam_buf_control, (void (*)(void))tmpnam_buf_allocate) && tmpnam_buf)
  {
    char v2 = (char *)tmpnam_buf;
LABEL_6:
    libc_hooks_will_write((uint64_t)v2, 1024);
    snprintf(v2, 0x400uLL, "%stmp.%lu.XXXXXX", "/var/tmp/", tmpnam_tmpcount);
    ++tmpnam_tmpcount;
    return _mktemp(v2);
  }
  return 0;
}

uint64_t tmpnam_buf_allocate()
{
  uint64_t result = malloc_type_malloc();
  tmpnam_unint64_t buf = result;
  return result;
}

int ungetc(int a1, FILE *a2)
{
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  flockfile(a2);
  if (!((char)(32 * *((unsigned char *)a2->_extra + 72)) >> 5)) {
    *((unsigned char *)a2->_extra + 72) = *((unsigned char *)a2->_extra + 72) & 0xF8 | 7;
  }
  int v3 = __ungetc(a1, (uint64_t)a2);
  funlockfile(a2);
  return v3;
}

uint64_t __ungetc(int a1, uint64_t a2)
{
  unsigned __int8 v5 = a1;
  if (a1 == -1)
  {
    return -1;
  }
  else
  {
    if ((*(_WORD *)(a2 + 16) & 4) == 0)
    {
      if ((*(_WORD *)(a2 + 16) & 0x10) == 0) {
        return -1;
      }
      if ((*(_WORD *)(a2 + 16) & 8) != 0)
      {
        if (__sflush(a2)) {
          return -1;
        }
        *(_WORD *)(a2 + 16) &= ~8u;
        *(_DWORD *)(a2 + 12) = 0;
        *(_DWORD *)(a2 + 40) = 0;
      }
      *(_WORD *)(a2 + 16) |= 4u;
    }
    if (*(void *)(a2 + 88))
    {
      if (*(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 96) && __submore(a2))
      {
        return -1;
      }
      else
      {
        char v2 = (unsigned __int8 *)(*(void *)a2 - 1);
        *(void *)a2 = v2;
        *char v2 = v5;
        ++*(_DWORD *)(a2 + 8);
        return v5;
      }
    }
    else
    {
      *(_WORD *)(a2 + 16) &= ~0x20u;
      if (*(void *)(a2 + 24)
        && *(void *)a2 > *(void *)(a2 + 24)
        && *(unsigned __int8 *)(*(void *)a2 - 1) == v5)
      {
        --*(void *)a2;
        ++*(_DWORD *)(a2 + 8);
        return v5;
      }
      else
      {
        *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 8);
        **(void **)(a2 + 104) = *(void *)a2;
        *(void *)(a2 + 88) = a2 + 116;
        *(_DWORD *)(a2 + 96) = 3;
        *(unsigned char *)(a2 + 118) = v5;
        *(void *)a2 = a2 + 118;
        *(_DWORD *)(a2 + 8) = 1;
        return v5;
      }
    }
  }
}

uint64_t __submore(uint64_t a1)
{
  if (*(void *)(a1 + 88) == a1 + 116)
  {
    uint64_t __src = (char *)malloc_type_malloc();
    if (__src)
    {
      *(void *)(a1 + 88) = __src;
      *(_DWORD *)(a1 + 96) = 1024;
      __srca = __src + 1021;
      for (__signed int n = 3; --__n >= 0; __srca[__n] = *(unsigned char *)(a1 + 116 + __n))
        ;
      *(void *)a1 = __srca;
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    int __na = *(_DWORD *)(a1 + 96);
    __srcb = (char *)malloc_type_realloc();
    if (__srcb)
    {
      memcpy(&__srcb[__na], __srcb, __na);
      *(void *)a1 = &__srcb[__na];
      *(void *)(a1 + 88) = __srcb;
      *(_DWORD *)(a1 + 96) = 2 * __na;
      return 0;
    }
    else
    {
      return -1;
    }
  }
}

uint64_t __ungetwc(unsigned int a1, uint64_t a2, uint64_t a3)
{
  unsigned int v9 = a1;
  uint64_t v8 = a2;
  uint64_t v7 = a3;
  if (a1 == -1)
  {
    return -1;
  }
  else
  {
    uint64_t v5 = (*(uint64_t (**)(unsigned char *, void, uint64_t, uint64_t))(*(void *)(v7 + 1328) + 96))(v6, v9, *(void *)(v8 + 104) + 80, v7);
    if (v5 == -1)
    {
      *(_WORD *)(v8 + 16) |= 0x40u;
      return -1;
    }
    else
    {
      while (v5--)
      {
        if (__ungetc(v6[v5], v8) == -1) {
          return -1;
        }
      }
      return v9;
    }
  }
}

wint_t ungetwc(wint_t a1, FILE *a2)
{
  flockfile(a2);
  if ((char)(32 * *((unsigned char *)a2->_extra + 72)) >> 5)
  {
    char v2 = 0;
  }
  else
  {
    *((unsigned char *)a2->_extra + 72) = *((unsigned char *)a2->_extra + 72) & 0xF8 | 1;
    char v2 = 1;
  }
  if (v2)
  {
    uint64_t v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    uint64_t v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    wint_t v3 = __ungetwc(a1, (uint64_t)a2, (uint64_t)v8);
  }
  else {
    wint_t v3 = __ungetwc(a1, (uint64_t)a2, (uint64_t)__global_locale);
  }
  wint_t v5 = v3;
  funlockfile(a2);
  return v5;
}

wint_t ungetwc_l(wint_t a1, FILE *a2, locale_t a3)
{
  locale_t v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      locale_t v5 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v5 = (locale_t)&__c_locale;
  }
  flockfile(a2);
  if (!((char)(32 * *((unsigned char *)a2->_extra + 72)) >> 5)) {
    *((unsigned char *)a2->_extra + 72) = *((unsigned char *)a2->_extra + 72) & 0xF8 | 1;
  }
  wint_t v4 = __ungetwc(a1, (uint64_t)a2, (uint64_t)v5);
  funlockfile(a2);
  return v4;
}

uint64_t _vasprintf(uint64_t a1, pthread_rwlock_t *a2, void *a3, _xlocale *a4, char *a5, int *a6)
{
  uint64_t v14 = a1;
  unsigned int v13 = a2;
  size_t v12 = a3;
  int v11 = a4;
  sigset_t v10 = a5;
  uint64_t v9 = a6;
  int v8 = 0;
  memset(__b, 0, sizeof(__b));
  memset(v17, 0, sizeof(v17));
  void __b[13] = v17;
  v17[0] = 0;
  memset(v16, 0, sizeof(v16));
  v16[0] = 850045858;
  memcpy(&v17[1], v16, 0x40uLL);
  LOBYTE(v17[9]) &= 0xF8u;
  memset(&v17[10], 0, 0x80uLL);
  LOBYTE(v17[9]) &= ~8u;
  LODWORD(__b[2]) = -48632;
  __b[0] = malloc_type_malloc();
  __b[3] = __b[0];
  if (__b[0])
  {
    HIDWORD(__b[1]) = 127;
    LODWORD(__b[4]) = 127;
    *(unsigned char *)(__b[13] + 72) &= 0xF8u;
    memset((void *)(__b[13] + 80), 0, 0x80uLL);
    int v8 = __v2printf(v14, v13, (uint64_t)__b, v11, v10, v9);
    if (v8 >= 0)
    {
      *(unsigned char *)__b[0] = 0;
      *size_t v12 = __b[3];
      return v8;
    }
    else
    {
      free((void *)__b[3]);
      *size_t v12 = 0;
      *__error() = 12;
      return -1;
    }
  }
  else
  {
    *size_t v12 = 0;
    *__error() = 12;
    return -1;
  }
}

int vasprintf_l(char **a1, locale_t a2, const char *a3, va_list a4)
{
  return _vasprintf(-1, 0, a1, a2, (char *)a3, (int *)a4);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    uint64_t v9 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    uint64_t v9 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return _vasprintf(-1, 0, a1, v9, a2, a3);
  }
  else {
    return _vasprintf(-1, 0, a1, &__global_locale, a2, a3);
  }
}

uint64_t _vdprintf(uint64_t a1, pthread_rwlock_t *a2, int a3, _xlocale *a4, char *a5, int *a6)
{
  uint64_t v15 = a1;
  uint64_t v14 = a2;
  int v13 = a3;
  size_t v12 = a4;
  int v11 = a5;
  uint64_t v10 = a6;
  memset(__b, 0, sizeof(__b));
  memset(v18, 0, sizeof(v18));
  void __b[13] = v18;
  v18[0] = 0;
  memset(v17, 0, sizeof(v17));
  v17[0] = 850045858;
  memcpy(&v18[1], v17, 0x40uLL);
  LOBYTE(v18[9]) &= 0xF8u;
  memset(&v18[10], 0, 0x80uLL);
  LOBYTE(v18[9]) &= ~8u;
  if (v13 < 0x8000)
  {
    __b[0] = v19;
    HIDWORD(__b[1]) = 1024;
    LOWORD(__b[2]) = 8;
    WORD1(__b[2]) = v13;
    void __b[6] = __b;
    __b[10] = __swrite;
    __b[3] = v19;
    LODWORD(__b[4]) = 1024;
    *(unsigned char *)(__b[13] + 72) &= 0xF8u;
    memset((void *)(__b[13] + 80), 0, 0x80uLL);
    int v8 = __v2printf(v15, v14, (uint64_t)__b, v12, v11, v10);
    if (v8 >= 0)
    {
      if (__fflush((uint64_t)__b)) {
        return -1;
      }
      else {
        return v8;
      }
    }
    else
    {
      return v8;
    }
  }
  else
  {
    *__error() = 24;
    return -1;
  }
}

int vdprintf_l(int a1, locale_t a2, const char *a3, va_list a4)
{
  return _vdprintf(-1, 0, a1, a2, (char *)a3, (int *)a4);
}

int vdprintf(int a1, const char *a2, va_list a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    uint64_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    uint64_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return _vdprintf(-1, 0, a1, v9, (char *)a2, (int *)a3);
  }
  else {
    return _vdprintf(-1, 0, a1, (_xlocale *)__global_locale, (char *)a2, (int *)a3);
  }
}

int vfprintf_l(FILE *a1, locale_t a2, const char *a3, va_list a4)
{
  libc_hooks_will_write((uint64_t)a1, 152);
  flockfile(a1);
  int v5 = __xvprintf(-1, 0, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4);
  funlockfile(a1);
  return v5;
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  libc_hooks_will_write((uint64_t)a1, 152);
  flockfile(a1);
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v11 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    int v11 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    int v5 = __xvprintf(-1, 0, (uint64_t)a1, (uint64_t)v11, (uint64_t)a2, (uint64_t)a3);
  }
  else {
    int v5 = __xvprintf(-1, 0, (uint64_t)a1, (uint64_t)&__global_locale, (uint64_t)a2, (uint64_t)a3);
  }
  int v7 = v5;
  funlockfile(a1);
  return v7;
}

BOOL __printf_is_memory_read_only(vm_address_t a1, vm_address_t a2)
{
  unsigned char v8[2] = a1;
  v8[1] = a2;
  v8[0] = a1;
  vm_size_t v7 = 0;
  memset(__b, 0, sizeof(__b));
  mach_msg_type_number_t infoCnt = 9;
  mach_port_t object_name = 0;
  BOOL v3 = 0;
  if (!vm_region_64(mach_task_self_, v8, &v7, 9, __b, &infoCnt, &object_name)) {
    return (__b[0] & 2) == 0;
  }
  return v3;
}

uint64_t __vfprintf(uint64_t a1, _xlocale *a2, char *a3, int *a4)
{
  uint64_t v319 = a1;
  locale_t v318 = a2;
  v317 = a3;
  v316 = a4;
  int v314 = 0;
  uint64_t v313 = 0;
  uint64_t v312 = 0;
  __s1 = 0;
  int v310 = 0;
  uint64_t v309 = 0;
  uint64_t v308 = 0;
  __signed int n = 0;
  char v306 = 0;
  uint64_t v305 = 0;
  long long v304 = 0u;
  long long v303 = 0u;
  BOOL only = 0;
  __s = 0;
  int v300 = 0;
  int v299 = 0;
  double v298 = 0.0;
  int v297 = 0;
  char v296 = 0;
  unint64_t v295 = 0;
  int v294 = 0;
  int v293 = 0;
  v292 = 0;
  long long v291 = 0uLL;
  unint64_t v290 = 0;
  char v289 = 0;
  int64_t v288 = 0;
  int64_t v287 = 0;
  int v286 = 0;
  int v285 = 0;
  int64_t v284 = 0;
  int64_t v283 = 0;
  uint64_t v282 = 0;
  v281 = 0;
  uint64_t v280 = 0;
  memset(v279, 0, sizeof(v279));
  v274 = 0;
  v315 = a3;
  *(void *)&v276[4] = 0;
  *(_DWORD *)v276 = 1;
  v275 = a4;
  io_init((uint64_t)v279, a1);
  uint64_t v309 = 0;
  v292 = 0;
  __s = localeconv_l(v318)->decimal_point;
  if (__s[1]) {
    int v196 = strlen(__s);
  }
  else {
    int v196 = 1;
  }
  int v300 = v196;
  while (1)
  {
LABEL_5:
    __s1 = v315;
    while (1)
    {
      int v314 = *v315;
      BOOL v195 = 0;
      if (v314) {
        BOOL v195 = v314 != 37;
      }
      if (!v195) {
        break;
      }
      ++v315;
    }
    uint64_t v313 = v315 - __s1;
    if (v315 != __s1)
    {
      if (v309 + v313 >= 0x7FFFFFFF) {
        goto LABEL_12;
      }
      if (io_print((uint64_t)v279, (uint64_t)__s1, v313, (uint64_t)v318)) {
        goto LABEL_656;
      }
      v309 += v313;
    }
    if (!v314) {
      break;
    }
    unint64_t v290 = (unint64_t)v315++;
    int v310 = 0;
    int v285 = 0;
    uint64_t v308 = 0;
    __signed int n = -1;
    *(void *)&long long v304 = 0;
    char v306 = 0;
    char v278 = 0;
    char v289 = 88;
    while (2)
    {
      char v4 = v315++;
      int v314 = *v4;
LABEL_18:
      switch(v314)
      {
        case ' ':
          if (!v306) {
            char v306 = 32;
          }
          continue;
        case '#':
          v310 |= 1u;
          continue;
        case '\'':
          v310 |= 0x200u;
          continue;
        case '*':
          uint64_t v312 = 0;
          for (__s1 = v315; (*__s1 - 48) <= 9; ++__s1)
            uint64_t v312 = 10 * v312 + *__s1 - 48;
          if (*__s1 == 36)
          {
            int v273 = *(_DWORD *)v276;
            if (!*(void *)&v276[4])
            {
              *(void *)&v276[4] = v322;
              if (__find_arguments(v317, v275, (uint64_t *)&v276[4]))
              {
                uint64_t v309 = -1;
                goto LABEL_656;
              }
            }
            *(_DWORD *)v276 = v312;
            if (*(void *)&v276[4])
            {
              uint64_t v5 = *(int *)v276;
              ++*(_DWORD *)v276;
              int v194 = *(_DWORD *)(*(void *)&v276[4] + 16 * v5);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              int v6 = v316;
              v316 += 2;
              int v272 = *v6;
              int v194 = v272;
            }
            uint64_t v308 = v194;
            *(_DWORD *)v276 = v273;
            v315 = ++__s1;
          }
          else
          {
            if (*(void *)&v276[4])
            {
              uint64_t v7 = *(int *)v276;
              ++*(_DWORD *)v276;
              int v193 = *(_DWORD *)(*(void *)&v276[4] + 16 * v7);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              int v8 = v316;
              v316 += 2;
              int v271 = *v8;
              int v193 = v271;
            }
            uint64_t v308 = v193;
          }
          if (v308 < 0)
          {
            uint64_t v308 = -v308;
LABEL_41:
            v310 |= 4u;
          }
          continue;
        case '+':
          char v306 = 43;
          continue;
        case ',':
        case ':':
        case ';':
        case '_':
          char v289 = v314;
          continue;
        case '-':
          goto LABEL_41;
        case '.':
          uint64_t v9 = v315++;
          int v314 = *v9;
          if (v314 != 42)
          {
            __signed int n = 0;
            while ((v314 - 48) <= 9)
            {
              __signed int n = 10 * __n + v314 - 48;
              uint64_t v14 = v315++;
              int v314 = *v14;
            }
            goto LABEL_18;
          }
          uint64_t v312 = 0;
          for (__s1 = v315; (*__s1 - 48) <= 9; ++__s1)
            uint64_t v312 = 10 * v312 + *__s1 - 48;
          if (*__s1 == 36)
          {
            int v270 = *(_DWORD *)v276;
            if (!*(void *)&v276[4])
            {
              *(void *)&v276[4] = v322;
              if (__find_arguments(v317, v275, (uint64_t *)&v276[4]))
              {
                uint64_t v309 = -1;
                goto LABEL_656;
              }
            }
            *(_DWORD *)v276 = v312;
            if (*(void *)&v276[4])
            {
              uint64_t v10 = *(int *)v276;
              ++*(_DWORD *)v276;
              int v192 = *(_DWORD *)(*(void *)&v276[4] + 16 * v10);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              int v11 = v316;
              v316 += 2;
              int v269 = *v11;
              int v192 = v269;
            }
            __signed int n = v192;
            *(_DWORD *)v276 = v270;
            v315 = ++__s1;
          }
          else
          {
            if (*(void *)&v276[4])
            {
              uint64_t v12 = *(int *)v276;
              ++*(_DWORD *)v276;
              int v191 = *(_DWORD *)(*(void *)&v276[4] + 16 * v12);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              int v13 = v316;
              v316 += 2;
              int v268 = *v13;
              int v191 = v268;
            }
            __signed int n = v191;
          }
          continue;
        case '0':
          v310 |= 0x80u;
          continue;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          uint64_t v313 = 0;
          do
          {
            uint64_t v313 = 10 * v313 + v314 - 48;
            uint64_t v15 = v315++;
            int v314 = *v15;
          }
          while ((v314 - 48) < 0xA);
          if (v314 != 36)
          {
            uint64_t v308 = v313;
            goto LABEL_18;
          }
          *(_DWORD *)v276 = v313;
          if (!*(void *)&v276[4])
          {
            *(void *)&v276[4] = v322;
            if (__find_arguments(v317, v275, (uint64_t *)&v276[4]))
            {
              uint64_t v309 = -1;
              goto LABEL_656;
            }
          }
          continue;
        case 'A':
        case 'a':
          if ((v310 & 0x4000) != 0)
          {
            v310 |= 0x100u;
            goto LABEL_466;
          }
          if (v314 == 97)
          {
            char v278 = 120;
            v281 = &__vfprintf_xdigs_lower;
            char v296 = 112;
          }
          else
          {
            char v278 = 88;
            v281 = &__vfprintf_xdigs_upper;
            char v296 = 80;
          }
          if ((__n & 0x8000000000000000) == 0) {
            ++__n;
          }
          if (v292) {
            __freedtoa((uint64_t)v292);
          }
          if ((v310 & 8) != 0)
          {
            if (*(void *)&v276[4])
            {
              uint64_t v36 = *(int *)v276;
              ++*(_DWORD *)v276;
              double v174 = *(double *)(*(void *)&v276[4] + 16 * v36);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              unsigned int v37 = (double *)v316;
              v316 += 2;
              double v256 = *v37;
              double v174 = v256;
            }
            double v298 = v174;
            __s1 = (char *)__hldtoa((uint64_t)v281, __n, &v297, &v299, &v295, v174);
            v292 = __s1;
          }
          else
          {
            if (*(void *)&v276[4])
            {
              uint64_t v38 = *(int *)v276;
              ++*(_DWORD *)v276;
              double v173 = *(double *)(*(void *)&v276[4] + 16 * v38);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              int v39 = (double *)v316;
              v316 += 2;
              double v255 = *v39;
              double v173 = v255;
            }
            double v298 = v173;
            __s1 = (char *)__hdtoa((uint64_t)v281, __n, &v297, &v299, &v295, v173);
            v292 = __s1;
          }
          if ((__n & 0x8000000000000000) != 0) {
            __signed int n = v295 - (void)__s1;
          }
          if (v297 == 0x7FFFFFFF) {
            char v278 = 0;
          }
          goto LABEL_204;
        case 'C':
          v310 |= 0x10u;
          goto LABEL_85;
        case 'D':
          v310 |= 0x10u;
          goto LABEL_99;
        case 'E':
        case 'e':
          if ((v310 & 0x4000) != 0)
          {
            v310 |= 0x100u;
            goto LABEL_466;
          }
          char v296 = v314;
          if ((__n & 0x8000000000000000) != 0) {
            __signed int n = 7;
          }
          else {
            ++__n;
          }
          goto LABEL_184;
        case 'F':
        case 'f':
          if ((v310 & 0x4000) != 0)
          {
            v310 |= 0x100u;
            goto LABEL_466;
          }
          char v296 = 0;
          goto LABEL_184;
        case 'G':
        case 'g':
          if ((v310 & 0x4000) != 0)
          {
            v310 |= 0x100u;
          }
          else
          {
            char v296 = v314 - 2;
            if (!__n) {
              __signed int n = 1;
            }
LABEL_184:
            if ((__n & 0x8000000000000000) != 0) {
              __signed int n = 6;
            }
            if (v292) {
              __freedtoa((uint64_t)v292);
            }
            if ((v310 & 8) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v40 = *(int *)v276;
                ++*(_DWORD *)v276;
                double v172 = *(double *)(*(void *)&v276[4] + 16 * v40);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                int v41 = (double *)v316;
                v316 += 2;
                double v254 = *v41;
                double v172 = v254;
              }
              double v298 = v172;
              if (v296) {
                int v42 = 2;
              }
              else {
                int v42 = 3;
              }
              __s1 = (char *)__ldtoa(&v298, v42, __n, &v297, &v299, &v295);
              v292 = __s1;
            }
            else
            {
              if (*(void *)&v276[4])
              {
                uint64_t v43 = *(int *)v276;
                ++*(_DWORD *)v276;
                double v171 = *(double *)(*(void *)&v276[4] + 16 * v43);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                uint64_t v44 = (double *)v316;
                v316 += 2;
                double v253 = *v44;
                double v171 = v253;
              }
              double v298 = v171;
              if (v296) {
                int v45 = 2;
              }
              else {
                int v45 = 3;
              }
              __s1 = (char *)__dtoa(v45, __n, &v297, &v299, &v295, v171);
              v292 = __s1;
              if (v297 == 9999) {
                int v297 = 0x7FFFFFFF;
              }
            }
LABEL_204:
            if (v299) {
              char v306 = 45;
            }
            if (v297 == 0x7FFFFFFF)
            {
              if (*__s1 == 78)
              {
                uint64_t v46 = "nan";
                if (v314 <= 96) {
                  uint64_t v46 = "NAN";
                }
                __s1 = v46;
                char v306 = 0;
              }
              else
              {
                int v47 = "inf";
                if (v314 <= 96) {
                  int v47 = "INF";
                }
                __s1 = v47;
              }
              int64_t v283 = 3;
              v310 &= ~0x80u;
            }
            else
            {
              v310 |= 0x100u;
              int v293 = v295 - __s1;
              if (v314 == 103 || v314 == 71)
              {
                if (v297 < -3 || v297 > (uint64_t)__n)
                {
                  if ((v310 & 1) == 0) {
                    __signed int n = v293;
                  }
                }
                else
                {
                  char v296 = 0;
                  if (v310) {
                    __n -= v297;
                  }
                  else {
                    __signed int n = v293 - v297;
                  }
                  if ((__n & 0x8000000000000000) != 0) {
                    __signed int n = 0;
                  }
                }
              }
              if (v296)
              {
                int v294 = exponent(v324, v297 - 1, v296);
                int64_t v283 = v294 + __n;
                if (uint64_t)__n > 1 || (v310) {
                  v283 += v300;
                }
              }
              else
              {
                if (v297 < 1) {
                  int64_t v283 = 1;
                }
                else {
                  int64_t v283 = v297;
                }
                if (__n || (v310 & 1) != 0) {
                  v283 += __n + v300;
                }
                if ((v310 & 0x200) != 0 && v297 >= 1)
                {
                  int v48 = grouping_init((uint64_t)&v303, v297, v318);
                  v283 += v48;
                }
              }
            }
          }
          goto LABEL_466;
        case 'L':
          v310 |= 8u;
          continue;
        case 'O':
          v310 |= 0x10u;
          goto LABEL_266;
        case 'S':
          v310 |= 0x10u;
          goto LABEL_319;
        case 'U':
          v310 |= 0x10u;
          goto LABEL_340;
        case 'X':
          v281 = &__vfprintf_xdigs_upper;
          goto LABEL_389;
        case 'c':
LABEL_85:
          if ((v310 & 0x4000) != 0) {
            goto LABEL_466;
          }
          if ((v310 & 0x10) != 0)
          {
            size_t v267 = 0;
            memset(&v321, 0, sizeof(v321));
            __s1 = v323;
            if (*(void *)&v276[4])
            {
              uint64_t v16 = *(int *)v276;
              ++*(_DWORD *)v276;
              __int32 v190 = *(_DWORD *)(*(void *)&v276[4] + 16 * v16);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              int v17 = v316;
              v316 += 2;
              __int32 v266 = *v17;
              __int32 v190 = v266;
            }
            size_t v267 = wcrtomb_l(v323, v190, &v321, v318);
            if (v267 == -1)
            {
              *(_WORD *)(v319 + 16) |= 0x40u;
              goto LABEL_656;
            }
            int64_t v283 = (int)v267;
          }
          else
          {
            if (*(void *)&v276[4])
            {
              uint64_t v18 = *(int *)v276;
              ++*(_DWORD *)v276;
              int v189 = *(_DWORD *)(*(void *)&v276[4] + 16 * v18);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              int v19 = v316;
              v316 += 2;
              int v265 = *v19;
              LOBYTE(v189) = v265;
            }
            __s1 = v323;
            v323[0] = v189;
            int64_t v283 = 1;
          }
          char v306 = 0;
          goto LABEL_466;
        case 'd':
        case 'i':
LABEL_99:
          if ((v310 & 0x4000) != 0) {
            goto LABEL_466;
          }
          if ((v310 & 0x1C20) != 0)
          {
            if ((v310 & 0x1000) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v20 = *(int *)v276;
                ++*(_DWORD *)v276;
                int64_t v188 = *(void *)(*(void *)&v276[4] + 16 * v20);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                int v21 = (int64_t *)v316;
                v316 += 2;
                int64_t v264 = *v21;
                int64_t v188 = v264;
              }
              int64_t v187 = v188;
            }
            else
            {
              if ((v310 & 0x400) != 0)
              {
                if (*(void *)&v276[4])
                {
                  uint64_t v22 = *(int *)v276;
                  ++*(_DWORD *)v276;
                  int64_t v186 = *(void *)(*(void *)&v276[4] + 16 * v22);
                }
                else
                {
                  *(void *)v276 = (*(_DWORD *)v276 + 1);
                  unsigned int v23 = (int64_t *)v316;
                  v316 += 2;
                  int64_t v263 = *v23;
                  int64_t v186 = v263;
                }
                int64_t v185 = v186;
              }
              else
              {
                if ((v310 & 0x800) != 0)
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v24 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int64_t v184 = *(void *)(*(void *)&v276[4] + 16 * v24);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    unint64_t v25 = (uint64_t *)v316;
                    v316 += 2;
                    uint64_t v262 = *v25;
                    int64_t v184 = v262;
                  }
                  int64_t v183 = v184;
                }
                else
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v26 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int64_t v182 = *(void *)(*(void *)&v276[4] + 16 * v26);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    long double v27 = (uint64_t *)v316;
                    v316 += 2;
                    uint64_t v261 = *v27;
                    int64_t v182 = v261;
                  }
                  int64_t v183 = v182;
                }
                int64_t v185 = v183;
              }
              int64_t v187 = v185;
            }
            int64_t v287 = v187;
            if (v187 < 0)
            {
              int64_t v287 = -v287;
              char v306 = 45;
            }
          }
          else
          {
            if ((v310 & 0x10) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v28 = *(int *)v276;
                ++*(_DWORD *)v276;
                int64_t v181 = *(void *)(*(void *)&v276[4] + 16 * v28);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                int v29 = (int64_t *)v316;
                v316 += 2;
                int64_t v260 = *v29;
                int64_t v181 = v260;
              }
              int64_t v180 = v181;
            }
            else
            {
              if ((v310 & 0x40) != 0)
              {
                if (*(void *)&v276[4])
                {
                  uint64_t v30 = *(int *)v276;
                  ++*(_DWORD *)v276;
                  int v179 = *(_DWORD *)(*(void *)&v276[4] + 16 * v30);
                }
                else
                {
                  *(void *)v276 = (*(_DWORD *)v276 + 1);
                  double v31 = v316;
                  v316 += 2;
                  int v259 = *v31;
                  LOWORD(v179) = v259;
                }
                int64_t v178 = (__int16)v179;
              }
              else
              {
                if ((v310 & 0x2000) != 0)
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v32 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int v177 = *(_DWORD *)(*(void *)&v276[4] + 16 * v32);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    uint64_t v33 = v316;
                    v316 += 2;
                    int v258 = *v33;
                    LOBYTE(v177) = v258;
                  }
                  int64_t v176 = (char)v177;
                }
                else
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v34 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int v175 = *(_DWORD *)(*(void *)&v276[4] + 16 * v34);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v35 = v316;
                    v316 += 2;
                    int v257 = *v35;
                    int v175 = v257;
                  }
                  int64_t v176 = v175;
                }
                int64_t v178 = v176;
              }
              int64_t v180 = v178;
            }
            int64_t v288 = v180;
            if (v180 < 0)
            {
              int64_t v288 = -v288;
              char v306 = 45;
            }
          }
          int v286 = 10;
          goto LABEL_443;
        case 'h':
          if ((v310 & 0x40) != 0)
          {
            v310 &= ~0x40u;
            v310 |= 0x2000u;
          }
          else
          {
            v310 |= 0x40u;
          }
          continue;
        case 'j':
          v310 |= 0x1000u;
          continue;
        case 'l':
          if ((v310 & 0x10) != 0)
          {
            v310 &= ~0x10u;
            v310 |= 0x20u;
          }
          else
          {
            v310 |= 0x10u;
          }
          continue;
        case 'n':
          v252 = 0;
          if (*(void *)&v276[4])
          {
            uint64_t v49 = *(int *)v276;
            ++*(_DWORD *)v276;
            uint64_t v170 = *(void *)(*(void *)&v276[4] + 16 * v49);
          }
          else
          {
            *(void *)v276 = (*(_DWORD *)v276 + 1);
            v50 = (uint64_t *)v316;
            v316 += 2;
            uint64_t v251 = *v50;
            uint64_t v170 = v251;
          }
          v252 = (uint64_t *)v170;
          if (v170)
          {
            if (!only)
            {
              vm_address_t v51 = strlen(v317);
              BOOL only = __printf_is_memory_read_only((vm_address_t)v317, v51);
            }
            if (!only)
            {
              _os_crash((uint64_t)"%%n used in a non-immutable format string");
              __break(1u);
              JUMPOUT(0x72D54);
            }
            if ((v310 & 0x20) != 0)
            {
              uint64_t v250 = v309;
              v249 = v252;
              libc_hooks_will_write((uint64_t)v252, 8);
              uint64_t *v249 = v250;
            }
            else if ((v310 & 0x400) != 0)
            {
              uint64_t v248 = v309;
              v247 = v252;
              libc_hooks_will_write((uint64_t)v252, 8);
              uint64_t *v247 = v248;
            }
            else if ((v310 & 0x800) != 0)
            {
              uint64_t v246 = v309;
              v245 = v252;
              libc_hooks_will_write((uint64_t)v252, 8);
              uint64_t *v245 = v246;
            }
            else if ((v310 & 0x1000) != 0)
            {
              uint64_t v244 = v309;
              v243 = v252;
              libc_hooks_will_write((uint64_t)v252, 8);
              uint64_t *v243 = v244;
            }
            else if ((v310 & 0x10) != 0)
            {
              uint64_t v242 = v309;
              v241 = v252;
              libc_hooks_will_write((uint64_t)v252, 8);
              uint64_t *v241 = v242;
            }
            else if ((v310 & 0x40) != 0)
            {
              __int16 v240 = v309;
              v239 = v252;
              libc_hooks_will_write((uint64_t)v252, 2);
              *(_WORD *)v239 = v240;
            }
            else if ((v310 & 0x2000) != 0)
            {
              char v238 = v309;
              v237 = v252;
              libc_hooks_will_write((uint64_t)v252, 1);
              *(unsigned char *)v237 = v238;
            }
            else
            {
              int v236 = v309;
              v235 = v252;
              libc_hooks_will_write((uint64_t)v252, 4);
              *(_DWORD *)v235 = v236;
            }
          }
          goto LABEL_5;
        case 'o':
LABEL_266:
          if ((v310 & 0x4000) != 0) {
            goto LABEL_466;
          }
          if ((v310 & 0x1C20) != 0)
          {
            if ((v310 & 0x1000) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v52 = *(int *)v276;
                ++*(_DWORD *)v276;
                int64_t v169 = *(void *)(*(void *)&v276[4] + 16 * v52);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                int v53 = (int64_t *)v316;
                v316 += 2;
                int64_t v234 = *v53;
                int64_t v169 = v234;
              }
              int64_t v168 = v169;
            }
            else
            {
              if ((v310 & 0x400) != 0)
              {
                if (*(void *)&v276[4])
                {
                  uint64_t v54 = *(int *)v276;
                  ++*(_DWORD *)v276;
                  int64_t v167 = *(void *)(*(void *)&v276[4] + 16 * v54);
                }
                else
                {
                  *(void *)v276 = (*(_DWORD *)v276 + 1);
                  int v55 = (int64_t *)v316;
                  v316 += 2;
                  int64_t v233 = *v55;
                  int64_t v167 = v233;
                }
                int64_t v166 = v167;
              }
              else
              {
                if ((v310 & 0x800) != 0)
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v56 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int64_t v165 = *(void *)(*(void *)&v276[4] + 16 * v56);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v57 = (uint64_t *)v316;
                    v316 += 2;
                    uint64_t v232 = *v57;
                    int64_t v165 = v232;
                  }
                  int64_t v164 = v165;
                }
                else
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v58 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int64_t v163 = *(void *)(*(void *)&v276[4] + 16 * v58);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    __int32 v59 = (uint64_t *)v316;
                    v316 += 2;
                    uint64_t v231 = *v59;
                    int64_t v163 = v231;
                  }
                  int64_t v164 = v163;
                }
                int64_t v166 = v164;
              }
              int64_t v168 = v166;
            }
            int64_t v287 = v168;
          }
          else
          {
            if ((v310 & 0x10) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v60 = *(int *)v276;
                ++*(_DWORD *)v276;
                int64_t v162 = *(void *)(*(void *)&v276[4] + 16 * v60);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                uint64_t v61 = (int64_t *)v316;
                v316 += 2;
                int64_t v230 = *v61;
                int64_t v162 = v230;
              }
              int64_t v161 = v162;
            }
            else
            {
              if ((v310 & 0x40) != 0)
              {
                if (*(void *)&v276[4])
                {
                  uint64_t v62 = *(int *)v276;
                  ++*(_DWORD *)v276;
                  int v160 = *(_DWORD *)(*(void *)&v276[4] + 16 * v62);
                }
                else
                {
                  *(void *)v276 = (*(_DWORD *)v276 + 1);
                  size_t v63 = v316;
                  v316 += 2;
                  int v229 = *v63;
                  LOWORD(v160) = v229;
                }
                int64_t v159 = (unsigned __int16)v160;
              }
              else
              {
                if ((v310 & 0x2000) != 0)
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v64 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int v158 = *(_DWORD *)(*(void *)&v276[4] + 16 * v64);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v65 = v316;
                    v316 += 2;
                    int v228 = *v65;
                    LOBYTE(v158) = v228;
                  }
                  int64_t v157 = v158;
                }
                else
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v66 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    unsigned int v156 = *(_DWORD *)(*(void *)&v276[4] + 16 * v66);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v67 = (unsigned int *)v316;
                    v316 += 2;
                    unsigned int v227 = *v67;
                    unsigned int v156 = v227;
                  }
                  int64_t v157 = v156;
                }
                int64_t v159 = v157;
              }
              int64_t v161 = v159;
            }
            int64_t v288 = v161;
          }
          int v286 = 8;
          goto LABEL_442;
        case 'p':
          if ((v310 & 0x4000) != 0) {
            goto LABEL_466;
          }
          if (*(void *)&v276[4])
          {
            uint64_t v68 = *(int *)v276;
            ++*(_DWORD *)v276;
            int64_t v155 = *(void *)(*(void *)&v276[4] + 16 * v68);
          }
          else
          {
            *(void *)v276 = (*(_DWORD *)v276 + 1);
            uint64_t v69 = (int64_t *)v316;
            v316 += 2;
            int64_t v226 = *v69;
            int64_t v155 = v226;
          }
          int64_t v287 = v155;
          int v286 = 16;
          v281 = &__vfprintf_xdigs_lower;
          v310 |= 0x1000u;
          char v278 = 120;
          goto LABEL_442;
        case 'q':
          v310 |= 0x20u;
          continue;
        case 's':
LABEL_319:
          if ((v310 & 0x10) != 0)
          {
            v225 = 0;
            free(v274);
            if (*(void *)&v276[4])
            {
              uint64_t v70 = *(int *)v276;
              ++*(_DWORD *)v276;
              v154 = *(const __int32 **)(*(void *)&v276[4] + 16 * v70);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              uint64_t v71 = (const __int32 **)v316;
              v316 += 2;
              v224 = *v71;
              v154 = v224;
            }
            v225 = v154;
            if (v154)
            {
              v274 = __wcsconv(v225, __n, v318);
              if (!v274)
              {
                *(_WORD *)(v319 + 16) |= 0x40u;
                goto LABEL_656;
              }
              __s1 = (char *)v274;
            }
            else
            {
              v274 = 0;
              __s1 = "(null)";
            }
          }
          else
          {
            if (*(void *)&v276[4])
            {
              uint64_t v72 = *(int *)v276;
              ++*(_DWORD *)v276;
              v153 = *(char **)(*(void *)&v276[4] + 16 * v72);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              uint64_t v73 = (char **)v316;
              v316 += 2;
              v223 = *v73;
              v153 = v223;
            }
            __s1 = v153;
            if (!v153) {
              __s1 = "(null)";
            }
          }
          size_t v222 = 0;
          if ((__n & 0x8000000000000000) != 0) {
            size_t v152 = strlen(__s1);
          }
          else {
            size_t v152 = strnlen(__s1, __n);
          }
          size_t v222 = v152;
          if (v152 > 0x7FFFFFFE)
          {
            uint64_t v309 = -1;
            goto LABEL_656;
          }
          int64_t v283 = v222;
          libc_hooks_will_read((uint64_t)__s1, v222);
          char v306 = 0;
LABEL_466:
          if ((v310 & 0x4000) != 0)
          {
            int i = 0;
            int v204 = 0;
            int v203 = 0;
            v202 = 0;
            int v201 = 0;
            int v200 = 0;
            v199 = 0;
            int v198 = 0;
            if (*(void *)&v276[4])
            {
              uint64_t v107 = *(int *)v276;
              ++*(_DWORD *)v276;
              long long v123 = *(_OWORD *)(*(void *)&v276[4] + 16 * v107);
            }
            else
            {
              *(void *)v276 = (*(_DWORD *)v276 + 1);
              v108 = (_OWORD *)(((unint64_t)v316 + 15) & 0xFFFFFFFFFFFFFFF0);
              v316 = (int *)(v108 + 1);
              long long v123 = *v108;
            }
            long long v291 = v123;
            if ((unint64_t)&v315[~v290 + 2] > 0x21) {
              v202 = (char *)malloc_type_malloc();
            }
            else {
              v202 = v320;
            }
            if (v289 == 88)
            {
              if (v314 == 99) {
                char v289 = 0;
              }
              else {
                char v289 = 32;
              }
            }
            int v204 = 0;
            for (int i = 0; i < (uint64_t)&v315[~v290]; ++i)
            {
              switch(*(unsigned char *)(v290 + i))
              {
                case '*':
                  if (*(unsigned char *)(v290 + i - 1) == 46) {
                    int v200 = 1;
                  }
                  else {
                    int v201 = 1;
                  }
                  goto LABEL_483;
                case ',':
                case ':':
                case ';':
                case '_':
                case 'h':
                case 'l':
                case 'v':
                  continue;
                default:
LABEL_483:
                  char v109 = *(unsigned char *)(v290 + i);
                  uint64_t v110 = v204++;
                  v202[v110] = v109;
                  break;
              }
            }
            if ((v310 & 0x40) != 0)
            {
              if (v314 == 99)
              {
                int v197 = 1;
              }
              else if (v314 == 112)
              {
                int v197 = 4;
              }
              else
              {
                uint64_t v111 = v204++;
                v202[v111] = 104;
                int v197 = 1;
              }
              int v203 = 8;
              goto LABEL_513;
            }
            if ((v310 & 0x10) != 0)
            {
              int v203 = 4;
              if (v314 == 112) {
                int v112 = 5;
              }
              else {
                int v112 = 2;
              }
              int v197 = v112;
              goto LABEL_513;
            }
            if (v314 != 65 && v314 != 69 && v314 != 71)
            {
              if (v314 == 88) {
                goto LABEL_508;
              }
              if (v314 != 97)
              {
                if (v314 == 99) {
                  goto LABEL_509;
                }
                if (v314 == 100) {
                  goto LABEL_508;
                }
                if ((v314 - 101) >= 3)
                {
                  if (v314 != 112)
                  {
LABEL_508:
                    uint64_t v113 = v204++;
                    v202[v113] = 104;
                    uint64_t v114 = v204++;
                    v202[v114] = 104;
                  }
LABEL_509:
                  int v203 = 16;
                  if (v314 == 112) {
                    int v115 = 3;
                  }
                  else {
                    int v115 = 0;
                  }
                  int v197 = v115;
                  goto LABEL_513;
                }
              }
            }
            int v203 = 4;
            int v197 = 6;
LABEL_513:
            uint64_t v116 = v204++;
            v202[v116] = v314;
            uint64_t v117 = v204++;
            v202[v117] = 0;
            if (v201)
            {
              if (v200)
              {
                switch(v197)
                {
                  case 0:
                  case 3:
                    int v198 = asprintf_l(&v199, v318, v202, v308, __n, v291);
                    break;
                  case 1:
                  case 4:
                    int v198 = asprintf_l(&v199, v318, v202, v308, __n, (unsigned __int16)v291);
                    break;
                  case 2:
                  case 5:
                    int v198 = asprintf_l(&v199, v318, v202, v308, __n, v291);
                    break;
                  case 6:
                    int v198 = asprintf_l(&v199, v318, v202, v308, __n, *(float *)&v291);
                    break;
                  default:
                    break;
                }
                v309 += v198;
                if (io_print((uint64_t)v279, (uint64_t)v199, v198, (uint64_t)v318)
                  || io_flush((uint64_t)v279, (uint64_t)v318))
                {
                  goto LABEL_656;
                }
                free(v199);
                for (int i = 1; i < v203; ++i)
                {
                  if (v289 && io_print((uint64_t)v279, (uint64_t)&v289, 1, (uint64_t)v318)) {
                    goto LABEL_656;
                  }
                  switch(v197)
                  {
                    case 0:
                    case 3:
                      int v198 = asprintf_l(&v199, v318, v202, v308, __n, *((unsigned __int8 *)&v291 + i));
                      break;
                    case 1:
                    case 4:
                      int v198 = asprintf_l(&v199, v318, v202, v308, __n, *((unsigned __int16 *)&v291 + i));
                      break;
                    case 2:
                    case 5:
                      int v198 = asprintf_l(&v199, v318, v202, v308, __n, *((unsigned int *)&v291 + i));
                      break;
                    case 6:
                      int v198 = asprintf_l(&v199, v318, v202, v308, __n, *((float *)&v291 + i));
                      break;
                    default:
                      break;
                  }
                  v309 += v198;
                  if (io_print((uint64_t)v279, (uint64_t)v199, v198, (uint64_t)v318)
                    || io_flush((uint64_t)v279, (uint64_t)v318))
                  {
                    goto LABEL_656;
                  }
                  free(v199);
                }
              }
              else
              {
                switch(v197)
                {
                  case 0:
                  case 3:
                    int v198 = asprintf_l(&v199, v318, v202, v308, v291);
                    break;
                  case 1:
                  case 4:
                    int v198 = asprintf_l(&v199, v318, v202, v308, (unsigned __int16)v291);
                    break;
                  case 2:
                  case 5:
                    int v198 = asprintf_l(&v199, v318, v202, v308, v291);
                    break;
                  case 6:
                    int v198 = asprintf_l(&v199, v318, v202, v308, *(float *)&v291);
                    break;
                  default:
                    break;
                }
                v309 += v198;
                if (io_print((uint64_t)v279, (uint64_t)v199, v198, (uint64_t)v318)
                  || io_flush((uint64_t)v279, (uint64_t)v318))
                {
                  goto LABEL_656;
                }
                free(v199);
                for (int i = 1; i < v203; ++i)
                {
                  if (v289 && io_print((uint64_t)v279, (uint64_t)&v289, 1, (uint64_t)v318)) {
                    goto LABEL_656;
                  }
                  switch(v197)
                  {
                    case 0:
                    case 3:
                      int v198 = asprintf_l(&v199, v318, v202, v308, *((unsigned __int8 *)&v291 + i));
                      break;
                    case 1:
                    case 4:
                      int v198 = asprintf_l(&v199, v318, v202, v308, *((unsigned __int16 *)&v291 + i));
                      break;
                    case 2:
                    case 5:
                      int v198 = asprintf_l(&v199, v318, v202, v308, *((unsigned int *)&v291 + i));
                      break;
                    case 6:
                      int v198 = asprintf_l(&v199, v318, v202, v308, *((float *)&v291 + i));
                      break;
                    default:
                      break;
                  }
                  v309 += v198;
                  if (io_print((uint64_t)v279, (uint64_t)v199, v198, (uint64_t)v318)
                    || io_flush((uint64_t)v279, (uint64_t)v318))
                  {
                    goto LABEL_656;
                  }
                  free(v199);
                }
              }
            }
            else if (v200)
            {
              switch(v197)
              {
                case 0:
                case 3:
                  int v198 = asprintf_l(&v199, v318, v202, __n, v291);
                  break;
                case 1:
                case 4:
                  int v198 = asprintf_l(&v199, v318, v202, __n, (unsigned __int16)v291);
                  break;
                case 2:
                case 5:
                  int v198 = asprintf_l(&v199, v318, v202, __n, v291);
                  break;
                case 6:
                  int v198 = asprintf_l(&v199, v318, v202, __n, *(float *)&v291);
                  break;
                default:
                  break;
              }
              v309 += v198;
              if (io_print((uint64_t)v279, (uint64_t)v199, v198, (uint64_t)v318)
                || io_flush((uint64_t)v279, (uint64_t)v318))
              {
                goto LABEL_656;
              }
              free(v199);
              for (int i = 1; i < v203; ++i)
              {
                if (v289 && io_print((uint64_t)v279, (uint64_t)&v289, 1, (uint64_t)v318)) {
                  goto LABEL_656;
                }
                switch(v197)
                {
                  case 0:
                  case 3:
                    int v198 = asprintf_l(&v199, v318, v202, __n, *((unsigned __int8 *)&v291 + i));
                    break;
                  case 1:
                  case 4:
                    int v198 = asprintf_l(&v199, v318, v202, __n, *((unsigned __int16 *)&v291 + i));
                    break;
                  case 2:
                  case 5:
                    int v198 = asprintf_l(&v199, v318, v202, __n, *((unsigned int *)&v291 + i));
                    break;
                  case 6:
                    int v198 = asprintf_l(&v199, v318, v202, __n, *((float *)&v291 + i));
                    break;
                  default:
                    break;
                }
                v309 += v198;
                if (io_print((uint64_t)v279, (uint64_t)v199, v198, (uint64_t)v318)
                  || io_flush((uint64_t)v279, (uint64_t)v318))
                {
                  goto LABEL_656;
                }
                free(v199);
              }
            }
            else
            {
              switch(v197)
              {
                case 0:
                case 3:
                  int v198 = asprintf_l(&v199, v318, v202, v291);
                  break;
                case 1:
                case 4:
                  int v198 = asprintf_l(&v199, v318, v202, (unsigned __int16)v291);
                  break;
                case 2:
                case 5:
                  int v198 = asprintf_l(&v199, v318, v202, v291);
                  break;
                case 6:
                  int v198 = asprintf_l(&v199, v318, v202, *(float *)&v291);
                  break;
                default:
                  break;
              }
              v309 += v198;
              if (io_print((uint64_t)v279, (uint64_t)v199, v198, (uint64_t)v318)
                || io_flush((uint64_t)v279, (uint64_t)v318))
              {
                goto LABEL_656;
              }
              free(v199);
              for (int i = 1; i < v203; ++i)
              {
                if (v289 && io_print((uint64_t)v279, (uint64_t)&v289, 1, (uint64_t)v318)) {
                  goto LABEL_656;
                }
                switch(v197)
                {
                  case 0:
                  case 3:
                    int v198 = asprintf_l(&v199, v318, v202, *((unsigned __int8 *)&v291 + i));
                    break;
                  case 1:
                  case 4:
                    int v198 = asprintf_l(&v199, v318, v202, *((unsigned __int16 *)&v291 + i));
                    break;
                  case 2:
                  case 5:
                    int v198 = asprintf_l(&v199, v318, v202, *((unsigned int *)&v291 + i));
                    break;
                  case 6:
                    int v198 = asprintf_l(&v199, v318, v202, *((float *)&v291 + i));
                    break;
                  default:
                    break;
                }
                v309 += v198;
                if (io_print((uint64_t)v279, (uint64_t)v199, v198, (uint64_t)v318)
                  || io_flush((uint64_t)v279, (uint64_t)v318))
                {
                  goto LABEL_656;
                }
                free(v199);
              }
            }
            if (v202 != v320) {
              free(v202);
            }
            goto LABEL_5;
          }
          if (v285 <= v283) {
            int64_t v122 = v283;
          }
          else {
            int64_t v122 = v285;
          }
          int64_t v284 = v122;
          if (v306) {
            ++v284;
          }
          if (v278) {
            v284 += 2;
          }
          if (v308 <= v284) {
            uint64_t v121 = v284;
          }
          else {
            uint64_t v121 = v308;
          }
          uint64_t v282 = v121;
          if (v309 + v121 >= 0x7FFFFFFF)
          {
LABEL_12:
            uint64_t v309 = -1;
            *__error() = 84;
            goto LABEL_656;
          }
          if ((v310 & 0x84) == 0
            && io_pad((uint64_t)v279, (int)v308 - (int)v284, (uint64_t)&blanks, (uint64_t)v318))
          {
            goto LABEL_656;
          }
          if (v306 && io_print((uint64_t)v279, (uint64_t)&v306, 1, (uint64_t)v318)) {
            goto LABEL_656;
          }
          if (v278)
          {
            char v277 = 48;
            if (io_print((uint64_t)v279, (uint64_t)&v277, 2, (uint64_t)v318)) {
              goto LABEL_656;
            }
          }
          if ((v310 & 0x84) == 0x80
            && io_pad((uint64_t)v279, (int)v308 - (int)v284, (uint64_t)&zeroes, (uint64_t)v318))
          {
            goto LABEL_656;
          }
          if ((v310 & 0x100) != 0)
          {
            if (v296)
            {
              if (uint64_t)__n > 1 || (v310)
              {
                v118 = __s1++;
                if (io_print((uint64_t)v279, (uint64_t)v118, 1, (uint64_t)v318)
                  || io_print((uint64_t)v279, (uint64_t)__s, v300, (uint64_t)v318)
                  || io_print((uint64_t)v279, (uint64_t)__s1, v293 - 1, (uint64_t)v318)
                  || io_pad((uint64_t)v279, (int)__n - v293, (uint64_t)&zeroes, (uint64_t)v318))
                {
                  goto LABEL_656;
                }
              }
              else if (io_print((uint64_t)v279, (uint64_t)__s1, 1, (uint64_t)v318))
              {
                goto LABEL_656;
              }
              if (io_print((uint64_t)v279, (uint64_t)v324, v294, (uint64_t)v318)) {
                goto LABEL_656;
              }
            }
            else
            {
              if (v297 > 0)
              {
                if ((void)v304)
                {
                  uint64_t v313 = (int)grouping_print((uint64_t)&v303, (uint64_t)v279, (uint64_t)__s1, v295, (uint64_t)v318);
                  if (v313 < 0) {
                    goto LABEL_656;
                  }
                  __s1 += v313;
                }
                else
                {
                  if (io_printandpad((uint64_t)v279, (uint64_t)__s1, v295, v297, (uint64_t)&zeroes, (uint64_t)v318))goto LABEL_656; {
                  __s1 += v297;
                  }
                }
                if (__n || (v310)
                  && io_print((uint64_t)v279, (uint64_t)__s, v300, (uint64_t)v318))
                {
                  goto LABEL_656;
                }
              }
              else
              {
                if (io_print((uint64_t)v279, (uint64_t)&zeroes, 1, (uint64_t)v318)
                  || (__n || (v310 & 1) != 0)
                  && io_print((uint64_t)v279, (uint64_t)__s, v300, (uint64_t)v318)
                  || io_pad((uint64_t)v279, -v297, (uint64_t)&zeroes, (uint64_t)v318))
                {
                  goto LABEL_656;
                }
                __n += v297;
              }
              if (io_printandpad((uint64_t)v279, (uint64_t)__s1, v295, __n, (uint64_t)&zeroes, (uint64_t)v318))goto LABEL_656; {
            }
              }
          }
          else
          {
            if (io_pad((uint64_t)v279, v285 - (int)v283, (uint64_t)&zeroes, (uint64_t)v318)) {
              goto LABEL_656;
            }
            if ((void)v304)
            {
              if ((grouping_print((uint64_t)&v303, (uint64_t)v279, (uint64_t)__s1, (unint64_t)v324, (uint64_t)v318) & 0x80000000) != 0) {
                goto LABEL_656;
              }
            }
            else if (io_print((uint64_t)v279, (uint64_t)__s1, v283, (uint64_t)v318))
            {
              goto LABEL_656;
            }
          }
          if ((v310 & 4) != 0
            && io_pad((uint64_t)v279, (int)v308 - (int)v284, (uint64_t)&blanks, (uint64_t)v318))
          {
            goto LABEL_656;
          }
          v309 += v282;
          if (io_flush((uint64_t)v279, (uint64_t)v318)) {
            goto LABEL_656;
          }
          break;
        case 't':
          v310 |= 0x800u;
          continue;
        case 'u':
LABEL_340:
          if ((v310 & 0x4000) != 0) {
            goto LABEL_466;
          }
          if ((v310 & 0x1C20) != 0)
          {
            if ((v310 & 0x1000) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v74 = *(int *)v276;
                ++*(_DWORD *)v276;
                int64_t v151 = *(void *)(*(void *)&v276[4] + 16 * v74);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                int v75 = (int64_t *)v316;
                v316 += 2;
                int64_t v221 = *v75;
                int64_t v151 = v221;
              }
              int64_t v150 = v151;
            }
            else
            {
              if ((v310 & 0x400) != 0)
              {
                if (*(void *)&v276[4])
                {
                  uint64_t v76 = *(int *)v276;
                  ++*(_DWORD *)v276;
                  int64_t v149 = *(void *)(*(void *)&v276[4] + 16 * v76);
                }
                else
                {
                  *(void *)v276 = (*(_DWORD *)v276 + 1);
                  int v77 = (int64_t *)v316;
                  v316 += 2;
                  int64_t v220 = *v77;
                  int64_t v149 = v220;
                }
                int64_t v148 = v149;
              }
              else
              {
                if ((v310 & 0x800) != 0)
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v78 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int64_t v147 = *(void *)(*(void *)&v276[4] + 16 * v78);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v79 = (uint64_t *)v316;
                    v316 += 2;
                    uint64_t v219 = *v79;
                    int64_t v147 = v219;
                  }
                  int64_t v146 = v147;
                }
                else
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v80 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int64_t v145 = *(void *)(*(void *)&v276[4] + 16 * v80);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v81 = (uint64_t *)v316;
                    v316 += 2;
                    uint64_t v218 = *v81;
                    int64_t v145 = v218;
                  }
                  int64_t v146 = v145;
                }
                int64_t v148 = v146;
              }
              int64_t v150 = v148;
            }
            int64_t v287 = v150;
          }
          else
          {
            if ((v310 & 0x10) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v82 = *(int *)v276;
                ++*(_DWORD *)v276;
                int64_t v144 = *(void *)(*(void *)&v276[4] + 16 * v82);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                int v83 = (int64_t *)v316;
                v316 += 2;
                int64_t v217 = *v83;
                int64_t v144 = v217;
              }
              int64_t v143 = v144;
            }
            else
            {
              if ((v310 & 0x40) != 0)
              {
                if (*(void *)&v276[4])
                {
                  uint64_t v84 = *(int *)v276;
                  ++*(_DWORD *)v276;
                  int v142 = *(_DWORD *)(*(void *)&v276[4] + 16 * v84);
                }
                else
                {
                  *(void *)v276 = (*(_DWORD *)v276 + 1);
                  int v85 = v316;
                  v316 += 2;
                  int v216 = *v85;
                  LOWORD(v142) = v216;
                }
                int64_t v141 = (unsigned __int16)v142;
              }
              else
              {
                if ((v310 & 0x2000) != 0)
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v86 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int v140 = *(_DWORD *)(*(void *)&v276[4] + 16 * v86);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v87 = v316;
                    v316 += 2;
                    int v215 = *v87;
                    LOBYTE(v140) = v215;
                  }
                  int64_t v139 = v140;
                }
                else
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v88 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    unsigned int v138 = *(_DWORD *)(*(void *)&v276[4] + 16 * v88);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v89 = (unsigned int *)v316;
                    v316 += 2;
                    unsigned int v214 = *v89;
                    unsigned int v138 = v214;
                  }
                  int64_t v139 = v138;
                }
                int64_t v141 = v139;
              }
              int64_t v143 = v141;
            }
            int64_t v288 = v143;
          }
          int v286 = 10;
          goto LABEL_442;
        case 'v':
          v310 |= 0x4000u;
          continue;
        case 'x':
          v281 = &__vfprintf_xdigs_lower;
LABEL_389:
          if ((v310 & 0x4000) != 0) {
            goto LABEL_466;
          }
          if ((v310 & 0x1C20) != 0)
          {
            if ((v310 & 0x1000) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v90 = *(int *)v276;
                ++*(_DWORD *)v276;
                int64_t v137 = *(void *)(*(void *)&v276[4] + 16 * v90);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                int v91 = (int64_t *)v316;
                v316 += 2;
                int64_t v213 = *v91;
                int64_t v137 = v213;
              }
              int64_t v136 = v137;
            }
            else
            {
              if ((v310 & 0x400) != 0)
              {
                if (*(void *)&v276[4])
                {
                  uint64_t v92 = *(int *)v276;
                  ++*(_DWORD *)v276;
                  int64_t v135 = *(void *)(*(void *)&v276[4] + 16 * v92);
                }
                else
                {
                  *(void *)v276 = (*(_DWORD *)v276 + 1);
                  int v93 = (int64_t *)v316;
                  v316 += 2;
                  int64_t v212 = *v93;
                  int64_t v135 = v212;
                }
                int64_t v134 = v135;
              }
              else
              {
                if ((v310 & 0x800) != 0)
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v94 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int64_t v133 = *(void *)(*(void *)&v276[4] + 16 * v94);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    int v95 = (uint64_t *)v316;
                    v316 += 2;
                    uint64_t v211 = *v95;
                    int64_t v133 = v211;
                  }
                  int64_t v132 = v133;
                }
                else
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v96 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int64_t v131 = *(void *)(*(void *)&v276[4] + 16 * v96);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    v97 = (uint64_t *)v316;
                    v316 += 2;
                    uint64_t v210 = *v97;
                    int64_t v131 = v210;
                  }
                  int64_t v132 = v131;
                }
                int64_t v134 = v132;
              }
              int64_t v136 = v134;
            }
            int64_t v287 = v136;
          }
          else
          {
            if ((v310 & 0x10) != 0)
            {
              if (*(void *)&v276[4])
              {
                uint64_t v98 = *(int *)v276;
                ++*(_DWORD *)v276;
                int64_t v130 = *(void *)(*(void *)&v276[4] + 16 * v98);
              }
              else
              {
                *(void *)v276 = (*(_DWORD *)v276 + 1);
                int v99 = (int64_t *)v316;
                v316 += 2;
                int64_t v209 = *v99;
                int64_t v130 = v209;
              }
              int64_t v129 = v130;
            }
            else
            {
              if ((v310 & 0x40) != 0)
              {
                if (*(void *)&v276[4])
                {
                  uint64_t v100 = *(int *)v276;
                  ++*(_DWORD *)v276;
                  int v128 = *(_DWORD *)(*(void *)&v276[4] + 16 * v100);
                }
                else
                {
                  *(void *)v276 = (*(_DWORD *)v276 + 1);
                  v101 = v316;
                  v316 += 2;
                  int v208 = *v101;
                  LOWORD(v128) = v208;
                }
                int64_t v127 = (unsigned __int16)v128;
              }
              else
              {
                if ((v310 & 0x2000) != 0)
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v102 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    int v126 = *(_DWORD *)(*(void *)&v276[4] + 16 * v102);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    v103 = v316;
                    v316 += 2;
                    int v207 = *v103;
                    LOBYTE(v126) = v207;
                  }
                  int64_t v125 = v126;
                }
                else
                {
                  if (*(void *)&v276[4])
                  {
                    uint64_t v104 = *(int *)v276;
                    ++*(_DWORD *)v276;
                    unsigned int v124 = *(_DWORD *)(*(void *)&v276[4] + 16 * v104);
                  }
                  else
                  {
                    *(void *)v276 = (*(_DWORD *)v276 + 1);
                    v105 = (unsigned int *)v316;
                    v316 += 2;
                    unsigned int v206 = *v105;
                    unsigned int v124 = v206;
                  }
                  int64_t v125 = v124;
                }
                int64_t v127 = v125;
              }
              int64_t v129 = v127;
            }
            int64_t v288 = v129;
          }
          int v286 = 16;
          if ((v310 & 1) == 0) {
            goto LABEL_441;
          }
          if ((v310 & 0x1C20) != 0)
          {
            if (!v287) {
              goto LABEL_441;
            }
          }
          else if (!v288)
          {
            goto LABEL_441;
          }
          char v278 = v314;
LABEL_441:
          v310 &= ~0x200u;
LABEL_442:
          char v306 = 0;
LABEL_443:
          int v285 = __n;
          if ((__n & 0x80000000) == 0) {
            v310 &= ~0x80u;
          }
          __s1 = v324;
          if ((v310 & 0x1C20) != 0)
          {
            if (v287 || __n || (v310 & 1) != 0 && v286 == 8) {
              __s1 = __ujtoa(v287, __s1, v286, v310 & 1, (uint64_t)v281);
            }
          }
          else if (v288 || __n || (v310 & 1) != 0 && v286 == 8)
          {
            __s1 = __ultoa(v288, __s1, v286, v310 & 1, (uint64_t)v281);
          }
          int64_t v283 = v323 - __s1 + 32;
          if (v283 >= 33) {
            abort_report_np((uint64_t)"%s:%s:%u: size (%zd) > BUF (%d)");
          }
          if ((v310 & 0x200) != 0 && v283)
          {
            int v106 = grouping_init((uint64_t)&v303, v283, v318);
            v283 += v106;
          }
          goto LABEL_466;
        case 'z':
          v310 |= 0x400u;
          continue;
        default:
          if (!v314) {
            goto LABEL_655;
          }
          __s1 = v323;
          v323[0] = v314;
          int64_t v283 = 1;
          char v306 = 0;
          goto LABEL_466;
      }
      break;
    }
  }
LABEL_655:
  io_flush((uint64_t)v279, (uint64_t)v318);
LABEL_656:
  if (v292) {
    __freedtoa((uint64_t)v292);
  }
  free(v274);
  if ((*(_WORD *)(v319 + 16) & 0x40) != 0) {
    uint64_t v309 = -1;
  }
  if (*(void *)&v276[4] && *(unsigned char **)&v276[4] != v322) {
    free(*(void **)&v276[4]);
  }
  if (v309 < 0 || v309 >= 0x7FFFFFFF) {
    return -1;
  }
  else {
    return v309;
  }
}

uint64_t io_init(uint64_t result, uint64_t a2)
{
  *(void *)(result + 8) = result + 24;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(void *)uint64_t result = a2;
  return result;
}

uint64_t io_print(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  *(void *)(a1 + 24 + 16 * *(int *)(a1 + 16)) = a2;
  *(void *)(a1 + 24 + 16 * *(int *)(a1 + 16) + 8) = a3;
  *(_DWORD *)(a1 + 20) += a3;
  int v4 = *(_DWORD *)(a1 + 16) + 1;
  *(_DWORD *)(a1 + 16) = v4;
  if (v4 < 8) {
    return 0;
  }
  else {
    return __sprint(*(void *)a1, a4, (_DWORD *)(a1 + 8));
  }
}

uint64_t exponent(unsigned char *a1, int a2, char a3)
{
  uint64_t v14 = a1;
  int v13 = a2;
  char v12 = a3;
  uint64_t v10 = 0;
  int v11 = a1 + 1;
  *a1 = a3;
  if (v13 >= 0)
  {
    int v4 = v11++;
    *int v4 = 43;
  }
  else
  {
    int v13 = -v13;
    BOOL v3 = v11++;
    *BOOL v3 = 45;
  }
  uint64_t v10 = &v10;
  if (v13 <= 9)
  {
    if (v12 == 101 || v12 == 69)
    {
      uint64_t v7 = v11++;
      *uint64_t v7 = 48;
    }
    int v8 = v11++;
    *int v8 = v13 + 48;
  }
  else
  {
    do
    {
      *--uint64_t v10 = v13 % 10 + 48;
      v13 /= 10;
    }
    while (v13 > 9);
    *--uint64_t v10 = v13 + 48;
    while (v10 < (unsigned char *)&v10)
    {
      uint64_t v5 = v10++;
      LOBYTE(v5) = *v5;
      int v6 = v11++;
      *int v6 = (_BYTE)v5;
    }
  }
  return v11 - v14;
}

uint64_t grouping_init(uint64_t a1, int a2, _xlocale *a3)
{
  int v4 = localeconv_l(a3);
  *(void *)(a1 + 16) = __fix_nogrouping(v4->grouping);
  *(void *)a1 = v4->thousands_sep;
  *(_DWORD *)(a1 + 8) = strlen(*(const char **)a1);
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = a2;
  while (**(unsigned char **)(a1 + 16) != 127 && *(_DWORD *)(a1 + 24) > **(char **)(a1 + 16))
  {
    *(_DWORD *)(a1 + 24) -= **(char **)(a1 + 16);
    if (*(unsigned char *)(*(void *)(a1 + 16) + 1))
    {
      ++*(_DWORD *)(a1 + 28);
      ++*(void *)(a1 + 16);
    }
    else
    {
      ++*(_DWORD *)(a1 + 32);
    }
  }
  return ((*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 32)) * *(_DWORD *)(a1 + 8));
}

char *__wcsconv(const __int32 *a1, int a2, _xlocale *a3)
{
  int v13 = a1;
  int v12 = a2;
  locale_t v11 = a3;
  memset(&__b, 0, sizeof(__b));
  uint64_t v9 = 0;
  if (v12 >= 0)
  {
    if (v12 >= 128)
    {
      size_t v5 = 0;
      uint64_t v9 = (__int32 *)v13;
      memcpy(&__b, &__wcsconv_initial, sizeof(__b));
      while (1)
      {
        BOOL v3 = v9++;
        size_t v7 = wcrtomb_l(v10, *v3, &__b, v11);
        if (!v7 || v7 == -1 || v5 + v7 > v12) {
          break;
        }
        v5 += v7;
      }
    }
    else
    {
      size_t v5 = v12;
    }
  }
  else
  {
    uint64_t v9 = (__int32 *)v13;
    memcpy(&__b, &__wcsconv_initial, sizeof(__b));
    size_t v5 = wcsrtombs_l(0, (const __int32 **)&v9, 0, &__b, v11);
    if (v5 == -1) {
      return 0;
    }
  }
  int v8 = (char *)malloc_type_malloc();
  if (!v8) {
    return 0;
  }
  uint64_t v9 = (__int32 *)v13;
  memcpy(&__b, &__wcsconv_initial, sizeof(__b));
  size_t v6 = wcsrtombs_l(v8, (const __int32 **)&v9, v5, &__b, v11);
  if (v6 == -1)
  {
    free(v8);
    return 0;
  }
  else
  {
    v8[v6] = 0;
    return v8;
  }
}

unsigned char *__ujtoa(unint64_t a1, unsigned char *a2, int a3, int a4, uint64_t a5)
{
  return __ultoa(a1, a2, a3, a4, a5);
}

unsigned char *__ultoa(unint64_t a1, unsigned char *a2, int a3, int a4, uint64_t a5)
{
  unint64_t v8 = a1;
  size_t v7 = a2;
  if (a3 == 8)
  {
    do
    {
      *--size_t v7 = (v8 & 7) + 48;
      v8 >>= 3;
    }
    while (v8);
    if (a4 && *v7 != 48) {
      *--size_t v7 = 48;
    }
    return v7;
  }
  if (a3 != 10)
  {
    if (a3 != 16) {
      abort_report_np((uint64_t)"%s:%s:%u: __ultoa: invalid base=%d");
    }
    do
    {
      *--size_t v7 = *(unsigned char *)(a5 + (v8 & 0xF));
      v8 >>= 4;
    }
    while (v8);
    return v7;
  }
  if (a1 >= 0xA)
  {
    if (a1 <= 0x7FFFFFFFFFFFFFFFLL)
    {
      int64_t v6 = a1;
    }
    else
    {
      size_t v7 = a2 - 1;
      *(a2 - 1) = a1 % 0xA + 48;
      int64_t v6 = a1 / 0xA;
    }
    do
    {
      *--size_t v7 = v6 % 10 + 48;
      v6 /= 10;
    }
    while (v6);
    return v7;
  }
  *(a2 - 1) = a1 + 48;
  return a2 - 1;
}

uint64_t io_flush(uint64_t a1, uint64_t a2)
{
  return __sprint(*(void *)a1, a2, (_DWORD *)(a1 + 8));
}

uint64_t io_pad(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  while (a2 > 0)
  {
    if (a2 < 16) {
      int v5 = a2;
    }
    else {
      int v5 = 16;
    }
    if (io_print(a1, a3, v5, a4)) {
      return -1;
    }
    a2 -= v5;
  }
  return 0;
}

uint64_t grouping_print(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  int v7 = a3;
  if (io_printandpad(a2, a3, a4, *(_DWORD *)(a1 + 24), (uint64_t)&zeroes, a5))
  {
    return -1;
  }
  else
  {
    for (unint64_t i = a3 + *(int *)(a1 + 24); ; i += **(char **)(a1 + 16))
    {
      BOOL v6 = 1;
      if (*(int *)(a1 + 28) <= 0) {
        BOOL v6 = *(_DWORD *)(a1 + 32) > 0;
      }
      if (!v6) {
        break;
      }
      if (*(int *)(a1 + 32) <= 0)
      {
        --*(void *)(a1 + 16);
        --*(_DWORD *)(a1 + 28);
      }
      else
      {
        --*(_DWORD *)(a1 + 32);
      }
      if (io_print(a2, *(void *)a1, *(_DWORD *)(a1 + 8), a5)) {
        return -1;
      }
      if (io_printandpad(a2, i, a4, **(char **)(a1 + 16), (uint64_t)&zeroes, a5)) {
        return -1;
      }
    }
    if (i > a4) {
      LODWORD(i) = a4;
    }
    return (i - v7);
  }
}

uint64_t io_printandpad(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  int v7 = a3 - a2;
  if (a3 - (int)a2 > a4) {
    int v7 = a4;
  }
  if (v7 <= 0)
  {
    int v7 = 0;
    return io_pad(a1, a4 - v7, a5, a6);
  }
  if (!io_print(a1, a2, v7, a6)) {
    return io_pad(a1, a4 - v7, a5, a6);
  }
  return -1;
}

uint64_t __sprint(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (a3[3])
  {
    unsigned int v3 = __sfvwrite(a1, a3);
    a3[3] = 0;
    a3[2] = 0;
    return v3;
  }
  else
  {
    a3[2] = 0;
    return 0;
  }
}

int vfscanf(FILE *__stream, const char *__format, va_list a3)
{
  libc_hooks_will_write((uint64_t)__stream, 152);
  flockfile(__stream);
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    locale_t v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    locale_t v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    int v5 = __svfscanf_l((int *)__stream, v11, (unsigned __int8 *)__format, (uint64_t *)a3);
  }
  else {
    int v5 = __svfscanf_l((int *)__stream, (_xlocale *)__global_locale, (unsigned __int8 *)__format, (uint64_t *)a3);
  }
  int v7 = v5;
  funlockfile(__stream);
  return v7;
}

uint64_t __svfscanf_l(int *a1, _xlocale *a2, unsigned __int8 *a3, uint64_t *a4)
{
  int v112 = a1;
  locale_t v111 = a2;
  uint64_t v110 = a3;
  char v109 = a4;
  v108 = a3;
  int v107 = 0;
  unint64_t v106 = 0;
  memset(v105, 0, sizeof(v105));
  int v104 = 0;
  uint64_t v103 = 0;
  unsigned int v102 = 0;
  int v101 = 0;
  int base = 0;
  int v99 = 0;
  size_t v98 = 0;
  int v97 = 0;
  uint64_t v96 = 0;
  memset(&__b, 0, sizeof(__b));
  int v95 = 0;
  libc_hooks_will_write((uint64_t)v111, 1472);
  libc_hooks_will_read_cstring((uint64_t)v110);
  if (v111)
  {
    if (v111 == (locale_t)-1) {
      locale_t v111 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v111 = (locale_t)&__c_locale;
  }
  int v95 = *(_DWORD *)(*((void *)v111 + 166) + 64);
  if (!((char)(32 * *(unsigned char *)(*((void *)v112 + 13) + 72)) >> 5)) {
    *(unsigned char *)(*((void *)v112 + 13) + 72) = *(unsigned char *)(*((void *)v112 + 13) + 72) & 0xF8 | 7;
  }
  unsigned int v102 = 0;
  int v101 = 0;
  uint64_t v96 = v109;
  do
  {
LABEL_8:
    while (2)
    {
      while (2)
      {
        char v4 = v108++;
        int v107 = *v4;
        if (!v107) {
          return v102;
        }
        if (isspace_l(v107, v111))
        {
          while (1)
          {
            if (v112[2] > 0 || (BOOL v38 = 0, !__srefill((uint64_t)v112))) {
              BOOL v38 = isspace_l(**(unsigned __int8 **)v112, v111) != 0;
            }
            if (!v38) {
              break;
            }
            ++v101;
            --v112[2];
            ++*(void *)v112;
          }
          continue;
        }
        break;
      }
      if (v107 != 37)
      {
        if (v112[2] <= 0 && __srefill((uint64_t)v112)) {
          goto LABEL_310;
        }
LABEL_31:
        if (**(unsigned __int8 **)v112 == v107)
        {
          --v112[2];
          ++*(void *)v112;
          ++v101;
          continue;
        }
        return v102;
      }
      break;
    }
    unint64_t v106 = 0;
    int v104 = 0;
    while (2)
    {
      int v5 = v108++;
      int v107 = *v5;
      if (v107)
      {
        uint64_t v7 = v107;
        char v6 = 1;
      }
      else
      {
        uint64_t v7 = 0;
        char v6 = 0;
      }
      if (v6) {
        return v102;
      }
      switch(v7)
      {
        case 0:
          return -1;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
        case 35:
        case 38:
        case 39:
        case 40:
        case 41:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 66:
        case 68:
        case 72:
        case 73:
        case 74:
        case 75:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 82:
        case 84:
        case 85:
        case 86:
        case 87:
        case 89:
        case 90:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 98:
        case 107:
        case 109:
        case 114:
        case 118:
        case 119:
        case 121:
          return v102;
        case 36:
          int v97 = v106;
          if ((int)v106 < 1 || v97 > 9 || *(v108 - 3) != 37) {
            goto LABEL_310;
          }
          unint64_t v106 = 0;
          char v109 = v96;
          while (v97 > 1)
          {
            uint64_t v8 = *v109++;
            uint64_t v94 = v8;
            --v97;
          }
          continue;
        case 37:
          while (2)
          {
            if (v112[2] <= 0 && __srefill((uint64_t)v112)) {
              goto LABEL_310;
            }
            if (isspace_l(**(unsigned __int8 **)v112, v111))
            {
              ++v101;
              --v112[2];
              ++*(void *)v112;
              continue;
            }
            goto LABEL_31;
          }
        case 42:
          v104 |= 8u;
          continue;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          unint64_t v106 = 10 * v106 + v107 - 48;
          continue;
        case 65:
        case 69:
        case 70:
        case 71:
        case 97:
        case 101:
        case 102:
        case 103:
          int v107 = 4;
          goto LABEL_85;
        case 67:
          v104 |= 1u;
          goto LABEL_64;
        case 76:
          v104 |= 2u;
          continue;
        case 83:
          v104 |= 1u;
          goto LABEL_61;
        case 88:
        case 120:
          v104 |= 0x100u;
          int v107 = 3;
          v104 |= 0x8000u;
          int base = 16;
          goto LABEL_85;
        case 91:
          v108 = __sccl(v116, v108, v111);
          v104 |= 0x20u;
          int v107 = 1;
          goto LABEL_85;
        case 99:
LABEL_64:
          v104 |= 0x20u;
          int v107 = 0;
          goto LABEL_85;
        case 100:
          int v107 = 3;
          int base = 10;
          goto LABEL_85;
        case 104:
          if ((v104 & 4) != 0)
          {
            v104 &= ~4u;
            v104 |= 0x4000u;
          }
          else
          {
            v104 |= 4u;
          }
          continue;
        case 105:
          int v107 = 3;
          int base = 0;
          goto LABEL_85;
        case 106:
          v104 |= 0x800u;
          continue;
        case 108:
          if (v104)
          {
            v104 &= ~1u;
            v104 |= 0x400u;
          }
          else
          {
            v104 |= 1u;
          }
          continue;
        case 110:
          if ((v104 & 8) == 0)
          {
            int v93 = 0;
            uint64_t v9 = *v109++;
            uint64_t v92 = v9;
            int v93 = (unsigned char *)v9;
            if (v9)
            {
              if ((v104 & 0x4000) != 0)
              {
                char v91 = v101;
                uint64_t v90 = v93;
                libc_hooks_will_write((uint64_t)v93, 1);
                *uint64_t v90 = v91;
              }
              else if ((v104 & 4) != 0)
              {
                __int16 v89 = v101;
                uint64_t v88 = v93;
                libc_hooks_will_write((uint64_t)v93, 2);
                *uint64_t v88 = v89;
              }
              else if (v104)
              {
                uint64_t v87 = v101;
                uint64_t v86 = v93;
                libc_hooks_will_write((uint64_t)v93, 8);
                *uint64_t v86 = v87;
              }
              else if ((v104 & 0x400) != 0)
              {
                uint64_t v85 = v101;
                uint64_t v84 = v93;
                libc_hooks_will_write((uint64_t)v93, 8);
                *uint64_t v84 = v85;
              }
              else if ((v104 & 0x800) != 0)
              {
                uint64_t v83 = v101;
                uint64_t v82 = v93;
                libc_hooks_will_write((uint64_t)v93, 8);
                *uint64_t v82 = v83;
              }
              else if ((v104 & 0x2000) != 0)
              {
                uint64_t v81 = v101;
                uint64_t v80 = v93;
                libc_hooks_will_write((uint64_t)v93, 8);
                *uint64_t v80 = v81;
              }
              else if ((v104 & 0x1000) != 0)
              {
                uint64_t v79 = v101;
                uint64_t v78 = v93;
                libc_hooks_will_write((uint64_t)v93, 8);
                *uint64_t v78 = v79;
              }
              else
              {
                int v77 = v101;
                uint64_t v76 = v93;
                libc_hooks_will_write((uint64_t)v93, 4);
                *uint64_t v76 = v77;
              }
            }
          }
          goto LABEL_8;
        case 111:
          int v107 = 3;
          v104 |= 0x8000u;
          int base = 8;
          goto LABEL_85;
        case 112:
          v104 |= 0x110u;
          int v107 = 3;
          v104 |= 0x8000u;
          int base = 16;
          goto LABEL_85;
        case 113:
          v104 |= 0x400u;
          continue;
        case 115:
LABEL_61:
          int v107 = 2;
          goto LABEL_85;
        case 116:
          v104 |= 0x1000u;
          continue;
        case 117:
          int v107 = 3;
          v104 |= 0x8000u;
          int base = 10;
LABEL_85:
          if (v112[2] <= 0 && __srefill((uint64_t)v112)) {
            goto LABEL_310;
          }
          if ((v104 & 0x20) != 0) {
            goto LABEL_93;
          }
          break;
        case 122:
          v104 |= 0x2000u;
          continue;
        default:
LABEL_316:
          JUMPOUT(0);
      }
      break;
    }
    while (isspace_l(**(unsigned __int8 **)v112, v111))
    {
      ++v101;
      int v10 = v112[2] - 1;
      v112[2] = v10;
      if (v10 <= 0)
      {
        if (__srefill((uint64_t)v112)) {
          goto LABEL_310;
        }
      }
      else
      {
        ++*(void *)v112;
      }
    }
LABEL_93:
    if (v107)
    {
      uint64_t v12 = v107;
      char v11 = 1;
    }
    else
    {
      uint64_t v12 = 0;
      char v11 = 0;
    }
  }
  while ((v11 & 1) != 0);
  switch(v12)
  {
    case 0:
      if (!v106) {
        unint64_t v106 = 1;
      }
      if (v104)
      {
        if ((v104 & 8) != 0)
        {
          int v99 = 0;
        }
        else
        {
          int v13 = (__int32 *)*v109++;
          int v75 = v13;
          int v99 = v13;
        }
        v105[0] = 0;
        do
        {
          if (!v106) {
            goto LABEL_123;
          }
          if (v105[0] == v95)
          {
            *((_WORD *)v112 + 8) |= 0x40u;
            goto LABEL_310;
          }
          char v14 = **(unsigned char **)v112;
          uint64_t v15 = v105[0]++;
          nptr[v15] = v14;
          ++*(void *)v112;
          --v112[2];
          memcpy(&__b, &__svfscanf_l_initial, sizeof(__b));
          size_t v98 = mbrtowc_l(v99, nptr, v105[0], &__b, v111);
          if (v98 == -1)
          {
            *((_WORD *)v112 + 8) |= 0x40u;
            goto LABEL_310;
          }
          if (!v98 && (v104 & 8) == 0) {
            *int v99 = 0;
          }
          if (v98 != -2)
          {
            v101 += v105[0];
            --v106;
            if ((v104 & 8) == 0) {
              ++v99;
            }
            v105[0] = 0;
          }
        }
        while (v112[2] > 0 || !__srefill((uint64_t)v112));
        if (v105[0])
        {
          *((_WORD *)v112 + 8) |= 0x40u;
          goto LABEL_310;
        }
LABEL_123:
        if ((v104 & 8) == 0) {
          ++v102;
        }
        goto LABEL_8;
      }
      if ((v104 & 8) == 0)
      {
        unint64_t v73 = 0;
        uint64_t v16 = *v109++;
        uint64_t v72 = v16;
        unint64_t v73 = __fread(v16, 1uLL, v106, (uint64_t)v112);
        if (!v73) {
          goto LABEL_310;
        }
        v101 += v73;
        ++v102;
        goto LABEL_8;
      }
      uint64_t v74 = 0;
      do
      {
        v105[0] = v112[2];
        if (v105[0] >= v106)
        {
          v74 += v106;
          v112[2] -= v106;
          *(void *)v112 += v106;
          goto LABEL_134;
        }
        v74 += v105[0];
        v106 -= v105[0];
        *(void *)v112 += v105[0];
      }
      while (!__srefill((uint64_t)v112));
      if (v74)
      {
LABEL_134:
        v101 += v74;
        goto LABEL_8;
      }
LABEL_310:
      if (v102) {
        return v102;
      }
      else {
        return -1;
      }
    case 1:
      if (!v106) {
        unint64_t v106 = -1;
      }
      if ((v104 & 1) == 0)
      {
        if ((v104 & 8) != 0)
        {
          v105[0] = 0;
          while (v116[**(unsigned __int8 **)v112])
          {
            ++v105[0];
            --v112[2];
            ++*(void *)v112;
            if (!--v106) {
              break;
            }
            if (v112[2] <= 0 && __srefill((uint64_t)v112))
            {
              if (!v105[0]) {
                goto LABEL_310;
              }
              break;
            }
          }
          if (v105[0]) {
            goto LABEL_193;
          }
        }
        else
        {
          uint64_t v20 = *v109++;
          uint64_t v68 = v20;
          *(void *)&v105[1] = v20;
          uint64_t v103 = v20;
          while (v116[**(unsigned __int8 **)v112])
          {
            --v112[2];
            int v21 = (unsigned __int8 *)(*(void *)v112)++;
            LOBYTE(v21) = *v21;
            uint64_t v22 = (unsigned char *)(*(void *)&v105[1])++;
            *uint64_t v22 = (_BYTE)v21;
            if (!--v106) {
              break;
            }
            if (v112[2] <= 0 && __srefill((uint64_t)v112))
            {
              if (*(void *)&v105[1] == v103) {
                goto LABEL_310;
              }
              break;
            }
          }
          v105[0] = v105[1] - v103;
          if (v105[1] != v103)
          {
            **(unsigned char **)&v105[1] = 0;
            ++v102;
            libc_hooks_will_read_cstring(v103);
            goto LABEL_193;
          }
        }
        return v102;
      }
      wint_t v71 = 0;
      int v70 = 0;
      if ((v104 & 8) != 0)
      {
        int v99 = &v71;
      }
      else
      {
        int v17 = (__int32 *)*v109++;
        uint64_t v69 = v17;
        int v99 = v17;
      }
      v105[0] = 0;
      int v70 = 0;
      do
      {
        if (!v106) {
          goto LABEL_166;
        }
        if (v105[0] == v95)
        {
          *((_WORD *)v112 + 8) |= 0x40u;
          goto LABEL_310;
        }
        char v18 = **(unsigned char **)v112;
        uint64_t v19 = v105[0]++;
        nptr[v19] = v18;
        ++*(void *)v112;
        --v112[2];
        memcpy(&__b, &__svfscanf_l_initial, sizeof(__b));
        size_t v98 = mbrtowc_l(&v71, nptr, v105[0], &__b, v111);
        if (v98 == -1)
        {
          *((_WORD *)v112 + 8) |= 0x40u;
          goto LABEL_310;
        }
        if (!v98) {
          wint_t v71 = 0;
        }
        if (v98 != -2)
        {
          if (wctob_l(v71, v111) != -1 && !v116[wctob_l(v71, v111)])
          {
            while (v105[0])
              __ungetc(nptr[--v105[0]], (uint64_t)v112);
LABEL_166:
            if (v105[0])
            {
              *((_WORD *)v112 + 8) |= 0x40u;
              goto LABEL_310;
            }
            v105[0] = v70;
            if (!v70) {
              return v102;
            }
            if ((v104 & 8) == 0)
            {
              *int v99 = 0;
              ++v102;
            }
LABEL_193:
            v101 += v105[0];
            goto LABEL_8;
          }
          v101 += v105[0];
          --v106;
          if ((v104 & 8) == 0) {
            *v99++ = v71;
          }
          ++v70;
          v105[0] = 0;
        }
      }
      while (v112[2] > 0 || !__srefill((uint64_t)v112));
      if (!v105[0]) {
        goto LABEL_166;
      }
      *((_WORD *)v112 + 8) |= 0x40u;
      goto LABEL_310;
    case 2:
      if (!v106) {
        unint64_t v106 = -1;
      }
      if ((v104 & 1) == 0)
      {
        if ((v104 & 8) != 0)
        {
          v105[0] = 0;
          do
          {
            if (isspace_l(**(unsigned __int8 **)v112, v111)) {
              break;
            }
            ++v105[0];
            --v112[2];
            ++*(void *)v112;
            if (!--v106) {
              break;
            }
          }
          while (v112[2] > 0 || !__srefill((uint64_t)v112));
          v101 += v105[0];
        }
        else
        {
          uint64_t v26 = *v109++;
          uint64_t v65 = v26;
          *(void *)&v105[1] = v26;
          uint64_t v103 = v26;
          do
          {
            if (isspace_l(**(unsigned __int8 **)v112, v111)) {
              break;
            }
            --v112[2];
            long double v27 = (unsigned __int8 *)(*(void *)v112)++;
            LOBYTE(v27) = *v27;
            uint64_t v28 = (unsigned char *)(*(void *)&v105[1])++;
            *uint64_t v28 = (_BYTE)v27;
            if (!--v106) {
              break;
            }
          }
          while (v112[2] > 0 || !__srefill((uint64_t)v112));
          **(unsigned char **)&v105[1] = 0;
          v101 += v105[1] - v103;
          ++v102;
          libc_hooks_will_read_cstring(v103);
        }
        goto LABEL_8;
      }
      int v67 = 0;
      if ((v104 & 8) != 0)
      {
        int v99 = &v67;
      }
      else
      {
        unsigned int v23 = (__int32 *)*v109++;
        uint64_t v66 = v23;
        int v99 = v23;
      }
      v105[0] = 0;
      while (1)
      {
        if (!v106) {
          goto LABEL_222;
        }
        if (v105[0] == v95)
        {
          *((_WORD *)v112 + 8) |= 0x40u;
          goto LABEL_310;
        }
        char v24 = **(unsigned char **)v112;
        uint64_t v25 = v105[0]++;
        nptr[v25] = v24;
        ++*(void *)v112;
        --v112[2];
        memcpy(&__b, &__svfscanf_l_initial, sizeof(__b));
        size_t v98 = mbrtowc_l(v99, nptr, v105[0], &__b, v111);
        if (v98 == -1)
        {
          *((_WORD *)v112 + 8) |= 0x40u;
          goto LABEL_310;
        }
        if (!v98) {
          *int v99 = 0;
        }
        if (v98 != -2)
        {
          if (iswspace_l(*v99, v111))
          {
            while (v105[0])
              __ungetc(nptr[--v105[0]], (uint64_t)v112);
            goto LABEL_222;
          }
          v101 += v105[0];
          --v106;
          if ((v104 & 8) == 0) {
            ++v99;
          }
          v105[0] = 0;
        }
        if (v112[2] <= 0 && __srefill((uint64_t)v112))
        {
          if (v105[0])
          {
            *((_WORD *)v112 + 8) |= 0x40u;
            goto LABEL_310;
          }
LABEL_222:
          if ((v104 & 8) == 0)
          {
            *int v99 = 0;
            ++v102;
          }
          goto LABEL_8;
        }
      }
    case 3:
      if (--v106 > 0x1FF) {
        unint64_t v106 = 511;
      }
      ++v106;
      v104 |= 0x2C0u;
      *(void *)&v105[1] = nptr;
      while (2)
      {
        if (!v106) {
          goto LABEL_270;
        }
        int v107 = **(unsigned __int8 **)v112;
        if (v107 <= 0x2B)
        {
          uint64_t v30 = (v107 - 43);
          char v29 = 0;
        }
        else
        {
          uint64_t v30 = (v107 - 43);
          char v29 = 1;
        }
        if (v29) {
          goto LABEL_270;
        }
        switch(v30)
        {
          case 0:
          case 2:
            if ((v104 & 0x40) == 0) {
              goto LABEL_270;
            }
            v104 &= ~0x40u;
            v104 |= 0x10000u;
            break;
          case 1:
          case 3:
          case 4:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
            goto LABEL_270;
          case 5:
            if (!base)
            {
              int base = 8;
              v104 |= 0x100u;
            }
            if ((v104 & 0x200) != 0) {
              v104 &= 0xFFFFFD3F;
            }
            else {
              v104 &= 0xFFFFFE3F;
            }
            break;
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
            int base = __svfscanf_l_basefix[base];
            v104 &= 0xFFFFFE3F;
            break;
          case 13:
          case 14:
            int base = __svfscanf_l_basefix[base];
            if (base <= 8) {
              goto LABEL_270;
            }
            v104 &= 0xFFFFFE3F;
            break;
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 59:
            if (base <= 10) {
              goto LABEL_270;
            }
            v104 &= 0xFFFFFE3F;
            break;
          case 45:
          case 77:
            if ((v104 & 0x100) == 0 || *(char **)&v105[1] != &nptr[((v104 & 0x10000) != 0) + 1]) {
              goto LABEL_270;
            }
            int base = 16;
            v104 &= ~0x100u;
            break;
          default:
            goto LABEL_316;
        }
        double v31 = (unsigned char *)(*(void *)&v105[1])++;
        *double v31 = v107;
        int v32 = v112[2] - 1;
        v112[2] = v32;
        if (v32 <= 0)
        {
          if (__srefill((uint64_t)v112))
          {
LABEL_270:
            if ((v104 & 0x80u) == 0)
            {
              int v107 = *(unsigned __int8 *)(*(void *)&v105[1] - 1);
              if (v107 == 120 || v107 == 88)
              {
                --*(void *)&v105[1];
                __ungetc(v107, (uint64_t)v112);
              }
              if ((v104 & 8) == 0)
              {
                uintmax_t v64 = 0;
                **(unsigned char **)&v105[1] = 0;
                if ((v104 & 0x8000u) != 0) {
                  uintmax_t v64 = strtoumax_l(nptr, 0, base, v111);
                }
                else {
                  uintmax_t v64 = strtoimax_l(nptr, 0, base, v111);
                }
                size_t v63 = 0;
                uint64_t v33 = *v109++;
                uint64_t v62 = v33;
                size_t v63 = (uintmax_t *)v33;
                if ((v104 & 0x10) != 0)
                {
                  uintmax_t v61 = v64;
                  uint64_t v60 = v63;
                  libc_hooks_will_write((uint64_t)v63, 8);
                  *uint64_t v60 = v61;
                }
                else if ((v104 & 0x4000) != 0)
                {
                  char v59 = v64;
                  uint64_t v58 = v63;
                  libc_hooks_will_write((uint64_t)v63, 1);
                  *(unsigned char *)uint64_t v58 = v59;
                }
                else if ((v104 & 4) != 0)
                {
                  __int16 v57 = v64;
                  uint64_t v56 = v63;
                  libc_hooks_will_write((uint64_t)v63, 2);
                  *(_WORD *)uint64_t v56 = v57;
                }
                else if (v104)
                {
                  uintmax_t v55 = v64;
                  uint64_t v54 = v63;
                  libc_hooks_will_write((uint64_t)v63, 8);
                  *uint64_t v54 = v55;
                }
                else if ((v104 & 0x400) != 0)
                {
                  uintmax_t v53 = v64;
                  uint64_t v52 = v63;
                  libc_hooks_will_write((uint64_t)v63, 8);
                  *uint64_t v52 = v53;
                }
                else if ((v104 & 0x800) != 0)
                {
                  uintmax_t v51 = v64;
                  v50 = v63;
                  libc_hooks_will_write((uint64_t)v63, 8);
                  uintmax_t *v50 = v51;
                }
                else if ((v104 & 0x1000) != 0)
                {
                  uintmax_t v49 = v64;
                  int v48 = v63;
                  libc_hooks_will_write((uint64_t)v63, 8);
                  *int v48 = v49;
                }
                else if ((v104 & 0x2000) != 0)
                {
                  uintmax_t v47 = v64;
                  uint64_t v46 = v63;
                  libc_hooks_will_write((uint64_t)v63, 8);
                  *uint64_t v46 = v47;
                }
                else
                {
                  int v45 = v64;
                  uint64_t v44 = v63;
                  libc_hooks_will_write((uint64_t)v63, 4);
                  *(_DWORD *)uint64_t v44 = v45;
                }
                ++v102;
              }
              v101 += *(void *)&v105[1] - (void)nptr;
              goto LABEL_8;
            }
            if (*(void *)&v105[1] > (unint64_t)nptr)
            {
              --*(void *)&v105[1];
              __ungetc(**(unsigned char **)&v105[1], (uint64_t)v112);
            }
            return v102;
          }
        }
        else
        {
          ++*(void *)v112;
        }
        --v106;
        continue;
      }
    case 4:
      uint64_t v43 = 0;
      int v34 = parsefloat((uint64_t)v112, (unsigned __int8 **)&v43, v106, v111);
      unint64_t v106 = v34;
      if (!v34) {
        return v102;
      }
      if ((v104 & 8) == 0)
      {
        int v35 = (long double *)*v109++;
        int v42 = v35;
        if ((v104 & 2) != 0)
        {
          long double v41 = strtold_l(v43, (char **)&v105[1], v111);
          libc_hooks_will_write((uint64_t)v42, 8);
          *int v42 = v41;
        }
        else if (v104)
        {
          double v40 = strtod_l(v43, (char **)&v105[1], v111);
          libc_hooks_will_write((uint64_t)v42, 8);
          *int v42 = v40;
        }
        else
        {
          float v39 = strtof_l(v43, (char **)&v105[1], v111);
          libc_hooks_will_write((uint64_t)v42, 4);
          *(float *)int v42 = v39;
        }
        ++v102;
      }
      v101 += v106;
      goto LABEL_8;
    default:
      goto LABEL_316;
  }
}

int vfscanf_l(FILE *a1, locale_t a2, const char *a3, va_list a4)
{
  libc_hooks_will_write((uint64_t)a1, 152);
  if (a2)
  {
    if (a2 == (locale_t)-1) {
      a2 = (locale_t)__global_locale;
    }
  }
  else
  {
    a2 = (locale_t)&__c_locale;
  }
  flockfile(a1);
  int v5 = __svfscanf_l((int *)a1, a2, (unsigned __int8 *)a3, (uint64_t *)a4);
  funlockfile(a1);
  return v5;
}

unsigned __int8 *__sccl(void *a1, unsigned __int8 *a2, _xlocale *a3)
{
  uint64_t v12 = a2 + 1;
  int v10 = *a2;
  if (v10 == 94)
  {
    char __c = 1;
    uint64_t v12 = a2 + 2;
    int v10 = a2[1];
    memset(a1, 1, 0x100uLL);
  }
  else
  {
    char __c = 0;
    memset(a1, 0, 0x100uLL);
  }
  if (!v10) {
    return v12 - 1;
  }
  char __ca = 1 - __c;
LABEL_7:
  while (2)
  {
    *((unsigned char *)a1 + v10) = __ca;
    while (1)
    {
      char v3 = v12++;
      int v5 = *v3;
      if (!*v3) {
        return v12 - 1;
      }
      if (v5 != 45) {
        break;
      }
      int v9 = *v12;
      if (v9 == 93) {
        goto LABEL_18;
      }
      if (*(unsigned char *)(*((void *)a3 + 165) + 64))
      {
        if (v9 < v10) {
          goto LABEL_18;
        }
      }
      else if ((int)__collate_range_cmp(v9, v10, a3) < 0)
      {
LABEL_18:
        int v10 = 45;
        goto LABEL_7;
      }
      ++v12;
      if (*(unsigned char *)(*((void *)a3 + 165) + 64))
      {
        do
          *((unsigned char *)a1 + ++v10) = __ca;
        while (v10 < v9);
      }
      else
      {
        for (int i = 0; i < 256; ++i)
        {
          if ((int)__collate_range_cmp(v10, i, a3) < 0 && (int)__collate_range_cmp(i, v9, a3) <= 0) {
            *((unsigned char *)a1 + i) = __ca;
          }
        }
      }
      int v10 = v9;
    }
    if (v5 != 93)
    {
      int v10 = *v3;
      continue;
    }
    return v12;
  }
}

uint64_t parsefloat(uint64_t a1, unsigned __int8 **a2, uint64_t a3, _xlocale *a4)
{
  int v22 = 0;
  int v21 = 0;
  unsigned int v20 = 0;
  decimal_point = localeconv_l(a4)->decimal_point;
  char v17 = 0;
  char v16 = 0;
  if (a3) {
    size_t v10 = a3 + 1;
  }
  else {
    size_t v10 = 513;
  }
  size_t v13 = v10;
  uint64_t v15 = (unsigned __int8 *)__parsefloat_buf(v10);
  if (!v15)
  {
    *a2 = 0;
    return 0;
  }
  char v14 = &v15[v10 - 1];
  char v24 = v15 - 1;
  unsigned int v23 = v15;
LABEL_7:
  BOOL v9 = 1;
  if (a3) {
    BOOL v9 = v23 < v14;
  }
  if (!v9) {
    goto LABEL_99;
  }
  unsigned __int8 v19 = **(unsigned char **)a1;
  while (2)
  {
    if (v20)
    {
      uint64_t v5 = v20;
      char v4 = 1;
    }
    else
    {
      uint64_t v5 = 0;
      char v4 = 0;
    }
    if (v4) {
      abort_report_np((uint64_t)"%s:%s:%u: unknown state %d");
    }
    switch(v5)
    {
      case 0:
        unsigned int v20 = 1;
        if (v19 == 45 || v19 == 43) {
          goto LABEL_92;
        }
        continue;
      case 1:
        switch(v19)
        {
          case '0':
            unsigned int v20 = 5;
            char v24 = v23;
            goto LABEL_92;
          case 'I':
            goto LABEL_27;
          case 'N':
LABEL_28:
            unsigned int v20 = 3;
            goto LABEL_92;
          case 'i':
LABEL_27:
            unsigned int v20 = 2;
            goto LABEL_92;
          case 'n':
            goto LABEL_28;
        }
        unsigned int v20 = 6;
        continue;
      case 2:
        if (v22 > 6 || v19 != aNfinity[v22] && v19 != aNfinity_0[v22]) {
          goto LABEL_99;
        }
        if (v22 == 1 || v22 == 6) {
          char v24 = v23;
        }
        ++v22;
        goto LABEL_92;
      case 3:
        if (v22)
        {
          if (v22 == 1)
          {
            if (v19 == 78 || v19 == 110)
            {
              char v24 = v23;
LABEL_53:
              ++v22;
              goto LABEL_92;
            }
          }
          else if (v22 == 2)
          {
            if (v19 == 40) {
              goto LABEL_53;
            }
          }
          else
          {
            if (v19 == 41)
            {
              char v24 = v23;
              unsigned int v20 = 4;
              goto LABEL_53;
            }
            if (isalnum_l(v19, a4) || v19 == 95) {
              goto LABEL_53;
            }
          }
        }
        else if (v19 == 65 || v19 == 97)
        {
          goto LABEL_53;
        }
LABEL_99:
        while (v24 < --v23)
          __ungetc(*v23, a1);
        uint64_t v25 = v24 + 1;
        *uint64_t v25 = 0;
        *a2 = v15;
        return (v25 - v15);
      case 4:
        goto LABEL_99;
      case 5:
        unsigned int v20 = 6;
        if (v19 == 88 || v19 == 120)
        {
          char v16 = 1;
          goto LABEL_92;
        }
        char v17 = 1;
        continue;
      case 6:
        if ((v16 & 1) != 0 && isxdigit_l(v19, a4) || isdigit_l(v19, a4))
        {
          char v17 = 1;
          char v24 = v23;
          goto LABEL_92;
        }
        unsigned int v20 = 7;
        continue;
      case 7:
        if (v19 != decimal_point[v21])
        {
          if (v21) {
            goto LABEL_99;
          }
          unsigned int v20 = 8;
          continue;
        }
        if (!decimal_point[++v21])
        {
          unsigned int v20 = 8;
          if (v17) {
            char v24 = v23;
          }
        }
LABEL_92:
        if (v23 >= v14)
        {
          int64_t v12 = v23 - v15;
          int64_t v11 = v24 - v15;
          v13 += 513;
          uint64_t v15 = (unsigned __int8 *)__parsefloat_buf(v13);
          if (!v15)
          {
            *a2 = 0;
            return 0;
          }
          char v14 = &v15[v13 - 1];
          unsigned int v23 = &v15[v12];
          char v24 = &v15[v11];
        }
        char v6 = v23++;
        *char v6 = v19;
        int v7 = *(_DWORD *)(a1 + 8) - 1;
        *(_DWORD *)(a1 + 8) = v7;
        if (v7 <= 0)
        {
          if (__srefill(a1)) {
            goto LABEL_99;
          }
        }
        else
        {
          ++*(void *)a1;
        }
        goto LABEL_7;
      case 8:
        if (v19 == 69 || v19 == 101) && (v16 & 1) == 0 || (v19 == 80 || v19 == 112) && (v16)
        {
          if (v17)
          {
            unsigned int v20 = 9;
            goto LABEL_92;
          }
        }
        else if ((v16 & 1) != 0 && isxdigit_l(v19, a4) || isdigit_l(v19, a4))
        {
          char v24 = v23;
          char v17 = 1;
          goto LABEL_92;
        }
        goto LABEL_99;
      case 9:
        unsigned int v20 = 10;
        if (v19 == 45 || v19 == 43) {
          goto LABEL_92;
        }
        continue;
      case 10:
        if (!isdigit_l(v19, a4)) {
          goto LABEL_99;
        }
        char v24 = v23;
        goto LABEL_92;
      default:
        JUMPOUT(0);
    }
  }
}

int __svfscanf(FILE *a1, const char *a2, va_list a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return __svfscanf_l((int *)a1, v9, (unsigned __int8 *)a2, (uint64_t *)a3);
  }
  else {
    return __svfscanf_l((int *)a1, (_xlocale *)__global_locale, (unsigned __int8 *)a2, (uint64_t *)a3);
  }
}

void *__parsefloat_buf(size_t a1)
{
  if (__parsefloat_buf_parsefloat_tsd_key == -1)
  {
    pthread_mutex_lock(&__parsefloat_buf_parsefloat_tsd_lock);
    if (__parsefloat_buf_parsefloat_tsd_key == -1)
    {
      __parsefloat_buf_parsefloat_tsd_key = 15;
      pthread_key_init_np();
    }
    pthread_mutex_unlock(&__parsefloat_buf_parsefloat_tsd_lock);
  }
  __ptsize_t r = pthread_getspecific(__parsefloat_buf_parsefloat_tsd_key);
  if (__ptr)
  {
    if (a1 > __parsefloat_buf_bsiz)
    {
      __ptsize_t r = reallocf(__ptr, a1);
      pthread_setspecific(__parsefloat_buf_parsefloat_tsd_key, __ptr);
      if (!__ptr)
      {
        __parsefloat_buf_bsiz = 0;
        return 0;
      }
      __parsefloat_buf_bsiz = a1;
    }
    return __ptr;
  }
  if (a1 <= 0x201) {
    uint64_t v2 = 513;
  }
  else {
    uint64_t v2 = a1;
  }
  __parsefloat_buf_bsiz = v2;
  __ptra = (void *)malloc_type_malloc();
  if (__ptra)
  {
    pthread_setspecific(__parsefloat_buf_parsefloat_tsd_key, __ptra);
    return __ptra;
  }
  else
  {
    __parsefloat_buf_bsiz = 0;
    return 0;
  }
}

int vfwprintf_l(FILE *a1, locale_t a2, const __int32 *a3, __darwin_va_list a4)
{
  uint64_t v8 = a2;
  if (a2)
  {
    if (a2 == (locale_t)-1) {
      uint64_t v8 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v8 = (_xlocale *)&__c_locale;
  }
  flockfile(a1);
  if ((a1->_flags & 0x1A) == 0xA && a1->_file >= 0) {
    int v5 = __sbprintf((uint64_t)a1, v8, (unsigned int *)a3, a4);
  }
  else {
    int v5 = __vfwprintf((uint64_t)a1, v8, (unsigned int *)a3, a4);
  }
  funlockfile(a1);
  return v5;
}

uint64_t __sbprintf(uint64_t a1, _xlocale *a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v11 = a1;
  uint64_t v10 = a2;
  BOOL v9 = a3;
  uint64_t v8 = a4;
  int v7 = 0;
  memset(__b, 0, sizeof(__b));
  memset(v14, 0, sizeof(v14));
  void __b[13] = v14;
  v14[0] = 0;
  memset(v13, 0, sizeof(v13));
  v13[0] = 850045858;
  memcpy(&v14[1], v13, 0x40uLL);
  LOBYTE(v14[9]) &= 0xF8u;
  memset(&v14[10], 0, 0x80uLL);
  LOBYTE(v14[9]) &= ~8u;
  if ((*(_WORD *)(v11 + 16) & 8) == 0
    || (BOOL v5 = 0, !*(void *)(v11 + 24)) && (BOOL v5 = 0, (*(_WORD *)(v11 + 16) & 0x200) == 0))
  {
    BOOL v5 = __swsetup(v11) != 0;
  }
  if (v5)
  {
    return -1;
  }
  else
  {
    LOWORD(__b[2]) = *(_WORD *)(v11 + 16) & 0xFFFD;
    WORD1(__b[2]) = *(_WORD *)(v11 + 18);
    void __b[6] = *(void *)(v11 + 48);
    __b[10] = *(void *)(v11 + 80);
    *(unsigned char *)(__b[13] + 72) = *(unsigned char *)(__b[13] + 72) & 0xF8 | ((char)(32
                                                                           * *(unsigned char *)(*(void *)(v11 + 104) + 72)) >> 5) & 7;
    memcpy((void *)(__b[13] + 80), (const void *)(*(void *)(v11 + 104) + 80), 0x80uLL);
    __b[0] = v15;
    __b[3] = v15;
    HIDWORD(__b[1]) = 1024;
    LODWORD(__b[4]) = 1024;
    LODWORD(__b[5]) = 0;
    int v7 = __vfwprintf((uint64_t)__b, v10, v9, v8);
    if (v7 >= 0 && __fflush((uint64_t)__b)) {
      int v7 = -1;
    }
    if ((__b[2] & 0x40) != 0) {
      *(_WORD *)(v11 + 16) |= 0x40u;
    }
    return v7;
  }
}

uint64_t __vfwprintf(uint64_t a1, _xlocale *a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t v294 = a1;
  locale_t v293 = a2;
  v292 = a3;
  long long v291 = a4;
  unint64_t v290 = 0;
  int v289 = 0;
  uint64_t v288 = 0;
  uint64_t v287 = 0;
  int i = 0;
  int v285 = 0;
  uint64_t v284 = 0;
  uint64_t v283 = 0;
  uint64_t v282 = 0;
  int v281 = 0;
  memset(v280, 0, sizeof(v280));
  int decpt = 0;
  int v278 = 0;
  double v277 = 0.0;
  int v276 = 0;
  char v275 = 0;
  uint64_t v274 = 0;
  int v273 = 0;
  int v272 = 0;
  int v271 = 0;
  long long v270 = 0uLL;
  int v269 = 0;
  int v268 = 0;
  int64_t v267 = 0;
  int64_t v266 = 0;
  int v265 = 0;
  int v264 = 0;
  uint64_t v263 = 0;
  uint64_t v262 = 0;
  uint64_t v261 = 0;
  int64_t v260 = 0;
  uint64_t v259 = 0;
  memset(v258, 0, sizeof(v258));
  memset(v257, 0, sizeof(v257));
  double v256 = 0;
  double v255 = 0;
  if ((*(_WORD *)(a1 + 16) & 8) == 0
    || (BOOL v195 = 0, !*(void *)(v294 + 24)) && (BOOL v195 = 0, (*(_WORD *)(v294 + 16) & 0x200) == 0))
  {
    BOOL v195 = __swsetup(v294) != 0;
  }
  if (v195)
  {
    *__error() = 9;
    return -1;
  }
  else
  {
    if ((*(unsigned char *)(*(void *)(v294 + 104) + 72) & 7) == 0) {
      *(unsigned char *)(*(void *)(v294 + 104) + 72) = *(unsigned char *)(*(void *)(v294 + 104) + 72) & 0xF8 | 1;
    }
    double v255 = 0;
    unint64_t v290 = (__int32 *)v292;
    *(void *)&v257[4] = 0;
    *(_DWORD *)int v257 = 1;
    double v256 = v291;
    io_init((uint64_t)v258, v294);
    uint64_t v284 = 0;
    int decpt = get_decpt(v293);
    while (1)
    {
LABEL_10:
      int i = v290;
      while (1)
      {
        int v289 = *v290;
        BOOL v194 = 0;
        if (v289) {
          BOOL v194 = v289 != 37;
        }
        if (!v194) {
          break;
        }
        ++v290;
      }
      uint64_t v288 = v290 - i;
      if (v288)
      {
        if (v284 + v288 >= 0x80000000) {
          goto LABEL_597;
        }
        if (io_print_0((uint64_t)v258, (uint64_t)i, v288, v293)) {
          goto LABEL_644;
        }
        v284 += v288;
      }
      if (!v289) {
        break;
      }
      int v269 = v290++;
      int v285 = 0;
      int v264 = 0;
      uint64_t v283 = 0;
      uint64_t v282 = -1;
      *((void *)&v280[0] + 1) = 0;
      int v281 = 0;
      int v299 = 0;
      int v268 = 88;
      while (2)
      {
        char v4 = v290++;
        int v289 = *v4;
LABEL_23:
        switch(v289)
        {
          case ' ':
            if (!v281) {
              int v281 = 32;
            }
            continue;
          case '#':
            v285 |= 1u;
            continue;
          case '\'':
            v285 |= 0x200u;
            continue;
          case '*':
            uint64_t v287 = 0;
            for (int i = v290; (*i - 48) <= 9; ++i)
              uint64_t v287 = 10 * v287 + *i - 48;
            if (*i == 36)
            {
              int v254 = *(_DWORD *)v257;
              if (!*(void *)&v257[4])
              {
                *(void *)&v257[4] = v297;
                if (__find_warguments(v292, v256, (uint64_t *)&v257[4]))
                {
                  uint64_t v284 = -1;
                  goto LABEL_644;
                }
              }
              *(_DWORD *)int v257 = v287;
              if (*(void *)&v257[4])
              {
                uint64_t v5 = *(int *)v257;
                ++*(_DWORD *)v257;
                int v193 = *(_DWORD *)(*(void *)&v257[4] + 16 * v5);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                char v6 = v291;
                v291 += 2;
                int v253 = *v6;
                int v193 = v253;
              }
              uint64_t v283 = v193;
              *(_DWORD *)int v257 = v254;
              unint64_t v290 = ++i;
            }
            else
            {
              if (*(void *)&v257[4])
              {
                uint64_t v7 = *(int *)v257;
                ++*(_DWORD *)v257;
                int v192 = *(_DWORD *)(*(void *)&v257[4] + 16 * v7);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                uint64_t v8 = v291;
                v291 += 2;
                int v252 = *v8;
                int v192 = v252;
              }
              uint64_t v283 = v192;
            }
            if (v283 < 0)
            {
              uint64_t v283 = -v283;
LABEL_46:
              v285 |= 4u;
            }
            continue;
          case '+':
            int v281 = 43;
            continue;
          case ',':
          case ':':
          case ';':
          case '_':
            int v268 = v289;
            continue;
          case '-':
            goto LABEL_46;
          case '.':
            BOOL v9 = v290++;
            int v289 = *v9;
            if (v289 != 42)
            {
              uint64_t v282 = 0;
              while ((v289 - 48) <= 9)
              {
                uint64_t v282 = 10 * v282 + v289 - 48;
                char v14 = v290++;
                int v289 = *v14;
              }
              goto LABEL_23;
            }
            uint64_t v287 = 0;
            for (int i = v290; (*i - 48) <= 9; ++i)
              uint64_t v287 = 10 * v287 + *i - 48;
            if (*i == 36)
            {
              int v251 = *(_DWORD *)v257;
              if (!*(void *)&v257[4])
              {
                *(void *)&v257[4] = v297;
                if (__find_warguments(v292, v256, (uint64_t *)&v257[4]))
                {
                  uint64_t v284 = -1;
                  goto LABEL_644;
                }
              }
              *(_DWORD *)int v257 = v287;
              if (*(void *)&v257[4])
              {
                uint64_t v10 = *(int *)v257;
                ++*(_DWORD *)v257;
                int v191 = *(_DWORD *)(*(void *)&v257[4] + 16 * v10);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                uint64_t v11 = v291;
                v291 += 2;
                int v250 = *v11;
                int v191 = v250;
              }
              uint64_t v282 = v191;
              *(_DWORD *)int v257 = v251;
              unint64_t v290 = ++i;
            }
            else
            {
              if (*(void *)&v257[4])
              {
                uint64_t v12 = *(int *)v257;
                ++*(_DWORD *)v257;
                int v190 = *(_DWORD *)(*(void *)&v257[4] + 16 * v12);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                size_t v13 = v291;
                v291 += 2;
                int v249 = *v13;
                int v190 = v249;
              }
              uint64_t v282 = v190;
            }
            continue;
          case '0':
            v285 |= 0x80u;
            continue;
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            uint64_t v288 = 0;
            do
            {
              uint64_t v288 = 10 * v288 + v289 - 48;
              uint64_t v15 = v290++;
              int v289 = *v15;
            }
            while ((v289 - 48) < 0xA);
            if (v289 != 36)
            {
              uint64_t v283 = v288;
              goto LABEL_23;
            }
            *(_DWORD *)int v257 = v288;
            if (!*(void *)&v257[4])
            {
              *(void *)&v257[4] = v297;
              if (__find_warguments(v292, v256, (uint64_t *)&v257[4]))
              {
                uint64_t v284 = -1;
                goto LABEL_644;
              }
            }
            continue;
          case 'A':
          case 'a':
            if ((v285 & 0x4000) != 0)
            {
              v285 |= 0x100u;
              goto LABEL_462;
            }
            if (v289 == 97)
            {
              int v299 = 120;
              int64_t v260 = (const char *)&__vfwprintf_xdigs_lower;
              char v275 = 112;
            }
            else
            {
              int v299 = 88;
              int64_t v260 = "0123456789ABCDEFn";
              char v275 = 80;
            }
            if ((v282 & 0x8000000000000000) == 0) {
              ++v282;
            }
            if ((v285 & 8) != 0)
            {
              if (*(void *)&v257[4])
              {
                uint64_t v37 = *(int *)v257;
                ++*(_DWORD *)v257;
                double v173 = *(double *)(*(void *)&v257[4] + 16 * v37);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                BOOL v38 = (double *)v291;
                v291 += 2;
                double v238 = *v38;
                double v173 = v238;
              }
              double v277 = v173;
              int v271 = (const char *)__hldtoa((uint64_t)v260, v282, &v276, &v278, &v274, v173);
            }
            else
            {
              if (*(void *)&v257[4])
              {
                uint64_t v39 = *(int *)v257;
                ++*(_DWORD *)v257;
                double v172 = *(double *)(*(void *)&v257[4] + 16 * v39);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                double v40 = (double *)v291;
                v291 += 2;
                double v237 = *v40;
                double v172 = v237;
              }
              double v277 = v172;
              int v271 = (const char *)__hdtoa((uint64_t)v260, v282, &v276, &v278, &v274, v172);
            }
            if (v282 < 0) {
              uint64_t v282 = v274 - (void)v271;
            }
            if (v276 == 0x7FFFFFFF) {
              int v299 = 0;
            }
            free(v255);
            int v272 = v274 - v271;
            double v255 = __mbsconv(v271, -1, v293);
            int i = (__int32 *)v255;
            __freedtoa((uint64_t)v271);
            goto LABEL_204;
          case 'C':
            v285 |= 0x10u;
            goto LABEL_90;
          case 'D':
            v285 |= 0x10u;
            goto LABEL_102;
          case 'E':
          case 'e':
            if ((v285 & 0x4000) != 0)
            {
              v285 |= 0x100u;
              goto LABEL_462;
            }
            char v275 = v289;
            if (v282 < 0) {
              uint64_t v282 = 7;
            }
            else {
              ++v282;
            }
            goto LABEL_185;
          case 'F':
          case 'f':
            if ((v285 & 0x4000) != 0)
            {
              v285 |= 0x100u;
              goto LABEL_462;
            }
            char v275 = 0;
            goto LABEL_185;
          case 'G':
          case 'g':
            if ((v285 & 0x4000) != 0)
            {
              v285 |= 0x100u;
            }
            else
            {
              char v275 = v289 - 2;
              if (!v282) {
                uint64_t v282 = 1;
              }
LABEL_185:
              if (v282 < 0) {
                uint64_t v282 = 6;
              }
              free(v255);
              if ((v285 & 8) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v41 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  double v171 = *(double *)(*(void *)&v257[4] + 16 * v41);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  int v42 = (double *)v291;
                  v291 += 2;
                  double v236 = *v42;
                  double v171 = v236;
                }
                double v277 = v171;
                if (v275) {
                  int v43 = 2;
                }
                else {
                  int v43 = 3;
                }
                int v271 = (const char *)__ldtoa(&v277, v43, v282, &v276, &v278, &v274);
              }
              else
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v44 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  double v170 = *(double *)(*(void *)&v257[4] + 16 * v44);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  int v45 = (double *)v291;
                  v291 += 2;
                  double v235 = *v45;
                  double v170 = v235;
                }
                double v277 = v170;
                if (v275) {
                  int v46 = 2;
                }
                else {
                  int v46 = 3;
                }
                int v271 = (const char *)__dtoa(v46, v282, &v276, &v278, &v274, v170);
                if (v276 == 9999) {
                  int v276 = 0x7FFFFFFF;
                }
              }
              int v272 = v274 - v271;
              double v255 = __mbsconv(v271, -1, v293);
              int i = (__int32 *)v255;
              __freedtoa((uint64_t)v271);
LABEL_204:
              if (v278) {
                int v281 = 45;
              }
              if (v276 == 0x7FFFFFFF)
              {
                if (*i == 78)
                {
                  uintmax_t v47 = "n";
                  if (v289 <= 96) {
                    uintmax_t v47 = "N";
                  }
                  int i = (__int32 *)v47;
                  int v281 = 0;
                }
                else
                {
                  int v48 = "i";
                  if (v289 <= 96) {
                    int v48 = "I";
                  }
                  int i = (__int32 *)v48;
                }
                uint64_t v262 = 3;
                v285 &= ~0x80u;
              }
              else
              {
                v285 |= 0x100u;
                if (v289 == 103 || v289 == 71)
                {
                  if (v276 < -3 || v276 > v282)
                  {
                    if ((v285 & 1) == 0) {
                      uint64_t v282 = v272;
                    }
                  }
                  else
                  {
                    char v275 = 0;
                    if (v285) {
                      v282 -= v276;
                    }
                    else {
                      uint64_t v282 = v272 - v276;
                    }
                    if (v282 < 0) {
                      uint64_t v282 = 0;
                    }
                  }
                }
                if (v275)
                {
                  int v273 = exponent_0(v301, v276 - 1, v275);
                  uint64_t v262 = v273 + v282;
                  if (v282 > 1 || (v285 & 1) != 0) {
                    ++v262;
                  }
                }
                else
                {
                  if (v276 < 1) {
                    uint64_t v262 = 1;
                  }
                  else {
                    uint64_t v262 = v276;
                  }
                  if (v282 || (v285 & 1) != 0) {
                    v262 += v282 + 1;
                  }
                  if ((v285 & 0x200) != 0 && v276 >= 1)
                  {
                    int inited = grouping_init_0((uint64_t)v280, v276, v293);
                    v262 += inited;
                  }
                }
              }
            }
            goto LABEL_462;
          case 'L':
            v285 |= 8u;
            continue;
          case 'O':
            v285 |= 0x10u;
            goto LABEL_262;
          case 'S':
            v285 |= 0x10u;
            goto LABEL_315;
          case 'U':
            v285 |= 0x10u;
            goto LABEL_336;
          case 'X':
            int64_t v260 = "0123456789ABCDEFn";
            goto LABEL_385;
          case 'c':
LABEL_90:
            if ((v285 & 0x4000) == 0)
            {
              if ((v285 & 0x10) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v16 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int v189 = *(_DWORD *)(*(void *)&v257[4] + 16 * v16);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  char v17 = v291;
                  v291 += 2;
                  int v248 = *v17;
                  int v189 = v248;
                }
                int i = v300;
                v300[0] = v189;
              }
              else
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v18 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int v188 = *(_DWORD *)(*(void *)&v257[4] + 16 * v18);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  unsigned __int8 v19 = v291;
                  v291 += 2;
                  int v247 = *v19;
                  int v188 = v247;
                }
                wint_t v20 = btowc_l(v188, v293);
                int i = v300;
                v300[0] = v20;
              }
              uint64_t v262 = 1;
              int v281 = 0;
            }
            goto LABEL_462;
          case 'd':
          case 'i':
LABEL_102:
            if ((v285 & 0x4000) != 0) {
              goto LABEL_462;
            }
            if ((v285 & 0x1C20) != 0)
            {
              if ((v285 & 0x1000) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v21 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int64_t v187 = *(void *)(*(void *)&v257[4] + 16 * v21);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  int v22 = (int64_t *)v291;
                  v291 += 2;
                  int64_t v246 = *v22;
                  int64_t v187 = v246;
                }
                int64_t v186 = v187;
              }
              else
              {
                if ((v285 & 0x400) != 0)
                {
                  if (*(void *)&v257[4])
                  {
                    uint64_t v23 = *(int *)v257;
                    ++*(_DWORD *)v257;
                    int64_t v185 = *(void *)(*(void *)&v257[4] + 16 * v23);
                  }
                  else
                  {
                    *(void *)int v257 = (*(_DWORD *)v257 + 1);
                    char v24 = (int64_t *)v291;
                    v291 += 2;
                    int64_t v245 = *v24;
                    int64_t v185 = v245;
                  }
                  int64_t v184 = v185;
                }
                else
                {
                  if ((v285 & 0x800) != 0)
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v25 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int64_t v183 = *(void *)(*(void *)&v257[4] + 16 * v25);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      uint64_t v26 = (uint64_t *)v291;
                      v291 += 2;
                      uint64_t v244 = *v26;
                      int64_t v183 = v244;
                    }
                    int64_t v182 = v183;
                  }
                  else
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v27 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int64_t v181 = *(void *)(*(void *)&v257[4] + 16 * v27);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      uint64_t v28 = (uint64_t *)v291;
                      v291 += 2;
                      uint64_t v243 = *v28;
                      int64_t v181 = v243;
                    }
                    int64_t v182 = v181;
                  }
                  int64_t v184 = v182;
                }
                int64_t v186 = v184;
              }
              int64_t v266 = v186;
              if (v186 < 0)
              {
                int64_t v266 = -v266;
                int v281 = 45;
              }
            }
            else
            {
              if ((v285 & 0x10) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v29 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int64_t v180 = *(void *)(*(void *)&v257[4] + 16 * v29);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  uint64_t v30 = (int64_t *)v291;
                  v291 += 2;
                  int64_t v242 = *v30;
                  int64_t v180 = v242;
                }
                int64_t v179 = v180;
              }
              else
              {
                if ((v285 & 0x40) != 0)
                {
                  if (*(void *)&v257[4])
                  {
                    uint64_t v31 = *(int *)v257;
                    ++*(_DWORD *)v257;
                    int v178 = *(_DWORD *)(*(void *)&v257[4] + 16 * v31);
                  }
                  else
                  {
                    *(void *)int v257 = (*(_DWORD *)v257 + 1);
                    int v32 = v291;
                    v291 += 2;
                    int v241 = *v32;
                    LOWORD(v178) = v241;
                  }
                  int64_t v177 = (__int16)v178;
                }
                else
                {
                  if ((v285 & 0x2000) != 0)
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v33 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int v176 = *(_DWORD *)(*(void *)&v257[4] + 16 * v33);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      int v34 = v291;
                      v291 += 2;
                      int v240 = *v34;
                      LOBYTE(v176) = v240;
                    }
                    int64_t v175 = (char)v176;
                  }
                  else
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v35 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int v174 = *(_DWORD *)(*(void *)&v257[4] + 16 * v35);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      uint64_t v36 = v291;
                      v291 += 2;
                      int v239 = *v36;
                      int v174 = v239;
                    }
                    int64_t v175 = v174;
                  }
                  int64_t v177 = v175;
                }
                int64_t v179 = v177;
              }
              int64_t v267 = v179;
              if (v179 < 0)
              {
                int64_t v267 = -v267;
                int v281 = 45;
              }
            }
            int v265 = 10;
            goto LABEL_439;
          case 'h':
            if ((v285 & 0x40) != 0)
            {
              v285 &= ~0x40u;
              v285 |= 0x2000u;
            }
            else
            {
              v285 |= 0x40u;
            }
            continue;
          case 'j':
            v285 |= 0x1000u;
            continue;
          case 'l':
            if ((v285 & 0x10) != 0)
            {
              v285 &= ~0x10u;
              v285 |= 0x20u;
            }
            else
            {
              v285 |= 0x10u;
            }
            continue;
          case 'n':
            int64_t v234 = 0;
            if (*(void *)&v257[4])
            {
              uint64_t v50 = *(int *)v257;
              ++*(_DWORD *)v257;
              int64_t v169 = *(uint64_t **)(*(void *)&v257[4] + 16 * v50);
            }
            else
            {
              *(void *)int v257 = (*(_DWORD *)v257 + 1);
              uintmax_t v51 = (uint64_t **)v291;
              v291 += 2;
              int64_t v233 = *v51;
              int64_t v169 = v233;
            }
            int64_t v234 = v169;
            if (v169)
            {
              if ((v285 & 0x20) != 0)
              {
                *int64_t v234 = v284;
              }
              else if ((v285 & 0x400) != 0)
              {
                *int64_t v234 = v284;
              }
              else if ((v285 & 0x800) != 0)
              {
                *int64_t v234 = v284;
              }
              else if ((v285 & 0x1000) != 0)
              {
                *int64_t v234 = v284;
              }
              else if ((v285 & 0x10) != 0)
              {
                *int64_t v234 = v284;
              }
              else if ((v285 & 0x40) != 0)
              {
                *(_WORD *)int64_t v234 = v284;
              }
              else if ((v285 & 0x2000) != 0)
              {
                *(unsigned char *)int64_t v234 = v284;
              }
              else
              {
                *(_DWORD *)int64_t v234 = v284;
              }
            }
            goto LABEL_10;
          case 'o':
LABEL_262:
            if ((v285 & 0x4000) != 0) {
              goto LABEL_462;
            }
            if ((v285 & 0x1C20) != 0)
            {
              if ((v285 & 0x1000) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v52 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int64_t v168 = *(void *)(*(void *)&v257[4] + 16 * v52);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  uintmax_t v53 = (int64_t *)v291;
                  v291 += 2;
                  int64_t v232 = *v53;
                  int64_t v168 = v232;
                }
                int64_t v167 = v168;
              }
              else
              {
                if ((v285 & 0x400) != 0)
                {
                  if (*(void *)&v257[4])
                  {
                    uint64_t v54 = *(int *)v257;
                    ++*(_DWORD *)v257;
                    int64_t v166 = *(void *)(*(void *)&v257[4] + 16 * v54);
                  }
                  else
                  {
                    *(void *)int v257 = (*(_DWORD *)v257 + 1);
                    uintmax_t v55 = (int64_t *)v291;
                    v291 += 2;
                    int64_t v231 = *v55;
                    int64_t v166 = v231;
                  }
                  int64_t v165 = v166;
                }
                else
                {
                  if ((v285 & 0x800) != 0)
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v56 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int64_t v164 = *(void *)(*(void *)&v257[4] + 16 * v56);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      __int16 v57 = (uint64_t *)v291;
                      v291 += 2;
                      uint64_t v230 = *v57;
                      int64_t v164 = v230;
                    }
                    int64_t v163 = v164;
                  }
                  else
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v58 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int64_t v162 = *(void *)(*(void *)&v257[4] + 16 * v58);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      char v59 = (uint64_t *)v291;
                      v291 += 2;
                      uint64_t v229 = *v59;
                      int64_t v162 = v229;
                    }
                    int64_t v163 = v162;
                  }
                  int64_t v165 = v163;
                }
                int64_t v167 = v165;
              }
              int64_t v266 = v167;
            }
            else
            {
              if ((v285 & 0x10) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v60 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int64_t v161 = *(void *)(*(void *)&v257[4] + 16 * v60);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  uintmax_t v61 = (int64_t *)v291;
                  v291 += 2;
                  int64_t v228 = *v61;
                  int64_t v161 = v228;
                }
                int64_t v160 = v161;
              }
              else
              {
                if ((v285 & 0x40) != 0)
                {
                  if (*(void *)&v257[4])
                  {
                    uint64_t v62 = *(int *)v257;
                    ++*(_DWORD *)v257;
                    int v159 = *(_DWORD *)(*(void *)&v257[4] + 16 * v62);
                  }
                  else
                  {
                    *(void *)int v257 = (*(_DWORD *)v257 + 1);
                    size_t v63 = v291;
                    v291 += 2;
                    int v227 = *v63;
                    LOWORD(v159) = v227;
                  }
                  int64_t v158 = (unsigned __int16)v159;
                }
                else
                {
                  if ((v285 & 0x2000) != 0)
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v64 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int v157 = *(_DWORD *)(*(void *)&v257[4] + 16 * v64);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      uint64_t v65 = v291;
                      v291 += 2;
                      int v226 = *v65;
                      LOBYTE(v157) = v226;
                    }
                    int64_t v156 = v157;
                  }
                  else
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v66 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      unsigned int v155 = *(_DWORD *)(*(void *)&v257[4] + 16 * v66);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      int v67 = v291;
                      v291 += 2;
                      unsigned int v225 = *v67;
                      unsigned int v155 = v225;
                    }
                    int64_t v156 = v155;
                  }
                  int64_t v158 = v156;
                }
                int64_t v160 = v158;
              }
              int64_t v267 = v160;
            }
            int v265 = 8;
            goto LABEL_438;
          case 'p':
            if ((v285 & 0x4000) != 0) {
              goto LABEL_462;
            }
            if (*(void *)&v257[4])
            {
              uint64_t v68 = *(int *)v257;
              ++*(_DWORD *)v257;
              int64_t v154 = *(void *)(*(void *)&v257[4] + 16 * v68);
            }
            else
            {
              *(void *)int v257 = (*(_DWORD *)v257 + 1);
              uint64_t v69 = (int64_t *)v291;
              v291 += 2;
              int64_t v224 = *v69;
              int64_t v154 = v224;
            }
            int64_t v266 = v154;
            int v265 = 16;
            int64_t v260 = (const char *)&__vfwprintf_xdigs_lower;
            v285 |= 0x1000u;
            int v299 = 120;
            goto LABEL_438;
          case 'q':
            v285 |= 0x20u;
            continue;
          case 's':
LABEL_315:
            if ((v285 & 0x10) != 0)
            {
              if (*(void *)&v257[4])
              {
                uint64_t v70 = *(int *)v257;
                ++*(_DWORD *)v257;
                v153 = *(__int32 **)(*(void *)&v257[4] + 16 * v70);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                wint_t v71 = (__int32 **)v291;
                v291 += 2;
                v223 = *v71;
                v153 = v223;
              }
              int i = v153;
              if (!v153) {
                int i = (__int32 *)"(";
              }
            }
            else
            {
              size_t v222 = 0;
              free(v255);
              if (*(void *)&v257[4])
              {
                uint64_t v72 = *(int *)v257;
                ++*(_DWORD *)v257;
                size_t v152 = *(const char **)(*(void *)&v257[4] + 16 * v72);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                unint64_t v73 = (const char **)v291;
                v291 += 2;
                int64_t v221 = *v73;
                size_t v152 = v221;
              }
              size_t v222 = v152;
              if (v152)
              {
                double v255 = __mbsconv(v222, v282, v293);
                if (!v255)
                {
                  *(_WORD *)(v294 + 16) |= 0x40u;
                  goto LABEL_644;
                }
                int i = (__int32 *)v255;
              }
              else
              {
                double v255 = 0;
                int i = (__int32 *)"(";
              }
            }
            uint64_t v262 = wcslen(i);
            if (v262 >= 0x7FFFFFFF) {
              goto LABEL_597;
            }
            if ((v282 & 0x8000000000000000) == 0 && v282 < v262) {
              uint64_t v262 = v282;
            }
            int v281 = 0;
LABEL_462:
            if ((v285 & 0x4000) != 0)
            {
              int j = 0;
              int v203 = 0;
              int v202 = 0;
              int v201 = 0;
              int v200 = 0;
              int v199 = 0;
              int v198 = 0;
              int v197 = 0;
              if (*(void *)&v257[4])
              {
                uint64_t v107 = *(int *)v257;
                ++*(_DWORD *)v257;
                long long v123 = *(_OWORD *)(*(void *)&v257[4] + 16 * v107);
              }
              else
              {
                *(void *)int v257 = (*(_DWORD *)v257 + 1);
                v108 = (_OWORD *)(((unint64_t)v291 + 15) & 0xFFFFFFFFFFFFFFF0);
                long long v291 = v108 + 1;
                long long v123 = *v108;
              }
              long long v270 = v123;
              if ((unint64_t)((((char *)v290 - (char *)v269 - 4) >> 2) + 2) > 0x21) {
                int v201 = (char *)malloc_type_malloc();
              }
              else {
                int v201 = v296;
              }
              if (v268 == 88)
              {
                if (v289 == 99) {
                  int v268 = 0;
                }
                else {
                  int v268 = 32;
                }
              }
              int v203 = 0;
              for (int j = 0; j < ((char *)v290 - (char *)v269 - 4) >> 2; ++j)
              {
                switch(v269[j])
                {
                  case '*':
                    if (v269[j - 1] == 46) {
                      int v199 = 1;
                    }
                    else {
                      int v200 = 1;
                    }
                    goto LABEL_479;
                  case ',':
                  case ':':
                  case ';':
                  case '_':
                  case 'h':
                  case 'l':
                  case 'v':
                    continue;
                  default:
LABEL_479:
                    __int32 v109 = v269[j];
                    uint64_t v110 = v203++;
                    v201[v110] = v109;
                    break;
                }
              }
              if ((v285 & 0x40) != 0)
              {
                if (v289 == 99)
                {
                  int v196 = 1;
                }
                else if (v289 == 112)
                {
                  int v196 = 4;
                }
                else
                {
                  uint64_t v111 = v203++;
                  v201[v111] = 104;
                  int v196 = 1;
                }
                int v202 = 8;
                goto LABEL_509;
              }
              if ((v285 & 0x10) != 0)
              {
                int v202 = 4;
                if (v289 == 112) {
                  int v112 = 5;
                }
                else {
                  int v112 = 2;
                }
                int v196 = v112;
                goto LABEL_509;
              }
              if (v289 != 65 && v289 != 69 && v289 != 71)
              {
                if (v289 == 88) {
                  goto LABEL_504;
                }
                if (v289 != 97)
                {
                  if (v289 == 99) {
                    goto LABEL_505;
                  }
                  if (v289 == 100) {
                    goto LABEL_504;
                  }
                  if ((v289 - 101) >= 3)
                  {
                    if (v289 != 112)
                    {
LABEL_504:
                      uint64_t v113 = v203++;
                      v201[v113] = 104;
                      uint64_t v114 = v203++;
                      v201[v114] = 104;
                    }
LABEL_505:
                    int v202 = 16;
                    if (v289 == 112) {
                      int v115 = 3;
                    }
                    else {
                      int v115 = 0;
                    }
                    int v196 = v115;
                    goto LABEL_509;
                  }
                }
              }
              int v202 = 4;
              int v196 = 6;
LABEL_509:
              uint64_t v116 = v203++;
              v201[v116] = v289;
              uint64_t v117 = v203++;
              v201[v117] = 0;
              if (v200)
              {
                if (v199)
                {
                  switch(v196)
                  {
                    case 0:
                    case 3:
                      int v197 = asprintf_l(&v198, v293, v201, v283, v282, v270);
                      break;
                    case 1:
                    case 4:
                      int v197 = asprintf_l(&v198, v293, v201, v283, v282, (unsigned __int16)v270);
                      break;
                    case 2:
                    case 5:
                      int v197 = asprintf_l(&v198, v293, v201, v283, v282, v270);
                      break;
                    case 6:
                      int v197 = asprintf_l(&v198, v293, v201, v283, v282, *(float *)&v270);
                      break;
                    default:
                      break;
                  }
                  v284 += v197;
                  if (io_print_0((uint64_t)v258, (uint64_t)v198, v197, v293)) {
                    goto LABEL_644;
                  }
                  free(v198);
                  for (int j = 1; j < v202; ++j)
                  {
                    if (v268 && io_print_0((uint64_t)v258, (uint64_t)&v268, 1, v293)) {
                      goto LABEL_644;
                    }
                    switch(v196)
                    {
                      case 0:
                      case 3:
                        int v197 = asprintf_l(&v198, v293, v201, v283, v282, *((unsigned __int8 *)&v270 + j));
                        break;
                      case 1:
                      case 4:
                        int v197 = asprintf_l(&v198, v293, v201, v283, v282, *((unsigned __int16 *)&v270 + j));
                        break;
                      case 2:
                      case 5:
                        int v197 = asprintf_l(&v198, v293, v201, v283, v282, *((unsigned int *)&v270 + j));
                        break;
                      case 6:
                        int v197 = asprintf_l(&v198, v293, v201, v283, v282, *((float *)&v270 + j));
                        break;
                      default:
                        break;
                    }
                    v284 += v197;
                    if (io_print_0((uint64_t)v258, (uint64_t)v198, v197, v293)) {
                      goto LABEL_644;
                    }
                    free(v198);
                  }
                }
                else
                {
                  switch(v196)
                  {
                    case 0:
                    case 3:
                      int v197 = asprintf_l(&v198, v293, v201, v283, v270);
                      break;
                    case 1:
                    case 4:
                      int v197 = asprintf_l(&v198, v293, v201, v283, (unsigned __int16)v270);
                      break;
                    case 2:
                    case 5:
                      int v197 = asprintf_l(&v198, v293, v201, v283, v270);
                      break;
                    case 6:
                      int v197 = asprintf_l(&v198, v293, v201, v283, *(float *)&v270);
                      break;
                    default:
                      break;
                  }
                  v284 += v197;
                  if (io_print_0((uint64_t)v258, (uint64_t)v198, v197, v293)) {
                    goto LABEL_644;
                  }
                  free(v198);
                  for (int j = 1; j < v202; ++j)
                  {
                    if (v268 && io_print_0((uint64_t)v258, (uint64_t)&v268, 1, v293)) {
                      goto LABEL_644;
                    }
                    switch(v196)
                    {
                      case 0:
                      case 3:
                        int v197 = asprintf_l(&v198, v293, v201, v283, *((unsigned __int8 *)&v270 + j));
                        break;
                      case 1:
                      case 4:
                        int v197 = asprintf_l(&v198, v293, v201, v283, *((unsigned __int16 *)&v270 + j));
                        break;
                      case 2:
                      case 5:
                        int v197 = asprintf_l(&v198, v293, v201, v283, *((unsigned int *)&v270 + j));
                        break;
                      case 6:
                        int v197 = asprintf_l(&v198, v293, v201, v283, *((float *)&v270 + j));
                        break;
                      default:
                        break;
                    }
                    v284 += v197;
                    if (io_print_0((uint64_t)v258, (uint64_t)v198, v197, v293)) {
                      goto LABEL_644;
                    }
                    free(v198);
                  }
                }
              }
              else if (v199)
              {
                switch(v196)
                {
                  case 0:
                  case 3:
                    int v197 = asprintf_l(&v198, v293, v201, v282, v270);
                    break;
                  case 1:
                  case 4:
                    int v197 = asprintf_l(&v198, v293, v201, v282, (unsigned __int16)v270);
                    break;
                  case 2:
                  case 5:
                    int v197 = asprintf_l(&v198, v293, v201, v282, v270);
                    break;
                  case 6:
                    int v197 = asprintf_l(&v198, v293, v201, v282, *(float *)&v270);
                    break;
                  default:
                    break;
                }
                v284 += v197;
                if (io_print_0((uint64_t)v258, (uint64_t)v198, v197, v293)) {
                  goto LABEL_644;
                }
                free(v198);
                for (int j = 1; j < v202; ++j)
                {
                  if (v268 && io_print_0((uint64_t)v258, (uint64_t)&v268, 1, v293)) {
                    goto LABEL_644;
                  }
                  switch(v196)
                  {
                    case 0:
                    case 3:
                      int v197 = asprintf_l(&v198, v293, v201, v282, *((unsigned __int8 *)&v270 + j));
                      break;
                    case 1:
                    case 4:
                      int v197 = asprintf_l(&v198, v293, v201, v282, *((unsigned __int16 *)&v270 + j));
                      break;
                    case 2:
                    case 5:
                      int v197 = asprintf_l(&v198, v293, v201, v282, *((unsigned int *)&v270 + j));
                      break;
                    case 6:
                      int v197 = asprintf_l(&v198, v293, v201, v282, *((float *)&v270 + j));
                      break;
                    default:
                      break;
                  }
                  v284 += v197;
                  if (io_print_0((uint64_t)v258, (uint64_t)v198, v197, v293)) {
                    goto LABEL_644;
                  }
                  free(v198);
                }
              }
              else
              {
                switch(v196)
                {
                  case 0:
                  case 3:
                    int v197 = asprintf_l(&v198, v293, v201, v270);
                    break;
                  case 1:
                  case 4:
                    int v197 = asprintf_l(&v198, v293, v201, (unsigned __int16)v270);
                    break;
                  case 2:
                  case 5:
                    int v197 = asprintf_l(&v198, v293, v201, v270);
                    break;
                  case 6:
                    int v197 = asprintf_l(&v198, v293, v201, *(float *)&v270);
                    break;
                  default:
                    break;
                }
                v284 += v197;
                if (io_print_0((uint64_t)v258, (uint64_t)v198, v197, v293)) {
                  goto LABEL_644;
                }
                free(v198);
                for (int j = 1; j < v202; ++j)
                {
                  if (v268 && io_print_0((uint64_t)v258, (uint64_t)&v268, 1, v293)) {
                    goto LABEL_644;
                  }
                  switch(v196)
                  {
                    case 0:
                    case 3:
                      int v197 = asprintf_l(&v198, v293, v201, *((unsigned __int8 *)&v270 + j));
                      break;
                    case 1:
                    case 4:
                      int v197 = asprintf_l(&v198, v293, v201, *((unsigned __int16 *)&v270 + j));
                      break;
                    case 2:
                    case 5:
                      int v197 = asprintf_l(&v198, v293, v201, *((unsigned int *)&v270 + j));
                      break;
                    case 6:
                      int v197 = asprintf_l(&v198, v293, v201, *((float *)&v270 + j));
                      break;
                    default:
                      break;
                  }
                  v284 += v197;
                  if (io_print_0((uint64_t)v258, (uint64_t)v198, v197, v293)) {
                    goto LABEL_644;
                  }
                  free(v198);
                }
              }
              if (v201 != v296) {
                free(v201);
              }
              goto LABEL_10;
            }
            if (v264 <= v262) {
              uint64_t v122 = v262;
            }
            else {
              uint64_t v122 = v264;
            }
            uint64_t v263 = v122;
            if (v281) {
              ++v263;
            }
            if (v299) {
              v263 += 2;
            }
            if (v283 <= v263) {
              uint64_t v121 = v263;
            }
            else {
              uint64_t v121 = v283;
            }
            uint64_t v261 = v121;
            if (v284 + v121 >= 0x80000000)
            {
LABEL_597:
              uint64_t v284 = -1;
              *__error() = 84;
              goto LABEL_644;
            }
            if ((v285 & 0x84) == 0 && io_pad_0((uint64_t)v258, (int)v283 - (int)v263, (uint64_t)" ", v293)) {
              goto LABEL_644;
            }
            if (v281 && io_print_0((uint64_t)v258, (uint64_t)&v281, 1, v293)) {
              goto LABEL_644;
            }
            if (v299)
            {
              int v298 = 48;
              if (io_print_0((uint64_t)v258, (uint64_t)&v298, 2, v293)) {
                goto LABEL_644;
              }
            }
            if ((v285 & 0x84) == 0x80
              && io_pad_0((uint64_t)v258, (int)v283 - (int)v263, (uint64_t)"0", v293))
            {
              goto LABEL_644;
            }
            if ((v285 & 0x100) != 0)
            {
              if (v275)
              {
                if (v282 > 1 || (v285 & 1) != 0)
                {
                  v118 = i++;
                  v300[0] = *v118;
                  v300[1] = decpt;
                  if (io_print_0((uint64_t)v258, (uint64_t)v300, 2, v293)
                    || io_print_0((uint64_t)v258, (uint64_t)i, v272 - 1, v293)
                    || io_pad_0((uint64_t)v258, (int)v282 - v272, (uint64_t)"0", v293))
                  {
                    goto LABEL_644;
                  }
                }
                else if (io_print_0((uint64_t)v258, (uint64_t)i, 1, v293))
                {
                  goto LABEL_644;
                }
                if (io_print_0((uint64_t)v258, (uint64_t)v301, v273, v293)) {
                  goto LABEL_644;
                }
              }
              else
              {
                if (v276 > 0)
                {
                  if (*((void *)&v280[0] + 1))
                  {
                    uint64_t v288 = (int)grouping_print_0((uint64_t)v280, (uint64_t)v258, (uint64_t)i, (unint64_t)v255 + 4 * v272, v293);
                    if (v288 < 0) {
                      goto LABEL_644;
                    }
                    i += v288;
                  }
                  else
                  {
                    if (io_printandpad_0((uint64_t)v258, (uint64_t)i, (uint64_t)v255 + 4 * v272, v276, (uint64_t)"0", v293))goto LABEL_644; {
                    i += v276;
                    }
                  }
                  if (v282 || (v285) && io_print_0((uint64_t)v258, (uint64_t)&decpt, 1, v293)) {
                    goto LABEL_644;
                  }
                }
                else
                {
                  if (io_print_0((uint64_t)v258, (uint64_t)"0", 1, v293)
                    || (v282 || (v285 & 1) != 0) && io_print_0((uint64_t)v258, (uint64_t)&decpt, 1, v293)
                    || io_pad_0((uint64_t)v258, -v276, (uint64_t)"0", v293))
                  {
                    goto LABEL_644;
                  }
                  v282 += v276;
                }
                if (io_printandpad_0((uint64_t)v258, (uint64_t)i, (uint64_t)v255 + 4 * v272, v282, (uint64_t)"0", v293))goto LABEL_644; {
              }
                }
            }
            else
            {
              if (io_pad_0((uint64_t)v258, v264 - (int)v262, (uint64_t)"0", v293)) {
                goto LABEL_644;
              }
              if (*((void *)&v280[0] + 1))
              {
                if ((grouping_print_0((uint64_t)v280, (uint64_t)v258, (uint64_t)i, (unint64_t)v301, v293) & 0x80000000) != 0) {
                  goto LABEL_644;
                }
              }
              else if (io_print_0((uint64_t)v258, (uint64_t)i, v262, v293))
              {
                goto LABEL_644;
              }
            }
            if ((v285 & 4) != 0 && io_pad_0((uint64_t)v258, (int)v283 - (int)v263, (uint64_t)" ", v293)) {
              goto LABEL_644;
            }
            v284 += v261;
            if (io_flush_0((FILE **)v258, v293)) {
              goto LABEL_644;
            }
            break;
          case 't':
            v285 |= 0x800u;
            continue;
          case 'u':
LABEL_336:
            if ((v285 & 0x4000) != 0) {
              goto LABEL_462;
            }
            if ((v285 & 0x1C20) != 0)
            {
              if ((v285 & 0x1000) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v74 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int64_t v151 = *(void *)(*(void *)&v257[4] + 16 * v74);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  int v75 = (int64_t *)v291;
                  v291 += 2;
                  int64_t v220 = *v75;
                  int64_t v151 = v220;
                }
                int64_t v150 = v151;
              }
              else
              {
                if ((v285 & 0x400) != 0)
                {
                  if (*(void *)&v257[4])
                  {
                    uint64_t v76 = *(int *)v257;
                    ++*(_DWORD *)v257;
                    int64_t v149 = *(void *)(*(void *)&v257[4] + 16 * v76);
                  }
                  else
                  {
                    *(void *)int v257 = (*(_DWORD *)v257 + 1);
                    int v77 = (int64_t *)v291;
                    v291 += 2;
                    int64_t v219 = *v77;
                    int64_t v149 = v219;
                  }
                  int64_t v148 = v149;
                }
                else
                {
                  if ((v285 & 0x800) != 0)
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v78 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int64_t v147 = *(void *)(*(void *)&v257[4] + 16 * v78);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      uint64_t v79 = (uint64_t *)v291;
                      v291 += 2;
                      uint64_t v218 = *v79;
                      int64_t v147 = v218;
                    }
                    int64_t v146 = v147;
                  }
                  else
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v80 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int64_t v145 = *(void *)(*(void *)&v257[4] + 16 * v80);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      uint64_t v81 = (uint64_t *)v291;
                      v291 += 2;
                      uint64_t v217 = *v81;
                      int64_t v145 = v217;
                    }
                    int64_t v146 = v145;
                  }
                  int64_t v148 = v146;
                }
                int64_t v150 = v148;
              }
              int64_t v266 = v150;
            }
            else
            {
              if ((v285 & 0x10) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v82 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int64_t v144 = *(void *)(*(void *)&v257[4] + 16 * v82);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  uint64_t v83 = (int64_t *)v291;
                  v291 += 2;
                  int64_t v216 = *v83;
                  int64_t v144 = v216;
                }
                int64_t v143 = v144;
              }
              else
              {
                if ((v285 & 0x40) != 0)
                {
                  if (*(void *)&v257[4])
                  {
                    uint64_t v84 = *(int *)v257;
                    ++*(_DWORD *)v257;
                    int v142 = *(_DWORD *)(*(void *)&v257[4] + 16 * v84);
                  }
                  else
                  {
                    *(void *)int v257 = (*(_DWORD *)v257 + 1);
                    uint64_t v85 = v291;
                    v291 += 2;
                    int v215 = *v85;
                    LOWORD(v142) = v215;
                  }
                  int64_t v141 = (unsigned __int16)v142;
                }
                else
                {
                  if ((v285 & 0x2000) != 0)
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v86 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int v140 = *(_DWORD *)(*(void *)&v257[4] + 16 * v86);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      uint64_t v87 = v291;
                      v291 += 2;
                      int v214 = *v87;
                      LOBYTE(v140) = v214;
                    }
                    int64_t v139 = v140;
                  }
                  else
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v88 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      unsigned int v138 = *(_DWORD *)(*(void *)&v257[4] + 16 * v88);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      __int16 v89 = v291;
                      v291 += 2;
                      unsigned int v213 = *v89;
                      unsigned int v138 = v213;
                    }
                    int64_t v139 = v138;
                  }
                  int64_t v141 = v139;
                }
                int64_t v143 = v141;
              }
              int64_t v267 = v143;
            }
            int v265 = 10;
            goto LABEL_438;
          case 'v':
            v285 |= 0x4000u;
            continue;
          case 'x':
            int64_t v260 = (const char *)&__vfwprintf_xdigs_lower;
LABEL_385:
            if ((v285 & 0x4000) != 0) {
              goto LABEL_462;
            }
            if ((v285 & 0x1C20) != 0)
            {
              if ((v285 & 0x1000) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v90 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int64_t v137 = *(void *)(*(void *)&v257[4] + 16 * v90);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  char v91 = (int64_t *)v291;
                  v291 += 2;
                  int64_t v212 = *v91;
                  int64_t v137 = v212;
                }
                int64_t v136 = v137;
              }
              else
              {
                if ((v285 & 0x400) != 0)
                {
                  if (*(void *)&v257[4])
                  {
                    uint64_t v92 = *(int *)v257;
                    ++*(_DWORD *)v257;
                    int64_t v135 = *(void *)(*(void *)&v257[4] + 16 * v92);
                  }
                  else
                  {
                    *(void *)int v257 = (*(_DWORD *)v257 + 1);
                    int v93 = (int64_t *)v291;
                    v291 += 2;
                    int64_t v211 = *v93;
                    int64_t v135 = v211;
                  }
                  int64_t v134 = v135;
                }
                else
                {
                  if ((v285 & 0x800) != 0)
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v94 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int64_t v133 = *(void *)(*(void *)&v257[4] + 16 * v94);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      int v95 = (uint64_t *)v291;
                      v291 += 2;
                      uint64_t v210 = *v95;
                      int64_t v133 = v210;
                    }
                    int64_t v132 = v133;
                  }
                  else
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v96 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int64_t v131 = *(void *)(*(void *)&v257[4] + 16 * v96);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      int v97 = (uint64_t *)v291;
                      v291 += 2;
                      uint64_t v209 = *v97;
                      int64_t v131 = v209;
                    }
                    int64_t v132 = v131;
                  }
                  int64_t v134 = v132;
                }
                int64_t v136 = v134;
              }
              int64_t v266 = v136;
            }
            else
            {
              if ((v285 & 0x10) != 0)
              {
                if (*(void *)&v257[4])
                {
                  uint64_t v98 = *(int *)v257;
                  ++*(_DWORD *)v257;
                  int64_t v130 = *(void *)(*(void *)&v257[4] + 16 * v98);
                }
                else
                {
                  *(void *)int v257 = (*(_DWORD *)v257 + 1);
                  int v99 = (int64_t *)v291;
                  v291 += 2;
                  int64_t v208 = *v99;
                  int64_t v130 = v208;
                }
                int64_t v129 = v130;
              }
              else
              {
                if ((v285 & 0x40) != 0)
                {
                  if (*(void *)&v257[4])
                  {
                    uint64_t v100 = *(int *)v257;
                    ++*(_DWORD *)v257;
                    int v128 = *(_DWORD *)(*(void *)&v257[4] + 16 * v100);
                  }
                  else
                  {
                    *(void *)int v257 = (*(_DWORD *)v257 + 1);
                    int v101 = v291;
                    v291 += 2;
                    int v207 = *v101;
                    LOWORD(v128) = v207;
                  }
                  int64_t v127 = (unsigned __int16)v128;
                }
                else
                {
                  if ((v285 & 0x2000) != 0)
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v102 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      int v126 = *(_DWORD *)(*(void *)&v257[4] + 16 * v102);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      uint64_t v103 = v291;
                      v291 += 2;
                      int v206 = *v103;
                      LOBYTE(v126) = v206;
                    }
                    int64_t v125 = v126;
                  }
                  else
                  {
                    if (*(void *)&v257[4])
                    {
                      uint64_t v104 = *(int *)v257;
                      ++*(_DWORD *)v257;
                      unsigned int v124 = *(_DWORD *)(*(void *)&v257[4] + 16 * v104);
                    }
                    else
                    {
                      *(void *)int v257 = (*(_DWORD *)v257 + 1);
                      v105 = v291;
                      v291 += 2;
                      unsigned int v205 = *v105;
                      unsigned int v124 = v205;
                    }
                    int64_t v125 = v124;
                  }
                  int64_t v127 = v125;
                }
                int64_t v129 = v127;
              }
              int64_t v267 = v129;
            }
            int v265 = 16;
            if ((v285 & 1) == 0) {
              goto LABEL_437;
            }
            if ((v285 & 0x1C20) != 0)
            {
              if (!v266) {
                goto LABEL_437;
              }
            }
            else if (!v267)
            {
              goto LABEL_437;
            }
            int v299 = v289;
LABEL_437:
            v285 &= ~0x200u;
LABEL_438:
            int v281 = 0;
LABEL_439:
            int v264 = v282;
            if ((v282 & 0x80000000) == 0) {
              v285 &= ~0x80u;
            }
            int i = v301;
            if ((v285 & 0x1C20) != 0)
            {
              if (v266 || v282 || (v285 & 1) != 0 && v265 == 8) {
                int i = __ujtoa_0(v266, i, v265, v285 & 1, (uint64_t)v260);
              }
            }
            else if (v267 || v282 || (v285 & 1) != 0 && v265 == 8)
            {
              int i = __ultoa_0(v267, i, v265, v285 & 1, (uint64_t)v260);
            }
            uint64_t v262 = ((char *)v300 - (char *)i + 128) >> 2;
            if (v262 >= 33) {
              abort_report_np((uint64_t)"%s:%s:%u: size (%zd) > BUF (%d)");
            }
            if ((v285 & 0x200) != 0 && v262)
            {
              int v106 = grouping_init_0((uint64_t)v280, v262, v293);
              v262 += v106;
            }
            goto LABEL_462;
          case 'z':
            v285 |= 0x400u;
            continue;
          default:
            if (!v289) {
              goto LABEL_643;
            }
            int i = v300;
            v300[0] = v289;
            uint64_t v262 = 1;
            int v281 = 0;
            goto LABEL_462;
        }
        break;
      }
    }
LABEL_643:
    io_flush_0((FILE **)v258, v293);
LABEL_644:
    free(v255);
    if ((*(_WORD *)(v294 + 16) & 0x40) != 0) {
      uint64_t v284 = -1;
    }
    if (*(void *)&v257[4] && *(unsigned char **)&v257[4] != v297) {
      free(*(void **)&v257[4]);
    }
    if (v284 < 0 || v284 >= 0x7FFFFFFF) {
      return -1;
    }
    else {
      return v284;
    }
  }
}

int vfwprintf(FILE *a1, const __int32 *a2, __darwin_va_list a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    BOOL v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    BOOL v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return vfwprintf_l(a1, v9, a2, a3);
  }
  else {
    return vfwprintf_l(a1, (locale_t)__global_locale, a2, a3);
  }
}

uint64_t get_decpt(_xlocale *a1)
{
  locale_t v4 = a1;
  unsigned int v3 = 0;
  memcpy(&__b, &initial_mbs, sizeof(__b));
  char v1 = localeconv_l(v4);
  if ((unint64_t)(int)mbrtowc_l((__int32 *)&v3, v1->decimal_point, *(int *)(*((void *)v4 + 166) + 64), &__b, v4) >= 0xFFFFFFFFFFFFFFFELL)return 46; {
  return v3;
  }
}

uint64_t io_print_0(uint64_t a1, uint64_t a2, int a3, _xlocale *a4)
{
  *(void *)(a1 + 24 + 16 * *(int *)(a1 + 16)) = a2;
  *(void *)(a1 + 24 + 16 * *(int *)(a1 + 16) + 8) = a3;
  *(_DWORD *)(a1 + 20) += a3;
  int v4 = *(_DWORD *)(a1 + 16) + 1;
  *(_DWORD *)(a1 + 16) = v4;
  if (v4 < 8) {
    return 0;
  }
  else {
    return __sprint_0(*(FILE **)a1, a4, a1 + 8);
  }
}

__int32 *__mbsconv(const char *a1, int a2, _xlocale *a3)
{
  memset(&__b, 0, sizeof(__b));
  int v4 = *(_DWORD *)(*((void *)a3 + 166) + 64);
  if (!a1) {
    return 0;
  }
  if (a2 < 0)
  {
    size_t v7 = strlen(a1);
    size_t v5 = 0;
  }
  else
  {
    uint64_t v8 = (char *)a1;
    size_t v5 = 0;
    uint64_t v6 = 0;
    size_t v7 = 0;
    memcpy(&__b, &initial_mbs, sizeof(__b));
    while (v6 != a2)
    {
      size_t v5 = mbrlen_l(v8, v4, &__b, a3);
      if (!v5 || v5 >= 0xFFFFFFFFFFFFFFFELL) {
        break;
      }
      v8 += v5;
      ++v6;
      v7 += v5;
    }
    if (v5 >= 0xFFFFFFFFFFFFFFFELL) {
      return 0;
    }
  }
  uint64_t v11 = (__int32 *)malloc_type_malloc();
  if (!v11) {
    return 0;
  }
  uint64_t v10 = v11;
  BOOL v9 = (char *)a1;
  memcpy(&__b, &initial_mbs, sizeof(__b));
  while (v7)
  {
    size_t v5 = mbrtowc_l(v10, v9, v7, &__b, a3);
    if (!v5 || v5 >= 0xFFFFFFFFFFFFFFFELL) {
      break;
    }
    ++v10;
    v9 += v5;
    v7 -= v5;
  }
  if (v5 < 0xFFFFFFFFFFFFFFFELL)
  {
    *uint64_t v10 = 0;
    return v11;
  }
  else
  {
    free(v11);
    return 0;
  }
}

uint64_t exponent_0(_DWORD *a1, int a2, int a3)
{
  int v11 = a2;
  *a1 = a3;
  if (a2 >= 0)
  {
    uint64_t v10 = a1 + 2;
    a1[1] = 43;
  }
  else
  {
    int v11 = -a2;
    uint64_t v10 = a1 + 2;
    a1[1] = 45;
  }
  uint64_t v8 = &v12;
  if (v11 <= 9)
  {
    if (a3 == 101 || a3 == 69)
    {
      size_t v5 = v10++;
      *size_t v5 = 48;
    }
    uint64_t v6 = v10++;
    *uint64_t v6 = v11 + 48;
  }
  else
  {
    do
    {
      uint64_t v8 = (uint64_t *)((char *)v8 - 4);
      *(_DWORD *)uint64_t v8 = v11 % 10 + 48;
      v11 /= 10;
    }
    while (v11 > 9);
    BOOL v9 = (uint64_t *)((char *)v8 - 4);
    *(_DWORD *)BOOL v9 = v11 + 48;
    while (v9 < &v12)
    {
      unsigned int v3 = v9;
      BOOL v9 = (uint64_t *)((char *)v9 + 4);
      int v4 = v10++;
      *int v4 = *(_DWORD *)v3;
    }
  }
  return v10 - a1;
}

uint64_t grouping_init_0(uint64_t a1, int a2, _xlocale *a3)
{
  unsigned int v3 = localeconv_l(a3);
  *(void *)(a1 + 8) = __fix_nogrouping(v3->grouping);
  *(_DWORD *)a1 = get_thousep(a3);
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  while (**(unsigned char **)(a1 + 8) != 127 && *(_DWORD *)(a1 + 16) > **(char **)(a1 + 8))
  {
    *(_DWORD *)(a1 + 16) -= **(char **)(a1 + 8);
    if (*(unsigned char *)(*(void *)(a1 + 8) + 1))
    {
      ++*(_DWORD *)(a1 + 20);
      ++*(void *)(a1 + 8);
    }
    else
    {
      ++*(_DWORD *)(a1 + 24);
    }
  }
  return (*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24));
}

_DWORD *__ujtoa_0(unint64_t a1, _DWORD *a2, int a3, int a4, uint64_t a5)
{
  return __ultoa_0(a1, a2, a3, a4, a5);
}

_DWORD *__ultoa_0(unint64_t a1, _DWORD *a2, int a3, int a4, uint64_t a5)
{
  unint64_t v9 = a1;
  uint64_t v8 = a2;
  if (a3 == 8)
  {
    do
    {
      *--uint64_t v8 = (v9 & 7) + 48;
      v9 >>= 3;
    }
    while (v9);
    if (a4 && *v8 != 48)
    {
      size_t v5 = v8--;
      *(v5 - 1) = 48;
    }
    return v8;
  }
  if (a3 != 10)
  {
    if (a3 != 16) {
      abort_report_np((uint64_t)"%s:%s:%u: __ultoa: invalid base=%d");
    }
    do
    {
      *--uint64_t v8 = *(char *)(a5 + (v9 & 0xF));
      v9 >>= 4;
    }
    while (v9);
    return v8;
  }
  if (a1 >= 0xA)
  {
    if (a1 <= 0x7FFFFFFFFFFFFFFFLL)
    {
      int64_t v7 = a1;
    }
    else
    {
      uint64_t v8 = a2 - 1;
      *(a2 - 1) = a1 % 0xA + 48;
      int64_t v7 = a1 / 0xA;
    }
    do
    {
      *--uint64_t v8 = v7 % 10 + 48;
      v7 /= 10;
    }
    while (v7);
    return v8;
  }
  *(a2 - 1) = a1 + 48;
  return a2 - 1;
}

uint64_t io_pad_0(uint64_t a1, int a2, uint64_t a3, _xlocale *a4)
{
  while (a2 > 0)
  {
    if (a2 < 16) {
      int v5 = a2;
    }
    else {
      int v5 = 16;
    }
    if (io_print_0(a1, a3, v5, a4)) {
      return -1;
    }
    a2 -= v5;
  }
  return 0;
}

uint64_t grouping_print_0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _xlocale *a5)
{
  if (io_printandpad_0(a2, a3, a4, *(_DWORD *)(a1 + 16), (uint64_t)"0", a5))
  {
    return -1;
  }
  else
  {
    for (unint64_t i = a3 + 4 * *(int *)(a1 + 16); ; i += 4 * **(char **)(a1 + 8))
    {
      BOOL v6 = 1;
      if (*(int *)(a1 + 20) <= 0) {
        BOOL v6 = *(_DWORD *)(a1 + 24) > 0;
      }
      if (!v6) {
        break;
      }
      if (*(int *)(a1 + 24) <= 0)
      {
        --*(void *)(a1 + 8);
        --*(_DWORD *)(a1 + 20);
      }
      else
      {
        --*(_DWORD *)(a1 + 24);
      }
      if (io_print_0(a2, a1, 1, a5)) {
        return -1;
      }
      if (io_printandpad_0(a2, i, a4, **(char **)(a1 + 8), (uint64_t)"0", a5)) {
        return -1;
      }
    }
    if (i > a4) {
      unint64_t i = a4;
    }
    return ((uint64_t)(i - a3) / 4);
  }
}

uint64_t io_printandpad_0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, _xlocale *a6)
{
  int v7 = (a3 - a2) / 4;
  if (v7 > a4) {
    int v7 = a4;
  }
  if (v7 <= 0)
  {
    int v7 = 0;
    return io_pad_0(a1, a4 - v7, a5, a6);
  }
  if (!io_print_0(a1, a2, v7, a6)) {
    return io_pad_0(a1, a4 - v7, a5, a6);
  }
  return -1;
}

uint64_t io_flush_0(FILE **a1, _xlocale *a2)
{
  return __sprint_0(*a1, a2, (uint64_t)(a1 + 1));
}

uint64_t __sprint_0(FILE *a1, _xlocale *a2, uint64_t a3)
{
  int v7 = *(uint64_t **)a3;
  while (*(_DWORD *)(a3 + 12))
  {
    uint64_t v6 = *v7;
    int v4 = v7[1];
    for (int i = 0; i < v4; ++i)
    {
      if (__xfputwc(*(_DWORD *)(v6 + 4 * i), a1, a2) == -1) {
        return -1;
      }
    }
    *(_DWORD *)(a3 + 12) -= v4;
    v7 += 2;
  }
  *(_DWORD *)(a3 + 8) = 0;
  return 0;
}

uint64_t __xfputwc(__int32 a1, FILE *a2, _xlocale *a3)
{
  __int32 v13 = a1;
  uint64_t v12 = a2;
  locale_t v11 = a3;
  memset(&__b, 0, sizeof(__b));
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  uint64_t v6 = 0;
  size_t v7 = 0;
  if ((v12->_flags & 0x200) != 0)
  {
    memcpy(&__b, &initial_mbs, sizeof(__b));
    size_t v5 = wcrtomb_l(v10, v13, &__b, v11);
    if (v5 == -1)
    {
      v12->_flags |= 0x40u;
      return -1;
    }
    else
    {
      uint64_t v8 = &v6;
      HIDWORD(v9) = v5;
      LODWORD(v9) = 1;
      uint64_t v6 = v10;
      size_t v7 = v5;
      if (__sfvwrite((uint64_t)v12, &v8) == -1) {
        return -1;
      }
      else {
        return v13;
      }
    }
  }
  else
  {
    return __fputwc(v13, v12, (uint64_t)v11);
  }
}

uint64_t get_thousep(_xlocale *a1)
{
  locale_t v4 = a1;
  unsigned int v3 = 0;
  memcpy(&__b, &initial_mbs, sizeof(__b));
  char v1 = localeconv_l(v4);
  if ((unint64_t)(int)mbrtowc_l((__int32 *)&v3, v1->thousands_sep, *(int *)(*((void *)v4 + 166) + 64), &__b, v4) >= 0xFFFFFFFFFFFFFFFELL)return 0; {
  return v3;
  }
}

int vfwscanf(FILE *a1, const __int32 *a2, __darwin_va_list a3)
{
  flockfile(a1);
  if ((char)(32 * *((unsigned char *)a1->_extra + 72)) >> 5)
  {
    char v3 = 0;
  }
  else
  {
    *((unsigned char *)a1->_extra + 72) = *((unsigned char *)a1->_extra + 72) & 0xF8 | 1;
    char v3 = 1;
  }
  if (v3)
  {
    uint64_t v10 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v11 = __locale_key;
    uint64_t v10 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v11);
  }
  if (v10) {
    int v4 = __vfwscanf((uint64_t)a1, v10, (__int32 *)a2, (__int32 **)a3);
  }
  else {
    int v4 = __vfwscanf((uint64_t)a1, (_xlocale *)__global_locale, (__int32 *)a2, (__int32 **)a3);
  }
  int v6 = v4;
  funlockfile(a1);
  return v6;
}

uint64_t __vfwscanf(uint64_t a1, _xlocale *a2, __int32 *a3, __int32 **a4)
{
  uint64_t v94 = a1;
  locale_t v93 = a2;
  uint64_t v92 = a3;
  char v91 = a4;
  wint_t v90 = 0;
  size_t v89 = 0;
  uint64_t v88 = 0;
  int i = 0;
  int v86 = 0;
  uint64_t v85 = 0;
  unsigned int v84 = 0;
  int v83 = 0;
  int base = 0;
  uint64_t v81 = 0;
  uint64_t v80 = 0;
  int v79 = 0;
  wint_t v78 = 0;
  int v77 = 0;
  __signed int n = 0;
  int v74 = 0;
  unint64_t v73 = 0;
  memset(&__b, 0, sizeof(__b));
  int v72 = 0;
  int v72 = *(_DWORD *)(*((void *)v93 + 166) + 64);
  unsigned int v84 = 0;
  int v83 = 0;
  uint64_t v80 = 0;
  uint64_t v81 = 0;
  unint64_t v73 = v91;
  while (1)
  {
    while (1)
    {
LABEL_2:
      int v4 = v92++;
      wint_t v90 = *v4;
      if (!v90) {
        return v84;
      }
      if (!iswspace_l(v90, v93)) {
        break;
      }
      while (1)
      {
        wint_t v90 = __fgetwc(v94, (uint64_t)v93);
        BOOL v57 = 0;
        if (v90 != -1) {
          BOOL v57 = iswspace_l(v90, v93) != 0;
        }
        if (!v57) {
          break;
        }
        ++v83;
      }
      if (v90 != -1) {
        __ungetwc(v90, v94, (uint64_t)v93);
      }
    }
    if (v90 == 37) {
      break;
    }
    wint_t v78 = __fgetwc(v94, (uint64_t)v93);
    if (v78 == -1) {
      goto LABEL_313;
    }
LABEL_24:
    if (v78 != v90)
    {
      __ungetwc(v78, v94, (uint64_t)v93);
      return v84;
    }
    ++v83;
  }
  size_t v89 = 0;
  int v86 = 0;
  while (2)
  {
    size_t v5 = v92++;
    wint_t v90 = *v5;
    if (v90)
    {
      uint64_t v7 = v90;
      char v6 = 1;
    }
    else
    {
      uint64_t v7 = 0;
      char v6 = 0;
    }
    if (v6) {
      return v84;
    }
    switch(v7)
    {
      case 0:
        return -1;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 26:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 32:
      case 33:
      case 34:
      case 35:
      case 38:
      case 39:
      case 40:
      case 41:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 66:
      case 68:
      case 72:
      case 73:
      case 74:
      case 75:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 84:
      case 85:
      case 86:
      case 87:
      case 89:
      case 90:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 98:
      case 107:
      case 109:
      case 114:
      case 118:
      case 119:
      case 121:
        return v84;
      case 36:
        int v74 = v89;
        if ((int)v89 < 1 || v74 > 9 || *(v92 - 3) != 37) {
          goto LABEL_313;
        }
        size_t v89 = 0;
        char v91 = v73;
        while (v74 > 1)
        {
          uint64_t v8 = (uint64_t)*v91++;
          uint64_t v71 = v8;
          --v74;
        }
        continue;
      case 37:
        while (2)
        {
          wint_t v78 = __fgetwc(v94, (uint64_t)v93);
          if (v78 == -1) {
            goto LABEL_313;
          }
          if (iswspace_l(v78, v93))
          {
            ++v83;
            continue;
          }
          goto LABEL_24;
        }
      case 42:
        v86 |= 8u;
        continue;
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        size_t v89 = 10 * v89 + v90 - 48;
        continue;
      case 65:
      case 69:
      case 70:
      case 71:
      case 97:
      case 101:
      case 102:
      case 103:
        wint_t v90 = 4;
        goto LABEL_88;
      case 67:
        v86 |= 1u;
        goto LABEL_67;
      case 76:
        v86 |= 2u;
        continue;
      case 83:
        v86 |= 1u;
        goto LABEL_55;
      case 88:
      case 120:
        v86 |= 0x100u;
        wint_t v90 = 3;
        v86 |= 0x8000u;
        int base = 16;
        goto LABEL_88;
      case 91:
        uint64_t v81 = v92;
        if (*v92 == 94)
        {
          int v79 = 1;
          ++v92;
        }
        else
        {
          int v79 = 0;
        }
        if (*v92 == 93) {
          ++v92;
        }
        while (1)
        {
          BOOL v56 = 0;
          if (*v92) {
            BOOL v56 = *v92 != 93;
          }
          if (!v56) {
            break;
          }
          ++v92;
        }
        uint64_t v80 = v92++;
        v86 |= 0x20u;
        wint_t v90 = 1;
        goto LABEL_88;
      case 99:
LABEL_67:
        v86 |= 0x20u;
        wint_t v90 = 0;
        goto LABEL_88;
      case 100:
        wint_t v90 = 3;
        int base = 10;
        goto LABEL_88;
      case 104:
        if ((v86 & 4) != 0)
        {
          v86 &= ~4u;
          v86 |= 0x4000u;
        }
        else
        {
          v86 |= 4u;
        }
        continue;
      case 105:
        wint_t v90 = 3;
        int base = 0;
        goto LABEL_88;
      case 106:
        v86 |= 0x800u;
        continue;
      case 108:
        if (v86)
        {
          v86 &= ~1u;
          v86 |= 0x400u;
        }
        else
        {
          v86 |= 1u;
        }
        continue;
      case 110:
        if ((v86 & 8) == 0)
        {
          uint64_t v70 = 0;
          uint64_t v9 = *v91++;
          uint64_t v69 = v9;
          uint64_t v70 = v9;
          if (v9)
          {
            if ((v86 & 0x4000) != 0)
            {
              *uint64_t v70 = v83;
            }
            else if ((v86 & 4) != 0)
            {
              *(_WORD *)uint64_t v70 = v83;
            }
            else if (v86)
            {
              *(void *)uint64_t v70 = v83;
            }
            else if ((v86 & 0x400) != 0)
            {
              *(void *)uint64_t v70 = v83;
            }
            else if ((v86 & 0x800) != 0)
            {
              *(void *)uint64_t v70 = v83;
            }
            else if ((v86 & 0x2000) != 0)
            {
              *(void *)uint64_t v70 = v83;
            }
            else if ((v86 & 0x1000) != 0)
            {
              *(void *)uint64_t v70 = v83;
            }
            else
            {
              *(_DWORD *)uint64_t v70 = v83;
            }
          }
        }
        goto LABEL_2;
      case 111:
        wint_t v90 = 3;
        v86 |= 0x8000u;
        int base = 8;
        goto LABEL_88;
      case 112:
        v86 |= 0x110u;
        wint_t v90 = 3;
        v86 |= 0x8000u;
        int base = 16;
        goto LABEL_88;
      case 113:
        v86 |= 0x400u;
        continue;
      case 115:
LABEL_55:
        wint_t v90 = 2;
        goto LABEL_88;
      case 116:
        v86 |= 0x1000u;
        continue;
      case 117:
        wint_t v90 = 3;
        v86 |= 0x8000u;
        int base = 10;
LABEL_88:
        if ((v86 & 0x20) != 0) {
          goto LABEL_95;
        }
        while (1)
        {
          wint_t v78 = __fgetwc(v94, (uint64_t)v93);
          BOOL v55 = 0;
          if (v78 != -1) {
            BOOL v55 = iswspace_l(v78, v93) != 0;
          }
          if (!v55) {
            break;
          }
          ++v83;
        }
        if (v78 == -1) {
          goto LABEL_313;
        }
        __ungetwc(v78, v94, (uint64_t)v93);
LABEL_95:
        if (v90)
        {
          uint64_t v11 = v90;
          char v10 = 1;
        }
        else
        {
          uint64_t v11 = 0;
          char v10 = 0;
        }
        if (v10) {
          goto LABEL_2;
        }
        break;
      case 122:
        v86 |= 0x2000u;
        continue;
      default:
LABEL_319:
        JUMPOUT(0);
    }
    break;
  }
  switch(v11)
  {
    case 0:
      if (!v89) {
        size_t v89 = 1;
      }
      if (v86)
      {
        if ((v86 & 8) == 0)
        {
          uint64_t v12 = *v91++;
          uint64_t v68 = v12;
          uint64_t v88 = v12;
        }
        for (int i = 0; ; ++i)
        {
          uint64_t v13 = v89--;
          BOOL v54 = 0;
          if (v13)
          {
            wint_t v78 = __fgetwc(v94, (uint64_t)v93);
            BOOL v54 = v78 != -1;
          }
          if (!v54) {
            break;
          }
          if ((v86 & 8) == 0)
          {
            char v14 = v88++;
            *char v14 = v78;
          }
        }
        if (!i) {
          goto LABEL_313;
        }
        v83 += i;
        if ((v86 & 8) == 0) {
          ++v84;
        }
      }
      else
      {
        if ((v86 & 8) == 0)
        {
          uint64_t v15 = (char *)*v91++;
          int v67 = v15;
          int v77 = v15;
        }
        int i = 0;
        memcpy(&__b, &initial_mbs_0, sizeof(__b));
        while (1)
        {
          BOOL v53 = 0;
          if (v89)
          {
            wint_t v78 = __fgetwc(v94, (uint64_t)v93);
            BOOL v53 = v78 != -1;
          }
          if (!v53) {
            break;
          }
          if (v89 < v72 || (v86 & 8) != 0)
          {
            __signed int n = wcrtomb_l(__src, v78, &__b, v93);
            if (__n == -1) {
              goto LABEL_313;
            }
            if (__n > v89)
            {
              __ungetwc(v78, v94, (uint64_t)v93);
              break;
            }
            if ((v86 & 8) == 0) {
              memcpy(v77, __src, __n);
            }
          }
          else
          {
            __signed int n = wcrtomb_l(v77, v78, &__b, v93);
            if (__n == -1) {
              goto LABEL_313;
            }
          }
          if ((v86 & 8) == 0) {
            v77 += __n;
          }
          v89 -= __n;
          ++i;
        }
        if (!i)
        {
LABEL_313:
          if (v84) {
            return v84;
          }
          else {
            return -1;
          }
        }
        v83 += i;
        if ((v86 & 8) == 0) {
          ++v84;
        }
      }
      goto LABEL_2;
    case 1:
      if (!v89) {
        size_t v89 = -1;
      }
      if (v86 & 8) != 0 && (v86)
      {
        for (int i = 0; ; ++i)
        {
          wint_t v78 = __fgetwc(v94, (uint64_t)v93);
          BOOL v52 = 0;
          if (v78 != -1)
          {
            uint64_t v16 = v89--;
            BOOL v52 = 0;
            if (v16)
            {
              if (v79) {
                BOOL v51 = wmemchr(v81, v78, v80 - v81) == 0;
              }
              else {
                BOOL v51 = wmemchr(v81, v78, v80 - v81) != 0;
              }
              BOOL v52 = v51;
            }
          }
          if (!v52) {
            break;
          }
        }
        if (v78 != -1) {
          __ungetwc(v78, v94, (uint64_t)v93);
        }
        if (!i) {
          return v84;
        }
      }
      else if (v86)
      {
        char v17 = *v91++;
        uint64_t v66 = v17;
        uint64_t v88 = v17;
        uint64_t v85 = v17;
        while (1)
        {
          wint_t v78 = __fgetwc(v94, (uint64_t)v93);
          BOOL v50 = 0;
          if (v78 != -1)
          {
            uint64_t v18 = v89--;
            BOOL v50 = 0;
            if (v18)
            {
              if (v79) {
                BOOL v49 = wmemchr(v81, v78, v80 - v81) == 0;
              }
              else {
                BOOL v49 = wmemchr(v81, v78, v80 - v81) != 0;
              }
              BOOL v50 = v49;
            }
          }
          if (!v50) {
            break;
          }
          unsigned __int8 v19 = v88++;
          *unsigned __int8 v19 = v78;
        }
        if (v78 != -1) {
          __ungetwc(v78, v94, (uint64_t)v93);
        }
        int i = v88 - v85;
        if (!i) {
          return v84;
        }
        *uint64_t v88 = 0;
        ++v84;
      }
      else
      {
        if ((v86 & 8) == 0)
        {
          wint_t v20 = (char *)*v91++;
          uint64_t v65 = v20;
          int v77 = v20;
        }
        int i = 0;
        memcpy(&__b, &initial_mbs_0, sizeof(__b));
        while (1)
        {
          wint_t v78 = __fgetwc(v94, (uint64_t)v93);
          BOOL v48 = 0;
          if (v78 != -1)
          {
            BOOL v48 = 0;
            if (v89)
            {
              if (v79) {
                BOOL v47 = wmemchr(v81, v78, v80 - v81) == 0;
              }
              else {
                BOOL v47 = wmemchr(v81, v78, v80 - v81) != 0;
              }
              BOOL v48 = v47;
            }
          }
          if (!v48) {
            break;
          }
          if (v89 < v72 || (v86 & 8) != 0)
          {
            __signed int n = wcrtomb_l(__src, v78, &__b, v93);
            if (__n == -1) {
              goto LABEL_313;
            }
            if (__n > v89) {
              break;
            }
            if ((v86 & 8) == 0) {
              memcpy(v77, __src, __n);
            }
          }
          else
          {
            __signed int n = wcrtomb_l(v77, v78, &__b, v93);
            if (__n == -1) {
              goto LABEL_313;
            }
          }
          if ((v86 & 8) == 0) {
            v77 += __n;
          }
          v89 -= __n;
          ++i;
        }
        if (v78 == -1)
        {
          if (!v84) {
            return -1;
          }
        }
        else
        {
          __ungetwc(v78, v94, (uint64_t)v93);
        }
        if (!i) {
          return v84;
        }
        if ((v86 & 8) == 0)
        {
          *int v77 = 0;
          ++v84;
        }
      }
      v83 += i;
      goto LABEL_2;
    case 2:
      if (!v89) {
        size_t v89 = -1;
      }
      if (v86 & 8) != 0 && (v86)
      {
        while (1)
        {
          wint_t v78 = __fgetwc(v94, (uint64_t)v93);
          BOOL v46 = 0;
          if (v78 != -1)
          {
            uint64_t v21 = v89--;
            BOOL v46 = 0;
            if (v21) {
              BOOL v46 = iswspace_l(v78, v93) == 0;
            }
          }
          if (!v46) {
            break;
          }
          ++v83;
        }
        if (v78 != -1) {
          __ungetwc(v78, v94, (uint64_t)v93);
        }
        goto LABEL_2;
      }
      if (v86)
      {
        int v22 = *v91++;
        uint64_t v64 = v22;
        uint64_t v88 = v22;
        uint64_t v85 = v22;
        while (1)
        {
          wint_t v78 = __fgetwc(v94, (uint64_t)v93);
          BOOL v45 = 0;
          if (v78 != -1)
          {
            uint64_t v23 = v89--;
            BOOL v45 = 0;
            if (v23) {
              BOOL v45 = iswspace_l(v78, v93) == 0;
            }
          }
          if (!v45) {
            break;
          }
          char v24 = v88++;
          *char v24 = v78;
          ++v83;
        }
        if (v78 != -1) {
          __ungetwc(v78, v94, (uint64_t)v93);
        }
        *uint64_t v88 = 0;
        ++v84;
        goto LABEL_2;
      }
      if ((v86 & 8) == 0)
      {
        uint64_t v25 = (char *)*v91++;
        size_t v63 = v25;
        int v77 = v25;
      }
      memcpy(&__b, &initial_mbs_0, sizeof(__b));
      while (2)
      {
        wint_t v78 = __fgetwc(v94, (uint64_t)v93);
        BOOL v44 = 0;
        if (v78 != -1)
        {
          BOOL v44 = 0;
          if (v89) {
            BOOL v44 = iswspace_l(v78, v93) == 0;
          }
        }
        if (!v44) {
          break;
        }
        if (v89 >= v72 && (v86 & 8) == 0)
        {
          __signed int n = wcrtomb_l(v77, v78, &__b, v93);
          if (__n == -1) {
            goto LABEL_313;
          }
          goto LABEL_235;
        }
        __signed int n = wcrtomb_l(__src, v78, &__b, v93);
        if (__n == -1) {
          goto LABEL_313;
        }
        if (__n <= v89)
        {
          if ((v86 & 8) == 0) {
            memcpy(v77, __src, __n);
          }
LABEL_235:
          if ((v86 & 8) == 0) {
            v77 += __n;
          }
          v89 -= __n;
          ++v83;
          continue;
        }
        break;
      }
      if (v78 != -1) {
        __ungetwc(v78, v94, (uint64_t)v93);
      }
      if ((v86 & 8) == 0)
      {
        *int v77 = 0;
        ++v84;
      }
      goto LABEL_2;
    case 3:
      if (!v89 || v89 > 0x200) {
        size_t v89 = 512;
      }
      v86 |= 0x2C0u;
      uint64_t v88 = nptr;
      while (2)
      {
        if (v89)
        {
          unsigned int v26 = __fgetwc(v94, (uint64_t)v93);
          wint_t v90 = v26;
          if (v26 <= 0x2B)
          {
            uint64_t v28 = v26 - 43;
            char v27 = 0;
          }
          else
          {
            uint64_t v28 = v26 - 43;
            char v27 = 1;
          }
          if ((v27 & 1) == 0)
          {
            switch(v28)
            {
              case 0:
              case 2:
                if ((v86 & 0x40) == 0) {
                  goto LABEL_269;
                }
                v86 &= ~0x40u;
                v86 |= 0x10000u;
                break;
              case 1:
              case 3:
              case 4:
              case 15:
              case 16:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 28:
              case 29:
              case 30:
              case 31:
              case 32:
              case 33:
              case 34:
              case 35:
              case 36:
              case 37:
              case 38:
              case 39:
              case 40:
              case 41:
              case 42:
              case 43:
              case 44:
              case 46:
              case 47:
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 60:
              case 61:
              case 62:
              case 63:
              case 64:
              case 65:
              case 66:
              case 67:
              case 68:
              case 69:
              case 70:
              case 71:
              case 72:
              case 73:
              case 74:
              case 75:
              case 76:
                goto LABEL_269;
              case 5:
                if (!base)
                {
                  int base = 8;
                  v86 |= 0x100u;
                }
                if ((v86 & 0x200) != 0) {
                  v86 &= 0xFFFFFD3F;
                }
                else {
                  v86 &= 0xFFFFFE3F;
                }
                break;
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
              case 11:
              case 12:
                int base = __vfwscanf_basefix[base];
                v86 &= 0xFFFFFE3F;
                break;
              case 13:
              case 14:
                int base = __vfwscanf_basefix[base];
                if (base <= 8) {
                  goto LABEL_269;
                }
                v86 &= 0xFFFFFE3F;
                break;
              case 22:
              case 23:
              case 24:
              case 25:
              case 26:
              case 27:
              case 54:
              case 55:
              case 56:
              case 57:
              case 58:
              case 59:
                if (base <= 10) {
                  goto LABEL_269;
                }
                v86 &= 0xFFFFFE3F;
                break;
              case 45:
              case 77:
                if ((v86 & 0x100) == 0 || v88 != &nptr[((v86 & 0x10000) != 0) + 1]) {
                  goto LABEL_269;
                }
                int base = 16;
                v86 &= ~0x100u;
                break;
              default:
                goto LABEL_319;
            }
            uint64_t v29 = v88++;
            *uint64_t v29 = v90;
            --v89;
            continue;
          }
LABEL_269:
          if (v90 != -1) {
            __ungetwc(v90, v94, (uint64_t)v93);
          }
        }
        break;
      }
      if ((v86 & 0x80u) == 0)
      {
        wint_t v90 = *(v88 - 1);
        if (v90 == 120 || v90 == 88)
        {
          --v88;
          __ungetwc(v90, v94, (uint64_t)v93);
        }
        if ((v86 & 8) == 0)
        {
          uintmax_t v62 = 0;
          *uint64_t v88 = 0;
          if ((v86 & 0x8000u) != 0) {
            uintmax_t v62 = wcstoumax_l(nptr, 0, base, v93);
          }
          else {
            uintmax_t v62 = wcstoimax_l(nptr, 0, base, v93);
          }
          if ((v86 & 0x10) != 0)
          {
            uint64_t v30 = *v91++;
            v61[9] = v30;
            *(void *)uint64_t v30 = v62;
          }
          else if ((v86 & 0x4000) != 0)
          {
            uint64_t v31 = *v91++;
            v61[8] = v31;
            *(unsigned char *)uint64_t v31 = v62;
          }
          else if ((v86 & 4) != 0)
          {
            int v32 = *v91++;
            v61[7] = v32;
            *(_WORD *)int v32 = v62;
          }
          else if (v86)
          {
            uint64_t v33 = *v91++;
            v61[6] = v33;
            *(void *)uint64_t v33 = v62;
          }
          else if ((v86 & 0x400) != 0)
          {
            int v34 = *v91++;
            v61[5] = v34;
            *(void *)int v34 = v62;
          }
          else if ((v86 & 0x800) != 0)
          {
            uint64_t v35 = *v91++;
            v61[4] = v35;
            *(void *)uint64_t v35 = v62;
          }
          else if ((v86 & 0x1000) != 0)
          {
            uint64_t v36 = *v91++;
            v61[3] = v36;
            *(void *)uint64_t v36 = v62;
          }
          else
          {
            uint64_t v37 = *v91++;
            if ((v86 & 0x2000) != 0)
            {
              v61[2] = v37;
              *(void *)uint64_t v37 = v62;
            }
            else
            {
              v61[1] = v37;
              *uint64_t v37 = v62;
            }
          }
          ++v84;
        }
        v83 += v88 - nptr;
        goto LABEL_2;
      }
      if (v88 > nptr) {
        __ungetwc(*--v88, v94, (uint64_t)v93);
      }
      return v84;
    case 4:
      v61[0] = 0;
      int v38 = parsefloat_0(v94, (unsigned int **)v61, v89, v93);
      size_t v89 = v38;
      if (!v38) {
        return v84;
      }
      if ((v86 & 8) == 0)
      {
        if ((v86 & 2) != 0)
        {
          long double v60 = wcstold_l(v61[0], &v88, v93);
          uint64_t v39 = (long double *)*v91++;
          *uint64_t v39 = v60;
        }
        else if (v86)
        {
          double v59 = wcstod_l(v61[0], &v88, v93);
          double v40 = (double *)*v91++;
          *double v40 = v59;
        }
        else
        {
          float v58 = wcstof_l(v61[0], &v88, v93);
          uint64_t v41 = (float *)*v91++;
          *uint64_t v41 = v58;
        }
        ++v84;
      }
      v83 += v89;
      goto LABEL_2;
    default:
      goto LABEL_319;
  }
}

int vfwscanf_l(FILE *a1, locale_t a2, const __int32 *a3, __darwin_va_list a4)
{
  uint64_t v8 = a2;
  if (a2)
  {
    if (a2 == (locale_t)-1) {
      uint64_t v8 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v8 = (_xlocale *)&__c_locale;
  }
  flockfile(a1);
  if (!((char)(32 * *((unsigned char *)a1->_extra + 72)) >> 5)) {
    *((unsigned char *)a1->_extra + 72) = *((unsigned char *)a1->_extra + 72) & 0xF8 | 1;
  }
  int v5 = __vfwscanf((uint64_t)a1, v8, (__int32 *)a3, (__int32 **)a4);
  funlockfile(a1);
  return v5;
}

uint64_t parsefloat_0(uint64_t a1, unsigned int **a2, uint64_t a3, _xlocale *a4)
{
  uint64_t v28 = a1;
  char v27 = a2;
  uint64_t v26 = a3;
  locale_t v25 = a4;
  size_t v24 = 0;
  uint64_t v23 = 0;
  int v22 = 0;
  int v21 = 0;
  unsigned int v20 = 0;
  wint_t v19 = 0;
  __int32 v18 = 0;
  char v17 = 0;
  char v16 = 0;
  memcpy(&__b, &initial_mbs_0, sizeof(__b));
  int v4 = localeconv();
  size_t v24 = mbrtowc_l(&v18, v4->decimal_point, *(int *)(*((void *)v25 + 166) + 64), &__b, v25);
  if (v24 >= 0xFFFFFFFFFFFFFFFELL) {
    __int32 v18 = 46;
  }
  if (v26) {
    uint64_t v10 = v26 + 1;
  }
  else {
    uint64_t v10 = 513;
  }
  uint64_t v13 = v10;
  uint64_t v15 = (unsigned int *)__parsefloat_buf(4 * v10);
  if (!v15)
  {
    *char v27 = 0;
    return 0;
  }
  char v14 = &v15[v10 - 1];
  uint64_t v23 = v15 - 1;
  wint_t v19 = -1;
  int v22 = v15;
LABEL_9:
  BOOL v9 = 1;
  if (v26) {
    BOOL v9 = v22 < v14;
  }
  if (!v9) {
    goto LABEL_94;
  }
  wint_t v19 = __fgetwc(v28, (uint64_t)v25);
  if (v19 == -1) {
    goto LABEL_94;
  }
  while (2)
  {
    if (v20)
    {
      uint64_t v6 = v20;
      char v5 = 1;
    }
    else
    {
      uint64_t v6 = 0;
      char v5 = 0;
    }
    if (v5) {
      abort_report_np((uint64_t)"%s:%s:%u: unknown state %d");
    }
    switch(v6)
    {
      case 0:
        unsigned int v20 = 1;
        if (v19 == 45 || v19 == 43) {
          goto LABEL_89;
        }
        continue;
      case 1:
        switch(v19)
        {
          case '0':
            unsigned int v20 = 5;
            uint64_t v23 = v22;
            goto LABEL_89;
          case 'I':
            goto LABEL_29;
          case 'N':
LABEL_30:
            unsigned int v20 = 3;
            goto LABEL_89;
          case 'i':
LABEL_29:
            unsigned int v20 = 2;
            goto LABEL_89;
          case 'n':
            goto LABEL_30;
        }
        unsigned int v20 = 6;
        continue;
      case 2:
        if (v21 > 6 || v19 != aNfinity[v21] && v19 != aNfinity_0[v21]) {
          goto LABEL_94;
        }
        if (v21 == 1 || v21 == 6) {
          uint64_t v23 = v22;
        }
        ++v21;
        goto LABEL_89;
      case 3:
        if (v21)
        {
          if (v21 == 1)
          {
            if (v19 == 78 || v19 == 110)
            {
              uint64_t v23 = v22;
LABEL_55:
              ++v21;
              goto LABEL_89;
            }
          }
          else if (v21 == 2)
          {
            if (v19 == 40) {
              goto LABEL_55;
            }
          }
          else
          {
            if (v19 == 41)
            {
              uint64_t v23 = v22;
              unsigned int v20 = 4;
              goto LABEL_55;
            }
            if (iswalnum_l(v19, v25) || v19 == 95) {
              goto LABEL_55;
            }
          }
        }
        else if (v19 == 65 || v19 == 97)
        {
          goto LABEL_55;
        }
LABEL_94:
        if (v19 != -1) {
          __ungetwc(v19, v28, (uint64_t)v25);
        }
        while (v23 < --v22)
          __ungetwc(*v22, v28, (uint64_t)v25);
        *++uint64_t v23 = 0;
        *char v27 = v15;
        return (v23 - v15);
      case 4:
        goto LABEL_94;
      case 5:
        unsigned int v20 = 6;
        if (v19 == 88 || v19 == 120)
        {
          char v16 = 1;
          goto LABEL_89;
        }
        char v17 = 1;
        continue;
      case 6:
        if (((v16 & 1) == 0 || !iswxdigit_l(v19, v25)) && !iswdigit_l(v19, v25))
        {
          unsigned int v20 = 7;
          if (v19 == v18) {
            goto LABEL_65;
          }
          continue;
        }
        char v17 = 1;
LABEL_65:
        if (v17) {
          uint64_t v23 = v22;
        }
LABEL_89:
        if (v22 >= v14)
        {
          uint64_t v12 = v22 - v15;
          uint64_t v11 = v23 - v15;
          v13 += 513;
          uint64_t v15 = (unsigned int *)__parsefloat_buf(4 * v13);
          if (!v15)
          {
            *char v27 = 0;
            return 0;
          }
          char v14 = &v15[v13 - 1];
          int v22 = &v15[v12];
          uint64_t v23 = &v15[v11];
        }
        uint64_t v7 = (wint_t *)v22++;
        *uint64_t v7 = v19;
        wint_t v19 = -1;
        goto LABEL_9;
      case 7:
        if (v19 == 69 || v19 == 101) && (v16 & 1) == 0 || (v19 == 80 || v19 == 112) && (v16)
        {
          if (v17)
          {
            unsigned int v20 = 8;
            goto LABEL_89;
          }
        }
        else if ((v16 & 1) != 0 && iswxdigit_l(v19, v25) || iswdigit_l(v19, v25))
        {
          uint64_t v23 = v22;
          char v17 = 1;
          goto LABEL_89;
        }
        goto LABEL_94;
      case 8:
        unsigned int v20 = 9;
        if (v19 == 45 || v19 == 43) {
          goto LABEL_89;
        }
        continue;
      case 9:
        if (!iswdigit_l(v19, v25)) {
          goto LABEL_94;
        }
        uint64_t v23 = v22;
        goto LABEL_89;
      default:
        JUMPOUT(0);
    }
  }
}

int vprintf(const char *a1, va_list a2)
{
  char v5 = __stdoutp;
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v8 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    uint64_t v8 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    return vfprintf_l(v5, v8, a1, a2);
  }
  else {
    return vfprintf_l(v5, (locale_t)__global_locale, a1, a2);
  }
}

int vprintf_l(locale_t a1, const char *a2, va_list a3)
{
  return vfprintf_l(__stdoutp, a1, a2, a3);
}

int vscanf(const char *__format, va_list a2)
{
  flockfile(__stdinp);
  uint64_t v6 = (int *)__stdinp;
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    uint64_t v10 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v11 = __locale_key;
    uint64_t v10 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v11);
  }
  if (v10) {
    int v4 = __svfscanf_l(v6, v10, (unsigned __int8 *)__format, (uint64_t *)a2);
  }
  else {
    int v4 = __svfscanf_l(v6, (_xlocale *)__global_locale, (unsigned __int8 *)__format, (uint64_t *)a2);
  }
  int v7 = v4;
  funlockfile(__stdinp);
  return v7;
}

int vscanf_l(locale_t a1, const char *a2, va_list a3)
{
  int v7 = a1;
  if (a1)
  {
    if (a1 == (locale_t)-1) {
      int v7 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    int v7 = (_xlocale *)&__c_locale;
  }
  flockfile(__stdinp);
  int v4 = __svfscanf_l((int *)__stdinp, v7, (unsigned __int8 *)a2, (uint64_t *)a3);
  funlockfile(__stdinp);
  return v4;
}

uint64_t _vsnprintf(uint64_t a1, pthread_rwlock_t *a2, char *a3, unint64_t a4, _xlocale *a5, char *a6, int *a7)
{
  uint64_t v18 = a1;
  char v17 = a2;
  char v16 = a3;
  unint64_t v15 = a4;
  char v14 = a5;
  uint64_t v13 = a6;
  uint64_t v12 = a7;
  unsigned int v10 = 0;
  memset(__b, 0, sizeof(__b));
  memset(v20, 0, sizeof(v20));
  void __b[13] = v20;
  v20[0] = 0;
  memset(v19, 0, sizeof(v19));
  v19[0] = 850045858;
  memcpy(&v20[1], v19, 0x40uLL);
  LOBYTE(v20[9]) &= 0xF8u;
  memset(&v20[10], 0, 0x80uLL);
  LOBYTE(v20[9]) &= ~8u;
  unint64_t v11 = v15;
  if (v15) {
    --v15;
  }
  if (v15 > 0x7FFFFFFF) {
    unint64_t v15 = 0x7FFFFFFFLL;
  }
  if (!v15)
  {
    if (v11) {
      *char v16 = 0;
    }
    char v16 = &v9;
    unint64_t v15 = 1;
  }
  LODWORD(__b[2]) = -65016;
  __b[0] = v16;
  __b[3] = v16;
  HIDWORD(__b[1]) = v15;
  LODWORD(__b[4]) = v15;
  *(unsigned char *)(__b[13] + 72) &= 0xF8u;
  memset((void *)(__b[13] + 80), 0, 0x80uLL);
  unsigned int v10 = __v2printf(v18, v17, (uint64_t)__b, v14, v13, v12);
  if (v11) {
    *(unsigned char *)__b[0] = 0;
  }
  return v10;
}

int vsnprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, va_list a5)
{
  return _vsnprintf(-1, 0, a1, a2, a3, (char *)a4, (int *)a5);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    unint64_t v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    unint64_t v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    return _vsnprintf(-1, 0, __str, __size, v11, (char *)__format, (int *)a4);
  }
  else {
    return _vsnprintf(-1, 0, __str, __size, (_xlocale *)__global_locale, (char *)__format, (int *)a4);
  }
}

int vsprintf_l(char *a1, locale_t a2, const char *a3, va_list a4)
{
  unsigned int v10 = a1;
  locale_t v9 = a2;
  uint64_t v8 = a3;
  va_list v7 = a4;
  int v6 = 0;
  memset(__b, 0, sizeof(__b));
  memset(v12, 0, sizeof(v12));
  void __b[13] = v12;
  v12[0] = 0;
  memset(v11, 0, sizeof(v11));
  v11[0] = 850045858;
  memcpy(&v12[1], v11, 0x40uLL);
  LOBYTE(v12[9]) &= 0xF8u;
  LOBYTE(v12[9]) &= ~8u;
  LODWORD(__b[2]) = -65016;
  __b[0] = v10;
  __b[3] = v10;
  HIDWORD(__b[1]) = 0x7FFFFFFF;
  LODWORD(__b[4]) = 0x7FFFFFFF;
  LOBYTE(v12[9]) &= 0xF8u;
  memset(&v12[10], 0, 0x80uLL);
  int v6 = __v2printf(-1, 0, __b, v9, v8, v7);
  *(unsigned char *)__b[0] = 0;
  return v6;
}

int vsprintf(char *a1, const char *a2, va_list a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    locale_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    locale_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return vsprintf_l(a1, v9, a2, a3);
  }
  else {
    return vsprintf_l(a1, (locale_t)__global_locale, a2, a3);
  }
}

int vsscanf_l(const char *a1, locale_t a2, const char *a3, va_list a4)
{
  __s = (char *)a1;
  uint64_t v8 = a2;
  va_list v7 = (unsigned __int8 *)a3;
  int v6 = (uint64_t *)a4;
  memset(__b, 0, sizeof(__b));
  memset(v11, 0, sizeof(v11));
  void __b[13] = v11;
  v11[0] = 0;
  memset(v10, 0, sizeof(v10));
  v10[0] = 850045858;
  memcpy(&v11[1], v10, 0x40uLL);
  LOBYTE(v11[9]) &= 0xF8u;
  memset(&v11[10], 0, 0x80uLL);
  LOBYTE(v11[9]) &= ~8u;
  libc_hooks_will_read_cstring((uint64_t)__s);
  LODWORD(__b[2]) = -65532;
  __b[0] = __s;
  __b[3] = __s;
  LODWORD(__b[1]) = strlen(__s);
  LODWORD(__b[4]) = __b[1];
  void __b[8] = eofread;
  __b[11] = 0;
  __b[15] = 0;
  *(unsigned char *)(__b[13] + 72) &= 0xF8u;
  memset((void *)(__b[13] + 80), 0, 0x80uLL);
  return __svfscanf_l((int *)__b, v8, v7, v6);
}

uint64_t eofread()
{
  return 0;
}

int vsscanf(const char *__str, const char *__format, va_list a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    locale_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    locale_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return vsscanf_l(__str, v9, __format, a3);
  }
  else {
    return vsscanf_l(__str, (locale_t)__global_locale, __format, a3);
  }
}

int vswprintf_l(__int32 *a1, size_t n, locale_t a3, const __int32 *a4, __darwin_va_list a5)
{
  unint64_t v15 = a1;
  size_t v14 = n;
  locale_t v13 = a3;
  uint64_t v12 = (unsigned int *)a4;
  unint64_t v11 = a5;
  memset(&__b, 0, sizeof(__b));
  memset(v10, 0, sizeof(v10));
  locale_t v9 = 0;
  memset(v18, 0, sizeof(v18));
  v10[13] = v18;
  v18[0] = 0;
  memset(v17, 0, sizeof(v17));
  v17[0] = 850045858;
  memcpy(&v18[1], v17, 0x40uLL);
  LOBYTE(v18[9]) &= 0xF8u;
  memset(&v18[10], 0, 0x80uLL);
  LOBYTE(v18[9]) &= ~8u;
  if (v13)
  {
    if (v13 == (locale_t)-1) {
      locale_t v13 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v13 = (locale_t)&__c_locale;
  }
  if (v14)
  {
    LODWORD(v10[2]) = -48632;
    v10[0] = malloc_type_malloc();
    v10[3] = v10[0];
    if (v10[0])
    {
      HIDWORD(v10[1]) = 127;
      LODWORD(v10[4]) = 127;
      *(unsigned char *)(v10[13] + 72) &= 0xF8u;
      memset((void *)(v10[13] + 80), 0, 0x80uLL);
      int v8 = __vfwprintf((uint64_t)v10, v13, v12, v11);
      if (v8 >= 0)
      {
        *(unsigned char *)v10[0] = 0;
        locale_t v9 = (const char *)v10[3];
        memcpy(&__b, &vswprintf_l_initial, sizeof(__b));
        size_t v6 = mbsrtowcs_l(v15, &v9, v14, &__b, v13);
        free((void *)v10[3]);
        if (v6 == -1)
        {
          *__error() = 92;
          return -1;
        }
        else if (v6 == v14)
        {
          v15[v14 - 1] = 0;
          *__error() = 84;
          return -1;
        }
        else
        {
          return v8;
        }
      }
      else
      {
        int v7 = *__error();
        free((void *)v10[3]);
        *__error() = v7;
        return -1;
      }
    }
    else
    {
      *__error() = 12;
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int vswprintf(__int32 *a1, size_t a2, const __int32 *a3, __darwin_va_list a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    unint64_t v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    unint64_t v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    return vswprintf_l(a1, a2, v11, a3, a4);
  }
  else {
    return vswprintf_l(a1, a2, (locale_t)__global_locale, a3, a4);
  }
}

int vswscanf_l(const __int32 *a1, locale_t a2, const __int32 *a3, __darwin_va_list a4)
{
  locale_t v13 = (__int32 *)a1;
  locale_t v12 = a2;
  unint64_t v11 = (__int32 *)a3;
  uint64_t v10 = (__int32 **)a4;
  memset(&__b, 0, sizeof(__b));
  memset(v9, 0, sizeof(v9));
  int v8 = 0;
  size_t v7 = 0;
  int v6 = 0;
  char v5 = 0;
  memset(v16, 0, sizeof(v16));
  v9[13] = v16;
  v16[0] = 0;
  memset(v15, 0, sizeof(v15));
  v15[0] = 850045858;
  memcpy(&v16[1], v15, 0x40uLL);
  LOBYTE(v16[9]) &= 0xF8u;
  memset(&v16[10], 0, 0x80uLL);
  LOBYTE(v16[9]) &= ~8u;
  if (v12)
  {
    if (v12 == (locale_t)-1) {
      locale_t v12 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v12 = (locale_t)&__c_locale;
  }
  wcslen(v13);
  int v8 = (char *)malloc_type_malloc();
  if (!v8) {
    return -1;
  }
  memcpy(&__b, &vswscanf_l_initial, sizeof(__b));
  char v5 = v13;
  size_t v7 = wcsrtombs_l(v8, (const __int32 **)&v5, 0xFFFFFFFFFFFFFFFFLL, &__b, v12);
  if (v7 == -1)
  {
    free(v8);
    return -1;
  }
  else
  {
    LODWORD(v9[2]) = -65532;
    v9[0] = v8;
    v9[3] = v8;
    LODWORD(v9[1]) = v7;
    LODWORD(v9[4]) = v7;
    void v9[8] = eofread_0;
    v9[11] = 0;
    v9[15] = 0;
    *(unsigned char *)(v9[13] + 72) &= 0xF8u;
    memset((void *)(v9[13] + 80), 0, 0x80uLL);
    int v6 = __vfwscanf((uint64_t)v9, v12, v11, v10);
    free(v8);
    return v6;
  }
}

uint64_t eofread_0()
{
  return 0;
}

int vswscanf(const __int32 *a1, const __int32 *a2, __darwin_va_list a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    locale_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    locale_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return vswscanf_l(a1, v9, a2, a3);
  }
  else {
    return vswscanf_l(a1, (locale_t)__global_locale, a2, a3);
  }
}

int vwprintf(const __int32 *a1, __darwin_va_list a2)
{
  char v5 = __stdoutp;
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v8 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    int v8 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    return vfwprintf_l(v5, v8, a1, a2);
  }
  else {
    return vfwprintf_l(v5, (locale_t)__global_locale, a1, a2);
  }
}

int vwprintf_l(locale_t a1, const __int32 *a2, __darwin_va_list a3)
{
  return vfwprintf_l(__stdoutp, a1, a2, a3);
}

int vwscanf(const __int32 *a1, __darwin_va_list a2)
{
  char v5 = __stdinp;
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v8 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v9 = __locale_key;
    int v8 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8) {
    return vfwscanf_l(v5, v8, a1, a2);
  }
  else {
    return vfwscanf_l(v5, (locale_t)__global_locale, a1, a2);
  }
}

int vwscanf_l(locale_t a1, const __int32 *a2, __darwin_va_list a3)
{
  return vfwscanf_l(__stdinp, a1, a2, a3);
}

int __swbuf(int a1, FILE *a2)
{
  unsigned __int8 v7 = a1;
  a2->_w = a2->_lbfsize;
  if ((a2->_flags & 8) == 0 || (BOOL v4 = 0, !a2->_bf._base) && (BOOL v4 = 0, (a2->_flags & 0x200) == 0)) {
    BOOL v4 = __swsetup((uint64_t)a2) != 0;
  }
  if (v4)
  {
    *__error() = 9;
    return -1;
  }
  else
  {
    if (!((char)(32 * *((unsigned char *)a2->_extra + 72)) >> 5)) {
      *((unsigned char *)a2->_extra + 72) = *((unsigned char *)a2->_extra + 72) & 0xF8 | 7;
    }
    int v5 = a2->_p - a2->_bf._base;
    if (v5 >= a2->_bf._size)
    {
      if (__fflush((uint64_t)a2)) {
        return -1;
      }
      int v5 = 0;
    }
    --a2->_w;
    char v2 = a2->_p++;
    *char v2 = v7;
    if ((v5 + 1 == a2->_bf._size || (a2->_flags & 1) != 0 && v7 == 10) && __fflush((uint64_t)a2)) {
      return -1;
    }
    else {
      return v7;
    }
  }
}

int wprintf(const __int32 *a1, ...)
{
  va_start(va, a1);
  BOOL v4 = __stdoutp;
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    int v6 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v7 = __locale_key;
    int v6 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6) {
    return vfwprintf_l(v4, v6, a1, va);
  }
  else {
    return vfwprintf_l(v4, (locale_t)__global_locale, a1, va);
  }
}

int wprintf_l(locale_t a1, const __int32 *a2, ...)
{
  va_start(va, a2);
  return vfwprintf_l(__stdoutp, a1, a2, va);
}

int wscanf(const __int32 *a1, ...)
{
  va_start(va, a1);
  BOOL v4 = __stdinp;
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    int v6 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v7 = __locale_key;
    int v6 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6) {
    return vfwscanf_l(v4, v6, a1, va);
  }
  else {
    return vfwscanf_l(v4, (locale_t)__global_locale, a1, va);
  }
}

int wscanf_l(locale_t a1, const __int32 *a2, ...)
{
  va_start(va, a2);
  return vfwscanf_l(__stdinp, a1, a2, va);
}

uint64_t __swsetup(uint64_t a1)
{
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  if ((*(_WORD *)(a1 + 16) & 8) == 0)
  {
    if ((*(_WORD *)(a1 + 16) & 0x10) == 0)
    {
      *__error() = 9;
      *(_WORD *)(a1 + 16) |= 0x40u;
      return -1;
    }
    if ((*(_WORD *)(a1 + 16) & 4) != 0)
    {
      if (*(void *)(a1 + 88))
      {
        if (*(void *)(a1 + 88) != a1 + 116) {
          free(*(void **)(a1 + 88));
        }
        *(void *)(a1 + 88) = 0;
      }
      *(_WORD *)(a1 + 16) &= 0xFFDBu;
      *(_DWORD *)(a1 + 8) = 0;
      *(void *)a1 = *(void *)(a1 + 24);
    }
    *(_WORD *)(a1 + 16) |= 8u;
  }
  if (!*(void *)(a1 + 24)) {
    __smakebuf(a1);
  }
  if (*(_WORD *)(a1 + 16))
  {
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 40) = -*(_DWORD *)(a1 + 32);
  }
  else
  {
    if ((*(_WORD *)(a1 + 16) & 2) != 0) {
      int v2 = 0;
    }
    else {
      int v2 = *(_DWORD *)(a1 + 32);
    }
    *(_DWORD *)(a1 + 12) = v2;
  }
  return 0;
}

FILE *__cdecl open_wmemstream(__int32 **__bufp, size_t *__sizep)
{
  if (__bufp && __sizep)
  {
    *__bufp = (__int32 *)malloc_type_calloc();
    if (*__bufp)
    {
      int v6 = (void *)malloc_type_malloc();
      if (v6)
      {
        *int v6 = __bufp;
        v6[1] = __sizep;
        unsigned char v6[2] = 0;
        v6[3] = 0;
        memset(v6 + 4, 0, 0x80uLL);
        wmemstream_update((uint64_t)v6);
        char v3 = funopen(v6, 0, (int (__cdecl *)(void *, const char *, int))wmemstream_write, (fpos_t (__cdecl *)(void *, fpos_t, int))wmemstream_seek, (int (__cdecl *)(void *))wmemstream_close);
        if (v3)
        {
          fwide(v3, 1);
          return v3;
        }
        else
        {
          int v5 = *__error();
          free(v6);
          free(*__bufp);
          *__bufp = 0;
          *__error() = v5;
          return 0;
        }
      }
      else
      {
        uint64_t v4 = *__error();
        free(*__bufp);
        *__bufp = 0;
        *__error() = v4;
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t wmemstream_update(uint64_t result)
{
  BOOL v2 = 0;
  if (*(uint64_t *)(result + 16) >= 0) {
    BOOL v2 = *(void *)(result + 24) >= 0;
  }
  if (!v2) {
    __assert_rtn("wmemstream_update", "open_wmemstream.c", 86, "ms->len >= 0 && ms->offset >= 0");
  }
  if (*(void *)(result + 16) >= *(void *)(result + 24)) {
    uint64_t v1 = *(void *)(result + 24);
  }
  else {
    uint64_t v1 = *(void *)(result + 16);
  }
  **(void **)(result + 8) = v1;
  return result;
}

uint64_t wmemstream_write(void *a1, const char *a2, int a3)
{
  uint64_t v10 = a2;
  int v9 = a3;
  uint64_t v6 = wbuflen(a1 + 4, a2, a3);
  if (v6 >= 0)
  {
    if (wmemstream_grow((uint64_t **)a1, a1[3] + v6))
    {
      uint64_t v7 = 0;
      while (1)
      {
        BOOL v4 = 0;
        if (v9 > 0) {
          BOOL v4 = a1[3] < a1[2];
        }
        if (!v4) {
          break;
        }
        size_t v5 = mbrtowc((__int32 *)(*(void *)*a1 + 4 * a1[3]), v10, v9, (mbstate_t *)(a1 + 4));
        if (v5 == -1)
        {
          if (!v7) {
            goto LABEL_2;
          }
          break;
        }
        if (!v5) {
          size_t v5 = 1;
        }
        if (v5 == -2)
        {
          v7 += v9;
          int v9 = 0;
        }
        else
        {
          v7 += v5;
          v10 += v5;
          v9 -= v5;
          ++a1[3];
        }
      }
      wmemstream_update((uint64_t)a1);
      fprintf(__stderrp, "WMS: write(%p, %d) = %zd\n", a1, v9, v7);
      return v7;
    }
    else
    {
      return -1;
    }
  }
  else
  {
LABEL_2:
    *__error() = 92;
    return -1;
  }
}

uint64_t wmemstream_seek(void *a1, uint64_t a2, int a3)
{
  uint64_t v4 = a1[3];
  if (a3)
  {
    if (a3 == 1)
    {
      if (a2) {
        __assert_rtn("wmemstream_seek", "open_wmemstream.c", 188, "pos == 0");
      }
    }
    else if (a3 == 2)
    {
      if (a2 >= 0)
      {
        if (0x7FFFFFFFFFFFFFFFLL - a1[2] < a2)
        {
          fprintf(__stderrp, "WMS: bad SEEK_END: pos %jd, len %zd\n", a2, a1[2]);
          *__error() = 84;
          return -1;
        }
      }
      else if (a2 + a1[2] < 0)
      {
        fprintf(__stderrp, "WMS: bad SEEK_END: pos %jd, len %zd\n", a2, a1[2]);
        *__error() = 22;
        return -1;
      }
      a1[3] = a1[2] + a2;
    }
  }
  else
  {
    if (a2 < 0) {
      __assert_rtn("wmemstream_seek", "open_wmemstream.c", 183, "pos >= 0");
    }
    a1[3] = a2;
  }
  if (a1[3] != v4) {
    memset(a1 + 4, 0, 0x80uLL);
  }
  wmemstream_update((uint64_t)a1);
  fprintf(__stderrp, "WMS: seek(%p, %jd, %d) %jd -> %jd\n", a1, a2, a3, v4, a1[3]);
  return a1[3];
}

uint64_t wmemstream_close(void *a1)
{
  return 0;
}

uint64_t wbuflen(const void *a1, const char *a2, int a3)
{
  memset(&__b, 0, sizeof(__b));
  uint64_t v4 = 0;
  memcpy(&__b, a1, sizeof(__b));
  while (a3 > 0)
  {
    size_t v5 = mbrlen(a2, a3, &__b);
    if (v5 == -1) {
      return -1;
    }
    if (v5 == -2) {
      break;
    }
    if (!v5) {
      size_t v5 = 1;
    }
    a3 -= v5;
    a2 += v5;
    ++v4;
  }
  return v4;
}

uint64_t wmemstream_grow(uint64_t **a1, unint64_t a2)
{
  if (a2 <= 0x1FFFFFFFFFFFFFFELL) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = 0x1FFFFFFFFFFFFFFELL;
  }
  if (v3 <= (uint64_t)a1[2])
  {
    return 1;
  }
  else
  {
    uint64_t v4 = reallocarray_DARWIN_EXTSN();
    if (v4)
    {
      fprintf(__stderrp, "WMS: %p growing from %zd to %zd\n", a1, (size_t)a1[2], v3);
      wmemset((__int32 *)(v4 + 4 * (void)a1[2] + 4), 0, v3 - (void)a1[2]);
      **a1 = v4;
      a1[2] = (uint64_t *)v3;
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

char *__cdecl asctime_r(const tm *a1, char *a2)
{
  if (a1->tm_wday <= 6u) {
    size_t v5 = (char *)&asctime_r_wday_name + 3 * a1->tm_wday;
  }
  else {
    size_t v5 = "???";
  }
  if (a1->tm_mon < 0xCu) {
    uint64_t v4 = &asctime_r_mon_name[3 * a1->tm_mon];
  }
  else {
    uint64_t v4 = "???";
  }
  strftime_l(v10, 0xDuLL, "%Y", a1, 0);
  if (strlen(v10) > 4) {
    BOOL v2 = "%.3s %.3s%3d %2.2d:%2.2d:%2.2d     %s\n";
  }
  else {
    BOOL v2 = "%.3s %.3s%3d %2.2d:%2.2d:%2.2d %-4s\n";
  }
  sprintf(__src, v2, v5, v4, a1->tm_mday, a1->tm_hour, a1->tm_min, a1->tm_sec, v10);
  if (strlen(__src) < 0x1A || a2 == (char *)&buf_asctime)
  {
    strcpy(a2, __src);
    return a2;
  }
  else
  {
    *__error() = 84;
    return 0;
  }
}

char *__cdecl asctime(const tm *a1)
{
  return asctime_r(a1, buf_asctime);
}

double difftime(time_t a1, time_t a2)
{
  if (a1 < 0 == a2 < 0) {
    return (double)(a1 - a2);
  }
  if (a1 < 0) {
    return -(double)(unint64_t)(a2 - a1);
  }
  return (double)(unint64_t)(a1 - a2);
}

int ftime(timeb *a1)
{
  uint64_t v4 = a1;
  uint64_t v3 = 0;
  v2.time_t tv_sec = 0;
  *(void *)&v2.tv_usec = 0;
  if (gettimeofday(&v2, &v3) < 0) {
    return -1;
  }
  v4->millitsigned int m = v2.tv_usec / 1000;
  v4->mach_error_t time = v2.tv_sec;
  v4->timezone = v3;
  v4->dstflag = WORD2(v3);
  return 0;
}

void tzsetwall(void)
{
}

void tzsetwall_basic(int a1)
{
  if (!a1) {
    pthread_rwlock_rdlock(&lcl_rwlock);
  }
  if (lcl_is_set >= 0)
  {
    pthread_rwlock_unlock(&lcl_rwlock);
    pthread_rwlock_wrlock(&lcl_rwlock);
    lcl_is_set = -1;
    if (tzload(0, (uint64_t)&lclmem, 1)) {
      gmtload((uint64_t)&lclmem);
    }
    settzname();
    pthread_rwlock_unlock(&lcl_rwlock);
    if (a1) {
      pthread_rwlock_rdlock(&lcl_rwlock);
    }
  }
  else if (!a1)
  {
    pthread_rwlock_unlock(&lcl_rwlock);
  }
}

void _st_tzset_basic(int a1)
{
  __s2 = getenv("TZ");
  if (__s2)
  {
    if (!a1) {
      pthread_rwlock_rdlock(&lcl_rwlock);
    }
    if (lcl_is_set > 0 && !strcmp(lcl_TZname, __s2))
    {
      if (!a1) {
        pthread_rwlock_unlock(&lcl_rwlock);
      }
    }
    else
    {
      pthread_rwlock_unlock(&lcl_rwlock);
      pthread_rwlock_wrlock(&lcl_rwlock);
      LOBYTE(lcl_is_set) = strlen(__s2) < 0x100;
      lcl_is_set = lcl_is_set;
      if ((_BYTE)lcl_is_set) {
        strcpy(lcl_TZname, __s2);
      }
      if (*__s2)
      {
        if (tzload(__s2, (uint64_t)&lclmem, 1)
          && (*__s2 == 58 || tzparse(__s2, (uint64_t)&lclmem, 0)))
        {
          gmtload((uint64_t)&lclmem);
        }
      }
      else
      {
        lclmesigned int m = 0;
        dword_EC414 = 0;
        dword_EC418 = 0;
        dword_EEE60 = 0;
        qword_EEE58[0] = 0;
        dword_EEE64 = 0;
        strcpy(byte_F0658, "UTC");
      }
      settzname();
      pthread_rwlock_unlock(&lcl_rwlock);
      if (a1) {
        pthread_rwlock_rdlock(&lcl_rwlock);
      }
    }
  }
  else
  {
    tzsetwall_basic(a1);
  }
}

uint64_t tzload(const char *a1, uint64_t a2, int a3)
{
  int v43 = a1;
  uint64_t v42 = a2;
  int v41 = a3;
  double v40 = 0;
  int j = 0;
  int v38 = 0;
  int i = 0;
  int NOCANCEL = 0;
  int v34 = 0;
  unsigned int v35 = -1;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(v42 + 16) = 0;
  if (v43 && issetugid() && (*v43 == 58 && v43[1] == 47 || *v43 == 47 || strchr(v43, 46))) {
    int v43 = 0;
  }
  if (!v43) {
    int v43 = "/var/db/timezone/localtime";
  }
  int v33 = 0;
  memset(&__b, 0, sizeof(__b));
  mbstate_t __dst = (char *)malloc_type_malloc();
  if (!__dst) {
    goto LABEL_132;
  }
  if (*v43 == 58) {
    ++v43;
  }
  LOBYTE(v33) = *v43 == 47;
  int v33 = v33;
  if ((_BYTE)v33)
  {
LABEL_19:
    if (v33 && access(v43, 4)) {
      goto LABEL_22;
    }
    int v38 = open_NOCANCEL();
    if (v38 == -1) {
      goto LABEL_22;
    }
    if (fstat(v38, &__b) < 0 || (__b.st_mode & 0xF000) != 0x8000)
    {
      free(__dst);
      close_NOCANCEL();
      return -1;
    }
    free(__dst);
    int v34 = (char *)malloc_type_malloc();
    if (!v34 || (int NOCANCEL = read_NOCANCEL(), (int)close_NOCANCEL() < 0) || NOCANCEL <= 0)
    {
LABEL_132:
      free(v34);
      return v35;
    }
    for (int i = 4; i <= 8; i *= 2)
    {
      int v30 = detzcode(v34 + 24);
      int v29 = detzcode(v34 + 20);
      *(_DWORD *)uint64_t v42 = detzcode(v34 + 28);
      *(_DWORD *)(v42 + 4) = detzcode(v34 + 32);
      *(_DWORD *)(v42 + 8) = detzcode(v34 + 36);
      *(_DWORD *)(v42 + 12) = detzcode(v34 + 40);
      double v40 = v34 + 44;
      if (*(_DWORD *)v42 > 0x32u
        || *(int *)(v42 + 8) <= 0
        || *(int *)(v42 + 8) > 256
        || *(_DWORD *)(v42 + 4) > 0x4B0u
        || *(_DWORD *)(v42 + 12) > 0x32u
        || v30 != *(_DWORD *)(v42 + 8) && v30
        || v29 != *(_DWORD *)(v42 + 8) && v29
        || NOCANCEL - (v40 - v34) < *(_DWORD *)(v42 + 4) * i
                                  + *(_DWORD *)(v42 + 4)
                                  + 6 * *(_DWORD *)(v42 + 8)
                                  + *(_DWORD *)(v42 + 12)
                                  + *(_DWORD *)v42 * (i + 4)
                                  + v30
                                  + v29)
      {
        goto LABEL_132;
      }
      for (int j = 0; j < *(_DWORD *)(v42 + 4); ++j)
      {
        if (i == 4) {
          uint64_t v22 = detzcode(v40);
        }
        else {
          uint64_t v22 = detzcode64(v40);
        }
        *(void *)(v42 + 24 + 8 * j) = v22;
        v40 += i;
      }
      for (int j = 0; j < *(_DWORD *)(v42 + 4); ++j)
      {
        uint64_t v3 = v40++;
        *(unsigned char *)(v42 + 9624 + j) = *v3;
        if (*(unsigned __int8 *)(v42 + 9624 + j) >= *(int *)(v42 + 8)) {
          goto LABEL_132;
        }
      }
      for (int j = 0; j < *(_DWORD *)(v42 + 8); ++j)
      {
        uint64_t v28 = v42 + 10824 + 24 * j;
        *(void *)uint64_t v28 = detzcode(v40);
        v40 += 4;
        uint64_t v4 = v40++;
        *(_DWORD *)(v28 + 8) = *v4;
        if (*(_DWORD *)(v28 + 8) >= 2u) {
          goto LABEL_132;
        }
        size_t v5 = v40++;
        *(_DWORD *)(v28 + 12) = *v5;
        if (*(int *)(v28 + 12) < 0 || *(_DWORD *)(v28 + 12) > *(_DWORD *)(v42 + 12)) {
          goto LABEL_132;
        }
      }
      for (int j = 0; j < *(_DWORD *)(v42 + 12); *(unsigned char *)(v42 + 16968 + j++) = *v6)
        uint64_t v6 = v40++;
      *(unsigned char *)(v42 + 16968 + j) = 0;
      for (int j = 0; j < *(_DWORD *)v42; ++j)
      {
        char v27 = (uint64_t *)(v42 + 17480 + 16 * j);
        if (i == 4) {
          uint64_t v21 = detzcode(v40);
        }
        else {
          uint64_t v21 = detzcode64(v40);
        }
        *char v27 = v21;
        v40 += i;
        v27[1] = detzcode(v40);
        v40 += 4;
      }
      for (int j = 0; j < *(_DWORD *)(v42 + 8); ++j)
      {
        uint64_t v26 = v42 + 10824 + 24 * j;
        if (v30)
        {
          uint64_t v7 = v40++;
          *(_DWORD *)(v26 + 16) = *v7;
          if (*(_DWORD *)(v26 + 16) >= 2u) {
            goto LABEL_132;
          }
        }
        else
        {
          *(_DWORD *)(v26 + 16) = 0;
        }
      }
      for (int j = 0; j < *(_DWORD *)(v42 + 8); ++j)
      {
        uint64_t v25 = v42 + 10824 + 24 * j;
        if (v29)
        {
          int v8 = v40++;
          *(_DWORD *)(v25 + 20) = *v8;
          if (*(_DWORD *)(v25 + 20) >= 2u) {
            goto LABEL_132;
          }
        }
        else
        {
          *(_DWORD *)(v25 + 20) = 0;
        }
      }
      for (int j = 0; j < *(_DWORD *)(v42 + 4) - 2; ++j)
      {
        if (*(void *)(v42 + 24 + 8 * j) > *(void *)(v42 + 24 + 8 * (j + 1)))
        {
          *(_DWORD *)(v42 + 4) = ++j;
          break;
        }
      }
      if (!v34[4]) {
        break;
      }
      NOCANCEL -= v40 - v34;
      for (int j = 0; j < NOCANCEL; ++j)
        v34[j] = v40[j];
      if (i >= 8) {
        break;
      }
    }
    if (v41 && NOCANCEL > 2 && *v34 == 10 && v34[NOCANCEL - 1] == 10 && *(_DWORD *)(v42 + 8) + 2 <= 256)
    {
      size_t v24 = (char *)malloc_type_malloc();
      if (!v24) {
        goto LABEL_132;
      }
      v34[NOCANCEL - 1] = 0;
      if (!tzparse(v34 + 1, (uint64_t)v24, 0)
        && *((_DWORD *)v24 + 2) == 2
        && *(_DWORD *)(v42 + 12) + *((_DWORD *)v24 + 3) <= 50)
      {
        for (int j = 0; j < 2; ++j)
          *(_DWORD *)&v24[24 * j + 10836] += *(_DWORD *)(v42 + 12);
        for (int j = 0; j < *((_DWORD *)v24 + 3); ++j)
        {
          char v9 = v24[j + 16968];
          uint64_t v10 = v42 + 16968;
          uint64_t v11 = (int)(*(_DWORD *)(v42 + 12))++;
          *(unsigned char *)(v10 + v11) = v9;
        }
        for (int j = 0; ; ++j)
        {
          BOOL v20 = 0;
          if (j < *((_DWORD *)v24 + 1)) {
            BOOL v20 = *(void *)&v24[8 * j + 24] <= *(void *)(v42 + 24 + 8 * (*(_DWORD *)(v42 + 4) - 1));
          }
          if (!v20) {
            break;
          }
        }
        while (1)
        {
          BOOL v19 = 0;
          if (j < *((_DWORD *)v24 + 1)) {
            BOOL v19 = *(_DWORD *)(v42 + 4) < 1200;
          }
          if (!v19) {
            break;
          }
          *(void *)(v42 + 24 + 8 * *(int *)(v42 + 4)) = *(void *)&v24[8 * j + 24];
          *(unsigned char *)(v42 + 9624 + (int)(*(_DWORD *)(v42 + 4))++) = *(_DWORD *)(v42 + 8) + v24[j++ + 9624];
        }
        uint64_t v12 = v42 + 10824;
        uint64_t v13 = (int)(*(_DWORD *)(v42 + 8))++;
        uint64_t v14 = v12 + 24 * v13;
        *(_OWORD *)uint64_t v14 = *(_OWORD *)(v24 + 10824);
        *(void *)(v14 + 16) = *((void *)v24 + 1355);
        uint64_t v15 = v42 + 10824;
        uint64_t v16 = (int)(*(_DWORD *)(v42 + 8))++;
        uint64_t v17 = v15 + 24 * v16;
        *(_OWORD *)uint64_t v17 = *((_OWORD *)v24 + 678);
        *(void *)(v17 + 16) = *((void *)v24 + 1358);
      }
      free(v24);
    }
    if (*(int *)(v42 + 4) > 1)
    {
      for (int j = 1; j < *(_DWORD *)(v42 + 4); ++j)
      {
        if (typesequiv(v42, *(unsigned __int8 *)(v42 + 9624 + j), *(unsigned __int8 *)(v42 + 9624))
          && differ_by_repeat(*(void *)(v42 + 24 + 8 * j), *(void *)(v42 + 24)))
        {
          *(_DWORD *)(v42 + 16) = 1;
          break;
        }
      }
      for (int j = *(_DWORD *)(v42 + 4) - 2; j >= 0; --j)
      {
        if (typesequiv(v42, *(unsigned __int8 *)(v42 + 9624 + *(_DWORD *)(v42 + 4) - 1), *(unsigned __int8 *)(v42 + 9624 + j))&& differ_by_repeat(*(void *)(v42 + 24 + 8 * (*(_DWORD *)(v42 + 4) - 1)), *(void *)(v42 + 24 + 8 * j)))
        {
          *(_DWORD *)(v42 + 20) = 1;
          break;
        }
      }
    }
    unsigned int v35 = 0;
    goto LABEL_132;
  }
  double v40 = "/var/db/timezone/zoneinfo";
  size_t v23 = strlen("/var/db/timezone/zoneinfo") + 1;
  if (v23 + strlen(v43) < 0x400)
  {
    strcpy(__dst, v40);
    strcat(__dst, "/");
    strcat(__dst, v43);
    if (strchr(v43, 46)) {
      int v33 = 1;
    }
    int v43 = __dst;
    goto LABEL_19;
  }
LABEL_22:
  free(__dst);
  return -1;
}

uint64_t tzparse(char *a1, uint64_t a2, int a3)
{
  int v38 = a1;
  uint64_t v37 = a2;
  int v36 = a3;
  unsigned int v35 = 0;
  size_t v33 = 0;
  size_t v32 = 0;
  uint64_t v31 = 0;
  uint64_t v30 = 0;
  int v29 = 0;
  uint64_t v28 = 0;
  char v27 = 0;
  int v26 = 0;
  int v34 = 0;
  if (a3)
  {
    unsigned int v35 = v38;
    size_t v33 = strlen(v38);
    v38 += v33;
    if (v33 >= 0x200) {
      size_t v33 = 511;
    }
    uint64_t v31 = 0;
  }
  else
  {
    int v38 = getzname(v38, &v35, &v33);
    if (!*v38) {
      return -1;
    }
    int v38 = getoffset(v38, &v31);
    if (!v38) {
      return -1;
    }
  }
  int v26 = tzload("posixrules", v37, 0);
  if (v26) {
    *(_DWORD *)uint64_t v37 = 0;
  }
  if (*v38)
  {
    if (*v38 == 60)
    {
      int v34 = ++v38;
      int v38 = getqzname(v38, 62);
      if (*v38 != 62) {
        return -1;
      }
      size_t v32 = v38 - v34;
      ++v38;
    }
    else
    {
      int v34 = v38;
      int v38 = getzname(v38, &v34, &v32);
    }
    if (!*v38 || *v38 == 44 || *v38 == 59)
    {
      uint64_t v30 = v31 - 3600;
    }
    else
    {
      int v38 = getoffset(v38, &v30);
      if (!v38) {
        return -1;
      }
    }
    if (!*v38 && v26) {
      int v38 = ",M4.1.0,M10.5.0";
    }
    if (*v38 == 44 || *v38 == 59)
    {
      memset(v25, 0, sizeof(v25));
      memset(v24, 0, sizeof(v24));
      ++v38;
      int v38 = getrule(v38, (uint64_t)v25);
      if (!v38) {
        return -1;
      }
      uint64_t v3 = v38++;
      if (*v3 != 44) {
        return -1;
      }
      int v38 = getrule(v38, (uint64_t)v24);
      if (!v38) {
        return -1;
      }
      if (*v38) {
        return -1;
      }
      *(_DWORD *)(v37 + 8) = 2;
      *(void *)(v37 + 10824) = -v30;
      *(_DWORD *)(v37 + 10832) = 1;
      *(_DWORD *)(v37 + 10836) = v33 + 1;
      *(void *)(v37 + 10848) = -v31;
      *(_DWORD *)(v37 + 10856) = 0;
      *(_DWORD *)(v37 + 10860) = 0;
      int v29 = (uint64_t *)(v37 + 24);
      uint64_t v28 = (unsigned char *)(v37 + 9624);
      uint64_t v22 = 0;
      *(_DWORD *)(v37 + 4) = 0;
      for (int i = 1970; *(_DWORD *)(v37 + 4) + 2 <= 1200; ++i)
      {
        uint64_t v21 = transtime(v22, i, (int *)v25, v31);
        uint64_t v20 = transtime(v22, i, (int *)v24, v30);
        uint64_t v4 = v29++;
        if (v21 <= v20)
        {
          *uint64_t v4 = v21;
          int v8 = v28++;
          *int v8 = 0;
          char v9 = v29++;
          *char v9 = v20;
          uint64_t v10 = v28++;
          *uint64_t v10 = 1;
        }
        else
        {
          *uint64_t v4 = v20;
          size_t v5 = v28++;
          *size_t v5 = 1;
          uint64_t v6 = v29++;
          *uint64_t v6 = v21;
          uint64_t v7 = v28++;
          *uint64_t v7 = 0;
        }
        *(_DWORD *)(v37 + 4) += 2;
        BOOL v14 = 0;
        if (!(i % 4))
        {
          BOOL v13 = 1;
          if (!(i % 100)) {
            BOOL v13 = i % 400 == 0;
          }
          BOOL v14 = v13;
        }
        if (v22 + 86400 * *((int *)&year_lengths + v14) <= v22) {
          break;
        }
        v22 += 86400 * *((int *)&year_lengths + v14);
      }
    }
    else
    {
      if (*v38) {
        return -1;
      }
      uint64_t v19 = 0;
      for (int j = 0; j < *(_DWORD *)(v37 + 4); ++j)
      {
        if (!*(_DWORD *)(v37 + 10824 + 24 * *(unsigned __int8 *)(v37 + 9624 + j) + 8))
        {
          uint64_t v19 = -*(void *)(v37 + 10824 + 24 * *(unsigned __int8 *)(v37 + 9624 + j));
          break;
        }
      }
      for (int k = 0;
            k < *(_DWORD *)(v37 + 4) && !*(_DWORD *)(v37 + 10824 + 24 * *(unsigned __int8 *)(v37 + 9624 + k) + 8);
      for (int m = 0; m < *(_DWORD *)(v37 + 4); ++m)
      {
        int v15 = *(unsigned __int8 *)(v37 + 9624 + m);
        *(unsigned char *)(v37 + 9624 + m) = *(_DWORD *)(v37 + 10824 + 24 * *(unsigned __int8 *)(v37 + 9624 + m) + 8);
        if (!*(_DWORD *)(v37 + 10824 + 24 * v15 + 20)) {
          *(void *)(v37 + 24 + 8 * m) += v31 - v19;
        }
        if (!*(_DWORD *)(v37 + 10824 + 24 * v15 + 8)) {
          uint64_t v19 = -*(void *)(v37 + 10824 + 24 * v15);
        }
      }
      *(void *)(v37 + 10824) = -v31;
      *(_DWORD *)(v37 + 10832) = 0;
      *(_DWORD *)(v37 + 10836) = 0;
      *(void *)(v37 + 10848) = -v30;
      *(_DWORD *)(v37 + 10856) = 1;
      *(_DWORD *)(v37 + 10860) = v33 + 1;
      *(_DWORD *)(v37 + 8) = 2;
    }
  }
  else
  {
    size_t v32 = 0;
    *(_DWORD *)(v37 + 8) = 1;
    *(_DWORD *)(v37 + 4) = 0;
    *(void *)(v37 + 10824) = -v31;
    *(_DWORD *)(v37 + 10832) = 0;
    *(_DWORD *)(v37 + 10836) = 0;
  }
  *(_DWORD *)(v37 + 12) = v33 + 1;
  if (v32) {
    *(_DWORD *)(v37 + 12) += v32 + 1;
  }
  if ((unint64_t)*(int *)(v37 + 12) <= 0x200)
  {
    char v27 = (char *)(v37 + 16968);
    strncpy((char *)(v37 + 16968), v35, v33);
    v27 += v33;
    uint64_t v11 = v27++;
    *uint64_t v11 = 0;
    if (v32)
    {
      strncpy(v27, v34, v32);
      v27[v32] = 0;
    }
    return 0;
  }
  else
  {
    return -1;
  }
}

uint64_t gmtload(uint64_t a1)
{
  uint64_t result = tzload("UTC", a1, 1);
  if (result) {
    return tzparse("UTC", a1, 1);
  }
  return result;
}

size_t settzname()
{
  tzname[0] = "   ";
  off_E95F8 = "   ";
  daylight = 0;
  size_t result = _st_set_timezone(0);
  __darwin_altzone = 0;
  if (dword_EC414 || dword_EC418 != 1)
  {
    int v6 = dword_EC414 - 1;
    uint64_t v4 = (unsigned __int8 *)&unk_EE9A8;
  }
  else
  {
    int v6 = 0;
    uint64_t v4 = (unsigned __int8 *)&unk_D793D;
  }
  int v5 = 7;
  while (1)
  {
    BOOL v1 = 0;
    if (v6 >= 0) {
      BOOL v1 = v5 != 0;
    }
    if (!v1) {
      break;
    }
    uint64_t v3 = &qword_EEE58[3 * v4[v6]];
    if ((v5 & 4) != 0 && *((_DWORD *)v3 + 2))
    {
      v5 &= ~4u;
      daylight = 1;
    }
    if (*((_DWORD *)v3 + 2))
    {
      if ((v5 & 2) != 0)
      {
        v5 &= ~2u;
        off_E95F8 = &byte_F0658[*((int *)v3 + 3)];
        __darwin_altzone = -*v3;
      }
    }
    else if (v5)
    {
      v5 &= ~1u;
      tzname[0] = &byte_F0658[*((int *)v3 + 3)];
      size_t result = _st_set_timezone(-*v3);
    }
    if (!v6)
    {
      if ((v5 & 2) != 0) {
        __darwin_altzone = -*v3;
      }
      if (v5) {
        size_t result = _st_set_timezone(-*v3);
      }
    }
    --v6;
  }
  for (int i = 0; i < unk_EC41C; ++i)
  {
    size_t result = (size_t)strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 :+-._", byte_F0658[i]);
    if (!result) {
      byte_F0658[i] = 95;
    }
  }
  for (int j = 0; j < dword_EC418; ++j)
  {
    __s = &byte_F0658[SHIDWORD(qword_EEE58[3 * j + 1])];
    size_t result = strlen(__s);
    if (result > 0xFF)
    {
      size_t result = strcmp(__s, "Local time zone must be set--see zic manual page");
      if (result) {
        __s[255] = 0;
      }
    }
  }
  return result;
}

void tzset(void)
{
}

uint64_t _st_localsub(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v20 = a1;
  uint64_t v19 = a2;
  uint64_t v18 = a3;
  uint64_t v17 = 0;
  uint64_t v16 = 0;
  int v15 = 0;
  uint64_t v14 = 0;
  uint64_t v13 = 0;
  uint64_t v13 = *a1;
  uint64_t v17 = &lclmem;
  if (unk_EC420 && v13 < *((void *)v17 + 3) || v17[5] && v13 > *(void *)&v17[2 * v17[1] + 4])
  {
    uint64_t v12 = v13;
    if (v13 >= *((void *)v17 + 3)) {
      uint64_t v10 = v13 - *(void *)&v17[2 * v17[1] + 4];
    }
    else {
      uint64_t v10 = *((void *)v17 + 3) - v13;
    }
    uint64_t v9 = (v10 - 1) / 400 / 31556952 + 1;
    uint64_t v11 = 0x2F0605980 * v9;
    if (v13 >= *((void *)v17 + 3)) {
      v12 -= v11;
    }
    else {
      v12 += v11;
    }
    if (v12 >= *((void *)v17 + 3) && v12 <= *(void *)&v17[2 * v17[1] + 4])
    {
      uint64_t v14 = _st_localsub(&v12, v19, v18);
      if (v14 != v18) {
        return v14;
      }
      uint64_t v7 = *(int *)(v18 + 20);
      uint64_t v8 = v13 >= *((void *)v17 + 3) ? v7 + 400 * v9 : v7 - 400 * v9;
      *(_DWORD *)(v18 + 20) = v8;
      if (*(_DWORD *)(v18 + 20) == v8) {
        return v14;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (v17[1] && v13 >= *((void *)v17 + 3))
    {
      int v6 = 1;
      int v5 = v17[1];
      while (v6 < v5)
      {
        int v4 = (v6 + v5) >> 1;
        if (v13 >= *(void *)&v17[2 * v4 + 6]) {
          int v6 = v4 + 1;
        }
        else {
          int v5 = (v6 + v5) >> 1;
        }
      }
      int v15 = *((unsigned __int8 *)v17 + v6 + 9623);
    }
    else
    {
      int v15 = 0;
      while (v17[6 * v15 + 2708])
      {
        if (++v15 >= v17[2])
        {
          int v15 = 0;
          break;
        }
      }
    }
    uint64_t v16 = &v17[6 * v15 + 2706];
    uint64_t v14 = timesub(&v13, *(void *)v16, v17, v18);
    if (v14)
    {
      *(_DWORD *)(v18 + 32) = v16[2];
      tzname[*(int *)(v18 + 32)] = (char *)v17 + v16[3] + 16968;
      *(void *)(v18 + 48) = (char *)v17 + v16[3] + 16968;
      return v14;
    }
    else
    {
      return 0;
    }
  }
}

uint64_t timesub(void *a1, uint64_t a2, int *a3, uint64_t a4)
{
  int v17 = 0;
  uint64_t v15 = 0;
  int v14 = 0;
  int v13 = *a3;
  while (--v13 >= 0)
  {
    size_t v23 = &a3[4 * v13 + 4370];
    if (*a1 >= *(void *)v23)
    {
      if (*a1 == *(void *)v23)
      {
        if (v13 || (BOOL v11 = 1, *((uint64_t *)v23 + 1) <= 0)) {
          BOOL v11 = *((void *)v23 + 1) > *(void *)&a3[4 * v13 + 4368];
        }
        int v14 = v11;
        if (v11)
        {
          while (1)
          {
            BOOL v10 = 0;
            if (v13 > 0)
            {
              BOOL v10 = 0;
              if (*(void *)&a3[4 * v13 + 4370] == *(void *)&a3[4 * v13 + 4366] + 1) {
                BOOL v10 = *(void *)&a3[4 * v13 + 4372] == *(void *)&a3[4 * v13 + 4368] + 1;
              }
            }
            if (!v10) {
              break;
            }
            ++v14;
            --v13;
          }
        }
      }
      uint64_t v15 = *((void *)v23 + 1);
      break;
    }
  }
  uint64_t v22 = *a1 / 86400;
  for (uint64_t i = *a1 % 86400 + a2 - v15; i < 0; i += 86400)
    --v22;
  while (i >= 86400)
  {
    i -= 86400;
    ++v22;
  }
  *(_DWORD *)(a4 + 8) = i / 3600;
  uint64_t v21 = i % 3600;
  *(_DWORD *)(a4 + 4) = v21 / 60;
  *(_DWORD *)a4 = v21 % 60 + v14;
  *(_DWORD *)(a4 + 24) = (v22 + 4) % 7;
  if (*(int *)(a4 + 24) < 0) {
    *(_DWORD *)(a4 + 24) += 7;
  }
  for (uint64_t j = 1970; ; uint64_t j = v12)
  {
    BOOL v9 = 1;
    if (v22 >= 0)
    {
      BOOL v8 = 0;
      if (!(j % 4))
      {
        BOOL v7 = 1;
        if (!(j % 100)) {
          BOOL v7 = j % 400 == 0;
        }
        BOOL v8 = v7;
      }
      int v17 = v8;
      BOOL v9 = v22 >= *((int *)&year_lengths + v8);
    }
    if (!v9) {
      break;
    }
    uint64_t v12 = j + v22 / 365;
    if (v22 < 0) {
      --v12;
    }
    if (v12 - 1 < 0) {
      uint64_t v6 = v12 / 4 - v12 / 100 + v12 / 400 - 1;
    }
    else {
      uint64_t v6 = (v12 - 1) / 4 - (v12 - 1) / 100 + (v12 - 1) / 400;
    }
    if (j - 1 < 0) {
      uint64_t v5 = j / 4 - j / 100 + j / 400 - 1;
    }
    else {
      uint64_t v5 = (j - 1) / 4 - (j - 1) / 100 + (j - 1) / 400;
    }
    v22 -= 365 * (v12 - j) + v6 - v5;
  }
  uint64_t v19 = j - 1900;
  if (v19 >= (uint64_t)0xFFFFFFFF80000000 && v19 <= 0x7FFFFFFF)
  {
    *(_DWORD *)(a4 + 20) = v19;
    *(_DWORD *)(a4 + 28) = v22;
    uint64_t v16 = &mon_lengths[12 * v17];
    for (*(_DWORD *)(a4 + 16) = 0; v22 >= v16[*(int *)(a4 + 16)]; ++*(_DWORD *)(a4 + 16))
      v22 -= v16[*(int *)(a4 + 16)];
    *(_DWORD *)(a4 + 12) = v22 + 1;
    *(_DWORD *)(a4 + 32) = 0;
    *(void *)(a4 + 40) = a2;
    return a4;
  }
  else
  {
    *__error() = 84;
    return 0;
  }
}

tm *__cdecl localtime(const time_t *a1)
{
  pthread_once(&localtime_once, (void (*)(void))localtime_key_init);
  if (!localtime_key_error)
  {
    uint64_t v3 = pthread_getspecific(localtime_key);
    if (!v3)
    {
      uint64_t v3 = (void *)malloc_type_malloc();
      if (!v3) {
        return 0;
      }
      pthread_setspecific(localtime_key, v3);
    }
    pthread_rwlock_rdlock(&lcl_rwlock);
    _st_tzset_basic(1);
    int v4 = (tm *)_st_localsub(a1, 0, (uint64_t)v3);
    pthread_rwlock_unlock(&lcl_rwlock);
    return v4;
  }
  int v2 = localtime_key_error;
  *__error() = v2;
  return 0;
}

uint64_t localtime_key_init()
{
  localtime_key = 12;
  uint64_t result = pthread_key_init_np();
  localtime_key_errosize_t r = result;
  return result;
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  pthread_rwlock_rdlock(&lcl_rwlock);
  _st_tzset_basic(1);
  int v4 = (tm *)_st_localsub(a1, 0, (uint64_t)a2);
  pthread_rwlock_unlock(&lcl_rwlock);
  return v4;
}

tm *__cdecl gmtime(const time_t *a1)
{
  pthread_once(&gmtime_once, (void (*)(void))gmtime_key_init);
  if (!gmtime_key_error)
  {
    uint64_t v3 = pthread_getspecific(gmtime_key);
    if (!v3)
    {
      uint64_t v3 = (void *)malloc_type_malloc();
      if (!v3) {
        return 0;
      }
      pthread_setspecific(gmtime_key, v3);
    }
    return (tm *)gmtsub(a1, 0, (uint64_t)v3);
  }
  int v2 = gmtime_key_error;
  *__error() = v2;
  return 0;
}

uint64_t gmtime_key_init()
{
  gmtime_key = 13;
  uint64_t result = pthread_key_init_np();
  gmtime_key_errosize_t r = result;
  return result;
}

uint64_t gmtsub(void *a1, uint64_t a2, uint64_t a3)
{
  pthread_once(&gmt_once, (void (*)(void))gmt_init);
  uint64_t v4 = timesub(a1, a2, gmtmem, a3);
  if (!v4) {
    return 0;
  }
  if (a2) {
    *(void *)(a3 + 48) = "   ";
  }
  else {
    *(void *)(a3 + 48) = &unk_F4E18;
  }
  return v4;
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return (tm *)gmtsub(a1, 0, (uint64_t)a2);
}

uint64_t offtime(void *a1, uint64_t a2)
{
  return gmtsub(a1, a2, (uint64_t)&tm);
}

char *__cdecl ctime(const time_t *a1)
{
  int v2 = localtime(a1);
  if (v2) {
    return asctime(v2);
  }
  else {
    return 0;
  }
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  uint64_t v5 = a1;
  uint64_t v4 = a2;
  memset(&__b, 0, sizeof(__b));
  if (localtime_r(v5, &__b)) {
    return asctime_r(&__b, v4);
  }
  else {
    return 0;
  }
}

uint64_t _st_time1(_DWORD *a1, uint64_t (*a2)(uint64_t *a1, uint64_t a2, uint64_t a3), uint64_t a3, int a4)
{
  uint64_t v20 = a1;
  uint64_t v19 = a2;
  uint64_t v18 = a3;
  int v17 = a4;
  uint64_t v16 = 0;
  uint64_t v15 = 0;
  int v14 = 0;
  int v13 = 0;
  int j = 0;
  int k = 0;
  int i = 0;
  int v9 = 0;
  int v8 = 0;
  if (a1)
  {
    if ((int)v20[8] > 1) {
      v20[8] = 1;
    }
    uint64_t v16 = time2(v20, v19, v18, &v8, v17);
    if (v8)
    {
      return v16;
    }
    else
    {
      if ((int)v20[8] < 0) {
        v20[8] = 0;
      }
      uint64_t v4 = &lclmem;
      if (v19 != _st_localsub) {
        uint64_t v4 = (int *)&gmtmem;
      }
      uint64_t v15 = v4;
      for (int i = 0; i < v15[2]; ++i)
        v22[i + 256] = 0;
      int v9 = 0;
      for (int i = v15[1] - 1; i >= 0; --i)
      {
        if (!v22[*((unsigned __int8 *)v15 + i + 9624) + 256])
        {
          v22[*((unsigned __int8 *)v15 + i + 9624) + 256] = 1;
          int v5 = *((unsigned __int8 *)v15 + i + 9624);
          uint64_t v6 = v9++;
          v22[v6] = v5;
        }
      }
      for (int j = 0; j < v9; ++j)
      {
        int v14 = v22[j];
        if (v15[6 * v14 + 2708] == v20[8])
        {
          for (int k = 0; k < v9; ++k)
          {
            int v13 = v22[k];
            if (v15[6 * v13 + 2708] != v20[8])
            {
              *v20 += v15[6 * v13 + 2706] - v15[6 * v14 + 2706];
              v20[8] = v20[8] == 0;
              uint64_t v16 = time2(v20, v19, v18, &v8, v17);
              if (v8) {
                return v16;
              }
              *v20 -= v15[6 * v13 + 2706] - v15[6 * v14 + 2706];
              v20[8] = v20[8] == 0;
            }
          }
        }
      }
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t time2(const void *a1, uint64_t (*a2)(uint64_t *a1, uint64_t a2, uint64_t a3), uint64_t a3, _DWORD *a4, int a5)
{
  uint64_t v7 = time2sub(a1, a2, a3, a4, 0, a5);
  if (*a4) {
    return v7;
  }
  else {
    return time2sub(a1, a2, a3, a4, 1, a5);
  }
}

time_t mktime(tm *a1)
{
  int v2 = *__error();
  pthread_rwlock_rdlock(&lcl_rwlock);
  _st_tzset_basic(1);
  time_t v3 = _st_time1(a1, _st_localsub, 0, 1);
  pthread_rwlock_unlock(&lcl_rwlock);
  *__error() = v2;
  return v3;
}

time_t timelocal(tm *const a1)
{
  if (a1) {
    a1->tm_isdst = -1;
  }
  return mktime(a1);
}

time_t timegm(tm *const a1)
{
  if (a1) {
    a1->tm_isdst = 0;
  }
  return _st_time1(a1, gmtsub, 0, 1);
}

uint64_t timeoff(_DWORD *a1, uint64_t a2)
{
  if (a1) {
    a1[8] = 0;
  }
  return _st_time1(a1, gmtsub, a2, 1);
}

time_t time2posix(time_t a1)
{
  time_t v3 = a1;
  tzset();
  time_t v2 = v3;
  return v2 - leapcorr(&v3);
}

uint64_t leapcorr(void *a1)
{
  int v2 = lclmem;
  while (--v2 >= 0)
  {
    if (*a1 >= qword_F0858[2 * v2]) {
      return qword_F0858[2 * v2 + 1];
    }
  }
  return 0;
}

time_t posix2time(time_t a1)
{
  time_t v10 = a1;
  time_t v9 = 0;
  tzset();
  time_t v4 = v10;
  time_t v9 = v4 + leapcorr(&v10);
  time_t v5 = v9;
  time_t v6 = v5 - leapcorr(&v9);
  if (v6 >= v10)
  {
    if (v6 > v10)
    {
      do
      {
        time_t v2 = --v9;
        time_t v8 = v2 - leapcorr(&v9);
      }
      while (v8 > v10);
      if (v10 != v8) {
        return v9 + 1;
      }
    }
    return v9;
  }
  do
  {
    time_t v3 = ++v9;
    time_t v7 = v3 - leapcorr(&v9);
  }
  while (v7 < v10);
  if (v10 == v7) {
    return v9;
  }
  return v9 - 1;
}

double tzsetwall_check_default_file_timestamp()
{
  memset(&__b, 0, sizeof(__b));
  if (!lstat("/var/db/timezone/localtime", &__b))
  {
    if (__b.st_mtimespec.tv_sec > (uint64_t)last_default_tzload_mtimespec
      || __b.st_mtimespec.tv_sec == (void)last_default_tzload_mtimespec
      && __b.st_mtimespec.tv_nsec > *((uint64_t *)&last_default_tzload_mtimespec + 1))
    {
      lcl_is_set = 0;
    }
    double result = *(double *)&__b.st_mtimespec.tv_sec;
    last_default_tzload_mtimespec = (__int128)__b.st_mtimespec;
  }
  return result;
}

uint64_t detzcode(char *a1)
{
  uint64_t v1 = 0;
  if (*a1 < 0) {
    uint64_t v1 = -1;
  }
  uint64_t v4 = v1;
  for (int i = 0; i < 4; ++i)
    uint64_t v4 = a1[i] | (unint64_t)(v4 << 8);
  return v4;
}

uint64_t detzcode64(char *a1)
{
  uint64_t v1 = 0;
  if (*a1 < 0) {
    uint64_t v1 = -1;
  }
  uint64_t v4 = v1;
  for (int i = 0; i < 8; ++i)
    uint64_t v4 = (v4 << 8) + a1[i];
  return v4;
}

BOOL typesequiv(uint64_t a1, int a2, int a3)
{
  if (a1 && a2 >= 0 && a2 < *(_DWORD *)(a1 + 8) && a3 >= 0 && a3 < *(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = a1 + 10824 + 24 * a2;
    uint64_t v5 = a1 + 10824 + 24 * a3;
    BOOL v4 = 0;
    if (*(void *)v6 == *(void *)v5)
    {
      BOOL v4 = 0;
      if (*(_DWORD *)(v6 + 8) == *(_DWORD *)(v5 + 8))
      {
        BOOL v4 = 0;
        if (*(_DWORD *)(v6 + 16) == *(_DWORD *)(v5 + 16))
        {
          BOOL v4 = 0;
          if (*(_DWORD *)(v6 + 20) == *(_DWORD *)(v5 + 20)) {
            return strcmp((const char *)(a1 + 16968 + *(int *)(v6 + 12)), (const char *)(a1 + 16968 + *(int *)(v5 + 12))) == 0;
          }
        }
      }
    }
    return v4;
  }
  else
  {
    return 0;
  }
}

BOOL differ_by_repeat(uint64_t a1, uint64_t a2)
{
  return a1 - a2 == 0x2F0605980;
}

char *getzname(const char *a1, void *a2, void *a3)
{
  time_t v9 = a1;
  if (*a1 == 60 && (uint64_t v5 = strchr(a1, 62)) != 0)
  {
    *a2 = v9 + 1;
    *a3 = v5 - v9 - 1;
    return v5 + 1;
  }
  else
  {
    *a2 = v9;
    while (1)
    {
      char v6 = *v9;
      BOOL v4 = 0;
      if (*v9)
      {
        BOOL v4 = 0;
        if ((v6 - 48) > 9)
        {
          BOOL v4 = 0;
          if (v6 != 44)
          {
            BOOL v4 = 0;
            if (v6 != 45) {
              BOOL v4 = v6 != 43;
            }
          }
        }
      }
      if (!v4) {
        break;
      }
      ++v9;
    }
    *a3 = &v9[-*a2];
    return (char *)v9;
  }
}

char *getoffset(char *a1, void *a2)
{
  uint64_t v5 = a1;
  int v3 = 0;
  if (*a1 == 45)
  {
    int v3 = 1;
    uint64_t v5 = a1 + 1;
  }
  else if (*a1 == 43)
  {
    uint64_t v5 = a1 + 1;
  }
  char v6 = getsecs(v5, a2);
  if (!v6) {
    return 0;
  }
  if (v3) {
    *a2 = -*a2;
  }
  return v6;
}

unsigned char *getqzname(unsigned char *a1, int a2)
{
  while (1)
  {
    BOOL v3 = 0;
    if (*a1) {
      BOOL v3 = (char)*a1 != a2;
    }
    if (!v3) {
      break;
    }
    ++a1;
  }
  return a1;
}

char *getrule(char *a1, uint64_t a2)
{
  if (*a1 == 74)
  {
    *(_DWORD *)a2 = 0;
    char v6 = getnum(a1 + 1, (int *)(a2 + 4), 1, 365);
  }
  else if (*a1 == 77)
  {
    *(_DWORD *)a2 = 2;
    time_t v7 = getnum(a1 + 1, (int *)(a2 + 12), 1, 12);
    if (!v7) {
      return 0;
    }
    time_t v2 = v7;
    time_t v8 = v7 + 1;
    if (*v2 != 46) {
      return 0;
    }
    time_t v9 = getnum(v8, (int *)(a2 + 8), 1, 5);
    if (!v9) {
      return 0;
    }
    BOOL v3 = v9;
    time_t v10 = v9 + 1;
    if (*v3 != 46) {
      return 0;
    }
    char v6 = getnum(v10, (int *)(a2 + 4), 0, 6);
  }
  else
  {
    if ((*a1 - 48) > 9) {
      return 0;
    }
    *(_DWORD *)a2 = 1;
    char v6 = getnum(a1, (int *)(a2 + 4), 0, 365);
  }
  if (!v6) {
    return 0;
  }
  if (*v6 == 47) {
    return getsecs(v6 + 1, (void *)(a2 + 16));
  }
  *(void *)(a2 + 16) = 7200;
  return v6;
}

uint64_t transtime(uint64_t a1, int a2, int *a3, uint64_t a4)
{
  uint64_t v14 = 0;
  BOOL v8 = 0;
  if (!(a2 % 4))
  {
    BOOL v7 = 1;
    if (!(a2 % 100)) {
      BOOL v7 = a2 % 400 == 0;
    }
    BOOL v8 = v7;
  }
  int v6 = *a3;
  if (*a3)
  {
    if (v6 == 1)
    {
      uint64_t v14 = a1 + 86400 * a3[1];
    }
    else if (v6 == 2)
    {
      uint64_t v15 = a1;
      for (int i = 0; i < a3[3] - 1; ++i)
        v15 += 86400 * mon_lengths[12 * v8 + i];
      if (a3[3] > 2) {
        int v5 = a2;
      }
      else {
        int v5 = a2 - 1;
      }
      int v9 = ((26 * ((a3[3] + 9) % 12 + 1) - 2) / 10 + 1 + v5 % 100 + v5 % 100 / 4 + v5 / 100 / 4 - 2 * (v5 / 100)) % 7;
      int v10 = v9 + (v9 < 0 ? 7 : 0);
      int v11 = a3[1] - v10 + (a3[1] - v10 < 0 ? 7 : 0);
      for (int j = 1; j < a3[2] && v11 + 7 < mon_lengths[12 * v8 - 1 + a3[3]]; ++j)
        v11 += 7;
      uint64_t v14 = v15 + 86400 * v11;
    }
  }
  else
  {
    uint64_t v14 = a1 + 86400 * (a3[1] - 1);
    if (v8 && a3[1] >= 60) {
      v14 += 86400;
    }
  }
  return v14 + *((void *)a3 + 2) + a4;
}

char *getsecs(char *a1, void *a2)
{
  int v5 = a1;
  BOOL v4 = a2;
  int v3 = 0;
  int v5 = getnum(a1, &v3, 0, 167);
  if (v5)
  {
    *BOOL v4 = 3600 * v3;
    if (*v5 == 58)
    {
      ++v5;
      int v5 = getnum(v5, &v3, 0, 59);
      if (!v5) {
        return 0;
      }
      *v4 += 60 * v3;
      if (*v5 == 58)
      {
        ++v5;
        int v5 = getnum(v5, &v3, 0, 60);
        if (!v5) {
          return 0;
        }
        *v4 += v3;
      }
    }
    return v5;
  }
  return 0;
}

char *getnum(char *a1, int *a2, int a3, int a4)
{
  BOOL v7 = a1;
  if (!a1) {
    return 0;
  }
  char v6 = *a1;
  if ((*a1 - 48) > 9) {
    return 0;
  }
  int v5 = 0;
  do
  {
    int v5 = 10 * v5 + v6 - 48;
    if (v5 > a4) {
      return 0;
    }
    char v6 = *++v7;
  }
  while ((*v7 - 48) <= 9);
  if (v5 < a3) {
    return 0;
  }
  *a2 = v5;
  return v7;
}

uint64_t gmt_init()
{
  return gmtload((uint64_t)&gmtmem);
}

uint64_t time2sub(const void *a1, uint64_t (*a2)(uint64_t *a1, uint64_t a2, uint64_t a3), uint64_t a3, _DWORD *a4, int a5, int a6)
{
  int v34 = a1;
  size_t v33 = a2;
  uint64_t v32 = a3;
  uint64_t v31 = a4;
  int v30 = a5;
  int v29 = a6;
  uint64_t v28 = 0;
  int v27 = 0;
  int i = 0;
  int j = 0;
  int v24 = 0;
  uint64_t v23 = 0;
  uint64_t v22 = 0;
  uint64_t v21 = 0;
  uint64_t v20 = 0;
  uint64_t v19 = 0;
  uint64_t v18 = 0;
  memset(__b, 0, sizeof(__b));
  memset(v16, 0, sizeof(v16));
  *uint64_t v31 = 0;
  memcpy(__b, v34, sizeof(__b));
  if (v30 && normalize_overflow(&__b[1], __b, 60)) {
    return -1;
  }
  if (normalize_overflow(&__b[2], &__b[1], 60)) {
    return -1;
  }
  if (normalize_overflow(&__b[3], &__b[2], 24)) {
    return -1;
  }
  uint64_t v20 = __b[5];
  if (long_normalize_overflow(&v20, &__b[4], 12)) {
    return -1;
  }
  if (long_increment_overflow(&v20, 1900)) {
    return -1;
  }
  while (__b[3] <= 0)
  {
    if (long_increment_overflow(&v20, -1)) {
      return -1;
    }
    uint64_t v23 = v20 + (__b[4] > 1);
    BOOL v15 = 0;
    if (!(v23 % 4))
    {
      BOOL v14 = 1;
      if (!(v23 % 100)) {
        BOOL v14 = v23 % 400 == 0;
      }
      BOOL v15 = v14;
    }
    __b[3] += year_lengths[v15];
  }
  while (__b[3] > 366)
  {
    uint64_t v23 = v20 + (__b[4] > 1);
    BOOL v13 = 0;
    if (!(v23 % 4))
    {
      BOOL v12 = 1;
      if (!(v23 % 100)) {
        BOOL v12 = v23 % 400 == 0;
      }
      BOOL v13 = v12;
    }
    __b[3] -= year_lengths[v13];
    if (long_increment_overflow(&v20, 1)) {
      return -1;
    }
  }
  while (1)
  {
    BOOL v11 = 0;
    if (!(v20 % 4))
    {
      BOOL v10 = 1;
      if (!(v20 % 100)) {
        BOOL v10 = v20 % 400 == 0;
      }
      BOOL v11 = v10;
    }
    int i = mon_lengths[12 * v11 + __b[4]];
    if (__b[3] <= i) {
      break;
    }
    __b[3] -= i;
    if (++__b[4] >= 12)
    {
      __b[4] = 0;
      if (long_increment_overflow(&v20, 1)) {
        return -1;
      }
    }
  }
  if (long_increment_overflow(&v20, -1900)) {
    return -1;
  }
  __b[5] = v20;
  if ((int)v20 != v20) {
    return -1;
  }
  if (__b[5] < 0) {
    return -1;
  }
  if (__b[0] >= 0x3Cu)
  {
    if (v20 + 1900 >= 1970)
    {
      int v24 = __b[0];
      __b[0] = 0;
    }
    else
    {
      if (increment_overflow(__b, -59)) {
        return -1;
      }
      int v24 = __b[0];
      __b[0] = 59;
    }
  }
  else
  {
    int v24 = 0;
  }
  uint64_t v22 = 1;
  for (int i = 0; i < 63; ++i)
    v22 *= 2;
  uint64_t v21 = -(v22 + 1);
  while (1)
  {
    uint64_t v18 = v22 / 2 + v21 / 2;
    if (v18 >= v22)
    {
      if (v18 > v21) {
        uint64_t v18 = v21;
      }
    }
    else
    {
      uint64_t v18 = v22;
    }
    if (v33(&v18, v32, (uint64_t)v16))
    {
      int v27 = tmcomp(v16, __b);
    }
    else
    {
      int v7 = v18 > 0 ? 1 : -1;
      int v27 = v7;
    }
    if (!v27) {
      break;
    }
    if (v18 == v22)
    {
      if (++v18 <= v22) {
        return -1;
      }
      ++v22;
    }
    else if (v18 == v21)
    {
      if (--v18 >= v21) {
        return -1;
      }
      --v21;
    }
    if (v22 > v21) {
      return -1;
    }
    if (v27 <= 0) {
      uint64_t v22 = v18;
    }
    else {
      uint64_t v21 = v18;
    }
  }
  BOOL v8 = &lclmem;
  if (v33 != _st_localsub) {
    BOOL v8 = (int *)&gmtmem;
  }
  uint64_t v28 = v8;
  if (v29 && v28[2] == 1 && __b[8] > 0) {
    void __b[8] = 0;
  }
  if (__b[8] < 0 || v16[8] == __b[8])
  {
LABEL_101:
    uint64_t v19 = v18 + v24;
    if (v19 < v18 == v24 < 0)
    {
      uint64_t v18 = v19;
      if (v33(&v18, v32, (uint64_t)v34))
      {
        *uint64_t v31 = 1;
        return v18;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    for (int i = v28[2] - 1; i >= 0; --i)
    {
      if (v28[6 * i + 2708] == __b[8])
      {
        for (int j = v28[2] - 1; j >= 0; --j)
        {
          if (v28[6 * j + 2708] != __b[8])
          {
            uint64_t v19 = v18 + *(void *)&v28[6 * j + 2706] - *(void *)&v28[6 * i + 2706];
            if (v33(&v19, v32, (uint64_t)v16))
            {
              if (!tmcomp(v16, __b) && v16[8] == __b[8])
              {
                uint64_t v18 = v19;
                goto LABEL_101;
              }
            }
          }
        }
      }
    }
    return -1;
  }
}

BOOL normalize_overflow(int *a1, int *a2, int a3)
{
  if (*a2 < 0) {
    int v4 = -1 - (-1 - *a2) / a3;
  }
  else {
    int v4 = *a2 / a3;
  }
  *a2 -= v4 * a3;
  return increment_overflow(a1, v4);
}

BOOL long_normalize_overflow(uint64_t *a1, int *a2, int a3)
{
  if (*a2 < 0) {
    int v4 = -1 - (-1 - *a2) / a3;
  }
  else {
    int v4 = *a2 / a3;
  }
  *a2 -= v4 * a3;
  return long_increment_overflow(a1, v4);
}

BOOL long_increment_overflow(uint64_t *a1, int a2)
{
  uint64_t v3 = *a1;
  *a1 += a2;
  return *a1 < v3 != a2 < 0;
}

BOOL increment_overflow(int *a1, int a2)
{
  int v3 = *a1;
  *a1 += a2;
  return *a1 < v3 != a2 < 0;
}

uint64_t tmcomp(_DWORD *a1, _DWORD *a2)
{
  if (a1[5] == a2[5])
  {
    unsigned int v4 = a1[4] - a2[4];
    if (a1[4] == a2[4])
    {
      unsigned int v4 = a1[3] - a2[3];
      if (a1[3] == a2[3])
      {
        unsigned int v4 = a1[2] - a2[2];
        if (a1[2] == a2[2])
        {
          unsigned int v4 = a1[1] - a2[1];
          if (a1[1] == a2[1]) {
            return (*a1 - *a2);
          }
        }
      }
    }
    return v4;
  }
  else if (a1[5] > a2[5])
  {
    return 1;
  }
  else
  {
    return -1;
  }
}

size_t strftime_l(char *a1, size_t a2, const char *a3, const tm *a4, locale_t a5)
{
  BOOL v14 = a1;
  size_t v13 = a2;
  BOOL v12 = (char *)a3;
  BOOL v11 = (tm *)a4;
  BOOL v10 = a5;
  int v9 = 0;
  int v8 = 0;
  if (a5)
  {
    if (v10 == (_xlocale *)-1) {
      BOOL v10 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    BOOL v10 = (_xlocale *)&__c_locale;
  }
  tzset();
  int v8 = 0;
  if (v12) {
    int v7 = v12;
  }
  else {
    int v7 = "%c";
  }
  current_time_unsigned int locale = __get_current_time_locale((uint64_t)v10);
  int v9 = _st_fmt(v7, &v11->tm_sec, v14, &v14[v13], &v8, (uint64_t)current_time_locale, v10);
  if (v8 && getenv("CHECK_STRFTIME_FORMATS_FOR_TWO_DIGIT_YEARS"))
  {
    fputs("\n", __stderrp);
    if (v12) {
      fprintf_l(__stderrp, v10, "strftime format \"%s\" ", v12);
    }
    else {
      fputs("NULL strftime format ", __stderrp);
    }
    fputs("yields only two digits of years in ", __stderrp);
    if (v8 == 1)
    {
      fputs("some locales", __stderrp);
    }
    else if (v8 == 2)
    {
      fputs("the current locale", __stderrp);
    }
    else
    {
      fputs("all locales", __stderrp);
    }
    fputs("\n", __stderrp);
  }
  if (v9 == &v14[v13]) {
    return 0;
  }
  *int v9 = 0;
  return v9 - v14;
}

unsigned char *_st_fmt(char *a1, int *a2, unsigned char *a3, unsigned char *a4, int *a5, uint64_t a6, _xlocale *a7)
{
  BOOL v51 = a1;
  BOOL v50 = a2;
  BOOL v49 = a3;
  BOOL v48 = a4;
  BOOL v47 = a5;
  uint64_t v46 = a6;
  BOOL v45 = a7;
  int v44 = 0;
  int v43 = 0;
  int v42 = 0;
  while (*v51)
  {
    if (*v51 != 37) {
      goto LABEL_138;
    }
    int v44 = 0;
    int v43 = 0;
    int v42 = 0;
    while (2)
    {
      if (*++v51)
      {
        uint64_t v8 = *v51;
        char v7 = 1;
      }
      else
      {
        uint64_t v8 = *v51;
        char v7 = 0;
      }
      if (v7)
      {
LABEL_138:
        if (v49 == v48) {
          return v49;
        }
        char v20 = *v51;
        uint64_t v21 = v49++;
        *uint64_t v21 = v20;
      }
      else
      {
        switch(v8)
        {
          case 0:
            --v51;
            goto LABEL_138;
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 44:
          case 46:
          case 47:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 74:
          case 75:
          case 76:
          case 78:
          case 80:
          case 81:
          case 91:
          case 92:
          case 93:
          case 94:
          case 96:
          case 102:
          case 105:
          case 111:
          case 113:
            goto LABEL_138;
          case 43:
            BOOL v49 = (unsigned char *)_st_fmt(*(const char **)(v46 + 344), v50, v49, v48, v47, v46, v45);
            goto LABEL_140;
          case 45:
            if (v42) {
              goto LABEL_138;
            }
            int v42 = 1;
            continue;
          case 48:
            if (v42) {
              goto LABEL_138;
            }
            int v42 = 3;
            continue;
          case 65:
            if (v50[6] <= 6) {
              int v9 = _add(*(char **)(v46 + 248 + 8 * v50[6]), v49, (unint64_t)v48);
            }
            else {
              int v9 = _add("?", v49, (unint64_t)v48);
            }
            BOOL v49 = v9;
            goto LABEL_140;
          case 66:
            if (v50[4] < 0xC)
            {
              if (v43) {
                uint64_t v28 = v46 + 352;
              }
              else {
                uint64_t v28 = v46 + 96;
              }
              BOOL v11 = _add(*(char **)(v28 + 8 * v50[4]), v49, (unint64_t)v48);
            }
            else
            {
              BOOL v11 = _add("?", v49, (unint64_t)v48);
            }
            BOOL v49 = v11;
            goto LABEL_140;
          case 67:
            BOOL v49 = _yconv(v50[5], 1900, 1, 0, v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 68:
            BOOL v49 = (unsigned char *)_st_fmt("%m/%d/%y", v50, v49, v48, v47, v46, v45);
            goto LABEL_140;
          case 69:
            if (v44 || v43) {
              goto LABEL_138;
            }
            ++v44;
            continue;
          case 70:
            BOOL v49 = (unsigned char *)_st_fmt("%Y-%m-%d", v50, v49, v48, v47, v46, v45);
            goto LABEL_140;
          case 71:
          case 86:
          case 103:
            int v38 = 0;
            int v37 = 0;
            int v36 = 0;
            int v35 = 0;
            unsigned int v34 = 0;
            int v38 = v50[5];
            int v37 = 1900;
            int v36 = v50[7];
            int v35 = v50[6];
            break;
          case 72:
            BOOL v49 = _conv(v50[2], fmt_padding[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 73:
            if (v50[2] % 12) {
              size_t v13 = _conv(v50[2] % 12, fmt_padding[v42], v49, (unint64_t)v48, v45);
            }
            else {
              size_t v13 = _conv(0xCu, fmt_padding[v42], v49, (unint64_t)v48, v45);
            }
            BOOL v49 = v13;
            goto LABEL_140;
          case 77:
            BOOL v49 = _conv(v50[1], fmt_padding[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 79:
            if (v44 || v43) {
              goto LABEL_138;
            }
            int v43 = 1;
            continue;
          case 82:
            BOOL v49 = (unsigned char *)_st_fmt("%H:%M", v50, v49, v48, v47, v46, v45);
            goto LABEL_140;
          case 83:
            BOOL v49 = _conv(*v50, fmt_padding[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 84:
            BOOL v49 = (unsigned char *)_st_fmt("%H:%M:%S", v50, v49, v48, v47, v46, v45);
            goto LABEL_140;
          case 85:
            BOOL v49 = _conv((v50[7] + 7 - v50[6]) / 7, fmt_padding[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 87:
            if (v50[6]) {
              int v23 = v50[6] - 1;
            }
            else {
              int v23 = 6;
            }
            BOOL v49 = _conv((v50[7] + 7 - v23) / 7, fmt_padding[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 88:
            BOOL v49 = (unsigned char *)_st_fmt(*(const char **)(v46 + 304), v50, v49, v48, v47, v46, v45);
            goto LABEL_140;
          case 89:
            BOOL v49 = _yconv(v50[5], 1900, 1, 1, v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 90:
            if (*((void *)v50 + 6))
            {
              BOOL v49 = _add(*((char **)v50 + 6), v49, (unint64_t)v48);
            }
            else if (v50[8] >= 0)
            {
              BOOL v49 = _add(tzname[v50[8] != 0], v49, (unint64_t)v48);
            }
            goto LABEL_140;
          case 95:
            if (v42) {
              goto LABEL_138;
            }
            int v42 = 2;
            continue;
          case 97:
            if (v50[6] <= 6) {
              BOOL v10 = _add(*(char **)(v46 + 192 + 8 * v50[6]), v49, (unint64_t)v48);
            }
            else {
              BOOL v10 = _add("?", v49, (unint64_t)v48);
            }
            BOOL v49 = v10;
            goto LABEL_140;
          case 98:
          case 104:
            if (v50[4] < 0xC) {
              BOOL v12 = _add(*(char **)(v46 + 8 * v50[4]), v49, (unint64_t)v48);
            }
            else {
              BOOL v12 = _add("?", v49, (unint64_t)v48);
            }
            BOOL v49 = v12;
            goto LABEL_140;
          case 99:
            int v41 = 1;
            BOOL v49 = (unsigned char *)_st_fmt(*(const char **)(v46 + 320), v50, v49, v48, &v41, v46, v45);
            if (v41 == 3) {
              int v41 = 2;
            }
            if (v41 > *v47) {
              *BOOL v47 = v41;
            }
            goto LABEL_140;
          case 100:
            BOOL v49 = _conv(v50[3], fmt_padding[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 101:
            BOOL v49 = _conv(v50[3], off_DC8D8[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 106:
            BOOL v49 = _conv(v50[7] + 1, off_DC8F8[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 107:
            BOOL v49 = _conv(v50[2], off_DC8D8[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 108:
            if (v50[2] % 12) {
              BOOL v14 = _conv(v50[2] % 12, off_DC8D8[v42], v49, (unint64_t)v48, v45);
            }
            else {
              BOOL v14 = _conv(0xCu, off_DC8D8[v42], v49, (unint64_t)v48, v45);
            }
            BOOL v49 = v14;
            goto LABEL_140;
          case 109:
            BOOL v49 = _conv(v50[4] + 1, fmt_padding[v42], v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 110:
            BOOL v49 = _add("\n", v49, (unint64_t)v48);
            goto LABEL_140;
          case 112:
            if (v50[2] < 12) {
              BOOL v15 = _add(*(char **)(v46 + 328), v49, (unint64_t)v48);
            }
            else {
              BOOL v15 = _add(*(char **)(v46 + 336), v49, (unint64_t)v48);
            }
            BOOL v49 = v15;
            goto LABEL_140;
          case 114:
            BOOL v49 = (unsigned char *)_st_fmt(*(const char **)(v46 + 456), v50, v49, v48, v47, v46, v45);
            goto LABEL_140;
          case 115:
            memset(&__b, 0, sizeof(__b));
            time_t v39 = 0;
            memcpy(&__b, v50, sizeof(__b));
            time_t v39 = mktime(&__b);
            sprintf_l(v52, v45, "%ld", v39);
            BOOL v49 = _add(v52, v49, (unint64_t)v48);
            goto LABEL_140;
          case 116:
            BOOL v49 = _add("\t", v49, (unint64_t)v48);
            goto LABEL_140;
          case 117:
            if (v50[6]) {
              uint64_t v16 = _conv(v50[6], "%d", v49, (unint64_t)v48, v45);
            }
            else {
              uint64_t v16 = _conv(7u, "%d", v49, (unint64_t)v48, v45);
            }
            BOOL v49 = v16;
            goto LABEL_140;
          case 118:
            BOOL v49 = (unsigned char *)_st_fmt("%e-%b-%Y", v50, v49, v48, v47, v46, v45);
            goto LABEL_140;
          case 119:
            BOOL v49 = _conv(v50[6], "%d", v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 120:
            int v30 = 1;
            BOOL v49 = (unsigned char *)_st_fmt(*(const char **)(v46 + 312), v50, v49, v48, &v30, v46, v45);
            if (v30 == 3) {
              int v30 = 2;
            }
            if (v30 > *v47) {
              *BOOL v47 = v30;
            }
            goto LABEL_140;
          case 121:
            *BOOL v47 = 3;
            BOOL v49 = _yconv(v50[5], 1900, 0, 1, v49, (unint64_t)v48, v45);
            goto LABEL_140;
          case 122:
            if (v50[8] >= 0)
            {
              if (v50[8]) {
                int v29 = -(int)__darwin_altzone;
              }
              else {
                int v29 = -(int)_st_get_timezone();
              }
              if (v29 >= 0)
              {
                uint64_t v19 = _add("+", v49, (unint64_t)v48);
              }
              else
              {
                int v29 = -v29;
                uint64_t v19 = _add("-", v49, (unint64_t)v48);
              }
              BOOL v49 = v19;
              BOOL v49 = _conv(100 * (v29 / 60 / 60) + v29 / 60 % 60, off_DC918[v42], v19, (unint64_t)v48, v45);
            }
            goto LABEL_140;
          default:
            JUMPOUT(0);
        }
        while (1)
        {
          int v33 = 0;
          int v32 = 0;
          int v31 = 0;
          BOOL v27 = 0;
          if (!((v38 % 400 + v37 % 400) % 4))
          {
            BOOL v26 = 1;
            if (!((v38 % 400 + v37 % 400) % 100)) {
              BOOL v26 = (v38 % 400 + v37 % 400) % 400 == 0;
            }
            BOOL v27 = v26;
          }
          if (v27) {
            int v17 = 366;
          }
          else {
            int v17 = 365;
          }
          int v33 = v17;
          int v32 = (v36 + 11 - v35) % 7 - 3;
          int v31 = v32 - v17 % 7;
          if (v31 < -3) {
            v31 += 7;
          }
          v31 += v33;
          if (v36 >= v31)
          {
            ++v37;
            unsigned int v34 = 1;
            goto LABEL_99;
          }
          if (v36 >= v32) {
            break;
          }
          --v37;
          BOOL v25 = 0;
          if (!((v38 % 400 + v37 % 400) % 4))
          {
            BOOL v24 = 1;
            if (!((v38 % 400 + v37 % 400) % 100)) {
              BOOL v24 = (v38 % 400 + v37 % 400) % 400 == 0;
            }
            BOOL v25 = v24;
          }
          if (v25) {
            int v18 = 366;
          }
          else {
            int v18 = 365;
          }
          v36 += v18;
        }
        unsigned int v34 = (v36 - v32) / 7 + 1;
LABEL_99:
        if (*v51 == 86)
        {
          BOOL v49 = _conv(v34, fmt_padding[v42], v49, (unint64_t)v48, v45);
        }
        else if (*v51 == 103)
        {
          *BOOL v47 = 3;
          BOOL v49 = _yconv(v38, v37, 0, 1, v49, (unint64_t)v48, v45);
        }
        else
        {
          BOOL v49 = _yconv(v38, v37, 1, 1, v49, (unint64_t)v48, v45);
        }
      }
      break;
    }
LABEL_140:
    ++v51;
  }
  return v49;
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    BOOL v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v12 = __locale_key;
    BOOL v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11) {
    return strftime_l(a1, a2, a3, a4, v11);
  }
  else {
    return strftime_l(a1, a2, a3, a4, (locale_t)__global_locale);
  }
}

unsigned char *_add(char *a1, unsigned char *a2, unint64_t a3)
{
  while (1)
  {
    BOOL v5 = 0;
    if ((unint64_t)a2 < a3)
    {
      int v3 = a1++;
      LODWORD(v3) = *v3;
      *a2 = (_BYTE)v3;
      BOOL v5 = v3 != 0;
    }
    if (!v5) {
      break;
    }
    ++a2;
  }
  return a2;
}

unsigned char *_yconv(int a1, int a2, int a3, int a4, unsigned char *a5, unint64_t a6, _xlocale *a7)
{
  size_t v13 = a5;
  signed int v10 = a1 / 100 + a2 / 100 + (a1 % 100 + a2 % 100) / 100;
  signed int v9 = (a1 % 100 + a2 % 100) % 100;
  if (v9 >= 0 || v10 <= 0)
  {
    if (v10 < 0 && v9 > 0)
    {
      v9 -= 100;
      ++v10;
    }
  }
  else
  {
    v9 += 100;
    --v10;
  }
  if (a3)
  {
    if (v10 || v9 >= 0) {
      size_t v13 = _conv(v10, "%02d", a5, a6, a7);
    }
    else {
      size_t v13 = _add("-0", a5, a6);
    }
  }
  if (a4)
  {
    if (v9 >= 0) {
      return _conv(v9, "%02d", v13, a6, a7);
    }
    else {
      return _conv(-v9, "%02d", v13, a6, a7);
    }
  }
  return v13;
}

unsigned char *_conv(unsigned int a1, const char *a2, unsigned char *a3, unint64_t a4, _xlocale *a5)
{
  sprintf_l(v8, a5, a2, a1);
  return _add(v8, a3, a4);
}

char *__cdecl strptime(const char *a1, const char *a2, tm *a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    signed int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    signed int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strptime_l(a1, a2, a3, v9);
  }
  else {
    return strptime_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

char *__cdecl strptime_l(const char *a1, const char *a2, tm *a3, locale_t a4)
{
  uint64_t v12 = a1;
  BOOL v11 = (char *)a2;
  uint64_t v10 = a3;
  signed int v9 = a4;
  uint64_t v8 = 0;
  int v7 = 0;
  if (a4)
  {
    if (v9 == (_xlocale *)-1) {
      signed int v9 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    signed int v9 = (_xlocale *)&__c_locale;
  }
  int v7 = 0;
  v10->tm_zone = 0;
  uint64_t v8 = (char *)_strptime0(v12, v11, v10, &v7, v9, 1, 0, 85);
  if (v8)
  {
    time_t v6 = 0;
    if (v7 == 1)
    {
      time_t v6 = timegm(v10);
      localtime_r(&v6, v10);
    }
    else if (v7 == 2)
    {
      uint64_t tm_gmtoff = v10->tm_gmtoff;
      v10->uint64_t tm_gmtoff = 0;
      time_t v6 = timeoff(v10, tm_gmtoff);
      localtime_r(&v6, v10);
    }
  }
  return v8;
}

const char *_strptime0(const char *a1, char *a2, tm *a3, _DWORD *a4, _xlocale *a5, int a6, int a7, int a8)
{
  uint64_t v81 = a1;
  uint64_t v80 = a2;
  int v79 = a3;
  wint_t v78 = a4;
  locale_t v77 = a5;
  int v76 = a6;
  int v75 = a7;
  int v74 = a8;
  unsigned __int8 v73 = 0;
  int v71 = 0;
  uint64_t v70 = 0;
  char v69 = 0;
  int v68 = 0;
  int v67 = 0;
  current_time_unsigned int locale = (const char **)__get_current_time_locale((uint64_t)a5);
  int v72 = v80;
  while (*v72)
  {
    int i = 0;
    uint64_t v8 = v72++;
    unsigned __int8 v73 = *v8;
    if (v73 == 37)
    {
      int v68 = 0;
      int v67 = 0;
LABEL_14:
      uint64_t v10 = v72++;
      unsigned __int8 v73 = *v10;
      if (is_zero(v73))
      {
        BOOL v11 = v72++;
        unsigned __int8 v73 = *v11;
      }
      else if (is_plus(v73))
      {
        char v64 = 0;
        char v64 = *v72;
        if (v64)
        {
          if (v64 != 37 && !isspace_l(v64, v77))
          {
            uint64_t v12 = v72++;
            unsigned __int8 v73 = *v12;
          }
        }
      }
      if (isdigit_l((char)v73, v77))
      {
        for (int i = (char)v73 - 48; ; i += *v13 - 48)
        {
          BOOL v48 = 0;
          if (*v72) {
            BOOL v48 = isdigit_l(*v72, v77) != 0;
          }
          if (!v48) {
            break;
          }
          i *= 10;
          size_t v13 = v72++;
        }
        BOOL v14 = v72++;
        unsigned __int8 v73 = *v14;
      }
      if ((char)v73 <= 0x25)
      {
        uint64_t v16 = ((char)v73 - 37);
        char v15 = 0;
      }
      else
      {
        uint64_t v16 = ((char)v73 - 37);
        char v15 = 1;
      }
      if (v15) {
        return 0;
      }
      switch(v16)
      {
        case 0:
          int v17 = v81++;
          if (*v17 == 37) {
            continue;
          }
          return 0;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 34:
        case 37:
        case 38:
        case 39:
        case 41:
        case 43:
        case 44:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 65:
        case 66:
        case 68:
        case 74:
        case 76:
        case 81:
          return 0;
        case 6:
          uint64_t v81 = (const char *)_strptime0(v81, current_time_locale[43], v79, v78, v77, 1, 0, 85);
          if (!v81) {
            return 0;
          }
          v76 |= 0x36u;
          break;
        case 28:
        case 60:
          for (HIDWORD(v70) = 0; (unint64_t)SHIDWORD(v70) < 7; ++HIDWORD(v70))
          {
            LODWORD(v70) = strlen(current_time_locale[SHIDWORD(v70) + 31]);
            if (!strncasecmp_l(v81, current_time_locale[SHIDWORD(v70) + 31], (int)v70, v77)) {
              break;
            }
            LODWORD(v70) = strlen(current_time_locale[SHIDWORD(v70) + 24]);
            if (!strncasecmp_l(v81, current_time_locale[SHIDWORD(v70) + 24], (int)v70, v77)) {
              break;
            }
          }
          if (SHIDWORD(v70) == 7) {
            return 0;
          }
          v81 += (int)v70;
          v79->tm_wday = HIDWORD(v70);
          v76 |= 0x20u;
          continue;
        case 29:
        case 61:
        case 67:
          HIDWORD(v70) = 0;
          while ((unint64_t)SHIDWORD(v70) < 0xC)
          {
            if (v67)
            {
              if (v73 != 66
                || (LODWORD(v70) = strlen(current_time_locale[SHIDWORD(v70) + 44]),
                    strncasecmp_l(v81, current_time_locale[SHIDWORD(v70) + 44], (int)v70, v77)))
              {
LABEL_225:
                ++HIDWORD(v70);
                continue;
              }
            }
            else
            {
              LODWORD(v70) = strlen(current_time_locale[SHIDWORD(v70) + 12]);
              if (strncasecmp_l(v81, current_time_locale[SHIDWORD(v70) + 12], (int)v70, v77)) {
                goto LABEL_225;
              }
            }
            break;
          }
          if (SHIDWORD(v70) == 12 && !v67)
          {
            for (HIDWORD(v70) = 0; (unint64_t)SHIDWORD(v70) < 0xC; ++HIDWORD(v70))
            {
              LODWORD(v70) = strlen(current_time_locale[SHIDWORD(v70)]);
              if (!strncasecmp_l(v81, current_time_locale[SHIDWORD(v70)], (int)v70, v77)) {
                break;
              }
            }
          }
          if (SHIDWORD(v70) == 12) {
            return 0;
          }
          v79->tm_mosigned int n = HIDWORD(v70);
          v81 += (int)v70;
          v76 |= 4u;
          continue;
        case 30:
          if (!isdigit_l(*(unsigned __int8 *)v81, v77) && !is_plus(*v81) && !is_minus(*v81)) {
            return 0;
          }
          char v69 = 0;
          if (i) {
            int v47 = i;
          }
          else {
            int v47 = 2;
          }
          LODWORD(v70) = v47;
          if (is_plus(*v81))
          {
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          else if (is_minus(*v81))
          {
            LODWORD(v70) = v70 - 1;
            char v69 = 1;
            ++v81;
          }
          HIDWORD(v70) = 0;
          while (1)
          {
            BOOL v46 = 0;
            if (v70)
            {
              BOOL v46 = 0;
              if (*v81) {
                BOOL v46 = isdigit_l(*(unsigned __int8 *)v81, v77) != 0;
              }
            }
            if (!v46) {
              break;
            }
            HIDWORD(v70) *= 10;
            HIDWORD(v70) += *v81 - 48;
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          if (v69) {
            HIDWORD(v70) = -HIDWORD(v70);
          }
          if ((v76 & 0x200) != 0)
          {
            v79->tm_yeasize_t r = 100 * HIDWORD(v70) + v79->tm_year % 100 - 1900;
            v76 &= ~0x200u;
          }
          else
          {
            v79->tm_yeasize_t r = 100 * HIDWORD(v70) - 1900;
            v76 |= 2u;
            v76 |= 0x100u;
          }
          continue;
        case 31:
          uint64_t v81 = (const char *)_strptime0(v81, "%m/%d/%y", v79, v78, v77, 1, 0, 85);
          if (!v81) {
            return 0;
          }
          v76 |= 0x16u;
          v76 &= 0xFFFFFCFF;
          continue;
        case 32:
          if (v68 || v67) {
            continue;
          }
          ++v68;
          if (*v72 != 37) {
            goto LABEL_14;
          }
          return 0;
        case 33:
          uint64_t v81 = (const char *)_strptime0(v81, "%Y-%m-%d", v79, v78, v77, 1, 0, 85);
          if (!v81) {
            return 0;
          }
          v76 |= 0x16u;
          v76 &= 0xFFFFFCFF;
          continue;
        case 35:
        case 36:
        case 70:
        case 71:
          if (!isdigit_l(*(unsigned __int8 *)v81, v77)) {
            return 0;
          }
          if (i) {
            unsigned int v41 = i;
          }
          else {
            unsigned int v41 = 2;
          }
          uint64_t v70 = v41;
          while (1)
          {
            BOOL v40 = 0;
            if (v70)
            {
              BOOL v40 = 0;
              if (*v81) {
                BOOL v40 = isdigit_l(*(unsigned __int8 *)v81, v77) != 0;
              }
            }
            if (!v40) {
              break;
            }
            HIDWORD(v70) *= 10;
            HIDWORD(v70) += *v81 - 48;
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          if (v73 == 72 || v73 == 107)
          {
            if (SHIDWORD(v70) > 23) {
              return 0;
            }
          }
          else if (SHIDWORD(v70) > 12)
          {
            return 0;
          }
          v79->tm_housize_t r = HIDWORD(v70);
          continue;
        case 40:
        case 46:
          if (!*v81 || isspace_l(*(unsigned __int8 *)v81, v77)) {
            continue;
          }
          if (!isdigit_l(*(unsigned __int8 *)v81, v77)) {
            return 0;
          }
          if (i) {
            unsigned int v43 = i;
          }
          else {
            unsigned int v43 = 2;
          }
          uint64_t v70 = v43;
          while (1)
          {
            BOOL v42 = 0;
            if (v70)
            {
              BOOL v42 = 0;
              if (*v81) {
                BOOL v42 = isdigit_l(*(unsigned __int8 *)v81, v77) != 0;
              }
            }
            if (!v42) {
              break;
            }
            HIDWORD(v70) *= 10;
            HIDWORD(v70) += *v81 - 48;
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          if (v73 == 77)
          {
            if (SHIDWORD(v70) > 59) {
              return 0;
            }
            v79->tm_misigned int n = HIDWORD(v70);
          }
          else
          {
            if (SHIDWORD(v70) > 60) {
              return 0;
            }
            v79->tm_sec = HIDWORD(v70);
          }
          continue;
        case 42:
          if (v68 || v67) {
            continue;
          }
          int v67 = 1;
          if (*v72 != 37) {
            goto LABEL_14;
          }
          return 0;
        case 45:
          uint64_t v81 = (const char *)_strptime0(v81, "%H:%M", v79, v78, v77, 1, 0, 85);
          if (v81) {
            continue;
          }
          return 0;
        case 47:
          uint64_t v81 = (const char *)_strptime0(v81, "%H:%M:%S", v79, v78, v77, 1, 0, 85);
          if (v81) {
            continue;
          }
          return 0;
        case 48:
        case 49:
        case 50:
          if (!isdigit_l(*(unsigned __int8 *)v81, v77)) {
            return 0;
          }
          if (i) {
            unsigned int v39 = i;
          }
          else {
            unsigned int v39 = 2;
          }
          uint64_t v70 = v39;
          while (1)
          {
            BOOL v38 = 0;
            if (v70)
            {
              BOOL v38 = 0;
              if (*v81) {
                BOOL v38 = isdigit_l(*(unsigned __int8 *)v81, v77) != 0;
              }
            }
            if (!v38) {
              break;
            }
            HIDWORD(v70) *= 10;
            HIDWORD(v70) += *v81 - 48;
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          if (SHIDWORD(v70) > 53) {
            return 0;
          }
          if (v73 == 86 && SHIDWORD(v70) < 1) {
            return 0;
          }
          int v75 = HIDWORD(v70);
          int v74 = (char)v73;
          v76 |= 0x40u;
          continue;
        case 51:
          uint64_t v81 = (const char *)_strptime0(v81, current_time_locale[38], v79, v78, v77, 1, 0, 85);
          if (v81) {
            continue;
          }
          return 0;
        case 52:
        case 84:
          if (!*v81 || isspace_l(*(unsigned __int8 *)v81, v77)) {
            continue;
          }
          if (!isdigit_l(*(unsigned __int8 *)v81, v77) && !is_plus(*v81) && !is_minus(*v81)) {
            return 0;
          }
          if (i)
          {
            int v31 = i;
          }
          else
          {
            if (v73 == 89) {
              int v18 = 4;
            }
            else {
              int v18 = 2;
            }
            int v31 = v18;
          }
          LODWORD(v70) = v31;
          char v69 = 0;
          if (is_plus(*v81))
          {
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          else if (is_minus(*v81))
          {
            LODWORD(v70) = v70 - 1;
            ++v81;
            char v69 = 1;
          }
          HIDWORD(v70) = 0;
          while (1)
          {
            BOOL v30 = 0;
            if (v70)
            {
              BOOL v30 = 0;
              if (*v81) {
                BOOL v30 = isdigit_l(*(unsigned __int8 *)v81, v77) != 0;
              }
            }
            if (!v30) {
              break;
            }
            HIDWORD(v70) *= 10;
            HIDWORD(v70) += *v81 - 48;
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          if (v70 < 0) {
            return 0;
          }
          if (v69) {
            HIDWORD(v70) = -HIDWORD(v70);
          }
          if (v73 == 89)
          {
            HIDWORD(v70) -= 1900;
          }
          else if (v73 == 121 && (v76 & 0x100) != 0)
          {
            HIDWORD(v70) = v79->tm_year + SHIDWORD(v70) % 100;
            v76 &= ~0x100u;
          }
          else if (v73 == 121)
          {
            if (SHIDWORD(v70) < 69) {
              HIDWORD(v70) += 100;
            }
            v76 |= 0x200u;
          }
          v79->tm_yeasize_t r = HIDWORD(v70);
          v76 |= 2u;
          if (v73 == 89) {
            v76 &= 0xFFFFFCFF;
          }
          continue;
        case 53:
          size_t v58 = 0;
          uint64_t v57 = 0;
          for (int j = v81; ; ++j)
          {
            BOOL v29 = 0;
            if (*j) {
              BOOL v29 = isupper_l(*(unsigned __int8 *)j, v77) != 0;
            }
            if (!v29) {
              break;
            }
          }
          if (i) {
            uint64_t v28 = i;
          }
          else {
            uint64_t v28 = j - v81;
          }
          uint64_t v57 = v28;
          if (v28 == 3 && !strncmp(v81, "GMT", 3uLL))
          {
            *wint_t v78 = 1;
            v81 += v57;
          }
          else
          {
            tzset();
            size_t v58 = strlen(tzname[0]);
            if (v57 == v58 && !strncmp(v81, tzname[0], v58))
            {
              v79->tm_isdst = 0;
              v81 += v57;
            }
            else
            {
              size_t v58 = strlen(off_E95F8);
              if (v57 != v58 || strncmp(v81, off_E95F8, v58)) {
                return 0;
              }
              v79->tm_isdst = 1;
              v81 += v57;
            }
          }
          continue;
        case 62:
          uint64_t v81 = (const char *)_strptime0(v81, current_time_locale[40], v79, v78, v77, 1, 0, 85);
          if (!v81) {
            return 0;
          }
          v76 |= 0x36u;
          v76 &= 0xFFFFFCFF;
          continue;
        case 63:
          goto LABEL_200;
        case 64:
          if (*v81 && isspace_l(*(unsigned __int8 *)v81, v77)) {
            ++v81;
          }
LABEL_200:
          if (i) {
            int v37 = i;
          }
          else {
            int v37 = 2;
          }
          LODWORD(v70) = v37;
          if (isspace_l(*(unsigned __int8 *)v81, v77)
            && isdigit_l(*((unsigned __int8 *)v81 + 1), v77)
            && !isdigit_l(*((unsigned __int8 *)v81 + 2), v77))
          {
            LODWORD(v70) = 1;
            ++v81;
          }
          if (!isdigit_l(*(unsigned __int8 *)v81, v77)) {
            return 0;
          }
          HIDWORD(v70) = 0;
          while (1)
          {
            BOOL v36 = 0;
            if (v70)
            {
              BOOL v36 = 0;
              if (*v81) {
                BOOL v36 = isdigit_l(*(unsigned __int8 *)v81, v77) != 0;
              }
            }
            if (!v36) {
              break;
            }
            HIDWORD(v70) *= 10;
            HIDWORD(v70) += *v81 - 48;
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          if (SHIDWORD(v70) > 31) {
            return 0;
          }
          v79->tm_mday = HIDWORD(v70);
          v76 |= 0x10u;
          continue;
        case 69:
          if (!isdigit_l(*(unsigned __int8 *)v81, v77)) {
            return 0;
          }
          if (i) {
            unsigned int v45 = i;
          }
          else {
            unsigned int v45 = 3;
          }
          uint64_t v70 = v45;
          while (1)
          {
            BOOL v44 = 0;
            if (v70)
            {
              BOOL v44 = 0;
              if (*v81) {
                BOOL v44 = isdigit_l(*(unsigned __int8 *)v81, v77) != 0;
              }
            }
            if (!v44) {
              break;
            }
            HIDWORD(v70) *= 10;
            HIDWORD(v70) += *v81 - 48;
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          if (SHIDWORD(v70) < 1 || SHIDWORD(v70) > 366) {
            return 0;
          }
          v79->tm_yday = HIDWORD(v70) - 1;
          v76 |= 8u;
          continue;
        case 72:
          if (!isdigit_l(*(unsigned __int8 *)v81, v77)) {
            return 0;
          }
          if (i) {
            unsigned int v35 = i;
          }
          else {
            unsigned int v35 = 2;
          }
          uint64_t v70 = v35;
          while (1)
          {
            BOOL v34 = 0;
            if (v70)
            {
              BOOL v34 = 0;
              if (*v81) {
                BOOL v34 = isdigit_l(*(unsigned __int8 *)v81, v77) != 0;
              }
            }
            if (!v34) {
              break;
            }
            HIDWORD(v70) *= 10;
            HIDWORD(v70) += *v81 - 48;
            LODWORD(v70) = v70 - 1;
            ++v81;
          }
          if (SHIDWORD(v70) < 1 || SHIDWORD(v70) > 12) {
            return 0;
          }
          v79->tm_mosigned int n = HIDWORD(v70) - 1;
          v76 |= 4u;
          continue;
        case 73:
        case 79:
          if (!isspace(*(unsigned __int8 *)v81)) {
            return 0;
          }
          while (isspace_l(*(unsigned __int8 *)v81, v77))
            ++v81;
          continue;
        case 75:
          if (v79->tm_hour > 12) {
            return 0;
          }
          LODWORD(v70) = strlen(current_time_locale[41]);
          if (strncasecmp_l(v81, current_time_locale[41], (int)v70, v77))
          {
            LODWORD(v70) = strlen(current_time_locale[42]);
            if (strncasecmp_l(v81, current_time_locale[42], (int)v70, v77)) {
              return 0;
            }
            if (v79->tm_hour != 12) {
              v79->tm_hour += 12;
            }
            v81 += (int)v70;
          }
          else
          {
            if (v79->tm_hour == 12) {
              v79->tm_housize_t r = 0;
            }
            v81 += (int)v70;
          }
          continue;
        case 77:
          uint64_t v81 = (const char *)_strptime0(v81, current_time_locale[57], v79, v78, v77, 1, 0, 85);
          if (v81) {
            continue;
          }
          return 0;
        case 78:
          size_t v63 = 0;
          int v62 = 0;
          time_t v61 = 0;
          time_t v60 = 0;
          int v62 = *__error();
          *__error() = 0;
          time_t v61 = strtol_l(v81, &v63, 10, v77);
          if (*__error() == 34)
          {
            int v33 = v62;
            *__error() = v33;
            return 0;
          }
          time_t v60 = v61;
          int v32 = v62;
          *__error() = v32;
          uint64_t v81 = v63;
          if (!gmtime_r(&v60, v79)) {
            return 0;
          }
          *wint_t v78 = 1;
          v76 |= 0x3Eu;
          v76 &= 0xFFFFFCFF;
          continue;
        case 80:
        case 82:
          if (!isdigit_l(*(unsigned __int8 *)v81, v77)) {
            return 0;
          }
          HIDWORD(v70) = *v81 - 48;
          if (HIDWORD(v70) >= 8 || v73 == 117 && SHIDWORD(v70) < 1 || v73 == 119 && SHIDWORD(v70) > 6) {
            return 0;
          }
          v79->tm_wday = SHIDWORD(v70) % 7;
          v76 |= 0x20u;
          ++v81;
          continue;
        case 83:
          uint64_t v81 = (const char *)_strptime0(v81, current_time_locale[39], v79, v78, v77, 1, 0, 85);
          if (!v81) {
            return 0;
          }
          v76 |= 0x16u;
          v76 &= 0xFFFFFCFF;
          continue;
        case 85:
          char v56 = 0;
          int v55 = 0;
          int v54 = 0;
          if (*v81 != 43 && *v81 != 45
            || !isdigit_l(*((unsigned __int8 *)v81 + 1), v77)
            || !isdigit_l(*((unsigned __int8 *)v81 + 2), v77)
            || !isdigit_l(*((unsigned __int8 *)v81 + 3), v77)
            || !isdigit_l(*((unsigned __int8 *)v81 + 4), v77))
          {
            return 0;
          }
          sscanf(v81, "%c%2d%2d", &v56, &v55, &v54);
          *wint_t v78 = 2;
          v79->uint64_t tm_gmtoff = 60 * (60 * v55 + v54);
          if (v56 == 45) {
            v79->uint64_t tm_gmtoff = -v79->tm_gmtoff;
          }
          v81 += 5;
          continue;
        default:
          JUMPOUT(0);
      }
    }
    else if (isspace_l(v73, v77))
    {
      while (1)
      {
        BOOL v49 = 0;
        if (*v81) {
          BOOL v49 = isspace_l(*(unsigned __int8 *)v81, v77) != 0;
        }
        if (!v49) {
          break;
        }
        ++v81;
      }
    }
    else
    {
      signed int v9 = v81++;
      if (v73 != *v9) {
        return 0;
      }
    }
  }
  if ((v76 & 8) == 0 && (v76 & 2) != 0)
  {
    if ((v76 & 0x14) == 0x14)
    {
      BOOL v27 = 0;
      if (!((v79->tm_year + 1900) % 4))
      {
        BOOL v26 = 1;
        if (!((v79->tm_year + 1900) % 100)) {
          BOOL v26 = (v79->tm_year + 1900) % 400 == 0;
        }
        BOOL v27 = v26;
      }
      v79->tm_yday = _strptime0_start_of_month[13 * v27 + v79->tm_mon] + v79->tm_mday - 1;
      v76 |= 8u;
    }
    else if ((v76 & 0x40) != 0)
    {
      int v53 = v74 != 85;
      int wday_of = first_wday_of(v79->tm_year + 1900);
      if (!v75 && wday_of == v53) {
        return 0;
      }
      if ((v76 & 0x20) == 0)
      {
        v79->tm_wday = v53;
        v76 |= 0x20u;
      }
      int v50 = (7 - wday_of + v53) % 7;
      if (v74 == 86 && wday_of > 1 && wday_of <= 4) {
        v50 -= 7;
      }
      int v51 = v50 + 7 * (v75 - 1) + (v79->tm_wday - v53 + 7) % 7;
      if (v51 < 0)
      {
        if ((v76 & 0x20) != 0) {
          return 0;
        }
        int v51 = 0;
      }
      v79->tm_yday = v51;
      v76 |= 8u;
    }
  }
  if ((v76 & 0xA) == 0xA)
  {
    if ((v76 & 4) == 0)
    {
      for (HIDWORD(v70) = 0; ; ++HIDWORD(v70))
      {
        BOOL v25 = 0;
        if (!((v79->tm_year + 1900) % 4))
        {
          BOOL v24 = 1;
          if (!((v79->tm_year + 1900) % 100)) {
            BOOL v24 = (v79->tm_year + 1900) % 400 == 0;
          }
          BOOL v25 = v24;
        }
        if (v79->tm_yday < _strptime0_start_of_month[13 * v25 + SHIDWORD(v70)]) {
          break;
        }
      }
      if (SHIDWORD(v70) > 12)
      {
        HIDWORD(v70) = 1;
        BOOL v23 = 0;
        if (!((v79->tm_year + 1900) % 4))
        {
          BOOL v22 = 1;
          if (!((v79->tm_year + 1900) % 100)) {
            BOOL v22 = (v79->tm_year + 1900) % 400 == 0;
          }
          BOOL v23 = v22;
        }
        v79->tm_yday -= _strptime0_start_of_month[13 * v23 + 12];
        ++v79->tm_year;
      }
      v79->tm_mosigned int n = HIDWORD(v70) - 1;
      v76 |= 4u;
    }
    if ((v76 & 0x10) == 0)
    {
      BOOL v21 = 0;
      if (!((v79->tm_year + 1900) % 4))
      {
        BOOL v20 = 1;
        if (!((v79->tm_year + 1900) % 100)) {
          BOOL v20 = (v79->tm_year + 1900) % 400 == 0;
        }
        BOOL v21 = v20;
      }
      v79->tm_mday = v79->tm_yday - _strptime0_start_of_month[13 * v21 + v79->tm_mon] + 1;
      v76 |= 0x10u;
    }
    if ((v76 & 0x20) == 0)
    {
      int v71 = first_wday_of(v79->tm_year + 1900);
      v79->tm_wday = (v71 + v79->tm_yday) % 7;
      v76 |= 0x20u;
    }
  }
  return v81;
}

BOOL is_zero(char a1)
{
  return a1 == 48;
}

BOOL is_plus(char a1)
{
  return a1 == 43;
}

BOOL is_minus(char a1)
{
  return a1 == 45;
}

uint64_t first_wday_of(int a1)
{
  BOOL v4 = 0;
  if (!(a1 % 4))
  {
    BOOL v3 = 1;
    if (!(a1 % 100)) {
      BOOL v3 = a1 % 400 == 0;
    }
    BOOL v4 = v3;
  }
  if (v4) {
    int v1 = 6;
  }
  else {
    int v1 = 0;
  }
  return ((2 * (3 - a1 / 100 % 4) + a1 % 100 + a1 % 100 / 4 + v1 + 1) % 7);
}

time_t _time32_to_time(int32_t t32)
{
  *(void *)&t32 = t32;
  LODWORD(result) = t32;
  return result;
}

int32_t _time_to_time32(time_t t)
{
  return t;
}

time_t _time64_to_time(time_t t64)
{
  return t64;
}

int64_t _time_to_time64(int64_t t)
{
  return t;
}

uint64_t _time_to_long(time_t t)
{
  return _time_to_time64(t);
}

time_t _long_to_time(time_t tlong)
{
  return tlong;
}

int _time_to_int(time_t t)
{
  return t;
}

time_t _int_to_time(int tint)
{
  return _time32_to_time(tint);
}

char **__get_current_time_locale(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 1315)) {
    return (char **)(*(void *)(a1 + 1352) + 72);
  }
  else {
    return _C_time_locale;
  }
}

uint64_t __time_load_locale(char *a1, uint64_t a2)
{
  if (!strcmp(a1, "C") || !strcmp(a1, "POSIX") || !strncmp(a1, "C.", 2uLL))
  {
    *(unsigned char *)(a2 + 1315) = 0;
    xlocale_release(*(void *)(a2 + 1352));
    *(void *)(a2 + 1352) = 0;
    return 1;
  }
  else if (__time_load_locale_cache {
         && *(void *)(__time_load_locale_cache + 64)
  }
         && !strcmp(a1, *(const char **)(__time_load_locale_cache + 64)))
  {
    *(unsigned char *)(a2 + 1315) = 1;
    xlocale_release(*(void *)(a2 + 1352));
    *(void *)(a2 + 1352) = __time_load_locale_cache;
    xlocale_retain((atomic_uint *)__time_load_locale_cache);
    return 1;
  }
  else
  {
    BOOL v3 = (void *)malloc_type_malloc();
    if (v3)
    {
      *(_DWORD *)BOOL v3 = 1;
      *((void *)v3 + 1) = destruct_ldpart;
      *((void *)v3 + 8) = 0;
      unsigned int locale = __part_load_locale(a1, (unsigned char *)(a2 + 1315), (void **)v3 + 8, "LC_TIME", 58, 58, (uint64_t)v3 + 72);
      if (locale)
      {
        if (locale == -1) {
          free(v3);
        }
      }
      else
      {
        xlocale_release(*(void *)(a2 + 1352));
        *(void *)(a2 + 1352) = v3;
        xlocale_release(__time_load_locale_cache);
        __time_load_locale_cache = (uint64_t)v3;
        xlocale_retain((atomic_uint *)v3);
      }
      return locale;
    }
    else
    {
      return -1;
    }
  }
}

void *__cdecl memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
{
  if (!__big_len || !__little_len) {
    return 0;
  }
  if (__big_len < __little_len) {
    return 0;
  }
  if (__little_len == 1) {
    return memchr(__big, *(char *)__little, __big_len);
  }
  time_t v6 = (char *)__big + __big_len - __little_len;
  for (__s1 = (char *)__big; __s1 <= v6; ++__s1)
  {
    if (*__s1 == *(char *)__little && !memcmp(__s1, __little, __little_len)) {
      return __s1;
    }
  }
  return 0;
}

char *__cdecl rindex(const char *a1, int a2)
{
  BOOL v3 = 0;
  while (1)
  {
    if (*a1 == (char)a2) {
      BOOL v3 = (char *)a1;
    }
    if (!*a1) {
      break;
    }
    ++a1;
  }
  return v3;
}

int strcasecmp_l(const char *a1, const char *a2, locale_t a3)
{
  uint64_t v10 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      uint64_t v10 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v10 = (_xlocale *)&__c_locale;
  }
  while (1)
  {
    int v7 = tolower_l(*(unsigned __int8 *)a1, v10);
    BOOL v3 = a2++;
    if (v7 != tolower_l(*(unsigned __int8 *)v3, v10)) {
      break;
    }
    BOOL v4 = a1++;
    if (!*v4) {
      return 0;
    }
  }
  int v6 = tolower_l(*(unsigned __int8 *)a1, v10);
  return v6 - tolower_l(*((unsigned __int8 *)a2 - 1), v10);
}

int strcasecmp(const char *a1, const char *a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return strcasecmp_l(a1, a2, v7);
  }
  else {
    return strcasecmp_l(a1, a2, (locale_t)__global_locale);
  }
}

int strncasecmp_l(const char *a1, const char *a2, size_t a3, locale_t a4)
{
  size_t v12 = a3;
  BOOL v11 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      BOOL v11 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    BOOL v11 = (_xlocale *)&__c_locale;
  }
  if (!a3) {
    return 0;
  }
  while (1)
  {
    int v8 = tolower_l(*(unsigned __int8 *)a1, v11);
    BOOL v4 = a2++;
    if (v8 != tolower_l(*(unsigned __int8 *)v4, v11)) {
      break;
    }
    BOOL v5 = a1++;
    if (*v5)
    {
      if (--v12) {
        continue;
      }
    }
    return 0;
  }
  int v7 = tolower_l(*(unsigned __int8 *)a1, v11);
  return v7 - tolower_l(*((unsigned __int8 *)a2 - 1), v11);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    signed int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    signed int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strncasecmp_l(a1, a2, a3, v9);
  }
  else {
    return strncasecmp_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

char *__cdecl strcasestr_l(const char *a1, const char *a2, locale_t a3)
{
  int v8 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      int v8 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    int v8 = (_xlocale *)&__c_locale;
  }
  __s = (char *)(a2 + 1);
  if (*a2)
  {
    char v7 = tolower_l(*(unsigned __int8 *)a2, v8);
    size_t v6 = strlen(__s);
    do
    {
      char v3 = a1++;
      int v4 = *v3;
      if (!v4) {
        return 0;
      }
    }
    while (v7 != (char)tolower_l(v4, v8) || strncasecmp_l(a1, __s, v6, v8));
    --a1;
  }
  return (char *)a1;
}

char *__cdecl strcasestr(const char *__big, const char *__little)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    char v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    char v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return strcasestr_l(__big, __little, v7);
  }
  else {
    return strcasestr_l(__big, __little, (locale_t)__global_locale);
  }
}

int strcoll_l(const char *a1, const char *a2, locale_t a3)
{
  locale_t v9 = a3;
  char v7 = 0;
  size_t v6 = 0;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      locale_t v9 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v9 = (locale_t)&__c_locale;
  }
  if (!*(unsigned char *)(*((void *)v9 + 165) + 64)
    && (char v7 = __collate_mbstowcs((char *)a1, v9)) != 0
    && (size_t v6 = __collate_mbstowcs((char *)a2, v9)) != 0)
  {
    int v8 = wcscoll_l(v7, v6, v9);
    int v5 = *__error();
    free(v7);
    free(v6);
    *__error() = v5;
    return v8;
  }
  else
  {
    int v4 = *__error();
    free(v7);
    free(v6);
    *__error() = v4;
    return strcmp(a1, a2);
  }
}

int strcoll(const char *__s1, const char *__s2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    char v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    char v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return strcoll_l(__s1, __s2, v7);
  }
  else {
    return strcoll_l(__s1, __s2, (locale_t)__global_locale);
  }
}

size_t strcspn(const char *__s, const char *__charset)
{
  if (!*__s) {
    return 0;
  }
  v7[0] = 1;
  memset(&v7[1], 0, 24);
  while (*__charset)
  {
    char v2 = &v7[*(unsigned __int8 *)__charset / 64];
    *v2 |= 1 << (*(unsigned __int8 *)__charset++ % 64);
  }
  for (int i = __s; (v7[*(unsigned __int8 *)i / 64] & (1 << (*(unsigned __int8 *)i % 64))) == 0; ++i)
    ;
  return i - __s;
}

char *__cdecl strdup(const char *__s1)
{
  __signed int n = strlen(__s1) + 1;
  mbstate_t __dst = (void *)malloc_type_malloc();
  if (!__dst) {
    return 0;
  }
  memcpy(__dst, __s1, __n);
  return (char *)__dst;
}

size_t __errstr(int a1, const char *a2, char *a3, size_t a4)
{
  char v7 = &v11;
  char v11 = 0;
  if (a1 < 0) {
    int v5 = -a1;
  }
  else {
    int v5 = a1;
  }
  unsigned int v6 = v5;
  do
  {
    *--char v7 = a0123456789[v6 % 0xA];
    v6 /= 0xAu;
  }
  while (v6);
  if (a1 < 0) {
    *--char v7 = 45;
  }
  uint64_t v8 = v7 - 1;
  *v8-- = 32;
  *uint64_t v8 = 58;
  strlcpy(a3, a2, a4);
  return strlcat(a3, v8, a4);
}

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
{
  int v4 = 0;
  if (__errnum <= 0x6A)
  {
    if (strlcpy(__strerrbuf, sys_errlist[__errnum], __buflen) >= __buflen) {
      return 34;
    }
  }
  else
  {
    __errstr(__errnum, "Unknown error", __strerrbuf, __buflen);
    return 22;
  }
  return v4;
}

char *__cdecl strerror(int __errnum)
{
  if (__errnum <= 0x6A) {
    return (char *)sys_errlist[__errnum];
  }
  if (!__strerror_ebuf)
  {
    __strerror_eunint64_t buf = malloc_type_calloc();
    if (!__strerror_ebuf) {
      return 0;
    }
  }
  if (strerror_r(__errnum, (char *)__strerror_ebuf, 0x800uLL)) {
    *__error() = 22;
  }
  return (char *)__strerror_ebuf;
}

void strmode(int __mode, char *__bp)
{
  int v23 = __mode & 0xF000;
  switch(v23)
  {
    case 4096:
      BOOL v24 = __bp + 1;
      *__bp = 112;
      break;
    case 8192:
      BOOL v24 = __bp + 1;
      *__bp = 99;
      break;
    case 16384:
      BOOL v24 = __bp + 1;
      *__bp = 100;
      break;
    case 24576:
      BOOL v24 = __bp + 1;
      *__bp = 98;
      break;
    case 32768:
      BOOL v24 = __bp + 1;
      *__bp = 45;
      break;
    case 40960:
      BOOL v24 = __bp + 1;
      *__bp = 108;
      break;
    case 49152:
      BOOL v24 = __bp + 1;
      *__bp = 115;
      break;
    default:
      BOOL v24 = __bp + 1;
      if (v23 == 57344) {
        *__bp = 119;
      }
      else {
        *__bp = 63;
      }
      break;
  }
  char v2 = v24;
  BOOL v25 = v24 + 1;
  if ((__mode & 0x100) != 0) {
    *char v2 = 114;
  }
  else {
    *char v2 = 45;
  }
  char v3 = v25;
  BOOL v26 = v25 + 1;
  if ((__mode & 0x80u) == 0) {
    *char v3 = 45;
  }
  else {
    *char v3 = 119;
  }
  int v22 = __mode & 0x840;
  if ((__mode & 0x840) != 0)
  {
    switch(v22)
    {
      case 64:
        int v5 = v26++;
        *int v5 = 120;
        break;
      case 2048:
        unsigned int v6 = v26++;
        *unsigned int v6 = 83;
        break;
      case 2112:
        char v7 = v26++;
        *char v7 = 115;
        break;
    }
  }
  else
  {
    int v4 = v26++;
    *int v4 = 45;
  }
  uint64_t v8 = v26;
  BOOL v27 = v26 + 1;
  if ((__mode & 0x20) != 0) {
    *uint64_t v8 = 114;
  }
  else {
    *uint64_t v8 = 45;
  }
  locale_t v9 = v27;
  uint64_t v28 = v27 + 1;
  if ((__mode & 0x10) != 0) {
    *locale_t v9 = 119;
  }
  else {
    *locale_t v9 = 45;
  }
  int v21 = __mode & 0x408;
  if ((__mode & 0x408) != 0)
  {
    switch(v21)
    {
      case 8:
        char v11 = v28++;
        *char v11 = 120;
        break;
      case 1024:
        size_t v12 = v28++;
        *size_t v12 = 83;
        break;
      case 1032:
        size_t v13 = v28++;
        *size_t v13 = 115;
        break;
    }
  }
  else
  {
    uint64_t v10 = v28++;
    *uint64_t v10 = 45;
  }
  BOOL v14 = v28;
  BOOL v29 = v28 + 1;
  if ((__mode & 4) != 0) {
    *BOOL v14 = 114;
  }
  else {
    *BOOL v14 = 45;
  }
  char v15 = v29;
  BOOL v30 = v29 + 1;
  if ((__mode & 2) != 0) {
    *char v15 = 119;
  }
  else {
    *char v15 = 45;
  }
  int v20 = __mode & 0x201;
  if ((__mode & 0x201) != 0)
  {
    switch(v20)
    {
      case 1:
        int v17 = v30++;
        *int v17 = 120;
        break;
      case 512:
        int v18 = v30++;
        *int v18 = 84;
        break;
      case 513:
        uint64_t v19 = v30++;
        *uint64_t v19 = 116;
        break;
    }
  }
  else
  {
    uint64_t v16 = v30++;
    *uint64_t v16 = 45;
  }
  *BOOL v30 = 32;
  v30[1] = 0;
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  for (size_t __na = 0; ; ++__na)
  {
    BOOL v3 = 0;
    if (__na < __n) {
      BOOL v3 = __s1[__na] != 0;
    }
    if (!v3) {
      break;
    }
  }
  mbstate_t __dst = (void *)malloc_type_malloc();
  if (!__dst) {
    return 0;
  }
  memcpy(__dst, __s1, __na);
  *((unsigned char *)__dst + __na) = 0;
  return (char *)__dst;
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  __s = (char *)(__little + 1);
  char v8 = *__little;
  if (*__little)
  {
    __signed int n = strlen(__s);
    do
    {
      do
      {
        if (__len--)
        {
          int v4 = __big++;
          int v5 = *v4;
          if (v5) {
            continue;
          }
        }
        return 0;
      }
      while ((char)v5 != v8);
      if (__n > __len) {
        return 0;
      }
    }
    while (strncmp(__big, __s, __n));
    --__big;
  }
  return (char *)__big;
}

char *__cdecl strpbrk(const char *__s, const char *__charset)
{
  while (1)
  {
    char v2 = __s++;
    int v5 = *v2;
    if (!*v2) {
      break;
    }
    unsigned int v6 = __charset;
    while (1)
    {
      BOOL v3 = v6++;
      if (!*v3) {
        break;
      }
      if (*v3 == v5) {
        return (char *)(__s - 1);
      }
    }
  }
  return 0;
}

char *__cdecl strrchr(const char *__s, int __c)
{
  BOOL v3 = 0;
  while (1)
  {
    if (*__s == (char)__c) {
      BOOL v3 = (char *)__s;
    }
    if (!*__s) {
      break;
    }
    ++__s;
  }
  return v3;
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  char v8 = *__stringp;
  if (!*__stringp) {
    return 0;
  }
  int v5 = *__stringp;
LABEL_4:
  char v2 = v8++;
  int v6 = *v2;
  char v7 = __delim;
  while (1)
  {
    BOOL v3 = v7++;
    if (*v3 == v6) {
      break;
    }
    if (!*v3) {
      goto LABEL_4;
    }
  }
  if (v6) {
    *(v8 - 1) = 0;
  }
  else {
    char v8 = 0;
  }
  char *__stringp = v8;
  return v5;
}

int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
{
  int v12 = 0;
  *(void *)__s = 0;
  v17[0] = 0;
  *(void *)((char *)v17 + 7) = 0;
  int v10 = __sig;
  if (__sig < 0) {
    int v10 = -__sig;
  }
  locale_t v9 = __s;
  do
  {
    BOOL v3 = v9++;
    *BOOL v3 = a0123456789[v10 % 10];
    v10 /= 10;
  }
  while (v10);
  if (__sig < 0)
  {
    int v4 = v9++;
    *int v4 = 45;
  }
  int v7 = strlen(__s) + 2;
  if (__sig <= 0 || __sig >= 32)
  {
    size_t v11 = strlcpy(__strsignalbuf, "Unknown signal", __buflen);
    int v12 = 22;
  }
  else
  {
    size_t v11 = strlcpy(__strsignalbuf, sys_siglist[__sig], __buflen);
    if (v11 >= __buflen - v7) {
      int v12 = 34;
    }
  }
  if (v11 < __buflen - v7)
  {
    __strsignalbuf[v11] = 58;
    char v8 = &__strsignalbuf[v11 + 2];
    __strsignalbuf[v11 + 1] = 32;
    do
    {
      --v9;
      int v5 = v8++;
      *int v5 = *v9;
    }
    while (v9 > __s);
    *char v8 = 0;
  }
  return v12;
}

char *__cdecl strsignal(int __sig)
{
  __strsignalunint64_t buf = (char *)sig_tlsalloc();
  if (__strsignalbuf)
  {
    if (strsignal_r(__sig, __strsignalbuf, 0x800uLL)) {
      *__error() = 22;
    }
    return __strsignalbuf;
  }
  else
  {
    *__error() = 12;
    return 0;
  }
}

void *sig_tlsalloc()
{
  int v1 = 0;
  if (!pthread_once(&sig_init_once, (void (*)(void))sig_keycreate))
  {
    if (sig_keycreated)
    {
      int v1 = pthread_getspecific(sig_key);
      if (!v1)
      {
        int v1 = (void *)malloc_type_malloc();
        if (v1)
        {
          if (pthread_setspecific(sig_key, v1))
          {
            free(v1);
            return 0;
          }
        }
      }
    }
  }
  return v1;
}

uint64_t sig_keycreate()
{
  uint64_t result = pthread_key_create((pthread_key_t *)&sig_key, (void (__cdecl *)(void *))&_free);
  sig_keycreated = result == 0;
  return result;
}

size_t strspn(const char *__s, const char *__charset)
{
  if (!*__s) {
    return 0;
  }
  memset(v7, 0, sizeof(v7));
  while (*__charset)
  {
    char v2 = &v7[*(unsigned __int8 *)__charset / 64];
    *v2 |= 1 << (*(unsigned __int8 *)__charset++ % 64);
  }
  for (int i = __s; (v7[*(unsigned __int8 *)i / 64] & (1 << (*(unsigned __int8 *)i % 64))) != 0; ++i)
    ;
  return i - __s;
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  size_t v13 = __str;
  if (!__str)
  {
    size_t v13 = *__lasts;
    if (!*__lasts) {
      return 0;
    }
  }
LABEL_4:
  BOOL v3 = v13++;
  int v8 = *v3;
  size_t v11 = __sep;
  while (1)
  {
    int v4 = v11++;
    if (!*v4) {
      break;
    }
    if (v8 == *v4) {
      goto LABEL_4;
    }
  }
  if (v8)
  {
    int v10 = v13 - 1;
LABEL_11:
    int v5 = v13++;
    int v9 = *v5;
    int v12 = __sep;
    while (1)
    {
      int v6 = v12++;
      if (*v6 == v9) {
        break;
      }
      if (!*v6) {
        goto LABEL_11;
      }
    }
    if (v9) {
      *(v13 - 1) = 0;
    }
    else {
      size_t v13 = 0;
    }
    *__lasts = v13;
    return v10;
  }
  else
  {
    *__lasts = 0;
    return 0;
  }
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return strtok_r(__str, __sep, &strtok_last);
}

size_t strxfrm_l(char *a1, const char *a2, size_t a3, locale_t a4)
{
  mbstate_t __dst = a1;
  __source = (char *)a2;
  size_t __size = a3;
  locale_t v22 = a4;
  size_t v21 = 0;
  int v20 = 0;
  memset(__b, 0, sizeof(__b));
  int v19 = 0;
  if (*__source || !__dst)
  {
    if (v22)
    {
      if (v22 == (locale_t)-1) {
        locale_t v22 = (locale_t)__global_locale;
      }
    }
    else
    {
      locale_t v22 = (locale_t)&__c_locale;
    }
    if (!*(unsigned char *)(*((void *)v22 + 165) + 64) && (int v20 = __collate_mbstowcs(__source, v22)) != 0)
    {
      __collate_xfrm((const __int32 *)v20, (uint64_t)__b, (uint64_t)v22);
      size_t v21 = 4 * wcslen(__b[0]);
      if (__b[1]) {
        v21 += 4 * (wcslen(__b[1]) + 1);
      }
      if (__size)
      {
        int v18 = __b[0];
        int v17 = 0;
        BOOL v14 = 0;
        while (__size > 1)
        {
          if (!v17)
          {
            if (!*v18) {
              break;
            }
            BOOL v14 = v16;
            int v4 = (int *)v18++;
            xfrm(v16, *v4);
            int v17 = 4;
          }
          int v5 = v14++;
          LOBYTE(v5) = *v5;
          int v6 = __dst++;
          *int v6 = (char)v5;
          --v17;
          --__size;
        }
        int v18 = __b[1];
        if (__b[1])
        {
          char v15 = v16;
          xfrm(v16, 0);
          int v17 = 4;
          while (__size > 1 && v17)
          {
            int v7 = v15++;
            LOBYTE(v7) = *v7;
            int v8 = __dst++;
            *int v8 = (char)v7;
            --v17;
            --__size;
          }
          int v17 = 0;
          while (__size > 1)
          {
            if (!v17)
            {
              if (!*v18) {
                break;
              }
              char v15 = v16;
              int v9 = (int *)v18++;
              xfrm(v16, *v9);
              int v17 = 4;
            }
            int v10 = v15++;
            LOBYTE(v10) = *v10;
            size_t v11 = __dst++;
            *size_t v11 = (char)v10;
            --v17;
            --__size;
          }
        }
        char *__dst = 0;
      }
      int v19 = *__error();
      free(v20);
      free((void *)__b[0]);
      free((void *)__b[1]);
      int v13 = v19;
      *__error() = v13;
      return v21;
    }
    else
    {
      return strlcpy(__dst, __source, __size);
    }
  }
  else
  {
    if (__size) {
      char *__dst = 0;
    }
    return 0;
  }
}

unsigned char *xfrm(unsigned char *result, int a2)
{
  result[3] = (a2 & 0x3F) + 48;
  result[2] = ((a2 >> 6) & 0x3F) + 48;
  result[1] = ((a2 >> 12) & 0x3F) + 48;
  char *result = ((a2 >> 18) & 0x3F) + 48;
  return result;
}

size_t strxfrm(char *__s1, const char *__s2, size_t __n)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strxfrm_l(__s1, __s2, __n, v9);
  }
  else {
    return strxfrm_l(__s1, __s2, __n, (locale_t)__global_locale);
  }
}

void swab(const void *a1, void *a2, ssize_t a3)
{
  if (a3 > 0)
  {
    for (int i = a3 >> 1; (i & 7) != 0; --i)
    {
      char v11 = *(unsigned char *)a1;
      char v3 = (char *)a1 + 1;
      a1 = (char *)a1 + 2;
      *(unsigned char *)a2 = *v3;
      char v4 = (char *)a2 + 1;
      a2 = (char *)a2 + 2;
      *char v4 = v11;
    }
    for (int j = i >> 3; j > 0; --j)
    {
      char v12 = *(unsigned char *)a1;
      *(unsigned char *)a2 = *((unsigned char *)a1 + 1);
      *((unsigned char *)a2 + 1) = v12;
      char v13 = *((unsigned char *)a1 + 2);
      *((unsigned char *)a2 + 2) = *((unsigned char *)a1 + 3);
      *((unsigned char *)a2 + 3) = v13;
      char v14 = *((unsigned char *)a1 + 4);
      *((unsigned char *)a2 + 4) = *((unsigned char *)a1 + 5);
      *((unsigned char *)a2 + 5) = v14;
      char v15 = *((unsigned char *)a1 + 6);
      *((unsigned char *)a2 + 6) = *((unsigned char *)a1 + 7);
      *((unsigned char *)a2 + 7) = v15;
      char v16 = *((unsigned char *)a1 + 8);
      *((unsigned char *)a2 + 8) = *((unsigned char *)a1 + 9);
      *((unsigned char *)a2 + 9) = v16;
      char v17 = *((unsigned char *)a1 + 10);
      *((unsigned char *)a2 + 10) = *((unsigned char *)a1 + 11);
      *((unsigned char *)a2 + 11) = v17;
      char v18 = *((unsigned char *)a1 + 12);
      *((unsigned char *)a2 + 12) = *((unsigned char *)a1 + 13);
      *((unsigned char *)a2 + 13) = v18;
      char v19 = *((unsigned char *)a1 + 14);
      int v5 = (char *)a1 + 15;
      a1 = (char *)a1 + 16;
      *((unsigned char *)a2 + 14) = *v5;
      int v6 = (char *)a2 + 15;
      a2 = (char *)a2 + 16;
      *int v6 = v19;
    }
  }
}

__int32 *__cdecl wcpcpy(__int32 *a1, const __int32 *a2)
{
  while (1)
  {
    __int32 v2 = *a2;
    *a1 = *a2;
    if (!v2) {
      break;
    }
    ++a2;
    ++a1;
  }
  return a1;
}

__int32 *__cdecl wcpncpy(__int32 *a1, const __int32 *a2, size_t a3)
{
  while (1)
  {
    if (!a3--) {
      return a1;
    }
    __int32 v4 = *a2;
    *a1 = *a2;
    if (!v4) {
      break;
    }
    ++a1;
    ++a2;
  }
  int v7 = a1;
  while (a3--)
    *++a1 = 0;
  return v7;
}

int wcscasecmp_l(const __int32 *a1, const __int32 *a2, locale_t a3)
{
  while (*a1)
  {
    wint_t v5 = towlower_l(*a1, a3);
    wint_t v4 = towlower_l(*a2, a3);
    if (v5 != v4) {
      return v5 - v4;
    }
    ++a1;
    ++a2;
  }
  return -*a2;
}

int wcscasecmp(const __int32 *a1, const __int32 *a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return wcscasecmp_l(a1, a2, v7);
  }
  else {
    return wcscasecmp_l(a1, a2, (locale_t)__global_locale);
  }
}

__int32 *__cdecl wcscat(__int32 *result, const __int32 *a2)
{
  for (int i = result; *i; ++i)
    ;
  do
  {
    char v2 = a2++;
    LODWORD(v2) = *v2;
    char v3 = i++;
    *char v3 = (int)v2;
  }
  while (v2);
  return result;
}

__int32 *__cdecl wcschr(const __int32 *a1, __int32 a2)
{
  while (1)
  {
    BOOL v3 = 0;
    if (*a1 != a2) {
      BOOL v3 = *a1 != 0;
    }
    if (!v3) {
      break;
    }
    ++a1;
  }
  if (*a1 == a2) {
    return (__int32 *)a1;
  }
  else {
    return 0;
  }
}

int wcscmp(const __int32 *a1, const __int32 *a2)
{
  while (1)
  {
    char v2 = a2++;
    if (*a1 != *v2) {
      break;
    }
    BOOL v3 = a1++;
    if (!*v3) {
      return 0;
    }
  }
  return *a1 - *(a2 - 1);
}

int wcscoll_l(const __int32 *a1, const __int32 *a2, locale_t a3)
{
  unsigned int v43 = a1;
  BOOL v42 = a2;
  unsigned int v41 = a3;
  int v40 = 0;
  int v39 = 0;
  int v38 = 0;
  int v37 = 0;
  int v36 = 0;
  int v35 = 0;
  int v34 = 0;
  BOOL v27 = 0;
  BOOL v26 = 0;
  BOOL v25 = 0;
  BOOL v24 = 0;
  if (a3)
  {
    if (v41 == (void *)-1) {
      unsigned int v41 = __global_locale;
    }
  }
  else
  {
    unsigned int v41 = &__c_locale;
  }
  if (*(unsigned char *)(v41[165] + 64)) {
    return wcscmp(v43, v42);
  }
  int v23 = *(unsigned __int8 **)(v41[165] + 88);
  int v38 = 1;
  int v39 = 1;
  int v32 = 0;
  int v33 = 0;
  if ((v23[1] & 6) != 0
    || (v23[2] & 6) != 0
    || !*((_DWORD *)v23 + 13) && (*((int *)v23 + 16) > 0 || *((int *)v23 + 17) > 0))
  {
    for (int i = 0; i < *v23; ++i)
    {
      unsigned __int8 v22 = v23[i + 1];
      if (!i || (*((_DWORD *)v23 + 13) & 1) == 0)
      {
        free(v27);
        BOOL v27 = __collate_substitute(v43, i, (uint64_t)v41);
        free(v26);
        if (v27) {
          char v14 = __collate_substitute(v42, i, (uint64_t)v41);
        }
        else {
          char v14 = 0;
        }
        BOOL v26 = v14;
      }
      if ((v22 & 2) != 0)
      {
        if (v27) {
          BOOL v3 = __collate_wcsdup(v27);
        }
        else {
          BOOL v3 = __collate_wcsdup(v43);
        }
        BOOL v25 = v3;
        char v19 = v3;
        for (int j = &v3[wcslen(v3) - 1]; v19 < j; --j)
        {
          __int32 v15 = *v19;
          wint_t v4 = v19++;
          *wint_t v4 = *j;
          wint_t v5 = j;
          *wint_t v5 = v15;
        }
        if (v26) {
          int v6 = __collate_wcsdup(v26);
        }
        else {
          int v6 = __collate_wcsdup(v42);
        }
        BOOL v24 = v6;
        int v20 = v6;
        for (int k = &v6[wcslen(v6) - 1]; v20 < k; --k)
        {
          __int32 v16 = *v20;
          int v7 = v20++;
          *int v7 = *k;
          uint64_t v8 = k;
          *uint64_t v8 = v16;
        }
        BOOL v30 = v25;
        uint64_t v28 = v24;
      }
      else if (v27)
      {
        BOOL v30 = v27;
        uint64_t v28 = v26;
      }
      else
      {
        BOOL v30 = v43;
        uint64_t v28 = v42;
      }
      if ((v22 & 4) != 0)
      {
        while (1)
        {
          BOOL v13 = 0;
          if (*v30) {
            BOOL v13 = *v28 != 0;
          }
          if (!v13) {
            break;
          }
          int v36 = 0;
          int v37 = 0;
          __collate_lookup_which(v30, &v39, &v37, i, (uint64_t)v41);
          if (v37 <= 0)
          {
            if (v37 < 0) {
              goto LABEL_63;
            }
            int v37 = 0xFFFFFF;
          }
          __collate_lookup_which(v28, &v38, &v36, i, (uint64_t)v41);
          if (v36 <= 0)
          {
            if (v36 < 0) {
              goto LABEL_63;
            }
            int v36 = 0xFFFFFF;
          }
          if (v37 != v36)
          {
            int v33 = v37 - v36;
            goto LABEL_110;
          }
          v30 += v39;
          v28 += v38;
        }
      }
      else
      {
        while (1)
        {
          BOOL v12 = 0;
          if (*v30) {
            BOOL v12 = *v28 != 0;
          }
          if (!v12) {
            break;
          }
          int v36 = 0;
          int v37 = 0;
          while (*v30)
          {
            __collate_lookup_which(v30, &v39, &v37, i, (uint64_t)v41);
            if (v37 > 0) {
              break;
            }
            if (v37 < 0)
            {
LABEL_63:
              *__error() = 22;
              int v33 = -1;
              goto LABEL_110;
            }
            v30 += v39;
          }
          while (*v28)
          {
            __collate_lookup_which(v28, &v38, &v36, i, (uint64_t)v41);
            if (v36 > 0) {
              break;
            }
            if (v36 < 0) {
              goto LABEL_63;
            }
            v28 += v38;
          }
          if (!v37 || !v36) {
            break;
          }
          if (v37 != v36)
          {
            int v33 = v37 - v36;
            goto LABEL_110;
          }
          v30 += v39;
          v28 += v38;
        }
      }
      if (*v30)
      {
        int v33 = *v30;
        goto LABEL_110;
      }
      if (*v28)
      {
        int v33 = -*v28;
        goto LABEL_110;
      }
    }
    int v33 = 0;
  }
  else
  {
    BOOL v27 = __collate_substitute(v43, 0, (uint64_t)v41);
    if (v27)
    {
      BOOL v26 = __collate_substitute(v42, 0, (uint64_t)v41);
      int v31 = v27;
      BOOL v29 = v26;
    }
    else
    {
      BOOL v26 = 0;
      int v31 = v43;
      BOOL v29 = v42;
    }
    while (1)
    {
      BOOL v11 = 0;
      if (*v31) {
        BOOL v11 = *v29 != 0;
      }
      if (!v11) {
        break;
      }
      int v36 = 0;
      int v37 = 0;
      while (*v31)
      {
        __collate_lookup_l(v31, &v39, &v37, &v35, v41);
        if (v37 > 0) {
          break;
        }
        if (v37 < 0)
        {
LABEL_87:
          *__error() = 22;
          int v33 = -1;
          goto LABEL_110;
        }
        v31 += v39;
      }
      while (*v29)
      {
        __collate_lookup_l(v29, &v38, &v36, &v34, v41);
        if (v36 > 0) {
          break;
        }
        if (v36 < 0) {
          goto LABEL_87;
        }
        v29 += v38;
      }
      if (!v37 || !v36) {
        break;
      }
      if (v37 != v36)
      {
        int v33 = v37 - v36;
        goto LABEL_110;
      }
      if (!v32) {
        int v32 = v35 - v34;
      }
      v31 += v39;
      v29 += v38;
    }
    if (*v31 || !*v29)
    {
      if (!*v31 || *v29)
      {
        if (!*v31 && !*v29) {
          int v33 = v32;
        }
      }
      else
      {
        int v33 = *v31;
      }
    }
    else
    {
      int v33 = -*v29;
    }
  }
LABEL_110:
  int v40 = *__error();
  free(v27);
  free(v26);
  free(v25);
  free(v24);
  int v10 = v40;
  *__error() = v10;
  return v33;
}

int wcscoll(const __int32 *a1, const __int32 *a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return wcscoll_l(a1, a2, v7);
  }
  else {
    return wcscoll_l(a1, a2, (locale_t)__global_locale);
  }
}

__int32 *__cdecl wcscpy(__int32 *result, const __int32 *a2)
{
  wint_t v4 = result;
  do
  {
    char v2 = a2++;
    LODWORD(v2) = *v2;
    char v3 = v4++;
    *char v3 = (int)v2;
  }
  while (v2);
  return result;
}

int wordexp(const char *a1, wordexp_t *a2, int a3)
{
  BOOL v13 = (char *)a1;
  BOOL v12 = a2;
  int v11 = a3;
  memset(&v9, 0, sizeof(v9));
  int v10 = we_check((char *)a1, a3);
  if (v10) {
    return v10;
  }
  v9.size_t we_offs = v12->we_offs;
  if (v11)
  {
    if ((v11 & 2) != 0) {
      size_t we_offs = v12->we_offs;
    }
    else {
      size_t we_offs = 0;
    }
    size_t v7 = v12->we_wordc + we_offs;
    uint64_t __src = (const void **)(v12->we_wordv - 2);
    mbstate_t __dst = (char **)malloc_type_malloc();
    if (!__dst) {
      return 4;
    }
    memcpy(__dst, __src, 8 * (v7 + 1) + 16);
    char *__dst = (char *)malloc_type_malloc();
    if (!*__dst)
    {
      free(__dst);
      return 4;
    }
    memcpy(*__dst, *__src, (size_t)__dst[1]);
    for (size_t i = 0; i < v7; ++i)
    {
      if (__dst[i + 2]) {
        __dst[i + 2] += *__dst - (unsigned char *)*__src;
      }
    }
    v9.we_wordc = v12->we_wordc;
    v9.we_wordv = __dst + 2;
  }
  else
  {
    v9.we_wordc = 0;
    v9.we_wordv = 0;
  }
  int v10 = we_askshell(v13, &v9.we_wordc, v11);
  if (v10)
  {
    if (v10 == 4)
    {
      if ((v11 & 8) != 0) {
        wordfree(v12);
      }
      *BOOL v12 = v9;
    }
    else
    {
      wordfree(&v9);
    }
    return v10;
  }
  else
  {
    if ((v11 & 8) != 0) {
      wordfree(v12);
    }
    *BOOL v12 = v9;
    return 0;
  }
}

uint64_t we_check(char *a1, char a2)
{
  int v23 = 0;
  int v19 = 0;
  int v20 = 0;
  while (1)
  {
    char v2 = a1++;
    int v3 = *v2;
    if (!v3) {
      break;
    }
    if ((char)v3 <= 0xA)
    {
      uint64_t v5 = ((char)v3 - 10);
      char v4 = 0;
    }
    else
    {
      uint64_t v5 = ((char)v3 - 10);
      char v4 = 1;
    }
    if ((v4 & 1) == 0)
    {
      switch(v5)
      {
        case 0:
        case 28:
        case 30:
        case 31:
        case 49:
        case 50:
        case 52:
        case 113:
        case 114:
        case 115:
          if (v20 + v19 + v23) {
            break;
          }
          return 1;
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 25:
        case 27:
        case 32:
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 48:
        case 51:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 65:
        case 66:
        case 67:
        case 68:
        case 69:
        case 70:
        case 71:
        case 72:
        case 73:
        case 74:
        case 75:
        case 76:
        case 77:
        case 78:
        case 79:
        case 80:
        case 81:
        case 83:
        case 84:
        case 85:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 97:
        case 98:
        case 99:
        case 100:
        case 101:
        case 102:
        case 103:
        case 104:
        case 105:
        case 106:
        case 107:
        case 108:
        case 109:
        case 110:
        case 111:
        case 112:
          break;
        case 24:
          if (!(v20 + v19)) {
            v23 ^= 1u;
          }
          break;
        case 26:
          wordexp_t v9 = a1++;
          int v10 = *v9;
          if (!v10) {
            break;
          }
          if (v20 + v19 || (char)v10 != 40)
          {
            if (v20 + v19 || (char)v10 != 123)
            {
              --a1;
            }
            else
            {
              int v22 = 1;
              while (1)
              {
                char v14 = a1++;
                int v15 = *v14;
                char v26 = v15;
                if (!v15) {
                  break;
                }
                if ((char)v15 == 92)
                {
                  __int32 v16 = a1++;
                  LODWORD(v16) = *v16;
                  char v26 = (char)v16;
                  if (!v16) {
                    break;
                  }
                }
                else if ((char)v15 == 123)
                {
                  ++v22;
                }
                else if ((char)v15 == 125 && !--v22)
                {
                  break;
                }
              }
              if (!v26 || v22) {
                return 6;
              }
            }
          }
          else
          {
            if ((a2 & 4) != 0 && *a1 != 40) {
              return 3;
            }
            int v21 = 1;
            while (1)
            {
              int v11 = a1++;
              int v12 = *v11;
              char v25 = v12;
              if (!v12) {
                break;
              }
              if ((char)v12 == 92)
              {
                BOOL v13 = a1++;
                LODWORD(v13) = *v13;
                char v25 = (char)v13;
                if (!v13) {
                  break;
                }
              }
              else if ((char)v12 == 40)
              {
                ++v21;
              }
              else if ((char)v12 == 41 && !--v21)
              {
                break;
              }
            }
            if (!v25 || v21) {
              return 6;
            }
          }
          break;
        case 29:
          if (!(v20 + v23)) {
            v19 ^= 1u;
          }
          break;
        case 82:
          if (!v19) {
            v20 ^= 1u;
          }
          continue;
        case 86:
          if (v20 + v19) {
            break;
          }
          if ((a2 & 4) != 0) {
            return 3;
          }
          while (1)
          {
            int v6 = a1++;
            int v7 = *v6;
            char v24 = v7;
            BOOL v18 = 0;
            if (v7) {
              BOOL v18 = (char)v7 != 96;
            }
            if (!v18) {
              break;
            }
            if ((char)v7 == 92)
            {
              uint64_t v8 = a1++;
              LODWORD(v8) = *v8;
              char v24 = (char)v8;
              if (!v8) {
                break;
              }
            }
          }
          if (!v24) {
            return 6;
          }
          break;
        default:
          JUMPOUT(0);
      }
    }
    int v20 = 0;
  }
  if (v20 + v19 + v23) {
    return 6;
  }
  else {
    return 0;
  }
}

uint64_t we_askshell(char *a1, unint64_t *a2, int a3)
{
  __s = a1;
  int v51 = a2;
  int v50 = a3;
  uint64_t v49 = 0;
  __signed int n = 0;
  unint64_t i = 0;
  uint64_t v46 = 0;
  unint64_t v45 = 0;
  pid_t v44 = 0;
  int v43 = 0;
  int v42 = 0;
  unsigned int v41 = 0;
  int v40 = 0;
  int v39 = 0;
  int j = 0;
  uint64_t v37 = 0;
  int v36 = 0;
  int v35 = 0;
  posix_spawn_file_actions_t v34 = 0;
  posix_spawnattr_t v33 = 0;
  sigset_t v32 = 0;
  sigset_t v31 = 0;
  int v40 = *__error();
  if (pipe(v61) < 0) {
    return 4;
  }
  if (pipe(v58) < 0)
  {
    close_NOCANCEL();
    close_NOCANCEL();
    return 4;
  }
  int v54 = 20;
  sigset_t v32 = 0x80000;
  sigprocmask(1, &v32, &v31);
  int v35 = posix_spawnattr_init(&v33);
  if (v35)
  {
LABEL_27:
    close_NOCANCEL();
    close_NOCANCEL();
    close_NOCANCEL();
    close_NOCANCEL();
    int v21 = v35;
    *__error() = v21;
    return 4;
  }
  sigset_t v30 = 0;
  int v35 = posix_spawnattr_setflags(&v33, 0x4000);
  if (!v35)
  {
    sigset_t v30 = -1;
    int v35 = posix_spawnattr_setsigdefault(&v33, &v30);
    if (!v35)
    {
      sigset_t v30 = 0;
      int v35 = posix_spawnattr_setsigmask(&v33, &v30);
      if (!v35)
      {
        int v35 = posix_spawn_file_actions_init(&v34);
        if (!v35)
        {
          memcpy(__dst, &off_DCB08, sizeof(__dst));
          strcpy(__src, "[ $# -gt 0 ] && export IFS=\"$1\";/usr/lib/system/wordexp-helper ");
          int v26 = 1;
          if (v61[1] == 1)
          {
            int v35 = posix_spawn_file_actions_addinherit_np(&v34, 1);
            if (v35) {
              goto LABEL_25;
            }
          }
          else
          {
            int v35 = posix_spawn_file_actions_adddup2(&v34, v61[1], 1);
            if (v35) {
              goto LABEL_25;
            }
          }
          if (v58[1] == 2)
          {
            int v35 = posix_spawn_file_actions_addinherit_np(&v34, 2);
            if (!v35) {
              goto LABEL_18;
            }
          }
          else
          {
            int v35 = posix_spawn_file_actions_adddup2(&v34, v58[1], 2);
            if (!v35)
            {
LABEL_18:
              if ((v50 & 0x20) != 0)
              {
                int v26 = 2;
                __dst[1] = "-u";
              }
              uint64_t v3 = v26;
              int v27 = v26 + 1;
              __dst[v3] = "-c";
              strlen(__s);
              __s1 = (char *)malloc_type_malloc();
              if (__s1)
              {
                strcpy(__s1, __src);
                strcat(__s1, __s);
                uint64_t v4 = v27;
                int v28 = v27 + 1;
                __dst[v4] = __s1;
                char v24 = getenv("IFS");
                if (v24)
                {
                  uint64_t v5 = v28;
                  int v29 = v28 + 1;
                  __dst[v5] = "--";
                  uint64_t v6 = v29;
                  int v28 = v29 + 1;
                  __dst[v6] = v24;
                }
                __dst[v28] = 0;
                int v7 = _NSGetEnviron();
                int v35 = posix_spawn(&v44, "/bin/sh", &v34, &v33, __dst, *v7);
                free(__s1);
              }
              else
              {
                int v35 = *__error();
              }
            }
          }
LABEL_25:
          posix_spawn_file_actions_destroy(&v34);
        }
      }
    }
  }
  posix_spawnattr_destroy(&v33);
  if (v35) {
    goto LABEL_27;
  }
  close_NOCANCEL();
  close_NOCANCEL();
  if (we_read_fully(v61[0], (uint64_t)__str, 8) == 8
    && we_read_fully(v61[0], (uint64_t)v60, 8) == 8)
  {
    v60[8] = 0;
    __str[8] = 0;
    uint64_t v49 = strtol(__str, 0, 16);
    uint64_t v9 = strtol(v60, 0, 16);
    __signed int n = v9 + v49;
    unint64_t v45 = *v51;
    if ((v50 & 3) == 3) {
      v45 += v51[2];
    }
    *v51 += v49;
    int v36 = (void *)malloc_type_realloc();
    if (!v36)
    {
      unsigned int v41 = 4;
      goto LABEL_58;
    }
    if (!v51[1])
    {
      *int v36 = 0;
      v36[1] = 0;
    }
    uint64_t v46 = v36[1];
    v36[1] += __n;
    v51[1] = (unint64_t)(v36 + 2);
    uint64_t v37 = malloc_type_realloc();
    if (!v37)
    {
      unsigned int v41 = 4;
      goto LABEL_58;
    }
    for (unint64_t i = 0; i < v45; ++i)
    {
      if (*(void *)(v51[1] + 8 * i)) {
        *(void *)(v51[1] + 8 * i) += v37 - *v36;
      }
    }
    *int v36 = v37;
    uint64_t fully = we_read_fully(v61[0], *v36 + v46, __n);
    if (fully == __n)
    {
      uint64_t NOCANCEL = read_NOCANCEL();
      if (NOCANCEL <= 0)
      {
        if (NOCANCEL < 0)
        {
          int v40 = *__error();
          unsigned int v41 = 4;
          goto LABEL_58;
        }
      }
      else
      {
        __big[NOCANCEL] = 0;
        if ((v50 & 0x10) != 0) {
          fputs(__big, __stderrp);
        }
      }
      unsigned int v41 = 0;
      goto LABEL_58;
    }
    if ((v50 & 0x20) != 0) {
      int v8 = 2;
    }
    else {
      int v8 = 6;
    }
  }
  else if ((v50 & 0x20) != 0)
  {
    int v8 = 2;
  }
  else
  {
    int v8 = 6;
  }
  unsigned int v41 = v8;
  int v40 = *__error();
LABEL_58:
  close_NOCANCEL();
  close_NOCANCEL();
  do
  {
    int v43 = waitpid_NOCANCEL(v44, (uint64_t)&v42, 0);
    BOOL v20 = 0;
    if (v43 < 0) {
      BOOL v20 = *__error() == 4;
    }
  }
  while (v20);
  sigprocmask(3, &v31, 0);
  if (v41)
  {
    int v19 = v40;
    *__error() = v19;
    return v41;
  }
  else if (v43 < 0 || (v42 & 0x7F) != 0 || BYTE1(v42))
  {
    if ((v50 & 0x20) != 0) {
      return 2;
    }
    else {
      return 6;
    }
  }
  else
  {
    int v22 = strstr(__big, "command substitution");
    if (v22 && strstr(v22 + 20, "syntax error"))
    {
      if (strstr(__big, " unbound variable")) {
        return 2;
      }
      else {
        return 6;
      }
    }
    else
    {
      if (!v45 && (v50 & 2) != 0)
      {
        while (v45 < v51[2])
        {
          unint64_t v13 = v51[1];
          uint64_t v14 = v45++;
          *(void *)(v13 + 8 * v14) = 0;
        }
      }
      for (int j = (void *)(*v36 + v46); v49--; int j = v39 + 1)
      {
        unint64_t v16 = v51[1];
        uint64_t v17 = v45++;
        *(void *)(v16 + 8 * v17) = j;
        int v39 = (char *)memchr(j, 0, __n);
        if (!v39) {
          return 4;
        }
        __n -= v39 - (unsigned char *)j + 1;
      }
      *(void *)(v51[1] + 8 * v45) = 0;
      return 0;
    }
  }
}

void wordfree(wordexp_t *a1)
{
  if (a1)
  {
    if (a1->we_wordv)
    {
      free(*((void **)a1->we_wordv - 2));
      free(a1->we_wordv - 2);
    }
    a1->we_wordv = 0;
    a1->we_wordc = 0;
  }
}

uint64_t we_read_fully(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = 0;
  do
  {
    uint64_t NOCANCEL = read_NOCANCEL();
    if (NOCANCEL != -1 || *__error() != 4)
    {
      if (NOCANCEL <= 0) {
        return v5;
      }
      v5 += NOCANCEL;
    }
  }
  while (v5 != a3);
  return v5;
}

size_t wcscspn(const __int32 *a1, const __int32 *a2)
{
  for (unint64_t i = a1; *i; ++i)
  {
    for (int j = a2; *j; ++j)
    {
      if (*i == *j) {
        return i - a1;
      }
    }
  }
  return i - a1;
}

__int32 *__cdecl wcsdup(const __int32 *a1)
{
  size_t v2 = wcslen(a1) + 1;
  uint64_t v3 = (__int32 *)malloc_type_malloc();
  if (v3) {
    return wmemcpy(v3, a1, v2);
  }
  else {
    return 0;
  }
}

size_t wcslcat(__int32 *a1, const __int32 *a2, size_t a3)
{
  int v11 = a1;
  int v10 = (__int32 *)a2;
  size_t v8 = a3;
  while (1)
  {
    BOOL v6 = 0;
    if (*v11)
    {
      size_t v3 = v8--;
      BOOL v6 = v3 != 0;
    }
    if (!v6) {
      break;
    }
    ++v11;
  }
  uint64_t v7 = v11 - a1;
  size_t v9 = a3 - v7;
  if (a3 == v7) {
    return v7 + wcslen(a2);
  }
  while (*v10)
  {
    if (v9 != 1)
    {
      uint64_t v4 = v11++;
      *uint64_t v4 = *v10;
      --v9;
    }
    ++v10;
  }
  *int v11 = 0;
  return v7 + v10 - a2;
}

size_t wcslcpy(__int32 *a1, const __int32 *a2, size_t a3)
{
  size_t v8 = a2;
  size_t v7 = a3;
  if (a3)
  {
    size_t v7 = a3 - 1;
    if (a3 != 1)
    {
      do
      {
        size_t v3 = v8++;
        LODWORD(v3) = *v3;
        uint64_t v4 = a1++;
        *uint64_t v4 = (int)v3;
        if (!v3) {
          break;
        }
        --v7;
      }
      while (v7);
    }
  }
  if (!v7)
  {
    if (a3) {
      *a1 = 0;
    }
    do
      uint64_t v5 = v8++;
    while (*v5);
  }
  return v8 - a2 - 1;
}

size_t wcslen(const __int32 *a1)
{
  for (unint64_t i = a1; *i; ++i)
    ;
  return i - a1;
}

int wcsncasecmp_l(const __int32 *a1, const __int32 *a2, size_t n, locale_t a4)
{
  size_t v8 = n;
  if (!n) {
    return 0;
  }
  while (*a1)
  {
    wint_t v6 = towlower_l(*a1, a4);
    wint_t v5 = towlower_l(*a2, a4);
    if (v6 != v5) {
      return v6 - v5;
    }
    if (!--v8) {
      return 0;
    }
    ++a1;
    ++a2;
  }
  return -*a2;
}

int wcsncasecmp(const __int32 *a1, const __int32 *a2, size_t n)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    size_t v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    size_t v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcsncasecmp_l(a1, a2, n, v9);
  }
  else {
    return wcsncasecmp_l(a1, a2, n, (locale_t)__global_locale);
  }
}

__int32 *__cdecl wcsncat(__int32 *result, const __int32 *a2, size_t a3)
{
  for (unint64_t i = result; *i; ++i)
    ;
  for (int j = i; ; ++j)
  {
    BOOL v5 = 0;
    if (*a2) {
      BOOL v5 = a3 != 0;
    }
    if (!v5) {
      break;
    }
    char v3 = a2++;
    char v4 = j;
    *char v4 = *v3;
    --a3;
  }
  __int32 *j = 0;
  return result;
}

int wcsncmp(const __int32 *a1, const __int32 *a2, size_t a3)
{
  size_t v6 = a3;
  if (!a3) {
    return 0;
  }
  do
  {
    char v3 = a2++;
    if (*a1 != *v3) {
      return *a1 - *(a2 - 1);
    }
    char v4 = a1++;
    if (!*v4) {
      break;
    }
    --v6;
  }
  while (v6);
  return 0;
}

__int32 *__cdecl wcsncpy(__int32 *result, const __int32 *a2, size_t a3)
{
  size_t v8 = a3;
  if (a3)
  {
    size_t v7 = result;
    while (1)
    {
      char v3 = a2++;
      LODWORD(v3) = *v3;
      char v4 = v7++;
      *char v4 = (int)v3;
      if (!v3) {
        break;
      }
      if (!--v8) {
        return result;
      }
    }
    while (--v8)
    {
      BOOL v5 = v7++;
      *BOOL v5 = 0;
    }
  }
  return result;
}

size_t wcsnlen(const __int32 *a1, size_t a2)
{
  for (size_t i = 0; i < a2 && *a1; ++i)
    ++a1;
  return i;
}

__int32 *__cdecl wcspbrk(const __int32 *a1, const __int32 *a2)
{
  while (*a1)
  {
    for (size_t i = a2; *i; ++i)
    {
      if (*a1 == *i) {
        return (__int32 *)a1;
      }
    }
    ++a1;
  }
  return 0;
}

__int32 *__cdecl wcsrchr(const __int32 *a1, __int32 a2)
{
  char v3 = 0;
  while (1)
  {
    if (*a1 == a2) {
      char v3 = (__int32 *)a1;
    }
    if (!*a1) {
      break;
    }
    ++a1;
  }
  return v3;
}

size_t wcsspn(const __int32 *a1, const __int32 *a2)
{
  for (size_t i = a1; *i; ++i)
  {
    for (int j = a2; *j && *i != *j; ++j)
      ;
    if (!*j) {
      break;
    }
  }
  return i - a1;
}

FILE *__cdecl fmemopen(void *__buf, size_t __size, const char *__mode)
{
  uint64_t v14 = __buf;
  size_t v13 = __size;
  int v12 = (char *)__mode;
  int v11 = 0;
  uint64_t v10 = 0;
  int v9 = 0;
  if (!__size)
  {
    *__error() = 22;
    return 0;
  }
  if (!__sflags(v12, &v9) || (v9 & 2) == 0 && !v14)
  {
    *__error() = 22;
    return 0;
  }
  int v11 = (void *)malloc_type_malloc();
  if (!v11) {
    return 0;
  }
  v11[4] = 0;
  v11[2] = v13;
  char v3 = v14;
  *int v11 = v14;
  *((unsigned char *)v11 + 8) = v3 == 0;
  if (v11[1])
  {
    *int v11 = malloc_type_malloc();
    if (!*v11)
    {
LABEL_11:
      free(v11);
      return 0;
    }
  }
  if ((v11[1] & 1) != 0 || *v12 == 119) {
    *(unsigned char *)*int v11 = 0;
  }
  BOOL v4 = strchr(v12, 98) != 0;
  *((unsigned char *)v11 + 9) = v4;
  int v8 = *v12;
  switch(v8)
  {
    case 'a':
      size_t v5 = strnlen((const char *)*v11, v11[2]);
      v11[3] = v5;
      v11[4] = v5;
      break;
    case 'r':
      v11[3] = v13;
      break;
    case 'w':
      v11[3] = 0;
      break;
  }
  if (v9) {
    size_t v6 = 0;
  }
  else {
    size_t v6 = (int (__cdecl *)(void *, char *, int))fmemopen_read;
  }
  uint64_t v10 = funopen(v11, v6, (int (__cdecl *)(void *, const char *, int))fmemopen_write, (fpos_t (__cdecl *)(void *, fpos_t, int))fmemopen_seek, (int (__cdecl *)(void *))fmemopen_close);
  if (!v10)
  {
    if (v11[1]) {
      free((void *)*v11);
    }
    goto LABEL_11;
  }
  if (*v12 == 97) {
    v10->_flags |= 0x100u;
  }
  setvbuf(v10, 0, 2, 0);
  return v10;
}

uint64_t fmemopen_read(void *a1, void *a2, unsigned int a3)
{
  __signed int n = a3;
  if ((unint64_t)(int)a3 > a1[3] - a1[4]) {
    __signed int n = a1[3] - a1[4];
  }
  if (__n)
  {
    memcpy(a2, (const void *)(*a1 + a1[4]), (int)__n);
    a1[4] += (int)__n;
    return __n;
  }
  else
  {
    return 0;
  }
}

uint64_t fmemopen_write(uint64_t a1, const void *a2, unsigned int a3)
{
  __signed int n = a3;
  if ((unint64_t)(int)a3 > *(void *)(a1 + 16) - *(void *)(a1 + 32)) {
    __signed int n = *(void *)(a1 + 16) - *(void *)(a1 + 32);
  }
  if (__n)
  {
    memcpy((void *)(*(void *)a1 + *(void *)(a1 + 32)), a2, (int)__n);
    *(void *)(a1 + 32) += (int)__n;
    if (*(void *)(a1 + 32) > *(void *)(a1 + 24)) {
      *(void *)(a1 + 24) = *(void *)(a1 + 32);
    }
    if (!*(unsigned char *)(a1 + 9)
      && *(void *)(a1 + 32) < *(void *)(a1 + 16)
      && *(unsigned char *)(*(void *)a1 + *(void *)(a1 + 32) - 1))
    {
      *(unsigned char *)(*(void *)a1 + *(void *)(a1 + 32)) = 0;
    }
    return __n;
  }
  else
  {
    return 0;
  }
}

uint64_t fmemopen_seek(void *a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (a3 != 1)
    {
      if (a3 != 2 || a2 > 0 || (unint64_t)-a2 > a1[3]) {
        goto LABEL_4;
      }
      a1[4] = a1[3] + a2;
      return a1[4];
    }
    if ((unint64_t)(a1[4] + a2) <= a1[2])
    {
      a1[4] += a2;
      return a1[4];
    }
  }
  else if ((unint64_t)a2 <= a1[2])
  {
    a1[4] = a2;
    return a1[4];
  }
LABEL_4:
  *__error() = 22;
  return -1;
}

uint64_t fmemopen_close(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 8)) {
    free(*(void **)a1);
  }
  free((void *)a1);
  return 0;
}

__int32 *__cdecl wcsstr(const __int32 *a1, const __int32 *a2)
{
  size_t v6 = (__int32 *)(a2 + 1);
  __int32 v5 = *a2;
  if (*a2)
  {
    size_t v4 = wcslen(v6);
    do
    {
      size_t v2 = a1++;
      if (!*v2) {
        return 0;
      }
    }
    while (*v2 != v5 || wcsncmp(a1, v6, v4));
    --a1;
  }
  return (__int32 *)a1;
}

__int32 *__cdecl wcstok(__int32 *a1, const __int32 *a2, __int32 **a3)
{
  size_t v13 = a1;
  if (!a1)
  {
    size_t v13 = *a3;
    if (!*a3) {
      return 0;
    }
  }
LABEL_4:
  char v3 = v13++;
  __int32 v8 = *v3;
  int v11 = a2;
  while (1)
  {
    size_t v4 = v11++;
    if (!*v4) {
      break;
    }
    if (v8 == *v4) {
      goto LABEL_4;
    }
  }
  if (v8)
  {
    uint64_t v10 = v13 - 1;
LABEL_11:
    __int32 v5 = v13++;
    __int32 v9 = *v5;
    int v12 = a2;
    while (1)
    {
      size_t v6 = v12++;
      if (*v6 == v9) {
        break;
      }
      if (!*v6) {
        goto LABEL_11;
      }
    }
    if (v9) {
      *(v13 - 1) = 0;
    }
    else {
      size_t v13 = 0;
    }
    *a3 = v13;
    return v10;
  }
  else
  {
    *a3 = 0;
    return 0;
  }
}

int wcswidth_l(const __int32 *a1, size_t a2, locale_t a3)
{
  uint64_t v10 = a3;
  __int32 v9 = 0;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      uint64_t v10 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    uint64_t v10 = (_xlocale *)__c_locale;
  }
  for (int i = 0; ; i += v7)
  {
    size_t v3 = a2--;
    BOOL v6 = 0;
    if (v3)
    {
      size_t v4 = (__int32 *)a1++;
      __int32 v9 = *v4;
      BOOL v6 = *v4 != 0;
    }
    if (!v6) {
      break;
    }
    int v7 = wcwidth_l(v9, v10);
    if (v7 < 0) {
      return -1;
    }
  }
  return i;
}

int wcswidth(const __int32 *a1, size_t a2)
{
  if (v2) {
    char v3 = 1;
  }
  else {
    char v3 = 0;
  }
  if (v3)
  {
    int v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v8 = __locale_key;
    int v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7) {
    return wcswidth_l(a1, a2, v7);
  }
  else {
    return wcswidth_l(a1, a2, (locale_t)__global_locale);
  }
}

size_t wcsxfrm_l(__int32 *a1, const __int32 *a2, size_t a3, locale_t a4)
{
  memset(__b, 0, sizeof(__b));
  if (*a2)
  {
    if (a4)
    {
      if (a4 == (locale_t)-1) {
        a4 = (locale_t)__global_locale;
      }
    }
    else
    {
      a4 = (locale_t)__c_locale;
    }
    if (*(unsigned char *)(*((void *)a4 + 165) + 64))
    {
      size_t v13 = wcslen(a2);
      if (a3)
      {
        if (v13 >= a3)
        {
          wcsncpy(a1, a2, a3 - 1);
          a1[a3 - 1] = 0;
        }
        else
        {
          wcscpy(a1, a2);
        }
      }
      return v13;
    }
    else
    {
      __collate_xfrm(a2, (uint64_t)__b, (uint64_t)a4);
      size_t v14 = wcslen(__b[0]);
      if (__b[1]) {
        v14 += wcslen(__b[1]) + 1;
      }
      if (a3)
      {
        uint64_t v10 = __b[0];
        while (a3 > 1 && *v10)
        {
          size_t v4 = v10++;
          __int32 v5 = a1++;
          *__int32 v5 = *v4 + 1;
          --a3;
        }
        int v11 = __b[1];
        if (__b[1])
        {
          if (a3 > 1)
          {
            BOOL v6 = a1++;
            *BOOL v6 = 1;
          }
          while (a3 > 1 && *v11)
          {
            int v7 = v11++;
            uint64_t v8 = a1++;
            *uint64_t v8 = *v7 + 1;
            --a3;
          }
        }
        *a1 = 0;
      }
      int v12 = *__error();
      free((void *)__b[0]);
      free((void *)__b[1]);
      *__error() = v12;
      return v14;
    }
  }
  else
  {
    if (a3) {
      *a1 = 0;
    }
    return 0;
  }
}

size_t wcsxfrm(__int32 *a1, const __int32 *a2, size_t a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    __int32 v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    __int32 v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return wcsxfrm_l(a1, a2, a3, v9);
  }
  else {
    return wcsxfrm_l(a1, a2, a3, (locale_t)__global_locale);
  }
}

__int32 *__cdecl wmemchr(const __int32 *a1, __int32 a2, size_t a3)
{
  for (size_t i = 0; i < a3; ++i)
  {
    if (*a1 == a2) {
      return (__int32 *)a1;
    }
    ++a1;
  }
  return 0;
}

int wmemcmp(const __int32 *a1, const __int32 *a2, size_t a3)
{
  for (size_t i = 0; ; ++i)
  {
    if (i >= a3) {
      return 0;
    }
    if (*a1 != *a2) {
      break;
    }
    ++a1;
    ++a2;
  }
  if (*a1 > *a2) {
    return 1;
  }
  else {
    return -1;
  }
}

__int32 *__cdecl wmemcpy(__int32 *a1, const __int32 *a2, size_t a3)
{
  return a1;
}

__int32 *__cdecl wmemmove(__int32 *a1, const __int32 *a2, size_t a3)
{
  return a1;
}

__int32 *__cdecl wmemset(__int32 *result, __int32 a2, size_t a3)
{
  char v3 = result;
  for (size_t i = 0; i < a3; ++i)
    *v3++ = a2;
  return result;
}

const char *regatoi(uint64_t a1, char *a2)
{
  for (size_t i = (const char **)&rerrs; *(_DWORD *)i && strcmp(i[1], *(const char **)(a1 + 16)); i += 3)
    ;
  if (!*(_DWORD *)i) {
    return "0";
  }
  sprintf(a2, "%d", *(_DWORD *)i);
  return a2;
}

uint64_t _UTF2_init(uint64_t a1)
{
  *(void *)(a1 + 72) = _UTF2_mbrtowc;
  *(void *)(a1 + 96) = _UTF2_wcrtomb;
  *(void *)(a1 + 80) = _UTF2_mbsinit;
  *(void *)(a1 + 88) = _UTF2_mbsnrtowcs;
  *(void *)(a1 + 104) = _UTF2_wcsnrtombs;
  *(_DWORD *)(a1 + 64) = 3;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _UTF2_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4)
{
  uint64_t v17 = a2;
  char v12 = 0;
  if (a4[1] > 6)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    uint64_t v17 = (unsigned __int8 *)&unk_D793D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3) {
    return -2;
  }
  if (!a4[1])
  {
    int v14 = *v17;
    if ((v14 & 0xFFFFFF80) == 0)
    {
      if (a1) {
        *a1 = v14;
      }
      return v14 != 0;
    }
  }
  if (a4[1])
  {
    int v11 = a4[1];
    int v10 = a4[2];
  }
  else
  {
    char v15 = *v17;
    if ((*v17 & 0x80u) != 0)
    {
      if ((v15 & 0xE0) == 0xC0)
      {
        char v12 = 31;
        int v11 = 2;
        int v10 = 128;
      }
      else
      {
        if ((v15 & 0xF0) != 0xE0) {
          goto LABEL_34;
        }
        char v12 = 15;
        int v11 = 3;
        int v10 = 2048;
      }
    }
    else
    {
      char v12 = 127;
      int v11 = 1;
      int v10 = 0;
    }
  }
  if (a4[1])
  {
    int v9 = *a4;
  }
  else
  {
    char v4 = v17++;
    int v9 = (*v4 & v12);
  }
  for (int i = a4[1] == 0; ; ++i)
  {
    unint64_t v8 = v11 >= a3 ? a3 : v11;
    if (i >= v8) {
      break;
    }
    if ((*v17 & 0xC0) != 0x80) {
      goto LABEL_34;
    }
    __int32 v5 = v17++;
    int v9 = (v9 << 6) | *v5 & 0x3F;
  }
  if (i < v11)
  {
    a4[1] = v11 - i;
    a4[2] = v10;
    *a4 = v9;
    return -2;
  }
  if (v9 < v10)
  {
LABEL_34:
    *__error() = 92;
    return -1;
  }
  if (a1) {
    *a1 = v9;
  }
  a4[1] = 0;
  if (v9) {
    return v11;
  }
  else {
    return 0;
  }
}

uint64_t _UTF2_wcrtomb(unsigned char *a1, int a2, uint64_t a3)
{
  int v7 = a2;
  if (*(_DWORD *)(a3 + 4))
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if ((a2 & 0xFFFFFF80) != 0)
    {
      if ((a2 & 0xFFFFF800) != 0)
      {
        if ((a2 & 0xFFFF0000) != 0)
        {
          *__error() = 92;
          return -1;
        }
        char v6 = -32;
        int v4 = 3;
      }
      else
      {
        char v6 = -64;
        int v4 = 2;
      }
      for (int i = v4 - 1; i > 0; --i)
      {
        a1[i] = v7 & 0x3F | 0x80;
        v7 >>= 6;
      }
      *a1 = v7 | v6;
      return v4;
    }
    else
    {
      *a1 = a2;
      return 1;
    }
  }
  else
  {
    return 1;
  }
}

BOOL _UTF2_mbsinit(uint64_t a1)
{
  BOOL v2 = 1;
  if (a1) {
    return *(_DWORD *)(a1 + 4) == 0;
  }
  return v2;
}

uint64_t _UTF2_mbsnrtowcs(int *a1, unsigned __int8 **a2, unint64_t a3, uint64_t a4, int *a5, uint64_t a6)
{
  int v19 = a1;
  BOOL v18 = a2;
  unint64_t v17 = a3;
  uint64_t v16 = a4;
  char v15 = a5;
  uint64_t v14 = a6;
  char v12 = 0;
  uint64_t v11 = 0;
  int v10 = 0;
  size_t v13 = a5;
  char v12 = *a2;
  uint64_t v11 = 0;
  if (a1)
  {
    if (!v17 || !v16 || v13[1] <= 0 || (char)*v12 <= 0)
    {
      while (1)
      {
        if (!v16--)
        {
          *BOOL v18 = v12;
          return v11;
        }
        if (v17 && (char)*v12 > 0)
        {
          *int v19 = (char)*v12;
          uint64_t v9 = 1;
        }
        else
        {
          uint64_t v9 = _UTF2_mbrtowc(v19, v12, v17, v15);
          switch(v9)
          {
            case -1:
              *BOOL v18 = v12;
              return -1;
            case -2:
              *BOOL v18 = &v12[v17];
              return v11;
            case 0:
              *BOOL v18 = 0;
              return v11;
          }
        }
        v12 += v9;
        v17 -= v9;
        ++v11;
        ++v19;
      }
    }
  }
  else if (!v17 || v13[1] <= 0 || (char)*v12 <= 0)
  {
    while (1)
    {
      if (v17 && (char)*v12 > 0)
      {
        uint64_t v8 = 1;
      }
      else
      {
        uint64_t v8 = _UTF2_mbrtowc(&v10, v12, v17, v15);
        if (v8 == -1) {
          return -1;
        }
        if (!v8 || v8 == -2) {
          return v11;
        }
      }
      v12 += v8;
      v17 -= v8;
      ++v11;
    }
  }
  *__error() = 92;
  return -1;
}

uint64_t _UTF2_wcsnrtombs(char *a1, int **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  int v21 = a1;
  BOOL v20 = a2;
  uint64_t v19 = a3;
  unint64_t v18 = a4;
  uint64_t v17 = a5;
  uint64_t v16 = a6;
  uint64_t v15 = a5;
  if (*(_DWORD *)(a5 + 4))
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    size_t v13 = *v20;
    uint64_t v12 = 0;
    if (v21)
    {
      while (1)
      {
        BOOL v9 = 0;
        if (v18)
        {
          uint64_t v7 = v19--;
          BOOL v9 = v7 != 0;
        }
        if (!v9) {
          break;
        }
        if (*v13 >= 0x80)
        {
          if (v18 <= 3)
          {
            unint64_t __na = _UTF2_wcrtomb(__src, *v13, v17);
            if (__na == -1)
            {
              __int32 *v20 = v13;
              return -1;
            }
            if (__na > (int)v18) {
              break;
            }
            memcpy(v21, __src, __na);
          }
          else
          {
            unint64_t __na = _UTF2_wcrtomb(v21, *v13, v17);
            if (__na == -1)
            {
              __int32 *v20 = v13;
              return -1;
            }
          }
        }
        else
        {
          unint64_t __na = 1;
          *int v21 = *v13;
        }
        if (!*v13)
        {
          __int32 *v20 = 0;
          return v12 + __na - 1;
        }
        ++v13;
        v21 += __na;
        v18 -= __na;
        v12 += __na;
      }
      __int32 *v20 = v13;
      return v12;
    }
    else
    {
      while (v19--)
      {
        if (*v13 >= 0x80)
        {
          __signed int n = _UTF2_wcrtomb(__src, *v13, v17);
          if (__n == -1) {
            return -1;
          }
        }
        else
        {
          __signed int n = 1;
        }
        if (!*v13) {
          return v12 + __n - 1;
        }
        ++v13;
        v12 += __n;
      }
      return v12;
    }
  }
}

void __guard_setup(const char **a1)
{
  while (1)
  {
    BOOL v2 = 0;
    if (a1) {
      BOOL v2 = *a1 != 0;
    }
    if (!v2) {
      break;
    }
    if (strstr(*a1, "stack_guard") == *a1)
    {
      __guard_from_kernel(*a1);
      size_t v1 = strlen(*a1);
      bzero((void *)*a1, v1);
    }
    ++a1;
  }
  if (open_NOCANCEL() != -1)
  {
    read_NOCANCEL();
    close_NOCANCEL();
  }
  LODWORD(__stack_chk_guard[0]) = -16121856;
}

char *__guard_from_kernel(const char *a1)
{
  unint64_t v6 = 0;
  int v3 = 0;
  uint64_t result = strchr(a1, 61);
  uint64_t v7 = result;
  if (result)
  {
    ++v7;
    while (1)
    {
      BOOL v2 = 0;
      if (v7) {
        BOOL v2 = v3 < 8;
      }
      if (!v2) {
        break;
      }
      strlcpy(__dst, v7, 0x14uLL);
      int v4 = strchr(__dst, 44);
      if (v4) {
        *int v4 = 0;
      }
      unint64_t v6 = strtoull(__dst, 0, 0);
      __stack_chk_guard[v3++] = v6;
      uint64_t result = strchr(v7, 44);
      uint64_t v7 = result;
      if (result) {
        ++v7;
      }
    }
  }
  return result;
}

uint64_t a64l(const char *a1)
{
  uint64_t v7 = a1;
  if (a1)
  {
    int v6 = 0;
    int v4 = 0;
    for (int i = 0; ; ++i)
    {
      BOOL v2 = 0;
      if (*v7) {
        BOOL v2 = i < 6;
      }
      if (!v2) {
        break;
      }
      if (*v7 < 46 || *v7 > 47)
      {
        if (*v7 < 48 || *v7 > 57)
        {
          if (*v7 < 65 || *v7 > 90)
          {
            if (*v7 < 97 || *v7 > 122) {
              goto LABEL_2;
            }
            int v5 = *v7 - 59;
          }
          else
          {
            int v5 = *v7 - 53;
          }
        }
        else
        {
          int v5 = *v7 - 46;
        }
      }
      else
      {
        int v5 = *v7 - 46;
      }
      v6 |= v5 << v4;
      v4 += 6;
      ++v7;
    }
    return v6;
  }
  else
  {
LABEL_2:
    *__error() = 22;
    return -1;
  }
}

void _Exit(int a1)
{
}

long double abs(long double __x)
{
  return __x;
}

void __atexit_init()
{
  if (*((void *)&_os_alloc_once_table + 4) == -1) {
    uint64_t v0 = *((void *)&_os_alloc_once_table + 5);
  }
  else {
    uint64_t v0 = _os_alloc_once();
  }
  __atexit = v0;
}

int atexit(void (*a1)(void))
{
  int v3 = a1;
  *(void *)&v2[0] = 1;
  *((void *)&v2[0] + 1) = a1;
  v2[1] = 0uLL;
  return atexit_register(v2);
}

uint64_t atexit_register(_OWORD *a1)
{
  int v5 = (int *)__atexit;
  if (!__atexit) {
    __assert_rtn("atexit_register", "atexit.c", 115, "p");
  }
  pthread_mutex_lock(&atexit_mutex);
  while (v5[2] >= 32)
  {
    uint64_t v4 = __atexit;
    pthread_mutex_unlock(&atexit_mutex);
    int v5 = (int *)malloc_type_malloc();
    if (!v5) {
      return -1;
    }
    pthread_mutex_lock(&atexit_mutex);
    if (v4 == __atexit)
    {
      _DWORD v5[2] = 0;
      *(void *)int v5 = __atexit;
      __atexit = (uint64_t)v5;
    }
    else
    {
      pthread_mutex_unlock(&atexit_mutex);
      free(v5);
      pthread_mutex_lock(&atexit_mutex);
      int v5 = (int *)__atexit;
    }
  }
  uint64_t v1 = v5[2]++;
  BOOL v2 = &v5[8 * v1 + 4];
  *(_OWORD *)BOOL v2 = *a1;
  *((_OWORD *)v2 + 1) = a1[1];
  __atexit_new_registratiosigned int n = 1;
  pthread_mutex_unlock(&atexit_mutex);
  return 0;
}

int atexit_b(void *a1)
{
  uint64_t v4 = a1;
  long long v2 = 0u;
  long long v3 = 0u;
  LODWORD(v2) = 3;
  *((void *)&v2 + 1) = _Block_copy(a1);
  long long v3 = 0uLL;
  return atexit_register(&v2);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  BOOL v9 = lpfunc;
  uint64_t v8 = obj;
  uint64_t v7 = lpdso_handle;
  *(void *)&long long v4 = 2;
  *((void *)&v4 + 1) = lpfunc;
  int v5 = obj;
  int v6 = lpdso_handle;
  return atexit_register(&v4);
}

uint64_t __cxa_finalize_ranges(uint64_t a1, unsigned int a2)
{
  pthread_mutex_lock(&atexit_mutex);
LABEL_2:
  uint64_t v10 = __atexit;
LABEL_3:
  if (v10)
  {
    int v8 = *(_DWORD *)(v10 + 8);
    while (1)
    {
      do
      {
        if (--v8 < 0)
        {
          uint64_t v10 = *(void *)v10;
          goto LABEL_3;
        }
        uint64_t v9 = v10 + 16 + 32 * v8;
      }
      while (!*(_DWORD *)v9);
      if (a2)
      {
        switch(*(_DWORD *)v9)
        {
          case 2:
            if (__cxa_in_range(a1, a2, *(void *)(v9 + 24))) {
              goto LABEL_20;
            }
            break;
          case 1:
            unint64_t v6 = 0;
            if (*(void *)(v9 + 8)) {
              unint64_t v6 = *(void *)(v9 + 8);
            }
            if (__cxa_in_range(a1, a2, v6)) {
              goto LABEL_20;
            }
            break;
          case 3:
            uint64_t v4 = _Block_get_invoke_fn(*(void *)(v9 + 8));
            unint64_t v5 = 0;
            if (v4) {
              unint64_t v5 = v4;
            }
            if (__cxa_in_range(a1, a2, v5)) {
              goto LABEL_20;
            }
            break;
          default:
            goto LABEL_20;
        }
      }
      else
      {
LABEL_20:
        int v7 = *(_DWORD *)v9;
        *(_DWORD *)uint64_t v9 = 0;
        __atexit_new_registratiosigned int n = 0;
        uint64_t v2 = pthread_mutex_unlock(&atexit_mutex);
        switch(v7)
        {
          case 2:
            (*(void (**)(void))(v9 + 8))(*(void *)(v9 + 16));
            break;
          case 1:
            (*(void (**)(uint64_t))(v9 + 8))(v2);
            break;
          case 3:
            (*(void (**)(void))(*(void *)(v9 + 8) + 16))();
            break;
        }
        pthread_mutex_lock(&atexit_mutex);
        if (__atexit_new_registration) {
          goto LABEL_2;
        }
      }
    }
  }
  return pthread_mutex_unlock(&atexit_mutex);
}

uint64_t __cxa_in_range(uint64_t a1, unsigned int a2, unint64_t a3)
{
  for (unsigned int i = 0; i < a2; ++i)
  {
    if (a3 >= *(void *)(a1 + 16 * i) && a3 < *(void *)(a1 + 16 * i) + *(void *)(a1 + 16 * i + 8))
    {
      char v5 = 1;
      return v5 & 1;
    }
  }
  char v5 = 0;
  return v5 & 1;
}

uint64_t _Block_get_invoke_fn(uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v2 = 0;
  if (v3) {
    return v3;
  }
  return v2;
}

int __cxa_finalize(void *a1)
{
  uint64_t v3 = a1;
  if (!a1) {
    return __cxa_finalize_ranges(0, 0);
  }
  v2[0] = v3;
  v2[1] = 1;
  return __cxa_finalize_ranges((uint64_t)v2, 1u);
}

double atof(const char *a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    char v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    char v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return strtod_l(a1, 0, v5);
  }
  else {
    return strtod_l(a1, 0, (locale_t)__global_locale);
  }
}

double atof_l(const char *a1, locale_t a2)
{
  return strtod_l(a1, 0, a2);
}

int atoi(const char *a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    char v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    char v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return strtol_l(a1, 0, 10, v5);
  }
  else {
    return strtol_l(a1, 0, 10, (locale_t)__global_locale);
  }
}

int atoi_l(const char *a1, locale_t a2)
{
  return strtol_l(a1, 0, 10, a2);
}

uint64_t atol(const char *a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    char v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    char v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return strtol_l(a1, 0, 10, v5);
  }
  else {
    return strtol_l(a1, 0, 10, (locale_t)__global_locale);
  }
}

uint64_t atol_l(const char *a1, locale_t a2)
{
  return strtol_l(a1, 0, 10, a2);
}

uint64_t atoll(const char *a1)
{
  if (v1) {
    char v2 = 1;
  }
  else {
    char v2 = 0;
  }
  if (v2)
  {
    char v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v6 = __locale_key;
    char v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5) {
    return strtoll_l(a1, 0, 10, v5);
  }
  else {
    return strtoll_l(a1, 0, 10, (locale_t)__global_locale);
  }
}

uint64_t atoll_l(const char *a1, locale_t a2)
{
  return strtoll_l(a1, 0, 10, a2);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  while (__nel)
  {
    int v6 = ((uint64_t (*)(const void *, char *))__compar)(__key, (char *)__base + (__nel >> 1) * __width);
    if (!v6) {
      return (char *)__base + (__nel >> 1) * __width;
    }
    if (v6 > 0) {
      __int base = (char *)__base + (__nel-- >> 1) * __width + __width;
    }
    __nel >>= 1;
  }
  return 0;
}

void *__cdecl bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, void *__compar)
{
  while (__nel)
  {
    int v6 = (*((uint64_t (**)(void *, const void *, char *))__compar + 2))(__compar, __key, (char *)__base + (__nel >> 1) * __width);
    if (!v6) {
      return (char *)__base + (__nel >> 1) * __width;
    }
    if (v6 > 0) {
      __int base = (char *)__base + (__nel-- >> 1) * __width + __width;
    }
    __nel >>= 1;
  }
  return 0;
}

div_t div(int a1, int a2)
{
  v3.quot = a1 / a2;
  v3.reint m = a1 % a2;
  if (a1 >= 0 && v3.rem < 0)
  {
    ++v3.quot;
    v3.rem -= a2;
  }
  return v3;
}

void exit(int a1)
{
  if (__cleanup) {
    _cleanup();
  }
  __exit(a1);
}

unsigned char *__findenv_locked(unsigned char *a1, _DWORD *a2, char **a3)
{
  if (!a1 || !a3) {
    return 0;
  }
  for (unsigned int i = a1; ; ++i)
  {
    BOOL v8 = 0;
    if (*i) {
      BOOL v8 = *i != 61;
    }
    if (!v8) {
      break;
    }
  }
  int v15 = i - a1;
  for (int j = a3; ; ++j)
  {
    uint64_t v9 = *j;
    if (!*j) {
      break;
    }
    size_t v13 = a1;
    for (int k = v15; ; --k)
    {
      BOOL v7 = 0;
      if (k) {
        BOOL v7 = *v9 != 0;
      }
      if (!v7) {
        break;
      }
      div_t v3 = v9++;
      uint64_t v4 = v13++;
      if (*v3 != *v4) {
        break;
      }
    }
    if (!k)
    {
      char v5 = v9;
      uint64_t v10 = v9 + 1;
      if (*v5 == 61)
      {
        *a2 = j - a3;
        return v10;
      }
    }
  }
  return 0;
}

uint64_t environ_lock_np()
{
  return os_unfair_lock_lock_with_options();
}

void environ_unlock_np()
{
}

void __environ_lock_fork_child()
{
  __environ_lock_obint j = 0;
}

unsigned char *_getenvp(unsigned char *a1, char ***a2, uint64_t a3)
{
  BOOL v8 = a1;
  BOOL v7 = a2;
  uint64_t v6 = a3;
  int v5 = 0;
  environ_lock_np();
  uint64_t v4 = __findenv_locked(v8, &v5, *v7);
  environ_unlock_np();
  return v4;
}

char *__cdecl getenv(const char *a1)
{
  uint64_t v6 = a1;
  int v5 = 0;
  environ_lock_np();
  div_t v3 = (char *)v6;
  char v1 = _NSGetEnviron();
  uint64_t v4 = __findenv_locked(v3, &v5, *v1);
  environ_unlock_np();
  return v4;
}

int getopt(int a1, char *const a2[], const char *a3)
{
  if (!optreset && *getopt_place)
  {
    int v5 = getopt_place++;
    optopt = *v5;
  }
  else
  {
    optreset = 0;
    getopt_place = a2[optind];
    if (optind >= a1 || (div_t v3 = getopt_place, ++getopt_place, *v3 != 45))
    {
      getopt_place = &EMSG;
      return -1;
    }
    uint64_t v4 = getopt_place++;
    optopt = *v4;
    if (optopt == 45 && !*getopt_place)
    {
      ++optind;
      getopt_place = &EMSG;
      return -1;
    }
    if (!optopt)
    {
      getopt_place = &EMSG;
      if (!strchr(a3, 45)) {
        return -1;
      }
      optopt = 45;
    }
  }
  if (optopt == 58 || (BOOL v7 = strchr(a3, optopt)) == 0)
  {
    if (!*getopt_place) {
      ++optind;
    }
    if (opterr && *a3 != 58) {
      fprintf(__stderrp, "%s: illegal option -- %c\n", *(const char **)a2, optopt);
    }
    return 63;
  }
  if (v7[1] != 58)
  {
    optarg = 0;
    if (!*getopt_place) {
      ++optind;
    }
    return optopt;
  }
  if (*getopt_place)
  {
    optarg = getopt_place;
LABEL_38:
    getopt_place = &EMSG;
    ++optind;
    return optopt;
  }
  if (v7[2] == 58)
  {
    optarg = 0;
    goto LABEL_38;
  }
  if (a1 > ++optind)
  {
    optarg = a2[optind];
    goto LABEL_38;
  }
  ++optind;
  optarg = 0;
  getopt_place = &EMSG;
  if (*a3 == 58) {
    return 58;
  }
  if (opterr) {
    fprintf(__stderrp, "%s: option requires an argument -- %c\n", *(const char **)a2, optopt);
  }
  return 63;
}

int getopt_long(int a1, char *const *a2, const char *a3, const option *a4, int *a5)
{
  return getopt_internal(a1, (uint64_t)a2, (char *)a3, (uint64_t)a4, a5, 1);
}

uint64_t getopt_internal(int a1, uint64_t a2, char *a3, uint64_t a4, int *a5, char a6)
{
  int v22 = a3;
  if (!a3) {
    return -1;
  }
  if (!optind)
  {
    optreset = 1;
    optind = 1;
  }
  if (getopt_internal_posixly_correct == -1 || optreset)
  {
    LOBYTE(getopt_internal_posixly_correct) = getenv("POSIXLY_CORRECT") != 0;
    getopt_internal_posixly_correct = getopt_internal_posixly_correct;
  }
  if (*v22 == 45)
  {
    a6 |= 2u;
  }
  else if (getopt_internal_posixly_correct || *v22 == 43)
  {
    a6 &= ~1u;
  }
  if (*v22 == 43 || *v22 == 45) {
    ++v22;
  }
  optarg = 0;
  if (optreset)
  {
    nonopt_end = -1;
    nonopt_start = -1;
  }
  while (1)
  {
    if (!optreset && *place) {
      goto LABEL_46;
    }
    optreset = 0;
    if (optind >= a1)
    {
      place = &EMSG_0;
      if (nonopt_end == -1)
      {
        if (nonopt_start != -1) {
          optind = nonopt_start;
        }
      }
      else
      {
        permute_args(nonopt_start, nonopt_end, optind, a2);
        optind -= nonopt_end - nonopt_start;
      }
      nonopt_end = -1;
      nonopt_start = -1;
      return -1;
    }
    place = *(char **)(a2 + 8 * optind);
    if (*place == 45)
    {
      if (*((unsigned char *)&def_1F2C + (void)place + 1)) {
        break;
      }
    }
    place = &EMSG_0;
    if ((a6 & 2) != 0)
    {
      uint64_t v6 = optind++;
      optarg = *(char **)(a2 + 8 * v6);
      return 1;
    }
    if ((a6 & 1) == 0) {
      return -1;
    }
    if (nonopt_start == -1)
    {
      nonopt_start = optind;
    }
    else if (nonopt_end != -1)
    {
      permute_args(nonopt_start, nonopt_end, optind, a2);
      nonopt_start = optind - (nonopt_end - nonopt_start);
      nonopt_end = -1;
    }
    ++optind;
  }
  if (nonopt_start != -1 && nonopt_end == -1) {
    nonopt_end = optind;
  }
  if (*((unsigned char *)&def_1F2C + (void)place + 1))
  {
    BOOL v7 = place++;
    if (*((unsigned char *)&def_1F2C + (void)v7 + 1) == 45 && !*((unsigned char *)&def_1F2C + (void)place + 1))
    {
      ++optind;
      place = &EMSG_0;
      if (nonopt_end != -1)
      {
        permute_args(nonopt_start, nonopt_end, optind, a2);
        optind -= nonopt_end - nonopt_start;
      }
      nonopt_end = -1;
      nonopt_start = -1;
      return -1;
    }
  }
LABEL_46:
  if (a4 && place != *(char **)(a2 + 8 * optind) && (*place == 45 || (a6 & 4) != 0))
  {
    BOOL v14 = 0;
    dash_prefix = 0;
    if (*place == 45)
    {
      if (!*++place)
      {
        if (*v22 == 58) {
          return 58;
        }
        else {
          return 63;
        }
      }
      dash_prefix = 1;
    }
    else if (*place != 58)
    {
      BOOL v14 = strchr(v22, *place) != 0;
    }
    unsigned int v15 = parse_long_options(a2, v22, a4, a5, v14, a6);
    if (v15 != -1)
    {
      place = &EMSG_0;
      return v15;
    }
  }
  uint64_t v9 = place++;
  unsigned int v16 = *v9;
  if (v16 == 58 || v16 == 45 && *place || (uint64_t v17 = strchr(v22, v16)) == 0)
  {
    if (v16 != 45 || *place)
    {
      if (!*place) {
        ++optind;
      }
      if (opterr && *v22 != 58)
      {
        if (getopt_internal_posixly_correct) {
          warnx("illegal option -- %c");
        }
        else {
          warnx("invalid option -- %c");
        }
      }
      optopt = v16;
      return 63;
    }
    else
    {
      return -1;
    }
  }
  if (a4 && v16 == 87 && v17[1] == 59)
  {
    if (!*place)
    {
      if (++optind >= a1)
      {
        place = &EMSG_0;
        if (opterr && *v22 != 58) {
          warnx("option requires an argument -- %c", 87);
        }
        optopt = 87;
        if (*v22 == 58) {
          return 58;
        }
        else {
          return 63;
        }
      }
      place = *(char **)(a2 + 8 * optind);
    }
    dash_prefix = 2;
    unsigned int v11 = parse_long_options(a2, v22, a4, a5, 0, a6);
    place = &EMSG_0;
    return v11;
  }
  unint64_t v18 = v17 + 1;
  if (*v18 != 58)
  {
    if (!*place) {
      ++optind;
    }
    return v16;
  }
  optarg = 0;
  if (*place)
  {
    optarg = place;
LABEL_106:
    place = &EMSG_0;
    ++optind;
    return v16;
  }
  if (v18[1] == 58) {
    goto LABEL_106;
  }
  if (++optind < a1)
  {
    optarg = *(char **)(a2 + 8 * optind);
    goto LABEL_106;
  }
  place = &EMSG_0;
  if (opterr && *v22 != 58) {
    warnx("option requires an argument -- %c", v16);
  }
  optopt = v16;
  if (*v22 == 58) {
    return 58;
  }
  else {
    return 63;
  }
}

int getopt_long_only(int a1, char *const *a2, const char *a3, const option *a4, int *a5)
{
  return getopt_internal(a1, (uint64_t)a2, (char *)a3, (uint64_t)a4, a5, 5);
}

uint64_t permute_args(int a1, int a2, int a3, uint64_t a4)
{
  int v8 = a2 - a1;
  int v7 = a3 - a2;
  uint64_t result = gcd(a2 - a1, a3 - a2);
  for (int i = 0; i < (int)result; ++i)
  {
    int v11 = a2 + i;
    int v6 = a2 + i;
    for (int j = 0; j < (a3 - a1) / (int)result; ++j)
    {
      if (v6 < a2) {
        v6 += v7;
      }
      else {
        v6 -= v8;
      }
      uint64_t v5 = *(void *)(a4 + 8 * v6);
      *(void *)(a4 + 8 * v6) = *(void *)(a4 + 8 * v11);
      *(void *)(a4 + 8 * v11) = v5;
    }
  }
  return result;
}

uint64_t parse_long_options(uint64_t a1, unsigned char *a2, uint64_t a3, int *a4, int a5, char a6)
{
  unsigned int v16 = place;
  if (dash_prefix)
  {
    if (dash_prefix == 1)
    {
      BOOL v14 = "--";
    }
    else if (dash_prefix == 2)
    {
      BOOL v14 = "-W ";
    }
    else
    {
      BOOL v14 = (const char *)&unk_D793D;
    }
  }
  else
  {
    BOOL v14 = "-";
  }
  int v11 = -1;
  int v10 = 0;
  int v9 = 0;
  ++optind;
  unsigned int v15 = strchr(place, 61);
  if (v15)
  {
    __signed int n = v15 - v16;
    ++v15;
  }
  else
  {
    __signed int n = strlen(v16);
  }
  for (int i = 0; *(void *)(a3 + 32 * i); ++i)
  {
    if (!strncmp(v16, *(const char **)(a3 + 32 * i), __n))
    {
      if (strlen(*(const char **)(a3 + 32 * i)) == __n)
      {
        int v11 = i;
        int v10 = 1;
        break;
      }
      if (!a5 || __n != 1)
      {
        if (v11 == -1)
        {
          int v11 = i;
        }
        else if ((a6 & 4) != 0 {
               || *(_DWORD *)(a3 + 32 * i + 8) != *(_DWORD *)(a3 + 32 * v11 + 8)
        }
               || *(void *)(a3 + 32 * i + 16) != *(void *)(a3 + 32 * v11 + 16)
               || *(_DWORD *)(a3 + 32 * i + 24) != *(_DWORD *)(a3 + 32 * v11 + 24))
        {
          int v9 = 1;
        }
      }
    }
  }
  if (v10 || !v9)
  {
    if (v11 == -1)
    {
      if (a5)
      {
        --optind;
        return -1;
      }
      else
      {
        if (opterr && *a2 != 58) {
        optopt = 0;
        }
        return 63;
      }
    }
    else if (*(_DWORD *)(a3 + 32 * v11 + 8) || !v15)
    {
      if (*(_DWORD *)(a3 + 32 * v11 + 8) == 1 || *(_DWORD *)(a3 + 32 * v11 + 8) == 2)
      {
        if (v15)
        {
          optarg = v15;
        }
        else if (*(_DWORD *)(a3 + 32 * v11 + 8) == 1)
        {
          uint64_t v6 = optind++;
          optarg = *(char **)(a1 + 8 * v6);
        }
      }
      if (*(_DWORD *)(a3 + 32 * v11 + 8) != 1 || optarg)
      {
        if (a4) {
          *a4 = v11;
        }
        if (*(void *)(a3 + 32 * v11 + 16))
        {
          **(_DWORD **)(a3 + 32 * v11 + 16) = *(_DWORD *)(a3 + 32 * v11 + 24);
          return 0;
        }
        else
        {
          return *(unsigned int *)(a3 + 32 * v11 + 24);
        }
      }
      else
      {
        if (opterr && *a2 != 58) {
        if (*(void *)(a3 + 32 * v11 + 16))
        }
          optopt = 0;
        else {
          optopt = *(_DWORD *)(a3 + 32 * v11 + 24);
        }
        --optind;
        if (*a2 == 58) {
          return 58;
        }
        else {
          return 63;
        }
      }
    }
    else
    {
      if (opterr && *a2 != 58) {
      if (*(void *)(a3 + 32 * v11 + 16))
      }
        optopt = 0;
      else {
        optopt = *(_DWORD *)(a3 + 32 * v11 + 24);
      }
      return 63;
    }
  }
  else
  {
    if (opterr && *a2 != 58) {
    optopt = 0;
    }
    return 63;
  }
}

uint64_t gcd(int a1, signed int a2)
{
  unsigned int v4 = a2;
  for (int i = a1 % a2; i; int i = v5 % i)
  {
    signed int v5 = v4;
    unsigned int v4 = i;
  }
  return v4;
}

int getsubopt(char **a1, char *const *a2, char **a3)
{
  *a3 = 0;
  suboptarg = 0;
  if (!a1 || !*a1) {
    return -1;
  }
  for (int i = *a1; ; ++i)
  {
    BOOL v11 = 0;
    if (*i)
    {
      BOOL v10 = 1;
      if (*i != 44)
      {
        BOOL v10 = 1;
        if (*i != 32) {
          BOOL v10 = *i == 9;
        }
      }
      BOOL v11 = v10;
    }
    if (!v11) {
      break;
    }
  }
  if (*i)
  {
    suboptarg = i;
    do
    {
      ++i;
      BOOL v9 = 0;
      if (*i)
      {
        BOOL v9 = 0;
        if (*i != 44)
        {
          BOOL v9 = 0;
          if (*i != 61)
          {
            BOOL v9 = 0;
            if (*i != 32) {
              BOOL v9 = *i != 9;
            }
          }
        }
      }
    }
    while (v9);
    if (*i)
    {
      if (*i == 61)
      {
        *i++ = 0;
        *a3 = i;
        while (1)
        {
          BOOL v8 = 0;
          if (*i)
          {
            BOOL v8 = 0;
            if (*i != 44)
            {
              BOOL v8 = 0;
              if (*i != 32) {
                BOOL v8 = *i != 9;
              }
            }
          }
          if (!v8) {
            break;
          }
          ++i;
        }
        if (*i)
        {
          div_t v3 = i++;
          *div_t v3 = 0;
        }
      }
      else
      {
        unsigned int v4 = i++;
        *unsigned int v4 = 0;
      }
      while (1)
      {
        BOOL v7 = 0;
        if (*i)
        {
          BOOL v6 = 1;
          if (*i != 44)
          {
            BOOL v6 = 1;
            if (*i != 32) {
              BOOL v6 = *i == 9;
            }
          }
          BOOL v7 = v6;
        }
        if (!v7) {
          break;
        }
        ++i;
      }
    }
    *a1 = i;
    int v13 = 0;
    while (*a2)
    {
      if (!strcmp(suboptarg, *(const char **)a2)) {
        return v13;
      }
      ++a2;
      ++v13;
    }
    return -1;
  }
  else
  {
    *a1 = i;
    return -1;
  }
}

int hcreate(size_t a1)
{
  size_t v4 = a1;
  if (htable)
  {
    *__error() = 22;
    return 0;
  }
  else
  {
    if (a1 < 0x10) {
      size_t v4 = 16;
    }
    if (v4 > 0x400000000000000) {
      size_t v4 = 0x400000000000000;
    }
    if ((v4 & (v4 - 1)) != 0)
    {
      char v2 = 0;
      while (v4)
      {
        v4 >>= 1;
        ++v2;
      }
      size_t v4 = 1 << v2;
    }
    htableint size = v4;
    htable = malloc_type_malloc();
    if (htable)
    {
      for (unint64_t i = 0; i < htablesize; ++i)
        *(void *)(htable + 8 * i) = 0;
      return 1;
    }
    else
    {
      *__error() = 12;
      return 0;
    }
  }
}

void hdestroy_0(void)
{
  if (htable)
  {
    for (unint64_t i = 0; i < htablesize; ++i)
    {
      while (*(void *)(htable + 8 * i))
      {
        char v1 = *(void ***)(htable + 8 * i);
        *(void *)(htable + 8 * i) = *v1;
        free(v1[1]);
        free(v1);
      }
    }
    free((void *)htable);
    htable = 0;
  }
}

ENTRY *__cdecl hsearch(ENTRY a1, ACTION a2)
{
  size_t v2 = strlen(a1.key);
  BOOL v6 = (uint64_t *)(htable
                 + 8
                 * (__default_hash((unsigned __int8 *)a1.key, v2) & (unint64_t)(htablesize - 1)));
  for (uint64_t i = *v6; i && strcmp(*(const char **)(i + 8), a1.key); uint64_t i = *(void *)i)
    ;
  if (i) {
    return (ENTRY *)(i + 8);
  }
  if (a2 == FIND) {
    return 0;
  }
  uint64_t v5 = malloc_type_malloc();
  if (!v5) {
    return 0;
  }
  *(ENTRY *)(v5 + 8) = a1;
  *(void *)uint64_t v5 = *v6;
  *BOOL v6 = v5;
  return (ENTRY *)(v5 + 8);
}

int heapsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  size_t v47 = __nel;
  if (__nel <= 1) {
    return 0;
  }
  if (__width)
  {
    BOOL v20 = (char *)malloc_type_malloc();
    if (v20)
    {
      int v21 = (char *)__base - __width;
      unint64_t v33 = v47 / 2 + 1;
      while (--v33)
      {
        for (unint64_t i = v33; ; unint64_t i = v34)
        {
          unint64_t v34 = 2 * i;
          if (2 * i > v47) {
            break;
          }
          unint64_t v18 = &v21[v34 * __width];
          if (v34 < v47 && ((int (*)(char *, char *))__compar)(v18, &v18[__width]) < 0)
          {
            v18 += __width;
            ++v34;
          }
          uint64_t v17 = &v21[i * __width];
          if (((int (*)(char *, char *))__compar)(v18, v17) <= 0) {
            break;
          }
          size_t v39 = __width;
          do
          {
            char v32 = *v17;
            size_t v4 = v17++;
            *size_t v4 = *v18;
            uint64_t v5 = v18++;
            *uint64_t v5 = v32;
            --v39;
          }
          while (v39);
        }
      }
      while (v47 > 1)
      {
        size_t v40 = __width;
        int v27 = v20;
        int v22 = &v21[v47 * __width];
        do
        {
          BOOL v6 = v22++;
          BOOL v7 = v27++;
          *BOOL v7 = *v6;
          --v40;
        }
        while (v40);
        size_t v41 = __width;
        int v28 = &v21[v47 * __width];
        int v23 = (char *)__base;
        do
        {
          BOOL v8 = v23++;
          BOOL v9 = v28++;
          *BOOL v9 = *v8;
          --v41;
        }
        while (v41);
        --v47;
        for (unint64_t j = 1; ; unint64_t j = v35)
        {
          unint64_t v35 = 2 * j;
          if (2 * j > v47) {
            break;
          }
          uint64_t v19 = &v21[v35 * __width];
          if (v35 < v47 && ((int (*)(char *, char *))__compar)(v19, &v19[__width]) < 0)
          {
            v19 += __width;
            ++v35;
          }
          size_t v42 = __width;
          int v29 = &v21[j * __width];
          char v24 = v19;
          do
          {
            BOOL v10 = v24++;
            BOOL v11 = v29++;
            *BOOL v11 = *v10;
            --v42;
          }
          while (v42);
        }
        while (1)
        {
          unint64_t v36 = j;
          j /= 2uLL;
          if (v36 == 1 || ((int (*)(char *, char *))__compar)(v20, &v21[j * __width]) < 0) {
            break;
          }
          size_t v44 = __width;
          sigset_t v31 = &v21[v36 * __width];
          int v26 = &v21[j * __width];
          do
          {
            BOOL v14 = v26++;
            unsigned int v15 = v31++;
            *unsigned int v15 = *v14;
            --v44;
          }
          while (v44);
        }
        size_t v43 = __width;
        sigset_t v30 = &v21[v36 * __width];
        char v25 = v20;
        do
        {
          uint64_t v12 = v25++;
          int v13 = v30++;
          *int v13 = *v12;
          --v43;
        }
        while (v43);
      }
      free(v20);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

intmax_t imaxabs(intmax_t j)
{
  if (j >= 0) {
    return j;
  }
  else {
    return -j;
  }
}

imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
{
  intmax_t v4 = __numer / __denom;
  intmax_t v5 = __numer % __denom;
  if (__numer >= 0 && v5 < 0)
  {
    ++v4;
    v5 -= __denom;
  }
  intmax_t v2 = v4;
  intmax_t v3 = v5;
  result.reint m = v3;
  result.quot = v2;
  return result;
}

void insque(void *a1, void *a2)
{
  if (a2)
  {
    intmax_t v3 = *(const void ***)a2;
    if (*(void *)a2)
    {
      if (v3[1] != a2) {
        fprintf(__stderrp, "insque: Inconsistency detected: next(%p)->prev(%p) != prev(%p)\n", v3, v3[1], a2);
      }
      v3[1] = a1;
    }
    *(void *)a2 = a1;
    *((void *)a1 + 1) = a2;
    *(void *)a1 = v3;
  }
  else
  {
    *(void *)a1 = 0;
    *((void *)a1 + 1) = 0;
  }
}

uint64_t labs(uint64_t a1)
{
  if (a1 >= 0) {
    return a1;
  }
  else {
    return -a1;
  }
}

ldiv_t ldiv(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 / a2;
  uint64_t v5 = a1 % a2;
  if (a1 >= 0 && v5 < 0)
  {
    ++v4;
    v5 -= a2;
  }
  uint64_t v2 = v4;
  uint64_t v3 = v5;
  result.reint m = v3;
  result.quot = v2;
  return result;
}

uint64_t llabs(uint64_t a1)
{
  if (a1 >= 0) {
    return a1;
  }
  else {
    return -a1;
  }
}

lldiv_t lldiv(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 / a2;
  uint64_t v5 = a1 % a2;
  if (a1 >= 0 && v5 < 0)
  {
    ++v4;
    v5 -= a2;
  }
  uint64_t v2 = v4;
  uint64_t v3 = v5;
  result.reint m = v3;
  result.quot = v2;
  return result;
}

void *__cdecl lsearch(const void *a1, void *a2, size_t *a3, size_t a4, int (__cdecl *a5)(const void *, const void *))
{
  return lwork(a1, (unint64_t)a2, a3, a4, (unsigned int (*)(const void *, unint64_t))a5, 1);
}

void *lwork(const void *a1, unint64_t a2, void *a3, size_t a4, unsigned int (*a5)(const void *, unint64_t), int a6)
{
  unint64_t v8 = a2;
  mbstate_t __dst = (void *)(a2 + a4 * *a3);
  while (v8 < (unint64_t)__dst)
  {
    if (!a5(a1, v8)) {
      return (void *)v8;
    }
    v8 += a4;
  }
  if (!a6) {
    return 0;
  }
  memcpy(__dst, a1, a4);
  ++*a3;
  return __dst;
}

void *__cdecl lfind(const void *a1, const void *a2, size_t *a3, size_t a4, int (__cdecl *a5)(const void *, const void *))
{
  return lwork(a1, (unint64_t)a2, a3, a4, (unsigned int (*)(const void *, unint64_t))a5, 0);
}

int mergesort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  if (__width >= 4)
  {
    if (__nel)
    {
      BOOL v33 = 0;
      if (!(__width % 4)) {
        BOOL v33 = (unint64_t)__base % 4 == 0;
      }
      mbstate_t __dst = (char *)malloc_type_malloc();
      if (__dst)
      {
        uint64_t __src = (char *)__base;
        setup((uint64_t)__base, __dst, __nel, __width, (uint64_t (*)(char *, char *))__compar);
        BOOL v20 = &__dst[__nel * __width];
        int v34 = 0;
        size_t v36 = 0;
        while (*(char **)((unint64_t)(__dst + 7) & 0xFFFFFFFFFFFFFFF8) != v20)
        {
          char v24 = __src;
          uint64_t v19 = (void *)((unint64_t)(__src + 7) & 0xFFFFFFFFFFFFFFF8);
          int v21 = __dst;
          int v27 = __dst;
          while (v21 != v20)
          {
            int v21 = *(char **)((unint64_t)(v21 + 7) & 0xFFFFFFFFFFFFFFF8);
            char v32 = v24;
            char v25 = &__src[v21 - __dst];
            sigset_t v31 = v25;
            if (v21 != v20) {
              int v21 = *(char **)((unint64_t)(v21 + 7) & 0xFFFFFFFFFFFFFFF8);
            }
            char v24 = &__src[v21 - __dst];
            while (1)
            {
              BOOL v18 = 0;
              if (v32 < (_DWORD *)v25) {
                BOOL v18 = v31 < (_DWORD *)v24;
              }
              if (!v18) {
                break;
              }
              if (((int (*)(_DWORD *, _DWORD *))__compar)(v32, v31) > 0)
              {
                int v26 = v32;
                int v29 = (char *)v31;
                sigset_t v30 = &__src[v21 - __dst];
                int v35 = 0;
              }
              else
              {
                int v26 = v31;
                int v29 = (char *)v32;
                sigset_t v30 = v25;
                int v35 = -1;
              }
              if (v34)
              {
LABEL_30:
                for (size_t i = __width; ; i *= 2)
                {
                  if (&v29[i] >= v30)
                  {
                    if (&v30[-__width] <= v29
                      || ((int (*)(_DWORD *, char *))__compar)(v26, &v30[-__width]) > v35)
                    {
                      int v29 = &v30[-__width];
                    }
                    else
                    {
                      v30 -= __width;
                    }
                    while (v30 > &v29[__width])
                    {
                      if (((int (*)(_DWORD *))__compar)(v26) > v35) {
                        v29 += (((v30 - v29) / __width) >> 1) * __width;
                      }
                      else {
                        sigset_t v30 = &v29[(((v30 - v29) / __width) >> 1) * __width];
                      }
                    }
                    goto LABEL_50;
                  }
                  if (((int (*)(_DWORD *, char *))__compar)(v26, &v29[i]) <= v35) {
                    break;
                  }
                  v29 += i;
                }
                sigset_t v30 = &v29[i];
                if (i == __width) {
                  int v34 = 0;
                }
                while (i > __width)
                {
                  i >>= 1;
                  if (((int (*)(_DWORD *))__compar)(v26) > v35) {
                    v29 += i;
                  }
                  else {
                    sigset_t v30 = &v29[i];
                  }
                }
LABEL_50:
                int v29 = v30;
              }
              else
              {
                while (1)
                {
                  v29 += __width;
                  BOOL v17 = 0;
                  if (v29 < v30) {
                    BOOL v17 = ((int (*)(_DWORD *, char *))__compar)(v26, v29) > v35;
                  }
                  if (!v17) {
                    break;
                  }
                  if (++v36 == 6)
                  {
                    int v34 = 1;
                    goto LABEL_30;
                  }
                }
              }
              size_t v36 = __width;
              if (v26 == v32)
              {
                if (v33)
                {
                  do
                    *v27++ = *v31++;
                  while (v31 < (_DWORD *)v29);
                  do
                  {
                    *v27++ = *v32++;
                    v36 -= 4;
                  }
                  while (v36);
                }
                else
                {
                  do
                  {
                    uint64_t v4 = v31;
                    sigset_t v31 = (_DWORD *)((char *)v31 + 1);
                    uint64_t v5 = v27;
                    int v27 = (_DWORD *)((char *)v27 + 1);
                    *uint64_t v5 = *v4;
                  }
                  while (v31 < (_DWORD *)v29);
                  do
                  {
                    BOOL v6 = v32;
                    char v32 = (_DWORD *)((char *)v32 + 1);
                    BOOL v7 = v27;
                    int v27 = (_DWORD *)((char *)v27 + 1);
                    *BOOL v7 = *v6;
                    --v36;
                  }
                  while (v36);
                }
              }
              else if (v33)
              {
                do
                  *v27++ = *v32++;
                while (v32 < (_DWORD *)v29);
                do
                {
                  *v27++ = *v31++;
                  v36 -= 4;
                }
                while (v36);
              }
              else
              {
                do
                {
                  unint64_t v8 = v32;
                  char v32 = (_DWORD *)((char *)v32 + 1);
                  BOOL v9 = v27;
                  int v27 = (_DWORD *)((char *)v27 + 1);
                  *BOOL v9 = *v8;
                }
                while (v32 < (_DWORD *)v29);
                do
                {
                  BOOL v10 = v31;
                  sigset_t v31 = (_DWORD *)((char *)v31 + 1);
                  BOOL v11 = v27;
                  int v27 = (_DWORD *)((char *)v27 + 1);
                  *BOOL v11 = *v10;
                  --v36;
                }
                while (v36);
              }
            }
            if (v31 >= (_DWORD *)v24)
            {
              if (v32 < (_DWORD *)v25)
              {
                if (v33)
                {
                  do
                    *v27++ = *v32++;
                  while (v32 < (_DWORD *)v25);
                }
                else
                {
                  do
                  {
                    BOOL v14 = v32;
                    char v32 = (_DWORD *)((char *)v32 + 1);
                    unsigned int v15 = v27;
                    int v27 = (_DWORD *)((char *)v27 + 1);
                    *unsigned int v15 = *v14;
                  }
                  while (v32 < (_DWORD *)v25);
                }
              }
            }
            else if (v33)
            {
              do
                *v27++ = *v31++;
              while (v31 < (_DWORD *)v24);
            }
            else
            {
              do
              {
                uint64_t v12 = v31;
                sigset_t v31 = (_DWORD *)((char *)v31 + 1);
                int v13 = v27;
                int v27 = (_DWORD *)((char *)v27 + 1);
                *int v13 = *v12;
              }
              while (v31 < (_DWORD *)v24);
            }
            *uint64_t v19 = v24;
            uint64_t v19 = (void *)((unint64_t)(v24 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
          int v28 = __src;
          uint64_t __src = __dst;
          mbstate_t __dst = v28;
          BOOL v20 = &v28[__nel * __width];
        }
        if (__base == __dst)
        {
          memmove(__dst, __src, __nel * __width);
          mbstate_t __dst = __src;
        }
        free(__dst);
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t setup(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(char *, char *))
{
  uint64_t v26 = 2 * a4;
  if (a3 > 5)
  {
    uint64_t v27 = (a3 & 1) + 4;
    insertionsort(a1 + (a3 - v27) * a4, v27, a4, a5);
    unint64_t v13 = a1 + a4 * (a3 - v27);
    *(void *)((unint64_t)&a2[a4 * (a3 - v27) + 7] & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
    uint64_t v12 = a2;
    BOOL v20 = (char *)a1;
    uint64_t result = a5((char *)a1, (char *)(a1 + a4));
    BOOL v21 = (int)result > 0;
    while ((unint64_t)v20 < v13)
    {
      int v25 = 2;
      for (size_t i = &v20[v26]; (unint64_t)i < v13; i += v26)
      {
        uint64_t result = a5(i, &i[a4]);
        if ((int)result > 0 != v21) {
          break;
        }
        v25 += 2;
      }
      if (v25 >= 16)
      {
        BOOL v14 = i;
        for (unint64_t j = &v20[v26]; j < v14; j += v26)
        {
          uint64_t result = a5(&j[-a4], j);
          if ((int)result > 0 != v21)
          {
            *(void *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &j[(void)a2 - a1];
            uint64_t v12 = &j[(void)a2 - a1];
            if (v21 > 0)
            {
              unsigned int v16 = &j[-a4];
              do
              {
                uint64_t v29 = a4;
                do
                {
                  char v23 = *v20;
                  unint64_t v8 = v20++;
                  *unint64_t v8 = *v16;
                  BOOL v9 = v16++;
                  *BOOL v9 = v23;
                  --v29;
                }
                while (v29);
                v16 -= v26;
              }
              while (v20 < v16);
            }
            BOOL v20 = j;
          }
        }
        if (v21 > 0)
        {
          BOOL v17 = &j[-a4];
          do
          {
            uint64_t v30 = a4;
            do
            {
              char v24 = *v20;
              BOOL v10 = v20++;
              *BOOL v10 = *v17;
              BOOL v11 = v17++;
              *BOOL v11 = v24;
              --v30;
            }
            while (v30);
            v17 -= v26;
          }
          while (v20 < v17);
        }
        BOOL v20 = j;
        if ((unint64_t)j >= v13 && (uint64_t result = a5(&j[-a4], j), (int)result <= 0))
        {
          *(void *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
          uint64_t v12 = &a2[a3 * a4];
        }
        else
        {
          *(void *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &j[(void)a2 - a1];
          uint64_t v12 = &j[(void)a2 - a1];
        }
      }
      else
      {
        do
        {
          *(void *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &v20[v26 - a1 + (void)a2];
          uint64_t v12 = &v20[v26 - a1 + (void)a2];
          if (v21 > 0)
          {
            unsigned int v15 = &v20[a4];
            uint64_t v28 = a4;
            do
            {
              char v22 = *v20;
              BOOL v6 = v20++;
              *BOOL v6 = *v15;
              BOOL v7 = v15++;
              *BOOL v7 = v22;
              --v28;
            }
            while (v28);
            v20 -= a4;
          }
          v20 += v26;
        }
        while (v20 < i);
      }
      BOOL v21 = !v21;
    }
  }
  else
  {
    uint64_t result = insertionsort(a1, a3, a4, a5);
    *(void *)((unint64_t)(a2 + 7) & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
  }
  return result;
}

uint64_t insertionsort(uint64_t result, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, char *))
{
  unint64_t v15 = result;
  for (size_t i = (char *)(result + a3); --a2; i += a3)
  {
    for (unint64_t j = i; (unint64_t)j > v15; j -= a3)
    {
      unint64_t v8 = &j[-a3];
      uint64_t result = a4(&j[-a3], j);
      if ((int)result <= 0) {
        break;
      }
      BOOL v10 = j;
      int v6 = a3;
      do
      {
        char v7 = *v8;
        uint64_t v4 = v8++;
        *uint64_t v4 = *v10;
        uint64_t v5 = v10++;
        *uint64_t v5 = v7;
        --v6;
      }
      while (v6);
    }
  }
  return result;
}

uint64_t _putenvp(char *a1, char ***a2, _DWORD *a3)
{
  environ_lock_np();
  if (__init__env_owned_locked(1))
  {
    environ_unlock_np();
    return -1;
  }
  else
  {
    if (a3) {
      unsigned int v3 = __setenv_locked(a1, 0, 1, 0, a2, a3);
    }
    else {
      unsigned int v3 = __setenv_locked(a1, 0, 1, 0, a2, (_DWORD *)__env_owned);
    }
    unsigned int v5 = v3;
    environ_unlock_np();
    return v5;
  }
}

int putenv(char *a1)
{
  if (a1 && *a1 && index(a1, 61))
  {
    environ_lock_np();
    if (__init__env_owned_locked(1))
    {
      environ_unlock_np();
      return -1;
    }
    else
    {
      char v1 = _NSGetEnviron();
      int v3 = __setenv_locked(a1, 0, 1, 0, v1, (_DWORD *)__env_owned);
      environ_unlock_np();
      return v3;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  int v4 = flsl(__nel);
  _qsort((unint64_t)__base, __nel, __width, __compar, 2 * (v4 - 1));
}

uint64_t _qsort(unint64_t a1, size_t a2, size_t a3, int (__cdecl *a4)(const void *, const void *), unsigned int a5)
{
  int v23 = 0;
  while (1)
  {
    if (a1 % 8 || a3 % 8) {
      int v12 = 2;
    }
    else {
      int v12 = a3 != 8;
    }
    if (a1 % 4 || a3 % 4) {
      int v11 = 2;
    }
    else {
      int v11 = a3 != 4;
    }
    int v22 = 0;
    int v5 = a5--;
    if (v5 <= 0) {
      return heapsort((void *)a1, a2, a3, a4);
    }
    if (a2 <= 7) {
      break;
    }
    uint64_t v29 = a1;
    uint64_t v28 = a1 + a2 / 2 * a3;
    uint64_t v26 = a1 + (a2 - 1) * a3;
    if (a2 > 0x28)
    {
      unint64_t v21 = a2 / 8 * a3;
      uint64_t v29 = med3(a1, a1 + v21, a1 + 2 * v21, (int (*)(uint64_t, uint64_t))a4);
      uint64_t v28 = med3(v28 - v21, v28, v28 + v21, (int (*)(uint64_t, uint64_t))a4);
      uint64_t v26 = med3(v26 - 2 * v21, v26 - v21, v26, (int (*)(uint64_t, uint64_t))a4);
    }
    uint64_t result = med3(v29, v28, v26, (int (*)(uint64_t, uint64_t))a4);
    if (v12)
    {
      if (v11)
      {
        uint64_t result = (uint64_t)swapfunc((char *)a1, (char *)result, a3, v12, v11);
      }
      else
      {
        int v19 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)result;
        *(_DWORD *)uint64_t result = v19;
      }
    }
    else
    {
      uint64_t v20 = *(void *)a1;
      *(void *)a1 = *(void *)result;
      *(void *)uint64_t result = v20;
    }
    char v32 = (char *)(a1 + a3);
    BOOL v33 = (char *)(a1 + a3);
    uint64_t v30 = (char *)(a1 + (a2 - 1) * a3);
    for (size_t i = v30; ; i -= a3)
    {
      while (1)
      {
        BOOL v10 = 0;
        if (v32 <= i)
        {
          uint64_t result = ((uint64_t (*)(char *, unint64_t))a4)(v32, a1);
          int v23 = result;
          BOOL v10 = (int)result <= 0;
        }
        if (!v10) {
          break;
        }
        if (!v23)
        {
          int v22 = 1;
          if (v12)
          {
            if (v11)
            {
              uint64_t result = (uint64_t)swapfunc(v33, v32, a3, v12, v11);
            }
            else
            {
              int v17 = *(_DWORD *)v33;
              *(_DWORD *)BOOL v33 = *(_DWORD *)v32;
              *(_DWORD *)char v32 = v17;
            }
          }
          else
          {
            uint64_t v18 = *(void *)v33;
            *(void *)BOOL v33 = *(void *)v32;
            *(void *)char v32 = v18;
          }
          v33 += a3;
        }
        v32 += a3;
      }
      while (1)
      {
        BOOL v9 = 0;
        if (v32 <= i)
        {
          uint64_t result = ((uint64_t (*)(char *, unint64_t))a4)(i, a1);
          int v23 = result;
          BOOL v9 = (int)result >= 0;
        }
        if (!v9) {
          break;
        }
        if (!v23)
        {
          int v22 = 1;
          if (v12)
          {
            if (v11)
            {
              uint64_t result = (uint64_t)swapfunc(i, v30, a3, v12, v11);
            }
            else
            {
              int v15 = *(_DWORD *)i;
              *(_DWORD *)size_t i = *(_DWORD *)v30;
              *(_DWORD *)uint64_t v30 = v15;
            }
          }
          else
          {
            uint64_t v16 = *(void *)i;
            *(void *)size_t i = *(void *)v30;
            *(void *)uint64_t v30 = v16;
          }
          v30 -= a3;
        }
        i -= a3;
      }
      if (v32 > i) {
        break;
      }
      if (v12)
      {
        if (v11)
        {
          uint64_t result = (uint64_t)swapfunc(v32, i, a3, v12, v11);
        }
        else
        {
          int v13 = *(_DWORD *)v32;
          *(_DWORD *)char v32 = *(_DWORD *)i;
          *(_DWORD *)size_t i = v13;
        }
      }
      else
      {
        uint64_t v14 = *(void *)v32;
        *(void *)char v32 = *(void *)i;
        *(void *)size_t i = v14;
      }
      int v22 = 1;
      v32 += a3;
    }
    unint64_t v27 = a1 + a2 * a3;
    if ((uint64_t)&v33[-a1] >= v32 - v33) {
      unint64_t v8 = v32 - v33;
    }
    else {
      unint64_t v8 = (unint64_t)&v33[-a1];
    }
    if (v8) {
      uint64_t result = (uint64_t)swapfunc((char *)a1, &v32[-v8], v8, v12, v11);
    }
    if (v30 - i >= v27 - (void)v30 - a3) {
      unint64_t v7 = v27 - (void)v30 - a3;
    }
    else {
      unint64_t v7 = v30 - i;
    }
    if (v7) {
      uint64_t result = (uint64_t)swapfunc(v32, (char *)(v27 - v7), v7, v12, v11);
    }
    if (!v22)
    {
      uint64_t result = _isort(a1, a2, a3, 0, (int (*)(char *, char *))a4, (a2 / 4) + 1, v12, v11);
      if (result) {
        return result;
      }
    }
    size_t v25 = v32 - v33;
    size_t v24 = v30 - i;
    if (v32 - v33 > (unint64_t)(v30 - i))
    {
      if (v24 > a3) {
        uint64_t result = _qsort(v27 - v24, v24 / a3, a3, a4, a5);
      }
      if (v25 <= a3) {
        return result;
      }
      a2 = v25 / a3;
    }
    else
    {
      if (v25 > a3) {
        uint64_t result = _qsort(a1, v25 / a3, a3, a4, a5);
      }
      if (v24 <= a3) {
        return result;
      }
      a1 = v27 - v24;
      a2 = v24 / a3;
    }
  }
  return _isort(a1, a2, a3, 0, (int (*)(char *, char *))a4, 0, v12, v11);
}

uint64_t _isort(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int (*a5)(char *, char *), int a6, int a7, int a8)
{
  int v14 = 0;
  for (size_t i = (char *)(a1 + a3); (unint64_t)i < a1 + a2 * a3; i += a3)
  {
    for (unint64_t j = i; ; j -= a3)
    {
      BOOL v9 = 0;
      if ((unint64_t)j > a1) {
        BOOL v9 = a5(&j[-a3], j) > 0;
      }
      if (!v9) {
        break;
      }
      if (a7)
      {
        if (a8)
        {
          swapfunc(j, &j[-a3], a3, a7, a8);
        }
        else
        {
          int v10 = *(_DWORD *)j;
          *(_DWORD *)unint64_t j = *(_DWORD *)&j[-a3];
          *(_DWORD *)&j[-a3] = v10;
        }
      }
      else
      {
        uint64_t v11 = *(void *)j;
        *(void *)unint64_t j = *(void *)&j[-a3];
        *(void *)&j[-a3] = v11;
      }
      if (a6)
      {
        if (++v14 > a6)
        {
          char v22 = 0;
          return v22 & 1;
        }
      }
    }
  }
  char v22 = 1;
  return v22 & 1;
}

uint64_t med3(uint64_t a1, uint64_t a2, uint64_t a3, int (*a4)(uint64_t, uint64_t))
{
  if (a4(a1, a2) >= 0)
  {
    if (a4(a2, a3) > 0) {
      return a2;
    }
    if (a4(a1, a3) >= 0) {
      return a3;
    }
    else {
      return a1;
    }
  }
  else
  {
    if (a4(a2, a3) < 0) {
      return a2;
    }
    if (a4(a1, a3) >= 0) {
      return a1;
    }
    else {
      return a3;
    }
  }
}

char *swapfunc(char *result, char *a2, unint64_t a3, int a4, int a5)
{
  if (a4 > 1)
  {
    if (a5 > 1)
    {
      unint64_t v14 = a3;
      int v13 = result;
      int v12 = a2;
      do
      {
        char v11 = *v13;
        BOOL v9 = v13++;
        *BOOL v9 = *v12;
        int v10 = v12++;
        *int v10 = v11;
        --v14;
      }
      while (v14);
    }
    else
    {
      unint64_t v18 = a3 / 4;
      int v17 = (int *)result;
      uint64_t v16 = (int *)a2;
      do
      {
        int v15 = *v17;
        unint64_t v7 = v17++;
        *unint64_t v7 = *v16;
        unint64_t v8 = v16++;
        *unint64_t v8 = v15;
        --v18;
      }
      while (v18);
    }
  }
  else
  {
    unint64_t v22 = a3 / 8;
    unint64_t v21 = (uint64_t *)result;
    uint64_t v20 = (uint64_t *)a2;
    do
    {
      uint64_t v19 = *v21;
      int v5 = v21++;
      *int v5 = *v20;
      int v6 = v20++;
      *int v6 = v19;
      --v22;
    }
    while (v22);
  }
  return result;
}

void qsort_r(void *__base, size_t __nel, size_t __width, void *a4, int (__cdecl *__compar)(void *, const void *, const void *))
{
  int v5 = flsl(__nel);
  _qsort_0((unint64_t)__base, __nel, __width, (uint64_t)a4, (int (*)(uint64_t, char *, char *))__compar, 2 * (v5 - 1));
}

uint64_t _qsort_0(unint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, int (*a5)(uint64_t, char *, char *), unsigned int a6)
{
  int v24 = 0;
  while (1)
  {
    if (a1 % 8 || a3 % 8) {
      int v13 = 2;
    }
    else {
      int v13 = a3 != 8;
    }
    if (a1 % 4 || a3 % 4) {
      int v12 = 2;
    }
    else {
      int v12 = a3 != 4;
    }
    int v23 = 0;
    int v6 = a6--;
    if (v6 <= 0) {
      return __heapsort_r((unsigned char *)a1, a2, a3, a4, a5);
    }
    if (a2 <= 7) {
      break;
    }
    uint64_t v30 = a1;
    uint64_t v29 = a1 + a2 / 2 * a3;
    uint64_t v27 = a1 + (a2 - 1) * a3;
    if (a2 > 0x28)
    {
      unint64_t v22 = a2 / 8 * a3;
      uint64_t v30 = med3_0(a1, a1 + v22, a1 + 2 * v22, (int (*)(uint64_t, uint64_t, uint64_t))a5, a4);
      uint64_t v29 = med3_0(v29 - v22, v29, v29 + v22, (int (*)(uint64_t, uint64_t, uint64_t))a5, a4);
      uint64_t v27 = med3_0(v27 - 2 * v22, v27 - v22, v27, (int (*)(uint64_t, uint64_t, uint64_t))a5, a4);
    }
    uint64_t result = med3_0(v30, v29, v27, (int (*)(uint64_t, uint64_t, uint64_t))a5, a4);
    if (v13)
    {
      if (v12)
      {
        uint64_t result = (uint64_t)swapfunc((char *)a1, (char *)result, a3, v13, v12);
      }
      else
      {
        int v20 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)result;
        *(_DWORD *)uint64_t result = v20;
      }
    }
    else
    {
      uint64_t v21 = *(void *)a1;
      *(void *)a1 = *(void *)result;
      *(void *)uint64_t result = v21;
    }
    BOOL v33 = (char *)(a1 + a3);
    int v34 = (char *)(a1 + a3);
    sigset_t v31 = (char *)(a1 + (a2 - 1) * a3);
    for (size_t i = v31; ; i -= a3)
    {
      while (1)
      {
        BOOL v11 = 0;
        if (v33 <= i)
        {
          uint64_t result = ((uint64_t (*)(uint64_t, char *, unint64_t))a5)(a4, v33, a1);
          int v24 = result;
          BOOL v11 = (int)result <= 0;
        }
        if (!v11) {
          break;
        }
        if (!v24)
        {
          int v23 = 1;
          if (v13)
          {
            if (v12)
            {
              uint64_t result = (uint64_t)swapfunc(v34, v33, a3, v13, v12);
            }
            else
            {
              int v18 = *(_DWORD *)v34;
              *(_DWORD *)int v34 = *(_DWORD *)v33;
              *(_DWORD *)BOOL v33 = v18;
            }
          }
          else
          {
            uint64_t v19 = *(void *)v34;
            *(void *)int v34 = *(void *)v33;
            *(void *)BOOL v33 = v19;
          }
          v34 += a3;
        }
        v33 += a3;
      }
      while (1)
      {
        BOOL v10 = 0;
        if (v33 <= i)
        {
          uint64_t result = ((uint64_t (*)(uint64_t, char *, unint64_t))a5)(a4, i, a1);
          int v24 = result;
          BOOL v10 = (int)result >= 0;
        }
        if (!v10) {
          break;
        }
        if (!v24)
        {
          int v23 = 1;
          if (v13)
          {
            if (v12)
            {
              uint64_t result = (uint64_t)swapfunc(i, v31, a3, v13, v12);
            }
            else
            {
              int v16 = *(_DWORD *)i;
              *(_DWORD *)size_t i = *(_DWORD *)v31;
              *(_DWORD *)sigset_t v31 = v16;
            }
          }
          else
          {
            uint64_t v17 = *(void *)i;
            *(void *)size_t i = *(void *)v31;
            *(void *)sigset_t v31 = v17;
          }
          v31 -= a3;
        }
        i -= a3;
      }
      if (v33 > i) {
        break;
      }
      if (v13)
      {
        if (v12)
        {
          uint64_t result = (uint64_t)swapfunc(v33, i, a3, v13, v12);
        }
        else
        {
          int v14 = *(_DWORD *)v33;
          *(_DWORD *)BOOL v33 = *(_DWORD *)i;
          *(_DWORD *)size_t i = v14;
        }
      }
      else
      {
        uint64_t v15 = *(void *)v33;
        *(void *)BOOL v33 = *(void *)i;
        *(void *)size_t i = v15;
      }
      int v23 = 1;
      v33 += a3;
    }
    unint64_t v28 = a1 + a2 * a3;
    if ((uint64_t)&v34[-a1] >= v33 - v34) {
      unint64_t v9 = v33 - v34;
    }
    else {
      unint64_t v9 = (unint64_t)&v34[-a1];
    }
    if (v9) {
      uint64_t result = (uint64_t)swapfunc((char *)a1, &v33[-v9], v9, v13, v12);
    }
    if (v31 - i >= v28 - (void)v31 - a3) {
      unint64_t v8 = v28 - (void)v31 - a3;
    }
    else {
      unint64_t v8 = v31 - i;
    }
    if (v8) {
      uint64_t result = (uint64_t)swapfunc(v33, (char *)(v28 - v8), v8, v13, v12);
    }
    if (!v23)
    {
      uint64_t result = _isort_0(a1, a2, a3, a4, a5, (a2 / 4) + 1, v13, v12);
      if (result) {
        return result;
      }
    }
    unint64_t v26 = v33 - v34;
    unint64_t v25 = v31 - i;
    if (v33 - v34 > (unint64_t)(v31 - i))
    {
      if (v25 > a3) {
        uint64_t result = _qsort_0(v28 - v25, v25 / a3, a3, a4, a5, a6);
      }
      if (v26 <= a3) {
        return result;
      }
      a2 = v26 / a3;
    }
    else
    {
      if (v26 > a3) {
        uint64_t result = _qsort_0(a1, v26 / a3, a3, a4, a5, a6);
      }
      if (v25 <= a3) {
        return result;
      }
      a1 = v28 - v25;
      a2 = v25 / a3;
    }
  }
  return _isort_0(a1, a2, a3, a4, a5, 0, v13, v12);
}

uint64_t _isort_0(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int (*a5)(uint64_t, char *, char *), int a6, int a7, int a8)
{
  int v14 = 0;
  for (size_t i = (char *)(a1 + a3); (unint64_t)i < a1 + a2 * a3; i += a3)
  {
    for (unint64_t j = i; ; j -= a3)
    {
      BOOL v9 = 0;
      if ((unint64_t)j > a1) {
        BOOL v9 = a5(a4, &j[-a3], j) > 0;
      }
      if (!v9) {
        break;
      }
      if (a7)
      {
        if (a8)
        {
          swapfunc(j, &j[-a3], a3, a7, a8);
        }
        else
        {
          int v10 = *(_DWORD *)j;
          *(_DWORD *)unint64_t j = *(_DWORD *)&j[-a3];
          *(_DWORD *)&j[-a3] = v10;
        }
      }
      else
      {
        uint64_t v11 = *(void *)j;
        *(void *)unint64_t j = *(void *)&j[-a3];
        *(void *)&j[-a3] = v11;
      }
      if (a6)
      {
        if (++v14 > a6)
        {
          char v23 = 0;
          return v23 & 1;
        }
      }
    }
  }
  char v23 = 1;
  return v23 & 1;
}

uint64_t med3_0(uint64_t a1, uint64_t a2, uint64_t a3, int (*a4)(uint64_t, uint64_t, uint64_t), uint64_t a5)
{
  if (a4(a5, a1, a2) >= 0)
  {
    if (a4(a5, a2, a3) > 0) {
      return a2;
    }
    if (a4(a5, a1, a3) >= 0) {
      return a3;
    }
    else {
      return a1;
    }
  }
  else
  {
    if (a4(a5, a2, a3) < 0) {
      return a2;
    }
    if (a4(a5, a1, a3) >= 0) {
      return a1;
    }
    else {
      return a3;
    }
  }
}

int radixsort(const unsigned __int8 **__base, int __nel, const unsigned __int8 *__table, unsigned int __endbyte)
{
  if (!__table)
  {
    for (unsigned int i = 0; i < __endbyte; ++i)
      v9[i] = i + 1;
    v9[i] = 0;
    for (int j = i + 1; j < 256; ++j)
      v9[j] = j;
    r_sort_a((uint64_t)__base, __nel, 0, (uint64_t)v9, 0);
    return 0;
  }
  unsigned int v7 = __table[__endbyte];
  if (!__table[__endbyte] || v7 == 255)
  {
    r_sort_a((uint64_t)__base, __nel, 0, (uint64_t)__table, v7);
    return 0;
  }
  *__error() = 22;
  return -1;
}

uint64_t r_sort_a(uint64_t a1, int a2, int a3, uint64_t a4, unsigned int a5)
{
  bzero(v42, 0x200uLL);
  uint64_t result = pthread_once(&r_sort_count_control, (void (*)(void))r_sort_count_allocate);
  if (!result)
  {
    r_sort_a_count = r_sort_a_count;
    uint64_t v43 = a1;
    int v44 = a2;
    uint64_t v21 = &v46;
    int v45 = a3;
    while (&v43 < v21)
    {
      v21 -= 2;
      int v34 = (uint64_t *)*v21;
      int v32 = *((_DWORD *)v21 + 2);
      unsigned int v30 = *((_DWORD *)v21 + 3);
      if (v32 >= 20)
      {
        unint64_t v15 = (unint64_t)&v34[v32];
        if (r_sort_a_nc) {
          goto LABEL_29;
        }
        r_sort_a_bmisigned int n = 255;
        char v23 = v34;
        while ((unint64_t)v23 < v15)
        {
          int v6 = v23++;
          int v25 = *(unsigned __int8 *)(a4 + *(unsigned __int8 *)(*v6 + (int)v30));
          unsigned int v7 = (int *)(r_sort_a_count + 4 * *(unsigned __int8 *)(a4 + *(unsigned __int8 *)(*v6 + (int)v30)));
          int v8 = *v7 + 1;
          *unsigned int v7 = v8;
          if (v8 == 1 && v25 != a5)
          {
            if (v25 < r_sort_a_bmin) {
              r_sort_a_bmisigned int n = v25;
            }
            ++r_sort_a_nc;
          }
        }
        if (&v21[2 * r_sort_a_nc] <= &v47)
        {
LABEL_29:
          if (r_sort_a_nc == 1 && *(_DWORD *)(r_sort_a_count + 4 * r_sort_a_bmin) == v32)
          {
            *uint64_t v21 = (uint64_t)v34;
            *((_DWORD *)v21 + 2) = v32;
            BOOL v9 = v21;
            v21 += 2;
            *((_DWORD *)v9 + 3) = v30 + 1;
            *(_DWORD *)(r_sort_a_count + 4 * r_sort_a_bmin) = 0;
            r_sort_a_nc = 0;
          }
          else
          {
            uint64_t v19 = v21;
            int v20 = (long long *)v21;
            int v16 = 2;
            if (a5)
            {
              int v24 = v34;
              v42[255] = &v34[v32];
            }
            else
            {
              int v24 = &v34[*(int *)r_sort_a_count];
              v42[0] = v24;
            }
            uint64_t v17 = (int *)(r_sort_a_count + 4 * r_sort_a_bmin);
            while (r_sort_a_nc > 0)
            {
              while (!*v17)
                ++v17;
              if (*v17 > 1)
              {
                if (*v17 > v16)
                {
                  int v16 = *v17;
                  uint64_t v19 = v21;
                }
                *uint64_t v21 = (uint64_t)v24;
                *((_DWORD *)v21 + 2) = *v17;
                int v10 = v21;
                v21 += 2;
                *((_DWORD *)v10 + 3) = v30 + 1;
              }
              v24 += *v17;
              v42[((uint64_t)v17 - r_sort_a_count) / 4] = v24;
              --r_sort_a_nc;
              ++v17;
            }
            long long v18 = *v20;
            long long *v20 = *(_OWORD *)v19;
            *(_OWORD *)uint64_t v19 = v18;
            int v13 = v34;
            while ((unint64_t)v13 < v15)
            {
              for (uint64_t i = *v13; ; uint64_t i = v14)
              {
                int v26 = *(unsigned __int8 *)(a4 + *(unsigned __int8 *)(i + (int)v30));
                uint64_t v11 = (uint64_t **)&v42[*(unsigned __int8 *)(a4 + *(unsigned __int8 *)(i + (int)v30))];
                int v12 = *v11 - 1;
                *uint64_t v11 = v12;
                if (v13 >= v12) {
                  break;
                }
                uint64_t v14 = *v12;
                *int v12 = i;
              }
              *int v13 = i;
              v13 += *(int *)(r_sort_a_count + 4 * v26);
              *(_DWORD *)(r_sort_a_count + 4 * v26) = 0;
            }
          }
        }
        else
        {
          uint64_t result = r_sort_a(v34, v32, v30, a4, a5);
        }
      }
      else
      {
        int v41 = *((_DWORD *)v21 + 2);
        for (int j = v34 + 1; --v41 >= 1; ++j)
        {
          for (int k = j; k > v34; --k)
          {
            size_t v36 = (unsigned __int8 *)(*k + (int)v30);
            for (int m = (unsigned __int8 *)(*(k - 1) + (int)v30); ; ++m)
            {
              unsigned __int8 v40 = *(unsigned char *)(a4 + *v36);
              if (v40 == a5 || v40 != *(unsigned __int8 *)(a4 + *m)) {
                break;
              }
              ++v36;
            }
            if (v40 >= (int)*(unsigned __int8 *)(a4 + *m)) {
              break;
            }
            uint64_t v37 = *k;
            *int k = *(k - 1);
            *(k - 1) = v37;
          }
        }
      }
    }
  }
  return result;
}

int sradixsort(const unsigned __int8 **__base, int __nel, const unsigned __int8 *__table, unsigned int __endbyte)
{
  if (__table)
  {
    unsigned int v9 = __table[__endbyte];
    int v8 = __table;
    if (__table[__endbyte] && v9 != 255)
    {
      *__error() = 22;
      return -1;
    }
  }
  else
  {
    int v8 = v20;
    for (unsigned int i = 0; i < __endbyte; ++i)
      v20[i] = i + 1;
    v20[i] = 0;
    for (int j = i + 1; j < 256; ++j)
      v20[j] = j;
    unsigned int v9 = 0;
  }
  if (__nel < 20)
  {
    int v19 = __nel;
    for (int k = __base + 1; --v19 >= 1; ++k)
    {
      for (int m = (unsigned __int8 **)k; m > (unsigned __int8 **)__base; --m)
      {
        uint64_t v14 = *m;
        for (signed int n = *(m - 1); ; ++n)
        {
          unsigned __int8 v18 = v8[*v14];
          if (v18 == v9 || v18 != v8[*n]) {
            break;
          }
          ++v14;
        }
        if (v18 >= (int)v8[*n]) {
          break;
        }
        unint64_t v15 = *m;
        *int m = *(m - 1);
        *(m - 1) = v15;
      }
    }
    return 0;
  }
  unsigned int v7 = (void *)malloc_type_malloc();
  if (v7)
  {
    r_sort_b((uint64_t)__base, (unint64_t)v7, __nel, 0, (uint64_t)v8, v9);
    free(v7);
    return 0;
  }
  return -1;
}

uint64_t r_sort_b(uint64_t a1, unint64_t a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  bzero(v42, 0x200uLL);
  uint64_t result = pthread_once(&r_sort_count_control, (void (*)(void))r_sort_count_allocate);
  if (!result)
  {
    r_sort_b_count = r_sort_b_count;
    uint64_t v43 = a1;
    int v44 = a3;
    unsigned __int8 v18 = (unint64_t *)&v46;
    int v45 = a4;
    while (&v43 < (uint64_t *)v18)
    {
      v18 -= 2;
      unint64_t v34 = *v18;
      int v31 = *((_DWORD *)v18 + 2);
      unsigned int v29 = *((_DWORD *)v18 + 3);
      if (v31 >= 20)
      {
        if (r_sort_b_nc) {
          goto LABEL_28;
        }
        r_sort_b_bmisigned int n = 255;
        int v20 = (void *)(v34 + 8 * v31);
        while ((unint64_t)--v20 >= v34)
        {
          int v24 = *(unsigned __int8 *)(a5 + *(unsigned __int8 *)(*v20 + (int)v29));
          unsigned int v7 = (int *)(r_sort_b_count + 4 * *(unsigned __int8 *)(a5 + *(unsigned __int8 *)(*v20 + (int)v29)));
          int v8 = *v7 + 1;
          *unsigned int v7 = v8;
          if (v8 == 1 && v24 != a6)
          {
            if (v24 < r_sort_b_bmin) {
              r_sort_b_bmisigned int n = v24;
            }
            ++r_sort_b_nc;
          }
        }
        if (&v18[2 * r_sort_b_nc] <= (unint64_t *)&v47)
        {
LABEL_28:
          int v16 = v18;
          uint64_t v17 = v18;
          int v13 = 2;
          if (a6)
          {
            unint64_t v21 = v34;
            v42[255] = v34 + 8 * v31;
            *(_DWORD *)(r_sort_b_count + 1020) = 0;
          }
          else
          {
            unint64_t v21 = v34 + 8 * *(int *)r_sort_b_count;
            v42[0] = v21;
            *(_DWORD *)r_sort_b_count = 0;
          }
          uint64_t v14 = (int *)(r_sort_b_count + 4 * r_sort_b_bmin);
          while (r_sort_b_nc > 0)
          {
            while (!*v14)
              ++v14;
            int v25 = *v14;
            if (*v14 > 1)
            {
              if (v25 > v13)
              {
                int v13 = *v14;
                int v16 = v18;
              }
              *unsigned __int8 v18 = v21;
              *((_DWORD *)v18 + 2) = v25;
              unsigned int v9 = v18;
              v18 += 2;
              *((_DWORD *)v9 + 3) = v29 + 1;
            }
            v21 += 8 * v25;
            v42[((uint64_t)v14 - r_sort_b_count) / 4] = v21;
            *uint64_t v14 = 0;
            --r_sort_b_nc;
            ++v14;
          }
          long long v15 = *(_OWORD *)v17;
          *(_OWORD *)uint64_t v17 = *(_OWORD *)v16;
          *(_OWORD *)int v16 = v15;
          unint64_t v22 = (void *)(a2 + 8 * v31);
          int v19 = (void *)(v34 + 8 * v31);
          while ((unint64_t)v22 > a2)
            *--unint64_t v22 = *--v19;
          char v23 = (uint64_t *)(a2 + 8 * v31);
          while ((unint64_t)--v23 >= a2)
          {
            uint64_t v10 = *v23;
            uint64_t v11 = &v42[*(unsigned __int8 *)(a5 + *(unsigned __int8 *)(*v23 + (int)v29))];
            int v12 = (void *)(*v11 - 8);
            *uint64_t v11 = v12;
            *int v12 = v10;
          }
        }
        else
        {
          uint64_t result = r_sort_b(v34, a2, v31, v29, a5, a6);
        }
      }
      else
      {
        int v41 = *((_DWORD *)v18 + 2);
        for (unsigned int i = (uint64_t *)(v34 + 8); --v41 >= 1; ++i)
        {
          for (int j = i; (unint64_t)j > v34; --j)
          {
            size_t v36 = (unsigned __int8 *)(*j + (int)v29);
            for (int k = (unsigned __int8 *)(*(j - 1) + (int)v29); ; ++k)
            {
              unsigned __int8 v40 = *(unsigned char *)(a5 + *v36);
              if (v40 == a6 || v40 != *(unsigned __int8 *)(a5 + *k)) {
                break;
              }
              ++v36;
            }
            if (v40 >= (int)*(unsigned __int8 *)(a5 + *k)) {
              break;
            }
            uint64_t v37 = *j;
            uint64_t *j = *(j - 1);
            *(j - 1) = v37;
          }
        }
      }
    }
  }
  return result;
}

uint64_t r_sort_count_allocate()
{
  r_sort_a_count = malloc_type_calloc();
  uint64_t result = malloc_type_calloc();
  r_sort_b_count = result;
  return result;
}

int rand_r(unsigned int *a1)
{
  int v3 = a1;
  unint64_t v2 = 0;
  unint64_t v2 = *a1;
  int result = do_rand(&v2);
  *int v3 = v2;
  return result;
}

unint64_t do_rand(unint64_t *a1)
{
  if (!*a1) {
    *a1 = 123459876;
  }
  int64_t v2 = 16807 * (*a1 % 0x1F31D) - 2836 * (*a1 / 0x1F31D);
  unint64_t v3 = v2 + (v2 < 0 ? 0x7FFFFFFFuLL : 0);
  *a1 = v3;
  return v3 % 0x80000000;
}

int rand(void)
{
  return do_rand((unint64_t *)&next);
}

void srand(unsigned int a1)
{
  next = a1;
}

void sranddev(void)
{
  BOOL v2 = 0;
  int v3 = open_NOCANCEL();
  if (v3 >= 0)
  {
    BOOL v2 = read_NOCANCEL() == 8;
    close_NOCANCEL();
  }
  if (!v2)
  {
    v1.time_t tv_sec = 0;
    *(void *)&v1.tv_usec = 0;
    gettimeofday(&v1, 0);
    pid_t v0 = getpid();
    srand((v0 << 16) ^ LODWORD(v1.tv_sec) ^ v1.tv_usec);
  }
}

void srandom(unsigned int a1)
{
  *state = a1;
  if (rand_type)
  {
    for (int i = 1; i < rand_deg; ++i)
      state[i] = good_rand(state[i - 1]);
    fptsize_t r = &state[rand_sep];
    rptsize_t r = state;
    int v1 = 10 * rand_deg;
  }
  else
  {
    int v1 = 50;
  }
  for (int j = 0; j < v1; ++j)
    random();
}

uint64_t good_rand(int a1)
{
  int v2 = a1;
  if (!a1) {
    int v2 = 123459876;
  }
  int v3 = 16807 * (v2 % 127773) - 2836 * (v2 / 127773);
  return v3 + (v3 < 0 ? 0x7FFFFFFF : 0);
}

uint64_t random(void)
{
  if (rand_type)
  {
    int v3 = fptr;
    int v1 = rptr;
    *(_DWORD *)fptr += *rptr;
    unsigned int v5 = (*v3 >> 1) & 0x7FFFFFFF;
    int v4 = v3 + 1;
    if (v4 < (int *)end_ptr)
    {
      int v2 = v1 + 1;
      if (v2 >= (int *)end_ptr) {
        int v2 = state;
      }
    }
    else
    {
      int v4 = state;
      int v2 = v1 + 1;
    }
    fptsize_t r = v4;
    rptsize_t r = v2;
  }
  else
  {
    unsigned int v5 = good_rand(*state) & 0x7FFFFFFF;
    *state = v5;
  }
  return v5;
}

void srandomdev(void)
{
  int v4 = 0;
  BOOL v3 = 0;
  uint64_t v2 = 0;
  if (rand_type) {
    uint64_t v2 = 4 * rand_deg;
  }
  else {
    uint64_t v2 = 4;
  }
  BOOL v3 = 0;
  int v4 = open_NOCANCEL();
  if (v4 >= 0)
  {
    BOOL v3 = read_NOCANCEL() == v2;
    close_NOCANCEL();
  }
  if (v3)
  {
    if (rand_type)
    {
      fptsize_t r = &state[rand_sep];
      rptsize_t r = state;
    }
  }
  else
  {
    v1.time_t tv_sec = 0;
    *(void *)&v1.tv_usec = 0;
    gettimeofday(&v1, 0);
    pid_t v0 = getpid();
    srandom((v0 << 16) ^ LODWORD(v1.tv_sec) ^ v1.tv_usec);
  }
}

char *__cdecl initstate(unsigned int a1, char *a2, size_t a3)
{
  unsigned int v5 = (char *)(state - 1);
  if (rand_type) {
    *(state - 1) = 5 * (rptr - state) + rand_type;
  }
  else {
    *(state - 1) = 0;
  }
  if (a3 >= 8)
  {
    if (a3 >= 0x20)
    {
      if (a3 >= 0x40)
      {
        if (a3 >= 0x80)
        {
          if (a3 >= 0x100)
          {
            rand_type = 4;
            rand_deg = 63;
            rand_sep = 1;
          }
          else
          {
            rand_type = 3;
            rand_deg = 31;
            rand_sep = 3;
          }
        }
        else
        {
          rand_type = 2;
          rand_deg = 15;
          rand_sep = 1;
        }
      }
      else
      {
        rand_type = 1;
        rand_deg = 7;
        rand_sep = 3;
      }
    }
    else
    {
      rand_type = 0;
      rand_deg = 0;
      rand_sep = 0;
    }
    state = (int *)(a2 + 4);
    end_ptsize_t r = &a2[4 * rand_deg + 4];
    srandom(a1);
    if (rand_type) {
      *(_DWORD *)a2 = 5 * (rptr - state) + rand_type;
    }
    else {
      *(_DWORD *)a2 = 0;
    }
    return v5;
  }
  else
  {
    fprintf(__stderrp, "random: not enough state (%ld bytes); ignored.\n", a3);
    return 0;
  }
}

char *__cdecl setstate(const char *a1)
{
  unsigned int v4 = *(_DWORD *)a1 % 5u;
  unsigned int v3 = *(_DWORD *)a1 / 5u;
  uint64_t v2 = (char *)(state - 1);
  if (rand_type) {
    *(state - 1) = 5 * (rptr - state) + rand_type;
  }
  else {
    *(state - 1) = 0;
  }
  if (v4 > 4)
  {
    fprintf(__stderrp, "random: state info corrupted; not changed.\n");
  }
  else
  {
    rand_type = v4;
    rand_deg = degrees[v4];
    rand_sep = seps[v4];
  }
  state = (int *)(a1 + 4);
  if (rand_type)
  {
    rptsize_t r = &state[v3];
    fptsize_t r = &state[(v3 + rand_sep) % rand_deg];
  }
  end_ptsize_t r = &state[rand_deg];
  return v2;
}

char *__cdecl realpath(const char *a1, char *a2)
{
  int v25 = a1;
  int v24 = a2;
  bzero(v32, 0x200uLL);
  memset(&__b, 0, sizeof(__b));
  BOOL v14 = 0;
  dev_t v12 = 0;
  bzero(&v28, 0x200uLL);
  __darwin_ino64_t st_ino = 0;
  if (!v25)
  {
    *__error() = 22;
    return 0;
  }
  if (!*v25)
  {
    *__error() = 2;
    return 0;
  }
  if (v24)
  {
    mbstate_t __dst = v24;
  }
  else
  {
    mbstate_t __dst = (char *)malloc_type_malloc();
    if (!__dst) {
      return 0;
    }
  }
  if (!realpath_rootdev_inited)
  {
    realpath_rootdev_int inited = 1;
    if (stat("/", &__b) < 0) {
      goto LABEL_12;
    }
    realpath_rootdev = __b.st_dev;
  }
  __error();
  unsigned int v16 = 0;
  if (*v25 == 47)
  {
    char *__dst = 47;
    __dst[1] = 0;
    if (!v25[1]) {
      return __dst;
    }
    size_t v18 = 1;
    size_t v19 = strlcpy(v31, v25 + 1, 0x400uLL);
  }
  else
  {
    if (!__private_getcwd(__dst, 1024, 0))
    {
      strlcpy(__dst, ".", 0x400uLL);
      goto LABEL_12;
    }
    size_t v18 = strlen(__dst);
    size_t v19 = strlcpy(v31, v25, 0x400uLL);
  }
  if (v19 < 0x400 && v18 < 0x400)
  {
    if (v18 > 1)
    {
      if (stat(__dst, &__b) >= 0)
      {
        dev_t st_dev = __b.st_dev;
        goto LABEL_30;
      }
      goto LABEL_12;
    }
    dev_t st_dev = realpath_rootdev;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            do
            {
LABEL_30:
              if (!v19)
              {
                if (v18 > 1 && __dst[v18 - 1] == 47) {
                  __dst[v18 - 1] = 0;
                }
                return __dst;
              }
              unint64_t v22 = strchr(v31, 47);
              if (v22) {
                size_t v5 = v22 - v31;
              }
              else {
                size_t v5 = v19;
              }
              memcpy(v30, v31, v5);
              v30[v5] = 0;
              if (v22)
              {
                v19 -= v5 + 1;
                memmove(v31, v22 + 1, v19 + 1);
              }
              else
              {
                v31[0] = 0;
                size_t v19 = 0;
              }
              if (__dst[v18 - 1] != 47)
              {
                if (v18 + 1 >= 0x400) {
                  goto LABEL_93;
                }
                size_t v2 = v18++;
                __dst[v2] = 47;
                __dst[v18] = 0;
              }
            }
            while (!v30[0] || !strcmp(v30, "."));
            if (strcmp(v30, "..")) {
              break;
            }
            if (v18 > 1)
            {
              __dst[v18 - 1] = 0;
              int v20 = strrchr(__dst, 47) + 1;
              char *v20 = 0;
              size_t v18 = v20 - __dst;
            }
          }
          size_t v17 = v18;
          size_t v18 = strlcat(__dst, v30, 0x400uLL);
          if (v18 >= 0x400) {
            goto LABEL_93;
          }
          if (getattrlist(__dst, &_rp_alist, v32, 0x41CuLL, 1u))
          {
            if (*__error() == 45 || *__error() == 22)
            {
              int v15 = lstat(__dst, &__b);
              if (!v15)
              {
                BOOL v14 = (__b.st_mode & 0xF000) == 40960;
                dev_t v12 = __b.st_dev;
                __darwin_ino64_t st_ino = __b.st_ino;
              }
            }
            else
            {
              int v15 = -1;
            }
          }
          else
          {
            int v15 = 1;
            BOOL v14 = v33[3] == 5;
            dev_t v12 = v33[2];
            __darwin_ino64_t st_ino = v33[4];
          }
          if (v15 < 0) {
            goto LABEL_12;
          }
          if (v12 == st_dev) {
            break;
          }
          dev_t st_dev = v12;
          if (statfs(__dst, &v28) || lstat(v28.f_mntonname, &__b) || v12 != __b.st_dev || st_ino != __b.st_ino) {
            break;
          }
          int v6 = 1;
          strcpy(__s, v28.f_mntonname);
          do
          {
            unsigned int v7 = strrchr(__s, 47);
            if (!v7)
            {
              int v6 = 0;
              goto LABEL_70;
            }
            if (v7 <= __s) {
              goto LABEL_70;
            }
            *unsigned int v7 = 0;
          }
          while (lstat(__s, &__b) >= 0 && (__b.st_mode & 0xF000) == 0x4000);
          int v6 = 0;
LABEL_70:
          if (!v6) {
            break;
          }
          size_t v18 = strlcpy(__dst, v28.f_mntonname, 0x400uLL);
        }
        if (v14) {
          break;
        }
        if (v15)
        {
          __dst[v17] = 0;
          size_t v18 = strlcat(__dst, (const char *)v33 + v33[0], 0x400uLL);
          if (v18 >= 0x400) {
            goto LABEL_93;
          }
        }
      }
      unsigned int v3 = v16++;
      if (v3 > 0x20)
      {
        *__error() = 62;
        goto LABEL_12;
      }
      ssize_t v13 = readlink(__dst, __source, 0x400uLL);
      if (v13 <= 0 || (unint64_t)v13 >= 0x400) {
        break;
      }
      __source[v13] = 0;
      if (__source[0] == 47)
      {
        __dst[1] = 0;
        size_t v18 = 1;
        dev_t st_dev = realpath_rootdev;
      }
      else
      {
        unint64_t v21 = strrchr(__dst, 47) + 1;
        *unint64_t v21 = 0;
        size_t v18 = v21 - __dst;
      }
      if (v22)
      {
        if (__source[v13 - 1] != 47)
        {
          if ((unint64_t)(v13 + 1) >= 0x400) {
            goto LABEL_93;
          }
          __source[v13] = 47;
          __source[v13 + 1] = 0;
        }
        if (strlcat(__source, v31, 0x400uLL) >= 0x400) {
          goto LABEL_93;
        }
      }
      size_t v19 = strlcpy(v31, __source, 0x400uLL);
    }
    if (v13 < 0) {
      goto LABEL_12;
    }
    if (!v13)
    {
      *__error() = 2;
      goto LABEL_12;
    }
  }
LABEL_93:
  *__error() = 63;
LABEL_12:
  if (!v24)
  {
    int v8 = *__error();
    free(__dst);
    *__error() = v8;
  }
  return 0;
}

void remque(void *a1)
{
  size_t v2 = (void *)*((void *)a1 + 1);
  uint64_t v1 = *(void *)a1;
  if (v2) {
    *size_t v2 = v1;
  }
  if (v1) {
    *(void *)(v1 + 8) = v2;
  }
}

uint64_t _do_nothing()
{
  return 0;
}

uint64_t _owned_ptr_add(uint64_t a1, unint64_t a2)
{
  uint64_t v6 = a1;
  unint64_t v5 = a2;
  int v4 = 0;
  uint64_t result = _owned_ptr_search(a1, a2, &v4);
  if (result)
  {
    if (*(_DWORD *)(v6 + 8) >= *(_DWORD *)(v6 + 12))
    {
      int v3 = 2 * *(_DWORD *)(v6 + 12);
      uint64_t result = malloc_type_realloc();
      if (!result) {
        return result;
      }
      *(void *)uint64_t v6 = result;
      *(_DWORD *)(v6 + 12) = v3;
    }
    uint64_t result = (uint64_t)memmove((void *)(*(void *)v6 + 8 * v4 + 16), (const void *)(*(void *)v6 + 8 * v4 + 8), 8 * (*(_DWORD *)(v6 + 8) - v4 - 1));
    *(void *)(*(void *)v6 + 8 * (v4 + 1)) = v5;
    ++*(_DWORD *)(v6 + 8);
  }
  return result;
}

uint64_t _owned_ptr_search(uint64_t a1, unint64_t a2, int *a3)
{
  int v6 = 0;
  int v5 = *(_DWORD *)(a1 + 8) - 1;
  if (*(void *)(*(void *)a1 + 8 * v5) >= a2)
  {
    if (*(void *)(*(void *)a1 + 8 * v5) == a2)
    {
      if (a3) {
        *a3 = v5;
      }
      return 0;
    }
    else
    {
      while (v5 - v6 > 1)
      {
        int v4 = (v6 + v5) / 2;
        if (a2 <= *(void *)(*(void *)a1 + 8 * v4))
        {
          if (a2 >= *(void *)(*(void *)a1 + 8 * v4))
          {
            if (a3) {
              *a3 = v4;
            }
            return 0;
          }
          int v5 = (v6 + v5) / 2;
        }
        else
        {
          int v6 = (v6 + v5) / 2;
        }
      }
      if (a3) {
        *a3 = v6;
      }
      return -1;
    }
  }
  else
  {
    if (a3) {
      *a3 = v5;
    }
    return -1;
  }
}

_DWORD *_owned_ptr_alloc()
{
  size_t v2 = (_DWORD *)malloc_type_malloc();
  if (!v2) {
    return 0;
  }
  *(void *)size_t v2 = malloc_type_malloc();
  if (*(void *)v2)
  {
    **(void **)size_t v2 = 0;
    void v2[2] = 1;
    v2[3] = 8;
    return v2;
  }
  else
  {
    int v1 = *__error();
    free(v2);
    *__error() = v1;
    return 0;
  }
}

_DWORD *_owned_ptr_delete(_DWORD *result, int a2)
{
  size_t v2 = result;
  if (a2)
  {
    if (a2 < result[2])
    {
      uint64_t result = memmove((void *)(*(void *)result + 8 * a2), (const void *)(*(void *)result + 8 * a2 + 8), 8 * (result[2] - a2 - 1));
      --v2[2];
    }
  }
  return result;
}

void _owned_ptr_free(void **a1)
{
}

uint64_t __init__env_owned_locked(int a1)
{
  int v2 = 0;
  if (__env_owned)
  {
    return 0;
  }
  else
  {
    if (!a1) {
      int v2 = *__error();
    }
    __env_owned = (uint64_t)_owned_ptr_alloc();
    if (__env_owned)
    {
      return 0;
    }
    else
    {
      if (!a1) {
        *__error() = v2;
      }
      return -1;
    }
  }
}

uint64_t __setenv_locked(char *a1, const char *a2, int a3, int a4, char ***a5, _DWORD *a6)
{
  BOOL v33 = a1;
  int v32 = a2;
  int v31 = a3;
  int v30 = a4;
  unsigned int v29 = (const void **)a5;
  statfs v28 = a6;
  int i = 0;
  int v26 = 0;
  int v25 = 0;
  int i = __findenv_locked(a1, &v26, *a5);
  if (!i)
  {
    size_t v17 = *v29;
    int v20 = 0;
    while (*v17)
    {
      ++v17;
      ++v20;
    }
    if (_owned_ptr_search((uint64_t)v28, (unint64_t)*v29, &v25))
    {
      size_t v19 = (void *)malloc_type_malloc();
      if (!v19) {
        return -1;
      }
      _owned_ptr_add((uint64_t)v28, (unint64_t)v19);
      bcopy(*v29, v19, 8 * v20);
      *unsigned int v29 = v19;
    }
    else
    {
      size_t v18 = (void *)malloc_type_realloc();
      if (!v18) {
        return -1;
      }
      if (*v29 != v18)
      {
        _owned_ptr_delete(v28, v25);
        _owned_ptr_add((uint64_t)v28, (unint64_t)v18);
        *unsigned int v29 = v18;
      }
    }
    *((void *)*v29 + v20 + 1) = 0;
    int v26 = v20;
    goto LABEL_28;
  }
  if (!v31) {
    return 0;
  }
  int v24 = (void *)*((void *)*v29 + v26);
  if (_owned_ptr_search((uint64_t)v28, (unint64_t)v24, &v25))
  {
LABEL_28:
    if (v30 <= 0)
    {
      if (v30 < 0)
      {
        size_t v16 = strlen(v33);
        int i = (char *)malloc_type_malloc();
        if (!i) {
          return -1;
        }
        _owned_ptr_add((uint64_t)v28, (unint64_t)i);
        memcpy(i, v33, v16 + 1);
        BOOL v33 = i;
      }
      *((void *)*v29 + v26) = v33;
    }
    else
    {
      for (int i = (char *)v33; ; ++i)
      {
        BOOL v15 = 0;
        if (*i) {
          BOOL v15 = *i != 61;
        }
        if (!v15) {
          break;
        }
      }
      strlen(v32);
      uint64_t v8 = malloc_type_malloc();
      *((void *)*v29 + v26) = v8;
      if (!v8) {
        return -1;
      }
      _owned_ptr_add((uint64_t)v28, *((void *)*v29 + v26));
      for (int i = (char *)*((void *)*v29 + v26); ; ++i)
      {
        unsigned int v9 = v33++;
        LODWORD(v9) = *v9;
        *int i = (char)v9;
        BOOL v14 = 0;
        if (v9) {
          BOOL v14 = *i != 61;
        }
        if (!v14) {
          break;
        }
      }
      uint64_t v10 = i++;
      *uint64_t v10 = 61;
      do
      {
        uint64_t v11 = v32++;
        LODWORD(v11) = *(unsigned __int8 *)v11;
        dev_t v12 = i++;
        *dev_t v12 = (char)v11;
      }
      while (v11);
    }
    return 0;
  }
  if (v30 <= 0)
  {
    _owned_ptr_delete(v28, v25);
    free(v24);
    goto LABEL_28;
  }
  size_t v23 = strlen(v32);
  if (strlen(i) < v23)
  {
    unint64_t v21 = (char *)(i - (unsigned char *)v24);
    unint64_t v22 = malloc_type_realloc();
    if (!v22) {
      return -1;
    }
    if ((void *)v22 != v24)
    {
      *((void *)*v29 + v26) = v22;
      int i = &v21[v22];
      _owned_ptr_delete(v28, v25);
      _owned_ptr_add((uint64_t)v28, v22);
    }
  }
  do
  {
    int v6 = v32++;
    LODWORD(v6) = *(unsigned __int8 *)v6;
    unsigned int v7 = i++;
    *unsigned int v7 = (char)v6;
  }
  while (v6);
  return 0;
}

unsigned char *__unsetenv_locked(unsigned char *a1, char **a2, _DWORD *a3)
{
  uint64_t v10 = a1;
  unsigned int v9 = a2;
  uint64_t v8 = a3;
  int i = 0;
  int v6 = 0;
  int v5 = 0;
  while (1)
  {
    uint64_t result = __findenv_locked(v10, &v6, v9);
    if (!result) {
      break;
    }
    if (!_owned_ptr_search((uint64_t)v8, (unint64_t)v9[v6], &v5))
    {
      _owned_ptr_delete(v8, v5);
      free(v9[v6]);
    }
    for (int i = &v9[v6]; ; ++i)
    {
      int v4 = i[1];
      *int i = v4;
      if (!v4) {
        break;
      }
    }
  }
  return result;
}

_DWORD *_allocenvstate()
{
  return _owned_ptr_alloc();
}

void *_copyenv(void *a1)
{
  int v2 = 1;
  if (a1)
  {
    for (int i = a1; *i; ++i)
      ++v2;
  }
  int v4 = (void *)malloc_type_malloc();
  if (!v4) {
    return 0;
  }
  if (a1) {
    bcopy(a1, v4, 8 * v2);
  }
  else {
    *int v4 = 0;
  }
  return v4;
}

uint64_t _deallocenvstate(void **a1)
{
  if (a1 && a1 != (void **)__env_owned)
  {
    _owned_ptr_free(a1);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t _setenvp(char *a1, const char *a2, int a3, char ***a4, _DWORD *a5)
{
  environ_lock_np();
  if (__init__env_owned_locked(1))
  {
    environ_unlock_np();
    return -1;
  }
  else
  {
    if (a5) {
      unsigned int v5 = __setenv_locked(a1, a2, a3, 1, a4, a5);
    }
    else {
      unsigned int v5 = __setenv_locked(a1, a2, a3, 1, a4, (_DWORD *)__env_owned);
    }
    unsigned int v7 = v5;
    environ_unlock_np();
    return v7;
  }
}

uint64_t _unsetenvp(unsigned char *a1, char ***a2, _DWORD *a3)
{
  environ_lock_np();
  if (__init__env_owned_locked(1))
  {
    environ_unlock_np();
    return -1;
  }
  else
  {
    int v4 = *a2;
    if (a3) {
      __unsetenv_locked(a1, v4, a3);
    }
    else {
      __unsetenv_locked(a1, v4, (_DWORD *)__env_owned);
    }
    environ_unlock_np();
    return 0;
  }
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  if (__name && *__name && !strchr(__name, 61))
  {
    environ_lock_np();
    if (__init__env_owned_locked(1))
    {
      environ_unlock_np();
      return -1;
    }
    else
    {
      int v3 = _NSGetEnviron();
      int v5 = __setenv_locked((char *)__name, __value, __overwrite, 1, v3, (_DWORD *)__env_owned);
      environ_unlock_np();
      return v5;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int unsetenv(const char *a1)
{
  if (a1 && *a1 && !strchr(a1, 61))
  {
    environ_lock_np();
    if (__init__env_owned_locked(1))
    {
      environ_unlock_np();
      return -1;
    }
    else
    {
      int v1 = _NSGetEnviron();
      __unsetenv_locked(a1, *v1, (_DWORD *)__env_owned);
      environ_unlock_np();
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

hash_table *__cdecl hash_create(int size)
{
  int v3 = (hash_table *)malloc_type_malloc();
  if (!v3 || size < 0) {
    return 0;
  }
  if (!size) {
    int size = 97;
  }
  uint64_t v1 = malloc_type_malloc();
  v3->buckets = (hash_node **)v1;
  if (!v1) {
    return 0;
  }
  for (int i = 0; i < size; ++i)
    v3->buckets[i] = 0;
  v3->int size = size;
  return v3;
}

void hash_destroy(hash_table *table, char *key, void (__cdecl *nukefunc)(char *, void *))
{
  int v5 = _hash(table->size, (unsigned __int8 *)key);
  int v4 = table->buckets[v5];
  next = 0;
  if (!v4) {
    return;
  }
  if (!strcmp(v4->key, key))
  {
    table->buckets[v5] = v4->next;
    next = v4;
LABEL_9:
    if (nukefunc) {
      ((void (*)(char *, void *))nukefunc)(next->key, next->data);
    }
    free(next);
    return;
  }
  while (v4->next)
  {
    if (!strcmp(v4->next->key, key))
    {
      next = v4->next;
      v4->next = next->next;
      break;
    }
    int v4 = v4->next;
  }
  if (next) {
    goto LABEL_9;
  }
}

uint64_t _hash(unsigned int a1, unsigned __int8 *a2)
{
  unsigned int v4 = 0;
  while (*a2)
  {
    int v2 = a2++;
    v4 ^= *v2 ^ (2 * v4);
  }
  return v4 % a1;
}

void *__cdecl hash_search(hash_table *table, char *key, void *datum, void (__cdecl *replace_func)(void *))
{
  int v7 = _hash(table->size, (unsigned __int8 *)key);
  uint64_t v6 = list_find(key, (uint64_t)table->buckets[v7]);
  if (v6)
  {
    if (!replace_func) {
      return *(void **)(v6 + 8);
    }
    ((void (*)(void))replace_func)(*(void *)(v6 + 8));
    *(void *)(v6 + 8) = datum;
    return 0;
  }
  if (!datum) {
    return 0;
  }
  int v5 = (hash_node *)malloc_type_malloc();
  if (!v5 || !assign_key(key, &v5->key)) {
    return 0;
  }
  v5->data = datum;
  v5->next = table->buckets[v7];
  table->buckets[v7] = v5;
  return v5;
}

uint64_t list_find(const char *a1, uint64_t a2)
{
  while (a2)
  {
    if (!strcmp(*(const char **)a2, a1)) {
      return a2;
    }
    a2 = *(void *)(a2 + 16);
  }
  return 0;
}

uint64_t assign_key(const char *a1, char **a2)
{
  if (a2 && a1)
  {
    strlen(a1);
    uint64_t v2 = malloc_type_malloc();
    *a2 = (char *)v2;
    if (v2)
    {
      **a2 = 0;
      strcat(*a2, a1);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

void hash_traverse(hash_table *table, int (__cdecl *func)(char *, void *, void *), void *arg)
{
  int size = table->size;
  if (func)
  {
    for (int i = 0; i < size; ++i)
    {
      for (int j = table->buckets[i]; j; int j = j->next)
      {
        if (!((unsigned int (*)(char *, void *, void *))func)(j->key, j->data, arg)) {
          return;
        }
      }
    }
  }
}

void hash_purge(hash_table *table, void (__cdecl *purge_func)(char *, void *))
{
  int size = table->size;
  for (int i = 0; i < size; ++i)
  {
    int v3 = table->buckets[i];
    if (v3)
    {
      do
      {
        uint64_t v2 = v3;
        if (purge_func) {
          ((void (*)(char *, void *))purge_func)(v3->key, v3->data);
        }
        int v3 = v3->next;
        free(v2);
      }
      while (v3);
      table->buckets[i] = 0;
    }
  }
}

uint64_t hash_stats(uint64_t a1, int a2)
{
  int v12 = 0;
  int v11 = 0;
  int v10 = 0;
  int v9 = 0;
  int v7 = *(_DWORD *)a1;
  uint64_t v8 = malloc_type_malloc();
  if (!v8)
  {
    fprintf(__stderrp, "malloc returns 0\n");
    exit(1);
  }
  for (int i = 0; i < v7; ++i)
  {
    int v6 = 0;
    uint64_t v5 = *(void *)(*(void *)(a1 + 8) + 8 * i);
    *(_DWORD *)(v8 + 4 * i) = 0;
    while (v5)
    {
      if (!v6)
      {
        int v6 = 1;
        ++v11;
        if (a2) {
          printf("bucket %2d: ", i);
        }
      }
      if (a2) {
        printf(" %s", *(const char **)v5);
      }
      ++*(_DWORD *)(v8 + 4 * i);
      uint64_t v5 = *(void *)(v5 + 16);
    }
    v12 += *(_DWORD *)(v8 + 4 * i);
    if (*(_DWORD *)(v8 + 4 * i) <= v10)
    {
      if (*(_DWORD *)(v8 + 4 * i) == v10) {
        ++v9;
      }
    }
    else
    {
      int v10 = *(_DWORD *)(v8 + 4 * i);
      int v9 = 1;
    }
    if (*(_DWORD *)(v8 + 4 * i) && a2) {
      printf(" (%d)\n", *(_DWORD *)(v8 + 4 * i));
    }
  }
  printf("\n");
  uint64_t v2 = (const char *)&unk_D793D;
  if (v12 != 1) {
    uint64_t v2 = "s";
  }
  uint64_t result = printf("%d element%s in storage.\n", v12, v2);
  if (v12)
  {
    printf("%d of %d (%.2f%%) buckets are in use\n", v11, v7, 100.0 * (double)v11 / (double)v7);
    printf("the maximum number of elements in a bucket is %d (%d times)\n", v10, v9);
    printf("average per bucket is %f\n", (double)v12 / (double)v11);
    if (v7 >= v12) {
      int v4 = v12;
    }
    else {
      int v4 = v7;
    }
    return printf("optimal would be %f\n", (double)v12 / (double)v4);
  }
  return result;
}

intmax_t strtoimax_l(const char *nptr, char **endptr, int base, locale_t a4)
{
  unint64_t v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      unint64_t v21 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    unint64_t v21 = (_xlocale *)&__c_locale;
  }
  int v20 = nptr;
  do
  {
    int v4 = v20++;
    char v17 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v21));
  if (v17 == 45)
  {
    int v15 = 1;
    uint64_t v5 = v20++;
    char v17 = *v5;
  }
  else
  {
    int v15 = 0;
    if (v17 == 43)
    {
      int v6 = v20++;
      char v17 = *v6;
    }
  }
  if ((!base || base == 16)
    && v17 == 48
    && (*v20 == 120 || *v20 == 88)
    && (v20[1] >= 48 && v20[1] <= 57 || v20[1] >= 65 && v20[1] <= 70 || v20[1] >= 97 && v20[1] <= 102))
  {
    char v17 = v20[1];
    v20 += 2;
    int base = 16;
  }
  if (!base)
  {
    if (v17 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    int base = v7;
  }
  int v14 = 0;
  unint64_t v19 = 0;
  if (base < 2 || base > 36) {
    goto LABEL_57;
  }
  unint64_t v8 = 0x8000000000000000;
  if (!v15) {
    unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  int v13 = v8 % base;
  unint64_t v16 = v8 / base;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      char v18 = v17 - 48;
      goto LABEL_44;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      char v18 = v17 - 55;
      goto LABEL_44;
    }
    if (v17 < 97 || v17 > 122) {
      break;
    }
    char v18 = v17 - 87;
LABEL_44:
    if (v18 >= base) {
      break;
    }
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      int v14 = -1;
    }
    else
    {
      int v14 = 1;
      unint64_t v19 = v19 * base + v18;
    }
    int v9 = v20++;
    char v17 = *v9;
  }
  if (v14 < 0)
  {
    unint64_t v10 = 0x8000000000000000;
    if (!v15) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v19 = v10;
    *__error() = 34;
    goto LABEL_60;
  }
  if (!v14)
  {
LABEL_57:
    *__error() = 22;
    goto LABEL_60;
  }
  if (v15) {
    unint64_t v19 = -(uint64_t)v19;
  }
LABEL_60:
  if (endptr)
  {
    if (v14) {
      int v12 = (char *)(v20 - 1);
    }
    else {
      int v12 = (char *)nptr;
    }
    *endptsize_t r = v12;
  }
  return v19;
}

intmax_t strtoimax(const char *__nptr, char **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strtoimax_l(__nptr, __endptr, __base, v9);
  }
  else {
    return strtoimax_l(__nptr, __endptr, __base, (locale_t)__global_locale);
  }
}

uint64_t strtol_l(const char *a1, char **a2, int a3, locale_t a4)
{
  unint64_t v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      unint64_t v21 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    unint64_t v21 = (_xlocale *)&__c_locale;
  }
  int v20 = a1;
  do
  {
    char v4 = v20++;
    char v17 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v21));
  if (v17 == 45)
  {
    int v15 = 1;
    uint64_t v5 = v20++;
    char v17 = *v5;
  }
  else
  {
    int v15 = 0;
    if (v17 == 43)
    {
      int v6 = v20++;
      char v17 = *v6;
    }
  }
  if ((!a3 || a3 == 16)
    && v17 == 48
    && (*v20 == 120 || *v20 == 88)
    && (v20[1] >= 48 && v20[1] <= 57 || v20[1] >= 65 && v20[1] <= 70 || v20[1] >= 97 && v20[1] <= 102))
  {
    char v17 = v20[1];
    v20 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v17 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    a3 = v7;
  }
  int v14 = 0;
  unint64_t v19 = 0;
  if (a3 < 2 || a3 > 36) {
    goto LABEL_57;
  }
  unint64_t v8 = 0x8000000000000000;
  if (!v15) {
    unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  int v13 = v8 % a3;
  unint64_t v16 = v8 / a3;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      char v18 = v17 - 48;
      goto LABEL_44;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      char v18 = v17 - 55;
      goto LABEL_44;
    }
    if (v17 < 97 || v17 > 122) {
      break;
    }
    char v18 = v17 - 87;
LABEL_44:
    if (v18 >= a3) {
      break;
    }
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      int v14 = -1;
    }
    else
    {
      int v14 = 1;
      unint64_t v19 = v19 * a3 + v18;
    }
    int v9 = v20++;
    char v17 = *v9;
  }
  if (v14 < 0)
  {
    unint64_t v10 = 0x8000000000000000;
    if (!v15) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v19 = v10;
    *__error() = 34;
    goto LABEL_60;
  }
  if (!v14)
  {
LABEL_57:
    *__error() = 22;
    goto LABEL_60;
  }
  if (v15) {
    unint64_t v19 = -(uint64_t)v19;
  }
LABEL_60:
  if (a2)
  {
    if (v14) {
      int v12 = (char *)(v20 - 1);
    }
    else {
      int v12 = (char *)a1;
    }
    *a2 = v12;
  }
  return v19;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strtol_l(__str, __endptr, __base, v9);
  }
  else {
    return strtol_l(__str, __endptr, __base, (locale_t)__global_locale);
  }
}

uint64_t strtoll_l(const char *a1, char **a2, int a3, locale_t a4)
{
  unint64_t v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      unint64_t v21 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    unint64_t v21 = (_xlocale *)&__c_locale;
  }
  int v20 = a1;
  do
  {
    char v4 = v20++;
    char v17 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v21));
  if (v17 == 45)
  {
    int v15 = 1;
    uint64_t v5 = v20++;
    char v17 = *v5;
  }
  else
  {
    int v15 = 0;
    if (v17 == 43)
    {
      int v6 = v20++;
      char v17 = *v6;
    }
  }
  if ((!a3 || a3 == 16)
    && v17 == 48
    && (*v20 == 120 || *v20 == 88)
    && (v20[1] >= 48 && v20[1] <= 57 || v20[1] >= 65 && v20[1] <= 70 || v20[1] >= 97 && v20[1] <= 102))
  {
    char v17 = v20[1];
    v20 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v17 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    a3 = v7;
  }
  int v14 = 0;
  unint64_t v19 = 0;
  if (a3 < 2 || a3 > 36) {
    goto LABEL_57;
  }
  unint64_t v8 = 0x8000000000000000;
  if (!v15) {
    unint64_t v8 = 0x7FFFFFFFFFFFFFFFLL;
  }
  int v13 = v8 % a3;
  unint64_t v16 = v8 / a3;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      char v18 = v17 - 48;
      goto LABEL_44;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      char v18 = v17 - 55;
      goto LABEL_44;
    }
    if (v17 < 97 || v17 > 122) {
      break;
    }
    char v18 = v17 - 87;
LABEL_44:
    if (v18 >= a3) {
      break;
    }
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      int v14 = -1;
    }
    else
    {
      int v14 = 1;
      unint64_t v19 = v19 * a3 + v18;
    }
    int v9 = v20++;
    char v17 = *v9;
  }
  if (v14 < 0)
  {
    unint64_t v10 = 0x8000000000000000;
    if (!v15) {
      unint64_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    unint64_t v19 = v10;
    *__error() = 34;
    goto LABEL_60;
  }
  if (!v14)
  {
LABEL_57:
    *__error() = 22;
    goto LABEL_60;
  }
  if (v15) {
    unint64_t v19 = -(uint64_t)v19;
  }
LABEL_60:
  if (a2)
  {
    if (v14) {
      int v12 = (char *)(v20 - 1);
    }
    else {
      int v12 = (char *)a1;
    }
    *a2 = v12;
  }
  return v19;
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strtoll_l(__str, __endptr, __base, v9);
  }
  else {
    return strtoll_l(__str, __endptr, __base, (locale_t)__global_locale);
  }
}

uint64_t strtoq(const char *__str, char **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strtoll_l(__str, __endptr, __base, v9);
  }
  else {
    return strtoll_l(__str, __endptr, __base, (locale_t)__global_locale);
  }
}

uint64_t strtoq_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return strtoll_l(a1, a2, a3, a4);
}

unint64_t strtoul_l(const char *a1, char **a2, int a3, locale_t a4)
{
  char v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      char v18 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    char v18 = (_xlocale *)&__c_locale;
  }
  char v17 = a1;
  do
  {
    char v4 = v17++;
    char v14 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v18));
  if (v14 == 45)
  {
    int v12 = 1;
    uint64_t v5 = v17++;
    char v14 = *v5;
  }
  else
  {
    int v12 = 0;
    if (v14 == 43)
    {
      int v6 = v17++;
      char v14 = *v6;
    }
  }
  if ((!a3 || a3 == 16)
    && v14 == 48
    && (*v17 == 120 || *v17 == 88)
    && (v17[1] >= 48 && v17[1] <= 57 || v17[1] >= 65 && v17[1] <= 70 || v17[1] >= 97 && v17[1] <= 102))
  {
    char v14 = v17[1];
    v17 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v14 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    a3 = v7;
  }
  int v11 = 0;
  unint64_t v16 = 0;
  if (a3 < 2 || a3 > 36) {
    goto LABEL_53;
  }
  unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL / a3;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      char v15 = v14 - 48;
      goto LABEL_42;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      char v15 = v14 - 55;
      goto LABEL_42;
    }
    if (v14 < 97 || v14 > 122) {
      break;
    }
    char v15 = v14 - 87;
LABEL_42:
    if (v15 >= a3) {
      break;
    }
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % a3))
    {
      int v11 = -1;
    }
    else
    {
      int v11 = 1;
      unint64_t v16 = v16 * a3 + v15;
    }
    unint64_t v8 = v17++;
    char v14 = *v8;
  }
  if (v11 < 0)
  {
    unint64_t v16 = -1;
    *__error() = 34;
    goto LABEL_56;
  }
  if (v11)
  {
    if (v12) {
      unint64_t v16 = -(uint64_t)v16;
    }
  }
  else
  {
LABEL_53:
    *__error() = 22;
  }
LABEL_56:
  if (a2)
  {
    if (v11) {
      uint64_t v10 = (char *)(v17 - 1);
    }
    else {
      uint64_t v10 = (char *)a1;
    }
    *a2 = v10;
  }
  return v16;
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strtoul_l(__str, __endptr, __base, v9);
  }
  else {
    return strtoul_l(__str, __endptr, __base, (locale_t)__global_locale);
  }
}

unint64_t strtoull_l(const char *a1, char **a2, int a3, locale_t a4)
{
  char v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      char v18 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    char v18 = (_xlocale *)&__c_locale;
  }
  char v17 = a1;
  do
  {
    char v4 = v17++;
    char v14 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v18));
  if (v14 == 45)
  {
    int v12 = 1;
    uint64_t v5 = v17++;
    char v14 = *v5;
  }
  else
  {
    int v12 = 0;
    if (v14 == 43)
    {
      int v6 = v17++;
      char v14 = *v6;
    }
  }
  if ((!a3 || a3 == 16)
    && v14 == 48
    && (*v17 == 120 || *v17 == 88)
    && (v17[1] >= 48 && v17[1] <= 57 || v17[1] >= 65 && v17[1] <= 70 || v17[1] >= 97 && v17[1] <= 102))
  {
    char v14 = v17[1];
    v17 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v14 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    a3 = v7;
  }
  int v11 = 0;
  unint64_t v16 = 0;
  if (a3 < 2 || a3 > 36) {
    goto LABEL_53;
  }
  unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL / a3;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      char v15 = v14 - 48;
      goto LABEL_42;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      char v15 = v14 - 55;
      goto LABEL_42;
    }
    if (v14 < 97 || v14 > 122) {
      break;
    }
    char v15 = v14 - 87;
LABEL_42:
    if (v15 >= a3) {
      break;
    }
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % a3))
    {
      int v11 = -1;
    }
    else
    {
      int v11 = 1;
      unint64_t v16 = v16 * a3 + v15;
    }
    unint64_t v8 = v17++;
    char v14 = *v8;
  }
  if (v11 < 0)
  {
    unint64_t v16 = -1;
    *__error() = 34;
    goto LABEL_56;
  }
  if (v11)
  {
    if (v12) {
      unint64_t v16 = -(uint64_t)v16;
    }
  }
  else
  {
LABEL_53:
    *__error() = 22;
  }
LABEL_56:
  if (a2)
  {
    if (v11) {
      uint64_t v10 = (char *)(v17 - 1);
    }
    else {
      uint64_t v10 = (char *)a1;
    }
    *a2 = v10;
  }
  return v16;
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strtoull_l(__str, __endptr, __base, v9);
  }
  else {
    return strtoull_l(__str, __endptr, __base, (locale_t)__global_locale);
  }
}

uintmax_t strtoumax_l(const char *nptr, char **endptr, int base, locale_t a4)
{
  char v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      char v18 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    char v18 = (_xlocale *)&__c_locale;
  }
  char v17 = nptr;
  do
  {
    char v4 = v17++;
    char v14 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v18));
  if (v14 == 45)
  {
    int v12 = 1;
    uint64_t v5 = v17++;
    char v14 = *v5;
  }
  else
  {
    int v12 = 0;
    if (v14 == 43)
    {
      int v6 = v17++;
      char v14 = *v6;
    }
  }
  if ((!base || base == 16)
    && v14 == 48
    && (*v17 == 120 || *v17 == 88)
    && (v17[1] >= 48 && v17[1] <= 57 || v17[1] >= 65 && v17[1] <= 70 || v17[1] >= 97 && v17[1] <= 102))
  {
    char v14 = v17[1];
    v17 += 2;
    int base = 16;
  }
  if (!base)
  {
    if (v14 == 48) {
      int v7 = 8;
    }
    else {
      int v7 = 10;
    }
    int base = v7;
  }
  int v11 = 0;
  uintmax_t v16 = 0;
  if (base < 2 || base > 36) {
    goto LABEL_53;
  }
  unint64_t v13 = 0xFFFFFFFFFFFFFFFFLL / base;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      char v15 = v14 - 48;
      goto LABEL_42;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      char v15 = v14 - 55;
      goto LABEL_42;
    }
    if (v14 < 97 || v14 > 122) {
      break;
    }
    char v15 = v14 - 87;
LABEL_42:
    if (v15 >= base) {
      break;
    }
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % base))
    {
      int v11 = -1;
    }
    else
    {
      int v11 = 1;
      uintmax_t v16 = v16 * base + v15;
    }
    unint64_t v8 = v17++;
    char v14 = *v8;
  }
  if (v11 < 0)
  {
    uintmax_t v16 = -1;
    *__error() = 34;
    goto LABEL_56;
  }
  if (v11)
  {
    if (v12) {
      uintmax_t v16 = -(uint64_t)v16;
    }
  }
  else
  {
LABEL_53:
    *__error() = 22;
  }
LABEL_56:
  if (endptr)
  {
    if (v11) {
      uint64_t v10 = (char *)(v17 - 1);
    }
    else {
      uint64_t v10 = (char *)nptr;
    }
    *endptsize_t r = v10;
  }
  return v16;
}

uintmax_t strtoumax(const char *__nptr, char **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strtoumax_l(__nptr, __endptr, __base, v9);
  }
  else {
    return strtoumax_l(__nptr, __endptr, __base, (locale_t)__global_locale);
  }
}

unint64_t strtouq(const char *__str, char **__endptr, int __base)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return strtoull_l(__str, __endptr, __base, v9);
  }
  else {
    return strtoull_l(__str, __endptr, __base, (locale_t)__global_locale);
  }
}

unint64_t strtouq_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return strtoull_l(a1, a2, a3, a4);
}

uint64_t system_NOCANCEL(uint64_t a1)
{
  uint64_t v17 = a1;
  pid_t v16 = 0;
  pid_t v15 = 0;
  int v14 = 0;
  int v13 = 0;
  v12.__sigaction_u.__sa_handlesize_t r = 0;
  *(void *)&v12.sa_masint k = 0;
  v11.__sigaction_u.__sa_handlesize_t r = 0;
  *(void *)&v11.sa_masint k = 0;
  v10.__sigaction_u.__sa_handlesize_t r = 0;
  *(void *)&v10.sa_masint k = 0;
  sigset_t v9 = 0;
  sigset_t v8 = 0;
  sigset_t v7 = 0;
  posix_spawnattr_t v6 = 0;
  __int16 v5 = 8;
  __argv[0] = "sh";
  __argv[1] = "-c";
  uint64_t v23 = a1;
  uint64_t v24 = 0;
  if (!__unix_conforming) {
    __unix_conforming = 1;
  }
  if (v17)
  {
    int v13 = posix_spawnattr_init(&v6);
    if (v13)
    {
      int v4 = v13;
      *__error() = v4;
      return -1;
    }
    else
    {
      sigset_t v7 = 0;
      pthread_mutex_lock(&__systemfn_mutex);
      v12.__sigaction_u.__sa_handlesize_t r = (void (__cdecl *)(int))(&def_1F2C + 1);
      v12.sa_masint k = 0;
      v12.sa_int flags = 0;
      sigaction(2, &v12, &v11);
      if (v11.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&def_1F2C + 1))
      {
        int v21 = 2;
        v7 |= 2u;
        __int16 v5 = 12;
      }
      sigaction(3, &v12, &v10);
      if (v10.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&def_1F2C + 1))
      {
        int v20 = 3;
        v7 |= 4u;
        v5 |= 4u;
      }
      int v19 = 20;
      sigset_t v9 = 0x80000;
      sigprocmask(1, &v9, &v8);
      posix_spawnattr_setsigmask(&v6, &v8);
      if ((v5 & 4) != 0) {
        posix_spawnattr_setsigdefault(&v6, &v7);
      }
      posix_spawnattr_setflags(&v6, v5);
      uint64_t v1 = _NSGetEnviron();
      int v13 = posix_spawn(&v16, "/bin/sh", 0, &v6, __argv, *v1);
      posix_spawnattr_destroy(&v6);
      if (v13)
      {
        if (v13 == 12 || v13 == 35) {
          int v14 = -1;
        }
        else {
          int v14 = 32512;
        }
      }
      else
      {
        pid_t v15 = v16;
        do
        {
          pid_t v16 = wait4(v15, &v14, 0, 0);
          BOOL v3 = 0;
          if (v16 == -1) {
            BOOL v3 = *__error() == 4;
          }
        }
        while (v3);
        if (v16 == -1) {
          int v14 = -1;
        }
      }
      sigaction(2, &v11, 0);
      sigaction(3, &v10, 0);
      sigprocmask(3, &v8, 0);
      pthread_mutex_unlock(&__systemfn_mutex);
      return v14;
    }
  }
  else
  {
    return access("/bin/sh", 0) != -1;
  }
}

void *__cdecl tdelete(const void *a1, void **a2, int (__cdecl *a3)(const void *, const void *))
{
  sigset_t v9 = a2;
  if (!a2) {
    return 0;
  }
  sigset_t v8 = *a2;
  if (!*a2) {
    return 0;
  }
  while (1)
  {
    int v5 = ((uint64_t (*)(const void *, void))a3)(a1, *(void *)*v9);
    if (!v5) {
      break;
    }
    sigset_t v8 = *v9;
    if (v5 >= 0) {
      int v4 = (void **)((char *)*v9 + 16);
    }
    else {
      int v4 = (void **)((char *)*v9 + 8);
    }
    sigset_t v9 = v4;
    if (!*v4) {
      return 0;
    }
  }
  posix_spawnattr_t v6 = (void *)*((void *)*v9 + 2);
  int i = (void *)*((void *)*v9 + 1);
  if (i)
  {
    if (v6)
    {
      if (v6[1])
      {
        for (int i = (void *)v6[1]; i[1]; int i = (void *)i[1])
          posix_spawnattr_t v6 = i;
        v6[1] = i[2];
        i[1] = *((void *)*v9 + 1);
        i[2] = *((void *)*v9 + 2);
      }
      else
      {
        v6[1] = i;
        int i = v6;
      }
    }
  }
  else
  {
    int i = (void *)*((void *)*v9 + 2);
  }
  free(*v9);
  *sigset_t v9 = i;
  return v8;
}

void *__cdecl tfind(const void *a1, void *const *a2, int (__cdecl *a3)(const void *, const void *))
{
  posix_spawnattr_t v6 = (void **)a2;
  if (!a2) {
    return 0;
  }
  while (*v6)
  {
    int v5 = ((uint64_t (*)(const void *, void))a3)(a1, *(void *)*v6);
    if (!v5) {
      return *v6;
    }
    if (v5 >= 0) {
      uint64_t v4 = (uint64_t)*v6 + 16;
    }
    else {
      uint64_t v4 = (uint64_t)*v6 + 8;
    }
    posix_spawnattr_t v6 = (void **)v4;
  }
  return 0;
}

void *__cdecl tsearch(const void *a1, void **a2, int (__cdecl *a3)(const void *, const void *))
{
  posix_spawnattr_t v6 = a2;
  if (!a2) {
    return 0;
  }
  while (*v6)
  {
    int v5 = ((uint64_t (*)(const void *, void))a3)(a1, *(void *)*v6);
    if (!v5) {
      return *v6;
    }
    if (v5 >= 0) {
      uint64_t v4 = (uint64_t)*v6 + 16;
    }
    else {
      uint64_t v4 = (uint64_t)*v6 + 8;
    }
    posix_spawnattr_t v6 = (void **)v4;
  }
  sigset_t v7 = (void *)malloc_type_malloc();
  if (v7)
  {
    *posix_spawnattr_t v6 = v7;
    *sigset_t v7 = a1;
    _DWORD v7[2] = 0;
    v7[1] = 0;
  }
  return v7;
}

void twalk(const void *a1, void (__cdecl *a2)(const void *, VISIT, int))
{
  if (a1)
  {
    if (a2) {
      trecurse((uint64_t)a1, (uint64_t (*)(uint64_t, uint64_t, void))a2, 0);
    }
  }
}

uint64_t trecurse(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, void), unsigned int a3)
{
  if (!*(void *)(a1 + 8) && !*(void *)(a1 + 16)) {
    return a2(a1, 3, a3);
  }
  a2(a1, 0, a3);
  if (*(void *)(a1 + 8)) {
    trecurse(*(void *)(a1 + 8), a2, a3 + 1);
  }
  a2(a1, 1, a3);
  if (*(void *)(a1 + 16)) {
    trecurse(*(void *)(a1 + 16), a2, a3 + 1);
  }
  return a2(a1, 2, a3);
}

int posix_openpt(int a1)
{
  int v2 = open_NOCANCEL();
  if (v2 < 0) {
    return -1;
  }
  else {
    return v2;
  }
}

int grantpt(int a1)
{
  return ioctl(a1, 0x20007454uLL);
}

char *__cdecl ptsname(int a1)
{
  if (ptsname_once != -1) {
    _os_once();
  }
  posix_spawnattr_t v6 = pthread_getspecific(ptsname_buffer_specific_key);
  if (!v6)
  {
    posix_spawnattr_t v6 = (void *)malloc_type_malloc();
    if (!v6)
    {
      int v5 = _os_assert_log(0);
      _os_crash((uint64_t)v5);
      __break(1u);
    }
    int v4 = pthread_setspecific(ptsname_buffer_specific_key, v6);
    if (v4)
    {
      BOOL v3 = _os_assert_log(v4);
      _os_crash((uint64_t)v3);
      __break(1u);
    }
  }
  if (ptsname_r(a1, (char *)v6, 0x80uLL)) {
    return 0;
  }
  else {
    return (char *)v6;
  }
}

uint64_t ptsname_once_init()
{
  uint64_t result = pthread_key_create((pthread_key_t *)&ptsname_buffer_specific_key, (void (__cdecl *)(void *))&_free);
  if (result)
  {
    uint64_t v1 = _os_assert_log((int)result);
    uint64_t result = _os_crash((uint64_t)v1);
    __break(1u);
  }
  return result;
}

int ptsname_r(int fildes, char *buffer, size_t buflen)
{
  int v9 = fildes;
  sigset_t v8 = buffer;
  size_t v7 = buflen;
  int v6 = 0;
  memset(&__b, 0, sizeof(__b));
  if (v8)
  {
    int v6 = ioctl(v9, 0x40807453uLL, __s);
    if (v6)
    {
      return -1;
    }
    else
    {
      int v6 = stat(__s, &__b);
      if (v6)
      {
        return -1;
      }
      else
      {
        __signed int n = strlen(__s) + 1;
        if (v7 >= __n)
        {
          memcpy(v8, __s, __n);
          return 0;
        }
        else
        {
          *__error() = 34;
          return -1;
        }
      }
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int unlockpt(int a1)
{
  return ioctl(a1, 0x20007452uLL);
}

char *__cdecl l64a(uint64_t a1)
{
  int v6 = a1;
  int v5 = &l64a_buf;
  for (int i = 0; ; ++i)
  {
    BOOL v2 = 0;
    if (v6) {
      BOOL v2 = i < 6;
    }
    if (!v2) {
      break;
    }
    char v4 = v6 & 0x3F;
    if ((v6 & 0x3Fu) >= 2)
    {
      if ((v6 & 0x3Fu) >= 0xC)
      {
        if ((v6 & 0x3Fu) >= 0x26) {
          *int v5 = v4 + 59;
        }
        else {
          *int v5 = v4 + 53;
        }
      }
      else
      {
        *int v5 = v4 + 46;
      }
    }
    else
    {
      *int v5 = v4 + 46;
    }
    v6 >>= 6;
    ++v5;
  }
  *int v5 = 0;
  return (char *)&l64a_buf;
}

char *__cdecl ecvt(double a1, int a2, int *a3, int *a4)
{
  return (char *)__cvt(a2, a3, a4, 0, 1, a1);
}

const char *__cvt(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, double a6)
{
  double v20 = a6;
  int v19 = a1;
  char v18 = a2;
  uint64_t v17 = a3;
  int v16 = a4;
  int v15 = a5;
  __source = 0;
  int v13 = 0;
  if (!a1)
  {
    *uint64_t v17 = v20 < 0.0;
    *char v18 = 0;
    return (const char *)&unk_D793D;
  }
  if (__cvt_s)
  {
    free((void *)__cvt_s);
    __cvt_s = 0;
  }
  if (v19 >= 0) {
    size_t __size = v19 + 1;
  }
  else {
    size_t __size = 1 - v19;
  }
  if (v20 == 0.0)
  {
    *char v18 = 1 - v16;
    *uint64_t v17 = 0;
    __cvt_s = malloc_type_malloc();
    int v13 = (unsigned char *)__cvt_s;
    if (!__cvt_s) {
      return 0;
    }
    int v6 = v13++;
    *int v6 = 48;
    *int v13 = 0;
    goto LABEL_24;
  }
  __source = (char *)__dtoa(v16 + 2, v19, v18, v17, &v13, v20);
  if (!__source) {
    return 0;
  }
  if (*v18 != 9999)
  {
    if (v15 && v16) {
      __size += (int)*v18;
    }
    __cvt_s = malloc_type_malloc();
    if (!__cvt_s)
    {
      __freedtoa((uint64_t)__source);
      return 0;
    }
    strlcpy((char *)__cvt_s, __source, __size);
    int v13 = (unsigned char *)(__cvt_s + v13 - __source);
    __freedtoa((uint64_t)__source);
LABEL_24:
    if (v15)
    {
      size_t __sizea = __size - (void)&v13[-__cvt_s];
      while (--__sizea)
      {
        sigset_t v8 = v13++;
        *sigset_t v8 = 48;
      }
      *int v13 = 0;
    }
    return (const char *)__cvt_s;
  }
  *char v18 = 0;
  char v12 = *__source;
  __freedtoa((uint64_t)__source);
  size_t v7 = "inf";
  if (v12 != 73) {
    return "nan";
  }
  return v7;
}

char *__cdecl fcvt(double a1, int a2, int *a3, int *a4)
{
  return (char *)__cvt(a2, a3, a4, 1, 1, a1);
}

char *__cdecl gcvt(double a1, int a2, char *a3)
{
  double v31 = a1;
  int v30 = a2;
  unsigned int v29 = a3;
  statfs v28 = 0;
  mbstate_t __dst = 0;
  int v26 = 0;
  int i = 0;
  int v24 = 0;
  int v23 = 0;
  unint64_t v22 = localeconv();
  if (v30)
  {
    statfs v28 = __dtoa(2, v30, &v24, &v23, 0, v31);
    if (v28)
    {
      if (v24 == 9999)
      {
        if (v23) {
          BOOL v3 = "-";
        }
        else {
          BOOL v3 = (const char *)&unk_D793D;
        }
        char v4 = "inf";
        if (*(unsigned char *)v28 != 73) {
          char v4 = "nan";
        }
        snprintf(v29, v30 + 1, "%s%s", v3, v4);
        __freedtoa((uint64_t)v28);
        return v29;
      }
      else
      {
        mbstate_t __dst = v29;
        if (v23)
        {
          int v5 = __dst++;
          *int v5 = 45;
        }
        if (v24 >= 0 && v24 <= v30)
        {
          int i = 0;
          int v26 = v28;
          while (i < v24)
          {
            if (*v26)
            {
              int v15 = v26++;
              LOBYTE(v15) = *v15;
              int v16 = __dst++;
              *int v16 = (char)v15;
            }
            else
            {
              uint64_t v17 = __dst++;
              *uint64_t v17 = 48;
            }
            ++i;
          }
          if (*v26)
          {
            if (v26 == (unsigned char *)v28)
            {
              char v18 = __dst++;
              *char v18 = 48;
            }
            mbstate_t __dst = stpcpy(__dst, v22->decimal_point);
            for (int i = v24; *((unsigned char *)v28 + i); ++i)
            {
              char v19 = *((unsigned char *)v28 + i);
              double v20 = __dst++;
              char *v20 = v19;
            }
          }
          char *__dst = 0;
        }
        else
        {
          if (--v24 >= 0)
          {
            int v23 = 0;
          }
          else
          {
            int v23 = 1;
            int v24 = -v24;
          }
          int v26 = (char *)v28 + 1;
          char v6 = *(unsigned char *)v28;
          size_t v7 = __dst++;
          *size_t v7 = v6;
          mbstate_t __dst = stpcpy(__dst, v22->decimal_point);
          while (*v26)
          {
            sigset_t v8 = v26++;
            LOBYTE(v8) = *v8;
            int v9 = __dst++;
            *int v9 = (char)v8;
          }
          sigaction v10 = __dst++;
          *sigaction v10 = 101;
          sigaction v11 = __dst++;
          if (v23) {
            *sigaction v11 = 45;
          }
          else {
            *sigaction v11 = 43;
          }
          if (v24 >= 10)
          {
            int v23 = v24;
            for (int i = 0; ; ++i)
            {
              v23 /= 10;
              if (!v23) {
                break;
              }
            }
            __dst[i + 1] = 0;
            while (v24)
            {
              uint64_t v14 = i--;
              __dst[v14] = v24 % 10 + 48;
              v24 /= 10;
            }
          }
          else
          {
            char v12 = __dst++;
            *char v12 = 48;
            int v13 = __dst++;
            *int v13 = v24 + 48;
            char *__dst = 0;
          }
        }
        __freedtoa((uint64_t)v28);
        return v29;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *unsigned int v29 = 0;
    return v29;
  }
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
  uint64_t v5 = _Block_get_invoke_fn((uint64_t)__compar);
  char v6 = 0;
  if (v5) {
    char v6 = (int (__cdecl *)(void *, const void *, const void *))v5;
  }
  __compara = 0;
  if (v6) {
    __compara = v6;
  }
  qsort_r(__base, __nel, __width, __compar, __compara);
}

int heapsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
  size_t v47 = __nel;
  if (__nel <= 1) {
    return 0;
  }
  if (__width)
  {
    double v20 = (char *)malloc_type_malloc();
    if (v20)
    {
      int v21 = (char *)__base - __width;
      unint64_t v33 = v47 / 2 + 1;
      while (--v33)
      {
        for (unint64_t i = v33; ; unint64_t i = v34)
        {
          unint64_t v34 = 2 * i;
          if (2 * i > v47) {
            break;
          }
          char v18 = &v21[v34 * __width];
          if (v34 < v47
            && (*((int (**)(void *, char *, char *))__compar + 2))(__compar, v18, &v18[__width]) < 0)
          {
            v18 += __width;
            ++v34;
          }
          uint64_t v17 = &v21[i * __width];
          if ((*((int (**)(void *, char *, char *))__compar + 2))(__compar, v18, v17) <= 0) {
            break;
          }
          size_t v39 = __width;
          do
          {
            char v32 = *v17;
            char v4 = v17++;
            *char v4 = *v18;
            uint64_t v5 = v18++;
            *uint64_t v5 = v32;
            --v39;
          }
          while (v39);
        }
      }
      while (v47 > 1)
      {
        size_t v40 = __width;
        uint64_t v27 = v20;
        unint64_t v22 = &v21[v47 * __width];
        do
        {
          char v6 = v22++;
          size_t v7 = v27++;
          *size_t v7 = *v6;
          --v40;
        }
        while (v40);
        size_t v41 = __width;
        statfs v28 = &v21[v47 * __width];
        int v23 = (char *)__base;
        do
        {
          sigset_t v8 = v23++;
          int v9 = v28++;
          *int v9 = *v8;
          --v41;
        }
        while (v41);
        --v47;
        for (unint64_t j = 1; ; unint64_t j = v35)
        {
          unint64_t v35 = 2 * j;
          if (2 * j > v47) {
            break;
          }
          char v19 = &v21[v35 * __width];
          if (v35 < v47
            && (*((int (**)(void *, char *, char *))__compar + 2))(__compar, v19, &v19[__width]) < 0)
          {
            v19 += __width;
            ++v35;
          }
          size_t v42 = __width;
          unsigned int v29 = &v21[j * __width];
          int v24 = v19;
          do
          {
            sigaction v10 = v24++;
            sigaction v11 = v29++;
            *sigaction v11 = *v10;
            --v42;
          }
          while (v42);
        }
        while (1)
        {
          unint64_t v36 = j;
          j /= 2uLL;
          if (v36 == 1
            || (*((int (**)(void *, char *, char *))__compar + 2))(__compar, v20, &v21[j * __width]) < 0)
          {
            break;
          }
          size_t v44 = __width;
          double v31 = &v21[v36 * __width];
          int v26 = &v21[j * __width];
          do
          {
            uint64_t v14 = v26++;
            int v15 = v31++;
            *int v15 = *v14;
            --v44;
          }
          while (v44);
        }
        size_t v43 = __width;
        int v30 = &v21[v36 * __width];
        int v25 = v20;
        do
        {
          char v12 = v25++;
          int v13 = v30++;
          *int v13 = *v12;
          --v43;
        }
        while (v43);
      }
      free(v20);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t __heapsort_r(unsigned char *a1, unint64_t a2, uint64_t a3, uint64_t a4, int (*a5)(uint64_t, char *, char *))
{
  unint64_t v49 = a2;
  if (a2 > 1)
  {
    if (a3)
    {
      int v21 = (unsigned char *)malloc_type_malloc();
      if (v21)
      {
        unint64_t v22 = &a1[-a3];
        unint64_t v34 = v49 / 2 + 1;
        while (--v34)
        {
          for (unint64_t i = v34; ; unint64_t i = v35)
          {
            unint64_t v35 = 2 * i;
            if (2 * i > v49) {
              break;
            }
            char v19 = &v22[v35 * a3];
            if (v35 < v49 && a5(a4, v19, &v19[a3]) < 0)
            {
              v19 += a3;
              ++v35;
            }
            char v18 = &v22[i * a3];
            if (a5(a4, v19, v18) <= 0) {
              break;
            }
            uint64_t v40 = a3;
            do
            {
              char v33 = *v18;
              uint64_t v5 = v18++;
              *uint64_t v5 = *v19;
              char v6 = v19++;
              *char v6 = v33;
              --v40;
            }
            while (v40);
          }
        }
        while (v49 > 1)
        {
          uint64_t v41 = a3;
          statfs v28 = v21;
          int v23 = &v22[v49 * a3];
          do
          {
            size_t v7 = v23++;
            sigset_t v8 = v28++;
            *sigset_t v8 = *v7;
            --v41;
          }
          while (v41);
          uint64_t v42 = a3;
          unsigned int v29 = &v22[v49 * a3];
          int v24 = a1;
          do
          {
            int v9 = v24++;
            sigaction v10 = v29++;
            *sigaction v10 = *v9;
            --v42;
          }
          while (v42);
          --v49;
          for (unint64_t j = 1; ; unint64_t j = v36)
          {
            unint64_t v36 = 2 * j;
            if (2 * j > v49) {
              break;
            }
            double v20 = &v22[v36 * a3];
            if (v36 < v49 && a5(a4, v20, &v20[a3]) < 0)
            {
              v20 += a3;
              ++v36;
            }
            uint64_t v43 = a3;
            int v30 = &v22[j * a3];
            int v25 = v20;
            do
            {
              sigaction v11 = v25++;
              char v12 = v30++;
              *char v12 = *v11;
              --v43;
            }
            while (v43);
          }
          while (1)
          {
            unint64_t v37 = j;
            j /= 2uLL;
            if (v37 == 1 || a5(a4, v21, &v22[j * a3]) < 0) {
              break;
            }
            uint64_t v45 = a3;
            char v32 = &v22[v37 * a3];
            uint64_t v27 = &v22[j * a3];
            do
            {
              int v15 = v27++;
              int v16 = v32++;
              *int v16 = *v15;
              --v45;
            }
            while (v45);
          }
          uint64_t v44 = a3;
          double v31 = &v22[v37 * a3];
          int v26 = v21;
          do
          {
            int v13 = v26++;
            uint64_t v14 = v31++;
            *uint64_t v14 = *v13;
            --v44;
          }
          while (v44);
        }
        free(v21);
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      *__error() = 22;
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

_DWORD *__ldtoa(double *a1, int a2, int a3, _DWORD *a4, _DWORD *a5, void *a6)
{
  size_t v7 = __dtoa(a2, a3, a4, a5, a6, *a1);
  if (*a4 == 9999) {
    *a4 = 0x7FFFFFFF;
  }
  return v7;
}

BOOL timespec_get(timespec *a1, int a2)
{
  return a2 == 1 && clock_gettime(_CLOCK_REALTIME, a1) != -1;
}

char *_Read_RuneMagi(FILE *a1)
{
  uint64_t v41 = a1;
  uint64_t v40 = 0;
  size_t v39 = 0;
  unint64_t v37 = 0;
  unint64_t v36 = 0;
  unint64_t v34 = 0;
  uint64_t v33 = 0;
  char v32 = 0;
  memset(&__b, 0, sizeof(__b));
  int v14 = 0;
  RuneMagi_A = 0;
  unint64_t v35 = 0;
  int v1 = fileno(v41);
  if (fstat(v1, &__b) < 0) {
    return 0;
  }
  if (__b.st_size < 0xC3CuLL)
  {
LABEL_4:
    *__error() = 79;
    return 0;
  }
  st_int size = __b.st_size;
  int v2 = fileno(v41);
  size_t v39 = (char *)mmap(0, st_size, 3, 2, v2, 0);
  if (v39 == (char *)-1)
  {
    *__error() = 22;
    return 0;
  }
  unint64_t v36 = v39;
  unint64_t v37 = &v39[__b.st_size];
  if (memcmp(v39, "RuneMagA", 8uLL))
  {
    uint64_t __src = v36 + 3132;
    if (memcmp(v36, "RuneMagB", 8uLL))
    {
      *__error() = 79;
LABEL_61:
      int v24 = *__error();
      munmap(v39, __b.st_size);
      free(v35);
      free(RuneMagi_A);
      *__error() = v24;
      return 0;
    }
    uint64_t v17 = __src;
    __srca = &__src[12 * *((int *)v36 + 778)];
    if (__srca <= v37)
    {
      int v16 = __srca;
      __srcb = &__srca[12 * *((int *)v36 + 779)];
      if (__srcb <= v37)
      {
        int v15 = __srcb;
        __srcc = &__srcb[12 * *((int *)v36 + 780)];
        if (__srcc <= v37)
        {
          unint64_t v34 = v17;
          for (int i = 0; i < *((_DWORD *)v36 + 778); ++i)
          {
            if (!*(_DWORD *)&v34[12 * i + 8])
            {
              int v13 = *(_DWORD *)&v34[12 * i + 4] - *(_DWORD *)&v34[12 * i] + 1;
              __srcc += 4 * v13;
              v14 += v13;
              if (__srcc > v37) {
                goto LABEL_48;
              }
            }
          }
          char v32 = __srcc;
          if (&__srcc[20 * *((int *)v36 + 782) + *((int *)v36 + 781)] <= v37)
          {
            uint64_t v40 = 24 * (*((_DWORD *)v36 + 778) + *((_DWORD *)v36 + 779) + *((_DWORD *)v36 + 780))
                + 128
                + 4 * v14
                + 20 * *((int *)v36 + 782)
                + *((int *)v36 + 781);
            RuneMagi_A = (char *)malloc_type_calloc();
            if (!RuneMagi_A) {
              goto LABEL_61;
            }
            *(_DWORD *)RuneMagi_A = 1;
            *((void *)RuneMagi_A + 1) = destruct_ctype;
            BOOL v3 = (char *)malloc_type_calloc();
            *((void *)RuneMagi_A + 15) = v3;
            unint64_t v35 = v3;
            if (!v3)
            {
              free(RuneMagi_A);
              goto LABEL_61;
            }
            *((void *)v35 + 398) = RuneMagi_A + 128;
            *(void *)unint64_t v35 = *(void *)"RuneMagA";
            char v4 = v35;
            uint64_t v5 = v36;
            *(_OWORD *)(v35 + 8) = *(_OWORD *)(v36 + 8);
            *(_OWORD *)(v4 + 24) = *(_OWORD *)(v5 + 24);
            *((_DWORD *)v35 + 14) = 0;
            *((_DWORD *)v35 + 798) = *((_DWORD *)v36 + 781);
            *((_DWORD *)v35 + 784) = *((_DWORD *)v36 + 778);
            *((_DWORD *)v35 + 788) = *((_DWORD *)v36 + 779);
            *((_DWORD *)v35 + 792) = *((_DWORD *)v36 + 780);
            *((_DWORD *)v35 + 799) = *((_DWORD *)v36 + 782);
            for (int j = 0; j < 256; ++j)
            {
              *(_DWORD *)&v35[4 * j + 60] = *(_DWORD *)&v36[4 * j + 40];
              *(_DWORD *)&v35[4 * j + 1084] = *(_DWORD *)&v36[4 * j + 1064];
              *(_DWORD *)&v35[4 * j + 2108] = *(_DWORD *)&v36[4 * j + 2088];
            }
            *((void *)v35 + 393) = *((void *)v35 + 398);
            *((void *)v35 + 398) = *((void *)v35 + 393) + 24 * *((int *)v35 + 784);
            *((void *)v35 + 395) = *((void *)v35 + 398);
            *((void *)v35 + 398) = *((void *)v35 + 395) + 24 * *((int *)v35 + 788);
            *((void *)v35 + 397) = *((void *)v35 + 398);
            *((void *)v35 + 398) = *((void *)v35 + 397) + 24 * *((int *)v35 + 792);
            *((void *)v35 + 400) = *((void *)v35 + 398);
            *((void *)v35 + 398) = *((void *)v35 + 400) + 20 * *((int *)v35 + 799);
            __srcd = &v15[12 * *((int *)v36 + 780)];
            unint64_t v34 = v17;
            uint64_t v33 = *((void *)v35 + 393);
            for (int k = 0; k < *((_DWORD *)v35 + 784); ++k)
            {
              *(_DWORD *)(v33 + 24 * k) = *(_DWORD *)&v34[12 * k];
              *(_DWORD *)(v33 + 24 * k + 4) = *(_DWORD *)&v34[12 * k + 4];
              *(_DWORD *)(v33 + 24 * k + 8) = *(_DWORD *)&v34[12 * k + 8];
              if (*(_DWORD *)(v33 + 24 * k + 8))
              {
                *(void *)(v33 + 24 * k + 16) = 0;
              }
              else
              {
                int v11 = *(_DWORD *)(v33 + 24 * k + 4) - *(_DWORD *)(v33 + 24 * k) + 1;
                char v12 = __srcd;
                __srcd += 4 * v11;
                *(void *)(v33 + 24 * k + 16) = *((void *)v35 + 398);
                *((void *)v35 + 398) = *(void *)(v33 + 24 * k + 16) + 4 * v11;
                while (1)
                {
                  int v6 = v11--;
                  if (v6 <= 0) {
                    break;
                  }
                  *(_DWORD *)(*(void *)(v33 + 24 * k + 16) + 4 * v11) = *(_DWORD *)&v12[4 * v11];
                }
              }
            }
            unint64_t v34 = v16;
            uint64_t v33 = *((void *)v35 + 395);
            for (int m = 0; m < *((_DWORD *)v35 + 788); ++m)
            {
              *(_DWORD *)(v33 + 24 * m) = *(_DWORD *)&v34[12 * m];
              *(_DWORD *)(v33 + 24 * m + 4) = *(_DWORD *)&v34[12 * m + 4];
              *(_DWORD *)(v33 + 24 * m + 8) = *(_DWORD *)&v34[12 * m + 8];
            }
            unint64_t v34 = v15;
            uint64_t v33 = *((void *)v35 + 397);
            for (int n = 0; n < *((_DWORD *)v36 + 780); ++n)
            {
              *(_DWORD *)(v33 + 24 * n) = *(_DWORD *)&v34[12 * n];
              *(_DWORD *)(v33 + 24 * n + 4) = *(_DWORD *)&v34[12 * n + 4];
              *(_DWORD *)(v33 + 24 * n + 8) = *(_DWORD *)&v34[12 * n + 8];
            }
            if (*((int *)v36 + 782) > 0)
            {
              char v32 = __srcd;
              __srcd += 20 * *((int *)v36 + 782);
              if (__srcd > v37) {
                goto LABEL_48;
              }
              *((void *)v35 + 400) = *((void *)v35 + 398);
              *((void *)v35 + 398) = *((void *)v35 + 400) + 20 * *((int *)v35 + 799);
              for (iint i = 0; ii < *((_DWORD *)v36 + 782); ++ii)
              {
                size_t v7 = (void *)(*((void *)v35 + 400) + 20 * ii);
                sigset_t v8 = &v32[20 * ii];
                *size_t v7 = *(void *)v8;
                *(void *)((char *)v7 + 6) = *(void *)(v8 + 6);
                *(_DWORD *)(*((void *)v35 + 400) + 20 * ii + 16) = *(_DWORD *)&v32[20 * ii + 16];
              }
            }
            memcpy(*((void **)v35 + 398), __srcd, *((int *)v35 + 798));
            munmap(v39, __b.st_size);
            if (!*((_DWORD *)v35 + 798)) {
              *((void *)v35 + 398) = 0;
            }
            if (!*((_DWORD *)v35 + 784)) {
              *((void *)v35 + 393) = 0;
            }
            if (!*((_DWORD *)v35 + 788)) {
              *((void *)v35 + 395) = 0;
            }
            if (!*((_DWORD *)v35 + 792)) {
              *((void *)v35 + 397) = 0;
            }
            *((_DWORD *)RuneMagi_A + 28) = v40;
            return RuneMagi_A;
          }
        }
      }
    }
LABEL_48:
    *__error() = 22;
    goto LABEL_61;
  }
  if (__b.st_size < 0xC5CuLL) {
    goto LABEL_4;
  }
  RuneMagi_A = (char *)_Read_RuneMagi_A((uint64_t)v41, (uint64_t)v36, (unint64_t)v37);
  int v23 = *__error();
  munmap(v39, __b.st_size);
  if (!RuneMagi_A) {
    *__error() = v23;
  }
  return RuneMagi_A;
}

_DWORD *_Read_RuneMagi_A(uint64_t a1, uint64_t a2, unint64_t a3)
{
  int v11 = 0;
  char v32 = 0;
  uint64_t v31 = 0;
  uint64_t v15 = a2 + 3164;
  *(_DWORD *)(a2 + 48) = _OSSwapInt32(*(_DWORD *)(a2 + 48));
  *(_DWORD *)(a2 + 3152) = _OSSwapInt32(*(_DWORD *)(a2 + 3152));
  *(_DWORD *)(a2 + 3156) = _OSSwapInt32(*(_DWORD *)(a2 + 3156));
  *(_DWORD *)(a2 + 3124) = _OSSwapInt32(*(_DWORD *)(a2 + 3124));
  *(_DWORD *)(a2 + 3132) = _OSSwapInt32(*(_DWORD *)(a2 + 3132));
  *(_DWORD *)(a2 + 3140) = _OSSwapInt32(*(_DWORD *)(a2 + 3140));
  uint64_t v14 = v15;
  unint64_t v16 = v15 + 16 * *(int *)(a2 + 3124);
  if (v16 > a3) {
    goto LABEL_35;
  }
  unint64_t v13 = v16;
  unint64_t v17 = v16 + 16 * *(int *)(a2 + 3132);
  if (v17 > a3) {
    goto LABEL_35;
  }
  unint64_t v12 = v17;
  unint64_t v18 = v17 + 16 * *(int *)(a2 + 3140);
  if (v18 > a3) {
    goto LABEL_35;
  }
  for (int i = 0; i < *(_DWORD *)(a2 + 3124); ++i)
  {
    *(_DWORD *)(v14 + 16 * i) = _OSSwapInt32(*(_DWORD *)(v14 + 16 * i));
    *(_DWORD *)(v14 + 16 * i + 4) = _OSSwapInt32(*(_DWORD *)(v14 + 16 * i + 4));
    *(_DWORD *)(v14 + 16 * i + 8) = _OSSwapInt32(*(_DWORD *)(v14 + 16 * i + 8));
    if (!*(_DWORD *)(v14 + 16 * i + 8))
    {
      int v10 = *(_DWORD *)(v14 + 16 * i + 4) - *(_DWORD *)(v14 + 16 * i) + 1;
      v18 += 4 * v10;
      v11 += v10;
      if (v18 > a3) {
        goto LABEL_35;
      }
    }
  }
  if (v18 + 20 * *(int *)(a2 + 3156) + *(int *)(a2 + 3152) > a3) {
    goto LABEL_35;
  }
  int v33 = 24 * (*(_DWORD *)(a2 + 3124) + *(_DWORD *)(a2 + 3132) + *(_DWORD *)(a2 + 3140))
      + 128
      + 4 * v11
      + 20 * *(_DWORD *)(a2 + 3156)
      + *(_DWORD *)(a2 + 3152);
  char v32 = (_DWORD *)malloc_type_calloc();
  if (!v32)
  {
LABEL_48:
    int v20 = *__error();
    free((void *)v31);
    free(v32);
    *__error() = v20;
    return 0;
  }
  _DWORD *v32 = 1;
  *((void *)v32 + 1) = destruct_ctype;
  uint64_t v3 = malloc_type_calloc();
  *((void *)v32 + 15) = v3;
  uint64_t v31 = v3;
  if (!v3)
  {
    free(v32);
    goto LABEL_48;
  }
  *(void *)(v3 + 3184) = v32 + 32;
  *(void *)uint64_t v3 = *(void *)"RuneMagA";
  *(_OWORD *)(v3 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v3 + 24) = *(_OWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(v3 + 3192) = *(_DWORD *)(a2 + 3152);
  *(_DWORD *)(v3 + 3136) = *(_DWORD *)(a2 + 3124);
  *(_DWORD *)(v3 + 3152) = *(_DWORD *)(a2 + 3132);
  *(_DWORD *)(v3 + 3168) = *(_DWORD *)(a2 + 3140);
  *(_DWORD *)(v3 + 3196) = *(_DWORD *)(a2 + 3156);
  for (int j = 0; j < 256; ++j)
  {
    *(_DWORD *)(v31 + 60 + 4 * j) = _OSSwapInt32(*(_DWORD *)(a2 + 52 + 4 * j));
    *(_DWORD *)(v31 + 1084 + 4 * j) = _OSSwapInt32(*(_DWORD *)(a2 + 1076 + 4 * j));
    *(_DWORD *)(v31 + 2108 + 4 * j) = _OSSwapInt32(*(_DWORD *)(a2 + 2100 + 4 * j));
  }
  *(void *)(v31 + 3144) = *(void *)(v31 + 3184);
  *(void *)(v31 + 3184) = *(void *)(v31 + 3144) + 24 * *(int *)(v31 + 3136);
  *(void *)(v31 + 3160) = *(void *)(v31 + 3184);
  *(void *)(v31 + 3184) = *(void *)(v31 + 3160) + 24 * *(int *)(v31 + 3152);
  *(void *)(v31 + 3176) = *(void *)(v31 + 3184);
  *(void *)(v31 + 3184) = *(void *)(v31 + 3176) + 24 * *(int *)(v31 + 3168);
  *(void *)(v31 + 3200) = *(void *)(v31 + 3184);
  *(void *)(v31 + 3184) = *(void *)(v31 + 3200) + 20 * *(int *)(v31 + 3196);
  char v19 = (char *)(v12 + 16 * *(int *)(a2 + 3140));
  uint64_t v28 = *(void *)(v31 + 3144);
  for (int k = 0; k < *(_DWORD *)(v31 + 3136); ++k)
  {
    *(_DWORD *)(v28 + 24 * k) = *(_DWORD *)(v14 + 16 * k);
    *(_DWORD *)(v28 + 24 * k + 4) = *(_DWORD *)(v14 + 16 * k + 4);
    *(_DWORD *)(v28 + 24 * k + 8) = *(_DWORD *)(v14 + 16 * k + 8);
    if (*(_DWORD *)(v28 + 24 * k + 8))
    {
      *(void *)(v28 + 24 * k + 16) = 0;
    }
    else
    {
      int v8 = *(_DWORD *)(v28 + 24 * k + 4) - *(_DWORD *)(v28 + 24 * k) + 1;
      int v9 = v19;
      v19 += 4 * v8;
      *(void *)(v28 + 24 * k + 16) = *(void *)(v31 + 3184);
      *(void *)(v31 + 3184) = *(void *)(v28 + 24 * k + 16) + 4 * v8;
      while (1)
      {
        int v4 = v8--;
        if (v4 <= 0) {
          break;
        }
        *(_DWORD *)(*(void *)(v28 + 24 * k + 16) + 4 * v8) = _OSSwapInt32(*(_DWORD *)&v9[4 * v8]);
      }
    }
  }
  uint64_t v29 = *(void *)(v31 + 3160);
  for (int m = 0; m < *(_DWORD *)(v31 + 3152); ++m)
  {
    *(_DWORD *)(v29 + 24 * m) = _OSSwapInt32(*(_DWORD *)(v13 + 16 * m));
    *(_DWORD *)(v29 + 24 * m + 4) = _OSSwapInt32(*(_DWORD *)(v13 + 16 * m + 4));
    *(_DWORD *)(v29 + 24 * m + 8) = _OSSwapInt32(*(_DWORD *)(v13 + 16 * m + 8));
  }
  uint64_t v30 = *(void *)(v31 + 3176);
  for (int n = 0; n < *(_DWORD *)(a2 + 3140); ++n)
  {
    *(_DWORD *)(v30 + 24 * n) = _OSSwapInt32(*(_DWORD *)(v12 + 16 * n));
    *(_DWORD *)(v30 + 24 * n + 4) = _OSSwapInt32(*(_DWORD *)(v12 + 16 * n + 4));
    *(_DWORD *)(v30 + 24 * n + 8) = _OSSwapInt32(*(_DWORD *)(v12 + 16 * n + 8));
  }
  if (*(int *)(a2 + 3156) > 0)
  {
    uint64_t v27 = v19;
    v19 += 20 * *(int *)(a2 + 3156);
    if ((unint64_t)v19 > a3)
    {
LABEL_35:
      *__error() = 22;
      goto LABEL_48;
    }
    *(void *)(v31 + 3200) = *(void *)(v31 + 3184);
    *(void *)(v31 + 3184) = *(void *)(v31 + 3200) + 20 * *(int *)(v31 + 3196);
    for (iint i = 0; ii < *(_DWORD *)(a2 + 3156); ++ii)
    {
      uint64_t v5 = (void *)(*(void *)(v31 + 3200) + 20 * ii);
      int v6 = &v27[20 * ii];
      *uint64_t v5 = *(void *)v6;
      *(void *)((char *)v5 + 6) = *(void *)(v6 + 6);
      *(_DWORD *)(*(void *)(v31 + 3200) + 20 * ii + 16) = _OSSwapInt32(*((_DWORD *)v6 + 4));
    }
  }
  memcpy(*(void **)(v31 + 3184), v19, *(int *)(v31 + 3192));
  if (!*(_DWORD *)(v31 + 3192)) {
    *(void *)(v31 + 3184) = 0;
  }
  if (!*(_DWORD *)(v31 + 3136)) {
    *(void *)(v31 + 3144) = 0;
  }
  if (!*(_DWORD *)(v31 + 3152)) {
    *(void *)(v31 + 3160) = 0;
  }
  if (!*(_DWORD *)(v31 + 3168)) {
    *(void *)(v31 + 3176) = 0;
  }
  v32[28] = v33;
  return v32;
}

void destruct_ctype(void **a1)
{
  if (&_DefaultRuneLocale != a1[15]) {
    free(a1[15]);
  }
  free(a1);
}

int mergesort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
  if (__width >= 4)
  {
    if (__nel)
    {
      BOOL v33 = 0;
      if (!(__width % 4)) {
        BOOL v33 = (unint64_t)__base % 4 == 0;
      }
      mbstate_t __dst = (char *)malloc_type_malloc();
      if (__dst)
      {
        uint64_t __src = (char *)__base;
        setup_0((uint64_t)__base, __dst, __nel, __width, (uint64_t)__compar);
        int v20 = &__dst[__nel * __width];
        int v34 = 0;
        size_t v36 = 0;
        while (*(char **)((unint64_t)(__dst + 7) & 0xFFFFFFFFFFFFFFF8) != v20)
        {
          int v24 = __src;
          char v19 = (void *)((unint64_t)(__src + 7) & 0xFFFFFFFFFFFFFFF8);
          int v21 = __dst;
          uint64_t v27 = __dst;
          while (v21 != v20)
          {
            int v21 = *(char **)((unint64_t)(v21 + 7) & 0xFFFFFFFFFFFFFFF8);
            char v32 = v24;
            int v25 = &__src[v21 - __dst];
            uint64_t v31 = v25;
            if (v21 != v20) {
              int v21 = *(char **)((unint64_t)(v21 + 7) & 0xFFFFFFFFFFFFFFF8);
            }
            int v24 = &__src[v21 - __dst];
            while (1)
            {
              BOOL v18 = 0;
              if (v32 < (_DWORD *)v25) {
                BOOL v18 = v31 < (_DWORD *)v24;
              }
              if (!v18) {
                break;
              }
              if ((*((int (**)(void *, _DWORD *, _DWORD *))__compar + 2))(__compar, v32, v31) > 0)
              {
                int v26 = v32;
                uint64_t v29 = (char *)v31;
                uint64_t v30 = &__src[v21 - __dst];
                int v35 = 0;
              }
              else
              {
                int v26 = v31;
                uint64_t v29 = (char *)v32;
                uint64_t v30 = v25;
                int v35 = -1;
              }
              if (v34)
              {
LABEL_30:
                for (size_t i = __width; ; i *= 2)
                {
                  if (&v29[i] >= v30)
                  {
                    if (&v30[-__width] <= v29
                      || (*((int (**)(void *, _DWORD *, char *))__compar + 2))(__compar, v26, &v30[-__width]) > v35)
                    {
                      uint64_t v29 = &v30[-__width];
                    }
                    else
                    {
                      v30 -= __width;
                    }
                    while (v30 > &v29[__width])
                    {
                      if ((*((int (**)(void *, _DWORD *))__compar + 2))(__compar, v26) > v35) {
                        v29 += (((v30 - v29) / __width) >> 1) * __width;
                      }
                      else {
                        uint64_t v30 = &v29[(((v30 - v29) / __width) >> 1) * __width];
                      }
                    }
                    goto LABEL_50;
                  }
                  if ((*((int (**)(void *, _DWORD *, char *))__compar + 2))(__compar, v26, &v29[i]) <= v35) {
                    break;
                  }
                  v29 += i;
                }
                uint64_t v30 = &v29[i];
                if (i == __width) {
                  int v34 = 0;
                }
                while (i > __width)
                {
                  i >>= 1;
                  if ((*((int (**)(void *, _DWORD *))__compar + 2))(__compar, v26) > v35) {
                    v29 += i;
                  }
                  else {
                    uint64_t v30 = &v29[i];
                  }
                }
LABEL_50:
                uint64_t v29 = v30;
              }
              else
              {
                while (1)
                {
                  v29 += __width;
                  BOOL v17 = 0;
                  if (v29 < v30) {
                    BOOL v17 = (*((int (**)(void *, _DWORD *, char *))__compar + 2))(__compar, v26, v29) > v35;
                  }
                  if (!v17) {
                    break;
                  }
                  if (++v36 == 6)
                  {
                    int v34 = 1;
                    goto LABEL_30;
                  }
                }
              }
              size_t v36 = __width;
              if (v26 == v32)
              {
                if (v33)
                {
                  do
                    *v27++ = *v31++;
                  while (v31 < (_DWORD *)v29);
                  do
                  {
                    *v27++ = *v32++;
                    v36 -= 4;
                  }
                  while (v36);
                }
                else
                {
                  do
                  {
                    int v4 = v31;
                    uint64_t v31 = (_DWORD *)((char *)v31 + 1);
                    uint64_t v5 = v27;
                    uint64_t v27 = (_DWORD *)((char *)v27 + 1);
                    *uint64_t v5 = *v4;
                  }
                  while (v31 < (_DWORD *)v29);
                  do
                  {
                    int v6 = v32;
                    char v32 = (_DWORD *)((char *)v32 + 1);
                    size_t v7 = v27;
                    uint64_t v27 = (_DWORD *)((char *)v27 + 1);
                    *size_t v7 = *v6;
                    --v36;
                  }
                  while (v36);
                }
              }
              else if (v33)
              {
                do
                  *v27++ = *v32++;
                while (v32 < (_DWORD *)v29);
                do
                {
                  *v27++ = *v31++;
                  v36 -= 4;
                }
                while (v36);
              }
              else
              {
                do
                {
                  int v8 = v32;
                  char v32 = (_DWORD *)((char *)v32 + 1);
                  int v9 = v27;
                  uint64_t v27 = (_DWORD *)((char *)v27 + 1);
                  *int v9 = *v8;
                }
                while (v32 < (_DWORD *)v29);
                do
                {
                  int v10 = v31;
                  uint64_t v31 = (_DWORD *)((char *)v31 + 1);
                  int v11 = v27;
                  uint64_t v27 = (_DWORD *)((char *)v27 + 1);
                  *int v11 = *v10;
                  --v36;
                }
                while (v36);
              }
            }
            if (v31 >= (_DWORD *)v24)
            {
              if (v32 < (_DWORD *)v25)
              {
                if (v33)
                {
                  do
                    *v27++ = *v32++;
                  while (v32 < (_DWORD *)v25);
                }
                else
                {
                  do
                  {
                    uint64_t v14 = v32;
                    char v32 = (_DWORD *)((char *)v32 + 1);
                    uint64_t v15 = v27;
                    uint64_t v27 = (_DWORD *)((char *)v27 + 1);
                    *uint64_t v15 = *v14;
                  }
                  while (v32 < (_DWORD *)v25);
                }
              }
            }
            else if (v33)
            {
              do
                *v27++ = *v31++;
              while (v31 < (_DWORD *)v24);
            }
            else
            {
              do
              {
                unint64_t v12 = v31;
                uint64_t v31 = (_DWORD *)((char *)v31 + 1);
                unint64_t v13 = v27;
                uint64_t v27 = (_DWORD *)((char *)v27 + 1);
                *unint64_t v13 = *v12;
              }
              while (v31 < (_DWORD *)v24);
            }
            *char v19 = v24;
            char v19 = (void *)((unint64_t)(v24 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
          uint64_t v28 = __src;
          uint64_t __src = __dst;
          mbstate_t __dst = v28;
          int v20 = &v28[__nel * __width];
        }
        if (__base == __dst)
        {
          memmove(__dst, __src, __nel * __width);
          mbstate_t __dst = __src;
        }
        free(__dst);
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t setup_0(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v26 = 2 * a4;
  if (a3 > 5)
  {
    uint64_t v27 = (a3 & 1) + 4;
    insertionsort_0(a1 + (a3 - v27) * a4, v27, a4, a5);
    unint64_t v13 = a1 + a4 * (a3 - v27);
    *(void *)((unint64_t)&a2[a4 * (a3 - v27) + 7] & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
    unint64_t v12 = a2;
    int v20 = (char *)a1;
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a5 + 16))(a5, a1, a1 + a4);
    BOOL v21 = (int)result > 0;
    while ((unint64_t)v20 < v13)
    {
      int v25 = 2;
      for (size_t i = &v20[v26]; (unint64_t)i < v13; i += v26)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a5 + 16))(a5, i, &i[a4]);
        if ((int)result > 0 != v21) {
          break;
        }
        v25 += 2;
      }
      if (v25 >= 16)
      {
        uint64_t v14 = i;
        for (int j = &v20[v26]; j < v14; j += v26)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a5 + 16))(a5, &j[-a4], j);
          if ((int)result > 0 != v21)
          {
            *(void *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &j[(void)a2 - a1];
            unint64_t v12 = &j[(void)a2 - a1];
            if (v21 > 0)
            {
              unint64_t v16 = &j[-a4];
              do
              {
                uint64_t v29 = a4;
                do
                {
                  char v23 = *v20;
                  int v8 = v20++;
                  *int v8 = *v16;
                  int v9 = v16++;
                  *int v9 = v23;
                  --v29;
                }
                while (v29);
                v16 -= v26;
              }
              while (v20 < v16);
            }
            int v20 = j;
          }
        }
        if (v21 > 0)
        {
          BOOL v17 = &j[-a4];
          do
          {
            uint64_t v30 = a4;
            do
            {
              char v24 = *v20;
              int v10 = v20++;
              *int v10 = *v17;
              int v11 = v17++;
              *int v11 = v24;
              --v30;
            }
            while (v30);
            v17 -= v26;
          }
          while (v20 < v17);
        }
        int v20 = j;
        if ((unint64_t)j >= v13
          && (uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a5 + 16))(a5, &j[-a4], j), (int)result <= 0))
        {
          *(void *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
          unint64_t v12 = &a2[a3 * a4];
        }
        else
        {
          *(void *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &j[(void)a2 - a1];
          unint64_t v12 = &j[(void)a2 - a1];
        }
      }
      else
      {
        do
        {
          *(void *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &v20[v26 - a1 + (void)a2];
          unint64_t v12 = &v20[v26 - a1 + (void)a2];
          if (v21 > 0)
          {
            uint64_t v15 = &v20[a4];
            uint64_t v28 = a4;
            do
            {
              char v22 = *v20;
              int v6 = v20++;
              *int v6 = *v15;
              size_t v7 = v15++;
              *size_t v7 = v22;
              --v28;
            }
            while (v28);
            v20 -= a4;
          }
          v20 += v26;
        }
        while (v20 < i);
      }
      BOOL v21 = !v21;
    }
  }
  else
  {
    uint64_t result = insertionsort_0(a1, a3, a4, a5);
    *(void *)((unint64_t)(a2 + 7) & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
  }
  return result;
}

uint64_t insertionsort_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v15 = result;
  for (size_t i = (char *)(result + a3); --a2; i += a3)
  {
    for (int j = i; (unint64_t)j > v15; j -= a3)
    {
      int v8 = &j[-a3];
      uint64_t result = (*(uint64_t (**)(uint64_t, char *, char *))(a4 + 16))(a4, &j[-a3], j);
      if ((int)result <= 0) {
        break;
      }
      int v10 = j;
      int v6 = a3;
      do
      {
        char v7 = *v8;
        int v4 = v8++;
        *int v4 = *v10;
        uint64_t v5 = v10++;
        *uint64_t v5 = v7;
        --v6;
      }
      while (v6);
    }
  }
  return result;
}

int scandir_b(const char *a1, dirent ***a2, void *a3, void *a4)
{
  size_t __nel = 0;
  int v8 = opendir(a1);
  if (!v8) {
    return -1;
  }
  unint64_t v9 = 32;
  __int base = (void *)malloc_type_malloc();
  if (__base)
  {
    while (1)
    {
      unint64_t v13 = readdir(v8);
      if (!v13) {
        break;
      }
      if (!a3 || (*((unsigned int (**)(void *, dirent *))a3 + 2))(a3, v13))
      {
        unint64_t v12 = (char *)malloc_type_malloc();
        if (!v12) {
          goto LABEL_17;
        }
        *(void *)unint64_t v12 = v13->d_ino;
        v12[20] = v13->d_type;
        *((_WORD *)v12 + 8) = v13->d_reclen;
        *((_WORD *)v12 + 9) = v13->d_namlen;
        bcopy(v13->d_name, v12 + 21, *((unsigned __int16 *)v12 + 9) + 1);
        if (__nel >= v9)
        {
          uint64_t v6 = malloc_type_realloc();
          if (!v6)
          {
            free(v12);
            goto LABEL_17;
          }
          __int base = (void *)v6;
          v9 *= 2;
        }
        size_t v4 = __nel++;
        __base[v4] = v12;
      }
    }
    closedir(v8);
    if (__nel && a4) {
      qsort_b(__base, __nel, 8uLL, a4);
    }
    *a2 = (dirent **)__base;
    return __nel;
  }
  else
  {
LABEL_17:
    while (__nel)
      free((void *)__base[--__nel]);
    free(__base);
    closedir(v8);
    return -1;
  }
}

uint64_t __printf_arginfo_errno(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_errno", "xprintf_errno.c", 44, "n >= 1");
  }
  uint64_t result = 1;
  *a3 = 1;
  return result;
}

uint64_t __printf_render_errno(uint64_t a1, uint64_t a2, unsigned int **a3)
{
  __errnuint m = **a3;
  if (__errnum > 0x6A)
  {
    sprintf(v12, "errno=%d/0x%x", __errnum, __errnum);
    signed int v4 = strlen(v12);
    unsigned int v8 = __printf_out(a1, a2, (uint64_t)v12, v4);
    __printf_flush(a1);
    return v8;
  }
  else
  {
    uint64_t v6 = strerror(__errnum);
    signed int v3 = strlen(v6);
    return __printf_out(a1, a2, (uint64_t)v6, v3);
  }
}

uint64_t __printf_arginfo_float(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_float", "xprintf_float.c", 130, "n > 0");
  }
  if (*(__int16 *)(a1 + 40) >= 0)
  {
    *a3 = 128;
    if (*(_WORD *)(a1 + 40)) {
      *a3 |= 0x10000u;
    }
  }
  else
  {
    *a3 = 256;
  }
  return 1;
}

uint64_t __printf_render_float(uint64_t a1, unsigned int *a2, float **a3)
{
  uint64_t v62 = a1;
  time_t v61 = (locale_t *)a2;
  time_t v60 = a3;
  int v59 = 0;
  size_t v58 = 0;
  char v57 = 0;
  char v56 = 0;
  int v55 = 0;
  int v54 = 0;
  int v53 = 0;
  char v52 = 0;
  signed int v51 = 0;
  int v50 = 0;
  unsigned int v49 = 0;
  int v48 = 0;
  int v47 = 0;
  fixed = 0;
  int v45 = 0;
  double v44 = 0.0;
  double v43 = 0.0;
  signed int v42 = 0;
  signed int v41 = 0;
  if (*((__int16 *)a2 + 20) >= 0)
  {
    int v59 = *((_DWORD *)v61 + 5);
    char v40 = 0;
    char v52 = *((_DWORD *)v61 + 9);
    int v21 = 0;
    int v30 = 0;
    __s = localeconv_l(v61[1])->thousands_sep;
    unsigned int v23 = strlen(__s);
    fixed = 0;
    if (((_WORD)v61[5] & 0x100) != 0)
    {
      signed int v3 = localeconv_l(v61[1]);
      fixed = __fix_nogrouping(v3->grouping);
    }
    int __n_4 = localeconv_l(v61[1])->decimal_point;
    __int n = strlen(__n_4);
    signed int v41 = -1;
    unsigned int v4 = *((_DWORD *)v61 + 7);
    BOOL v5 = v4 > 0x41;
    uint64_t v6 = v4 - 65;
    if (v5)
    {
      uint64_t v8 = v6;
      char v7 = 1;
    }
    else
    {
      uint64_t v8 = v6;
      char v7 = 0;
    }
    if ((v7 & 1) == 0)
    {
      switch(v8)
      {
        case 0:
        case 32:
          if (*((_DWORD *)v61 + 7) == 97)
          {
            char v40 = 120;
            char v22 = &__lowercase_hex;
            char v57 = 112;
          }
          else
          {
            char v40 = 88;
            char v22 = &__uppercase_hex;
            char v57 = 80;
          }
          if (v59 >= 0) {
            ++v59;
          }
          if ((_WORD)v61[5])
          {
            double v44 = *(double *)*v60;
            unint64_t v9 = __hldtoa((uint64_t)v22, v59, &v55, &v54, &v53, v44);
          }
          else
          {
            double v43 = *(double *)*v60;
            unint64_t v9 = __hdtoa((uint64_t)v22, v59, &v55, &v54, &v53, v43);
          }
          char v56 = v9;
          size_t v58 = v9;
          if (v59 < 0) {
            int v59 = v53 - v56;
          }
          if (v55 == 0x7FFFFFFF) {
            char v40 = 0;
          }
          goto LABEL_44;
        case 1:
        case 2:
        case 3:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 33:
        case 34:
        case 35:
          break;
        case 4:
        case 36:
          char v57 = *((_DWORD *)v61 + 7);
          if (v59 >= 0) {
            ++v59;
          }
          else {
            int v59 = 7;
          }
          goto LABEL_32;
        case 5:
        case 37:
          char v57 = 0;
          goto LABEL_32;
        case 6:
        case 38:
          char v57 = *((_DWORD *)v61 + 7) - 2;
          if (!v59) {
            int v59 = 1;
          }
          goto LABEL_32;
        default:
          JUMPOUT(0);
      }
    }
    if (*((_DWORD *)v61 + 7) != 102) {
      __assert_rtn("__printf_render_float", "xprintf_float.c", 263, "pi->spec == 'f'");
    }
LABEL_32:
    if (v59 < 0) {
      int v59 = 6;
    }
    if ((_WORD)v61[5])
    {
      double v44 = *(double *)*v60;
      if (v57) {
        int v10 = 2;
      }
      else {
        int v10 = 3;
      }
      char v56 = __ldtoa(&v44, v10, v59, &v55, &v54, &v53);
      size_t v58 = v56;
    }
    else
    {
      double v43 = *(double *)*v60;
      if (v57) {
        int v11 = 2;
      }
      else {
        int v11 = 3;
      }
      char v56 = __dtoa(v11, v59, &v55, &v54, &v53, v43);
      size_t v58 = v56;
      if (v55 == 9999) {
        int v55 = 0x7FFFFFFF;
      }
    }
LABEL_44:
    if (v54) {
      char v52 = 45;
    }
    if (v55 == 0x7FFFFFFF)
    {
      if (*(unsigned char *)v56 == 78)
      {
        unint64_t v12 = "nan";
        if (*((int *)v61 + 7) < 97) {
          unint64_t v12 = "NAN";
        }
        char v56 = v12;
        char v52 = 0;
      }
      else
      {
        unint64_t v13 = "inf";
        if (*((int *)v61 + 7) < 97) {
          unint64_t v13 = "INF";
        }
        char v56 = v13;
      }
      signed int v51 = 3;
      int v21 = 1;
    }
    else
    {
      int v50 = v53 - v56;
      if (*((_DWORD *)v61 + 7) == 103 || *((_DWORD *)v61 + 7) == 71)
      {
        if (v55 <= -4 || v55 > v59)
        {
          if (((*((_WORD *)v61 + 20) >> 4) & 1) == 0) {
            int v59 = v50;
          }
        }
        else
        {
          char v57 = 0;
          if ((*((_WORD *)v61 + 20) >> 4)) {
            v59 -= v55;
          }
          else {
            int v59 = v50 - v55;
          }
          if (v59 < 0) {
            int v59 = 0;
          }
        }
      }
      if (v57)
      {
        unsigned int v49 = exponent_1(v66, v55 - 1, v57);
        signed int v51 = v49 + v59;
        if (v59 > 1 || ((*((_WORD *)v61 + 20) >> 4) & 1) != 0) {
          ++v51;
        }
      }
      else
      {
        if (v55 <= 0) {
          signed int v51 = 1;
        }
        else {
          signed int v51 = v55;
        }
        if (v59 || ((*((_WORD *)v61 + 20) >> 4) & 1) != 0) {
          v51 += v59 + 1;
        }
        if (fixed && v55 > 0)
        {
          int v47 = 0;
          int v48 = 0;
          int v45 = v55;
          while (*fixed != 127 && v45 > (char)*fixed)
          {
            v45 -= (char)*fixed;
            if (fixed[1])
            {
              ++v48;
              ++fixed;
            }
            else
            {
              ++v47;
            }
          }
          v51 += v48 + v47;
        }
        else
        {
          int v45 = v55;
        }
      }
    }
    if (v41 <= v51) {
      signed int v20 = v51;
    }
    else {
      signed int v20 = v41;
    }
    signed int v42 = v20;
    if (v52) {
      ++v42;
    }
    if (v40) {
      v42 += 2;
    }
    if (*((_DWORD *)v61 + 8) != 48 && ((*((_WORD *)v61 + 20) >> 6) & 1) == 0) {
      int v30 = __printf_pad(v62, *((_DWORD *)v61 + 6) - v42, 0);
    }
    if (v52) {
      v30 += __printf_puts(v62, (uint64_t)&v52, 1u);
    }
    if (v40)
    {
      char v39 = 48;
      v30 += __printf_puts(v62, (uint64_t)&v39, 2u);
    }
    if (*((_DWORD *)v61 + 8) == 48 && ((*((_WORD *)v61 + 20) >> 6) & 1) == 0) {
      v30 += __printf_pad(v62, *((_DWORD *)v61 + 6) - v42, 1);
    }
    int v31 = v30 + __printf_pad(v62, v41 - v51, 1);
    if (v21)
    {
      unsigned int v32 = v31 + __printf_puts(v62, (uint64_t)v56, v51);
    }
    else if (v57)
    {
      if (v59 > 1 || ((*((_WORD *)v61 + 20) >> 4) & 1) != 0)
      {
        uint64_t v14 = (char *)v56;
        char v56 = (_DWORD *)((char *)v56 + 1);
        char v64 = *v14;
        memcpy(v65, __n_4, __n);
        int v36 = v31 + __printf_puts(v62, (uint64_t)&v64, __n + 1);
        int v37 = v36 + __printf_puts(v62, (uint64_t)v56, v50 - 1);
        int v38 = v37 + __printf_pad(v62, v59 - v50, 1);
      }
      else
      {
        int v38 = v31 + __printf_puts(v62, (uint64_t)v56, 1u);
      }
      unsigned int v32 = v38 + __printf_puts(v62, (uint64_t)v66, v49);
    }
    else
    {
      if (v55 > 0)
      {
        signed int v25 = v53 - v56;
        if ((int)v53 - (int)v56 > v45) {
          signed int v25 = v45;
        }
        if (v25 <= 0)
        {
          signed int v19 = 0;
        }
        else
        {
          v31 += __printf_puts(v62, (uint64_t)v56, v25);
          signed int v19 = v25;
        }
        int v34 = v31 + __printf_pad(v62, v45 - v19, 1);
        char v56 = (_DWORD *)((char *)v56 + v45);
        if (fixed)
        {
          while (1)
          {
            BOOL v18 = 1;
            if (v48 <= 0) {
              BOOL v18 = v47 > 0;
            }
            if (!v18) {
              break;
            }
            if (v47 <= 0)
            {
              --fixed;
              --v48;
            }
            else
            {
              --v47;
            }
            int v35 = v34 + __printf_puts(v62, (uint64_t)__s, v23);
            signed int v26 = v53 - v56;
            if ((int)v53 - (int)v56 > (char)*fixed) {
              signed int v26 = (char)*fixed;
            }
            if (v26 <= 0)
            {
              signed int v17 = 0;
            }
            else
            {
              v35 += __printf_puts(v62, (uint64_t)v56, v26);
              signed int v17 = v26;
            }
            int v34 = v35 + __printf_pad(v62, (char)*fixed - v17, 1);
            char v56 = (_DWORD *)((char *)v56 + (char)*fixed);
          }
          if (v56 > v53) {
            char v56 = v53;
          }
        }
        if (v59 || ((*((_WORD *)v61 + 20) >> 4) & 1) != 0) {
          v34 += __printf_puts(v62, (uint64_t)__n_4, __n);
        }
      }
      else
      {
        int v33 = v31 + __printf_puts(v62, (uint64_t)"0", 1u);
        if (v59 || ((*((_WORD *)v61 + 20) >> 4) & 1) != 0) {
          v33 += __printf_puts(v62, (uint64_t)__n_4, __n);
        }
        int v34 = v33 + __printf_pad(v62, -v55, 1);
        v59 += v55;
      }
      signed int v27 = v53 - v56;
      if ((int)v53 - (int)v56 > v59) {
        signed int v27 = v59;
      }
      if (v27 <= 0)
      {
        signed int v16 = 0;
      }
      else
      {
        v34 += __printf_puts(v62, (uint64_t)v56, v27);
        signed int v16 = v27;
      }
      unsigned int v32 = v34 + __printf_pad(v62, v59 - v16, 1);
    }
    if ((*((_WORD *)v61 + 20) >> 6)) {
      v32 += __printf_pad(v62, *((_DWORD *)v61 + 6) - v42, 0);
    }
    __printf_flush(v62);
    if (v58) {
      __freedtoa((uint64_t)v58);
    }
    return v32;
  }
  else
  {
    return __xprintf_vector(v62, (unsigned int *)v61, v60);
  }
}

uint64_t exponent_1(unsigned char *a1, int a2, int a3)
{
  uint64_t v14 = a1;
  int v13 = a2;
  int v12 = a3;
  int v10 = 0;
  int v11 = a1 + 1;
  *a1 = a3;
  if (v13 >= 0)
  {
    unsigned int v4 = v11++;
    *unsigned int v4 = 43;
  }
  else
  {
    int v13 = -v13;
    signed int v3 = v11++;
    *signed int v3 = 45;
  }
  int v10 = &v10;
  if (v13 <= 9)
  {
    if (v12 == 101 || v12 == 69)
    {
      char v7 = v11++;
      *char v7 = 48;
    }
    uint64_t v8 = v11++;
    *uint64_t v8 = v13 + 48;
  }
  else
  {
    do
    {
      *--int v10 = v13 % 10 + 48;
      v13 /= 10;
    }
    while (v13 > 9);
    *--int v10 = v13 + 48;
    while (v10 < (unsigned char *)&v10)
    {
      BOOL v5 = v10++;
      LOBYTE(v5) = *v5;
      uint64_t v6 = v11++;
      *uint64_t v6 = (_BYTE)v5;
    }
  }
  return v11 - v14;
}

uint64_t __printf_arginfo_hexdump(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  if (a2 < 2) {
    __assert_rtn("__printf_arginfo_hexdump", "xprintf_hexdump.c", 42, "n >= 2");
  }
  *a3 = 32;
  a3[1] = 1;
  return 2;
}

uint64_t __printf_render_hexdump(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  if (*(int *)(a2 + 24) <= 0 || *(int *)(a2 + 24) >= 16) {
    unsigned int v18 = 16;
  }
  else {
    unsigned int v18 = *(_DWORD *)(a2 + 24);
  }
  uint64_t v20 = **a3;
  unsigned int v19 = *(_DWORD *)a3[1];
  unsigned int v11 = 0;
  int v14 = 0;
  while (v19)
  {
    int v12 = &v23;
    if ((*(_WORD *)(a2 + 40) >> 7)) {
      int v12 = &v24[sprintf(&v23, " %04x", v14) - 1];
    }
    for (unsigned int i = 0; ; ++i)
    {
      BOOL v10 = 0;
      if (i < v18) {
        BOOL v10 = i < v19;
      }
      if (!v10) {
        break;
      }
      v12 += sprintf(v12, " %02x", *(unsigned __int8 *)(v20 + i));
    }
    if ((*(_WORD *)(a2 + 40) >> 4))
    {
      while (i < v18)
      {
        v12 += sprintf(v12, "   ");
        ++i;
      }
      int v13 = &v12[sprintf(v12, "  |")];
      for (unsigned int j = 0; ; ++j)
      {
        BOOL v9 = 0;
        if (j < v18) {
          BOOL v9 = j < v19;
        }
        if (!v9) {
          break;
        }
        if (*(unsigned __int8 *)(v20 + j) >= 0x20u && *(unsigned __int8 *)(v20 + j) <= 0x7Eu)
        {
          unsigned int v4 = v13++;
          *unsigned int v4 = *(unsigned char *)(v20 + j);
        }
        else
        {
          signed int v3 = v13++;
          *signed int v3 = 46;
        }
      }
      while (j < v18)
      {
        BOOL v5 = v13++;
        *BOOL v5 = 32;
        ++j;
      }
      uint64_t v6 = v13;
      int v12 = v13 + 1;
      *uint64_t v6 = 124;
    }
    if (v18 >= v19) {
      unsigned int v17 = v19;
    }
    else {
      unsigned int v17 = v18;
    }
    v20 += v17;
    v19 -= v17;
    v14 += v17;
    if (v19)
    {
      char v7 = v12++;
      *char v7 = 10;
    }
    v11 += __printf_puts(a1, (uint64_t)v24, v12 - v24);
    __printf_flush(a1);
  }
  return v11;
}

uint64_t __printf_arginfo_int(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_int", "xprintf_int.c", 240, "n > 0");
  }
  *a3 = 1;
  if (*(__int16 *)(a1 + 40) >= 0)
  {
    if ((*(_WORD *)(a1 + 40) >> 13))
    {
      *a3 |= 0x800000u;
    }
    else if ((*(_WORD *)(a1 + 40) >> 14))
    {
      *a3 |= 0x400000u;
    }
    else if ((*(_WORD *)(a1 + 40) >> 3))
    {
      *a3 |= 0x20000u;
    }
    else if ((*(_WORD *)(a1 + 40) >> 12))
    {
      *a3 |= 0x200000u;
    }
    else if ((*(_WORD *)(a1 + 40) >> 11))
    {
      *a3 |= 0x100000u;
    }
    else if (*(_WORD *)(a1 + 40))
    {
      *a3 |= 0x10000u;
    }
    else if ((*(_WORD *)(a1 + 40) >> 2))
    {
      *a3 |= 0x40000u;
    }
    else if ((*(_WORD *)(a1 + 40) >> 1))
    {
      *a3 = 2;
    }
  }
  else
  {
    *a3 = 256;
  }
  return 1;
}

uint64_t __printf_render_int(uint64_t a1, uint64_t a2, unint64_t **a3)
{
  uint64_t v36 = a1;
  uint64_t v35 = a2;
  int v34 = a3;
  int v33 = 0;
  unint64_t v32 = 0;
  int v31 = 0;
  char v30 = 0;
  if (*(__int16 *)(a2 + 40) >= 0)
  {
    int v14 = 0;
    int v21 = 0;
    uint64_t v20 = &__lowercase_hex;
    char v30 = 0;
    int v31 = &v39;
    if ((*(_WORD *)(v35 + 40) & 0x100) != 0)
    {
      __s = localeconv_l(*(locale_t *)(v35 + 8))->thousands_sep;
      int v18 = strlen(__s);
      signed int v3 = localeconv_l(*(locale_t *)(v35 + 8));
      fixed = __fix_nogrouping(v3->grouping);
      int v26 = 1;
    }
    else
    {
      __s = 0;
      int v18 = 0;
      fixed = 0;
      int v26 = 0;
    }
    unsigned int v4 = *(_DWORD *)(v35 + 28);
    BOOL v5 = v4 > 0x4F;
    uint64_t v6 = v4 - 79;
    if (v5)
    {
      uint64_t v8 = v6;
      char v7 = 1;
    }
    else
    {
      uint64_t v8 = v6;
      char v7 = 0;
    }
    if (v7)
    {
LABEL_16:
      fprintf(__stderrp, "pi->spec = '%c'\n", *(unsigned int *)(v35 + 28));
      __assert_rtn("__printf_render_int", "xprintf_int.c", 328, "1 == 0");
    }
    switch(v8)
    {
      case 0:
      case 32:
        int v29 = 8;
        int v28 = 0;
        goto LABEL_17;
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 7:
      case 8:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 22:
      case 23:
      case 24:
      case 25:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 39:
      case 40:
        goto LABEL_16;
      case 6:
      case 38:
        int v29 = 10;
        int v28 = 0;
        goto LABEL_17;
      case 9:
        uint64_t v20 = &__uppercase_hex;
        goto LABEL_13;
      case 21:
      case 26:
        int v29 = 10;
        int v28 = 1;
        goto LABEL_17;
      case 41:
LABEL_13:
        int v29 = 16;
        int v28 = 0;
LABEL_17:
        int v33 = *v34;
        if (v28) {
          char v30 = *(_DWORD *)(v35 + 36);
        }
        if ((*(_WORD *)(v35 + 40) & 1) != 0
          || ((*(_WORD *)(v35 + 40) >> 11) & 1) != 0
          || ((*(_WORD *)(v35 + 40) >> 12) & 1) != 0
          || ((*(_WORD *)(v35 + 40) >> 14) & 1) != 0
          || ((*(_WORD *)(v35 + 40) >> 13) & 1) != 0)
        {
          if (v28 && (*v33 & 0x8000000000000000) != 0)
          {
            unint64_t v16 = -(uint64_t)*v33;
            char v30 = 45;
          }
          else
          {
            unint64_t v16 = *v33;
          }
        }
        else if ((*(_WORD *)(v35 + 40) >> 3))
        {
          if (v28 && (*v33 & 0x8000000000000000) != 0)
          {
            unint64_t v16 = -(uint64_t)*v33;
            char v30 = 45;
          }
          else
          {
            unint64_t v16 = *v33;
          }
        }
        else if ((*(_WORD *)(v35 + 40) >> 2))
        {
          if (v28 && (*(_DWORD *)v33 & 0x8000u) != 0)
          {
            unint64_t v16 = -(__int16)*(_DWORD *)v33;
            char v30 = 45;
          }
          else
          {
            unint64_t v16 = (unsigned __int16)*(_DWORD *)v33;
          }
        }
        else if ((*(_WORD *)(v35 + 40) >> 1))
        {
          if (v28 && (*(_DWORD *)v33 & 0x80u) != 0)
          {
            unint64_t v16 = -(char)*(_DWORD *)v33;
            char v30 = 45;
          }
          else
          {
            unint64_t v16 = *(_DWORD *)v33;
          }
        }
        else if (v28 && *(int *)v33 < 0)
        {
          unint64_t v16 = -*(_DWORD *)v33;
          char v30 = 45;
        }
        else
        {
          unint64_t v16 = *(unsigned int *)v33;
        }
        unint64_t v32 = (unint64_t)__ultoa_1(v16, v31, v29, (uint64_t)v20, v26, __s, v18, fixed);
        int v22 = 0;
        if (v16)
        {
          if ((*(_WORD *)(v35 + 40) >> 4))
          {
            if (v29 == 8) {
              *(unsigned char *)--unint64_t v32 = 48;
            }
            if (v29 == 16)
            {
              if (*(_DWORD *)(v35 + 28) == 120) {
                int v21 = "0x";
              }
              else {
                int v21 = "0X";
              }
              int v22 = 2;
            }
          }
        }
        else if (!*(_DWORD *)(v35 + 20) && (((*(_WORD *)(v35 + 40) >> 4) & 1) == 0 || v29 != 8))
        {
          unint64_t v32 = (unint64_t)v31;
        }
        int v23 = v22 + v31 - v32;
        if (v30) {
          ++v23;
        }
        if (*(int *)(v35 + 20) <= (uint64_t)&v31[-v32])
        {
          if (*(_DWORD *)(v35 + 20) == -1)
          {
            if (*(_DWORD *)(v35 + 32) != 48 || *(_DWORD *)(v35 + 24) <= v23 || ((*(_WORD *)(v35 + 40) >> 6) & 1) != 0) {
              int v27 = 0;
            }
            else {
              int v27 = *(_DWORD *)(v35 + 24) - v23;
            }
          }
          else
          {
            int v27 = 0;
          }
        }
        else
        {
          int v27 = *(_DWORD *)(v35 + 20) - (v31 - v32);
        }
        int v24 = v23 + v27;
        while (1)
        {
          BOOL v13 = 0;
          if (v27 > 0) {
            BOOL v13 = v32 > (unint64_t)v38;
          }
          if (!v13) {
            break;
          }
          *(unsigned char *)--unint64_t v32 = 48;
          --v27;
        }
        if (v24 >= 128)
        {
          if (((*(_WORD *)(v35 + 40) >> 6) & 1) == 0 && *(_DWORD *)(v35 + 24) > v24) {
            int v14 = __printf_pad(v36, *(_DWORD *)(v35 + 24) - v24, 0);
          }
          if (v30)
          {
            v14 += __printf_puts(v36, (uint64_t)&v30, 1u);
          }
          else if (v21)
          {
            v14 += __printf_puts(v36, (uint64_t)v21, 2u);
          }
          if (v27 > 0) {
            v14 += __printf_pad(v36, v27, 1);
          }
        }
        else
        {
          if (v30)
          {
            *(unsigned char *)--unint64_t v32 = v30;
          }
          else if (v21)
          {
            char v9 = v21[1];
            *(unsigned char *)--unint64_t v32 = v9;
            char v10 = *v21;
            *(unsigned char *)--unint64_t v32 = v10;
          }
          if (*(int *)(v35 + 24) > (uint64_t)&v31[-v32] && ((*(_WORD *)(v35 + 40) >> 6) & 1) == 0)
          {
            for (int i = *(_DWORD *)(v35 + 24) - (v31 - v32); ; --i)
            {
              BOOL v12 = 0;
              if (i > 0) {
                BOOL v12 = v32 > (unint64_t)v38;
              }
              if (!v12) {
                break;
              }
              *(unsigned char *)--unint64_t v32 = 32;
            }
            if (i) {
              int v14 = __printf_pad(v36, i, 0);
            }
          }
        }
        int v15 = v14 + __printf_puts(v36, v32, (int)v31 - (int)v32);
        if (*(_DWORD *)(v35 + 24) > v15 && ((*(_WORD *)(v35 + 40) >> 6) & 1) != 0) {
          v15 += __printf_pad(v36, *(_DWORD *)(v35 + 24) - v15, 0);
        }
        __printf_flush(v36);
        unsigned int v37 = v15;
        break;
      default:
        JUMPOUT(0);
    }
  }
  else
  {
    return __xprintf_vector(v36, v35, v34);
  }
  return v37;
}

char *__ultoa_1(unint64_t a1, char *a2, int a3, uint64_t a4, int a5, const void *a6, int a7, char *a8)
{
  unint64_t v16 = a1;
  mbstate_t __dst = a2;
  if (a3 == 8)
  {
    do
    {
      *--mbstate_t __dst = (v16 & 7) + 48;
      v16 >>= 3;
    }
    while (v16);
    return __dst;
  }
  if (a3 != 10)
  {
    if (a3 != 16) {
      __assert_rtn("__ultoa", "xprintf_int.c", 162, "base == 16");
    }
    do
    {
      *--mbstate_t __dst = *(unsigned char *)(a4 + (v16 & 0xF));
      v16 >>= 4;
    }
    while (v16);
    return __dst;
  }
  if (a1 >= 0xA)
  {
    int v9 = 0;
    if (a1 <= 0x7FFFFFFFFFFFFFFFLL)
    {
      int64_t v10 = a1;
    }
    else
    {
      mbstate_t __dst = a2 - 1;
      *(a2 - 1) = a1 % 0xA + 48;
      int v9 = 1;
      int64_t v10 = a1 / 0xA;
    }
    do
    {
      *--mbstate_t __dst = v10 % 10 + 48;
      ++v9;
      if (a5)
      {
        if (v9 == *a8 && *a8 != 127 && v10 > 9)
        {
          __dst -= a7;
          memcpy(__dst, a6, a7);
          int v9 = 0;
          if (a8[1]) {
            ++a8;
          }
        }
      }
      v10 /= 10;
    }
    while (v10);
    return __dst;
  }
  *(a2 - 1) = a1 + 48;
  return a2 - 1;
}

char *__ujtoa_1(unint64_t a1, char *a2, int a3, uint64_t a4, int a5, const void *a6, int a7, char *a8)
{
  unint64_t v16 = a1;
  mbstate_t __dst = a2;
  if (a3 == 8)
  {
    do
    {
      *--mbstate_t __dst = (v16 & 7) + 48;
      v16 >>= 3;
    }
    while (v16);
    return __dst;
  }
  if (a3 != 10)
  {
    if (a3 != 16) {
      abort();
    }
    do
    {
      *--mbstate_t __dst = *(unsigned char *)(a4 + (v16 & 0xF));
      v16 >>= 4;
    }
    while (v16);
    return __dst;
  }
  if (a1 >= 0xA)
  {
    int v9 = 0;
    if (a1 <= 0x7FFFFFFFFFFFFFFFLL)
    {
      int64_t v10 = a1;
    }
    else
    {
      mbstate_t __dst = a2 - 1;
      *(a2 - 1) = a1 % 0xA + 48;
      int v9 = 1;
      int64_t v10 = a1 / 0xA;
    }
    do
    {
      *--mbstate_t __dst = v10 % 10 + 48;
      ++v9;
      if (a5)
      {
        if (*a8 != 127 && v9 == *a8 && v10 > 9)
        {
          __dst -= a7;
          memcpy(__dst, a6, a7);
          int v9 = 0;
          if (a8[1]) {
            ++a8;
          }
        }
      }
      v10 /= 10;
    }
    while (v10);
    return __dst;
  }
  *(a2 - 1) = a1 % 0xA + 48;
  return a2 - 1;
}

uint64_t __printf_arginfo_ptr(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_ptr", "xprintf_int.c", 462, "n > 0");
  }
  if (*(__int16 *)(a1 + 40) >= 0) {
    *a3 = 32;
  }
  else {
    *a3 = 256;
  }
  return 1;
}

uint64_t __printf_render_ptr(uint64_t a1, const void *a2, uint64_t **a3)
{
  uint64_t v9 = a1;
  uint64_t v8 = a2;
  char v7 = a3;
  memset(__b, 0, sizeof(__b));
  uint64_t v5 = 0;
  unsigned int v4 = 0;
  if (*((__int16 *)v8 + 20) >= 0)
  {
    uint64_t v5 = **v7;
    memcpy(__b, v8, sizeof(__b));
    __b[7] = 120;
    LOWORD(__b[10]) = __b[10] & 0xFFEF | 0x10;
    LOWORD(__b[10]) = __b[10] & 0xFFFE | 1;
    unsigned int v4 = (unint64_t *)&v5;
    return __printf_render_int(v9, (uint64_t)__b, &v4);
  }
  else
  {
    return __xprintf_vector(v9, v8, v7);
  }
}

uint64_t __printf_arginfo_quote(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_quote", "xprintf_quote.c", 45, "n >= 1");
  }
  *a3 = 32;
  return 1;
}

uint64_t __printf_render_quote(uint64_t a1, uint64_t a2, const char ***a3)
{
  uint64_t v16 = a1;
  uint64_t v15 = a2;
  int v14 = a3;
  BOOL v13 = 0;
  int i = 0;
  unsigned int v11 = 0;
  int64_t v10 = 0;
  BOOL v13 = **a3;
  if (!v13) {
    return __printf_out(v16, v15, (uint64_t)"\"(null)\"", 8);
  }
  if (!*v13) {
    return __printf_out(v16, v15, (uint64_t)"\"\"", 2);
  }
  int v8 = 0;
  for (int i = v13; *i; ++i)
  {
    if (isspace(*i) || *i == 92 || *i == 34) {
      ++v8;
    }
  }
  if (!v8)
  {
    signed int v3 = strlen(v13);
    return __printf_out(v16, v15, (uint64_t)v13, v3);
  }
  int v6 = __printf_out(v16, v15, (uint64_t)"\"", 1);
  int i = v13;
  unsigned int v11 = v13;
  while (*i)
  {
    int64_t v10 = 0;
    switch(*i)
    {
      case 92:
        int64_t v10 = "\\\\"";
        break;
      case 10:
        int64_t v10 = "\\n";
        break;
      case 13:
        int64_t v10 = "\\r";
        break;
      case 9:
        int64_t v10 = "\\t";
        break;
      case 32:
        int64_t v10 = " ";
        break;
      case 34:
        int64_t v10 = "\\\"";
        break;
      default:
        if (!isspace(*i)) {
          goto LABEL_34;
        }
        sprintf(v9, "\\%03o", *i);
        int64_t v10 = v9;
        break;
    }
    if (i != v11) {
      v6 += __printf_out(v16, v15, (uint64_t)v11, (int)i - (int)v11);
    }
    signed int v4 = strlen(v10);
    v6 += __printf_out(v16, v15, (uint64_t)v10, v4);
    unsigned int v11 = i + 1;
LABEL_34:
    ++i;
  }
  if (i != v11) {
    v6 += __printf_out(v16, v15, (uint64_t)v11, (int)i - (int)v11);
  }
  unsigned int v7 = v6 + __printf_out(v16, v15, (uint64_t)"\"", 1);
  __printf_flush(v16);
  return v7;
}

uint64_t __printf_arginfo_str(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_str", "xprintf_str.c", 113, "n > 0");
  }
  if (((*(_WORD *)(a1 + 40) >> 3) & 1) != 0 || *(_DWORD *)(a1 + 28) == 67) {
    *a3 = 16;
  }
  else {
    *a3 = 8;
  }
  return 1;
}

uint64_t __printf_render_str(uint64_t a1, uint64_t a2, const char ***a3)
{
  if (((*(_WORD *)(a2 + 40) >> 3) & 1) != 0 || *(_DWORD *)(a2 + 28) == 83)
  {
    int v8 = (const __int32 *)**a3;
    if (!v8) {
      return __printf_out(a1, a2, (uint64_t)"(null)", 6);
    }
    __s = __wcsconv_0(v8, *(_DWORD *)(a2 + 20), *(_xlocale **)(a2 + 8));
    if (__s)
    {
      signed int v3 = strlen(__s);
      unsigned int v5 = __printf_out(a1, a2, (uint64_t)__s, v3);
      __printf_flush(a1);
      free(__s);
      return v5;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    uint64_t v9 = **a3;
    if (!v9) {
      return __printf_out(a1, a2, (uint64_t)"(null)", 6);
    }
    signed int v6 = strlen(v9);
    if (*(int *)(a2 + 20) >= 0 && *(_DWORD *)(a2 + 20) < v6) {
      signed int v6 = *(_DWORD *)(a2 + 20);
    }
    return __printf_out(a1, a2, (uint64_t)v9, v6);
  }
}

char *__wcsconv_0(const __int32 *a1, int a2, _xlocale *a3)
{
  BOOL v13 = a1;
  int v12 = a2;
  locale_t v11 = a3;
  memset(&__b, 0, sizeof(__b));
  uint64_t v9 = 0;
  if (v12 >= 0)
  {
    if (v12 >= 128)
    {
      size_t v5 = 0;
      uint64_t v9 = (__int32 *)v13;
      memcpy(&__b, &__wcsconv_initial_0, sizeof(__b));
      while (1)
      {
        signed int v3 = v9++;
        size_t v7 = wcrtomb_l(v10, *v3, &__b, v11);
        if (!v7 || v7 == -1 || (int)v5 + (int)v7 > v12) {
          break;
        }
        v5 += v7;
      }
    }
    else
    {
      size_t v5 = v12;
    }
  }
  else
  {
    uint64_t v9 = (__int32 *)v13;
    memcpy(&__b, &__wcsconv_initial_0, sizeof(__b));
    size_t v5 = wcsrtombs_l(0, (const __int32 **)&v9, 0, &__b, v11);
    if (v5 == -1) {
      return 0;
    }
  }
  int v8 = (char *)malloc_type_malloc();
  if (!v8) {
    return 0;
  }
  uint64_t v9 = (__int32 *)v13;
  memcpy(&__b, &__wcsconv_initial_0, sizeof(__b));
  size_t v6 = wcsrtombs_l(v8, (const __int32 **)&v9, v5, &__b, v11);
  if (v6 == -1)
  {
    free(v8);
    return 0;
  }
  else
  {
    v8[v6] = 0;
    return v8;
  }
}

uint64_t __printf_arginfo_chr(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_chr", "xprintf_str.c", 156, "n > 0");
  }
  if (*(__int16 *)(a1 + 40) >= 0)
  {
    if (((*(_WORD *)(a1 + 40) >> 3) & 1) != 0 || *(_DWORD *)(a1 + 28) == 67) {
      *a3 = 4;
    }
    else {
      *a3 = 1;
    }
  }
  else
  {
    *a3 = 256;
  }
  return 1;
}

uint64_t __printf_render_chr(uint64_t a1, uint64_t a2, __int32 **a3)
{
  uint64_t v19 = a1;
  uint64_t v18 = a2;
  unsigned int v17 = a3;
  unsigned int v16 = 0;
  __int32 v15 = 0;
  char v14 = 0;
  memset(&__b, 0, sizeof(__b));
  size_t v13 = 0;
  uint64_t v3 = *(unsigned int *)(*(void *)(*(void *)(v18 + 8) + 1328) + 64);
  int v12 = &v5;
  int v8 = (char *)&v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v11 = v3;
  if (*(__int16 *)(v18 + 40) >= 0)
  {
    if (((*(_WORD *)(v18 + 40) >> 3) & 1) != 0 || *(_DWORD *)(v18 + 28) == 67)
    {
      unsigned int v9 = 0;
      __int32 v15 = **v17;
      p_b = &__b;
      memcpy(&__b, &__printf_render_chr_initial, sizeof(__b));
      size_t v13 = wcrtomb_l(v8, v15, &__b, *(locale_t *)(v18 + 8));
      if (v13 == -1)
      {
        unsigned int v20 = -1;
      }
      else
      {
        unsigned int v9 = __printf_out(v19, v18, (uint64_t)v8, v13);
        __printf_flush(v19);
        unsigned int v20 = v9;
      }
      int v10 = 1;
    }
    else
    {
      unsigned int v16 = **v17;
      char v14 = v16;
      int v6 = 1;
      unsigned int v16 = __printf_out(v19, v18, (uint64_t)&v14, 1);
      __printf_flush(v19);
      unsigned int v20 = v16;
      int v10 = v6;
    }
  }
  else
  {
    unsigned int v20 = __xprintf_vector(v19, v18, v17);
    int v10 = 1;
  }
  return v20;
}

uint64_t __printf_arginfo_time(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_time", "xprintf_time.c", 48, "n >= 1");
  }
  *a3 = 32;
  return 1;
}

uint64_t __printf_render_time(uint64_t a1, uint64_t a2, uint64_t ***a3)
{
  if ((*(_WORD *)(a2 + 40) >> 3))
  {
    uint64_t v11 = **a3;
    uint64_t v9 = *v11;
    int v5 = 1000 * *((_DWORD *)v11 + 2);
    int v6 = 6;
  }
  else if (*(_WORD *)(a2 + 40))
  {
    int v10 = **a3;
    uint64_t v9 = *v10;
    int v5 = v10[1];
    int v6 = 9;
  }
  else
  {
    uint64_t v9 = ***a3;
    int v5 = 0;
    int v6 = 0;
  }
  if ((*(_WORD *)(a2 + 40) >> 3) & 1) != 0 || (*(_WORD *)(a2 + 40))
  {
    if (*(int *)(a2 + 20) >= 0) {
      int v6 = *(_DWORD *)(a2 + 20);
    }
    if (!v6) {
      int v5 = 0;
    }
  }
  int v12 = v15;
  if ((*(_WORD *)(a2 + 40) >> 4))
  {
    uint64_t v8 = v9;
    if (v9 >= 31536000)
    {
      int v12 = &v15[sprintf(v15, "%jdy", v9 / 31536000)];
      v9 %= 31536000;
    }
    if (v8 >= 86400 && (v9 || v6))
    {
      v12 += sprintf(v12, "%jdd", v9 / 86400);
      v9 %= 86400;
    }
    if (v8 >= 3600 && (v9 || v6))
    {
      v12 += sprintf(v12, "%jdh", v9 / 3600);
      v9 %= 3600;
    }
    if (v8 >= 60 && (v9 || v6))
    {
      v12 += sprintf(v12, "%jdm", v9 / 60);
      v9 %= 60;
    }
    if (v9 || !v8 || v6) {
      v12 += sprintf(v12, "%jds", v9);
    }
  }
  else
  {
    int v12 = &v15[sprintf(v15, "%jd", v9)];
  }
  if (v6)
  {
    for (int i = v6; i < 9; ++i)
      v5 /= 10;
    v12 += sprintf(v12, ".%.*d", v6, v5);
  }
  unsigned int v4 = __printf_out(a1, a2, (uint64_t)v15, v12 - v15);
  __printf_flush(a1);
  return v4;
}

uint64_t __printf_arginfo_vis(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_vis", "xprintf_vis.c", 44, "n >= 1");
  }
  *a3 = 32;
  return 1;
}

uint64_t __printf_render_vis(uint64_t a1, uint64_t a2, char ***a3)
{
  __s = **a3;
  if (__s)
  {
    if (*(int *)(a2 + 20) < 0) {
      unsigned int v7 = strlen(__s);
    }
    else {
      unsigned int v7 = *(_DWORD *)(a2 + 20);
    }
    uint64_t v8 = (char *)malloc_type_malloc();
    if (v8)
    {
      if ((*(_WORD *)(a2 + 40) >> 7))
      {
        signed int v5 = strvisx(v8, __s, v7, 156);
        int v3 = __printf_out(a1, a2, (uint64_t)v8, v5);
      }
      else if (*(_DWORD *)(a2 + 32) == 48)
      {
        signed int v5 = strvisx(v8, __s, v7, 29);
        int v3 = __printf_out(a1, a2, (uint64_t)v8, v5);
      }
      else
      {
        if ((*(_WORD *)(a2 + 40) >> 4)) {
          signed int v5 = strvisx(v8, __s, v7, 28);
        }
        else {
          signed int v5 = strvisx(v8, __s, v7, 31);
        }
        int v3 = __printf_out(a1, a2, (uint64_t)v8, v5);
      }
      unsigned int v6 = v5 + v3;
      __printf_flush(a1);
      free(v8);
      return v6;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return __printf_out(a1, a2, (uint64_t)"(null)", 6);
  }
}

uint64_t __printf_flush(uint64_t a1)
{
  return __printf_init(a1);
}

uint64_t __printf_init(uint64_t result)
{
  *(void *)(result + 152) = result + 24;
  *(void *)(result + 8) = result + 24;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t __printf_puts(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3)
  {
    **(void **)(a1 + 152) = a2;
    *(void *)(*(void *)(a1 + 152) + 8) = (int)a3;
    *(_DWORD *)(a1 + 20) += a3;
    *(void *)(a1 + 152) += 16;
    if ((int)++*(_DWORD *)(a1 + 16) >= 8) {
      __printf_flush(a1);
    }
    return a3;
  }
  else
  {
    return 0;
  }
}

uint64_t __printf_pad(uint64_t a1, int a2, int a3)
{
  unsigned int v4 = 0;
  if (a3) {
    signed int v5 = &zeroes_1;
  }
  else {
    signed int v5 = &blanks_1;
  }
  signed int v6 = a2;
  if (a2 > 0)
  {
    while (v6 > 16)
    {
      v4 += __printf_puts(a1, (uint64_t)v5, 0x10u);
      v6 -= 16;
    }
    v4 += __printf_puts(a1, (uint64_t)v5, v6);
  }
  return v4;
}

uint64_t __printf_out(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4)
{
  int v5 = 0;
  if (((*(_WORD *)(a2 + 40) >> 6) & 1) == 0 && *(_DWORD *)(a2 + 24) > a4) {
    int v5 = __printf_pad(a1, *(_DWORD *)(a2 + 24) - a4, *(_DWORD *)(a2 + 32) == 48);
  }
  unsigned int v6 = v5 + __printf_puts(a1, a3, a4);
  if (((*(_WORD *)(a2 + 40) >> 6) & 1) != 0 && *(_DWORD *)(a2 + 24) > a4) {
    v6 += __printf_pad(a1, *(_DWORD *)(a2 + 24) - a4, *(_DWORD *)(a2 + 32) == 48);
  }
  return v6;
}

uint64_t __printf_arginfo_pct()
{
  return 0;
}

uint64_t __printf_render_pct(uint64_t a1)
{
  return __printf_puts(a1, (uint64_t)"%", 1u);
}

uint64_t __printf_arginfo_n(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    __assert_rtn("__printf_arginfo_n", "xprintf.c", 233, "n >= 1");
  }
  *a3 = 32;
  return 1;
}

uint64_t __printf_render_n(uint64_t a1, uint64_t a2, unsigned char **a3)
{
  size_t v13 = *a3;
  if ((*(_WORD *)(a2 + 40) >> 1))
  {
    char v12 = *(_DWORD *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 1);
    *size_t v13 = v12;
  }
  else if ((*(_WORD *)(a2 + 40) >> 2))
  {
    __int16 v11 = *(_DWORD *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 2);
    *(_WORD *)size_t v13 = v11;
  }
  else if ((*(_WORD *)(a2 + 40) >> 3))
  {
    uint64_t v10 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(void *)size_t v13 = v10;
  }
  else if (*(_WORD *)(a2 + 40))
  {
    uint64_t v9 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(void *)size_t v13 = v9;
  }
  else if ((*(_WORD *)(a2 + 40) >> 12))
  {
    uint64_t v8 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(void *)size_t v13 = v8;
  }
  else if ((*(_WORD *)(a2 + 40) >> 13))
  {
    uint64_t v7 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(void *)size_t v13 = v7;
  }
  else if ((*(_WORD *)(a2 + 40) >> 11))
  {
    uint64_t v6 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(void *)size_t v13 = v6;
  }
  else if ((*(_WORD *)(a2 + 40) >> 14))
  {
    uint64_t v5 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(void *)size_t v13 = v5;
  }
  else
  {
    int v4 = *(_DWORD *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 4);
    *(_DWORD *)size_t v13 = v4;
  }
  return 0;
}

uint64_t __printf_comp(uint64_t a1, uint64_t a2)
{
  uint64_t v36 = a1;
  uint64_t v35 = a2;
  unint64_t k = 0;
  unint64_t v33 = 0;
  unint64_t v32 = 0;
  int v31 = 0;
  int i = 0;
  int v29 = 0;
  int v28 = 0;
  int v27 = 0;
  unsigned int v26 = 0;
  int j = 0;
  v24[0] = 0;
  v24[1] = 0;
  v23[0] = 0;
  v23[1] = 0;
  unint64_t v32 = *(unsigned char **)(a1 + 64);
  int v27 = 0;
  int v28 = 1;
  int v22 = (void **)arrayinit((uint64_t)v24, 88);
  if (v22)
  {
    int v21 = (void **)arrayinit((uint64_t)v23, 4);
    if (v21)
    {
      for (int i = 0; ; ++i)
      {
        unint64_t k = arrayget((uint64_t)v22, i);
        if (!k)
        {
          unsigned int v26 = -1;
          goto LABEL_116;
        }
        unint64_t v33 = k;
        if (!*v32) {
          break;
        }
        unint64_t v33 = k + 88;
        *(_DWORD *)(k + 20) = -1;
        *(_DWORD *)(k + 32) = 32;
        *(_DWORD *)(k + 16) = 88;
        int v2 = v32;
        *(void *)(k + 64) = v32;
        *(void *)(k + 56) = v2;
        while (1)
        {
          BOOL v20 = 0;
          if (*v32) {
            BOOL v20 = *v32 != 37;
          }
          if (!v20) {
            break;
          }
          *(void *)(k + 64) = ++v32;
        }
        if (!*v32) {
          break;
        }
        ++v32;
        while (1)
        {
          *(_DWORD *)(k + 28) = (char)*v32;
          unsigned int v3 = *(_DWORD *)(k + 28);
          BOOL v4 = v3 > 0x20;
          uint64_t v5 = v3 - 32;
          if (v4)
          {
            uint64_t v7 = v5;
            char v6 = 1;
          }
          else
          {
            uint64_t v7 = v5;
            char v6 = 0;
          }
          if (v6) {
            break;
          }
          switch(v7)
          {
            case 0:
              if (((*(_WORD *)(k + 40) >> 7) & 1) == 0)
              {
                *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFFDF | 0x20;
                *(_DWORD *)(k + 36) = 32;
              }
              ++v32;
              continue;
            case 1:
            case 2:
            case 4:
            case 6:
            case 8:
            case 9:
            case 15:
            case 28:
            case 29:
            case 30:
            case 31:
            case 32:
            case 33:
            case 34:
            case 35:
            case 36:
            case 37:
            case 38:
            case 39:
            case 40:
            case 41:
            case 42:
            case 43:
            case 45:
            case 46:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 52:
            case 53:
            case 54:
            case 55:
            case 56:
            case 57:
            case 58:
            case 59:
            case 60:
            case 61:
            case 62:
            case 64:
            case 65:
            case 66:
            case 67:
            case 68:
            case 69:
            case 70:
            case 71:
            case 73:
            case 75:
            case 77:
            case 78:
            case 79:
            case 80:
            case 82:
            case 83:
            case 85:
            case 87:
            case 88:
            case 89:
              goto LABEL_85;
            case 3:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFFEF | 0x10;
              ++v32;
              continue;
            case 5:
              ++v32;
              goto LABEL_86;
            case 7:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFEFF | 0x100;
              ++v32;
              continue;
            case 10:
              ++v32;
              for (int j = 0; ; j += (char)*v32++ - 48)
              {
                BOOL v17 = 0;
                if (*v32) {
                  BOOL v17 = ((char)*v32 - 48) <= 9;
                }
                if (!v17) {
                  break;
                }
                j *= 10;
              }
              if (*v32 == 36)
              {
                if (j + 1 > v27) {
                  int v27 = j + 1;
                }
                ++v32;
              }
              else
              {
                int v9 = v28++;
                int j = v9;
              }
              *(_DWORD *)(k + 48) = j;
              int v29 = (_DWORD *)arrayget((uint64_t)v21, j);
              if (!v29)
              {
                unsigned int v26 = -1;
                goto LABEL_116;
              }
              *int v29 = 1;
              break;
            case 11:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFF7F | 0x80;
              *(_DWORD *)(k + 36) = 43;
              ++v32;
              continue;
            case 12:
            case 26:
            case 27:
            case 63:
              *(_DWORD *)(k + 16) = *(_DWORD *)(k + 28);
              ++v32;
              continue;
            case 13:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFFBF | 0x40;
              ++v32;
              continue;
            case 14:
              *(_DWORD *)(k + 20) = 0;
              if (*++v32 == 42)
              {
                ++v32;
                for (int j = 0; ; j += (char)*v32++ - 48)
                {
                  BOOL v19 = 0;
                  if (*v32) {
                    BOOL v19 = ((char)*v32 - 48) <= 9;
                  }
                  if (!v19) {
                    break;
                  }
                  j *= 10;
                }
                if (*v32 == 36)
                {
                  if (j + 1 > v27) {
                    int v27 = j + 1;
                  }
                  ++v32;
                }
                else
                {
                  int v8 = v28++;
                  int j = v8;
                }
                *(_DWORD *)(k + 52) = j;
                int v29 = (_DWORD *)arrayget((uint64_t)v21, j);
                if (!v29)
                {
                  unsigned int v26 = -1;
                  goto LABEL_116;
                }
                *int v29 = 1;
              }
              else
              {
                while (1)
                {
                  BOOL v18 = 0;
                  if (*v32) {
                    BOOL v18 = ((char)*v32 - 48) <= 9;
                  }
                  if (!v18) {
                    break;
                  }
                  *(_DWORD *)(k + 20) *= 10;
                  *(_DWORD *)(k + 20) += (char)*v32++ - 48;
                }
              }
              continue;
            case 16:
              *(_DWORD *)(k + 32) = 48;
              ++v32;
              continue;
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
              for (int j = 0; ; j += (char)*v32++ - 48)
              {
                BOOL v16 = 0;
                if (*v32) {
                  BOOL v16 = ((char)*v32 - 48) <= 9;
                }
                if (!v16) {
                  break;
                }
                j *= 10;
              }
              if (*v32 == 36)
              {
                if (v28 > v27) {
                  int v27 = v28;
                }
                int v28 = j;
                ++v32;
              }
              else
              {
                *(_DWORD *)(k + 24) = j;
              }
              continue;
            case 44:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFFFE | 1;
              ++v32;
              continue;
            case 72:
              if (*++v32 == 104)
              {
                ++v32;
                *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFFFD | 2;
              }
              else
              {
                *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFFFB | 4;
              }
              continue;
            case 74:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xEFFF | 0x1000;
              ++v32;
              continue;
            case 76:
              if (*++v32 == 108)
              {
                ++v32;
                *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFFFE | 1;
                *(_WORD *)(k + 40) &= ~0x800u;
              }
              else
              {
                *(_WORD *)(k + 40) &= ~0x800u;
                *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xFFF7 | 8;
              }
              continue;
            case 81:
              *(_WORD *)(k + 40) &= ~8u;
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xF7FF | 0x800;
              ++v32;
              continue;
            case 84:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xDFFF | 0x2000;
              ++v32;
              continue;
            case 86:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0x7FFF | 0x8000;
              ++v32;
              continue;
            case 90:
              *(_WORD *)(k + 40) = *(_WORD *)(k + 40) & 0xBFFF | 0x4000;
              ++v32;
              continue;
            default:
              JUMPOUT(0);
          }
        }
LABEL_85:
        ++v32;
LABEL_86:
        if (*(int *)(k + 28) >= 33 && *(int *)(k + 28) <= 126)
        {
          int v15 = *(char *)(v35 + 200 + *(_DWORD *)(k + 28) - 33);
          if (v15 == 2 || v15 == 1)
          {
            if (!arrayget((uint64_t)v21, v28 + 1))
            {
              unsigned int v26 = -1;
LABEL_116:
              arrayfree(v22);
              arrayfree(v21);
              return v26;
            }
            *(void *)unint64_t k = *(void *)(v35 + 296 + 24 * (*(_DWORD *)(k + 28) - 33) + 16);
            *(void *)(k + 8) = *(void *)(v36 + 80);
            size_t v13 = *(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v35
                                                                               + 296
                                                                               + 24 * (*(_DWORD *)(k + 28) - 33));
            unint64_t v14 = k;
            uint64_t v11 = arrayget((uint64_t)v21, v28);
            int v31 = v13(v14, 2, v11);
            if (v31 > 0) {
              *(void *)(k + 72) = v28;
            }
            if (v31 > 1) {
              *(void *)(k + 80) = v28 + 1;
            }
            v28 += v31;
          }
          else if (v15 == 3)
          {
            errx(1, "Unexpected flag: %c", *(unsigned int *)(k + 28));
          }
        }
      }
      if (v28 > v27) {
        int v27 = v28;
      }
      *(void *)(v36 + 104) = *v21;
      *(void *)(v36 + 88) = *v22;
      *(void *)(v36 + 96) = v33;
      int v31 = v27;
      *(_DWORD *)(v36 + 120) = v27;
      if (v31 < 1) {
        int v31 = 1;
      }
      *(void *)(v36 + 112) = malloc_type_malloc();
      if (!*(void *)(v36 + 112))
      {
        unsigned int v26 = -1;
        goto LABEL_116;
      }
      for (unint64_t k = *(void *)(v36 + 88); k < v33; k += 88)
      {
        if (*(void *)(k + 72)) {
          *(void *)(k + 72) = *(void *)(v36 + 112) + 16 * *(void *)(k + 72);
        }
        if (*(void *)(k + 80)) {
          *(void *)(k + 80) = *(void *)(v36 + 112) + 16 * *(void *)(k + 80);
        }
      }
      *(void *)(v36 + 72) = v35;
      return v26;
    }
    else
    {
      arrayfree(v22);
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t arrayinit(uint64_t a1, int a2)
{
  *(void *)a1 = malloc_type_calloc();
  if (!*(void *)a1) {
    return 0;
  }
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = 8;
  return a1;
}

void arrayfree(void **a1)
{
  if (a1) {
    free(*a1);
  }
}

uint64_t arrayget(uint64_t a1, int a2)
{
  if (a2 < *(_DWORD *)(a1 + 12)) {
    return *(void *)a1 + a2 * *(_DWORD *)(a1 + 8);
  }
  int v6 = *(_DWORD *)(a1 + 12) * *(_DWORD *)(a1 + 8);
  int v5 = a2 + 8;
  int v4 = (a2 + 8) * *(_DWORD *)(a1 + 8);
  uint64_t v3 = malloc_type_realloc();
  if (v3)
  {
    bzero((void *)(v3 + v6), v4 - v6);
    *(void *)a1 = v3;
    *(_DWORD *)(a1 + 12) = v5;
    return *(void *)a1 + a2 * *(_DWORD *)(a1 + 8);
  }
  return 0;
}

uint64_t __printf_exec(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v53 = a1;
  uint64_t v52 = a2;
  signed int v51 = a3;
  unint64_t j = 0;
  int i = 0;
  unsigned int v48 = 0;
  int v47 = 0;
  memset(v46, 0, sizeof(v46));
  __printf_init((uint64_t)v46);
  v46[0] = v52;
  for (int i = 1; i < *(_DWORD *)(v53 + 120); ++i)
  {
    int v26 = *(_DWORD *)(*(void *)(v53 + 104) + 4 * i);
    switch(v26)
    {
      case 1:
        int v4 = v51;
        v51 += 2;
        int v44 = *v4;
        *(_DWORD *)(*(void *)(v53 + 112) + 16 * i) = v44;
        break;
      case 2:
        uint64_t v3 = v51;
        v51 += 2;
        int v45 = *v3;
        *(_DWORD *)(*(void *)(v53 + 112) + 16 * i) = (char)v45;
        break;
      case 4:
        char v12 = v51;
        v51 += 2;
        int v36 = *v12;
        *(_DWORD *)(*(void *)(v53 + 112) + 16 * i) = v36;
        break;
      case 8:
        uint64_t v34 = 0;
        unint64_t v14 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v33 = *v14;
        uint64_t v34 = v33;
        libc_hooks_will_read_cstring(v33);
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v33;
        break;
      case 16:
        uint64_t v32 = 0;
        int v15 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v31 = *v15;
        uint64_t v32 = v31;
        libc_hooks_will_read_wcstring(v31);
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v31;
        break;
      case 32:
        size_t v13 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v35 = *v13;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v35;
        break;
      case 128:
        BOOL v16 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v30 = *v16;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v30;
        break;
      case 256:
        BOOL v18 = (_OWORD *)(((unint64_t)v51 + 15) & 0xFFFFFFFFFFFFFFF0);
        signed int v51 = (int *)(v18 + 1);
        long long v28 = *v18;
        *(_OWORD *)(*(void *)(v53 + 112) + 16 * i) = v28;
        break;
      case 65537:
        int v9 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v39 = *v9;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v39;
        break;
      case 65664:
        BOOL v17 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v29 = *v17;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v29;
        break;
      case 131073:
        int v6 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v42 = *v6;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v42;
        break;
      case 262145:
        int v5 = v51;
        v51 += 2;
        int v43 = *v5;
        *(_DWORD *)(*(void *)(v53 + 112) + 16 * i) = (__int16)v43;
        break;
      case 1048577:
        int v8 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v40 = *v8;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v40;
        break;
      case 2097153:
        uint64_t v7 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v41 = *v7;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v41;
        break;
      case 4194305:
        uint64_t v10 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v38 = *v10;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v38;
        break;
      case 8388609:
        uint64_t v11 = (uint64_t *)v51;
        v51 += 2;
        uint64_t v37 = *v11;
        *(void *)(*(void *)(v53 + 112) + 16 * i) = v37;
        break;
      default:
        errx(1, "argtype = %x (fmt = \"%s\")\n", *(_DWORD *)(*(void *)(v53 + 104) + 4 * i), *(const char **)(v53 + 64));
    }
  }
  for (unint64_t j = *(void *)(v53 + 88); j < *(void *)(v53 + 96); j += 88)
  {
    if (*(_DWORD *)(j + 48))
    {
      *(_DWORD *)(j + 24) = *(_DWORD *)(*(void *)(v53 + 112) + 16 * *(unsigned int *)(j + 48));
      if ((*(_DWORD *)(j + 24) & 0x80000000) != 0)
      {
        *(_WORD *)(j + 40) |= 0x40u;
        *(_DWORD *)(j + 24) = -*(_DWORD *)(j + 24);
      }
    }
    if (*(_DWORD *)(j + 52)) {
      *(_DWORD *)(j + 20) = *(_DWORD *)(*(void *)(v53 + 112) + 16 * *(unsigned int *)(j + 52));
    }
    v48 += __printf_puts((uint64_t)v46, *(void *)(j + 56), *(_DWORD *)(j + 64) - *(void *)(j + 56));
    if (*(_DWORD *)(j + 28))
    {
      if (*(int *)(j + 28) >= 33
        && *(int *)(j + 28) < 127
        && (int v19 = *(_DWORD *)(j + 28) - 33,
            int v25 = *(char *)(*(void *)(v53 + 72) + v19 + 200),
            *(unsigned char *)(*(void *)(v53 + 72) + v19 + 200)))
      {
        if (v25 == 1)
        {
          __printf_flush((uint64_t)v46);
          *(_DWORD *)(j + 44) = v48;
          int v24 = 0;
          if (*(void *)(*(void *)(v53 + 72) + 24 * (*(_DWORD *)(j + 28) - 33) + 304)) {
            int v24 = *(uint64_t (**)(void, void, void))(*(void *)(v53 + 72)
          }
                                                                   + 24 * (*(_DWORD *)(j + 28) - 33)
                                                                   + 304);
          int v21 = v24(v52, j, j + 72);
          v48 += v21;
        }
        else if (v25 == 2)
        {
          *(_DWORD *)(j + 44) = v48;
          int v23 = 0;
          if (*(void *)(*(void *)(v53 + 72) + 24 * (*(_DWORD *)(j + 28) - 33) + 304)) {
            int v23 = *(uint64_t (**)(void, void, void))(*(void *)(v53 + 72)
          }
                                                                   + 24 * (*(_DWORD *)(j + 28) - 33)
                                                                   + 304);
          int v47 = v23(v46, j, j + 72);
          if (v47 < 0) {
            *(_WORD *)(v46[0] + 16) |= 0x40u;
          }
          else {
            v48 += v47;
          }
        }
      }
      else
      {
        char v27 = 0;
        char v27 = *(_DWORD *)(j + 28);
        int v20 = __printf_out((uint64_t)v46, j, (uint64_t)&v27, 1);
        v48 += v20;
      }
    }
  }
  __printf_flush((uint64_t)v46);
  return v48;
}

uint64_t libc_hooks_will_read_wcstring(uint64_t result)
{
  int v1 = 0;
  if (off_F5430) {
    int v1 = off_F5430;
  }
  if (v1) {
    return off_F5430(result);
  }
  return result;
}

uint64_t __v2printf(uint64_t a1, pthread_rwlock_t *a2, uint64_t a3, _xlocale *a4, char *a5, int *a6)
{
  memset(__b, 0, sizeof(__b));
  libc_hooks_will_read((uint64_t)a4, 1472);
  libc_hooks_will_read_cstring((uint64_t)a5);
  if ((*(_WORD *)(a3 + 16) & 8) == 0 || (BOOL v9 = 0, !*(void *)(a3 + 24)) && (BOOL v9 = 0, (*(_WORD *)(a3 + 16) & 0x200) == 0)) {
    BOOL v9 = __swsetup(a3) != 0;
  }
  if (v9)
  {
    *__error() = 9;
    return -1;
  }
  else
  {
    if (!((char)(32 * *(unsigned char *)(*(void *)(a3 + 104) + 72)) >> 5)) {
      *(unsigned char *)(*(void *)(a3 + 104) + 72) = *(unsigned char *)(*(void *)(a3 + 104) + 72) & 0xF8 | 7;
    }
    if (a1 == -1)
    {
      if (a4)
      {
        if (a4 == (_xlocale *)-1) {
          a4 = (_xlocale *)&__global_locale;
        }
        return __vfprintf(a3, a4, a5, a6);
      }
      else
      {
        return __vfprintf(a3, (_xlocale *)&__c_locale, a5, a6);
      }
    }
    else if (a1)
    {
      pthread_mutex_lock((pthread_mutex_t *)a1);
      pthread_rwlock_rdlock(*(pthread_rwlock_t **)(a1 + 72));
      unsigned int v13 = __printf_exec(a1, a3, a6);
      int v10 = *__error();
      pthread_rwlock_unlock(*(pthread_rwlock_t **)(a1 + 72));
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      *__error() = v10;
      return v13;
    }
    else if (a2)
    {
      pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
      memset(__b, 0, sizeof(__b));
      void __b[8] = a5;
      if (a4)
      {
        if (a4 == (_xlocale *)-1) {
          a4 = (_xlocale *)&__global_locale;
        }
        xlocale_retain(a4);
      }
      else
      {
        int v22 = (atomic_uint *)pthread_getspecific(__locale_key);
        if (v22) {
          int v8 = v22;
        }
        else {
          int v8 = (atomic_uint *)&__global_locale;
        }
        a4 = v8;
        xlocale_retain(v8);
      }
      __b[10] = a4;
      pthread_rwlock_rdlock(a2);
      if ((int)__printf_comp((uint64_t)__b, (uint64_t)a2) >= 0)
      {
        unsigned int v14 = __printf_exec((uint64_t)__b, a3, a6);
        int v12 = *__error();
        pthread_rwlock_unlock(a2);
        xlocale_release((uint64_t)a4);
        free((void *)__b[11]);
        free((void *)__b[13]);
        free((void *)__b[14]);
        *__error() = v12;
        return v14;
      }
      else
      {
        int v11 = *__error();
        pthread_rwlock_unlock(a2);
        xlocale_release((uint64_t)a4);
        *__error() = v11;
        return -1;
      }
    }
    else
    {
      *__error() = 22;
      return -1;
    }
  }
}

uint64_t __xvprintf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((*(_WORD *)(a3 + 16) & 0x1A) == 0xA && *(__int16 *)(a3 + 18) >= 0) {
    return __v3printf(a1, a2, a3, a4, a5, a6);
  }
  else {
    return __v2printf(a1, a2, a3, a4, a5, a6);
  }
}

uint64_t __v3printf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v14 = a1;
  uint64_t v13 = a2;
  uint64_t v12 = a3;
  uint64_t v11 = a4;
  uint64_t v10 = a5;
  uint64_t v9 = a6;
  int v8 = 0;
  memset(__b, 0, sizeof(__b));
  memset(v17, 0, sizeof(v17));
  void __b[13] = v17;
  v17[0] = 0;
  memset(v15, 0, sizeof(v15));
  v15[0] = 850045858;
  memcpy(&v17[1], v15, 0x40uLL);
  LOBYTE(v17[9]) &= 0xF8u;
  memset(&v17[10], 0, 0x80uLL);
  LOBYTE(v17[9]) &= ~8u;
  LOWORD(__b[2]) = *(_WORD *)(v12 + 16) & 0xFFFD;
  WORD1(__b[2]) = *(_WORD *)(v12 + 18);
  void __b[6] = *(void *)(v12 + 48);
  __b[10] = *(void *)(v12 + 80);
  LOBYTE(v17[9]) = v17[9] & 0xF8 | ((char)(32 * *(unsigned char *)(*(void *)(v12 + 104) + 72)) >> 5) & 7;
  memcpy(&v17[10], (const void *)(*(void *)(v12 + 104) + 80), 0x80uLL);
  __b[0] = v16;
  __b[3] = v16;
  HIDWORD(__b[1]) = 1024;
  LODWORD(__b[4]) = 1024;
  LODWORD(__b[5]) = 0;
  int v8 = __v2printf(v14, v13, __b, v11, v10, v9);
  if (v8 >= 0 && __fflush((uint64_t)__b)) {
    int v8 = -1;
  }
  if ((__b[2] & 0x40) != 0) {
    *(_WORD *)(v12 + 16) |= 0x40u;
  }
  return v8;
}

uint64_t __xprintf_vector(uint64_t a1, unsigned int *a2, float **a3)
{
  uint64_t v63 = a1;
  uint64_t v62 = a2;
  time_t v61 = a3;
  char v60 = 0;
  int v59 = 0;
  unsigned int v58 = 0;
  memset(__b, 0, sizeof(__b));
  memcpy(__b, v62, sizeof(__b));
  int v59 = *v61;
  char v60 = v62[4];
  if (v60 == 88)
  {
    if (v62[7] == 99) {
      char v60 = 0;
    }
    else {
      char v60 = 32;
    }
  }
  void __b[8] = (uint64_t)&v60;
  __b[7] = (uint64_t)&v60;
  if (v60) {
    ++__b[8];
  }
  LOWORD(__b[5]) &= ~0x8000u;
  if ((*((_WORD *)v62 + 20) >> 2))
  {
    if (v62[7] == 112)
    {
      int i = 0;
      uint64_t v55 = 0;
      int v54 = 0;
      uint64_t v55 = *(unsigned __int16 *)v59;
      int v54 = &v55;
      int v3 = __printf_render_ptr(v63, __b, &v54);
      v58 += v3;
      for (int i = 1; i < 8; ++i)
      {
        int v4 = __printf_puts(v63, __b[7], LODWORD(__b[8]) - LODWORD(__b[7]));
        v58 += v4;
        uint64_t v55 = *((unsigned __int16 *)v59 + i);
        int v5 = __printf_render_ptr(v63, __b, &v54);
        v58 += v5;
      }
    }
    else
    {
      int j = 0;
      int v52 = 0;
      signed int v51 = 0;
      int v52 = *(unsigned __int16 *)v59;
      signed int v51 = (unint64_t *)&v52;
      int v6 = __printf_render_int(v63, (uint64_t)__b, &v51);
      v58 += v6;
      for (int j = 1; j < 8; ++j)
      {
        int v7 = __printf_puts(v63, __b[7], LODWORD(__b[8]) - LODWORD(__b[7]));
        v58 += v7;
        int v52 = *((unsigned __int16 *)v59 + j);
        int v8 = __printf_render_int(v63, (uint64_t)__b, &v51);
        v58 += v8;
      }
    }
  }
  else if ((*((_WORD *)v62 + 20) >> 3))
  {
    LOWORD(__b[5]) &= ~8u;
    if (v62[7] == 112)
    {
      int k = 0;
      uint64_t v49 = 0;
      unsigned int v48 = 0;
      uint64_t v49 = *(unsigned int *)v59;
      unsigned int v48 = &v49;
      int v9 = __printf_render_ptr(v63, __b, &v48);
      v58 += v9;
      for (int k = 1; k < 4; ++k)
      {
        int v10 = __printf_puts(v63, __b[7], LODWORD(__b[8]) - LODWORD(__b[7]));
        v58 += v10;
        uint64_t v49 = LODWORD(v59[k]);
        int v11 = __printf_render_ptr(v63, __b, &v48);
        v58 += v11;
      }
    }
    else
    {
      int m = 0;
      float v46 = 0.0;
      int v45 = 0;
      float v46 = *v59;
      int v45 = &v46;
      int v12 = __printf_render_int(v63, (uint64_t)__b, (unint64_t **)&v45);
      v58 += v12;
      for (int m = 1; m < 4; ++m)
      {
        int v13 = __printf_puts(v63, __b[7], LODWORD(__b[8]) - LODWORD(__b[7]));
        v58 += v13;
        float v46 = v59[m];
        int v14 = __printf_render_int(v63, (uint64_t)__b, (unint64_t **)&v45);
        v58 += v14;
      }
    }
  }
  else
  {
    unsigned int v15 = v62[7];
    BOOL v16 = v15 > 0x41;
    uint64_t v17 = v15 - 65;
    if (v16)
    {
      uint64_t v19 = v17;
      char v18 = 1;
    }
    else
    {
      uint64_t v19 = v17;
      char v18 = 0;
    }
    if ((v18 & 1) == 0)
    {
      switch(v19)
      {
        case 0:
        case 4:
        case 6:
        case 32:
        case 36:
        case 37:
        case 38:
          int n = 0;
          double v43 = 0.0;
          uint64_t v42 = 0;
          double v43 = *v59;
          uint64_t v42 = &v43;
          int v20 = __printf_render_float(v63, __b, &v42);
          v58 += v20;
          for (int n = 1; n < 4; ++n)
          {
            int v21 = __printf_puts(v63, __b[7], LODWORD(__b[8]) - LODWORD(__b[7]));
            v58 += v21;
            double v43 = v59[n];
            int v22 = __printf_render_float(v63, __b, &v42);
            v58 += v22;
          }
          return v58;
        case 1:
        case 2:
        case 3:
        case 5:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 33:
        case 39:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 47:
        case 48:
        case 49:
        case 50:
        case 51:
        case 53:
        case 54:
          break;
        case 23:
        case 35:
        case 40:
        case 46:
        case 52:
        case 55:
          LOWORD(__b[5]) = __b[5] & 0xFFFD | 2;
          iint i = 0;
          int v37 = 0;
          int v36 = 0;
          int v37 = *(unsigned __int8 *)v59;
          int v36 = (unint64_t *)&v37;
          int v26 = __printf_render_int(v63, (uint64_t)__b, &v36);
          v58 += v26;
          for (iint i = 1; ii < 16; ++ii)
          {
            int v27 = __printf_puts(v63, __b[7], LODWORD(__b[8]) - LODWORD(__b[7]));
            v58 += v27;
            int v37 = *((unsigned __int8 *)v59 + ii);
            int v28 = __printf_render_int(v63, (uint64_t)__b, &v36);
            v58 += v28;
          }
          return v58;
        case 34:
          jint j = 0;
          int v34 = 0;
          uint64_t v33 = 0;
          int v34 = *(unsigned __int8 *)v59;
          uint64_t v33 = &v34;
          int v29 = __printf_render_chr(v63, (uint64_t)__b, &v33);
          v58 += v29;
          for (jint j = 1; jj < 16; ++jj)
          {
            int v30 = __printf_puts(v63, __b[7], LODWORD(__b[8]) - LODWORD(__b[7]));
            v58 += v30;
            int v34 = *((unsigned __int8 *)v59 + jj);
            int v31 = __printf_render_chr(v63, (uint64_t)__b, &v33);
            v58 += v31;
          }
          return v58;
        default:
          JUMPOUT(0);
      }
    }
    kint k = 0;
    uint64_t v40 = 0;
    uint64_t v39 = 0;
    uint64_t v40 = *(unsigned __int8 *)v59;
    uint64_t v39 = &v40;
    int v23 = __printf_render_ptr(v63, __b, &v39);
    v58 += v23;
    for (kint k = 1; kk < 16; ++kk)
    {
      int v24 = __printf_puts(v63, __b[7], LODWORD(__b[8]) - LODWORD(__b[7]));
      v58 += v24;
      uint64_t v40 = *((unsigned __int8 *)v59 + kk);
      int v25 = __printf_render_ptr(v63, __b, &v39);
      v58 += v25;
    }
  }
  return v58;
}

uint64_t at_quick_exit(uint64_t a1)
{
  int v4 = (uint64_t *)malloc_type_calloc();
  if (v4)
  {
    v4[1] = a1;
    while (1)
    {
      uint64_t v1 = *v4;
      uint64_t v2 = *v4;
      atomic_compare_exchange_strong((atomic_ullong *volatile)&handlers, (unint64_t *)&v2, (unint64_t)v4);
      if (v2 == v1) {
        break;
      }
      *int v4 = v2;
    }
    return 0;
  }
  else
  {
    return -1;
  }
}

void quick_exit(int a1)
{
  for (unint64_t i = atomic_load_explicit((atomic_ullong *volatile)&handlers, memory_order_acquire); i; unint64_t i = *(void *)i)
    (*(void (**)(void))(i + 8))();
  _Exit(a1);
}

ssize_t strfmon(char *a1, size_t a2, const char *a3, ...)
{
  va_start(va, a3);
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    int v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v10 = __locale_key;
    int v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9) {
    return _strfmon(a1, a2, v9, (char *)a3, (double *)va);
  }
  else {
    return _strfmon(a1, a2, (_xlocale *)__global_locale, (char *)a3, (double *)va);
  }
}

uint64_t _strfmon(char *a1, unint64_t a2, _xlocale *a3, char *a4, double *a5)
{
  uint64_t v81 = a1;
  unint64_t v80 = a2;
  int v79 = a3;
  wint_t v78 = a4;
  locale_t v77 = a5;
  unsigned int v72 = 0;
  int v71 = 0;
  int v69 = 0;
  int v68 = 0;
  int v67 = 0;
  double v66 = 0.0;
  char v65 = 32;
  char v64 = 0;
  char v63 = 0;
  char v62 = 0;
  char v60 = 0;
  int v74 = localeconv_l(a3);
  int v76 = v81;
  int v75 = v78;
  unsigned __int8 v73 = 0;
  time_t v61 = 0;
  int v70 = 0;
  while (*v75)
  {
    if (*v75 != 37) {
      goto LABEL_6;
    }
    if (v75[1] == 37)
    {
      ++v75;
LABEL_6:
      if (v76 >= &v81[v80]) {
        goto LABEL_169;
      }
      int v5 = (unsigned __int8 *)v75++;
      LOBYTE(v5) = *v5;
      int v6 = v76++;
      *int v6 = (char)v5;
    }
    else
    {
      unsigned int v72 = 5;
      int v71 = 32;
      int v68 = -1;
      int v67 = -1;
      int v69 = -1;
      double v66 = 0.0;
      while (1)
      {
        while (1)
        {
          while (1)
          {
            while (1)
            {
              while (1)
              {
                while (1)
                {
                  int v47 = *++v75;
                  if (v47 != 33) {
                    break;
                  }
                  v72 |= 0x10u;
                }
                if (v47 != 40) {
                  break;
                }
                if ((v72 & 2) != 0) {
                  goto LABEL_170;
                }
                v72 |= 0xAu;
              }
              if (v47 != 43) {
                break;
              }
              if ((v72 & 2) != 0) {
                goto LABEL_170;
              }
              v72 |= 6u;
            }
            if (v47 != 45) {
              break;
            }
            v72 |= 0x20u;
          }
          if (v47 != 61) {
            break;
          }
          int v71 = *++v75;
          if (!v71) {
            goto LABEL_170;
          }
        }
        if (v47 != 94) {
          break;
        }
        v72 &= ~1u;
      }
      if (isdigit_l(*v75, v79) != 0)
      {
        char v57 = (char *)(v76 - v81);
        int v69 = 0;
        while (isdigit_l(*v75, v79))
        {
          v69 *= 10;
          v69 += *v75 - 48;
          if (v69 > 0xFFFFFF) {
            goto LABEL_169;
          }
          ++v75;
        }
        if ((unint64_t)&v57[v69] >= v80) {
          goto LABEL_169;
        }
      }
      if (*v75 == 35)
      {
        if (!isdigit_l(*++v75, v79)) {
          goto LABEL_170;
        }
        int v68 = 0;
        while (isdigit_l(*v75, v79))
        {
          v68 *= 10;
          v68 += *v75 - 48;
          if (v68 > 0xFFFFFF) {
            goto LABEL_169;
          }
          ++v75;
        }
      }
      if (*v75 == 46)
      {
        if (!isdigit_l(*++v75, v79)) {
          goto LABEL_170;
        }
        int v67 = 0;
        while (isdigit_l(*v75, v79))
        {
          v67 *= 10;
          v67 += *v75 - 48;
          if (v67 > 0xFFFFFF) {
            goto LABEL_169;
          }
          ++v75;
        }
      }
      int v8 = (unsigned __int8 *)v75++;
      int v46 = (char)*v8;
      if (v46 == 105)
      {
        v72 |= 0x40u;
      }
      else
      {
        if (v46 != 110)
        {
LABEL_170:
          *__error() = 22;
          goto LABEL_171;
        }
        v72 &= ~0x40u;
      }
      if (v61) {
        free(v61);
      }
      if ((v72 & 0x40) != 0)
      {
        time_t v61 = strdup(v74->int_curr_symbol);
        if (v61)
        {
          char v65 = *((unsigned char *)v61 + 3);
          *((unsigned char *)v61 + 3) = 0;
        }
      }
      else
      {
        time_t v61 = strdup(v74->currency_symbol);
      }
      if (!v61) {
        goto LABEL_171;
      }
      double v9 = *v77++;
      double v66 = v9;
      if (v9 < 0.0)
      {
        v72 |= 0x80u;
        double v66 = -v66;
      }
      if (v68 >= 0)
      {
        int v45 = __calc_left_pad(v72 ^ 0x80, (const char *)v61, (uint64_t)v74);
        int v70 = v45 - __calc_left_pad(v72, (const char *)v61, (uint64_t)v74);
        if (v70 < 0) {
          int v70 = 0;
        }
      }
      unsigned __int8 v73 = __format_grouped_double(&v72, v68, v67, v71, &v74->decimal_point, v79, v66);
      if (!v73) {
        goto LABEL_171;
      }
      __setup_vars(v72, &v64, &v63, &v62, &v60, (uint64_t)v74);
      uint64_t __src = v76;
      while (1)
      {
        int v10 = v70--;
        if (v10 <= 0) {
          break;
        }
        if (v76 >= &v81[v80]) {
          goto LABEL_169;
        }
        int v11 = v76++;
        *int v11 = 32;
      }
      if (!v62 && (v72 & 0x80) != 0)
      {
        if (v76 >= &v81[v80]) {
          goto LABEL_169;
        }
        int v12 = v76++;
        *int v12 = 40;
      }
      if (v64 == 1)
      {
        if (v62 == 1 || v62 == 3)
        {
          char v56 = v60;
          while (*v56)
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            int v13 = v56++;
            LOBYTE(v13) = *v13;
            int v14 = v76++;
            *int v14 = (char)v13;
          }
          if (v63 == 2)
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            unsigned int v15 = v76++;
            *unsigned int v15 = 32;
          }
        }
        if ((v72 & 0x10) == 0)
        {
          uint64_t v55 = v61;
          while (*v55)
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            BOOL v16 = v55++;
            LOBYTE(v16) = *v16;
            uint64_t v17 = v76++;
            *uint64_t v17 = (char)v16;
          }
          if (v62 == 4)
          {
            if (v63 == 2)
            {
              if (v76 >= &v81[v80]) {
                goto LABEL_169;
              }
              char v18 = v76++;
              *char v18 = v65;
            }
            int v54 = v60;
            while (*v54)
            {
              if (v76 >= &v81[v80]) {
                goto LABEL_169;
              }
              uint64_t v19 = v54++;
              LOBYTE(v19) = *v19;
              int v20 = v76++;
              char *v20 = (char)v19;
            }
            if (v63 == 1)
            {
              if (v76 >= &v81[v80]) {
                goto LABEL_169;
              }
              int v21 = v76++;
              *int v21 = 32;
            }
          }
          else if (v63 == 1)
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            int v22 = v76++;
            *int v22 = v65;
          }
        }
      }
      else if (v62 == 1)
      {
        uint64_t v53 = v60;
        while (*v53)
        {
          if (v76 >= &v81[v80]) {
            goto LABEL_169;
          }
          int v23 = v53++;
          LOBYTE(v23) = *v23;
          int v24 = v76++;
          *int v24 = (char)v23;
        }
        if (v63 == 2)
        {
          if (v76 >= &v81[v80]) {
            goto LABEL_169;
          }
          int v25 = v76++;
          *int v25 = 32;
        }
      }
      int v52 = v73;
      while (*v52)
      {
        if (v76 >= &v81[v80]) {
          goto LABEL_169;
        }
        int v26 = v52++;
        LOBYTE(v26) = *v26;
        int v27 = v76++;
        *int v27 = (char)v26;
      }
      if (!v64)
      {
        if (v62 == 3)
        {
          if (v63 == 1)
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            int v28 = v76++;
            *int v28 = 32;
          }
          signed int v51 = v60;
          while (*v51)
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            int v29 = v51++;
            LOBYTE(v29) = *v29;
            int v30 = v76++;
            *int v30 = (char)v29;
          }
        }
        if ((v72 & 0x10) == 0)
        {
          if (v62 == 3 && v63 == 2 || v63 == 1 && (!v62 || v62 == 1 || v62 == 2 || v62 == 4))
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            int v31 = v76++;
            *int v31 = v65;
          }
          int v50 = v61;
          while (*v50)
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            uint64_t v32 = v50++;
            LOBYTE(v32) = *v32;
            uint64_t v33 = v76++;
            char *v33 = (char)v32;
          }
          if (v62 == 4)
          {
            if (v63 == 2)
            {
              if (v76 >= &v81[v80]) {
                goto LABEL_169;
              }
              int v34 = v76++;
              *int v34 = 32;
            }
            uint64_t v49 = v60;
            while (*v49)
            {
              if (v76 >= &v81[v80]) {
                goto LABEL_169;
              }
              uint64_t v35 = v49++;
              LOBYTE(v35) = *v35;
              int v36 = v76++;
              *int v36 = (char)v35;
            }
          }
        }
      }
      if (v62 == 2)
      {
        if (v63 == 2)
        {
          if (v76 >= &v81[v80]) {
            goto LABEL_169;
          }
          int v37 = v76++;
          *int v37 = 32;
        }
        unsigned int v48 = v60;
        while (*v48)
        {
          if (v76 >= &v81[v80]) {
            goto LABEL_169;
          }
          uint64_t v38 = v48++;
          LOBYTE(v38) = *v38;
          uint64_t v39 = v76++;
          *uint64_t v39 = (char)v38;
        }
      }
      if (!v62)
      {
        if ((v72 & 0x80) != 0)
        {
          if (v76 >= &v81[v80]) {
            goto LABEL_169;
          }
          uint64_t v40 = v76++;
          *uint64_t v40 = 41;
        }
        else if (v68 >= 0)
        {
          if (v76 >= &v81[v80]) {
            goto LABEL_169;
          }
          uint64_t v41 = v76++;
          *uint64_t v41 = 32;
        }
      }
      if (v76 - __src < v69)
      {
        if ((v72 & 0x20) != 0)
        {
          while (v76 - __src < v69)
          {
            if (v76 >= &v81[v80]) {
              goto LABEL_169;
            }
            uint64_t v42 = v76++;
            *uint64_t v42 = 32;
          }
        }
        else
        {
          int v70 = v76 - __src;
          memmove(&__src[v69 - ((int)v76 - (int)__src)], __src, (int)v76 - (int)__src);
          memset(__src, 32, v69 - (uint64_t)v70);
          v76 += v69 - v70;
        }
      }
    }
  }
  if (v76 < &v81[v80])
  {
    double v43 = v76++;
    char *v43 = 0;
    free(v73);
    free(v61);
    return v76 - v81 - 1;
  }
LABEL_169:
  *__error() = 7;
LABEL_171:
  int v58 = *__error();
  if (v73) {
    free(v73);
  }
  if (v61) {
    free(v61);
  }
  *__error() = v58;
  return -1;
}

ssize_t strfmon_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  va_start(va, a4);
  int v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1) {
      int v5 = (_xlocale *)__global_locale;
    }
  }
  else
  {
    int v5 = (_xlocale *)__c_locale;
  }
  return _strfmon(a1, a2, v5, (char *)a4, (double *)va);
}

uint64_t __calc_left_pad(unsigned int a1, const char *a2, uint64_t a3)
{
  unsigned int v12 = a1;
  int v11 = a2;
  uint64_t v10 = a3;
  char v9 = 0;
  char v8 = 0;
  char v7 = 0;
  __s = 0;
  unsigned int v5 = 0;
  __setup_vars(a1, &v9, &v8, &v7, (const char **)&__s, a3);
  if (v9)
  {
    unsigned int v5 = strlen(v11);
    if (v8) {
      ++v5;
    }
  }
  if (v7)
  {
    if (v7 == 1 || (v7 != 4 && v7 != 3 ? (char v3 = 0) : (char v3 = 1), (v3 & 1) != 0 && v9)) {
      v5 += strlen(__s);
    }
  }
  else if ((v12 & 0x80) != 0)
  {
    ++v5;
  }
  return v5;
}

void *__format_grouped_double(_DWORD *a1, int a2, int a3, int a4, char **a5, _xlocale *a6, double a7)
{
  double v30 = a7;
  int v29 = a1;
  int v28 = a2;
  int v27 = a3;
  int v26 = a4;
  int v25 = a5;
  locale_t v24 = a6;
  mbstate_t __dst = 0;
  *(void *)&__n[1] = 0;
  int v14 = 0;
  fixed = __fix_nogrouping(a5[7]);
  char v16 = *v25[5];
  if (!v16) {
    char v16 = **v25;
  }
  char v15 = *v25[6];
  if (!v15) {
    char v15 = *v25[1];
  }
  if (v28 == -1) {
    int v28 = 0;
  }
  if (v27 == -1)
  {
    int v27 = (*v29 & 0x40) != 0 ? *((char *)v25 + 80) : *((char *)v25 + 81);
    if (v27 == 127) {
      int v27 = 2;
    }
  }
  if (*v29) {
    v28 += get_groups(v28, fixed);
  }
  snprintf_l(v32, 0x20uLL, v24, "%%%d.%df", v28 + v27 + 1, v27);
  __n[0] = asprintf_l((char **)&__n[1], v24, v32, *(void *)&v30);
  if (__n[0] < 0) {
    return 0;
  }
  size_t v21 = 2 * strlen(*(const char **)&__n[1]) + 1;
  mbstate_t __dst = (void *)malloc_type_malloc();
  if (__dst)
  {
    bzero(__dst, v21);
    __int16 __len_4 = (char *)__dst + v21 - 1;
    for (__leint n = 0; *(unsigned char *)(*(void *)&__n[1] + __len) == 32; ++__len)
      --__n[0];
    if (v27 > 0)
    {
      __len_4a = &__len_4[-v27];
      memcpy(__len_4a, (const void *)(*(void *)&__n[1] + __n[0] + __len - v27), v27);
      __int16 __len_4 = __len_4a - 1;
      char *__len_4 = v16;
      __n[0] -= v27 + 1;
    }
    if ((*v29 & 1) != 0 && v15 && *fixed != 127 && *fixed > 0)
    {
      while (__n[0] > *fixed)
      {
        int v13 = *fixed;
        while (1)
        {
          int v7 = v13--;
          if (v7 <= 0) {
            break;
          }
          --__n[0];
          *--__int16 __len_4 = *(unsigned char *)(*(void *)&__n[1] + __n[0] + __len);
        }
        *--__int16 __len_4 = v15;
        ++v14;
        if (*++fixed == 127) {
          break;
        }
        if (!*fixed)
        {
          --fixed;
          while (__n[0] > *fixed)
          {
            int v12 = *fixed;
            while (1)
            {
              int v8 = v12--;
              if (v8 <= 0) {
                break;
              }
              --__n[0];
              *--__int16 __len_4 = *(unsigned char *)(*(void *)&__n[1] + __n[0] + __len);
            }
            *--__int16 __len_4 = v15;
            ++v14;
          }
        }
      }
      if (__n[0])
      {
        int v11 = __n[0];
        while (1)
        {
          int v9 = v11--;
          if (v9 <= 0) {
            break;
          }
          --__n[0];
          *--__int16 __len_4 = *(unsigned char *)(*(void *)&__n[1] + __n[0] + __len);
        }
      }
      __len -= v14;
    }
    else
    {
      __len_4 -= __n[0];
      memcpy(__len_4, (const void *)(*(void *)&__n[1] + __len), __n[0]);
      if (!v27) {
        --__len;
      }
    }
    if (__len > 0)
    {
      __len_4 -= __len;
      memset(__len_4, v26, __len);
    }
    memmove(__dst, __len_4, v21 - (__len_4 - (unsigned char *)__dst) + 1);
    free(*(void **)&__n[1]);
    return __dst;
  }
  else
  {
    free(*(void **)&__n[1]);
    return 0;
  }
}

uint64_t __setup_vars(uint64_t result, unsigned char *a2, unsigned char *a3, unsigned char *a4, const char **a5, uint64_t a6)
{
  if ((result & 0x80u) != 0 && (result & 0x40) != 0)
  {
    *a2 = *(unsigned char *)(a6 + 89);
    *a3 = *(unsigned char *)(a6 + 91);
    if ((result & 8) != 0) {
      char v11 = 0;
    }
    else {
      char v11 = *(unsigned char *)(a6 + 93);
    }
    *a4 = v11;
    if (**(unsigned char **)(a6 + 72)) {
      uint64_t v10 = *(const char **)(a6 + 72);
    }
    else {
      uint64_t v10 = "-";
    }
    *a5 = v10;
  }
  else if ((result & 0x40) != 0)
  {
    *a2 = *(unsigned char *)(a6 + 88);
    *a3 = *(unsigned char *)(a6 + 90);
    if ((result & 8) != 0) {
      char v9 = 0;
    }
    else {
      char v9 = *(unsigned char *)(a6 + 92);
    }
    *a4 = v9;
    *a5 = *(const char **)(a6 + 64);
  }
  else if ((result & 0x80u) == 0)
  {
    *a2 = *(unsigned char *)(a6 + 82);
    *a3 = *(unsigned char *)(a6 + 83);
    if ((result & 8) != 0) {
      char v6 = 0;
    }
    else {
      char v6 = *(unsigned char *)(a6 + 86);
    }
    *a4 = v6;
    *a5 = *(const char **)(a6 + 64);
  }
  else
  {
    *a2 = *(unsigned char *)(a6 + 84);
    *a3 = *(unsigned char *)(a6 + 85);
    if ((result & 8) != 0) {
      char v8 = 0;
    }
    else {
      char v8 = *(unsigned char *)(a6 + 87);
    }
    *a4 = v8;
    if (**(unsigned char **)(a6 + 72)) {
      int v7 = *(const char **)(a6 + 72);
    }
    else {
      int v7 = "-";
    }
    *a5 = v7;
  }
  if (*a2) {
    *a2 = 1;
  }
  if (*a3 == 127) {
    *a3 = 0;
  }
  if (*a4 == 127) {
    *a4 = 0;
  }
  return result;
}

uint64_t get_groups(int a1, char *a2)
{
  unsigned int v5 = a2;
  unsigned int v4 = 0;
  if (*a2 == 127 || *a2 <= 0)
  {
    return 0;
  }
  else
  {
    while (a1 > *v5)
    {
      ++v4;
      uint64_t v2 = v5++;
      a1 -= *v2;
      if (*v5 == 127) {
        break;
      }
      if (!*v5)
      {
        v4 += (a1 - 1) / *(v5 - 1);
        break;
      }
    }
    return v4;
  }
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  __leint n = __n;
  errno_t v5 = 0;
  if (!__s) {
    return 22;
  }
  if (__smax > 0x7FFFFFFFFFFFFFFFLL) {
    return 7;
  }
  if (__n > 0x7FFFFFFFFFFFFFFFLL)
  {
    errno_t v5 = 7;
    __leint n = __smax;
  }
  if (__len > __smax)
  {
    errno_t v5 = 84;
    __leint n = __smax;
  }
  memset(__s, __c, __len);
  return v5;
}

void rb_tree_init(rb_tree_t *a1, const rb_tree_ops_t *a2)
{
  a1->opaque[1] = (void *)a2;
  a1->opaque[0] = 0;
  a1->opaque[2] = a1->opaque[0];
  a1->opaque[3] = a1->opaque[0];
  a1->opaque[4] = 0;
}

void *__cdecl rb_tree_find_node(rb_tree_t *a1, const void *a2)
{
  int v7 = a1->opaque[1];
  char v6 = (uint64_t (*)(void, char *, const void *))v7[1];
  for (unint64_t i = a1->opaque[0]; i; unint64_t i = (void *)i[v3 < 0])
  {
    unsigned int v4 = (char *)i - v7[2];
    int v3 = v6(v7[3], v4, a2);
    if (!v3) {
      return v4;
    }
  }
  return 0;
}

void *__cdecl rb_tree_find_node_geq(rb_tree_t *a1, const void *a2)
{
  char v9 = a1->opaque[1];
  char v8 = (uint64_t (*)(void, char *, const void *))v9[1];
  int v7 = a1->opaque[0];
  char v6 = 0;
  while (v7)
  {
    errno_t v5 = (char *)v7 - v9[2];
    int v4 = v8(v9[3], v5, a2);
    if (!v4) {
      return v5;
    }
    if (v4 > 0) {
      char v6 = v7;
    }
    int v7 = (void *)v7[v4 < 0];
  }
  if (v6) {
    return (char *)v6 - v9[2];
  }
  else {
    return 0;
  }
}

void *__cdecl rb_tree_find_node_leq(rb_tree_t *a1, const void *a2)
{
  char v9 = a1->opaque[1];
  char v8 = (uint64_t (*)(void, char *, const void *))v9[1];
  int v7 = a1->opaque[0];
  char v6 = 0;
  while (v7)
  {
    errno_t v5 = (char *)v7 - v9[2];
    int v4 = v8(v9[3], v5, a2);
    if (!v4) {
      return v5;
    }
    if (v4 < 0) {
      char v6 = v7;
    }
    int v7 = (void *)v7[v4 < 0];
  }
  if (v6) {
    return (char *)v6 - v9[2];
  }
  else {
    return 0;
  }
}

void *__cdecl rb_tree_insert_node(rb_tree_t *a1, void *a2)
{
  int v12 = a1->opaque[1];
  char v11 = (uint64_t (*)(void, char *, void *))*v12;
  char v8 = (char *)a2 + v12[2];
  char v9 = (rb_tree_t *)a1->opaque[0];
  uint64_t v10 = a1;
  BOOL v7 = 0;
  while (v9)
  {
    errno_t v5 = (char *)v9 - v12[2];
    int v4 = v11(v12[3], v5, a2);
    if (!v4) {
      return v5;
    }
    uint64_t v10 = v9;
    BOOL v7 = v4 < 0;
    char v9 = (rb_tree_t *)v9->opaque[v4 < 0];
  }
  unsigned char v8[2] = (unint64_t)v10 | v8[2] & 3;
  if (v7) {
    v8[2] |= 2uLL;
  }
  else {
    v8[2] &= ~2uLL;
  }
  if (v10 == a1)
  {
    v8[2] &= ~1uLL;
    a1->opaque[2] = v8;
    a1->opaque[3] = v8;
    BOOL v6 = 0;
  }
  else
  {
    if (v10 == a1->opaque[v7 + 2]) {
      a1->opaque[v7 + 2] = v8;
    }
    v8[2] |= 1uLL;
    BOOL v3 = 0;
    if (v10) {
      BOOL v3 = ((uint64_t)v10->opaque[2] & 1) != 0;
    }
    BOOL v6 = v3;
  }
  *char v8 = v10->opaque[v7];
  v8[1] = v10->opaque[v7];
  v10->opaque[v7] = v8;
  ++a1->opaque[4];
  if (v6) {
    rb_tree_insert_rebalance((uint64_t)a1, (unint64_t)v8);
  }
  return a2;
}

void rb_tree_insert_rebalance(uint64_t a1, unint64_t a2)
{
  unint64_t v6 = a2;
  unint64_t v5 = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    unint64_t v4 = *(void *)(v5 + 16) & 0xFFFFFFFFFFFFFFFCLL;
    unsigned int v2 = v5 == *(void *)(v4 + 8);
    uint64_t v3 = *(void *)(v4 + 8 * (v5 != *(void *)(v4 + 8)));
    if (!v3 || (*(void *)(v3 + 16) & 1) == 0) {
      break;
    }
    *(void *)(v3 + 16) &= ~1uLL;
    *(void *)(v5 + 16) &= ~1uLL;
    if (*(void *)a1 != v4)
    {
      *(void *)(v4 + 16) |= 1uLL;
      unint64_t v6 = v4;
      unint64_t v5 = *(void *)(v4 + 16) & 0xFFFFFFFFFFFFFFFCLL;
      if (v5)
      {
        if (*(void *)(v5 + 16)) {
          continue;
        }
      }
    }
    return;
  }
  if (v6 == *(void *)(v5 + 8 * (v5 != *(void *)(v4 + 8)))) {
    rb_tree_reparent_nodes(a1, v5, v5 != *(void *)(v4 + 8));
  }
  rb_tree_reparent_nodes(a1, v4, v2);
  *(void *)(*(void *)a1 + 16) &= ~1uLL;
}

void rb_tree_remove_node(rb_tree_t *a1, void *a2)
{
  unint64_t v5 = a1->opaque[1];
  unint64_t v4 = (char *)a2 + v5[2];
  if (v4 && (*v4 || v4[1]))
  {
    if (*v4 && v4[1])
    {
      unsigned int v2 = rb_tree_iterate(a1, a2, (v4[2] & 2) == 0);
      rb_tree_swap_prune_and_rebalance(a1, (uint64_t)v4, (unint64_t)v2 + v5[2]);
    }
    else
    {
      rb_tree_prune_blackred_branch(a1, (uint64_t)v4, *v4 == 0);
    }
  }
  else
  {
    if (!v4 || (BOOL v3 = 0, (v4[2] & 1) == 0)) {
      BOOL v3 = a1->opaque[0] != v4;
    }
    rb_tree_prune_node(a1, v4, v3);
  }
}

void rb_tree_prune_node(void *a1, void *a2, char a3)
{
  unsigned int v5 = (a2[2] & 2) != 0;
  unint64_t v4 = a2[2] & 0xFFFFFFFFFFFFFFFCLL;
  BOOL v3 = *a1 == (void)a2;
  *(void *)(v4 + 8 * ((a2[2] & 2) != 0)) = *a2;
  --a1[4];
  if ((void *)a1[((a2[2] & 2) != 0) + 2] == a2)
  {
    a1[((a2[2] & 2) != 0) + 2] = v4;
    if (v3) {
      a1[3] = v4;
    }
  }
  a2[2] &= 3uLL;
  if (a3) {
    rb_tree_removal_rebalance(a1, v4, v5);
  }
}

void *rb_tree_prune_blackred_branch(void *result, uint64_t a2, unsigned int a3)
{
  unint64_t v5 = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v4 = *(void *)(a2 + 8 * a3);
  BOOL v3 = *result == a2;
  *(void *)(v4 + 16) ^= (*(void *)(v4 + 16) ^ *(void *)(a2 + 16)) & 3;
  *(void *)(v5 + 8 * ((*(void *)(v4 + 16) & 2) != 0)) = v4;
  *(void *)(v4 + 16) = v5 | *(void *)(v4 + 16) & 3;
  --result[4];
  if (v3)
  {
    result[(a3 ^ 1) + 2] = v4;
  }
  else if (result[((*(void *)(a2 + 16) & 2) != 0) + 2] == a2)
  {
    result[((*(void *)(a2 + 16) & 2) != 0) + 2] = v4;
  }
  *(void *)(a2 + 16) &= 3uLL;
  return result;
}

void *__cdecl rb_tree_iterate(rb_tree_t *a1, void *a2, const unsigned int a3)
{
  BOOL v7 = a1->opaque[1];
  unsigned int v6 = a3 ^ 1;
  if (a2)
  {
    uint64_t v4 = (char *)a2 + v7[2];
    if (v4[a3])
    {
      for (uint64_t i = v4[a3]; *(void *)(i + 8 * v6); uint64_t i = *(void *)(i + 8 * v6))
        ;
      return (void *)(i - v7[2]);
    }
    else
    {
      while (a1->opaque[0] != v4)
      {
        if (v6 == ((v4[2] & 2) != 0)) {
          return (void *)((v4[2] & 0xFFFFFFFFFFFFFFFCLL) - v7[2]);
        }
        uint64_t v4 = (void *)(v4[2] & 0xFFFFFFFFFFFFFFFCLL);
      }
      return 0;
    }
  }
  else if (a1->opaque[0])
  {
    return (char *)a1->opaque[(a3 == 0) + 2] - v7[2];
  }
  else
  {
    return 0;
  }
}

void rb_tree_swap_prune_and_rebalance(void *a1, uint64_t a2, unint64_t a3)
{
  unsigned int v3 = (*(void *)(a3 + 16) & 2) != 0;
  BOOL v9 = (*(void *)(a3 + 16) & 2) == 0;
  unint64_t v7 = *(void *)(a3 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  BOOL v5 = 1;
  if (a3) {
    BOOL v5 = (*(void *)(a3 + 16) & 1) == 0;
  }
  BOOL v6 = v5;
  if (v7 == a2) {
    uint64_t v8 = *(void *)(a3 + 8 * ((*(void *)(a3 + 16) & 2) != 0));
  }
  else {
    uint64_t v8 = *(void *)(a3 + 8 * ((*(void *)(a3 + 16) & 2) == 0));
  }
  BOOL v4 = 0;
  if (v8) {
    BOOL v4 = (*(void *)(v8 + 16) & 1) != 0;
  }
  if (v4)
  {
    *(void *)(v8 + 16) &= ~1uLL;
    BOOL v6 = 0;
    if (v7 != a2)
    {
      *(void *)(v8 + 16) = v7 | *(void *)(v8 + 16) & 3;
      if (v3) {
        *(void *)(v8 + 16) |= 2uLL;
      }
      else {
        *(void *)(v8 + 16) &= ~2uLL;
      }
    }
  }
  if (v7 == a2)
  {
    unint64_t v7 = a3;
  }
  else
  {
    *(void *)(v7 + 8 * v3) = v8;
    *(void *)(a3 + 8 * v9) = *(void *)(a2 + 8 * v9);
    *(void *)(*(void *)(a3 + 8 * v9) + 16) = a3 | *(void *)(*(void *)(a3 + 8 * v9) + 16) & 3;
    BOOL v9 = v3;
  }
  *(void *)(a3 + 8 * v9) = *(void *)(a2 + 8 * v9);
  *(void *)(*(void *)(a3 + 8 * v9) + 16) = a3 | *(void *)(*(void *)(a3 + 8 * v9) + 16) & 3;
  *(void *)(a3 + 16) ^= (*(void *)(a3 + 16) ^ *(void *)(a2 + 16)) & 3;
  *(void *)(a3 + 16) = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL | *(void *)(a3 + 16) & 3;
  *(void *)((*(void *)(a3 + 16) & 0xFFFFFFFFFFFFFFFCLL) + 8 * ((*(void *)(a3 + 16) & 2) != 0)) = a3;
  --a1[4];
  if (a1[((*(void *)(a2 + 16) & 2) != 0) + 2] == a2) {
    a1[((*(void *)(a2 + 16) & 2) != 0) + 2] = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  }
  *(void *)(a2 + 16) &= 3uLL;
  if (v6) {
    rb_tree_removal_rebalance(a1, v7, v3);
  }
}

size_t rb_tree_count(rb_tree_t *a1)
{
  if (a1) {
    return (size_t)a1->opaque[4];
  }
  else {
    return 0;
  }
}

void rb_tree_reparent_nodes(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unint64_t v5 = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  uint64_t v4 = *(void *)(a2 + 8 * a3);
  *(void *)(v5 + 8 * ((*(void *)(a2 + 16) & 2) != 0)) = v4;
  *(void *)(a2 + 8 * a3) = *(void *)(v4 + 8 * (a3 ^ 1));
  *(void *)(v4 + 8 * (a3 ^ 1)) = a2;
  *(void *)(v4 + 16) = v5 | *(void *)(v4 + 16) & 3;
  *(void *)(a2 + 16) = v4 | *(void *)(a2 + 16) & 3;
  uint64_t v3 = (*(void *)(v4 + 16) ^ *(void *)(a2 + 16)) & 3;
  *(void *)(v4 + 16) ^= v3;
  *(void *)(a2 + 16) ^= v3;
  if (a3 != 1) {
    *(void *)(a2 + 16) |= 2uLL;
  }
  else {
    *(void *)(a2 + 16) &= ~2uLL;
  }
  if (*(void *)(a2 + 8 * a3))
  {
    *(void *)(*(void *)(a2 + 8 * a3) + 16) = a2 | *(void *)(*(void *)(a2 + 8 * a3) + 16) & 3;
    if (a3) {
      *(void *)(*(void *)(a2 + 8 * a3) + 16) |= 2uLL;
    }
    else {
      *(void *)(*(void *)a2 + 16) &= ~2uLL;
    }
  }
}

void rb_tree_removal_rebalance(void *a1, unint64_t a2, unsigned int a3)
{
  while (1)
  {
    BOOL v3 = 1;
    if (*(void *)(a2 + 8 * a3)) {
      BOOL v3 = (*(void *)(*(void *)(a2 + 8 * a3) + 16) & 1) == 0;
    }
    if (!v3) {
      break;
    }
    unsigned int v5 = a3 ^ 1;
    uint64_t v4 = *(void **)(a2 + 8 * (a3 ^ 1));
    if (a2 && (*(void *)(a2 + 16) & 1) != 0
      || *v4 && (*(void *)(*v4 + 16) & 1) != 0
      || v4[1] && (*(void *)(v4[1] + 16) & 1) != 0)
    {
      goto LABEL_15;
    }
    if (v4 && (v4[2] & 1) != 0)
    {
      rb_tree_reparent_nodes((uint64_t)a1, a2, v5);
      uint64_t v4 = *(void **)(a2 + 8 * v5);
LABEL_15:
      if (!a2
        || (*(void *)(a2 + 16) & 1) == 0
        || v4 && (v4[2] & 1) != 0
        || *v4 && (*(void *)(*v4 + 16) & 1) != 0
        || v4[1] && (*(void *)(v4[1] + 16) & 1) != 0)
      {
        if (!v4[v5] || (*(void *)(v4[v5] + 16) & 1) == 0)
        {
          rb_tree_reparent_nodes((uint64_t)a1, (unint64_t)v4, a3);
          uint64_t v4 = *(void **)(a2 + 8 * v5);
        }
        *(void *)(v4[v5] + 16) &= ~1uLL;
        rb_tree_reparent_nodes((uint64_t)a1, a2, v5);
      }
      else
      {
        *(void *)(a2 + 16) &= ~1uLL;
        v4[2] |= 1uLL;
      }
      return;
    }
    v4[2] |= 1uLL;
    if (*a1 == a2) {
      return;
    }
    a3 = (*(void *)(a2 + 16) & 2) != 0;
    a2 = *(void *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  }
}

int regncomp_l(regex_t *a1, const char *a2, size_t a3, int a4, locale_t a5)
{
  int v14 = (__int32 *)malloc_type_malloc();
  if (!v14) {
    return 12;
  }
  if (a5)
  {
    if (a5 == (locale_t)-1) {
      a5 = (locale_t)__global_locale;
    }
  }
  else
  {
    a5 = (locale_t)&__c_locale;
  }
  if (*(_DWORD *)(*((void *)a5 + 166) + 64) == 1)
  {
    char v11 = a2;
    uint64_t v10 = v14;
    for (unsigned int i = 0; i < a3; ++i)
    {
      unsigned int v5 = v11++;
      BOOL v6 = v10++;
      *BOOL v6 = *(unsigned __int8 *)v5;
    }
    uint64_t v13 = a3;
  }
  else
  {
    uint64_t v8 = v14;
    memset(&__b, 0, sizeof(__b));
    while (a3)
    {
      size_t v9 = mbrtowc_l(v8, a2, a3, &__b, a5);
      if (v9 + 2 <= 1)
      {
        free(v14);
        return 17;
      }
      if (!v9)
      {
        if (*a2)
        {
          free(v14);
          return 2;
        }
        size_t v9 = 1;
      }
      a2 += v9;
      a3 -= v9;
      ++v8;
    }
    uint64_t v13 = v8 - v14;
  }
  v14[v13] = 0;
  int v15 = tre_compile((uint64_t)a1, (uint64_t)v14, v13, a4, (uint64_t)a5);
  free(v14);
  return v15;
}

int regncomp(regex_t *a1, const char *a2, size_t a3, int a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    int v12 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v13 = __locale_key;
    int v12 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v13);
  }
  if (v12) {
    unint64_t v7 = v12;
  }
  else {
    unint64_t v7 = (_xlocale *)__global_locale;
  }
  return regncomp_l(a1, a2, a3, a4, v7);
}

int regcomp_l(regex_t *a1, const char *a2, int a3, locale_t a4)
{
  if ((a3 & 0x20) != 0)
  {
    if (a1->re_endp >= a2) {
      return regncomp_l(a1, a2, a1->re_endp - a2, a3, a4);
    }
    else {
      return 16;
    }
  }
  else
  {
    size_t v5 = strlen(a2);
    return regncomp_l(a1, a2, v5, a3, a4);
  }
}

int regcomp(regex_t *a1, const char *a2, int a3)
{
  if (v3) {
    char v4 = 1;
  }
  else {
    char v4 = 0;
  }
  if (v4)
  {
    uint64_t v10 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v11 = __locale_key;
    uint64_t v10 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v11);
  }
  if (v10) {
    BOOL v6 = v10;
  }
  else {
    BOOL v6 = (_xlocale *)__global_locale;
  }
  return regcomp_l(a1, a2, a3, v6);
}

uint64_t regwncomp_l(uint64_t a1, uint64_t a2, uint64_t a3, int a4, void *a5)
{
  BOOL v6 = a5;
  if (!a5) {
    return tre_compile(a1, a2, a3, a4, (uint64_t)__c_locale);
  }
  if (a5 == (void *)-1) {
    BOOL v6 = __global_locale;
  }
  return tre_compile(a1, a2, a3, a4, (uint64_t)v6);
}

int regwncomp(regex_t *a1, const __int32 *a2, size_t a3, int a4)
{
  if (v4) {
    char v5 = 1;
  }
  else {
    char v5 = 0;
  }
  if (v5)
  {
    int v12 = pthread_getspecific(__locale_key);
  }
  else
  {
    uint64_t v13 = __locale_key;
    int v12 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v13);
  }
  if (v12) {
    unint64_t v7 = v12;
  }
  else {
    unint64_t v7 = __global_locale;
  }
  return tre_compile((uint64_t)a1, (uint64_t)a2, a3, a4, (uint64_t)v7);
}

int regwcomp_l(regex_t *a1, const __int32 *a2, int a3, locale_t a4)
{
  locale_t v6 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1) {
      locale_t v6 = (locale_t)__global_locale;
    }
  }
  else
  {
    locale_t v6 = (locale_t)__c_locale;
  }
  size_t v4 = wcslen(a2);
  return tre_compile((uint64_t)a1, (uint64_t)a2, v4, a3, (uint64_t)v6);
}

int regwcomp(regex_t *a1, const __int32 *a2, int a3)
{
  size_t v3 = wcslen(a2);
  return regwncomp(a1, a2, v3, a3);
}

void regfree(regex_t *a1)
{
}

uint64_t tre_fill_pmatch(unint64_t a1, uint64_t a2, char a3, uint64_t a4, void *a5, int a6)
{
  if ((a3 & 4) != 0)
  {
    return 0;
  }
  else
  {
    unsigned int v11 = 0;
    if (a6 >= 0 && a5)
    {
      uint64_t v10 = a5;
      if (*(void *)(a4 + 48) && *(int *)(*(void *)(a4 + 48) + 16) > 0)
      {
        mbstate_t __dst = (void *)malloc_type_malloc();
        if (!__dst) {
          return 12;
        }
        memcpy(__dst, a5, 16 * *(int *)(a4 + 80));
        tre_reset_last_matched_branches((uint64_t)__dst, *(uint64_t **)(*(void *)(a4 + 48) + 8), *(_DWORD *)(*(void *)(a4 + 48) + 16), 0, 0);
        uint64_t v10 = __dst;
      }
      uint64_t v9 = *(void *)(a4 + 24);
      while (1)
      {
        BOOL v7 = 0;
        if (v11 < *(_DWORD *)(a4 + 72)) {
          BOOL v7 = v11 < a1;
        }
        if (!v7) {
          break;
        }
        if (*(_DWORD *)(v9 + 8 * v11) == *(_DWORD *)(a4 + 88)) {
          *(void *)(a2 + 16 * v11) = a6;
        }
        else {
          *(void *)(a2 + 16 * v11) = (int)tre_tag_get((uint64_t)v10, *(_DWORD *)(v9 + 8 * v11));
        }
        if (*(_DWORD *)(v9 + 8 * v11 + 4) == *(_DWORD *)(a4 + 88)) {
          *(void *)(a2 + 16 * v11 + 8) = a6;
        }
        else {
          *(void *)(a2 + 16 * v11 + 8) = (int)tre_tag_get((uint64_t)v10, *(_DWORD *)(v9 + 8 * v11 + 4));
        }
        if (*(void *)(a2 + 16 * v11) == -1 || *(void *)(a2 + 16 * v11 + 8) == -1)
        {
          *(void *)(a2 + 16 * v11 + 8) = -1;
          *(void *)(a2 + 16 * v11) = -1;
        }
        ++v11;
      }
      if (v10 != a5) {
        free(v10);
      }
    }
    while (v11 < a1)
    {
      *(void *)(a2 + 16 * v11) = -1;
      *(void *)(a2 + 16 * v11++ + 8) = -1;
    }
    return 0;
  }
}

uint64_t tre_reset_last_matched_branches(uint64_t result, uint64_t *a2, int a3, int a4, int a5)
{
  uint64_t v25 = result;
  int v20 = 0;
  while (1)
  {
    int v5 = a3--;
    if (v5 <= 0) {
      break;
    }
    if (*((_DWORD *)a2 + 2) == 1)
    {
      uint64_t v13 = *a2;
      if (a4 <= 0)
      {
        unsigned int v16 = 0;
      }
      else
      {
        BOOL v9 = 1;
        if (!a5)
        {
          unsigned int v8 = tre_tag_touch_get(v25, *(_DWORD *)(v13 + 20));
          int v6 = tre_tag_touch_get(v25, a4);
          uint64_t result = v8;
          BOOL v9 = (int)v8 < v6;
        }
        unsigned int v16 = v9;
      }
      if (v16)
      {
        int v17 = *(_DWORD *)(v13 + 24);
        int v12 = *(int **)v13;
        while (v17 > 0)
        {
          uint64_t result = tre_tag_reset(v25, *v12);
          --v17;
          ++v12;
        }
      }
      if (*(int *)(v13 + 16) > 0) {
        uint64_t result = tre_reset_last_matched_branches(v25, *(void *)(v13 + 8), *(unsigned int *)(v13 + 16), *((unsigned int *)a2 + 3), v16);
      }
    }
    else
    {
      if (!a5)
      {
        int v20 = 0;
        int v18 = *((_DWORD *)a2 + 2);
        uint64_t v14 = *a2;
        while (v18 > 0)
        {
          uint64_t result = tre_tag_touch_get(v25, *(_DWORD *)(v14 + 20));
          if ((int)result > v20) {
            int v20 = result;
          }
          --v18;
          v14 += 32;
        }
      }
      int v19 = *((_DWORD *)a2 + 2);
      uint64_t v15 = *a2;
      while (v19 > 0)
      {
        BOOL v7 = 1;
        if (!a5)
        {
          uint64_t result = tre_tag_touch_get(v25, *(_DWORD *)(v15 + 20));
          BOOL v7 = (int)result < v20;
        }
        if (v7)
        {
          int v11 = *(_DWORD *)(v15 + 24);
          uint64_t v10 = *(int **)v15;
          while (v11 > 0)
          {
            uint64_t result = tre_tag_reset(v25, *v10);
            --v11;
            ++v10;
          }
        }
        if (*(int *)(v15 + 16) > 0) {
          uint64_t result = tre_reset_last_matched_branches(v25, *(void *)(v15 + 8), *(unsigned int *)(v15 + 16), *((unsigned int *)a2 + 3), v7);
        }
        --v19;
        v15 += 32;
      }
    }
    a2 += 2;
  }
  return result;
}

uint64_t tre_tag_get(uint64_t a1, int a2)
{
  if (*(int *)(a1 + 16 * a2) <= 0) {
    return -1;
  }
  else {
    return *(unsigned int *)(a1 + 16 * a2 + 8);
  }
}

int regnexec(const regex_t *a1, const char *a2, size_t a3, size_t a4, regmatch_t __pmatch[], int a6)
{
  re_g = a1->re_g;
  if (*(_DWORD *)(*(void *)(*((void *)re_g + 7) + 1328) + 64) == 1) {
    int v6 = 1;
  }
  else {
    int v6 = 2;
  }
  if (a1->re_magic == 62053) {
    return tre_match((int *)re_g, (uint64_t)a2, a3, v6, a4, &__pmatch->rm_so, a6);
  }
  else {
    return 2;
  }
}

uint64_t tre_match(int *a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5, uint64_t *a6, int a7)
{
  size_t v21 = a1;
  uint64_t v20 = a2;
  uint64_t v19 = a3;
  int v18 = a4;
  unint64_t v17 = a5;
  unsigned int v16 = a6;
  int v15 = a7;
  unsigned int v14 = 0;
  uint64_t v13 = 0;
  int v12 = 0;
  uint64_t v11 = 0;
  uint64_t v10 = 0;
  if ((a7 & 4) != 0 && v16)
  {
    if (*v16 < 0) {
      return 16;
    }
    if (v19 == -1)
    {
      if (v16[1] < 0 || *v16 > v16[1]) {
        return 16;
      }
      uint64_t v19 = v16[1] - *v16;
    }
    uint64_t v11 = *v16;
    uint64_t v10 = *v16;
    if (!v18) {
      v11 *= 4;
    }
  }
  if (v21[20] <= 0 || !v17 || (uint64_t v13 = (void *)malloc_type_malloc()) != 0)
  {
    if (v21[25] || (v15 & 0x400) != 0) {
      unsigned int v14 = tre_tnfa_run_backtrack((uint64_t)v21, (char *)(v20 + v11), v19, v18, v13, v15, &v12);
    }
    else {
      unsigned int v14 = tre_tnfa_run_parallel((uint64_t)v21, (const char *)(v20 + v11), v19, v18, v13, v15, &v12);
    }
    if (!v14)
    {
      unsigned int v14 = tre_fill_pmatch(v17, (uint64_t)v16, v21[24], (uint64_t)v21, v13, v12);
      if (!v14 && (v21[24] & 4) == 0 && (v15 & 4) != 0 && v16 && v17)
      {
        unint64_t v9 = v17;
        unsigned int v8 = v16;
        while (v9)
        {
          if (*v8 >= 0) {
            *v8 += v10;
          }
          if (v8[1] >= 0) {
            v8[1] += v10;
          }
          v8 += 2;
          --v9;
        }
      }
    }
    if (v13) {
      free(v13);
    }
    return v14;
  }
  else
  {
    return 12;
  }
}

int regexec(const regex_t *a1, const char *a2, size_t a3, regmatch_t __pmatch[], int a5)
{
  return regnexec(a1, a2, 0xFFFFFFFFFFFFFFFFLL, a3, __pmatch, a5);
}

int regwnexec(const regex_t *a1, const __int32 *a2, size_t a3, size_t a4, regmatch_t __pmatch[], int a6)
{
  if (a1->re_magic == 62053) {
    return tre_match((int *)a1->re_g, (uint64_t)a2, a3, 0, a4, &__pmatch->rm_so, a6);
  }
  else {
    return 2;
  }
}

int regwexec(const regex_t *a1, const __int32 *a2, size_t a3, regmatch_t __pmatch[], int a5)
{
  return regwnexec(a1, a2, 0xFFFFFFFFFFFFFFFFLL, a3, __pmatch, a5);
}

uint64_t tre_tag_touch_get(uint64_t a1, int a2)
{
  return *(unsigned int *)(a1 + 16 * a2 + 12);
}

uint64_t tre_tag_reset(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16 * a2) = 0;
  return result;
}

char *tre_ast_new_node(uint64_t a1, int a2, unint64_t a3)
{
  size_t v4 = tre_mem_alloc_impl(a1, 0, 0, 1, 0x48uLL);
  if (!v4) {
    return 0;
  }
  *(void *)size_t v4 = tre_mem_alloc_impl(a1, 0, 0, 1, a3);
  if (!*(void *)v4) {
    return 0;
  }
  *((_DWORD *)v4 + 12) = a2;
  *((_WORD *)v4 + 32) = -1;
  *((_DWORD *)v4 + 13) = -1;
  return v4;
}

char *tre_ast_new_literal(uint64_t a1, int a2, int a3, int a4)
{
  int v6 = tre_ast_new_node(a1, 0, 0x18uLL);
  if (!v6) {
    return 0;
  }
  int v5 = *(_DWORD **)v6;
  *int v5 = a2;
  v5[1] = a3;
  _DWORD v5[2] = a4;
  return v6;
}

char *tre_ast_new_iter(uint64_t a1, uint64_t a2, int a3, int a4, char a5)
{
  BOOL v7 = tre_ast_new_node(a1, 2, 0x20uLL);
  if (!v7) {
    return 0;
  }
  uint64_t v6 = *(void *)v7;
  *(void *)uint64_t v6 = a2;
  *(_DWORD *)(v6 + 8) = a3;
  *(_DWORD *)(v6 + 12) = a4;
  *(unsigned char *)(v6 + 16) = *(unsigned char *)(v6 + 16) & 0xFE | a5 & 1;
  *((_DWORD *)v7 + 14) = *(_DWORD *)(a2 + 56);
  return v7;
}

char *tre_ast_new_union(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v4 = tre_ast_new_node(a1, 3, 0x18uLL);
  if (!v4) {
    return 0;
  }
  **(void **)size_t v4 = a2;
  *(void *)(*(void *)v4 + 8) = a3;
  *((_DWORD *)v4 + 14) = *(_DWORD *)(a2 + 56) + *(_DWORD *)(a3 + 56);
  return v4;
}

char *tre_ast_new_catenation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  size_t v4 = tre_ast_new_node(a1, 1, 0x10uLL);
  if (!v4) {
    return 0;
  }
  **(void **)size_t v4 = a2;
  *(void *)(*(void *)v4 + 8) = a3;
  *((_DWORD *)v4 + 14) = *(_DWORD *)(a2 + 56) + *(_DWORD *)(a3 + 56);
  return v4;
}

uint64_t tre_compile(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v32 = a1;
  uint64_t v31 = a2;
  uint64_t v30 = a3;
  int v29 = a4;
  uint64_t v28 = a5;
  int v27 = 0;
  int v26 = 0;
  uint64_t v25 = 0;
  locale_t v24 = 0;
  int j = 0;
  int v22 = 0;
  size_t v21 = 0;
  int i = 0;
  int v19 = 0;
  uint64_t v18 = 0;
  uint64_t v17 = 0;
  uint64_t v16 = 0;
  uint64_t v15 = 0;
  unsigned int v14 = 0;
  unsigned int v13 = 0;
  int v12 = 0;
  memset(__b, 0, sizeof(__b));
  int v27 = (void **)tre_stack_new(512, 10240, 128);
  if (!v27) {
    return 12;
  }
  int v12 = (void **)tre_mem_new_impl(0, 0);
  if (!v12)
  {
    tre_stack_destroy(v27);
    return 12;
  }
  memset(__b, 0, sizeof(__b));
  __b[0] = v12;
  __b[1] = v27;
  __b[3] = v31;
  LODWORD(__b[7]) = v30;
  if ((v29 & 0x101) != 0x101) {
    v29 &= ~0x40u;
  }
  HIDWORD(__b[10]) = v29;
  LODWORD(__b[9]) = -1;
  void __b[6] = v28;
  LODWORD(__b[8]) = 0x40000000;
  unsigned int v13 = tre_parse(__b);
  if (v13) {
    goto LABEL_84;
  }
  *(void *)(v32 + 8) = HIDWORD(__b[7]) - 1;
  int v26 = (char *)__b[2];
  if (SLODWORD(__b[9]) >= 0 && LODWORD(__b[10]))
  {
    unsigned int v13 = 2;
LABEL_84:
    tre_mem_destroy(v12);
    if (v27) {
      tre_stack_destroy(v27);
    }
    if (v22) {
      free(v22);
    }
    if (v21) {
      free(v21);
    }
    *(void *)(v32 + 24) = v16;
    if (v16) {
      *(void *)(v16 + 56) = 0;
    }
    tre_free(v32);
    return v13;
  }
  if (SLODWORD(__b[9]) > (int)*(void *)(v32 + 8))
  {
    unsigned int v13 = 6;
    goto LABEL_84;
  }
  uint64_t v16 = malloc_type_calloc();
  if (!v16)
  {
    unsigned int v13 = 12;
    goto LABEL_84;
  }
  *(_DWORD *)(v16 + 100) = SLODWORD(__b[9]) >= 0;
  *(_DWORD *)(v16 + 108) = __b[10];
  *(_DWORD *)(v16 + 72) = HIDWORD(__b[7]);
  *(_DWORD *)(v16 + 76) = LODWORD(__b[8]) - 0x40000000;
  *(_DWORD *)(v16 + 104) = HIDWORD(__b[9]);
  *(void *)(v16 + 56) = __b[6];
  if (*(int *)(v16 + 104) > 0 || (v29 & 4) == 0)
  {
    unsigned int v13 = tre_add_tags(0, (uint64_t)v27, (uint64_t)v26, v16);
    if (v13) {
      goto LABEL_84;
    }
    if (*(int *)(v16 + 80) > 0)
    {
      unsigned int v14 = (void *)malloc_type_malloc();
      if (!v14)
      {
        unsigned int v13 = 12;
        goto LABEL_84;
      }
      *(void *)(v16 + 32) = v14;
      memset(v14, -1, 4 * (*(_DWORD *)(v16 + 80) + 1));
    }
    *(void *)(v16 + 40) = malloc_type_calloc();
    if (!*(void *)(v16 + 40))
    {
      unsigned int v13 = 12;
      goto LABEL_84;
    }
    uint64_t v15 = malloc_type_calloc();
    if (!v15)
    {
      unsigned int v13 = 12;
      goto LABEL_84;
    }
    for (int i = 0; i < SHIDWORD(__b[7]); ++i)
      *(_DWORD *)(v15 + 8 * i + 4) = -1;
    *(void *)(v16 + 24) = v15;
    unsigned int v13 = tre_add_tags((uint64_t)v12, (uint64_t)v27, (uint64_t)v26, v16);
    if (v13) {
      goto LABEL_84;
    }
  }
  unsigned int v13 = tre_expand_ast((uint64_t)v12, (uint64_t)v27, (uint64_t)v26, (_DWORD *)&__b[8] + 1, (uint64_t)v14, v16 + 112);
  if (v13) {
    goto LABEL_84;
  }
  uint64_t v25 = v26;
  int v5 = HIDWORD(__b[8])++;
  locale_t v24 = tre_ast_new_literal((uint64_t)v12, 0, 0, v5);
  if (!v24)
  {
    unsigned int v13 = 12;
    goto LABEL_84;
  }
  int v26 = tre_ast_new_catenation((uint64_t)v12, (uint64_t)v25, (uint64_t)v24);
  if (!v26)
  {
    unsigned int v13 = 12;
    goto LABEL_84;
  }
  unsigned int v13 = tre_compute_nfl((uint64_t)v12, (uint64_t)v27, (uint64_t)v26);
  if (v13) {
    goto LABEL_84;
  }
  int v22 = (void *)malloc_type_malloc();
  if (!v22)
  {
    unsigned int v13 = 12;
    goto LABEL_84;
  }
  size_t v21 = (int *)malloc_type_malloc();
  if (!v21)
  {
    unsigned int v13 = 12;
    goto LABEL_84;
  }
  for (int i = 0; i < SHIDWORD(__b[8]); ++i)
    *((_DWORD *)v22 + i) = 0;
  tre_ast_to_tnfa(v26, 0, (uint64_t)v22, 0);
  int v19 = 0;
  for (int i = 0; i < SHIDWORD(__b[8]); ++i)
  {
    v21[i] = v19;
    v19 += *((_DWORD *)v22 + i) + 1;
    *((_DWORD *)v22 + i) = 0;
  }
  uint64_t v18 = malloc_type_calloc();
  if (!v18)
  {
    unsigned int v13 = 12;
    goto LABEL_84;
  }
  *(void *)uint64_t v16 = v18;
  *(_DWORD *)(v16 + 64) = v19;
  unsigned int v13 = tre_ast_to_tnfa(v26, v18, (uint64_t)v22, (uint64_t)v21);
  if (v13) {
    goto LABEL_84;
  }
  *(_DWORD *)(v16 + 68) = -1;
  if (!*((_WORD *)v25 + 32))
  {
    int v10 = 1;
    for (int j = (int *)*((void *)v26 + 3); ; j += 16)
    {
      BOOL v7 = 0;
      if (v10) {
        BOOL v7 = *j >= 0;
      }
      if (!v7) {
        break;
      }
      for (uint64_t k = v18 + 56 * v21[*j]; *(void *)(k + 8); k += 56)
      {
        if (*(_DWORD *)k <= *(_DWORD *)(k + 4))
        {
          if (*(_DWORD *)(k + 4) != *(_DWORD *)k || *(_DWORD *)k == -1 || *(_DWORD *)(v16 + 68) != -1)
          {
            *(_DWORD *)(v16 + 68) = -1;
            int v10 = 0;
            break;
          }
          *(_DWORD *)(v16 + 68) = *(_DWORD *)k;
        }
      }
    }
  }
  int j = (int *)*((void *)v26 + 3);
  int i = 0;
  while (*j >= 0)
  {
    ++i;
    j += 16;
  }
  uint64_t v17 = malloc_type_calloc();
  if (!v17)
  {
    unsigned int v13 = 12;
    goto LABEL_84;
  }
  *(void *)(v16 + 8) = v17;
  int i = 0;
  for (int j = (int *)*((void *)v26 + 3); *j >= 0; j += 16)
  {
    *(void *)(v17 + 56 * i + 8) = v18 + 56 * v21[*j];
    *(_DWORD *)(v17 + 56 * i + 16) = *j;
    *(void *)(v17 + 56 * i + 24) = 0;
    if (*((void *)j + 2))
    {
      for (int m = 0; *(int *)(*((void *)j + 2) + 4 * m) >= 0; ++m)
        ;
      *(void *)(v17 + 56 * i + 24) = malloc_type_malloc();
      if (!*(void *)(v17 + 56 * i + 24))
      {
        unsigned int v13 = 12;
        goto LABEL_84;
      }
      memcpy(*(void **)(v17 + 56 * i + 24), *((const void **)j + 2), 4 * (m + 1));
    }
    *(void *)(v17 + 56 * i + 32) = 0;
    if (*((void *)j + 6))
    {
      *(void *)(v17 + 56 * i + 32) = malloc_type_malloc();
      if (!*(void *)(v17 + 56 * i + 32))
      {
        unsigned int v13 = 12;
        goto LABEL_84;
      }
      memcpy(*(void **)(v17 + 56 * i + 32), *((const void **)j + 6), 0x24uLL);
    }
    *(_DWORD *)(v17 + 56 * i++ + 40) = j[6];
  }
  *(void *)(v17 + 56 * i + 8) = 0;
  *(_DWORD *)(v16 + 64) = v19;
  *(void *)(v16 + 16) = v18 + 56 * v21[**((int **)v26 + 4)];
  *(_DWORD *)(v16 + 92) = HIDWORD(__b[8]);
  *(_DWORD *)(v16 + 96) = v29;
  tre_mem_destroy(v12);
  tre_stack_destroy(v27);
  free(v22);
  free(v21);
  *(_DWORD *)uint64_t v32 = 62053;
  *(void *)(v32 + 24) = v16;
  xlocale_retain(*(atomic_uint **)(v16 + 56));
  return 0;
}

uint64_t tre_add_tags(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v115 = tre_stack_num_objects(a2);
  BOOL v31 = 1;
  if (a1) {
    BOOL v31 = a4 == 0;
  }
  int v112 = 0;
  int v111 = 0;
  int v110 = 0;
  signed int v109 = 0;
  int v108 = 1;
  int v107 = -1;
  int v106 = 0;
  uint64_t v103 = 0;
  uint64_t v102 = 0;
  int v99 = 2;
  if (!v31)
  {
    *(_DWORD *)(a4 + 88) = 0;
    **(_DWORD **)(a4 + 40) = -1;
  }
  uint64_t v114 = (_DWORD *)malloc_type_malloc();
  if (v114)
  {
    *uint64_t v114 = -1;
    uint64_t v113 = v114;
    if (!v31)
    {
      int v106 = (signed int *)malloc_type_malloc();
      uint64_t v103 = v106;
      if (!v106)
      {
        unsigned int v126 = 12;
LABEL_348:
        free(v113);
        return v126;
      }
      uint64_t v102 = (char *)&v106[2 * *(_DWORD *)(a4 + 104) + 1];
    }
    tre_stack_push_voidptr(a2, a3);
    unsigned int v126 = tre_stack_push_int(a2, 0);
    while ((int)tre_stack_num_objects(a2) > v115 && !v126)
    {
      unsigned int v124 = tre_stack_pop_int(a2);
      if (v124)
      {
        uint64_t v5 = v124;
        char v4 = 1;
      }
      else
      {
        uint64_t v5 = v124;
        char v4 = 0;
      }
      if ((v4 & 1) == 0)
      {
        switch(v5)
        {
          case 0:
            int v98 = 1;
            goto LABEL_35;
          case 1:
            int v98 = 0;
LABEL_35:
            v118 = (void **)tre_stack_pop_voidptr(a2);
            signed int v101 = *((_DWORD *)v118 + 13);
            if (v101 >= 0)
            {
              for (int i = 0; v114[i] != -1; ++i)
                ;
              v114[i] = 2 * v101;
              v114[i + 1] = -1;
              v112 |= 1u;
              tre_stack_push_voidptr(a2, (uint64_t)v118);
              unsigned int v126 = tre_stack_push_int(a2, v101);
              if (v126) {
                continue;
              }
              unsigned int v126 = tre_stack_push_int(a2, 7u);
              if (v126) {
                continue;
              }
            }
            unsigned int v7 = *((_DWORD *)v118 + 12);
            if (v7)
            {
              uint64_t v9 = v7;
              char v8 = 1;
            }
            else
            {
              uint64_t v9 = *((unsigned int *)v118 + 12);
              char v8 = 0;
            }
            if (v8) {
              continue;
            }
            break;
          case 2:
            uint64_t v119 = tre_stack_pop_voidptr(a2);
            if (*(void *)(v119 + 40)) {
              int v29 = *(unsigned char ***)(v119 + 40);
            }
            else {
              int v29 = (unsigned char **)v119;
            }
            wint_t v78 = *v29;
            int v77 = tre_stack_pop_int(a2);
            if (v78[16]) {
              int v107 = v77;
            }
            if (v31)
            {
              int v28 = *(_DWORD *)(*(void *)v78 + 60);
              *(_DWORD *)(v119 + 60) = v28 + tre_stack_pop_int(a2);
              continue;
            }
            int v76 = *(_DWORD **)(*(void *)v78 + 8);
            if (!v76 || (int)v76[6] <= 0) {
              goto LABEL_160;
            }
            int v74 = v76 + 10;
            int v71 = -1;
            int v73 = 0;
            while (2)
            {
              if (v73 <= v111 >> 3)
              {
                if (!*((unsigned char *)v74 + v73))
                {
                  ++v73;
                  continue;
                }
                int v71 = 8 * v73;
                for (int j = *((unsigned __int8 *)v74 + v73); (j & 1) == 0; j >>= 1)
                  ++v71;
              }
              break;
            }
            v76[5] = v71;
            int v75 = tre_mem_alloc_impl(a1, 0, 0, 1, ((*(_DWORD *)(a4 + 80) + 7) >> 3) + 80);
            if (!v75)
            {
              unsigned int v126 = 12;
              continue;
            }
            *((void *)v75 + 1) = v76;
            *((_DWORD *)v75 + 4) = 1;
            *((_DWORD *)v75 + 5) = v76[5];
            *((_DWORD *)v75 + 6) = v76[7];
            *((_DWORD *)v75 + 7) = v76[8] + 1;
            *((_DWORD *)v75 + 8) = v76[9];
            *((void *)v75 + 6) = v75;
            *((_DWORD *)v75 + 14) = 1;
            *((_DWORD *)v75 + 17) = *((_DWORD *)v75 + 6) + 1;
            *((_DWORD *)v75 + 18) = *((_DWORD *)v75 + 7);
            *((_DWORD *)v75 + 19) = *((_DWORD *)v75 + 8);
            *(void *)(*(void *)v78 + 8) = v75 + 40;
LABEL_160:
            unsigned int v126 = tre_merge_branches(a1, v119, *(void *)v78, 0, *(_DWORD *)(a4 + 80));
            if (v126) {
              continue;
            }
            if (v78[16])
            {
              if (!*((_DWORD *)v78 + 2) && *((int *)v78 + 3) <= 1)
              {
                int v69 = tre_ast_new_literal(a1, -1, -1, -1);
                if (!v69)
                {
                  unsigned int v126 = 12;
                  continue;
                }
                int v70 = tre_ast_new_union(a1, (uint64_t)v69, *(void *)v78);
                if (!v70)
                {
                  unsigned int v126 = 12;
                  continue;
                }
                *(void *)wint_t v78 = v70;
              }
              int v99 = 0;
            }
            else
            {
              int v99 = 1;
            }
            continue;
          case 3:
            while (*v114 != -1)
              ++v114;
            int v112 = 0;
            continue;
          case 4:
            uint64_t v121 = tre_stack_pop_voidptr(a2);
            if (*(void *)(v121 + 40)) {
              int v27 = *(uint64_t **)(v121 + 40);
            }
            else {
              int v27 = (uint64_t *)v121;
            }
            uint64_t v65 = *v27;
            int v66 = tre_stack_pop_int(a2);
            if (v31)
            {
              *(_DWORD *)(v121 + 60) = *(_DWORD *)(*(void *)v65 + 60)
                                     + *(_DWORD *)(*(void *)(v65 + 8) + 60)
                                     + v66;
              if (*(int *)(v65 + 16) > 0) {
                ++*(_DWORD *)(v121 + 60);
              }
              if (*(int *)(v65 + 20) > 0) {
                ++*(_DWORD *)(v121 + 60);
              }
            }
            uint64_t v114 = (_DWORD *)tre_stack_pop_voidptr(a2);
            if (v31 || !*(_WORD *)(v121 + 66)) {
              goto LABEL_232;
            }
            uint64_t v64 = *(void *)(*(void *)v65 + 8);
            uint64_t v63 = *(void *)(*(void *)(v65 + 8) + 8);
            uint64_t v62 = *(void *)(*(void *)v65 + 16);
            uint64_t v61 = *(void *)(*(void *)(v65 + 8) + 16);
            if (*(int *)(v65 + 16) <= 0) {
              goto LABEL_197;
            }
            unsigned int v126 = tre_add_tag_right(a1, *(void *)v65, *(_DWORD *)(v65 + 16));
            if (v126) {
              continue;
            }
            *(_DWORD *)(*(void *)(a4 + 32) + 4 * *(int *)(v65 + 16)) = 1;
            if (v64) {
              goto LABEL_196;
            }
            unsigned int v126 = tre_merge_branches(a1, *(void *)v65, 0, -1, *(_DWORD *)(a4 + 80));
            if (v126) {
              continue;
            }
            uint64_t v64 = *(void *)(*(void *)v65 + 8);
LABEL_196:
            *(_DWORD *)(v64 + 20) = *(_DWORD *)(v65 + 16);
LABEL_197:
            if (*(int *)(v65 + 20) <= 0) {
              goto LABEL_203;
            }
            unsigned int v126 = tre_add_tag_right(a1, *(void *)(v65 + 8), *(_DWORD *)(v65 + 20));
            if (v126) {
              continue;
            }
            *(_DWORD *)(*(void *)(a4 + 32) + 4 * *(int *)(v65 + 20)) = 1;
            if (v63) {
              goto LABEL_202;
            }
            unsigned int v126 = tre_merge_branches(a1, *(void *)(v65 + 8), 0, -1, *(_DWORD *)(a4 + 80));
            if (v126) {
              continue;
            }
            uint64_t v63 = *(void *)(*(void *)(v65 + 8) + 8);
LABEL_202:
            *(_DWORD *)(v63 + 20) = *(_DWORD *)(v65 + 20);
LABEL_203:
            if (v62)
            {
              if (v61)
              {
                if (*(void *)(v62 + 8))
                {
                  if (*(void *)(v61 + 8))
                  {
                    for (uint64_t k = *(void **)(v62 + 8); *k; uint64_t k = (void *)*k)
                      ;
                    *uint64_t k = *(void *)(v61 + 8);
                    *(_DWORD *)(v62 + 16) += *(_DWORD *)(v61 + 16);
                  }
                }
                else if (*(void *)(v61 + 8))
                {
                  *(void *)(v62 + 8) = *(void *)(v61 + 8);
                  *(_DWORD *)(v62 + 16) = *(_DWORD *)(v61 + 16);
                }
                *(_DWORD *)(v62 + 24) += *(_DWORD *)(v61 + 24);
                *(_DWORD *)(v62 + 28) += *(_DWORD *)(v61 + 28) - 1;
                *(_DWORD *)(v62 + 32) += *(_DWORD *)(v61 + 32);
                char v60 = (char *)v62;
              }
              else
              {
                char v60 = (char *)v62;
                if (v63)
                {
                  *(void *)uint64_t v63 = *(void *)(v62 + 8);
                  *(void *)(v62 + 8) = v63;
                  ++*(_DWORD *)(v62 + 16);
                  *(_DWORD *)(v62 + 24) += *(_DWORD *)(v63 + 28);
                  *(_DWORD *)(v62 + 28) += *(_DWORD *)(v63 + 32);
                  *(_DWORD *)(v62 + 32) += *(_DWORD *)(v63 + 36);
                }
              }
            }
            else if (v61)
            {
              char v60 = (char *)v61;
              if (v64)
              {
                *(void *)uint64_t v64 = *(void *)(v61 + 8);
                *(void *)(v61 + 8) = v64;
                ++*(_DWORD *)(v61 + 16);
                *(_DWORD *)(v61 + 24) += *(_DWORD *)(v64 + 28);
                *(_DWORD *)(v61 + 28) += *(_DWORD *)(v64 + 32);
                *(_DWORD *)(v61 + 32) += *(_DWORD *)(v64 + 36);
              }
            }
            else
            {
              char v60 = tre_mem_alloc_impl(a1, 0, 0, 1, 0x28uLL);
              if (!v60)
              {
                unsigned int v126 = 12;
                continue;
              }
              *((_DWORD *)v60 + 7) = 1;
              if (v64)
              {
                *((void *)v60 + 1) = v64;
                *((_DWORD *)v60 + 4) = 1;
                *((_DWORD *)v60 + 6) += *(_DWORD *)(v64 + 28);
                *((_DWORD *)v60 + 7) += *(_DWORD *)(v64 + 32);
                *((_DWORD *)v60 + 8) += *(_DWORD *)(v64 + 36);
                if (v63)
                {
                  *(void *)uint64_t v64 = v63;
                  ++*((_DWORD *)v60 + 4);
                  *((_DWORD *)v60 + 6) += *(_DWORD *)(v63 + 28);
                  *((_DWORD *)v60 + 7) += *(_DWORD *)(v63 + 32);
                  *((_DWORD *)v60 + 8) += *(_DWORD *)(v63 + 36);
                }
              }
              else if (v63)
              {
                *((void *)v60 + 1) = v63;
                *((_DWORD *)v60 + 4) = 1;
                *((_DWORD *)v60 + 6) += *(_DWORD *)(v63 + 28);
                *((_DWORD *)v60 + 7) += *(_DWORD *)(v63 + 32);
                *((_DWORD *)v60 + 8) += *(_DWORD *)(v63 + 36);
              }
            }
            *(void *)(v121 + 16) = v60;
LABEL_232:
            int v99 = 1;
            continue;
          case 5:
            int v68 = tre_stack_pop_int(a2);
            int v108 = tre_stack_pop_int(a2);
            if (v68 >= 0) {
              signed int v109 = v68;
            }
            continue;
          case 6:
            uint64_t v120 = tre_stack_pop_voidptr(a2);
            int v67 = *(uint64_t **)v120;
            if (v31)
            {
              *(_DWORD *)(v120 + 60) = *(_DWORD *)(*v67 + 60) + *(_DWORD *)(v67[1] + 60);
            }
            else
            {
              unsigned int v126 = tre_merge_branches(a1, *v67, v67[1], 0, *(_DWORD *)(a4 + 80));
              if (!v126) {
                unsigned int v126 = tre_merge_branches(a1, v120, *v67, 0, *(_DWORD *)(a4 + 80));
              }
            }
            continue;
          case 7:
            int v100 = tre_stack_pop_int(a2);
            uint64_t v117 = tre_stack_pop_voidptr(a2);
            for (int m = 0; v114[m] != -1; ++m)
              ;
            v114[m] = 2 * v100 + 1;
            v114[m + 1] = -1;
            v112 |= 2u;
            if (v107 < 0) {
              continue;
            }
            if (v31)
            {
              ++*(_DWORD *)(v117 + 60);
LABEL_31:
              int v107 = -1;
              *uint64_t v114 = -1;
              int v112 = 0;
              signed int v109 = v108;
              ++v111;
              ++v108;
              continue;
            }
            unsigned int v126 = tre_merge_branches(a1, v117, 0, v109, *(_DWORD *)(a4 + 80));
            if (!v126)
            {
              unsigned int v126 = tre_add_tag_right(a1, v117, v109);
              if (!v126)
              {
                *(_DWORD *)(*(void *)(a4 + 32) + 4 * v109) = 0;
                for (int n = 0; *(int *)(*(void *)(a4 + 40) + 4 * n) >= 0; ++n)
                  ;
                *(_DWORD *)(*(void *)(a4 + 40) + 4 * n) = v109;
                *(_DWORD *)(*(void *)(a4 + 40) + 4 * (n + 1)) = v107;
                *(_DWORD *)(*(void *)(a4 + 40) + 4 * (n + 2)) = -1;
                signed int *v103 = v109;
                uint64_t v6 = v103 + 1;
                v103 += 2;
                *uint64_t v6 = v107;
                ++v110;
                tre_purge_regset(v114, a4, v109);
                goto LABEL_31;
              }
            }
            continue;
          case 8:
          case 9:
            continue;
          case 10:
            uint64_t v122 = tre_stack_pop_voidptr(a2);
            *(void *)char v57 = tre_stack_pop_int(a2);
            int v58 = tre_mem_alloc_impl(a1, 0, 0, 1, ((*(_DWORD *)(a4 + 80) + 7) >> 3) + 40);
            if (v58)
            {
              *(void *)&v57[4] = *(void *)(v122 + 16);
              *(_DWORD *)(*(void *)&v57[4] + 20) = *(_DWORD *)v57;
              *((_DWORD *)v58 + 7) = *(_DWORD *)(*(void *)&v57[4] + 24) + 1;
              *((_DWORD *)v58 + 8) = *(_DWORD *)(*(void *)&v57[4] + 28);
              *((_DWORD *)v58 + 9) = *(_DWORD *)(*(void *)&v57[4] + 32);
              *((void *)v58 + 1) = *(void *)&v57[4];
              *((_DWORD *)v58 + 4) = 1;
              *(void *)(v122 + 8) = v58;
              *(void *)(v122 + 16) = 0;
            }
            else
            {
              unsigned int v126 = 12;
            }
            continue;
          default:
            goto LABEL_350;
        }
        switch(v9)
        {
          case 0:
            uint64_t v94 = *v118;
            if (*(int *)*v118 < 0 && *(_DWORD *)v94 != -4 && *(_DWORD *)v94 < 0xFFFFFFFE || !v112) {
              continue;
            }
            if (v31)
            {
              *((_DWORD *)v118 + 15) = 1;
LABEL_64:
              *uint64_t v114 = -1;
              int v112 = 0;
              signed int v109 = v108;
              ++v111;
              ++v108;
              continue;
            }
            unsigned int v126 = tre_merge_branches(a1, (uint64_t)v118, 0, v109, *(_DWORD *)(a4 + 80));
            if (!v126)
            {
              unsigned int v126 = tre_add_tag_left(a1, (uint64_t)v118, v109);
              if (!v126)
              {
                if (v112 == 1) {
                  *(_DWORD *)(*(void *)(a4 + 32) + 4 * v109) = 2;
                }
                else {
                  *(_DWORD *)(*(void *)(a4 + 32) + 4 * v109) = v99;
                }
                tre_purge_regset(v114, a4, v109);
                if (*(_DWORD *)v94 == -4)
                {
                  int v93 = *((_DWORD *)v94 + 1);
                  int v92 = *(_DWORD *)(*(void *)(a4 + 24) + 8 * v93);
                  if (*(int *)(*(void *)(a4 + 24) + 8 * v93 + 4) < 0)
                  {
                    unsigned int v126 = 6;
                    continue;
                  }
                  if (v92 < v109)
                  {
                    if (v92 > 0) {
                      --v92;
                    }
                    signed int *v103 = v109;
                    int v10 = v103 + 1;
                    v103 += 2;
                    *int v10 = v92;
                  }
                }
                goto LABEL_64;
              }
            }
            break;
          case 1:
            uint64_t v91 = **v118;
            uint64_t v90 = (*v118)[1];
            unsigned int v89 = -1;
            unsigned int v126 = tre_stack_push_voidptr(a2, (uint64_t)v118);
            if (!v126)
            {
              unsigned int v126 = tre_stack_push_int(a2, 6u);
              if (!v126)
              {
                unsigned int v126 = tre_stack_push_voidptr(a2, v90);
                if (!v126)
                {
                  unsigned int v126 = tre_stack_push_int(a2, 0);
                  if (!v126)
                  {
                    unsigned int v126 = tre_stack_push_int(a2, v108 + *(_DWORD *)(v91 + 60));
                    if (!v126)
                    {
                      if (*(int *)(v91 + 60) > 0 && *(int *)(v90 + 60) > 0) {
                        unsigned int v89 = v108++;
                      }
                      unsigned int v126 = tre_stack_push_int(a2, v89);
                      if (!v126)
                      {
                        unsigned int v126 = tre_stack_push_int(a2, 5u);
                        if (!v126)
                        {
                          unsigned int v126 = tre_stack_push_voidptr(a2, v91);
                          if (!v126) {
                            unsigned int v126 = tre_stack_push_int(a2, 0);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            continue;
          case 2:
            uint64_t v88 = *v118;
            if (v31)
            {
              unsigned int v126 = tre_stack_push_int(a2, v112 != 0);
              if (v126) {
                continue;
              }
            }
            unsigned int v126 = tre_stack_push_int(a2, v109);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_voidptr(a2, (uint64_t)v118);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_int(a2, 2u);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_voidptr(a2, *v88);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_int(a2, 0);
            if (v126) {
              continue;
            }
            if (!v112) {
              goto LABEL_99;
            }
            if (v31) {
              goto LABEL_98;
            }
            unsigned int v126 = tre_merge_branches(a1, (uint64_t)v118, 0, v109, *(_DWORD *)(a4 + 80));
            if (!v126)
            {
              unsigned int v126 = tre_add_tag_left(a1, (uint64_t)v118, v109);
              if (!v126)
              {
                if (v112 == 1 && v109)
                {
                  if (v88[2]) {
                    int v11 = 0;
                  }
                  else {
                    int v11 = 2;
                  }
                  *(_DWORD *)(*(void *)(a4 + 32) + 4 * v109) = v11;
                }
                else
                {
                  *(_DWORD *)(*(void *)(a4 + 32) + 4 * v109) = v99;
                }
                tre_purge_regset(v114, a4, v109);
LABEL_98:
                *uint64_t v114 = -1;
                int v112 = 0;
                signed int v109 = v108;
                ++v111;
                ++v108;
LABEL_99:
                int v99 = 2;
              }
            }
            continue;
          case 3:
            int v82 = -1;
            if (v112)
            {
              int v82 = v109;
              signed int v109 = v108;
              ++v111;
              ++v108;
            }
            if (v98)
            {
              BOOL v30 = 0;
              if (*((int *)v118 + 13) >= 0) {
                BOOL v30 = *((_DWORD *)v118 + 13) < 0x40000000;
              }
              if (*((_DWORD *)v118 + 14) - v30 > 0)
              {
                uint64_t v79 = tre_stack_num_objects(a2);
                tre_stack_push_voidptr(a2, (uint64_t)v118);
                tre_stack_push_int(a2, 8u);
                while ((int)tre_stack_num_objects(a2) > (int)v79)
                {
                  int v125 = tre_stack_pop_int(a2);
                  if (v125 == 8)
                  {
                    uint64_t v80 = tre_stack_pop_voidptr(a2);
                    uint64_t v87 = *(uint64_t **)v80;
                    uint64_t v85 = **(void **)v80;
                    *(_WORD *)(v80 + 66) = 1;
                    tre_stack_push_voidptr(a2, v80);
                    tre_stack_push_int(a2, 9u);
                    if (*(_DWORD *)(v85 + 48) == 3)
                    {
                      tre_stack_push_voidptr(a2, v85);
                      tre_stack_push_int(a2, 8u);
                    }
                    else
                    {
                      *((_DWORD *)v87 + 4) = v109;
                      signed int v109 = v108;
                      ++v111;
                      ++v108;
                    }
                  }
                  else if (v125 == 9)
                  {
                    uint64_t v81 = tre_stack_pop_voidptr(a2);
                    uint64_t v83 = *(void *)(*(void *)v81 + 8);
                    if (*(_DWORD *)(v83 + 48) == 3)
                    {
                      tre_stack_push_voidptr(a2, v83);
                      tre_stack_push_int(a2, 8u);
                    }
                    else
                    {
                      *(_DWORD *)(*(void *)v81 + 20) = v109;
                      signed int v109 = v108;
                      ++v111;
                      ++v108;
                    }
                  }
                }
                if (!v31)
                {
                  unsigned int v126 = tre_stack_push_int(a2, v82);
                  if (v126) {
                    continue;
                  }
                  unsigned int v126 = tre_stack_push_voidptr(a2, (uint64_t)v118);
                  if (v126) {
                    continue;
                  }
                  unsigned int v126 = tre_stack_push_int(a2, 0xAu);
                  if (v126) {
                    continue;
                  }
                }
              }
            }
            uint64_t v86 = **v118;
            uint64_t v84 = (*v118)[1];
            unsigned int v126 = tre_stack_push_voidptr(a2, (uint64_t)v114);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_int(a2, v112 != 0);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_voidptr(a2, (uint64_t)v118);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_int(a2, 4u);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_voidptr(a2, v84);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_int(a2, 1u);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_int(a2, 3u);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_voidptr(a2, v86);
            if (v126) {
              continue;
            }
            unsigned int v126 = tre_stack_push_int(a2, 1u);
            if (v126 || !v112) {
              continue;
            }
            if (v31) {
              goto LABEL_138;
            }
            unsigned int v126 = tre_merge_branches(a1, (uint64_t)v118, 0, v82, *(_DWORD *)(a4 + 80));
            if (!v126)
            {
              unsigned int v126 = tre_add_tag_left(a1, (uint64_t)v118, v82);
              if (!v126)
              {
                if (v112 == 1) {
                  *(_DWORD *)(*(void *)(a4 + 32) + 4 * v82) = 2;
                }
                else {
                  *(_DWORD *)(*(void *)(a4 + 32) + 4 * v82) = v99;
                }
                tre_purge_regset(v114, a4, v82);
LABEL_138:
                *uint64_t v114 = -1;
                int v112 = 0;
              }
            }
            continue;
          default:
            goto LABEL_350;
        }
      }
    }
    if (!v126)
    {
      if (!v31)
      {
        if (v111 != *(_DWORD *)(a4 + 80))
        {
          unsigned int v126 = 2;
          goto LABEL_347;
        }
        tre_purge_regset(v114, a4, v109);
        *(_DWORD *)(*(void *)(a4 + 32) + 4 * v111) = v99;
        if (v103 > &v106[2 * *(_DWORD *)(a4 + 104)])
        {
          unsigned int v126 = 2;
          goto LABEL_347;
        }
        signed int *v103 = -1;
        for (iint i = 0; ii < v111; ++ii)
          *(_DWORD *)&v102[4 * ii] = ii;
        uint64_t v104 = v106;
        while (*v104 >= 0)
        {
          int v12 = v104;
          v105 = v104 + 1;
          int v51 = *v12;
          if (*v12 < v111)
          {
            int v53 = *(_DWORD *)&v102[4 * v51];
            unsigned int v13 = v105;
            uint64_t v104 = v105 + 1;
            int v52 = *(_DWORD *)&v102[4 * *v13];
            if (v52 <= v53)
            {
              for (jint j = 0; jj < v111; ++jj)
              {
                if (*(_DWORD *)&v102[4 * jj] > v52 && *(_DWORD *)&v102[4 * jj] < v53) {
                  ++*(_DWORD *)&v102[4 * jj];
                }
              }
              *(_DWORD *)&v102[4 * v51] = v52 + 1;
            }
          }
          else
          {
            uint64_t v104 = v105 + 1;
          }
        }
        int v50 = 0;
        for (kuint64_t k = 0; kk < v111; ++kk)
        {
          if (*(_DWORD *)&v102[4 * kk] != kk)
          {
            int v50 = 1;
            break;
          }
        }
        if (!v50)
        {
          free(v106);
          int v106 = 0;
        }
      }
      if (v106)
      {
        for (mint m = 0; mm < *(_DWORD *)(a4 + 72); ++mm)
        {
          *(_DWORD *)(*(void *)(a4 + 24) + 8 * mm) = *(_DWORD *)&v102[4 * *(int *)(*(void *)(a4 + 24) + 8 * mm)];
          if (*(_DWORD *)(*(void *)(a4 + 24) + 8 * mm + 4) >= v111) {
            int v26 = *(_DWORD *)(*(void *)(a4 + 24) + 8 * mm + 4);
          }
          else {
            int v26 = *(_DWORD *)&v102[4 * *(int *)(*(void *)(a4 + 24) + 8 * mm + 4)];
          }
          *(_DWORD *)(*(void *)(a4 + 24) + 8 * mm + 4) = v26;
        }
        uint64_t __src = (_DWORD *)malloc_type_malloc();
        if (!__src)
        {
          unsigned int v126 = 12;
          goto LABEL_347;
        }
        for (nint n = 0; nn < v111; ++nn)
          __src[*(int *)&v102[4 * nn]] = *(_DWORD *)(*(void *)(a4 + 32) + 4 * nn);
        memcpy(*(void **)(a4 + 32), __src, 4 * v111);
        free(__src);
        for (int i1 = 0; *(int *)(*(void *)(a4 + 40) + 4 * i1) >= 0; ++i1)
        {
          if (*(_DWORD *)(*(void *)(a4 + 40) + 4 * i1) >= v111) {
            int v25 = *(_DWORD *)(*(void *)(a4 + 40) + 4 * i1);
          }
          else {
            int v25 = *(_DWORD *)&v102[4 * *(int *)(*(void *)(a4 + 40) + 4 * i1)];
          }
          *(_DWORD *)(*(void *)(a4 + 40) + 4 * i1) = v25;
        }
        unsigned int v126 = tre_stack_push_voidptr(a2, a3);
        while (1)
        {
          BOOL v24 = 0;
          if (!v126) {
            BOOL v24 = (int)tre_stack_num_objects(a2) > v115;
          }
          if (!v24) {
            break;
          }
          long long v123 = (uint64_t **)tre_stack_pop_voidptr(a2);
          unsigned int v14 = *((_DWORD *)v123 + 12);
          if (v14)
          {
            uint64_t v16 = v14;
            char v15 = 1;
          }
          else
          {
            uint64_t v16 = *((unsigned int *)v123 + 12);
            char v15 = 0;
          }
          if ((v15 & 1) == 0)
          {
            switch(v16)
            {
              case 0:
                if (*(_DWORD *)*v123 == -3) {
                  *((_DWORD *)*v123 + 1) = *(_DWORD *)&v102[4 * *((int *)*v123 + 1)];
                }
                continue;
              case 1:
                int v44 = *v123;
                unsigned int v126 = tre_stack_push_voidptr(a2, (*v123)[1]);
                if (!v126) {
                  unsigned int v126 = tre_stack_push_voidptr(a2, *v44);
                }
                continue;
              case 2:
                unsigned int v126 = tre_stack_push_voidptr(a2, **v123);
                continue;
              case 3:
                int v45 = *v123;
                unsigned int v126 = tre_stack_push_voidptr(a2, (*v123)[1]);
                if (!v126) {
                  unsigned int v126 = tre_stack_push_voidptr(a2, *v45);
                }
                continue;
              default:
                goto LABEL_350;
            }
          }
        }
        if (v126) {
          goto LABEL_347;
        }
      }
      if (!v31 && *(void *)(a3 + 8))
      {
        uint64_t v43 = malloc_type_calloc();
        if (!v43)
        {
          unsigned int v126 = 12;
          goto LABEL_347;
        }
        uint64_t v42 = v43;
        uint64_t v39 = v43 + 32 * *(int *)(*(void *)(a3 + 8) + 28);
        int v36 = (int *)(v39 + 16 * *(int *)(*(void *)(a3 + 8) + 32));
        tre_stack_push_voidptr(a2, *(void *)(a3 + 8));
        tre_stack_push_int(a2, 1u);
        unsigned int v126 = tre_stack_push_int(a2, 0);
        while (1)
        {
          BOOL v23 = 0;
          if (!v126) {
            BOOL v23 = (int)tre_stack_num_objects(a2) > v115;
          }
          if (!v23) {
            break;
          }
          unsigned int v17 = tre_stack_pop_int(a2);
          if (v17)
          {
            uint64_t v19 = v17;
            char v18 = 1;
          }
          else
          {
            uint64_t v19 = 0;
            char v18 = 0;
          }
          if ((v18 & 1) == 0)
          {
            switch(v19)
            {
              case 0:
                int v33 = tre_stack_pop_int(a2);
                unsigned int v126 = tre_stack_push_voidptr(a2, v42);
                if (!v126)
                {
                  unsigned int v126 = tre_stack_push_int(a2, 1u);
                  if (!v126) {
                    v42 += 32 * v33;
                  }
                }
                break;
              case 1:
                uint64_t v41 = tre_stack_pop_voidptr(a2);
                uint64_t v40 = tre_stack_pop_voidptr(a2);
                *(_DWORD *)(v41 + 16) = *(_DWORD *)(v40 + 16);
                *(_DWORD *)(v41 + 20) = *(_DWORD *)(v40 + 20);
                if (*(int *)(v40 + 24) > 0)
                {
                  int v20 = *(_DWORD *)(v40 + 24);
                  *(_DWORD *)(v41 + 24) = v20;
                  int v32 = v20;
                  *(void *)uint64_t v41 = v36;
                  for (int i2 = 0; i2 < v111; ++i2)
                  {
                    if ((*(unsigned __int8 *)(v40 + 40 + (i2 >> 3)) & (1 << (i2 & 7))) != 0)
                    {
                      size_t v21 = v36++;
                      *size_t v21 = i2;
                      if (--v32 <= 0) {
                        break;
                      }
                    }
                  }
                }
                if ((!*(void *)v40
                   || (unsigned int v126 = tre_stack_push_voidptr(a2, *(void *)v40)) == 0
                   && (unsigned int v126 = tre_stack_push_voidptr(a2, v41 + 32)) == 0
                   && (unsigned int v126 = tre_stack_push_int(a2, 1u)) == 0)
                  && *(int *)(v40 + 16) > 0)
                {
                  *(void *)(v41 + 8) = v39;
                  unsigned int v126 = tre_stack_push_voidptr(a2, *(void *)(v40 + 8));
                  if (!v126)
                  {
                    unsigned int v126 = tre_stack_push_int(a2, *(_DWORD *)(v40 + 16));
                    if (!v126) {
                      unsigned int v126 = tre_stack_push_int(a2, 2u);
                    }
                  }
                }
                break;
              case 2:
                int v35 = tre_stack_pop_int(a2);
                unsigned int v126 = tre_stack_push_voidptr(a2, v39);
                if (!v126)
                {
                  unsigned int v126 = tre_stack_push_int(a2, 3u);
                  if (!v126) {
                    v39 += 16 * v35;
                  }
                }
                break;
              case 3:
                uint64_t v38 = tre_stack_pop_voidptr(a2);
                uint64_t v37 = tre_stack_pop_voidptr(a2);
                *(_DWORD *)(v38 + 8) = *(_DWORD *)(v37 + 16);
                *(void *)uint64_t v38 = v42;
                *(_DWORD *)(v38 + 12) = *(_DWORD *)(v37 + 20);
                if (!*(void *)v37
                  || (unsigned int v126 = tre_stack_push_voidptr(a2, *(void *)v37)) == 0
                  && (unsigned int v126 = tre_stack_push_voidptr(a2, v38 + 16)) == 0
                  && (unsigned int v126 = tre_stack_push_int(a2, 3u)) == 0)
                {
                  unsigned int v126 = tre_stack_push_voidptr(a2, *(void *)(v37 + 8));
                  if (!v126)
                  {
                    unsigned int v126 = tre_stack_push_int(a2, *(_DWORD *)(v37 + 16));
                    if (!v126) {
                      unsigned int v126 = tre_stack_push_int(a2, 0);
                    }
                  }
                }
                break;
              default:
LABEL_350:
                JUMPOUT(0);
            }
          }
        }
        if (v126) {
          goto LABEL_347;
        }
        *(void *)(a4 + 48) = v43;
      }
      *(_DWORD *)(a4 + 88) = v111;
      *(_DWORD *)(a4 + 80) = v111;
      *(_DWORD *)(a4 + 84) = v110;
    }
LABEL_347:
    free(v106);
    goto LABEL_348;
  }
  return 12;
}

uint64_t tre_expand_ast(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  uint64_t v43 = a1;
  uint64_t v42 = a2;
  uint64_t v41 = a3;
  uint64_t v40 = a4;
  uint64_t v39 = a5;
  uint64_t v38 = a6;
  unsigned int v37 = 0;
  int v36 = tre_stack_num_objects(a2);
  unsigned int v35 = 0;
  unsigned int v34 = 0;
  int v33 = 0;
  int v32 = 0;
  unsigned int v31 = tre_stack_push_voidptr(v42, v41);
  if (v31)
  {
    return v31;
  }
  else
  {
    unsigned int v30 = tre_stack_push_int(v42, 0);
    if (v30)
    {
      return v30;
    }
    else
    {
      while (1)
      {
        BOOL v12 = 0;
        if (!v37)
        {
          int v6 = tre_stack_num_objects(v42);
          BOOL v12 = v6 > v36;
        }
        if (!v12) {
          break;
        }
        uint64_t v29 = 0;
        int v28 = 0;
        if (v37) {
          break;
        }
        int v28 = tre_stack_pop_int(v42);
        uint64_t v29 = tre_stack_pop_voidptr(v42);
        if (v28)
        {
          if (v28 == 1)
          {
            BOOL v23 = 0;
            BOOL v23 = *(int **)v29;
            unsigned int v22 = 0;
            unsigned int v35 = tre_stack_pop_int(v42);
            unsigned int v22 = v35;
            if (v23[2] || v23[3])
            {
              if (v23[2] > 1 || v23[3] > 1)
              {
                int v20 = 0;
                uint64_t v19 = 0;
                unsigned int v17 = v35;
                for (int i = 0; i < v23[2]; ++i)
                {
                  uint64_t v16 = 0;
                  int v15 = 0;
                  if (i + 1 < v23[2]) {
                    int v10 = 1;
                  }
                  else {
                    int v10 = 2;
                  }
                  int v15 = v10;
                  unsigned int v17 = v35;
                  unsigned int v37 = tre_copy_ast(v43, v42, *(void *)v23, v10, &v35, v39, (void **)&v16, &v33);
                  if (v37) {
                    return v37;
                  }
                  if (v20) {
                    int v20 = tre_ast_new_catenation(v43, (uint64_t)v20, (uint64_t)v16);
                  }
                  else {
                    int v20 = v16;
                  }
                  if (!v20) {
                    return 12;
                  }
                }
                if (v23[3] == -1)
                {
                  unsigned int v17 = v35;
                  unsigned int v37 = tre_copy_ast(v43, v42, *(void *)v23, 0, &v35, 0, (void **)&v19, &v33);
                  if (v37) {
                    return v37;
                  }
                  uint64_t v19 = tre_ast_new_iter(v43, (uint64_t)v19, 0, -1, 0);
                  if (!v19) {
                    return 12;
                  }
                }
                else
                {
                  for (int i = v23[2]; i < v23[3]; ++i)
                  {
                    unsigned int v14 = 0;
                    unsigned int v13 = 0;
                    unsigned int v17 = v35;
                    unsigned int v37 = tre_copy_ast(v43, v42, *(void *)v23, 0, &v35, 0, (void **)&v13, &v33);
                    if (v37) {
                      return v37;
                    }
                    if (v19) {
                      uint64_t v19 = tre_ast_new_catenation(v43, (uint64_t)v13, (uint64_t)v19);
                    }
                    else {
                      uint64_t v19 = v13;
                    }
                    if (!v19) {
                      return 12;
                    }
                    unsigned int v14 = tre_ast_new_literal(v43, -1, -1, -1);
                    if (!v14) {
                      return 12;
                    }
                    uint64_t v19 = tre_ast_new_union(v43, (uint64_t)v14, (uint64_t)v19);
                    if (!v19) {
                      return 12;
                    }
                  }
                }
                unsigned int v35 = v17;
                if (v20)
                {
                  if (v19) {
                    int v20 = tre_ast_new_catenation(v43, (uint64_t)v20, (uint64_t)v19);
                  }
                }
                else
                {
                  int v20 = v19;
                }
                if (!v20) {
                  return 12;
                }
                *(void *)uint64_t v29 = *(void *)v20;
                *(_DWORD *)(v29 + 48) = *((_DWORD *)v20 + 12);
              }
            }
            else
            {
              size_t v21 = 0;
              size_t v21 = tre_ast_new_literal(v43, -1, -1, -1);
              if (!v21) {
                return 12;
              }
              *(void *)uint64_t v29 = *(void *)v21;
              *(_DWORD *)(v29 + 48) = *((_DWORD *)v21 + 12);
            }
            --v32;
            v34 += v35 - v22;
            if (!v32) {
              unsigned int v35 = v34;
            }
          }
        }
        else
        {
          unsigned int v7 = *(_DWORD *)(v29 + 48);
          if (v7)
          {
            uint64_t v9 = v7;
            char v8 = 1;
          }
          else
          {
            uint64_t v9 = *(unsigned int *)(v29 + 48);
            char v8 = 0;
          }
          if ((v8 & 1) == 0)
          {
            switch(v9)
            {
              case 0:
                int v27 = 0;
                int v27 = *(int **)v29;
                if (*v27 >= 0 || *v27 == -4)
                {
                  v27[2] += v35;
                  if (v27[2] > v33) {
                    int v33 = v27[2];
                  }
                }
                continue;
              case 1:
                int v25 = 0;
                int v25 = *(uint64_t **)v29;
                unsigned int v37 = tre_stack_push_voidptr(v42, v25[1]);
                if (!v37)
                {
                  unsigned int v37 = tre_stack_push_int(v42, 0);
                  if (!v37)
                  {
                    unsigned int v37 = tre_stack_push_voidptr(v42, *v25);
                    if (!v37) {
                      goto LABEL_25;
                    }
                  }
                }
                continue;
              case 2:
                BOOL v24 = 0;
                BOOL v24 = *(int **)v29;
                unsigned int v37 = tre_stack_push_int(v42, v35);
                if (!v37)
                {
                  unsigned int v37 = tre_stack_push_voidptr(v42, v29);
                  if (!v37)
                  {
                    unsigned int v37 = tre_stack_push_int(v42, 1u);
                    if (!v37)
                    {
                      unsigned int v37 = tre_stack_push_voidptr(v42, *(void *)v24);
                      if (!v37)
                      {
                        unsigned int v37 = tre_stack_push_int(v42, 0);
                        if (!v37)
                        {
                          if (v24[2] > 1 || v24[3] > 1) {
                            unsigned int v35 = 0;
                          }
                          ++v32;
                        }
                      }
                    }
                  }
                }
                continue;
              case 3:
                int v26 = 0;
                int v26 = *(uint64_t **)v29;
                unsigned int v37 = tre_stack_push_voidptr(v42, v26[1]);
                if (!v37)
                {
                  unsigned int v37 = tre_stack_push_int(v42, 0);
                  if (!v37)
                  {
                    unsigned int v37 = tre_stack_push_voidptr(v42, *v26);
                    if (!v37) {
LABEL_25:
                    }
                      unsigned int v37 = tre_stack_push_int(v42, 0);
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
          }
        }
      }
      *v40 += v34;
      if (v33 > *v40) {
        *uint64_t v40 = v33;
      }
      return v37;
    }
  }
}

uint64_t tre_compute_nfl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v65 = a1;
  uint64_t v64 = a2;
  uint64_t v63 = a3;
  int v62 = tre_stack_num_objects(a2);
  unsigned int v61 = tre_stack_push_voidptr(v64, v63);
  if (v61)
  {
    return v61;
  }
  else
  {
    unsigned int v60 = tre_stack_push_int(v64, 0);
    if (!v60)
    {
      while (1)
      {
        do
        {
LABEL_5:
          int v3 = tre_stack_num_objects(v64);
          if (v3 <= v62) {
            return 0;
          }
          unsigned int v59 = 0;
          int v58 = 0;
          unsigned int v59 = tre_stack_pop_int(v64);
          int v58 = (uint64_t **)tre_stack_pop_voidptr(v64);
          if (v59)
          {
            uint64_t v5 = v59;
            char v4 = 1;
          }
          else
          {
            uint64_t v5 = 0;
            char v4 = 0;
          }
        }
        while ((v4 & 1) != 0);
        switch(v5)
        {
          case 0:
            unsigned int v6 = *((_DWORD *)v58 + 12);
            if (v6)
            {
              uint64_t v8 = v6;
              char v7 = 1;
            }
            else
            {
              uint64_t v8 = *((unsigned int *)v58 + 12);
              char v7 = 0;
            }
            if (v7) {
              goto LABEL_5;
            }
            break;
          case 1:
            uint64_t v40 = 0;
            uint64_t v40 = *v58;
            BOOL v22 = 1;
            if (!*(_WORD *)(*v40 + 64)) {
              BOOL v22 = *(_WORD *)(v40[1] + 64) != 0;
            }
            *((_WORD *)v58 + 32) = v22;
            int v15 = tre_set_union(v65, *(void *)(*v40 + 24), *(void *)(v40[1] + 24), 0, 0, 0);
            v58[3] = (uint64_t *)v15;
            if (!v58[3]) {
              return 12;
            }
            uint64_t v16 = tre_set_union(v65, *(void *)(*v40 + 32), *(void *)(v40[1] + 32), 0, 0, 0);
            v58[4] = (uint64_t *)v16;
            if (!v58[4]) {
              return 12;
            }
            goto LABEL_5;
          case 2:
            int v32 = 0;
            unsigned int v31 = 0;
            int v30 = 0;
            int v29 = 0;
            BOOL v23 = *v58;
            BOOL v21 = 0;
            if (*(_WORD *)(**v58 + 64)) {
              BOOL v21 = *(_WORD *)(v23[1] + 64) != 0;
            }
            *((_WORD *)v58 + 32) = v21;
            if (*(_WORD *)(*v23 + 64))
            {
              unsigned int matched = tre_match_empty(v64, *v23, 0, 0, 0, &v32, &v29);
              if (matched) {
                return matched;
              }
              unsigned int v31 = (void *)malloc_type_malloc();
              if (!v31) {
                return 12;
              }
              *(_DWORD *)unsigned int v31 = -1;
              int v30 = 0;
              int v27 = 0;
              if (v29)
              {
                int v27 = tre_mem_alloc_impl(v65, 0, 0, 0, 0x24uLL);
                if (!v27)
                {
LABEL_102:
                  free(v31);
                  return 12;
                }
              }
              unsigned int v25 = tre_match_empty(v64, *v23, (uint64_t)v31, &v30, (uint64_t)v27, 0, 0);
              if (v25) {
                goto LABEL_104;
              }
              char v18 = tre_set_union(v65, *(void *)(v23[1] + 24), *(void *)(*v23 + 24), (uint64_t)v31, v30, (uint64_t)v27);
              v58[3] = (uint64_t *)v18;
              free(v31);
              if (!v58[3]) {
                return 12;
              }
            }
            else
            {
              v58[3] = *(uint64_t **)(*v23 + 24);
            }
            if (*(_WORD *)(v23[1] + 64))
            {
              unsigned int v26 = tre_match_empty(v64, v23[1], 0, 0, 0, &v32, &v29);
              if (v26) {
                return v26;
              }
              unsigned int v31 = (void *)malloc_type_malloc();
              if (!v31) {
                return 12;
              }
              *(_DWORD *)unsigned int v31 = -1;
              int v30 = 0;
              int v28 = 0;
              if (v29)
              {
                int v28 = tre_mem_alloc_impl(v65, 0, 0, 0, 0x24uLL);
                if (!v28) {
                  goto LABEL_102;
                }
              }
              unsigned int v25 = tre_match_empty(v64, v23[1], (uint64_t)v31, &v30, (uint64_t)v28, 0, 0);
              if (v25)
              {
LABEL_104:
                free(v31);
                return v25;
              }
              uint64_t v19 = tre_set_union(v65, *(void *)(*v23 + 32), *(void *)(v23[1] + 32), (uint64_t)v31, v30, (uint64_t)v28);
              v58[4] = (uint64_t *)v19;
              free(v31);
              if (!v58[4]) {
                return 12;
              }
            }
            else
            {
              v58[4] = *(uint64_t **)(v23[1] + 32);
            }
            goto LABEL_5;
          case 3:
            int v39 = 0;
            uint64_t v38 = 0;
            int v37 = 0;
            int v36 = 0;
            unsigned int v35 = 0;
            unsigned int v34 = 0;
            int v33 = 0;
            int v33 = *v58;
            if (*((_DWORD *)v33 + 2) && !*(_WORD *)(*v33 + 64))
            {
              *((_WORD *)v58 + 32) = 0;
              v58[4] = *(uint64_t **)(*v33 + 32);
            }
            else
            {
              *((_WORD *)v58 + 32) = 1;
              if (*(_WORD *)(*v33 + 64))
              {
                unsigned int v34 = tre_match_empty(v64, *v33, 0, 0, 0, &v39, &v36);
                if (v34) {
                  return v34;
                }
                uint64_t v38 = (void *)malloc_type_malloc();
                if (!v38) {
                  return 12;
                }
                *(_DWORD *)uint64_t v38 = -1;
                int v37 = 0;
                unsigned int v35 = 0;
                if (v36)
                {
                  unsigned int v35 = tre_mem_alloc_impl(v65, 0, 0, 0, 0x24uLL);
                  if (!v35)
                  {
                    free(v38);
                    return 12;
                  }
                }
                unsigned int v34 = tre_match_empty(v64, *v33, (uint64_t)v38, &v37, (uint64_t)v35, 0, 0);
                if (v34)
                {
                  free(v38);
                  return v34;
                }
                unsigned int v17 = tre_set_union(v65, *(void *)(*v33 + 32), *(void *)(*v33 + 32), (uint64_t)v38, v37, (uint64_t)v35);
                v58[4] = (uint64_t *)v17;
                free(v38);
                if (!v58[4]) {
                  return 12;
                }
              }
              else
              {
                v58[4] = *(uint64_t **)(*v33 + 32);
              }
            }
            v58[3] = *(uint64_t **)(*v33 + 24);
            goto LABEL_5;
          default:
LABEL_124:
            JUMPOUT(0);
        }
        switch(v8)
        {
          case 0:
            char v57 = 0;
            char v57 = *v58;
            if (*(_DWORD *)v57 == -4)
            {
              *((_WORD *)v58 + 32) = 0;
              uint64_t v9 = tre_set_one(v65, *((_DWORD *)v57 + 2), 0, 0x7FFFFFFF, 0, -1);
              v58[3] = (uint64_t *)v9;
              if (!v58[3]) {
                return 12;
              }
              int v10 = tre_set_one(v65, *((_DWORD *)v57 + 2), 0, 0x7FFFFFFF, 0, *((_DWORD *)v57 + 1));
              v58[4] = (uint64_t *)v10;
              if (!v58[4]) {
                return 12;
              }
            }
            else if (*(int *)v57 >= 0)
            {
              *((_WORD *)v58 + 32) = 0;
              unsigned int v13 = tre_set_one(v65, *((_DWORD *)v57 + 2), *(_DWORD *)v57, *((_DWORD *)v57 + 1), 0, -1);
              v58[3] = (uint64_t *)v13;
              if (!v58[3]) {
                return 12;
              }
              unsigned int v14 = tre_set_one(v65, *((_DWORD *)v57 + 2), *(_DWORD *)v57, *((_DWORD *)v57 + 1), v57[2], -1);
              v58[4] = (uint64_t *)v14;
              if (!v58[4]) {
                return 12;
              }
            }
            else
            {
              *((_WORD *)v58 + 32) = 1;
              int v11 = tre_set_empty(v65);
              v58[3] = (uint64_t *)v11;
              if (!v58[3]) {
                return 12;
              }
              BOOL v12 = tre_set_empty(v65);
              v58[4] = (uint64_t *)v12;
              if (!v58[4]) {
                return 12;
              }
            }
            break;
          case 1:
            unsigned int v50 = 0;
            unsigned int v50 = tre_stack_push_voidptr(v64, (uint64_t)v58);
            if (v50) {
              return v50;
            }
            unsigned int v49 = 0;
            unsigned int v49 = tre_stack_push_int(v64, 2u);
            if (v49) {
              return v49;
            }
            unsigned int v48 = 0;
            unsigned int v48 = tre_stack_push_voidptr(v64, (*v58)[1]);
            if (v48) {
              return v48;
            }
            unsigned int v47 = 0;
            unsigned int v47 = tre_stack_push_int(v64, 0);
            if (v47) {
              return v47;
            }
            unsigned int v46 = 0;
            unsigned int v46 = tre_stack_push_voidptr(v64, **v58);
            if (v46) {
              return v46;
            }
            unsigned int v45 = 0;
            unsigned int v45 = tre_stack_push_int(v64, 0);
            if (v45) {
              return v45;
            }
            goto LABEL_5;
          case 2:
            unsigned int v44 = 0;
            unsigned int v44 = tre_stack_push_voidptr(v64, (uint64_t)v58);
            if (v44) {
              return v44;
            }
            unsigned int v43 = 0;
            unsigned int v43 = tre_stack_push_int(v64, 3u);
            if (v43) {
              return v43;
            }
            unsigned int v42 = 0;
            unsigned int v42 = tre_stack_push_voidptr(v64, **v58);
            if (v42) {
              return v42;
            }
            unsigned int v41 = 0;
            unsigned int v41 = tre_stack_push_int(v64, 0);
            if (v41) {
              return v41;
            }
            goto LABEL_5;
          case 3:
            unsigned int v56 = 0;
            unsigned int v56 = tre_stack_push_voidptr(v64, (uint64_t)v58);
            if (v56) {
              return v56;
            }
            unsigned int v55 = 0;
            unsigned int v55 = tre_stack_push_int(v64, 1u);
            if (v55) {
              return v55;
            }
            unsigned int v54 = 0;
            unsigned int v54 = tre_stack_push_voidptr(v64, (*v58)[1]);
            if (v54) {
              return v54;
            }
            unsigned int v53 = 0;
            unsigned int v53 = tre_stack_push_int(v64, 0);
            if (v53) {
              return v53;
            }
            unsigned int v52 = 0;
            unsigned int v52 = tre_stack_push_voidptr(v64, **v58);
            if (v52) {
              return v52;
            }
            unsigned int v51 = 0;
            unsigned int v51 = tre_stack_push_int(v64, 0);
            if (v51) {
              return v51;
            }
            goto LABEL_5;
          default:
            goto LABEL_124;
        }
      }
    }
    return v60;
  }
}

uint64_t tre_ast_to_tnfa(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v8 = 0;
  unsigned int v4 = a1[12];
  if (v4)
  {
    uint64_t v6 = v4;
    char v5 = 1;
  }
  else
  {
    uint64_t v6 = a1[12];
    char v5 = 0;
  }
  if ((v5 & 1) == 0)
  {
    switch(v6)
    {
      case 0:
        break;
      case 1:
        unsigned int v14 = *(void **)a1;
        unsigned int trans = tre_make_trans(*(int **)(**(void **)a1 + 32), *(int **)(*(void *)(*(void *)a1 + 8) + 24), a2, a3, a4);
        if (trans) {
          return trans;
        }
        unsigned int v11 = tre_ast_to_tnfa(*v14, a2, a3, a4);
        if (v11) {
          return v11;
        }
        unsigned int v8 = tre_ast_to_tnfa(v14[1], a2, a3, a4);
        break;
      case 2:
        unsigned int v13 = *(void **)a1;
        if (*(_DWORD *)(*(void *)a1 + 12) == -1)
        {
          unsigned int v12 = tre_make_trans(*(int **)(*v13 + 32), *(int **)(*v13 + 24), a2, a3, a4);
          if (v12) {
            return v12;
          }
        }
        unsigned int v8 = tre_ast_to_tnfa(*v13, a2, a3, a4);
        break;
      case 3:
        uint64_t v15 = *(void *)a1;
        unsigned int v9 = tre_ast_to_tnfa(**(void **)a1, a2, a3, a4);
        if (v9) {
          return v9;
        }
        unsigned int v8 = tre_ast_to_tnfa(*(void *)(v15 + 8), a2, a3, a4);
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v8;
}

void tre_free(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  int v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 24) = 0;
    for (unsigned int i = 0; i < *((_DWORD *)v3 + 16); ++i)
    {
      if (*(void *)(*(void *)v3 + 56 * i + 8))
      {
        if (*(void *)(*(void *)v3 + 56 * i + 24)) {
          free(*(void **)(*(void *)v3 + 56 * i + 24));
        }
        if ((*(_DWORD *)(*(void *)v3 + 56 * i + 40) & 4) != 0) {
          free(*(void **)(*(void *)v3 + 56 * i + 48));
        }
        if (*(void *)(*(void *)v3 + 56 * i + 32)) {
          free(*(void **)(*(void *)v3 + 56 * i + 32));
        }
      }
    }
    if (*(void *)v3) {
      free(*(void **)v3);
    }
    if (*((void *)v3 + 1))
    {
      for (uint64_t j = *((void *)v3 + 1); *(void *)(j + 8); j += 56)
      {
        if (*(void *)(j + 24)) {
          free(*(void **)(j + 24));
        }
        if (*(void *)(j + 32)) {
          free(*(void **)(j + 32));
        }
      }
      free(*((void **)v3 + 1));
    }
    if (*((void *)v3 + 3)) {
      free(*((void **)v3 + 3));
    }
    if (*((void *)v3 + 4)) {
      free(*((void **)v3 + 4));
    }
    if (*((void *)v3 + 5)) {
      free(*((void **)v3 + 5));
    }
    if (*((void *)v3 + 7)) {
      xlocale_release(*((void *)v3 + 7));
    }
    if (*((void *)v3 + 6)) {
      free(*((void **)v3 + 6));
    }
    free(v3);
  }
}

uint64_t tre_merge_branches(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  unsigned int v14 = *(char **)(a2 + 8);
  if (a3) {
    uint64_t v9 = *(void *)(a3 + 8);
  }
  else {
    uint64_t v9 = 0;
  }
  if (v14)
  {
    if (v9)
    {
      unsigned int v13 = v14 + 40;
      unsigned int v12 = (unsigned char *)(v9 + 40);
      int v11 = (a5 + 7) >> 3;
      while (1)
      {
        int v5 = v11--;
        if (v5 <= 0) {
          break;
        }
        uint64_t v6 = v12++;
        char v7 = v13++;
        *v7 |= *v6;
      }
      *((_DWORD *)v14 + 6) += *(_DWORD *)(v9 + 24);
      *((_DWORD *)v14 + 9) += *(_DWORD *)(v9 + 36);
      if (*((void *)v14 + 1))
      {
        if (*(void *)(v9 + 8))
        {
          for (unsigned int i = (void *)*((void *)v14 + 1); *i; unsigned int i = (void *)*i)
            ;
          *unsigned int i = *(void *)(v9 + 8);
          *((_DWORD *)v14 + 4) += *(_DWORD *)(v9 + 16);
          *((_DWORD *)v14 + 7) += *(_DWORD *)(v9 + 28);
          *((_DWORD *)v14 + 8) += *(_DWORD *)(v9 + 32);
        }
      }
      else if (*(void *)(v9 + 8))
      {
        *((void *)v14 + 1) = *(void *)(v9 + 8);
        *((_DWORD *)v14 + 4) = *(_DWORD *)(v9 + 16);
        *((_DWORD *)v14 + 7) = *(_DWORD *)(v9 + 28);
        *((_DWORD *)v14 + 8) = *(_DWORD *)(v9 + 32);
      }
    }
  }
  else
  {
    unsigned int v14 = (char *)v9;
  }
  if (!a4) {
    goto LABEL_27;
  }
  if (v14)
  {
LABEL_25:
    if (a4 > 0)
    {
      v14[(a4 >> 3) + 40] |= 1 << (a4 & 7);
      ++*((_DWORD *)v14 + 6);
      ++*((_DWORD *)v14 + 9);
    }
LABEL_27:
    *(void *)(a2 + 8) = v14;
    return 0;
  }
  unsigned int v14 = tre_mem_alloc_impl(a1, 0, 0, 1, ((a5 + 7) >> 3) + 40);
  if (v14)
  {
    *((_DWORD *)v14 + 7) = 1;
    goto LABEL_25;
  }
  return 12;
}

uint64_t tre_add_tag_right(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4 = tre_mem_alloc_impl(a1, 0, 0, 0, 0x10uLL);
  if (v4)
  {
    *((void *)v4 + 1) = tre_ast_new_literal(a1, -3, a3, -1);
    if (*((void *)v4 + 1))
    {
      *(void *)unsigned int v4 = tre_mem_alloc_impl(a1, 0, 0, 1, 0x48uLL);
      if (*(void *)v4)
      {
        **(void **)unsigned int v4 = *(void *)a2;
        *(_DWORD *)(*(void *)v4 + 48) = *(_DWORD *)(a2 + 48);
        *(void *)(*(void *)v4 + 8) = *(void *)(a2 + 8);
        *(_WORD *)(*(void *)v4 + 64) = -1;
        *(_DWORD *)(*(void *)v4 + 52) = -1;
        *(void *)a2 = v4;
        *(_DWORD *)(a2 + 48) = 1;
        *(void *)(a2 + 40) = *(void *)v4;
        return 0;
      }
      else
      {
        return 12;
      }
    }
    else
    {
      return 12;
    }
  }
  else
  {
    return 12;
  }
}

_DWORD *tre_purge_regset(_DWORD *result, uint64_t a2, int a3)
{
  for (int i = 0; result[i] != -1; ++i)
  {
    signed int v3 = result[i] / 2u;
    if (v3 < 0x40000000)
    {
      if (result[i] % 2u) {
        *(_DWORD *)(*(void *)(a2 + 24) + 8 * v3 + 4) = a3;
      }
      else {
        *(_DWORD *)(*(void *)(a2 + 24) + 8 * v3) = a3;
      }
    }
  }
  unsigned char *result = -1;
  return result;
}

uint64_t tre_add_tag_left(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4 = tre_mem_alloc_impl(a1, 0, 0, 0, 0x10uLL);
  if (v4)
  {
    *(void *)unsigned int v4 = tre_ast_new_literal(a1, -3, a3, -1);
    if (*(void *)v4)
    {
      *((void *)v4 + 1) = tre_mem_alloc_impl(a1, 0, 0, 1, 0x48uLL);
      if (*((void *)v4 + 1))
      {
        **((void **)v4 + 1) = *(void *)a2;
        *(_DWORD *)(*((void *)v4 + 1) + 48) = *(_DWORD *)(a2 + 48);
        *(void *)(*((void *)v4 + 1) + 8) = *(void *)(a2 + 8);
        *(_WORD *)(*((void *)v4 + 1) + 64) = -1;
        *(_DWORD *)(*((void *)v4 + 1) + 52) = -1;
        *(void *)a2 = v4;
        *(_DWORD *)(a2 + 48) = 1;
        *(void *)(a2 + 40) = *((void *)v4 + 1);
        return 0;
      }
      else
      {
        return 12;
      }
    }
    else
    {
      return 12;
    }
  }
  else
  {
    return 12;
  }
}

uint64_t tre_copy_ast(uint64_t a1, uint64_t a2, uint64_t a3, char a4, _DWORD *a5, uint64_t a6, void **a7, int *a8)
{
  int v29 = tre_stack_num_objects(a2);
  int v28 = 0;
  int v27 = 1;
  unsigned int v26 = a7;
  tre_stack_push_voidptr(a2, a3);
  unsigned int v30 = tre_stack_push_int(a2, 0);
  while (1)
  {
    BOOL v15 = 0;
    if (!v30) {
      BOOL v15 = (int)tre_stack_num_objects(a2) > v29;
    }
    if (!v15 || v30) {
      break;
    }
    int v14 = tre_stack_pop_int(a2);
    if (v14)
    {
      if (v14 == 1) {
        unsigned int v26 = (void **)tre_stack_pop_voidptr(a2);
      }
    }
    else
    {
      unsigned int v25 = (uint64_t **)tre_stack_pop_voidptr(a2);
      unsigned int v8 = *((_DWORD *)v25 + 12);
      if (v8)
      {
        uint64_t v10 = v8;
        char v9 = 1;
      }
      else
      {
        uint64_t v10 = *((unsigned int *)v25 + 12);
        char v9 = 0;
      }
      if ((v9 & 1) == 0)
      {
        switch(v10)
        {
          case 0:
            BOOL v24 = *v25;
            int v23 = *((_DWORD *)*v25 + 2);
            int v22 = *(_DWORD *)*v25;
            int v21 = *((_DWORD *)*v25 + 1);
            if (v22 < 0) {
              uint64_t v13 = 0;
            }
            else {
              uint64_t v13 = v24[2];
            }
            if (*(int *)v24 >= 0 || *(_DWORD *)v24 == -4)
            {
              v23 += *a5;
              ++v28;
              int v11 = tre_ast_new_literal(a1, v22, v21, v23);
            }
            else if (*(_DWORD *)v24 == -3 && (a4 & 1) != 0)
            {
              int v23 = -1;
              int v11 = tre_ast_new_literal(a1, -1, -1, -1);
            }
            else
            {
              if (*(_DWORD *)v24 == -3 && (a4 & 2) != 0 && v27)
              {
                if (*(_DWORD *)(a6 + 4 * v21) == 2) {
                  *(_DWORD *)(a6 + 4 * v21) = 1;
                }
                int v27 = 0;
              }
              int v11 = tre_ast_new_literal(a1, v22, v21, v23);
            }
            *unsigned int v26 = v11;
            if (!*v26) {
              unsigned int v30 = 12;
            }
            if (v23 > *a8) {
              *a8 = v23;
            }
            if (*(int *)v24 >= 0) {
              *(void *)(**v26 + 16) = v13;
            }
            continue;
          case 1:
            char v18 = *v25;
            *unsigned int v26 = tre_ast_new_catenation(a1, **v25, (*v25)[1]);
            if (!*v26)
            {
              unsigned int v30 = 12;
              continue;
            }
            unsigned int v17 = (void *)**v26;
            *unsigned int v17 = 0;
            v17[1] = 0;
            unsigned int v26 = (void **)v17;
            unsigned int v30 = tre_stack_push_voidptr(a2, v18[1]);
            if (!v30)
            {
              unsigned int v30 = tre_stack_push_int(a2, 0);
              if (!v30)
              {
                unsigned int v30 = tre_stack_push_voidptr(a2, (uint64_t)(v17 + 1));
                if (!v30)
                {
                  unsigned int v30 = tre_stack_push_int(a2, 1u);
                  if (!v30)
                  {
                    unsigned int v30 = tre_stack_push_voidptr(a2, *v18);
                    if (!v30) {
                      goto LABEL_44;
                    }
                  }
                }
              }
            }
            continue;
          case 2:
            uint64_t v16 = *v25;
            unsigned int v30 = tre_stack_push_voidptr(a2, **v25);
            if (!v30)
            {
              unsigned int v30 = tre_stack_push_int(a2, 0);
              if (!v30)
              {
                *unsigned int v26 = tre_ast_new_iter(a1, *v16, *((_DWORD *)v16 + 2), *((_DWORD *)v16 + 3), v16[2] & 1);
                if (*v26) {
                  unsigned int v26 = (void **)**v26;
                }
                else {
                  unsigned int v30 = 12;
                }
              }
            }
            continue;
          case 3:
            int v20 = *v25;
            *unsigned int v26 = tre_ast_new_union(a1, **v25, (*v25)[1]);
            if (*v26)
            {
              uint64_t v19 = (void **)**v26;
              unsigned int v26 = v19;
              unsigned int v30 = tre_stack_push_voidptr(a2, v20[1]);
              if (!v30)
              {
                unsigned int v30 = tre_stack_push_int(a2, 0);
                if (!v30)
                {
                  unsigned int v30 = tre_stack_push_voidptr(a2, (uint64_t)(v19 + 1));
                  if (!v30)
                  {
                    unsigned int v30 = tre_stack_push_int(a2, 1u);
                    if (!v30)
                    {
                      unsigned int v30 = tre_stack_push_voidptr(a2, *v20);
                      if (!v30) {
LABEL_44:
                      }
                        unsigned int v30 = tre_stack_push_int(a2, 0);
                    }
                  }
                }
              }
            }
            else
            {
              unsigned int v30 = 12;
            }
            break;
          default:
            JUMPOUT(0);
        }
      }
    }
  }
  *a5 += v28;
  return v30;
}

char *tre_set_one(uint64_t a1, int a2, int a3, int a4, uint64_t a5, int a6)
{
  char v7 = tre_mem_alloc_impl(a1, 0, 0, 1, 0x80uLL);
  if (!v7) {
    return 0;
  }
  *(_DWORD *)char v7 = a2;
  *((_DWORD *)v7 + 1) = a3;
  *((_DWORD *)v7 + 2) = a4;
  *((void *)v7 + 4) = a5;
  *((_DWORD *)v7 + 10) = a6;
  *((_DWORD *)v7 + 16) = -1;
  *((_DWORD *)v7 + 17) = -1;
  *((_DWORD *)v7 + 18) = -1;
  return v7;
}

char *tre_set_empty(uint64_t a1)
{
  unsigned int v2 = tre_mem_alloc_impl(a1, 0, 0, 1, 0x40uLL);
  if (!v2) {
    return 0;
  }
  *(_DWORD *)unsigned int v2 = -1;
  *((_DWORD *)v2 + 1) = -1;
  *((_DWORD *)v2 + 2) = -1;
  return v2;
}

char *tre_set_union(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  for (int i = 0; ; ++i)
  {
    BOOL v8 = 0;
    if (a4) {
      BOOL v8 = *(_DWORD *)(a4 + 4 * i) >= 0;
    }
    if (!v8) {
      break;
    }
  }
  for (int j = 0; *(int *)(a2 + ((uint64_t)j << 6)) >= 0; ++j)
    ;
  for (int k = 0; *(int *)(a3 + ((uint64_t)k << 6)) >= 0; ++k)
    ;
  unsigned int v12 = tre_mem_alloc_impl(a1, 0, 0, 1, (uint64_t)(j + k + 1) << 6);
  if (!v12) {
    return 0;
  }
  for (int m = 0; *(int *)(a2 + ((uint64_t)m << 6)) >= 0; ++m)
  {
    *(_DWORD *)&v12[64 * (uint64_t)m] = *(_DWORD *)(a2 + ((uint64_t)m << 6));
    *(_DWORD *)&v12[64 * (uint64_t)m + 4] = *(_DWORD *)(a2 + ((uint64_t)m << 6) + 4);
    *(_DWORD *)&v12[64 * (uint64_t)m + 8] = *(_DWORD *)(a2 + ((uint64_t)m << 6) + 8);
    *(_DWORD *)&v12[64 * (uint64_t)m + 24] = *(_DWORD *)(a2 + ((uint64_t)m << 6) + 24) | a5;
    *(void *)&v12[64 * (uint64_t)m + 32] = *(void *)(a2 + ((uint64_t)m << 6) + 32);
    *(_DWORD *)&v12[64 * (uint64_t)m + 40] = *(_DWORD *)(a2 + ((uint64_t)m << 6) + 40);
    if (*(void *)(a2 + ((uint64_t)m << 6) + 16) || a4)
    {
      for (int n = 0; ; ++n)
      {
        BOOL v7 = 0;
        if (*(void *)(a2 + ((uint64_t)m << 6) + 16)) {
          BOOL v7 = *(_DWORD *)(*(void *)(a2 + ((uint64_t)m << 6) + 16) + 4 * n) >= 0;
        }
        if (!v7) {
          break;
        }
      }
      uint64_t v10 = tre_mem_alloc_impl(a1, 0, 0, 0, 4 * (n + i + 1));
      if (!v10) {
        return 0;
      }
      for (iint i = 0; ii < n; ++ii)
        *(_DWORD *)&v10[4 * ii] = *(_DWORD *)(*(void *)(a2 + ((uint64_t)m << 6) + 16) + 4 * ii);
      for (jint j = 0; jj < i; ++jj)
        *(_DWORD *)&v10[4 * ii + 4 * jj] = *(_DWORD *)(a4 + 4 * jj);
      *(_DWORD *)&v10[4 * ii + 4 * jj] = -1;
      *(void *)&v12[64 * (uint64_t)m + 16] = v10;
    }
    else
    {
      *(void *)&v12[64 * (uint64_t)m + 16] = 0;
    }
    if (*(void *)(a2 + ((uint64_t)m << 6) + 48)) {
      *(void *)&v12[64 * (uint64_t)m + 48] = *(void *)(a2 + ((uint64_t)m << 6) + 48);
    }
    if (a6)
    {
      if (*(void *)&v12[64 * (uint64_t)m + 48])
      {
        *(void *)&v12[64 * (uint64_t)m + 48] = tre_mem_alloc_impl(a1, 0, 0, 0, 0x24uLL);
        if (!*(void *)&v12[64 * (uint64_t)m + 48]) {
          return 0;
        }
        for (kint k = 0; kk < 9; ++kk)
        {
          if (*(_DWORD *)(a6 + 4 * kk) != -1) {
            *(_DWORD *)(*(void *)&v12[64 * (uint64_t)m + 48] + 4 * kk) = *(_DWORD *)(a6 + 4 * kk);
          }
        }
      }
      else
      {
        *(void *)&v12[64 * (uint64_t)m + 48] = a6;
      }
    }
  }
  for (mint m = 0; *(int *)(a3 + ((uint64_t)mm << 6)) >= 0; ++mm)
  {
    *(_DWORD *)&v12[64 * (uint64_t)(m + mm)] = *(_DWORD *)(a3 + ((uint64_t)mm << 6));
    *(_DWORD *)&v12[64 * (uint64_t)(m + mm) + 4] = *(_DWORD *)(a3 + ((uint64_t)mm << 6) + 4);
    *(_DWORD *)&v12[64 * (uint64_t)(m + mm) + 8] = *(_DWORD *)(a3 + ((uint64_t)mm << 6) + 8);
    *(_DWORD *)&v12[64 * (uint64_t)(m + mm) + 24] = *(_DWORD *)(a3 + ((uint64_t)mm << 6) + 24);
    *(void *)&v12[64 * (uint64_t)(m + mm) + 32] = *(void *)(a3 + ((uint64_t)mm << 6) + 32);
    *(_DWORD *)&v12[64 * (uint64_t)(m + mm) + 40] = *(_DWORD *)(a3 + ((uint64_t)mm << 6) + 40);
    if (*(void *)(a3 + ((uint64_t)mm << 6) + 16))
    {
      for (nint n = 0; *(int *)(*(void *)(a3 + ((uint64_t)mm << 6) + 16) + 4 * nn) >= 0; ++nn)
        ;
      int v11 = tre_mem_alloc_impl(a1, 0, 0, 0, 4 * (nn + 1));
      if (!v11) {
        return 0;
      }
      for (int i1 = 0; i1 < nn; ++i1)
        *(_DWORD *)&v11[4 * i1] = *(_DWORD *)(*(void *)(a3 + ((uint64_t)mm << 6) + 16) + 4 * i1);
      *(_DWORD *)&v11[4 * i1] = -1;
      *(void *)&v12[64 * (uint64_t)(m + mm) + 16] = v11;
    }
    else
    {
      *(void *)&v12[64 * (uint64_t)(m + mm) + 16] = 0;
    }
    if (*(void *)(a3 + ((uint64_t)mm << 6) + 48)) {
      *(void *)&v12[64 * (uint64_t)(m + mm) + 48] = *(void *)(a3 + ((uint64_t)mm << 6) + 48);
    }
    if (a6)
    {
      if (*(void *)&v12[64 * (uint64_t)(m + mm) + 48])
      {
        *(void *)&v12[64 * (uint64_t)(m + mm) + 48] = tre_mem_alloc_impl(a1, 0, 0, 0, 0x24uLL);
        if (!*(void *)&v12[64 * (uint64_t)(m + mm) + 48]) {
          return 0;
        }
        for (int i2 = 0; i2 < 9; ++i2)
        {
          if (*(_DWORD *)(a6 + 4 * i2) != -1) {
            *(_DWORD *)(*(void *)&v12[64 * (uint64_t)(m + mm) + 48] + 4 * i2) = *(_DWORD *)(a6 + 4 * i2);
          }
        }
      }
      else
      {
        *(void *)&v12[64 * (uint64_t)(m + mm) + 48] = a6;
      }
    }
  }
  *(_DWORD *)&v12[64 * (uint64_t)(m + mm)] = -1;
  return v12;
}

uint64_t tre_match_empty(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, _DWORD *a6, _DWORD *a7)
{
  int v16 = tre_stack_num_objects(a1);
  if (a6) {
    *a6 = 0;
  }
  if (a7) {
    *a7 = 0;
  }
  unsigned int v15 = tre_stack_push_voidptr(a1, a2);
  while (1)
  {
    BOOL v14 = 0;
    if (!v15) {
      BOOL v14 = (int)tre_stack_num_objects(a1) > v16;
    }
    if (!v14) {
      return v15;
    }
    uint64_t v28 = tre_stack_pop_voidptr(a1);
    unsigned int v7 = *(_DWORD *)(v28 + 48);
    BOOL v8 = v7 == 0;
    if (v7)
    {
      uint64_t v10 = v7;
      char v9 = 1;
    }
    else
    {
      uint64_t v10 = 0;
      char v9 = 0;
    }
    if ((v9 & 1) == 0)
    {
      switch(v10)
      {
        case 0:
          int v21 = *(uint64_t **)v28;
          if (v8)
          {
            uint64_t v12 = (**(_DWORD **)v28 + 5);
            char v11 = 0;
          }
          else
          {
            uint64_t v12 = (**(_DWORD **)v28 + 5);
            char v11 = 1;
          }
          if ((v11 & 1) == 0)
          {
            switch(v12)
            {
              case 0:
                if (a5)
                {
                  for (int i = 0; i < 9; ++i)
                    *(_DWORD *)(a5 + 4 * i) = *(_DWORD *)(v21[2] + 4 * i);
                }
                if (a7) {
                  *a7 = 1;
                }
                continue;
              case 1:
              case 4:
                continue;
              case 2:
                if (*((int *)v21 + 1) >= 0)
                {
                  if (a3)
                  {
                    for (int j = 0; *(int *)(a3 + 4 * j) >= 0 && *(_DWORD *)(a3 + 4 * j) != *((_DWORD *)v21 + 1); ++j)
                      ;
                    if (*(int *)(a3 + 4 * j) < 0)
                    {
                      *(_DWORD *)(a3 + 4 * j) = *((_DWORD *)v21 + 1);
                      *(_DWORD *)(a3 + 4 * (j + 1)) = -1;
                    }
                  }
                  if (a6) {
                    ++*a6;
                  }
                }
                continue;
              case 3:
                if (a4) {
                  *a4 |= *((_DWORD *)v21 + 1);
                }
                continue;
              default:
                goto LABEL_53;
            }
          }
          break;
        case 1:
          uint64_t v19 = *(uint64_t **)v28;
          unsigned int v15 = tre_stack_push_voidptr(a1, **(void **)v28);
          if (!v15) {
            unsigned int v15 = tre_stack_push_voidptr(a1, v19[1]);
          }
          break;
        case 2:
          if (*(_WORD *)(**(void **)v28 + 64)) {
            unsigned int v15 = tre_stack_push_voidptr(a1, **(void **)v28);
          }
          break;
        case 3:
          int v20 = *(uint64_t **)v28;
          if (*(_WORD *)(**(void **)v28 + 64))
          {
            unsigned int v15 = tre_stack_push_voidptr(a1, *v20);
          }
          else if (*(_WORD *)(v20[1] + 64))
          {
            unsigned int v15 = tre_stack_push_voidptr(a1, v20[1]);
          }
          break;
        default:
LABEL_53:
          JUMPOUT(0);
      }
    }
  }
}

uint64_t tre_make_trans(int *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a3)
  {
    while (*a1 >= 0)
    {
      int v21 = a2;
      int v8 = -1;
      while (*v21 >= 0)
      {
        if (*v21 == v8)
        {
          v21 += 16;
        }
        else
        {
          int v8 = *v21;
          for (uint64_t i = a3 + 56 * *(int *)(a5 + 4 * *a1); *(void *)(i + 8); i += 56)
            ;
          *(void *)(i + 64) = 0;
          *(_DWORD *)uint64_t i = a1[1];
          *(_DWORD *)(i + 4) = a1[2];
          *(void *)(i + 8) = a3 + 56 * *(int *)(a5 + 4 * *v21);
          *(_DWORD *)(i + 16) = *v21;
          if (*((void *)a1 + 4)) {
            int v5 = 4;
          }
          else {
            int v5 = 0;
          }
          *(_DWORD *)(i + 40) = a1[6] | v21[6] | v5;
          if (a1[10] >= 0)
          {
            *(_DWORD *)(i + 48) = a1[10];
            *(_DWORD *)(i + 40) |= 0x80u;
          }
          if (*((void *)a1 + 4))
          {
            *(void *)(i + 48) = malloc_type_malloc();
            if (!*(void *)(i + 48)) {
              return 12;
            }
            memcpy(*(void **)(i + 48), *((const void **)a1 + 4), 8 * **((int **)a1 + 4) + 8);
          }
          int v14 = 0;
          if (*((void *)a1 + 2))
          {
            while (*(int *)(*((void *)a1 + 2) + 4 * v14) >= 0)
              ++v14;
          }
          int v12 = 0;
          if (*((void *)v21 + 2))
          {
            while (*(int *)(*((void *)v21 + 2) + 4 * v12) >= 0)
              ++v12;
          }
          if (*(void *)(i + 24)) {
            free(*(void **)(i + 24));
          }
          *(void *)(i + 24) = 0;
          if (v14 + v12 > 0)
          {
            *(void *)(i + 24) = malloc_type_malloc();
            if (!*(void *)(i + 24)) {
              return 12;
            }
            int v15 = 0;
            if (*((void *)a1 + 2))
            {
              while (*(int *)(*((void *)a1 + 2) + 4 * v15) >= 0)
              {
                *(_DWORD *)(*(void *)(i + 24) + 4 * v15) = *(_DWORD *)(*((void *)a1 + 2) + 4 * v15);
                ++v15;
              }
            }
            int v10 = v15;
            int v13 = 0;
            if (*((void *)v21 + 2))
            {
              while (*(int *)(*((void *)v21 + 2) + 4 * v13) >= 0)
              {
                int v9 = 0;
                for (int j = 0; j < v15; ++j)
                {
                  if (*(_DWORD *)(*(void *)(i + 24) + 4 * j) == *(_DWORD *)(*((void *)v21 + 2) + 4 * v13))
                  {
                    int v9 = 1;
                    break;
                  }
                }
                if (!v9)
                {
                  uint64_t v6 = v10++;
                  *(_DWORD *)(*(void *)(i + 24) + 4 * v6) = *(_DWORD *)(*((void *)v21 + 2) + 4 * v13);
                }
                ++v13;
              }
            }
            *(_DWORD *)(*(void *)(i + 24) + 4 * v10) = -1;
          }
          if (*((void *)a1 + 6) || *((void *)v21 + 6))
          {
            if (!*(void *)(i + 32)) {
              *(void *)(i + 32) = malloc_type_malloc();
            }
            if (!*(void *)(i + 32)) {
              return 12;
            }
            for (int k = 0; k < 9; ++k)
            {
              *(_DWORD *)(*(void *)(i + 32) + 4 * k) = -1;
              if (*((void *)a1 + 6) && *(_DWORD *)(*((void *)a1 + 6) + 4 * k) != -1) {
                *(_DWORD *)(*(void *)(i + 32) + 4 * k) = *(_DWORD *)(*((void *)a1 + 6) + 4 * k);
              }
              if (*((void *)v21 + 6) && *(_DWORD *)(*((void *)v21 + 6) + 4 * k) != -1) {
                *(_DWORD *)(*(void *)(i + 32) + 4 * k) = *(_DWORD *)(*((void *)v21 + 6) + 4 * k);
              }
            }
          }
          else
          {
            if (*(void *)(i + 32)) {
              free(*(void **)(i + 32));
            }
            *(void *)(i + 32) = 0;
          }
          v21 += 16;
        }
      }
      a1 += 16;
    }
  }
  else
  {
    while (*a1 >= 0)
    {
      for (int m = a2; *m >= 0; m += 16)
        ++*(_DWORD *)(a4 + 4 * *a1);
      a1 += 16;
    }
  }
  return 0;
}

uint64_t tre_tnfa_run_backtrack(uint64_t a1, char *a2, int a3, int a4, void *a5, int a6, int *a7)
{
  uint64_t v89 = a1;
  uint64_t v88 = a2;
  int v87 = a3;
  int v86 = a4;
  uint64_t v85 = a5;
  int v84 = a6;
  uint64_t v83 = a7;
  wint_t v82 = 0;
  wint_t v81 = 0;
  uint64_t v80 = a2;
  int v78 = 1;
  int v77 = (wint_t *)a2;
  memset(&__b, 0, sizeof(__b));
  int v76 = v84 & 1;
  int v75 = v84 & 2;
  int v74 = *(_DWORD *)(v89 + 96) & 8;
  int v68 = -1;
  memset(__dst, 0, sizeof(__dst));
  int v66 = -1;
  int v62 = (void **)tre_mem_new_impl(0, 0);
  int v56 = *(_DWORD *)(v89 + 80);
  int v55 = 1;
  unsigned int v54 = 0;
  memset(&__b, 0, sizeof(__b));
  if (!v62) {
    return 12;
  }
  unsigned int v61 = tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 0xC0uLL);
  if (!v61)
  {
    unsigned int v57 = 12;
    goto LABEL_302;
  }
  *((void *)v61 + 22) = 0;
  *((void *)v61 + 23) = 0;
  int v53 = 16 * *(_DWORD *)(v89 + 72);
  unsigned int v54 = (char *)malloc_type_malloc();
  if (!v54) {
    return 12;
  }
  unint64_t v51 = (unint64_t)&v54[16 * v56];
  if (v51 % 8) {
    unint64_t v32 = 8 - v51 % 8;
  }
  else {
    unint64_t v32 = 0;
  }
  int v58 = (char *)(v51 + v32);
  unint64_t v52 = v51 + v32 + v53;
  if (v52 % 8) {
    unint64_t v31 = 8 - v52 % 8;
  }
  else {
    unint64_t v31 = 0;
  }
  uint64_t v63 = (_DWORD *)(v52 + v31);
  while (1)
  {
    bzero(v54, 16 * v56);
    if (v85) {
      bzero(v85, 16 * v56);
    }
    for (int i = 0; i < *(_DWORD *)(v89 + 92); ++i)
      v63[i] = 0;
    uint64_t v64 = 0;
    int v79 = v68;
    wint_t v82 = v81;
    if (v86)
    {
      if (v86 == 1)
      {
        int v79 = v68 + 1;
        if (v87 < 0 || v79 < v87)
        {
          unsigned int v7 = v80++;
          wint_t v81 = *v7;
        }
        else
        {
          wint_t v81 = 0;
        }
      }
      else if (v86 == 2)
      {
        int v79 = v68 + v78;
        BOOL v30 = 0;
        if (v87 >= 0) {
          BOOL v30 = v79 >= v87;
        }
        if (v30)
        {
          wint_t v81 = 0;
          int v78 = 1;
        }
        else if (*v80 < 0)
        {
          if (v87 < 0) {
            int v49 = 32;
          }
          else {
            int v49 = v87 - v79;
          }
          size_t v50 = mbrtowc_l(&v81, v80, v49, &__b, *(locale_t *)(v89 + 56));
          if (v50 >= 0xFFFFFFFFFFFFFFFELL) {
            return 17;
          }
          if (v50 || v87 < 0)
          {
            int v78 = v50;
            v80 += v50;
          }
          else
          {
            int v78 = 1;
            wint_t v81 = 0;
            ++v80;
          }
        }
        else
        {
          int v9 = v80++;
          wint_t v81 = *v9;
          int v78 = 1;
        }
      }
    }
    else
    {
      int v79 = v68 + 1;
      if (v87 < 0 || v79 < v87)
      {
        int v8 = v77++;
        wint_t v81 = *v8;
      }
      else
      {
        wint_t v81 = 0;
      }
    }
    int v68 = v79;
    wint_t v70 = v81;
    int v69 = v80;
    int v67 = v77;
    memcpy(__dst, &__b, sizeof(__dst));
    uint64_t v65 = 0;
    for (uint64_t j = *(void *)(v89 + 8); *(void *)(j + 8); j += 56)
    {
      if (!*(_DWORD *)(j + 40)) {
        goto LABEL_86;
      }
      if (((*(_DWORD *)(j + 40) & 1) == 0 || v79 <= 0 && !v76 || v82 == 10 && v74)
        && ((*(_DWORD *)(j + 40) & 2) == 0 || !v81 && !v75 || v81 == 10 && v74)
        && ((*(_DWORD *)(j + 40) & 8) == 0
         || v82 != 95
         && !iswalnum_l(v82, *(locale_t *)(v89 + 56))
         && (v81 == 95 || iswalnum_l(v81, *(locale_t *)(v89 + 56))))
        && ((*(_DWORD *)(j + 40) & 0x10) == 0
         || (v82 == 95 || iswalnum_l(v82, *(locale_t *)(v89 + 56)))
         && v81 != 95
         && !iswalnum_l(v81, *(locale_t *)(v89 + 56))))
      {
        if ((*(_DWORD *)(j + 40) & 0x20) == 0 || !v79 || !v81) {
          goto LABEL_77;
        }
        BOOL v29 = 1;
        if (v82 != 95) {
          BOOL v29 = iswalnum_l(v82, *(locale_t *)(v89 + 56)) != 0;
        }
        BOOL v28 = 1;
        if (v81 != 95) {
          BOOL v28 = iswalnum_l(v81, *(locale_t *)(v89 + 56)) != 0;
        }
        if (v29 != v28)
        {
LABEL_77:
          if ((*(_DWORD *)(j + 40) & 0x40) == 0) {
            goto LABEL_86;
          }
          if (v79 && v81)
          {
            BOOL v27 = 1;
            if (v82 != 95) {
              BOOL v27 = iswalnum_l(v82, *(locale_t *)(v89 + 56)) != 0;
            }
            BOOL v26 = 1;
            if (v81 != 95) {
              BOOL v26 = iswalnum_l(v81, *(locale_t *)(v89 + 56)) != 0;
            }
            if (v27 == v26)
            {
LABEL_86:
              if (v64)
              {
                if (*((void *)v61 + 23))
                {
                  unsigned int v61 = (char *)*((void *)v61 + 23);
                }
                else
                {
                  unsigned int v48 = tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 0xC0uLL);
                  if (!v48)
                  {
                    tre_mem_destroy(v62);
                    free(v54);
                    if (v58) {
                      free(v58);
                    }
                    if (v63) {
                      free(v63);
                    }
                    return 12;
                  }
                  *((void *)v48 + 22) = v61;
                  *((void *)v48 + 23) = 0;
                  *((void *)v48 + 5) = tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 16 * v56);
                  if (!*((void *)v48 + 5))
                  {
                    tre_mem_destroy(v62);
                    free(v54);
                    if (v58) {
                      free(v58);
                    }
                    if (v63) {
                      free(v63);
                    }
                    return 12;
                  }
                  *((void *)v61 + 23) = v48;
                  unsigned int v61 = v48;
                }
                *(_DWORD *)unsigned int v61 = v79;
                *((_DWORD *)v61 + 1) = v78;
                *((void *)v61 + 1) = v80;
                *((void *)v61 + 2) = v77;
                *((void *)v61 + 3) = *(void *)(j + 8);
                *((_DWORD *)v61 + 8) = *(_DWORD *)(j + 16);
                *((_DWORD *)v61 + 9) = v81;
                memcpy(*((void **)v61 + 5), v54, 16 * v56);
                memcpy(v61 + 48, &__b, 0x80uLL);
                unsigned int v47 = *(int **)(j + 24);
                if (v47)
                {
                  while (*v47 >= 0)
                  {
                    int v10 = v47++;
                    tre_tag_set(*((void *)v61 + 5), *v10, v79, v55);
                  }
                  ++v55;
                }
              }
              else
              {
                uint64_t v64 = *(void *)(j + 8);
                uint64_t v65 = *(int **)(j + 24);
              }
            }
          }
        }
      }
    }
    if (v65)
    {
      while (*v65 >= 0)
        tre_tag_set((uint64_t)v54, *v65++, v79, v55);
      ++v55;
    }
    if (!v64) {
      goto LABEL_290;
    }
    while (1)
    {
      while (1)
      {
        if (v66 >= 0 && *(_DWORD *)(v89 + 84))
        {
          int v44 = 0;
          for (int k = 0; *(int *)(*(void *)(v89 + 40) + 4 * k) >= 0; k += 2)
          {
            if ((int)tre_minimal_tag_order(*(_DWORD *)(*(void *)(v89 + 40) + 4 * (k + 1)), *(_DWORD *)(*(void *)(v89 + 40) + 4 * k), (uint64_t)v85, (uint64_t)v54) > 0)
            {
              int v44 = 1;
              break;
            }
          }
          if (v44) {
            goto LABEL_290;
          }
        }
        if (v64 == *(void *)(v89 + 16)) {
          break;
        }
        int v45 = 0;
        if (*(void *)(v64 + 8) && (*(_DWORD *)(v64 + 40) & 0x80) != 0)
        {
          int __n_4 = *(_DWORD *)(v64 + 48);
          unsigned int v57 = tre_fill_pmatch(__n_4 + 1, (uint64_t)v58, *(_DWORD *)(v89 + 96) & 0xFB, v89, v54, v79);
          if (v57) {
            goto LABEL_302;
          }
          int v42 = *(void *)&v58[16 * __n_4];
          __int n = *(void *)&v58[16 * __n_4 + 8] - v42;
          if (v42 >= 0)
          {
            if (v87 >= 0)
            {
              if (v87 - v79 >= __n)
              {
                if (v86) {
                  int v39 = memcmp(&v88[v42], v80 - 1, __n);
                }
                else {
                  int v39 = wmemcmp((const __int32 *)&v88[4 * v42], v77 - 1, __n);
                }
              }
              else
              {
                int v39 = 1;
              }
            }
            else if (v86)
            {
              int v39 = strncmp(&v88[v42], v80 - 1, __n);
            }
            else
            {
              int v39 = wcsncmp((const __int32 *)&v88[4 * v42], v77 - 1, __n);
            }
          }
          else
          {
            int v39 = 1;
          }
          if (v39) {
            goto LABEL_290;
          }
          if (!__n) {
            int v45 = 1;
          }
          if (v45 && v63[*(int *)(v64 + 16)]) {
            goto LABEL_290;
          }
          v63[*(int *)(v64 + 16)] = v45;
          v80 += __n - 1;
          v77 += __n - 1;
          v79 += __n - 1;
          wint_t v82 = v81;
          if (v86)
          {
            if (v86 == 1)
            {
              ++v79;
              if (v87 < 0 || v79 < v87)
              {
                char v11 = v80++;
                wint_t v81 = *v11;
              }
              else
              {
                wint_t v81 = 0;
              }
            }
            else if (v86 == 2)
            {
              v79 += v78;
              BOOL v25 = 0;
              if (v87 >= 0) {
                BOOL v25 = v79 >= v87;
              }
              if (v25)
              {
                wint_t v81 = 0;
                int v78 = 1;
              }
              else if (*v80 < 0)
              {
                if (v87 < 0) {
                  int v37 = 32;
                }
                else {
                  int v37 = v87 - v79;
                }
                size_t v38 = mbrtowc_l(&v81, v80, v37, &__b, *(locale_t *)(v89 + 56));
                if (v38 >= 0xFFFFFFFFFFFFFFFELL) {
                  return 17;
                }
                if (v38 || v87 < 0)
                {
                  int v78 = v38;
                  v80 += v38;
                }
                else
                {
                  int v78 = 1;
                  wint_t v81 = 0;
                  ++v80;
                }
              }
              else
              {
                int v13 = v80++;
                wint_t v81 = *v13;
                int v78 = 1;
              }
            }
          }
          else
          {
            ++v79;
            if (v87 < 0 || v79 < v87)
            {
              int v12 = v77++;
              wint_t v81 = *v12;
            }
            else
            {
              wint_t v81 = 0;
            }
          }
        }
        else
        {
          if (v87 >= 0)
          {
            if (v79 >= v87) {
              goto LABEL_290;
            }
          }
          else if (!v81)
          {
            goto LABEL_290;
          }
          wint_t v82 = v81;
          if (v86)
          {
            if (v86 == 1)
            {
              ++v79;
              if (v87 < 0 || v79 < v87)
              {
                int v14 = v80++;
                wint_t v81 = *v14;
              }
              else
              {
                wint_t v81 = 0;
              }
            }
            else if (v86 == 2)
            {
              v79 += v78;
              BOOL v24 = 0;
              if (v87 >= 0) {
                BOOL v24 = v79 >= v87;
              }
              if (v24)
              {
                wint_t v81 = 0;
                int v78 = 1;
              }
              else if (*v80 < 0)
              {
                if (v87 < 0) {
                  int v35 = 32;
                }
                else {
                  int v35 = v87 - v79;
                }
                size_t v36 = mbrtowc_l(&v81, v80, v35, &__b, *(locale_t *)(v89 + 56));
                if (v36 >= 0xFFFFFFFFFFFFFFFELL) {
                  return 17;
                }
                if (v36 || v87 < 0)
                {
                  int v78 = v36;
                  v80 += v36;
                }
                else
                {
                  int v78 = 1;
                  wint_t v81 = 0;
                  ++v80;
                }
              }
              else
              {
                int v16 = v80++;
                wint_t v81 = *v16;
                int v78 = 1;
              }
            }
          }
          else
          {
            ++v79;
            if (v87 < 0 || v79 < v87)
            {
              int v15 = v77++;
              wint_t v81 = *v15;
            }
            else
            {
              wint_t v81 = 0;
            }
          }
        }
        uint64_t v46 = 0;
        for (uint64_t m = v64; *(void *)(m + 8); m += 56)
        {
          if (*(_DWORD *)m <= v82 && *(_DWORD *)(m + 4) >= v82)
          {
            if (!*(_DWORD *)(m + 40)) {
              goto LABEL_260;
            }
            if (((*(_DWORD *)(m + 40) & 1) == 0 || v79 <= 0 && !v76 || v82 == 10 && v74)
              && ((*(_DWORD *)(m + 40) & 2) == 0 || !v81 && !v75 || v81 == 10 && v74)
              && ((*(_DWORD *)(m + 40) & 8) == 0
               || v82 != 95
               && !iswalnum_l(v82, *(locale_t *)(v89 + 56))
               && (v81 == 95 || iswalnum_l(v81, *(locale_t *)(v89 + 56))))
              && ((*(_DWORD *)(m + 40) & 0x10) == 0
               || (v82 == 95 || iswalnum_l(v82, *(locale_t *)(v89 + 56)))
               && v81 != 95
               && !iswalnum_l(v81, *(locale_t *)(v89 + 56))))
            {
              if ((*(_DWORD *)(m + 40) & 0x20) == 0 || !v79 || !v81) {
                goto LABEL_249;
              }
              BOOL v23 = 1;
              if (v82 != 95) {
                BOOL v23 = iswalnum_l(v82, *(locale_t *)(v89 + 56)) != 0;
              }
              BOOL v22 = 1;
              if (v81 != 95) {
                BOOL v22 = iswalnum_l(v81, *(locale_t *)(v89 + 56)) != 0;
              }
              if (v23 != v22)
              {
LABEL_249:
                if ((*(_DWORD *)(m + 40) & 0x40) == 0) {
                  goto LABEL_308;
                }
                if (v79 && v81)
                {
                  BOOL v21 = 1;
                  if (v82 != 95) {
                    BOOL v21 = iswalnum_l(v82, *(locale_t *)(v89 + 56)) != 0;
                  }
                  BOOL v20 = 1;
                  if (v81 != 95) {
                    BOOL v20 = iswalnum_l(v81, *(locale_t *)(v89 + 56)) != 0;
                  }
                  if (v21 == v20)
                  {
LABEL_308:
                    if ((*(_DWORD *)(m + 40) & 4) == 0
                      || tre_bracket_match(*(_DWORD **)(m + 48), v82, v89))
                    {
LABEL_260:
                      if (v46)
                      {
                        if (*((void *)v61 + 23))
                        {
                          unsigned int v61 = (char *)*((void *)v61 + 23);
                        }
                        else
                        {
                          unsigned int v34 = tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 0xC0uLL);
                          if (!v34)
                          {
                            tre_mem_destroy(v62);
                            free(v54);
                            if (v58) {
                              free(v58);
                            }
                            if (v63) {
                              free(v63);
                            }
                            return 12;
                          }
                          *((void *)v34 + 22) = v61;
                          *((void *)v34 + 23) = 0;
                          *((void *)v34 + 5) = tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 16 * v56);
                          if (!*((void *)v34 + 5))
                          {
                            tre_mem_destroy(v62);
                            free(v54);
                            if (v58) {
                              free(v58);
                            }
                            if (v63) {
                              free(v63);
                            }
                            return 12;
                          }
                          *((void *)v61 + 23) = v34;
                          unsigned int v61 = v34;
                        }
                        *(_DWORD *)unsigned int v61 = v79;
                        *((_DWORD *)v61 + 1) = v78;
                        *((void *)v61 + 1) = v80;
                        *((void *)v61 + 2) = v77;
                        *((void *)v61 + 3) = *(void *)(m + 8);
                        *((_DWORD *)v61 + 8) = *(_DWORD *)(m + 16);
                        *((_DWORD *)v61 + 9) = v81;
                        memcpy(*((void **)v61 + 5), v54, 16 * v56);
                        memcpy(v61 + 48, &__b, 0x80uLL);
                        for (int n = *(int **)(m + 24); ; ++n)
                        {
                          BOOL v19 = 0;
                          if (n) {
                            BOOL v19 = *n >= 0;
                          }
                          if (!v19) {
                            break;
                          }
                          tre_tag_set(*((void *)v61 + 5), *n, v79, v55);
                        }
                        ++v55;
                      }
                      else
                      {
                        uint64_t v46 = *(void *)(m + 8);
                        uint64_t v65 = *(int **)(m + 24);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (!v46) {
          goto LABEL_290;
        }
        uint64_t v64 = v46;
        if (v65)
        {
          while (*v65 >= 0)
          {
            unsigned int v17 = v65++;
            tre_tag_set((uint64_t)v54, *v17, v79, v55);
          }
          ++v55;
        }
      }
      if (v66 >= 0 && *(_DWORD *)(v89 + 84))
      {
        int v43 = 0;
        for (iint i = 0; *(int *)(*(void *)(v89 + 40) + 4 * ii) >= 0; ii += 2)
        {
          int v43 = tre_minimal_tag_order(*(_DWORD *)(*(void *)(v89 + 40) + 4 * (ii + 1)), *(_DWORD *)(*(void *)(v89 + 40) + 4 * ii), (uint64_t)v85, (uint64_t)v54);
          if (v43) {
            break;
          }
        }
        if (v43 > 0) {
          goto LABEL_290;
        }
        if (v43 < 0) {
          int v66 = -1;
        }
      }
      if (v66 < v79
        || v66 == v79 && v85 && tre_tag_order(*(_DWORD *)(v89 + 80), *(void *)(v89 + 32), (uint64_t)v54, (uint64_t)v85))
      {
        int v66 = v79;
        if (v85) {
          memcpy(v85, v54, 16 * v56);
        }
      }
LABEL_290:
      if (!*((void *)v61 + 22)) {
        break;
      }
      if ((*(_DWORD *)(*((void *)v61 + 3) + 40) & 0x80) != 0) {
        v63[*((int *)v61 + 8)] = 0;
      }
      int v79 = *(_DWORD *)v61;
      int v78 = *((_DWORD *)v61 + 1);
      uint64_t v80 = (char *)*((void *)v61 + 1);
      int v77 = (wint_t *)*((void *)v61 + 2);
      uint64_t v64 = *((void *)v61 + 3);
      wint_t v81 = *((_DWORD *)v61 + 9);
      memcpy(v54, *((const void **)v61 + 5), 16 * v56);
      memcpy(&__b, v61 + 48, sizeof(__b));
      unsigned int v61 = (char *)*((void *)v61 + 22);
    }
    if (v66 >= 0) {
      goto LABEL_301;
    }
    if (v79 != v68) {
      goto LABEL_300;
    }
    if (v87 >= 0) {
      break;
    }
    if (!v81) {
      goto LABEL_301;
    }
LABEL_300:
    wint_t v81 = v70;
    memcpy(&__b, __dst, sizeof(__b));
    uint64_t v80 = v69;
    int v77 = v67;
  }
  if (v79 < v87) {
    goto LABEL_300;
  }
LABEL_301:
  unsigned int v57 = v66 < 0;
  *uint64_t v83 = v66;
LABEL_302:
  tre_mem_destroy(v62);
  if (v54) {
    free(v54);
  }
  return v57;
}

uint64_t tre_tag_set(uint64_t result, int a2, int a3, int a4)
{
  int v5 = (_DWORD *)(result + 16 * a2);
  if (!(*v5)++) {
    v5[1] = a3;
  }
  _DWORD v5[2] = a3;
  _DWORD v5[3] = a4;
  return result;
}

uint64_t tre_minimal_tag_order(int a1, int a2, uint64_t a3, uint64_t a4)
{
  int v5 = (_DWORD *)(a4 + 16 * a1);
  if (*(_DWORD *)(a3 + 16 * a1) && *v5)
  {
    if (*(_DWORD *)(a3 + 16 * a1 + 8) == v5[2])
    {
      uint64_t v6 = (_DWORD *)(a4 + 16 * a2);
      if (*(_DWORD *)(a3 + 16 * a2))
      {
        if (!*v6) {
          return 1;
        }
      }
      else if (*v6)
      {
        return -1;
      }
      return (v6[2] - *(_DWORD *)(a3 + 16 * a2 + 8));
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

BOOL tre_tag_order(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  for (int i = 0; i < a1; ++i)
  {
    int v5 = tre_tag_order_1(i, *(_DWORD *)(a2 + 4 * i), a3, a4);
    if (v5) {
      return v5 > 0;
    }
  }
  return 0;
}

uint64_t tre_bracket_match(_DWORD *a1, wint_t a2, uint64_t a3)
{
  BOOL v26 = a1;
  wint_t v25 = a2;
  uint64_t v24 = a3;
  unsigned int v23 = 0;
  int v22 = 0;
  int i = 0;
  wint_t v20 = 0;
  wint_t v19 = 0;
  int v18 = 0;
  int v17 = 0;
  int v16 = 0;
  int v15 = 0;
  BOOL v14 = (*(_DWORD *)(a3 + 96) & 2) != 0;
  if ((*(_DWORD *)(a3 + 96) & 2) != 0)
  {
    if (iswlower_l(v25, *(locale_t *)(v24 + 56)))
    {
      wint_t v19 = v25;
      wint_t v20 = towupper_l(v25, *(locale_t *)(v24 + 56));
    }
    else if (iswupper_l(v25, *(locale_t *)(v24 + 56)))
    {
      wint_t v20 = v25;
      wint_t v19 = towlower_l(v25, *(locale_t *)(v24 + 56));
    }
    else
    {
      BOOL v14 = 0;
    }
  }
  int v22 = 0;
  for (int i = v26 + 2; v22 < *v26; i += 2)
  {
    if (*i <= 1u)
    {
      uint64_t v4 = (*i - 1);
      char v3 = 0;
    }
    else
    {
      uint64_t v4 = (*i - 1);
      char v3 = 1;
    }
    if ((v3 & 1) == 0)
    {
      switch(v4)
      {
        case 0:
          if (v14)
          {
            BOOL v11 = 1;
            if (i[1] != v20) {
              BOOL v11 = i[1] == v19;
            }
            unsigned int v23 = v11;
          }
          else
          {
            LOBYTE(v23) = i[1] == v25;
            unsigned int v23 = v23;
          }
          break;
        case 1:
          int v13 = i[1];
          if (++v22 >= *v26) {
            goto LABEL_54;
          }
          i += 2;
          if (*i != 3) {
            goto LABEL_54;
          }
          int v12 = i[1];
          if (!v15)
          {
            if (v14)
            {
              int v17 = __collate_equiv_value(*(void *)(v24 + 56), &v20, 1uLL);
              int v16 = __collate_equiv_value(*(void *)(v24 + 56), &v19, 1uLL);
            }
            else
            {
              int v18 = __collate_equiv_value(*(void *)(v24 + 56), &v25, 1uLL);
            }
            int v15 = 1;
          }
          if (v14)
          {
            if (v13 > v17 || (char v10 = 1, v17 > v12))
            {
              BOOL v9 = 0;
              if (v13 <= v16) {
                BOOL v9 = v16 <= v12;
              }
              char v10 = v9;
            }
            unsigned int v23 = v10 & 1;
          }
          else
          {
            BOOL v8 = 0;
            if (v13 <= v18) {
              BOOL v8 = v18 <= v12;
            }
            unsigned int v23 = v8;
          }
          break;
        case 2:
          break;
        case 3:
          if (v14)
          {
            BOOL v7 = 1;
            if (!iswctype_l(v20, i[1], *(locale_t *)(v24 + 56))) {
              BOOL v7 = iswctype_l(v19, i[1], *(locale_t *)(v24 + 56)) != 0;
            }
            unsigned int v23 = v7;
          }
          else
          {
            unsigned int v23 = iswctype_l(v25, i[1], *(locale_t *)(v24 + 56));
          }
          break;
        case 4:
          if (!v15)
          {
            if (v14)
            {
              int v17 = __collate_equiv_value(*(void *)(v24 + 56), &v20, 1uLL);
              int v16 = __collate_equiv_value(*(void *)(v24 + 56), &v19, 1uLL);
            }
            else
            {
              int v18 = __collate_equiv_value(*(void *)(v24 + 56), &v25, 1uLL);
            }
            int v15 = 1;
          }
          if (v14)
          {
            BOOL v6 = 1;
            if (i[1] != v17) {
              BOOL v6 = i[1] == v16;
            }
            unsigned int v23 = v6;
          }
          else
          {
            LOBYTE(v23) = i[1] == v18;
            unsigned int v23 = v23;
          }
          break;
        default:
          JUMPOUT(0);
      }
    }
    if (v23) {
      break;
    }
    ++v22;
  }
LABEL_54:
  if ((v26[1] & 1) == 0) {
    return v23;
  }
  if ((*(_DWORD *)(v24 + 96) & 8) == 0 || v25 != 10)
  {
    LOBYTE(v23) = v23 == 0;
    return v23;
  }
  return 0;
}

uint64_t tre_tag_order_1(int a1, int a2, uint64_t a3, uint64_t a4)
{
  BOOL v6 = (_DWORD *)(a3 + 16 * a1);
  int v5 = (_DWORD *)(a4 + 16 * a1);
  if (a2)
  {
    if (a2 == 1)
    {
      if (*v6)
      {
        if (*v5)
        {
          if (v6[1] == v5[1])
          {
            if (*v5 == *v6)
            {
              if (*v6 == 1) {
                return 0;
              }
              else {
                return (v6[2] - v5[2]);
              }
            }
            else
            {
              return (*v5 - *v6);
            }
          }
          else
          {
            return (v6[1] - v5[1]);
          }
        }
        else
        {
          return 1;
        }
      }
      else if (*v5)
      {
        return -1;
      }
      else
      {
        return 0;
      }
    }
    else if (a2 == 2)
    {
      if (*v6)
      {
        if (*v5)
        {
          if (v5[1] == v6[1])
          {
            if (*v5 == *v6)
            {
              if (*v6 == 1) {
                return 0;
              }
              else {
                return (v6[2] - v5[2]);
              }
            }
            else
            {
              return (*v5 - *v6);
            }
          }
          else
          {
            return (v5[1] - v6[1]);
          }
        }
        else
        {
          return 1;
        }
      }
      else if (*v5)
      {
        return -1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return (v5[2] - v6[2]);
  }
}

uint64_t tre_tnfa_run_parallel(uint64_t a1, const char *a2, int a3, int a4, void *a5, int a6, int *a7)
{
  uint64_t v90 = a1;
  uint64_t v89 = a2;
  int v88 = a3;
  int v87 = a4;
  int v86 = a5;
  int v85 = a6;
  int v84 = a7;
  wint_t v83 = 0;
  __int32 v82 = 0;
  wint_t v81 = a2;
  int v79 = 1;
  int v78 = (__int32 *)a2;
  memset(&__b, 0, sizeof(__b));
  int v77 = v85 & 1;
  int v76 = v85 & 2;
  int v75 = *(_DWORD *)(v90 + 96) & 8;
  int v59 = -1;
  int v54 = 1;
  memset(&__b, 0, sizeof(__b));
  if (v86) {
    int v63 = *(_DWORD *)(v90 + 80);
  }
  else {
    int v63 = 0;
  }
  __int n = 16 * v63;
  uint64_t v53 = 16 * (*(_DWORD *)(v90 + 92) + 1);
  uint64_t v52 = 16 * *(int *)(v90 + 92);
  size_t v51 = 2 * (v53 + __n * *(int *)(v90 + 92)) + 28 + __n + v52;
  int v74 = (char *)malloc_type_malloc();
  if (v74)
  {
    bzero(v74, v51);
    mbstate_t __dst = v74;
    unint64_t v45 = (unint64_t)&v74[__n];
    if ((unint64_t)&v74[__n] % 8) {
      unint64_t v32 = 8 - v45 % 8;
    }
    else {
      unint64_t v32 = 0;
    }
    wint_t v70 = (char *)(v45 + v32);
    unint64_t v46 = v45 + v32 + v53;
    if (v46 % 8) {
      unint64_t v31 = 8 - v46 % 8;
    }
    else {
      unint64_t v31 = 0;
    }
    unint64_t v71 = v46 + v31;
    unint64_t v47 = v46 + v31 + v53;
    if (v47 % 8) {
      unint64_t v30 = 8 - v47 % 8;
    }
    else {
      unint64_t v30 = 0;
    }
    unint64_t v66 = v47 + v30;
    unint64_t v48 = v47 + v30 + v52;
    if (v48 % 8) {
      unint64_t v29 = 8 - v48 % 8;
    }
    else {
      unint64_t v29 = 0;
    }
    unint64_t v49 = v48 + v29;
    for (int i = 0; i < *(_DWORD *)(v90 + 92); ++i)
    {
      *(void *)(v71 + 16 * i + 8) = v49;
      unint64_t v50 = v49 + __n;
      *(void *)&v70[16 * i + 8] = v50;
      unint64_t v49 = v50 + __n;
    }
    for (int j = 0; j < *(_DWORD *)(v90 + 92); ++j)
      *(_DWORD *)(v66 + 16 * j) = -1;
    if (*(int *)(v90 + 68) >= 0 && v81)
    {
      __s = v81;
      int v43 = *(_DWORD *)(v90 + 68);
      int v42 = 0;
      if (v87 == 1)
      {
        if (v88 < 0) {
          wint_t v81 = strchr(v81, v43);
        }
        else {
          wint_t v81 = (const char *)memchr(v81, v43, v88);
        }
      }
      else if (v87 == 2)
      {
        if (v43 >= 128)
        {
          if (v88 < 0)
          {
            while (1)
            {
              if (!*v81)
              {
                wint_t v81 = 0;
                goto LABEL_58;
              }
              if (*v81 < 0) {
                break;
              }
              ++v81;
            }
            int v42 = 1;
          }
          else
          {
            for (int k = 0; ; ++k)
            {
              if (k >= v88)
              {
                wint_t v81 = 0;
                goto LABEL_58;
              }
              if (*v81 < 0) {
                break;
              }
              ++v81;
            }
            int v42 = 1;
          }
        }
        else if (v88 < 0)
        {
          while (1)
          {
            if (!*v81)
            {
              wint_t v81 = 0;
              goto LABEL_58;
            }
            if (*v81 == v43) {
              goto LABEL_58;
            }
            if (*v81 < 0) {
              break;
            }
            ++v81;
          }
          int v42 = 1;
        }
        else
        {
          for (int m = 0; ; ++m)
          {
            if (m >= v88)
            {
              wint_t v81 = 0;
              goto LABEL_58;
            }
            if (*v81 == v43) {
              goto LABEL_58;
            }
            if (*v81 < 0) {
              break;
            }
            ++v81;
          }
          int v42 = 1;
        }
      }
LABEL_58:
      if (!v81)
      {
        free(v74);
        return 1;
      }
      if (!v42)
      {
        if (v81 >= __s + 1) {
          wint_t v83 = *((unsigned __int8 *)v81 - 1);
        }
        __int32 v82 = *(unsigned __int8 *)v81;
        int v80 = v81 - __s;
        if (v88 < 0 || v80 < v88) {
          ++v81;
        }
LABEL_121:
        int v67 = v70;
        while (v59 >= 0)
        {
          if (!v63 || v67 == v70)
          {
LABEL_283:
            *int v84 = v59;
            free(v74);
            return v59 < 0;
          }
LABEL_178:
          if (v88 >= 0)
          {
            if (v80 >= v88) {
              goto LABEL_283;
            }
          }
          else if (!v82)
          {
            goto LABEL_283;
          }
          wint_t v83 = v82;
          if (v87)
          {
            if (v87 == 1)
            {
              ++v80;
              if (v88 < 0 || v80 < v88)
              {
                int v13 = v81++;
                __int32 v82 = *(unsigned __int8 *)v13;
              }
              else
              {
                __int32 v82 = 0;
              }
            }
            else if (v87 == 2)
            {
              v80 += v79;
              BOOL v22 = 0;
              if (v88 >= 0) {
                BOOL v22 = v80 >= v88;
              }
              if (v22)
              {
                __int32 v82 = 0;
                int v79 = 1;
              }
              else if (*v81 < 0)
              {
                if (v88 < 0) {
                  int v34 = 32;
                }
                else {
                  int v34 = v88 - v80;
                }
                size_t v35 = mbrtowc_l(&v82, v81, v34, &__b, *(locale_t *)(v90 + 56));
                if (v35 >= 0xFFFFFFFFFFFFFFFELL) {
                  return 17;
                }
                if (v35 || v88 < 0)
                {
                  int v79 = v35;
                  v81 += v35;
                }
                else
                {
                  int v79 = 1;
                  __int32 v82 = 0;
                  ++v81;
                }
              }
              else
              {
                int v15 = v81++;
                __int32 v82 = *(unsigned __int8 *)v15;
                int v79 = 1;
              }
            }
          }
          else
          {
            ++v80;
            if (v88 < 0 || v80 < v88)
            {
              BOOL v14 = v78++;
              __int32 v82 = *v14;
            }
            else
            {
              __int32 v82 = 0;
            }
          }
          int v68 = (char *)v71;
          unint64_t v71 = (unint64_t)v70;
          wint_t v70 = v68;
          int v67 = v68;
          for (int n = (uint64_t *)v71; *n; n += 2)
          {
            for (iint i = *n; *(void *)(ii + 8); ii += 56)
            {
              if (*(_DWORD *)ii <= v83 && *(_DWORD *)(ii + 4) >= v83)
              {
                if (!*(_DWORD *)(ii + 40)) {
                  goto LABEL_255;
                }
                if (((*(_DWORD *)(ii + 40) & 1) == 0 || v80 <= 0 && !v77 || v83 == 10 && v75)
                  && ((*(_DWORD *)(ii + 40) & 2) == 0 || !v82 && !v76 || v82 == 10 && v75)
                  && ((*(_DWORD *)(ii + 40) & 8) == 0
                   || v83 != 95
                   && !iswalnum_l(v83, *(locale_t *)(v90 + 56))
                   && (v82 == 95 || iswalnum_l(v82, *(locale_t *)(v90 + 56))))
                  && ((*(_DWORD *)(ii + 40) & 0x10) == 0
                   || (v83 == 95 || iswalnum_l(v83, *(locale_t *)(v90 + 56)))
                   && v82 != 95
                   && !iswalnum_l(v82, *(locale_t *)(v90 + 56))))
                {
                  if ((*(_DWORD *)(ii + 40) & 0x20) == 0 || !v80 || !v82) {
                    goto LABEL_244;
                  }
                  BOOL v21 = 1;
                  if (v83 != 95) {
                    BOOL v21 = iswalnum_l(v83, *(locale_t *)(v90 + 56)) != 0;
                  }
                  BOOL v20 = 1;
                  if (v82 != 95) {
                    BOOL v20 = iswalnum_l(v82, *(locale_t *)(v90 + 56)) != 0;
                  }
                  if (v21 != v20)
                  {
LABEL_244:
                    if ((*(_DWORD *)(ii + 40) & 0x40) == 0) {
                      goto LABEL_287;
                    }
                    if (v80 && v82)
                    {
                      BOOL v19 = 1;
                      if (v83 != 95) {
                        BOOL v19 = iswalnum_l(v83, *(locale_t *)(v90 + 56)) != 0;
                      }
                      BOOL v18 = 1;
                      if (v82 != 95) {
                        BOOL v18 = iswalnum_l(v82, *(locale_t *)(v90 + 56)) != 0;
                      }
                      if (v19 == v18)
                      {
LABEL_287:
                        if ((*(_DWORD *)(ii + 40) & 4) == 0
                          || tre_bracket_match_0(*(_DWORD **)(ii + 48), v83, v90))
                        {
LABEL_255:
                          memcpy(__dst, (const void *)n[1], __n);
                          uint64_t v65 = *(int **)(ii + 24);
                          if (v65)
                          {
                            while (*v65 >= 0)
                            {
                              if (*v65 < v63) {
                                tre_tag_set((uint64_t)__dst, *v65, v80, v54);
                              }
                              ++v65;
                            }
                            ++v54;
                          }
                          if (!*(_DWORD *)(v90 + 84) || v59 < 0) {
                            goto LABEL_269;
                          }
                          int v33 = 0;
                          for (jint j = 0; *(int *)(*(void *)(v90 + 40) + 4 * jj) >= 0; jj += 2)
                          {
                            if ((int)tre_minimal_tag_order(*(_DWORD *)(*(void *)(v90 + 40) + 4 * (jj + 1)), *(_DWORD *)(*(void *)(v90 + 40) + 4 * jj), (uint64_t)v86, (uint64_t)__dst) > 0)
                            {
                              int v33 = 1;
                              break;
                            }
                          }
                          if (!v33)
                          {
LABEL_269:
                            if (*(_DWORD *)(v66 + 16 * *(int *)(ii + 16)) >= v80)
                            {
                              if (tre_tag_order(v63, *(void *)(v90 + 32), (uint64_t)__dst, **(void **)(v66 + 16 * *(int *)(ii + 16) + 8)))
                              {
                                unsigned int v57 = **(void ***)(v66 + 16 * *(int *)(ii + 16) + 8);
                                **(void **)(v66 + 16 * *(int *)(ii + 16) + 8) = __dst;
                                if (*(void *)(ii + 8) == *(void *)(v90 + 16))
                                {
                                  int v59 = v80;
                                  memcpy(v86, __dst, __n);
                                }
                                mbstate_t __dst = v57;
                              }
                            }
                            else
                            {
                              *(void *)int v67 = *(void *)(ii + 8);
                              int v56 = (void *)*((void *)v67 + 1);
                              *((void *)v67 + 1) = __dst;
                              mbstate_t __dst = v56;
                              *(_DWORD *)(v66 + 16 * *(int *)(ii + 16)) = v80;
                              *(void *)(v66 + 16 * *(int *)(ii + 16) + 8) = v67 + 8;
                              if (*(void *)v67 == *(void *)(v90 + 16))
                              {
                                if (v59 == -1
                                  || v63 > 0
                                  && (int v17 = tre_tag_get(*((void *)v67 + 1), 0),
                                      v17 <= (int)tre_tag_get((uint64_t)v86, 0)))
                                {
                                  int v59 = v80;
                                  memcpy(v86, *((const void **)v67 + 1), __n);
                                }
                              }
                              v67 += 16;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          *(void *)int v67 = 0;
        }
        for (kint k = *(void *)(v90 + 8); ; kk += 56)
        {
          while (1)
          {
            if (!*(void *)(kk + 8))
            {
              *(void *)int v67 = 0;
              goto LABEL_178;
            }
            if (*(_DWORD *)(v66 + 16 * *(int *)(kk + 16)) < v80) {
              break;
            }
LABEL_173:
            kk += 56;
          }
          if (!*(_DWORD *)(kk + 40)) {
            goto LABEL_164;
          }
          if (((*(_DWORD *)(kk + 40) & 1) == 0 || v80 <= 0 && !v77 || v83 == 10 && v75)
            && ((*(_DWORD *)(kk + 40) & 2) == 0 || !v82 && !v76 || v82 == 10 && v75)
            && ((*(_DWORD *)(kk + 40) & 8) == 0
             || v83 != 95
             && !iswalnum_l(v83, *(locale_t *)(v90 + 56))
             && (v82 == 95 || iswalnum_l(v82, *(locale_t *)(v90 + 56))))
            && ((*(_DWORD *)(kk + 40) & 0x10) == 0
             || (v83 == 95 || iswalnum_l(v83, *(locale_t *)(v90 + 56)))
             && v82 != 95
             && !iswalnum_l(v82, *(locale_t *)(v90 + 56))))
          {
            if ((*(_DWORD *)(kk + 40) & 0x20) == 0 || !v80 || !v82) {
              goto LABEL_155;
            }
            BOOL v26 = 1;
            if (v83 != 95) {
              BOOL v26 = iswalnum_l(v83, *(locale_t *)(v90 + 56)) != 0;
            }
            BOOL v25 = 1;
            if (v82 != 95) {
              BOOL v25 = iswalnum_l(v82, *(locale_t *)(v90 + 56)) != 0;
            }
            if (v26 != v25)
            {
LABEL_155:
              if ((*(_DWORD *)(kk + 40) & 0x40) == 0) {
                goto LABEL_164;
              }
              if (v80 && v82)
              {
                BOOL v24 = 1;
                if (v83 != 95) {
                  BOOL v24 = iswalnum_l(v83, *(locale_t *)(v90 + 56)) != 0;
                }
                BOOL v23 = 1;
                if (v82 != 95) {
                  BOOL v23 = iswalnum_l(v82, *(locale_t *)(v90 + 56)) != 0;
                }
                if (v24 == v23)
                {
LABEL_164:
                  *(void *)int v67 = *(void *)(kk + 8);
                  bzero(*((void **)v67 + 1), __n);
                  uint64_t v64 = *(int **)(kk + 24);
                  if (v64)
                  {
                    while (*v64 >= 0)
                    {
                      if (*v64 < v63) {
                        tre_tag_set(*((void *)v67 + 1), *v64, v80, v54);
                      }
                      ++v64;
                    }
                    ++v54;
                  }
                  if (*(void *)v67 == *(void *)(v90 + 16))
                  {
                    int v59 = v80;
                    memcpy(v86, *((const void **)v67 + 1), __n);
                  }
                  *(_DWORD *)(v66 + 16 * *(int *)(kk + 16)) = v80;
                  *(void *)(v66 + 16 * *(int *)(kk + 16) + 8) = v67 + 8;
                  v67 += 16;
                  goto LABEL_173;
                }
              }
            }
          }
        }
      }
      if (v81 != __s)
      {
        __int32 v82 = *((unsigned __int8 *)v81 - 1);
        int v80 = v81 - 1 - __s;
        wint_t v83 = v82;
        if (v87)
        {
          if (v87 == 1)
          {
            int v80 = v81 - __s;
            if (v88 < 0 || v80 < v88)
            {
              BOOL v7 = v81++;
              __int32 v82 = *(unsigned __int8 *)v7;
            }
            else
            {
              __int32 v82 = 0;
            }
          }
          else if (v87 == 2)
          {
            int v80 = v81 - __s;
            BOOL v28 = 0;
            if (v88 >= 0) {
              BOOL v28 = v80 >= v88;
            }
            if (v28)
            {
              __int32 v82 = 0;
              int v79 = 1;
            }
            else if (*v81 < 0)
            {
              if (v88 < 0) {
                int v38 = 32;
              }
              else {
                int v38 = v88 - v80;
              }
              size_t v39 = mbrtowc_l(&v82, v81, v38, &__b, *(locale_t *)(v90 + 56));
              if (v39 >= 0xFFFFFFFFFFFFFFFELL) {
                return 17;
              }
              if (v39 || v88 < 0)
              {
                int v79 = v39;
                v81 += v39;
              }
              else
              {
                int v79 = 1;
                __int32 v82 = 0;
                ++v81;
              }
            }
            else
            {
              BOOL v9 = v81++;
              __int32 v82 = *(unsigned __int8 *)v9;
              int v79 = 1;
            }
          }
        }
        else
        {
          int v80 = v81 - __s;
          if (v88 < 0 || v80 < v88)
          {
            BOOL v8 = v78++;
            __int32 v82 = *v8;
          }
          else
          {
            __int32 v82 = 0;
          }
        }
        goto LABEL_121;
      }
    }
    wint_t v83 = v82;
    if (v87)
    {
      if (v87 == 1)
      {
        if (v88)
        {
          char v10 = v81++;
          __int32 v82 = *(unsigned __int8 *)v10;
        }
        else
        {
          __int32 v82 = 0;
        }
      }
      else if (v87 == 2)
      {
        BOOL v27 = 0;
        if (v88 >= 0) {
          BOOL v27 = v88 <= 0;
        }
        if (v27)
        {
          __int32 v82 = 0;
          int v79 = 1;
        }
        else if (*v81 < 0)
        {
          if (v88 < 0) {
            int v36 = 32;
          }
          else {
            int v36 = v88;
          }
          size_t v37 = mbrtowc_l(&v82, v81, v36, &__b, *(locale_t *)(v90 + 56));
          if (v37 >= 0xFFFFFFFFFFFFFFFELL) {
            return 17;
          }
          if (v37 || v88 < 0)
          {
            int v79 = v37;
            v81 += v37;
          }
          else
          {
            int v79 = 1;
            __int32 v82 = 0;
            ++v81;
          }
        }
        else
        {
          int v12 = v81++;
          __int32 v82 = *(unsigned __int8 *)v12;
          int v79 = 1;
        }
      }
    }
    else if (v88)
    {
      BOOL v11 = v78++;
      __int32 v82 = *v11;
    }
    else
    {
      __int32 v82 = 0;
    }
    int v80 = 0;
    goto LABEL_121;
  }
  return 12;
}

uint64_t tre_bracket_match_0(_DWORD *a1, wint_t a2, uint64_t a3)
{
  BOOL v26 = a1;
  wint_t v25 = a2;
  uint64_t v24 = a3;
  unsigned int v23 = 0;
  int v22 = 0;
  int i = 0;
  wint_t v20 = 0;
  wint_t v19 = 0;
  int v18 = 0;
  int v17 = 0;
  int v16 = 0;
  int v15 = 0;
  BOOL v14 = (*(_DWORD *)(a3 + 96) & 2) != 0;
  if ((*(_DWORD *)(a3 + 96) & 2) != 0)
  {
    if (iswlower_l(v25, *(locale_t *)(v24 + 56)))
    {
      wint_t v19 = v25;
      wint_t v20 = towupper_l(v25, *(locale_t *)(v24 + 56));
    }
    else if (iswupper_l(v25, *(locale_t *)(v24 + 56)))
    {
      wint_t v20 = v25;
      wint_t v19 = towlower_l(v25, *(locale_t *)(v24 + 56));
    }
    else
    {
      BOOL v14 = 0;
    }
  }
  int v22 = 0;
  for (int i = v26 + 2; v22 < *v26; i += 2)
  {
    if (*i <= 1u)
    {
      uint64_t v4 = (*i - 1);
      char v3 = 0;
    }
    else
    {
      uint64_t v4 = (*i - 1);
      char v3 = 1;
    }
    if ((v3 & 1) == 0)
    {
      switch(v4)
      {
        case 0:
          if (v14)
          {
            BOOL v11 = 1;
            if (i[1] != v20) {
              BOOL v11 = i[1] == v19;
            }
            unsigned int v23 = v11;
          }
          else
          {
            LOBYTE(v23) = i[1] == v25;
            unsigned int v23 = v23;
          }
          break;
        case 1:
          int v13 = i[1];
          if (++v22 >= *v26) {
            goto LABEL_54;
          }
          i += 2;
          if (*i != 3) {
            goto LABEL_54;
          }
          int v12 = i[1];
          if (!v15)
          {
            if (v14)
            {
              int v17 = __collate_equiv_value(*(void *)(v24 + 56), &v20, 1uLL);
              int v16 = __collate_equiv_value(*(void *)(v24 + 56), &v19, 1uLL);
            }
            else
            {
              int v18 = __collate_equiv_value(*(void *)(v24 + 56), &v25, 1uLL);
            }
            int v15 = 1;
          }
          if (v14)
          {
            if (v13 > v17 || (char v10 = 1, v17 > v12))
            {
              BOOL v9 = 0;
              if (v13 <= v16) {
                BOOL v9 = v16 <= v12;
              }
              char v10 = v9;
            }
            unsigned int v23 = v10 & 1;
          }
          else
          {
            BOOL v8 = 0;
            if (v13 <= v18) {
              BOOL v8 = v18 <= v12;
            }
            unsigned int v23 = v8;
          }
          break;
        case 2:
          break;
        case 3:
          if (v14)
          {
            BOOL v7 = 1;
            if (!iswctype_l(v20, i[1], *(locale_t *)(v24 + 56))) {
              BOOL v7 = iswctype_l(v19, i[1], *(locale_t *)(v24 + 56)) != 0;
            }
            unsigned int v23 = v7;
          }
          else
          {
            unsigned int v23 = iswctype_l(v25, i[1], *(locale_t *)(v24 + 56));
          }
          break;
        case 4:
          if (!v15)
          {
            if (v14)
            {
              int v17 = __collate_equiv_value(*(void *)(v24 + 56), &v20, 1uLL);
              int v16 = __collate_equiv_value(*(void *)(v24 + 56), &v19, 1uLL);
            }
            else
            {
              int v18 = __collate_equiv_value(*(void *)(v24 + 56), &v25, 1uLL);
            }
            int v15 = 1;
          }
          if (v14)
          {
            BOOL v6 = 1;
            if (i[1] != v17) {
              BOOL v6 = i[1] == v16;
            }
            unsigned int v23 = v6;
          }
          else
          {
            LOBYTE(v23) = i[1] == v18;
            unsigned int v23 = v23;
          }
          break;
        default:
          JUMPOUT(0);
      }
    }
    if (v23) {
      break;
    }
    ++v22;
  }
LABEL_54:
  if ((v26[1] & 1) == 0) {
    return v23;
  }
  if ((*(_DWORD *)(v24 + 96) & 8) == 0 || v25 != 10)
  {
    LOBYTE(v23) = v23 == 0;
    return v23;
  }
  return 0;
}

void *tre_mem_new_impl(int a1, void *a2)
{
  if (a1)
  {
    mbstate_t __b = a2;
    memset(a2, 0, 0x30uLL);
  }
  else
  {
    mbstate_t __b = (void *)malloc_type_calloc();
  }
  if (__b) {
    return __b;
  }
  else {
    return 0;
  }
}

void tre_mem_destroy(void **a1)
{
  for (int i = (void **)*a1; i; int i = v2)
  {
    free(*i);
    unsigned int v2 = (void **)i[1];
    free(i);
  }
  free(a1);
}

char *tre_mem_alloc_impl(uint64_t a1, int a2, uint64_t a3, int a4, unint64_t a5)
{
  if (*(_DWORD *)(a1 + 32)) {
    return 0;
  }
  if (*(void *)(a1 + 24) < a5)
  {
    if (a2)
    {
      if (!a3)
      {
        *(_DWORD *)(a1 + 32) = 1;
        return 0;
      }
      *(void *)(a1 + 16) = a3;
      *(void *)(a1 + 24) = 1024;
    }
    else
    {
      if (8 * a5 <= 0x400) {
        uint64_t v7 = 1024;
      }
      else {
        uint64_t v7 = 8 * a5;
      }
      BOOL v8 = (void *)malloc_type_malloc();
      if (!v8)
      {
        *(_DWORD *)(a1 + 32) = 1;
        return 0;
      }
      *BOOL v8 = malloc_type_malloc();
      if (!*v8)
      {
        free(v8);
        *(_DWORD *)(a1 + 32) = 1;
        return 0;
      }
      v8[1] = 0;
      if (*(void *)(a1 + 8)) {
        *(void *)(*(void *)(a1 + 8) + 8) = v8;
      }
      if (!*(void *)a1) {
        *(void *)a1 = v8;
      }
      *(void *)(a1 + 8) = v8;
      *(void *)(a1 + 16) = *v8;
      *(void *)(a1 + 24) = v7;
    }
  }
  if ((*(void *)(a1 + 16) + a5) % 8) {
    unint64_t v6 = 8 - (*(void *)(a1 + 16) + a5) % 8;
  }
  else {
    unint64_t v6 = 0;
  }
  size_t v11 = a5 + v6;
  BOOL v9 = *(char **)(a1 + 16);
  *(void *)(a1 + 16) = &v9[v11];
  *(void *)(a1 + 24) -= v11;
  if (a4) {
    bzero(v9, v11);
  }
  return v9;
}

uint64_t tre_parse(void *a1)
{
  uint64_t __src = a1;
  uint64_t v65 = 0;
  unsigned int v64 = 0;
  unsigned int v63 = 0;
  uint64_t v62 = 0;
  uint64_t v62 = a1[1];
  int v61 = tre_stack_num_objects(v62);
  int v60 = 0;
  int v59 = 0;
  unsigned int v58 = 0;
  if (*((int *)__src + 14) <= 0) {
    return 14;
  }
  if (!*((_DWORD *)__src + 22))
  {
    unsigned int v63 = tre_stack_push_int(v62, *((_DWORD *)__src + 21));
    tre_stack_push_int(v62, *((_DWORD *)__src + 15));
    unsigned int v63 = tre_stack_push_int(v62, 2u);
    ++*((_DWORD *)__src + 15);
  }
  tre_stack_push_int(v62, 0);
  unsigned int v63 = tre_stack_push_int(v62, 0);
  *((void *)__src + 4) = *((void *)__src + 3);
  *((void *)__src + 5) = *((void *)__src + 3) + 4 * *((int *)__src + 14);
  do
  {
LABEL_6:
    int v1 = tre_stack_num_objects(v62);
    BOOL v31 = 0;
    if (v1 > v61) {
      BOOL v31 = v63 == 0;
    }
    if (!v31)
    {
      if (v63)
      {
        return v63;
      }
      else if (v60 <= 0)
      {
        *((void *)__src + 2) = v65;
        return 0;
      }
      else
      {
        return 8;
      }
    }
    unsigned int v2 = tre_stack_pop_int(v62);
    unsigned int v64 = v2;
    if (v2)
    {
      uint64_t v4 = v2;
      char v3 = 1;
    }
    else
    {
      uint64_t v4 = 0;
      char v3 = 0;
    }
  }
  while ((v3 & 1) != 0);
  switch(v4)
  {
    case 0:
      unsigned int v58 = tre_stack_pop_int(v62);
      if ((*((_DWORD *)__src + 21) & 0x10) != 0
        || (*((_DWORD *)__src + 21) & 0x101) == 0
        || (unsigned int v63 = tre_stack_push_int(v62, 7u)) == 0)
      {
        unsigned int v63 = tre_stack_push_int(v62, v58);
        if (!v63) {
          unsigned int v63 = tre_stack_push_int(v62, 3u);
        }
      }
      goto LABEL_6;
    case 1:
      unsigned int v58 = tre_stack_pop_int(v62);
      if (*((void *)__src + 3) >= *((void *)__src + 5) || (*((_DWORD *)__src + 21) & 0x10) != 0) {
        goto LABEL_313;
      }
      unsigned int v7 = **((_DWORD **)__src + 3);
      BOOL v8 = v7 > 0x24;
      uint64_t v9 = v7 - 36;
      if (v8)
      {
        uint64_t v11 = v9;
        char v10 = 1;
      }
      else
      {
        uint64_t v11 = v9;
        char v10 = 0;
      }
      if (v10) {
        goto LABEL_313;
      }
      break;
    case 2:
      int v34 = tre_stack_pop_int(v62);
      int v18 = tre_stack_pop_int(v62);
      *((_DWORD *)__src + 21) = v18;
      if (*((_DWORD *)v65 + 13) >= 0x40000000u) {
        goto LABEL_369;
      }
      if (v34 >= 0x40000000) {
        goto LABEL_6;
      }
      int v33 = tre_ast_new_literal(*(void *)__src, -1, -1, -1);
      if (!v33) {
        return 12;
      }
      unint64_t v32 = tre_ast_new_catenation(*(void *)__src, (uint64_t)v33, (uint64_t)v65);
      if (!v32) {
        return 12;
      }
      *((_DWORD *)v32 + 14) = *((_DWORD *)v65 + 14);
      uint64_t v65 = v32;
LABEL_369:
      *((_DWORD *)v65 + 13) = v34;
      if (v34 < 0x40000000) {
        ++*((_DWORD *)v65 + 14);
      }
      goto LABEL_6;
    case 3:
      unsigned int v58 = tre_stack_pop_int(v62);
      unsigned int v63 = tre_stack_push_int(v62, 5u);
      if (!v63)
      {
        unsigned int v63 = tre_stack_push_int(v62, v58);
        if (!v63) {
          goto LABEL_21;
        }
      }
      goto LABEL_6;
    case 4:
      unsigned int v58 = tre_stack_pop_int(v62);
      unsigned int v63 = tre_stack_push_int(v62, 9u);
      if (!v63)
      {
        unsigned int v63 = tre_stack_push_int(v62, v58);
        if (!v63) {
          goto LABEL_319;
        }
      }
      goto LABEL_6;
    case 5:
      int v57 = 0;
      if (*((void *)__src + 3) >= *((void *)__src + 5)) {
        goto LABEL_6;
      }
      int v57 = **((_DWORD **)__src + 3);
      if ((*((_DWORD *)__src + 21) & 0x10) != 0) {
        goto LABEL_47;
      }
      if ((*((_DWORD *)__src + 21) & 1) != 0 && v57 == 124
        || (*((_DWORD *)__src + 21) & 0x101) == 0x100
        && (unint64_t)(*((void *)__src + 3) + 4) < *((void *)__src + 5)
        && v57 == 92
        && *(_DWORD *)(*((void *)__src + 3) + 4) == 124)
      {
        goto LABEL_6;
      }
      if ((*((_DWORD *)__src + 21) & 1) != 0 && v57 == 41 && v60 > 0
        || (*((_DWORD *)__src + 21) & 1) == 0
        && (unint64_t)(*((void *)__src + 3) + 4) < *((void *)__src + 5)
        && v57 == 92
        && *(_DWORD *)(*((void *)__src + 3) + 4) == 41)
      {
        if ((*((_DWORD *)__src + 21) & 1) == 0 && !v60) {
          return 8;
        }
        --v60;
        if ((*((_DWORD *)__src + 21) & 0x101) == 0) {
          *((void *)__src + 3) += 8;
        }
      }
      else
      {
LABEL_47:
        unsigned int v63 = tre_stack_push_voidptr(v62, (uint64_t)v65);
        if (!v63)
        {
          unsigned int v63 = tre_stack_push_int(v62, 6u);
          if (!v63)
          {
            unsigned int v63 = tre_stack_push_int(v62, 5u);
            if (!v63)
            {
              unsigned int v63 = tre_stack_push_int(v62, 0);
              if (!v63) {
LABEL_21:
              }
                unsigned int v63 = tre_stack_push_int(v62, 4u);
            }
          }
        }
      }
      goto LABEL_6;
    case 6:
      uint64_t v56 = 0;
      uint64_t v56 = tre_stack_pop_voidptr(v62);
      int v55 = 0;
      int v55 = tre_ast_new_catenation(*(void *)__src, v56, (uint64_t)v65);
      if (!v55) {
        return 12;
      }
      uint64_t v65 = v55;
      goto LABEL_6;
    case 7:
      if (*((void *)__src + 3) >= *((void *)__src + 5) || (*((_DWORD *)__src + 21) & 0x10) != 0) {
        goto LABEL_6;
      }
      if (*((_DWORD *)__src + 21)) {
        goto LABEL_62;
      }
      if (**((_DWORD **)__src + 3) == 92 && (unint64_t)(*((void *)__src + 3) + 4) < *((void *)__src + 5))
      {
        *((void *)__src + 3) += 4;
LABEL_62:
        int v30 = **((_DWORD **)__src + 3);
        if (v30 == 41)
        {
          *((void *)__src + 3) += 4;
        }
        else if (v30 == 124)
        {
          unsigned int v63 = tre_stack_push_int(v62, 7u);
          if (!v63)
          {
            unsigned int v63 = tre_stack_push_voidptr(v62, *((void *)__src + 3));
            if (!v63)
            {
              unsigned int v63 = tre_stack_push_voidptr(v62, (uint64_t)v65);
              if (!v63)
              {
                unsigned int v63 = tre_stack_push_int(v62, 8u);
                if (!v63)
                {
                  unsigned int v63 = tre_stack_push_int(v62, (*((_DWORD *)__src + 21) & 0x101) == 256);
                  if (!v63)
                  {
                    unsigned int v63 = tre_stack_push_int(v62, 3u);
                    if (!v63) {
                      *((void *)__src + 3) += 4;
                    }
                  }
                }
              }
            }
          }
        }
        else if ((*((_DWORD *)__src + 21) & 1) == 0)
        {
          *((void *)__src + 3) -= 4;
        }
      }
      goto LABEL_6;
    case 8:
      int v54 = 0;
      uint64_t v53 = 0;
      uint64_t v53 = tre_stack_pop_voidptr(v62);
      uint64_t v52 = 0;
      uint64_t v52 = tre_stack_pop_voidptr(v62);
      if (v52 == *((void *)__src + 3) - 4) {
        return 14;
      }
      int v54 = tre_ast_new_union(*(void *)__src, v53, (uint64_t)v65);
      if (!v54) {
        return 12;
      }
      uint64_t v65 = v54;
      goto LABEL_6;
    case 9:
      if (*((void *)__src + 3) >= *((void *)__src + 5) || (*((_DWORD *)__src + 21) & 0x10) != 0) {
        goto LABEL_6;
      }
      int v51 = 0;
      int v51 = (*((_DWORD *)__src + 21) & 0x40) != 0;
      int v50 = 0;
      int v49 = -1;
      int v29 = **((_DWORD **)__src + 3);
      switch(v29)
      {
        case '*':
          goto LABEL_89;
        case '+':
        case '?':
          if ((*((_DWORD *)__src + 21) & 1) == 0) {
            goto LABEL_6;
          }
LABEL_89:
          unint64_t v48 = 0;
          break;
        case '\\':
          if ((*((_DWORD *)__src + 21) & 1) != 0
            || (unint64_t)(*((void *)__src + 3) + 4) >= *((void *)__src + 5))
          {
            goto LABEL_6;
          }
          int v28 = *(_DWORD *)(*((void *)__src + 3) + 4);
          if (v28 != 43 && v28 != 63)
          {
            if (v28 != 123) {
              goto LABEL_6;
            }
            *((void *)__src + 3) += 4;
LABEL_141:
            BOOL v27 = 0;
            if (!*((_DWORD *)v65 + 12))
            {
              BOOL v27 = 0;
              if (*((int *)v65 + 13) < 0) {
                BOOL v27 = **(_DWORD **)v65 == -2;
              }
            }
            int v47 = v27;
            *((void *)__src + 3) += 4;
            unsigned int v63 = tre_parse_bound((uint64_t)__src, (uint64_t *)&v65);
            if (v63 == 1)
            {
              unsigned int v63 = 0;
              *((void *)__src + 3) -= 4;
            }
            else
            {
              if (v63) {
                return v63;
              }
              if (v47) {
                return 13;
              }
              if (*((_DWORD *)v65 + 12) == 2)
              {
                int v6 = *((_DWORD *)__src + 16);
                *((_DWORD *)__src + 16) = v6 + 1;
                *((_DWORD *)v65 + 13) = v6;
              }
            }
            goto LABEL_6;
          }
          if ((*((_DWORD *)__src + 21) & 0x100) == 0) {
            goto LABEL_6;
          }
          *((void *)__src + 3) += 4;
          break;
        case '{':
          int v47 = 0;
          if ((*((_DWORD *)__src + 21) & 1) == 0) {
            goto LABEL_6;
          }
          goto LABEL_141;
        default:
          goto LABEL_6;
      }
      if (*((_DWORD *)v65 + 12) || *((int *)v65 + 13) >= 0 || **(_DWORD **)v65 != -2)
      {
        if (**((_DWORD **)__src + 3) == 43) {
          int v50 = 1;
        }
        if (**((_DWORD **)__src + 3) == 63) {
          int v49 = 1;
        }
        if (*((_DWORD *)__src + 21))
        {
          if ((unint64_t)(*((void *)__src + 3) + 4) < *((void *)__src + 5))
          {
            if (*(_DWORD *)(*((void *)__src + 3) + 4) == 63)
            {
              if ((*((_DWORD *)__src + 21) & 0x100) == 0) {
                return 13;
              }
              LOBYTE(v51) = (*((_DWORD *)__src + 21) & 0x40) == 0;
              int v51 = v51;
              *((void *)__src + 3) += 4;
            }
            else if (*(_DWORD *)(*((void *)__src + 3) + 4) == 42 || *(_DWORD *)(*((void *)__src + 3) + 4) == 43)
            {
              return 13;
            }
          }
        }
        else
        {
          if ((unint64_t)(*((void *)__src + 3) + 4) < *((void *)__src + 5)
            && *(_DWORD *)(*((void *)__src + 3) + 4) == 42)
          {
            return 13;
          }
          if ((unint64_t)(*((void *)__src + 3) + 8) < *((void *)__src + 5))
          {
            if (*(_DWORD *)(*((void *)__src + 3) + 4) == 92 && *(_DWORD *)(*((void *)__src + 3) + 4) == 63)
            {
              if ((*((_DWORD *)__src + 21) & 0x100) != 0)
              {
                LOBYTE(v51) = (*((_DWORD *)__src + 21) & 0x40) == 0;
                int v51 = v51;
                *((void *)__src + 3) += 8;
              }
            }
            else if (*(_DWORD *)(*((void *)__src + 3) + 4) == 92 && *(_DWORD *)(*((void *)__src + 3) + 8) == 43)
            {
              return 13;
            }
          }
        }
        if (v51) {
          ++*((_DWORD *)__src + 19);
        }
        if (!v65)
        {
          if (*((_DWORD *)__src + 21)) {
            return 13;
          }
          goto LABEL_313;
        }
        *((void *)__src + 3) += 4;
        unint64_t v48 = tre_ast_new_iter(*(void *)__src, (uint64_t)v65, v50, v49, v51);
        if (!v48) {
          return 12;
        }
        uint64_t v65 = v48;
        int v5 = *((_DWORD *)__src + 16);
        *((_DWORD *)__src + 16) = v5 + 1;
        *((_DWORD *)v65 + 13) = v5;
      }
      else if (*((_DWORD *)__src + 21))
      {
        return 13;
      }
      goto LABEL_6;
    default:
LABEL_379:
      JUMPOUT(0);
  }
  switch(v11)
  {
    case 0:
      if ((*((_DWORD *)__src + 21) & 1) == 0
        && ((unint64_t)(*((void *)__src + 3) + 8) >= *((void *)__src + 5)
         || *(_DWORD *)(*((void *)__src + 3) + 4) != 92
         || *(_DWORD *)(*((void *)__src + 3) + 8) != 41)
        && *((void *)__src + 3) + 4 != *((void *)__src + 5))
      {
        goto LABEL_313;
      }
      uint64_t v65 = tre_ast_new_literal(*(void *)__src, -2, 2, -1);
      if (!v65) {
        return 12;
      }
      *((void *)__src + 3) += 4;
      goto LABEL_6;
    case 1:
    case 2:
    case 3:
    case 6:
    case 7:
    case 8:
    case 9:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
    case 37:
    case 38:
    case 39:
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 57:
      goto LABEL_313;
    case 4:
      if ((*((_DWORD *)__src + 21) & 0x101) == 0x101 && *(_DWORD *)(*((void *)__src + 3) + 4) == 63)
      {
        int v46 = 0;
        int v46 = *((_DWORD *)__src + 21);
        int v45 = 1;
        int v44 = 0;
        *((void *)__src + 3) += 8;
        while (1)
        {
          while (1)
          {
            while (1)
            {
              while (**((_DWORD **)__src + 3) == 105)
              {
                if (v45) {
                  v46 |= 2u;
                }
                else {
                  v46 &= ~2u;
                }
                *((void *)__src + 3) += 4;
              }
              if (**((_DWORD **)__src + 3) != 110) {
                break;
              }
              if (v45) {
                v46 |= 8u;
              }
              else {
                v46 &= ~8u;
              }
              *((void *)__src + 3) += 4;
            }
            if (**((_DWORD **)__src + 3) != 85) {
              break;
            }
            if (v45) {
              v46 |= 0x40u;
            }
            else {
              v46 &= ~0x40u;
            }
            *((void *)__src + 3) += 4;
          }
          if (**((_DWORD **)__src + 3) != 45) {
            break;
          }
          *((void *)__src + 3) += 4;
          int v45 = 0;
        }
        switch(**((_DWORD **)__src + 3))
        {
          case ':':
            *((void *)__src + 3) += 4;
            ++v60;
            int v44 = 1;
            break;
          case '#':
            while (1)
            {
              BOOL v26 = 0;
              if (**((_DWORD **)__src + 3) != 41) {
                BOOL v26 = *((void *)__src + 3) < *((void *)__src + 5);
              }
              if (!v26) {
                break;
              }
              *((void *)__src + 3) += 4;
            }
            if (**((_DWORD **)__src + 3) != 41 || *((void *)__src + 3) >= *((void *)__src + 5)) {
              return 2;
            }
            *((void *)__src + 3) += 4;
            break;
          case ')':
            *((void *)__src + 3) += 4;
            break;
          default:
            return 13;
        }
        if (v44)
        {
          unsigned int v63 = tre_stack_push_int(v62, *((_DWORD *)__src + 21));
          if (!v63)
          {
            unsigned int v63 = tre_stack_push_int(v62, *((_DWORD *)__src + 16));
            if (!v63)
            {
              unsigned int v63 = tre_stack_push_int(v62, 2u);
              if (!v63)
              {
                ++*((_DWORD *)__src + 16);
                unsigned int v63 = tre_stack_push_int(v62, 0);
                if (!v63)
                {
                  unsigned int v63 = tre_stack_push_int(v62, 0);
                  if (!v63) {
                    goto LABEL_203;
                  }
                }
              }
            }
          }
        }
        else
        {
          unsigned int v63 = tre_stack_push_int(v62, 0);
          if (!v63)
          {
            unsigned int v63 = tre_stack_push_int(v62, 1u);
            if (!v63) {
LABEL_203:
            }
              *((_DWORD *)__src + 21) = v46;
          }
        }
        goto LABEL_6;
      }
      if (*((_DWORD *)__src + 21)) {
        goto LABEL_205;
      }
LABEL_313:
      if (v59
        && (unint64_t)(*((void *)__src + 3) + 4) < *((void *)__src + 5)
        && **((_DWORD **)__src + 3) == 92
        && *(_DWORD *)(*((void *)__src + 3) + 4) == 69)
      {
        *((_DWORD *)__src + 21) &= ~v59;
        int v59 = 0;
        *((void *)__src + 3) += 8;
        if (*((void *)__src + 3) >= *((void *)__src + 5))
        {
          uint64_t v65 = tre_ast_new_literal(*(void *)__src, -1, -1, -1);
          if (!v65) {
            return 12;
          }
        }
        else
        {
          unsigned int v63 = tre_stack_push_int(v62, 0);
          if (!v63) {
            goto LABEL_319;
          }
        }
        goto LABEL_6;
      }
      if ((*((_DWORD *)__src + 21) & 0x10) != 0) {
        goto LABEL_349;
      }
      if (*((void *)__src + 3) < *((void *)__src + 5))
      {
        if (*((_DWORD *)__src + 21))
        {
          if (*((void *)__src + 3) >= *((void *)__src + 5)) {
            goto LABEL_349;
          }
          if (**((_DWORD **)__src + 3) == 124) {
            return 14;
          }
          if (**((_DWORD **)__src + 3) != 123)
          {
            if (**((_DWORD **)__src + 3) == 42 || **((_DWORD **)__src + 3) == 43 || **((_DWORD **)__src + 3) == 63) {
              return 13;
            }
            goto LABEL_349;
          }
          *((void *)__src + 3) += 4;
        }
        else
        {
          if ((unint64_t)(*((void *)__src + 3) + 4) >= *((void *)__src + 5)
            || **((_DWORD **)__src + 3) != 92
            || *(_DWORD *)(*((void *)__src + 3) + 4) != 123)
          {
            goto LABEL_349;
          }
          *((void *)__src + 3) += 8;
        }
        unsigned int v63 = tre_parse_bound((uint64_t)__src, 0);
        if (v63 != 1)
        {
          if (v63) {
            return v63;
          }
          else {
            return 13;
          }
        }
        unsigned int v63 = 0;
        *((void *)__src + 3) -= 4;
LABEL_349:
        if ((*((_DWORD *)__src + 21) & 2) != 0
          && (iswupper_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6))
           || iswlower_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6))))
        {
          uint64_t v23 = *(void *)__src;
          wint_t v22 = towupper_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6));
          wint_t v16 = towupper_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6));
          int v36 = tre_ast_new_literal(v23, v22, v16, *((_DWORD *)__src + 17));
          if (!v36) {
            return 12;
          }
          uint64_t v21 = *(void *)__src;
          wint_t v20 = towlower_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6));
          wint_t v17 = towlower_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6));
          size_t v35 = tre_ast_new_literal(v21, v20, v17, *((_DWORD *)__src + 17));
          if (!v35) {
            return 12;
          }
          uint64_t v65 = tre_ast_new_union(*(void *)__src, (uint64_t)v36, (uint64_t)v35);
          if (!v65) {
            return 12;
          }
        }
        else
        {
          uint64_t v65 = tre_ast_new_literal(*(void *)__src, **((_DWORD **)__src + 3), **((_DWORD **)__src + 3), *((_DWORD *)__src + 17));
          if (!v65) {
            return 12;
          }
        }
        ++*((_DWORD *)__src + 17);
        *((void *)__src + 3) += 4;
        goto LABEL_6;
      }
      if (v60 <= 0) {
        return 14;
      }
      else {
        return 8;
      }
    case 5:
      if ((*((_DWORD *)__src + 21) & 1) != 0 && v60 > 0) {
        goto LABEL_214;
      }
      goto LABEL_313;
    case 10:
      if ((*((_DWORD *)__src + 21) & 8) != 0)
      {
        int v38 = tre_ast_new_literal(*(void *)__src, 0, 9, *((_DWORD *)__src + 17));
        if (!v38) {
          return 12;
        }
        size_t v37 = tre_ast_new_literal(*(void *)__src, 11, 0x7FFFFFFF, *((_DWORD *)__src + 17) + 1);
        if (!v37) {
          return 12;
        }
        uint64_t v65 = tre_ast_new_union(*(void *)__src, (uint64_t)v38, (uint64_t)v37);
        if (!v65) {
          return 12;
        }
        *((_DWORD *)__src + 17) += 2;
      }
      else
      {
        uint64_t v65 = tre_ast_new_literal(*(void *)__src, 0, 0x7FFFFFFF, *((_DWORD *)__src + 17));
        if (!v65) {
          return 12;
        }
        ++*((_DWORD *)__src + 17);
      }
      *((void *)__src + 3) += 4;
      goto LABEL_6;
    case 55:
      *((void *)__src + 3) += 4;
      unsigned int v63 = tre_parse_bracket((uint64_t)__src, &v65);
      if (!v63) {
        goto LABEL_6;
      }
      return v63;
    case 56:
      if ((*((_DWORD *)__src + 21) & 1) != 0
        || (unint64_t)(*((void *)__src + 3) + 4) >= *((void *)__src + 5))
      {
        goto LABEL_233;
      }
      switch(*(_DWORD *)(*((void *)__src + 3) + 4))
      {
        case '(':
          *((void *)__src + 3) += 4;
LABEL_205:
          *((void *)__src + 3) += 4;
          unsigned int v63 = tre_stack_push_int(v62, *((_DWORD *)__src + 21));
          if (!v63)
          {
            unsigned int v63 = tre_stack_push_int(v62, *((_DWORD *)__src + 15));
            if (!v63)
            {
              unsigned int v63 = tre_stack_push_int(v62, 2u);
              if (!v63)
              {
                unsigned int v63 = tre_stack_push_int(v62, (*((_DWORD *)__src + 21) & 1) == 0);
                if (!v63)
                {
                  unsigned int v63 = tre_stack_push_int(v62, 0);
                  if (!v63)
                  {
                    ++*((_DWORD *)__src + 15);
                    ++v60;
                  }
                }
              }
            }
          }
          break;
        case ')':
          *((void *)__src + 3) += 4;
LABEL_214:
          if ((*((_DWORD *)__src + 21) & 1) == 0 && !v60) {
            return 8;
          }
          uint64_t v65 = tre_ast_new_literal(*(void *)__src, -1, -1, -1);
          if (!v65) {
            return 12;
          }
          if ((*((_DWORD *)__src + 21) & 1) == 0) {
            *((void *)__src + 3) -= 4;
          }
          break;
        case '{':
          goto LABEL_313;
        default:
LABEL_233:
          if ((unint64_t)(*((void *)__src + 3) + 4) >= *((void *)__src + 5)) {
            return 5;
          }
          if ((*((_DWORD *)__src + 21) & 0x100) == 0)
          {
            *((void *)__src + 3) += 4;
            goto LABEL_273;
          }
          tre_expand_macro((_DWORD *)(*((void *)__src + 3) + 4), *((void *)__src + 5), v69, 0x40uLL);
          if (v69[0])
          {
            memset(__b, 0, sizeof(__b));
            memcpy(__b, __src, sizeof(__b));
            __b[3] = v69;
            LODWORD(__b[7]) = wcslen(v69);
            LODWORD(__b[11]) = 1;
            unsigned int v63 = tre_parse(__b);
            if (v63) {
              return v63;
            }
            *((void *)__src + 3) += 8;
            *((_DWORD *)__src + 17) = HIDWORD(__b[8]);
            uint64_t v65 = (char *)__b[2];
          }
          else
          {
            if (*(_DWORD *)(*((void *)__src + 3) + 4) != 81)
            {
              *((void *)__src + 3) += 4;
              int v25 = **((_DWORD **)__src + 3);
              switch(v25)
              {
                case '<':
                  uint64_t v65 = tre_ast_new_literal(*(void *)__src, -2, 8, -1);
                  *((void *)__src + 3) += 4;
                  break;
                case '>':
                  uint64_t v65 = tre_ast_new_literal(*(void *)__src, -2, 16, -1);
                  *((void *)__src + 3) += 4;
                  break;
                case 'B':
                  uint64_t v65 = tre_ast_new_literal(*(void *)__src, -2, 64, -1);
                  *((void *)__src + 3) += 4;
                  break;
                case 'b':
                  uint64_t v65 = tre_ast_new_literal(*(void *)__src, -2, 32, -1);
                  *((void *)__src + 3) += 4;
                  break;
                case 'x':
                  *((void *)__src + 3) += 4;
                  if (**((_DWORD **)__src + 3) == 123 || *((void *)__src + 3) >= *((void *)__src + 5))
                  {
                    if (*((void *)__src + 3) < *((void *)__src + 5))
                    {
                      int v40 = 0;
                      for (*((void *)__src + 3) += 4;
                            (*((void *)__src + 5) - *((void *)__src + 3)) / 4 >= 0;
                            *((void *)__src + 3) += 4)
                      {
                        if (v40 == 32) {
                          return 9;
                        }
                        if (**((_DWORD **)__src + 3) == 125) {
                          break;
                        }
                        if (!iswxdigit_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6))) {
                          return 9;
                        }
                        v68[v40++] = **((_DWORD **)__src + 3);
                      }
                      *((void *)__src + 3) += 4;
                      v68[v40] = 0;
                      int v13 = strtol(v68, 0, 16);
                      uint64_t v65 = tre_ast_new_literal(*(void *)__src, v13, v13, *((_DWORD *)__src + 17));
                      ++*((_DWORD *)__src + 17);
                      break;
                    }
                    goto LABEL_273;
                  }
                  *(_WORD *)__stsize_t r = 0;
                  char v42 = 0;
                  if (iswxdigit_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6))
                    && *((void *)__src + 3) < *((void *)__src + 5))
                  {
                    __str[0] = **((_DWORD **)__src + 3);
                    *((void *)__src + 3) += 4;
                  }
                  if (iswxdigit_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6))
                    && *((void *)__src + 3) < *((void *)__src + 5))
                  {
                    __str[1] = **((_DWORD **)__src + 3);
                    *((void *)__src + 3) += 4;
                  }
                  int v12 = strtol(__str, 0, 16);
                  uint64_t v65 = tre_ast_new_literal(*(void *)__src, v12, v12, *((_DWORD *)__src + 17));
                  ++*((_DWORD *)__src + 17);
                  break;
                default:
LABEL_273:
                  if ((*((_DWORD *)__src + 21) & 0x101) == 1
                    || !iswdigit_l(**((_DWORD **)__src + 3), *((locale_t *)__src + 6))
                    || **((_DWORD **)__src + 3) == 48)
                  {
                    uint64_t v65 = tre_ast_new_literal(*(void *)__src, **((_DWORD **)__src + 3), **((_DWORD **)__src + 3), *((_DWORD *)__src + 17));
                    ++*((_DWORD *)__src + 17);
                    *((void *)__src + 3) += 4;
                  }
                  else
                  {
                    int v39 = **((_DWORD **)__src + 3) - 48;
                    uint64_t v65 = tre_ast_new_literal(*(void *)__src, -4, v39, *((_DWORD *)__src + 17));
                    if (!v65) {
                      return 12;
                    }
                    int v14 = *((_DWORD *)__src + 16);
                    *((_DWORD *)__src + 16) = v14 + 1;
                    *((_DWORD *)v65 + 13) = v14;
                    ++*((_DWORD *)__src + 17);
                    ++*((_DWORD *)__src + 19);
                    if (v39 < *((_DWORD *)__src + 18)) {
                      int v24 = *((_DWORD *)__src + 18);
                    }
                    else {
                      int v24 = v39;
                    }
                    *((_DWORD *)__src + 18) = v24;
                    *((void *)__src + 3) += 4;
                  }
                  break;
              }
              if (!v65) {
                return 12;
              }
              goto LABEL_6;
            }
            *((_DWORD *)__src + 21) |= 0x10u;
            v59 |= 0x10u;
            *((void *)__src + 3) += 8;
            unsigned int v63 = tre_stack_push_int(v62, 0);
            if (!v63) {
LABEL_319:
            }
              unsigned int v63 = tre_stack_push_int(v62, 1u);
          }
          break;
      }
      goto LABEL_6;
    case 58:
      if ((*((_DWORD *)__src + 21) & 1) == 0 && !v58 && *((void *)__src + 3) != *((void *)__src + 4)) {
        goto LABEL_313;
      }
      uint64_t v65 = tre_ast_new_literal(*(void *)__src, -2, 1, -1);
      if (!v65) {
        return 12;
      }
      *((void *)__src + 3) += 4;
      goto LABEL_6;
    default:
      goto LABEL_379;
  }
}

uint64_t tre_parse_bound(uint64_t a1, uint64_t *a2)
{
  uint64_t v11 = a1;
  char v10 = a2;
  int v9 = 0;
  int v8 = 0;
  unsigned int v7 = 0;
  unsigned int v7 = *(int **)(a1 + 24);
  BOOL v6 = (*(_DWORD *)(a1 + 84) & 0x40) != 0;
  int v9 = -1;
  if ((unint64_t)v7 < *(void *)(a1 + 40))
  {
    if (*v7 < 48 || *v7 > 57)
    {
      if (*(_DWORD *)(v11 + 84)) {
        return 1;
      }
      else {
        return 10;
      }
    }
    else
    {
      int v9 = tre_parse_int(&v7, *(void *)(v11 + 40));
      int v8 = v9;
      if ((unint64_t)v7 < *(void *)(v11 + 40) && *v7 == 44)
      {
        ++v7;
        int v8 = tre_parse_int(&v7, *(void *)(v11 + 40));
      }
      if ((v8 < 0 || v9 <= v8) && v9 <= 255 && v8 <= 255)
      {
        if ((unint64_t)v7 < *(void *)(v11 + 40))
        {
          if (v7 == *(int **)(v11 + 24))
          {
            return 10;
          }
          else
          {
            if (*(_DWORD *)(v11 + 84))
            {
              if ((unint64_t)v7 >= *(void *)(v11 + 40) || *v7 != 125) {
                return 10;
              }
              if ((unint64_t)++v7 < *(void *)(v11 + 40))
              {
                if (*v7 == 63)
                {
                  if ((*(_DWORD *)(v11 + 84) & 0x100) == 0) {
                    return 13;
                  }
                  BOOL v6 = (*(_DWORD *)(v11 + 84) & 0x40) == 0;
                  ++v7;
                }
                else if (*v7 == 42 || *v7 == 43)
                {
                  return 13;
                }
              }
            }
            else
            {
              if ((unint64_t)(v7 + 1) >= *(void *)(v11 + 40) || *v7 != 92 || v7[1] != 125) {
                return 10;
              }
              v7 += 2;
              if ((unint64_t)v7 < *(void *)(v11 + 40) && *v7 == 42) {
                return 13;
              }
            }
            if (v6) {
              ++*(_DWORD *)(v11 + 76);
            }
            if (!v10 || (uint64_t v4 = tre_ast_new_iter(*(void *)v11, *v10, v9, v8, v6), (*v10 = (uint64_t)v4) != 0))
            {
              *(void *)(v11 + 24) = v7;
              return 0;
            }
            else
            {
              return 12;
            }
          }
        }
        else
        {
          return 9;
        }
      }
      else
      {
        return 10;
      }
    }
  }
  else if (*(_DWORD *)(v11 + 84))
  {
    return 1;
  }
  else
  {
    return 9;
  }
}

uint64_t tre_parse_bracket(uint64_t a1, char **a2)
{
  uint64_t v22 = a1;
  uint64_t v21 = a2;
  wint_t v20 = 0;
  unsigned int v19 = 0;
  int v18 = 0;
  int v17 = 32;
  wint_t v16 = 0;
  if ((*(void *)(v22 + 40) - *(void *)(v22 + 24)) / 4 >= 6
    && **(_DWORD **)(v22 + 24) == 91
    && *(_DWORD *)(*(void *)(v22 + 24) + 4) == 58
    && (*(_DWORD *)(*(void *)(v22 + 24) + 8) == 60 || *(_DWORD *)(*(void *)(v22 + 24) + 8) == 62)
    && *(_DWORD *)(*(void *)(v22 + 24) + 12) == 58
    && *(_DWORD *)(*(void *)(v22 + 24) + 16) == 93
    && *(_DWORD *)(*(void *)(v22 + 24) + 20) == 93)
  {
    if (*(_DWORD *)(*(void *)(v22 + 24) + 8) == 60) {
      int v2 = 8;
    }
    else {
      int v2 = 16;
    }
    *uint64_t v21 = tre_ast_new_literal(*(void *)v22, -2, v2, -1);
    *(void *)(v22 + 24) += 24;
    if (*v21) {
      return 0;
    }
    else {
      return 12;
    }
  }
  int v18 = (_DWORD *)malloc_type_calloc();
  if (!v18) {
    return 12;
  }
  if (**(_DWORD **)(v22 + 24) == 94)
  {
    v18[1] |= 1u;
    *(void *)(v22 + 24) += 4;
  }
  unsigned int v19 = tre_parse_bracket_items(v22, (uint64_t *)&v18, &v17, (void **)&v16);
  if (v19)
  {
LABEL_44:
    free(v18);
    ++*(_DWORD *)(v22 + 68);
    *uint64_t v21 = v20;
    return v19;
  }
  if (!v16)
  {
    wint_t v20 = tre_ast_new_literal(*(void *)v22, 0, 0x7FFFFFFF, *(_DWORD *)(v22 + 68));
    if (v20)
    {
      uint64_t v8 = *(void *)v20;
      *(void *)(v8 + 16) = tre_mem_alloc_impl(*(void *)v22, 0, 0, 0, 8 * (int)*v18 + 8);
      if (*(void *)(v8 + 16)) {
        memcpy(*(void **)(v8 + 16), v18, 8 * (int)*v18 + 8);
      }
      else {
        unsigned int v19 = 12;
      }
    }
    else
    {
      unsigned int v19 = 12;
    }
    goto LABEL_44;
  }
  int v15 = 0;
  int v14 = 0;
  int i = 0;
  memset(__b, 0, sizeof(__b));
  free(v18);
  int v15 = (char *)malloc_type_malloc();
  if (v15)
  {
    int v14 = v15;
    if (v16[2] > 0)
    {
      uint64_t v4 = v14;
      v14 += 4;
      *uint64_t v4 = 91;
      uint64_t __src = *(void **)(v22 + 24);
      for (int i = (char *)(v16 + 4); *(void *)i; i += 16)
      {
        uint64_t v9 = (*(void *)i - (void)__src) / 4 - 2;
        if (v9 > 0)
        {
          memcpy(v14, __src, 4 * v9);
          v14 += 4 * v9;
        }
        uint64_t __src = (void *)(*(void *)i + 4 * *((int *)i + 2) + 8);
      }
      uint64_t v10 = (*(void *)v16 - (void)__src) / 4;
      memcpy(v14, __src, 4 * v10);
      v14 += 4 * v10;
      int v5 = v14;
      v14 += 4;
      *int v5 = 124;
    }
    for (int i = (char *)(v16 + 4); *(void *)i; i += 16)
    {
      memcpy(v14, *(const void **)i, 4 * *((int *)i + 2));
      v14 += 4 * *((int *)i + 2);
      if (*((void *)i + 2))
      {
        BOOL v6 = v14;
        v14 += 4;
        *BOOL v6 = 124;
      }
    }
    *(_DWORD *)int v14 = 0;
    memcpy(__b, (const void *)v22, sizeof(__b));
    __b[3] = v15;
    LODWORD(__b[7]) = (v14 - v15) / 4;
    LODWORD(__b[11]) = 1;
    HIDWORD(__b[10]) |= 1u;
    unsigned int v19 = tre_parse(__b);
    free(v15);
    if (v19)
    {
      free(v16);
      return v19;
    }
    else
    {
      *(void *)(v22 + 24) = *(void *)v16;
      *(_DWORD *)(v22 + 68) = HIDWORD(__b[8]);
      free(v16);
      *uint64_t v21 = (char *)__b[2];
      return 0;
    }
  }
  else
  {
    free(v16);
    return 12;
  }
}

_DWORD *tre_expand_macro(_DWORD *result, unint64_t a2, _DWORD *a3, unint64_t a4)
{
  *a3 = 0;
  if ((unint64_t)result < a2)
  {
    for (int i = 0; *((void *)&tre_macros + 2 * i + 1); ++i)
    {
      if (*((char *)&tre_macros + 16 * i) == *result)
      {
        for (unsigned int j = 0; ; ++j)
        {
          BOOL v4 = 0;
          if (*(unsigned char *)(*((void *)&tre_macros + 2 * i + 1) + j)) {
            BOOL v4 = j < a4;
          }
          if (!v4) {
            break;
          }
          a3[j] = *(char *)(*((void *)&tre_macros + 2 * i + 1) + j);
        }
        a3[j] = 0;
        return result;
      }
    }
  }
  return result;
}

uint64_t tre_parse_int(_DWORD **a1, unint64_t a2)
{
  int v5 = -1;
  for (int i = *a1; ; ++i)
  {
    BOOL v3 = 0;
    if ((unint64_t)i < a2)
    {
      BOOL v3 = 0;
      if ((int)*i >= 48) {
        BOOL v3 = *i <= 57;
      }
    }
    if (!v3) {
      break;
    }
    if (v5 < 0) {
      int v5 = 0;
    }
    int v5 = 10 * v5 + *i - 48;
  }
  *a1 = i;
  return v5;
}

uint64_t tre_parse_bracket_items(uint64_t a1, uint64_t *a2, int *a3, void **a4)
{
  int v36 = (uint64_t *)a1;
  size_t v35 = a2;
  int v34 = a3;
  int v33 = a4;
  unint64_t v32 = 0;
  unint64_t v32 = *(__int32 **)(a1 + 24);
  unint64_t v31 = 0;
  unint64_t v31 = *(void *)(a1 + 40);
  int v30 = 0;
  int v29 = 0;
  int v28 = 0;
  unsigned int v27 = 0;
  int v26 = 0;
  int v26 = *a3;
  int v25 = 0;
  int v24 = -1;
  __int32 v23 = 0;
  __int32 v22 = 0;
  int v21 = 0;
  int v21 = *(_DWORD *)(*a2 + 4) & 1;
  int v20 = 0;
  unsigned int v19 = 0;
  while (1)
  {
    if ((unint64_t)v32 >= v31)
    {
      unsigned int v27 = 7;
      goto LABEL_117;
    }
    __int32 v10 = *v32;
    if (*v32 == 45)
    {
      if (v32 == (__int32 *)v36[3])
      {
        __int32 v23 = 45;
        ++v25;
        int v24 = 0;
        goto LABEL_115;
      }
      if (v24 > 0)
      {
        __int32 v22 = 45;
        goto LABEL_103;
      }
      if ((unint64_t)(v32 + 1) >= v31)
      {
        unsigned int v27 = 7;
        goto LABEL_117;
      }
      if (v32[1] == 93)
      {
        __int32 v22 = 45;
        goto LABEL_109;
      }
      if (v24 < 0)
      {
        unsigned int v27 = 11;
        goto LABEL_117;
      }
      int v24 = 1;
      goto LABEL_115;
    }
    if (v10 != 91)
    {
      if (v10 != 93)
      {
        __int32 v22 = *v32;
        goto LABEL_102;
      }
      if (v32 != (__int32 *)v36[3])
      {
        if (v20)
        {
          if (v30)
          {
            *(void *)int v30 = v32 + 1;
            *((_DWORD *)v30 + 2) = v25;
            *(void *)int v29 = 0;
          }
          char *v33 = v30;
          return 0;
        }
        else
        {
          if (!v24)
          {
            unsigned int v27 = tre_new_item(*v36, 1, v23, &v26, v35);
            if (v27) {
              goto LABEL_117;
            }
          }
          *int v34 = v26;
          v36[3] = (uint64_t)(v32 + 1);
          return 0;
        }
      }
      __int32 v23 = 93;
      int v24 = 0;
      ++v25;
      goto LABEL_115;
    }
    if ((unint64_t)(v32 + 1) >= v31)
    {
      unsigned int v27 = 7;
      goto LABEL_117;
    }
    __int32 v9 = v32[1];
    if (v9 != 46) {
      break;
    }
    v32 += 2;
    unsigned int v19 = v32;
    while (1)
    {
      if ((unint64_t)v32 >= v31)
      {
        unsigned int v27 = 3;
        goto LABEL_117;
      }
      if (*v32 == 46)
      {
        if ((unint64_t)(v32 + 1) >= v31)
        {
          unsigned int v27 = 3;
          goto LABEL_117;
        }
        if (v32[1] == 93) {
          break;
        }
      }
      ++v32;
    }
    if (v32 == v19)
    {
      unsigned int v27 = 3;
      goto LABEL_117;
    }
    __int32 v22 = tre_search_cnames(v19, v32 - v19);
    if (v22 != -1)
    {
      ++v32;
      goto LABEL_102;
    }
    if ((int)__collate_equiv_value(v36[6], v19, v32 - v19) <= 0)
    {
      unsigned int v27 = 3;
      goto LABEL_117;
    }
    if (v32 - v19 == 1)
    {
      __int32 v22 = *v19;
      ++v32;
LABEL_102:
      if (v24 <= 0)
      {
LABEL_109:
        if (!v20)
        {
          if (!v24)
          {
            unsigned int v27 = tre_new_item(*v36, 1, v23, &v26, v35);
            if (v27) {
              goto LABEL_117;
            }
          }
          __int32 v23 = v22;
        }
        int v24 = 0;
      }
      else
      {
LABEL_103:
        int v12 = __collate_equiv_value(v36[6], &v23, 1uLL);
        int v11 = __collate_equiv_value(v36[6], &v22, 1uLL);
        if (v11 < v12)
        {
          unsigned int v27 = 11;
          goto LABEL_117;
        }
        if (!v20)
        {
          unsigned int v27 = tre_new_item(*v36, 2, v12, &v26, v35);
          if (v27) {
            goto LABEL_117;
          }
          unsigned int v27 = tre_new_item(*v36, 3, v11, &v26, v35);
          if (v27) {
            goto LABEL_117;
          }
        }
        int v24 = -1;
      }
      ++v25;
      goto LABEL_115;
    }
    if (v21)
    {
      unsigned int v27 = 3;
      goto LABEL_117;
    }
    if (v24 > 0)
    {
      unsigned int v27 = 11;
      goto LABEL_117;
    }
    int v24 = -1;
    int v20 = 1;
    if (!v29)
    {
      int v30 = (void *)malloc_type_malloc();
      if (!v30) {
        return 12;
      }
      int v29 = (char *)v30 + 16;
      int v28 = 16;
    }
    if ((v29 - (unsigned char *)v30) / 16 - 1 >= v28)
    {
      int v18 = v28;
      int v17 = 0;
      v28 *= 2;
      int v17 = (char *)malloc_type_realloc();
      if (!v17)
      {
        free(v30);
        return 12;
      }
      int v30 = v17;
      int v29 = &v17[16 * v18 + 16];
    }
    *(void *)int v29 = v19;
    *((_DWORD *)v29 + 2) = v32 - v19;
    v29 += 16;
    ++v32;
LABEL_115:
    ++v32;
  }
  if (v9 != 58 && v9 != 61)
  {
    __int32 v22 = 91;
    goto LABEL_102;
  }
  __int32 v16 = 0;
  __int32 v16 = v32[1];
  if (v24 > 0)
  {
    unsigned int v27 = 11;
    goto LABEL_117;
  }
  if (v20 || v24 || (unsigned int v27 = tre_new_item(*v36, 1, v23, &v26, v35)) == 0)
  {
    int v24 = -1;
    v32 += 2;
    unsigned int v19 = v32;
    while (1)
    {
      if ((unint64_t)v32 >= v31)
      {
        if (v16 == 61) {
          int v4 = 3;
        }
        else {
          int v4 = 4;
        }
        unsigned int v27 = v4;
        goto LABEL_117;
      }
      if (*v32 == v16)
      {
        if ((unint64_t)(v32 + 1) >= v31)
        {
          if (v16 == 61) {
            int v5 = 3;
          }
          else {
            int v5 = 4;
          }
          unsigned int v27 = v5;
          goto LABEL_117;
        }
        if (v32[1] == 93) {
          break;
        }
      }
      ++v32;
    }
    if (v32 == v19)
    {
      if (v16 == 61) {
        int v6 = 3;
      }
      else {
        int v6 = 4;
      }
      unsigned int v27 = v6;
      goto LABEL_117;
    }
    if (v16 == 61)
    {
      int v15 = 0;
      int v15 = __collate_equiv_value(v36[6], v19, v32 - v19);
      if (v15 <= 0)
      {
        __int32 v22 = tre_search_cnames(v19, v32 - v19);
        if (v22 != -1)
        {
          ++v32;
          goto LABEL_102;
        }
        unsigned int v27 = 3;
        goto LABEL_117;
      }
      if (!v20)
      {
        unsigned int v27 = tre_new_item(*v36, 5, v15, &v26, v35);
        if (v27) {
          goto LABEL_117;
        }
      }
LABEL_91:
      ++v32;
      ++v25;
      goto LABEL_115;
    }
    if (v20) {
      goto LABEL_91;
    }
    size_t v14 = 0;
    if (v32 - v19 > 63) {
      LODWORD(v8) = 63;
    }
    else {
      uint64_t v8 = v32 - v19;
    }
    LODWORD(v14) = v8;
    wcsncpy(v39, v19, (int)v8);
    v39[(int)v14] = 0;
    int v13 = v39;
    memset(&__b, 0, sizeof(__b));
    LODWORD(v14) = wcsrtombs_l(v40, (const __int32 **)&v13, 0x40uLL, &__b, (locale_t)v36[6]);
    v40[(int)v14] = 0;
    HIDWORD(v14) = wctype_l(v40, (locale_t)v36[6]);
    if (!HIDWORD(v14))
    {
      unsigned int v27 = 4;
      goto LABEL_117;
    }
    unsigned int v27 = tre_new_item(*v36, 4, SHIDWORD(v14), &v26, v35);
    if (!v27) {
      goto LABEL_91;
    }
  }
LABEL_117:
  if (v30) {
    free(v30);
  }
  return v27;
}

uint64_t tre_search_cnames(const __int32 *a1, size_t a2)
{
  unint64_t v6 = 0;
  unint64_t v5 = 95;
  while (v6 <= v5)
  {
    unint64_t v4 = (v6 + v5) / 2;
    int v3 = wcsncmp(a1, (const __int32 *)*(&cnames + 2 * v4), a2);
    if (!v3 && !*((_DWORD *)*(&cnames + 2 * v4) + a2)) {
      return *((_DWORD *)&cnames + 4 * v4 + 2);
    }
    if (v3 <= 0) {
      unint64_t v5 = v4 - 1;
    }
    else {
      unint64_t v6 = v4 + 1;
    }
  }
  return -1;
}

uint64_t tre_new_item(uint64_t a1, int a2, int a3, int *a4, uint64_t *a5)
{
  uint64_t v8 = (_DWORD *)*a5;
  int v7 = *(_DWORD *)*a5;
  if (v7 < *a4) {
    goto LABEL_7;
  }
  if (*a4 < 1024)
  {
    *a4 *= 2;
    uint64_t v6 = malloc_type_realloc();
    if (!v6) {
      return 12;
    }
    uint64_t v8 = (_DWORD *)v6;
    *a5 = v6;
LABEL_7:
    v8[2 * v7 + 2] = a2;
    v8[2 * v7 + 3] = a3;
    ++*v8;
    return 0;
  }
  return 12;
}

void *tre_stack_new(int a1, int a2, int a3)
{
  unint64_t v4 = (void *)malloc_type_malloc();
  if (!v4) {
    return v4;
  }
  void v4[2] = malloc_type_malloc();
  if (v4[2])
  {
    *(_DWORD *)unint64_t v4 = a1;
    *((_DWORD *)v4 + 1) = a2;
    *((_DWORD *)v4 + 2) = a3;
    *((_DWORD *)v4 + 3) = 0;
    return v4;
  }
  free(v4);
  return 0;
}

void tre_stack_destroy(void **a1)
{
}

uint64_t tre_stack_num_objects(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t tre_stack_push_int(uint64_t a1, unsigned int a2)
{
  return tre_stack_push(a1, a2);
}

uint64_t tre_stack_push(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 12) < *(_DWORD *)a1)
  {
    *(void *)(*(void *)(a1 + 16) + 8 * (int)(*(_DWORD *)(a1 + 12))++) = a2;
    return 0;
  }
  if (*(_DWORD *)a1 < *(_DWORD *)(a1 + 4))
  {
    *(void *)int v3 = (*(_DWORD *)a1 + *(_DWORD *)(a1 + 8));
    if (*(int *)v3 > *(_DWORD *)(a1 + 4)) {
      *(_DWORD *)int v3 = *(_DWORD *)(a1 + 4);
    }
    *(void *)&v3[4] = malloc_type_realloc();
    if (*(void *)&v3[4])
    {
      *(_DWORD *)a1 = *(_DWORD *)v3;
      *(void *)(a1 + 16) = *(void *)&v3[4];
      tre_stack_push(a1, a2);
      return 0;
    }
    return 12;
  }
  else
  {
    return 12;
  }
}

uint64_t tre_stack_push_voidptr(uint64_t a1, uint64_t a2)
{
  return tre_stack_push(a1, a2);
}

uint64_t tre_stack_pop_int(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  int v2 = *(_DWORD *)(a1 + 12) - 1;
  *(_DWORD *)(a1 + 12) = v2;
  return *(unsigned int *)(v1 + 8 * v2);
}

uint64_t tre_stack_pop_voidptr(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  int v2 = *(_DWORD *)(a1 + 12) - 1;
  *(_DWORD *)(a1 + 12) = v2;
  return *(void *)(v1 + 8 * v2);
}

int creat(const char *a1, mode_t a2)
{
  return __open();
}

int sigpause(int a1)
{
  int v4 = a1;
  sigset_t v3 = 0;
  if (!__unix_conforming) {
    __unix_conforming = 1;
  }
  pthread_testcancel();
  if (v4 > 0 && v4 < 32)
  {
    if (sigprocmask(1, 0, &v3) >= 0)
    {
      int v6 = v4;
      if (v4 <= 32) {
        int v2 = 1 << (v6 - 1);
      }
      else {
        int v2 = 0;
      }
      v3 &= ~v2;
      return sigsuspend_NOCANCEL();
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int lockf(int a1, int a2, off_t a3)
{
  if (a2)
  {
    uint64_t v4 = a2;
    char v3 = 1;
  }
  else
  {
    uint64_t v4 = 0;
    char v3 = 0;
  }
  if (v3)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    switch(v4)
    {
      case 0:
      case 1:
      case 2:
        int v6 = __fcntl();
        break;
      case 3:
        if (__fcntl() == -1)
        {
          int v6 = -1;
        }
        else if (getpid())
        {
          *__error() = 35;
          int v6 = -1;
        }
        else
        {
          int v6 = 0;
        }
        break;
      default:
        JUMPOUT(0);
    }
  }
  return v6;
}

int pause(void)
{
  sigset_t v1 = 0;
  sigprocmask(0, 0, &v1);
  return sigsuspend(&v1);
}

unsigned int sleep(unsigned int a1)
{
  unsigned int v4 = a1;
  __rqtp.time_t tv_sec = 0;
  __rqtp.tv_nsec = 0;
  __rmtp.time_t tv_sec = 0;
  __rmtp.tv_nsec = 0;
  if (a1 > 0x7FFFFFFF) {
    return v4 - 0x7FFFFFFF + sleep(0x7FFFFFFFu);
  }
  __rqtp.time_t tv_sec = v4;
  __rqtp.tv_nsec = 0;
  if (nanosleep(&__rqtp, &__rmtp) != -1) {
    return 0;
  }
  if (*__error() == 4) {
    return LODWORD(__rmtp.tv_sec) + (__rmtp.tv_nsec != 0);
  }
  return v4;
}

int tcdrain(int a1)
{
  return ioctl(a1, 0x2000745EuLL, 0);
}

int usleep(useconds_t a1)
{
  useconds_t v3 = a1;
  __rqtp.tv_nsec = 1000 * (a1 % 0xF4240);
  __rqtp.time_t tv_sec = a1 / 0xF4240;
  return nanosleep(&__rqtp, 0);
}

pid_t wait(int *a1)
{
  return __wait4();
}

pid_t waitpid(pid_t a1, int *a2, int a3)
{
  if ((a3 & 0x13) == a3) {
    return __wait4();
  }
  *__error() = 22;
  return -1;
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  __int32 v16 = __rqtp;
  int v15 = __rmtp;
  mach_error_t v14 = 0;
  mach_error_t time = 0;
  mach_timespec_t v12 = 0;
  mach_timespec_t cur_time = 0;
  if (!__unix_conforming) {
    __unix_conforming = 1;
  }
  pthread_testcancel();
  if (v16 && v16->tv_sec >= 0 && v16->tv_nsec < 0x3B9ACA00uLL)
  {
    if (!v15 || (mach_error_t v14 = clock_get_time(clock_port, &cur_time)) == 0)
    {
      mach_error_t time = __semwait_signal();
      if (time < 0)
      {
        if (*__error() == 60) {
          return 0;
        }
        if (*__error() == 4)
        {
          if (v15)
          {
            mach_error_t time = clock_get_time(clock_port, &v12);
            if (time)
            {
              __int32 v9 = __stderrp;
              useconds_t v3 = mach_error_string(time);
              fprintf(v9, "clock_get_time() failed: %s\n", v3);
              return -1;
            }
            uint64_t v4 = cur_time.tv_nsec + v16->tv_nsec;
            cur_time.tv_nsec += LODWORD(v16->tv_nsec);
            if ((int)v4 >= 1000000000)
            {
              cur_time.tv_nsec -= 1000000000;
              ++cur_time.tv_sec;
            }
            cur_time.tv_sec += v16->tv_sec;
            if (cur_time.tv_sec <= v12.tv_sec)
            {
              if (cur_time.tv_sec >= v12.tv_sec) {
                uint64_t v7 = cur_time.tv_nsec - v12.tv_nsec;
              }
              else {
                uint64_t v7 = -1000000000;
              }
              uint64_t v8 = v7;
            }
            else
            {
              uint64_t v8 = 1000000000;
            }
            if (v8 <= 0)
            {
              unint64_t v5 = v15;
              v15->time_t tv_sec = 0;
              v5->tv_nsec = 0;
            }
            else
            {
              cur_time.tv_nsec -= v12.tv_nsec;
              if (cur_time.tv_nsec < 0)
              {
                cur_time.tv_nsec += 1000000000;
                --cur_time.tv_sec;
              }
              cur_time.tv_sec -= v12.tv_sec;
              v15->time_t tv_sec = cur_time.tv_sec;
              v15->tv_nsec = cur_time.tv_nsec;
            }
          }
        }
        else
        {
          *__error() = 22;
        }
      }
      return -1;
    }
    __int32 v10 = __stderrp;
    int v2 = mach_error_string(v14);
    fprintf(v10, "clock_get_time() failed: %s\n", v2);
    *__error() = 22;
    return -1;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return __recvfrom();
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return __sendto();
}

int system(const char *a1)
{
  int v17 = a1;
  pid_t v16 = 0;
  pid_t v15 = 0;
  int v14 = 0;
  int v13 = 0;
  v12.__sigaction_u.__sa_handlesize_t r = 0;
  *(void *)&v12.sa_masint k = 0;
  v11.__sigaction_u.__sa_handlesize_t r = 0;
  *(void *)&v11.sa_masint k = 0;
  v10.__sigaction_u.__sa_handlesize_t r = 0;
  *(void *)&v10.sa_masint k = 0;
  sigset_t v9 = 0;
  sigset_t v8 = 0;
  sigset_t v7 = 0;
  posix_spawnattr_t v6 = 0;
  __int16 v5 = 8;
  __argv[0] = "sh";
  __argv[1] = "-c";
  __int32 v23 = a1;
  uint64_t v24 = 0;
  if (!__unix_conforming) {
    __unix_conforming = 1;
  }
  pthread_testcancel();
  if (!v17) {
    return access("/bin/sh", 0) != -1;
  }
  int v13 = posix_spawnattr_init(&v6);
  if (v13)
  {
    int v4 = v13;
    *__error() = v4;
    return -1;
  }
  else
  {
    sigset_t v7 = 0;
    pthread_mutex_lock(&__systemfn_mutex_0);
    v12.__sigaction_u.__sa_handlesize_t r = (void (__cdecl *)(int))(&def_1F2C + 1);
    v12.sa_masint k = 0;
    v12.sa_int flags = 0;
    sigaction(2, &v12, &v11);
    if (v11.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&def_1F2C + 1))
    {
      int v21 = 2;
      v7 |= 2u;
      __int16 v5 = 12;
    }
    sigaction(3, &v12, &v10);
    if (v10.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&def_1F2C + 1))
    {
      int v20 = 3;
      v7 |= 4u;
      v5 |= 4u;
    }
    int v19 = 20;
    sigset_t v9 = 0x80000;
    sigprocmask(1, &v9, &v8);
    posix_spawnattr_setsigmask(&v6, &v8);
    if ((v5 & 4) != 0) {
      posix_spawnattr_setsigdefault(&v6, &v7);
    }
    posix_spawnattr_setflags(&v6, v5);
    sigset_t v1 = _NSGetEnviron();
    int v13 = posix_spawn(&v16, "/bin/sh", 0, &v6, __argv, *v1);
    posix_spawnattr_destroy(&v6);
    if (v13)
    {
      if (v13 == 12 || v13 == 35) {
        int v14 = -1;
      }
      else {
        int v14 = 32512;
      }
    }
    else
    {
      pid_t v15 = v16;
      do
      {
        pid_t v16 = wait4(v15, &v14, 0, 0);
        BOOL v3 = 0;
        if (v16 == -1) {
          BOOL v3 = *__error() == 4;
        }
      }
      while (v3);
      if (v16 == -1) {
        int v14 = -1;
      }
    }
    sigaction(2, &v11, 0);
    sigaction(3, &v10, 0);
    sigprocmask(3, &v8, 0);
    pthread_mutex_unlock(&__systemfn_mutex_0);
    return v14;
  }
}

FILE *popen_DARWIN_EXTSN(uint64_t a1, char *a2)
{
  uint64_t v13 = a1;
  sigaction v12 = a2;
  sigaction v11 = 0;
  sigaction v10 = 0;
  pid_t v9 = 0;
  int v8 = 0;
  int v7 = 0;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t i = 0;
  posix_spawn_file_actions_t v5 = 0;
  libc_hooks_will_read_cstring(a1);
  libc_hooks_will_read_cstring((uint64_t)v12);
  if (!v12)
  {
LABEL_2:
    *__error() = 22;
    return 0;
  }
  if (!strcmp(v12, "r+"))
  {
    int v8 = 1;
    sigaction v12 = "r+";
    if (socketpair(1, 1, 0, &v17) < 0) {
      return 0;
    }
  }
  else
  {
    int v8 = 0;
    if (*v12 != 114 && *v12 != 119 || v12[1]) {
      goto LABEL_2;
    }
    if (pipe(&v17) < 0) {
      return 0;
    }
  }
  if (*v12 == 114)
  {
    sigaction v10 = (FILE *)fdopen_DARWIN_EXTSN(v17, v12);
    int v7 = v18;
  }
  else
  {
    sigaction v10 = (FILE *)fdopen_DARWIN_EXTSN(v18, v12);
    int v7 = v17;
  }
  if (v10)
  {
    sigaction v11 = (void *)malloc_type_malloc();
    if (v11)
    {
      int v4 = posix_spawn_file_actions_init(&v5);
      if (v4) {
        goto LABEL_21;
      }
      if (*v12 == 114)
      {
        posix_spawn_file_actions_addclose(&v5, v17);
        if (v18 == 1)
        {
          if (v8) {
            posix_spawn_file_actions_adddup2(&v5, v18, 0);
          }
        }
        else
        {
          posix_spawn_file_actions_adddup2(&v5, v18, 1);
          posix_spawn_file_actions_addclose(&v5, v18);
          if (v8) {
            posix_spawn_file_actions_adddup2(&v5, 1, 0);
          }
        }
      }
      else
      {
        if (v17)
        {
          posix_spawn_file_actions_adddup2(&v5, v17, 0);
          posix_spawn_file_actions_addclose(&v5, v17);
        }
        posix_spawn_file_actions_addclose(&v5, v18);
      }
      pthread_mutex_lock(&__popen_pidlist_mutex);
      for (uint64_t i = __popen_pidlist; i; uint64_t i = *(void *)i)
        posix_spawn_file_actions_addclose(&v5, *(_DWORD *)(i + 16));
      *(void *)&long long v15 = "sh";
      *((void *)&v15 + 1) = "-c";
      long long v16 = (unint64_t)v13;
      int v2 = _NSGetEnviron();
      int v4 = posix_spawn(&v9, "/bin/sh", &v5, 0, (char *const *)&v15, *v2);
      pthread_mutex_unlock(&__popen_pidlist_mutex);
      posix_spawn_file_actions_destroy(&v5);
      if (v4 == 12 || v4 == 35)
      {
LABEL_21:
        fclose(v10);
        close_NOCANCEL();
        free(v11);
        *__error() = v4;
        return 0;
      }
      else
      {
        if (v4) {
          pid_t v9 = -1;
        }
        if (*v12 == 114) {
          *((_DWORD *)v11 + 4) = v17;
        }
        else {
          *((_DWORD *)v11 + 4) = v18;
        }
        close_NOCANCEL();
        v11[1] = v10;
        *((_DWORD *)v11 + 5) = v9;
        pthread_mutex_lock(&__popen_pidlist_mutex);
        *sigaction v11 = __popen_pidlist;
        __popen_pidlist = (uint64_t)v11;
        pthread_mutex_unlock(&__popen_pidlist_mutex);
        fwide(v10, -1);
        return v10;
      }
    }
    else
    {
      fclose(v10);
      close_NOCANCEL();
      return 0;
    }
  }
  else
  {
    close_NOCANCEL();
    close_NOCANCEL();
    return 0;
  }
}

uint64_t *fdopen_DARWIN_EXTSN(int a1, char *a2)
{
  int v8 = a1;
  int v7 = a2;
  posix_spawnattr_t v6 = 0;
  int v5 = 0;
  int v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a2);
  if (v8 < 0x8000)
  {
    int v5 = __sflags(v7, &v4);
    if (v5)
    {
      int v3 = fcntl_NOCANCEL();
      if (v3 >= 0)
      {
        if ((v3 & 3) == 2 || (v3 & 3) == (v4 & 3))
        {
          posix_spawnattr_t v6 = __sfp(0);
          if (v6)
          {
            *((_WORD *)v6 + 8) = v5;
            if ((v4 & 8) != 0 && (v3 & 8) == 0) {
              *((_WORD *)v6 + 8) |= 0x100u;
            }
            *((_WORD *)v6 + 9) = v8;
            unsigned char v6[6] = (uint64_t)v6;
            v6[8] = (uint64_t)__sread;
            v6[10] = (uint64_t)__swrite;
            v6[9] = (uint64_t)__sseek;
            v6[7] = (uint64_t)__sclose;
            return v6;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          *__error() = 22;
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 24;
    return 0;
  }
}

uint64_t *fopen_DARWIN_EXTSN(uint64_t a1, char *a2)
{
  uint64_t v8 = a1;
  int v7 = a2;
  posix_spawnattr_t v6 = 0;
  int v5 = 0;
  int v4 = 0;
  int v3 = 0;
  libc_hooks_will_read_cstring(a1);
  libc_hooks_will_read_cstring((uint64_t)v7);
  int v4 = __sflags(v7, &v3);
  if (!v4) {
    return 0;
  }
  posix_spawnattr_t v6 = __sfp(0);
  if (!v6) {
    return 0;
  }
  int v5 = open_NOCANCEL();
  if (v5 >= 0)
  {
    if (v5 < 0x8000)
    {
      *((_WORD *)v6 + 9) = v5;
      *((_WORD *)v6 + 8) = v4;
      unsigned char v6[6] = (uint64_t)v6;
      v6[8] = (uint64_t)__sread;
      v6[10] = (uint64_t)__swrite;
      v6[9] = (uint64_t)__sseek;
      v6[7] = (uint64_t)__sclose;
      if ((v3 & 8) != 0) {
        _sseek((uint64_t)v6, 0, 2u);
      }
      return v6;
    }
    else
    {
      *((_WORD *)v6 + 8) = 0;
      close_NOCANCEL();
      *__error() = 24;
      return 0;
    }
  }
  else
  {
    __sfprelease((uint64_t)v6);
    return 0;
  }
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  int v25 = a1;
  uint64_t v24 = a2;
  bzero(v32, 0x200uLL);
  memset(&__b, 0, sizeof(__b));
  BOOL v14 = 0;
  dev_t v12 = 0;
  bzero(&v28, 0x200uLL);
  __darwin_ino64_t st_ino = 0;
  if (!v25)
  {
    *__error() = 22;
    return 0;
  }
  if (!*v25)
  {
    *__error() = 2;
    return 0;
  }
  if (v24)
  {
    mbstate_t __dst = v24;
  }
  else
  {
    mbstate_t __dst = (char *)malloc_type_malloc();
    if (!__dst) {
      return 0;
    }
  }
  if (!realpath_DARWIN_EXTSN_rootdev_inited)
  {
    realpath_DARWIN_EXTSN_rootdev_int inited = 1;
    if (stat("/", &__b) < 0) {
      goto LABEL_12;
    }
    realpath_DARWIN_EXTSN_rootdev = __b.st_dev;
  }
  __error();
  unsigned int v16 = 0;
  if (*v25 == 47)
  {
    char *__dst = 47;
    __dst[1] = 0;
    if (!v25[1]) {
      return __dst;
    }
    size_t v18 = 1;
    size_t v19 = strlcpy(v31, v25 + 1, 0x400uLL);
  }
  else
  {
    if (!__private_getcwd(__dst, 1024, 1))
    {
      strlcpy(__dst, ".", 0x400uLL);
      goto LABEL_12;
    }
    size_t v18 = strlen(__dst);
    size_t v19 = strlcpy(v31, v25, 0x400uLL);
  }
  if (v19 < 0x400 && v18 < 0x400)
  {
    if (v18 > 1)
    {
      if (stat(__dst, &__b) >= 0)
      {
        dev_t st_dev = __b.st_dev;
        goto LABEL_30;
      }
      goto LABEL_12;
    }
    dev_t st_dev = realpath_DARWIN_EXTSN_rootdev;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            do
            {
LABEL_30:
              if (!v19)
              {
                if (v18 > 1 && __dst[v18 - 1] == 47) {
                  __dst[v18 - 1] = 0;
                }
                return __dst;
              }
              __int32 v22 = strchr(v31, 47);
              if (v22) {
                size_t v5 = v22 - v31;
              }
              else {
                size_t v5 = v19;
              }
              memcpy(v30, v31, v5);
              v30[v5] = 0;
              if (v22)
              {
                v19 -= v5 + 1;
                memmove(v31, v22 + 1, v19 + 1);
              }
              else
              {
                v31[0] = 0;
                size_t v19 = 0;
              }
              if (__dst[v18 - 1] != 47)
              {
                if (v18 + 1 >= 0x400) {
                  goto LABEL_93;
                }
                size_t v2 = v18++;
                __dst[v2] = 47;
                __dst[v18] = 0;
              }
            }
            while (!v30[0] || !strcmp(v30, "."));
            if (strcmp(v30, "..")) {
              break;
            }
            if (v18 > 1)
            {
              __dst[v18 - 1] = 0;
              int v20 = strrchr(__dst, 47) + 1;
              char *v20 = 0;
              size_t v18 = v20 - __dst;
            }
          }
          size_t v17 = v18;
          size_t v18 = strlcat(__dst, v30, 0x400uLL);
          if (v18 >= 0x400) {
            goto LABEL_93;
          }
          if (getattrlist(__dst, &_rp_alist, v32, 0x41CuLL, 1u))
          {
            if (*__error() == 45 || *__error() == 22)
            {
              int v15 = lstat(__dst, &__b);
              if (!v15)
              {
                BOOL v14 = (__b.st_mode & 0xF000) == 40960;
                dev_t v12 = __b.st_dev;
                __darwin_ino64_t st_ino = __b.st_ino;
              }
            }
            else
            {
              int v15 = -1;
            }
          }
          else
          {
            int v15 = 1;
            BOOL v14 = v33[3] == 5;
            dev_t v12 = v33[2];
            __darwin_ino64_t st_ino = v33[4];
          }
          if (v15 < 0) {
            goto LABEL_12;
          }
          if (v12 == st_dev) {
            break;
          }
          dev_t st_dev = v12;
          if (statfs(__dst, &v28) || lstat(v28.f_mntonname, &__b) || v12 != __b.st_dev || st_ino != __b.st_ino) {
            break;
          }
          int v6 = 1;
          strcpy(__s, v28.f_mntonname);
          do
          {
            int v7 = strrchr(__s, 47);
            if (!v7)
            {
              int v6 = 0;
              goto LABEL_70;
            }
            if (v7 <= __s) {
              goto LABEL_70;
            }
            *int v7 = 0;
          }
          while (lstat(__s, &__b) >= 0 && (__b.st_mode & 0xF000) == 0x4000);
          int v6 = 0;
LABEL_70:
          if (!v6) {
            break;
          }
          size_t v18 = strlcpy(__dst, v28.f_mntonname, 0x400uLL);
        }
        if (v14) {
          break;
        }
        if (v15)
        {
          __dst[v17] = 0;
          size_t v18 = strlcat(__dst, (const char *)v33 + v33[0], 0x400uLL);
          if (v18 >= 0x400) {
            goto LABEL_93;
          }
        }
      }
      unsigned int v3 = v16++;
      if (v3 > 0x20)
      {
        *__error() = 62;
        goto LABEL_12;
      }
      ssize_t v13 = readlink(__dst, __source, 0x400uLL);
      if (v13 <= 0 || (unint64_t)v13 >= 0x400) {
        break;
      }
      __source[v13] = 0;
      if (__source[0] == 47)
      {
        __dst[1] = 0;
        size_t v18 = 1;
        dev_t st_dev = realpath_DARWIN_EXTSN_rootdev;
      }
      else
      {
        int v21 = strrchr(__dst, 47) + 1;
        *int v21 = 0;
        size_t v18 = v21 - __dst;
      }
      if (v22)
      {
        if (__source[v13 - 1] != 47)
        {
          if ((unint64_t)(v13 + 1) >= 0x400) {
            goto LABEL_93;
          }
          __source[v13] = 47;
          __source[v13 + 1] = 0;
        }
        if (strlcat(__source, v31, 0x400uLL) >= 0x400) {
          goto LABEL_93;
        }
      }
      size_t v19 = strlcpy(v31, __source, 0x400uLL);
    }
    if (v13 < 0) {
      goto LABEL_12;
    }
    if (!v13)
    {
      *__error() = 2;
      goto LABEL_12;
    }
  }
LABEL_93:
  *__error() = 63;
LABEL_12:
  if (!v24)
  {
    int v8 = *__error();
    free(__dst);
    *__error() = v8;
  }
  return 0;
}

size_t __strlcat_chk(const char *a1, const char *a2, size_t a3, size_t a4)
{
  if (a4 < a3) {
    __chk_fail_overflow();
  }
  size_t v6 = strlen(a2);
  size_t v5 = strnlen(a1, a3);
  if (v5 == a3) {
    return a3 + v6;
  }
  if (v6 >= a3 - v5)
  {
    __chk_overlap((unint64_t)a1, a3, (unint64_t)a2, a3 - v5 - 1);
    memcpy((void *)&a1[v5], a2, a3 - v5 - 1);
    a1[a3 - 1] = 0;
  }
  else
  {
    __chk_overlap((unint64_t)a1, v6 + v5 + 1, (unint64_t)a2, v6 + 1);
    memcpy((void *)&a1[v5], a2, v6 + 1);
  }
  return v6 + v5;
}

void __chk_fail_overflow()
{
}

void __chk_fail_overlap()
{
}

unint64_t __chk_overlap(unint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v4 = 1;
  if (a2) {
    BOOL v4 = a4 == 0;
  }
  if (!v4)
  {
    if (result == a3) {
      __chk_fail_overlap();
    }
    if (result >= a3)
    {
      if (a3 + a4 > result) {
        __chk_fail_overlap();
      }
    }
    else if (result + a2 > a3)
    {
      __chk_fail_overlap();
    }
  }
  return result;
}

void *__memset_chk(void *a1, int a2, size_t a3, size_t a4)
{
  if (a4 < a3) {
    __chk_fail_overflow();
  }
  memset(a1, a2, a3);
  return a1;
}

size_t __strlcpy_chk(char *a1, const char *a2, size_t a3, size_t a4)
{
  size_t __size = a3;
  if (a4 < a3) {
    __chk_fail_overflow();
  }
  size_t v5 = strlcpy(a1, a2, a3);
  if (v5 < __size) {
    size_t __size = v5 + 1;
  }
  __chk_overlap((unint64_t)a1, __size, (unint64_t)a2, __size);
  return v5;
}

const char *__strncat_chk(const char *a1, const char *a2, size_t a3, unint64_t a4)
{
  size_t v6 = strlen(a1);
  size_t v5 = strnlen(a2, a3);
  if (a4 < v6 + v5 + 1) {
    __chk_fail_overflow();
  }
  if (__chk_assert_no_overlap) {
    __chk_overlap((unint64_t)a1, v6 + v5 + 1, (unint64_t)a2, v5 + 1);
  }
  memcpy((void *)&a1[v6], a2, v5);
  a1[v6 + v5] = 0;
  return a1;
}

unint64_t __strncpy_chk(unint64_t a1, const char *a2, size_t a3, size_t a4)
{
  if (a4 < a3) {
    __chk_fail_overflow();
  }
  size_t v5 = &stpncpy((char *)a1, a2, a3)[-a1 + 1];
  if (v5 == (char *)(a3 + 1)) {
    --v5;
  }
  if (__chk_assert_no_overlap) {
    __chk_overlap(a1, (uint64_t)v5, (unint64_t)a2, (uint64_t)v5);
  }
  return a1;
}

void *__memmove_chk(void *a1, const void *a2, size_t a3, size_t a4)
{
  if (a4 < a3) {
    __chk_fail_overflow();
  }
  memmove(a1, a2, a3);
  return a1;
}

unint64_t __strcpy_chk(unint64_t a1, const char *a2, unint64_t a3)
{
  BOOL v4 = &stpcpy((char *)a1, a2)[-a1 + 1];
  if (a3 < (unint64_t)v4) {
    __chk_fail_overflow();
  }
  if (__chk_assert_no_overlap) {
    __chk_overlap(a1, (uint64_t)v4, (unint64_t)a2, (uint64_t)v4);
  }
  return a1;
}

unsigned char *__memccpy_chk(void *a1, const void *a2, int a3, size_t a4, size_t a5)
{
  __int n = a4;
  if (a5 < a4) {
    __chk_fail_overflow();
  }
  size_t v6 = memccpy(a1, a2, a3, a4);
  if (v6) {
    __int n = v6 - (unsigned char *)a1;
  }
  __chk_overlap((unint64_t)a1, __n, (unint64_t)a2, __n);
  return v6;
}

int __snprintf_chk(char *a1, size_t a2, int a3, size_t a4, const char *a5, ...)
{
  va_start(va, a5);
  if (a4 < a2) {
    __chk_fail_overflow();
  }
  return vsnprintf(a1, a2, a5, va);
}

uint64_t __snprintf_object_size_chk(char *a1, size_t a2, size_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a2 < a3) {
    __chk_fail_overflow();
  }
  return vsnprintf(a1, a3, a4, &a9);
}

const char *__strcat_chk(const char *a1, const char *a2, unint64_t a3)
{
  size_t v5 = strlen(a1);
  size_t v4 = strlen(a2);
  if (a3 < v5 + v4 + 1) {
    __chk_fail_overflow();
  }
  if (__chk_assert_no_overlap) {
    __chk_overlap((unint64_t)a1, v5 + v4 + 1, (unint64_t)a2, v4 + 1);
  }
  memcpy((void *)&a1[v5], a2, v4 + 1);
  return a1;
}

int __vsprintf_chk(char *a1, int a2, size_t a3, const char *a4, va_list a5)
{
  if (a3 > 0x7FFFFFFF) {
    return vsprintf(a1, a4, a5);
  }
  int v7 = vsnprintf(a1, a3, a4, a5);
  BOOL v6 = 0;
  if (v7 >= 0) {
    BOOL v6 = v7 >= a3;
  }
  if (v6) {
    __chk_fail_overflow();
  }
  return v7;
}

char *__stpcpy_chk(char *a1, const char *a2, unint64_t a3)
{
  size_t v5 = stpcpy(a1, a2);
  unint64_t v4 = v5 - a1 + 1;
  if (a3 < v4) {
    __chk_fail_overflow();
  }
  if (__chk_assert_no_overlap) {
    __chk_overlap((unint64_t)a1, v4, (unint64_t)a2, v4);
  }
  return v5;
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  va_start(va, a4);
  if (a3 > 0x7FFFFFFF) {
    return vsprintf(a1, a4, va);
  }
  int v6 = vsnprintf(a1, a3, a4, va);
  BOOL v5 = 0;
  if (v6 >= 0) {
    BOOL v5 = v6 >= a3;
  }
  if (v5) {
    __chk_fail_overflow();
  }
  return v6;
}

uint64_t __sprintf_object_size_chk(char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a2 <= 0x7FFFFFFF)
  {
    int v11 = vsnprintf(a1, a2, a3, &a9);
    BOOL v10 = 0;
    if (v11 >= 0) {
      BOOL v10 = v11 >= a2;
    }
    if (v10) {
      __chk_fail_overflow();
    }
  }
  else
  {
    return vsprintf(a1, a3, &a9);
  }
  return v11;
}

void *__memcpy_chk(void *a1, const void *a2, size_t a3, size_t a4)
{
  if (a4 < a3) {
    __chk_fail_overflow();
  }
  memcpy(a1, a2, a3);
  return a1;
}

char *__stpncpy_chk(char *a1, const char *a2, size_t a3, size_t a4)
{
  if (a4 < a3) {
    __chk_fail_overflow();
  }
  BOOL v5 = stpncpy(a1, a2, a3);
  uint64_t v6 = v5 - a1 + 1;
  if (v6 == a3 + 1) {
    uint64_t v6 = v5 - a1;
  }
  if (__chk_assert_no_overlap) {
    __chk_overlap((unint64_t)a1, v6, (unint64_t)a2, v6);
  }
  return v5;
}

int __vsnprintf_chk(char *a1, size_t a2, int a3, size_t a4, const char *a5, va_list a6)
{
  if (a4 < a2) {
    __chk_fail_overflow();
  }
  return vsnprintf(a1, a2, a5, a6);
}

uint64_t _os_crash(uint64_t result)
{
  qword_E9898 = result;
  return result;
}

BOOL _os_assumes_log(uint64_t a1)
{
  uint64_t v3 = a1;
  memset(__b, 0, sizeof(__b));
  uint64_t v10 = v3;
  pid_t v9 = &v2;
  int v8 = __b;
  size_t __size = 256;
  uint64_t v6 = 0;
  uint64_t v5 = 0;
  memset(v15, 0, sizeof(v15));
  uint64_t v2 = 0;
  snprintf(__str, 0x40uLL, "%s:%lu", v15, 0);
  snprintf(v13, 0x18uLL, "0x%llx", v10);
  uint64_t v4 = 32;
  _os_get_build(v12, 0x20uLL);
  snprintf(v8, __size, "assertion failed: %s: %s + %lu [%s]: %s", v12, v6, v5, v15, v13);
  _os_log_redirect(v2, (uint64_t)__b);
  BOOL result = _os_abort_on_assumes();
  if (result)
  {
    _os_crash((uint64_t)__b);
    __break(1u);
    JUMPOUT(0xD2A90);
  }
  return result;
}

char *_os_assert_log(uint64_t a1)
{
  void v2[2] = a1;
  v2[1] = 0;
  uint64_t v8 = a1;
  int v7 = v2;
  uint64_t v6 = __s1;
  size_t __size = 256;
  uint64_t v4 = 0;
  uint64_t v3 = 0;
  memset(__b, 0, sizeof(__b));
  v2[0] = 0;
  snprintf(__str, 0x40uLL, "%s:%lu", __b, 0);
  snprintf(v11, 0x18uLL, "0x%llx", v8);
  v2[3] = 32;
  _os_get_build(v10, 0x20uLL);
  snprintf(v6, __size, "assertion failed: %s: %s + %lu [%s]: %s", v10, v4, v3, __b, v11);
  _os_log_redirect(v2[0], (uint64_t)__s1);
  return strdup(__s1);
}

BOOL _os_assumes_log_ctx(void (*a1)(uint64_t, uint64_t, unsigned char *), uint64_t a2, uint64_t a3)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  uint64_t v6 = a3;
  memset(__b, 0, sizeof(__b));
  uint64_t v15 = v6;
  BOOL v14 = &v5;
  ssize_t v13 = __b;
  size_t __size = 256;
  int v11 = 0;
  uint64_t v10 = 0;
  memset(v20, 0, sizeof(v20));
  uint64_t v5 = 0;
  snprintf(__str, 0x40uLL, "%s:%lu", v20, 0);
  snprintf(v18, 0x18uLL, "0x%llx", v15);
  uint64_t v9 = 32;
  _os_get_build(v17, 0x20uLL);
  snprintf(v13, __size, "assertion failed: %s: %s + %lu [%s]: %s", v17, v11, v10, v20, v18);
  uint64_t v4 = _simple_asl_msg_new();
  v8(v4, v7, __b);
  _simple_sfree();
  BOOL result = _os_abort_on_assumes();
  if (result)
  {
    _os_crash((uint64_t)__b);
    __break(1u);
    JUMPOUT(0xD2E00);
  }
  return result;
}

char *_os_assert_log_ctx(void (*a1)(uint64_t, uint64_t, char *), uint64_t a2, uint64_t a3)
{
  uint64_t v8 = a1;
  uint64_t v7 = a2;
  uint64_t v6 = a3;
  v5[1] = 0;
  memset(__b, 0, sizeof(__b));
  uint64_t v15 = v6;
  BOOL v14 = v5;
  ssize_t v13 = __b;
  size_t __size = 256;
  int v11 = 0;
  uint64_t v10 = 0;
  memset(v20, 0, sizeof(v20));
  v5[0] = 0;
  snprintf(__str, 0x40uLL, "%s:%lu", v20, 0);
  snprintf(v18, 0x18uLL, "0x%llx", v15);
  uint64_t v9 = 32;
  _os_get_build(v17, 0x20uLL);
  snprintf(v13, __size, "assertion failed: %s: %s + %lu [%s]: %s", v17, v11, v10, v20, v18);
  uint64_t v4 = _simple_asl_msg_new();
  v8(v4, v7, __b);
  _simple_sfree();
  return strdup(__b);
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  if (a1 == (const char *)-1)
  {
    _simple_dprintf();
    if (!qword_E9898)
    {
      if (_simple_salloc())
      {
LABEL_14:
        _simple_sprintf();
        qword_E9898 = _simple_string();
        goto LABEL_16;
      }
      qword_E9898 = (uint64_t)a4;
    }
  }
  else if (a1)
  {
    _simple_dprintf();
    if (qword_E9898) {
      goto LABEL_16;
    }
    if (_simple_salloc()) {
      goto LABEL_14;
    }
    qword_E9898 = (uint64_t)a4;
  }
  else
  {
    _simple_dprintf();
    if (!qword_E9898)
    {
      if (_simple_salloc()) {
        goto LABEL_14;
      }
      qword_E9898 = (uint64_t)a4;
    }
  }
LABEL_16:
  abort();
}

void err(int a1, const char *a2, ...)
{
  va_start(va, a2);
  uint64_t v2 = __error();
  verrc(a1, *v2, a2, va);
}

void verrc(int a1, int a2, const char *a3, __darwin_va_list a4)
{
  if (!_e_err_file) {
    err_set_file(0);
  }
  uint64_t v7 = (FILE *)_e_err_file;
  uint64_t v4 = getprogname();
  fprintf(v7, "%s: ", v4);
  if (a3)
  {
    _e_visprintf((FILE *)_e_err_file, a3, a4);
    fprintf((FILE *)_e_err_file, ": ");
  }
  uint64_t v6 = (FILE *)_e_err_file;
  uint64_t v5 = strerror(a2);
  fprintf(v6, "%s\n", v5);
  if (_e_err_exit)
  {
    if (_e_err_exit == 1) {
      (*((void (**)(uint64_t (*)(void), void))off_F5460 + 2))(off_F5460, a1);
    }
    else {
      off_F5460(a1);
    }
  }
  exit(a1);
}

void verr(int a1, const char *a2, __darwin_va_list a3)
{
  uint64_t v3 = __error();
  verrc(a1, *v3, a2, a3);
}

void errc(int a1, int a2, const char *a3, ...)
{
  va_start(va, a3);
  verrc(a1, a2, a3, va);
}

void errx(int a1, const char *a2, ...)
{
  va_start(va, a2);
  verrx(a1, a2, va);
}

void verrx(int a1, const char *a2, __darwin_va_list a3)
{
  if (!_e_err_file) {
    err_set_file(0);
  }
  uint64_t v4 = (FILE *)_e_err_file;
  uint64_t v3 = getprogname();
  fprintf(v4, "%s: ", v3);
  if (a2) {
    _e_visprintf((FILE *)_e_err_file, a2, a3);
  }
  fprintf((FILE *)_e_err_file, "\n");
  if (_e_err_exit)
  {
    if (_e_err_exit == 1) {
      (*((void (**)(uint64_t (*)(void), void))off_F5460 + 2))(off_F5460, a1);
    }
    else {
      off_F5460(a1);
    }
  }
  exit(a1);
}

void warn(const char *a1, ...)
{
  va_start(va, a1);
  sigset_t v1 = __error();
  vwarnc(*v1, a1, va);
}

void vwarnc(int a1, const char *a2, __darwin_va_list a3)
{
  if (!_e_err_file) {
    err_set_file(0);
  }
  uint64_t v6 = (FILE *)_e_err_file;
  uint64_t v3 = getprogname();
  fprintf(v6, "%s: ", v3);
  if (a2)
  {
    _e_visprintf((FILE *)_e_err_file, a2, a3);
    fprintf((FILE *)_e_err_file, ": ");
  }
  uint64_t v5 = (FILE *)_e_err_file;
  uint64_t v4 = strerror(a1);
  fprintf(v5, "%s\n", v4);
}

void vwarn(const char *a1, __darwin_va_list a2)
{
  uint64_t v2 = __error();
  vwarnc(*v2, a1, a2);
}

void warnc(int a1, const char *a2, ...)
{
  va_start(va, a2);
  vwarnc(a1, a2, va);
}

void warnx(const char *a1, ...)
{
  va_start(va, a1);
  vwarnx(a1, va);
}

void vwarnx(const char *a1, __darwin_va_list a2)
{
  if (!_e_err_file) {
    err_set_file(0);
  }
  uint64_t v3 = (FILE *)_e_err_file;
  uint64_t v2 = getprogname();
  fprintf(v3, "%s: ", v2);
  if (a1) {
    _e_visprintf((FILE *)_e_err_file, a1, a2);
  }
  fprintf((FILE *)_e_err_file, "\n");
}

void perror(const char *a1)
{
  uint64_t v2 = (char **)v4;
  if (a1 && *a1)
  {
    v4[0] = a1;
    v4[1] = strlen(a1);
    void v4[2] = ": ";
    void v4[3] = 2;
    uint64_t v2 = (char **)&v5;
  }
  sigset_t v1 = __error();
  strerror_r(*v1, __strerrbuf, 0x800uLL);
  *uint64_t v2 = __strerrbuf;
  v2[1] = (char *)strlen(*v2);
  uint64_t v3 = v2 + 2;
  *uint64_t v3 = "\n";
  v3[1] = 1;
  flockfile(__stderrp);
  __sflush((uint64_t)__stderrp);
  writev_NOCANCEL();
  __stderrp->_flags &= ~0x1000u;
  funlockfile(__stderrp);
}

size_t regerror(int a1, const regex_t *a2, char *a3, size_t a4)
{
  uint64_t v7 = a1 & 0xFFFFFEFF;
  if (a1 == 255)
  {
    __s = (char *)regatoi((uint64_t)a2, __dst);
    size_t v4 = strlen(__s);
  }
  else
  {
    for (uint64_t i = (char *)&rerrs; *(_DWORD *)i && *(_DWORD *)i != v7; i += 24)
      ;
    if ((a1 & 0x100) != 0)
    {
      if (*(_DWORD *)i) {
        strcpy(__dst, *((const char **)i + 1));
      }
      else {
        sprintf(__dst, "REG_0x%x", v7);
      }
      __s = __dst;
      size_t v4 = strlen(__dst);
    }
    else
    {
      __s = (char *)*((void *)i + 2);
      size_t v4 = strlen(__s);
    }
  }
  size_t v8 = v4 + 1;
  if (a4)
  {
    if (a4 <= v8)
    {
      strncpy(a3, __s, a4 - 1);
      a3[a4 - 1] = 0;
    }
    else
    {
      strcpy(a3, __s);
    }
  }
  return v8;
}

void abort(void)
{
  uint64_t v2 = 0;
  *(void *)uint64_t v3 = 0;
  if (!qword_E9898) {
    qword_E9898 = (uint64_t)"abort() called";
  }
  pthread_t v1 = pthread_self();
  if (__cleanup) {
    _cleanup();
  }
  int v6 = 6;
  int v5 = 11;
  int v4 = 10;
  v3[0] = -1569;
  sigset_t v0 = -1;
  sigprocmask(3, &v0, 0);
  __pthread_workqueue_setkill();
  pthread_sigmask(3, v3, 0);
  pthread_kill(v1, 6);
  usleep_NOCANCEL(0x2710u);
  __abort();
}

void __abort()
{
  v2.__sigaction_u.__sa_handlesize_t r = 0;
  *(void *)&v2.sa_masint k = 0;
  if (!qword_E9898) {
    qword_E9898 = (uint64_t)"__abort() called";
  }
  pthread_t v1 = pthread_self();
  v2.__sigaction_u.__sa_handlesize_t r = 0;
  v2.sa_int flags = 0;
  v2.sa_masint k = -1;
  sigaction(6, &v2, 0);
  int v5 = 6;
  v2.sa_mask &= ~0x20u;
  sigset_t v0 = -1;
  sigprocmask(3, &v0, 0);
  __pthread_workqueue_setkill();
  pthread_sigmask(3, &v2.sa_mask, 0);
  pthread_kill(v1, 6);
  usleep_NOCANCEL(0x2710u);
  int v4 = 4;
  int v3 = 5;
  v2.sa_masint k = -25;
  sigprocmask(3, &v2.sa_mask, 0);
  __break(1u);
}

void abort_report_np(uint64_t a1)
{
  if (_simple_salloc())
  {
    _simple_vsprintf();
    qword_E9898 = _simple_string();
  }
  else
  {
    qword_E9898 = a1;
  }
  abort();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return __Block_copy(aBlock);
}

void _Block_release(const void *aBlock)
{
}

uint64_t __commpage_gettimeofday()
{
  return ___commpage_gettimeofday();
}

int *__error(void)
{
  return ___error();
}

void __exit(int a1)
{
}

uint64_t __fcntl()
{
  return ___fcntl();
}

uint64_t __fcntl_nocancel()
{
  return ___fcntl_nocancel();
}

uint64_t __fork()
{
  return ___fork();
}

int __fpclassifyd(double a1)
{
  return ___fpclassifyd(a1);
}

uint64_t __getdirentries64()
{
  return ___getdirentries64();
}

uint64_t __gettimeofday()
{
  return ___gettimeofday();
}

uint64_t __kill()
{
  return ___kill();
}

uint64_t __open()
{
  return ___open();
}

uint64_t __open_nocancel()
{
  return ___open_nocancel();
}

uint64_t __platform_sigaction()
{
  return ___platform_sigaction();
}

uint64_t __pthread_workqueue_setkill()
{
  return ___pthread_workqueue_setkill();
}

uint64_t __recvfrom()
{
  return ___recvfrom();
}

uint64_t __recvfrom_nocancel()
{
  return ___recvfrom_nocancel();
}

uint64_t __semwait_signal()
{
  return ___semwait_signal();
}

uint64_t __semwait_signal_nocancel()
{
  return ___semwait_signal_nocancel();
}

uint64_t __sendto()
{
  return ___sendto();
}

uint64_t __sendto_nocancel()
{
  return ___sendto_nocancel();
}

uint64_t __settimeofday()
{
  return ___settimeofday();
}

uint64_t __sigaltstack()
{
  return ___sigaltstack();
}

uint64_t __sysctl()
{
  return ___sysctl();
}

uint64_t __thread_selfusage()
{
  return ___thread_selfusage();
}

uint64_t __wait4()
{
  return ___wait4();
}

uint64_t __wait4_nocancel()
{
  return ___wait4_nocancel();
}

uint64_t _dyld_images_for_addresses()
{
  return __dyld_images_for_addresses();
}

void _exit(int a1)
{
}

uint64_t _os_alloc_once()
{
  return __os_alloc_once();
}

uint64_t _os_once()
{
  return __os_once();
}

uint64_t _platform_memmove()
{
  return __platform_memmove();
}

uint64_t _simple_asl_log()
{
  return __simple_asl_log();
}

uint64_t _simple_asl_log_prog()
{
  return __simple_asl_log_prog();
}

uint64_t _simple_asl_msg_new()
{
  return __simple_asl_msg_new();
}

uint64_t _simple_dprintf()
{
  return __simple_dprintf();
}

uint64_t _simple_getenv()
{
  return __simple_getenv();
}

uint64_t _simple_salloc()
{
  return __simple_salloc();
}

uint64_t _simple_sappend()
{
  return __simple_sappend();
}

uint64_t _simple_sfree()
{
  return __simple_sfree();
}

uint64_t _simple_sprintf()
{
  return __simple_sprintf();
}

uint64_t _simple_string()
{
  return __simple_string();
}

uint64_t _simple_vsprintf()
{
  return __simple_vsprintf();
}

int access(const char *a1, int a2)
{
  return _access(a1, a2);
}

void bzero(void *a1, size_t a2)
{
  while (1)
    ;
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return _calloc(__count, __size);
}

uint64_t ccrng()
{
  return _ccrng();
}

uint64_t ccrng_uniform()
{
  return _ccrng_uniform();
}

int chdir(const char *a1)
{
  return _chdir(a1);
}

kern_return_t clock_get_time(clock_serv_t clock_serv, mach_timespec_t *cur_time)
{
  return _clock_get_time(clock_serv, cur_time);
}

uint64_t close_NOCANCEL()
{
  return _close_NOCANCEL();
}

int dup2(int a1, int a2)
{
  return _dup2(a1, a2);
}

int execve(const char *__file, char *const *__argv, char *const *__envp)
{
  return _execve(__file, __argv, __envp);
}

int fchdir(int a1)
{
  return _fchdir(a1);
}

int fchmodat(int a1, const char *a2, mode_t a3, int a4)
{
  return _fchmodat(a1, a2, a3, a4);
}

uint64_t fcntl_NOCANCEL()
{
  return _fcntl_NOCANCEL();
}

int fegetenv(fenv_t *a1)
{
  return _fegetenv(a1);
}

int fegetround(void)
{
  return _fegetround();
}

int fesetenv(const fenv_t *a1)
{
  return _fesetenv(a1);
}

int ffs(int a1)
{
  return _ffs(a1);
}

int ffsctl(int a1, unint64_t a2, void *a3, unsigned int a4)
{
  return _ffsctl(a1, a2, a3, a4);
}

int flsl(uint64_t a1)
{
  return _flsl(a1);
}

void free(void *a1)
{
}

int fsctl(const char *a1, unint64_t a2, void *a3, unsigned int a4)
{
  return _fsctl(a1, a2, a3, a4);
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

int fstatat(int a1, const char *a2, stat *a3, int a4)
{
  return _fstatat(a1, a2, a3, a4);
}

int fstatfs(int a1, statfs *a2)
{
  return _fstatfs(a1, a2);
}

uint64_t fsync_NOCANCEL()
{
  return _fsync_NOCANCEL();
}

int ftruncate(int a1, off_t a2)
{
  return _ftruncate(a1, a2);
}

int getattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return _getattrlist(a1, a2, a3, a4, a5);
}

int getattrlistbulk(int a1, void *a2, void *a3, size_t a4, uint64_t a5)
{
  return _getattrlistbulk(a1, a2, a3, a4, a5);
}

int getdtablesize(void)
{
  return _getdtablesize();
}

int getfsstat(statfs *a1, int a2, int a3)
{
  return _getfsstat(a1, a2, a3);
}

pid_t getpgrp(void)
{
  return _getpgrp();
}

pid_t getpid(void)
{
  return _getpid();
}

int getpriority(int a1, id_t a2)
{
  return _getpriority(a1, a2);
}

int getrlimit(int a1, rlimit *a2)
{
  return _getrlimit(a1, a2);
}

int getrusage(int a1, rusage *a2)
{
  return _getrusage(a1, a2);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return _getsockopt(a1, a2, a3, a4, a5);
}

kern_return_t host_get_clock_service(host_t host, clock_id_t clock_id, clock_serv_t *clock_serv)
{
  return _host_get_clock_service(host, clock_id, clock_serv);
}

char *__cdecl index(const char *a1, int a2)
{
  while (1)
    ;
}

int ioctl(int a1, unint64_t a2, ...)
{
  return _ioctl(a1, a2);
}

int issetugid(void)
{
  return _issetugid();
}

int kill(pid_t a1, int a2)
{
  return _kill(a1, a2);
}

off_t lseek(int a1, off_t a2, int a3)
{
  return _lseek(a1, a2, a3);
}

int lstat(const char *a1, stat *a2)
{
  return _lstat(a1, a2);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

uint64_t mach_approximate_time(void)
{
  return _mach_approximate_time();
}

uint64_t mach_boottime_usec()
{
  return _mach_boottime_usec();
}

uint64_t mach_continuous_approximate_time(void)
{
  return _mach_continuous_approximate_time();
}

uint64_t mach_continuous_time(void)
{
  return _mach_continuous_time();
}

char *__cdecl mach_error_string(mach_error_t error_value)
{
  return _mach_error_string(error_value);
}

mach_port_t mach_host_self(void)
{
  return _mach_host_self();
}

kern_return_t mach_port_deallocate(ipc_space_t task, mach_port_name_t name)
{
  return _mach_port_deallocate(task, name);
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

uint64_t malloc_type_calloc()
{
  return _malloc_type_calloc();
}

uint64_t malloc_type_malloc()
{
  return _malloc_type_malloc();
}

uint64_t malloc_type_realloc()
{
  return _malloc_type_realloc();
}

void *__cdecl memccpy(void *__dst, const void *__src, int __c, size_t __n)
{
  while (1)
    ;
}

void *__cdecl memchr(const void *__s, int __c, size_t __n)
{
  while (1)
    ;
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  while (1)
    ;
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  while (1)
    ;
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  while (1)
    ;
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  while (1)
    ;
}

int mkdirat(int a1, const char *a2, mode_t a3)
{
  return _mkdirat(a1, a2, a3);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint64_t open_NOCANCEL()
{
  return _open_NOCANCEL();
}

int open_dprotected_np(const char *a1, int a2, int a3, int a4, ...)
{
  return _open_dprotected_np(a1, a2, a3, a4);
}

uint64_t openat_NOCANCEL()
{
  return _openat_NOCANCEL();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_lock_lock_with_options()
{
  return _os_unfair_lock_lock_with_options();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t pathconf(const char *a1, int a2)
{
  return _pathconf(a1, a2);
}

int pipe(int a1[2])
{
  return _pipe(a1);
}

int posix_spawn(pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  return _posix_spawn(a1, a2, a3, a4, __argv, __envp);
}

int posix_spawn_file_actions_addclose(posix_spawn_file_actions_t *a1, int a2)
{
  return _posix_spawn_file_actions_addclose(a1, a2);
}

int posix_spawn_file_actions_adddup2(posix_spawn_file_actions_t *a1, int a2, int a3)
{
  return _posix_spawn_file_actions_adddup2(a1, a2, a3);
}

int posix_spawn_file_actions_addinherit_np(posix_spawn_file_actions_t *a1, int a2)
{
  return _posix_spawn_file_actions_addinherit_np(a1, a2);
}

int posix_spawn_file_actions_destroy(posix_spawn_file_actions_t *a1)
{
  return _posix_spawn_file_actions_destroy(a1);
}

int posix_spawn_file_actions_init(posix_spawn_file_actions_t *a1)
{
  return _posix_spawn_file_actions_init(a1);
}

int posix_spawnattr_destroy(posix_spawnattr_t *a1)
{
  return _posix_spawnattr_destroy(a1);
}

int posix_spawnattr_init(posix_spawnattr_t *a1)
{
  return _posix_spawnattr_init(a1);
}

int posix_spawnattr_setflags(posix_spawnattr_t *a1, __int16 a2)
{
  return _posix_spawnattr_setflags(a1, a2);
}

int posix_spawnattr_setsigdefault(posix_spawnattr_t *a1, const sigset_t *a2)
{
  return _posix_spawnattr_setsigdefault(a1, a2);
}

int posix_spawnattr_setsigmask(posix_spawnattr_t *a1, const sigset_t *a2)
{
  return _posix_spawnattr_setsigmask(a1, a2);
}

uint64_t pread_NOCANCEL()
{
  return _pread_NOCANCEL();
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return _proc_name(pid, buffer, buffersize);
}

uint64_t pthread_fchdir_np()
{
  return _pthread_fchdir_np();
}

void *__cdecl pthread_get_stackaddr_np(pthread_t a1)
{
  return _pthread_get_stackaddr_np(a1);
}

size_t pthread_get_stacksize_np(pthread_t a1)
{
  return _pthread_get_stacksize_np(a1);
}

void *__cdecl pthread_getspecific(pthread_key_t a1)
{
  return _pthread_getspecific(a1);
}

int pthread_key_create(pthread_key_t *a1, void (__cdecl *a2)(void *))
{
  return _pthread_key_create(a1, a2);
}

uint64_t pthread_key_init_np()
{
  return _pthread_key_init_np();
}

int pthread_kill(pthread_t a1, int a2)
{
  return _pthread_kill(a1, a2);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_trylock(pthread_mutex_t *a1)
{
  return _pthread_mutex_trylock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_once(pthread_once_t *a1, void (*a2)(void))
{
  return _pthread_once(a1, a2);
}

int pthread_rwlock_destroy(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_destroy(a1);
}

int pthread_rwlock_rdlock(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_rdlock(a1);
}

int pthread_rwlock_unlock(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_unlock(a1);
}

int pthread_rwlock_wrlock(pthread_rwlock_t *a1)
{
  return _pthread_rwlock_wrlock(a1);
}

pthread_t pthread_self(void)
{
  return _pthread_self();
}

int pthread_setspecific(pthread_key_t a1, const void *a2)
{
  return _pthread_setspecific(a1, a2);
}

int pthread_sigmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  return _pthread_sigmask(a1, a2, a3);
}

uint64_t pthread_stack_frame_decode_np()
{
  return _pthread_stack_frame_decode_np();
}

void pthread_testcancel(void)
{
}

uint64_t pwrite_NOCANCEL()
{
  return _pwrite_NOCANCEL();
}

uint64_t read_NOCANCEL()
{
  return _read_NOCANCEL();
}

ssize_t readlink(const char *a1, char *a2, size_t a3)
{
  return _readlink(a1, a2, a3);
}

uint64_t reallocarray_DARWIN_EXTSN()
{
  return _reallocarray_DARWIN_EXTSN();
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return _reallocf(__ptr, __size);
}

int rmdir(const char *a1)
{
  return _rmdir(a1);
}

uint64_t select_NOCANCEL()
{
  return _select_NOCANCEL();
}

kern_return_t semaphore_create(task_t task, semaphore_t *semaphore, int policy, int value)
{
  return _semaphore_create(task, semaphore, policy, value);
}

int setattrlist(const char *a1, void *a2, void *a3, size_t a4, unsigned int a5)
{
  return _setattrlist(a1, a2, a3, a4, a5);
}

int setitimer(int a1, const itimerval *a2, itimerval *a3)
{
  return _setitimer(a1, a2, a3);
}

int setpgid(pid_t a1, pid_t a2)
{
  return _setpgid(a1, a2);
}

int setpriority(int a1, id_t a2, int a3)
{
  return _setpriority(a1, a2, a3);
}

int setregid(gid_t a1, gid_t a2)
{
  return _setregid(a1, a2);
}

int setreuid(uid_t a1, uid_t a2)
{
  return _setreuid(a1, a2);
}

int setrlimit(int a1, const rlimit *a2)
{
  return _setrlimit(a1, a2);
}

pid_t setsid(void)
{
  return _setsid();
}

int sigprocmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  return _sigprocmask(a1, a2, a3);
}

int sigsuspend(const sigset_t *a1)
{
  return _sigsuspend(a1);
}

uint64_t sigsuspend_NOCANCEL()
{
  return _sigsuspend_NOCANCEL();
}

int socket(int a1, int a2, int a3)
{
  return _socket(a1, a2, a3);
}

int socketpair(int a1, int a2, int a3, int *a4)
{
  return _socketpair(a1, a2, a3, a4);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

int statfs(const char *a1, statfs *a2)
{
  return _statfs(a1, a2);
}

char *__cdecl strchr(const char *__s, int __c)
{
  while (1)
    ;
}

int strcmp(const char *__s1, const char *__s2)
{
  while (1)
    ;
}

char *__cdecl strcpy(char *__dst, const char *__src)
{
  while (1)
    ;
}

size_t strlcat(char *__dst, const char *__source, size_t __size)
{
  while (1)
    ;
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  while (1)
    ;
}

size_t strlen(const char *__s)
{
  while (1)
    ;
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  while (1)
    ;
}

char *__cdecl strncpy(char *__dst, const char *__src, size_t __n)
{
  while (1)
    ;
}

size_t strnlen(const char *__s1, size_t __n)
{
  while (1)
    ;
}

char *__cdecl strstr(const char *__big, const char *__little)
{
  while (1)
    ;
}

mode_t umask(mode_t a1)
{
  return _umask(a1);
}

int unlink(const char *a1)
{
  return _unlink(a1);
}

int utimes(const char *a1, const timeval *a2)
{
  return _utimes(a1, a2);
}

kern_return_t vm_allocate(vm_map_t target_task, vm_address_t *address, vm_size_t size, int flags)
{
  return _vm_allocate(target_task, address, size, flags);
}

kern_return_t vm_region_64(vm_map_t target_task, vm_address_t *address, vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name)
{
  return _vm_region_64(target_task, address, size, flavor, info, infoCnt, object_name);
}

pid_t wait4(pid_t a1, int *a2, int a3, rusage *a4)
{
  return _wait4(a1, a2, a3, a4);
}

uint64_t write_NOCANCEL()
{
  return _write_NOCANCEL();
}

uint64_t writev_NOCANCEL()
{
  return _writev_NOCANCEL();
}